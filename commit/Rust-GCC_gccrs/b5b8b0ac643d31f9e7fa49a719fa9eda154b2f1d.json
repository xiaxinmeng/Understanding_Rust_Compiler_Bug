{"sha": "b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjViOGIwYWM2NDNkMzFmOWU3ZmE0OWE3MTlmYTllZGExNTRiMmYxZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-09-02T02:42:21Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-09-02T02:42:21Z"}, "message": "invoke.texi (-fvar-tracking-assignments): New.\n\ngcc/ChangeLog:\n* doc/invoke.texi (-fvar-tracking-assignments): New.\n(-fvar-tracking-assignments-toggle): New.\n(-fdump-final-insns=file): Mark filename as optional.\n(--param min-nondebug-insn-uid): New.\n(-gdwarf-@{version}): Mention version 4.\n* opts.c (common_handle_option): Accept it.\n* tree-vrp.c (find_assert_locations_1): Skip debug stmts.\n* regrename.c (regrename_optimize): Drop last.  Don't count debug\ninsns as uses.  Don't reject change because of debug insn.\n(do_replace): Reject DEBUG_INSN as chain starter.  Take base_regno\nfrom the chain starter, and check for inexact matches in\nDEBUG_INSNS.\n(scan_rtx_reg): Accept inexact matches in DEBUG_INSNs.\n(build_def_use): Simplify and fix the marking of DEBUG_INSNs.\n* sched-ebb.c (schedule_ebbs): Skip boundary debug insns.\n* fwprop.c (forward_propagate_and_simplify): ...into debug insns.\n* doc/gimple.texi (is_gimple_debug): New.\n(gimple_debug_bind_p): New.\n(is_gimple_call, gimple_assign_cast_p): End sentence with period.\n* doc/install.texi (bootstrap-debug): More details.\n(bootstrap-debug-big, bootstrap-debug-lean): Document.\n(bootstrap-debug-lib): More details.\n(bootstrap-debug-ckovw): Update.\n(bootstrap-time): New.\n* tree-into-ssa.c (mark_def_sites): Skip debug stmts.\n(insert_phi_nodes_for): Insert debug stmts.\n(rewrite_stmt): Take iterator.  Insert debug stmts.\n(rewrite_enter_block): Adjust.\n(maybe_replace_use_in_debug_stmt): New.\n(rewrite_update_stmt): Use it.\n(mark_use_interesting): Return early for debug stmts.\n* tree-ssa-loop-im.c (rewrite_bittest): Propagate DEFs into debug\nstmts before replacing stmt.\n(move_computations_stmt): Likewise.\n* ira-conflicts.c (add_copies): Skip debug insns.\n* regstat.c (regstat_init_n_sets_and_refs): Discount debug insns.\n(regstat_bb_compute_ri): Skip debug insns.\n* tree-ssa-threadupdate.c (redirection_block_p): Skip debug stmts.\n* tree-ssa-loop-manip.c (find_uses_to_rename_stmt,\ncheck_loop_closed_ssa_stmt): Skip debug stmts.\n* tree-tailcall.c (find_tail_calls): Likewise.\n* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Likewise.\n* tree.h (MAY_HAVE_DEBUG_STMTS): New.\n(build_var_debug_value_stat): Declare.\n(build_var_debug_value): Define.\n(target_for_debug_bind): Declare.\n* reload.c (find_equiv_reg): Skip debug insns.\n* rtlanal.c (reg_used_between_p): Skip debug insns.\n(side_effects_p): Likewise.\n(canonicalize_condition): Likewise.\n* ddg.c (create_ddg_dep_from_intra_loop_link): Check that non-debug\ninsns never depend on debug insns.\n(create_ddg_dep_no_link): Likewise.\n(add_cross_iteration_register_deps): Use ANTI_DEP for debug insns.\nDon't add inter-loop dependencies for debug insns.\n(build_intra_loop_deps): Likewise.\n(create_ddg): Count debug insns.\n* ddg.h (struct ddg::num_debug): New.\n(num_backargs): Pair up with previous int field.\n* diagnostic.c (diagnostic_report_diagnostic): Skip notes on\n-fcompare-debug-second.\n* final.c (get_attr_length_1): Skip debug insns.\n(rest_of_clean-state): Don't dump CFA_RESTORE_STATE.\n* gcc.c (invoke_as): Call compare-debug-dump-opt.\n(driver_self_specs): Map -fdump-final-insns to\n-fdump-final-insns=..\n(get_local_tick): New.\n(compare_debug_dump_opt_spec_function): Test for . argument and\ncompute output name.  Compute temp output spec without flag name.\nCompute -frandom-seed.\n(OPT): Undef after use.\n* cfgloopanal.c (num_loop_insns): Skip debug insns.\n(average_num_loop_insns): Likewise.\n* params.h (MIN_NONDEBUG_INSN_UID): New.\n* gimple.def (GIMPLE_DEBUG): New.\n* ipa-reference.c (scan_stmt_for_static_refs): Skip debug stmts.\n* auto-inc-dec.c (merge_in_block): Skip debug insns.\n(merge_in_block): Fix whitespace.\n* toplev.c (flag_var_tracking): Update comment.\n(flag_var_tracking_assignments): New.\n(flag_var_tracking_assignments_toggle): New.\n(process_options): Don't open final insns dump file if we're not\ngoing to write to it.  Compute defaults for var_tracking.\n* df-scan.c (df_insn_rescan_debug_internal): New.\n(df_uses_record): Handle debug insns.\n* haifa-sched.c (ready): Initialize n_debug.\n(contributes_to_priority): Skip debug insns.\n(dep_list_size): New.\n(priority): Use it.\n(rank_for_schedule): Likewise.  Schedule debug insns as soon as\nthey're ready.  Disregard previous debug insns to make decisions.\n(queue_insn): Never queue debug insns.\n(ready_add, ready_remove_first, ready_remove): Count debug insns.\n(schedule_insn): Don't reject debug insns because of issue rate.\n(get_ebb_head_tail, no_real_insns_p): Skip boundary debug insns.\n(queue_to_ready): Skip and discount debug insns.\n(choose_ready): Let debug insns through.\n(schedule_block): Check boundary debug insns.  Discount debug\ninsns, schedule them early.  Adjust whitespace.\n(set_priorities): Check for boundary debug insns.\n(add_jump_dependencies): Use dep_list_size.\n(prev_non_location_insn): New.\n(check_cfg): Use it.\n* tree-ssa-loop-ivopts.c (find-interesting_users): Skip debug\nstmts.\n(remove_unused_ivs): Reset debug stmts.\n* modulo-sched.c (const_iteration_count): Skip debug insns.\n(res_MII): Discount debug insns.\n(loop_single_full_bb_p): Skip debug insns.\n(sms_schedule): Likewise.\n(sms_schedule_by_order): Likewise.\n(ps_has_conflicts): Likewise.\n* caller-save.c (refmarker_fn): New.\n(save_call_clobbered_regs): Replace regs with saved mem in\ndebug insns.\n(mark_referenced_regs): Take pointer, mark and arg.  Adjust.\nCall refmarker_fn mark for hardregnos.\n(mark_reg_as_referenced): New.\n(replace_reg_with_saved_mem): New.\n* ipa-pure-const.c (check_stmt): Skip debug stmts.\n* cse.c (cse_insn): Canonicalize debug insns.  Skip them when\nsearching back.\n(cse_extended_basic_block): Skip debug insns.\n(count_reg_usage): Likewise.\n(is_dead_reg): New, split out of...\n(set_live_p): ... here.\n(insn_live_p): Use it for debug insns.\n* tree-stdarg.c (check_all_va_list_escapes): Skip debug stmts.\n(execute_optimize_stdarg): Likewise.\n* tree-ssa-dom.c (propagate_rhs_into_lhs): Likewise.\n* tree-ssa-propagate.c (substitute_and_fold): Don't regard\nchanges in debug stmts as changes.\n* sel-sched.c (moving_insn_creates_bookkeeping_block_p): New.\n(moveup_expr): Don't move across debug insns.  Don't move\ndebug insn if it would create a bookkeeping block.\n(moveup_expr_cached): Don't use cache for debug insns that\nare heads of blocks.\n(compute_av_set_inside_bb): Skip debug insns.\n(sel_rank_for_schedule): Schedule debug insns first.  Remove\ndead code.\n(block_valid_for_bookkeeping_p); Support lax searches.\n(create_block_for_bookkeeping): Adjust block numbers when\nencountering debug-only blocks.\n(find_place_for_bookkeeping): Deal with debug-only blocks.\n(generate_bookkeeping_insn): Accept no place to insert.\n(remove_temp_moveop_nops): New argument full_tidying.\n(prepare_place_to_insert): Deal with debug insns.\n(advance_state_on_fence): Debug insns don't start cycles.\n(update_boundaries): Take fence as argument.  Deal with\ndebug insns.\n(schedule_expr_on_boundary): No full_tidying on debug insns.\n(fill_insns): Deal with debug insns.\n(track_scheduled_insns_and_blocks): Don't count debug insns.\n(need_nop_to_preserve_insn_bb): New, split out of...\n(remove_insn_from_stream): ... this.\n(fur_orig_expr_not_found): Skip debug insns.\n* rtl.def (VALUE): Move up.\n(DEBUG_INSN): New.\n* tree-ssa-sink.c (all_immediate_uses_same_place): Skip debug\nstmts.\n(nearest_common_dominator_of_uses): Take debug_stmts argument.\nSet it if debug stmts are found.\n(statement_sink_location): Skip debug stmts.  Propagate\nmoving defs into debug stmts.\n* ifcvt.c (first_active_insn): Skip debug insns.\n(last_active_insns): Likewise.\n(cond_exec_process_insns): Likewise.\n(noce_process_if_block): Likewise.\n(check_cond_move_block): Likewise.\n(cond_move_convert_if_block): Likewise.\n(block_jumps_and_fallthru_p): Likewise.\n(dead_or_predicable): Likewise.\n* dwarf2out.c (debug_str_hash_forced): New.\n(find_AT_string): Add comment.\n(gen_label_for_indirect_string): New.\n(get_debug_string_label): New.\n(AT_string_form): Use it.\n(mem_loc_descriptor): Handle non-TLS symbols.  Handle MINUS , DIV,\nMOD, AND, IOR, XOR, NOT, ABS, NEG, and CONST_STRING.  Accept but\ndiscard COMPARE, IF_THEN_ELSE, ROTATE, ROTATERT, TRUNCATE and\nseveral operations that cannot be represented with DWARF opcodes.\n(loc_descriptor): Ignore SIGN_EXTEND and ZERO_EXTEND.  Require\ndwarf_version 4 for DW_OP_implicit_value and DW_OP_stack_value.\n(dwarf2out_var_location): Take during-call mark into account.\n(output_indirect_string): Update comment.  Output if there are\nlabel and references.\n(prune_indirect_string): New.\n(prune_unused_types): Call it if debug_str_hash_forced.\nMore in dwarf2out.c, from Jakub Jelinek <jakub@redhat.com>:\n(dw_long_long_const): Remove.\n(struct dw_val_struct): Change val_long_long type to rtx.\n(print_die, attr_checksum, same_dw_val_p, loc_descriptor): Adjust for\nval_long_long change to CONST_DOUBLE rtx from a long hi/lo pair.\n(output_die): Likewise.  Use HOST_BITS_PER_WIDE_INT size of each\ncomponent instead of HOST_BITS_PER_LONG.\n(output_loc_operands): Likewise.   For const8* assert\nHOST_BITS_PER_WIDE_INT rather than HOST_BITS_PER_LONG is >= 64.\n(output_loc_operands_raw): For const8* assert HOST_BITS_PER_WIDE_INT\nrather than HOST_BITS_PER_LONG is >= 64.\n(add_AT_long_long): Remove val_hi and val_lo arguments, add\nval_const_double.\n(size_of_die): Use HOST_BITS_PER_WIDE_INT size multiplier instead of\nHOST_BITS_PER_LONG for dw_val_class_long_long.\n(add_const_value_attribute): Adjust add_AT_long_long caller.  Don't\nhandle TLS SYMBOL_REFs.  If CONST wraps a constant, tail recurse.\n(dwarf_stack_op_name): Handle DW_OP_implicit_value and\nDW_OP_stack_value.\n(size_of_loc_descr, output_loc_operands, output_loc_operands_raw):\nHandle DW_OP_implicit_value.\n(extract_int): Move prototype earlier.\n(mem_loc_descriptor): For SUBREG punt if inner\nmode size is wider than DWARF2_ADDR_SIZE.  Handle SIGN_EXTEND\nand ZERO_EXTEND by DW_OP_shl and DW_OP_shr{a,}.  Handle\nEQ, NE, GT, GE, LT, LE, GTU, GEU, LTU, LEU, SMIN, SMAX, UMIN,\nUMAX, SIGN_EXTRACT, ZERO_EXTRACT.\n(loc_descriptor): Compare mode size with DWARF2_ADDR_SIZE\ninstead of Pmode size.\n(loc_descriptor): Add MODE argument.  Handle CONST_INT, CONST_DOUBLE,\nCONST_VECTOR, CONST, LABEL_REF and SYMBOL_REF if mode != VOIDmode,\nattempt to handle other expressions.  Don't handle TLS SYMBOL_REFs.\n(concat_loc_descriptor, concatn_loc_descriptor,\nloc_descriptor_from_tree_1): Adjust loc_descriptor callers.\n(add_location_or_const_value_attribute): Likewise.  For single\nlocation loc_lists attempt to use add_const_value_attribute\nfor constant decls.  Add DW_AT_const_value even if\nNOTE_VAR_LOCATION is VAR_LOCATION with CONSTANT_P or CONST_STRING\nin its expression.\n* cfgbuild.c (inside_basic_block_p): Handle debug insns.\n(control_flow_insn_p): Likewise.\n* tree-parloops.c (eliminate_local_variables_stmt): Handle debug\nstmt.\n(separate_decls_in_region_debug_bind): New.\n(separate_decls_in_region): Process debug bind stmts afterwards.\n* recog.c (verify_changes): Handle debug insns.\n(extract_insn): Likewise.\n(peephole2_optimize): Skip debug insns.\n* dse.c (scan_insn): Skip debug insns.\n* sel-sched-ir.c (return_nop_to_pool): Take full_tidying argument.\nPass it on.\n(setup_id_for_insn): Handle debug insns.\n(maybe_tidy_empty_bb): Adjust whitespace.\n(tidy_control_flow): Skip debug insns.\n(sel_remove_insn): Adjust for debug insns.\n(sel_estimate_number_of_insns): Skip debug insns.\n(create_insn_rtx_from_pattern): Handle debug insns.\n(create_copy_of_insn_rtx): Likewise.\n* sel-sched-.h (sel_bb_end): Declare.\n(sel_bb_empty_or_nop_p): New.\n(get_all_loop_exits): Use it.\n(_eligible_successor_edge_p): Likewise.\n(return_nop_to_pool): Adjust.\n* tree-eh.c (tre_empty_eh_handler_p): Skip debug stmts.\n* ira-lives.c (process_bb_node_lives): Skip debug insns.\n* gimple-pretty-print.c (dump_gimple_debug): New.\n(dump_gimple_stmt): Use it.\n(dump_bb_header): Skip gimple debug stmts.\n* regmove.c (optimize_reg_copy_1): Discount debug insns.\n(fixup_match_2): Likewise.\n(regmove_backward_pass): Likewise.  Simplify combined\nreplacement.  Handle debug insns.\n* function.c (instantiate_virtual_regs): Handle debug insns.\n* function.h (struct emit_status): Add x_cur_debug_insn_uid.\n* print-rtl.h: Include cselib.h.\n(print_rtx): Print VALUEs.  Split out and recurse for\nVAR_LOCATIONs.\n* df.h (df_inns_rescan_debug_internal): Declare.\n* gcse.c (alloc_hash_table): Estimate n_insns.\n(cprop_insn): Don't regard debug insns as changes.\n(bypass_conditional_jumps): Skip debug insns.\n(one_pre_gcse_pass): Adjust.\n(one_code_hoisting_pass): Likewise.\n(compute_ld_motion_mems): Skip debug insns.\n(one_cprop_pass): Adjust.\n* tree-if-conv.c (tree_if_convert_stmt): Reset debug stmts.\n(if_convertible_stmt_p): Handle debug stmts.\n* init-regs.c (initialize_uninitialized_regs): Skip debug insns.\n* tree-vect-loop.c (vect_is_simple_reduction): Skip debug stmts.\n* ira-build.c (create_bb_allocnos): Skip debug insns.\n* tree-flow-inline.h (has_zero_uses): Discount debug stmts.\n(has_single_use): Likewise.\n(single_imm_use): Likewise.\n(num_imm_uses): Likewise.\n* tree-ssa-phiopt.c (empty_block_p): Skip debug stmts.\n* tree-ssa-coalesce.c (build_ssa_conflict_graph): Skip debug stmts.\n(create_outofssa_var_map): Likewise.\n* lower-subreg.c (adjust_decomposed_uses): New.\n(resolve_debug): New.\n(decompose_multiword_subregs): Use it.\n* tree-dfa.c (find_referenced_vars): Skip debug stmts.\n* emit-rtl.c: Include params.h.\n(cur_debug_insn_uid): Define.\n(set_new_first_and_last_insn): Set cur_debug_insn_uid too.\n(copy_rtx_if_shared_1): Handle debug insns.\n(reset_used_flags): Likewise.\n(set_used_flags): LIkewise.\n(get_max_insn_count): New.\n(next_nondebug_insn): New.\n(prev_nondebug_insn): New.\n(make_debug_insn_raw): New.\n(emit_insn_before_noloc): Handle debug insns.\n(emit_jump_insn_before_noloc): Likewise.\n(emit_call_insn_before_noloc): Likewise.\n(emit_debug_insn_before_noloc): New.\n(emit_insn_after_noloc): Handle debug insns.\n(emit_jump_insn_after_noloc): Likewise.\n(emit_call_insn_after_noloc): Likewise.\n(emit_debug_insn_after_noloc): Likewise.\n(emit_insn_after): Take loc from earlier non-debug insn.\n(emit_jump_insn_after): Likewise.\n(emit_call_insn_after): Likewise.\n(emit_debug_insn_after_setloc): New.\n(emit_debug_insn_after): New.\n(emit_insn_before): Take loc from later non-debug insn.\n(emit_jump_insn_before): Likewise.\n(emit_call_insn_before): Likewise.\n(emit_debug_insn_before_setloc): New.\n(emit_debug_insn_before): New.\n(emit_insn): Handle debug insns.\n(emit_debug_insn): New.\n(emit_jump_insn): Handle debug insns.\n(emit_call_insn): Likewise.\n(emit): Likewise.\n(init_emit): Take min-nondebug-insn-uid into account.\nInitialize cur_debug_insn_uid.\n(emit_copy_of_insn_after): Handle debug insns.\n* cfgexpand.c (gimple_assign_rhs_to_tree): Do not overwrite\nlocation of single rhs in place.\n(maybe_dump_rtl_for_gimple_stmt): Dump lineno.\n(floor_sdiv_adjust): New.\n(cell_sdiv_adjust): New.\n(cell_udiv_adjust): New.\n(round_sdiv_adjust): New.\n(round_udiv_adjust): New.\n(wrap_constant): Moved from cselib.\n(unwrap_constant): New.\n(expand_debug_expr): New.\n(expand_debug_locations): New.\n(expand_gimple_basic_block): Drop hiding redeclaration.  Expand\ndebug bind stmts.\n(gimple_expand_cfg): Expand debug locations.\n* cselib.c: Include tree-pass.h.\n(struct expand_value_data): New.\n(cselib_record_sets_hook): New.\n(PRESERVED_VALUE_P, LONG_TERM_PRESERVED_VALUE_P): New.\n(cselib_clear_table): Move, and implemnet in terms of...\n(cselib_reset_table_with_next_value): ... this.\n(cselib_get_next_unknown_value): New.\n(discard_useless_locs): Don't discard preserved values.\n(cselib_preserve_value): New.\n(cselib_preserved_value_p): New.\n(cselib_preserve_definitely): New.\n(cselib_clear_preserve): New.\n(cselib_preserve_only_values): New.\n(new_cselib_val): Take rtx argument.  Dump it in details.\n(cselib_lookup_mem): Adjust.\n(expand_loc): Take regs_active in struct.  Adjust.  Silence\ndumps unless details are requested.\n(cselib_expand_value_rtx_cb): New.\n(cselib_expand_value_rtx): Rename and reimplment in terms of...\n(cselib_expand_value_rtx_1): ... this.  Adjust.  Silence dumps\nwithout details.  Copy more subregs.  Try to resolve values\nusing a callback.  Wrap constants.\n(cselib_subst_to_values): Adjust.\n(cselib_log_lookup): New.\n(cselib_lookup): Call it.\n(cselib_invalidate_regno): Don't count preserved values as\nuseless.\n(cselib_invalidate_mem): Likewise.\n(cselib_record_set): Likewise.\n(struct set): Renamed to cselib_set, moved to cselib.h.\n(cselib_record_sets): Adjust.  Call hook.\n(cselib_process_insn): Reset table when it would be cleared.\n(dump_cselib_val): New.\n(dump_cselib_table): New.\n* tree-cfgcleanup.c (tree_forwarded_block_p): Skip debug stmts.\n(remove_forwarder_block): Support moving debug stmts.\n* cselib.h (cselib_record_sets_hook): Declare.\n(cselib_expand_callback): New type.\n(cselib_expand_value_rtx_cb): Declare.\n(cselib_reset_table_with_next_value): Declare.\n(cselib_get_next_unknown_value): Declare.\n(cselib_preserve_value): Declare.\n(cselib_preserved_value_p): Declare.\n(cselib_preserve_only_values): Declare.\n(dump_cselib_table): Declare.\n* cfgcleanup.c (flow_find_cross_jump): Skip debug insns.\n(try_crossjump_to_edge): Likewise.\n(delete_unreachable_blocks): Remove dominant GIMPLE blocks after\ndominated blocks when debug stmts are present.\n* simplify-rtx.c (delegitimize_mem_from_attrs): New.\n* tree-ssa-live.c (remove_unused_locals): Skip debug stmts.\n(set_var_live_on_entry): Likewise.\n* loop-invariant.c (find_invariants_bb): Skip debug insns.\n* cfglayout.c (curr_location, last_location): Make static.\n(set_curr_insn_source_location): Don't avoid bouncing.\n(get_curr_insn_source_location): New.\n(get_curr_insn_block): New.\n(duplicate_insn_chain): Handle debug insns.\n* tree-ssa-forwprop.c (forward_propagate_addr_expr): Propagate\ninto debug stmts.\n* common.opt (fcompare-debug): Move to sort order.\n(fdump-unnumbered-links): Likewise.\n(fvar-tracking-assignments): New.\n(fvar-tracking-assignments-toggle): New.\n* tree-ssa-dce.c (mark_stmt_necessary): Don't mark blocks\nbecause of debug stmts.\n(mark_stmt_if_obviously_necessary): Mark debug stmts.\n(eliminate_unnecessary_stmts): Walk dominated blocks before\ndominators.\n* tree-ssa-ter.c (find_replaceable_in_bb): Skip debug stmts.\n* ira.c (memref_used_between_p): Skip debug insns.\n(update_equiv_regs): Likewise.\n* sched-deps.c (sd_lists_size): Accept empty list.\n(sd_init_insn): Mark debug insns.\n(sd_finish_insn): Unmark them.\n(sd_add_dep): Reject non-debug deps on debug insns.\n(fixup_sched_groups): Give debug insns group treatment.\nSkip debug insns.\n(sched_analyze_reg): Don't mark debug insns for sched before call.\n(sched_analyze_2): Handle debug insns.\n(sched_analyze_insn): Compute next non-debug insn.  Handle debug\ninsns.\n(deps_analyze_insn): Handle debug insns.\n(deps_start_bb): Skip debug insns.\n(init_deps): Initialize last_debug_insn.\n* tree-ssa.c (target_for_debug_bind): New.\n(find_released_ssa_name): New.\n(propagate_var_def_into_debug_stmts): New.\n(propagate_defs_into_debug_stmts): New.\n(verify_ssa): Skip debug bind stmts without values.\n(warn_uninialized_vars): Skip debug stmts.\n* target-def.h (TARGET_DELEGITIMIZE_ADDRESS): Set default.\n* rtl.c (rtx_equal_p_cb): Handle VALUEs.\n(rtx_equal_p): Likewise.\n* ira-costs.c (scan_one_insn): Skip debug insns.\n(process_bb_node_for_hard_reg_moves): Likewise.\n* rtl.h (DEBUG_INSN_P): New.\n(NONDEBUG_INSN_P): New.\n(MAY_HAVE_DEBUG_INSNS): New.\n(INSN_P): Accept debug insns.\n(RTX_FRAME_RELATED_P): Likewise.\n(INSN_DELETED_P): Likewise\n(PAT_VAR_LOCATION_DECL): New.\n(PAT_VAR_LOCATION_LOC): New.\n(PAT_VAR_OCATION_STATUS): New.\n(NOTE_VAR_LOCATION_DECL): Reimplement.\n(NOTE_VAR_LOCATION_LOC): Likewise.\n(NOTE_VAR_LOCATION_STATUS): Likewise.\n(INSN_VAR_LOCATION): New.\n(INSN_VAR_LOCATION_DECL): New.\n(INSN_VAR_LOCATION_LOC): New.\n(INSN_VAR_LOCATION_STATUS): New.\n(gen_rtx_UNKNOWN_VAR_LOC): New.\n(VAR_LOC_UNKNOWN_P): New.\n(NOTE_DURING_CALL_P): New.\n(SCHED_GROUP_P): Accept debug insns.\n(emit_debug_insn_before): Declare.\n(emit_debug_insn_before_noloc): Declare.\n(emit_debug_insn_beore_setloc): Declare.\n(emit_debug_insn_after): Declare.\n(emit_debug_insn_after_noloc): Declare.\n(emit_debug_insn_after_setloc): Declare.\n(emit_debug_insn): Declare.\n(make_debug_insn_raw): Declare.\n(prev_nondebug_insn): Declare.\n(next_nondebug_insn): Declare.\n(delegitimize_mem_from_attrs): Declare.\n(get_max_insn_count): Declare.\n(wrap_constant): Declare.\n(unwrap_constant): Declare.\n(get_curr_insn_source_location): Declare.\n(get_curr_insn_block): Declare.\n* tree-inline.c (insert_debug_decl_map): New.\n(processing_debug_stmt): New.\n(remap_decl): Don't create new mappings in debug stmts.\n(remap_gimple_op_r): Don't add references in debug stmts.\n(copy_tree_body_r): Likewise.\n(remap_gimple_stmt): Handle debug bind stmts.\n(copy_bb): Skip debug stmts.\n(copy_edges_for_bb): Likewise.\n(copy_debug_stmt): New.\n(copy_debug_stmts): New.\n(copy_body): Copy debug stmts at the end.\n(insert_init_debug_bind): New.\n(insert_init_stmt): Take id.  Skip and emit debug stmts.\n(setup_one_parameter): Remap variable earlier, register debug\nmapping.\n(estimate_num_insns): Skip debug stmts.\n(expand_call_inline): Preserve debug_map.\n(optimize_inline_calls): Check for no debug_stmts left-overs.\n(unsave_expr_now): Preserve debug_map.\n(copy_gimple_seq_and_replace_locals): Likewise.\n(tree_function_versioning): Check for no debug_stmts left-overs.\nInit and destroy debug_map as needed.  Split edges unconditionally.\n(build_duplicate_type): Init and destroy debug_map as needed.\n* tree-inline.h: Include gimple.h instead of pointer-set.h.\n(struct copy_body_data): Add debug_stmts and debug_map.\n* sched-int.h (struct ready_list): Add n_debug.\n(struct deps): Add last_debug_insn.\n(DEBUG_INSN_SCHED_P): New.\n(BOUNDARY_DEBUG_INSN_P): New.\n(SCHEDULE_DEBUG_INSN_P): New.\n(sd_iterator_cond): Accept empty list.\n* combine.c (create_log_links): Skip debug insns.\n(combine_instructions): Likewise.\n(cleanup_auto_inc_dec): New.  From Jakub Jelinek: Make sure the\nreturn value is always unshared.\n(struct rtx_subst_pair): New.\n(auto_adjust_pair): New.\n(propagate_for_debug_subst): New.\n(propagate_for_debug): New.\n(try_combine): Skip debug insns.  Propagate removed defs into\ndebug insns.\n(next_nonnote_nondebug_insn): New.\n(distribute_notes): Use it.  Skip debug insns.\n(distribute_links): Skip debug insns.\n* tree-outof-ssa.c (set_location_for_edge): Likewise.\n* resource.c (mark_target_live_regs): Likewise.\n* var-tracking.c: Include cselib.h and target.h.\n(enum micro_operation_type): Add MO_VAL_USE, MO_VAL_LOC, and\nMO_VAL_SET.\n(micro_operation_type_name): New.\n(enum emit_note_where): Add EMIT_NOTE_AFTER_CALL_INSN.\n(struct micro_operation_def): Update comments.\n(decl_or_value): New type.  Use instead of decls.\n(struct emit_note_data_def): Add vars.\n(struct attrs_def): Use decl_or_value.\n(struct variable_tracking_info_def): Add permp, flooded.\n(struct location_chain_def): Update comment.\n(struct variable_part_def): Use decl_or_value.\n(struct variable_def): Make var_part a variable length array.\n(valvar_pool): New.\n(scratch_regs): New.\n(cselib_hook_called): New.\n(dv_is_decl_p): New.\n(dv_is_value_p): New.\n(dv_as_decl): New.\n(dv_as_value): New.\n(dv_as_opaque): New.\n(dv_onepart_p): New.\n(dv_pool): New.\n(IS_DECL_CODE): New.\n(check_value_is_not_decl): New.\n(dv_from_decl): New.\n(dv_from_value): New.\n(dv_htab_hash): New.\n(variable_htab_hash): Use it.\n(variable_htab_eq): Support values.\n(variable_htab_free): Free from the right pool.\n(attrs_list_member, attrs_list_insert): Use decl_or_value.\n(attrs_list_union): Adjust.\n(attrs_list_mpdv_union): New.\n(tie_break_pointers): New.\n(canon_value_cmp): New.\n(unshare_variable): Return possibly-modified slot.\n(vars_copy_1): Adjust.\n(var_reg_decl_set): Adjust.  Split out of...\n(var_reg_set): ... this.\n(get_init_value): Adjust.\n(var_reg_delete_and_set): Adjust.\n(var_reg_delete): Adjust.\n(var_regno_delete): Adjust.\n(var_mem_decl_set): Split out of...\n(var_mem_set): ... this.\n(var_mem_delete_and_set): Adjust.\n(var_mem_delete): Adjust.\n(val_store): New.\n(val_reset): New.\n(val_resolve): New.\n(variable_union): Adjust.  Speed up merge of 1-part vars.\n(variable_canonicalize): Use unshared slot.\n(VALUED_RECURSED_INTO): New.\n(find_loc_in_1pdv): New.\n(struct dfset_merge): New.\n(insert_into_intersection): New.\n(intersect_loc_chains): New.\n(loc_cmp): New.\n(canonicalize_loc_order_check): New.\n(canonicalize_values_mark): New.\n(canonicalize_values_star): New.\n(variable_merge_over_cur): New.\n(variable_merge_over_src): New.\n(dataflow_set_merge): New.\n(dataflow_set_equiv_regs): New.\n(remove_duplicate_values): New.\n(struct dfset_post_merge): New.\n(variable_post_merge_new_vals): New.\n(variable_post_merge_perm_vals): New.\n(dataflow_post_merge_adjust): New.\n(find_mem_expr_in_1pdv): New.\n(dataflow_set_preserve_mem_locs): New.\n(dataflow_set_remove_mem_locs): New.\n(dataflow_set_clear_at_call): New.\n(onepart_variable_different_p): New.\n(variable_different_p): Use it.\n(dataflow_set_different_1): Adjust.  Make detailed dump\nmore verbose.\n(track_expr_p): Add need_rtl parameter.  Don't generate rtl\nif not needed.\n(track_loc_p): Pass it true.\n(struct count_use_info): New.\n(find_use_val): New.\n(replace_expr_with_values): New.\n(log_op_type): New.\n(use_type): New, partially split out of...\n(count_uses): ... this.  Count new micro-ops.\n(count_uses_1): Adjust.\n(count_stores): Adjust.\n(count_with_sets): New.\n(VAL_NEEDS_RESOLUTION): New.\n(VAL_HOLDS_TRACK_EXPR): New.\n(VAL_EXPR_IS_COPIED): New.\n(VAL_EXPR_IS_CLOBBERED): New.\n(add_uses): Adjust.  Generate new micro-ops.\n(add_uses_1): Adjust.\n(add_stores): Generate new micro-ops.\n(add_with_sets): New.\n(find_src_status): Adjust.\n(find_src_set_src): Adjust.\n(compute_bb_dataflow): Use dataflow_set_clear_at_call.\nHandle new micro-ops.  Canonicalize value equivalances.\n(vt_find_locations): Compute total size of hash tables for\ndumping.  Perform merge for var-tracking-assignments.  Don't\ndisregard single-block loops.\n(dump_attrs_list): Handle decl_or_value.\n(dump_variable): Take variable.  Deal with decl_or_value.\n(dump_variable_slot): New.\n(dump_vars): Use it.\n(dump_dataflow_sets): Adjust.\n(set_slot_part): New, extended to support one-part variables\nafter splitting out of...\n(set_variable_part): ... this.\n(clobber_slot_part): New, split out of...\n(clobber_variable_part): ... this.\n(delete_slot_part): New, split out of...\n(delete_variable_part): .... this.\n(check_wrap_constant): New.\n(vt_expand_loc_callback): New.\n(vt_expand_loc): New.\n(emit_note_insn_var_location): Adjust.  Handle values.  Handle\nEMIT_NOTE_AFTER_CALL_INSN.\n(emit_notes_for_differences_1): Adjust.  Handle values.\n(emit_notes_for_differences_2): Likewise.\n(emit_notes_for_differences): Adjust.\n(emit_notes_in_bb): Take pointer to set.  Emit AFTER_CALL_INSN\nnotes.  Adjust.  Handle new micro-ops.\n(vt_add_function_parameters): Adjust.  Create and bind values.\n(vt_initialize): Adjust.  Initialize scratch_regs and\nvalvar_pool, flooded and perm..  Initialize and use cselib.  Log\noperations.  Move some code to count_with_sets and add_with_sets.\n(delete_debug_insns): New.\n(vt_debug_insns_local): New.\n(vt_finalize): Release permp, valvar_pool, scratch_regs.  Finish\ncselib.\n(var_tracking_main): If var-tracking-assignments is enabled\nbut var-tracking isn't, delete debug insns and leave.  Likewise\nif we exceed limits or fail the stack adjustments tests, and\nafter all var-tracking processing.\nMore in var-tracking, from Jakub Jelinek <jakub@redhat.com>:\n(dataflow_set): Add traversed_vars.\n(value_chain, const_value_chain): New typedefs.\n(value_chain_pool, value_chains): New variables.\n(value_chain_htab_hash, value_chain_htab_eq, add_value_chain,\nadd_value_chains, add_cselib_value_chains, remove_value_chain,\nremove_value_chains, remove_cselib_value_chains): New functions.\n(shared_hash_find_slot_unshare_1, shared_hash_find_slot_1,\nshared_hash_find_slot_noinsert_1, shared_hash_find_1): New\nstatic inlines.\n(shared_hash_find_slot_unshare, shared_hash_find_slot,\nshared_hash_find_slot_noinsert, shared_hash_find): Update.\n(dst_can_be_shared): New variable.\n(unshare_variable): Unshare set->vars if shared, use shared_hash_*.\nClear dst_can_be_shared.  If set->traversed_vars is non-NULL and\ndifferent from set->vars, look up slot again instead of using the\npassed in slot.\n(dataflow_set_init): Initialize traversed_vars.\n(variable_union): Use shared_hash_*.  Use initially NO_INSERT\nlookup if set->vars is shared.  Don't keep slot cleared before\ncalling unshare_variable.  Unshare set->vars if needed.  Adjust\nunshare_variable callers.  Clear dst_can_be_shared if needed.\nEven ->refcount == 1 vars must be unshared if set->vars is shared\nand var needs to be modified.\n(dataflow_set_union): Set traversed_vars during canonicalization.\n(VALUE_CHANGED, DECL_CHANGED): Define.\n(set_dv_changed, dv_changed_p): New static inlines.\n(track_expr_p): Clear DECL_CHANGED.\n(dump_dataflow_sets): Set it.\n(variable_was_changed): Call set_dv_changed.\n(emit_note_insn_var_location): Likewise.\n(changed_variables_stack): New variable.\n(check_changed_vars_1, check_changed_vars_2): New functions.\n(emit_notes_for_changes): Do nothing if changed_variables is\nempty.  Traverse changed_variables with check_changed_vars_1,\ncall check_changed_vars_2 on each changed_variables_stack entry.\n(emit_notes_in_bb): Add SET argument.  Just clear it at the\nbeginning, use it instead of local &set, don't destroy it at the\nend.\n(vt_emit_notes): Call dataflow_set_clear early on all\nVTI(bb)->out sets, never use them, instead use emit_notes_in_bb\ncomputed set, dataflow_set_clear also VTI(bb)->in when we are\ndone with the basic block.  Initialize changed_variables_stack,\nfree it afterwards.  If ENABLE_CHECKING verify that after noting\ndifferences to an empty set value_chains hash table is empty.\n(vt_initialize): Initialize value_chains and value_chain_pool.\n(vt_finalize): Delete value_chains htab, free value_chain_pool.\n(variable_tracking_main): Call dump_dataflow_sets before calling\nvt_emit_notes, not after it.\n* tree-flow.h (propagate_defs_into_debug_stmts): Declare.\n(propagate_var_def_into_debug_stmts): Declare.\n* df-problems.c (df_lr_bb_local_compute): Skip debug insns.\n(df_set_note): Reject debug insns.\n(df_whole_mw_reg_dead_p): Take added_notes_p argument.  Don't\nadd notes to debug insns.\n(df_note_bb_compute): Adjust.  Likewise.\n(df_simulate_uses): Skip debug insns.\n(df_simulate_initialize_backwards): Likewise.\n* reg-stack.c (subst_stack_regs_in_debug_insn): New.\n(subst_stack_regs_pat): Reject debug insns.\n(convert_regs_1): Handle debug insns.\n* Makefile.in (TREE_INLINE_H): Take pointer-set.h from GIMPLE_H.\n(print-rtl.o): Depend on cselib.h.\n(cselib.o): Depend on TREE_PASS_H.\n(var-tracking.o): Depend on cselib.h and TARGET_H.\n* sched-rgn.c (rgn_estimate_number_of_insns): Discount\ndebug insns.\n(init_ready_list): Skip boundary debug insns.\n(add_branch_dependences): Skip debug insns.\n(free_block_dependencies): Check for blocks with only debug\ninsns.\n(compute_priorities): Likewise.\n* gimple.c (gss_for_code): Handle GIMPLE_DEBUG.\n(gimple_build_with_ops_stat): Take subcode as unsigned.  Adjust\nall callers.\n(gimple_build_debug_bind_stat): New.\n(empty_body_p): Skip debug stmts.\n(gimple_has_side_effects): Likewise.\n(gimple_rhs_has_side_effects): Likewise.\n* gimple.h (enum gimple_debug_subcode, GIMPLE_DEBUG_BIND): New.\n(gimple_build_debug_bind_stat): Declare.\n(gimple_build_debug_bind): Define.\n(is_gimple_debug): New.\n(gimple_debug_bind_p): New.\n(gimple_debug_bind_get_var): New.\n(gimple_debug_bind_get_value): New.\n(gimple_debug_bind_get_value_ptr): New.\n(gimple_debug_bind_set_var): New.\n(gimple_debug_bind_set_value): New.\n(GIMPLE_DEBUG_BIND_NOVALUE): New internal temporary macro.\n(gimple_debug_bind_reset_value): New.\n(gimple_debug_bind_has_value_p): New.\n(gsi_next_nondebug): New.\n(gsi_prev_nondebug): New.\n(gsi_start_nondebug_bb): New.\n(gsi_last_nondebug_bb): New.\n* sched-vis.c (print_pattern): Handle VAR_LOCATION.\n(print_insn): Handle DEBUG_INSN.\n* tree-cfg.c (remove_bb): Walk stmts backwards.  Let loc\nof first insn prevail.\n(first_stmt): Skip debug stmts.\n(first_non_label_stmt): Likewise.\n(last_stmt): Likewise.\n(has_zero_uses_1): New.\n(single_imm_use_1): New.\n(verify_gimple_debug): New.\n(verify_types_in_gimple_stmt): Handle debug stmts.\n(verify_stmt): Likewise.\n(debug_loop_num): Skip debug stmts.\n(remove_edge_and_dominated_blocks): Remove dominators last.\n* tree-ssa-reasssoc.c (rewrite_expr_tree): Propagate into\ndebug stmts.\n(linearize_expr): Likewise.\n* config/i386/i386.c (ix86_delegitimize_address): Call\ndefault implementation.\n* config/ia64/ia64.c (ia64_safe_itanium_class): Handle debug\ninsns.\n(group_barrier_needed): Skip debug insns.\n(emit_insn_group_barriers): Likewise.\n(emit_all_insn_group_barriers): Likewise.\n(ia64_variable_issue): Handle debug insns.\n(ia64_dfa_new_cycle): Likewise.\n(final_emit_insn_group_barriers): Skip debug insns.\n(ia64_dwarf2out_def_steady_cfa): Take frame argument.  Don't\ndef cfa without frame.\n(process_set): Likewise.\n(process_for_unwind_directive): Pass frame on.\n* config/rs6000/rs6000.c (TARGET_DELEGITIMIZE_ADDRESS): Define.\n(rs6000_delegitimize_address): New.\n(rs6000_debug_adjust_cost): Handle debug insns.\n(is_microcoded_insn): Likewise.\n(is_cracked_insn): Likewise.\n(is_nonpipeline_insn): Likewise.\n(insn_must_be_first_in_group): Likewise.\n(insn_must_be_last_in_group): Likewise.\n(force_new_group): Likewise.\n* cfgrtl.c (rtl_split_block): Emit INSN_DELETED note if block\ncontains only debug insns.\n(rtl_merge_blocks): Skip debug insns.\n(purge_dead_edges): Likewise.\n(rtl_block_ends_with_call_p): Skip debug insns.\n* dce.c (deletable_insn_p): Handle VAR_LOCATION.\n(mark_reg_dependencies): Skip debug insns.\n* params.def (PARAM_MIN_NONDEBUG_INSN_UID): New.\n* tree-ssanames.c (release_ssa_name): Propagate def into\ndebug stmts.\n* tree-ssa-threadedge.c\n(record_temporary_equivalences_from_stmts): Skip debug stmts.\n* regcprop.c (replace_oldest_value_addr): Skip debug insns.\n(replace_oldest_value_mem): Use ALL_REGS for debug insns.\n(copyprop_hardreg_forward_1): Handle debug insns.\n* reload1.c (reload): Skip debug insns.  Replace unassigned\npseudos in debug insns with their equivalences.\n(eliminate_regs_in_insn): Skip debug insns.\n(emit_input_reload_insns): Skip debug insns at first, adjust\nthem later.\n* tree-ssa-operands.c (add_virtual_operand): Reject debug stmts.\n(get_indirect_ref_operands): Pass opf_no_vops on.\n(get_expr_operands): Likewise.  Skip debug stmts.\n(parse_ssa_operands): Scan debug insns with opf_no_vops.\ngcc/testsuite/ChangeLog:\n* gcc.dg/guality/guality.c: New.\n* gcc.dg/guality/guality.h: New.\n* gcc.dg/guality/guality.exp: New.\n* gcc.dg/guality/example.c: New.\n* lib/gcc-dg.exp (cleanup-dump): Remove .gk files.\n(cleanup-saved-temps): Likewise, .gkd files too.\ngcc/cp/ChangeLog:\n* cp-tree.h (TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS): New.\n* cp-lang.c (cxx_dwarf_name): Pass it.\n* error.c (count_non_default_template_args): Take flags as\nargument.  Adjust all callers.  Skip counting of default\narguments if the new flag is given.\nChangeLog:\n* Makefile.tpl (BUILD_CONFIG): Default to bootstrap-debug.\n* Makefile.in: Rebuilt.\ncontrib/ChangeLog:\n* compare-debug: Look for .gkd files and compare them.\nconfig/ChangeLog:\n* bootstrap-debug.mk: Add comments.\n* bootstrap-debug-big.mk: New.\n* bootstrap-debug-lean.mk: New.\n* bootstrap-debug-ckovw.mk: Add comments.\n* bootstrap-debug-lib.mk: Drop CFLAGS for stages.  Use -g0\nfor TFLAGS in stage1.  Drop -fvar-tracking-assignments-toggle.\n\nFrom-SVN: r151312", "tree": {"sha": "dee43173429d96027577fbb1e51160bec6fa91a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dee43173429d96027577fbb1e51160bec6fa91a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/comments", "author": null, "committer": null, "parents": [{"sha": "8fc68cba0989f9b8cf382858ef89b0aa1785cfa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fc68cba0989f9b8cf382858ef89b0aa1785cfa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fc68cba0989f9b8cf382858ef89b0aa1785cfa9"}], "stats": {"total": 12793, "additions": 11345, "deletions": 1448}, "files": [{"sha": "b46c5e94d640aaff996f0531809ecdc4c4cbd0ca", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -771,7 +771,7 @@ EXTRA_GCC_FLAGS = \\\n GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(EXTRA_GCC_FLAGS)\n \n @if gcc\n-BUILD_CONFIG =\n+BUILD_CONFIG = bootstrap-debug\n ifneq ($(BUILD_CONFIG),)\n include $(foreach CONFIG, $(BUILD_CONFIG), $(srcdir)/config/$(CONFIG).mk)\n endif"}, {"sha": "b4e02d5582195d97da230ba0a8211f7919618458", "filename": "Makefile.tpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -619,7 +619,7 @@ EXTRA_GCC_FLAGS = \\\n GCC_FLAGS_TO_PASS = $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(EXTRA_GCC_FLAGS)\n \n @if gcc\n-BUILD_CONFIG =\n+BUILD_CONFIG = bootstrap-debug\n ifneq ($(BUILD_CONFIG),)\n include $(foreach CONFIG, $(BUILD_CONFIG), $(srcdir)/config/$(CONFIG).mk)\n endif"}, {"sha": "e657735e3b33d8b4ff5cf8085d11319bf0814f95", "filename": "config/bootstrap-debug-big.mk", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-big.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-big.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-debug-big.mk?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,8 @@\n+# This BUILD_CONFIG option is a bit like bootstrap-debug-lean, but it\n+# trades space for speed: instead of recompiling programs during\n+# stage3, it generates dumps during stage2 and stage3, saving them all\n+# until the final compare.\n+\n+STAGE2_CFLAGS += -gtoggle -fdump-final-insns\n+STAGE3_CFLAGS += -fdump-final-insns\n+do-compare = $(SHELL) $(srcdir)/contrib/compare-debug $$f1 $$f2"}, {"sha": "909b9047fc21dcd78321d72ed3a78874059355dc", "filename": "config/bootstrap-debug-ckovw.mk", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-ckovw.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-ckovw.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-debug-ckovw.mk?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,16 @@\n+# This BUILD_CONFIG option is to be used along with\n+# bootstrap-debug-lean and bootstrap-debug-lib in a full bootstrap, to\n+# check that all host and target files are built with -fcompare-debug.\n+\n+# These arrange for a simple warning to be issued if -fcompare-debug\n+# is not given.\n+# BOOT_CFLAGS += -fcompare-debug=\"-w%n-fcompare-debug not overridden\"\n+# TFLAGS += -fcompare-debug=\"-w%n-fcompare-debug not overridden\"\n+\n+# GCC_COMPARE_DEBUG=\"-w%n-fcompare-debug not overridden\";\n+\n+FORCE_COMPARE_DEBUG = \\\n+\tGCC_COMPARE_DEBUG=$${GCC_COMPARE_DEBUG--fcompare-debug-not-overridden}; \\\n+\texport GCC_COMPARE_DEBUG;\n+POSTSTAGE1_HOST_EXPORTS += $(FORCE_COMPARE_DEBUG)\n+BASE_TARGET_EXPORTS += $(FORCE_COMPARE_DEBUG)"}, {"sha": "5666d3f2119daf1267e236e9f4cfde8b8de1cfa8", "filename": "config/bootstrap-debug-lean.mk", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-lean.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-lean.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-debug-lean.mk?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,11 @@\n+# This BUILD_CONFIG option is a bit like bootstrap-debug, but in\n+# addition to comparing stripped object files, it also compares\n+# compiler internal state during stage3.\n+\n+# This makes it slower than bootstrap-debug, for there's additional\n+# dumping and recompilation during stage3.  bootstrap-debug-big can\n+# avoid the recompilation, if plenty of disk space is available.\n+\n+STAGE2_CFLAGS += -gtoggle -fcompare-debug=\n+STAGE3_CFLAGS += -fcompare-debug\n+do-compare = $(SHELL) $(srcdir)/contrib/compare-debug $$f1 $$f2"}, {"sha": "32fdf4dd86350e2c35005da347684d3406afb78d", "filename": "config/bootstrap-debug-lib.mk", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-lib.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug-lib.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-debug-lib.mk?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,12 @@\n+# This BUILD_CONFIG option tests that target libraries built during\n+# stage3 would have generated the same executable code if they were\n+# compiled with -g0.\n+\n+# It uses -g0 rather than -gtoggle because -g is default on target\n+# library builds, and toggling it where it's supposed to be disabled\n+# breaks e.g. crtstuff on ppc.\n+\n+STAGE1_TFLAGS += -g0 -fcompare-debug=\n+STAGE2_TFLAGS += -fcompare-debug=\n+STAGE3_TFLAGS += -fcompare-debug=-g0\n+do-compare = $(SHELL) $(srcdir)/contrib/compare-debug $$f1 $$f2"}, {"sha": "41389241c0541cb5230e7b46e0f8a61e18d0bee2", "filename": "config/bootstrap-debug.mk", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-debug.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-debug.mk?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,2 +1,12 @@\n-STAGE2_CFLAGS += -g0\n+# This BUILD_CONFIG option builds checks that toggling debug\n+# information generation doesn't affect the generated object code.\n+\n+# It is very lightweight: in addition to not performing any additional\n+# compilation (unlike bootstrap-debug-lean), it actually speeds up\n+# stage2, for no debug information is generated when compiling with\n+# the unoptimized stage1.\n+\n+# For more thorough testing, see bootstrap-debug-lean.mk\n+\n+STAGE2_CFLAGS += -gtoggle\n do-compare = $(SHELL) $(srcdir)/contrib/compare-debug $$f1 $$f2"}, {"sha": "08a8dff912b1fa6d19a659d2802e15ca29619008", "filename": "config/bootstrap-time.mk", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-time.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/config%2Fbootstrap-time.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fbootstrap-time.mk?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,2 @@\n+BOOT_CFLAGS += -time=$(shell pwd)/time.log\n+TFLAGS += -time=$(shell pwd)/time.log"}, {"sha": "c2e1335366ce17d0abf339a027333fe3e8a6712c", "filename": "contrib/compare-debug", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/contrib%2Fcompare-debug", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/contrib%2Fcompare-debug", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcompare-debug?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -141,4 +141,12 @@ $rm \"$1.$suf1\" \"$2.$suf2\"\n \n trap \"exit $status; exit\" 0 1 2 15\n \n+if test -f \"$1\".gkd || test -f \"$2\".gkd; then\n+  if cmp \"$1\".gkd \"$2\".gkd; then\n+    :\n+  else\n+    status=$?\n+  fi\n+fi\n+\n exit $status"}, {"sha": "6bed3390f48627acd1f8fd2aae7946392aa5c92e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -911,7 +911,7 @@ SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h $(TREE_H) vec.h $(GGC_H)\n TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h graphds.h $(SCEV_H)\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n-TREE_INLINE_H = tree-inline.h pointer-set.h\n+TREE_INLINE_H = tree-inline.h $(GIMPLE_H)\n REAL_H = real.h $(MACHMODE_H)\n IRA_INT_H = ira.h ira-int.h $(CFGLOOP_H) alloc-pool.h\n DBGCNT_H = dbgcnt.h dbgcnt.def\n@@ -2653,7 +2653,7 @@ rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n \n print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) $(FLAGS_H) \\\n-    $(BCONFIG_H) $(REAL_H) $(DIAGNOSTIC_H)\n+    $(BCONFIG_H) $(REAL_H) $(DIAGNOSTIC_H) cselib.h\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \\\n    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H) \\\n@@ -2832,8 +2832,9 @@ coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(HASHTAB_H) tree-iterator.h $(CGRAPH_H) $(TREE_PASS_H) gcov-io.c $(TM_P_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(RECOG_H) \\\n-   $(EMIT_RTL_H) $(TOPLEV_H) output.h $(FUNCTION_H) cselib.h $(GGC_H) $(TM_P_H) \\\n-   gt-cselib.h $(PARAMS_H) alloc-pool.h $(HASHTAB_H) $(TARGET_H)\n+   $(EMIT_RTL_H) $(TOPLEV_H) output.h $(FUNCTION_H) $(TREE_PASS_H) \\\n+   cselib.h gt-cselib.h $(GGC_H) $(TM_P_H) $(PARAMS_H) alloc-pool.h \\\n+   $(HASHTAB_H) $(TARGET_H)\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) $(EXPR_H) $(TOPLEV_H) \\\n    output.h $(FUNCTION_H) $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\\n@@ -2923,7 +2924,7 @@ regstat.o : regstat.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n-   $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H)\n+   $(REGS_H) $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) cselib.h $(TARGET_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) $(FUNCTION_H) \\\n    $(TOPLEV_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h cfghooks.h \\"}, {"sha": "929a2dcade856eb9a9114d9d90f3cc7a5c266a64", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1341,7 +1341,7 @@ merge_in_block (int max_reg, basic_block bb)\n       unsigned int uid = INSN_UID (insn);\n       bool insn_is_add_or_inc = true;\n \n-      if (!INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\t\n \n       /* This continue is deliberate.  We do not want the uses of the\n@@ -1414,7 +1414,7 @@ merge_in_block (int max_reg, basic_block bb)\n       \n       /* If the inc insn was merged with a mem, the inc insn is gone\n \t and there is noting to update.  */\n-      if (DF_INSN_UID_GET(uid))\n+      if (DF_INSN_UID_GET (uid))\n \t{\n \t  df_ref *def_rec;\n \t  df_ref *use_rec;"}, {"sha": "778a3edeec40c1c4f1510cef938341315e4de469", "filename": "gcc/caller-save.c", "status": "modified", "additions": 126, "deletions": 24, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -98,6 +98,9 @@ static int n_regs_saved;\n static HARD_REG_SET referenced_regs;\n \n \n+typedef void refmarker_fn (rtx *loc, enum machine_mode mode, int hardregno,\n+\t\t\t   void *mark_arg);\n+\n static int reg_save_code (int, enum machine_mode);\n static int reg_restore_code (int, enum machine_mode);\n \n@@ -108,8 +111,9 @@ static void finish_saved_hard_regs (void);\n static int saved_hard_reg_compare_func (const void *, const void *);\n \n static void mark_set_regs (rtx, const_rtx, void *);\n-static void add_stored_regs (rtx, const_rtx, void *);\n-static void mark_referenced_regs (rtx);\n+static void mark_referenced_regs (rtx *, refmarker_fn *mark, void *mark_arg);\n+static refmarker_fn mark_reg_as_referenced;\n+static refmarker_fn replace_reg_with_saved_mem;\n static int insert_save (struct insn_chain *, int, int, HARD_REG_SET *,\n \t\t\tenum machine_mode *);\n static int insert_restore (struct insn_chain *, int, int, int,\n@@ -770,7 +774,7 @@ save_call_clobbered_regs (void)\n \n       gcc_assert (!chain->is_caller_save_insn);\n \n-      if (INSN_P (insn))\n+      if (NONDEBUG_INSN_P (insn))\n \t{\n \t  /* If some registers have been saved, see if INSN references\n \t     any of them.  We must restore them before the insn if so.  */\n@@ -785,7 +789,8 @@ save_call_clobbered_regs (void)\n \t      else\n \t\t{\n \t\t  CLEAR_HARD_REG_SET (referenced_regs);\n-\t\t  mark_referenced_regs (PATTERN (insn));\n+\t\t  mark_referenced_regs (&PATTERN (insn),\n+\t\t\t\t\tmark_reg_as_referenced, NULL);\n \t\t  AND_HARD_REG_SET (referenced_regs, hard_regs_saved);\n \t\t}\n \n@@ -858,6 +863,10 @@ save_call_clobbered_regs (void)\n \t\t  n_regs_saved++;\n \t    }\n \t}\n+      else if (DEBUG_INSN_P (insn) && n_regs_saved)\n+\tmark_referenced_regs (&PATTERN (insn),\n+\t\t\t      replace_reg_with_saved_mem,\n+\t\t\t      save_mode);\n \n       if (chain->next == 0 || chain->next->block != chain->block)\n \t{\n@@ -947,65 +956,158 @@ add_stored_regs (rtx reg, const_rtx setter, void *data)\n \n /* Walk X and record all referenced registers in REFERENCED_REGS.  */\n static void\n-mark_referenced_regs (rtx x)\n+mark_referenced_regs (rtx *loc, refmarker_fn *mark, void *arg)\n {\n-  enum rtx_code code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (*loc);\n   const char *fmt;\n   int i, j;\n \n   if (code == SET)\n-    mark_referenced_regs (SET_SRC (x));\n+    mark_referenced_regs (&SET_SRC (*loc), mark, arg);\n   if (code == SET || code == CLOBBER)\n     {\n-      x = SET_DEST (x);\n-      code = GET_CODE (x);\n-      if ((code == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+      loc = &SET_DEST (*loc);\n+      code = GET_CODE (*loc);\n+      if ((code == REG && REGNO (*loc) < FIRST_PSEUDO_REGISTER)\n \t  || code == PC || code == CC0\n-\t  || (code == SUBREG && REG_P (SUBREG_REG (x))\n-\t      && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n+\t  || (code == SUBREG && REG_P (SUBREG_REG (*loc))\n+\t      && REGNO (SUBREG_REG (*loc)) < FIRST_PSEUDO_REGISTER\n \t      /* If we're setting only part of a multi-word register,\n \t\t we shall mark it as referenced, because the words\n \t\t that are not being set should be restored.  */\n-\t      && ((GET_MODE_SIZE (GET_MODE (x))\n-\t\t   >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t\t  || (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t      && ((GET_MODE_SIZE (GET_MODE (*loc))\n+\t\t   >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (*loc))))\n+\t\t  || (GET_MODE_SIZE (GET_MODE (SUBREG_REG (*loc)))\n \t\t      <= UNITS_PER_WORD))))\n \treturn;\n     }\n   if (code == MEM || code == SUBREG)\n     {\n-      x = XEXP (x, 0);\n-      code = GET_CODE (x);\n+      loc = &XEXP (*loc, 0);\n+      code = GET_CODE (*loc);\n     }\n \n   if (code == REG)\n     {\n-      int regno = REGNO (x);\n+      int regno = REGNO (*loc);\n       int hardregno = (regno < FIRST_PSEUDO_REGISTER ? regno\n \t\t       : reg_renumber[regno]);\n \n       if (hardregno >= 0)\n-\tadd_to_hard_reg_set (&referenced_regs, GET_MODE (x), hardregno);\n+\tmark (loc, GET_MODE (*loc), hardregno, arg);\n+      else if (arg)\n+\t/* ??? Will we ever end up with an equiv expression in a debug\n+\t   insn, that would have required restoring a reg, or will\n+\t   reload take care of it for us?  */\n+\treturn;\n       /* If this is a pseudo that did not get a hard register, scan its\n \t memory location, since it might involve the use of another\n \t register, which might be saved.  */\n       else if (reg_equiv_mem[regno] != 0)\n-\tmark_referenced_regs (XEXP (reg_equiv_mem[regno], 0));\n+\tmark_referenced_regs (&XEXP (reg_equiv_mem[regno], 0), mark, arg);\n       else if (reg_equiv_address[regno] != 0)\n-\tmark_referenced_regs (reg_equiv_address[regno]);\n+\tmark_referenced_regs (&reg_equiv_address[regno], mark, arg);\n       return;\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tmark_referenced_regs (XEXP (x, i));\n+\tmark_referenced_regs (&XEXP (*loc, i), mark, arg);\n       else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  mark_referenced_regs (XVECEXP (x, i, j));\n+\tfor (j = XVECLEN (*loc, i) - 1; j >= 0; j--)\n+\t  mark_referenced_regs (&XVECEXP (*loc, i, j), mark, arg);\n+    }\n+}\n+\n+/* Parameter function for mark_referenced_regs() that adds registers\n+   present in the insn and in equivalent mems and addresses to\n+   referenced_regs.  */\n+\n+static void\n+mark_reg_as_referenced (rtx *loc ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode,\n+\t\t\tint hardregno,\n+\t\t\tvoid *arg ATTRIBUTE_UNUSED)\n+{\n+  add_to_hard_reg_set (&referenced_regs, mode, hardregno);\n+}\n+\n+/* Parameter function for mark_referenced_regs() that replaces\n+   registers referenced in a debug_insn that would have been restored,\n+   should it be a non-debug_insn, with their save locations.  */\n+\n+static void\n+replace_reg_with_saved_mem (rtx *loc,\n+\t\t\t    enum machine_mode mode,\n+\t\t\t    int regno,\n+\t\t\t    void *arg)\n+{\n+  unsigned int i, nregs = hard_regno_nregs [regno][mode];\n+  rtx mem;\n+  enum machine_mode *save_mode = (enum machine_mode *)arg;\n+\n+  for (i = 0; i < nregs; i++)\n+    if (TEST_HARD_REG_BIT (hard_regs_saved, regno + i))\n+      break;\n+\n+  /* If none of the registers in the range would need restoring, we're\n+     all set.  */\n+  if (i == nregs)\n+    return;\n+\n+  while (++i < nregs)\n+    if (!TEST_HARD_REG_BIT (hard_regs_saved, regno + i))\n+      break;\n+\n+  if (i == nregs\n+      && regno_save_mem[regno][nregs])\n+    {\n+      mem = copy_rtx (regno_save_mem[regno][nregs]);\n+\n+      if (nregs == (unsigned int) hard_regno_nregs[regno][save_mode[regno]])\n+\tmem = adjust_address_nv (mem, save_mode[regno], 0);\n+\n+      if (GET_MODE (mem) != mode)\n+\t{\n+\t  /* This is gen_lowpart_if_possible(), but without validating\n+\t     the newly-formed address.  */\n+\t  int offset = 0;\n+\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    offset = (MAX (GET_MODE_SIZE (GET_MODE (mem)), UNITS_PER_WORD)\n+\t\t      - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    /* Adjust the address so that the address-after-the-data is\n+\t       unchanged.  */\n+\t    offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n+\t\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (mem))));\n+\n+\t  mem = adjust_address_nv (mem, mode, offset);\n+\t}\n     }\n+  else\n+    {\n+      mem = gen_rtx_CONCATN (mode, rtvec_alloc (nregs));\n+      for (i = 0; i < nregs; i++)\n+\tif (TEST_HARD_REG_BIT (hard_regs_saved, regno + i))\n+\t  {\n+\t    gcc_assert (regno_save_mem[regno + i][1]);\n+\t    XVECEXP (mem, 0, i) = copy_rtx (regno_save_mem[regno + i][1]);\n+\t  }\n+\telse\n+\t  {\n+\t    gcc_assert (save_mode[regno] != VOIDmode);\n+\t    XVECEXP (mem, 0, i) = gen_rtx_REG (save_mode [regno],\n+\t\t\t\t\t       regno + i);\n+\t  }\n+    }\n+\n+  gcc_assert (GET_MODE (mem) == mode);\n+  *loc = mem;\n }\n+\n \f\n /* Insert a sequence of insns to restore.  Place these insns in front of\n    CHAIN if BEFORE_P is nonzero, behind the insn otherwise.  MAXRESTORE is"}, {"sha": "012bd0b6be7ecb5bf625818096dc0e77b6f8d5af", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -62,6 +62,7 @@ inside_basic_block_p (const_rtx insn)\n \n     case CALL_INSN:\n     case INSN:\n+    case DEBUG_INSN:\n       return true;\n \n     case BARRIER:\n@@ -85,6 +86,7 @@ control_flow_insn_p (const_rtx insn)\n     {\n     case NOTE:\n     case CODE_LABEL:\n+    case DEBUG_INSN:\n       return false;\n \n     case JUMP_INSN:"}, {"sha": "cfb19b602758e758d4a099504372442766ff8616", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 67, "deletions": 12, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1057,10 +1057,10 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n   while (true)\n     {\n       /* Ignore notes.  */\n-      while (!INSN_P (i1) && i1 != BB_HEAD (bb1))\n+      while (!NONDEBUG_INSN_P (i1) && i1 != BB_HEAD (bb1))\n \ti1 = PREV_INSN (i1);\n \n-      while (!INSN_P (i2) && i2 != BB_HEAD (bb2))\n+      while (!NONDEBUG_INSN_P (i2) && i2 != BB_HEAD (bb2))\n \ti2 = PREV_INSN (i2);\n \n       if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n@@ -1111,13 +1111,13 @@ flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n      Two, it keeps line number notes as matched as may be.  */\n   if (ninsns)\n     {\n-      while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n+      while (last1 != BB_HEAD (bb1) && !NONDEBUG_INSN_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n       if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n-      while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n+      while (last2 != BB_HEAD (bb2) && !NONDEBUG_INSN_P (PREV_INSN (last2)))\n \tlast2 = PREV_INSN (last2);\n \n       if (last2 != BB_HEAD (bb2) && LABEL_P (PREV_INSN (last2)))\n@@ -1557,8 +1557,12 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \t  /* Skip possible basic block header.  */\n \t  if (LABEL_P (newpos2))\n \t    newpos2 = NEXT_INSN (newpos2);\n+\t  while (DEBUG_INSN_P (newpos2))\n+\t    newpos2 = NEXT_INSN (newpos2);\n \t  if (NOTE_P (newpos2))\n \t    newpos2 = NEXT_INSN (newpos2);\n+\t  while (DEBUG_INSN_P (newpos2))\n+\t    newpos2 = NEXT_INSN (newpos2);\n \t}\n \n       if (dump_file)\n@@ -1643,9 +1647,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   /* Skip possible basic block header.  */\n   if (LABEL_P (newpos1))\n     newpos1 = NEXT_INSN (newpos1);\n+\n+  while (DEBUG_INSN_P (newpos1))\n+    newpos1 = NEXT_INSN (newpos1);\n+\n   if (NOTE_INSN_BASIC_BLOCK_P (newpos1))\n     newpos1 = NEXT_INSN (newpos1);\n \n+  while (DEBUG_INSN_P (newpos1))\n+    newpos1 = NEXT_INSN (newpos1);\n+\n   redirect_from = split_block (src1, PREV_INSN (newpos1))->src;\n   to_remove = single_succ (redirect_from);\n \n@@ -2032,20 +2043,64 @@ bool\n delete_unreachable_blocks (void)\n {\n   bool changed = false;\n-  basic_block b, next_bb;\n+  basic_block b, prev_bb;\n \n   find_unreachable_blocks ();\n \n-  /* Delete all unreachable basic blocks.  */\n-\n-  for (b = ENTRY_BLOCK_PTR->next_bb; b != EXIT_BLOCK_PTR; b = next_bb)\n+  /* When we're in GIMPLE mode and there may be debug insns, we should\n+     delete blocks in reverse dominator order, so as to get a chance\n+     to substitute all released DEFs into debug stmts.  If we don't\n+     have dominators information, walking blocks backward gets us a\n+     better chance of retaining most debug information than\n+     otherwise.  */\n+  if (MAY_HAVE_DEBUG_STMTS && current_ir_type () == IR_GIMPLE\n+      && dom_info_available_p (CDI_DOMINATORS))\n     {\n-      next_bb = b->next_bb;\n+      for (b = EXIT_BLOCK_PTR->prev_bb; b != ENTRY_BLOCK_PTR; b = prev_bb)\n+\t{\n+\t  prev_bb = b->prev_bb;\n+\n+\t  if (!(b->flags & BB_REACHABLE))\n+\t    {\n+\t      /* Speed up the removal of blocks that don't dominate\n+\t\t others.  Walking backwards, this should be the common\n+\t\t case.  */\n+\t      if (!first_dom_son (CDI_DOMINATORS, b))\n+\t\tdelete_basic_block (b);\n+\t      else\n+\t\t{\n+\t\t  VEC (basic_block, heap) *h\n+\t\t    = get_all_dominated_blocks (CDI_DOMINATORS, b);\n+\n+\t\t  while (VEC_length (basic_block, h))\n+\t\t    {\n+\t\t      b = VEC_pop (basic_block, h);\n+\n+\t\t      prev_bb = b->prev_bb;\n \n-      if (!(b->flags & BB_REACHABLE))\n+\t\t      gcc_assert (!(b->flags & BB_REACHABLE));\n+\n+\t\t      delete_basic_block (b);\n+\t\t    }\n+\n+\t\t  VEC_free (basic_block, heap, h);\n+\t\t}\n+\n+\t      changed = true;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (b = EXIT_BLOCK_PTR->prev_bb; b != ENTRY_BLOCK_PTR; b = prev_bb)\n \t{\n-\t  delete_basic_block (b);\n-\t  changed = true;\n+\t  prev_bb = b->prev_bb;\n+\n+\t  if (!(b->flags & BB_REACHABLE))\n+\t    {\n+\t      delete_basic_block (b);\n+\t      changed = true;\n+\t    }\n \t}\n     }\n "}, {"sha": "8bd58b088328c437d0eb5dfacfacafd89c346be1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 870, "deletions": 3, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -70,7 +70,13 @@ gimple_assign_rhs_to_tree (gimple stmt)\n \t\tTREE_TYPE (gimple_assign_lhs (stmt)),\n \t\tgimple_assign_rhs1 (stmt));\n   else if (grhs_class == GIMPLE_SINGLE_RHS)\n-    t = gimple_assign_rhs1 (stmt);\n+    {\n+      t = gimple_assign_rhs1 (stmt);\n+      /* Avoid modifying this tree in place below.  */\n+      if (gimple_has_location (stmt) && CAN_HAVE_LOCATION_P (t)\n+\t  && gimple_location (stmt) != EXPR_LOCATION (t))\n+\tt = copy_node (t);\n+    }\n   else\n     gcc_unreachable ();\n \n@@ -1834,7 +1840,8 @@ maybe_dump_rtl_for_gimple_stmt (gimple stmt, rtx since)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\n;; \");\n-      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+      print_gimple_stmt (dump_file, stmt, 0,\n+\t\t\t TDF_SLIM | (dump_flags & TDF_LINENO));\n       fprintf (dump_file, \"\\n\");\n \n       print_rtl (dump_file, since ? NEXT_INSN (since) : since);\n@@ -2147,6 +2154,808 @@ expand_gimple_tailcall (basic_block bb, gimple stmt, bool *can_fallthru)\n   return bb;\n }\n \n+/* Return the difference between the floor and the truncated result of\n+   a signed division by OP1 with remainder MOD.  */\n+static rtx\n+floor_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+{\n+  /* (mod != 0 ? (op1 / mod < 0 ? -1 : 0) : 0) */\n+  return gen_rtx_IF_THEN_ELSE\n+    (mode, gen_rtx_NE (BImode, mod, const0_rtx),\n+     gen_rtx_IF_THEN_ELSE\n+     (mode, gen_rtx_LT (BImode,\n+\t\t\tgen_rtx_DIV (mode, op1, mod),\n+\t\t\tconst0_rtx),\n+      constm1_rtx, const0_rtx),\n+     const0_rtx);\n+}\n+\n+/* Return the difference between the ceil and the truncated result of\n+   a signed division by OP1 with remainder MOD.  */\n+static rtx\n+ceil_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+{\n+  /* (mod != 0 ? (op1 / mod > 0 ? 1 : 0) : 0) */\n+  return gen_rtx_IF_THEN_ELSE\n+    (mode, gen_rtx_NE (BImode, mod, const0_rtx),\n+     gen_rtx_IF_THEN_ELSE\n+     (mode, gen_rtx_GT (BImode,\n+\t\t\tgen_rtx_DIV (mode, op1, mod),\n+\t\t\tconst0_rtx),\n+      const1_rtx, const0_rtx),\n+     const0_rtx);\n+}\n+\n+/* Return the difference between the ceil and the truncated result of\n+   an unsigned division by OP1 with remainder MOD.  */\n+static rtx\n+ceil_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1 ATTRIBUTE_UNUSED)\n+{\n+  /* (mod != 0 ? 1 : 0) */\n+  return gen_rtx_IF_THEN_ELSE\n+    (mode, gen_rtx_NE (BImode, mod, const0_rtx),\n+     const1_rtx, const0_rtx);\n+}\n+\n+/* Return the difference between the rounded and the truncated result\n+   of a signed division by OP1 with remainder MOD.  Halfway cases are\n+   rounded away from zero, rather than to the nearest even number.  */\n+static rtx\n+round_sdiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+{\n+  /* (abs (mod) >= abs (op1) - abs (mod)\n+      ? (op1 / mod > 0 ? 1 : -1)\n+      : 0) */\n+  return gen_rtx_IF_THEN_ELSE\n+    (mode, gen_rtx_GE (BImode, gen_rtx_ABS (mode, mod),\n+\t\t       gen_rtx_MINUS (mode,\n+\t\t\t\t      gen_rtx_ABS (mode, op1),\n+\t\t\t\t      gen_rtx_ABS (mode, mod))),\n+     gen_rtx_IF_THEN_ELSE\n+     (mode, gen_rtx_GT (BImode,\n+\t\t\tgen_rtx_DIV (mode, op1, mod),\n+\t\t\tconst0_rtx),\n+      const1_rtx, constm1_rtx),\n+     const0_rtx);\n+}\n+\n+/* Return the difference between the rounded and the truncated result\n+   of a unsigned division by OP1 with remainder MOD.  Halfway cases\n+   are rounded away from zero, rather than to the nearest even\n+   number.  */\n+static rtx\n+round_udiv_adjust (enum machine_mode mode, rtx mod, rtx op1)\n+{\n+  /* (mod >= op1 - mod ? 1 : 0) */\n+  return gen_rtx_IF_THEN_ELSE\n+    (mode, gen_rtx_GE (BImode, mod,\n+\t\t       gen_rtx_MINUS (mode, op1, mod)),\n+     const1_rtx, const0_rtx);\n+}\n+\n+/* Wrap modeless constants in CONST:MODE.  */\n+rtx\n+wrap_constant (enum machine_mode mode, rtx x)\n+{\n+  if (GET_MODE (x) != VOIDmode)\n+    return x;\n+\n+  if (CONST_INT_P (x)\n+      || GET_CODE (x) == CONST_FIXED\n+      || GET_CODE (x) == CONST_DOUBLE\n+      || GET_CODE (x) == LABEL_REF)\n+    {\n+      gcc_assert (mode != VOIDmode);\n+\n+      x = gen_rtx_CONST (mode, x);\n+    }\n+\n+  return x;\n+}\n+\n+/* Remove CONST wrapper added by wrap_constant().  */\n+rtx\n+unwrap_constant (rtx x)\n+{\n+  rtx ret = x;\n+\n+  if (GET_CODE (x) != CONST)\n+    return x;\n+\n+  x = XEXP (x, 0);\n+\n+  if (CONST_INT_P (x)\n+      || GET_CODE (x) == CONST_FIXED\n+      || GET_CODE (x) == CONST_DOUBLE\n+      || GET_CODE (x) == LABEL_REF)\n+    ret = x;\n+\n+  return ret;\n+}\n+\n+/* Return an RTX equivalent to the value of the tree expression\n+   EXP.  */\n+\n+static rtx\n+expand_debug_expr (tree exp)\n+{\n+  rtx op0 = NULL_RTX, op1 = NULL_RTX, op2 = NULL_RTX;\n+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (exp));\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n+    {\n+    case tcc_expression:\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase COND_EXPR:\n+\t  goto ternary;\n+\n+\tcase TRUTH_ANDIF_EXPR:\n+\tcase TRUTH_ORIF_EXPR:\n+\tcase TRUTH_AND_EXPR:\n+\tcase TRUTH_OR_EXPR:\n+\tcase TRUTH_XOR_EXPR:\n+\t  goto binary;\n+\n+\tcase TRUTH_NOT_EXPR:\n+\t  goto unary;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    ternary:\n+      op2 = expand_debug_expr (TREE_OPERAND (exp, 2));\n+      if (!op2)\n+\treturn NULL_RTX;\n+      /* Fall through.  */\n+\n+    binary:\n+    case tcc_binary:\n+    case tcc_comparison:\n+      op1 = expand_debug_expr (TREE_OPERAND (exp, 1));\n+      if (!op1)\n+\treturn NULL_RTX;\n+      /* Fall through.  */\n+\n+    unary:\n+    case tcc_unary:\n+      op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n+      if (!op0)\n+\treturn NULL_RTX;\n+      break;\n+\n+    case tcc_type:\n+    case tcc_statement:\n+      gcc_unreachable ();\n+\n+    case tcc_constant:\n+    case tcc_exceptional:\n+    case tcc_declaration:\n+    case tcc_reference:\n+    case tcc_vl_exp:\n+      break;\n+    }\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case STRING_CST:\n+      if (!lookup_constant_def (exp))\n+\t{\n+\t  op0 = gen_rtx_CONST_STRING (Pmode, TREE_STRING_POINTER (exp));\n+\t  op0 = gen_rtx_MEM (BLKmode, op0);\n+\t  set_mem_attributes (op0, exp, 0);\n+\t  return op0;\n+\t}\n+      /* Fall through...  */\n+\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+      op0 = expand_expr (exp, NULL_RTX, mode, EXPAND_INITIALIZER);\n+      return op0;\n+\n+    case COMPLEX_CST:\n+      gcc_assert (COMPLEX_MODE_P (mode));\n+      op0 = expand_debug_expr (TREE_REALPART (exp));\n+      op0 = wrap_constant (GET_MODE_INNER (mode), op0);\n+      op1 = expand_debug_expr (TREE_IMAGPART (exp));\n+      op1 = wrap_constant (GET_MODE_INNER (mode), op1);\n+      return gen_rtx_CONCAT (mode, op0, op1);\n+\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FUNCTION_DECL:\n+    case LABEL_DECL:\n+    case CONST_DECL:\n+    case RESULT_DECL:\n+      op0 = DECL_RTL_IF_SET (exp);\n+\n+      /* This decl was probably optimized away.  */\n+      if (!op0)\n+\treturn NULL;\n+\n+      op0 = copy_rtx (op0);\n+\n+      if (GET_MODE (op0) == BLKmode)\n+\t{\n+\t  gcc_assert (MEM_P (op0));\n+\t  op0 = adjust_address_nv (op0, mode, 0);\n+\t  return op0;\n+\t}\n+\n+      /* Fall through.  */\n+\n+    adjust_mode:\n+    case PAREN_EXPR:\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      {\n+\tenum machine_mode inner_mode = GET_MODE (op0);\n+\n+\tif (mode == inner_mode)\n+\t  return op0;\n+\n+\tif (inner_mode == VOIDmode)\n+\t  {\n+\t    inner_mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t    if (mode == inner_mode)\n+\t      return op0;\n+\t  }\n+\n+\tif (FLOAT_MODE_P (mode) && FLOAT_MODE_P (inner_mode))\n+\t  {\n+\t    if (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (inner_mode))\n+\t      op0 = simplify_gen_subreg (mode, op0, inner_mode, 0);\n+\t    else if (GET_MODE_BITSIZE (mode) < GET_MODE_BITSIZE (inner_mode))\n+\t      op0 = simplify_gen_unary (FLOAT_TRUNCATE, mode, op0, inner_mode);\n+\t    else\n+\t      op0 = simplify_gen_unary (FLOAT_EXTEND, mode, op0, inner_mode);\n+\t  }\n+\telse if (FLOAT_MODE_P (mode))\n+\t  {\n+\t    if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\t      op0 = simplify_gen_unary (UNSIGNED_FLOAT, mode, op0, inner_mode);\n+\t    else\n+\t      op0 = simplify_gen_unary (FLOAT, mode, op0, inner_mode);\n+\t  }\n+\telse if (FLOAT_MODE_P (inner_mode))\n+\t  {\n+\t    if (unsignedp)\n+\t      op0 = simplify_gen_unary (UNSIGNED_FIX, mode, op0, inner_mode);\n+\t    else\n+\t      op0 = simplify_gen_unary (FIX, mode, op0, inner_mode);\n+\t  }\n+\telse if (CONSTANT_P (op0)\n+\t\t || GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (inner_mode))\n+\t  op0 = simplify_gen_subreg (mode, op0, inner_mode,\n+\t\t\t\t     subreg_lowpart_offset (mode,\n+\t\t\t\t\t\t\t    inner_mode));\n+\telse if (unsignedp)\n+\t  op0 = gen_rtx_ZERO_EXTEND (mode, op0);\n+\telse\n+\t  op0 = gen_rtx_SIGN_EXTEND (mode, op0);\n+\n+\treturn op0;\n+      }\n+\n+    case INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n+      op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n+      if (!op0)\n+\treturn NULL;\n+\n+      gcc_assert (GET_MODE (op0) == Pmode\n+\t\t  || GET_CODE (op0) == CONST_INT\n+\t\t  || GET_CODE (op0) == CONST_DOUBLE);\n+\n+      if (TREE_CODE (exp) == ALIGN_INDIRECT_REF)\n+\t{\n+\t  int align = TYPE_ALIGN_UNIT (TREE_TYPE (exp));\n+\t  op0 = gen_rtx_AND (Pmode, op0, GEN_INT (-align));\n+\t}\n+\n+      op0 = gen_rtx_MEM (mode, op0);\n+\n+      set_mem_attributes (op0, exp, 0);\n+\n+      return op0;\n+\n+    case TARGET_MEM_REF:\n+      if (TMR_SYMBOL (exp) && !DECL_RTL_SET_P (TMR_SYMBOL (exp)))\n+\treturn NULL;\n+\n+      op0 = expand_debug_expr\n+\t(tree_mem_ref_addr (build_pointer_type (TREE_TYPE (exp)),\n+\t\t\t    exp));\n+      if (!op0)\n+\treturn NULL;\n+\n+      gcc_assert (GET_MODE (op0) == Pmode\n+\t\t  || GET_CODE (op0) == CONST_INT\n+\t\t  || GET_CODE (op0) == CONST_DOUBLE);\n+\n+      op0 = gen_rtx_MEM (mode, op0);\n+\n+      set_mem_attributes (op0, exp, 0);\n+\n+      return op0;\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      {\n+\tenum machine_mode mode1;\n+\tHOST_WIDE_INT bitsize, bitpos;\n+\ttree offset;\n+\tint volatilep = 0;\n+\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n+\t\t\t\t\t&mode1, &unsignedp, &volatilep, false);\n+\trtx orig_op0;\n+\n+\torig_op0 = op0 = expand_debug_expr (tem);\n+\n+\tif (!op0)\n+\t  return NULL;\n+\n+\tif (offset)\n+\t  {\n+\t    gcc_assert (MEM_P (op0));\n+\n+\t    op1 = expand_debug_expr (offset);\n+\t    if (!op1)\n+\t      return NULL;\n+\n+\t    op0 = gen_rtx_MEM (mode, gen_rtx_PLUS (Pmode, XEXP (op0, 0), op1));\n+\t  }\n+\n+\tif (MEM_P (op0))\n+\t  {\n+\t    if (bitpos >= BITS_PER_UNIT)\n+\t      {\n+\t\top0 = adjust_address_nv (op0, mode1, bitpos / BITS_PER_UNIT);\n+\t\tbitpos %= BITS_PER_UNIT;\n+\t      }\n+\t    else if (bitpos < 0)\n+\t      {\n+\t\tint units = (-bitpos + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n+\t\top0 = adjust_address_nv (op0, mode1, units);\n+\t\tbitpos += units * BITS_PER_UNIT;\n+\t      }\n+\t    else if (bitpos == 0 && bitsize == GET_MODE_BITSIZE (mode))\n+\t      op0 = adjust_address_nv (op0, mode, 0);\n+\t    else if (GET_MODE (op0) != mode1)\n+\t      op0 = adjust_address_nv (op0, mode1, 0);\n+\t    else\n+\t      op0 = copy_rtx (op0);\n+\t    if (op0 == orig_op0)\n+\t      op0 = shallow_copy_rtx (op0);\n+\t    set_mem_attributes (op0, exp, 0);\n+\t  }\n+\n+\tif (bitpos == 0 && mode == GET_MODE (op0))\n+\t  return op0;\n+\n+\tif ((bitpos % BITS_PER_UNIT) == 0\n+\t    && bitsize == GET_MODE_BITSIZE (mode1))\n+\t  {\n+\t    enum machine_mode opmode = GET_MODE (op0);\n+\n+\t    gcc_assert (opmode != BLKmode);\n+\n+\t    if (opmode == VOIDmode)\n+\t      opmode = mode1;\n+\n+\t    /* This condition may hold if we're expanding the address\n+\t       right past the end of an array that turned out not to\n+\t       be addressable (i.e., the address was only computed in\n+\t       debug stmts).  The gen_subreg below would rightfully\n+\t       crash, and the address doesn't really exist, so just\n+\t       drop it.  */\n+\t    if (bitpos >= GET_MODE_BITSIZE (opmode))\n+\t      return NULL;\n+\n+\t    return simplify_gen_subreg (mode, op0, opmode,\n+\t\t\t\t\tbitpos / BITS_PER_UNIT);\n+\t  }\n+\n+\treturn simplify_gen_ternary (SCALAR_INT_MODE_P (GET_MODE (op0))\n+\t\t\t\t     && TYPE_UNSIGNED (TREE_TYPE (exp))\n+\t\t\t\t     ? SIGN_EXTRACT\n+\t\t\t\t     : ZERO_EXTRACT, mode,\n+\t\t\t\t     GET_MODE (op0) != VOIDmode\n+\t\t\t\t     ? GET_MODE (op0) : mode1,\n+\t\t\t\t     op0, GEN_INT (bitsize), GEN_INT (bitpos));\n+      }\n+\n+    case EXC_PTR_EXPR:\n+      /* ??? Do not call get_exception_pointer(), we don't want to gen\n+\t it if it hasn't been created yet.  */\n+      return get_exception_pointer ();\n+\n+    case FILTER_EXPR:\n+      /* Likewise get_exception_filter().  */\n+      return get_exception_filter ();\n+\n+    case ABS_EXPR:\n+      return gen_rtx_ABS (mode, op0);\n+\n+    case NEGATE_EXPR:\n+      return gen_rtx_NEG (mode, op0);\n+\n+    case BIT_NOT_EXPR:\n+      return gen_rtx_NOT (mode, op0);\n+\n+    case FLOAT_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UNSIGNED_FLOAT (mode, op0);\n+      else\n+\treturn gen_rtx_FLOAT (mode, op0);\n+\n+    case FIX_TRUNC_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UNSIGNED_FIX (mode, op0);\n+      else\n+\treturn gen_rtx_FIX (mode, op0);\n+\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+      return gen_rtx_PLUS (mode, op0, op1);\n+\n+    case MINUS_EXPR:\n+      return gen_rtx_MINUS (mode, op0, op1);\n+\n+    case MULT_EXPR:\n+      return gen_rtx_MULT (mode, op0, op1);\n+\n+    case RDIV_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UDIV (mode, op0, op1);\n+      else\n+\treturn gen_rtx_DIV (mode, op0, op1);\n+\n+    case TRUNC_MOD_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UMOD (mode, op0, op1);\n+      else\n+\treturn gen_rtx_MOD (mode, op0, op1);\n+\n+    case FLOOR_DIV_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UDIV (mode, op0, op1);\n+      else\n+\t{\n+\t  rtx div = gen_rtx_DIV (mode, op0, op1);\n+\t  rtx mod = gen_rtx_MOD (mode, op0, op1);\n+\t  rtx adj = floor_sdiv_adjust (mode, mod, op1);\n+\t  return gen_rtx_PLUS (mode, div, adj);\n+\t}\n+\n+    case FLOOR_MOD_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UMOD (mode, op0, op1);\n+      else\n+\t{\n+\t  rtx mod = gen_rtx_MOD (mode, op0, op1);\n+\t  rtx adj = floor_sdiv_adjust (mode, mod, op1);\n+\t  adj = gen_rtx_NEG (mode, gen_rtx_MULT (mode, adj, op1));\n+\t  return gen_rtx_PLUS (mode, mod, adj);\n+\t}\n+\n+    case CEIL_DIV_EXPR:\n+      if (unsignedp)\n+\t{\n+\t  rtx div = gen_rtx_UDIV (mode, op0, op1);\n+\t  rtx mod = gen_rtx_UMOD (mode, op0, op1);\n+\t  rtx adj = ceil_udiv_adjust (mode, mod, op1);\n+\t  return gen_rtx_PLUS (mode, div, adj);\n+\t}\n+      else\n+\t{\n+\t  rtx div = gen_rtx_DIV (mode, op0, op1);\n+\t  rtx mod = gen_rtx_MOD (mode, op0, op1);\n+\t  rtx adj = ceil_sdiv_adjust (mode, mod, op1);\n+\t  return gen_rtx_PLUS (mode, div, adj);\n+\t}\n+\n+    case CEIL_MOD_EXPR:\n+      if (unsignedp)\n+\t{\n+\t  rtx mod = gen_rtx_UMOD (mode, op0, op1);\n+\t  rtx adj = ceil_udiv_adjust (mode, mod, op1);\n+\t  adj = gen_rtx_NEG (mode, gen_rtx_MULT (mode, adj, op1));\n+\t  return gen_rtx_PLUS (mode, mod, adj);\n+\t}\n+      else\n+\t{\n+\t  rtx mod = gen_rtx_MOD (mode, op0, op1);\n+\t  rtx adj = ceil_sdiv_adjust (mode, mod, op1);\n+\t  adj = gen_rtx_NEG (mode, gen_rtx_MULT (mode, adj, op1));\n+\t  return gen_rtx_PLUS (mode, mod, adj);\n+\t}\n+\n+    case ROUND_DIV_EXPR:\n+      if (unsignedp)\n+\t{\n+\t  rtx div = gen_rtx_UDIV (mode, op0, op1);\n+\t  rtx mod = gen_rtx_UMOD (mode, op0, op1);\n+\t  rtx adj = round_udiv_adjust (mode, mod, op1);\n+\t  return gen_rtx_PLUS (mode, div, adj);\n+\t}\n+      else\n+\t{\n+\t  rtx div = gen_rtx_DIV (mode, op0, op1);\n+\t  rtx mod = gen_rtx_MOD (mode, op0, op1);\n+\t  rtx adj = round_sdiv_adjust (mode, mod, op1);\n+\t  return gen_rtx_PLUS (mode, div, adj);\n+\t}\n+\n+    case ROUND_MOD_EXPR:\n+      if (unsignedp)\n+\t{\n+\t  rtx mod = gen_rtx_UMOD (mode, op0, op1);\n+\t  rtx adj = round_udiv_adjust (mode, mod, op1);\n+\t  adj = gen_rtx_NEG (mode, gen_rtx_MULT (mode, adj, op1));\n+\t  return gen_rtx_PLUS (mode, mod, adj);\n+\t}\n+      else\n+\t{\n+\t  rtx mod = gen_rtx_MOD (mode, op0, op1);\n+\t  rtx adj = round_sdiv_adjust (mode, mod, op1);\n+\t  adj = gen_rtx_NEG (mode, gen_rtx_MULT (mode, adj, op1));\n+\t  return gen_rtx_PLUS (mode, mod, adj);\n+\t}\n+\n+    case LSHIFT_EXPR:\n+      return gen_rtx_ASHIFT (mode, op0, op1);\n+\n+    case RSHIFT_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_LSHIFTRT (mode, op0, op1);\n+      else\n+\treturn gen_rtx_ASHIFTRT (mode, op0, op1);\n+\n+    case LROTATE_EXPR:\n+      return gen_rtx_ROTATE (mode, op0, op1);\n+\n+    case RROTATE_EXPR:\n+      return gen_rtx_ROTATERT (mode, op0, op1);\n+\n+    case MIN_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UMIN (mode, op0, op1);\n+      else\n+\treturn gen_rtx_SMIN (mode, op0, op1);\n+\n+    case MAX_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_UMAX (mode, op0, op1);\n+      else\n+\treturn gen_rtx_SMAX (mode, op0, op1);\n+\n+    case BIT_AND_EXPR:\n+    case TRUTH_AND_EXPR:\n+      return gen_rtx_AND (mode, op0, op1);\n+\n+    case BIT_IOR_EXPR:\n+    case TRUTH_OR_EXPR:\n+      return gen_rtx_IOR (mode, op0, op1);\n+\n+    case BIT_XOR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      return gen_rtx_XOR (mode, op0, op1);\n+\n+    case TRUTH_ANDIF_EXPR:\n+      return gen_rtx_IF_THEN_ELSE (mode, op0, op1, const0_rtx);\n+\n+    case TRUTH_ORIF_EXPR:\n+      return gen_rtx_IF_THEN_ELSE (mode, op0, const_true_rtx, op1);\n+\n+    case TRUTH_NOT_EXPR:\n+      return gen_rtx_EQ (mode, op0, const0_rtx);\n+\n+    case LT_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_LTU (mode, op0, op1);\n+      else\n+\treturn gen_rtx_LT (mode, op0, op1);\n+\n+    case LE_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_LEU (mode, op0, op1);\n+      else\n+\treturn gen_rtx_LE (mode, op0, op1);\n+\n+    case GT_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_GTU (mode, op0, op1);\n+      else\n+\treturn gen_rtx_GT (mode, op0, op1);\n+\n+    case GE_EXPR:\n+      if (unsignedp)\n+\treturn gen_rtx_GEU (mode, op0, op1);\n+      else\n+\treturn gen_rtx_GE (mode, op0, op1);\n+\n+    case EQ_EXPR:\n+      return gen_rtx_EQ (mode, op0, op1);\n+\n+    case NE_EXPR:\n+      return gen_rtx_NE (mode, op0, op1);\n+\n+    case UNORDERED_EXPR:\n+      return gen_rtx_UNORDERED (mode, op0, op1);\n+\n+    case ORDERED_EXPR:\n+      return gen_rtx_ORDERED (mode, op0, op1);\n+\n+    case UNLT_EXPR:\n+      return gen_rtx_UNLT (mode, op0, op1);\n+\n+    case UNLE_EXPR:\n+      return gen_rtx_UNLE (mode, op0, op1);\n+\n+    case UNGT_EXPR:\n+      return gen_rtx_UNGT (mode, op0, op1);\n+\n+    case UNGE_EXPR:\n+      return gen_rtx_UNGE (mode, op0, op1);\n+\n+    case UNEQ_EXPR:\n+      return gen_rtx_UNEQ (mode, op0, op1);\n+\n+    case LTGT_EXPR:\n+      return gen_rtx_LTGT (mode, op0, op1);\n+\n+    case COND_EXPR:\n+      return gen_rtx_IF_THEN_ELSE (mode, op0, op1, op2);\n+\n+    case COMPLEX_EXPR:\n+      gcc_assert (COMPLEX_MODE_P (mode));\n+      if (GET_MODE (op0) == VOIDmode)\n+\top0 = gen_rtx_CONST (GET_MODE_INNER (mode), op0);\n+      if (GET_MODE (op1) == VOIDmode)\n+\top1 = gen_rtx_CONST (GET_MODE_INNER (mode), op1);\n+      return gen_rtx_CONCAT (mode, op0, op1);\n+\n+    case ADDR_EXPR:\n+      op0 = expand_debug_expr (TREE_OPERAND (exp, 0));\n+      if (!op0 || !MEM_P (op0))\n+\treturn NULL;\n+\n+      return XEXP (op0, 0);\n+\n+    case VECTOR_CST:\n+      exp = build_constructor_from_list (TREE_TYPE (exp),\n+\t\t\t\t\t TREE_VECTOR_CST_ELTS (exp));\n+      /* Fall through.  */\n+\n+    case CONSTRUCTOR:\n+      if (TREE_CODE (TREE_TYPE (exp)) == VECTOR_TYPE)\n+\t{\n+\t  unsigned i;\n+\t  tree val;\n+\n+\t  op0 = gen_rtx_CONCATN\n+\t    (mode, rtvec_alloc (TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp))));\n+\n+\t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), i, val)\n+\t    {\n+\t      op1 = expand_debug_expr (val);\n+\t      if (!op1)\n+\t\treturn NULL;\n+\t      XVECEXP (op0, 0, i) = op1;\n+\t    }\n+\n+\t  if (i < TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp)))\n+\t    {\n+\t      op1 = expand_debug_expr\n+\t\t(fold_convert (TREE_TYPE (TREE_TYPE (exp)), integer_zero_node));\n+\n+\t      if (!op1)\n+\t\treturn NULL;\n+\n+\t      for (; i < TYPE_VECTOR_SUBPARTS (TREE_TYPE (exp)); i++)\n+\t\tXVECEXP (op0, 0, i) = op1;\n+\t    }\n+\n+\t  return op0;\n+\t}\n+      else\n+\tgoto flag_unsupported;\n+\n+    case CALL_EXPR:\n+      /* ??? Maybe handle some builtins?  */\n+      return NULL;\n+\n+    case SSA_NAME:\n+      {\n+\tint part = var_to_partition (SA.map, exp);\n+\n+\tif (part == NO_PARTITION)\n+\t  return NULL;\n+\n+\tgcc_assert (part >= 0 && (unsigned)part < SA.map->num_partitions);\n+\n+\top0 = SA.partition_to_pseudo[part];\n+\tgoto adjust_mode;\n+      }\n+\n+    case ERROR_MARK:\n+      return NULL;\n+\n+    default:\n+    flag_unsupported:\n+#ifdef ENABLE_CHECKING\n+      debug_tree (exp);\n+      gcc_unreachable ();\n+#else\n+      return NULL;\n+#endif\n+    }\n+}\n+\n+/* Expand the _LOCs in debug insns.  We run this after expanding all\n+   regular insns, so that any variables referenced in the function\n+   will have their DECL_RTLs set.  */\n+\n+static void\n+expand_debug_locations (void)\n+{\n+  rtx insn;\n+  rtx last = get_last_insn ();\n+  int save_strict_alias = flag_strict_aliasing;\n+\n+  /* New alias sets while setting up memory attributes cause\n+     -fcompare-debug failures, even though it doesn't bring about any\n+     codegen changes.  */\n+  flag_strict_aliasing = 0;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (DEBUG_INSN_P (insn))\n+      {\n+\ttree value = (tree)INSN_VAR_LOCATION_LOC (insn);\n+\trtx val;\n+\tenum machine_mode mode;\n+\n+\tif (value == NULL_TREE)\n+\t  val = NULL_RTX;\n+\telse\n+\t  {\n+\t    val = expand_debug_expr (value);\n+\t    gcc_assert (last == get_last_insn ());\n+\t  }\n+\n+\tif (!val)\n+\t  val = gen_rtx_UNKNOWN_VAR_LOC ();\n+\telse\n+\t  {\n+\t    mode = GET_MODE (INSN_VAR_LOCATION (insn));\n+\n+\t    gcc_assert (mode == GET_MODE (val)\n+\t\t\t|| (GET_MODE (val) == VOIDmode\n+\t\t\t    && (CONST_INT_P (val)\n+\t\t\t\t|| GET_CODE (val) == CONST_FIXED\n+\t\t\t\t|| GET_CODE (val) == CONST_DOUBLE\n+\t\t\t\t|| GET_CODE (val) == LABEL_REF)));\n+\t  }\n+\n+\tINSN_VAR_LOCATION_LOC (insn) = val;\n+      }\n+\n+  flag_strict_aliasing = save_strict_alias;\n+}\n+\n /* Expand basic block BB from GIMPLE trees to RTL.  */\n \n static basic_block\n@@ -2234,9 +3043,10 @@ expand_gimple_basic_block (basic_block bb)\n \n   for (; !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n       basic_block new_bb;\n \n+      stmt = gsi_stmt (gsi);\n+\n       /* Expand this statement, then evaluate the resulting RTL and\n \t fixup the CFG accordingly.  */\n       if (gimple_code (stmt) == GIMPLE_COND)\n@@ -2245,6 +3055,60 @@ expand_gimple_basic_block (basic_block bb)\n \t  if (new_bb)\n \t    return new_bb;\n \t}\n+      else if (gimple_debug_bind_p (stmt))\n+\t{\n+\t  location_t sloc = get_curr_insn_source_location ();\n+\t  tree sblock = get_curr_insn_block ();\n+\t  gimple_stmt_iterator nsi = gsi;\n+\n+\t  for (;;)\n+\t    {\n+\t      tree var = gimple_debug_bind_get_var (stmt);\n+\t      tree value;\n+\t      rtx val;\n+\t      enum machine_mode mode;\n+\n+\t      if (gimple_debug_bind_has_value_p (stmt))\n+\t\tvalue = gimple_debug_bind_get_value (stmt);\n+\t      else\n+\t\tvalue = NULL_TREE;\n+\n+\t      last = get_last_insn ();\n+\n+\t      set_curr_insn_source_location (gimple_location (stmt));\n+\t      set_curr_insn_block (gimple_block (stmt));\n+\n+\t      if (DECL_P (var))\n+\t\tmode = DECL_MODE (var);\n+\t      else\n+\t\tmode = TYPE_MODE (TREE_TYPE (var));\n+\n+\t      val = gen_rtx_VAR_LOCATION\n+\t\t(mode, var, (rtx)value, VAR_INIT_STATUS_INITIALIZED);\n+\n+\t      val = emit_debug_insn (val);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  /* We can't dump the insn with a TREE where an RTX\n+\t\t     is expected.  */\n+\t\t  INSN_VAR_LOCATION_LOC (val) = const0_rtx;\n+\t\t  maybe_dump_rtl_for_gimple_stmt (stmt, last);\n+\t\t  INSN_VAR_LOCATION_LOC (val) = (rtx)value;\n+\t\t}\n+\n+\t      gsi = nsi;\n+\t      gsi_next (&nsi);\n+\t      if (gsi_end_p (nsi))\n+\t\tbreak;\n+\t      stmt = gsi_stmt (nsi);\n+\t      if (!gimple_debug_bind_p (stmt))\n+\t\tbreak;\n+\t    }\n+\n+\t  set_curr_insn_source_location (sloc);\n+\t  set_curr_insn_block (sblock);\n+\t}\n       else\n \t{\n \t  if (is_gimple_call (stmt) && gimple_call_tail_p (stmt))\n@@ -2718,6 +3582,9 @@ gimple_expand_cfg (void)\n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n     bb = expand_gimple_basic_block (bb);\n \n+  if (MAY_HAVE_DEBUG_INSNS)\n+    expand_debug_locations ();\n+\n   execute_free_datastructures ();\n   finish_out_of_ssa (&SA);\n "}, {"sha": "ca400a8c503e82b530c878a51e172db19026aa29", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -238,7 +238,7 @@ int epilogue_locator;\n /* Hold current location information and last location information, so the\n    datastructures are built lazily only when some instructions in given\n    place are needed.  */\n-location_t curr_location, last_location;\n+static location_t curr_location, last_location;\n static tree curr_block, last_block;\n static int curr_rtl_loc = -1;\n \n@@ -290,12 +290,17 @@ set_curr_insn_source_location (location_t location)\n      time locators are not initialized.  */\n   if (curr_rtl_loc == -1)\n     return;\n-  if (location == last_location)\n-    return;\n   curr_location = location;\n }\n \n-/* Set current scope block. */\n+/* Get current location.  */\n+location_t\n+get_curr_insn_source_location (void)\n+{\n+  return curr_location;\n+}\n+\n+/* Set current scope block.  */\n void\n set_curr_insn_block (tree b)\n {\n@@ -307,6 +312,13 @@ set_curr_insn_block (tree b)\n     curr_block = b;\n }\n \n+/* Get current scope block.  */\n+tree\n+get_curr_insn_block (void)\n+{\n+  return curr_block;\n+}\n+\n /* Return current insn locator.  */\n int\n curr_insn_locator (void)\n@@ -1120,6 +1132,7 @@ duplicate_insn_chain (rtx from, rtx to)\n     {\n       switch (GET_CODE (insn))\n \t{\n+\tcase DEBUG_INSN:\n \tcase INSN:\n \tcase CALL_INSN:\n \tcase JUMP_INSN:"}, {"sha": "33aff6dbcebf24c7eb2b0a40bf379fd08b9d4b73", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -176,8 +176,8 @@ num_loop_insns (const struct loop *loop)\n     {\n       bb = bbs[i];\n       ninsns++;\n-      for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n-\tif (INSN_P (insn))\n+      FOR_BB_INSNS (bb, insn)\n+\tif (NONDEBUG_INSN_P (insn))\n \t  ninsns++;\n     }\n   free(bbs);\n@@ -199,9 +199,9 @@ average_num_loop_insns (const struct loop *loop)\n     {\n       bb = bbs[i];\n \n-      binsns = 1;\n-      for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n-\tif (INSN_P (insn))\n+      binsns = 0;\n+      FOR_BB_INSNS (bb, insn)\n+\tif (NONDEBUG_INSN_P (insn))\n \t  binsns++;\n \n       ratio = loop->header->frequency == 0"}, {"sha": "4c4b3b72cc76acf6de88bb02e613033881c9785d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -531,7 +531,26 @@ rtl_split_block (basic_block bb, void *insnp)\n       insn = first_insn_after_basic_block_note (bb);\n \n       if (insn)\n-\tinsn = PREV_INSN (insn);\n+\t{\n+\t  rtx next = insn;\n+\n+\t  insn = PREV_INSN (insn);\n+\n+\t  /* If the block contains only debug insns, insn would have\n+\t     been NULL in a non-debug compilation, and then we'd end\n+\t     up emitting a DELETED note.  For -fcompare-debug\n+\t     stability, emit the note too.  */\n+\t  if (insn != BB_END (bb)\n+\t      && DEBUG_INSN_P (next)\n+\t      && DEBUG_INSN_P (BB_END (bb)))\n+\t    {\n+\t      while (next != BB_END (bb) && DEBUG_INSN_P (next))\n+\t\tnext = NEXT_INSN (next);\n+\n+\t      if (next == BB_END (bb))\n+\t\temit_note_after (NOTE_INSN_DELETED, next);\n+\t    }\n+\t}\n       else\n \tinsn = get_last_insn ();\n     }\n@@ -566,11 +585,15 @@ rtl_merge_blocks (basic_block a, basic_block b)\n {\n   rtx b_head = BB_HEAD (b), b_end = BB_END (b), a_end = BB_END (a);\n   rtx del_first = NULL_RTX, del_last = NULL_RTX;\n+  rtx b_debug_start = b_end, b_debug_end = b_end;\n   int b_empty = 0;\n \n   if (dump_file)\n     fprintf (dump_file, \"merging block %d into block %d\\n\", b->index, a->index);\n \n+  while (DEBUG_INSN_P (b_end))\n+    b_end = PREV_INSN (b_debug_start = b_end);\n+\n   /* If there was a CODE_LABEL beginning B, delete it.  */\n   if (LABEL_P (b_head))\n     {\n@@ -636,9 +659,21 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n     {\n-      update_bb_for_insn_chain (a_end, b_end, a);\n+      update_bb_for_insn_chain (a_end, b_debug_end, a);\n \n-      a_end = b_end;\n+      a_end = b_debug_end;\n+    }\n+  else if (b_end != b_debug_end)\n+    {\n+      /* Move any deleted labels and other notes between the end of A\n+\t and the debug insns that make up B after the debug insns,\n+\t bringing the debug insns into A while keeping the notes after\n+\t the end of A.  */\n+      if (NEXT_INSN (a_end) != b_debug_start)\n+\treorder_insns_nobb (NEXT_INSN (a_end), PREV_INSN (b_debug_start),\n+\t\t\t    b_debug_end);\n+      update_bb_for_insn_chain (b_debug_start, b_debug_end, a);\n+      a_end = b_debug_end;\n     }\n \n   df_bb_delete (b->index);\n@@ -2162,6 +2197,11 @@ purge_dead_edges (basic_block bb)\n   bool found;\n   edge_iterator ei;\n \n+  if (DEBUG_INSN_P (insn) && insn != BB_HEAD (bb))\n+    do\n+      insn = PREV_INSN (insn);\n+    while ((DEBUG_INSN_P (insn) || NOTE_P (insn)) && insn != BB_HEAD (bb));\n+\n   /* If this instruction cannot trap, remove REG_EH_REGION notes.  */\n   if (NONJUMP_INSN_P (insn)\n       && (note = find_reg_note (insn, REG_EH_REGION, NULL)))\n@@ -2182,18 +2222,18 @@ purge_dead_edges (basic_block bb)\n \t latter can appear when nonlocal gotos are used.  */\n       if (e->flags & EDGE_EH)\n \t{\n-\t  if (can_throw_internal (BB_END (bb))\n+\t  if (can_throw_internal (insn)\n \t      /* If this is a call edge, verify that this is a call insn.  */\n \t      && (! (e->flags & EDGE_ABNORMAL_CALL)\n-\t\t  || CALL_P (BB_END (bb))))\n+\t\t  || CALL_P (insn)))\n \t    {\n \t      ei_next (&ei);\n \t      continue;\n \t    }\n \t}\n       else if (e->flags & EDGE_ABNORMAL_CALL)\n \t{\n-\t  if (CALL_P (BB_END (bb))\n+\t  if (CALL_P (insn)\n \t      && (! (note = find_reg_note (insn, REG_EH_REGION, NULL))\n \t\t  || INTVAL (XEXP (note, 0)) >= 0))\n \t    {\n@@ -2771,7 +2811,8 @@ rtl_block_ends_with_call_p (basic_block bb)\n   while (!CALL_P (insn)\n \t && insn != BB_HEAD (bb)\n \t && (keep_with_call_p (insn)\n-\t     || NOTE_P (insn)))\n+\t     || NOTE_P (insn)\n+\t     || DEBUG_INSN_P (insn)))\n     insn = PREV_INSN (insn);\n   return (CALL_P (insn));\n }"}, {"sha": "bc61fbedcf43b80eed1034ee0b769779957f2546", "filename": "gcc/combine.c", "status": "modified", "additions": 313, "deletions": 9, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -921,7 +921,7 @@ create_log_links (void)\n     {\n       FOR_BB_INSNS_REVERSE (bb, insn)\n         {\n-          if (!INSN_P (insn))\n+          if (!NONDEBUG_INSN_P (insn))\n             continue;\n \n \t  /* Log links are created only once.  */\n@@ -1129,7 +1129,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \t   insn = next ? next : NEXT_INSN (insn))\n \t{\n \t  next = 0;\n-\t  if (INSN_P (insn))\n+\t  if (NONDEBUG_INSN_P (insn))\n \t    {\n \t      /* See if we know about function return values before this\n \t\t insn based upon SUBREG flags.  */\n@@ -2161,6 +2161,209 @@ reg_subword_p (rtx x, rtx reg)\n \t && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT;\n }\n \n+#ifdef AUTO_INC_DEC\n+/* Replace auto-increment addressing modes with explicit operations to\n+   access the same addresses without modifying the corresponding\n+   registers.  If AFTER holds, SRC is meant to be reused after the\n+   side effect, otherwise it is to be reused before that.  */\n+\n+static rtx\n+cleanup_auto_inc_dec (rtx src, bool after, enum machine_mode mem_mode)\n+{\n+  rtx x = src;\n+  const RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST_FIXED:\n+    case CONST_VECTOR:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+      /* SCRATCH must be shared because they represent distinct values.  */\n+      return x;\n+    case CLOBBER:\n+      if (REG_P (XEXP (x, 0)) && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n+\treturn x;\n+      break;\n+\n+    case CONST:\n+      if (shared_const_p (x))\n+\treturn x;\n+      break;\n+\n+    case MEM:\n+      mem_mode = GET_MODE (x);\n+      break;\n+\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case POST_INC:\n+    case POST_DEC:\n+      gcc_assert (mem_mode != VOIDmode && mem_mode != BLKmode);\n+      if (after == (code == PRE_INC || code == PRE_DEC))\n+\tx = cleanup_auto_inc_dec (XEXP (x, 0), after, mem_mode);\n+      else\n+\tx = gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t  cleanup_auto_inc_dec (XEXP (x, 0), after, mem_mode),\n+\t\t\t  GEN_INT ((code == PRE_INC || code == POST_INC)\n+\t\t\t\t   ? GET_MODE_SIZE (mem_mode)\n+\t\t\t\t   : -GET_MODE_SIZE (mem_mode)));\n+      return x;\n+\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      if (after == (code == PRE_MODIFY))\n+\tx = XEXP (x, 0);\n+      else\n+\tx = XEXP (x, 1);\n+      return cleanup_auto_inc_dec (x, after, mem_mode);\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Copy the various flags, fields, and other information.  We assume\n+     that all fields need copying, and then clear the fields that should\n+     not be copied.  That is the sensible default behavior, and forces\n+     us to explicitly document why we are *not* copying a flag.  */\n+  x = shallow_copy_rtx (x);\n+\n+  /* We do not copy the USED flag, which is used as a mark bit during\n+     walks over the RTL.  */\n+  RTX_FLAG (x, used) = 0;\n+\n+  /* We do not copy FRAME_RELATED for INSNs.  */\n+  if (INSN_P (x))\n+    RTX_FLAG (x, frame_related) = 0;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      XEXP (x, i) = cleanup_auto_inc_dec (XEXP (x, i), after, mem_mode);\n+    else if (fmt[i] == 'E' || fmt[i] == 'V')\n+      {\n+\tint j;\n+\tXVEC (x, i) = rtvec_alloc (XVECLEN (x, i));\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  XVECEXP (x, i, j)\n+\t    = cleanup_auto_inc_dec (XVECEXP (src, i, j), after, mem_mode);\n+      }\n+\n+  return x;\n+}\n+#endif\n+\n+/* Auxiliary data structure for propagate_for_debug_stmt.  */\n+\n+struct rtx_subst_pair\n+{\n+  rtx from, to;\n+  bool changed;\n+#ifdef AUTO_INC_DEC\n+  bool adjusted;\n+  bool after;\n+#endif\n+};\n+\n+/* Clean up any auto-updates in PAIR->to the first time it is called\n+   for a PAIR.  PAIR->adjusted is used to tell whether we've cleaned\n+   up before.  */\n+\n+static void\n+auto_adjust_pair (struct rtx_subst_pair *pair ATTRIBUTE_UNUSED)\n+{\n+#ifdef AUTO_INC_DEC\n+  if (!pair->adjusted)\n+    {\n+      pair->adjusted = true;\n+      pair->to = cleanup_auto_inc_dec (pair->to, pair->after, VOIDmode);\n+    }\n+#endif\n+}\n+\n+/* If *LOC is the same as FROM in the struct rtx_subst_pair passed as\n+   DATA, replace it with a copy of TO.  Handle SUBREGs of *LOC as\n+   well.  */\n+\n+static int\n+propagate_for_debug_subst (rtx *loc, void *data)\n+{\n+  struct rtx_subst_pair *pair = (struct rtx_subst_pair *)data;\n+  rtx from = pair->from, to = pair->to;\n+  rtx x = *loc, s = x;\n+\n+  if (rtx_equal_p (x, from)\n+      || (GET_CODE (x) == SUBREG && rtx_equal_p ((s = SUBREG_REG (x)), from)))\n+    {\n+      auto_adjust_pair (pair);\n+      if (pair->to != to)\n+\tto = pair->to;\n+      else\n+\tto = copy_rtx (to);\n+      if (s != x)\n+\t{\n+\t  gcc_assert (GET_CODE (x) == SUBREG && SUBREG_REG (x) == s);\n+\t  to = simplify_gen_subreg (GET_MODE (x), to,\n+\t\t\t\t    GET_MODE (from), SUBREG_BYTE (x));\n+\t}\n+      *loc = to;\n+      pair->changed = true;\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Replace occurrences of DEST with SRC in DEBUG_INSNs between INSN\n+   and LAST.  If MOVE holds, debug insns must also be moved past\n+   LAST.  */\n+\n+static void\n+propagate_for_debug (rtx insn, rtx last, rtx dest, rtx src, bool move)\n+{\n+  struct rtx_subst_pair p;\n+  rtx next, move_pos = move ? last : NULL_RTX;\n+\n+  p.from = dest;\n+  p.to = src;\n+  p.changed = false;\n+\n+#ifdef AUTO_INC_DEC\n+  p.adjusted = false;\n+  p.after = move;\n+#endif\n+\n+  next = NEXT_INSN (insn);\n+  while (next != last)\n+    {\n+      insn = next;\n+      next = NEXT_INSN (insn);\n+      if (DEBUG_INSN_P (insn))\n+\t{\n+\t  for_each_rtx (&INSN_VAR_LOCATION_LOC (insn),\n+\t\t\tpropagate_for_debug_subst, &p);\n+\t  if (!p.changed)\n+\t    continue;\n+\t  p.changed = false;\n+\t  if (move_pos)\n+\t    {\n+\t      remove_insn (insn);\n+\t      PREV_INSN (insn) = NEXT_INSN (insn) = NULL_RTX;\n+\t      move_pos = emit_debug_insn_after (insn, move_pos);\n+\t    }\n+\t  else\n+\t    df_insn_rescan (insn);\n+\t}\n+    }\n+}\n \n /* Delete the conditional jump INSN and adjust the CFG correspondingly.\n    Note that the INSN should be deleted *after* removing dead edges, so\n@@ -2217,7 +2420,9 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      I2 and not in I3, a REG_DEAD note must be made.  */\n   rtx i3dest_killed = 0;\n   /* SET_DEST and SET_SRC of I2 and I1.  */\n-  rtx i2dest, i2src, i1dest = 0, i1src = 0;\n+  rtx i2dest = 0, i2src = 0, i1dest = 0, i1src = 0;\n+  /* Set if I2DEST was reused as a scratch register.  */\n+  bool i2scratch = false;\n   /* PATTERN (I1) and PATTERN (I2), or a copy of it in certain cases.  */\n   rtx i1pat = 0, i2pat = 0;\n   /* Indicates if I2DEST or I1DEST is in I2SRC or I1_SRC.  */\n@@ -2301,7 +2506,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       && GET_CODE (SET_DEST (PATTERN (i3))) != STRICT_LOW_PART\n       && ! reg_overlap_mentioned_p (SET_SRC (PATTERN (i3)),\n \t\t\t\t    SET_DEST (PATTERN (i3)))\n-      && next_real_insn (i2) == i3)\n+      && next_active_insn (i2) == i3)\n     {\n       rtx p2 = PATTERN (i2);\n \n@@ -2334,6 +2539,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t      subst_low_luid = DF_INSN_LUID (i2);\n \n \t      added_sets_2 = added_sets_1 = 0;\n+\t      i2src = SET_DEST (PATTERN (i3));\n \t      i2dest = SET_SRC (PATTERN (i3));\n \t      i2dest_killed = dead_or_set_p (i2, i2dest);\n \n@@ -3006,6 +3212,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t  undobuf.frees = buf;\n \t\t}\n \t    }\n+\n+\t  i2scratch = m_split != 0;\n \t}\n \n       /* If recog_for_combine has discarded clobbers, try to use them\n@@ -3100,6 +3308,8 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  bool subst_done = false;\n \t  newi2pat = NULL_RTX;\n \n+\t  i2scratch = true;\n+\n \t  /* Get NEWDEST as a register in the proper mode.  We have already\n \t     validated that we can do this.  */\n \t  if (GET_MODE (i2dest) != split_mode && split_mode != VOIDmode)\n@@ -3402,6 +3612,67 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       return 0;\n     }\n \n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      struct undo *undo;\n+\n+      for (undo = undobuf.undos; undo; undo = undo->next)\n+\tif (undo->kind == UNDO_MODE)\n+\t  {\n+\t    rtx reg = *undo->where.r;\n+\t    enum machine_mode new_mode = GET_MODE (reg);\n+\t    enum machine_mode old_mode = undo->old_contents.m;\n+\n+\t    /* Temporarily revert mode back.  */\n+\t    adjust_reg_mode (reg, old_mode);\n+\n+\t    if (reg == i2dest && i2scratch)\n+\t      {\n+\t\t/* If we used i2dest as a scratch register with a\n+\t\t   different mode, substitute it for the original\n+\t\t   i2src while its original mode is temporarily\n+\t\t   restored, and then clear i2scratch so that we don't\n+\t\t   do it again later.  */\n+\t\tpropagate_for_debug (i2, i3, reg, i2src, false);\n+\t\ti2scratch = false;\n+\t\t/* Put back the new mode.  */\n+\t\tadjust_reg_mode (reg, new_mode);\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx tempreg = gen_raw_REG (old_mode, REGNO (reg));\n+\t\trtx first, last;\n+\n+\t\tif (reg == i2dest)\n+\t\t  {\n+\t\t    first = i2;\n+\t\t    last = i3;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    first = i3;\n+\t\t    last = undobuf.other_insn;\n+\t\t    gcc_assert (last);\n+\t\t  }\n+\n+\t\t/* We're dealing with a reg that changed mode but not\n+\t\t   meaning, so we want to turn it into a subreg for\n+\t\t   the new mode.  However, because of REG sharing and\n+\t\t   because its mode had already changed, we have to do\n+\t\t   it in two steps.  First, replace any debug uses of\n+\t\t   reg, with its original mode temporarily restored,\n+\t\t   with this copy we have created; then, replace the\n+\t\t   copy with the SUBREG of the original shared reg,\n+\t\t   once again changed to the new mode.  */\n+\t\tpropagate_for_debug (first, last, reg, tempreg, false);\n+\t\tadjust_reg_mode (reg, new_mode);\n+\t\tpropagate_for_debug (first, last, tempreg,\n+\t\t\t\t     lowpart_subreg (old_mode, reg, new_mode),\n+\t\t\t\t     false);\n+\t      }\n+\t  }\n+    }\n+\n   /* If we will be able to accept this, we have made a\n      change to the destination of I3.  This requires us to\n      do a few adjustments.  */\n@@ -3592,16 +3863,24 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \n     if (newi2pat)\n       {\n+\tif (MAY_HAVE_DEBUG_INSNS && i2scratch)\n+\t  propagate_for_debug (i2, i3, i2dest, i2src, false);\n \tINSN_CODE (i2) = i2_code_number;\n \tPATTERN (i2) = newi2pat;\n       }\n     else\n-      SET_INSN_DELETED (i2);\n+      {\n+\tif (MAY_HAVE_DEBUG_INSNS && i2src)\n+\t  propagate_for_debug (i2, i3, i2dest, i2src, i3_subst_into_i2);\n+\tSET_INSN_DELETED (i2);\n+      }\n \n     if (i1)\n       {\n \tLOG_LINKS (i1) = 0;\n \tREG_NOTES (i1) = 0;\n+\tif (MAY_HAVE_DEBUG_INSNS)\n+\t  propagate_for_debug (i1, i3, i1dest, i1src, false);\n \tSET_INSN_DELETED (i1);\n       }\n \n@@ -12396,6 +12675,29 @@ reg_bitfield_target_p (rtx x, rtx body)\n \n   return 0;\n }\n+\n+/* Return the next insn after INSN that is neither a NOTE nor a\n+   DEBUG_INSN.  This routine does not look inside SEQUENCEs.  */\n+\n+static rtx\n+next_nonnote_nondebug_insn (rtx insn)\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0)\n+\tbreak;\n+      if (NOTE_P (insn))\n+\tcontinue;\n+      if (DEBUG_INSN_P (insn))\n+\tcontinue;\n+      break;\n+    }\n+\n+  return insn;\n+}\n+\n+\n \f\n /* Given a chain of REG_NOTES originally from FROM_INSN, try to place them\n    as appropriate.  I3 and I2 are the insns resulting from the combination\n@@ -12649,7 +12951,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\tplace = from_insn;\n \t      else if (reg_referenced_p (XEXP (note, 0), PATTERN (i3)))\n \t\tplace = i3;\n-\t      else if (i2 != 0 && next_nonnote_insn (i2) == i3\n+\t      else if (i2 != 0 && next_nonnote_nondebug_insn (i2) == i3\n \t\t       && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n \t\tplace = i2;\n \t      else if ((rtx_equal_p (XEXP (note, 0), elim_i2)\n@@ -12667,7 +12969,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \n \t      for (tem = PREV_INSN (tem); place == 0; tem = PREV_INSN (tem))\n \t\t{\n-\t\t  if (! INSN_P (tem))\n+\t\t  if (!NONDEBUG_INSN_P (tem))\n \t\t    {\n \t\t      if (tem == BB_HEAD (bb))\n \t\t\tbreak;\n@@ -12868,7 +13170,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t\t\t    for (tem = PREV_INSN (place); ;\n \t\t\t\t tem = PREV_INSN (tem))\n \t\t\t      {\n-\t\t\t\tif (! INSN_P (tem))\n+\t\t\t\tif (!NONDEBUG_INSN_P (tem))\n \t\t\t\t  {\n \t\t\t\t    if (tem == BB_HEAD (bb))\n \t\t\t \t      break;\n@@ -12958,7 +13260,9 @@ distribute_links (rtx links)\n \t   (insn && (this_basic_block->next_bb == EXIT_BLOCK_PTR\n \t\t     || BB_HEAD (this_basic_block->next_bb) != insn));\n \t   insn = NEXT_INSN (insn))\n-\tif (INSN_P (insn) && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+\tif (DEBUG_INSN_P (insn))\n+\t  continue;\n+\telse if (INSN_P (insn) && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n \t  {\n \t    if (reg_referenced_p (reg, PATTERN (insn)))\n \t      place = insn;"}, {"sha": "8fe512a76e24b0bf687868d6365cc7105841a25a", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -380,10 +380,6 @@ fcommon\n Common Report Var(flag_no_common,0) Optimization\n Do not put uninitialized globals in the common section\n \n-fconserve-stack\n-Common Var(flag_conserve_stack) Optimization\n-Do not perform optimizations increasing noticeably stack usage\n-\n fcompare-debug=\n Common JoinedOrMissing RejectNegative Var(flag_compare_debug_opt)\n -fcompare-debug[=<opts>] Compile with and without e.g. -gtoggle, and compare the final-insns dump\n@@ -392,6 +388,10 @@ fcompare-debug-second\n Common RejectNegative Var(flag_compare_debug)\n Run only the second compilation of -fcompare-debug\n \n+fconserve-stack\n+Common Var(flag_conserve_stack) Optimization\n+Do not perform optimizations increasing noticeably stack usage\n+\n fcprop-registers\n Common Report Var(flag_cprop_registers) Optimization\n Perform a register copy-propagation optimization pass\n@@ -470,14 +470,14 @@ fdump-unnumbered\n Common Report Var(flag_dump_unnumbered) VarExists\n Suppress output of instruction numbers, line number notes and addresses in debugging dumps\n \n-fdwarf2-cfi-asm\n-Common Report Var(flag_dwarf2_cfi_asm) Init(HAVE_GAS_CFI_DIRECTIVE)\n-Enable CFI tables via GAS assembler directives.\n-\n fdump-unnumbered-links\n Common Report Var(flag_dump_unnumbered_links) VarExists\n Suppress output of previous and next insn numbers in debugging dumps\n \n+fdwarf2-cfi-asm\n+Common Report Var(flag_dwarf2_cfi_asm) Init(HAVE_GAS_CFI_DIRECTIVE)\n+Enable CFI tables via GAS assembler directives.\n+\n fearly-inlining\n Common Report Var(flag_early_inlining) Init(1) Optimization\n Perform early inlining\n@@ -1369,6 +1369,14 @@ fvar-tracking\n Common Report Var(flag_var_tracking) VarExists Optimization\n Perform variable tracking\n \n+fvar-tracking-assignments\n+Common Report Var(flag_var_tracking_assignments) VarExists Optimization\n+Perform variable tracking by annotating assignments\n+\n+fvar-tracking-assignments-toggle\n+Common Report Var(flag_var_tracking_assignments_toggle) VarExists Optimization\n+Toggle -fvar-tracking-assignments\n+\n fvar-tracking-uninit\n Common Report Var(flag_var_tracking_uninit) Optimization\n Perform variable tracking and also tag variables that are uninitialized"}, {"sha": "ccb5e2f1459b1868211c55e742e3edf0f683eacc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -10752,16 +10752,18 @@ ix86_pic_register_p (rtx x)\n    the DWARF output code.  */\n \n static rtx\n-ix86_delegitimize_address (rtx orig_x)\n+ix86_delegitimize_address (rtx x)\n {\n-  rtx x = orig_x;\n+  rtx orig_x = delegitimize_mem_from_attrs (x);\n   /* reg_addend is NULL or a multiple of some register.  */\n   rtx reg_addend = NULL_RTX;\n   /* const_addend is NULL or a const_int.  */\n   rtx const_addend = NULL_RTX;\n   /* This is the result, or NULL.  */\n   rtx result = NULL_RTX;\n \n+  x = orig_x;\n+\n   if (MEM_P (x))\n     x = XEXP (x, 0);\n "}, {"sha": "7e75752338185afc7b4a9a1ae571ec39f79d0dca", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -5521,6 +5521,8 @@ ia64_safe_itanium_class (rtx insn)\n {\n   if (recog_memoized (insn) >= 0)\n     return get_attr_itanium_class (insn);\n+  else if (DEBUG_INSN_P (insn))\n+    return ITANIUM_CLASS_IGNORE;\n   else\n     return ITANIUM_CLASS_UNKNOWN;\n }\n@@ -6277,6 +6279,7 @@ group_barrier_needed (rtx insn)\n   switch (GET_CODE (insn))\n     {\n     case NOTE:\n+    case DEBUG_INSN:\n       break;\n \n     case BARRIER:\n@@ -6434,7 +6437,7 @@ emit_insn_group_barriers (FILE *dump)\n \t  init_insn_group_barriers ();\n \t  last_label = 0;\n \t}\n-      else if (INSN_P (insn))\n+      else if (NONDEBUG_INSN_P (insn))\n \t{\n \t  insns_since_last_label = 1;\n \n@@ -6482,7 +6485,7 @@ emit_all_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \n \t  init_insn_group_barriers ();\n \t}\n-      else if (INSN_P (insn))\n+      else if (NONDEBUG_INSN_P (insn))\n \t{\n \t  if (recog_memoized (insn) == CODE_FOR_insn_group_barrier)\n \t    init_insn_group_barriers ();\n@@ -6975,6 +6978,9 @@ ia64_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n \tpending_data_specs--;\n     }\n \n+  if (DEBUG_INSN_P (insn))\n+    return 1;\n+\n   last_scheduled_insn = insn;\n   memcpy (prev_cycle_state, curr_state, dfa_state_size);\n   if (reload_completed)\n@@ -7057,6 +7063,10 @@ ia64_dfa_new_cycle (FILE *dump, int verbose, rtx insn, int last_clock,\n   int setup_clocks_p = FALSE;\n \n   gcc_assert (insn && INSN_P (insn));\n+\n+  if (DEBUG_INSN_P (insn))\n+    return 0;\n+\n   /* When a group barrier is needed for insn, last_scheduled_insn\n      should be set.  */\n   gcc_assert (!(reload_completed && safe_group_barrier_needed (insn))\n@@ -9043,7 +9053,7 @@ final_emit_insn_group_barriers (FILE *dump ATTRIBUTE_UNUSED)\n \t  need_barrier_p = 0;\n \t  prev_insn = NULL_RTX;\n \t}\n-      else if (INSN_P (insn))\n+      else if (NONDEBUG_INSN_P (insn))\n \t{\n \t  if (recog_memoized (insn) == CODE_FOR_insn_group_barrier)\n \t    {\n@@ -9605,15 +9615,18 @@ ia64_emit_deleted_label_after_insn (rtx insn)\n /* Define the CFA after INSN with the steady-state definition.  */\n \n static void\n-ia64_dwarf2out_def_steady_cfa (rtx insn)\n+ia64_dwarf2out_def_steady_cfa (rtx insn, bool frame)\n {\n   rtx fp = frame_pointer_needed\n     ? hard_frame_pointer_rtx\n     : stack_pointer_rtx;\n+  const char *label = ia64_emit_deleted_label_after_insn (insn);\n+\n+  if (!frame)\n+    return;\n \n   dwarf2out_def_cfa\n-    (ia64_emit_deleted_label_after_insn (insn),\n-     REGNO (fp),\n+    (label, REGNO (fp),\n      ia64_initial_elimination_offset\n      (REGNO (arg_pointer_rtx), REGNO (fp))\n      + ARG_POINTER_CFA_OFFSET (current_function_decl));\n@@ -9706,8 +9719,7 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n \t      if (unwind)\n \t\tfprintf (asm_out_file, \"\\t.fframe \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t\t\t -INTVAL (op1));\n-\t      if (frame)\n-\t\tia64_dwarf2out_def_steady_cfa (insn);\n+\t      ia64_dwarf2out_def_steady_cfa (insn, frame);\n \t    }\n \t  else\n \t    process_epilogue (asm_out_file, insn, unwind, frame);\n@@ -9765,8 +9777,7 @@ process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n \t  if (unwind)\n \t    fprintf (asm_out_file, \"\\t.vframe r%d\\n\",\n \t\t     ia64_dbx_register_number (dest_regno));\n-\t  if (frame)\n-\t    ia64_dwarf2out_def_steady_cfa (insn);\n+\t  ia64_dwarf2out_def_steady_cfa (insn, frame);\n \t  return 1;\n \n \tdefault:\n@@ -9911,8 +9922,8 @@ process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n \t\t  fprintf (asm_out_file, \"\\t.copy_state %d\\n\",\n \t\t\t   cfun->machine->state_num);\n \t\t}\n-\t      if (IA64_CHANGE_CFA_IN_EPILOGUE && frame)\n-\t\tia64_dwarf2out_def_steady_cfa (insn);\n+\t      if (IA64_CHANGE_CFA_IN_EPILOGUE)\n+\t\tia64_dwarf2out_def_steady_cfa (insn, frame);\n \t      need_copy_state = false;\n \t    }\n \t}"}, {"sha": "40d83900bc9e3ce421cb59bbc0cac0d9940477ef", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -979,6 +979,7 @@ static void rs6000_init_dwarf_reg_sizes_extra (tree);\n static rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n static rtx rs6000_debug_legitimize_address (rtx, rtx, enum machine_mode);\n static rtx rs6000_legitimize_tls_address (rtx, enum tls_model);\n+static rtx rs6000_delegitimize_address (rtx);\n static void rs6000_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static rtx rs6000_tls_get_addr (void);\n static rtx rs6000_got_sym (void);\n@@ -1436,6 +1437,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n #define TARGET_USE_BLOCKS_FOR_CONSTANT_P rs6000_use_blocks_for_constant_p\n \n+#undef TARGET_DELEGITIMIZE_ADDRESS\n+#define TARGET_DELEGITIMIZE_ADDRESS rs6000_delegitimize_address\n+\n #undef TARGET_BUILTIN_RECIPROCAL\n #define TARGET_BUILTIN_RECIPROCAL rs6000_builtin_reciprocal\n \n@@ -5080,6 +5084,33 @@ rs6000_debug_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n   return ret;\n }\n \n+/* If ORIG_X is a constant pool reference, return its known value,\n+   otherwise ORIG_X.  */\n+\n+static rtx\n+rs6000_delegitimize_address (rtx x)\n+{\n+  rtx orig_x = delegitimize_mem_from_attrs (x);\n+\n+  x = orig_x;\n+\n+  if (!MEM_P (x))\n+    return orig_x;\n+\n+  x = XEXP (x, 0);\n+\n+  if (legitimate_constant_pool_address_p (x)\n+      && GET_CODE (XEXP (x, 1)) == CONST\n+      && GET_CODE (XEXP (XEXP (x, 1), 0)) == MINUS\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 1), 0), 0)) == SYMBOL_REF\n+      && constant_pool_expr_p (XEXP (XEXP (XEXP (x, 1), 0), 0))\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 1), 0), 1)) == SYMBOL_REF\n+      && toc_relative_expr_p (XEXP (XEXP (XEXP (x, 1), 0), 1)))\n+    return get_pool_constant (XEXP (XEXP (XEXP (x, 1), 0), 0));\n+\n+  return orig_x;\n+}\n+\n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */\n \n@@ -21304,7 +21335,7 @@ rs6000_debug_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n static bool\n is_microcoded_insn (rtx insn)\n {\n-  if (!insn || !INSN_P (insn)\n+  if (!insn || !NONDEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n@@ -21332,7 +21363,7 @@ is_microcoded_insn (rtx insn)\n static bool\n is_cracked_insn (rtx insn)\n {\n-  if (!insn || !INSN_P (insn)\n+  if (!insn || !NONDEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n@@ -21360,7 +21391,7 @@ is_cracked_insn (rtx insn)\n static bool\n is_branch_slot_insn (rtx insn)\n {\n-  if (!insn || !INSN_P (insn)\n+  if (!insn || !NONDEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n@@ -21519,7 +21550,7 @@ static bool\n is_nonpipeline_insn (rtx insn)\n {\n   enum attr_type type;\n-  if (!insn || !INSN_P (insn)\n+  if (!insn || !NONDEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n@@ -22098,8 +22129,8 @@ insn_must_be_first_in_group (rtx insn)\n   enum attr_type type;\n \n   if (!insn\n-      || insn == NULL_RTX\n       || GET_CODE (insn) == NOTE\n+      || DEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n@@ -22229,8 +22260,8 @@ insn_must_be_last_in_group (rtx insn)\n   enum attr_type type;\n \n   if (!insn\n-      || insn == NULL_RTX\n       || GET_CODE (insn) == NOTE\n+      || DEBUG_INSN_P (insn)\n       || GET_CODE (PATTERN (insn)) == USE\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n@@ -22356,7 +22387,7 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns,\n   bool end = *group_end;\n   int i;\n \n-  if (next_insn == NULL_RTX)\n+  if (next_insn == NULL_RTX || DEBUG_INSN_P (next_insn))\n     return can_issue_more;\n \n   if (rs6000_sched_insert_nops > sched_finish_regroup_exact)"}, {"sha": "0278028a8cbda12dd1a7d48d67b10528bc7b1cda", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,5 +1,5 @@\n /* Language-dependent hooks for C++.\n-   Copyright 2001, 2002, 2004, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva  <aoliva@redhat.com>\n \n This file is part of GCC.\n@@ -124,7 +124,9 @@ cxx_dwarf_name (tree t, int verbosity)\n   gcc_assert (DECL_P (t));\n \n   if (verbosity >= 2)\n-    return decl_as_string (t, TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME);\n+    return decl_as_string (t,\n+\t\t\t   TFF_DECL_SPECIFIERS | TFF_UNQUALIFIED_NAME\n+\t\t\t   | TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS);\n \n   return cxx_printable_name (t, verbosity);\n }"}, {"sha": "a76b2d2e8ed19f489f55fdefb1256a061b3f4f1b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -3987,7 +3987,9 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    TFF_EXPR_IN_PARENS: parenthesize expressions.\n    TFF_NO_FUNCTION_ARGUMENTS: don't show function arguments.\n    TFF_UNQUALIFIED_NAME: do not print the qualifying scope of the\n-       top-level entity.  */\n+       top-level entity.\n+   TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS: do not omit template arguments\n+       identical to their defaults.  */\n \n #define TFF_PLAIN_IDENTIFIER\t\t\t(0)\n #define TFF_SCOPE\t\t\t\t(1)\n@@ -4002,6 +4004,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define TFF_EXPR_IN_PARENS\t\t\t(1 << 9)\n #define TFF_NO_FUNCTION_ARGUMENTS\t\t(1 << 10)\n #define TFF_UNQUALIFIED_NAME\t\t\t(1 << 11)\n+#define TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS\t(1 << 12)\n \n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */"}, {"sha": "19649292627c0c64259c6cf5b5633354a4a184fd", "filename": "gcc/cp/error.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -84,7 +84,7 @@ static void dump_template_bindings (tree, tree, VEC(tree,gc) *);\n static void dump_scope (tree, int);\n static void dump_template_parms (tree, int, int);\n \n-static int count_non_default_template_args (tree, tree);\n+static int count_non_default_template_args (tree, tree, int);\n \n static const char *function_category (tree);\n static void maybe_print_instantiation_context (diagnostic_context *);\n@@ -163,13 +163,20 @@ dump_template_argument (tree arg, int flags)\n    match the (optional) default template parameter in PARAMS  */\n \n static int\n-count_non_default_template_args (tree args, tree params)\n+count_non_default_template_args (tree args, tree params, int flags)\n {\n   tree inner_args = INNERMOST_TEMPLATE_ARGS (args);\n   int n = TREE_VEC_LENGTH (inner_args);\n   int last;\n \n-  if (params == NULL_TREE || !flag_pretty_templates)\n+  if (params == NULL_TREE\n+      /* We use this flag when generating debug information.  We don't\n+\t want to expand templates at this point, for this may generate\n+\t new decls, which gets decl counts out of sync, which may in\n+\t turn cause codegen differences between compilations with and\n+\t without -g.  */\n+      || (flags & TFF_NO_OMIT_DEFAULT_TEMPLATE_ARGUMENTS) != 0\n+      || !flag_pretty_templates)\n     return n;\n \n   for (last = n - 1; last >= 0; --last)\n@@ -201,7 +208,7 @@ count_non_default_template_args (tree args, tree params)\n static void\n dump_template_argument_list (tree args, tree parms, int flags)\n {\n-  int n = count_non_default_template_args (args, parms);\n+  int n = count_non_default_template_args (args, parms, flags);\n   int need_comma = 0;\n   int i;\n \n@@ -1448,7 +1455,7 @@ dump_template_parms (tree info, int primary, int flags)\n \t\t     ? DECL_INNERMOST_TEMPLATE_PARMS (TI_TEMPLATE (info))\n \t\t     : NULL_TREE);\n \n-      len = count_non_default_template_args (args, params);\n+      len = count_non_default_template_args (args, params, flags);\n \n       args = INNERMOST_TEMPLATE_ARGS (args);\n       for (ix = 0; ix != len; ix++)"}, {"sha": "3f3b863794f1a8122b3c649b8ae397c4c7418aab", "filename": "gcc/cse.c", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -4358,6 +4358,8 @@ cse_insn (rtx insn)\n       apply_change_group ();\n       fold_rtx (x, insn);\n     }\n+  else if (DEBUG_INSN_P (insn))\n+    canon_reg (PATTERN (insn), insn);\n \n   /* Store the equivalent value in SRC_EQV, if different, or if the DEST\n      is a STRICT_LOW_PART.  The latter condition is necessary because SRC_EQV\n@@ -5788,7 +5790,7 @@ cse_insn (rtx insn)\n \t    {\n \t      prev = PREV_INSN (prev);\n \t    }\n-\t  while (prev != bb_head && NOTE_P (prev));\n+\t  while (prev != bb_head && (NOTE_P (prev) || DEBUG_INSN_P (prev)));\n \n \t  /* Do not swap the registers around if the previous instruction\n \t     attaches a REG_EQUIV note to REG1.\n@@ -6244,7 +6246,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \n \t     FIXME: This is a real kludge and needs to be done some other\n \t\t    way.  */\n-\t  if (INSN_P (insn)\n+\t  if (NONDEBUG_INSN_P (insn)\n \t      && num_insns++ > PARAM_VALUE (PARAM_MAX_CSE_INSNS))\n \t    {\n \t      flush_hash_table ();\n@@ -6536,6 +6538,9 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \t\t       incr);\n       return;\n \n+    case DEBUG_INSN:\n+      return;\n+\n     case CALL_INSN:\n     case INSN:\n     case JUMP_INSN:\n@@ -6608,6 +6613,19 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n     }\n }\n \f\n+/* Return true if a register is dead.  Can be used in for_each_rtx.  */\n+\n+static int\n+is_dead_reg (rtx *loc, void *data)\n+{\n+  rtx x = *loc;\n+  int *counts = (int *)data;\n+\n+  return (REG_P (x)\n+\t  && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t  && counts[REGNO (x)] == 0);\n+}\n+\n /* Return true if set is live.  */\n static bool\n set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n@@ -6628,9 +6646,7 @@ set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n \t       || !reg_referenced_p (cc0_rtx, PATTERN (tem))))\n     return false;\n #endif\n-  else if (!REG_P (SET_DEST (set))\n-\t   || REGNO (SET_DEST (set)) < FIRST_PSEUDO_REGISTER\n-\t   || counts[REGNO (SET_DEST (set))] != 0\n+  else if (!is_dead_reg (&SET_DEST (set), counts)\n \t   || side_effects_p (SET_SRC (set)))\n     return true;\n   return false;\n@@ -6662,6 +6678,29 @@ insn_live_p (rtx insn, int *counts)\n \t}\n       return false;\n     }\n+  else if (DEBUG_INSN_P (insn))\n+    {\n+      rtx next;\n+\n+      for (next = NEXT_INSN (insn); next; next = NEXT_INSN (next))\n+\tif (NOTE_P (next))\n+\t  continue;\n+\telse if (!DEBUG_INSN_P (next))\n+\t  return true;\n+\telse if (INSN_VAR_LOCATION_DECL (insn) == INSN_VAR_LOCATION_DECL (next))\n+\t  return false;\n+\n+      /* If this debug insn references a dead register, drop the\n+\t location expression for now.  ??? We could try to find the\n+\t def and see if propagation is possible.  */\n+      if (for_each_rtx (&INSN_VAR_LOCATION_LOC (insn), is_dead_reg, counts))\n+\t{\n+\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t  df_insn_rescan (insn);\n+\t}\n+\n+      return true;\n+    }\n   else\n     return true;\n }"}, {"sha": "8d52c519ff39bf26176d6e1c0973e5253ac358e0", "filename": "gcc/cselib.c", "status": "modified", "additions": 336, "deletions": 71, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"ggc.h\"\n #include \"hashtab.h\"\n+#include \"tree-pass.h\"\n #include \"cselib.h\"\n #include \"params.h\"\n #include \"alloc-pool.h\"\n@@ -54,16 +55,24 @@ static void unchain_one_elt_loc_list (struct elt_loc_list **);\n static int discard_useless_locs (void **, void *);\n static int discard_useless_values (void **, void *);\n static void remove_useless_values (void);\n-static rtx wrap_constant (enum machine_mode, rtx);\n static unsigned int cselib_hash_rtx (rtx, int);\n-static cselib_val *new_cselib_val (unsigned int, enum machine_mode);\n+static cselib_val *new_cselib_val (unsigned int, enum machine_mode, rtx);\n static void add_mem_for_addr (cselib_val *, cselib_val *, rtx);\n static cselib_val *cselib_lookup_mem (rtx, int);\n static void cselib_invalidate_regno (unsigned int, enum machine_mode);\n static void cselib_invalidate_mem (rtx);\n static void cselib_record_set (rtx, cselib_val *, cselib_val *);\n static void cselib_record_sets (rtx);\n \n+struct expand_value_data\n+{\n+  bitmap regs_active;\n+  cselib_expand_callback callback;\n+  void *callback_arg;\n+};\n+\n+static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n+\n /* There are three ways in which cselib can look up an rtx:\n    - for a REG, the reg_values table (which is indexed by regno) is used\n    - for a MEM, we recursively look up its address and then follow the\n@@ -134,6 +143,20 @@ static alloc_pool elt_loc_list_pool, elt_list_pool, cselib_val_pool, value_pool;\n /* If nonnull, cselib will call this function before freeing useless\n    VALUEs.  A VALUE is deemed useless if its \"locs\" field is null.  */\n void (*cselib_discard_hook) (cselib_val *);\n+\n+/* If nonnull, cselib will call this function before recording sets or\n+   even clobbering outputs of INSN.  All the recorded sets will be\n+   represented in the array sets[n_sets].  new_val_min can be used to\n+   tell whether values present in sets are introduced by this\n+   instruction.  */\n+void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n+\t\t\t\t int n_sets);\n+\n+#define PRESERVED_VALUE_P(RTX) \\\n+  (RTL_FLAG_CHECK1(\"PRESERVED_VALUE_P\", (RTX), VALUE)->unchanging)\n+#define LONG_TERM_PRESERVED_VALUE_P(RTX) \\\n+  (RTL_FLAG_CHECK1(\"LONG_TERM_PRESERVED_VALUE_P\", (RTX), VALUE)->in_struct)\n+\n \f\n \n /* Allocate a struct elt_list and fill in its two elements with the\n@@ -199,11 +222,19 @@ unchain_one_value (cselib_val *v)\n }\n \n /* Remove all entries from the hash table.  Also used during\n-   initialization.  If CLEAR_ALL isn't set, then only clear the entries\n-   which are known to have been used.  */\n+   initialization.  */\n \n void\n cselib_clear_table (void)\n+{\n+  cselib_reset_table_with_next_value (0);\n+}\n+\n+/* Remove all entries from the hash table, arranging for the next\n+   value to be numbered NUM.  */\n+\n+void\n+cselib_reset_table_with_next_value (unsigned int num)\n {\n   unsigned int i;\n \n@@ -214,15 +245,24 @@ cselib_clear_table (void)\n \n   n_used_regs = 0;\n \n+  /* ??? Preserve constants?  */\n   htab_empty (cselib_hash_table);\n \n   n_useless_values = 0;\n \n-  next_unknown_value = 0;\n+  next_unknown_value = num;\n \n   first_containing_mem = &dummy_val;\n }\n \n+/* Return the number of the next value that will be generated.  */\n+\n+unsigned int\n+cselib_get_next_unknown_value (void)\n+{\n+  return next_unknown_value;\n+}\n+\n /* The equality test for our hash table.  The first argument ENTRY is a table\n    element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n    that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n@@ -317,7 +357,7 @@ discard_useless_locs (void **x, void *info ATTRIBUTE_UNUSED)\n \tp = &(*p)->next;\n     }\n \n-  if (had_locs && v->locs == 0)\n+  if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n     {\n       n_useless_values++;\n       values_became_useless = 1;\n@@ -332,7 +372,7 @@ discard_useless_values (void **x, void *info ATTRIBUTE_UNUSED)\n {\n   cselib_val *v = (cselib_val *)*x;\n \n-  if (v->locs == 0)\n+  if (v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n     {\n       if (cselib_discard_hook)\n \tcselib_discard_hook (v);\n@@ -378,6 +418,78 @@ remove_useless_values (void)\n   gcc_assert (!n_useless_values);\n }\n \n+/* Arrange for a value to not be removed from the hash table even if\n+   it becomes useless.  */\n+\n+void\n+cselib_preserve_value (cselib_val *v)\n+{\n+  PRESERVED_VALUE_P (v->val_rtx) = 1;\n+}\n+\n+/* Test whether a value is preserved.  */\n+\n+bool\n+cselib_preserved_value_p (cselib_val *v)\n+{\n+  return PRESERVED_VALUE_P (v->val_rtx);\n+}\n+\n+/* Mark preserved values as preserved for the long term.  */\n+\n+static int\n+cselib_preserve_definitely (void **slot, void *info ATTRIBUTE_UNUSED)\n+{\n+  cselib_val *v = (cselib_val *)*slot;\n+\n+  if (PRESERVED_VALUE_P (v->val_rtx)\n+      && !LONG_TERM_PRESERVED_VALUE_P (v->val_rtx))\n+    LONG_TERM_PRESERVED_VALUE_P (v->val_rtx) = true;\n+\n+  return 1;\n+}\n+\n+/* Clear the preserve marks for values not preserved for the long\n+   term.  */\n+\n+static int\n+cselib_clear_preserve (void **slot, void *info ATTRIBUTE_UNUSED)\n+{\n+  cselib_val *v = (cselib_val *)*slot;\n+\n+  if (PRESERVED_VALUE_P (v->val_rtx)\n+      && !LONG_TERM_PRESERVED_VALUE_P (v->val_rtx))\n+    {\n+      PRESERVED_VALUE_P (v->val_rtx) = false;\n+      if (!v->locs)\n+\tn_useless_values++;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Clean all non-constant expressions in the hash table, but retain\n+   their values.  */\n+\n+void\n+cselib_preserve_only_values (bool retain)\n+{\n+  int i;\n+\n+  htab_traverse (cselib_hash_table,\n+\t\t retain ? cselib_preserve_definitely : cselib_clear_preserve,\n+\t\t NULL);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    cselib_invalidate_regno (i, reg_raw_mode[i]);\n+\n+  cselib_invalidate_mem (callmem);\n+\n+  remove_useless_values ();\n+\n+  gcc_assert (first_containing_mem == &dummy_val);\n+}\n+\n /* Return the mode in which a register was last set.  If X is not a\n    register, return its mode.  If the mode in which the register was\n    set is not known, or the value was already clobbered, return\n@@ -549,19 +661,6 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n   return 1;\n }\n \n-/* We need to pass down the mode of constants through the hash table\n-   functions.  For that purpose, wrap them in a CONST of the appropriate\n-   mode.  */\n-static rtx\n-wrap_constant (enum machine_mode mode, rtx x)\n-{\n-  if (!CONST_INT_P (x) && GET_CODE (x) != CONST_FIXED\n-      && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n-    return x;\n-  gcc_assert (mode != VOIDmode);\n-  return gen_rtx_CONST (mode, x);\n-}\n-\n /* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n    For registers and memory locations, we look up their cselib_val structure\n    and return its VALUE element.\n@@ -748,7 +847,7 @@ cselib_hash_rtx (rtx x, int create)\n    value is MODE.  */\n \n static inline cselib_val *\n-new_cselib_val (unsigned int value, enum machine_mode mode)\n+new_cselib_val (unsigned int value, enum machine_mode mode, rtx x)\n {\n   cselib_val *e = (cselib_val *) pool_alloc (cselib_val_pool);\n \n@@ -768,6 +867,18 @@ new_cselib_val (unsigned int value, enum machine_mode mode)\n   e->addr_list = 0;\n   e->locs = 0;\n   e->next_containing_mem = 0;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"cselib value %u \", value);\n+      if (flag_dump_noaddr || flag_dump_unnumbered)\n+\tfputs (\"# \", dump_file);\n+      else\n+\tfprintf (dump_file, \"%p \", (void*)e);\n+      print_rtl_single (dump_file, x);\n+      fputc ('\\n', dump_file);\n+    }\n+\n   return e;\n }\n \n@@ -827,7 +938,7 @@ cselib_lookup_mem (rtx x, int create)\n   if (! create)\n     return 0;\n \n-  mem_elt = new_cselib_val (++next_unknown_value, mode);\n+  mem_elt = new_cselib_val (++next_unknown_value, mode, x);\n   add_mem_for_addr (addr, mem_elt, x);\n   slot = htab_find_slot_with_hash (cselib_hash_table, wrap_constant (mode, x),\n \t\t\t\t   mem_elt->value, INSERT);\n@@ -842,7 +953,8 @@ cselib_lookup_mem (rtx x, int create)\n    expand to the same place.  */\n \n static rtx \n-expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n+expand_loc (struct elt_loc_list *p, struct expand_value_data *evd,\n+\t    int max_depth)\n {\n   rtx reg_result = NULL;\n   unsigned int regno = UINT_MAX;\n@@ -854,7 +966,7 @@ expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n \t the same reg.  */\n       if ((REG_P (p->loc)) \n \t  && (REGNO (p->loc) < regno) \n-\t  && !bitmap_bit_p (regs_active, REGNO (p->loc)))\n+\t  && !bitmap_bit_p (evd->regs_active, REGNO (p->loc)))\n \t{\n \t  reg_result = p->loc;\n \t  regno = REGNO (p->loc);\n@@ -867,7 +979,7 @@ expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n       else if (!REG_P (p->loc))\n \t{\n \t  rtx result, note;\n-\t  if (dump_file)\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      print_inline_rtx (dump_file, p->loc, 0);\n \t      fprintf (dump_file, \"\\n\");\n@@ -878,7 +990,7 @@ expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n \t      && (note = find_reg_note (p->setting_insn, REG_EQUAL, NULL_RTX))\n \t      && XEXP (note, 0) == XEXP (p->loc, 1))\n \t    return XEXP (p->loc, 1);\n-\t  result = cselib_expand_value_rtx (p->loc, regs_active, max_depth - 1);\n+\t  result = cselib_expand_value_rtx_1 (p->loc, evd, max_depth - 1);\n \t  if (result)\n \t    return result;\n \t}\n@@ -888,15 +1000,15 @@ expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n   if (regno != UINT_MAX)\n     {\n       rtx result;\n-      if (dump_file)\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"r%d\\n\", regno);\n \n-      result = cselib_expand_value_rtx (reg_result, regs_active, max_depth - 1);\n+      result = cselib_expand_value_rtx_1 (reg_result, evd, max_depth - 1);\n       if (result)\n \treturn result;\n     }\n \n-  if (dump_file)\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       if (reg_result)\n \t{\n@@ -930,6 +1042,35 @@ expand_loc (struct elt_loc_list *p, bitmap regs_active, int max_depth)\n \n rtx\n cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n+{\n+  struct expand_value_data evd;\n+\n+  evd.regs_active = regs_active;\n+  evd.callback = NULL;\n+  evd.callback_arg = NULL;\n+\n+  return cselib_expand_value_rtx_1 (orig, &evd, max_depth);\n+}\n+\n+/* Same as cselib_expand_value_rtx, but using a callback to try to\n+   resolve VALUEs that expand to nothing.  */\n+\n+rtx\n+cselib_expand_value_rtx_cb (rtx orig, bitmap regs_active, int max_depth,\n+\t\t\t    cselib_expand_callback cb, void *data)\n+{\n+  struct expand_value_data evd;\n+\n+  evd.regs_active = regs_active;\n+  evd.callback = cb;\n+  evd.callback_arg = data;\n+\n+  return cselib_expand_value_rtx_1 (orig, &evd, max_depth);\n+}\n+\n+static rtx\n+cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n+\t\t\t   int max_depth)\n {\n   rtx copy, scopy;\n   int i, j;\n@@ -980,13 +1121,13 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \t\t  || regno == HARD_FRAME_POINTER_REGNUM)\n \t\treturn orig;\n \n-\t      bitmap_set_bit (regs_active, regno);\n+\t      bitmap_set_bit (evd->regs_active, regno);\n \n-\t      if (dump_file)\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"expanding: r%d into: \", regno);\n \n-\t      result = expand_loc (l->elt->locs, regs_active, max_depth);\n-\t      bitmap_clear_bit (regs_active, regno);\n+\t      result = expand_loc (l->elt->locs, evd, max_depth);\n+\t      bitmap_clear_bit (evd->regs_active, regno);\n \n \t      if (result)\n \t\treturn result;\n@@ -1017,8 +1158,8 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \n     case SUBREG:\n       {\n-\trtx subreg = cselib_expand_value_rtx (SUBREG_REG (orig), regs_active,\n-\t\t\t\t\t      max_depth - 1);\n+\trtx subreg = cselib_expand_value_rtx_1 (SUBREG_REG (orig), evd,\n+\t\t\t\t\t\tmax_depth - 1);\n \tif (!subreg)\n \t  return NULL;\n \tscopy = simplify_gen_subreg (GET_MODE (orig), subreg,\n@@ -1027,18 +1168,39 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \tif (scopy == NULL\n \t    || (GET_CODE (scopy) == SUBREG\n \t\t&& !REG_P (SUBREG_REG (scopy))\n-\t\t&& !MEM_P (SUBREG_REG (scopy))))\n+\t\t&& !MEM_P (SUBREG_REG (scopy))\n+\t\t&& (REG_P (SUBREG_REG (orig))\n+\t\t    || MEM_P (SUBREG_REG (orig)))))\n \t  return shallow_copy_rtx (orig);\n \treturn scopy;\n       }\n \n     case VALUE:\n-      if (dump_file)\n-\tfprintf (dump_file, \"expanding value %s into: \",\n-\t\t GET_MODE_NAME (GET_MODE (orig)));\n+      {\n+\trtx result;\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  {\n+\t    fputs (\"\\nexpanding \", dump_file);\n+\t    print_rtl_single (dump_file, orig);\n+\t    fputs (\" into...\", dump_file);\n+\t  }\n \n-      return expand_loc (CSELIB_VAL_PTR (orig)->locs, regs_active, max_depth);\n+\tif (!evd->callback)\n+\t  result = NULL;\n+\telse\n+\t  {\n+\t    result = evd->callback (orig, evd->regs_active, max_depth,\n+\t\t\t\t    evd->callback_arg);\n+\t    if (result == orig)\n+\t      result = NULL;\n+\t    else if (result)\n+\t      result = cselib_expand_value_rtx_1 (result, evd, max_depth);\n+\t  }\n \n+\tif (!result)\n+\t  result = expand_loc (CSELIB_VAL_PTR (orig)->locs, evd, max_depth);\n+\treturn result;\n+      }\n     default:\n       break;\n     }\n@@ -1057,7 +1219,8 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n       case 'e':\n \tif (XEXP (orig, i) != NULL)\n \t  {\n-\t    rtx result = cselib_expand_value_rtx (XEXP (orig, i), regs_active, max_depth - 1);\n+\t    rtx result = cselib_expand_value_rtx_1 (XEXP (orig, i), evd,\n+\t\t\t\t\t\t    max_depth - 1);\n \t    if (!result)\n \t      return NULL;\n \t    XEXP (copy, i) = result;\n@@ -1071,7 +1234,8 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n \t    XVEC (copy, i) = rtvec_alloc (XVECLEN (orig, i));\n \t    for (j = 0; j < XVECLEN (copy, i); j++)\n \t      {\n-\t\trtx result = cselib_expand_value_rtx (XVECEXP (orig, i, j), regs_active, max_depth - 1);\n+\t\trtx result = cselib_expand_value_rtx_1 (XVECEXP (orig, i, j),\n+\t\t\t\t\t\t\tevd, max_depth - 1);\n \t\tif (!result)\n \t\t  return NULL;\n \t\tXVECEXP (copy, i, j) = result;\n@@ -1155,13 +1319,17 @@ cselib_expand_value_rtx (rtx orig, bitmap regs_active, int max_depth)\n     {\n       XEXP (copy, 0)\n \t= gen_rtx_CONST (GET_MODE (XEXP (orig, 0)), XEXP (copy, 0));\n-      if (dump_file)\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"  wrapping const_int result in const to preserve mode %s\\n\",\n \t\t GET_MODE_NAME (GET_MODE (XEXP (copy, 0))));\n     }\n   scopy = simplify_rtx (copy);\n   if (scopy)\n-    return scopy;\n+    {\n+      if (GET_MODE (copy) != GET_MODE (scopy))\n+\tscopy = wrap_constant (GET_MODE (copy), scopy);\n+      return scopy;\n+    }\n   return copy;\n }\n \n@@ -1199,7 +1367,7 @@ cselib_subst_to_values (rtx x)\n \t{\n \t  /* This happens for autoincrements.  Assign a value that doesn't\n \t     match any other.  */\n-\t  e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+\t  e = new_cselib_val (++next_unknown_value, GET_MODE (x), x);\n \t}\n       return e->val_rtx;\n \n@@ -1215,7 +1383,7 @@ cselib_subst_to_values (rtx x)\n     case PRE_DEC:\n     case POST_MODIFY:\n     case PRE_MODIFY:\n-      e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+      e = new_cselib_val (++next_unknown_value, GET_MODE (x), x);\n       return e->val_rtx;\n \n     default:\n@@ -1259,6 +1427,21 @@ cselib_subst_to_values (rtx x)\n   return copy;\n }\n \n+/* Log a lookup of X to the cselib table along with the result RET.  */\n+\n+static cselib_val *\n+cselib_log_lookup (rtx x, cselib_val *ret)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fputs (\"cselib lookup \", dump_file);\n+      print_inline_rtx (dump_file, x, 2);\n+      fprintf (dump_file, \" => %u\\n\", ret ? ret->value : 0);\n+    }\n+\n+  return ret;\n+}\n+\n /* Look up the rtl expression X in our tables and return the value it has.\n    If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n    we create a new one if possible, using mode MODE if X doesn't have a mode\n@@ -1287,10 +1470,10 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \tl = l->next;\n       for (; l; l = l->next)\n \tif (mode == GET_MODE (l->elt->val_rtx))\n-\t  return l->elt;\n+\t  return cselib_log_lookup (x, l->elt);\n \n       if (! create)\n-\treturn 0;\n+\treturn cselib_log_lookup (x, 0);\n \n       if (i < FIRST_PSEUDO_REGISTER)\n \t{\n@@ -1300,7 +1483,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \t    max_value_regs = n;\n \t}\n \n-      e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n+      e = new_cselib_val (++next_unknown_value, GET_MODE (x), x);\n       e->locs = new_elt_loc_list (e->locs, x);\n       if (REG_VALUES (i) == 0)\n \t{\n@@ -1313,34 +1496,34 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n       slot = htab_find_slot_with_hash (cselib_hash_table, x, e->value, INSERT);\n       *slot = e;\n-      return e;\n+      return cselib_log_lookup (x, e);\n     }\n \n   if (MEM_P (x))\n-    return cselib_lookup_mem (x, create);\n+    return cselib_log_lookup (x, cselib_lookup_mem (x, create));\n \n   hashval = cselib_hash_rtx (x, create);\n   /* Can't even create if hashing is not possible.  */\n   if (! hashval)\n-    return 0;\n+    return cselib_log_lookup (x, 0);\n \n   slot = htab_find_slot_with_hash (cselib_hash_table, wrap_constant (mode, x),\n \t\t\t\t   hashval, create ? INSERT : NO_INSERT);\n   if (slot == 0)\n-    return 0;\n+    return cselib_log_lookup (x, 0);\n \n   e = (cselib_val *) *slot;\n   if (e)\n-    return e;\n+    return cselib_log_lookup (x, e);\n \n-  e = new_cselib_val (hashval, mode);\n+  e = new_cselib_val (hashval, mode, x);\n \n   /* We have to fill the slot before calling cselib_subst_to_values:\n      the hash table is inconsistent until we do so, and\n      cselib_subst_to_values will need to do lookups.  */\n   *slot = (void *) e;\n   e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n-  return e;\n+  return cselib_log_lookup (x, e);\n }\n \n /* Invalidate any entries in reg_values that overlap REGNO.  This is called\n@@ -1427,7 +1610,7 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t\t  break;\n \t\t}\n \t    }\n-\t  if (v->locs == 0)\n+\t  if (v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n \t    n_useless_values++;\n \t}\n     }\n@@ -1510,7 +1693,7 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t  unchain_one_elt_loc_list (p);\n \t}\n \n-      if (had_locs && v->locs == 0)\n+      if (had_locs && v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n \tn_useless_values++;\n \n       next = v->next_containing_mem;\n@@ -1591,28 +1774,19 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n \t  REG_VALUES (dreg)->elt = src_elt;\n \t}\n \n-      if (src_elt->locs == 0)\n+      if (src_elt->locs == 0 && !PRESERVED_VALUE_P (src_elt->val_rtx))\n \tn_useless_values--;\n       src_elt->locs = new_elt_loc_list (src_elt->locs, dest);\n     }\n   else if (MEM_P (dest) && dest_addr_elt != 0\n \t   && cselib_record_memory)\n     {\n-      if (src_elt->locs == 0)\n+      if (src_elt->locs == 0 && !PRESERVED_VALUE_P (src_elt->val_rtx))\n \tn_useless_values--;\n       add_mem_for_addr (dest_addr_elt, src_elt, dest);\n     }\n }\n \n-/* Describe a single set that is part of an insn.  */\n-struct set\n-{\n-  rtx src;\n-  rtx dest;\n-  cselib_val *src_elt;\n-  cselib_val *dest_addr_elt;\n-};\n-\n /* There is no good way to determine how many elements there can be\n    in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n #define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)\n@@ -1623,7 +1797,7 @@ cselib_record_sets (rtx insn)\n {\n   int n_sets = 0;\n   int i;\n-  struct set sets[MAX_SETS];\n+  struct cselib_set sets[MAX_SETS];\n   rtx body = PATTERN (insn);\n   rtx cond = 0;\n \n@@ -1695,6 +1869,9 @@ cselib_record_sets (rtx insn)\n \t}\n     }\n \n+  if (cselib_record_sets_hook)\n+    cselib_record_sets_hook (insn, sets, n_sets);\n+\n   /* Invalidate all locations written by this insn.  Note that the elts we\n      looked up in the previous loop aren't affected, just some of their\n      locations may go away.  */\n@@ -1751,7 +1928,7 @@ cselib_process_insn (rtx insn)\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))\n     {\n-      cselib_clear_table ();\n+      cselib_reset_table_with_next_value (next_unknown_value);\n       return;\n     }\n \n@@ -1868,4 +2045,92 @@ cselib_finish (void)\n   next_unknown_value = 0;\n }\n \n+/* Dump the cselib_val *X to FILE *info.  */\n+\n+static int\n+dump_cselib_val (void **x, void *info)\n+{\n+  cselib_val *v = (cselib_val *)*x;\n+  FILE *out = (FILE *)info;\n+  bool need_lf = true;\n+\n+  print_inline_rtx (out, v->val_rtx, 0);\n+\n+  if (v->locs)\n+    {\n+      struct elt_loc_list *l = v->locs;\n+      if (need_lf)\n+\t{\n+\t  fputc ('\\n', out);\n+\t  need_lf = false;\n+\t}\n+      fputs (\" locs:\", out);\n+      do\n+\t{\n+\t  fprintf (out, \"\\n  from insn %i \",\n+\t\t   INSN_UID (l->setting_insn));\n+\t  print_inline_rtx (out, l->loc, 4);\n+\t}\n+      while ((l = l->next));\n+      fputc ('\\n', out);\n+    }\n+  else\n+    {\n+      fputs (\" no locs\", out);\n+      need_lf = true;\n+    }\n+\n+  if (v->addr_list)\n+    {\n+      struct elt_list *e = v->addr_list;\n+      if (need_lf)\n+\t{\n+\t  fputc ('\\n', out);\n+\t  need_lf = false;\n+\t}\n+      fputs (\" addr list:\", out);\n+      do\n+\t{\n+\t  fputs (\"\\n  \", out);\n+\t  print_inline_rtx (out, e->elt->val_rtx, 2);\n+\t}\n+      while ((e = e->next));\n+      fputc ('\\n', out);\n+    }\n+  else\n+    {\n+      fputs (\" no addrs\", out);\n+      need_lf = true;\n+    }\n+\n+  if (v->next_containing_mem == &dummy_val)\n+    fputs (\" last mem\\n\", out);\n+  else if (v->next_containing_mem)\n+    {\n+      fputs (\" next mem \", out);\n+      print_inline_rtx (out, v->next_containing_mem->val_rtx, 2);\n+      fputc ('\\n', out);\n+    }\n+  else if (need_lf)\n+    fputc ('\\n', out);\n+\n+  return 1;\n+}\n+\n+/* Dump to OUT everything in the CSELIB table.  */\n+\n+void\n+dump_cselib_table (FILE *out)\n+{\n+  fprintf (out, \"cselib hash table:\\n\");\n+  htab_traverse (cselib_hash_table, dump_cselib_val, out);\n+  if (first_containing_mem != &dummy_val)\n+    {\n+      fputs (\"first mem \", out);\n+      print_inline_rtx (out, first_containing_mem->val_rtx, 2);\n+      fputc ('\\n', out);\n+    }\n+  fprintf (out, \"last unknown value %i\\n\", next_unknown_value);\n+}\n+\n #include \"gt-cselib.h\""}, {"sha": "433f4deb87dbb1d2e607257b76289acc77c922de", "filename": "gcc/cselib.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -53,7 +53,18 @@ struct GTY(()) elt_list {\n   cselib_val *elt;\n };\n \n+/* Describe a single set that is part of an insn.  */\n+struct cselib_set\n+{\n+  rtx src;\n+  rtx dest;\n+  cselib_val *src_elt;\n+  cselib_val *dest_addr_elt;\n+};\n+\n extern void (*cselib_discard_hook) (cselib_val *);\n+extern void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n+\t\t\t\t\tint n_sets);\n \n extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n extern void cselib_init (bool record_memory);\n@@ -64,5 +75,16 @@ extern enum machine_mode cselib_reg_set_mode (const_rtx);\n extern int rtx_equal_for_cselib_p (rtx, rtx);\n extern int references_value_p (const_rtx, int);\n extern rtx cselib_expand_value_rtx (rtx, bitmap, int);\n+typedef rtx (*cselib_expand_callback)(rtx, bitmap, int, void *);\n+extern rtx cselib_expand_value_rtx_cb (rtx, bitmap, int,\n+\t\t\t\t       cselib_expand_callback, void*);\n extern rtx cselib_subst_to_values (rtx);\n extern void cselib_invalidate_rtx (rtx);\n+\n+extern void cselib_reset_table_with_next_value (unsigned int);\n+extern unsigned int cselib_get_next_unknown_value (void);\n+extern void cselib_preserve_value (cselib_val *);\n+extern bool cselib_preserved_value_p (cselib_val *);\n+extern void cselib_preserve_only_values (bool);\n+\n+extern void dump_cselib_table (FILE *);"}, {"sha": "3e1dd47f3a4b456d9fd618d2f35efb41908b9ac7", "filename": "gcc/dce.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -124,6 +124,7 @@ deletable_insn_p (rtx insn, bool fast, bitmap arg_stores)\n   switch (GET_CODE (body))\n     {\n     case USE:\n+    case VAR_LOCATION:\n       return false;\n \n     case CLOBBER:\n@@ -643,6 +644,9 @@ mark_reg_dependencies (rtx insn)\n   struct df_link *defs;\n   df_ref *use_rec;\n \n+  if (DEBUG_INSN_P (insn))\n+    return;\n+\n   for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n     {\n       df_ref use = *use_rec;"}, {"sha": "439acd1f4342668fd29608a69ca26dd3d8ce9bcf", "filename": "gcc/ddg.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -166,6 +166,9 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n   else if (DEP_TYPE (link) == REG_DEP_OUTPUT)\n     t = OUTPUT_DEP;\n \n+  gcc_assert (!DEBUG_INSN_P (dest_node->insn) || t == ANTI_DEP);\n+  gcc_assert (!DEBUG_INSN_P (src_node->insn) || DEBUG_INSN_P (dest_node->insn));\n+\n   /* We currently choose not to create certain anti-deps edges and\n      compensate for that by generating reg-moves based on the life-range\n      analysis.  The anti-deps that will be deleted are the ones which\n@@ -209,6 +212,9 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n   enum reg_note dep_kind;\n   struct _dep _dep, *dep = &_dep;\n \n+  gcc_assert (!DEBUG_INSN_P (to->insn) || d_t == ANTI_DEP);\n+  gcc_assert (!DEBUG_INSN_P (from->insn) || DEBUG_INSN_P (to->insn));\n+\n   if (d_t == ANTI_DEP)\n     dep_kind = REG_DEP_ANTI;\n   else if (d_t == OUTPUT_DEP)\n@@ -277,10 +283,11 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n \t  /* Add true deps from last_def to it's uses in the next\n \t     iteration.  Any such upwards exposed use appears before\n \t     the last_def def.  */\n-\t  create_ddg_dep_no_link (g, last_def_node, use_node, TRUE_DEP,\n+\t  create_ddg_dep_no_link (g, last_def_node, use_node,\n+\t\t\t\t  DEBUG_INSN_P (use_insn) ? ANTI_DEP : TRUE_DEP,\n \t\t\t\t  REG_DEP, 1);\n \t}\n-      else\n+      else if (!DEBUG_INSN_P (use_insn))\n \t{\n \t  /* Add anti deps from last_def's uses in the current iteration\n \t     to the first def in the next iteration.  We do not add ANTI\n@@ -417,6 +424,8 @@ build_intra_loop_deps (ddg_ptr g)\n \t  for (j = 0; j <= i; j++)\n \t    {\n \t      ddg_node_ptr j_node = &g->nodes[j];\n+\t      if (DEBUG_INSN_P (j_node->insn))\n+\t\tcontinue;\n \t      if (mem_access_insn_p (j_node->insn))\n  \t\t/* Don't bother calculating inter-loop dep if an intra-loop dep\n \t\t   already exists.  */\n@@ -458,10 +467,15 @@ create_ddg (basic_block bb, int closing_branch_deps)\n       if (! INSN_P (insn) || GET_CODE (PATTERN (insn)) == USE)\n \tcontinue;\n \n-      if (mem_read_insn_p (insn))\n-\tg->num_loads++;\n-      if (mem_write_insn_p (insn))\n-\tg->num_stores++;\n+      if (DEBUG_INSN_P (insn))\n+\tg->num_debug++;\n+      else\n+\t{\n+\t  if (mem_read_insn_p (insn))\n+\t    g->num_loads++;\n+\t  if (mem_write_insn_p (insn))\n+\t    g->num_stores++;\n+\t}\n       num_nodes++;\n     }\n "}, {"sha": "fbe2988606cef4ffd98964cb0e651b9366897964", "filename": "gcc/ddg.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,5 +1,5 @@\n /* DDG - Data Dependence Graph - interface.\n-   Copyright (C) 2004, 2005, 2006, 2007\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Ayal Zaks and Mustafa Hagog <zaks,mustafa@il.ibm.com>\n \n@@ -121,6 +121,9 @@ struct ddg\n   int num_loads;\n   int num_stores;\n \n+  /* Number of debug instructions in the BB.  */\n+  int num_debug;\n+\n   /* This array holds the nodes in the graph; it is indexed by the node\n      cuid, which follows the order of the instructions in the BB.  */\n   ddg_node_ptr nodes;\n@@ -134,8 +137,8 @@ struct ddg\n   int closing_branch_deps;\n \n   /* Array and number of backarcs (edges with distance > 0) in the DDG.  */\n-  ddg_edge_ptr *backarcs;\n   int num_backarcs;\n+  ddg_edge_ptr *backarcs;\n };\n \n \f"}, {"sha": "cdbc8a19d9d0a704d490800b24b51c11b581c674", "filename": "gcc/df-problems.c", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -858,7 +858,7 @@ df_lr_bb_local_compute (unsigned int bb_index)\n     {\n       unsigned int uid = INSN_UID (insn);\n \n-      if (!INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\t\n \n       for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n@@ -3182,6 +3182,8 @@ df_set_note (enum reg_note note_type, rtx insn, rtx old, rtx reg)\n   rtx curr = old;\n   rtx prev = NULL;\n \n+  gcc_assert (!DEBUG_INSN_P (insn));\n+\n   while (curr)\n     if (XEXP (curr, 0) == reg)\n       {\n@@ -3314,9 +3316,12 @@ df_whole_mw_reg_dead_p (struct df_mw_hardreg *mws,\n static rtx\n df_set_dead_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n \t\t\t  bitmap live, bitmap do_not_gen,\n-\t\t\t  bitmap artificial_uses)\n+\t\t\t  bitmap artificial_uses, bool *added_notes_p)\n {\n   unsigned int r;\n+  bool is_debug = *added_notes_p;\n+\n+  *added_notes_p = false;\n   \n #ifdef REG_DEAD_DEBUGGING\n   if (dump_file)\n@@ -3334,6 +3339,11 @@ df_set_dead_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n   if (df_whole_mw_reg_dead_p (mws, live, artificial_uses, do_not_gen))\n     {\n       /* Add a dead note for the entire multi word register.  */\n+      if (is_debug)\n+\t{\n+\t  *added_notes_p = true;\n+\t  return old;\n+\t}\n       old = df_set_note (REG_DEAD, insn, old, mws->mw_reg);\n #ifdef REG_DEAD_DEBUGGING\n       df_print_note (\"adding 1: \", insn, REG_NOTES (insn));\n@@ -3346,6 +3356,11 @@ df_set_dead_notes_for_mw (rtx insn, rtx old, struct df_mw_hardreg *mws,\n \t    && !bitmap_bit_p (artificial_uses, r)\n \t    && !bitmap_bit_p (do_not_gen, r))\n \t  {\n+\t    if (is_debug)\n+\t      {\n+\t\t*added_notes_p = true;\n+\t\treturn old;\n+\t      }\n \t    old = df_set_note (REG_DEAD, insn, old, regno_reg_rtx[r]);\n #ifdef REG_DEAD_DEBUGGING\n \t    df_print_note (\"adding 2: \", insn, REG_NOTES (insn));\n@@ -3456,10 +3471,13 @@ df_note_bb_compute (unsigned int bb_index,\n       struct df_mw_hardreg **mws_rec;\n       rtx old_dead_notes;\n       rtx old_unused_notes;\n+      int debug_insn;\n  \n       if (!INSN_P (insn))\n \tcontinue;\n \n+      debug_insn = DEBUG_INSN_P (insn);\n+\n       bitmap_clear (do_not_gen);\n       df_kill_notes (insn, &old_dead_notes, &old_unused_notes);\n \n@@ -3544,10 +3562,18 @@ df_note_bb_compute (unsigned int bb_index,\n \t  struct df_mw_hardreg *mws = *mws_rec; \n \t  if ((DF_MWS_REG_DEF_P (mws))  \n \t      && !df_ignore_stack_reg (mws->start_regno))\n-\t    old_dead_notes\n-\t      = df_set_dead_notes_for_mw (insn, old_dead_notes, \n-\t\t\t\t\t  mws, live, do_not_gen,\n-\t\t\t\t\t  artificial_uses);\n+\t    {\n+\t      bool really_add_notes = debug_insn != 0;\n+\n+\t      old_dead_notes\n+\t\t= df_set_dead_notes_for_mw (insn, old_dead_notes,\n+\t\t\t\t\t    mws, live, do_not_gen,\n+\t\t\t\t\t    artificial_uses,\n+\t\t\t\t\t    &really_add_notes);\n+\n+\t      if (really_add_notes)\n+\t\tdebug_insn = -1;\n+\t    }\n \t  mws_rec++;\n \t}\n \n@@ -3557,14 +3583,20 @@ df_note_bb_compute (unsigned int bb_index,\n \t  unsigned int uregno = DF_REF_REGNO (use);\n \n #ifdef REG_DEAD_DEBUGGING\n-\t  if (dump_file)\n+\t  if (dump_file && !debug_insn)\n \t    {\n \t      fprintf (dump_file, \"  regular looking at use \");\n \t      df_ref_debug (use, dump_file);\n \t    }\n #endif\n \t  if (!bitmap_bit_p (live, uregno))\n \t    {\n+\t      if (debug_insn)\n+\t\t{\n+\t\t  debug_insn = -1;\n+\t\t  break;\n+\t\t}\n+\n \t      if ( (!(DF_REF_FLAGS (use) & DF_REF_MW_HARDREG))\n \t\t   && (!bitmap_bit_p (do_not_gen, uregno))\n \t\t   && (!bitmap_bit_p (artificial_uses, uregno))\n@@ -3596,6 +3628,14 @@ df_note_bb_compute (unsigned int bb_index,\n \t  free_EXPR_LIST_node (old_dead_notes);\n \t  old_dead_notes = next;\n \t}\n+\n+      if (debug_insn == -1)\n+\t{\n+\t  /* ??? We could probably do better here, replacing dead\n+\t     registers with their definitions.  */\n+\t  INSN_VAR_LOCATION_LOC (insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+\t  df_insn_rescan_debug_internal (insn);\n+\t}\n     }\n }\n \n@@ -3741,6 +3781,9 @@ df_simulate_uses (rtx insn, bitmap live)\n   df_ref *use_rec;\n   unsigned int uid = INSN_UID (insn);\n \n+  if (DEBUG_INSN_P (insn))\n+    return;\n+\n   for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n     {\n       df_ref use = *use_rec;\n@@ -3807,7 +3850,7 @@ df_simulate_initialize_backwards (basic_block bb, bitmap live)\n void \n df_simulate_one_insn_backwards (basic_block bb, rtx insn, bitmap live)\n {\n-  if (! INSN_P (insn))\n+  if (!NONDEBUG_INSN_P (insn))\n     return;\t\n   \n   df_simulate_defs (insn, live);"}, {"sha": "35be03c7629afd8b47eaa192ad7c917f8ae96a6f", "filename": "gcc/df-scan.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1310,6 +1310,62 @@ df_insn_rescan (rtx insn)\n   return true;\n }\n \n+/* Same as df_insn_rescan, but don't mark the basic block as\n+   dirty.  */\n+\n+bool\n+df_insn_rescan_debug_internal (rtx insn)\n+{\n+  unsigned int uid = INSN_UID (insn);\n+  struct df_insn_info *insn_info;\n+\n+  gcc_assert (DEBUG_INSN_P (insn));\n+  gcc_assert (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)));\n+\n+  if (!df)\n+    return false;\n+\n+  insn_info = DF_INSN_UID_SAFE_GET (INSN_UID (insn));\n+  if (!insn_info)\n+    return false;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"deleting debug_insn with uid = %d.\\n\", uid);\n+\n+  bitmap_clear_bit (df->insns_to_delete, uid);\n+  bitmap_clear_bit (df->insns_to_rescan, uid);\n+  bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n+\n+  if (!insn_info->defs)\n+    return false;\n+\n+  if (insn_info->defs == df_null_ref_rec\n+      && insn_info->uses == df_null_ref_rec\n+      && insn_info->eq_uses == df_null_ref_rec\n+      && insn_info->mw_hardregs == df_null_mw_rec)\n+    return false;\n+\n+  df_mw_hardreg_chain_delete (insn_info->mw_hardregs);\n+\n+  if (df_chain)\n+    {\n+      df_ref_chain_delete_du_chain (insn_info->defs);\n+      df_ref_chain_delete_du_chain (insn_info->uses);\n+      df_ref_chain_delete_du_chain (insn_info->eq_uses);\n+    }\n+\n+  df_ref_chain_delete (insn_info->defs);\n+  df_ref_chain_delete (insn_info->uses);\n+  df_ref_chain_delete (insn_info->eq_uses);\n+\n+  insn_info->defs = df_null_ref_rec;\n+  insn_info->uses = df_null_ref_rec;\n+  insn_info->eq_uses = df_null_ref_rec;\n+  insn_info->mw_hardregs = df_null_mw_rec;\n+\n+  return true;\n+}\n+\n \n /* Rescan all of the insns in the function.  Note that the artificial\n    uses and defs are not touched.  This function will destroy def-se\n@@ -3267,12 +3323,20 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \tbreak;\n       }\n \n+    case VAR_LOCATION:\n+      df_uses_record (cl, collection_rec,\n+\t\t      &PAT_VAR_LOCATION_LOC (x),\n+\t\t      DF_REF_REG_USE, bb, insn_info,\n+\t\t      flags, width, offset, mode);\n+      return;\n+\n     case PRE_DEC:\n     case POST_DEC:\n     case PRE_INC:\n     case POST_INC:\n     case PRE_MODIFY:\n     case POST_MODIFY:\n+      gcc_assert (!DEBUG_INSN_P (insn_info->insn));\n       /* Catch the def of the register being modified.  */\n       df_ref_record (cl, collection_rec, XEXP (x, 0), &XEXP (x, 0),\n \t\t     bb, insn_info, "}, {"sha": "633bf282d69f57355f0d05b61c1ac2dee2cf48f8", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1002,6 +1002,7 @@ extern struct df_insn_info * df_insn_create_insn_record (rtx);\n extern void df_insn_delete (basic_block, unsigned int);\n extern void df_bb_refs_record (int, bool);\n extern bool df_insn_rescan (rtx);\n+extern bool df_insn_rescan_debug_internal (rtx);\n extern void df_insn_rescan_all (void);\n extern void df_process_deferred_rescans (void);\n extern void df_recompute_luids (basic_block);"}, {"sha": "b8e025ac992642ae11406340b8f647494999809e", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -322,6 +322,9 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n       && !diagnostic_report_warnings_p (location))\n     return false;\n \n+  if (diagnostic->kind == DK_NOTE && flag_compare_debug)\n+    return false;\n+\n   if (diagnostic->kind == DK_PEDWARN) \n     diagnostic->kind = pedantic_warning_kind ();\n   "}, {"sha": "76cc269aefeba329ad5a9c2f87a6d66a6a2554ed", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -691,12 +691,21 @@ Return true if the code of g is @code{GIMPLE_ASSIGN}.\n @end deftypefn\n  \n @deftypefn {GIMPLE function} is_gimple_call (gimple g)\n-Return true if the code of g is @code{GIMPLE_CALL}\n+Return true if the code of g is @code{GIMPLE_CALL}.\n @end deftypefn\n  \n+@deftypefn {GIMPLE function} is_gimple_debug (gimple g)\n+Return true if the code of g is @code{GIMPLE_DEBUG}.\n+@end deftypefn\n+\n @deftypefn {GIMPLE function} gimple_assign_cast_p (gimple g)\n Return true if g is a @code{GIMPLE_ASSIGN} that performs a type cast\n-operation\n+operation.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_debug_bind_p (gimple g)\n+Return true if g is a @code{GIMPLE_DEBUG} that binds the value of an\n+expression to a variable.\n @end deftypefn\n \n @node Manipulating GIMPLE statements"}, {"sha": "d0f9839f7057d032fc9d78c841ea954ca397980d", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -2096,8 +2096,53 @@ Removes any @option{-O}-started option from @code{BOOT_CFLAGS}, and adds\n Analogous to @code{bootstrap-O1}.\n \n @item @samp{bootstrap-debug}\n-Builds stage2 without debug information, and uses\n-@file{contrib/compare-debug} to compare object files.\n+Verifies that the compiler generates the same executable code, whether\n+or not it is asked to emit debug information.  To this end, this option\n+builds stage2 host programs without debug information, and uses\n+@file{contrib/compare-debug} to compare them with the stripped stage3\n+object files.  If @code{BOOT_CFLAGS} is overridden so as to not enable\n+debug information, stage2 will have it, and stage3 won't.  This option\n+is enabled by default when GCC bootstrapping is enabled: in addition to\n+better test coverage, it makes default bootstraps faster and leaner.\n+\n+@item @samp{bootstrap-debug-big}\n+In addition to the checking performed by @code{bootstrap-debug}, this\n+option saves internal compiler dumps during stage2 and stage3 and\n+compares them as well, which helps catch additional potential problems,\n+but at a great cost in terms of disk space.\n+\n+@item @samp{bootstrap-debug-lean}\n+This option saves disk space compared with @code{bootstrap-debug-big},\n+but at the expense of some recompilation.  Instead of saving the dumps\n+of stage2 and stage3 until the final compare, it uses\n+@option{-fcompare-debug} to generate, compare and remove the dumps\n+during stage3, repeating the compilation that already took place in\n+stage2, whose dumps were not saved.\n+\n+@item @samp{bootstrap-debug-lib}\n+This option tests executable code invariance over debug information\n+generation on target libraries, just like @code{bootstrap-debug-lean}\n+tests it on host programs.  It builds stage3 libraries with\n+@option{-fcompare-debug}, and it can be used along with any of the\n+@code{bootstrap-debug} options above.\n+\n+There aren't @code{-lean} or @code{-big} counterparts to this option\n+because most libraries are only build in stage3, so bootstrap compares\n+would not get significant coverage.  Moreover, the few libraries built\n+in stage2 are used in stage3 host programs, so we wouldn't want to\n+compile stage2 libraries with different options for comparison purposes.\n+\n+@item @samp{bootstrap-debug-ckovw}\n+Arranges for error messages to be issued if the compiler built on any\n+stage is run without the option @option{-fcompare-debug}.  This is\n+useful to verify the full @option{-fcompare-debug} testing coverage.  It\n+must be used along with @code{bootstrap-debug-lean} and\n+@code{bootstrap-debug-lib}.\n+\n+@item @samp{bootstrap-time}\n+Arranges for the run time of each program started by the GCC driver,\n+built in any stage, to be logged to @file{time.log}, in the top level of\n+the build tree.\n \n @end table\n "}, {"sha": "4aa4f52f0d6446d8c1e58c75a05f307aa4ba906d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -311,6 +311,7 @@ Objective-C and Objective-C++ Dialects}.\n -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol\n -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol\n -ftest-coverage  -ftime-report -fvar-tracking @gol\n+-fvar-tracking-assigments  -fvar-tracking-assignments-toggle @gol\n -g  -g@var{level}  -gtoggle  -gcoff  -gdwarf-@var{version} @gol\n -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol\n -fno-merge-debug-strings -fno-dwarf2-cfi-asm @gol\n@@ -4397,11 +4398,14 @@ assembler (GAS) to fail with an error.\n @opindex gdwarf-@var{version}\n Produce debugging information in DWARF format (if that is\n supported).  This is the format used by DBX on IRIX 6.  The value\n-of @var{version} may be either 2 or 3; the default version is 2.\n+of @var{version} may be either 2, 3 or 4; the default version is 2.\n \n Note that with DWARF version 2 some ports require, and will always\n use, some non-conflicting DWARF 3 extensions in the unwind tables.\n \n+Version 4 may require GDB 7.0 and @option{-fvar-tracking-assignments}\n+for maximum benefit.\n+\n @item -gvms\n @opindex gvms\n Produce debugging information in VMS debug format (if that is\n@@ -4445,9 +4449,12 @@ other options are processed, and it does so only once, no matter how\n many times it is given.  This is mainly intended to be used with\n @option{-fcompare-debug}.\n \n-@item -fdump-final-insns=@var{file}\n-@opindex fdump-final-insns=\n-Dump the final internal representation (RTL) to @var{file}.\n+@item -fdump-final-insns@r{[}=@var{file}@r{]}\n+@opindex fdump-final-insns\n+Dump the final internal representation (RTL) to @var{file}.  If the\n+optional argument is omitted (or if @var{file} is @code{.}), the name\n+of the dump file will be determined by appending @code{.gkd} to the\n+compilation output file name.\n \n @item -fcompare-debug@r{[}=@var{opts}@r{]}\n @opindex fcompare-debug\n@@ -5446,6 +5453,23 @@ It is enabled by default when compiling with optimization (@option{-Os},\n @option{-O}, @option{-O2}, @dots{}), debugging information (@option{-g}) and\n the debug info format supports it.\n \n+@item -fvar-tracking-assignments\n+@opindex fvar-tracking-assignments\n+@opindex fno-var-tracking-assignments\n+Annotate assignments to user variables early in the compilation and\n+attempt to carry the annotations over throughout the compilation all the\n+way to the end, in an attempt to improve debug information while\n+optimizing.  Use of @option{-gdwarf-4} is recommended along with it.\n+\n+It can be enabled even if var-tracking is disabled, in which case\n+annotations will be created and maintained, but discarded at the end.\n+\n+@item -fvar-tracking-assignments-toggle\n+@opindex fvar-tracking-assignments-toggle\n+@opindex fno-var-tracking-assignments-toggle\n+Toggle @option{-fvar-tracking-assignments}, in the same way that\n+@option{-gtoggle} toggles @option{-g}.\n+\n @item -print-file-name=@var{library}\n @opindex print-file-name\n Print the full absolute name of the library file @var{library} that\n@@ -8094,6 +8118,12 @@ with more basic blocks than this parameter won't have loop invariant\n motion optimization performed on them.  The default value of the\n parameter is 1000 for -O1 and 10000 for -O2 and above.\n \n+@item min-nondebug-insn-uid\n+Use uids starting at this parameter for nondebug insns.  The range below\n+the parameter is reserved exclusively for debug insns created by\n+@option{-fvar-tracking-assignments}, but debug insns may get\n+(non-overlapping) uids above it if the reserved range is exhausted.\n+\n @end table\n @end table\n "}, {"sha": "3e6b57d6ca118fc33755366972f1f3c98c8ca3da", "filename": "gcc/dse.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -2387,6 +2387,11 @@ scan_insn (bb_info_t bb_info, rtx insn)\n   insn_info->insn = insn;\n   bb_info->last_insn = insn_info;\n   \n+  if (DEBUG_INSN_P (insn))\n+    {\n+      insn_info->cannot_delete = true;\n+      return;\n+    }\n \n   /* Cselib clears the table for this case, so we have to essentially\n      do the same.  */"}, {"sha": "fd386dd99d113235e6a2021ad87a7313bfecb634", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 795, "deletions": 81, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -407,6 +407,10 @@ struct GTY(()) indirect_string_node {\n \n static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;\n \n+/* True if the compilation unit has location entries that reference\n+   debug strings.  */\n+static GTY(()) bool debug_str_hash_forced = false;\n+\n static GTY(()) int dw2_string_counter;\n static GTY(()) unsigned long dwarf2out_cfi_label_num;\n \n@@ -4142,15 +4146,6 @@ enum dw_val_class\n   dw_val_class_file\n };\n \n-/* Describe a double word constant value.  */\n-/* ??? Every instance of long_long in the code really means CONST_DOUBLE.  */\n-\n-typedef struct GTY(()) dw_long_long_struct {\n-  unsigned long hi;\n-  unsigned long low;\n-}\n-dw_long_long_const;\n-\n /* Describe a floating point constant value, or a vector constant value.  */\n \n typedef struct GTY(()) dw_vec_struct {\n@@ -4173,7 +4168,7 @@ typedef struct GTY(()) dw_val_struct {\n       dw_loc_descr_ref GTY ((tag (\"dw_val_class_loc\"))) val_loc;\n       HOST_WIDE_INT GTY ((default)) val_int;\n       unsigned HOST_WIDE_INT GTY ((tag (\"dw_val_class_unsigned_const\"))) val_unsigned;\n-      dw_long_long_const GTY ((tag (\"dw_val_class_long_long\"))) val_long_long;\n+      rtx GTY ((tag (\"dw_val_class_long_long\"))) val_long_long;\n       dw_vec_const GTY ((tag (\"dw_val_class_vec\"))) val_vec;\n       struct dw_val_die_union\n \t{\n@@ -4528,6 +4523,10 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_call4\";\n     case DW_OP_call_ref:\n       return \"DW_OP_call_ref\";\n+    case DW_OP_implicit_value:\n+      return \"DW_OP_implicit_value\";\n+    case DW_OP_stack_value:\n+      return \"DW_OP_stack_value\";\n     case DW_OP_form_tls_address:\n       return \"DW_OP_form_tls_address\";\n     case DW_OP_call_frame_cfa:\n@@ -4738,6 +4737,10 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n     case DW_OP_call_ref:\n       size += DWARF2_ADDR_SIZE;\n       break;\n+    case DW_OP_implicit_value:\n+      size += size_of_uleb128 (loc->dw_loc_oprnd1.v.val_unsigned)\n+\t      + loc->dw_loc_oprnd1.v.val_unsigned;\n+      break;\n     default:\n       break;\n     }\n@@ -4773,6 +4776,10 @@ size_of_locs (dw_loc_descr_ref loc)\n   return size;\n }\n \n+#ifdef DWARF2_DEBUGGING_INFO\n+static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n+#endif\n+\n /* Output location description stack opcode's operands (if any).  */\n \n static void\n@@ -4794,7 +4801,7 @@ output_loc_operands (dw_loc_descr_ref loc)\n       break;\n     case DW_OP_const8u:\n     case DW_OP_const8s:\n-      gcc_assert (HOST_BITS_PER_LONG >= 64);\n+      gcc_assert (HOST_BITS_PER_WIDE_INT >= 64);\n       dw2_asm_output_data (8, val1->v.val_int, NULL);\n       break;\n     case DW_OP_skip:\n@@ -4808,6 +4815,60 @@ output_loc_operands (dw_loc_descr_ref loc)\n \tdw2_asm_output_data (2, offset, NULL);\n       }\n       break;\n+    case DW_OP_implicit_value:\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n+      switch (val2->val_class)\n+\t{\n+\tcase dw_val_class_const:\n+\t  dw2_asm_output_data (val1->v.val_unsigned, val2->v.val_int, NULL);\n+\t  break;\n+\tcase dw_val_class_vec:\n+\t  {\n+\t    unsigned int elt_size = val2->v.val_vec.elt_size;\n+\t    unsigned int len = val2->v.val_vec.length;\n+\t    unsigned int i;\n+\t    unsigned char *p;\n+\n+\t    if (elt_size > sizeof (HOST_WIDE_INT))\n+\t      {\n+\t\telt_size /= 2;\n+\t\tlen *= 2;\n+\t      }\n+\t    for (i = 0, p = val2->v.val_vec.array;\n+\t\t i < len;\n+\t\t i++, p += elt_size)\n+\t      dw2_asm_output_data (elt_size, extract_int (p, elt_size),\n+\t\t\t\t   \"fp or vector constant word %u\", i);\n+\t  }\n+\t  break;\n+\tcase dw_val_class_long_long:\n+\t  {\n+\t    unsigned HOST_WIDE_INT first, second;\n+\n+\t    if (WORDS_BIG_ENDIAN)\n+\t      {\n+\t\tfirst = CONST_DOUBLE_HIGH (val2->v.val_long_long);\n+\t\tsecond = CONST_DOUBLE_LOW (val2->v.val_long_long);\n+\t      }\n+\t    else\n+\t      {\n+\t\tfirst = CONST_DOUBLE_LOW (val2->v.val_long_long);\n+\t\tsecond = CONST_DOUBLE_HIGH (val2->v.val_long_long);\n+\t      }\n+\t    dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,\n+\t\t\t\t first, \"long long constant\");\n+\t    dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,\n+\t\t\t\t second, NULL);\n+\t  }\n+\t  break;\n+\tcase dw_val_class_addr:\n+\t  gcc_assert (val1->v.val_unsigned == DWARF2_ADDR_SIZE);\n+\t  dw2_asm_output_addr_rtx (DWARF2_ADDR_SIZE, val2->v.val_addr, NULL);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n #else\n     case DW_OP_const2u:\n     case DW_OP_const2s:\n@@ -4817,6 +4878,7 @@ output_loc_operands (dw_loc_descr_ref loc)\n     case DW_OP_const8s:\n     case DW_OP_skip:\n     case DW_OP_bra:\n+    case DW_OP_implicit_value:\n       /* We currently don't make any attempt to make sure these are\n \t aligned properly like we do for the main unwind info, so\n \t don't support emitting things larger than a byte if we're\n@@ -4948,6 +5010,7 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n   switch (loc->dw_loc_opc)\n     {\n     case DW_OP_addr:\n+    case DW_OP_implicit_value:\n       /* We cannot output addresses in .cfi_escape, only bytes.  */\n       gcc_unreachable ();\n \n@@ -4974,7 +5037,7 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n \n     case DW_OP_const8u:\n     case DW_OP_const8s:\n-      gcc_assert (HOST_BITS_PER_LONG >= 64);\n+      gcc_assert (HOST_BITS_PER_WIDE_INT >= 64);\n       fputc (',', asm_out_file);\n       dw2_asm_output_data_raw (8, val1->v.val_int);\n       break;\n@@ -5719,8 +5782,7 @@ static void add_AT_int (dw_die_ref, enum dwarf_attribute, HOST_WIDE_INT);\n static inline HOST_WIDE_INT AT_int (dw_attr_ref);\n static void add_AT_unsigned (dw_die_ref, enum dwarf_attribute, unsigned HOST_WIDE_INT);\n static inline unsigned HOST_WIDE_INT AT_unsigned (dw_attr_ref);\n-static void add_AT_long_long (dw_die_ref, enum dwarf_attribute, unsigned long,\n-\t\t\t      unsigned long);\n+static void add_AT_long_long (dw_die_ref, enum dwarf_attribute, rtx);\n static inline void add_AT_vec (dw_die_ref, enum dwarf_attribute, unsigned int,\n \t\t\t       unsigned int, unsigned char *);\n static hashval_t debug_str_do_hash (const void *);\n@@ -5852,7 +5914,8 @@ static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode,\n \t\t\t\t\t    enum var_init_status);\n static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n \t\t\t\t\t       enum var_init_status);\n-static dw_loc_descr_ref loc_descriptor (rtx, enum var_init_status);\n+static dw_loc_descr_ref loc_descriptor (rtx, enum machine_mode mode,\n+\t\t\t\t\tenum var_init_status);\n static dw_loc_descr_ref loc_descriptor_from_tree_1 (tree, int);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n@@ -5866,7 +5929,6 @@ static void add_AT_location_description\t(dw_die_ref, enum dwarf_attribute,\n static void add_data_member_location_attribute (dw_die_ref, tree);\n static void add_const_value_attribute (dw_die_ref, rtx);\n static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n-static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n static void insert_float (const_rtx, unsigned char *);\n static rtx rtl_for_decl_location (tree);\n static void add_location_or_const_value_attribute (dw_die_ref, tree,\n@@ -6652,14 +6714,13 @@ AT_unsigned (dw_attr_ref a)\n \n static inline void\n add_AT_long_long (dw_die_ref die, enum dwarf_attribute attr_kind,\n-\t\t  long unsigned int val_hi, long unsigned int val_low)\n+\t\t  rtx val_const_double)\n {\n   dw_attr_node attr;\n \n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_long_long;\n-  attr.dw_attr_val.v.val_long_long.hi = val_hi;\n-  attr.dw_attr_val.v.val_long_long.low = val_low;\n+  attr.dw_attr_val.v.val_long_long = val_const_double;\n   add_dwarf_attr (die, &attr);\n }\n \n@@ -6694,6 +6755,8 @@ debug_str_eq (const void *x1, const void *x2)\n \t\t (const char *)x2) == 0;\n }\n \n+/* Add STR to the indirect string hash table.  */\n+\n static struct indirect_string_node *\n find_AT_string (const char *str)\n {\n@@ -6736,6 +6799,37 @@ add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)\n   add_dwarf_attr (die, &attr);\n }\n \n+/* Create a label for an indirect string node, ensuring it is going to\n+   be output, unless its reference count goes down to zero.  */\n+\n+static inline void\n+gen_label_for_indirect_string (struct indirect_string_node *node)\n+{\n+  char label[32];\n+\n+  if (node->label)\n+    return;\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n+  ++dw2_string_counter;\n+  node->label = xstrdup (label);\n+}\n+\n+/* Create a SYMBOL_REF rtx whose value is the initial address of a\n+   debug string STR.  */\n+\n+static inline rtx\n+get_debug_string_label (const char *str)\n+{\n+  struct indirect_string_node *node = find_AT_string (str);\n+\n+  debug_str_hash_forced = true;\n+\n+  gen_label_for_indirect_string (node);\n+\n+  return gen_rtx_SYMBOL_REF (Pmode, node->label);\n+}\n+\n static inline const char *\n AT_string (dw_attr_ref a)\n {\n@@ -6751,7 +6845,6 @@ AT_string_form (dw_attr_ref a)\n {\n   struct indirect_string_node *node;\n   unsigned int len;\n-  char label[32];\n \n   gcc_assert (a && AT_class (a) == dw_val_class_str);\n \n@@ -6774,9 +6867,7 @@ AT_string_form (dw_attr_ref a)\n       && (len - DWARF_OFFSET_SIZE) * node->refcount <= len))\n     return node->form = DW_FORM_string;\n \n-  ASM_GENERATE_INTERNAL_LABEL (label, \"LASF\", dw2_string_counter);\n-  ++dw2_string_counter;\n-  node->label = xstrdup (label);\n+  gen_label_for_indirect_string (node);\n \n   return node->form = DW_FORM_strp;\n }\n@@ -7489,9 +7580,10 @@ print_die (dw_die_ref die, FILE *outfile)\n \t  fprintf (outfile, HOST_WIDE_INT_PRINT_UNSIGNED, AT_unsigned (a));\n \t  break;\n \tcase dw_val_class_long_long:\n-\t  fprintf (outfile, \"constant (%lu,%lu)\",\n-\t\t   a->dw_attr_val.v.val_long_long.hi,\n-\t\t   a->dw_attr_val.v.val_long_long.low);\n+\t  fprintf (outfile, \"constant (\" HOST_WIDE_INT_PRINT_UNSIGNED\n+\t\t\t    \",\" HOST_WIDE_INT_PRINT_UNSIGNED \")\",\n+\t\t   CONST_DOUBLE_HIGH (a->dw_attr_val.v.val_long_long),\n+\t\t   CONST_DOUBLE_LOW (a->dw_attr_val.v.val_long_long));\n \t  break;\n \tcase dw_val_class_vec:\n \t  fprintf (outfile, \"floating-point or vector constant\");\n@@ -7648,7 +7740,8 @@ attr_checksum (dw_attr_ref at, struct md5_ctx *ctx, int *mark)\n       CHECKSUM (at->dw_attr_val.v.val_unsigned);\n       break;\n     case dw_val_class_long_long:\n-      CHECKSUM (at->dw_attr_val.v.val_long_long);\n+      CHECKSUM (CONST_DOUBLE_HIGH (at->dw_attr_val.v.val_long_long));\n+      CHECKSUM (CONST_DOUBLE_LOW (at->dw_attr_val.v.val_long_long));\n       break;\n     case dw_val_class_vec:\n       CHECKSUM (at->dw_attr_val.v.val_vec);\n@@ -7748,8 +7841,10 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n     case dw_val_class_unsigned_const:\n       return v1->v.val_unsigned == v2->v.val_unsigned;\n     case dw_val_class_long_long:\n-      return v1->v.val_long_long.hi == v2->v.val_long_long.hi\n-\t     && v1->v.val_long_long.low == v2->v.val_long_long.low;\n+      return CONST_DOUBLE_HIGH (v1->v.val_long_long)\n+\t     == CONST_DOUBLE_HIGH (v2->v.val_long_long)\n+\t     && CONST_DOUBLE_LOW (v1->v.val_long_long)\n+\t\t== CONST_DOUBLE_LOW (v2->v.val_long_long);\n     case dw_val_class_vec:\n       if (v1->v.val_vec.length != v2->v.val_vec.length\n \t  || v1->v.val_vec.elt_size != v2->v.val_vec.elt_size)\n@@ -8358,7 +8453,7 @@ size_of_die (dw_die_ref die)\n \t  size += constant_size (AT_unsigned (a));\n \t  break;\n \tcase dw_val_class_long_long:\n-\t  size += 1 + 2*HOST_BITS_PER_LONG/HOST_BITS_PER_CHAR; /* block */\n+\t  size += 1 + 2*HOST_BITS_PER_WIDE_INT/HOST_BITS_PER_CHAR; /* block */\n \t  break;\n \tcase dw_val_class_vec:\n \t  size += constant_size (a->dw_attr_val.v.val_vec.length\n@@ -8840,23 +8935,24 @@ output_die (dw_die_ref die)\n \t    unsigned HOST_WIDE_INT first, second;\n \n \t    dw2_asm_output_data (1,\n-\t\t\t\t 2 * HOST_BITS_PER_LONG / HOST_BITS_PER_CHAR,\n+\t\t\t\t 2 * HOST_BITS_PER_WIDE_INT\n+\t\t\t\t / HOST_BITS_PER_CHAR,\n \t\t\t\t \"%s\", name);\n \n \t    if (WORDS_BIG_ENDIAN)\n \t      {\n-\t\tfirst = a->dw_attr_val.v.val_long_long.hi;\n-\t\tsecond = a->dw_attr_val.v.val_long_long.low;\n+\t\tfirst = CONST_DOUBLE_HIGH (a->dw_attr_val.v.val_long_long);\n+\t\tsecond = CONST_DOUBLE_LOW (a->dw_attr_val.v.val_long_long);\n \t      }\n \t    else\n \t      {\n-\t\tfirst = a->dw_attr_val.v.val_long_long.low;\n-\t\tsecond = a->dw_attr_val.v.val_long_long.hi;\n+\t\tfirst = CONST_DOUBLE_LOW (a->dw_attr_val.v.val_long_long);\n+\t\tsecond = CONST_DOUBLE_HIGH (a->dw_attr_val.v.val_long_long);\n \t      }\n \n-\t    dw2_asm_output_data (HOST_BITS_PER_LONG / HOST_BITS_PER_CHAR,\n+\t    dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,\n \t\t\t\t first, \"long long constant\");\n-\t    dw2_asm_output_data (HOST_BITS_PER_LONG / HOST_BITS_PER_CHAR,\n+\t    dw2_asm_output_data (HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR,\n \t\t\t\t second, NULL);\n \t  }\n \t  break;\n@@ -10922,6 +11018,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n   enum dwarf_location_atom op;\n+  dw_loc_descr_ref op0, op1;\n \n   /* Note that for a dynamically sized array, the location we will generate a\n      description of here will be the lowest numbered location which is\n@@ -10947,6 +11044,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t legitimate to make the Dwarf info refer to the whole register which\n \t contains the given subreg.  */\n       rtl = XEXP (rtl, 0);\n+      if (GET_MODE_SIZE (GET_MODE (rtl)) > DWARF2_ADDR_SIZE)\n+\tbreak;\n \n       /* ... fall through ...  */\n \n@@ -10978,6 +11077,29 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t}\n       break;\n \n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      if (op0 == 0)\n+\tbreak;\n+      else\n+\t{\n+\t  int shift = DWARF2_ADDR_SIZE\n+\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)));\n+\t  shift *= BITS_PER_UNIT;\n+\t  if (GET_CODE (rtl) == SIGN_EXTEND)\n+\t    op = DW_OP_shra;\n+\t  else\n+\t    op = DW_OP_shr;\n+\t  mem_loc_result = op0;\n+\t  add_loc_descr (&mem_loc_result, int_loc_descriptor (shift));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_shl, 0, 0));\n+\t  add_loc_descr (&mem_loc_result, int_loc_descriptor (shift));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+\t}\n+      break;\n+\n     case MEM:\n       mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n \t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n@@ -11022,6 +11144,27 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t    return 0;\n \t}\n \n+      if (GET_CODE (rtl) == SYMBOL_REF\n+\t  && SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)\n+\t{\n+\t  dw_loc_descr_ref temp;\n+\n+\t  /* If this is not defined, we have no way to emit the data.  */\n+\t  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)\n+\t    break;\n+\n+\t  temp = new_loc_descr (DW_OP_addr, 0, 0);\n+\t  temp->dw_loc_oprnd1.val_class = dw_val_class_addr;\n+\t  temp->dw_loc_oprnd1.v.val_addr = rtl;\n+\t  temp->dtprel = true;\n+\n+\t  mem_loc_result = new_loc_descr (DW_OP_GNU_push_tls_address, 0, 0);\n+\t  add_loc_descr (&mem_loc_result, temp);\n+\n+\t  break;\n+\t}\n+\n+    symref:\n       mem_loc_result = new_loc_descr (DW_OP_addr, 0, 0);\n       mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_addr;\n       mem_loc_result->dw_loc_oprnd1.v.val_addr = rtl;\n@@ -11076,10 +11219,22 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \n     /* If a pseudo-reg is optimized away, it is possible for it to\n        be replaced with a MEM containing a multiply or shift.  */\n+    case MINUS:\n+      op = DW_OP_minus;\n+      goto do_binop;\n+\n     case MULT:\n       op = DW_OP_mul;\n       goto do_binop;\n \n+    case DIV:\n+      op = DW_OP_div;\n+      goto do_binop;\n+\n+    case MOD:\n+      op = DW_OP_mod;\n+      goto do_binop;\n+\n     case ASHIFT:\n       op = DW_OP_shl;\n       goto do_binop;\n@@ -11092,21 +11247,54 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       op = DW_OP_shr;\n       goto do_binop;\n \n+    case AND:\n+      op = DW_OP_and;\n+      goto do_binop;\n+\n+    case IOR:\n+      op = DW_OP_or;\n+      goto do_binop;\n+\n+    case XOR:\n+      op = DW_OP_xor;\n+      goto do_binop;\n+\n     do_binop:\n-      {\n-\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n-\t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n-\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n-\t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \n-\tif (op0 == 0 || op1 == 0)\n-\t  break;\n+      if (op0 == 0 || op1 == 0)\n+\tbreak;\n+\n+      mem_loc_result = op0;\n+      add_loc_descr (&mem_loc_result, op1);\n+      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+      break;\n \n-\tmem_loc_result = op0;\n-\tadd_loc_descr (&mem_loc_result, op1);\n-\tadd_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+    case NOT:\n+      op = DW_OP_not;\n+      goto do_unop;\n+\n+    case ABS:\n+      op = DW_OP_abs;\n+      goto do_unop;\n+\n+    case NEG:\n+      op = DW_OP_neg;\n+      goto do_unop;\n+\n+    do_unop:\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\n+      if (op0 == 0)\n \tbreak;\n-      }\n+\n+      mem_loc_result = op0;\n+      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+      break;\n \n     case CONST_INT:\n       mem_loc_result = int_loc_descriptor (INTVAL (rtl));\n@@ -11117,14 +11305,287 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n \t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n       break;\n \n+    case EQ:\n+      op = DW_OP_eq;\n+      goto do_scompare;\n+\n+    case GE:\n+      op = DW_OP_ge;\n+      goto do_scompare;\n+\n+    case GT:\n+      op = DW_OP_gt;\n+      goto do_scompare;\n+\n+    case LE:\n+      op = DW_OP_le;\n+      goto do_scompare;\n+\n+    case LT:\n+      op = DW_OP_lt;\n+      goto do_scompare;\n+\n+    case NE:\n+      op = DW_OP_ne;\n+      goto do_scompare;\n+\n+    do_scompare:\n+      if (GET_MODE_CLASS (GET_MODE (XEXP (rtl, 0))) != MODE_INT\n+\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) > DWARF2_ADDR_SIZE\n+\t  || GET_MODE (XEXP (rtl, 0)) != GET_MODE (XEXP (rtl, 1)))\n+\tbreak;\n+\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\n+      if (op0 == 0 || op1 == 0)\n+\tbreak;\n+\n+      if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) < DWARF2_ADDR_SIZE)\n+\t{\n+\t  int shift = DWARF2_ADDR_SIZE\n+\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)));\n+\t  shift *= BITS_PER_UNIT;\n+\t  add_loc_descr (&op0, int_loc_descriptor (shift));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+\t  if (CONST_INT_P (XEXP (rtl, 1)))\n+\t    op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) << shift);\n+\t  else\n+\t    {\n+\t      add_loc_descr (&op1, int_loc_descriptor (shift));\n+\t      add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n+\t    }\n+\t}\n+\n+    do_compare:\n+      mem_loc_result = op0;\n+      add_loc_descr (&mem_loc_result, op1);\n+      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+      if (STORE_FLAG_VALUE != 1)\n+\t{\n+\t  add_loc_descr (&mem_loc_result,\n+\t\t\t int_loc_descriptor (STORE_FLAG_VALUE));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_mul, 0, 0));\n+\t}\n+      break;\n+\n+    case GEU:\n+      op = DW_OP_ge;\n+      goto do_ucompare;\n+\n+    case GTU:\n+      op = DW_OP_gt;\n+      goto do_ucompare;\n+\n+    case LEU:\n+      op = DW_OP_le;\n+      goto do_ucompare;\n+\n+    case LTU:\n+      op = DW_OP_lt;\n+      goto do_ucompare;\n+\n+    do_ucompare:\n+      if (GET_MODE_CLASS (GET_MODE (XEXP (rtl, 0))) != MODE_INT\n+\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) > DWARF2_ADDR_SIZE\n+\t  || GET_MODE (XEXP (rtl, 0)) != GET_MODE (XEXP (rtl, 1)))\n+\tbreak;\n+\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\n+      if (op0 == 0 || op1 == 0)\n+\tbreak;\n+\n+      if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) < DWARF2_ADDR_SIZE)\n+\t{\n+\t  HOST_WIDE_INT mask = GET_MODE_MASK (GET_MODE (XEXP (rtl, 0)));\n+\t  add_loc_descr (&op0, int_loc_descriptor (mask));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t  if (CONST_INT_P (XEXP (rtl, 1)))\n+\t    op1 = int_loc_descriptor (INTVAL (XEXP (rtl, 1)) & mask);\n+\t  else\n+\t    {\n+\t      add_loc_descr (&op1, int_loc_descriptor (mask));\n+\t      add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT bias = 1;\n+\t  bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t  if (CONST_INT_P (XEXP (rtl, 1)))\n+\t    op1 = int_loc_descriptor ((unsigned HOST_WIDE_INT) bias\n+\t\t\t\t      + INTVAL (XEXP (rtl, 1)));\n+\t  else\n+\t    add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t}\n+      goto do_compare;\n+\n+    case SMIN:\n+    case SMAX:\n+    case UMIN:\n+    case UMAX:\n+      if (GET_MODE_CLASS (GET_MODE (XEXP (rtl, 0))) != MODE_INT\n+\t  || GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) > DWARF2_ADDR_SIZE\n+\t  || GET_MODE (XEXP (rtl, 0)) != GET_MODE (XEXP (rtl, 1)))\n+\tbreak;\n+\n+      op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+      op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n+\n+      if (op0 == 0 || op1 == 0)\n+\tbreak;\n+\n+      add_loc_descr (&op0, new_loc_descr (DW_OP_dup, 0, 0));\n+      add_loc_descr (&op1, new_loc_descr (DW_OP_swap, 0, 0));\n+      add_loc_descr (&op1, new_loc_descr (DW_OP_over, 0, 0));\n+      if (GET_CODE (rtl) == UMIN || GET_CODE (rtl) == UMAX)\n+\t{\n+\t  if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) < DWARF2_ADDR_SIZE)\n+\t    {\n+\t      HOST_WIDE_INT mask = GET_MODE_MASK (GET_MODE (XEXP (rtl, 0)));\n+\t      add_loc_descr (&op0, int_loc_descriptor (mask));\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_and, 0, 0));\n+\t      add_loc_descr (&op1, int_loc_descriptor (mask));\n+\t      add_loc_descr (&op1, new_loc_descr (DW_OP_and, 0, 0));\n+\t    }\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT bias = 1;\n+\t      bias <<= (DWARF2_ADDR_SIZE * BITS_PER_UNIT - 1);\n+\t      add_loc_descr (&op0, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t      add_loc_descr (&op1, new_loc_descr (DW_OP_plus_uconst, bias, 0));\n+\t    }\n+\t}\n+      else if (GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0))) < DWARF2_ADDR_SIZE)\n+\t{\n+\t  int shift = DWARF2_ADDR_SIZE\n+\t\t      - GET_MODE_SIZE (GET_MODE (XEXP (rtl, 0)));\n+\t  shift *= BITS_PER_UNIT;\n+\t  add_loc_descr (&op0, int_loc_descriptor (shift));\n+\t  add_loc_descr (&op0, new_loc_descr (DW_OP_shl, 0, 0));\n+\t  add_loc_descr (&op1, int_loc_descriptor (shift));\n+\t  add_loc_descr (&op1, new_loc_descr (DW_OP_shl, 0, 0));\n+\t}\n+\n+      if (GET_CODE (rtl) == SMIN || GET_CODE (rtl) == UMIN)\n+\top = DW_OP_lt;\n+      else\n+\top = DW_OP_gt;\n+      mem_loc_result = op0;\n+      add_loc_descr (&mem_loc_result, op1);\n+      add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+      {\n+\tdw_loc_descr_ref bra_node, drop_node;\n+\n+\tbra_node = new_loc_descr (DW_OP_bra, 0, 0);\n+\tadd_loc_descr (&mem_loc_result, bra_node);\n+\tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_swap, 0, 0));\n+\tdrop_node = new_loc_descr (DW_OP_drop, 0, 0);\n+\tadd_loc_descr (&mem_loc_result, drop_node);\n+\tbra_node->dw_loc_oprnd1.val_class = dw_val_class_loc;\n+\tbra_node->dw_loc_oprnd1.v.val_loc = drop_node;\n+      }\n+      break;\n+\n+    case ZERO_EXTRACT:\n+    case SIGN_EXTRACT:\n+      if (CONST_INT_P (XEXP (rtl, 1))\n+\t  && CONST_INT_P (XEXP (rtl, 2))\n+\t  && ((unsigned) INTVAL (XEXP (rtl, 1))\n+\t      + (unsigned) INTVAL (XEXP (rtl, 2))\n+\t      <= GET_MODE_BITSIZE (GET_MODE (rtl)))\n+\t  && GET_MODE_BITSIZE (GET_MODE (rtl)) <= DWARF2_ADDR_SIZE\n+\t  && GET_MODE_BITSIZE (GET_MODE (XEXP (rtl, 0))) <= DWARF2_ADDR_SIZE)\n+\t{\n+\t  int shift, size;\n+\t  op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\t    VAR_INIT_STATUS_INITIALIZED);\n+\t  if (op0 == 0)\n+\t    break;\n+\t  if (GET_CODE (rtl) == SIGN_EXTRACT)\n+\t    op = DW_OP_shra;\n+\t  else\n+\t    op = DW_OP_shr;\n+\t  mem_loc_result = op0;\n+\t  size = INTVAL (XEXP (rtl, 1));\n+\t  shift = INTVAL (XEXP (rtl, 2));\n+\t  if (BITS_BIG_ENDIAN)\n+\t    shift = GET_MODE_BITSIZE (GET_MODE (XEXP (rtl, 0)))\n+\t\t    - shift - size;\n+\t  add_loc_descr (&mem_loc_result,\n+\t\t\t int_loc_descriptor (DWARF2_ADDR_SIZE - shift - size));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_shl, 0, 0));\n+\t  add_loc_descr (&mem_loc_result,\n+\t\t\t int_loc_descriptor (DWARF2_ADDR_SIZE - size));\n+\t  add_loc_descr (&mem_loc_result, new_loc_descr (op, 0, 0));\n+\t}\n+      break;\n+\n+    case COMPARE:\n+    case IF_THEN_ELSE:\n+    case ROTATE:\n+    case ROTATERT:\n+    case TRUNCATE:\n+      /* In theory, we could implement the above.  */\n+      /* DWARF cannot represent the unsigned compare operations\n+\t natively.  */\n+    case SS_MULT:\n+    case US_MULT:\n+    case SS_DIV:\n+    case US_DIV:\n+    case UDIV:\n+    case UMOD:\n+    case UNORDERED:\n+    case ORDERED:\n+    case UNEQ:\n+    case UNGE:\n+    case UNLE:\n+    case UNLT:\n+    case LTGT:\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case UNSIGNED_FLOAT:\n+    case FIX:\n+    case UNSIGNED_FIX:\n+    case FRACT_CONVERT:\n+    case UNSIGNED_FRACT_CONVERT:\n+    case SAT_FRACT:\n+    case UNSIGNED_SAT_FRACT:\n+    case SQRT:\n+    case BSWAP:\n+    case FFS:\n+    case CLZ:\n+    case CTZ:\n+    case POPCOUNT:\n+    case PARITY:\n+    case ASM_OPERANDS:\n     case UNSPEC:\n       /* If delegitimize_address couldn't do anything with the UNSPEC, we\n \t can't express it in the debug info.  This can happen e.g. with some\n \t TLS UNSPECs.  */\n       break;\n \n+    case CONST_STRING:\n+      rtl = get_debug_string_label (XSTR (rtl, 0));\n+      goto symref;\n+\n     default:\n+#ifdef ENABLE_CHECKING\n+      print_rtl (stderr, rtl);\n       gcc_unreachable ();\n+#else\n+      break;\n+#endif\n     }\n \n   if (mem_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n@@ -11140,8 +11601,10 @@ static dw_loc_descr_ref\n concat_loc_descriptor (rtx x0, rtx x1, enum var_init_status initialized)\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n-  dw_loc_descr_ref x0_ref = loc_descriptor (x0, VAR_INIT_STATUS_INITIALIZED);\n-  dw_loc_descr_ref x1_ref = loc_descriptor (x1, VAR_INIT_STATUS_INITIALIZED);\n+  dw_loc_descr_ref x0_ref\n+    = loc_descriptor (x0, VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n+  dw_loc_descr_ref x1_ref\n+    = loc_descriptor (x1, VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n \n   if (x0_ref == 0 || x1_ref == 0)\n     return 0;\n@@ -11173,7 +11636,7 @@ concatn_loc_descriptor (rtx concatn, enum var_init_status initialized)\n       dw_loc_descr_ref ref;\n       rtx x = XVECEXP (concatn, 0, i);\n \n-      ref = loc_descriptor (x, VAR_INIT_STATUS_INITIALIZED);\n+      ref = loc_descriptor (x, VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n       if (ref == NULL)\n \treturn NULL;\n \n@@ -11193,16 +11656,23 @@ concatn_loc_descriptor (rtx concatn, enum var_init_status initialized)\n    memory location we provide a Dwarf postfix expression describing how to\n    generate the (dynamic) address of the object onto the address stack.\n \n+   MODE is mode of the decl if this loc_descriptor is going to be used in\n+   .debug_loc section where DW_OP_stack_value and DW_OP_implicit_value are\n+   allowed, VOIDmode otherwise.\n+\n    If we don't know how to describe it, return 0.  */\n \n static dw_loc_descr_ref\n-loc_descriptor (rtx rtl, enum var_init_status initialized)\n+loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\tenum var_init_status initialized)\n {\n   dw_loc_descr_ref loc_result = NULL;\n \n   switch (GET_CODE (rtl))\n     {\n     case SUBREG:\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n       /* The case of a subreg may arise when we have a local (register)\n \t variable or a formal (register) parameter which doesn't quite fill\n \t up an entire register.  For now, just assume that it is\n@@ -11236,7 +11706,8 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n       /* Single part.  */\n       if (GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n \t{\n-\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0), initialized);\n+\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0), mode,\n+\t\t\t\t       initialized);\n \t  break;\n \t}\n \n@@ -11252,7 +11723,7 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n \n \t/* Create the first one, so we have something to add to.  */\n \tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n-\t\t\t\t     initialized);\n+\t\t\t\t     VOIDmode, initialized);\n \tif (loc_result == NULL)\n \t  return NULL;\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n@@ -11262,7 +11733,7 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n \t    dw_loc_descr_ref temp;\n \n \t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n-\t\t\t\t   initialized);\n+\t\t\t\t   VOIDmode, initialized);\n \t    if (temp == NULL)\n \t      return NULL;\n \t    add_loc_descr (&loc_result, temp);\n@@ -11272,8 +11743,206 @@ loc_descriptor (rtx rtl, enum var_init_status initialized)\n       }\n       break;\n \n+    case CONST_INT:\n+      if (mode != VOIDmode && mode != BLKmode && dwarf_version >= 4)\n+        {\n+          HOST_WIDE_INT i = INTVAL (rtl);\n+          int litsize;\n+          if (i >= 0)\n+            {\n+              if (i <= 31)\n+\t\tlitsize = 1;\n+\t      else if (i <= 0xff)\n+\t\tlitsize = 2;\n+\t      else if (i <= 0xffff)\n+\t\tlitsize = 3;\n+\t      else if (HOST_BITS_PER_WIDE_INT == 32\n+\t\t       || i <= 0xffffffff)\n+\t\tlitsize = 5;\n+\t      else\n+\t\tlitsize = 1 + size_of_uleb128 ((unsigned HOST_WIDE_INT) i);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (i >= -0x80)\n+\t\tlitsize = 2;\n+\t      else if (i >= -0x8000)\n+\t\tlitsize = 3;\n+\t      else if (HOST_BITS_PER_WIDE_INT == 32\n+\t\t       || i >= -0x80000000)\n+\t\tlitsize = 5;\n+\t      else\n+\t\tlitsize = 1 + size_of_sleb128 (i);\n+\t    }\n+\t  /* Determine if DW_OP_stack_value or DW_OP_implicit_value\n+\t     is more compact.  For DW_OP_stack_value we need:\n+\t     litsize + 1 (DW_OP_stack_value) + 1 (DW_OP_bit_size)\n+\t     + 1 (mode size)\n+\t     and for DW_OP_implicit_value:\n+\t     1 (DW_OP_implicit_value) + 1 (length) + mode_size.  */\n+\t  if (DWARF2_ADDR_SIZE >= GET_MODE_SIZE (mode)\n+\t      && litsize + 1 + 1 + 1 < 1 + 1 + GET_MODE_SIZE (mode))\n+\t    {\n+\t      loc_result = int_loc_descriptor (i);\n+\t      add_loc_descr (&loc_result,\n+\t\t\t     new_loc_descr (DW_OP_stack_value, 0, 0));\n+\t      add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n+\t      return loc_result;\n+\t    }\n+\n+\t  loc_result = new_loc_descr (DW_OP_implicit_value,\n+\t\t\t\t      GET_MODE_SIZE (mode), 0);\n+\t  loc_result->dw_loc_oprnd2.val_class = dw_val_class_const;\n+\t  loc_result->dw_loc_oprnd2.v.val_int = i;\n+\t}\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (mode != VOIDmode && dwarf_version >= 4)\n+\t{\n+\t  /* Note that a CONST_DOUBLE rtx could represent either an integer\n+\t     or a floating-point constant.  A CONST_DOUBLE is used whenever\n+\t     the constant requires more than one word in order to be\n+\t     adequately represented.  We output CONST_DOUBLEs as blocks.  */\n+\t  if (GET_MODE (rtl) != VOIDmode)\n+\t    mode = GET_MODE (rtl);\n+\n+\t  loc_result = new_loc_descr (DW_OP_implicit_value,\n+\t\t\t\t      GET_MODE_SIZE (mode), 0);\n+\t  if (SCALAR_FLOAT_MODE_P (mode))\n+\t    {\n+\t      unsigned int length = GET_MODE_SIZE (mode);\n+\t      unsigned char *array = GGC_NEWVEC (unsigned char, length);\n+\n+\t      insert_float (rtl, array);\n+\t      loc_result->dw_loc_oprnd2.val_class = dw_val_class_vec;\n+\t      loc_result->dw_loc_oprnd2.v.val_vec.length = length / 4;\n+\t      loc_result->dw_loc_oprnd2.v.val_vec.elt_size = 4;\n+\t      loc_result->dw_loc_oprnd2.v.val_vec.array = array;\n+\t    }\n+\t  else\n+\t    {\n+\t      loc_result->dw_loc_oprnd2.val_class = dw_val_class_long_long;\n+\t      loc_result->dw_loc_oprnd2.v.val_long_long = rtl;\n+\t    }\n+\t}\n+      break;\n+\n+    case CONST_VECTOR:\n+      if (mode != VOIDmode && dwarf_version >= 4)\n+\t{\n+\t  unsigned int elt_size = GET_MODE_UNIT_SIZE (GET_MODE (rtl));\n+\t  unsigned int length = CONST_VECTOR_NUNITS (rtl);\n+\t  unsigned char *array = GGC_NEWVEC (unsigned char, length * elt_size);\n+\t  unsigned int i;\n+\t  unsigned char *p;\n+\n+\t  mode = GET_MODE (rtl);\n+\t  switch (GET_MODE_CLASS (mode))\n+\t    {\n+\t    case MODE_VECTOR_INT:\n+\t      for (i = 0, p = array; i < length; i++, p += elt_size)\n+\t\t{\n+\t\t  rtx elt = CONST_VECTOR_ELT (rtl, i);\n+\t\t  HOST_WIDE_INT lo, hi;\n+\n+\t\t  switch (GET_CODE (elt))\n+\t\t    {\n+\t\t    case CONST_INT:\n+\t\t      lo = INTVAL (elt);\n+\t\t      hi = -(lo < 0);\n+\t\t      break;\n+\n+\t\t    case CONST_DOUBLE:\n+\t\t      lo = CONST_DOUBLE_LOW (elt);\n+\t\t      hi = CONST_DOUBLE_HIGH (elt);\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n+\t\t    }\n+\n+\t\t  if (elt_size <= sizeof (HOST_WIDE_INT))\n+\t\t    insert_int (lo, elt_size, p);\n+\t\t  else\n+\t\t    {\n+\t\t      unsigned char *p0 = p;\n+\t\t      unsigned char *p1 = p + sizeof (HOST_WIDE_INT);\n+\n+\t\t      gcc_assert (elt_size == 2 * sizeof (HOST_WIDE_INT));\n+\t\t      if (WORDS_BIG_ENDIAN)\n+\t\t\t{\n+\t\t\t  p0 = p1;\n+\t\t\t  p1 = p;\n+\t\t\t}\n+\t\t      insert_int (lo, sizeof (HOST_WIDE_INT), p0);\n+\t\t      insert_int (hi, sizeof (HOST_WIDE_INT), p1);\n+\t\t    }\n+\t\t}\n+\t      break;\n+\n+\t    case MODE_VECTOR_FLOAT:\n+\t      for (i = 0, p = array; i < length; i++, p += elt_size)\n+\t\t{\n+\t\t  rtx elt = CONST_VECTOR_ELT (rtl, i);\n+\t\t  insert_float (elt, p);\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  loc_result = new_loc_descr (DW_OP_implicit_value,\n+\t\t\t\t      length * elt_size, 0);\n+\t  loc_result->dw_loc_oprnd2.val_class = dw_val_class_vec;\n+\t  loc_result->dw_loc_oprnd2.v.val_vec.length = length;\n+\t  loc_result->dw_loc_oprnd2.v.val_vec.elt_size = elt_size;\n+\t  loc_result->dw_loc_oprnd2.v.val_vec.array = array;\n+\t}\n+      break;\n+\n+    case CONST:\n+      if (mode == VOIDmode\n+\t  || GET_CODE (XEXP (rtl, 0)) == CONST_INT\n+\t  || GET_CODE (XEXP (rtl, 0)) == CONST_DOUBLE\n+\t  || GET_CODE (XEXP (rtl, 0)) == CONST_VECTOR)\n+\t{\n+\t  loc_result = loc_descriptor (XEXP (rtl, 0), mode, initialized);\n+\t  break;\n+\t}\n+      /* FALLTHROUGH */\n+    case SYMBOL_REF:\n+      if (GET_CODE (rtl) == SYMBOL_REF\n+\t  && SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)\n+\tbreak;\n+    case LABEL_REF:\n+      if (mode != VOIDmode && GET_MODE_SIZE (mode) == DWARF2_ADDR_SIZE\n+\t  && dwarf_version >= 4)\n+\t{\n+\t  loc_result = new_loc_descr (DW_OP_implicit_value,\n+\t\t\t\t      DWARF2_ADDR_SIZE, 0);\n+\t  loc_result->dw_loc_oprnd2.val_class = dw_val_class_addr;\n+\t  loc_result->dw_loc_oprnd2.v.val_addr = rtl;\n+\t  VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n+\t}\n+      break;\n+\n     default:\n-      gcc_unreachable ();\n+      if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE (rtl) == mode\n+\t  && GET_MODE_SIZE (GET_MODE (rtl)) <= DWARF2_ADDR_SIZE\n+\t  && dwarf_version >= 4)\n+\t{\n+\t  /* Value expression.  */\n+\t  loc_result = mem_loc_descriptor (rtl, VOIDmode, initialized);\n+\t  if (loc_result)\n+\t    {\n+\t      add_loc_descr (&loc_result,\n+\t\t\t     new_loc_descr (DW_OP_stack_value, 0, 0));\n+\t      add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n+\t    }\n+\t}\n+      break;\n     }\n \n   return loc_result;\n@@ -11416,7 +12085,8 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n \t    /* Certain constructs can only be represented at top-level.  */\n \t    if (want_address == 2)\n-\t      return loc_descriptor (rtl, VAR_INIT_STATUS_INITIALIZED);\n+\t      return loc_descriptor (rtl, VOIDmode,\n+\t\t\t\t     VAR_INIT_STATUS_INITIALIZED);\n \n \t    mode = GET_MODE (rtl);\n \t    if (MEM_P (rtl))\n@@ -12131,13 +12801,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \t    add_AT_vec (die, DW_AT_const_value, length / 4, 4, array);\n \t  }\n \telse\n-\t  {\n-\t    /* ??? We really should be using HOST_WIDE_INT throughout.  */\n-\t    gcc_assert (HOST_BITS_PER_LONG == HOST_BITS_PER_WIDE_INT);\n-\n-\t    add_AT_long_long (die, DW_AT_const_value,\n-\t\t\t      CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n-\t  }\n+\t  add_AT_long_long (die, DW_AT_const_value, rtl);\n       }\n       break;\n \n@@ -12213,9 +12877,18 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n       add_AT_string (die, DW_AT_const_value, XSTR (rtl, 0));\n       break;\n \n+    case CONST:\n+      if (CONSTANT_P (XEXP (rtl, 0)))\n+\t{\n+\t  add_const_value_attribute (die, XEXP (rtl, 0));\n+\t  return;\n+\t}\n+      /* FALLTHROUGH */\n     case SYMBOL_REF:\n+      if (GET_CODE (rtl) == SYMBOL_REF\n+\t  && SYMBOL_REF_TLS_MODEL (rtl) != TLS_MODEL_NONE)\n+\tbreak;\n     case LABEL_REF:\n-    case CONST:\n       add_AT_addr (die, DW_AT_const_value, rtl);\n       VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n       break;\n@@ -12761,7 +13434,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       else\n \tinitialized = VAR_INIT_STATUS_INITIALIZED;\n \n-      descr = loc_by_reference (loc_descriptor (varloc, initialized), decl);\n+      descr = loc_by_reference (loc_descriptor (varloc, DECL_MODE (decl),\n+\t\t\t\t\t\tinitialized), decl);\n       list = new_loc_list (descr, node->label, node->next->label, secname, 1);\n       node = node->next;\n \n@@ -12773,8 +13447,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t    enum var_init_status initialized =\n \t      NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n \t    varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\t    descr = loc_by_reference (loc_descriptor (varloc, initialized),\n-\t\t\t\t      decl);\n+\t    descr = loc_by_reference (loc_descriptor (varloc, DECL_MODE (decl),\n+\t\t\t\t      initialized), decl);\n \t    add_loc_descr_to_loc_list (&list, descr,\n \t\t\t\t       node->label, node->next->label, secname);\n \t  }\n@@ -12796,7 +13470,9 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t\t\t\t\t   current_function_funcdef_no);\n \t      endname = ggc_strdup (label_id);\n \t    }\n-\t  descr = loc_by_reference (loc_descriptor (varloc, initialized),\n+\t  descr = loc_by_reference (loc_descriptor (varloc,\n+\t\t\t\t\t\t    DECL_MODE (decl),\n+\t\t\t\t\t\t    initialized),\n \t\t\t\t    decl);\n \t  add_loc_descr_to_loc_list (&list, descr,\n \t\t\t\t     node->label, endname, secname);\n@@ -12825,7 +13501,17 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       enum var_init_status status;\n       node = loc_list->first;\n       status = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note), status);\n+      rtl = NOTE_VAR_LOCATION (node->var_loc_note);\n+      if (GET_CODE (rtl) == VAR_LOCATION\n+\t  && GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n+\trtl = XEXP (XEXP (rtl, 1), 0);\n+      if (CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n+\t{\n+\t  add_const_value_attribute (die, rtl);\n+\t  return;\n+\t}\n+      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note),\n+\t\t\t      DECL_MODE (decl), status);\n       if (descr)\n \t{\n \t  descr = loc_by_reference (descr, decl);\n@@ -16898,10 +17584,11 @@ dwarf2out_set_name (tree decl, tree name)\n static void\n dwarf2out_var_location (rtx loc_note)\n {\n-  char loclabel[MAX_ARTIFICIAL_LABEL_BYTES];\n+  char loclabel[MAX_ARTIFICIAL_LABEL_BYTES + 2];\n   struct var_loc_node *newloc;\n   rtx next_real;\n   static const char *last_label;\n+  static const char *last_postcall_label;\n   static bool last_in_cold_section_p;\n   tree decl;\n \n@@ -16917,27 +17604,38 @@ dwarf2out_var_location (rtx loc_note)\n   newloc = GGC_CNEW (struct var_loc_node);\n   /* If there were no real insns between note we processed last time\n      and this note, use the label we emitted last time.  */\n-  if (last_var_location_insn != NULL_RTX\n-      && last_var_location_insn == next_real\n-      && last_in_cold_section_p == in_cold_section_p)\n-    newloc->label = last_label;\n-  else\n+  if (last_var_location_insn == NULL_RTX\n+      || last_var_location_insn != next_real\n+      || last_in_cold_section_p != in_cold_section_p)\n     {\n       ASM_GENERATE_INTERNAL_LABEL (loclabel, \"LVL\", loclabel_num);\n       ASM_OUTPUT_DEBUG_LABEL (asm_out_file, \"LVL\", loclabel_num);\n       loclabel_num++;\n-      newloc->label = ggc_strdup (loclabel);\n+      last_label = ggc_strdup (loclabel);\n+      if (!NOTE_DURING_CALL_P (loc_note))\n+\tlast_postcall_label = NULL;\n     }\n   newloc->var_loc_note = loc_note;\n   newloc->next = NULL;\n \n+  if (!NOTE_DURING_CALL_P (loc_note))\n+    newloc->label = last_label;\n+  else\n+    {\n+      if (!last_postcall_label)\n+\t{\n+\t  sprintf (loclabel, \"%s-1\", last_label);\n+\t  last_postcall_label = ggc_strdup (loclabel);\n+\t}\n+      newloc->label = last_postcall_label;\n+    }\n+\n   if (cfun && in_cold_section_p)\n     newloc->section_label = crtl->subsections.cold_section_label;\n   else\n     newloc->section_label = text_section_label;\n \n   last_var_location_insn = next_real;\n-  last_label = newloc->label;\n   last_in_cold_section_p = in_cold_section_p;\n   decl = NOTE_VAR_LOCATION_DECL (loc_note);\n   add_var_loc_to_decl (decl, newloc);\n@@ -17242,14 +17940,14 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n }\n \n /* A helper function for dwarf2out_finish called through\n-   ht_forall.  Emit one queued .debug_str string.  */\n+   htab_traverse.  Emit one queued .debug_str string.  */\n \n static int\n output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)\n {\n   struct indirect_string_node *node = (struct indirect_string_node *) *h;\n \n-  if (node->form == DW_FORM_strp)\n+  if (node->label && node->refcount)\n     {\n       switch_to_section (debug_str_section);\n       ASM_OUTPUT_LABEL (asm_out_file, node->label);\n@@ -17527,6 +18225,20 @@ prune_unused_types_prune (dw_die_ref die)\n   } while (c != die->die_child);\n }\n \n+/* A helper function for dwarf2out_finish called through\n+   htab_traverse.  Clear .debug_str strings that we haven't already\n+   decided to emit.  */\n+\n+static int\n+prune_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)\n+{\n+  struct indirect_string_node *node = (struct indirect_string_node *) *h;\n+\n+  if (!node->label || !node->refcount)\n+    htab_clear_slot (debug_str_hash, h);\n+\n+  return 1;\n+}\n \n /* Remove dies representing declarations that we never use.  */\n \n@@ -17557,7 +18269,9 @@ prune_unused_types (void)\n     prune_unused_types_mark (arange_table[i], 1);\n \n   /* Get rid of nodes that aren't marked; and update the string counts.  */\n-  if (debug_str_hash)\n+  if (debug_str_hash && debug_str_hash_forced)\n+    htab_traverse (debug_str_hash, prune_indirect_string, NULL);\n+  else if (debug_str_hash)\n     htab_empty (debug_str_hash);\n   prune_unused_types_prune (comp_unit_die);\n   for (node = limbo_die_list; node; node = node->next)"}, {"sha": "9096a62dcbf06c8e3e558283f713a909773017af", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 357, "deletions": 15, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n+#include \"params.h\"\n \n /* Commonly used modes.  */\n \n@@ -175,6 +176,7 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n #define first_insn (crtl->emit.x_first_insn)\n #define last_insn (crtl->emit.x_last_insn)\n #define cur_insn_uid (crtl->emit.x_cur_insn_uid)\n+#define cur_debug_insn_uid (crtl->emit.x_cur_debug_insn_uid)\n #define last_location (crtl->emit.x_last_location)\n #define first_label_num (crtl->emit.x_first_label_num)\n \n@@ -2268,8 +2270,31 @@ set_new_first_and_last_insn (rtx first, rtx last)\n   last_insn = last;\n   cur_insn_uid = 0;\n \n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    cur_insn_uid = MAX (cur_insn_uid, INSN_UID (insn));\n+  if (MIN_NONDEBUG_INSN_UID || MAY_HAVE_DEBUG_INSNS)\n+    {\n+      int debug_count = 0;\n+\n+      cur_insn_uid = MIN_NONDEBUG_INSN_UID - 1;\n+      cur_debug_insn_uid = 0;\n+\n+      for (insn = first; insn; insn = NEXT_INSN (insn))\n+\tif (INSN_UID (insn) < MIN_NONDEBUG_INSN_UID)\n+\t  cur_debug_insn_uid = MAX (cur_debug_insn_uid, INSN_UID (insn));\n+\telse\n+\t  {\n+\t    cur_insn_uid = MAX (cur_insn_uid, INSN_UID (insn));\n+\t    if (DEBUG_INSN_P (insn))\n+\t      debug_count++;\n+\t  }\n+\n+      if (debug_count)\n+\tcur_debug_insn_uid = MIN_NONDEBUG_INSN_UID + debug_count;\n+      else\n+\tcur_debug_insn_uid++;\n+    }\n+  else\n+    for (insn = first; insn; insn = NEXT_INSN (insn))\n+      cur_insn_uid = MAX (cur_insn_uid, INSN_UID (insn));\n \n   cur_insn_uid++;\n }\n@@ -2592,6 +2617,7 @@ copy_rtx_if_shared_1 (rtx *orig1)\n \treturn;\n       break;\n \n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -2698,6 +2724,7 @@ reset_used_flags (rtx x)\n     case CC0:\n       return;\n \n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -2768,6 +2795,7 @@ set_used_flags (rtx x)\n     case CC0:\n       return;\n \n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -2947,6 +2975,27 @@ get_max_uid (void)\n {\n   return cur_insn_uid;\n }\n+\n+/* Return the number of actual (non-debug) insns emitted in this\n+   function.  */\n+\n+int\n+get_max_insn_count (void)\n+{\n+  int n = cur_insn_uid;\n+\n+  /* The table size must be stable across -g, to avoid codegen\n+     differences due to debug insns, and not be affected by\n+     -fmin-insn-uid, to avoid excessive table size and to simplify\n+     debugging of -fcompare-debug failures.  */\n+  if (cur_debug_insn_uid > MIN_NONDEBUG_INSN_UID)\n+    n -= cur_debug_insn_uid;\n+  else\n+    n -= MIN_NONDEBUG_INSN_UID;\n+\n+  return n;\n+}\n+\n \f\n /* Return the next insn.  If it is a SEQUENCE, return the first insn\n    of the sequence.  */\n@@ -3033,6 +3082,38 @@ prev_nonnote_insn (rtx insn)\n   return insn;\n }\n \n+/* Return the next insn after INSN that is not a DEBUG_INSN.  This\n+   routine does not look inside SEQUENCEs.  */\n+\n+rtx\n+next_nondebug_insn (rtx insn)\n+{\n+  while (insn)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (insn == 0 || !DEBUG_INSN_P (insn))\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Return the previous insn before INSN that is not a DEBUG_INSN.\n+   This routine does not look inside SEQUENCEs.  */\n+\n+rtx\n+prev_nondebug_insn (rtx insn)\n+{\n+  while (insn)\n+    {\n+      insn = PREV_INSN (insn);\n+      if (insn == 0 || !DEBUG_INSN_P (insn))\n+\tbreak;\n+    }\n+\n+  return insn;\n+}\n+\n /* Return the next INSN, CALL_INSN or JUMP_INSN after INSN;\n    or 0, if there is none.  This routine does not look inside\n    SEQUENCEs.  */\n@@ -3504,6 +3585,27 @@ make_insn_raw (rtx pattern)\n   return insn;\n }\n \n+/* Like `make_insn_raw' but make a DEBUG_INSN instead of an insn.  */\n+\n+rtx\n+make_debug_insn_raw (rtx pattern)\n+{\n+  rtx insn;\n+\n+  insn = rtx_alloc (DEBUG_INSN);\n+  INSN_UID (insn) = cur_debug_insn_uid++;\n+  if (cur_debug_insn_uid > MIN_NONDEBUG_INSN_UID)\n+    INSN_UID (insn) = cur_insn_uid++;\n+\n+  PATTERN (insn) = pattern;\n+  INSN_CODE (insn) = -1;\n+  REG_NOTES (insn) = NULL;\n+  INSN_LOCATOR (insn) = curr_insn_locator ();\n+  BLOCK_FOR_INSN (insn) = NULL;\n+\n+  return insn;\n+}\n+\n /* Like `make_insn_raw' but make a JUMP_INSN instead of an insn.  */\n \n rtx\n@@ -3917,6 +4019,7 @@ emit_insn_before_noloc (rtx x, rtx before, basic_block bb)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -3960,6 +4063,7 @@ emit_jump_insn_before_noloc (rtx x, rtx before)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4003,6 +4107,7 @@ emit_call_insn_before_noloc (rtx x, rtx before)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4034,6 +4139,50 @@ emit_call_insn_before_noloc (rtx x, rtx before)\n   return last;\n }\n \n+/* Make an instruction with body X and code DEBUG_INSN\n+   and output it before the instruction BEFORE.  */\n+\n+rtx\n+emit_debug_insn_before_noloc (rtx x, rtx before)\n+{\n+  rtx last = NULL_RTX, insn;\n+\n+  gcc_assert (before);\n+\n+  switch (GET_CODE (x))\n+    {\n+    case DEBUG_INSN:\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  add_insn_before (insn, before, NULL);\n+\t  last = insn;\n+\t  insn = next;\n+\t}\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      gcc_unreachable ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_debug_insn_raw (x);\n+      add_insn_before (last, before, NULL);\n+      break;\n+    }\n+\n+  return last;\n+}\n+\n /* Make an insn of code BARRIER\n    and output it before the insn BEFORE.  */\n \n@@ -4140,6 +4289,7 @@ emit_insn_after_noloc (rtx x, rtx after, basic_block bb)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4177,6 +4327,7 @@ emit_jump_insn_after_noloc (rtx x, rtx after)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4213,6 +4364,7 @@ emit_call_insn_after_noloc (rtx x, rtx after)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4237,6 +4389,43 @@ emit_call_insn_after_noloc (rtx x, rtx after)\n   return last;\n }\n \n+/* Make an instruction with body X and code CALL_INSN\n+   and output it after the instruction AFTER.  */\n+\n+rtx\n+emit_debug_insn_after_noloc (rtx x, rtx after)\n+{\n+  rtx last;\n+\n+  gcc_assert (after);\n+\n+  switch (GET_CODE (x))\n+    {\n+    case DEBUG_INSN:\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      last = emit_insn_after_1 (x, after, NULL);\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      gcc_unreachable ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_debug_insn_raw (x);\n+      add_insn_after (last, after, NULL);\n+      break;\n+    }\n+\n+  return last;\n+}\n+\n /* Make an insn of code BARRIER\n    and output it after the insn AFTER.  */\n \n@@ -4307,8 +4496,13 @@ emit_insn_after_setloc (rtx pattern, rtx after, int loc)\n rtx\n emit_insn_after (rtx pattern, rtx after)\n {\n-  if (INSN_P (after))\n-    return emit_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  rtx prev = after;\n+\n+  while (DEBUG_INSN_P (prev))\n+    prev = PREV_INSN (prev);\n+\n+  if (INSN_P (prev))\n+    return emit_insn_after_setloc (pattern, after, INSN_LOCATOR (prev));\n   else\n     return emit_insn_after_noloc (pattern, after, NULL);\n }\n@@ -4338,8 +4532,13 @@ emit_jump_insn_after_setloc (rtx pattern, rtx after, int loc)\n rtx\n emit_jump_insn_after (rtx pattern, rtx after)\n {\n-  if (INSN_P (after))\n-    return emit_jump_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  rtx prev = after;\n+\n+  while (DEBUG_INSN_P (prev))\n+    prev = PREV_INSN (prev);\n+\n+  if (INSN_P (prev))\n+    return emit_jump_insn_after_setloc (pattern, after, INSN_LOCATOR (prev));\n   else\n     return emit_jump_insn_after_noloc (pattern, after);\n }\n@@ -4369,12 +4568,48 @@ emit_call_insn_after_setloc (rtx pattern, rtx after, int loc)\n rtx\n emit_call_insn_after (rtx pattern, rtx after)\n {\n-  if (INSN_P (after))\n-    return emit_call_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  rtx prev = after;\n+\n+  while (DEBUG_INSN_P (prev))\n+    prev = PREV_INSN (prev);\n+\n+  if (INSN_P (prev))\n+    return emit_call_insn_after_setloc (pattern, after, INSN_LOCATOR (prev));\n   else\n     return emit_call_insn_after_noloc (pattern, after);\n }\n \n+/* Like emit_debug_insn_after_noloc, but set INSN_LOCATOR according to SCOPE.  */\n+rtx\n+emit_debug_insn_after_setloc (rtx pattern, rtx after, int loc)\n+{\n+  rtx last = emit_debug_insn_after_noloc (pattern, after);\n+\n+  if (pattern == NULL_RTX || !loc)\n+    return last;\n+\n+  after = NEXT_INSN (after);\n+  while (1)\n+    {\n+      if (active_insn_p (after) && !INSN_LOCATOR (after))\n+\tINSN_LOCATOR (after) = loc;\n+      if (after == last)\n+\tbreak;\n+      after = NEXT_INSN (after);\n+    }\n+  return last;\n+}\n+\n+/* Like emit_debug_insn_after_noloc, but set INSN_LOCATOR according to AFTER.  */\n+rtx\n+emit_debug_insn_after (rtx pattern, rtx after)\n+{\n+  if (INSN_P (after))\n+    return emit_debug_insn_after_setloc (pattern, after, INSN_LOCATOR (after));\n+  else\n+    return emit_debug_insn_after_noloc (pattern, after);\n+}\n+\n /* Like emit_insn_before_noloc, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n emit_insn_before_setloc (rtx pattern, rtx before, int loc)\n@@ -4404,8 +4639,13 @@ emit_insn_before_setloc (rtx pattern, rtx before, int loc)\n rtx\n emit_insn_before (rtx pattern, rtx before)\n {\n-  if (INSN_P (before))\n-    return emit_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  rtx next = before;\n+\n+  while (DEBUG_INSN_P (next))\n+    next = PREV_INSN (next);\n+\n+  if (INSN_P (next))\n+    return emit_insn_before_setloc (pattern, before, INSN_LOCATOR (next));\n   else\n     return emit_insn_before_noloc (pattern, before, NULL);\n }\n@@ -4436,8 +4676,13 @@ emit_jump_insn_before_setloc (rtx pattern, rtx before, int loc)\n rtx\n emit_jump_insn_before (rtx pattern, rtx before)\n {\n-  if (INSN_P (before))\n-    return emit_jump_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  rtx next = before;\n+\n+  while (DEBUG_INSN_P (next))\n+    next = PREV_INSN (next);\n+\n+  if (INSN_P (next))\n+    return emit_jump_insn_before_setloc (pattern, before, INSN_LOCATOR (next));\n   else\n     return emit_jump_insn_before_noloc (pattern, before);\n }\n@@ -4469,11 +4714,49 @@ emit_call_insn_before_setloc (rtx pattern, rtx before, int loc)\n rtx\n emit_call_insn_before (rtx pattern, rtx before)\n {\n-  if (INSN_P (before))\n-    return emit_call_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  rtx next = before;\n+\n+  while (DEBUG_INSN_P (next))\n+    next = PREV_INSN (next);\n+\n+  if (INSN_P (next))\n+    return emit_call_insn_before_setloc (pattern, before, INSN_LOCATOR (next));\n   else\n     return emit_call_insn_before_noloc (pattern, before);\n }\n+\n+/* like emit_insn_before_noloc, but set insn_locator according to scope.  */\n+rtx\n+emit_debug_insn_before_setloc (rtx pattern, rtx before, int loc)\n+{\n+  rtx first = PREV_INSN (before);\n+  rtx last = emit_debug_insn_before_noloc (pattern, before);\n+\n+  if (pattern == NULL_RTX)\n+    return last;\n+\n+  first = NEXT_INSN (first);\n+  while (1)\n+    {\n+      if (active_insn_p (first) && !INSN_LOCATOR (first))\n+\tINSN_LOCATOR (first) = loc;\n+      if (first == last)\n+\tbreak;\n+      first = NEXT_INSN (first);\n+    }\n+  return last;\n+}\n+\n+/* like emit_debug_insn_before_noloc,\n+   but set insn_locator according to before.  */\n+rtx\n+emit_debug_insn_before (rtx pattern, rtx before)\n+{\n+  if (INSN_P (before))\n+    return emit_debug_insn_before_setloc (pattern, before, INSN_LOCATOR (before));\n+  else\n+    return emit_debug_insn_before_noloc (pattern, before);\n+}\n \f\n /* Take X and emit it at the end of the doubly-linked\n    INSN list.\n@@ -4491,6 +4774,7 @@ emit_insn (rtx x)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4522,6 +4806,52 @@ emit_insn (rtx x)\n   return last;\n }\n \n+/* Make an insn of code DEBUG_INSN with pattern X\n+   and add it to the end of the doubly-linked list.  */\n+\n+rtx\n+emit_debug_insn (rtx x)\n+{\n+  rtx last = last_insn;\n+  rtx insn;\n+\n+  if (x == NULL_RTX)\n+    return last;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case DEBUG_INSN:\n+    case INSN:\n+    case JUMP_INSN:\n+    case CALL_INSN:\n+    case CODE_LABEL:\n+    case BARRIER:\n+    case NOTE:\n+      insn = x;\n+      while (insn)\n+\t{\n+\t  rtx next = NEXT_INSN (insn);\n+\t  add_insn (insn);\n+\t  last = insn;\n+\t  insn = next;\n+\t}\n+      break;\n+\n+#ifdef ENABLE_RTL_CHECKING\n+    case SEQUENCE:\n+      gcc_unreachable ();\n+      break;\n+#endif\n+\n+    default:\n+      last = make_debug_insn_raw (x);\n+      add_insn (last);\n+      break;\n+    }\n+\n+  return last;\n+}\n+\n /* Make an insn of code JUMP_INSN with pattern X\n    and add it to the end of the doubly-linked list.  */\n \n@@ -4532,6 +4862,7 @@ emit_jump_insn (rtx x)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4573,6 +4904,7 @@ emit_call_insn (rtx x)\n \n   switch (GET_CODE (x))\n     {\n+    case DEBUG_INSN:\n     case INSN:\n     case JUMP_INSN:\n     case CALL_INSN:\n@@ -4844,6 +5176,8 @@ emit (rtx x)\n       }\n     case CALL_INSN:\n       return emit_call_insn (x);\n+    case DEBUG_INSN:\n+      return emit_debug_insn (x);\n     default:\n       gcc_unreachable ();\n     }\n@@ -5168,7 +5502,11 @@ init_emit (void)\n {\n   first_insn = NULL;\n   last_insn = NULL;\n-  cur_insn_uid = 1;\n+  if (MIN_NONDEBUG_INSN_UID)\n+    cur_insn_uid = MIN_NONDEBUG_INSN_UID;\n+  else\n+    cur_insn_uid = 1;\n+  cur_debug_insn_uid = 1;\n   reg_rtx_no = LAST_VIRTUAL_REGISTER + 1;\n   last_location = UNKNOWN_LOCATION;\n   first_label_num = label_num;\n@@ -5625,6 +5963,10 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n       new_rtx = emit_jump_insn_after (copy_insn (PATTERN (insn)), after);\n       break;\n \n+    case DEBUG_INSN:\n+      new_rtx = emit_debug_insn_after (copy_insn (PATTERN (insn)), after);\n+      break;\n+\n     case CALL_INSN:\n       new_rtx = emit_call_insn_after (copy_insn (PATTERN (insn)), after);\n       if (CALL_INSN_FUNCTION_USAGE (insn))"}, {"sha": "76c52ca100e5d32d440a802ccd63b0637ab655fb", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -391,6 +391,7 @@ get_attr_length_1 (rtx insn ATTRIBUTE_UNUSED,\n       case NOTE:\n       case BARRIER:\n       case CODE_LABEL:\n+      case DEBUG_INSN:\n \treturn 0;\n \n       case CALL_INSN:\n@@ -4381,7 +4382,8 @@ rest_of_clean_state (void)\n \t  && (!NOTE_P (insn) ||\n \t      (NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_BEG\n-\t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END)))\n+\t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END\n+\t       && NOTE_KIND (insn) != NOTE_INSN_CFA_RESTORE_STATE)))\n \tprint_rtl_single (final_output, insn);\n \n     }"}, {"sha": "3257254429867387cd49a93833539e546e9665a1", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1775,8 +1775,11 @@ instantiate_virtual_regs (void)\n \t    || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n \t    || GET_CODE (PATTERN (insn)) == ASM_INPUT)\n \t  continue;\n-\n-\tinstantiate_virtual_regs_in_insn (insn);\n+\telse if (DEBUG_INSN_P (insn))\n+\t  for_each_rtx (&INSN_VAR_LOCATION (insn),\n+\t\t\tinstantiate_virtual_regs_in_rtx, NULL);\n+\telse\n+\t  instantiate_virtual_regs_in_insn (insn);\n \n \tif (INSN_DELETED_P (insn))\n \t  continue;"}, {"sha": "446bc9d82e15b88c181a3de728248a74bdee376b", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -64,6 +64,10 @@ struct GTY(()) emit_status {\n      Reset to 1 for each function compiled.  */\n   int x_cur_insn_uid;\n \n+  /* INSN_UID for next debug insn emitted.  Only used if\n+     --param min-nondebug-insn-uid=<value> is given with nonzero value.  */\n+  int x_cur_debug_insn_uid;\n+\n   /* Location the last line-number NOTE emitted.\n      This is used to avoid generating duplicates.  */\n   location_t x_last_location;"}, {"sha": "d3ed74298c0b69730117af75bd3bf3c7079da3bc", "filename": "gcc/fwprop.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1208,7 +1208,7 @@ forward_propagate_and_simplify (df_ref use, rtx def_insn, rtx def_set)\n   if (INSN_CODE (use_insn) < 0)\n     asm_use = asm_noperands (PATTERN (use_insn));\n \n-  if (!use_set && asm_use < 0)\n+  if (!use_set && asm_use < 0 && !DEBUG_INSN_P (use_insn))\n     return false;\n \n   /* Do not propagate into PC, CC0, etc.  */\n@@ -1265,6 +1265,11 @@ forward_propagate_and_simplify (df_ref use, rtx def_insn, rtx def_set)\n       loc = &SET_DEST (use_set);\n       set_reg_equal = false;\n     }\n+  else if (!use_set)\n+    {\n+      loc = &INSN_VAR_LOCATION_LOC (use_insn);\n+      set_reg_equal = false;\n+    }\n   else\n     {\n       rtx note = find_reg_note (use_insn, REG_EQUAL, NULL_RTX);"}, {"sha": "25deb494a8d939707c94aa23f116d22eb5eda0e9", "filename": "gcc/gcc.c", "status": "modified", "additions": 64, "deletions": 14, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -891,10 +891,10 @@ static const char *asm_options =\n \n static const char *invoke_as =\n #ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT\n-\"%{fcompare-debug=*:%:compare-debug-dump-opt()}\\\n+\"%{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}\\\n  %{!S:-o %|.s |\\n as %(asm_options) %|.s %A }\";\n #else\n-\"%{fcompare-debug=*:%:compare-debug-dump-opt()}\\\n+\"%{fcompare-debug=*|fdump-final-insns=*:%:compare-debug-dump-opt()}\\\n  %{!S:-o %|.s |\\n as %(asm_options) %m.s %A }\";\n #endif\n \n@@ -926,6 +926,7 @@ static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n #endif\n \n static const char *const driver_self_specs[] = {\n+  \"%{fdump-final-insns:-fdump-final-insns=.} %<fdump-final-insns\",\n   DRIVER_SELF_SPECS, GOMP_SELF_SPECS\n };\n \n@@ -8672,6 +8673,33 @@ print_asm_header_spec_function (int arg ATTRIBUTE_UNUSED,\n   return NULL;\n }\n \n+/* Compute a timestamp to initialize flag_random_seed.  */\n+\n+static unsigned\n+get_local_tick (void)\n+{\n+  unsigned ret = 0;\n+\n+  /* Get some more or less random data.  */\n+#ifdef HAVE_GETTIMEOFDAY\n+  {\n+    struct timeval tv;\n+\n+    gettimeofday (&tv, NULL);\n+    ret = tv.tv_sec * 1000 + tv.tv_usec / 1000;\n+  }\n+#else\n+  {\n+    time_t now = time (NULL);\n+\n+    if (now != (time_t)-1)\n+      ret = (unsigned) now;\n+  }\n+#endif\n+\n+  return ret;\n+}\n+\n /* %:compare-debug-dump-opt spec function.  Save the last argument,\n    expected to be the last -fdump-final-insns option, or generate a\n    temporary.  */\n@@ -8683,41 +8711,61 @@ compare_debug_dump_opt_spec_function (int arg,\n   const char *ret;\n   char *name;\n   int which;\n+  static char random_seed[HOST_BITS_PER_WIDE_INT / 4 + 3];\n \n   if (arg != 0)\n     fatal (\"too many arguments to %%:compare-debug-dump-opt\");\n \n-  if (!compare_debug)\n-    return NULL;\n-\n   do_spec_2 (\"%{fdump-final-insns=*:%*}\");\n   do_spec_1 (\" \", 0, NULL);\n \n-  if (argbuf_index > 0)\n+  if (argbuf_index > 0 && strcmp (argv[argbuf_index - 1], \".\"))\n     {\n+      if (!compare_debug)\n+\treturn NULL;\n+\n       name = xstrdup (argv[argbuf_index - 1]);\n       ret = NULL;\n     }\n   else\n     {\n-#define OPT \"-fdump-final-insns=\"\n-      ret = \"-fdump-final-insns=%g.gkd\";\n+      const char *ext = NULL;\n+\n+      if (argbuf_index > 0)\n+\t{\n+\t  do_spec_2 (\"%{o*:%*}%{!o:%{!S:%b%O}%{S:%b.s}}\");\n+\t  ext = \".gkd\";\n+\t}\n+      else if (!compare_debug)\n+\treturn NULL;\n+      else\n+\tdo_spec_2 (\"%g.gkd\");\n \n-      do_spec_2 (ret + sizeof (OPT) - 1);\n       do_spec_1 (\" \", 0, NULL);\n-#undef OPT\n \n       gcc_assert (argbuf_index > 0);\n \n-      name = xstrdup (argbuf[argbuf_index - 1]);\n+      name = concat (argbuf[argbuf_index - 1], ext, NULL);\n+\n+      ret = concat (\"-fdump-final-insns=\", name, NULL);\n     }\n \n   which = compare_debug < 0;\n   debug_check_temp_file[which] = name;\n \n-#if 0\n-  error (\"compare-debug: [%i]=\\\"%s\\\", ret %s\", which, name, ret);\n-#endif\n+  if (!which)\n+    {\n+      unsigned HOST_WIDE_INT value = get_local_tick () ^ getpid ();\n+\n+      sprintf (random_seed, HOST_WIDE_INT_PRINT_HEX, value);\n+    }\n+\n+  if (*random_seed)\n+    ret = concat (\"%{!frandom-seed=*:-frandom-seed=\", random_seed, \"} \",\n+\t\t  ret, NULL);\n+\n+  if (which)\n+    *random_seed = 0;\n \n   return ret;\n }\n@@ -8791,5 +8839,7 @@ compare_debug_auxbase_opt_spec_function (int arg,\n   memcpy (name + sizeof (OPT) - 1, argv[0], len);\n   name[sizeof (OPT) - 1 + len] = '\\0';\n \n+#undef OPT\n+\n   return name;\n }"}, {"sha": "dc4aa8b9a965eb3fef880e95ea05ef309b4e6bdd", "filename": "gcc/gcse.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -465,7 +465,7 @@ static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n static void record_last_set_info (rtx, const_rtx, void *);\n static void compute_hash_table (struct hash_table_d *);\n-static void alloc_hash_table (int, struct hash_table_d *, int);\n+static void alloc_hash_table (struct hash_table_d *, int);\n static void free_hash_table (struct hash_table_d *);\n static void compute_hash_table_work (struct hash_table_d *);\n static void dump_hash_table (FILE *, const char *, struct hash_table_d *);\n@@ -1716,17 +1716,18 @@ compute_hash_table_work (struct hash_table_d *table)\n }\n \n /* Allocate space for the set/expr hash TABLE.\n-   N_INSNS is the number of instructions in the function.\n    It is used to determine the number of buckets to use.\n    SET_P determines whether set or expression table will\n    be created.  */\n \n static void\n-alloc_hash_table (int n_insns, struct hash_table_d *table, int set_p)\n+alloc_hash_table (struct hash_table_d *table, int set_p)\n {\n   int n;\n \n-  table->size = n_insns / 4;\n+  n = get_max_insn_count ();\n+\n+  table->size = n / 4;\n   if (table->size < 11)\n     table->size = 11;\n \n@@ -2610,6 +2611,9 @@ cprop_insn (rtx insn)\n \t}\n     }\n \n+  if (changed && DEBUG_INSN_P (insn))\n+    return 0;\n+\n   return changed;\n }\n \n@@ -3137,7 +3141,9 @@ bypass_conditional_jumps (void)\n \t{\n \t  setcc = NULL_RTX;\n \t  FOR_BB_INSNS (bb, insn)\n-\t    if (NONJUMP_INSN_P (insn))\n+\t    if (DEBUG_INSN_P (insn))\n+\t      continue;\n+\t    else if (NONJUMP_INSN_P (insn))\n \t      {\n \t\tif (setcc)\n \t\t  break;\n@@ -3967,7 +3973,7 @@ one_pre_gcse_pass (void)\n   gcc_obstack_init (&gcse_obstack);\n   alloc_gcse_mem ();\n \n-  alloc_hash_table (get_max_uid (), &expr_hash_table, 0);\n+  alloc_hash_table (&expr_hash_table, 0);\n   add_noreturn_fake_exit_edges ();\n   if (flag_gcse_lm)\n     compute_ld_motion_mems ();\n@@ -4448,7 +4454,7 @@ one_code_hoisting_pass (void)\n   gcc_obstack_init (&gcse_obstack);\n   alloc_gcse_mem ();\n \n-  alloc_hash_table (get_max_uid (), &expr_hash_table, 0);\n+  alloc_hash_table (&expr_hash_table, 0);\n   compute_hash_table (&expr_hash_table);\n   if (dump_file)\n     dump_hash_table (dump_file, \"Code Hosting Expressions\", &expr_hash_table);\n@@ -4752,7 +4758,7 @@ compute_ld_motion_mems (void)\n     {\n       FOR_BB_INSNS (bb, insn)\n \t{\n-\t  if (INSN_P (insn))\n+\t  if (NONDEBUG_INSN_P (insn))\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == SET)\n \t\t{\n@@ -4988,7 +4994,7 @@ one_cprop_pass (void)\n   implicit_sets = XCNEWVEC (rtx, last_basic_block);\n   find_implicit_sets ();\n \n-  alloc_hash_table (get_max_uid (), &set_hash_table, 1);\n+  alloc_hash_table (&set_hash_table, 1);\n   compute_hash_table (&set_hash_table);\n \n   /* Free implicit_sets before peak usage.  */"}, {"sha": "50180203e2d2351e90d956b108de9256341f6956", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -780,6 +780,31 @@ dump_gimple_resx (pretty_printer *buffer, gimple gs, int spc, int flags)\n     dump_gimple_fmt (buffer, spc, flags, \"resx %d\", gimple_resx_region (gs));\n }\n \n+/* Dump a GIMPLE_DEBUG tuple on the pretty_printer BUFFER, SPC spaces\n+   of indent.  FLAGS specifies details to show in the dump (see TDF_*\n+   in tree-pass.h).  */\n+\n+static void\n+dump_gimple_debug (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  switch (gs->gsbase.subcode)\n+    {\n+    case GIMPLE_DEBUG_BIND:\n+      if (flags & TDF_RAW)\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G BIND <%T, %T>\", gs,\n+\t\t\t gimple_debug_bind_get_var (gs),\n+\t\t\t gimple_debug_bind_get_value (gs));\n+      else\n+\tdump_gimple_fmt (buffer, spc, flags, \"# DEBUG %T => %T\",\n+\t\t\t gimple_debug_bind_get_var (gs),\n+\t\t\t gimple_debug_bind_get_value (gs));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Dump a GIMPLE_OMP_FOR tuple on the pretty_printer BUFFER.  */\n static void\n dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n@@ -1524,6 +1549,10 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_gimple_resx (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_DEBUG:\n+      dump_gimple_debug (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_PREDICT:\n       pp_string (buffer, \"// predicted \");\n       if (gimple_predict_outcome (gs))\n@@ -1577,7 +1606,8 @@ dump_bb_header (pretty_printer *buffer, basic_block bb, int indent, int flags)\n \t  gimple_stmt_iterator gsi;\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    if (get_lineno (gsi_stmt (gsi)) != -1)\n+\t    if (!is_gimple_debug (gsi_stmt (gsi))\n+\t\t&& get_lineno (gsi_stmt (gsi)) != UNKNOWN_LOCATION)\n \t      {\n \t\tpp_string (buffer, \", starting at line \");\n \t\tpp_decimal_int (buffer, get_lineno (gsi_stmt (gsi)));"}, {"sha": "7db34106e677fc36723ad8a91cf8c6887a775e10", "filename": "gcc/gimple.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -102,6 +102,7 @@ gss_for_code (enum gimple_code code)\n     case GIMPLE_COND:\n     case GIMPLE_GOTO:\n     case GIMPLE_LABEL:\n+    case GIMPLE_DEBUG:\n     case GIMPLE_SWITCH:\t\t\treturn GSS_WITH_OPS;\n     case GIMPLE_ASM:\t\t\treturn GSS_ASM;\n     case GIMPLE_BIND:\t\t\treturn GSS_BIND;\n@@ -253,7 +254,7 @@ gimple_set_subcode (gimple g, unsigned subcode)\n   gimple_build_with_ops_stat (c, s, n MEM_STAT_INFO)\n \n static gimple\n-gimple_build_with_ops_stat (enum gimple_code code, enum tree_code subcode,\n+gimple_build_with_ops_stat (enum gimple_code code, unsigned subcode,\n \t\t            unsigned num_ops MEM_STAT_DECL)\n {\n   gimple s = gimple_alloc_stat (code, num_ops PASS_MEM_STAT);\n@@ -427,7 +428,7 @@ gimple_build_assign_with_ops_stat (enum tree_code subcode, tree lhs, tree op1,\n      code).  */\n   num_ops = get_gimple_rhs_num_ops (subcode) + 1;\n   \n-  p = gimple_build_with_ops_stat (GIMPLE_ASSIGN, subcode, num_ops\n+  p = gimple_build_with_ops_stat (GIMPLE_ASSIGN, (unsigned)subcode, num_ops\n   \t\t\t          PASS_MEM_STAT);\n   gimple_assign_set_lhs (p, lhs);\n   gimple_assign_set_rhs1 (p, op1);\n@@ -831,6 +832,29 @@ gimple_build_switch_vec (tree index, tree default_label, VEC(tree, heap) *args)\n }\n \n \n+/* Build a new GIMPLE_DEBUG_BIND statement.\n+\n+   VAR is bound to VALUE; block and location are taken from STMT.  */\n+\n+gimple\n+gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n+{\n+  gimple p = gimple_build_with_ops_stat (GIMPLE_DEBUG,\n+\t\t\t\t\t (unsigned)GIMPLE_DEBUG_BIND, 2\n+\t\t\t\t\t PASS_MEM_STAT);\n+\n+  gimple_debug_bind_set_var (p, var);\n+  gimple_debug_bind_set_value (p, value);\n+  if (stmt)\n+    {\n+      gimple_set_block (p, gimple_block (stmt));\n+      gimple_set_location (p, gimple_location (stmt));\n+    }\n+\n+  return p;\n+}\n+\n+\n /* Build a GIMPLE_OMP_CRITICAL statement.\n \n    BODY is the sequence of statements for which only one thread can execute.\n@@ -1213,11 +1237,11 @@ empty_body_p (gimple_seq body)\n {\n   gimple_stmt_iterator i;\n \n-\n   if (gimple_seq_empty_p (body))\n     return true;\n   for (i = gsi_start (body); !gsi_end_p (i); gsi_next (&i))\n-    if (!empty_stmt_p (gsi_stmt (i)))\n+    if (!empty_stmt_p (gsi_stmt (i))\n+\t&& !is_gimple_debug (gsi_stmt (i)))\n       return false;\n \n   return true;\n@@ -2224,6 +2248,9 @@ gimple_has_side_effects (const_gimple s)\n {\n   unsigned i;\n \n+  if (is_gimple_debug (s))\n+    return false;\n+\n   /* We don't have to scan the arguments to check for\n      volatile arguments, though, at present, we still\n      do a scan to check for TREE_SIDE_EFFECTS.  */\n@@ -2317,6 +2344,8 @@ gimple_rhs_has_side_effects (const_gimple s)\n \t    return true;\n \t  }\n     }\n+  else if (is_gimple_debug (s))\n+    return false;\n   else\n     {\n       /* For statements without an LHS, examine all arguments.  */"}, {"sha": "716f6e2acbbe5124a22aa106755ca52307ba5391", "filename": "gcc/gimple.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -53,6 +53,9 @@ DEFGSCODE(GIMPLE_ERROR_MARK, \"gimple_error_mark\", NULL)\n    jump target for the comparison.  */\n DEFGSCODE(GIMPLE_COND, \"gimple_cond\", struct gimple_statement_with_ops)\n \n+/* GIMPLE_DEBUG represents a debug statement.  */\n+DEFGSCODE(GIMPLE_DEBUG, \"gimple_debug\", struct gimple_statement_with_ops)\n+\n /* GIMPLE_GOTO <TARGET> represents unconditional jumps.\n    TARGET is a LABEL_DECL or an expression node for computed GOTOs.  */\n DEFGSCODE(GIMPLE_GOTO, \"gimple_goto\", struct gimple_statement_with_ops)"}, {"sha": "7a034a1f3915f1c0cbef8a03644e9ef7c1f0faf3", "filename": "gcc/gimple.h", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -117,6 +117,14 @@ enum gf_mask {\n     GF_PREDICT_TAKEN\t\t= 1 << 15\n };\n \n+/* Currently, there's only one type of gimple debug stmt.  Others are\n+   envisioned, for example, to enable the generation of is_stmt notes\n+   in line number information, to mark sequence points, etc.  This\n+   subcode is to be used to tell them apart.  */\n+enum gimple_debug_subcode {\n+  GIMPLE_DEBUG_BIND = 0\n+};\n+\n /* Masks for selecting a pass local flag (PLF) to work on.  These\n    masks are used by gimple_set_plf and gimple_plf.  */\n enum plf_mask {\n@@ -754,6 +762,10 @@ gimple gimple_build_assign_with_ops_stat (enum tree_code, tree, tree,\n #define gimple_build_assign_with_ops(c,o1,o2,o3) \\\n   gimple_build_assign_with_ops_stat (c, o1, o2, o3 MEM_STAT_INFO)\n \n+gimple gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n+#define gimple_build_debug_bind(var,val,stmt)\t\t\t\\\n+  gimple_build_debug_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n+\n gimple gimple_build_call_vec (tree, VEC(tree, heap) *);\n gimple gimple_build_call (tree, unsigned, ...);\n gimple gimple_build_call_from_tree (tree);\n@@ -3158,6 +3170,105 @@ gimple_switch_set_default_label (gimple gs, tree label)\n   gimple_switch_set_label (gs, 0, label);\n }\n \n+/* Return true if GS is a GIMPLE_DEBUG statement.  */\n+\n+static inline bool\n+is_gimple_debug (const_gimple gs)\n+{\n+  return gimple_code (gs) == GIMPLE_DEBUG;\n+}\n+\n+/* Return true if S is a GIMPLE_DEBUG BIND statement.  */\n+\n+static inline bool\n+gimple_debug_bind_p (const_gimple s)\n+{\n+  if (is_gimple_debug (s))\n+    return s->gsbase.subcode == GIMPLE_DEBUG_BIND;\n+\n+  return false;\n+}\n+\n+/* Return the variable bound in a GIMPLE_DEBUG bind statement.  */\n+\n+static inline tree\n+gimple_debug_bind_get_var (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  return gimple_op (dbg, 0);\n+}\n+\n+/* Return the value bound to the variable in a GIMPLE_DEBUG bind\n+   statement.  */\n+\n+static inline tree\n+gimple_debug_bind_get_value (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  return gimple_op (dbg, 1);\n+}\n+\n+/* Return a pointer to the value bound to the variable in a\n+   GIMPLE_DEBUG bind statement.  */\n+\n+static inline tree *\n+gimple_debug_bind_get_value_ptr (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  return gimple_op_ptr (dbg, 1);\n+}\n+\n+/* Set the variable bound in a GIMPLE_DEBUG bind statement.  */\n+\n+static inline void\n+gimple_debug_bind_set_var (gimple dbg, tree var)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  gimple_set_op (dbg, 0, var);\n+}\n+\n+/* Set the value bound to the variable in a GIMPLE_DEBUG bind\n+   statement.  */\n+\n+static inline void\n+gimple_debug_bind_set_value (gimple dbg, tree value)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  gimple_set_op (dbg, 1, value);\n+}\n+\n+/* The second operand of a GIMPLE_DEBUG_BIND, when the value was\n+   optimized away.  */\n+#define GIMPLE_DEBUG_BIND_NOVALUE NULL_TREE /* error_mark_node */\n+\n+/* Remove the value bound to the variable in a GIMPLE_DEBUG bind\n+   statement.  */\n+\n+static inline void\n+gimple_debug_bind_reset_value (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  gimple_set_op (dbg, 1, GIMPLE_DEBUG_BIND_NOVALUE);\n+}\n+\n+/* Return true if the GIMPLE_DEBUG bind statement is bound to a\n+   value.  */\n+\n+static inline bool\n+gimple_debug_bind_has_value_p (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_assert (gimple_debug_bind_p (dbg));\n+  return gimple_op (dbg, 1) != GIMPLE_DEBUG_BIND_NOVALUE;\n+}\n+\n+#undef GIMPLE_DEBUG_BIND_NOVALUE\n \n /* Return the body for the OMP statement GS.  */\n \n@@ -4308,6 +4419,58 @@ gsi_after_labels (basic_block bb)\n   return gsi;\n }\n \n+/* Advance the iterator to the next non-debug gimple statement.  */\n+\n+static inline void\n+gsi_next_nondebug (gimple_stmt_iterator *i)\n+{\n+  do\n+    {\n+      gsi_next (i);\n+    }\n+  while (!gsi_end_p (*i) && is_gimple_debug (gsi_stmt (*i)));\n+}\n+\n+/* Advance the iterator to the next non-debug gimple statement.  */\n+\n+static inline void\n+gsi_prev_nondebug (gimple_stmt_iterator *i)\n+{\n+  do\n+    {\n+      gsi_prev (i);\n+    }\n+  while (!gsi_end_p (*i) && is_gimple_debug (gsi_stmt (*i)));\n+}\n+\n+/* Return a new iterator pointing to the first non-debug statement in\n+   basic block BB.  */\n+\n+static inline gimple_stmt_iterator\n+gsi_start_nondebug_bb (basic_block bb)\n+{\n+  gimple_stmt_iterator i = gsi_start_bb (bb);\n+\n+  if (!gsi_end_p (i) && is_gimple_debug (gsi_stmt (i)))\n+    gsi_next_nondebug (&i);\n+\n+  return i;\n+}\n+\n+/* Return a new iterator pointing to the last non-debug statement in\n+   basic block BB.  */\n+\n+static inline gimple_stmt_iterator\n+gsi_last_nondebug_bb (basic_block bb)\n+{\n+  gimple_stmt_iterator i = gsi_last_bb (bb);\n+\n+  if (!gsi_end_p (i) && is_gimple_debug (gsi_stmt (i)))\n+    gsi_prev_nondebug (&i);\n+\n+  return i;\n+}\n+\n /* Return a pointer to the current stmt.\n    \n   NOTE: You may want to use gsi_replace on the iterator itself,"}, {"sha": "d5072385d220b4a6a7f3a7a53a7c062d28f3f283", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 193, "deletions": 31, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -310,7 +310,7 @@ size_t dfa_state_size;\n char *ready_try = NULL;\n \n /* The ready list.  */\n-struct ready_list ready = {NULL, 0, 0, 0};\n+struct ready_list ready = {NULL, 0, 0, 0, 0};\n \n /* The pointer to the ready list (to be removed).  */\n static struct ready_list *readyp = &ready;\n@@ -748,6 +748,10 @@ increase_insn_priority (rtx insn, int amount)\n static bool\n contributes_to_priority_p (dep_t dep)\n {\n+  if (DEBUG_INSN_P (DEP_CON (dep))\n+      || DEBUG_INSN_P (DEP_PRO (dep)))\n+    return false;\n+\n   /* Critical path is meaningful in block boundaries only.  */\n   if (!current_sched_info->contributes_to_priority (DEP_CON (dep),\n \t\t\t\t\t\t    DEP_PRO (dep)))\n@@ -767,6 +771,31 @@ contributes_to_priority_p (dep_t dep)\n   return true;\n }\n \n+/* Compute the number of nondebug forward deps of an insn.  */\n+\n+static int\n+dep_list_size (rtx insn)\n+{\n+  sd_iterator_def sd_it;\n+  dep_t dep;\n+  int dbgcount = 0, nodbgcount = 0;\n+\n+  if (!MAY_HAVE_DEBUG_INSNS)\n+    return sd_lists_size (insn, SD_LIST_FORW);\n+\n+  FOR_EACH_DEP (insn, SD_LIST_FORW, sd_it, dep)\n+    {\n+      if (DEBUG_INSN_P (DEP_CON (dep)))\n+\tdbgcount++;\n+      else\n+\tnodbgcount++;\n+    }\n+\n+  gcc_assert (dbgcount + nodbgcount == sd_lists_size (insn, SD_LIST_FORW));\n+\n+  return nodbgcount;\n+}\n+\n /* Compute the priority number for INSN.  */\n static int\n priority (rtx insn)\n@@ -781,7 +810,7 @@ priority (rtx insn)\n     {\n       int this_priority = -1;\n \n-      if (sd_lists_empty_p (insn, SD_LIST_FORW))\n+      if (dep_list_size (insn) == 0)\n \t/* ??? We should set INSN_PRIORITY to insn_cost when and insn has\n \t   some forward deps but all of them are ignored by\n \t   contributes_to_priority hook.  At the moment we set priority of\n@@ -886,9 +915,19 @@ rank_for_schedule (const void *x, const void *y)\n {\n   rtx tmp = *(const rtx *) y;\n   rtx tmp2 = *(const rtx *) x;\n+  rtx last;\n   int tmp_class, tmp2_class;\n   int val, priority_val, weight_val, info_val;\n \n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      /* Schedule debug insns as early as possible.  */\n+      if (DEBUG_INSN_P (tmp) && !DEBUG_INSN_P (tmp2))\n+\treturn -1;\n+      else if (DEBUG_INSN_P (tmp2))\n+\treturn 1;\n+    }\n+\n   /* The insn in a schedule group should be issued the first.  */\n   if (flag_sched_group_heuristic && \n       SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n@@ -936,8 +975,20 @@ rank_for_schedule (const void *x, const void *y)\n   if(flag_sched_rank_heuristic && info_val)\n     return info_val;\n \n-  /* Compare insns based on their relation to the last-scheduled-insn.  */\n-  if (flag_sched_last_insn_heuristic && INSN_P (last_scheduled_insn))\n+  if (flag_sched_last_insn_heuristic)\n+    {\n+      last = last_scheduled_insn;\n+\n+      if (DEBUG_INSN_P (last) && last != current_sched_info->prev_head)\n+\tdo\n+\t  last = PREV_INSN (last);\n+\twhile (!NONDEBUG_INSN_P (last)\n+\t       && last != current_sched_info->prev_head);\n+    }\n+\n+  /* Compare insns based on their relation to the last scheduled\n+     non-debug insn.  */\n+  if (flag_sched_last_insn_heuristic && NONDEBUG_INSN_P (last))\n     {\n       dep_t dep1;\n       dep_t dep2;\n@@ -947,7 +998,7 @@ rank_for_schedule (const void *x, const void *y)\n          2) Anti/Output dependent on last scheduled insn.\n          3) Independent of last scheduled insn, or has latency of one.\n          Choose the insn from the highest numbered class if different.  */\n-      dep1 = sd_find_dep_between (last_scheduled_insn, tmp, true);\n+      dep1 = sd_find_dep_between (last, tmp, true);\n \n       if (dep1 == NULL || dep_cost (dep1) == 1)\n \ttmp_class = 3;\n@@ -957,7 +1008,7 @@ rank_for_schedule (const void *x, const void *y)\n       else\n \ttmp_class = 2;\n \n-      dep2 = sd_find_dep_between (last_scheduled_insn, tmp2, true);\n+      dep2 = sd_find_dep_between (last, tmp2, true);\n \n       if (dep2 == NULL || dep_cost (dep2)  == 1)\n \ttmp2_class = 3;\n@@ -975,8 +1026,7 @@ rank_for_schedule (const void *x, const void *y)\n      This gives the scheduler more freedom when scheduling later\n      instructions at the expense of added register pressure.  */\n \n-  val = (sd_lists_size (tmp2, SD_LIST_FORW)\n-\t - sd_lists_size (tmp, SD_LIST_FORW));\n+  val = (dep_list_size (tmp2) - dep_list_size (tmp));\n \n   if (flag_sched_dep_count_heuristic && val != 0)\n     return val;\n@@ -1014,6 +1064,7 @@ queue_insn (rtx insn, int n_cycles)\n   rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n \n   gcc_assert (n_cycles <= max_insn_queue_index);\n+  gcc_assert (!DEBUG_INSN_P (insn));\n \n   insn_queue[next_q] = link;\n   q_size += 1;\n@@ -1081,6 +1132,8 @@ ready_add (struct ready_list *ready, rtx insn, bool first_p)\n     }\n \n   ready->n_ready++;\n+  if (DEBUG_INSN_P (insn))\n+    ready->n_debug++;\n \n   gcc_assert (QUEUE_INDEX (insn) != QUEUE_READY);\n   QUEUE_INDEX (insn) = QUEUE_READY;\n@@ -1097,6 +1150,8 @@ ready_remove_first (struct ready_list *ready)\n   gcc_assert (ready->n_ready);\n   t = ready->vec[ready->first--];\n   ready->n_ready--;\n+  if (DEBUG_INSN_P (t))\n+    ready->n_debug--;\n   /* If the queue becomes empty, reset it.  */\n   if (ready->n_ready == 0)\n     ready->first = ready->veclen - 1;\n@@ -1138,6 +1193,8 @@ ready_remove (struct ready_list *ready, int index)\n   gcc_assert (ready->n_ready && index < ready->n_ready);\n   t = ready->vec[ready->first - index];\n   ready->n_ready--;\n+  if (DEBUG_INSN_P (t))\n+    ready->n_debug--;\n   for (i = index; i < ready->n_ready; i++)\n     ready->vec[ready->first - i] = ready->vec[ready->first - i - 1];\n   QUEUE_INDEX (t) = QUEUE_NOWHERE;\n@@ -1316,7 +1373,8 @@ schedule_insn (rtx insn)\n      be aligned.  */\n   if (issue_rate > 1\n       && GET_CODE (PATTERN (insn)) != USE\n-      && GET_CODE (PATTERN (insn)) != CLOBBER)\n+      && GET_CODE (PATTERN (insn)) != CLOBBER\n+      && !DEBUG_INSN_P (insn))\n     {\n       if (reload_completed)\n \tPUT_MODE (insn, clock_var > last_clock_var ? TImode : VOIDmode);\n@@ -1428,7 +1486,7 @@ get_ebb_head_tail (basic_block beg, basic_block end, rtx *headp, rtx *tailp)\n     beg_head = NEXT_INSN (beg_head);\n \n   while (beg_head != beg_tail)\n-    if (NOTE_P (beg_head))\n+    if (NOTE_P (beg_head) || BOUNDARY_DEBUG_INSN_P (beg_head))\n       beg_head = NEXT_INSN (beg_head);\n     else\n       break;\n@@ -1441,7 +1499,7 @@ get_ebb_head_tail (basic_block beg, basic_block end, rtx *headp, rtx *tailp)\n     end_head = NEXT_INSN (end_head);\n \n   while (end_head != end_tail)\n-    if (NOTE_P (end_tail))\n+    if (NOTE_P (end_tail) || BOUNDARY_DEBUG_INSN_P (end_tail))\n       end_tail = PREV_INSN (end_tail);\n     else\n       break;\n@@ -1456,7 +1514,8 @@ no_real_insns_p (const_rtx head, const_rtx tail)\n {\n   while (head != NEXT_INSN (tail))\n     {\n-      if (!NOTE_P (head) && !LABEL_P (head))\n+      if (!NOTE_P (head) && !LABEL_P (head)\n+\t  && !BOUNDARY_DEBUG_INSN_P (head))\n \treturn 0;\n       head = NEXT_INSN (head);\n     }\n@@ -1627,9 +1686,13 @@ queue_to_ready (struct ready_list *ready)\n   q_ptr = NEXT_Q (q_ptr);\n \n   if (dbg_cnt (sched_insn) == false)\n-    /* If debug counter is activated do not requeue insn next after\n-       last_scheduled_insn.  */\n-    skip_insn = next_nonnote_insn (last_scheduled_insn);\n+    {\n+      /* If debug counter is activated do not requeue insn next after\n+\t last_scheduled_insn.  */\n+      skip_insn = next_nonnote_insn (last_scheduled_insn);\n+      while (skip_insn && DEBUG_INSN_P (skip_insn))\n+\tskip_insn = next_nonnote_insn (skip_insn);\n+    }\n   else\n     skip_insn = NULL_RTX;\n \n@@ -1647,7 +1710,7 @@ queue_to_ready (struct ready_list *ready)\n       /* If the ready list is full, delay the insn for 1 cycle.\n \t See the comment in schedule_block for the rationale.  */\n       if (!reload_completed\n-\t  && ready->n_ready > MAX_SCHED_READY_INSNS\n+\t  && ready->n_ready - ready->n_debug > MAX_SCHED_READY_INSNS\n \t  && !SCHED_GROUP_P (insn)\n \t  && insn != skip_insn)\n \t{\n@@ -2255,7 +2318,8 @@ choose_ready (struct ready_list *ready, rtx *insn_ptr)\n \n   if (targetm.sched.first_cycle_multipass_dfa_lookahead)\n     lookahead = targetm.sched.first_cycle_multipass_dfa_lookahead ();\n-  if (lookahead <= 0 || SCHED_GROUP_P (ready_element (ready, 0)))\n+  if (lookahead <= 0 || SCHED_GROUP_P (ready_element (ready, 0))\n+      || DEBUG_INSN_P (ready_element (ready, 0)))\n     {\n       *insn_ptr = ready_remove_first (ready);\n       return 0;\n@@ -2414,6 +2478,7 @@ schedule_block (basic_block *target_bb)\n   /* Clear the ready list.  */\n   ready.first = ready.veclen - 1;\n   ready.n_ready = 0;\n+  ready.n_debug = 0;\n \n   /* It is used for first cycle multipass scheduling.  */\n   temp_state = alloca (dfa_state_size);\n@@ -2424,7 +2489,8 @@ schedule_block (basic_block *target_bb)\n   /* We start inserting insns after PREV_HEAD.  */\n   last_scheduled_insn = prev_head;\n \n-  gcc_assert (NOTE_P (last_scheduled_insn)\n+  gcc_assert ((NOTE_P (last_scheduled_insn)\n+\t       || BOUNDARY_DEBUG_INSN_P (last_scheduled_insn))\n \t      && BLOCK_FOR_INSN (last_scheduled_insn) == *target_bb);\n \n   /* Initialize INSN_QUEUE.  Q_SIZE is the total number of insns in the\n@@ -2445,12 +2511,14 @@ schedule_block (basic_block *target_bb)\n   /* The algorithm is O(n^2) in the number of ready insns at any given\n      time in the worst case.  Before reload we are more likely to have\n      big lists so truncate them to a reasonable size.  */\n-  if (!reload_completed && ready.n_ready > MAX_SCHED_READY_INSNS)\n+  if (!reload_completed\n+      && ready.n_ready - ready.n_debug > MAX_SCHED_READY_INSNS)\n     {\n       ready_sort (&ready);\n \n-      /* Find first free-standing insn past MAX_SCHED_READY_INSNS.  */\n-      for (i = MAX_SCHED_READY_INSNS; i < ready.n_ready; i++)\n+      /* Find first free-standing insn past MAX_SCHED_READY_INSNS.\n+         If there are debug insns, we know they're first.  */\n+      for (i = MAX_SCHED_READY_INSNS + ready.n_debug; i < ready.n_ready; i++)\n \tif (!SCHED_GROUP_P (ready_element (&ready, i)))\n \t  break;\n \n@@ -2533,6 +2601,46 @@ schedule_block (basic_block *target_bb)\n \t    }\n \t}\n \n+      /* We don't want md sched reorder to even see debug isns, so put\n+\t them out right away.  */\n+      if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n+\t{\n+\t  if (control_flow_insn_p (last_scheduled_insn))\n+\t    {\n+\t      *target_bb = current_sched_info->advance_target_bb\n+\t\t(*target_bb, 0);\n+\n+\t      if (sched_verbose)\n+\t\t{\n+\t\t  rtx x;\n+\n+\t\t  x = next_real_insn (last_scheduled_insn);\n+\t\t  gcc_assert (x);\n+\t\t  dump_new_block_header (1, *target_bb, x, tail);\n+\t\t}\n+\n+\t      last_scheduled_insn = bb_note (*target_bb);\n+\t    }\n+\n+\t  while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n+\t    {\n+\t      rtx insn = ready_remove_first (&ready);\n+\t      gcc_assert (DEBUG_INSN_P (insn));\n+\t      (*current_sched_info->begin_schedule_ready) (insn,\n+\t\t\t\t\t\t\t   last_scheduled_insn);\n+\t      move_insn (insn, last_scheduled_insn,\n+\t\t\t current_sched_info->next_tail);\n+\t      last_scheduled_insn = insn;\n+\t      advance = schedule_insn (insn);\n+\t      gcc_assert (advance == 0);\n+\t      if (ready.n_ready > 0)\n+\t\tready_sort (&ready);\n+\t    }\n+\n+\t  if (!ready.n_ready)\n+\t    continue;\n+\t}\n+\n       /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n       if (sort_p && targetm.sched.reorder\n@@ -2574,7 +2682,8 @@ schedule_block (basic_block *target_bb)\n \t\tready_sort (&ready);\n \t    }\n \n-\t  if (ready.n_ready == 0 || !can_issue_more\n+\t  if (ready.n_ready == 0\n+\t      || !can_issue_more\n \t      || state_dead_lock_p (curr_state)\n \t      || !(*current_sched_info->schedule_more_p) ())\n \t    break;\n@@ -2711,7 +2820,7 @@ schedule_block (basic_block *target_bb)\n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n \t      targetm.sched.variable_issue (sched_dump, sched_verbose,\n-\t\t\t\t\t       insn, can_issue_more);\n+\t\t\t\t\t    insn, can_issue_more);\n \t  /* A naked CLOBBER or USE generates no instruction, so do\n \t     not count them against the issue rate.  */\n \t  else if (GET_CODE (PATTERN (insn)) != USE\n@@ -2734,6 +2843,44 @@ schedule_block (basic_block *target_bb)\n \t  if (ready.n_ready > 0)\n \t    ready_sort (&ready);\n \n+\t  /* Quickly go through debug insns such that md sched\n+\t     reorder2 doesn't have to deal with debug insns.  */\n+\t  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))\n+\t      && (*current_sched_info->schedule_more_p) ())\n+\t    {\n+\t      if (control_flow_insn_p (last_scheduled_insn))\n+\t\t{\n+\t\t  *target_bb = current_sched_info->advance_target_bb\n+\t\t    (*target_bb, 0);\n+\n+\t\t  if (sched_verbose)\n+\t\t    {\n+\t\t      rtx x;\n+\n+\t\t      x = next_real_insn (last_scheduled_insn);\n+\t\t      gcc_assert (x);\n+\t\t      dump_new_block_header (1, *target_bb, x, tail);\n+\t\t    }\n+\n+\t\t  last_scheduled_insn = bb_note (*target_bb);\n+\t\t}\n+\n+ \t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n+\t\t{\n+\t\t  insn = ready_remove_first (&ready);\n+\t\t  gcc_assert (DEBUG_INSN_P (insn));\n+\t\t  (*current_sched_info->begin_schedule_ready)\n+\t\t    (insn, last_scheduled_insn);\n+\t\t  move_insn (insn, last_scheduled_insn,\n+\t\t\t     current_sched_info->next_tail);\n+\t\t  advance = schedule_insn (insn);\n+\t\t  last_scheduled_insn = insn;\n+\t\t  gcc_assert (advance == 0);\n+\t\t  if (ready.n_ready > 0)\n+\t\t    ready_sort (&ready);\n+\t\t}\n+\t    }\n+\n \t  if (targetm.sched.reorder2\n \t      && (ready.n_ready == 0\n \t\t  || !SCHED_GROUP_P (ready_element (&ready, 0))))\n@@ -2757,7 +2904,7 @@ schedule_block (basic_block *target_bb)\n   if (current_sched_info->queue_must_finish_empty)\n     /* Sanity check -- queue must be empty now.  Meaningless if region has\n        multiple bbs.  */\n-    gcc_assert (!q_size && !ready.n_ready);\n+    gcc_assert (!q_size && !ready.n_ready && !ready.n_debug);\n   else \n     {\n       /* We must maintain QUEUE_INDEX between blocks in region.  */\n@@ -2836,8 +2983,8 @@ set_priorities (rtx head, rtx tail)\n \tcurrent_sched_info->sched_max_insns_priority;\n   rtx prev_head;\n \n-  if (head == tail && (! INSN_P (head)))\n-    return 0;\n+  if (head == tail && (! INSN_P (head) || BOUNDARY_DEBUG_INSN_P (head)))\n+    gcc_unreachable ();\n \n   n_insn = 0;\n \n@@ -4605,7 +4752,7 @@ add_jump_dependencies (rtx insn, rtx jump)\n       if (insn == jump)\n \tbreak;\n       \n-      if (sd_lists_empty_p (insn, SD_LIST_FORW))\n+      if (dep_list_size (insn) == 0)\n \t{\n \t  dep_def _new_dep, *new_dep = &_new_dep;\n \n@@ -4648,6 +4795,19 @@ has_edge_p (VEC(edge,gc) *el, int type)\n   return 0;\n }\n \n+/* Search back, starting at INSN, for an insn that is not a\n+   NOTE_INSN_VAR_LOCATION.  Don't search beyond HEAD, and return it if\n+   no such insn can be found.  */\n+static inline rtx\n+prev_non_location_insn (rtx insn, rtx head)\n+{\n+  while (insn != head && NOTE_P (insn)\n+\t && NOTE_KIND (insn) == NOTE_INSN_VAR_LOCATION)\n+    insn = PREV_INSN (insn);\n+\n+  return insn;\n+}\n+\n /* Check few properties of CFG between HEAD and TAIL.\n    If HEAD (TAIL) is NULL check from the beginning (till the end) of the\n    instruction stream.  */\n@@ -4707,8 +4867,9 @@ check_cfg (rtx head, rtx tail)\n \t    {\n \t      if (control_flow_insn_p (head))\n \t\t{\n-\t\t  gcc_assert (BB_END (bb) == head);\n-\t\t  \n+\t\t  gcc_assert (prev_non_location_insn (BB_END (bb), head)\n+\t\t\t      == head);\n+\n \t\t  if (any_uncondjump_p (head))\n \t\t    gcc_assert (EDGE_COUNT (bb->succs) == 1\n \t\t\t\t&& BARRIER_P (NEXT_INSN (head)));\n@@ -4724,11 +4885,12 @@ check_cfg (rtx head, rtx tail)\n \t      if (BB_END (bb) == head)\n \t\t{\n \t\t  if (EDGE_COUNT (bb->succs) > 1)\n-\t\t    gcc_assert (control_flow_insn_p (head)\n+\t\t    gcc_assert (control_flow_insn_p (prev_non_location_insn\n+\t\t\t\t\t\t     (head, BB_HEAD (bb)))\n \t\t\t\t|| has_edge_p (bb->succs, EDGE_COMPLEX));\n \t\t  bb = 0;\n \t\t}\n-\t\t\t      \n+\n \t      head = NEXT_INSN (head);\n \t    }\n \t}"}, {"sha": "1cf2608a1778a78daaff2d14357cb9817eda9134", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -194,7 +194,7 @@ first_active_insn (basic_block bb)\n       insn = NEXT_INSN (insn);\n     }\n \n-  while (NOTE_P (insn))\n+  while (NOTE_P (insn) || DEBUG_INSN_P (insn))\n     {\n       if (insn == BB_END (bb))\n \treturn NULL_RTX;\n@@ -217,6 +217,7 @@ last_active_insn (basic_block bb, int skip_use_p)\n \n   while (NOTE_P (insn)\n \t || JUMP_P (insn)\n+\t || DEBUG_INSN_P (insn)\n \t || (skip_use_p\n \t     && NONJUMP_INSN_P (insn)\n \t     && GET_CODE (PATTERN (insn)) == USE))\n@@ -269,7 +270,7 @@ cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n \n   for (insn = start; ; insn = NEXT_INSN (insn))\n     {\n-      if (NOTE_P (insn))\n+      if (NOTE_P (insn) || DEBUG_INSN_P (insn))\n \tgoto insn_done;\n \n       gcc_assert(NONJUMP_INSN_P (insn) || CALL_P (insn));\n@@ -2256,6 +2257,8 @@ noce_process_if_block (struct noce_if_info *if_info)\n   else\n     {\n       insn_b = prev_nonnote_insn (if_info->cond_earliest);\n+      while (insn_b && DEBUG_INSN_P (insn_b))\n+\tinsn_b = prev_nonnote_insn (insn_b);\n       /* We're going to be moving the evaluation of B down from above\n \t COND_EARLIEST to JUMP.  Make sure the relevant data is still\n \t intact.  */\n@@ -2266,14 +2269,13 @@ noce_process_if_block (struct noce_if_info *if_info)\n \t  || ! rtx_equal_p (x, SET_DEST (set_b))\n \t  || ! noce_operand_ok (SET_SRC (set_b))\n \t  || reg_overlap_mentioned_p (x, SET_SRC (set_b))\n-\t  || modified_between_p (SET_SRC (set_b),\n-\t\t\t\t PREV_INSN (if_info->cond_earliest), jump)\n+\t  || modified_between_p (SET_SRC (set_b), insn_b, jump)\n \t  /* Likewise with X.  In particular this can happen when\n \t     noce_get_condition looks farther back in the instruction\n \t     stream than one might expect.  */\n \t  || reg_overlap_mentioned_p (x, cond)\n \t  || reg_overlap_mentioned_p (x, a)\n-\t  || modified_between_p (x, PREV_INSN (if_info->cond_earliest), jump))\n+\t  || modified_between_p (x, insn_b, jump))\n \tinsn_b = set_b = NULL_RTX;\n     }\n \n@@ -2481,7 +2483,7 @@ check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs, rtx co\n     {\n       rtx set, dest, src;\n \n-      if (!INSN_P (insn) || JUMP_P (insn))\n+      if (!NONDEBUG_INSN_P (insn) || JUMP_P (insn))\n \tcontinue;\n       set = single_set (insn);\n       if (!set)\n@@ -2559,7 +2561,8 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n       rtx set, target, dest, t, e;\n       unsigned int regno;\n \n-      if (!INSN_P (insn) || JUMP_P (insn))\n+      /* ??? Maybe emit conditional debug insn?  */\n+      if (!NONDEBUG_INSN_P (insn) || JUMP_P (insn))\n \tcontinue;\n       set = single_set (insn);\n       gcc_assert (set && REG_P (SET_DEST (set)));\n@@ -3120,6 +3123,7 @@ block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n \n       if (INSN_P (insn)\n \t  && !JUMP_P (insn)\n+\t  && !DEBUG_INSN_P (insn)\n \t  && GET_CODE (PATTERN (insn)) != USE\n \t  && GET_CODE (PATTERN (insn)) != CLOBBER)\n \tn_insns++;\n@@ -3789,6 +3793,9 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   head = BB_HEAD (merge_bb);\n   end = BB_END (merge_bb);\n \n+  while (DEBUG_INSN_P (end) && end != head)\n+    end = PREV_INSN (end);\n+\n   /* If merge_bb ends with a tablejump, predicating/moving insn's\n      into test_bb and then deleting merge_bb will result in the jumptable\n      that follows merge_bb being removed along with merge_bb and then we\n@@ -3798,6 +3805,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n   if (LABEL_P (head))\n     head = NEXT_INSN (head);\n+  while (DEBUG_INSN_P (head) && head != end)\n+    head = NEXT_INSN (head);\n   if (NOTE_P (head))\n     {\n       if (head == end)\n@@ -3806,6 +3815,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t  goto no_body;\n \t}\n       head = NEXT_INSN (head);\n+      while (DEBUG_INSN_P (head) && head != end)\n+\thead = NEXT_INSN (head);\n     }\n \n   if (JUMP_P (end))\n@@ -3816,6 +3827,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t  goto no_body;\n \t}\n       end = PREV_INSN (end);\n+      while (DEBUG_INSN_P (end) && end != head)\n+\tend = PREV_INSN (end);\n     }\n \n   /* Disable handling dead code by conditional execution if the machine needs\n@@ -3876,7 +3889,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t{\n \t  if (CALL_P (insn))\n \t    return FALSE;\n-\t  if (INSN_P (insn))\n+\t  if (NONDEBUG_INSN_P (insn))\n \t    {\n \t      if (may_trap_p (PATTERN (insn)))\n \t\treturn FALSE;\n@@ -3922,7 +3935,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n       FOR_BB_INSNS (merge_bb, insn)\n \t{\n-\t  if (INSN_P (insn))\n+\t  if (NONDEBUG_INSN_P (insn))\n \t    {\n \t      unsigned int uid = INSN_UID (insn);\n \t      df_ref *def_rec;"}, {"sha": "f667797b8df32350467a9dca72c432faee270ff4", "filename": "gcc/init-regs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -70,7 +70,7 @@ initialize_uninitialized_regs (void)\n \t{\n \t  unsigned int uid = INSN_UID (insn);\n \t  df_ref *use_rec;\n-\t  if (!INSN_P (insn))\n+\t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n \n \t  for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)"}, {"sha": "201dc5996c1ef8eb6da5fdc2321ca055d85e664f", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -411,6 +411,9 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n   gimple stmt = gsi_stmt (*gsip);\n   unsigned int i = 0;\n \n+  if (is_gimple_debug (stmt))\n+    return;\n+\n   if (dump_file)\n     {\n       fprintf (dump_file, \"  scanning: \");"}, {"sha": "10daf56eab6a660ec1b9610060e0f3321a18962e", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -442,6 +442,9 @@ scan_stmt_for_static_refs (gimple_stmt_iterator *gsip,\n   gimple stmt = gsi_stmt (*gsip);\n   ipa_reference_local_vars_info_t local = NULL;\n \n+  if (is_gimple_debug (stmt))\n+    return NULL;\n+\n   if (fn)\n     local = get_reference_vars_info (fn)->local;\n "}, {"sha": "edb761b0d71274b9f70cb2e7937c68c8189d5ca5", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1491,7 +1491,7 @@ create_bb_allocnos (ira_loop_tree_node_t bb_node)\n   curr_bb = bb = bb_node->bb;\n   ira_assert (bb != NULL);\n   FOR_BB_INSNS_REVERSE (bb, insn)\n-    if (INSN_P (insn))\n+    if (NONDEBUG_INSN_P (insn))\n       create_insn_allocnos (PATTERN (insn), false);\n   /* It might be a allocno living through from one subloop to\n      another.  */"}, {"sha": "bce5c7f6294fdc9543e7b362b0a62fac9d56f382", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -522,7 +522,7 @@ add_copies (ira_loop_tree_node_t loop_tree_node)\n   if (bb == NULL)\n     return;\n   FOR_BB_INSNS (bb, insn)\n-    if (INSN_P (insn))\n+    if (NONDEBUG_INSN_P (insn))\n       add_insn_allocno_copies (insn);\n }\n "}, {"sha": "bb51c55bc651beb0d55ca35b49a0a3ba4680895c", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -995,7 +995,7 @@ scan_one_insn (rtx insn)\n   rtx set, note;\n   int i, k;\n \n-  if (!INSN_P (insn))\n+  if (!NONDEBUG_INSN_P (insn))\n     return insn;\n \n   pat_code = GET_CODE (PATTERN (insn));\n@@ -1384,7 +1384,7 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n     freq = 1;\n   FOR_BB_INSNS (bb, insn)\n     {\n-      if (! INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n       set = single_set (insn);\n       if (set == NULL_RTX)"}, {"sha": "aa1904092ad35965f5f0599445fffbd2726b6eab", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -910,7 +910,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  df_ref *def_rec, *use_rec;\n \t  bool call_p;\n \t  \n-\t  if (! INSN_P (insn))\n+\t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n \t  \n \t  if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)"}, {"sha": "b6524895efe7025fe381c8e27ff026068efaa89c", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -2234,7 +2234,7 @@ memref_used_between_p (rtx memref, rtx start, rtx end)\n   for (insn = NEXT_INSN (start); insn != NEXT_INSN (end);\n        insn = NEXT_INSN (insn))\n     {\n-      if (!INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n       \n       if (memref_referenced_p (memref, PATTERN (insn)))\n@@ -2678,7 +2678,7 @@ update_equiv_regs (void)\n \t\t    }\n \t\t  /* Move the initialization of the register to just before\n \t\t     INSN.  Update the flow information.  */\n-\t\t  else if (PREV_INSN (insn) != equiv_insn)\n+\t\t  else if (prev_nondebug_insn (insn) != equiv_insn)\n \t\t    {\n \t\t      rtx new_insn;\n "}, {"sha": "11a8310f33ee8b99b93e57c0cf552760b0d81cde", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -912,7 +912,7 @@ find_invariants_bb (basic_block bb, bool always_reached, bool always_executed)\n \n   FOR_BB_INSNS (bb, insn)\n     {\n-      if (!INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n       find_invariants_insn (insn, always_reached, always_executed);"}, {"sha": "3ff20eb3de52647a18f38515c92d9fbc7c47f5e7", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -531,6 +531,34 @@ resolve_subreg_use (rtx *px, void *data)\n   return 0;\n }\n \n+/* This is called via for_each_rtx.  Look for SUBREGs which can be\n+   decomposed and decomposed REGs that need copying.  */\n+\n+static int\n+adjust_decomposed_uses (rtx *px, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *px;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+\n+  if (resolve_subreg_p (x))\n+    {\n+      x = simplify_subreg_concatn (GET_MODE (x), SUBREG_REG (x),\n+\t\t\t\t   SUBREG_BYTE (x));\n+\n+      if (x)\n+\t*px = x;\n+      else\n+\tx = copy_rtx (*px);\n+    }\n+\n+  if (resolve_reg_p (x))\n+    *px = copy_rtx (x);\n+\n+  return 0;\n+}\n+\n /* We are deleting INSN.  Move any EH_REGION notes to INSNS.  */\n \n static void\n@@ -886,6 +914,18 @@ resolve_use (rtx pat, rtx insn)\n   return false;\n }\n \n+/* A VAR_LOCATION can be simplified.  */\n+\n+static void\n+resolve_debug (rtx insn)\n+{\n+  for_each_rtx (&PATTERN (insn), adjust_decomposed_uses, NULL_RTX);\n+\n+  df_insn_rescan (insn);\n+\n+  resolve_reg_notes (insn);\n+}\n+\n /* Checks if INSN is a decomposable multiword-shift or zero-extend and\n    sets the decomposable_context bitmap accordingly.  A non-zero value\n    is returned if a decomposable insn has been found.  */\n@@ -1170,6 +1210,8 @@ decompose_multiword_subregs (void)\n \t\tresolve_clobber (pat, insn);\n \t      else if (GET_CODE (pat) == USE)\n \t\tresolve_use (pat, insn);\n+\t      else if (DEBUG_INSN_P (insn))\n+\t\tresolve_debug (insn);\n \t      else\n \t\t{\n \t\t  rtx set;"}, {"sha": "fb6f548b0c9ad75f36f89843cbb8bebcf53d3983", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -349,7 +349,7 @@ const_iteration_count (rtx count_reg, basic_block pre_header,\n   get_ebb_head_tail (pre_header, pre_header, &head, &tail);\n \n   for (insn = tail; insn != PREV_INSN (head); insn = PREV_INSN (insn))\n-    if (INSN_P (insn) && single_set (insn) &&\n+    if (NONDEBUG_INSN_P (insn) && single_set (insn) &&\n \trtx_equal_p (count_reg, SET_DEST (single_set (insn))))\n       {\n \trtx pat = single_set (insn);\n@@ -375,7 +375,7 @@ res_MII (ddg_ptr g)\n   if (targetm.sched.sms_res_mii)\n     return targetm.sched.sms_res_mii (g); \n   \n-  return (g->num_nodes / issue_rate);\n+  return ((g->num_nodes - g->num_debug) / issue_rate);\n }\n \n \n@@ -769,7 +769,7 @@ loop_single_full_bb_p (struct loop *loop)\n       for (; head != NEXT_INSN (tail); head = NEXT_INSN (head))\n         {\n           if (NOTE_P (head) || LABEL_P (head)\n- \t      || (INSN_P (head) && JUMP_P (head)))\n+ \t      || (INSN_P (head) && (DEBUG_INSN_P (head) || JUMP_P (head))))\n  \t    continue;\n  \t  empty_bb = false;\n  \t  break;\n@@ -1020,7 +1020,7 @@ sms_schedule (void)\n \n         if (CALL_P (insn)\n             || BARRIER_P (insn)\n-            || (INSN_P (insn) && !JUMP_P (insn)\n+            || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE)\n             || (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n             || (INSN_P (insn) && (set = single_set (insn))\n@@ -1038,7 +1038,7 @@ sms_schedule (void)\n \t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n               else if (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n                 fprintf (dump_file, \"SMS reg inc\\n\");\n-              else if ((INSN_P (insn) && !JUMP_P (insn)\n+              else if ((NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n                 && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n                 fprintf (dump_file, \"SMS loop-with-not-single-set\\n\");\n               else\n@@ -1754,7 +1754,7 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n   \t  ddg_node_ptr u_node = &ps->g->nodes[u];\n \t  rtx insn = u_node->insn;\n \n-\t  if (!INSN_P (insn))\n+\t  if (!NONDEBUG_INSN_P (insn))\n \t    {\n \t      RESET_BIT (tobe_scheduled, u);\n \t      continue;\n@@ -2743,7 +2743,7 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n \t{\n \t  rtx insn = crr_insn->node->insn;\n \n-\t  if (!INSN_P (insn))\n+\t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n \n \t  /* Check if there is room for the current insn.  */"}, {"sha": "601132e14a8daf67f5cfac9f95abafca52332c79", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -2054,7 +2054,7 @@ common_handle_option (size_t scode, const char *arg, int value,\n       break;\n \n     case OPT_gdwarf_:\n-      if (value < 2 || value > 3)\n+      if (value < 2 || value > 4)\n \terror (\"dwarf version %d is not supported\", value);\n       else\n \tdwarf_version = value;"}, {"sha": "dc5ceaf573ea206cbd4413cd0a2f3e0e5704f1cd", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -752,6 +752,13 @@ DEFPARAM (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO,\n \t  \"min. ratio of insns to mem ops to enable prefetching in a loop\",\n \t  3, 0, 0)\n \n+/* Set minimum insn uid for non-debug insns.  */\n+\n+DEFPARAM (PARAM_MIN_NONDEBUG_INSN_UID,\n+\t  \"min-nondebug-insn-uid\",\n+\t  \"The minimum UID to be used for a nondebug insn\",\n+\t  0, 1, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "67a7a05c3deefe91357c8fbf50837835978ecedb", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -170,4 +170,6 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_MIN_INSN_TO_PREFETCH_RATIO)\n #define PREFETCH_MIN_INSN_TO_MEM_RATIO \\\n   PARAM_VALUE (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO)\n+#define MIN_NONDEBUG_INSN_UID \\\n+  PARAM_VALUE (PARAM_MIN_NONDEBUG_INSN_UID)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "cb09597b5797cc0ae8a0e2b379bb11cf9e7e8c7f", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"diagnostic.h\"\n+#include \"cselib.h\"\n #endif\n \n static FILE *outfile;\n@@ -165,6 +166,23 @@ print_rtx (const_rtx in_rtx)\n \t  /* For other rtl, print the mode if it's not VOID.  */\n \t  else if (GET_MODE (in_rtx) != VOIDmode)\n \t    fprintf (outfile, \":%s\", GET_MODE_NAME (GET_MODE (in_rtx)));\n+\n+#ifndef GENERATOR_FILE\n+\t  if (GET_CODE (in_rtx) == VAR_LOCATION)\n+\t    {\n+\t      if (TREE_CODE (PAT_VAR_LOCATION_DECL (in_rtx)) == STRING_CST)\n+\t\tfputs (\" <debug string placeholder>\", outfile);\n+\t      else\n+\t\tprint_mem_expr (outfile, PAT_VAR_LOCATION_DECL (in_rtx));\n+\t      fputc (' ', outfile);\n+\t      print_rtx (PAT_VAR_LOCATION_LOC (in_rtx));\n+\t      if (PAT_VAR_LOCATION_STATUS (in_rtx)\n+\t\t  == VAR_INIT_STATUS_UNINITIALIZED)\n+\t\tfprintf (outfile, \" [uninit]\");\n+\t      sawclose = 1;\n+\t      i = GET_RTX_LENGTH (VAR_LOCATION);\n+\t    }\n+#endif\n \t}\n     }\n \n@@ -278,14 +296,8 @@ print_rtx (const_rtx in_rtx)\n \t\t\n \t      case NOTE_INSN_VAR_LOCATION:\n #ifndef GENERATOR_FILE\n-\t\tfprintf (outfile, \" (\");\n-\t\tprint_mem_expr (outfile, NOTE_VAR_LOCATION_DECL (in_rtx));\n-\t\tfprintf (outfile, \" \");\n-\t\tprint_rtx (NOTE_VAR_LOCATION_LOC (in_rtx));\n-\t\tif (NOTE_VAR_LOCATION_STATUS (in_rtx) == \n-\t\t                                 VAR_INIT_STATUS_UNINITIALIZED)\n-\t\t  fprintf (outfile, \" [uninit]\");\n-\t\tfprintf (outfile, \")\");\n+\t\tfputc (' ', outfile);\n+\t\tprint_rtx (NOTE_VAR_LOCATION (in_rtx));\n #endif\n \t\tbreak;\n \n@@ -296,6 +308,16 @@ print_rtx (const_rtx in_rtx)\n \telse if (i == 9 && JUMP_P (in_rtx) && XEXP (in_rtx, i) != NULL)\n \t  /* Output the JUMP_LABEL reference.  */\n \t  fprintf (outfile, \"\\n -> %d\", INSN_UID (XEXP (in_rtx, i)));\n+\telse if (i == 0 && GET_CODE (in_rtx) == VALUE)\n+\t  {\n+#ifndef GENERATOR_FILE\n+\t    cselib_val *val = CSELIB_VAL_PTR (in_rtx);\n+\n+\t    fprintf (outfile, \" %i\", val->value);\n+\t    dump_addr (outfile, \" @\", in_rtx);\n+\t    dump_addr (outfile, \"/\", (void*)val);\n+#endif\n+\t  }\n \tbreak;\n \n       case 'e':"}, {"sha": "c1e25d746a15150039aec6da7bc3f6b20c3b03cb", "filename": "gcc/recog.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -389,6 +389,8 @@ verify_changes (int num)\n \t     assemblies if they have been defined as register asm (\"x\").  */\n \t  break;\n \t}\n+      else if (DEBUG_INSN_P (object))\n+\tcontinue;\n       else if (insn_invalid_p (object))\n \t{\n \t  rtx pat = PATTERN (object);\n@@ -429,7 +431,8 @@ verify_changes (int num)\n \t      validate_change (object, &PATTERN (object), newpat, 1);\n \t      continue;\n \t    }\n-\t  else if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t  else if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n+\t\t   || GET_CODE (pat) == VAR_LOCATION)\n \t    /* If this insn is a CLOBBER or USE, it is always valid, but is\n \t       never recognized.  */\n \t    continue;\n@@ -2039,6 +2042,7 @@ extract_insn (rtx insn)\n     case ASM_INPUT:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n+    case VAR_LOCATION:\n       return;\n \n     case SET:\n@@ -3119,7 +3123,7 @@ peephole2_optimize (void)\n       for (insn = BB_END (bb); ; insn = prev)\n \t{\n \t  prev = PREV_INSN (insn);\n-\t  if (INSN_P (insn))\n+\t  if (NONDEBUG_INSN_P (insn))\n \t    {\n \t      rtx attempt, before_try, x;\n \t      int match_len;"}, {"sha": "ff09ad224d920a9b7aa482889f09324a6805cba6", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1327,6 +1327,30 @@ compare_for_stack_reg (rtx insn, stack regstack, rtx pat_src)\n     }\n }\n \f\n+/* Substitute new registers in LOC, which is part of a debug insn.\n+   REGSTACK is the current register layout.  */\n+\n+static int\n+subst_stack_regs_in_debug_insn (rtx *loc, void *data)\n+{\n+  rtx *tloc = get_true_reg (loc);\n+  stack regstack = (stack)data;\n+  int hard_regno;\n+\n+  if (!STACK_REG_P (*tloc))\n+    return 0;\n+\n+  if (tloc != loc)\n+    return 0;\n+\n+  hard_regno = get_hard_regnum (regstack, *loc);\n+  gcc_assert (hard_regno >= FIRST_STACK_REG);\n+\n+  replace_reg (loc, hard_regno);\n+\n+  return -1;\n+}\n+\n /* Substitute new registers in PAT, which is part of INSN.  REGSTACK\n    is the current register layout.  Return whether a control flow insn\n    was deleted in the process.  */\n@@ -1360,6 +1384,9 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t since the REG_DEAD notes are not issued.)  */\n       break;\n \n+    case VAR_LOCATION:\n+      gcc_unreachable ();\n+\n     case CLOBBER:\n       {\n \trtx note;\n@@ -2871,6 +2898,7 @@ convert_regs_1 (basic_block block)\n   int reg;\n   rtx insn, next;\n   bool control_flow_insn_deleted = false;\n+  int debug_insns_with_starting_stack = 0;\n \n   any_malformed_asm = false;\n \n@@ -2923,8 +2951,25 @@ convert_regs_1 (basic_block block)\n \n       /* Don't bother processing unless there is a stack reg\n \t mentioned or if it's a CALL_INSN.  */\n-      if (stack_regs_mentioned (insn)\n-\t  || CALL_P (insn))\n+      if (DEBUG_INSN_P (insn))\n+\t{\n+\t  if (starting_stack_p)\n+\t    debug_insns_with_starting_stack++;\n+\t  else\n+\t    {\n+\t      for_each_rtx (&PATTERN (insn), subst_stack_regs_in_debug_insn,\n+\t\t\t    &regstack);\n+\n+\t      /* Nothing must ever die at a debug insn.  If something\n+\t\t is referenced in it that becomes dead, it should have\n+\t\t died before and the reference in the debug insn\n+\t\t should have been removed so as to avoid changing code\n+\t\t generation.  */\n+\t      gcc_assert (!find_reg_note (insn, REG_DEAD, NULL));\n+\t    }\n+\t}\n+      else if (stack_regs_mentioned (insn)\n+\t       || CALL_P (insn))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -2938,6 +2983,24 @@ convert_regs_1 (basic_block block)\n     }\n   while (next);\n \n+  if (debug_insns_with_starting_stack)\n+    {\n+      /* Since it's the first non-debug instruction that determines\n+\t the stack requirements of the current basic block, we refrain\n+\t from updating debug insns before it in the loop above, and\n+\t fix them up here.  */\n+      for (insn = BB_HEAD (block); debug_insns_with_starting_stack;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!DEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  debug_insns_with_starting_stack--;\n+\t  for_each_rtx (&PATTERN (insn), subst_stack_regs_in_debug_insn,\n+\t\t\t&bi->stack_in);\n+\t}\n+    }\n+\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Expected live registers [\");"}, {"sha": "893751886ebcf78d8d0953145b3ff00d327dfb07", "filename": "gcc/regcprop.c", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -474,6 +474,9 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n   switch (code)\n     {\n     case PLUS:\n+      if (DEBUG_INSN_P (insn))\n+\tbreak;\n+\n       {\n \trtx orig_op0 = XEXP (x, 0);\n \trtx orig_op1 = XEXP (x, 1);\n@@ -608,9 +611,14 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n static bool\n replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n {\n-  return replace_oldest_value_addr (&XEXP (x, 0),\n-\t\t\t\t    base_reg_class (GET_MODE (x), MEM,\n-\t\t\t\t\t\t    SCRATCH),\n+  enum reg_class cl;\n+\n+  if (DEBUG_INSN_P (insn))\n+    cl = ALL_REGS;\n+  else\n+    cl = base_reg_class (GET_MODE (x), MEM, SCRATCH);\n+\n+  return replace_oldest_value_addr (&XEXP (x, 0), cl,\n \t\t\t\t    GET_MODE (x), insn, vd);\n }\n \n@@ -619,7 +627,7 @@ replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n static bool\n copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n {\n-  bool changed = false;\n+  bool anything_changed = false;\n   rtx insn;\n \n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n@@ -628,9 +636,25 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       bool is_asm, any_replacements;\n       rtx set;\n       bool replaced[MAX_RECOG_OPERANDS];\n+      bool changed = false;\n \n-      if (! INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \t{\n+\t  if (DEBUG_INSN_P (insn))\n+\t    {\n+\t      rtx loc = INSN_VAR_LOCATION_LOC (insn);\n+\t      if (!VAR_LOC_UNKNOWN_P (loc)\n+\t\t  && replace_oldest_value_addr (&INSN_VAR_LOCATION_LOC (insn),\n+\t\t\t\t\t\tALL_REGS, GET_MODE (loc),\n+\t\t\t\t\t\tinsn, vd))\n+\t\t{\n+\t\t  changed = apply_change_group ();\n+\t\t  gcc_assert (changed);\n+\t\t  df_insn_rescan (insn);\n+\t\t  anything_changed = true;\n+\t\t}\n+\t    }\n+\n \t  if (insn == BB_END (bb))\n \t    break;\n \t  else\n@@ -817,6 +841,12 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t}\n \n     did_replacement:\n+      if (changed)\n+\t{\n+\t  df_insn_rescan (insn);\n+\t  anything_changed = true;\n+\t}\n+\n       /* Clobber call-clobbered registers.  */\n       if (CALL_P (insn))\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -834,7 +864,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \tbreak;\n     }\n \n-  return changed;\n+  return anything_changed;\n }\n \n /* Main entry point for the forward copy propagation optimization.  */"}, {"sha": "ab1a4696d367a48f7d149392f99e9627b3c57493", "filename": "gcc/regmove.c", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -321,9 +321,12 @@ optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n \t      /* For SREGNO, count the total number of insns scanned.\n \t\t For DREGNO, count the total number of insns scanned after\n \t\t passing the death note for DREGNO.  */\n-\t      s_length++;\n-\t      if (dest_death)\n-\t\td_length++;\n+\t      if (!DEBUG_INSN_P (p))\n+\t\t{\n+\t\t  s_length++;\n+\t\t  if (dest_death)\n+\t\t    d_length++;\n+\t\t}\n \n \t      /* If the insn in which SRC dies is a CALL_INSN, don't count it\n \t\t as a call that has been crossed.  Otherwise, count it.  */\n@@ -767,7 +770,7 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n \n       if (find_regno_note (p, REG_DEAD, REGNO (dst)))\n \tdst_death = p;\n-      if (! dst_death)\n+      if (! dst_death && !DEBUG_INSN_P (p))\n \tlength++;\n \n       pset = single_set (p);\n@@ -1095,32 +1098,22 @@ regmove_backward_pass (void)\n \t\t  if (BLOCK_FOR_INSN (p) != bb)\n \t\t    break;\n \n-\t\t  length++;\n+\t\t  if (!DEBUG_INSN_P (p))\n+\t\t    length++;\n \n \t\t  /* ??? See if all of SRC is set in P.  This test is much\n \t\t     more conservative than it needs to be.  */\n \t\t  pset = single_set (p);\n \t\t  if (pset && SET_DEST (pset) == src)\n \t\t    {\n \t\t      /* We use validate_replace_rtx, in case there\n-\t\t\t are multiple identical source operands.  All of\n-\t\t\t them have to be changed at the same time.  */\n+\t\t\t are multiple identical source operands.  All\n+\t\t\t of them have to be changed at the same time:\n+\t\t\t when validate_replace_rtx() calls\n+\t\t\t apply_change_group().  */\n+\t\t      validate_change (p, &SET_DEST (pset), dst, 1);\n \t\t      if (validate_replace_rtx (src, dst, insn))\n-\t\t\t{\n-\t\t\t  if (validate_change (p, &SET_DEST (pset),\n-\t\t\t\t\t       dst, 0))\n-\t\t\t    success = 1;\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      /* Change all source operands back.\n-\t\t\t\t This modifies the dst as a side-effect.  */\n-\t\t\t      validate_replace_rtx (dst, src, insn);\n-\t\t\t      /* Now make sure the dst is right.  */\n-\t\t\t      validate_change (insn,\n-\t\t\t\t\t       recog_data.operand_loc[match_no],\n-\t\t\t\t\t       dst, 0);\n-\t\t\t    }\n-\t\t\t}\n+\t\t\tsuccess = 1;\n \t\t      break;\n \t\t    }\n \n@@ -1129,9 +1122,21 @@ regmove_backward_pass (void)\n \t\t     eliminate SRC. We can't make this change \n \t\t     if DST is mentioned at all in P,\n \t\t     since we are going to change its value.  */\n-\t\t  if (reg_overlap_mentioned_p (src, PATTERN (p))\n-\t\t      || reg_mentioned_p (dst, PATTERN (p)))\n-\t\t    break;\n+\t\t  if (reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t\t    {\n+\t\t      if (DEBUG_INSN_P (p))\n+\t\t\tvalidate_replace_rtx_group (dst, src, insn);\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  if (reg_mentioned_p (dst, PATTERN (p)))\n+\t\t    {\n+\t\t      if (DEBUG_INSN_P (p))\n+\t\t\tvalidate_change (p, &INSN_VAR_LOCATION_LOC (p),\n+\t\t\t\t\t gen_rtx_UNKNOWN_VAR_LOC (), 1);\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n \n \t\t  /* If we have passed a call instruction, and the\n \t\t     pseudo-reg DST is not already live across a call,\n@@ -1193,6 +1198,8 @@ regmove_backward_pass (void)\n \n \t\t  break;\n \t\t}\n+\t      else if (num_changes_pending () > 0)\n+\t\tcancel_changes (0);\n \t    }\n \n \t  /* If we weren't able to replace any of the alternatives, try an"}, {"sha": "03aba8073a2fd6eb8ffebfdaad648c9d00bc5924", "filename": "gcc/regrename.c", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -230,7 +230,7 @@ regrename_optimize (void)\n \t  int new_reg, best_new_reg;\n \t  int n_uses;\n \t  struct du_chain *this_du = all_chains;\n-\t  struct du_chain *tmp, *last;\n+\t  struct du_chain *tmp;\n \t  HARD_REG_SET this_unavailable;\n \t  int reg = REGNO (*this_du->loc);\n \t  int i;\n@@ -259,21 +259,20 @@ regrename_optimize (void)\n \n \t  COPY_HARD_REG_SET (this_unavailable, unavailable);\n \n-\t  /* Find last entry on chain (which has the need_caller_save bit),\n-\t     count number of uses, and narrow the set of registers we can\n+\t  /* Count number of uses, and narrow the set of registers we can\n \t     use for renaming.  */\n \t  n_uses = 0;\n-\t  for (last = this_du; last->next_use; last = last->next_use)\n+\t  for (tmp = this_du; tmp; tmp = tmp->next_use)\n \t    {\n+\t      if (DEBUG_INSN_P (tmp->insn))\n+\t\tcontinue;\n \t      n_uses++;\n \t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n-\t\t\t\t      reg_class_contents[last->cl]);\n+\t\t\t\t      reg_class_contents[tmp->cl]);\n \t    }\n-\t  if (n_uses < 1)\n-\t    continue;\n \n-\t  IOR_COMPL_HARD_REG_SET (this_unavailable,\n-\t\t\t\t  reg_class_contents[last->cl]);\n+\t  if (n_uses < 2)\n+\t    continue;\n \n \t  if (this_du->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n@@ -310,7 +309,8 @@ regrename_optimize (void)\n \t      /* See whether it accepts all modes that occur in\n \t\t definition and uses.  */\n \t      for (tmp = this_du; tmp; tmp = tmp->next_use)\n-\t\tif (! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n+\t\tif ((! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n+\t\t     && ! DEBUG_INSN_P (tmp->insn))\n \t\t    || (tmp->need_caller_save_reg\n \t\t\t&& ! (HARD_REGNO_CALL_PART_CLOBBERED\n \t\t\t      (reg, GET_MODE (*tmp->loc)))\n@@ -327,8 +327,8 @@ regrename_optimize (void)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Register %s in insn %d\",\n-\t\t       reg_names[reg], INSN_UID (last->insn));\n-\t      if (last->need_caller_save_reg)\n+\t\t       reg_names[reg], INSN_UID (this_du->insn));\n+\t      if (this_du->need_caller_save_reg)\n \t\tfprintf (dump_file, \" crosses a call\");\n \t    }\n \n@@ -362,17 +362,27 @@ regrename_optimize (void)\n static void\n do_replace (struct du_chain *chain, int reg)\n {\n+  unsigned int base_regno = REGNO (*chain->loc);\n+\n+  gcc_assert (! DEBUG_INSN_P (chain->insn));\n+\n   while (chain)\n     {\n       unsigned int regno = ORIGINAL_REGNO (*chain->loc);\n       struct reg_attrs * attr = REG_ATTRS (*chain->loc);\n       int reg_ptr = REG_POINTER (*chain->loc);\n \n-      *chain->loc = gen_raw_REG (GET_MODE (*chain->loc), reg);\n-      if (regno >= FIRST_PSEUDO_REGISTER)\n-\tORIGINAL_REGNO (*chain->loc) = regno;\n-      REG_ATTRS (*chain->loc) = attr;\n-      REG_POINTER (*chain->loc) = reg_ptr;\n+      if (DEBUG_INSN_P (chain->insn) && REGNO (*chain->loc) != base_regno)\n+\tINSN_VAR_LOCATION_LOC (chain->insn) = gen_rtx_UNKNOWN_VAR_LOC ();\n+      else\n+\t{\n+\t  *chain->loc = gen_raw_REG (GET_MODE (*chain->loc), reg);\n+\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t    ORIGINAL_REGNO (*chain->loc) = regno;\n+\t  REG_ATTRS (*chain->loc) = attr;\n+\t  REG_POINTER (*chain->loc) = reg_ptr;\n+\t}\n+\n       df_insn_rescan (chain->insn);\n       chain = chain->next_use;\n     }\n@@ -440,7 +450,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \n \t  if (action == mark_read || action == mark_access)\n \t    {\n-\t      gcc_assert (exact_match);\n+\t      gcc_assert (exact_match || DEBUG_INSN_P (insn));\n \n \t      /* ??? Class NO_REGS can happen if the md file makes use of\n \t\t EXTRA_CONSTRAINTS to match registers.  Which is arguably\n@@ -744,7 +754,7 @@ build_def_use (basic_block bb)\n \n   for (insn = BB_HEAD (bb); ; insn = NEXT_INSN (insn))\n     {\n-      if (INSN_P (insn))\n+      if (NONDEBUG_INSN_P (insn))\n \t{\n \t  int n_ops;\n \t  rtx note;\n@@ -970,6 +980,12 @@ build_def_use (basic_block bb)\n \t      scan_rtx (insn, &XEXP (note, 0), NO_REGS, terminate_dead,\n \t\t\tOP_IN, 0);\n \t}\n+      else if (DEBUG_INSN_P (insn)\n+\t       && !VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))\n+\t{\n+\t  scan_rtx (insn, &INSN_VAR_LOCATION_LOC (insn),\n+\t\t    ALL_REGS, mark_read, OP_IN, 0);\n+\t}\n       if (insn == BB_END (bb))\n \tbreak;\n     }"}, {"sha": "70ddfa4d84f2b3025f243ec91b791030fb48e399", "filename": "gcc/regstat.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -61,11 +61,27 @@ regstat_init_n_sets_and_refs (void)\n \n   regstat_n_sets_and_refs = XNEWVEC (struct regstat_n_sets_and_refs_t, max_regno);\n \n-  for (i = 0; i < max_regno; i++)\n-    {\n-      SET_REG_N_SETS (i, DF_REG_DEF_COUNT (i));\n-      SET_REG_N_REFS (i, DF_REG_USE_COUNT (i) + REG_N_SETS (i));\n-    }\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    for (i = 0; i < max_regno; i++)\n+      {\n+\tint use_count;\n+\tdf_ref use;\n+\n+\tuse_count = DF_REG_USE_COUNT (i);\n+\tfor (use = DF_REG_USE_CHAIN (i); use; use = DF_REF_NEXT_REG (use))\n+\t  if (DF_REF_INSN_INFO (use) && DEBUG_INSN_P (DF_REF_INSN (use)))\n+\t    use_count--;\n+\n+\n+\tSET_REG_N_SETS (i, DF_REG_DEF_COUNT (i));\n+\tSET_REG_N_REFS (i, use_count + REG_N_SETS (i));\n+      }\n+  else\n+    for (i = 0; i < max_regno; i++)\n+      {\n+\tSET_REG_N_SETS (i, DF_REG_DEF_COUNT (i));\n+\tSET_REG_N_REFS (i, DF_REG_USE_COUNT (i) + REG_N_SETS (i));\n+      }\n   timevar_pop (TV_REG_STATS);\n \n }\n@@ -149,7 +165,7 @@ regstat_bb_compute_ri (unsigned int bb_index,\n       struct df_mw_hardreg **mws_rec;\n       rtx link;\n  \n-      if (!INSN_P (insn))\n+      if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n       /* Increment the live_length for all of the registers that"}, {"sha": "87bdfde32ba885f2699cda35a954bb6fa1bb4538", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -6736,6 +6736,8 @@ find_equiv_reg (rtx goal, rtx insn, enum reg_class rclass, int other,\n   while (1)\n     {\n       p = PREV_INSN (p);\n+      if (p && DEBUG_INSN_P (p))\n+\tcontinue;\n       num++;\n       if (p == 0 || LABEL_P (p)\n \t  || num > PARAM_VALUE (PARAM_MAX_RELOAD_SEARCH_INSNS))"}, {"sha": "d5cd37ce0bd09765c0f769ebd5745b5e3ad28ae9", "filename": "gcc/reload1.c", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -801,7 +801,7 @@ reload (rtx first, int global)\n \t  && GET_MODE (insn) != VOIDmode)\n \tPUT_MODE (insn, VOIDmode);\n \n-      if (INSN_P (insn))\n+      if (NONDEBUG_INSN_P (insn))\n \tscan_paradoxical_subregs (PATTERN (insn));\n \n       if (set != 0 && REG_P (SET_DEST (set)))\n@@ -1234,6 +1234,48 @@ reload (rtx first, int global)\n \t  else if (reg_equiv_mem[i])\n \t    XEXP (reg_equiv_mem[i], 0) = addr;\n \t}\n+\n+      /* We don't want complex addressing modes in debug insns\n+\t if simpler ones will do, so delegitimize equivalences\n+\t in debug insns.  */\n+      if (MAY_HAVE_DEBUG_INSNS && reg_renumber[i] < 0)\n+\t{\n+\t  rtx reg = regno_reg_rtx[i];\n+\t  rtx equiv = 0;\n+\t  df_ref use;\n+\n+\t  if (reg_equiv_constant[i])\n+\t    equiv = reg_equiv_constant[i];\n+\t  else if (reg_equiv_invariant[i])\n+\t    equiv = reg_equiv_invariant[i];\n+\t  else if (reg && MEM_P (reg))\n+\t    {\n+\t      equiv = targetm.delegitimize_address (reg);\n+\t      if (equiv == reg)\n+\t\tequiv = 0;\n+\t    }\n+\t  else if (reg && REG_P (reg) && (int)REGNO (reg) != i)\n+\t    equiv = reg;\n+\n+\t  if (equiv)\n+\t    for (use = DF_REG_USE_CHAIN (i); use;\n+\t\t use = DF_REF_NEXT_REG (use))\n+\t      if (DEBUG_INSN_P (DF_REF_INSN (use)))\n+\t\t{\n+\t\t  rtx *loc = DF_REF_LOC (use);\n+\t\t  rtx x = *loc;\n+\n+\t\t  if (x == reg)\n+\t\t    *loc = copy_rtx (equiv);\n+\t\t  else if (GET_CODE (x) == SUBREG\n+\t\t\t   && SUBREG_REG (x) == reg)\n+\t\t    *loc = simplify_gen_subreg (GET_MODE (x), equiv,\n+\t\t\t\t\t\tGET_MODE (reg),\n+\t\t\t\t\t\tSUBREG_BYTE (x));\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\t\t}\n+\t}\n     }\n \n   /* We must set reload_completed now since the cleanup_subreg_operands call\n@@ -3151,7 +3193,8 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t  || GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC\n \t\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n-\t\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n+\t\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t  || DEBUG_INSN_P (insn));\n       return 0;\n     }\n \n@@ -6941,7 +6984,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t\t\trl->when_needed, old, rl->out, j, 0))\n     {\n       rtx temp = PREV_INSN (insn);\n-      while (temp && NOTE_P (temp))\n+      while (temp && (NOTE_P (temp) || DEBUG_INSN_P (temp)))\n \ttemp = PREV_INSN (temp);\n       if (temp\n \t  && NONJUMP_INSN_P (temp)\n@@ -6984,6 +7027,13 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t  alter_reg (REGNO (old), -1, false);\n \t\t}\n \t      special = 1;\n+\n+\t      /* Adjust any debug insns between temp and insn.  */\n+\t      while ((temp = NEXT_INSN (temp)) != insn)\n+\t\tif (DEBUG_INSN_P (temp))\n+\t\t  replace_rtx (PATTERN (temp), old, reloadreg);\n+\t\telse\n+\t\t  gcc_assert (NOTE_P (temp));\n \t    }\n \t  else\n \t    {"}, {"sha": "2bb3a1ad1e811768ee8a9828fc97913caeaccd9a", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -976,6 +976,9 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t  rtx real_insn = insn;\n \t  enum rtx_code code = GET_CODE (insn);\n \n+\t  if (DEBUG_INSN_P (insn))\n+\t    continue;\n+\n \t  /* If this insn is from the target of a branch, it isn't going to\n \t     be used in the sequel.  If it is used in both cases, this\n \t     test will not be true.  */"}, {"sha": "feeb40bf61bfbf3836896c96fbbfd4f39d8022d7", "filename": "gcc/rtl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,6 +1,6 @@\n /* RTL utility routines.\n    Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -381,6 +381,7 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n+    case VALUE:\n     case SCRATCH:\n     case CONST_DOUBLE:\n     case CONST_INT:\n@@ -495,6 +496,7 @@ rtx_equal_p (const_rtx x, const_rtx y)\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n+    case VALUE:\n     case SCRATCH:\n     case CONST_DOUBLE:\n     case CONST_INT:"}, {"sha": "bcb5cbcd9b0523f70b52b5e4b84fe3883e8d5dd3", "filename": "gcc/rtl.def", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -2,7 +2,7 @@\n    Register Transfer Expressions (rtx's) that make up the\n    Register Transfer Language (rtl) used in the Back End of the GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1994, 1995, 1997, 1998, 1999, 2000, 2004,\n-   2005, 2006, 2007, 2008\n+   2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -81,6 +81,13 @@ along with GCC; see the file COPYING3.  If not see\n    value zero.  */\n DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", RTX_EXTRA)\n \n+/* Used in the cselib routines to describe a value.  Objects of this\n+   kind are only allocated in cselib.c, in an alloc pool instead of in\n+   GC memory.  The only operand of a VALUE is a cselib_val_struct.\n+   var-tracking requires this to have a distinct integral value from\n+   DECL codes in trees.  */\n+DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n+\n /* ---------------------------------------------------------------------\n    Expressions used in constructing lists.\n    --------------------------------------------------------------------- */\n@@ -111,6 +118,9 @@ DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", RTX_MATCH)\n \n    ---------------------------------------------------------------------- */\n \n+/* An annotation for variable assignment tracking.  */\n+DEF_RTL_EXPR(DEBUG_INSN, \"debug_insn\", \"iuuBieie\", RTX_INSN)\n+\n /* An instruction that cannot jump.  */\n DEF_RTL_EXPR(INSN, \"insn\", \"iuuBieie\", RTX_INSN)\n \n@@ -329,11 +339,6 @@ DEF_RTL_EXPR(CONST, \"const\", \"e\", RTX_CONST_OBJ)\n    by a SET whose first operand is (PC).  */\n DEF_RTL_EXPR(PC, \"pc\", \"\", RTX_OBJ)\n \n-/* Used in the cselib routines to describe a value.  Objects of this\n-   kind are only allocated in cselib.c, in an alloc pool instead of\n-   in GC memory.  The only operand of a VALUE is a cselib_val_struct.  */\n-DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n-\n /* A register.  The \"operand\" is the register number, accessed with\n    the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n    than a hardware register is being referred to.  The second operand"}, {"sha": "64dba7aff08ab743cb011d14b150fcba2bf2a927", "filename": "gcc/rtl.h", "status": "modified", "additions": 69, "deletions": 12, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -385,9 +385,18 @@ struct GTY(()) rtvec_def {\n /* Predicate yielding nonzero iff X is an insn that cannot jump.  */\n #define NONJUMP_INSN_P(X) (GET_CODE (X) == INSN)\n \n+/* Predicate yielding nonzero iff X is a debug note/insn.  */\n+#define DEBUG_INSN_P(X) (GET_CODE (X) == DEBUG_INSN)\n+\n+/* Predicate yielding nonzero iff X is an insn that is not a debug insn.  */\n+#define NONDEBUG_INSN_P(X) (INSN_P (X) && !DEBUG_INSN_P (X))\n+\n+/* Nonzero if DEBUG_INSN_P may possibly hold.  */\n+#define MAY_HAVE_DEBUG_INSNS MAY_HAVE_DEBUG_STMTS\n+\n /* Predicate yielding nonzero iff X is a real insn.  */\n #define INSN_P(X) \\\n-  (NONJUMP_INSN_P (X) || JUMP_P (X) || CALL_P (X))\n+  (NONJUMP_INSN_P (X) || DEBUG_INSN_P (X) || JUMP_P (X) || CALL_P (X))\n \n /* Predicate yielding nonzero iff X is a note insn.  */\n #define NOTE_P(X) (GET_CODE (X) == NOTE)\n@@ -764,12 +773,13 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #define INSN_CODE(INSN) XINT (INSN, 6)\n \n #define RTX_FRAME_RELATED_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK5(\"RTX_FRAME_RELATED_P\", (RTX), INSN, CALL_INSN,\t\\\n-\t\t   JUMP_INSN, BARRIER, SET)->frame_related)\n+  (RTL_FLAG_CHECK6(\"RTX_FRAME_RELATED_P\", (RTX), DEBUG_INSN, INSN,\t\\\n+\t\t   CALL_INSN, JUMP_INSN, BARRIER, SET)->frame_related)\n \n /* 1 if RTX is an insn that has been deleted.  */\n #define INSN_DELETED_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK6(\"INSN_DELETED_P\", (RTX), INSN, CALL_INSN, JUMP_INSN,\t\\\n+  (RTL_FLAG_CHECK7(\"INSN_DELETED_P\", (RTX), DEBUG_INSN, INSN,\t\t\\\n+\t\t   CALL_INSN, JUMP_INSN,\t\t\t\t\\\n \t\t   CODE_LABEL, BARRIER, NOTE)->volatil)\n \n /* 1 if RTX is a call to a const function.  Built from ECF_CONST and\n@@ -878,16 +888,46 @@ extern const char * const reg_note_name[];\n    && NOTE_KIND (INSN) == NOTE_INSN_BASIC_BLOCK)\n \n /* Variable declaration and the location of a variable.  */\n-#define NOTE_VAR_LOCATION_DECL(INSN)\t(XCTREE (XCEXP (INSN, 4, NOTE), \\\n-\t\t\t\t\t\t 0, VAR_LOCATION))\n-#define NOTE_VAR_LOCATION_LOC(INSN)\t(XCEXP (XCEXP (INSN, 4, NOTE),  \\\n-\t\t\t\t\t\t1, VAR_LOCATION))\n+#define PAT_VAR_LOCATION_DECL(PAT) (XCTREE ((PAT), 0, VAR_LOCATION))\n+#define PAT_VAR_LOCATION_LOC(PAT) (XCEXP ((PAT), 1, VAR_LOCATION))\n \n /* Initialization status of the variable in the location.  Status\n    can be unknown, uninitialized or initialized.  See enumeration\n    type below.  */\n-#define NOTE_VAR_LOCATION_STATUS(INSN) \\\n-  ((enum var_init_status) (XCINT (XCEXP (INSN, 4, NOTE), 2, VAR_LOCATION)))\n+#define PAT_VAR_LOCATION_STATUS(PAT) \\\n+  ((enum var_init_status) (XCINT ((PAT), 2, VAR_LOCATION)))\n+\n+/* Accessors for a NOTE_INSN_VAR_LOCATION.  */\n+#define NOTE_VAR_LOCATION_DECL(NOTE) \\\n+  PAT_VAR_LOCATION_DECL (NOTE_VAR_LOCATION (NOTE))\n+#define NOTE_VAR_LOCATION_LOC(NOTE) \\\n+  PAT_VAR_LOCATION_LOC (NOTE_VAR_LOCATION (NOTE))\n+#define NOTE_VAR_LOCATION_STATUS(NOTE) \\\n+  PAT_VAR_LOCATION_STATUS (NOTE_VAR_LOCATION (NOTE))\n+\n+/* The VAR_LOCATION rtx in a DEBUG_INSN.  */\n+#define INSN_VAR_LOCATION(INSN) PATTERN (INSN)\n+\n+/* Accessors for a tree-expanded var location debug insn.  */\n+#define INSN_VAR_LOCATION_DECL(INSN) \\\n+  PAT_VAR_LOCATION_DECL (INSN_VAR_LOCATION (INSN))\n+#define INSN_VAR_LOCATION_LOC(INSN) \\\n+  PAT_VAR_LOCATION_LOC (INSN_VAR_LOCATION (INSN))\n+#define INSN_VAR_LOCATION_STATUS(INSN) \\\n+  PAT_VAR_LOCATION_STATUS (INSN_VAR_LOCATION (INSN))\n+\n+/* Expand to the RTL that denotes an unknown variable location in a\n+   DEBUG_INSN.  */\n+#define gen_rtx_UNKNOWN_VAR_LOC() (gen_rtx_CLOBBER (VOIDmode, const0_rtx))\n+\n+/* Determine whether X is such an unknown location.  */\n+#define VAR_LOC_UNKNOWN_P(X) \\\n+  (GET_CODE (X) == CLOBBER && XEXP ((X), 0) == const0_rtx)\n+\n+/* 1 if RTX is emitted after a call, but it should take effect before\n+   the call returns.  */\n+#define NOTE_DURING_CALL_P(RTX)\t\t\t\t\\\n+  (RTL_FLAG_CHECK1(\"NOTE_VAR_LOCATION_DURING_CALL_P\", (RTX), NOTE)->call)\n \n /* Possible initialization status of a variable.   When requested\n    by the user, this information is tracked and recorded in the DWARF\n@@ -1259,8 +1299,9 @@ do {\t\t\t\t\t\t\\\n /* During sched, 1 if RTX is an insn that must be scheduled together\n    with the preceding insn.  */\n #define SCHED_GROUP_P(RTX)\t\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"SCHED_GROUP_P\", (RTX), INSN, JUMP_INSN, CALL_INSN\t\\\n-\t\t          )->in_struct)\n+  (RTL_FLAG_CHECK4(\"SCHED_GROUP_P\", (RTX), DEBUG_INSN, INSN,\t\t\\\n+\t\t   JUMP_INSN, CALL_INSN\t\t\t\t\t\\\n+\t\t   )->in_struct)\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n@@ -1593,6 +1634,9 @@ extern rtx emit_jump_insn_before_setloc (rtx, rtx, int);\n extern rtx emit_call_insn_before (rtx, rtx);\n extern rtx emit_call_insn_before_noloc (rtx, rtx);\n extern rtx emit_call_insn_before_setloc (rtx, rtx, int);\n+extern rtx emit_debug_insn_before (rtx, rtx);\n+extern rtx emit_debug_insn_before_noloc (rtx, rtx);\n+extern rtx emit_debug_insn_before_setloc (rtx, rtx, int);\n extern rtx emit_barrier_before (rtx);\n extern rtx emit_label_before (rtx, rtx);\n extern rtx emit_note_before (enum insn_note, rtx);\n@@ -1605,10 +1649,14 @@ extern rtx emit_jump_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_call_insn_after (rtx, rtx);\n extern rtx emit_call_insn_after_noloc (rtx, rtx);\n extern rtx emit_call_insn_after_setloc (rtx, rtx, int);\n+extern rtx emit_debug_insn_after (rtx, rtx);\n+extern rtx emit_debug_insn_after_noloc (rtx, rtx);\n+extern rtx emit_debug_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_barrier_after (rtx);\n extern rtx emit_label_after (rtx, rtx);\n extern rtx emit_note_after (enum insn_note, rtx);\n extern rtx emit_insn (rtx);\n+extern rtx emit_debug_insn (rtx);\n extern rtx emit_jump_insn (rtx);\n extern rtx emit_call_insn (rtx);\n extern rtx emit_label (rtx);\n@@ -1620,6 +1668,7 @@ extern rtx emit_clobber (rtx);\n extern rtx gen_use (rtx);\n extern rtx emit_use (rtx);\n extern rtx make_insn_raw (rtx);\n+extern rtx make_debug_insn_raw (rtx);\n extern rtx make_jump_insn_raw (rtx);\n extern void add_function_usage_to (rtx, rtx);\n extern rtx last_call_insn (void);\n@@ -1628,6 +1677,8 @@ extern rtx next_insn (rtx);\n extern rtx prev_nonnote_insn (rtx);\n extern rtx next_nonnote_insn (rtx);\n extern rtx next_nonnote_insn_bb (rtx);\n+extern rtx prev_nondebug_insn (rtx);\n+extern rtx next_nondebug_insn (rtx);\n extern rtx prev_real_insn (rtx);\n extern rtx next_real_insn (rtx);\n extern rtx prev_active_insn (rtx);\n@@ -1699,6 +1750,7 @@ extern rtx simplify_gen_subreg (enum machine_mode, rtx, enum machine_mode,\n extern rtx simplify_replace_rtx (rtx, const_rtx, rtx);\n extern rtx simplify_rtx (const_rtx);\n extern rtx avoid_constant_pool_reference (rtx);\n+extern rtx delegitimize_mem_from_attrs (rtx);\n extern bool mode_signbit_p (enum machine_mode, const_rtx);\n \n /* In reginfo.c  */\n@@ -2127,6 +2179,7 @@ extern void set_used_flags (rtx);\n extern void reorder_insns (rtx, rtx, rtx);\n extern void reorder_insns_nobb (rtx, rtx, rtx);\n extern int get_max_uid (void);\n+extern int get_max_insn_count (void);\n extern int in_sequence_p (void);\n extern void force_next_line_note (void);\n extern void init_emit (void);\n@@ -2327,6 +2380,8 @@ extern void invert_br_probabilities (rtx);\n extern bool expensive_function_p (int);\n /* In cfgexpand.c */\n extern void add_reg_br_prob_note (rtx last, int probability);\n+extern rtx wrap_constant (enum machine_mode, rtx);\n+extern rtx unwrap_constant (rtx);\n \n /* In var-tracking.c */\n extern unsigned int variable_tracking_main (void);\n@@ -2372,7 +2427,9 @@ extern void insn_locators_alloc (void);\n extern void insn_locators_free (void);\n extern void insn_locators_finalize (void);\n extern void set_curr_insn_source_location (location_t);\n+extern location_t get_curr_insn_source_location (void);\n extern void set_curr_insn_block (tree);\n+extern tree get_curr_insn_block (void);\n extern int curr_insn_locator (void);\n extern bool optimize_insn_for_size_p (void);\n extern bool optimize_insn_for_speed_p (void);"}, {"sha": "7a734eb66e5f1f01fce02c52af018f6995baf032", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -741,7 +741,7 @@ reg_used_between_p (const_rtx reg, const_rtx from_insn, const_rtx to_insn)\n     return 0;\n \n   for (insn = NEXT_INSN (from_insn); insn != to_insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n+    if (NONDEBUG_INSN_P (insn)\n \t&& (reg_overlap_mentioned_p (reg, PATTERN (insn))\n \t   || (CALL_P (insn) && find_reg_fusage (insn, USE, reg))))\n       return 1;\n@@ -2148,6 +2148,7 @@ side_effects_p (const_rtx x)\n     case SCRATCH:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n+    case VAR_LOCATION:\n       return 0;\n \n     case CLOBBER:\n@@ -4725,7 +4726,11 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t stop if it isn't a single set or if it has a REG_INC note because\n \t we don't want to bother dealing with it.  */\n \n-      if ((prev = prev_nonnote_insn (prev)) == 0\n+      do\n+\tprev = prev_nonnote_insn (prev);\n+      while (prev && DEBUG_INSN_P (prev));\n+\n+      if (prev == 0\n \t  || !NONJUMP_INSN_P (prev)\n \t  || FIND_REG_INC_NOTE (prev, NULL_RTX)\n \t  /* In cfglayout mode, there do not have to be labels at the"}, {"sha": "17df6a5d1cd9efd1d54a17159557ef16d1cb3025", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 95, "deletions": 8, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,7 +1,7 @@\n /* Instruction scheduling pass.  This file computes dependencies between\n    instructions.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n@@ -650,7 +650,8 @@ sd_lists_size (const_rtx insn, sd_list_types_def list_types)\n       bool resolved_p;\n \n       sd_next_list (insn, &list_types, &list, &resolved_p);\n-      size += DEPS_LIST_N_LINKS (list);\n+      if (list)\n+\tsize += DEPS_LIST_N_LINKS (list);\n     }\n \n   return size;\n@@ -673,6 +674,9 @@ sd_init_insn (rtx insn)\n   INSN_FORW_DEPS (insn) = create_deps_list ();\n   INSN_RESOLVED_FORW_DEPS (insn) = create_deps_list ();\n \n+  if (DEBUG_INSN_P (insn))\n+    DEBUG_INSN_SCHED_P (insn) = TRUE;\n+\n   /* ??? It would be nice to allocate dependency caches here.  */\n }\n \n@@ -682,6 +686,12 @@ sd_finish_insn (rtx insn)\n {\n   /* ??? It would be nice to deallocate dependency caches here.  */\n \n+  if (DEBUG_INSN_P (insn))\n+    {\n+      gcc_assert (DEBUG_INSN_SCHED_P (insn));\n+      DEBUG_INSN_SCHED_P (insn) = FALSE;\n+    }\n+\n   free_deps_list (INSN_HARD_BACK_DEPS (insn));\n   INSN_HARD_BACK_DEPS (insn) = NULL;\n \n@@ -1181,6 +1191,7 @@ sd_add_dep (dep_t dep, bool resolved_p)\n   rtx insn = DEP_CON (dep);\n \n   gcc_assert (INSN_P (insn) && INSN_P (elem) && insn != elem);\n+  gcc_assert (!DEBUG_INSN_P (elem) || DEBUG_INSN_P (insn));\n \n   if ((current_sched_info->flags & DO_SPECULATION)\n       && !sched_insn_is_legitimate_for_speculation_p (insn, DEP_STATUS (dep)))\n@@ -1462,7 +1473,7 @@ fixup_sched_groups (rtx insn)\n \n \t  if (pro == i)\n \t    goto next_link;\n-\t} while (SCHED_GROUP_P (i));\n+\t} while (SCHED_GROUP_P (i) || DEBUG_INSN_P (i));\n \n       if (! sched_insns_conditions_mutex_p (i, pro))\n \tadd_dependence (i, pro, DEP_TYPE (dep));\n@@ -1472,6 +1483,8 @@ fixup_sched_groups (rtx insn)\n   delete_all_dependences (insn);\n \n   prev_nonnote = prev_nonnote_insn (insn);\n+  while (DEBUG_INSN_P (prev_nonnote))\n+    prev_nonnote = prev_nonnote_insn (prev_nonnote);\n   if (BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (prev_nonnote)\n       && ! sched_insns_conditions_mutex_p (insn, prev_nonnote))\n     add_dependence (insn, prev_nonnote, REG_DEP_ANTI);\n@@ -1801,8 +1814,7 @@ sched_analyze_reg (struct deps *deps, int regno, enum machine_mode mode,\n \t already cross one.  */\n       if (REG_N_CALLS_CROSSED (regno) == 0)\n \t{\n-\t  if (!deps->readonly \n-              && ref == USE)\n+\t  if (!deps->readonly && ref == USE && !DEBUG_INSN_P (insn))\n \t    deps->sched_before_next_call\n \t      = alloc_INSN_LIST (insn, deps->sched_before_next_call);\n \t  else\n@@ -2059,6 +2071,12 @@ sched_analyze_2 (struct deps *deps, rtx x, rtx insn)\n \trtx pending, pending_mem;\n \trtx t = x;\n \n+\tif (DEBUG_INSN_P (insn))\n+\t  {\n+\t    sched_analyze_2 (deps, XEXP (x, 0), insn);\n+\t    return;\n+\t  }\n+\n \tif (sched_deps_info->use_cselib)\n \t  {\n \t    t = shallow_copy_rtx (t);\n@@ -2287,6 +2305,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n     {\n       rtx next;\n       next = next_nonnote_insn (insn);\n+      while (next && DEBUG_INSN_P (next))\n+\tnext = next_nonnote_insn (next);\n       if (next && BARRIER_P (next))\n \treg_pending_barrier = MOVE_BARRIER;\n       else\n@@ -2361,9 +2381,49 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n       || (NONJUMP_INSN_P (insn) && control_flow_insn_p (insn)))\n     reg_pending_barrier = MOVE_BARRIER;\n \n+  /* Add register dependencies for insn.  */\n+  if (DEBUG_INSN_P (insn))\n+    {\n+      rtx prev = deps->last_debug_insn;\n+      rtx u;\n+\n+      if (!deps->readonly)\n+\tdeps->last_debug_insn = insn;\n+\n+      if (prev)\n+\tadd_dependence (insn, prev, REG_DEP_ANTI);\n+\n+      add_dependence_list (insn, deps->last_function_call, 1,\n+\t\t\t   REG_DEP_ANTI);\n+\n+      for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n+\tif (! JUMP_P (XEXP (u, 0))\n+\t    || !sel_sched_p ())\n+\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\n+      EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n+\t{\n+\t  struct deps_reg *reg_last = &deps->reg_last[i];\n+\t  add_dependence_list (insn, reg_last->sets, 1, REG_DEP_ANTI);\n+\t  add_dependence_list (insn, reg_last->clobbers, 1, REG_DEP_ANTI);\n+\t}\n+      CLEAR_REG_SET (reg_pending_uses);\n+\n+      /* Quite often, a debug insn will refer to stuff in the\n+\t previous instruction, but the reason we want this\n+\t dependency here is to make sure the scheduler doesn't\n+\t gratuitously move a debug insn ahead.  This could dirty\n+\t DF flags and cause additional analysis that wouldn't have\n+\t occurred in compilation without debug insns, and such\n+\t additional analysis can modify the generated code.  */\n+      prev = PREV_INSN (insn);\n+\n+      if (prev && NONDEBUG_INSN_P (prev))\n+\tadd_dependence (insn, prev, REG_DEP_ANTI);\n+    }\n   /* If the current insn is conditional, we can't free any\n      of the lists.  */\n-  if (sched_has_condition_p (insn))\n+  else if (sched_has_condition_p (insn))\n     {\n       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n         {\n@@ -2557,7 +2617,30 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n       int src_regno, dest_regno;\n \n       if (set == NULL)\n-\tgoto end_call_group;\n+\t{\n+\t  if (DEBUG_INSN_P (insn))\n+\t    /* We don't want to mark debug insns as part of the same\n+\t       sched group.  We know they really aren't, but if we use\n+\t       debug insns to tell that a call group is over, we'll\n+\t       get different code if debug insns are not there and\n+\t       instructions that follow seem like they should be part\n+\t       of the call group.\n+\n+\t       Also, if we did, fixup_sched_groups() would move the\n+\t       deps of the debug insn to the call insn, modifying\n+\t       non-debug post-dependency counts of the debug insn\n+\t       dependencies and otherwise messing with the scheduling\n+\t       order.\n+\n+\t       Instead, let such debug insns be scheduled freely, but\n+\t       keep the call group open in case there are insns that\n+\t       should be part of it afterwards.  Since we grant debug\n+\t       insns higher priority than even sched group insns, it\n+\t       will all turn out all right.  */\n+\t    goto debug_dont_end_call_group;\n+\t  else\n+\t    goto end_call_group;\n+\t}\n \n       tmp = SET_DEST (set);\n       if (GET_CODE (tmp) == SUBREG)\n@@ -2602,6 +2685,7 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n \t}\n     }\n \n+ debug_dont_end_call_group:\n   if ((current_sched_info->flags & DO_SPECULATION)\n       && !sched_insn_is_legitimate_for_speculation_p (insn, 0))\n     /* INSN has an internal dependency (e.g. r14 = [r14]) and thus cannot\n@@ -2628,7 +2712,7 @@ deps_analyze_insn (struct deps *deps, rtx insn)\n   if (sched_deps_info->start_insn)\n     sched_deps_info->start_insn (insn);\n \n-  if (NONJUMP_INSN_P (insn) || JUMP_P (insn))\n+  if (NONJUMP_INSN_P (insn) || DEBUG_INSN_P (insn) || JUMP_P (insn))\n     {\n       /* Make each JUMP_INSN (but not a speculative check) \n          a scheduling barrier for memory references.  */\n@@ -2758,6 +2842,8 @@ deps_start_bb (struct deps *deps, rtx head)\n     {\n       rtx insn = prev_nonnote_insn (head);\n \n+      while (insn && DEBUG_INSN_P (insn))\n+\tinsn = prev_nonnote_insn (insn);\n       if (insn && CALL_P (insn))\n \tdeps->in_post_call_group_p = post_call_initial;\n     }\n@@ -2873,6 +2959,7 @@ init_deps (struct deps *deps)\n   deps->last_function_call = 0;\n   deps->sched_before_next_call = 0;\n   deps->in_post_call_group_p = not_post_call;\n+  deps->last_debug_insn = 0;\n   deps->last_reg_pending_barrier = NOT_A_BARRIER;\n   deps->readonly = 0;\n }"}, {"sha": "c6dc55330d9e5b1342f7bb75979ee4ed8e8d7e3f", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -607,9 +607,9 @@ schedule_ebbs (void)\n \t a note or two.  */\n       while (head != tail)\n \t{\n-\t  if (NOTE_P (head))\n+\t  if (NOTE_P (head) || BOUNDARY_DEBUG_INSN_P (head))\n \t    head = NEXT_INSN (head);\n-\t  else if (NOTE_P (tail))\n+\t  else if (NOTE_P (tail) || BOUNDARY_DEBUG_INSN_P (tail))\n \t    tail = PREV_INSN (tail);\n \t  else if (LABEL_P (head))\n \t    head = NEXT_INSN (head);"}, {"sha": "518fcb53e28bb1ce0c16105c5dc5fbc18bdbba6c", "filename": "gcc/sched-int.h", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -181,13 +181,15 @@ extern bool sel_insn_is_speculation_check (rtx);\n    FIRST is the index of the element with the highest priority; i.e. the\n    last one in the ready list, since elements are ordered by ascending\n    priority.\n-   N_READY determines how many insns are on the ready list.  */\n+   N_READY determines how many insns are on the ready list.\n+   N_DEBUG determines how many debug insns are on the ready list.  */\n struct ready_list\n {\n   rtx *vec;\n   int veclen;\n   int first;\n   int n_ready;\n+  int n_debug;\n };\n \n extern char *ready_try;\n@@ -509,6 +511,9 @@ struct deps\n      the call.  */\n   enum post_call_group in_post_call_group_p;\n \n+  /* The last debug insn we've seen.  */\n+  rtx last_debug_insn;\n+\n   /* The maximum register number for the following arrays.  Before reload\n      this is max_reg_num; after reload it is FIRST_PSEUDO_REGISTER.  */\n   int max_reg;\n@@ -800,6 +805,23 @@ extern VEC(haifa_deps_insn_data_def, heap) *h_d_i_d;\n #define IS_SPECULATION_BRANCHY_CHECK_P(INSN) \\\n   (RECOVERY_BLOCK (INSN) != NULL && RECOVERY_BLOCK (INSN) != EXIT_BLOCK_PTR)\n \n+/* The unchanging bit tracks whether a debug insn is to be handled\n+   like an insn (i.e., schedule it) or like a note (e.g., it is next\n+   to a basic block boundary.  */\n+#define DEBUG_INSN_SCHED_P(insn) \\\n+  (RTL_FLAG_CHECK1(\"DEBUG_INSN_SCHED_P\", (insn), DEBUG_INSN)->unchanging)\n+\n+/* True if INSN is a debug insn that is next to a basic block\n+   boundary, i.e., it is to be handled by the scheduler like a\n+   note.  */\n+#define BOUNDARY_DEBUG_INSN_P(insn) \\\n+  (DEBUG_INSN_P (insn) && !DEBUG_INSN_SCHED_P (insn))\n+/* True if INSN is a debug insn that is not next to a basic block\n+   boundary, i.e., it is to be handled by the scheduler like an\n+   insn.  */\n+#define SCHEDULE_DEBUG_INSN_P(insn) \\\n+  (DEBUG_INSN_P (insn) && DEBUG_INSN_SCHED_P (insn))\n+\n /* Dep status (aka ds_t) of the link encapsulates information, that is needed\n    for speculative scheduling.  Namely, it is 4 integers in the range\n    [0, MAX_DEP_WEAK] and 3 bits.\n@@ -1342,7 +1364,8 @@ sd_iterator_cond (sd_iterator_def *it_ptr, dep_t *dep_ptr)\n \n \t  it_ptr->linkp = &DEPS_LIST_FIRST (list);\n \n-\t  return sd_iterator_cond (it_ptr, dep_ptr);\n+\t  if (list)\n+\t    return sd_iterator_cond (it_ptr, dep_ptr);\n \t}\n \n       *dep_ptr = NULL;"}, {"sha": "91ac01050ffb7c6c252644b2adb8446dd2963a0b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -530,7 +530,20 @@ find_single_block_region (bool ebbs_p)\n static int\n rgn_estimate_number_of_insns (basic_block bb)\n {\n-  return INSN_LUID (BB_END (bb)) - INSN_LUID (BB_HEAD (bb));\n+  int count;\n+\n+  count = INSN_LUID (BB_END (bb)) - INSN_LUID (BB_HEAD (bb));\n+\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      rtx insn;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\tif (DEBUG_INSN_P (insn))\n+\t  count--;\n+    }\n+\n+  return count;\n }\n \n /* Update number of blocks and the estimate for number of insns\n@@ -2129,7 +2142,7 @@ init_ready_list (void)\n \tsrc_head = head;\n \n \tfor (insn = src_head; insn != src_next_tail; insn = NEXT_INSN (insn))\n-\t  if (INSN_P (insn))\n+\t  if (INSN_P (insn) && !BOUNDARY_DEBUG_INSN_P (insn))\n \t    try_ready (insn);\n       }\n }\n@@ -2438,6 +2451,9 @@ add_branch_dependences (rtx head, rtx tail)\n      are not moved before reload because we can wind up with register\n      allocation failures.  */\n \n+  while (tail != head && DEBUG_INSN_P (tail))\n+    tail = PREV_INSN (tail);\n+\n   insn = tail;\n   last = 0;\n   while (CALL_P (insn)\n@@ -2472,7 +2488,9 @@ add_branch_dependences (rtx head, rtx tail)\n       if (insn == head)\n \tbreak;\n \n-      insn = PREV_INSN (insn);\n+      do\n+\tinsn = PREV_INSN (insn);\n+      while (insn != head && DEBUG_INSN_P (insn));\n     }\n \n   /* Make sure these insns are scheduled last in their block.  */\n@@ -2482,7 +2500,8 @@ add_branch_dependences (rtx head, rtx tail)\n       {\n \tinsn = prev_nonnote_insn (insn);\n \n-\tif (TEST_BIT (insn_referenced, INSN_LUID (insn)))\n+\tif (TEST_BIT (insn_referenced, INSN_LUID (insn))\n+\t    || DEBUG_INSN_P (insn))\n \t  continue;\n \n \tif (! sched_insns_conditions_mutex_p (last, insn))\n@@ -2719,6 +2738,9 @@ free_block_dependencies (int bb)\n \n   get_ebb_head_tail (EBB_FIRST_BB (bb), EBB_LAST_BB (bb), &head, &tail);\n \n+  if (no_real_insns_p (head, tail))\n+    return;\n+\n   sched_free_deps (head, tail, true);\n }\n \n@@ -2876,6 +2898,9 @@ compute_priorities (void)\n       gcc_assert (EBB_FIRST_BB (bb) == EBB_LAST_BB (bb));\n       get_ebb_head_tail (EBB_FIRST_BB (bb), EBB_LAST_BB (bb), &head, &tail);\n \n+      if (no_real_insns_p (head, tail))\n+\tcontinue;\n+\n       rgn_n_insns += set_priorities (head, tail);\n     }\n   current_sched_info->sched_max_insns_priority++;"}, {"sha": "89230efa34c71ffdcdcee1cc7d7f6af6f30e310c", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -556,6 +556,10 @@ print_pattern (char *buf, const_rtx x, int verbose)\n       print_value (t1, XEXP (x, 0), verbose);\n       sprintf (buf, \"use %s\", t1);\n       break;\n+    case VAR_LOCATION:\n+      print_value (t1, PAT_VAR_LOCATION_LOC (x), verbose);\n+      sprintf (buf, \"loc %s\", t1);\n+      break;\n     case COND_EXEC:\n       if (GET_CODE (COND_EXEC_TEST (x)) == NE\n \t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n@@ -658,6 +662,34 @@ print_insn (char *buf, const_rtx x, int verbose)\n #endif\n \tsprintf (buf, \" %4d %s\", INSN_UID (x), t);\n       break;\n+\n+    case DEBUG_INSN:\n+      {\n+\tconst char *name = \"?\";\n+\n+\tif (DECL_P (INSN_VAR_LOCATION_DECL (insn)))\n+\t  {\n+\t    tree id = DECL_NAME (INSN_VAR_LOCATION_DECL (insn));\n+\t    if (id)\n+\t      name = IDENTIFIER_POINTER (id);\n+\t    else\n+\t      {\n+\t\tchar idbuf[32];\n+\t\tsprintf (idbuf, \"D.%i\",\n+\t\t\t DECL_UID (INSN_VAR_LOCATION_DECL (insn)));\n+\t\tname = idbuf;\n+\t      }\n+\t  }\n+\tif (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (insn)))\n+\t  sprintf (buf, \" %4d: debug %s optimized away\", INSN_UID (insn), name);\n+\telse\n+\t  {\n+\t    print_pattern (t, INSN_VAR_LOCATION_LOC (insn), verbose);\n+\t    sprintf (buf, \" %4d: debug %s => %s\", INSN_UID (insn), name, t);\n+\t  }\n+      }\n+      break;\n+\n     case JUMP_INSN:\n       print_pattern (t, PATTERN (x), verbose);\n #ifdef INSN_SCHEDULING"}, {"sha": "9a61ed84dca6e8f642573793f7a08669c43f10a0", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -157,6 +157,7 @@ static void sel_remove_loop_preheader (void);\n static bool insn_is_the_only_one_in_bb_p (insn_t);\n static void create_initial_data_sets (basic_block);\n \n+static void free_av_set (basic_block);\n static void invalidate_av_set (basic_block);\n static void extend_insn_data (void);\n static void sel_init_new_insn (insn_t, int);\n@@ -1044,10 +1045,10 @@ get_nop_from_pool (insn_t insn)\n \n /* Remove NOP from the instruction stream and return it to the pool.  */\n void\n-return_nop_to_pool (insn_t nop)\n+return_nop_to_pool (insn_t nop, bool full_tidying)\n {\n   gcc_assert (INSN_IN_STREAM_P (nop));\n-  sel_remove_insn (nop, false, true);\n+  sel_remove_insn (nop, false, full_tidying);\n \n   if (nop_pool.n == nop_pool.s)\n     nop_pool.v = XRESIZEVEC (rtx, nop_pool.v, \n@@ -2362,6 +2363,8 @@ setup_id_for_insn (idata_t id, insn_t insn, bool force_unique_p)\n     type = SET;\n   else if (type == JUMP_INSN && simplejump_p (insn))\n     type = PC;\n+  else if (type == DEBUG_INSN)\n+    type = !force_unique_p ? USE : INSN;\n   \n   IDATA_TYPE (id) = type;\n   IDATA_REG_SETS (id) = get_clear_regset_from_pool ();\n@@ -3487,7 +3490,7 @@ maybe_tidy_empty_bb (basic_block bb)\n \n   /* Keep empty bb only if this block immediately precedes EXIT and\n      has incoming non-fallthrough edge.  Otherwise remove it.  */\n-  if (!sel_bb_empty_p (bb) \n+  if (!sel_bb_empty_p (bb)\n       || (single_succ_p (bb) \n           && single_succ (bb) == EXIT_BLOCK_PTR\n           && (!single_pred_p (bb) \n@@ -3559,6 +3562,7 @@ bool\n tidy_control_flow (basic_block xbb, bool full_tidying)\n {\n   bool changed = true;\n+  insn_t first, last;\n   \n   /* First check whether XBB is empty.  */\n   changed = maybe_tidy_empty_bb (xbb);\n@@ -3575,16 +3579,30 @@ tidy_control_flow (basic_block xbb, bool full_tidying)\n       tidy_fallthru_edge (EDGE_SUCC (xbb, 0));\n     }\n \n+  first = sel_bb_head (xbb);\n+  last = sel_bb_end (xbb);\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      if (first != last && DEBUG_INSN_P (first))\n+\tdo\n+\t  first = NEXT_INSN (first);\n+\twhile (first != last && (DEBUG_INSN_P (first) || NOTE_P (first)));\n+\n+      if (first != last && DEBUG_INSN_P (last))\n+\tdo\n+\t  last = PREV_INSN (last);\n+\twhile (first != last && (DEBUG_INSN_P (last) || NOTE_P (last)));\n+    }\n   /* Check if there is an unnecessary jump in previous basic block leading\n      to next basic block left after removing INSN from stream.  \n      If it is so, remove that jump and redirect edge to current \n      basic block (where there was INSN before deletion).  This way \n      when NOP will be deleted several instructions later with its \n      basic block we will not get a jump to next instruction, which \n      can be harmful.  */\n-  if (sel_bb_head (xbb) == sel_bb_end (xbb) \n+  if (first == last\n       && !sel_bb_empty_p (xbb)\n-      && INSN_NOP_P (sel_bb_end (xbb))\n+      && INSN_NOP_P (last)\n       /* Flow goes fallthru from current block to the next.  */\n       && EDGE_COUNT (xbb->succs) == 1\n       && (EDGE_SUCC (xbb, 0)->flags & EDGE_FALLTHRU)\n@@ -3624,6 +3642,21 @@ sel_remove_insn (insn_t insn, bool only_disconnect, bool full_tidying)\n \n   gcc_assert (INSN_IN_STREAM_P (insn));\n \n+  if (DEBUG_INSN_P (insn) && BB_AV_SET_VALID_P (bb))\n+    {\n+      expr_t expr;\n+      av_set_iterator i;\n+\n+      /* When we remove a debug insn that is head of a BB, it remains\n+\t in the AV_SET of the block, but it shouldn't.  */\n+      FOR_EACH_EXPR_1 (expr, i, &BB_AV_SET (bb))\n+\tif (EXPR_INSN_RTX (expr) == insn)\n+\t  {\n+\t    av_set_iter_remove (&i);\n+\t    break;\n+\t  }\n+    }\n+\n   if (only_disconnect)\n     {\n       insn_t prev = PREV_INSN (insn);\n@@ -3662,7 +3695,7 @@ sel_estimate_number_of_insns (basic_block bb)\n   insn_t insn = NEXT_INSN (BB_HEAD (bb)), next_tail = NEXT_INSN (BB_END (bb));\n \n   for (; insn != next_tail; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n+    if (NONDEBUG_INSN_P (insn))\n       res++;\n \n   return res;\n@@ -5363,6 +5396,8 @@ create_insn_rtx_from_pattern (rtx pattern, rtx label)\n \n   if (label == NULL_RTX)\n     insn_rtx = emit_insn (pattern);\n+  else if (DEBUG_INSN_P (label))\n+    insn_rtx = emit_debug_insn (pattern);\n   else\n     {\n       insn_rtx = emit_jump_insn (pattern);\n@@ -5398,6 +5433,10 @@ create_copy_of_insn_rtx (rtx insn_rtx)\n {\n   rtx res;\n \n+  if (DEBUG_INSN_P (insn_rtx))\n+    return create_insn_rtx_from_pattern (copy_rtx (PATTERN (insn_rtx)),\n+\t\t\t\t\t insn_rtx);\n+\n   gcc_assert (NONJUMP_INSN_P (insn_rtx));\n \n   res = create_insn_rtx_from_pattern (copy_rtx (PATTERN (insn_rtx)),"}, {"sha": "9bc90bda5598a1daa45a57b7d3caefc70d7e870d", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.  This file contains definitions used\n    internally in the scheduler.\n-   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1019,6 +1019,7 @@ struct succs_info\n extern basic_block after_recovery;\n \n extern insn_t sel_bb_head (basic_block);\n+extern insn_t sel_bb_end (basic_block);\n extern bool sel_bb_empty_p (basic_block);\n extern bool in_current_region_p (basic_block);\n \n@@ -1079,6 +1080,27 @@ get_loop_exit_edges_unique_dests (const struct loop *loop)\n   return edges;\n }\n \n+static bool\n+sel_bb_empty_or_nop_p (basic_block bb)\n+{\n+  insn_t first = sel_bb_head (bb), last;\n+\n+  if (first == NULL_RTX)\n+    return true;\n+\n+  if (!INSN_NOP_P (first))\n+    return false;\n+\n+  if (bb == EXIT_BLOCK_PTR)\n+    return false;\n+\n+  last = sel_bb_end (bb);\n+  if (first != last)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Collect all loop exits recursively, skipping empty BBs between them.  \n    E.g. if BB is a loop header which has several loop exits,\n    traverse all of them and if any of them turns out to be another loop header\n@@ -1091,7 +1113,7 @@ get_all_loop_exits (basic_block bb)\n \n   /* If bb is empty, and we're skipping to loop exits, then\n      consider bb as a possible gate to the inner loop now.  */\n-  while (sel_bb_empty_p (bb) \n+  while (sel_bb_empty_or_nop_p (bb)\n \t && in_current_region_p (bb))\n     {\n       bb = single_succ (bb);\n@@ -1350,7 +1372,24 @@ _eligible_successor_edge_p (edge e1, succ_iterator *ip)\n   while (1)\n     {\n       if (!sel_bb_empty_p (bb))\n-        break;\n+\t{\n+\t  edge ne;\n+\t  basic_block nbb;\n+\n+\t  if (!sel_bb_empty_or_nop_p (bb))\n+\t    break;\n+\n+\t  ne = EDGE_SUCC (bb, 0);\n+\t  nbb = ne->dest;\n+\n+\t  if (!in_current_region_p (nbb)\n+\t      && !(flags & SUCCS_OUT))\n+\t    break;\n+\n+\t  e2 = ne;\n+\t  bb = nbb;\n+\t  continue;\n+\t}\n         \n       if (!in_current_region_p (bb) \n           && !(flags & SUCCS_OUT))\n@@ -1470,7 +1509,7 @@ extern void return_regset_to_pool (regset);\n extern void free_regset_pool (void);\n \n extern insn_t get_nop_from_pool (insn_t);\n-extern void return_nop_to_pool (insn_t);\n+extern void return_nop_to_pool (insn_t, bool);\n extern void free_nop_pool (void);\n \n /* Vinsns functions.  */"}, {"sha": "102dc19187f2bbed05aeb80a6dbdf73a00126293", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 314, "deletions": 41, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -557,6 +557,7 @@ static int stat_substitutions_total;\n static bool rtx_ok_for_substitution_p (rtx, rtx);\n static int sel_rank_for_schedule (const void *, const void *);\n static av_set_t find_sequential_best_exprs (bnd_t, expr_t, bool);\n+static basic_block find_block_for_bookkeeping (edge e1, edge e2, bool lax);\n \n static rtx get_dest_from_orig_ops (av_set_t);\n static basic_block generate_bookkeeping_insn (expr_t, edge, edge);\n@@ -2059,6 +2060,56 @@ moveup_expr_inside_insn_group (expr_t expr, insn_t through_insn)\n /* True when a conflict on a target register was found during moveup_expr.  */\n static bool was_target_conflict = false;\n \n+/* Return true when moving a debug INSN across THROUGH_INSN will\n+   create a bookkeeping block.  We don't want to create such blocks,\n+   for they would cause codegen differences between compilations with\n+   and without debug info.  */\n+\n+static bool\n+moving_insn_creates_bookkeeping_block_p (insn_t insn,\n+\t\t\t\t\t insn_t through_insn)\n+{\n+  basic_block bbi, bbt;\n+  edge e1, e2;\n+  edge_iterator ei1, ei2;\n+\n+  if (!bookkeeping_can_be_created_if_moved_through_p (through_insn))\n+    {\n+      if (sched_verbose >= 9)\n+\tsel_print (\"no bookkeeping required: \");\n+      return FALSE;\n+    }\n+\n+  bbi = BLOCK_FOR_INSN (insn);\n+\n+  if (EDGE_COUNT (bbi->preds) == 1)\n+    {\n+      if (sched_verbose >= 9)\n+\tsel_print (\"only one pred edge: \");\n+      return TRUE;\n+    }\n+\n+  bbt = BLOCK_FOR_INSN (through_insn);\n+\n+  FOR_EACH_EDGE (e1, ei1, bbt->succs)\n+    {\n+      FOR_EACH_EDGE (e2, ei2, bbi->preds)\n+\t{\n+\t  if (find_block_for_bookkeeping (e1, e2, TRUE))\n+\t    {\n+\t      if (sched_verbose >= 9)\n+\t\tsel_print (\"found existing block: \");\n+\t      return FALSE;\n+\t    }\n+\t}\n+    }\n+\n+  if (sched_verbose >= 9)\n+    sel_print (\"would create bookkeeping block: \");\n+\n+  return TRUE;\n+}\n+\n /* Modifies EXPR so it can be moved through the THROUGH_INSN,\n    performing necessary transformations.  Record the type of transformation \n    made in PTRANS_TYPE, when it is not NULL.  When INSIDE_INSN_GROUP, \n@@ -2110,7 +2161,8 @@ moveup_expr (expr_t expr, insn_t through_insn, bool inside_insn_group,\n           /* And it should be mutually exclusive with through_insn, or \n              be an unconditional jump.  */\n           if (! any_uncondjump_p (insn)\n-              && ! sched_insns_conditions_mutex_p (insn, through_insn))\n+              && ! sched_insns_conditions_mutex_p (insn, through_insn)\n+\t      && ! DEBUG_INSN_P (through_insn))\n             return MOVEUP_EXPR_NULL;\n         }\n \n@@ -2131,6 +2183,12 @@ moveup_expr (expr_t expr, insn_t through_insn, bool inside_insn_group,\n   else\n     gcc_assert (!control_flow_insn_p (insn));\n \n+  /* Don't move debug insns if this would require bookkeeping.  */\n+  if (DEBUG_INSN_P (insn)\n+      && BLOCK_FOR_INSN (through_insn) != BLOCK_FOR_INSN (insn)\n+      && moving_insn_creates_bookkeeping_block_p (insn, through_insn))\n+    return MOVEUP_EXPR_NULL;\n+\n   /* Deal with data dependencies.  */\n   was_target_conflict = false;\n   full_ds = has_dependence_p (expr, through_insn, &has_dep_p);\n@@ -2440,7 +2498,12 @@ moveup_expr_cached (expr_t expr, insn_t insn, bool inside_insn_group)\n       sel_print (\" through %d: \", INSN_UID (insn));\n     }\n \n-  if (try_bitmap_cache (expr, insn, inside_insn_group, &res))\n+  if (DEBUG_INSN_P (EXPR_INSN_RTX (expr))\n+      && (sel_bb_head (BLOCK_FOR_INSN (EXPR_INSN_RTX (expr)))\n+\t  == EXPR_INSN_RTX (expr)))\n+    /* Don't use cached information for debug insns that are heads of\n+       basic blocks.  */;\n+  else if (try_bitmap_cache (expr, insn, inside_insn_group, &res))\n     /* When inside insn group, we do not want remove stores conflicting\n        with previosly issued loads.  */\n     got_answer = ! inside_insn_group || res != MOVEUP_EXPR_NULL;\n@@ -2852,6 +2915,9 @@ compute_av_set_inside_bb (insn_t first_insn, ilist_t p, int ws,\n \t  break;\t  \n \t}\n \n+      if (DEBUG_INSN_P (last_insn))\n+\tcontinue;\n+\n       if (end_ws > max_ws)\n \t{\n \t  /* We can reach max lookahead size at bb_header, so clean av_set \n@@ -3261,6 +3327,12 @@ sel_rank_for_schedule (const void *x, const void *y)\n   tmp_insn = EXPR_INSN_RTX (tmp);\n   tmp2_insn = EXPR_INSN_RTX (tmp2);\n   \n+  /* Schedule debug insns as early as possible.  */\n+  if (DEBUG_INSN_P (tmp_insn) && !DEBUG_INSN_P (tmp2_insn))\n+    return -1;\n+  else if (DEBUG_INSN_P (tmp2_insn))\n+    return 1;\n+\n   /* Prefer SCHED_GROUP_P insns to any others.  */\n   if (SCHED_GROUP_P (tmp_insn) != SCHED_GROUP_P (tmp2_insn))\n     {\n@@ -3332,9 +3404,6 @@ sel_rank_for_schedule (const void *x, const void *y)\n \treturn dw;\n     }\n \n-  tmp_insn = EXPR_INSN_RTX (tmp);\n-  tmp2_insn = EXPR_INSN_RTX (tmp2);\n-\n   /* Prefer an old insn to a bookkeeping insn.  */\n   if (INSN_UID (tmp_insn) < first_emitted_uid \n       && INSN_UID (tmp2_insn) >= first_emitted_uid)\n@@ -4412,15 +4481,16 @@ block_valid_for_bookkeeping_p (basic_block bb)\n /* Attempt to find a block that can hold bookkeeping code for path(s) incoming\n    into E2->dest, except from E1->src (there may be a sequence of empty basic\n    blocks between E1->src and E2->dest).  Return found block, or NULL if new\n-   one must be created.  */\n+   one must be created.  If LAX holds, don't assume there is a simple path\n+   from E1->src to E2->dest.  */\n static basic_block\n-find_block_for_bookkeeping (edge e1, edge e2)\n+find_block_for_bookkeeping (edge e1, edge e2, bool lax)\n {\n   basic_block candidate_block = NULL;\n   edge e;\n \n   /* Loop over edges from E1 to E2, inclusive.  */\n-  for (e = e1; ; e = EDGE_SUCC (e->dest, 0))\n+  for (e = e1; !lax || e->dest != EXIT_BLOCK_PTR; e = EDGE_SUCC (e->dest, 0))\n     {\n       if (EDGE_COUNT (e->dest->preds) == 2)\n \t{\n@@ -4438,10 +4508,18 @@ find_block_for_bookkeeping (edge e1, edge e2)\n \treturn NULL;\n \n       if (e == e2)\n-\treturn (block_valid_for_bookkeeping_p (candidate_block)\n+\treturn ((!lax || candidate_block)\n+\t\t&& block_valid_for_bookkeeping_p (candidate_block)\n \t\t? candidate_block\n \t\t: NULL);\n+\n+      if (lax && EDGE_COUNT (e->dest->succs) != 1)\n+\treturn NULL;\n     }\n+\n+  if (lax)\n+    return NULL;\n+\n   gcc_unreachable ();\n }\n \n@@ -4485,6 +4563,101 @@ create_block_for_bookkeeping (edge e1, edge e2)\n   gcc_assert (e1->dest == new_bb);\n   gcc_assert (sel_bb_empty_p (bb));\n \n+  /* To keep basic block numbers in sync between debug and non-debug\n+     compilations, we have to rotate blocks here.  Consider that we\n+     started from (a,b)->d, (c,d)->e, and d contained only debug\n+     insns.  It would have been removed before if the debug insns\n+     weren't there, so we'd have split e rather than d.  So what we do\n+     now is to swap the block numbers of new_bb and\n+     single_succ(new_bb) == e, so that the insns that were in e before\n+     get the new block number.  */\n+\n+  if (MAY_HAVE_DEBUG_INSNS)\n+    {\n+      basic_block succ;\n+      insn_t insn = sel_bb_head (new_bb);\n+      insn_t last;\n+\n+      if (DEBUG_INSN_P (insn)\n+\t  && single_succ_p (new_bb)\n+\t  && (succ = single_succ (new_bb))\n+\t  && succ != EXIT_BLOCK_PTR\n+\t  && DEBUG_INSN_P ((last = sel_bb_end (new_bb))))\n+\t{\n+\t  while (insn != last && (DEBUG_INSN_P (insn) || NOTE_P (insn)))\n+\t    insn = NEXT_INSN (insn);\n+\n+\t  if (insn == last)\n+\t    {\n+\t      sel_global_bb_info_def gbi;\n+\t      sel_region_bb_info_def rbi;\n+\t      int i;\n+\n+\t      if (sched_verbose >= 2)\n+\t\tsel_print (\"Swapping block ids %i and %i\\n\",\n+\t\t\t   new_bb->index, succ->index);\n+\n+\t      i = new_bb->index;\n+\t      new_bb->index = succ->index;\n+\t      succ->index = i;\n+\n+\t      SET_BASIC_BLOCK (new_bb->index, new_bb);\n+\t      SET_BASIC_BLOCK (succ->index, succ);\n+\n+\t      memcpy (&gbi, SEL_GLOBAL_BB_INFO (new_bb), sizeof (gbi));\n+\t      memcpy (SEL_GLOBAL_BB_INFO (new_bb), SEL_GLOBAL_BB_INFO (succ),\n+\t\t      sizeof (gbi));\n+\t      memcpy (SEL_GLOBAL_BB_INFO (succ), &gbi, sizeof (gbi));\n+\n+\t      memcpy (&rbi, SEL_REGION_BB_INFO (new_bb), sizeof (rbi));\n+\t      memcpy (SEL_REGION_BB_INFO (new_bb), SEL_REGION_BB_INFO (succ),\n+\t\t      sizeof (rbi));\n+\t      memcpy (SEL_REGION_BB_INFO (succ), &rbi, sizeof (rbi));\n+\n+\t      i = BLOCK_TO_BB (new_bb->index);\n+\t      BLOCK_TO_BB (new_bb->index) = BLOCK_TO_BB (succ->index);\n+\t      BLOCK_TO_BB (succ->index) = i;\n+\n+\t      i = CONTAINING_RGN (new_bb->index);\n+\t      CONTAINING_RGN (new_bb->index) = CONTAINING_RGN (succ->index);\n+\t      CONTAINING_RGN (succ->index) = i;\n+\n+\t      for (i = 0; i < current_nr_blocks; i++)\n+\t\tif (BB_TO_BLOCK (i) == succ->index)\n+\t\t  BB_TO_BLOCK (i) = new_bb->index;\n+\t\telse if (BB_TO_BLOCK (i) == new_bb->index)\n+\t\t  BB_TO_BLOCK (i) = succ->index;\n+\n+\t      FOR_BB_INSNS (new_bb, insn)\n+\t\tif (INSN_P (insn))\n+\t\t  EXPR_ORIG_BB_INDEX (INSN_EXPR (insn)) = new_bb->index;\n+\n+\t      FOR_BB_INSNS (succ, insn)\n+\t\tif (INSN_P (insn))\n+\t\t  EXPR_ORIG_BB_INDEX (INSN_EXPR (insn)) = succ->index;\n+\n+\t      if (bitmap_bit_p (code_motion_visited_blocks, new_bb->index))\n+\t\t{\n+\t\t  bitmap_set_bit (code_motion_visited_blocks, succ->index);\n+\t\t  bitmap_clear_bit (code_motion_visited_blocks, new_bb->index);\n+\t\t}\n+\n+\t      gcc_assert (LABEL_P (BB_HEAD (new_bb))\n+\t\t\t  && LABEL_P (BB_HEAD (succ)));\n+\n+\t      if (sched_verbose >= 4)\n+\t\tsel_print (\"Swapping code labels %i and %i\\n\",\n+\t\t\t   CODE_LABEL_NUMBER (BB_HEAD (new_bb)),\n+\t\t\t   CODE_LABEL_NUMBER (BB_HEAD (succ)));\n+\n+\t      i = CODE_LABEL_NUMBER (BB_HEAD (new_bb));\n+\t      CODE_LABEL_NUMBER (BB_HEAD (new_bb))\n+\t\t= CODE_LABEL_NUMBER (BB_HEAD (succ));\n+\t      CODE_LABEL_NUMBER (BB_HEAD (succ)) = i;\n+\t    }\n+\t}\n+    }\n+\n   return bb;\n }\n \n@@ -4496,12 +4669,42 @@ find_place_for_bookkeeping (edge e1, edge e2)\n   insn_t place_to_insert;\n   /* Find a basic block that can hold bookkeeping.  If it can be found, do not\n      create new basic block, but insert bookkeeping there.  */\n-  basic_block book_block = find_block_for_bookkeeping (e1, e2);\n+  basic_block book_block = find_block_for_bookkeeping (e1, e2, FALSE);\n \n-  if (!book_block)\n-    book_block = create_block_for_bookkeeping (e1, e2);\n+  if (book_block)\n+    {\n+      place_to_insert = BB_END (book_block);\n+\n+      /* Don't use a block containing only debug insns for\n+\t bookkeeping, this causes scheduling differences between debug\n+\t and non-debug compilations, for the block would have been\n+\t removed already.  */\n+      if (DEBUG_INSN_P (place_to_insert))\n+\t{\n+\t  rtx insn = sel_bb_head (book_block);\n \n-  place_to_insert = BB_END (book_block);\n+\t  while (insn != place_to_insert &&\n+\t\t (DEBUG_INSN_P (insn) || NOTE_P (insn)))\n+\t    insn = NEXT_INSN (insn);\n+\n+\t  if (insn == place_to_insert)\n+\t    book_block = NULL;\n+\t}\n+    }\n+\n+  if (!book_block)\n+    {\n+      book_block = create_block_for_bookkeeping (e1, e2);\n+      place_to_insert = BB_END (book_block);\n+      if (sched_verbose >= 9)\n+\tsel_print (\"New block is %i, split from bookkeeping block %i\\n\",\n+\t\t   EDGE_SUCC (book_block, 0)->dest->index, book_block->index);\n+    }\n+  else\n+    {\n+      if (sched_verbose >= 9)\n+\tsel_print (\"Pre-existing bookkeeping block is %i\\n\", book_block->index);\n+    }\n \n   /* If basic block ends with a jump, insert bookkeeping code right before it.  */\n   if (INSN_P (place_to_insert) && control_flow_insn_p (place_to_insert))\n@@ -4587,6 +4790,8 @@ generate_bookkeeping_insn (expr_t c_expr, edge e1, edge e2)\n \n   join_point = sel_bb_head (e2->dest);\n   place_to_insert = find_place_for_bookkeeping (e1, e2);\n+  if (!place_to_insert)\n+    return NULL;\n   new_seqno = find_seqno_for_bookkeeping (place_to_insert, join_point);\n   need_to_exchange_data_sets\n     = sel_bb_empty_p (BLOCK_FOR_INSN (place_to_insert));\n@@ -4748,15 +4953,15 @@ move_cond_jump (rtx insn, bnd_t bnd)\n /* Remove nops generated during move_op for preventing removal of empty\n    basic blocks.  */\n static void\n-remove_temp_moveop_nops (void)\n+remove_temp_moveop_nops (bool full_tidying)\n {\n   int i;\n   insn_t insn;\n   \n   for (i = 0; VEC_iterate (insn_t, vec_temp_moveop_nops, i, insn); i++)\n     {\n       gcc_assert (INSN_NOP_P (insn));\n-      return_nop_to_pool (insn);\n+      return_nop_to_pool (insn, full_tidying);\n     }\n \n   /* Empty the vector.  */\n@@ -4949,8 +5154,20 @@ prepare_place_to_insert (bnd_t bnd)\n     {\n       /* Add it after last scheduled.  */\n       place_to_insert = ILIST_INSN (BND_PTR (bnd));\n+      if (DEBUG_INSN_P (place_to_insert))\n+\t{\n+\t  ilist_t l = BND_PTR (bnd);\n+\t  while ((l = ILIST_NEXT (l)) &&\n+\t\t DEBUG_INSN_P (ILIST_INSN (l)))\n+\t    ;\n+\t  if (!l)\n+\t    place_to_insert = NULL;\n+\t}\n     }\n   else\n+    place_to_insert = NULL;\n+\n+  if (!place_to_insert)\n     {\n       /* Add it before BND_TO.  The difference is in the\n          basic block, where INSN will be added.  */\n@@ -5058,7 +5275,8 @@ advance_state_on_fence (fence_t fence, insn_t insn)\n \n   if (sched_verbose >= 2)\n     debug_state (FENCE_STATE (fence));\n-  FENCE_STARTS_CYCLE_P (fence) = 0;\n+  if (!DEBUG_INSN_P (insn))\n+    FENCE_STARTS_CYCLE_P (fence) = 0;\n   return asm_p;\n }\n \n@@ -5117,10 +5335,11 @@ update_fence_and_insn (fence_t fence, insn_t insn, int need_stall)\n     }\n }\n \n-/* Update boundary BND with INSN, remove the old boundary from\n-   BNDSP, add new boundaries to BNDS_TAIL_P and return it.  */\n+/* Update boundary BND (and, if needed, FENCE) with INSN, remove the\n+   old boundary from BNDSP, add new boundaries to BNDS_TAIL_P and\n+   return it.  */\n static blist_t *\n-update_boundaries (bnd_t bnd, insn_t insn, blist_t *bndsp, \n+update_boundaries (fence_t fence, bnd_t bnd, insn_t insn, blist_t *bndsp,\n                    blist_t *bnds_tailp)\n {\n   succ_iterator si;\n@@ -5133,6 +5352,21 @@ update_boundaries (bnd_t bnd, insn_t insn, blist_t *bndsp,\n       ilist_t ptr = ilist_copy (BND_PTR (bnd));\n       \n       ilist_add (&ptr, insn);\n+\n+      if (DEBUG_INSN_P (insn) && sel_bb_end_p (insn)\n+\t  && is_ineligible_successor (succ, ptr))\n+\t{\n+\t  ilist_clear (&ptr);\n+\t  continue;\n+\t}\n+\n+      if (FENCE_INSN (fence) == insn && !sel_bb_end_p (insn))\n+\t{\n+\t  if (sched_verbose >= 9)\n+\t    sel_print (\"Updating fence insn from %i to %i\\n\",\n+\t\t       INSN_UID (insn), INSN_UID (succ));\n+\t  FENCE_INSN (fence) = succ;\n+\t}\n       blist_add (bnds_tailp, succ, ptr, BND_DC (bnd));\n       bnds_tailp = &BLIST_NEXT (*bnds_tailp);\n     }\n@@ -5192,8 +5426,8 @@ schedule_expr_on_boundary (bnd_t bnd, expr_t expr_vliw, int seqno)\n   /* Return the nops generated for preserving of data sets back\n      into pool.  */\n   if (INSN_NOP_P (place_to_insert))\n-    return_nop_to_pool (place_to_insert);\n-  remove_temp_moveop_nops ();\n+    return_nop_to_pool (place_to_insert, !DEBUG_INSN_P (insn));\n+  remove_temp_moveop_nops (!DEBUG_INSN_P (insn));\n \n   av_set_clear (&expr_seq);\n  \n@@ -5251,7 +5485,9 @@ fill_insns (fence_t fence, int seqno, ilist_t **scheduled_insns_tailpp)\n       int was_stall = 0, scheduled_insns = 0, stall_iterations = 0;\n       int max_insns = pipelining_p ? issue_rate : 2 * issue_rate;\n       int max_stall = pipelining_p ? 1 : 3;\n-      \n+      bool last_insn_was_debug = false;\n+      bool was_debug_bb_end_p = false;\n+\n       compute_av_set_on_boundaries (fence, bnds, &av_vliw);\n       remove_insns_that_need_bookkeeping (fence, &av_vliw);\n       remove_insns_for_debug (bnds, &av_vliw);\n@@ -5309,8 +5545,11 @@ fill_insns (fence_t fence, int seqno, ilist_t **scheduled_insns_tailpp)\n \t    }\n           \n           insn = schedule_expr_on_boundary (bnd, expr_vliw, seqno);\n+\t  last_insn_was_debug = DEBUG_INSN_P (insn);\n+\t  if (last_insn_was_debug)\n+\t    was_debug_bb_end_p = (insn == BND_TO (bnd) && sel_bb_end_p (insn));\n           update_fence_and_insn (fence, insn, need_stall);\n-          bnds_tailp = update_boundaries (bnd, insn, bndsp, bnds_tailp);\n+          bnds_tailp = update_boundaries (fence, bnd, insn, bndsp, bnds_tailp);\n \n \t  /* Add insn to the list of scheduled on this cycle instructions.  */\n \t  ilist_add (*scheduled_insns_tailpp, insn);\n@@ -5319,13 +5558,14 @@ fill_insns (fence_t fence, int seqno, ilist_t **scheduled_insns_tailpp)\n       while (*bndsp != *bnds_tailp1);\n \n       av_set_clear (&av_vliw);\n-      scheduled_insns++;\n+      if (!last_insn_was_debug)\n+\tscheduled_insns++;\n \n       /* We currently support information about candidate blocks only for\n \t one 'target_bb' block.  Hence we can't schedule after jump insn,\n \t as this will bring two boundaries and, hence, necessity to handle\n \t information for two or more blocks concurrently.  */\n-      if (sel_bb_end_p (insn)\n+      if ((last_insn_was_debug ? was_debug_bb_end_p : sel_bb_end_p (insn))\n           || (was_stall \n               && (was_stall >= max_stall \n                   || scheduled_insns >= max_insns)))\n@@ -5544,7 +5784,7 @@ track_scheduled_insns_and_blocks (rtx insn)\n \t instruction out of it.  */\n       if (INSN_SCHED_TIMES (insn) > 0)\n \tbitmap_set_bit (blocks_to_reschedule, BLOCK_FOR_INSN (insn)->index);\n-      else if (INSN_UID (insn) < first_emitted_uid)\n+      else if (INSN_UID (insn) < first_emitted_uid && !DEBUG_INSN_P (insn))\n \tnum_insns_scheduled++;\n     }\n   else\n@@ -5636,32 +5876,63 @@ handle_emitting_transformations (rtx insn, expr_t expr,\n   return insn_emitted;\n }  \n \n-/* Remove INSN from stream.  When ONLY_DISCONNECT is true, its data \n-   is not removed but reused when INSN is re-emitted.  */\n-static void\n-remove_insn_from_stream (rtx insn, bool only_disconnect)\n+/* If INSN is the only insn in the basic block (not counting JUMP,\n+   which may be a jump to next insn, and DEBUG_INSNs), we want to\n+   leave a NOP there till the return to fill_insns.  */\n+\n+static bool\n+need_nop_to_preserve_insn_bb (rtx insn)\n {\n-  insn_t nop, bb_head, bb_end;\n-  bool need_nop_to_preserve_bb;\n+  insn_t bb_head, bb_end, bb_next, in_next;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n-  /* If INSN is the only insn in the basic block (not counting JUMP,\n-     which may be a jump to next insn), leave NOP there till the \n-     return to fill_insns.  */\n   bb_head = sel_bb_head (bb);\n   bb_end = sel_bb_end (bb);\n-  need_nop_to_preserve_bb = ((bb_head == bb_end)\n-                             || (NEXT_INSN (bb_head) == bb_end \n-                                 && JUMP_P (bb_end))\n-                             || IN_CURRENT_FENCE_P (NEXT_INSN (insn)));\n \n+  if (bb_head == bb_end)\n+    return true;\n+\n+  while (bb_head != bb_end && DEBUG_INSN_P (bb_head))\n+    bb_head = NEXT_INSN (bb_head);\n+\n+  if (bb_head == bb_end)\n+    return true;\n+\n+  while (bb_head != bb_end && DEBUG_INSN_P (bb_end))\n+    bb_end = PREV_INSN (bb_end);\n+\n+  if (bb_head == bb_end)\n+    return true;\n+\n+  bb_next = NEXT_INSN (bb_head);\n+  while (bb_next != bb_end && DEBUG_INSN_P (bb_next))\n+    bb_next = NEXT_INSN (bb_next);\n+\n+  if (bb_next == bb_end && JUMP_P (bb_end))\n+    return true;\n+\n+  in_next = NEXT_INSN (insn);\n+  while (DEBUG_INSN_P (in_next))\n+    in_next = NEXT_INSN (in_next);\n+\n+  if (IN_CURRENT_FENCE_P (in_next))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Remove INSN from stream.  When ONLY_DISCONNECT is true, its data\n+   is not removed but reused when INSN is re-emitted.  */\n+static void\n+remove_insn_from_stream (rtx insn, bool only_disconnect)\n+{\n   /* If there's only one insn in the BB, make sure that a nop is\n      inserted into it, so the basic block won't disappear when we'll\n      delete INSN below with sel_remove_insn. It should also survive\n      till the return to fill_insns.  */\t     \n-  if (need_nop_to_preserve_bb)\n+  if (need_nop_to_preserve_insn_bb (insn))\n     {\n-      nop = get_nop_from_pool (insn);\n+      insn_t nop = get_nop_from_pool (insn);\n       gcc_assert (INSN_NOP_P (nop));\n       VEC_safe_push (insn_t, heap, vec_temp_moveop_nops, nop);\n     }\n@@ -5925,6 +6196,8 @@ fur_orig_expr_not_found (insn_t insn, av_set_t orig_ops, void *static_params)\n \n   if (CALL_P (insn))\n     sparams->crosses_call = true;\n+  else if (DEBUG_INSN_P (insn))\n+    return true;\n \n   /* If current insn we are looking at cannot be executed together\n      with original insn, then we can skip it safely."}, {"sha": "0450ea083f4f23da928d9afa3f597d1c466ce3b2", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -202,6 +202,106 @@ avoid_constant_pool_reference (rtx x)\n   return x;\n }\n \f\n+/* Simplify a MEM based on its attributes.  This is the default\n+   delegitimize_address target hook, and it's recommended that every\n+   overrider call it.  */\n+\n+rtx\n+delegitimize_mem_from_attrs (rtx x)\n+{\n+  if (MEM_P (x)\n+      && MEM_EXPR (x)\n+      && (!MEM_OFFSET (x)\n+\t  || GET_CODE (MEM_OFFSET (x)) == CONST_INT))\n+    {\n+      tree decl = MEM_EXPR (x);\n+      enum machine_mode mode = GET_MODE (x);\n+      HOST_WIDE_INT offset = 0;\n+\n+      switch (TREE_CODE (decl))\n+\t{\n+\tdefault:\n+\t  decl = NULL;\n+\t  break;\n+\n+\tcase VAR_DECL:\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\tcase COMPONENT_REF:\n+\tcase BIT_FIELD_REF:\n+\tcase REALPART_EXPR:\n+\tcase IMAGPART_EXPR:\n+\tcase VIEW_CONVERT_EXPR:\n+\t  {\n+\t    HOST_WIDE_INT bitsize, bitpos;\n+\t    tree toffset;\n+\t    int unsignedp = 0, volatilep = 0;\n+\n+\t    decl = get_inner_reference (decl, &bitsize, &bitpos, &toffset,\n+\t\t\t\t\t&mode, &unsignedp, &volatilep, false);\n+\t    if (bitsize != GET_MODE_BITSIZE (mode)\n+\t\t|| (bitpos % BITS_PER_UNIT)\n+\t\t|| (toffset && !host_integerp (toffset, 0)))\n+\t      decl = NULL;\n+\t    else\n+\t      {\n+\t\toffset += bitpos / BITS_PER_UNIT;\n+\t\tif (toffset)\n+\t\t  offset += TREE_INT_CST_LOW (toffset);\n+\t      }\n+\t    break;\n+\t  }\n+\t}\n+\n+      if (decl\n+\t  && mode == GET_MODE (x)\n+\t  && TREE_CODE (decl) == VAR_DECL\n+\t  && (TREE_STATIC (decl)\n+\t      || DECL_THREAD_LOCAL_P (decl))\n+\t  && DECL_RTL_SET_P (decl)\n+\t  && MEM_P (DECL_RTL (decl)))\n+\t{\n+\t  rtx newx;\n+\n+\t  if (MEM_OFFSET (x))\n+\t    offset += INTVAL (MEM_OFFSET (x));\n+\n+\t  newx = DECL_RTL (decl);\n+\n+\t  if (MEM_P (newx))\n+\t    {\n+\t      rtx n = XEXP (newx, 0), o = XEXP (x, 0);\n+\n+\t      /* Avoid creating a new MEM needlessly if we already had\n+\t\t the same address.  We do if there's no OFFSET and the\n+\t\t old address X is identical to NEWX, or if X is of the\n+\t\t form (plus NEWX OFFSET), or the NEWX is of the form\n+\t\t (plus Y (const_int Z)) and X is that with the offset\n+\t\t added: (plus Y (const_int Z+OFFSET)).  */\n+\t      if (!((offset == 0\n+\t\t     || (GET_CODE (o) == PLUS\n+\t\t\t && GET_CODE (XEXP (o, 1)) == CONST_INT\n+\t\t\t && (offset == INTVAL (XEXP (o, 1))\n+\t\t\t     || (GET_CODE (n) == PLUS\n+\t\t\t\t && GET_CODE (XEXP (n, 1)) == CONST_INT\n+\t\t\t\t && (INTVAL (XEXP (n, 1)) + offset\n+\t\t\t\t     == INTVAL (XEXP (o, 1)))\n+\t\t\t\t && (n = XEXP (n, 0))))\n+\t\t\t && (o = XEXP (o, 0))))\n+\t\t    && rtx_equal_p (o, n)))\n+\t\tx = adjust_address_nv (newx, mode, offset);\n+\t    }\n+\t  else if (GET_MODE (x) == GET_MODE (newx)\n+\t\t   && offset == 0)\n+\t    x = newx;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\f\n /* Make a unary operation by first seeing if it folds and otherwise making\n    the specified operation.  */\n "}, {"sha": "286e1e68cd79c74470a36a824475b150f220c9fa", "filename": "gcc/target-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -488,7 +488,7 @@\n #define TARGET_CANNOT_COPY_INSN_P NULL\n #define TARGET_COMMUTATIVE_P hook_bool_const_rtx_commutative_p\n #define TARGET_LEGITIMIZE_ADDRESS default_legitimize_address\n-#define TARGET_DELEGITIMIZE_ADDRESS hook_rtx_rtx_identity\n+#define TARGET_DELEGITIMIZE_ADDRESS delegitimize_mem_from_attrs\n #define TARGET_LEGITIMATE_ADDRESS_P default_legitimate_address_p\n #define TARGET_USE_BLOCKS_FOR_CONSTANT_P hook_bool_mode_const_rtx_false\n #define TARGET_MIN_ANCHOR_OFFSET 0"}, {"sha": "e02066ee339a85df8ebf948cf96d0cc718715e20", "filename": "gcc/testsuite/gcc.dg/guality/example.c", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fexample.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fexample.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fexample.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,138 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#define GUALITY_DONT_FORCE_LIVE_AFTER -1\n+\n+#ifndef STATIC_INLINE\n+#define STATIC_INLINE /*static*/\n+#endif\n+\n+#include \"guality.h\"\n+\n+#include <assert.h>\n+\n+/* Test the debug info for the functions used in the VTA\n+   presentation at the GCC Summit 2008.  */\n+\n+typedef struct list {\n+  struct list *n;\n+  int v;\n+} elt, *node;\n+\n+STATIC_INLINE node\n+find_val (node c, int v, node e)\n+{\n+  while (c < e)\n+    {\n+      GUALCHK (c);\n+      GUALCHK (v);\n+      GUALCHK (e);\n+      if (c->v == v)\n+\treturn c;\n+      GUALCHK (c);\n+      GUALCHK (v);\n+      GUALCHK (e);\n+      c++;\n+    }\n+  return NULL;\n+}\n+\n+STATIC_INLINE node\n+find_prev (node c, node w)\n+{\n+  while (c)\n+    {\n+      node o = c;\n+      c = c->n;\n+      GUALCHK (c);\n+      GUALCHK (o);\n+      GUALCHK (w);\n+      if (c == w)\n+\treturn o;\n+      GUALCHK (c);\n+      GUALCHK (o);\n+      GUALCHK (w);\n+    }\n+  return NULL;\n+}\n+\n+STATIC_INLINE node\n+check_arr (node c, node e)\n+{\n+  if (c == e)\n+    return NULL;\n+  e--;\n+  while (c < e)\n+    {\n+      GUALCHK (c);\n+      GUALCHK (e);\n+      if (c->v > (c+1)->v)\n+\treturn c;\n+      GUALCHK (c);\n+      GUALCHK (e);\n+      c++;\n+    }\n+  return NULL;\n+}\n+\n+STATIC_INLINE node\n+check_list (node c, node t)\n+{\n+  while (c != t)\n+    {\n+      node n = c->n;\n+      GUALCHK (c);\n+      GUALCHK (n);\n+      GUALCHK (t);\n+      if (c->v > n->v)\n+\treturn c;\n+      GUALCHK (c);\n+      GUALCHK (n);\n+      GUALCHK (t);\n+      c = n;\n+    }\n+  return NULL;\n+}\n+\n+struct list testme[] = {\n+  { &testme[1],  2 },\n+  { &testme[2],  3 },\n+  { &testme[3],  5 },\n+  { &testme[4],  7 },\n+  { &testme[5], 11 },\n+  { NULL, 13 },\n+};\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int n = sizeof (testme) / sizeof (*testme);\n+  node first, last, begin, end, ret;\n+\n+  GUALCHKXPR (n);\n+\n+  begin = first = &testme[0];\n+  last = &testme[n-1];\n+  end = &testme[n];\n+\n+  GUALCHKXPR (first);\n+  GUALCHKXPR (last);\n+  GUALCHKXPR (begin);\n+  GUALCHKXPR (end);\n+\n+  ret = find_val (begin, 13, end);\n+  GUALCHK (ret);\n+  assert (ret == last);\n+\n+  ret = find_prev (first, last);\n+  GUALCHK (ret);\n+  assert (ret == &testme[n-2]);\n+\n+  ret = check_arr (begin, end);\n+  GUALCHK (ret);\n+  assert (!ret);\n+\n+  ret = check_list (first, last);\n+  GUALCHK (ret);\n+  assert (!ret);\n+}"}, {"sha": "0e47d0155ae2671968070a8fff22f3d48889c196", "filename": "gcc/testsuite/gcc.dg/guality/guality.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"guality.h\"\n+\n+/* Some silly sanity checking.  */\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i = argc+1;\n+  int j = argc-2;\n+  int k = 5;\n+\n+  GUALCHKXPR (argc);\n+  GUALCHKXPR (i);\n+  GUALCHKXPR (j);\n+  GUALCHKXPR (k);\n+  GUALCHKXPR (&i);\n+  GUALCHKFLA (argc);\n+  GUALCHKFLA (i);\n+  GUALCHKFLA (j);\n+  GUALCHKXPR (i);\n+  GUALCHKXPR (j);\n+  GUALCHKXPRVAL (\"k\", 5, 1);\n+  GUALCHKXPRVAL (\"0x40\", 64, 0);\n+  /* GUALCHKXPRVAL (\"0\", 0, 0); *//* XFAIL */\n+}"}, {"sha": "b151c2e07728eaa28119ef278d8d699293785e63", "filename": "gcc/testsuite/gcc.dg/guality/guality.exp", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.exp?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,7 @@\n+# This harness is for tests that should be run at all optimisation levels.\n+\n+load_lib gcc-dg.exp\n+\n+dg-init\n+gcc-dg-runtest [lsort [glob $srcdir/$subdir/*.c]] \"\"\n+dg-finish"}, {"sha": "6025da8b0282efbb935b697dcdd7b77d87c2a548", "filename": "gcc/testsuite/gcc.dg/guality/guality.h", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fguality.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -0,0 +1,330 @@\n+/* Infrastructure to test the quality of debug information.\n+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+   Contributed by Alexandre Oliva <aoliva@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/wait.h>\n+\n+/* This is a first cut at checking that debug information matches\n+   run-time.  The idea is to annotate programs with GUALCHK* macros\n+   that guide the tests.\n+\n+   In the current implementation, all of the macros expand to function\n+   calls.  On the one hand, this interferes with optimizations; on the\n+   other hand, it establishes an optimization barrier and a clear\n+   inspection point, where previous operations (as in the abstract\n+   machine) should have been completed and have their effects visible,\n+   and future operations shouldn't have started yet.\n+\n+   In the current implementation of guality_check(), we fork a child\n+   process that runs gdb, attaches to the parent process (the one that\n+   called guality_check), moves up one stack frame (to the caller of\n+   guality_check) and then examines the given expression.\n+\n+   If it matches the expected value, we have a PASS.  If it differs,\n+   we have a FAILure.  If it is missing, we'll have a FAIL or an\n+   UNRESOLVED depending on whether the variable or expression might be\n+   unavailable at that point, as indicated by the third argument.\n+\n+   We envision a future alternate implementation with two compilation\n+   and execution cycles, say one that runs the program and uses the\n+   macros to log expressions and expected values, another in which the\n+   macros expand to nothing and the logs are used to guide a debug\n+   session that tests the values.  How to identify the inspection\n+   points in the second case is yet to be determined.  It is\n+   recommended that GUALCHK* macros be by themselves in source lines,\n+   so that __FILE__ and __LINE__ will be usable to identify them.\n+*/\n+\n+/* Attach a debugger to the current process and verify that the string\n+   EXPR, evaluated by the debugger, yields the long long number VAL.\n+   If the debugger cannot compute the expression, say because the\n+   variable is unavailable, this will count as an error, unless unkok\n+   is nonzero.  */\n+\n+#define GUALCHKXPRVAL(expr, val, unkok) \\\n+  guality_check ((expr), (val), (unkok))\n+\n+/* Check that a debugger knows that EXPR evaluates to the run-time\n+   value of EXPR.  Unknown values are marked as acceptable,\n+   considering that EXPR may die right after this call.  This will\n+   affect the generated code in that EXPR will be evaluated and forced\n+   to remain live at least until right before the call to\n+   guality_check, although not necessarily after the call.  */\n+\n+#define GUALCHKXPR(expr) \\\n+  GUALCHKXPRVAL (#expr, (long long)(expr), 1)\n+\n+/* Same as GUALCHKXPR, but issue an error if the variable is optimized\n+   away.  */\n+\n+#define GUALCHKVAL(expr) \\\n+  GUALCHKXPRVAL (#expr, (long long)(expr), 0)\n+\n+/* Check that a debugger knows that EXPR evaluates to the run-time\n+   value of EXPR.  Unknown values are marked as errors, because the\n+   value of EXPR is forced to be available right after the call, for a\n+   range of at least one instruction.  This will affect the generated\n+   code, in that EXPR *will* be evaluated before and preserved until\n+   after the call to guality_check.  */\n+\n+#define GUALCHKFLA(expr) do {\t\t\t\t\t\\\n+    __typeof(expr) volatile __preserve_after;\t\t\t\\\n+    __typeof(expr) __preserve_before = (expr);\t\t\t\\\n+    GUALCHKXPRVAL (#expr, (long long)(__preserve_before), 0);\t\\\n+    __preserve_after = __preserve_before;\t\t\t\\\n+    asm (\"\" : : \"m\" (__preserve_after));\t\t\t\\\n+  } while (0)\n+\n+/* GUALCHK is the simplest way to assert that debug information for an\n+   expression matches its run-time value.  Whether to force the\n+   expression live after the call, so as to flag incompleteness\n+   errors, can be disabled by defining GUALITY_DONT_FORCE_LIVE_AFTER.\n+   Setting it to -1, an error is issued for optimized out variables,\n+   even though they are not forced live.  */\n+\n+#if ! GUALITY_DONT_FORCE_LIVE_AFTER\n+#define GUALCHK(var) GUALCHKFLA(var)\n+#elif GUALITY_DONT_FORCE_LIVE_AFTER < 0\n+#define GUALCHK(var) GUALCHKVAL(var)\n+#else\n+#define GUALCHK(var) GUALCHKXPR(var)\n+#endif\n+\n+/* The name of the GDB program, with arguments to make it quiet.  This\n+   is GUALITY_GDB_DEFAULT GUALITY_GDB_ARGS by default, but it can be\n+   overridden by setting the GUALITY_GDB environment variable, whereas\n+   GUALITY_GDB_DEFAULT can be overridden by setting the\n+   GUALITY_GDB_NAME environment variable.  */\n+\n+static const char *guality_gdb_command;\n+#define GUALITY_GDB_DEFAULT \"gdb\"\n+#define GUALITY_GDB_ARGS \" -nx -nw --quiet > /dev/null 2>&1\"\n+\n+/* Kinds of results communicated as exit status from child process\n+   that runs gdb to the parent process that's being monitored.  */\n+\n+enum guality_counter { PASS, INCORRECT, INCOMPLETE };\n+\n+/* Count of passes and errors.  */\n+\n+static int guality_count[INCOMPLETE+1];\n+\n+/* If --guality-skip is given in the command line, all the monitoring,\n+   forking and debugger-attaching action will be disabled.  This is\n+   useful to run the monitor program within a debugger.  */\n+\n+static int guality_skip;\n+\n+/* This is a file descriptor to which we'll issue gdb commands to\n+   probe and test.  */\n+FILE *guality_gdb_input;\n+\n+/* This holds the line number where we're supposed to set a\n+   breakpoint.  */\n+int guality_breakpoint_line;\n+\n+/* GDB should set this to true once it's connected.  */\n+int volatile guality_attached;\n+\n+/* This function is the main guality program.  It may actually be\n+   defined as main, because we #define main to it afterwards.  Because\n+   of this wrapping, guality_main may not have an empty argument\n+   list.  */\n+\n+extern int guality_main (int argc, char *argv[]);\n+\n+static void __attribute__((noinline))\n+guality_check (const char *name, long long value, int unknown_ok);\n+\n+/* Set things up, run guality_main, then print a summary and quit.  */\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  char *argv0 = argv[0];\n+\n+  guality_gdb_command = getenv (\"GUALITY_GDB\");\n+  if (!guality_gdb_command)\n+    {\n+      guality_gdb_command = getenv (\"GUALITY_GDB_NAME\");\n+      if (!guality_gdb_command)\n+\tguality_gdb_command = GUALITY_GDB_DEFAULT GUALITY_GDB_ARGS;\n+      else\n+\t{\n+\t  int len = strlen (guality_gdb_command) + sizeof (GUALITY_GDB_ARGS);\n+\t  char *buf = __builtin_alloca (len);\n+\t  strcpy (buf, guality_gdb_command);\n+\t  strcat (buf, GUALITY_GDB_ARGS);\n+\t  guality_gdb_command = buf;\n+\t}\n+    }\n+\n+  for (i = 1; i < argc; i++)\n+    if (strcmp (argv[i], \"--guality-skip\") == 0)\n+      guality_skip = 1;\n+    else\n+      break;\n+\n+  if (!guality_skip)\n+    {\n+      guality_gdb_input = popen (guality_gdb_command, \"w\");\n+      /* This call sets guality_breakpoint_line.  */\n+      guality_check (NULL, 0, 0);\n+      if (!guality_gdb_input\n+\t  || fprintf (guality_gdb_input, \"\\\n+set height 0\\n\\\n+attach %i\\n\\\n+set guality_attached = 1\\n\\\n+b %i\\n\\\n+continue\\n\\\n+\", (int)getpid (), guality_breakpoint_line) <= 0\n+\t  || fflush (guality_gdb_input))\n+\t{\n+\t  perror (\"gdb\");\n+\t  abort ();\n+\t}\n+    }\n+\n+  argv[--i] = argv0;\n+\n+  guality_main (argc - i, argv + i);\n+\n+  i = guality_count[INCORRECT];\n+\n+  fprintf (stderr, \"%s: %i PASS, %i FAIL, %i UNRESOLVED\\n\",\n+\t   i ? \"FAIL\" : \"PASS\",\n+\t   guality_count[PASS], guality_count[INCORRECT],\n+\t   guality_count[INCOMPLETE]);\n+\n+  return i;\n+}\n+\n+#define main guality_main\n+\n+/* Tell the GDB child process to evaluate NAME in the caller.  If it\n+   matches VALUE, we have a PASS; if it's unknown and UNKNOWN_OK, we\n+   have an UNRESOLVED.  Otherwise, it's a FAIL.  */\n+\n+static void __attribute__((noinline))\n+guality_check (const char *name, long long value, int unknown_ok)\n+{\n+  int result;\n+\n+  if (guality_skip)\n+    return;\n+\n+  {\n+    volatile long long xvalue = -1;\n+    volatile int unavailable = 0;\n+    if (name)\n+      {\n+\t/* The sequence below cannot distinguish an optimized away\n+\t   variable from one mapped to a non-lvalue zero.  */\n+\tif (fprintf (guality_gdb_input, \"\\\n+up\\n\\\n+set $value1 = 0\\n\\\n+set $value1 = (%s)\\n\\\n+set $value2 = -1\\n\\\n+set $value2 = (%s)\\n\\\n+set $value3 = $value1 - 1\\n\\\n+set $value4 = $value1 + 1\\n\\\n+set $value3 = (%s)++\\n\\\n+set $value4 = --(%s)\\n\\\n+down\\n\\\n+set xvalue = $value1\\n\\\n+set unavailable = $value1 != $value2 ? -1 : $value3 != $value4 ? 1 : 0\\n\\\n+continue\\n\\\n+\", name, name, name, name) <= 0\n+\t    || fflush (guality_gdb_input))\n+\t  {\n+\t    perror (\"gdb\");\n+\t    abort ();\n+\t  }\n+\telse if (!guality_attached)\n+\t  {\n+\t    unsigned int timeout = 0;\n+\n+\t    /* Give GDB some more time to attach.  Wrapping around a\n+\t       32-bit counter takes some seconds, it should be plenty\n+\t       of time for GDB to get a chance to start up and attach,\n+\t       but not long enough that, if GDB is unavailable or\n+\t       broken, we'll take far too long to give up.  */\n+\t    while (--timeout && !guality_attached)\n+\t      ;\n+\t    if (!timeout && !guality_attached)\n+\t      {\n+\t\tfprintf (stderr, \"gdb: took too long to attach\\n\");\n+\t\tabort ();\n+\t      }\n+\t  }\n+      }\n+    else\n+      {\n+\tguality_breakpoint_line = __LINE__ + 5;\n+\treturn;\n+      }\n+    /* Do NOT add lines between the __LINE__ above and the line below,\n+       without also adjusting the added constant to match.  */\n+    if (!unavailable || (unavailable > 0 && xvalue))\n+      {\n+\tif (xvalue == value)\n+\t  result = PASS;\n+\telse\n+\t  result = INCORRECT;\n+      }\n+    else\n+      result = INCOMPLETE;\n+    asm (\"\" : : \"X\" (name), \"X\" (value), \"X\" (unknown_ok), \"m\" (xvalue));\n+    switch (result)\n+      {\n+      case PASS:\n+\tfprintf (stderr, \"PASS: %s is %lli\\n\", name, value);\n+\tbreak;\n+      case INCORRECT:\n+\tfprintf (stderr, \"FAIL: %s is %lli, not %lli\\n\", name, xvalue, value);\n+\tbreak;\n+      case INCOMPLETE:\n+\tfprintf (stderr, \"%s: %s is %s, expected %lli\\n\",\n+\t\t unknown_ok ? \"UNRESOLVED\" : \"FAIL\", name,\n+\t\t unavailable < 0 ? \"not computable\" : \"optimized away\", value);\n+\tresult = unknown_ok ? INCOMPLETE : INCORRECT;\n+\tbreak;\n+      default:\n+\tabort ();\n+      }\n+  }\n+\n+  switch (result)\n+    {\n+    case PASS:\n+    case INCORRECT:\n+    case INCOMPLETE:\n+      ++guality_count[result];\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}"}, {"sha": "feec50582146f724aacd9e403af742cbad7c8b13", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -449,11 +449,15 @@ proc cleanup-dump { suffix } {\n     # The name might include a list of options; extract the file name.\n     set src [file tail [lindex $testcase 0]]\n     remove-build-file \"[file tail $src].$suffix\"\n+    # -fcompare-debug dumps\n+    remove-build-file \"[file tail $src].gk.$suffix\"\n \n     # Clean up dump files for additional source files.\n     if [info exists additional_sources] {\n \tforeach srcfile $additional_sources {\n \t    remove-build-file \"[file tail $srcfile].$suffix\"\n+\t    # -fcompare-debug dumps\n+\t    remove-build-file \"[file tail $srcfile].gk.$suffix\"\n \t}\n     }\n }\n@@ -468,7 +472,7 @@ proc cleanup-saved-temps { args } {\n     set suffixes {}\n \n     # add the to-be-kept suffixes\n-    foreach suffix {\".ii\" \".i\" \".s\" \".o\"} {\n+    foreach suffix {\".ii\" \".i\" \".s\" \".o\" \".gkd\"} {\n \tif {[lsearch $args $suffix] < 0} {\n \t    lappend suffixes $suffix\n \t}\n@@ -480,13 +484,17 @@ proc cleanup-saved-temps { args } {\n     upvar 2 name testcase\n     foreach suffix $suffixes {\n \tremove-build-file \"[file rootname [file tail $testcase]]$suffix\"\n+\t# -fcompare-debug dumps\n+\tremove-build-file \"[file rootname [file tail $testcase]].gk$suffix\"\n     }\n \n     # Clean up saved temp files for additional source files.\n     if [info exists additional_sources] {\n \tforeach srcfile $additional_sources {\n \t    foreach suffix $suffixes {\n \t\tremove-build-file \"[file rootname [file tail $srcfile]]$suffix\"\n+\t\t# -fcompare-debug dumps\n+\t\tremove-build-file \"[file rootname [file tail $srcfile]].gk$suffix\"\n \t    }\n \t}\n     }"}, {"sha": "b0e7039ca1df0c2a9d1319aa623df7cc6d4da2c6", "filename": "gcc/toplev.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -319,11 +319,23 @@ int flag_dump_rtl_in_asm = 0;\n    the support provided depends on the backend.  */\n rtx stack_limit_rtx;\n \n-/* Nonzero if we should track variables.  When\n-   flag_var_tracking == AUTODETECT_VALUE it will be set according\n-   to optimize, debug_info_level and debug_hooks in process_options ().  */\n+/* Positive if we should track variables, negative if we should run\n+   the var-tracking pass only to discard debug annotations, zero if\n+   we're not to run it.  When flag_var_tracking == AUTODETECT_VALUE it\n+   will be set according to optimize, debug_info_level and debug_hooks\n+   in process_options ().  */\n int flag_var_tracking = AUTODETECT_VALUE;\n \n+/* Positive if we should track variables at assignments, negative if\n+   we should run the var-tracking pass only to discard debug\n+   annotations.  When flag_var_tracking_assignments ==\n+   AUTODETECT_VALUE it will be set according to flag_var_tracking.  */\n+int flag_var_tracking_assignments = AUTODETECT_VALUE;\n+\n+/* Nonzero if we should toggle flag_var_tracking_assignments after\n+   processing options and computing its default.  */\n+int flag_var_tracking_assignments_toggle = 0;\n+\n /* Type of stack check.  */\n enum stack_check_type flag_stack_check = NO_STACK_CHECK;\n \n@@ -1876,7 +1888,7 @@ process_options (void)\n \tdebug_info_level = DINFO_LEVEL_NONE;\n     }\n \n-  if (flag_dump_final_insns)\n+  if (flag_dump_final_insns && !flag_syntax_only && !no_backend)\n     {\n       FILE *final_output = fopen (flag_dump_final_insns, \"w\");\n       if (!final_output)\n@@ -1977,6 +1989,15 @@ process_options (void)\n   if (flag_var_tracking == AUTODETECT_VALUE)\n     flag_var_tracking = optimize >= 1;\n \n+  if (flag_var_tracking_assignments == AUTODETECT_VALUE)\n+    flag_var_tracking_assignments = 0;\n+\n+  if (flag_var_tracking_assignments_toggle)\n+    flag_var_tracking_assignments = !flag_var_tracking_assignments;\n+\n+  if (flag_var_tracking_assignments && !flag_var_tracking)\n+    flag_var_tracking = flag_var_tracking_assignments = -1;\n+\n   if (flag_tree_cselim == AUTODETECT_VALUE)\n #ifdef HAVE_conditional_move\n     flag_tree_cselim = 1;"}, {"sha": "81d95d75e6e74e8add5ce34f30ab2fc7f28eed87", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 102, "deletions": 11, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1395,6 +1395,49 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n   return true;\n }\n \n+/* Return true if the var whose chain of uses starts at PTR has no\n+   nondebug uses.  */\n+bool\n+has_zero_uses_1 (const ssa_use_operand_t *head)\n+{\n+  const ssa_use_operand_t *ptr;\n+\n+  for (ptr = head->next; ptr != head; ptr = ptr->next)\n+    if (!is_gimple_debug (USE_STMT (ptr)))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Return true if the var whose chain of uses starts at PTR has a\n+   single nondebug use.  Set USE_P and STMT to that single nondebug\n+   use, if so, or to NULL otherwise.  */\n+bool\n+single_imm_use_1 (const ssa_use_operand_t *head,\n+\t\t  use_operand_p *use_p, gimple *stmt)\n+{\n+  ssa_use_operand_t *ptr, *single_use = 0;\n+\n+  for (ptr = head->next; ptr != head; ptr = ptr->next)\n+    if (!is_gimple_debug (USE_STMT (ptr)))\n+      {\n+\tif (single_use)\n+\t  {\n+\t    single_use = NULL;\n+\t    break;\n+\t  }\n+\tsingle_use = ptr;\n+      }\n+\n+  if (use_p)\n+    *use_p = single_use;\n+\n+  if (stmt)\n+    *stmt = single_use ? single_use->loc.stmt : NULL;\n+\n+  return !!single_use;\n+}\n+\n /* Replaces all uses of NAME by VAL.  */\n \n void\n@@ -2263,7 +2306,11 @@ remove_bb (basic_block bb)\n   /* Remove all the instructions in the block.  */\n   if (bb_seq (bb) != NULL)\n     {\n-      for (i = gsi_start_bb (bb); !gsi_end_p (i);)\n+      /* Walk backwards so as to get a chance to substitute all\n+\t released DEFs into debug stmts.  See\n+\t eliminate_unnecessary_stmts() in tree-ssa-dce.c for more\n+\t details.  */\n+      for (i = gsi_last_bb (bb); !gsi_end_p (i);)\n \t{\n \t  gimple stmt = gsi_stmt (i);\n \t  if (gimple_code (stmt) == GIMPLE_LABEL\n@@ -2299,13 +2346,17 @@ remove_bb (basic_block bb)\n \t      gsi_remove (&i, true);\n \t    }\n \n+\t  if (gsi_end_p (i))\n+\t    i = gsi_last_bb (bb);\n+\t  else\n+\t    gsi_prev (&i);\n+\n \t  /* Don't warn for removed gotos.  Gotos are often removed due to\n \t     jump threading, thus resulting in bogus warnings.  Not great,\n \t     since this way we lose warnings for gotos in the original\n \t     program that are indeed unreachable.  */\n \t  if (gimple_code (stmt) != GIMPLE_GOTO\n-\t      && gimple_has_location (stmt)\n-\t      && !loc)\n+\t      && gimple_has_location (stmt))\n \t    loc = gimple_location (stmt);\n \t}\n     }\n@@ -2807,7 +2858,14 @@ gimple\n first_stmt (basic_block bb)\n {\n   gimple_stmt_iterator i = gsi_start_bb (bb);\n-  return !gsi_end_p (i) ? gsi_stmt (i) : NULL;\n+  gimple stmt = NULL;\n+\n+  while (!gsi_end_p (i) && is_gimple_debug ((stmt = gsi_stmt (i))))\n+    {\n+      gsi_next (&i);\n+      stmt = NULL;\n+    }\n+  return stmt;\n }\n \n /* Return the first non-label statement in basic block BB.  */\n@@ -2826,8 +2884,15 @@ first_non_label_stmt (basic_block bb)\n gimple\n last_stmt (basic_block bb)\n {\n-  gimple_stmt_iterator b = gsi_last_bb (bb);\n-  return !gsi_end_p (b) ? gsi_stmt (b) : NULL;\n+  gimple_stmt_iterator i = gsi_last_bb (bb);\n+  gimple stmt = NULL;\n+\n+  while (!gsi_end_p (i) && is_gimple_debug ((stmt = gsi_stmt (i))))\n+    {\n+      gsi_prev (&i);\n+      stmt = NULL;\n+    }\n+  return stmt;\n }\n \n /* Return the last statement of an otherwise empty block.  Return NULL\n@@ -2837,14 +2902,14 @@ last_stmt (basic_block bb)\n gimple\n last_and_only_stmt (basic_block bb)\n {\n-  gimple_stmt_iterator i = gsi_last_bb (bb);\n+  gimple_stmt_iterator i = gsi_last_nondebug_bb (bb);\n   gimple last, prev;\n \n   if (gsi_end_p (i))\n     return NULL;\n \n   last = gsi_stmt (i);\n-  gsi_prev (&i);\n+  gsi_prev_nondebug (&i);\n   if (gsi_end_p (i))\n     return last;\n \n@@ -4109,6 +4174,22 @@ verify_gimple_phi (gimple stmt)\n }\n \n \n+/* Verify a gimple debug statement STMT.\n+   Returns true if anything is wrong.  */\n+\n+static bool\n+verify_gimple_debug (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  /* There isn't much that could be wrong in a gimple debug stmt.  A\n+     gimple debug bind stmt, for example, maps a tree, that's usually\n+     a VAR_DECL or a PARM_DECL, but that could also be some scalarized\n+     component or member of an aggregate type, to another tree, that\n+     can be an arbitrary expression.  These stmts expand into debug\n+     insns, and are converted to debug notes by var-tracking.c.  */\n+  return false;\n+}\n+\n+\n /* Verify the GIMPLE statement STMT.  Returns true if there is an\n    error, otherwise false.  */\n \n@@ -4163,6 +4244,9 @@ verify_types_in_gimple_stmt (gimple stmt)\n     case GIMPLE_PREDICT:\n       return false;\n \n+    case GIMPLE_DEBUG:\n+      return verify_gimple_debug (stmt);\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -4269,6 +4353,9 @@ verify_stmt (gimple_stmt_iterator *gsi)\n \t}\n     }\n \n+  if (is_gimple_debug (stmt))\n+    return false;\n+\n   memset (&wi, 0, sizeof (wi));\n   addr = walk_gimple_op (gsi_stmt (*gsi), verify_expr, &wi);\n   if (addr)\n@@ -6618,7 +6705,7 @@ debug_loop_num (unsigned num, int verbosity)\n static bool\n gimple_block_ends_with_call_p (basic_block bb)\n {\n-  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gimple_stmt_iterator gsi = gsi_last_nondebug_bb (bb);\n   return is_gimple_call (gsi_stmt (gsi));\n }\n \n@@ -6924,8 +7011,12 @@ remove_edge_and_dominated_blocks (edge e)\n     remove_edge (e);\n   else\n     {\n-      for (i = 0; VEC_iterate (basic_block, bbs_to_remove, i, bb); i++)\n-\tdelete_basic_block (bb);\n+      /* Walk backwards so as to get a chance to substitute all\n+\t released DEFs into debug stmts.  See\n+\t eliminate_unnecessary_stmts() in tree-ssa-dce.c for more\n+\t details.  */\n+      for (i = VEC_length (basic_block, bbs_to_remove); i-- > 0; )\n+\tdelete_basic_block (VEC_index (basic_block, bbs_to_remove, i));\n     }\n \n   /* Update the dominance information.  The immediate dominator may change only"}, {"sha": "5cce1b6eec7f58937865a763f813010521f6a12e", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -252,6 +252,11 @@ tree_forwarder_block_p (basic_block bb, bool phi_wanted)\n \t    return false;\n \t  break;\n \n+\t  /* ??? For now, hope there's a corresponding debug\n+\t     assignment at the destination.  */\n+\tcase GIMPLE_DEBUG:\n+\t  break;\n+\n \tdefault:\n \t  return false;\n \t}\n@@ -415,9 +420,10 @@ remove_forwarder_block (basic_block bb)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n \t  label = gsi_stmt (gsi);\n-\t  gcc_assert (gimple_code (label) == GIMPLE_LABEL);\n+\t  gcc_assert (gimple_code (label) == GIMPLE_LABEL\n+\t\t      || is_gimple_debug (label));\n \t  gsi_remove (&gsi, false);\n-\t  gsi_insert_before (&gsi_to, label, GSI_CONTINUE_LINKING);\n+\t  gsi_insert_before (&gsi_to, label, GSI_SAME_STMT);\n \t}\n     }\n "}, {"sha": "b6eff5ea8f16b8cd2764e00f7d25015f60f99762", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -88,7 +88,12 @@ find_referenced_vars (void)\n   FOR_EACH_BB (bb)\n     {\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-\tfind_referenced_vars_in (gsi_stmt (si));\n+\t{\n+\t  gimple stmt = gsi_stmt (si);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\t  find_referenced_vars_in (gsi_stmt (si));\n+\t}\n \n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n \tfind_referenced_vars_in (gsi_stmt (si));"}, {"sha": "d9baf711379526c6bf97c6601e78cf075706e73c", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -2823,7 +2823,7 @@ tree_empty_eh_handler_p (basic_block bb)\n   region = gimple_resx_region (gsi_stmt (gsi));\n \n   /* filter_object set.  */\n-  gsi_prev (&gsi);\n+  gsi_prev_nondebug (&gsi);\n   if (gsi_end_p (gsi))\n     return 0;\n   if (gimple_code (gsi_stmt (gsi)) == GIMPLE_ASSIGN)\n@@ -2836,7 +2836,7 @@ tree_empty_eh_handler_p (basic_block bb)\n       filter_tmp = gimple_assign_rhs1 (gsi_stmt (gsi));\n \n       /* filter_object set.  */\n-      gsi_prev (&gsi);\n+      gsi_prev_nondebug (&gsi);\n       if (gsi_end_p (gsi))\n \treturn 0;\n       if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n@@ -2848,7 +2848,7 @@ tree_empty_eh_handler_p (basic_block bb)\n       /* exc_ptr get.  */\n       if (TREE_CODE (exc_ptr_tmp) != EXC_PTR_EXPR)\n \t{\n-\t  gsi_prev (&gsi);\n+\t  gsi_prev_nondebug (&gsi);\n \t  if (gsi_end_p (gsi))\n \t    return 0;\n \t  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n@@ -2864,7 +2864,7 @@ tree_empty_eh_handler_p (basic_block bb)\n       /* filter_object get.  */\n       if (TREE_CODE (filter_tmp) != FILTER_EXPR)\n \t{\n-\t  gsi_prev (&gsi);\n+\t  gsi_prev_nondebug (&gsi);\n \t  if (gsi_end_p (gsi))\n \t    return 0;\n \t  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n@@ -2878,7 +2878,7 @@ tree_empty_eh_handler_p (basic_block bb)\n \t}\n \n       /* label.  */\n-      gsi_prev (&gsi);\n+      gsi_prev_nondebug (&gsi);\n       if (gsi_end_p (gsi))\n \treturn 0;\n     }"}, {"sha": "eef2f4324a999e7f3f9ce548d56583585dd326ef", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -358,52 +358,102 @@ next_readonly_imm_use (imm_use_iterator *imm)\n   return imm->imm_use;\n }\n \n-/* Return true if VAR has no uses.  */\n+/* tree-cfg.c */\n+extern bool has_zero_uses_1 (const ssa_use_operand_t *head);\n+extern bool single_imm_use_1 (const ssa_use_operand_t *head,\n+\t\t\t      use_operand_p *use_p, gimple *stmt);\n+\n+/* Return true if VAR has no nondebug uses.  */\n static inline bool\n has_zero_uses (const_tree var)\n {\n   const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n-  /* A single use means there is no items in the list.  */\n-  return (ptr == ptr->next);\n+\n+  /* A single use_operand means there is no items in the list.  */\n+  if (ptr == ptr->next)\n+    return true;\n+\n+  /* If there are debug stmts, we have to look at each use and see\n+     whether there are any nondebug uses.  */\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return false;\n+\n+  return has_zero_uses_1 (ptr);\n }\n \n-/* Return true if VAR has a single use.  */\n+/* Return true if VAR has a single nondebug use.  */\n static inline bool\n has_single_use (const_tree var)\n {\n   const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n-  /* A single use means there is one item in the list.  */\n-  return (ptr != ptr->next && ptr == ptr->next->next);\n+\n+  /* If there aren't any uses whatsoever, we're done.  */\n+  if (ptr == ptr->next)\n+    return false;\n+\n+  /* If there's a single use, check that it's not a debug stmt.  */\n+  if (ptr == ptr->next->next)\n+    return !is_gimple_debug (USE_STMT (ptr->next));\n+\n+  /* If there are debug stmts, we have to look at each of them.  */\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return false;\n+\n+  return single_imm_use_1 (ptr, NULL, NULL);\n }\n \n \n-/* If VAR has only a single immediate use, return true, and set USE_P and STMT\n-   to the use pointer and stmt of occurrence.  */\n+/* If VAR has only a single immediate nondebug use, return true, and\n+   set USE_P and STMT to the use pointer and stmt of occurrence.  */\n static inline bool\n single_imm_use (const_tree var, use_operand_p *use_p, gimple *stmt)\n {\n   const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n-  if (ptr != ptr->next && ptr == ptr->next->next)\n+\n+  /* If there aren't any uses whatsoever, we're done.  */\n+  if (ptr == ptr->next)\n     {\n-      *use_p = ptr->next;\n-      *stmt = ptr->next->loc.stmt;\n-      return true;\n+    return_false:\n+      *use_p = NULL_USE_OPERAND_P;\n+      *stmt = NULL;\n+      return false;\n     }\n-  *use_p = NULL_USE_OPERAND_P;\n-  *stmt = NULL;\n-  return false;\n+\n+  /* If there's a single use, check that it's not a debug stmt.  */\n+  if (ptr == ptr->next->next)\n+    {\n+      if (!is_gimple_debug (USE_STMT (ptr->next)))\n+\t{\n+\t  *use_p = ptr->next;\n+\t  *stmt = ptr->next->loc.stmt;\n+\t  return true;\n+\t}\n+      else\n+\tgoto return_false;\n+    }\n+\n+  /* If there are debug stmts, we have to look at each of them.  */\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    goto return_false;\n+\n+  return single_imm_use_1 (ptr, use_p, stmt);\n }\n \n-/* Return the number of immediate uses of VAR.  */\n+/* Return the number of nondebug immediate uses of VAR.  */\n static inline unsigned int\n num_imm_uses (const_tree var)\n {\n   const ssa_use_operand_t *const start = &(SSA_NAME_IMM_USE_NODE (var));\n   const ssa_use_operand_t *ptr;\n   unsigned int num = 0;\n \n-  for (ptr = start->next; ptr != start; ptr = ptr->next)\n-     num++;\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    for (ptr = start->next; ptr != start; ptr = ptr->next)\n+      num++;\n+  else\n+    for (ptr = start->next; ptr != start; ptr = ptr->next)\n+      if (!is_gimple_debug (USE_STMT (ptr)))\n+\tnum++;\n \n   return num;\n }"}, {"sha": "11b67120e390b6d664d83d871a56bfd6b59f82c0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -636,6 +636,10 @@ typedef bool (*walk_use_def_chains_fn) (tree, gimple, void *);\n \n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n \n+void propagate_defs_into_debug_stmts (gimple, basic_block,\n+\t\t\t\t  const gimple_stmt_iterator *);\n+void propagate_var_def_into_debug_stmts (tree, basic_block,\n+\t\t\t\t\t  const gimple_stmt_iterator *);\n \n /* In tree-into-ssa.c  */\n void update_ssa (unsigned);"}, {"sha": "7f00a63453fc1da6ec04028ffc47dc0054f70947", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -239,6 +239,15 @@ tree_if_convert_stmt (struct loop *  loop, gimple t, tree cond,\n     case GIMPLE_LABEL:\n       break;\n \n+    case GIMPLE_DEBUG:\n+      /* ??? Should there be conditional GIMPLE_DEBUG_BINDs?  */\n+      if (gimple_debug_bind_p (gsi_stmt (*gsi)))\n+\t{\n+\t  gimple_debug_bind_reset_value (gsi_stmt (*gsi));\n+\t  update_stmt (gsi_stmt (*gsi));\n+\t}\n+      break;\n+\n     case GIMPLE_ASSIGN:\n       /* This GIMPLE_ASSIGN is killing previous value of LHS. Appropriate\n \t value will be selected by PHI node based on condition. It is possible\n@@ -423,8 +432,10 @@ if_convertible_stmt_p (struct loop *loop, basic_block bb, gimple stmt)\n     case GIMPLE_LABEL:\n       break;\n \n-    case GIMPLE_ASSIGN:\n+    case GIMPLE_DEBUG:\n+      break;\n \n+    case GIMPLE_ASSIGN:\n       if (!if_convertible_gimple_assign_stmt_p (loop, bb, stmt))\n \treturn false;\n       break;"}, {"sha": "fbd973b4281405f07c261489ba87e2d5c98004d6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 261, "deletions": 53, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -147,6 +147,30 @@ insert_decl_map (copy_body_data *id, tree key, tree value)\n     *pointer_map_insert (id->decl_map, value) = value;\n }\n \n+/* Insert a tree->tree mapping for ID.  This is only used for\n+   variables.  */\n+\n+static void\n+insert_debug_decl_map (copy_body_data *id, tree key, tree value)\n+{\n+  if (!gimple_in_ssa_p (id->src_cfun))\n+    return;\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  if (!target_for_debug_bind (key))\n+    return;\n+\n+  gcc_assert (TREE_CODE (key) == PARM_DECL);\n+  gcc_assert (TREE_CODE (value) == VAR_DECL);\n+\n+  if (!id->debug_map)\n+    id->debug_map = pointer_map_create ();\n+\n+  *pointer_map_insert (id->debug_map, key) = value;\n+}\n+\n /* Construct new SSA name for old NAME. ID is the inline context.  */\n \n static tree\n@@ -220,6 +244,12 @@ remap_ssa_name (tree name, copy_body_data *id)\n   return new_tree;\n }\n \n+/* If nonzero, we're remapping the contents of inlined debug\n+   statements.  If negative, an error has occurred, such as a\n+   reference to a variable that isn't available in the inlined\n+   context.  */\n+int processing_debug_stmt = 0;\n+\n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n tree\n@@ -235,6 +265,12 @@ remap_decl (tree decl, copy_body_data *id)\n \n   n = (tree *) pointer_map_contains (id->decl_map, decl);\n \n+  if (!n && processing_debug_stmt)\n+    {\n+      processing_debug_stmt = -1;\n+      return decl;\n+    }\n+\n   /* If we didn't already have an equivalent for this declaration,\n      create one now.  */\n   if (!n)\n@@ -812,7 +848,8 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t vars.  If not referenced from types only.  */\n       if (gimple_in_ssa_p (cfun)\n \t  && TREE_CODE (*tp) == VAR_DECL\n-\t  && id->remapping_type_depth == 0)\n+\t  && id->remapping_type_depth == 0\n+\t  && !processing_debug_stmt)\n \tadd_referenced_var (*tp);\n \n       /* We should never have TREE_BLOCK set on non-statements.  */\n@@ -1043,10 +1080,11 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n       copy_tree_r (tp, walk_subtrees, NULL);\n \n       /* Global variables we haven't seen yet needs to go into referenced\n-\t vars.  If not referenced from types only.  */\n+\t vars.  If not referenced from types or debug stmts only.  */\n       if (gimple_in_ssa_p (cfun)\n \t  && TREE_CODE (*tp) == VAR_DECL\n-\t  && id->remapping_type_depth == 0)\n+\t  && id->remapping_type_depth == 0\n+\t  && !processing_debug_stmt)\n \tadd_referenced_var (*tp);\n        \n       /* If EXPR has block defined, map it to newly constructed block.\n@@ -1292,8 +1330,17 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t    }\n \t}\n \n-      /* Create a new deep copy of the statement.  */\n-      copy = gimple_copy (stmt);\n+      if (gimple_debug_bind_p (stmt))\n+\t{\n+\t  copy = gimple_build_debug_bind (gimple_debug_bind_get_var (stmt),\n+\t\t\t\t\t  gimple_debug_bind_get_value (stmt),\n+\t\t\t\t\t  stmt);\n+\t  VEC_safe_push (gimple, heap, id->debug_stmts, copy);\n+\t  return copy;\n+\t}\n+      else\n+\t/* Create a new deep copy of the statement.  */\n+\tcopy = gimple_copy (stmt);\n     }\n \n   /* If STMT has a block defined, map it to the newly constructed\n@@ -1310,6 +1357,9 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \n   gimple_set_block (copy, new_block);\n \n+  if (gimple_debug_bind_p (copy))\n+    return copy;\n+\n   /* Remap all the operands in COPY.  */\n   memset (&wi, 0, sizeof (wi));\n   wi.info = id;\n@@ -1604,7 +1654,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\tadd_stmt_to_eh_region (stmt, id->eh_region);\n \t    }\n \n-\t  if (gimple_in_ssa_p (cfun))\n+\t  if (gimple_in_ssa_p (cfun) && !is_gimple_debug (stmt))\n \t    {\n \t      ssa_op_iter i;\n \t      tree def;\n@@ -1733,9 +1783,12 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)\n       bool can_throw, nonlocal_goto;\n \n       copy_stmt = gsi_stmt (si);\n-      update_stmt (copy_stmt);\n-      if (gimple_in_ssa_p (cfun))\n-        mark_symbols_for_renaming (copy_stmt);\n+      if (!is_gimple_debug (copy_stmt))\n+\t{\n+\t  update_stmt (copy_stmt);\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    mark_symbols_for_renaming (copy_stmt);\n+\t}\n \n       /* Do this before the possible split_block.  */\n       gsi_next (&si);\n@@ -2011,6 +2064,82 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n   return new_fndecl;\n }\n \n+/* Copy the debug STMT using ID.  We deal with these statements in a\n+   special way: if any variable in their VALUE expression wasn't\n+   remapped yet, we won't remap it, because that would get decl uids\n+   out of sync, causing codegen differences between -g and -g0.  If\n+   this arises, we drop the VALUE expression altogether.  */\n+\n+static void\n+copy_debug_stmt (gimple stmt, copy_body_data *id)\n+{\n+  tree t, *n;\n+  struct walk_stmt_info wi;\n+\n+  t = id->block;\n+  if (gimple_block (stmt))\n+    {\n+      tree *n;\n+      n = (tree *) pointer_map_contains (id->decl_map, gimple_block (stmt));\n+      if (n)\n+\tt = *n;\n+    }\n+  gimple_set_block (stmt, t);\n+\n+  /* Remap all the operands in COPY.  */\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = id;\n+\n+  processing_debug_stmt = 1;\n+\n+  t = gimple_debug_bind_get_var (stmt);\n+\n+  if (TREE_CODE (t) == PARM_DECL && id->debug_map\n+      && (n = (tree *) pointer_map_contains (id->debug_map, t)))\n+    {\n+      gcc_assert (TREE_CODE (*n) == VAR_DECL);\n+      t = *n;\n+    }\n+  else\n+    walk_tree (&t, remap_gimple_op_r, &wi, NULL);\n+\n+  gimple_debug_bind_set_var (stmt, t);\n+\n+  if (gimple_debug_bind_has_value_p (stmt))\n+    walk_tree (gimple_debug_bind_get_value_ptr (stmt),\n+\t       remap_gimple_op_r, &wi, NULL);\n+\n+  /* Punt if any decl couldn't be remapped.  */\n+  if (processing_debug_stmt < 0)\n+    gimple_debug_bind_reset_value (stmt);\n+\n+  processing_debug_stmt = 0;\n+\n+  update_stmt (stmt);\n+  if (gimple_in_ssa_p (cfun))\n+    mark_symbols_for_renaming (stmt);\n+}\n+\n+/* Process deferred debug stmts.  In order to give values better odds\n+   of being successfully remapped, we delay the processing of debug\n+   stmts until all other stmts that might require remapping are\n+   processed.  */\n+\n+static void\n+copy_debug_stmts (copy_body_data *id)\n+{\n+  size_t i;\n+  gimple stmt;\n+\n+  if (!id->debug_stmts)\n+    return;\n+\n+  for (i = 0; VEC_iterate (gimple, id->debug_stmts, i, stmt); i++)\n+    copy_debug_stmt (stmt, id);\n+\n+  VEC_free (gimple, heap, id->debug_stmts);\n+}\n+\n /* Make a copy of the body of SRC_FN so that it can be inserted inline in\n    another function.  */\n \n@@ -2025,6 +2154,9 @@ copy_tree_body (copy_body_data *id)\n   return body;\n }\n \n+/* Make a copy of the body of FN so that it can be inserted inline in\n+   another function.  */\n+\n static tree\n copy_body (copy_body_data *id, gcov_type count, int frequency,\n \t   basic_block entry_block_map, basic_block exit_block_map)\n@@ -2035,6 +2167,7 @@ copy_body (copy_body_data *id, gcov_type count, int frequency,\n   /* If this body has a CFG, walk CFG and copy.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fndecl)));\n   body = copy_cfg_body (id, count, frequency, entry_block_map, exit_block_map);\n+  copy_debug_stmts (id);\n \n   return body;\n }\n@@ -2055,8 +2188,51 @@ self_inlining_addr_expr (tree value, tree fn)\n   return var && auto_var_in_fn_p (var, fn);\n }\n \n+/* Append to BB a debug annotation that binds VAR to VALUE, inheriting\n+   lexical block and line number information from base_stmt, if given,\n+   or from the last stmt of the block otherwise.  */\n+\n+static gimple\n+insert_init_debug_bind (copy_body_data *id,\n+\t\t\tbasic_block bb, tree var, tree value,\n+\t\t\tgimple base_stmt)\n+{\n+  gimple note;\n+  gimple_stmt_iterator gsi;\n+  tree tracked_var;\n+\n+  if (!gimple_in_ssa_p (id->src_cfun))\n+    return NULL;\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return NULL;\n+\n+  tracked_var = target_for_debug_bind (var);\n+  if (!tracked_var)\n+    return NULL;\n+\n+  if (bb)\n+    {\n+      gsi = gsi_last_bb (bb);\n+      if (!base_stmt && !gsi_end_p (gsi))\n+\tbase_stmt = gsi_stmt (gsi);\n+    }\n+\n+  note = gimple_build_debug_bind (tracked_var, value, base_stmt);\n+\n+  if (bb)\n+    {\n+      if (!gsi_end_p (gsi))\n+\tgsi_insert_after (&gsi, note, GSI_SAME_STMT);\n+      else\n+\tgsi_insert_before (&gsi, note, GSI_SAME_STMT);\n+    }\n+\n+  return note;\n+}\n+\n static void\n-insert_init_stmt (basic_block bb, gimple init_stmt)\n+insert_init_stmt (copy_body_data *id, basic_block bb, gimple init_stmt)\n {\n   /* If VAR represents a zero-sized variable, it's possible that the\n      assignment statement may result in no gimple statements.  */\n@@ -2068,7 +2244,8 @@ insert_init_stmt (basic_block bb, gimple init_stmt)\n          from a rhs with a conversion.  Handle that here by forcing the\n \t rhs into a temporary.  gimple_regimplify_operands is not\n \t prepared to do this for us.  */\n-      if (!is_gimple_reg (gimple_assign_lhs (init_stmt))\n+      if (!is_gimple_debug (init_stmt)\n+\t  && !is_gimple_reg (gimple_assign_lhs (init_stmt))\n \t  && is_gimple_reg_type (TREE_TYPE (gimple_assign_lhs (init_stmt)))\n \t  && gimple_assign_rhs_class (init_stmt) == GIMPLE_UNARY_RHS)\n \t{\n@@ -2083,6 +2260,18 @@ insert_init_stmt (basic_block bb, gimple init_stmt)\n       gsi_insert_after (&si, init_stmt, GSI_NEW_STMT);\n       gimple_regimplify_operands (init_stmt, &si);\n       mark_symbols_for_renaming (init_stmt);\n+\n+      if (!is_gimple_debug (init_stmt) && MAY_HAVE_DEBUG_STMTS)\n+\t{\n+\t  tree var, def = gimple_assign_lhs (init_stmt);\n+\n+\t  if (TREE_CODE (def) == SSA_NAME)\n+\t    var = SSA_NAME_VAR (def);\n+\t  else\n+\t    var = def;\n+\n+\t  insert_init_debug_bind (id, bb, var, def, init_stmt);\n+\t}\n     }\n }\n \n@@ -2113,9 +2302,29 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \trhs = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (p), value);\n     }\n \n+  /* Make an equivalent VAR_DECL.  Note that we must NOT remap the type\n+     here since the type of this decl must be visible to the calling\n+     function.  */\n+  var = copy_decl_to_var (p, id);\n+\n+  /* We're actually using the newly-created var.  */\n+  if (gimple_in_ssa_p (cfun) && TREE_CODE (var) == VAR_DECL)\n+    {\n+      get_var_ann (var);\n+      add_referenced_var (var);\n+    }\n+\n+  /* Declare this new variable.  */\n+  TREE_CHAIN (var) = *vars;\n+  *vars = var;\n+\n+  /* Make gimplifier happy about this variable.  */\n+  DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n+\n   /* If the parameter is never assigned to, has no SSA_NAMEs created,\n-     we may not need to create a new variable here at all.  Instead, we may\n-     be able to just use the argument value.  */\n+     we would not need to create a new variable here at all, if it\n+     weren't for debug info.  Still, we can just use the argument\n+     value.  */\n   if (TREE_READONLY (p)\n       && !TREE_ADDRESSABLE (p)\n       && value && !TREE_SIDE_EFFECTS (value)\n@@ -2136,32 +2345,16 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t  && ! self_inlining_addr_expr (value, fn))\n \t{\n \t  insert_decl_map (id, p, value);\n-\t  return NULL;\n+\t  insert_debug_decl_map (id, p, var);\n+\t  return insert_init_debug_bind (id, bb, var, value, NULL);\n \t}\n     }\n \n-  /* Make an equivalent VAR_DECL.  Note that we must NOT remap the type\n-     here since the type of this decl must be visible to the calling\n-     function.  */\n-  var = copy_decl_to_var (p, id);\n-  if (gimple_in_ssa_p (cfun) && TREE_CODE (var) == VAR_DECL)\n-    {\n-      get_var_ann (var);\n-      add_referenced_var (var);\n-    }\n-\n   /* Register the VAR_DECL as the equivalent for the PARM_DECL;\n      that way, when the PARM_DECL is encountered, it will be\n      automatically replaced by the VAR_DECL.  */\n   insert_decl_map (id, p, var);\n \n-  /* Declare this new variable.  */\n-  TREE_CHAIN (var) = *vars;\n-  *vars = var;\n-\n-  /* Make gimplifier happy about this variable.  */\n-  DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n-\n   /* Even if P was TREE_READONLY, the new VAR should not be.\n      In the original code, we would have constructed a\n      temporary, and then the function body would have never\n@@ -2183,15 +2376,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \n      Do replacement at -O0 for const arguments replaced by constant.\n      This is important for builtin_constant_p and other construct requiring\n-     constant argument to be visible in inlined function body.\n-\n-     FIXME: This usually kills the last connection in between inlined\n-     function parameter and the actual value in debug info.  Can we do\n-     better here?  If we just inserted the statement, copy propagation\n-     would kill it anyway as it always did in older versions of GCC.\n-\n-     We might want to introduce a notion that single SSA_NAME might\n-     represent multiple variables for purposes of debugging. */\n+     constant argument to be visible in inlined function body.  */\n   if (gimple_in_ssa_p (cfun) && rhs && def && is_gimple_reg (p)\n       && (optimize\n           || (TREE_READONLY (p)\n@@ -2201,15 +2386,15 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n       && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def))\n     {\n       insert_decl_map (id, def, rhs);\n-      return NULL;\n+      return insert_init_debug_bind (id, bb, var, rhs, NULL);\n     }\n \n   /* If the value of argument is never used, don't care about initializing\n      it.  */\n   if (optimize && gimple_in_ssa_p (cfun) && !def && is_gimple_reg (p))\n     {\n       gcc_assert (!value || !TREE_SIDE_EFFECTS (value));\n-      return NULL;\n+      return insert_init_debug_bind (id, bb, var, rhs, NULL);\n     }\n \n   /* Initialize this VAR_DECL from the equivalent argument.  Convert\n@@ -2219,7 +2404,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n       if (rhs == error_mark_node)\n \t{\n \t  insert_decl_map (id, p, var);\n-\t  return NULL;\n+\t  return insert_init_debug_bind (id, bb, var, rhs, NULL);\n \t}\n \n       STRIP_USELESS_TYPE_CONVERSION (rhs);\n@@ -2237,7 +2422,7 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n         init_stmt = gimple_build_assign (var, rhs);\n \n       if (bb && init_stmt)\n-        insert_init_stmt (bb, init_stmt);\n+        insert_init_stmt (id, bb, init_stmt);\n     }\n   return init_stmt;\n }\n@@ -3118,6 +3303,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n     case GIMPLE_PHI:\n     case GIMPLE_RETURN:\n     case GIMPLE_PREDICT:\n+    case GIMPLE_DEBUG:\n       return 0;\n \n     case GIMPLE_ASM:\n@@ -3262,7 +3448,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n {\n   tree retvar, use_retvar;\n   tree fn;\n-  struct pointer_map_t *st;\n+  struct pointer_map_t *st, *dst;\n   tree return_slot;\n   tree modify_dest;\n   location_t saved_location;\n@@ -3402,6 +3588,8 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      map.  */\n   st = id->decl_map;\n   id->decl_map = pointer_map_create ();\n+  dst = id->debug_map;\n+  id->debug_map = NULL;\n \n   /* Record the function we are about to inline.  */\n   id->src_fn = fn;\n@@ -3498,6 +3686,11 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n     }\n \n   /* Clean up.  */\n+  if (id->debug_map)\n+    {\n+      pointer_map_destroy (id->debug_map);\n+      id->debug_map = dst;\n+    }\n   pointer_map_destroy (id->decl_map);\n   id->decl_map = st;\n \n@@ -3726,6 +3919,8 @@ optimize_inline_calls (tree fn)\n   fold_marked_statements (last, id.statements_to_fold);\n   pointer_set_destroy (id.statements_to_fold);\n   \n+  gcc_assert (!id.debug_stmts);\n+\n   /* Renumber the (code) basic_blocks consecutively.  */\n   compact_blocks ();\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n@@ -3961,6 +4156,7 @@ unsave_expr_now (tree expr)\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n   id.decl_map = pointer_map_create ();\n+  id.debug_map = NULL;\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -3976,6 +4172,8 @@ unsave_expr_now (tree expr)\n \n   /* Clean up.  */\n   pointer_map_destroy (id.decl_map);\n+  if (id.debug_map)\n+    pointer_map_destroy (id.debug_map);\n \n   return expr;\n }\n@@ -4107,6 +4305,7 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n   id.decl_map = pointer_map_create ();\n+  id.debug_map = NULL;\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -4131,6 +4330,8 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n \n   /* Clean up.  */\n   pointer_map_destroy (id.decl_map);\n+  if (id.debug_map)\n+    pointer_map_destroy (id.debug_map);\n \n   return copy;\n }\n@@ -4506,7 +4707,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   tree p;\n   unsigned i;\n   struct ipa_replace_map *replace_info;\n-  basic_block old_entry_block;\n+  basic_block old_entry_block, bb;\n   VEC (gimple, heap) *init_stmts = VEC_alloc (gimple, heap, 10);\n \n   tree t_step;\n@@ -4534,8 +4735,9 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   /* Generate a new name for the new version. */\n   id.statements_to_fold = pointer_set_create ();\n-  \n+\n   id.decl_map = pointer_map_create ();\n+  id.debug_map = NULL;\n   id.src_fn = old_decl;\n   id.dst_fn = new_decl;\n   id.src_node = old_version_node;\n@@ -4637,12 +4839,12 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n   number_blocks (new_decl);\n \n-  if (VEC_length (gimple, init_stmts))\n-    {\n-      basic_block bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n-      while (VEC_length (gimple, init_stmts))\n-\tinsert_init_stmt (bb, VEC_pop (gimple, init_stmts));\n-    }\n+  /* We want to create the BB unconditionally, so that the addition of\n+     debug stmts doesn't affect BB count, which may in the end cause\n+     codegen differences.  */\n+  bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+  while (VEC_length (gimple, init_stmts))\n+    insert_init_stmt (&id, bb, VEC_pop (gimple, init_stmts));\n   update_clone_info (&id);\n \n   /* Remap the nonlocal_goto_save_area, if any.  */\n@@ -4657,6 +4859,8 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   /* Clean up.  */\n   pointer_map_destroy (id.decl_map);\n+  if (id.debug_map)\n+    pointer_map_destroy (id.debug_map);\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n@@ -4668,6 +4872,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n+  gcc_assert (!id.debug_stmts);\n   VEC_free (gimple, heap, init_stmts);\n   pop_cfun ();\n   current_function_decl = old_current_function_decl;\n@@ -4742,11 +4947,14 @@ build_duplicate_type (tree type)\n   id.dst_fn = current_function_decl;\n   id.src_cfun = cfun;\n   id.decl_map = pointer_map_create ();\n+  id.debug_map = NULL;\n   id.copy_decl = copy_decl_no_change;\n \n   type = remap_type_1 (type, &id);\n \n   pointer_map_destroy (id.decl_map);\n+  if (id.debug_map)\n+    pointer_map_destroy (id.debug_map);\n \n   TYPE_CANONICAL (type) = type;\n "}, {"sha": "f04a3f0a8437b2ecad9e9c9f61ef99c71e565bc5", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_INLINE_H\n #define GCC_TREE_INLINE_H\n \n-#include \"pointer-set.h\"\n+#include \"gimple.h\"\n \n struct cgraph_edge;\n \n@@ -117,6 +117,15 @@ typedef struct copy_body_data\n \n   /* Entry basic block to currently copied body.  */\n   struct basic_block_def *entry_bb;\n+\n+  /* Debug statements that need processing.  */\n+  VEC(gimple,heap) *debug_stmts;\n+\n+  /* A map from local declarations in the inlined function to\n+     equivalents in the function into which it is being inlined, where\n+     the originals have been mapped to a value rather than to a\n+     variable.  */\n+  struct pointer_map_t *debug_map;\n } copy_body_data;\n \n /* Weights of constructions for estimate_num_insns.  */"}, {"sha": "9f06e8c5d0486c97f67ccf816353ac08076d59c9", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 99, "deletions": 7, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -749,6 +749,9 @@ mark_def_sites (basic_block bb, gimple stmt, bitmap kills)\n   set_register_defs (stmt, false);\n   set_rewrite_uses (stmt, false);\n \n+  if (is_gimple_debug (stmt))\n+    return;\n+\n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n@@ -1051,7 +1054,6 @@ mark_phi_for_rewrite (basic_block bb, gimple phi)\n   VEC_replace (gimple_vec, phis_to_rewrite, idx, phis);\n }\n \n-\n /* Insert PHI nodes for variable VAR using the iterated dominance\n    frontier given in PHI_INSERTION_POINTS.  If UPDATE_P is true, this\n    function assumes that the caller is incrementally updating the\n@@ -1118,8 +1120,17 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n \t}\n       else\n \t{\n+\t  tree tracked_var;\n \t  gcc_assert (DECL_P (var));\n \t  phi = create_phi_node (var, bb);\n+\t  if (!update_p && (tracked_var = target_for_debug_bind (var)))\n+\t    {\n+\t      gimple note = gimple_build_debug_bind (tracked_var,\n+\t\t\t\t\t\t     PHI_RESULT (phi),\n+\t\t\t\t\t\t     phi);\n+\t      gimple_stmt_iterator si = gsi_after_labels (bb);\n+\t      gsi_insert_before (&si, note, GSI_SAME_STMT);\n+\t    }\n \t}\n \n       /* Mark this PHI node as interesting for update_ssa.  */\n@@ -1260,11 +1271,12 @@ get_reaching_def (tree var)\n    definition of a variable when a new real or virtual definition is found.  */\n \n static void\n-rewrite_stmt (gimple stmt)\n+rewrite_stmt (gimple_stmt_iterator si)\n {\n   use_operand_p use_p;\n   def_operand_p def_p;\n   ssa_op_iter iter;\n+  gimple stmt = gsi_stmt (si);\n \n   /* If mark_def_sites decided that we don't need to rewrite this\n      statement, ignore it.  */\n@@ -1293,9 +1305,18 @@ rewrite_stmt (gimple stmt)\n     FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, iter, SSA_OP_DEF)\n       {\n \ttree var = DEF_FROM_PTR (def_p);\n+\ttree name = make_ssa_name (var, stmt);\n+\ttree tracked_var;\n \tgcc_assert (DECL_P (var));\n-\tSET_DEF (def_p, make_ssa_name (var, stmt));\n+\tSET_DEF (def_p, name);\n \tregister_new_def (DEF_FROM_PTR (def_p), var);\n+\n+\ttracked_var = target_for_debug_bind (var);\n+\tif (tracked_var)\n+\t  {\n+\t    gimple note = gimple_build_debug_bind (tracked_var, name, stmt);\n+\t    gsi_insert_after (&si, note, GSI_SAME_STMT);\n+\t  }\n       }\n }\n \n@@ -1366,7 +1387,7 @@ rewrite_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n      of a variable when a new real or virtual definition is found.  */\n   if (TEST_BIT (interesting_blocks, bb->index))\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      rewrite_stmt (gsi_stmt (gsi));\n+      rewrite_stmt (gsi);\n \n   /* Step 3.  Visit all the successor blocks of BB looking for PHI nodes.\n      For every PHI node found, add a new argument containing the current\n@@ -1759,6 +1780,38 @@ maybe_replace_use (use_operand_p use_p)\n }\n \n \n+/* Same as maybe_replace_use, but without introducing default stmts,\n+   returning false to indicate a need to do so.  */\n+\n+static inline bool\n+maybe_replace_use_in_debug_stmt (use_operand_p use_p)\n+{\n+  tree rdef = NULL_TREE;\n+  tree use = USE_FROM_PTR (use_p);\n+  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n+\n+  if (symbol_marked_for_renaming (sym))\n+    rdef = get_current_def (sym);\n+  else if (is_old_name (use))\n+    {\n+      rdef = get_current_def (use);\n+      /* We can't assume that, if there's no current definition, the\n+\t default one should be used.  It could be the case that we've\n+\t rearranged blocks so that the earlier definition no longer\n+\t dominates the use.  */\n+      if (!rdef && SSA_NAME_IS_DEFAULT_DEF (use))\n+\trdef = use;\n+    }\n+  else\n+    rdef = use;\n+\n+  if (rdef && rdef != use)\n+    SET_USE (use_p, rdef);\n+\n+  return rdef != NULL_TREE;\n+}\n+\n+\n /* If the operand pointed to by DEF_P is an SSA name in NEW_SSA_NAMES\n    or OLD_SSA_NAMES, or if it is a symbol marked for renaming,\n    register it as the current definition for the names replaced by\n@@ -1825,8 +1878,42 @@ rewrite_update_stmt (gimple stmt)\n   /* Rewrite USES included in OLD_SSA_NAMES and USES whose underlying\n      symbol is marked for renaming.  */\n   if (rewrite_uses_p (stmt))\n-    FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n-      maybe_replace_use (use_p);\n+    {\n+      if (is_gimple_debug (stmt))\n+\t{\n+\t  bool failed = false;\n+\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t    if (!maybe_replace_use_in_debug_stmt (use_p))\n+\t      {\n+\t\tfailed = true;\n+\t\tbreak;\n+\t      }\n+\n+\t  if (failed)\n+\t    {\n+\t      /* DOM sometimes threads jumps in such a way that a\n+\t\t debug stmt ends up referencing a SSA variable that no\n+\t\t longer dominates the debug stmt, but such that all\n+\t\t incoming definitions refer to the same definition in\n+\t\t an earlier dominator.  We could try to recover that\n+\t\t definition somehow, but this will have to do for now.\n+\n+\t\t Introducing a default definition, which is what\n+\t\t maybe_replace_use() would do in such cases, may\n+\t\t modify code generation, for the otherwise-unused\n+\t\t default definition would never go away, modifying SSA\n+\t\t version numbers all over.  */\n+\t      gimple_debug_bind_reset_value (stmt);\n+\t      update_stmt (stmt);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n+\t    maybe_replace_use (use_p);\n+\t}\n+    }\n \n   /* Register definitions of names in NEW_SSA_NAMES and OLD_SSA_NAMES.\n      Also register definitions for names whose underlying symbol is\n@@ -2325,7 +2412,12 @@ mark_use_interesting (tree var, gimple stmt, basic_block bb, bool insert_phi_p)\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     mark_phi_for_rewrite (def_bb, stmt);\n   else\n-    set_rewrite_uses (stmt, true);\n+    {\n+      set_rewrite_uses (stmt, true);\n+\n+      if (is_gimple_debug (stmt))\n+\treturn;\n+    }\n \n   /* If VAR has not been defined in BB, then it is live-on-entry\n      to BB.  Note that we cannot just use the block holding VAR's"}, {"sha": "d3901c34f0e76945de53ee25a3995e7aa63e4985", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,5 +1,6 @@\n /* Convert a program in SSA form into Normal form.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009\n+   Free Software Foundation, Inc.\n    Contributed by Andrew Macleod <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -119,6 +120,8 @@ set_location_for_edge (edge e)\n \t  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n+\t      if (is_gimple_debug (stmt))\n+\t\tcontinue;\n \t      if (gimple_has_location (stmt) || gimple_block (stmt))\n \t\t{\n \t\t  set_curr_insn_source_location (gimple_location (stmt));"}, {"sha": "a6d8f2159142a1eb10d0b820fcb2ebdd4bfa362d", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 91, "deletions": 3, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -508,7 +508,11 @@ eliminate_local_variables_stmt (edge entry, gimple stmt,\n   dta.decl_address = decl_address;\n   dta.changed = false;\n \n-  walk_gimple_op (stmt, eliminate_local_variables_1, &dta.info);\n+  if (gimple_debug_bind_p (stmt))\n+    walk_tree (gimple_debug_bind_get_value_ptr (stmt),\n+\t       eliminate_local_variables_1, &dta.info, NULL);\n+  else\n+    walk_gimple_op (stmt, eliminate_local_variables_1, &dta.info);\n \n   if (dta.changed)\n     update_stmt (stmt);\n@@ -692,6 +696,53 @@ separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n   }\n }\n \n+/* Finds the ssa names used in STMT that are defined outside the\n+   region between ENTRY and EXIT and replaces such ssa names with\n+   their duplicates.  The duplicates are stored to NAME_COPIES.  Base\n+   decls of all ssa names used in STMT (including those defined in\n+   LOOP) are replaced with the new temporary variables; the\n+   replacement decls are stored in DECL_COPIES.  */\n+\n+static bool\n+separate_decls_in_region_debug_bind (gimple stmt,\n+\t\t\t\t     htab_t name_copies, htab_t decl_copies)\n+{\n+  use_operand_p use;\n+  ssa_op_iter oi;\n+  tree var, name;\n+  struct int_tree_map ielt;\n+  struct name_to_copy_elt elt;\n+  void **slot, **dslot;\n+\n+  var = gimple_debug_bind_get_var (stmt);\n+  gcc_assert (DECL_P (var) && SSA_VAR_P (var));\n+  ielt.uid = DECL_UID (var);\n+  dslot = htab_find_slot_with_hash (decl_copies, &ielt, ielt.uid, NO_INSERT);\n+  if (!dslot)\n+    return true;\n+  gimple_debug_bind_set_var (stmt, ((struct int_tree_map *) *dslot)->to);\n+\n+  FOR_EACH_PHI_OR_STMT_USE (use, stmt, oi, SSA_OP_USE)\n+  {\n+    name = USE_FROM_PTR (use);\n+    if (TREE_CODE (name) != SSA_NAME)\n+      continue;\n+\n+    elt.version = SSA_NAME_VERSION (name);\n+    slot = htab_find_slot_with_hash (name_copies, &elt, elt.version, NO_INSERT);\n+    if (!slot)\n+      {\n+\tgimple_debug_bind_reset_value (stmt);\n+\tupdate_stmt (stmt);\n+\tbreak;\n+      }\n+\n+    SET_USE (use, ((struct name_to_copy_elt *) *slot)->new_name);\n+  }\n+\n+  return false;\n+}\n+\n /* Callback for htab_traverse.  Adds a field corresponding to the reduction\n    specified in SLOT. The type is passed in DATA.  */\n \n@@ -1027,6 +1078,7 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n   basic_block bb;\n   basic_block entry_bb = bb1;\n   basic_block exit_bb = exit->dest;\n+  bool has_debug_stmt = false;\n \n   entry = single_succ_edge (entry_bb);\n   gather_blocks_in_sese_region (entry_bb, exit_bb, &body);\n@@ -1040,11 +1092,47 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n \t\t\t\t\t   name_copies, decl_copies);\n \n \t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    separate_decls_in_region_stmt (entry, exit, gsi_stmt (gsi),\n-\t\t\t\t\t   name_copies, decl_copies);\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\n+\t      if (is_gimple_debug (stmt))\n+\t\thas_debug_stmt = true;\n+\t      else\n+\t\tseparate_decls_in_region_stmt (entry, exit, stmt,\n+\t\t\t\t\t       name_copies, decl_copies);\n+\t    }\n \t}\n     }\n \n+  /* Now process debug bind stmts.  We must not create decls while\n+     processing debug stmts, so we defer their processing so as to\n+     make sure we will have debug info for as many variables as\n+     possible (all of those that were dealt with in the loop above),\n+     and discard those for which we know there's nothing we can\n+     do.  */\n+  if (has_debug_stmt)\n+    for (i = 0; VEC_iterate (basic_block, body, i, bb); i++)\n+      if (bb != entry_bb && bb != exit_bb)\n+\t{\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\n+\t      if (gimple_debug_bind_p (stmt))\n+\t\t{\n+\t\t  if (separate_decls_in_region_debug_bind (stmt,\n+\t\t\t\t\t\t\t   name_copies,\n+\t\t\t\t\t\t\t   decl_copies))\n+\t\t    {\n+\t\t      gsi_remove (&gsi, true);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      gsi_next (&gsi);\n+\t    }\n+\t}\n+\n   VEC_free (basic_block, heap, body);\n \n   if (htab_elements (name_copies) == 0 && reduction_list == 0) "}, {"sha": "0164eca7ddbd1842ac55a07d9f862c45c9007308", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -884,6 +884,8 @@ build_ssa_conflict_graph (tree_live_info_p liveinfo)\n                   && TREE_CODE (rhs1) == SSA_NAME)\n \t\tlive_track_clear_var (live, rhs1);\n \t    }\n+\t  else if (is_gimple_debug (stmt))\n+\t    continue;\n \n \t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_DEF)\n \t    live_track_process_def (live, var, graph);\n@@ -1048,6 +1050,9 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n         {\n \t  stmt = gsi_stmt (gsi);\n \n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n \t  /* Register USE and DEF operands in each statement.  */\n \t  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, (SSA_OP_DEF|SSA_OP_USE))\n \t    register_ssa_partition (map, var);"}, {"sha": "99a039fffee59fbf08afcb3d8c25adcbba428ae8", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,5 +1,5 @@\n /* Dead code elimination pass for the GNU compiler.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Ben Elliston <bje@redhat.com>\n    and Andrew MacLeod <amacleod@redhat.com>\n@@ -221,7 +221,7 @@ mark_stmt_necessary (gimple stmt, bool add_to_worklist)\n   gimple_set_plf (stmt, STMT_NECESSARY, true);\n   if (add_to_worklist)\n     VEC_safe_push (gimple, heap, worklist, stmt);\n-  if (bb_contains_live_stmts)\n+  if (bb_contains_live_stmts && !is_gimple_debug (stmt))\n     SET_BIT (bb_contains_live_stmts, gimple_bb (stmt)->index);\n }\n \n@@ -333,6 +333,10 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n \t}\n       break;\n \n+    case GIMPLE_DEBUG:\n+      mark_stmt_necessary (stmt, false);\n+      return;\n+\n     case GIMPLE_GOTO:\n       gcc_assert (!simple_goto_p (stmt));\n       mark_stmt_necessary (stmt, true);\n@@ -1063,7 +1067,6 @@ remove_dead_stmt (gimple_stmt_iterator *i, basic_block bb)\n   release_defs (stmt); \n }\n \n-\n /* Eliminate unnecessary statements. Any instruction not marked as necessary\n    contributes nothing to the program, and can be deleted.  */\n \n@@ -1075,16 +1078,44 @@ eliminate_unnecessary_stmts (void)\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n   tree call;\n+  VEC (basic_block, heap) *h;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEliminating unnecessary statements:\\n\");\n \n   clear_special_calls ();\n \n-  FOR_EACH_BB (bb)\n+  /* Walking basic blocks and statements in reverse order avoids\n+     releasing SSA names before any other DEFs that refer to them are\n+     released.  This helps avoid loss of debug information, as we get\n+     a chance to propagate all RHSs of removed SSAs into debug uses,\n+     rather than only the latest ones.  E.g., consider:\n+\n+     x_3 = y_1 + z_2;\n+     a_5 = x_3 - b_4;\n+     # DEBUG a => a_5\n+\n+     If we were to release x_3 before a_5, when we reached a_5 and\n+     tried to substitute it into the debug stmt, we'd see x_3 there,\n+     but x_3's DEF, type, etc would have already been disconnected.\n+     By going backwards, the debug stmt first changes to:\n+\n+     # DEBUG a => x_3 - b_4\n+\n+     and then to:\n+\n+     # DEBUG a => y_1 + z_2 - b_4\n+\n+     as desired.  */\n+  gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n+  h = get_all_dominated_blocks (CDI_DOMINATORS, single_succ (ENTRY_BLOCK_PTR));\n+\n+  while (VEC_length (basic_block, h))\n     {\n+      bb = VEC_pop (basic_block, h);\n+\n       /* Remove dead statements.  */\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n \t{\n \t  stmt = gsi_stmt (gsi);\n \n@@ -1095,6 +1126,14 @@ eliminate_unnecessary_stmts (void)\n \t    {\n \t      remove_dead_stmt (&gsi, bb);\n \t      something_changed = true;\n+\n+\t      /* If stmt was the last stmt in the block, we want to\n+\t\t move gsi to the stmt that became the last stmt, but\n+\t\t gsi_prev would crash.  */\n+\t      if (gsi_end_p (gsi))\n+\t\tgsi = gsi_last_bb (bb);\n+\t      else\n+\t\tgsi_prev (&gsi);\n \t    }\n \t  else if (is_gimple_call (stmt))\n \t    {\n@@ -1124,24 +1163,29 @@ eliminate_unnecessary_stmts (void)\n \t\t    }\n \t\t  notice_special_calls (stmt);\n \t\t}\n-\t      gsi_next (&gsi);\n+\t      gsi_prev (&gsi);\n \t    }\n \t  else\n-\t    {\n-\t      gsi_next (&gsi);\n-\t    }\n+\t    gsi_prev (&gsi);\n \t}\n     }\n+\n+  VEC_free (basic_block, heap, h);\n+\n   /* Since we don't track liveness of virtual PHI nodes, it is possible that we\n      rendered some PHI nodes unreachable while they are still in use.\n      Mark them for renaming.  */\n   if (cfg_altered)\n     {\n-      basic_block next_bb;\n+      basic_block prev_bb;\n+\n       find_unreachable_blocks ();\n-      for (bb = ENTRY_BLOCK_PTR->next_bb; bb != EXIT_BLOCK_PTR; bb = next_bb)\n+\n+      /* Delete all unreachable basic blocks in reverse dominator order.  */\n+      for (bb = EXIT_BLOCK_PTR->prev_bb; bb != ENTRY_BLOCK_PTR; bb = prev_bb)\n \t{\n-\t  next_bb = bb->next_bb;\n+\t  prev_bb = bb->prev_bb;\n+\n \t  if (!TEST_BIT (bb_contains_live_stmts, bb->index)\n \t      || !(bb->flags & BB_REACHABLE))\n \t    {\n@@ -1165,8 +1209,36 @@ eliminate_unnecessary_stmts (void)\n \t\t    if (found)\n \t\t      mark_virtual_phi_result_for_renaming (gsi_stmt (gsi));\n \t\t  }\n+\n \t      if (!(bb->flags & BB_REACHABLE))\n-\t        delete_basic_block (bb);\n+\t\t{\n+\t\t  /* Speed up the removal of blocks that don't\n+\t\t     dominate others.  Walking backwards, this should\n+\t\t     be the common case.  ??? Do we need to recompute\n+\t\t     dominators because of cfg_altered?  */\n+\t\t  if (!MAY_HAVE_DEBUG_STMTS\n+\t\t      || !first_dom_son (CDI_DOMINATORS, bb))\n+\t\t    delete_basic_block (bb);\n+\t\t  else\n+\t\t    {\n+\t\t      h = get_all_dominated_blocks (CDI_DOMINATORS, bb);\n+\n+\t\t      while (VEC_length (basic_block, h))\n+\t\t\t{\n+\t\t\t  bb = VEC_pop (basic_block, h);\n+\t\t\t  prev_bb = bb->prev_bb;\n+\t\t\t  /* Rearrangements to the CFG may have failed\n+\t\t\t     to update the dominators tree, so that\n+\t\t\t     formerly-dominated blocks are now\n+\t\t\t     otherwise reachable.  */\n+\t\t\t  if (!!(bb->flags & BB_REACHABLE))\n+\t\t\t    continue;\n+\t\t\t  delete_basic_block (bb);\n+\t\t\t}\n+\n+\t\t      VEC_free (basic_block, heap, h);\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "3f7cbfe48746892c9074381f6b9ccbdd74ef9a50", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,5 +1,5 @@\n /* SSA Dominator optimizations for trees\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n@@ -2526,6 +2526,11 @@ propagate_rhs_into_lhs (gimple stmt, tree lhs, tree rhs, bitmap interesting_name\n \t be successful would be if the use occurs in an ASM_EXPR.  */\n       FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n \t{\n+\t  /* Leave debug stmts alone.  If we succeed in propagating\n+\t     all non-debug uses, we'll drop the DEF, and propagation\n+\t     into debug stmts will occur then.  */\n+\t  if (gimple_debug_bind_p (use_stmt))\n+\t    continue;\n \t\n \t  /* It's not always safe to propagate into an ASM_EXPR.  */\n \t  if (gimple_code (use_stmt) == GIMPLE_ASM"}, {"sha": "5aec33415d444b2b30fdd777be4b2ae9b0d897af", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -937,6 +937,7 @@ forward_propagate_addr_expr (tree name, tree rhs)\n   gimple use_stmt;\n   bool all = true;\n   bool single_use_p = has_single_use (name);\n+  bool debug = false;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, iter, name)\n     {\n@@ -947,7 +948,10 @@ forward_propagate_addr_expr (tree name, tree rhs)\n \t there is nothing we can do.  */\n       if (gimple_code (use_stmt) != GIMPLE_ASSIGN)\n \t{\n-\t  all = false;\n+\t  if (is_gimple_debug (use_stmt))\n+\t    debug = true;\n+\t  else\n+\t    all = false;\n \t  continue;\n \t}\n \n@@ -989,6 +993,9 @@ forward_propagate_addr_expr (tree name, tree rhs)\n \t}\n     }\n \n+  if (all && debug)\n+    propagate_var_def_into_debug_stmts (name, NULL, NULL);\n+\n   return all;\n }\n "}, {"sha": "6d2fb32e585c845142e80d0f892f1909886147ae", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -703,6 +703,9 @@ remove_unused_locals (void)\n \t  gimple stmt = gsi_stmt (gsi);\n \t  tree b = gimple_block (stmt);\n \n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n \t  if (b)\n \t    TREE_USED (b) = true;\n \n@@ -988,6 +991,8 @@ set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n \t\tadd_block = e->src;\n \t    }\n \t}\n+      else if (is_gimple_debug (use_stmt))\n+\tcontinue;\n       else\n         {\n \t  /* If its not defined in this block, its live on entry.  */"}, {"sha": "dffaf49ba0615821a68d51040027ee6ba5ba884d", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -90,6 +90,9 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n       if (gimple_code (last) == GIMPLE_LABEL)\n \tcontinue;\n \n+      if (is_gimple_debug (last))\n+\tcontinue;\n+\n       if (is_gimple_call (last))\n \treturn false;\n "}, {"sha": "738249445b0288df7d7f1f9ae49adec1ad2710a3", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -879,6 +879,7 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n       gimple_cond_set_rhs (use_stmt, build_int_cst_type (TREE_TYPE (name), 0));\n \n       gsi_insert_before (bsi, stmt1, GSI_SAME_STMT);\n+      propagate_defs_into_debug_stmts (gsi_stmt (*bsi), NULL, NULL);\n       gsi_replace (bsi, stmt2, true);\n \n       return stmt1;\n@@ -1059,6 +1060,7 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \n       mark_virtual_ops_for_renaming (stmt);\n       gsi_insert_on_edge (loop_preheader_edge (level), stmt);\n+      propagate_defs_into_debug_stmts (gsi_stmt (bsi), NULL, NULL);\n       gsi_remove (&bsi, false);\n     }\n }"}, {"sha": "05988636489ff8149a647aa961dc5ee89e4c9ada", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1849,7 +1849,8 @@ find_interesting_uses (struct ivopts_data *data)\n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \tfind_interesting_uses_stmt (data, gsi_stmt (bsi));\n       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tfind_interesting_uses_stmt (data, gsi_stmt (bsi));\n+\tif (!is_gimple_debug (gsi_stmt (bsi)))\n+\t  find_interesting_uses_stmt (data, gsi_stmt (bsi));\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -5621,7 +5622,24 @@ remove_unused_ivs (struct ivopts_data *data)\n \t  && !info->inv_id\n \t  && !info->iv->have_use_for\n \t  && !info->preserve_biv)\n-\tremove_statement (SSA_NAME_DEF_STMT (info->iv->ssa_name), true);\n+\t{\n+\t  if (MAY_HAVE_DEBUG_STMTS)\n+\t    {\n+\t      gimple stmt;\n+\t      imm_use_iterator iter;\n+\n+\t      FOR_EACH_IMM_USE_STMT (stmt, iter, info->iv->ssa_name)\n+\t\t{\n+\t\t  if (!gimple_debug_bind_p (stmt))\n+\t\t    continue;\n+\n+\t\t  /* ??? We can probably do better than this.  */\n+\t\t  gimple_debug_bind_reset_value (stmt);\n+\t\t  update_stmt (stmt);\n+\t\t}\n+\t    }\n+\t  remove_statement (SSA_NAME_DEF_STMT (info->iv->ssa_name), true);\n+\t}\n     }\n }\n "}, {"sha": "bc5c3392a0fddb0a5b073f7b2d0e4370e2ecb36a", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -279,6 +279,9 @@ find_uses_to_rename_stmt (gimple stmt, bitmap *use_blocks, bitmap need_phis)\n   tree var;\n   basic_block bb = gimple_bb (stmt);\n \n+  if (is_gimple_debug (stmt))\n+    return;\n+\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n     find_uses_to_rename_use (bb, var, use_blocks, need_phis);\n }\n@@ -429,6 +432,9 @@ check_loop_closed_ssa_stmt (basic_block bb, gimple stmt)\n   ssa_op_iter iter;\n   tree var;\n \n+  if (is_gimple_debug (stmt))\n+    return;\n+\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)\n     check_loop_closed_ssa_use (bb, var);\n }"}, {"sha": "ac84fb978b06fd1e323afa28ae6c493bba540668", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1,5 +1,5 @@\n /* SSA operands management for trees.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -635,6 +635,8 @@ add_virtual_operand (gimple stmt ATTRIBUTE_UNUSED, int flags)\n   if (flags & opf_no_vops)\n     return;\n \n+  gcc_assert (!is_gimple_debug (stmt));\n+\n   if (flags & opf_def)\n     append_vdef (gimple_vop (cfun));\n   else\n@@ -722,7 +724,8 @@ get_indirect_ref_operands (gimple stmt, tree expr, int flags,\n \n   /* If requested, add a USE operand for the base pointer.  */\n   if (recurse_on_base)\n-    get_expr_operands (stmt, pptr, opf_use);\n+    get_expr_operands (stmt, pptr,\n+\t\t       opf_use | (flags & opf_no_vops));\n }\n \n \n@@ -846,10 +849,14 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n   enum tree_code code;\n   enum tree_code_class codeclass;\n   tree expr = *expr_p;\n+  int uflags = opf_use;\n \n   if (expr == NULL)\n     return;\n \n+  if (is_gimple_debug (stmt))\n+    uflags |= (flags & opf_no_vops);\n+\n   code = TREE_CODE (expr);\n   codeclass = TREE_CODE_CLASS (code);\n \n@@ -860,7 +867,8 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \t reference to it, but the fact that the statement takes its\n \t address will be of interest to some passes (e.g. alias\n \t resolution).  */\n-      mark_address_taken (TREE_OPERAND (expr, 0));\n+      if (!is_gimple_debug (stmt))\n+\tmark_address_taken (TREE_OPERAND (expr, 0));\n \n       /* If the address is invariant, there may be no interesting\n \t variable references inside.  */\n@@ -914,13 +922,13 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \t  {\n \t    if (TREE_THIS_VOLATILE (TREE_OPERAND (expr, 1)))\n \t      gimple_set_has_volatile_ops (stmt, true);\n-\t    get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_use);\n+\t    get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);\n \t  }\n \telse if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t  {\n-            get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_use);\n-            get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_use);\n-            get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_use);\n+            get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n+            get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);\n+            get_expr_operands (stmt, &TREE_OPERAND (expr, 3), uflags);\n \t  }\n \n \treturn;\n@@ -929,15 +937,15 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR is a pass-through reference to its first argument,\n \t and an rvalue reference to its second argument.  */\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_use);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_use);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_use);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_use);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), uflags);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);\n       return;\n \n     case CONSTRUCTOR:\n@@ -950,7 +958,7 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \tfor (idx = 0;\n \t     VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (expr), idx, ce);\n \t     idx++)\n-\t  get_expr_operands (stmt, &ce->value, opf_use);\n+\t  get_expr_operands (stmt, &ce->value, uflags);\n \n \treturn;\n       }\n@@ -1026,6 +1034,13 @@ parse_ssa_operands (gimple stmt)\n \n   if (code == GIMPLE_ASM)\n     get_asm_expr_operands (stmt);\n+  else if (is_gimple_debug (stmt))\n+    {\n+      if (gimple_debug_bind_p (stmt)\n+\t  && gimple_debug_bind_has_value_p (stmt))\n+\tget_expr_operands (stmt, gimple_debug_bind_get_value_ptr (stmt),\n+\t\t\t   opf_use | opf_no_vops);\n+    }\n   else\n     {\n       size_t i, start = 0;"}, {"sha": "b809ab30f8d44a47ceebbd974afa30bf77476988", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -384,7 +384,12 @@ bool\n empty_block_p (basic_block bb)\n {\n   /* BB must have no executable statements.  */\n-  return gsi_end_p (gsi_after_labels (bb));\n+  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n+  if (gsi_end_p (gsi))\n+    return true;\n+  if (is_gimple_debug (gsi_stmt (gsi)))\n+    gsi_next_nondebug (&gsi);\n+  return gsi_end_p (gsi);\n }\n \n /* Replace PHI node element whose edge is E in block BB with variable NEW."}, {"sha": "ab9cee34a218d37059210081b7618f11e7820cb4", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1170,7 +1170,8 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \n \t      /* Determine what needs to be done to update the SSA form.  */\n \t      update_stmt (stmt);\n-\t      something_changed = true;\n+\t      if (!is_gimple_debug (stmt))\n+\t\tsomething_changed = true;\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "d97f51367e2b4d154fd8f4cfafb72a3c5a67167b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1405,6 +1405,7 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t    {\n \t      stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt1));\n \t      gsirhs1 = gsi_for_stmt (stmt2);\n+\t      propagate_defs_into_debug_stmts (stmt2, gimple_bb (stmt), &gsinow);\n \t      gsi_move_before (&gsirhs1, &gsinow);\n \t      gsi_prev (&gsinow);\n \t      stmt1 = stmt2;\n@@ -1451,6 +1452,7 @@ linearize_expr (gimple stmt)\n \n   gsinow = gsi_for_stmt (stmt);\n   gsirhs = gsi_for_stmt (binrhs);\n+  propagate_defs_into_debug_stmts (binrhs, gimple_bb (stmt), &gsinow);\n   gsi_move_before (&gsirhs, &gsinow);\n \n   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));"}, {"sha": "5b9b4be3090d1dad881c1f5831ae86dc25f8afb8", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -120,6 +120,8 @@ all_immediate_uses_same_place (gimple stmt)\n     {\n       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n         {\n+\t  if (is_gimple_debug (USE_STMT (use_p)))\n+\t    continue;\n \t  if (firstuse == NULL)\n \t    firstuse = USE_STMT (use_p);\n \t  else\n@@ -202,7 +204,7 @@ is_hidden_global_store (gimple stmt)\n /* Find the nearest common dominator of all of the immediate uses in IMM.  */\n \n static basic_block\n-nearest_common_dominator_of_uses (gimple stmt)\n+nearest_common_dominator_of_uses (gimple stmt, bool *debug_stmts)\n {  \n   bitmap blocks = BITMAP_ALLOC (NULL);\n   basic_block commondom;\n@@ -227,6 +229,11 @@ nearest_common_dominator_of_uses (gimple stmt)\n \n \t      useblock = gimple_phi_arg_edge (usestmt, idx)->src;\n \t    }\n+\t  else if (is_gimple_debug (usestmt))\n+\t    {\n+\t      *debug_stmts = true;\n+\t      continue;\n+\t    }\n \t  else\n \t    {\n \t      useblock = gimple_bb (usestmt);\n@@ -272,6 +279,9 @@ statement_sink_location (gimple stmt, basic_block frombb,\n     {\n       FOR_EACH_IMM_USE_FAST (one_use, imm_iter, def)\n \t{\n+\t  if (is_gimple_debug (USE_STMT (one_use)))\n+\t    continue;\n+\n \t  break;\n \t}\n       if (one_use != NULL_USE_OPERAND_P)\n@@ -343,7 +353,9 @@ statement_sink_location (gimple stmt, basic_block frombb,\n      that is where insertion would have to take place.  */\n   if (!all_immediate_uses_same_place (stmt))\n     {\n-      basic_block commondom = nearest_common_dominator_of_uses (stmt);\n+      bool debug_stmts = false;\n+      basic_block commondom = nearest_common_dominator_of_uses (stmt,\n+\t\t\t\t\t\t\t\t&debug_stmts);\n      \n       if (commondom == frombb)\n \treturn false;\n@@ -372,7 +384,12 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \t  fprintf (dump_file, \"Common dominator of all uses is %d\\n\",\n \t\t   commondom->index);\n \t}\n+\n       *togsi = gsi_after_labels (commondom);\n+\n+      if (debug_stmts)\n+\tpropagate_defs_into_debug_stmts (stmt, commondom, togsi);\n+\n       return true;\n     }\n \n@@ -390,6 +407,9 @@ statement_sink_location (gimple stmt, basic_block frombb,\n         return false;\n \n       *togsi = gsi_for_stmt (use);\n+\n+      propagate_defs_into_debug_stmts (stmt, sinkbb, togsi);\n+\n       return true;\n     }\n \n@@ -423,6 +443,8 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \n   *togsi = gsi_after_labels (sinkbb);\n \n+  propagate_defs_into_debug_stmts (stmt, sinkbb, togsi);\n+\n   return true;\n }\n "}, {"sha": "c35d6336beb5f608cad2f6d9ac1737140b21f950", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -585,6 +585,9 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n     {\n       stmt = gsi_stmt (bsi);\n \n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n       stmt_replaceable = is_replaceable_p (stmt);\n \n       /* Determine if this stmt finishes an existing expression.  */"}, {"sha": "1bcf2bf1804f27f8c6ab423987fecf4fe0594738", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -308,7 +308,9 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       stmt = gsi_stmt (gsi);\n \n       /* Ignore empty statements and labels.  */\n-      if (gimple_code (stmt) == GIMPLE_NOP || gimple_code (stmt) == GIMPLE_LABEL)\n+      if (gimple_code (stmt) == GIMPLE_NOP\n+\t  || gimple_code (stmt) == GIMPLE_LABEL\n+\t  || is_gimple_debug (stmt))\n \tcontinue;\n \n       /* If the statement has volatile operands, then we assume we"}, {"sha": "62524bb1460da29b07198abf5822c4868cb1474c", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -478,6 +478,7 @@ redirection_block_p (basic_block bb)\n   gsi = gsi_start_bb (bb);\n   while (!gsi_end_p (gsi)\n          && (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL\n+\t     || is_gimple_debug (gsi_stmt (gsi))\n              || gimple_nop_p (gsi_stmt (gsi))))\n     gsi_next (&gsi);\n   "}, {"sha": "db707fb35a9cfa64735add3a4ed8ba007d1bcd61", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -243,6 +243,207 @@ flush_pending_stmts (edge e)\n   redirect_edge_var_map_clear (e);\n }\n \n+/* Given a tree for an expression for which we might want to emit\n+   locations or values in debug information (generally a variable, but\n+   we might deal with other kinds of trees in the future), return the\n+   tree that should be used as the variable of a DEBUG_BIND STMT or\n+   VAR_LOCATION INSN or NOTE.  Return NULL if VAR is not to be tracked.  */\n+\n+tree\n+target_for_debug_bind (tree var)\n+{\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (var) != VAR_DECL\n+      && TREE_CODE (var) != PARM_DECL)\n+    return NULL_TREE;\n+\n+  if (DECL_HAS_VALUE_EXPR_P (var))\n+    return target_for_debug_bind (DECL_VALUE_EXPR (var));\n+\n+  if (DECL_IGNORED_P (var))\n+    return NULL_TREE;\n+\n+  if (!is_gimple_reg (var))\n+    return NULL_TREE;\n+\n+  return var;\n+}\n+\n+/* Called via walk_tree, look for SSA_NAMEs that have already been\n+   released.  */\n+\n+static tree\n+find_released_ssa_name (tree *tp, int *walk_subtrees, void *data_)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data_;\n+\n+  if (wi->is_lhs)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (*tp) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IN_FREE_LIST (*tp))\n+\treturn *tp;\n+\n+      *walk_subtrees = 0;\n+    }\n+  else if (IS_TYPE_OR_DECL_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Given a VAR whose definition STMT is to be moved to the iterator\n+   position TOGSIP in the TOBB basic block, verify whether we're\n+   moving it across any of the debug statements that use it, and\n+   adjust them as needed.  If TOBB is NULL, then the definition is\n+   understood as being removed, and TOGSIP is unused.  */\n+void\n+propagate_var_def_into_debug_stmts (tree var,\n+\t\t\t\t    basic_block tobb,\n+\t\t\t\t    const gimple_stmt_iterator *togsip)\n+{\n+  imm_use_iterator imm_iter;\n+  gimple stmt;\n+  use_operand_p use_p;\n+  tree value = NULL;\n+  bool no_value = false;\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, var)\n+    {\n+      basic_block bb;\n+      gimple_stmt_iterator si;\n+\n+      if (!is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      if (tobb)\n+\t{\n+\t  bb = gimple_bb (stmt);\n+\n+\t  if (bb != tobb)\n+\t    {\n+\t      gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n+\t      if (dominated_by_p (CDI_DOMINATORS, bb, tobb))\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    {\n+\t      si = *togsip;\n+\n+\t      if (gsi_end_p (si))\n+\t\tcontinue;\n+\n+\t      do\n+\t\t{\n+\t\t  gsi_prev (&si);\n+\t\t  if (gsi_end_p (si))\n+\t\t    break;\n+\t\t}\n+\t      while (gsi_stmt (si) != stmt);\n+\n+\t      if (gsi_end_p (si))\n+\t\tcontinue;\n+\t    }\n+\t}\n+\n+      /* Here we compute (lazily) the value assigned to VAR, but we\n+\t remember if we tried before and failed, so that we don't try\n+\t again.  */\n+      if (!value && !no_value)\n+\t{\n+\t  gimple def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+\t  if (is_gimple_assign (def_stmt))\n+\t    {\n+\t      if (!dom_info_available_p (CDI_DOMINATORS))\n+\t\t{\n+\t\t  struct walk_stmt_info wi;\n+\n+\t\t  memset (&wi, 0, sizeof (wi));\n+\n+\t\t  /* When removing blocks without following reverse\n+\t\t     dominance order, we may sometimes encounter SSA_NAMEs\n+\t\t     that have already been released, referenced in other\n+\t\t     SSA_DEFs that we're about to release.  Consider:\n+\n+\t\t     <bb X>:\n+\t\t     v_1 = foo;\n+\n+\t\t     <bb Y>:\n+\t\t     w_2 = v_1 + bar;\n+\t\t     # DEBUG w => w_2\n+\n+\t\t     If we deleted BB X first, propagating the value of\n+\t\t     w_2 won't do us any good.  It's too late to recover\n+\t\t     their original definition of v_1: when it was\n+\t\t     deleted, it was only referenced in other DEFs, it\n+\t\t     couldn't possibly know it should have been retained,\n+\t\t     and propagating every single DEF just in case it\n+\t\t     might have to be propagated into a DEBUG STMT would\n+\t\t     probably be too wasteful.\n+\n+\t\t     When dominator information is not readily\n+\t\t     available, we check for and accept some loss of\n+\t\t     debug information.  But if it is available,\n+\t\t     there's no excuse for us to remove blocks in the\n+\t\t     wrong order, so we don't even check for dead SSA\n+\t\t     NAMEs.  SSA verification shall catch any\n+\t\t     errors.  */\n+\t\t  if (!walk_gimple_op (def_stmt, find_released_ssa_name, &wi))\n+\t\t    no_value = true;\n+\t\t}\n+\n+\t      if (!no_value)\n+\t\tvalue = gimple_assign_rhs_to_tree (def_stmt);\n+\t    }\n+\n+\t  if (!value)\n+\t    no_value = true;\n+\t}\n+\n+      if (no_value)\n+\tgimple_debug_bind_reset_value (stmt);\n+      else\n+\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t  SET_USE (use_p, unshare_expr (value));\n+\n+      update_stmt (stmt);\n+    }\n+}\n+\n+\n+/* Given a STMT to be moved to the iterator position TOBSIP in the\n+   TOBB basic block, verify whether we're moving it across any of the\n+   debug statements that use it.  If TOBB is NULL, then the definition\n+   is understood as being removed, and TOBSIP is unused.  */\n+\n+void\n+propagate_defs_into_debug_stmts (gimple def, basic_block tobb,\n+\t\t\t\t const gimple_stmt_iterator *togsip)\n+{\n+  ssa_op_iter op_iter;\n+  def_operand_p def_p;\n+\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, def, op_iter, SSA_OP_DEF)\n+    {\n+      tree var = DEF_FROM_PTR (def_p);\n+\n+      if (TREE_CODE (var) != SSA_NAME)\n+\tcontinue;\n+\n+      propagate_var_def_into_debug_stmts (var, tobb, togsip);\n+    }\n+}\n+\n /* Return true if SSA_NAME is malformed and mark it visited.\n \n    IS_VIRTUAL is true if this SSA_NAME was found inside a virtual\n@@ -636,6 +837,9 @@ verify_ssa (bool check_modified_stmt)\n \t\t  goto err;\n \t\t}\n \t    }\n+\t  else if (gimple_debug_bind_p (stmt)\n+\t\t   && !gimple_debug_bind_has_value_p (stmt))\n+\t    continue;\n \n \t  /* Verify the single virtual operand and its constraints.  */\n \t  has_err = false;\n@@ -1480,6 +1684,8 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t{\n \t  struct walk_stmt_info wi;\n \t  data.stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (data.stmt))\n+\t    continue;\n \t  memset (&wi, 0, sizeof (wi));\n \t  wi.info = &data;\n \t  walk_gimple_op (gsi_stmt (gsi), warn_uninitialized_var, &wi);"}, {"sha": "45183218a2c86cf1751e968a56d15e204c4e9556", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -205,6 +205,9 @@ release_ssa_name (tree var)\n       int saved_ssa_name_version = SSA_NAME_VERSION (var);\n       use_operand_p imm = &(SSA_NAME_IMM_USE_NODE (var));\n \n+      if (MAY_HAVE_DEBUG_STMTS)\n+\tpropagate_var_def_into_debug_stmts (var, NULL, NULL);\n+\n #ifdef ENABLE_CHECKING\n       verify_imm_links (stderr, var);\n #endif"}, {"sha": "9e7369fc3c13fee87da73999d675c468aab3a178", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -496,6 +496,9 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t  tree use;\n \t  ssa_op_iter iter;\n \n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\n \t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES)\n \t    {\n \t      if (! bitmap_bit_p (si->va_list_escape_vars,\n@@ -837,6 +840,8 @@ execute_optimize_stdarg (void)\n \t\t    continue;\n \t\t}\n \t    }\n+\t  else if (is_gimple_debug (stmt))\n+\t    continue;\n \n \t  /* All other uses of va_list are either va_copy (that is not handled\n \t     in this optimization), taking address of va_list variable or"}, {"sha": "d1f6dc1488a04020058e03579de4b4c1f6470336", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -395,7 +395,7 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       stmt = gsi_stmt (gsi);\n \n       /* Ignore labels.  */\n-      if (gimple_code (stmt) == GIMPLE_LABEL)\n+      if (gimple_code (stmt) == GIMPLE_LABEL || is_gimple_debug (stmt))\n \tcontinue;\n \n       /* Check for a call.  */\n@@ -501,6 +501,9 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       if (gimple_code (stmt) == GIMPLE_RETURN)\n \tbreak;\n \n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n       if (gimple_code (stmt) != GIMPLE_ASSIGN)\n \treturn;\n "}, {"sha": "c23577034b1dc2706cec33ba88747d3fc2ca6581", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1590,6 +1590,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n     {\n       gimple use_stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n       if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))\n \t  && vinfo_for_stmt (use_stmt)\n \t  && !is_pattern_stmt_p (vinfo_for_stmt (use_stmt)))\n@@ -1642,6 +1644,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple phi,\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n     {\n       gimple use_stmt = USE_STMT (use_p);\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n       if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt))\n \t  && vinfo_for_stmt (use_stmt)\n \t  && !is_pattern_stmt_p (vinfo_for_stmt (use_stmt)))"}, {"sha": "514a3ec661ed9525846b117cca3914a97da27e31", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -4651,6 +4651,9 @@ find_assert_locations_1 (basic_block bb, sbitmap live)\n \n       stmt = gsi_stmt (si);\n \n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+\n       /* See if we can derive an assertion for any of STMT's operands.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n \t{"}, {"sha": "4121af74cccf663a330e46a5f8d8c32133f3ecb8", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d", "patch": "@@ -1532,6 +1532,9 @@ struct GTY(()) tree_constructor {\n #define VL_EXP_OPERAND_LENGTH(NODE) \\\n   ((int)TREE_INT_CST_LOW (VL_EXP_CHECK (NODE)->exp.operands[0]))\n \n+/* Nonzero if is_gimple_debug() may possibly hold.  */\n+#define MAY_HAVE_DEBUG_STMTS    (flag_var_tracking_assignments)\n+\n /* In a LOOP_EXPR node.  */\n #define LOOP_EXPR_BODY(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_EXPR, 0)\n \n@@ -3807,6 +3810,10 @@ extern tree build6_stat (enum tree_code, tree, tree, tree, tree, tree,\n #define build6(c,t1,t2,t3,t4,t5,t6,t7) \\\n   build6_stat (c,t1,t2,t3,t4,t5,t6,t7 MEM_STAT_INFO)\n \n+extern tree build_var_debug_value_stat (tree, tree MEM_STAT_DECL);\n+#define build_var_debug_value(t1,t2) \\\n+  build_var_debug_value_stat (t1,t2 MEM_STAT_INFO)\n+\n extern tree build_int_cst (tree, HOST_WIDE_INT);\n extern tree build_int_cst_type (tree, HOST_WIDE_INT);\n extern tree build_int_cstu (tree, unsigned HOST_WIDE_INT);\n@@ -5209,6 +5216,10 @@ struct GTY(()) tree_priority_map {\n #define tree_priority_map_hash tree_map_base_hash\n #define tree_priority_map_marked_p tree_map_base_marked_p\n \n+/* In tree-ssa.c */\n+\n+tree target_for_debug_bind (tree);\n+\n /* In tree-ssa-ccp.c */\n extern tree maybe_fold_offset_to_reference (location_t, tree, tree, tree);\n extern tree maybe_fold_offset_to_address (location_t, tree, tree, tree);"}, {"sha": "a24755fe07effb8965de5b52967e3557a7db726f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4592, "deletions": 749, "changes": 5341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=b5b8b0ac643d31f9e7fa49a719fa9eda154b2f1d"}]}