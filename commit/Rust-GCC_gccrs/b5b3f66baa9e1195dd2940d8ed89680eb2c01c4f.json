{"sha": "b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjViM2Y2NmJhYTllMTE5NWRkMjk0MGQ4ZWQ4OTY4MGViMmMwMWM0Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-07T15:44:35Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-07T15:44:35Z"}, "message": "2008-11-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* Complete last commit.\n\nFrom-SVN: r141677", "tree": {"sha": "0d3285617f4b2fbb00c086224c557208948f52ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d3285617f4b2fbb00c086224c557208948f52ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f/comments", "author": null, "committer": null, "parents": [{"sha": "8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a"}], "stats": {"total": 184, "additions": 184, "deletions": 0}, "files": [{"sha": "e1b056cdff259b92222a2e9cbdcdace3e786f6dd", "filename": "libstdc++-v3/include/ext/extptr_allocator.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h?ref=b5b3f66baa9e1195dd2940d8ed89680eb2c01c4f", "patch": "@@ -0,0 +1,184 @@\n+// <extptr_allocator.h> -*- C++ -*-\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/**\n+ * @file ext/extptr_allocator.h\n+ * @author Bob Walters\n+ *\n+ * An example allocator which uses an alternative pointer type from\n+ * bits/pointer.h.  Supports test cases which confirm container support\n+ * for alternative pointers.\n+ */\n+\n+#ifndef _EXTPTR_ALLOCATOR_H\n+#define _EXTPTR_ALLOCATOR_H 1\n+\n+#include <memory>\n+#include <limits>\n+#include <ext/pointer.h>\n+\n+using __gnu_cxx::_Pointer_adapter;\n+using __gnu_cxx::_Relative_pointer_impl;\n+\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n+\n+  // forward declaration\n+  template<typename _Tp>\n+    class _ExtPtr_allocator;\n+\n+  // _ExtPtr_allocator<void> specialization.\n+  template<>\n+    class _ExtPtr_allocator<void>\n+    {\n+    public:\n+      typedef size_t      size_type;\n+      typedef ptrdiff_t   difference_type;\n+      typedef void        value_type;\n+\n+      // Note the non-standard pointer types\n+      typedef _Pointer_adapter<_Relative_pointer_impl<void> >       pointer;\n+      typedef _Pointer_adapter<_Relative_pointer_impl<const void> >\n+                                                              const_pointer;\n+\n+      template<typename _Up>\n+        struct rebind\n+        { typedef _ExtPtr_allocator<_Up> other; };\n+    };\n+\n+  /**\n+   * @brief An example allocator which uses a non-standard pointer type.\n+   *\n+   * This allocator specifies that containers use a 'relative pointer' as it's\n+   * pointer type.  (See bits/pointer.h)  Memory allocation in this example\n+   * is still performed using std::allocator.\n+   */\n+  template<typename _Tp>\n+    class _ExtPtr_allocator\n+    {\n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+\n+      // Note the non-standard pointer types.\n+      typedef _Pointer_adapter<_Relative_pointer_impl<_Tp> >       pointer;\n+      typedef _Pointer_adapter<_Relative_pointer_impl<const _Tp> > const_pointer;\n+\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      template<typename _Up>\n+        struct rebind\n+        { typedef _ExtPtr_allocator<_Up> other; };\n+\n+      _ExtPtr_allocator() throw() \n+      : _M_real_alloc() { }\n+\n+      _ExtPtr_allocator(const _ExtPtr_allocator &__rarg) throw()\n+      : _M_real_alloc(__rarg._M_real_alloc) { }\n+\n+      template<class _Up>\n+        _ExtPtr_allocator(const _ExtPtr_allocator<_Up>& __rarg) throw()\n+        : _M_real_alloc(__rarg._M_getUnderlyingImp()) { }\n+\n+      ~_ExtPtr_allocator() throw()\n+      { }\n+\n+      pointer address(reference __x) const\n+      { return &__x; }\n+\n+      const_pointer address(const_reference __x) const\n+      { return &__x; }\n+\n+      pointer allocate(size_type __n, void* __hint = 0)\n+      { return _M_real_alloc.allocate(__n,__hint); }\n+\n+      void deallocate(pointer __p, size_type __n)\n+      { _M_real_alloc.deallocate(__p.get(), __n); }\n+\n+      size_type max_size() const throw()\n+      { return std::numeric_limits<size_type>::max() / sizeof(_Tp); }\n+\n+      void construct(pointer __p, const _Tp& __val)\n+      { ::new(__p.get()) _Tp(__val); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename... _Args>\n+        void\n+        construct(pointer __p, _Args&&... __args)\n+        { ::new(__p.get()) _Tp(std::forward<_Args>(__args)...); }\n+#endif\n+\n+      void destroy(pointer __p)\n+      { __p->~_Tp(); }\n+\n+      template<typename _Up>\n+        inline bool\n+        operator==(const _ExtPtr_allocator<_Up>& __rarg)\n+        { return _M_real_alloc == __rarg._M_getUnderlyingImp(); }\n+\n+      inline bool\n+      operator==(const _ExtPtr_allocator& __rarg)\n+      { return _M_real_alloc == __rarg._M_real_alloc; }\n+\n+      template<typename _Up>\n+        inline bool\n+        operator!=(const _ExtPtr_allocator<_Up>& __rarg)\n+        { return _M_real_alloc != __rarg._M_getUnderlyingImp(); }\n+\n+      inline bool\n+      operator!=(const _ExtPtr_allocator& __rarg)\n+      { return _M_real_alloc != __rarg._M_real_alloc; }\n+\n+      template<typename _Up>\n+        inline friend void\n+        swap(_ExtPtr_allocator<_Up>& __larg, _ExtPtr_allocator<_Up>& __rarg);\n+\n+      // A method specific to this implementation.\n+      const std::allocator<_Tp>&\n+      _M_getUnderlyingImp() const\n+      { return _M_real_alloc; }\n+\n+    private:\n+      // simlated state data.\n+      std::allocator<_Tp>  _M_real_alloc;\n+    };\n+\n+  template<typename _Tp>\n+    inline void\n+    swap(_ExtPtr_allocator<_Tp>& __larg, _ExtPtr_allocator<_Tp>& __rarg)\n+    {\n+      std::allocator<_Tp> temp( __rarg._M_real_alloc );\n+      __rarg._M_real_alloc = __larg._M_real_alloc;\n+      __larg._M_real_alloc = temp;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif /* _EXTPTR_ALLOCATOR_H */"}]}