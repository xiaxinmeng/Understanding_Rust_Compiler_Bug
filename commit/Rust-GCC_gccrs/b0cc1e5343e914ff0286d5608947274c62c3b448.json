{"sha": "b0cc1e5343e914ff0286d5608947274c62c3b448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjYzFlNTM0M2U5MTRmZjAyODZkNTYwODk0NzI3NGM2MmMzYjQ0OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-04-12T23:44:09Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-04-12T23:44:09Z"}, "message": "Prevent erroneous \"macro had not yet been defined\" messages (PR c++/85385)\n\nPR c++/85385 reports an issue where we emit bogus \"macro had not yet been\ndefined\" notes when a macro is mis-used:\n\n  $ cat test.c\n  #define MACRO(X,Y)\n\n  void test ()\n  {\n    MACRO(42);\n  }\n\n  $ ./xg++ -B. -c test.c\n  test.c:5:11: error: macro \"MACRO\" requires 2 arguments, but only 1 given\n     MACRO(42);\n             ^\n  test.c: In function \u2018void test()\u2019:\n  test.c:5:3: error: \u2018MACRO\u2019 was not declared in this scope\n     MACRO(42);\n     ^~~~~\n  test.c:5:3: note:\n  test.c:1: note: it was later defined here\n   #define MACRO(X,Y)\n\nThe macro *had* been defined, it was merely misused.\n\nThis patch fixes the issue by only issuing the note if the use location\nis before the definition location (using linemap_location_before_p).\n\ngcc/cp/ChangeLog:\n\tPR c++/85385\n\t* name-lookup.c (macro_use_before_def::maybe_make): New function,\n\tchecking that the use is indeed before the definition.\n\t(macro_use_before_def::macro_use_before_def): Make private.\n\t(macro_use_before_def::~macro_use_before_def): Make private.  Move\n\tcheck for UNKNOWN_LOCATION to macro_use_before_def::maybe_make.\n\t(lookup_name_fuzzy): Call macro_use_before_def::maybe_make rather\n\tthan using new directly.\n\ngcc/testsuite/ChangeLog:\n\tPR c++/85385\n\t* g++.dg/diagnostic/macro-arg-count.C: New test.\n\nFrom-SVN: r259360", "tree": {"sha": "6207beaff213a6b74ad72a649609313b2fdda17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6207beaff213a6b74ad72a649609313b2fdda17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0cc1e5343e914ff0286d5608947274c62c3b448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc1e5343e914ff0286d5608947274c62c3b448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0cc1e5343e914ff0286d5608947274c62c3b448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0cc1e5343e914ff0286d5608947274c62c3b448/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc436e10e0b892b6953e19776367170cd982367c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc436e10e0b892b6953e19776367170cd982367c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc436e10e0b892b6953e19776367170cd982367c"}], "stats": {"total": 106, "additions": 96, "deletions": 10}, "files": [{"sha": "5f29b0c82502713032893bfe10ef2a4cf19e79de", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0cc1e5343e914ff0286d5608947274c62c3b448", "patch": "@@ -1,3 +1,14 @@\n+2018-04-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/85385\n+\t* name-lookup.c (macro_use_before_def::maybe_make): New function,\n+\tchecking that the use is indeed before the definition.\n+\t(macro_use_before_def::macro_use_before_def): Make private.\n+\t(macro_use_before_def::~macro_use_before_def): Make private.  Move\n+\tcheck for UNKNOWN_LOCATION to macro_use_before_def::maybe_make.\n+\t(lookup_name_fuzzy): Call macro_use_before_def::maybe_make rather\n+\tthan using new directly.\n+\n 2018-04-12  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/85356 - ICE with pointer to member function."}, {"sha": "3f86cd2f0e2e3c5b5b611540d48e59c15dc6d086", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b0cc1e5343e914ff0286d5608947274c62c3b448", "patch": "@@ -5888,6 +5888,27 @@ consider_binding_level (tree name, best_match <tree, const char *> &bm,\n class macro_use_before_def : public deferred_diagnostic\n {\n  public:\n+  /* Factory function.  Return a new macro_use_before_def instance if\n+     appropriate, or return NULL. */\n+  static macro_use_before_def *\n+  maybe_make (location_t use_loc, cpp_hashnode *macro)\n+  {\n+    source_location def_loc = cpp_macro_definition_location (macro);\n+    if (def_loc == UNKNOWN_LOCATION)\n+      return NULL;\n+\n+    /* We only want to issue a note if the macro was used *before* it was\n+       defined.\n+       We don't want to issue a note for cases where a macro was incorrectly\n+       used, leaving it unexpanded (e.g. by using the wrong argument\n+       count).  */\n+    if (!linemap_location_before_p (line_table, use_loc, def_loc))\n+      return NULL;\n+\n+    return new macro_use_before_def (use_loc, macro);\n+  }\n+\n+ private:\n   /* Ctor.  LOC is the location of the usage.  MACRO is the\n      macro that was used.  */\n   macro_use_before_def (location_t loc, cpp_hashnode *macro)\n@@ -5901,13 +5922,10 @@ class macro_use_before_def : public deferred_diagnostic\n     if (is_suppressed_p ())\n       return;\n \n-    source_location def_loc = cpp_macro_definition_location (m_macro);\n-    if (def_loc != UNKNOWN_LOCATION)\n-      {\n-\tinform (get_location (), \"the macro %qs had not yet been defined\",\n-\t\t(const char *)m_macro->ident.str);\n-\tinform (def_loc, \"it was later defined here\");\n-      }\n+    inform (get_location (), \"the macro %qs had not yet been defined\",\n+\t    (const char *)m_macro->ident.str);\n+    inform (cpp_macro_definition_location (m_macro),\n+\t    \"it was later defined here\");\n   }\n \n  private:\n@@ -5990,12 +6008,13 @@ lookup_name_fuzzy (tree name, enum lookup_name_fuzzy_kind kind, location_t loc)\n     bm.consider ((const char *)best_macro->ident.str);\n   else if (bmm.get_best_distance () == 0)\n     {\n-      /* If we have an exact match for a macro name, then the\n-\t macro has been used before it was defined.  */\n+      /* If we have an exact match for a macro name, then either the\n+\t macro was used with the wrong argument count, or the macro\n+\t has been used before it was defined.  */\n       cpp_hashnode *macro = bmm.blithely_get_best_candidate ();\n       if (macro && (macro->flags & NODE_BUILTIN) == 0)\n \treturn name_hint (NULL,\n-\t\t\t  new macro_use_before_def (loc, macro));\n+\t\t\t  macro_use_before_def::maybe_make (loc, macro));\n     }\n \n   /* Try the \"starts_decl_specifier_p\" keywords to detect"}, {"sha": "ce924a3ae5cc5bcf5fed034cb7dbd17a67a75ebf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b0cc1e5343e914ff0286d5608947274c62c3b448", "patch": "@@ -1,3 +1,8 @@\n+2018-04-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c++/85385\n+\t* g++.dg/diagnostic/macro-arg-count.C: New test.\n+\n 2018-04-12  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/83064"}, {"sha": "12b2dbd3be72fa9541245a029627dcd083b8cb48", "filename": "gcc/testsuite/g++.dg/diagnostic/macro-arg-count.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fmacro-arg-count.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0cc1e5343e914ff0286d5608947274c62c3b448/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fmacro-arg-count.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fmacro-arg-count.C?ref=b0cc1e5343e914ff0286d5608947274c62c3b448", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-fdiagnostics-show-caret\" }\n+\n+#define MACRO_1(X,Y)\n+void test_1 ()\n+{\n+  MACRO_1(42); // { dg-line \"use_of_MACRO_1\" }\n+  // { dg-error \"macro \\\"MACRO_1\\\" requires 2 arguments, but only 1 given\" \"\" { target *-*-* } use_of_MACRO_1 }\n+  /* { dg-begin-multiline-output \"\" }\n+   MACRO_1(42);\n+             ^\n+     { dg-end-multiline-output \"\" } */\n+  // { dg-error \"'MACRO_1' was not declared in this scope\" \"\" { target *-*-* } use_of_MACRO_1 }\n+  /* { dg-begin-multiline-output \"\" }\n+   MACRO_1(42);\n+   ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+  // { dg-bogus \"had not yet been defined\" \"\" { target *-*-* } use_of_MACRO_1 }\n+}\n+\n+#define MACRO_2(X,Y)\n+void test_2 ()\n+{\n+  MACRO_2(1, 2, 3); // { dg-line \"use_of_MACRO_2\" }\n+  // { dg-error \"macro \\\"MACRO_2\\\" passed 3 arguments, but takes just 2\" \"\" { target *-*-* } use_of_MACRO_2 }\n+  /* { dg-begin-multiline-output \"\" }\n+   MACRO_2(1, 2, 3);\n+                  ^\n+     { dg-end-multiline-output \"\" } */\n+  // { dg-error \"'MACRO_2' was not declared in this scope\" \"\" { target *-*-* } use_of_MACRO_2 }\n+  /* { dg-begin-multiline-output \"\" }\n+   MACRO_2(1, 2, 3);\n+   ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+  // { dg-bogus \"had not yet been defined\" \"\" { target *-*-* } use_of_MACRO_2 }\n+}\n+\n+#define MACRO_3\n+void test_3 ()\n+{\n+  MACRO_3 (42);\n+}\n+\n+#define MACRO_4(X,Y)\n+void test_4 ()\n+{\n+  MACRO_4; // { dg-error \"'MACRO_4' was not declared in this scope\" }\n+  /* { dg-begin-multiline-output \"\" }\n+   MACRO_4;\n+   ^~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+}"}]}