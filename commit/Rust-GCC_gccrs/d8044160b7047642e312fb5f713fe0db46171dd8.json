{"sha": "d8044160b7047642e312fb5f713fe0db46171dd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwNDQxNjBiNzA0NzY0MmUzMTJmYjVmNzEzZmUwZGI0NjE3MWRkOA==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2004-06-09T20:10:13Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2004-06-09T20:10:13Z"}, "message": "Index: gcc/ChangeLog\n2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n\n\t* Makefile.in (CPPLIB_H): Put files in order of inclusion.\n\t(CPP_ID_DATA_H): New.\n\t(gtype-desc.o): Update dependencies.\n\t(GTFILES): Use CPP_ID_DATA_H.\n\nIndex: gcc/testsuite/ChangeLog\n2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n\n\t* gcc.dg/pch/macro-4.c: New.\n\t* gcc.dg/pch/macro-4.hs: New.\n\nIndex: libcpp/ChangeLog\n2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n\n\t* traditional.c (push_replacement_text): Set macro->traditional.\n\t(save_replacement_text): Likewise.\n\t* pch.c (cpp_write_pch_state): Don't write list of defined macros.\n\t(struct save_macro_item): Delete.\n\t(struct save_macro_data): Use a character array not the previous\n\tstructured format.\n\t(save_macros): Save macro as text not as internal structures.\n\t(cpp_prepare_state): Update for changes to save_macro_data.\n\t(cpp_read_state): Don't read macros defined in PCH.  Restore\n\t-D macros as text.\n\t* macro.c (create_iso_definition): Honour alloc_subobject.\n\tClear traditional flag.\n\t(_cpp_create_definition): Honour alloc_subobject.\n\t* lex.c (cpp_token_val_index): New.\n\t* internal.h: Include cpp-id-data.h.\n\t(uchar): Move definition to cpp-id-data.h.\n\t(U): Likewise.\n\t(cpp_macro): Likewise.\n\t* directives.c (struct answer): Move to cpp-id-data.h.\n\t(do_assert): Honour alloc_subobject.\n\nIndex: libcpp/include/ChangeLog\n2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n\n\t* symtab.h (struct ht): Add field 'alloc_subobject'.\n\t* cpplib.h (struct cpp_string): Add GTY marker.\n\t(enum cpp_token_fld_kind): New.\n\t(struct cpp_token): Add GTY markers.\n\t(cpp_token_val_index): Prototype.\n\t(CPP_HASHNODE_VALUE_IDX): New.\n\t(struct cpp_hashnode): Don't skip fields of 'value' when marking.\n\t* cpp-id-data.h: New file.\n\nFrom-SVN: r82851", "tree": {"sha": "1238be7fc80d74d8323d5f6c4344a6bb2be0f854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1238be7fc80d74d8323d5f6c4344a6bb2be0f854"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8044160b7047642e312fb5f713fe0db46171dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8044160b7047642e312fb5f713fe0db46171dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8044160b7047642e312fb5f713fe0db46171dd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8044160b7047642e312fb5f713fe0db46171dd8/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "293155b099b94b81fa0147f2719f3da23c859f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/293155b099b94b81fa0147f2719f3da23c859f7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/293155b099b94b81fa0147f2719f3da23c859f7e"}], "stats": {"total": 605, "additions": 372, "deletions": 233}, "files": [{"sha": "7f5e57d0efda91ba01806bb27a0887b4a23298f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -1,3 +1,10 @@\n+2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* Makefile.in (CPPLIB_H): Put files in order of inclusion.\n+\t(CPP_ID_DATA_H): New.\n+\t(gtype-desc.o): Update dependencies.\n+\t(GTFILES): Use CPP_ID_DATA_H.\n+\n 2004-06-09  Mark Mitchell  <mark@codesourcery.com>\n \n \tRevert:"}, {"sha": "fc87854332344e51557d230915a8436d1c9fa65a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -712,10 +712,11 @@ C_COMMON_H = c-common.h $(SPLAY_TREE_H) $(CPPLIB_H)\n C_TREE_H = c-tree.h $(C_COMMON_H)\n SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h\n PREDICT_H = predict.h predict.def\n-CPPLIB_H = $(srcdir)/../libcpp/include/cpplib.h \\\n-\t$(srcdir)/../libcpp/include/line-map.h\n+CPPLIB_H = $(srcdir)/../libcpp/include/line-map.h \\\n+\t$(srcdir)/../libcpp/include/cpplib.h\n MKDEPS_H = $(srcdir)/../libcpp/include/mkdeps.h\n SYMTAB_H = $(srcdir)/../libcpp/include/symtab.h\n+CPP_ID_DATA_H = $(CPPLIB_H) $(srcdir)/../libcpp/include/cpp-id-data.h\n TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)\n TREE_GIMPLE_H = tree-gimple.h tree-iterator.h\n TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n@@ -1522,10 +1523,11 @@ dumpvers: dumpvers.c\n \n version.o: version.c version.h\n \n-gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h \\\n-\t$(HASHTAB_H) $(TREE_H) $(RTL_H) function.h insn-config.h $(EXPR_H) $(OPTABS_H) \\\n-\tlibfuncs.h debug.h $(GGC_H) bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-\tcselib.h insn-addr.h $(TREE_FLOW_H)\n+gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+\tvarray.h $(HASHTAB_H) $(SPLAY_TREE_H) bitmap.h $(TREE_H) $(RTL_H) \\\n+\tfunction.h insn-config.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n+\tcselib.h insn-addr.h $(OPTABS_H) libfuncs.h debug.h $(GGC_H) \\\n+\tcgraph.h tree-alias-type.h $(TREE_FLOW_H) reload.h $(CPP_ID_DATA_H)\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n@@ -2289,7 +2291,7 @@ s-preds: genpreds$(build_exeext)\n \t$(STAMP) s-preds\n \n GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n-  $(srcdir)/../libcpp/include/cpplib.h $(host_xm_file_list) \\\n+  $(CPP_ID_DATA_H) $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/coverage.c $(srcdir)/function.h $(srcdir)/rtl.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\"}, {"sha": "5d7082437b02ffb4ee5d9bafa094413a32cd3485", "filename": "gcc/gengtype.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -875,15 +875,15 @@ note_yacc_type (options_p o, pair_p fields, pair_p typeinfo,\n }\n \f\n static void process_gc_options (options_p, enum gc_used_enum,\n-\t\t\t\tint *, int *, int *);\n+\t\t\t\tint *, int *, int *, type_p *);\n static void set_gc_used_type (type_p, enum gc_used_enum, type_p *);\n static void set_gc_used (pair_p);\n \n /* Handle OPT for set_gc_used_type.  */\n \n static void\n process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n-\t\t    int *pass_param, int *length)\n+\t\t    int *pass_param, int *length, type_p *nested_ptr)\n {\n   options_p o;\n   for (o = opt; o; o = o->next)\n@@ -895,6 +895,8 @@ process_gc_options (options_p opt, enum gc_used_enum level, int *maybe_undef,\n       *pass_param = 1;\n     else if (strcmp (o->name, \"length\") == 0)\n       *length = 1;\n+    else if (strcmp (o->name, \"nested_ptr\") == 0)\n+      *nested_ptr = ((const struct nested_ptr_data *) o->info)->type;\n }\n \n /* Set the gc_used field of T to LEVEL, and handle the types it references.  */\n@@ -914,18 +916,24 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n       {\n \tpair_p f;\n \tint dummy;\n+\ttype_p dummy2;\n \n-\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy);\n+\tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy,\n+\t\t\t    &dummy2);\n \n \tfor (f = t->u.s.fields; f; f = f->next)\n \t  {\n \t    int maybe_undef = 0;\n \t    int pass_param = 0;\n \t    int length = 0;\n+\t    type_p nested_ptr = NULL;\n \t    process_gc_options (f->opt, level, &maybe_undef, &pass_param,\n-\t\t\t\t&length);\n+\t\t\t\t&length, &nested_ptr);\n \n-\t    if (length && f->type->kind == TYPE_POINTER)\n+\t    if (nested_ptr && f->type->kind == TYPE_POINTER)\n+\t      set_gc_used_type (nested_ptr, GC_POINTED_TO, \n+\t\t\t\tpass_param ? param : NULL);\n+\t    else if (length && f->type->kind == TYPE_POINTER)\n \t      set_gc_used_type (f->type->u.p, GC_USED, NULL);\n \t    else if (maybe_undef && f->type->kind == TYPE_POINTER)\n \t      set_gc_used_type (f->type->u.p, GC_MAYBE_POINTED_TO, NULL);\n@@ -1015,7 +1023,7 @@ static outf_p\n create_file (const char *name, const char *oname)\n {\n   static const char *const hdr[] = {\n-    \"   Copyright (C) 2003 Free Software Foundation, Inc.\\n\",\n+    \"   Copyright (C) 2004 Free Software Foundation, Inc.\\n\",\n     \"\\n\",\n     \"This file is part of GCC.\\n\",\n     \"\\n\",\n@@ -1101,6 +1109,7 @@ open_base_files (void)\n       \"basic-block.h\", \"cselib.h\", \"insn-addr.h\", \"optabs.h\",\n       \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-alias-type.h\", \"tree-flow.h\", \"reload.h\",\n+      \"cpp-id-data.h\",\n       NULL\n     };\n     const char *const *ifp;\n@@ -1408,7 +1417,8 @@ struct walk_type_data\n   int used_length;\n   type_p orig_s;\n   const char *reorder_fn;\n-  int needs_cast_p;\n+  bool needs_cast_p;\n+  bool fn_wants_lvalue;\n };\n \n /* Print a mangled name representing T to OF.  */\n@@ -1511,7 +1521,7 @@ walk_type (type_p t, struct walk_type_data *d)\n   options_p oo;\n   const struct nested_ptr_data *nested_ptr_d = NULL;\n \n-  d->needs_cast_p = 0;\n+  d->needs_cast_p = false;\n   for (oo = d->opt; oo; oo = oo->next)\n     if (strcmp (oo->name, \"length\") == 0)\n       length = (const char *)oo->info;\n@@ -1525,7 +1535,7 @@ walk_type (type_p t, struct walk_type_data *d)\n     else if (strcmp (oo->name, \"desc\") == 0)\n       desc = (const char *)oo->info;\n     else if (strcmp (oo->name, \"nested_ptr\") == 0)\n-      nested_ptr_d = (const struct nested_ptr_data *)oo->info ;\n+      nested_ptr_d = (const struct nested_ptr_data *) oo->info;\n     else if (strcmp (oo->name, \"dot\") == 0)\n       ;\n     else if (strcmp (oo->name, \"tag\") == 0)\n@@ -1643,23 +1653,28 @@ walk_type (type_p t, struct walk_type_data *d)\n \t\toprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n \t\td->indent += 2;\n \t\td->val = xasprintf (\"x%d\", d->counter++);\n-\t\toprintf (d->of, \"%*s%s %s * %s =\\n\", d->indent, \"\",\n+\t\toprintf (d->of, \"%*s%s %s * %s%s =\\n\", d->indent, \"\",\n \t\t\t (nested_ptr_d->type->kind == TYPE_UNION \n \t\t\t  ? \"union\" : \"struct\"), \n-\t\t\t nested_ptr_d->type->u.s.tag, d->val);\n+\t\t\t nested_ptr_d->type->u.s.tag, \n+\t\t\t d->fn_wants_lvalue ? \"\" : \"const \",\n+\t\t\t d->val);\n \t\toprintf (d->of, \"%*s\", d->indent + 2, \"\");\n \t\toutput_escaped_param (d, nested_ptr_d->convert_from,\n \t\t\t\t      \"nested_ptr\");\n \t\toprintf (d->of, \";\\n\");\n \n \t\td->process_field (nested_ptr_d->type, d);\n \n-\t\toprintf (d->of, \"%*s%s = \", d->indent, \"\",\n-\t\t\t d->prev_val[2]);\n-\t\td->prev_val[2] = d->val;\n-\t\toutput_escaped_param (d, nested_ptr_d->convert_to,\n-\t\t\t\t      \"nested_ptr\");\n-\t\toprintf (d->of, \";\\n\");\n+\t\tif (d->fn_wants_lvalue)\n+\t\t  {\n+\t\t    oprintf (d->of, \"%*s%s = \", d->indent, \"\",\n+\t\t\t     d->prev_val[2]);\n+\t\t    d->prev_val[2] = d->val;\n+\t\t    output_escaped_param (d, nested_ptr_d->convert_to,\n+\t\t\t\t\t  \"nested_ptr\");\n+\t\t    oprintf (d->of, \";\\n\");\n+\t\t  }\n \n \t\td->indent -= 2;\n \t\toprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n@@ -1839,6 +1854,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    d->line = &f->line;\n \t    d->val = newval = xasprintf (\"%s%s%s\", oldval, dot, f->name);\n \t    d->opt = f->opt;\n+\t    d->used_length = false;\n \n \t    if (union_p && use_param_p && d->param == NULL)\n \t      oprintf (d->of, \"%*sabort();\\n\", d->indent, \"\");\n@@ -2231,7 +2247,7 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n /* For S, a structure that's part of ORIG_S, and using parameters\n    PARAM, write out a routine that:\n    - Is of type gt_note_pointers\n-   - If calls PROCESS_FIELD on each field of S or its substructures.\n+   - Calls PROCESS_FIELD on each field of S or its substructures.\n */\n \n static void\n@@ -2259,6 +2275,7 @@ write_local_func_for_structure (type_p orig_s, type_p s, type_p *param)\n   d.prev_val[1] = \"not valid postage\";  /* Guarantee an error.  */\n   d.prev_val[3] = \"x\";\n   d.val = \"(*x)\";\n+  d.fn_wants_lvalue = true;\n \n   oprintf (d.of, \"\\n\");\n   oprintf (d.of, \"void\\n\");"}, {"sha": "0227688f6e176b723c0f863ee6db3f3e55af14ff", "filename": "gcc/stringpool.c", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -51,7 +51,12 @@ static struct obstack string_stack;\n \n static hashnode alloc_node (hash_table *);\n static int mark_ident (struct cpp_reader *, hashnode, const void *);\n-static int ht_copy_and_clear (struct cpp_reader *, hashnode, const void *);\n+\n+static void *\n+stringpool_ggc_alloc (size_t x)\n+{\n+  return ggc_alloc (x);\n+}\n \n /* Initialize the string pool.  */\n void\n@@ -60,6 +65,7 @@ init_stringpool (void)\n   /* Create with 16K (2^14) entries.  */\n   ident_hash = ht_create (14);\n   ident_hash->alloc_node = alloc_node;\n+  ident_hash->alloc_subobject = stringpool_ggc_alloc;\n   gcc_obstack_init (&string_stack);\n }\n \n@@ -212,39 +218,7 @@ struct string_pool_data GTY(())\n \n static GTY(()) struct string_pool_data * spd;\n \n-/* Copy HP into the corresponding entry in HT2, and then clear\n-   the cpplib parts of HP.  */\n-\n-static int\n-ht_copy_and_clear (cpp_reader *r ATTRIBUTE_UNUSED, hashnode hp, const void *ht2_p)\n-{\n-  cpp_hashnode *h = CPP_HASHNODE (hp);\n-  struct ht *ht2 = (struct ht *) ht2_p;\n-\n-  if (h->type != NT_VOID\n-      && (h->flags & NODE_BUILTIN) == 0)\n-    {\n-      cpp_hashnode *h2 = CPP_HASHNODE (ht_lookup (ht2,\n-\t\t\t\t\t\t  NODE_NAME (h),\n-\t\t\t\t\t\t  NODE_LEN (h),\n-\t\t\t\t\t\t  HT_ALLOC));\n-      h2->type = h->type;\n-      memcpy (&h2->value, &h->value, sizeof (h->value));\n-\n-      h->type = NT_VOID;\n-      memset (&h->value, 0, sizeof (h->value));\n-    }\n-  return 1;\n-}\n-\n-/* The hash table as it was before gt_pch_save_stringpool was called.  */\n-\n-static struct ht *saved_ident_hash;\n-\n-/* Prepare the stringpool to be written (by clearing all the cpp parts\n-   of each entry) and place the data to be saved in SPD.  Save the\n-   current state in SAVED_IDENT_HASH so that gt_pch_fixup_stringpool\n-   can restore it.  */\n+/* Save the stringpool data in SPD.  */\n \n void\n gt_pch_save_stringpool (void)\n@@ -255,10 +229,6 @@ gt_pch_save_stringpool (void)\n   spd->entries = ggc_alloc (sizeof (spd->entries[0]) * spd->nslots);\n   memcpy (spd->entries, ident_hash->entries,\n \t  spd->nslots * sizeof (spd->entries[0]));\n-\n-  saved_ident_hash = ht_create (14);\n-  saved_ident_hash->alloc_node = alloc_node;\n-  ht_forall (ident_hash, ht_copy_and_clear, saved_ident_hash);\n }\n \n /* Return the stringpool to its state before gt_pch_save_stringpool\n@@ -267,9 +237,6 @@ gt_pch_save_stringpool (void)\n void\n gt_pch_fixup_stringpool (void)\n {\n-  ht_forall (saved_ident_hash, ht_copy_and_clear, ident_hash);\n-  ht_destroy (saved_ident_hash);\n-  saved_ident_hash = 0;\n }\n \n /* A PCH file has been restored, which loaded SPD; fill the real hash table"}, {"sha": "c9565dd8949c8704ae1f3a20ed807915c5055996", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -1,3 +1,8 @@\n+2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/pch/macro-4.c: New.\n+\t* gcc.dg/pch/macro-4.hs: New.\n+\n 2004-06-09  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/13249"}, {"sha": "1c199fa6eb04a438d688d17b783fd4dd4f95e140", "filename": "gcc/testsuite/gcc.dg/pch/macro-4.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-4.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -0,0 +1,8 @@\n+#define DEFN aa + bb\n+\n+#include \"macro-4.h\"\n+\n+int foo(int aa, int bb)\n+{\n+  return DEFN;\n+}"}, {"sha": "5af162d63d1bc660d1a8687e6780e2ee438020ab", "filename": "gcc/testsuite/gcc.dg/pch/macro-4.hs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-4.hs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-4.hs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpch%2Fmacro-4.hs?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -0,0 +1 @@\n+/* No content!  */"}, {"sha": "cc2b931688754f22a1334aa56cc41c5905ba6210", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -1,3 +1,27 @@\n+2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* traditional.c (push_replacement_text): Set macro->traditional.\n+\t(save_replacement_text): Likewise.\n+\t* pch.c (cpp_write_pch_state): Don't write list of defined macros.\n+\t(struct save_macro_item): Delete.\n+\t(struct save_macro_data): Use a character array not the previous\n+\tstructured format.\n+\t(save_macros): Save macro as text not as internal structures.\n+\t(cpp_prepare_state): Update for changes to save_macro_data.\n+\t(cpp_read_state): Don't read macros defined in PCH.  Restore\n+\t-D macros as text.  \n+\t* macro.c (create_iso_definition): Honour alloc_subobject.\n+\tClear traditional flag.\n+\t(_cpp_create_definition): Honour alloc_subobject.\n+\t* lex.c (cpp_token_val_index): New.\n+\t* internal.h: Include cpp-id-data.h.\n+\t(uchar): Move definition to cpp-id-data.h.\n+\t(U): Likewise.\n+\t(cpp_macro): Likewise.\n+\t* directives.c (struct answer): Move to cpp-id-data.h.\n+\t(do_assert): Honour alloc_subobject.\n+\t\n+\n 2004-06-09  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* Makefile.am (all-local): New."}, {"sha": "16873dadecf3cd2dbc5b19fda9d4701c00d01d08", "filename": "libcpp/directives.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -26,14 +26,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"mkdeps.h\"\n #include \"obstack.h\"\n \n-/* Chained list of answers to an assertion.  */\n-struct answer\n-{\n-  struct answer *next;\n-  unsigned int count;\n-  cpp_token first[1];\n-};\n-\n /* Stack of conditionals currently in progress\n    (including both successful and failing conditionals).  */\n struct if_stack\n@@ -1727,6 +1719,8 @@ do_assert (cpp_reader *pfile)\n   node = parse_assertion (pfile, &new_answer, T_ASSERT);\n   if (node)\n     {\n+      size_t answer_size;\n+\n       /* Place the new answer in the answer list.  First check there\n          is not a duplicate.  */\n       new_answer->next = 0;\n@@ -1741,11 +1735,20 @@ do_assert (cpp_reader *pfile)\n \t  new_answer->next = node->value.answers;\n \t}\n \n+      answer_size = sizeof (struct answer) + ((new_answer->count - 1)\n+\t\t\t\t\t      * sizeof (cpp_token));\n+      /* Commit or allocate storage for the object.  */\n+      if (pfile->hash_table->alloc_subobject)\n+\t{\n+\t  struct answer *temp_answer = new_answer;\n+\t  new_answer = pfile->hash_table->alloc_subobject (answer_size);\n+\t  memcpy (new_answer, temp_answer, answer_size);\n+\t}\n+      else\n+\tBUFF_FRONT (pfile->a_buff) += answer_size;\n+\n       node->type = NT_ASSERTION;\n       node->value.answers = new_answer;\n-      BUFF_FRONT (pfile->a_buff) += (sizeof (struct answer)\n-\t\t\t\t     + (new_answer->count - 1)\n-\t\t\t\t     * sizeof (cpp_token));\n       check_eol (pfile);\n     }\n }"}, {"sha": "0dbd0c33474fa348277235320d9e5a5168b934b2", "filename": "libcpp/include/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2FChangeLog?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -1,3 +1,14 @@\n+2004-06-09  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* symtab.h (struct ht): Add field 'alloc_subobject'.\n+\t* cpplib.h (struct cpp_string): Add GTY marker.\n+\t(enum cpp_token_fld_kind): New.\n+\t(struct cpp_token): Add GTY markers.\n+\t(cpp_token_val_index): Prototype.\n+\t(CPP_HASHNODE_VALUE_IDX): New.\n+\t(struct cpp_hashnode): Don't skip fields of 'value' when marking.\n+\t* cpp-id-data.h: New file.\n+\n 2004-05-29  Geoffrey Keating  <geoffk@apple.com>\n \n \t* symtab.h (struct ht): New field 'entries_owned'"}, {"sha": "bdeaeba5182b1568ca689d1d75fefa8ceaa2691b", "filename": "libcpp/include/cpp-id-data.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2Fcpp-id-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2Fcpp-id-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpp-id-data.h?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -0,0 +1,77 @@\n+/* Structures that hang off cpp_identifier, for PCH.\n+   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"cpplib.h\"\n+\n+#ifndef HAVE_UCHAR\n+typedef unsigned char uchar;\n+#endif\n+#define U (const uchar *)  /* Intended use: U\"string\" */\n+\n+/* Chained list of answers to an assertion.  */\n+struct answer GTY(())\n+{\n+  struct answer *next;\n+  unsigned int count;\n+  cpp_token GTY ((length (\"%h.count\"))) first[1];\n+};\n+\n+/* Each macro definition is recorded in a cpp_macro structure.\n+   Variadic macros cannot occur with traditional cpp.  */\n+struct cpp_macro GTY(())\n+{\n+  /* Parameters, if any.  */\n+  cpp_hashnode ** GTY ((nested_ptr (union tree_node,\n+\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\"),\n+\t\t\tlength (\"%h.paramc\")))\n+    params;\n+\n+  /* Replacement tokens (ISO) or replacement text (traditional).  See\n+     comment at top of cpptrad.c for how traditional function-like\n+     macros are encoded.  */\n+  union cpp_macro_u\n+  {\n+    cpp_token * GTY ((tag (\"0\"), length (\"%0.count\"))) tokens;\n+    const uchar * GTY ((tag (\"1\"))) text;\n+  } GTY ((desc (\"%1.traditional\"))) exp;\n+\n+  /* Definition line number.  */\n+  source_location line;\n+\n+  /* Number of tokens in expansion, or bytes for traditional macros.  */\n+  unsigned int count;\n+\n+  /* Number of parameters.  */\n+  unsigned short paramc;\n+\n+  /* If a function-like macro.  */\n+  unsigned int fun_like : 1;\n+\n+  /* If a variadic macro.  */\n+  unsigned int variadic : 1;\n+\n+  /* If macro defined in system header.  */\n+  unsigned int syshdr   : 1;\n+\n+  /* Nonzero if it has been expanded or had its existence tested.  */\n+  unsigned int used     : 1;\n+\n+  /* Indicate which field of 'exp' is in use.  */\n+  unsigned int traditional : 1;\n+};"}, {"sha": "dab315714df68e61526417f9881c57889f259042", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -156,7 +156,7 @@ enum c_lang {CLK_GNUC89 = 0, CLK_GNUC99, CLK_STDC89, CLK_STDC94, CLK_STDC99,\n \t     CLK_GNUCXX, CLK_CXX98, CLK_ASM};\n \n /* Payload of a NUMBER, STRING, CHAR or COMMENT token.  */\n-struct cpp_string\n+struct cpp_string GTY(())\n {\n   unsigned int len;\n   const unsigned char *text;\n@@ -171,23 +171,48 @@ struct cpp_string\n #define NO_EXPAND\t(1 << 5) /* Do not macro-expand this token.  */\n #define BOL\t\t(1 << 6) /* Token at beginning of line.  */\n \n+/* Specify which field, if any, of the cpp_token union is used.  */\n+\n+enum cpp_token_fld_kind {\n+  CPP_TOKEN_FLD_NODE,\n+  CPP_TOKEN_FLD_SOURCE,\n+  CPP_TOKEN_FLD_STR,\n+  CPP_TOKEN_FLD_ARG_NO,\n+  CPP_TOKEN_FLD_NONE\n+};\n+\n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on 32-bit hosts and 24 bytes on 64-bit hosts.  */\n-struct cpp_token\n+struct cpp_token GTY(())\n {\n   source_location src_loc;\t/* Location of first char of token.  */\n   ENUM_BITFIELD(cpp_ttype) type : CHAR_BIT;  /* token type */\n   unsigned char flags;\t\t/* flags - see above */\n \n-  union\n+  union cpp_token_u\n   {\n-    cpp_hashnode *node;\t\t/* An identifier.  */\n-    const cpp_token *source;\t/* Inherit padding from this token.  */\n-    struct cpp_string str;\t/* A string, or number.  */\n-    unsigned int arg_no;\t/* Argument no. for a CPP_MACRO_ARG.  */\n-  } val;\n+    /* An identifier.  */\n+    cpp_hashnode *\n+      GTY ((nested_ptr (union tree_node,\n+\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\"),\n+\t    tag (\"CPP_TOKEN_FLD_NODE\")))\n+\t node;\n+\t \n+    /* Inherit padding from this token.  */\n+    cpp_token * GTY ((tag (\"CPP_TOKEN_FLD_SOURCE\"))) source;\n+\n+    /* A string, or number.  */\n+    struct cpp_string GTY ((tag (\"CPP_TOKEN_FLD_STR\"))) str;\n+\n+    /* Argument no. for a CPP_MACRO_ARG.  */\n+    unsigned int GTY ((tag (\"CPP_TOKEN_FLD_ARG_NO\"))) arg_no;\n+  } GTY ((desc (\"cpp_token_val_index (&%1)\"))) val;\n };\n \n+/* Say which field is in use.  */\n+extern enum cpp_token_fld_kind cpp_token_val_index (cpp_token *tok);\n+\n /* A type wide enough to hold any multibyte source character.\n    cpplib's character constant interpreter requires an unsigned type.\n    Also, a typedef for the signed equivalent.\n@@ -498,6 +523,23 @@ enum builtin_type\n #define NODE_LEN(NODE)\t\tHT_LEN (&(NODE)->ident)\n #define NODE_NAME(NODE)\t\tHT_STR (&(NODE)->ident)\n \n+/* Specify which field, if any, of the union is used.  */\n+\n+enum {\n+  NTV_MACRO,\n+  NTV_ANSWER,\n+  NTV_BUILTIN,\n+  NTV_ARGUMENT,\n+  NTV_NONE\n+};\n+\n+#define CPP_HASHNODE_VALUE_IDX(HNODE)\t\t\t\t\\\n+  ((HNODE.flags & NODE_MACRO_ARG) ? NTV_ARGUMENT\t\t\\\n+   : HNODE.type == NT_MACRO ? ((HNODE.flags & NODE_BUILTIN) \t\\\n+\t\t\t       ? NTV_BUILTIN : NTV_MACRO)\t\\\n+   : HNODE.type == NT_ASSERTION ? NTV_ANSWER\t\t\t\\\n+   : NTV_NONE)\n+\n /* The common part of an identifier node shared amongst all 3 C front\n    ends.  Also used to store CPP identifiers, which are a superset of\n    identifiers in the grammatical sense.  */\n@@ -515,14 +557,14 @@ struct cpp_hashnode GTY(())\n   union _cpp_hashnode_value\n   {\n     /* If a macro.  */\n-    cpp_macro * GTY((skip)) macro;\n+    cpp_macro * GTY((tag (\"NTV_MACRO\"))) macro;\n     /* Answers to an assertion.  */\n-    struct answer * GTY ((skip)) answers;\n+    struct answer * GTY ((tag (\"NTV_ANSWER\"))) answers;\n     /* Code for a builtin macro.  */\n-    enum builtin_type GTY ((tag (\"1\"))) builtin;\n+    enum builtin_type GTY ((tag (\"NTV_BUILTIN\"))) builtin;\n     /* Macro argument index.  */\n-    unsigned short GTY ((tag (\"0\"))) arg_index;\n-  } GTY ((desc (\"0\"))) value;\n+    unsigned short GTY ((tag (\"NTV_ARGUMENT\"))) arg_index;\n+  } GTY ((desc (\"CPP_HASHNODE_VALUE_IDX (%1)\"))) value;\n };\n \n /* Call this first to get a handle to pass to other functions."}, {"sha": "0b2a848739e13ee6526f274d0ee740d75a0161a0", "filename": "libcpp/include/symtab.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2Fsymtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finclude%2Fsymtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fsymtab.h?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -46,8 +46,11 @@ struct ht\n   struct obstack stack;\n \n   hashnode *entries;\n-  /* Call back.  */\n+  /* Call back, allocate a node.  */\n   hashnode (*alloc_node) (hash_table *);\n+  /* Call back, allocate something that hangs off a node like a cpp_macro.  \n+     NULL means use the usual allocator.  */\n+  void * (*alloc_subobject) (size_t);\n \n   unsigned int nslots;\t\t/* Total slots in the entries array.  */\n   unsigned int nelements;\t/* Number of live elements.  */"}, {"sha": "fd3facf6136d38b3a75406d56bab5e133c36ac4f", "filename": "libcpp/internal.h", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -24,6 +24,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define LIBCPP_INTERNAL_H\n \n #include \"symtab.h\"\n+#include \"cpp-id-data.h\"\n \n #if defined HAVE_ICONV_H && defined HAVE_ICONV\n #include <iconv.h>\n@@ -45,11 +46,6 @@ struct cset_converter\n   iconv_t cd;\n };\n \n-#ifndef HAVE_UCHAR\n-typedef unsigned char uchar;\n-#endif\n-#define U (const uchar *)  /* Intended use: U\"string\" */\n-\n #define BITS_PER_CPPCHAR_T (CHAR_BIT * sizeof (cppchar_t))\n \n /* Test if a sign is valid within a preprocessing number.  */\n@@ -90,44 +86,6 @@ struct dummy\n #define CPP_ALIGN2(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n #define CPP_ALIGN(size) CPP_ALIGN2 (size, DEFAULT_ALIGNMENT)\n \n-/* Each macro definition is recorded in a cpp_macro structure.\n-   Variadic macros cannot occur with traditional cpp.  */\n-struct cpp_macro\n-{\n-  /* Parameters, if any.  */\n-  cpp_hashnode **params;\n-\n-  /* Replacement tokens (ISO) or replacement text (traditional).  See\n-     comment at top of cpptrad.c for how traditional function-like\n-     macros are encoded.  */\n-  union\n-  {\n-    cpp_token *tokens;\n-    const uchar *text;\n-  } exp;\n-\n-  /* Definition line number.  */\n-  fileline line;\n-\n-  /* Number of tokens in expansion, or bytes for traditional macros.  */\n-  unsigned int count;\n-\n-  /* Number of parameters.  */\n-  unsigned short paramc;\n-\n-  /* If a function-like macro.  */\n-  unsigned int fun_like : 1;\n-\n-  /* If a variadic macro.  */\n-  unsigned int variadic : 1;\n-\n-  /* If macro defined in system header.  */\n-  unsigned int syshdr   : 1;\n-\n-  /* Nonzero if it has been expanded or had its existence tested.  */\n-  unsigned int used     : 1;\n-};\n-\n #define _cpp_mark_macro_used(NODE) do {\t\t\t\t\t\\\n   if ((NODE)->type == NT_MACRO && !((NODE)->flags & NODE_BUILTIN))\t\\\n     (NODE)->value.macro->used = 1; } while (0)"}, {"sha": "7eafb13d3b432982d92e83bc4f7e447552ea3382", "filename": "libcpp/lex.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -1556,3 +1556,25 @@ _cpp_aligned_alloc (cpp_reader *pfile, size_t len)\n   buff->cur = result + len;\n   return result;\n }\n+\n+/* Say which field of TOK is in use.  */\n+\n+enum cpp_token_fld_kind\n+cpp_token_val_index (cpp_token *tok)\n+{\n+  switch (TOKEN_SPELL (tok))\n+    {\n+    case SPELL_IDENT:\n+      return CPP_TOKEN_FLD_NODE;\n+    case SPELL_LITERAL:\n+      return CPP_TOKEN_FLD_STR;\n+    case SPELL_NONE:\n+      if (tok->type == CPP_MACRO_ARG)\n+\treturn CPP_TOKEN_FLD_ARG_NO;\n+      else if (tok->type == CPP_PADDING)\n+\treturn CPP_TOKEN_FLD_SOURCE;\n+      /* else fall through */\n+    default:\n+      return CPP_TOKEN_FLD_NONE;\n+    }\n+}"}, {"sha": "dc58b3180f12e2861232dbed3d91e6dc1d913e63", "filename": "libcpp/macro.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -1408,8 +1408,16 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n       if (!ok)\n \treturn false;\n \n-      /* Success.  Commit the parameter array.  */\n-      BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n+      /* Success.  Commit or allocate the parameter array.  */\n+      if (pfile->hash_table->alloc_subobject)\n+\t{\n+\t  cpp_token *tokns = pfile->hash_table->alloc_subobject\n+\t    (sizeof (cpp_token) * macro->paramc);\n+\t  memcpy (tokns, macro->params, sizeof (cpp_token) * macro->paramc);\n+\t  macro->params = tokns;\n+\t}\n+      else\n+\tBUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n       macro->fun_like = 1;\n     }\n   else if (ctoken->type != CPP_EOF && !(ctoken->flags & PREV_WHITE))\n@@ -1472,6 +1480,7 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n     }\n \n   macro->exp.tokens = (cpp_token *) BUFF_FRONT (pfile->a_buff);\n+  macro->traditional = 0;\n \n   /* Don't count the CPP_EOF.  */\n   macro->count--;\n@@ -1480,8 +1489,16 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n   if (macro->count)\n     macro->exp.tokens[0].flags &= ~PREV_WHITE;\n \n-  /* Commit the memory.  */\n-  BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->exp.tokens[macro->count];\n+  /* Commit or allocate the memory.  */\n+  if (pfile->hash_table->alloc_subobject)\n+    {\n+      cpp_token *tokns = pfile->hash_table->alloc_subobject (sizeof (cpp_token)\n+\t\t\t\t\t\t\t     * macro->count);\n+      memcpy (tokns, macro->exp.tokens, sizeof (cpp_token) * macro->count);\n+      macro->exp.tokens = tokns;\n+    }\n+  else\n+    BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->exp.tokens[macro->count];\n \n   return true;\n }\n@@ -1494,7 +1511,10 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   unsigned int i;\n   bool ok;\n \n-  macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n+  if (pfile->hash_table->alloc_subobject)\n+    macro = pfile->hash_table->alloc_subobject (sizeof (cpp_macro));\n+  else\n+    macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n   macro->line = pfile->directive_line;\n   macro->params = 0;\n   macro->paramc = 0;"}, {"sha": "a9d139a30b76121e0ed457b791c20853c6b95567", "filename": "libcpp/pch.c", "status": "modified", "additions": 63, "deletions": 94, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -347,15 +347,6 @@ cpp_write_pch_state (cpp_reader *r, FILE *f)\n {\n   struct macrodef_struct z;\n \n-  /* Write out the list of defined identifiers.  */\n-  cpp_forall_identifiers (r, write_macdef, f);\n-  memset (&z, 0, sizeof (z));\n-  if (fwrite (&z, sizeof (z), 1, f) != 1)\n-    {\n-      cpp_errno (r, CPP_DL_ERROR, \"while writing precompiled header\");\n-      return -1;\n-    }\n-\n   if (!r->deps)\n     r->deps = deps_init ();\n \n@@ -544,46 +535,64 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n   return 1;\n }\n \n-/* Save all the existing macros and assertions.  \n-   This code assumes that there might be hundreds, but not thousands of\n-   existing definitions.  */\n-\n-struct save_macro_item {\n-  struct save_macro_item *next;\n-  struct cpp_hashnode macs[64];\n-};\n+/* Save all the existing macros.  */\n \n struct save_macro_data \n {\n-  struct save_macro_item *macros;\n+  uchar **defns;\n   size_t count;\n+  size_t array_size;\n   char **saved_pragmas;\n };\n \n-/* Save the definition of a single macro, so that it will persist across\n-   a PCH restore.  */\n+/* Save the definition of a single macro, so that it will persist\n+   across a PCH restore.  Because macro data is in GCed memory, which\n+   will be blown away by PCH, it must be temporarily copied to\n+   malloced memory.  (The macros will refer to identifier nodes which\n+   are also GCed and so on, so the copying is done by turning them\n+   into self-contained strings.)  The assumption is that most macro\n+   definitions will come from the PCH file, not from the compilation\n+   before the PCH file is loaded, so it doesn't matter that this is\n+   a little expensive.\n+\n+   It would reduce the cost even further if macros defined in the PCH\n+   file were not saved in this way, but this is not done (yet), except\n+   for builtins, and for #assert by default.  */\n \n static int \n-save_macros (cpp_reader *r ATTRIBUTE_UNUSED, cpp_hashnode *h, void *data_p)\n+save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n {\n   struct save_macro_data *data = (struct save_macro_data *)data_p;\n   if (h->type != NT_VOID\n       && (h->flags & NODE_BUILTIN) == 0)\n     {\n-      cpp_hashnode *save;\n-      if (data->count == ARRAY_SIZE (data->macros->macs))\n+      if (data->count == data->array_size)\n+\t{\n+\t  data->array_size *= 2;\n+\t  data->defns = xrealloc (data->defns, (data->array_size \n+\t\t\t\t\t\t* sizeof (uchar *)));\n+\t}\n+      \n+      switch (h->type)\n \t{\n-\t  struct save_macro_item *d = data->macros;\n-\t  data->macros = xmalloc (sizeof (struct save_macro_item));\n-\t  data->macros->next = d;\n-\t  data->count = 0;\n+\tcase NT_ASSERTION:\n+\t  /* Not currently implemented.  */\n+\t  return 1;\n+\n+\tcase NT_MACRO:\n+\t  {\n+\t    const uchar * defn = cpp_macro_definition (r, h);\n+\t    size_t defnlen = ustrlen (defn);\n+\n+\t    data->defns[data->count] = xmemdup (defn, defnlen, defnlen + 2);\n+\t    data->defns[data->count][defnlen] = '\\n';\n+\t  }\n+\t  break;\n+\t  \n+\tdefault:\n+\t  abort ();\n \t}\n-      save = data->macros->macs + data->count;\n       data->count++;\n-      memcpy (save, h, sizeof (struct cpp_hashnode));\n-      HT_STR (&save->ident) = xmemdup (HT_STR (HT_NODE (save)),\n-\t\t\t\t       HT_LEN (HT_NODE (save)),\n-\t\t\t\t       HT_LEN (HT_NODE (save)) + 1);\n     }\n   return 1;\n }\n@@ -596,8 +605,9 @@ cpp_prepare_state (cpp_reader *r, struct save_macro_data **data)\n {\n   struct save_macro_data *d = xmalloc (sizeof (struct save_macro_data));\n   \n-  d->macros = NULL;\n-  d->count = ARRAY_SIZE (d->macros->macs);\n+  d->array_size = 512;\n+  d->defns = xmalloc (d->array_size * sizeof (d->defns[0]));\n+  d->count = 0;\n   cpp_forall_identifiers (r, save_macros, d);\n   d->saved_pragmas = _cpp_save_pragma_names (r);\n   *data = d;\n@@ -612,11 +622,9 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n \t\tstruct save_macro_data *data)\n {\n   struct macrodef_struct m;\n-  size_t defnlen = 256;\n-  unsigned char *defn = xmalloc (defnlen);\n-  struct lexer_state old_state;\n   struct save_macro_item *d;\n   size_t i, mac_count;\n+  struct lexer_state old_state;\n \n   /* Restore spec_nodes, which will be full of references to the old \n      hashtable entries and so will now be invalid.  */\n@@ -628,70 +636,28 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n     s->n__VA_ARGS__     = cpp_lookup (r, DSC(\"__VA_ARGS__\"));\n   }\n \n-  /* Run through the carefully-saved macros, insert them.  */\n-  d = data->macros;\n-  mac_count = data->count;\n-  while (d)\n-    {\n-      struct save_macro_item *nextd;\n-      for (i = 0; i < mac_count; i++)\n-\t{\n-\t  cpp_hashnode *h;\n-\t  \n-\t  h = cpp_lookup (r, HT_STR (HT_NODE (&d->macs[i])), \n-\t\t\t  HT_LEN (HT_NODE (&d->macs[i])));\n-\t  h->type = d->macs[i].type;\n-\t  h->flags = d->macs[i].flags;\n-\t  h->value = d->macs[i].value;\n-\t  free ((void *)HT_STR (HT_NODE (&d->macs[i])));\n-\t}\n-      nextd = d->next;\n-      free (d);\n-      d = nextd;\n-      mac_count = ARRAY_SIZE (d->macs);\n-    }\n-\n-  _cpp_restore_pragma_names (r, data->saved_pragmas);\n-\n-  free (data);\n-\n   old_state = r->state;\n-\n   r->state.in_directive = 1;\n   r->state.prevent_expansion = 1;\n   r->state.angled_headers = 0;\n \n-  /* Read in the identifiers that must be defined.  */\n-  for (;;)\n+  /* Run through the carefully-saved macros, insert them.  */\n+  for (i = 0; i < data->count; i++)\n     {\n       cpp_hashnode *h;\n-      \n-      if (fread (&m, sizeof (m), 1, f) != 1)\n-\tgoto error;\n-      \n-      if (m.name_length == 0)\n-\tbreak;\n-\n-      if (defnlen < m.definition_length + 1)\n-\t{\n-\t  defnlen = m.definition_length + 256;\n-\t  defn = xrealloc (defn, defnlen);\n-\t}\n+      size_t namelen;\n+      uchar *defn;\n \n-      if (fread (defn, 1, m.definition_length, f) != m.definition_length)\n-\tgoto error;\n-      defn[m.definition_length] = '\\n';\n-      \n-      h = cpp_lookup (r, defn, m.name_length);\n+      namelen = strcspn (data->defns[i], \"( \\n\");\n+      h = cpp_lookup (r, data->defns[i], namelen);\n+      defn = data->defns[i] + namelen;\n \n-      if (h->type == NT_MACRO)\n-\t_cpp_free_definition (h);\n-      if (m.flags & NODE_POISONED)\n-\th->flags |= NODE_POISONED | NODE_DIAGNOSTIC;\n-      else if (m.name_length != m.definition_length)\n+      /* The PCH file is valid, so we know that if there is a definition\n+\t from the PCH file it must be the same as the one we had\n+\t originally, and so do not need to restore it.  */\n+      if (h->type == NT_VOID)\n \t{\n-\t  if (cpp_push_buffer (r, defn + m.name_length, \n-\t\t\t       m.definition_length - m.name_length, true)\n+\t  if (cpp_push_buffer (r, defn, ustrchr (defn, '\\n') - defn, true)\n \t      != NULL)\n \t    {\n \t      _cpp_clean_line (r);\n@@ -702,11 +668,14 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,\n \t  else\n \t    abort ();\n \t}\n-    }\n \n+      free (data->defns[i]);\n+    }\n   r->state = old_state;\n-  free (defn);\n-  defn = NULL;\n+\n+  _cpp_restore_pragma_names (r, data->saved_pragmas);\n+\n+  free (data);\n \n   if (deps_restore (r->deps, f, CPP_OPTION (r, restore_pch_deps) ? name : NULL)\n       != 0)"}, {"sha": "38e301c43ff767fac0773b5c305b21ace9257cf9", "filename": "libcpp/traditional.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8044160b7047642e312fb5f713fe0db46171dd8/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=d8044160b7047642e312fb5f713fe0db46171dd8", "patch": "@@ -701,6 +701,7 @@ push_replacement_text (cpp_reader *pfile, cpp_hashnode *node)\n       cpp_macro *macro = node->value.macro;\n       macro->used = 1;\n       text = macro->exp.text;\n+      macro->traditional = 1;\n       len = macro->count;\n     }\n \n@@ -934,6 +935,7 @@ save_replacement_text (cpp_reader *pfile, cpp_macro *macro,\n       memcpy (exp, pfile->out.base, len);\n       exp[len] = '\\n';\n       macro->exp.text = exp;\n+      macro->traditional = 1;\n       macro->count = len;\n     }\n   else\n@@ -949,6 +951,7 @@ save_replacement_text (cpp_reader *pfile, cpp_macro *macro,\n       exp = BUFF_FRONT (pfile->a_buff);\n       block = (struct block *) (exp + macro->count);\n       macro->exp.text = exp;\n+      macro->traditional = 1;\n \n       /* Write out the block information.  */\n       block->text_len = len;"}]}