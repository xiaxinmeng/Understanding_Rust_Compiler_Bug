{"sha": "a764d66099b476db7d59829da1b86fd4a701523f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc2NGQ2NjA5OWI0NzZkYjdkNTk4MjlkYTFiODZmZDRhNzAxNTIzZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-05-16T08:05:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-05-16T08:05:50Z"}, "message": "tree-ssa-sccvn.c: Include tree-cfg.h and domwalk.h.\n\n2014-05-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-sccvn.c: Include tree-cfg.h and domwalk.h.\n\t(set_ssa_val_to): Handle unexpected sets to VN_TOP.\n\t(visit_phi): Ignore edges marked as not executable.\n\t(class cond_dom_walker): New.\n\t(cond_dom_walker::before_dom_children): Value-number\n\tcontrol statements and mark successor edges as not\n\texecutable if possible.\n\t(run_scc_vn): First walk all control statements in\n\tdominator order, marking edges as not executable.\n\t* tree-inline.c (copy_edges_for_bb): Be not confused\n\tabout random edge flags.\n\n\t* gcc.dg/tree-ssa/ssa-fre-39.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-40.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-8.c: One more elimination.\n\t* gcc.dg/tree-ssa/struct-aliasing-2.c: Scan cddce1 dump.\n\nFrom-SVN: r210492", "tree": {"sha": "6b4c7eeefda2e10dbce6363164cd1f14df8d78f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b4c7eeefda2e10dbce6363164cd1f14df8d78f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a764d66099b476db7d59829da1b86fd4a701523f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a764d66099b476db7d59829da1b86fd4a701523f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a764d66099b476db7d59829da1b86fd4a701523f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a764d66099b476db7d59829da1b86fd4a701523f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a27c386001166cec7abc12d54e96413022bcc747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27c386001166cec7abc12d54e96413022bcc747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a27c386001166cec7abc12d54e96413022bcc747"}], "stats": {"total": 265, "additions": 230, "deletions": 35}, "files": [{"sha": "cc0d973056f368bc1f429658921f8846cfd7d5d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -1,3 +1,17 @@\n+2014-05-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-sccvn.c: Include tree-cfg.h and domwalk.h.\n+\t(set_ssa_val_to): Handle unexpected sets to VN_TOP.\n+\t(visit_phi): Ignore edges marked as not executable.\n+\t(class cond_dom_walker): New.\n+\t(cond_dom_walker::before_dom_children): Value-number\n+\tcontrol statements and mark successor edges as not\n+\texecutable if possible.\n+\t(run_scc_vn): First walk all control statements in\n+\tdominator order, marking edges as not executable.\n+\t* tree-inline.c (copy_edges_for_bb): Be not confused\n+\tabout random edge flags.\n+\n 2014-05-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (visit_use): Also constant-fold calls."}, {"sha": "66d0694e0c1cb3f5a19cbc59b31437783214b5db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -1,3 +1,10 @@\n+2014-05-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-fre-39.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-40.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-8.c: One more elimination.\n+\t* gcc.dg/tree-ssa/struct-aliasing-2.c: Scan cddce1 dump.\n+\n 2014-05-16  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ssa-fre-41.c: New testcase."}, {"sha": "a30926caccd4e57d5f10c39f5b12d9340928ff1a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-39.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-39.c?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n+\n+int foo (int i)\n+{\n+  int k = i + 1;\n+  int j = i + 1;\n+  if (k != j)\n+    k = k + 1;\n+  if (k != j)\n+    k = k + 1;\n+  k = k - i;\n+  return k;\n+}\n+\n+/* We should be able to value-number the final assignment to k to 1.  */\n+\n+/* { dg-final { scan-tree-dump \"k_. = 1;\" \"fre1\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "dd085a0877029ee88e4fda38f4f7b9e1a8d14509", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-40.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-40.c?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n+\n+int x;\n+int foo (int *p)\n+{\n+  x = 0;\n+  if (x)\n+    *p = 1;\n+  return x;\n+}\n+\n+/* The final load of x should be replaced as well as the\n+   aliasing store via *p is not reachable.  */\n+\n+/* { dg-final { scan-tree-dump-not \"= x;\" \"fre1\" } } */"}, {"sha": "dab57fa391bbde0e94f16c28460e4b502b6055fb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-8.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-8.c?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -17,7 +17,9 @@ foo (__SIZE_TYPE__ i, struct s *array)\n   return 0;\n }\n /* We should eliminate two address calculations, and one load.  */\n+/* We also elimiate the PHI node feeding the return because the case\n+   returning 1 is unreachable.  */\n /* We used to eliminate a cast but that was before POINTER_PLUS_EXPR\n    was added.  */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 3\" 1 \"fre1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 4\" 1 \"fre1\"} } */\n /* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "66a5442a9effcad5ebfaa5e8a3f06fa7ebfd456d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-2.c?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+/* { dg-options \"-O2 -fdump-tree-cddce1\" } */\n \n struct S { unsigned f; };\n \n@@ -12,8 +12,8 @@ foo ( struct S *p)\n }\n \n \n-/* There should only be one load of p->f because fwprop can change\n-   *(int *)&p->f into just (int)p->f.  */\n-/* { dg-final { scan-tree-dump-times \"= \\[^\\n\\]*p_.\\\\\\(D\\\\\\)\" 1 \"fre1\" } } */\n-/* { dg-final { cleanup-tree-dump \"fre1\" } } */\n+/* There should only be one load of p->f because FRE removes the redundancy\n+   by realizing it can cast the result of either to the other.  */\n+/* { dg-final { scan-tree-dump-times \"= \\[^\\n\\]*p_.\\\\\\(D\\\\\\)\" 1 \"cddce1\" } } */\n+/* { dg-final { cleanup-tree-dump \"cddce1\" } } */\n "}, {"sha": "bc2b2712b05a98566a65583ba58a83692a9a6749", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -1984,7 +1984,8 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \tflags = old_edge->flags;\n \n \t/* Return edges do get a FALLTHRU flag when the get inlined.  */\n-\tif (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n+\tif (old_edge->dest->index == EXIT_BLOCK\n+\t    && !(old_edge->flags & (EDGE_TRUE_VALUE|EDGE_FALSE_VALUE|EDGE_FAKE))\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR_FOR_FN (cfun))\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);"}, {"sha": "84c0d6e1feb32c03062dc4731a03d330f3eae01e", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 164, "deletions": 28, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a764d66099b476db7d59829da1b86fd4a701523f/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=a764d66099b476db7d59829da1b86fd4a701523f", "patch": "@@ -51,6 +51,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-sccvn.h\"\n+#include \"tree-cfg.h\"\n+#include \"domwalk.h\"\n \n /* This algorithm is based on the SCC algorithm presented by Keith\n    Cooper and L. Taylor Simpson in \"SCC-Based Value numbering\"\n@@ -2661,6 +2663,25 @@ set_ssa_val_to (tree from, tree to)\n   tree currval = SSA_VAL (from);\n   HOST_WIDE_INT toff, coff;\n \n+  /* The only thing we allow as value numbers are ssa_names\n+     and invariants.  So assert that here.  We don't allow VN_TOP\n+     as visiting a stmt should produce a value-number other than\n+     that.\n+     ???  Still VN_TOP can happen for unreachable code, so force\n+     it to varying in that case.  Not all code is prepared to\n+     get VN_TOP on valueization.  */\n+  if (to == VN_TOP)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Forcing value number to varying on \"\n+\t\t \"receiving VN_TOP\\n\");\n+      to = from;\n+    }\n+\n+  gcc_assert (to != NULL_TREE\n+\t      && (TREE_CODE (to) == SSA_NAME\n+\t\t  || is_gimple_min_invariant (to)));\n+\n   if (from != to)\n     {\n       if (currval == from)\n@@ -2680,13 +2701,6 @@ set_ssa_val_to (tree from, tree to)\n \tto = from;\n     }\n \n-  /* The only thing we allow as value numbers are VN_TOP, ssa_names\n-     and invariants.  So assert that here.  */\n-  gcc_assert (to != NULL_TREE\n-\t      && (to == VN_TOP\n-\t\t  || TREE_CODE (to) == SSA_NAME\n-\t\t  || is_gimple_min_invariant (to)));\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Setting value number of \");\n@@ -3071,7 +3085,6 @@ visit_phi (gimple phi)\n   tree result;\n   tree sameval = VN_TOP;\n   bool allsame = true;\n-  unsigned i;\n \n   /* TODO: We could check for this in init_sccvn, and replace this\n      with a gcc_assert.  */\n@@ -3080,27 +3093,30 @@ visit_phi (gimple phi)\n \n   /* See if all non-TOP arguments have the same value.  TOP is\n      equivalent to everything, so we can ignore it.  */\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      tree def = PHI_ARG_DEF (phi, i);\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n+    if (e->flags & EDGE_EXECUTABLE)\n+      {\n+\ttree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \n-      if (TREE_CODE (def) == SSA_NAME)\n-\tdef = SSA_VAL (def);\n-      if (def == VN_TOP)\n-\tcontinue;\n-      if (sameval == VN_TOP)\n-\t{\n-\t  sameval = def;\n-\t}\n-      else\n-\t{\n-\t  if (!expressions_equal_p (def, sameval))\n-\t    {\n-\t      allsame = false;\n-\t      break;\n-\t    }\n-\t}\n-    }\n+\tif (TREE_CODE (def) == SSA_NAME)\n+\t  def = SSA_VAL (def);\n+\tif (def == VN_TOP)\n+\t  continue;\n+\tif (sameval == VN_TOP)\n+\t  {\n+\t    sameval = def;\n+\t  }\n+\telse\n+\t  {\n+\t    if (!expressions_equal_p (def, sameval))\n+\t      {\n+\t\tallsame = false;\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n \n   /* If all value numbered to the same value, the phi node has that\n      value.  */\n@@ -4140,13 +4156,113 @@ set_hashtable_value_ids (void)\n     set_value_id_for_result (vr->result, &vr->value_id);\n }\n \n+class cond_dom_walker : public dom_walker\n+{\n+public:\n+  cond_dom_walker () : dom_walker (CDI_DOMINATORS), fail (false) {}\n+\n+  virtual void before_dom_children (basic_block);\n+\n+  bool fail;\n+};\n+\n+void\n+cond_dom_walker::before_dom_children (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (fail)\n+    return;\n+\n+  /* If any of the predecessor edges are still marked as possibly\n+     executable consider this block reachable.  */\n+  bool reachable = bb == ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    reachable |= (e->flags & EDGE_EXECUTABLE);\n+\n+  /* If the block is not reachable all outgoing edges are not\n+     executable.  */\n+  if (!reachable)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Marking all outgoing edges of unreachable \"\n+\t\t \"BB %d as not executable\\n\", bb->index);\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->flags &= ~EDGE_EXECUTABLE;\n+      return;\n+    }\n+\n+  gimple stmt = last_stmt (bb);\n+  if (!stmt)\n+    return;\n+\n+  /* Value-number the last stmts SSA uses.  */\n+  ssa_op_iter i;\n+  tree op;\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+    if (VN_INFO (op)->visited == false\n+\t&& !DFS (op))\n+      {\n+\tfail = true;\n+\treturn;\n+      }\n+\n+  /* ???  We can even handle stmts with outgoing EH or ABNORMAL edges\n+     if value-numbering can prove they are not reachable.  Handling\n+     computed gotos is also possible.  */\n+  tree val;\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_COND:\n+      {\n+\ttree lhs = gimple_cond_lhs (stmt);\n+\ttree rhs = gimple_cond_rhs (stmt);\n+\t/* Work hard in computing the condition and take into account\n+\t   the valueization of the defining stmt.  */\n+\tif (TREE_CODE (lhs) == SSA_NAME)\n+\t  lhs = vn_get_expr_for (lhs);\n+\tif (TREE_CODE (rhs) == SSA_NAME)\n+\t  rhs = vn_get_expr_for (rhs);\n+\tval = fold_binary (gimple_cond_code (stmt),\n+\t\t\t   boolean_type_node, lhs, rhs);\n+\tbreak;\n+      }\n+    case GIMPLE_SWITCH:\n+      val = gimple_switch_index (stmt);\n+      break;\n+    case GIMPLE_GOTO:\n+      val = gimple_goto_dest (stmt);\n+      break;\n+    default:\n+      val = NULL_TREE;\n+      break;\n+    }\n+  if (!val)\n+    return;\n+\n+  edge taken = find_taken_edge (bb, vn_valueize (val));\n+  if (!taken)\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Marking all edges out of BB %d but (%d -> %d) as \"\n+\t     \"not executable\\n\", bb->index, bb->index, taken->dest->index);\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e != taken)\n+      e->flags &= ~EDGE_EXECUTABLE;\n+}\n+\n /* Do SCCVN.  Returns true if it finished, false if we bailed out\n    due to resource constraints.  DEFAULT_VN_WALK_KIND_ specifies\n    how we use the alias oracle walking during the VN process.  */\n \n bool\n run_scc_vn (vn_lookup_kind default_vn_walk_kind_)\n {\n+  basic_block bb;\n   size_t i;\n   tree param;\n \n@@ -4164,6 +4280,26 @@ run_scc_vn (vn_lookup_kind default_vn_walk_kind_)\n \tVN_INFO (def)->valnum = def;\n     }\n \n+  /* Mark all edges as possibly executable.  */\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->flags |= EDGE_EXECUTABLE;\n+    }\n+\n+  /* Walk all blocks in dominator order, value-numbering the last stmts\n+     SSA uses and decide whether outgoing edges are not executable.  */\n+  cond_dom_walker walker;\n+  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  if (walker.fail)\n+    {\n+      free_scc_vn ();\n+      return false;\n+    }\n+\n+  /* Value-number remaining SSA names.  */\n   for (i = 1; i < num_ssa_names; ++i)\n     {\n       tree name = ssa_name (i);"}]}