{"sha": "fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUzMmJiMWI1YmQyOTczMzA1YTIwNmEyOWVkNGM3Yzg3NDlkOThjNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-06-30T14:50:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-06-30T14:50:48Z"}, "message": "cp-tree.h (lookup_fnfields_1, [...]): Don't declare.\n\n\n\t* cp-tree.h (lookup_fnfields_1, class_method_index_for_fn): Don't\n\tdeclare.\n\t(lookup_all_conversions): Declare.\n\t* class.c (get_basefndecls): Use lookup_fnfields_slot.\n\t* decl.c (register_dtor_fn): Use lookup_fnfields_slot.\n\t* decl2.c (check_class_fn): Use lookup_fnfields_slot.  Rework\n\tdiagnostics.\n\t* pt.c (retrieve_specialization): Use lookup_fnfields_slot.\n\t(check_explicit_specialization): Use lookup_fnfields_slot_nolazy,\n\tlookup_all_conversions.\n\t* search.c (lookup_fnfields_1): Make static.\n\t(lookup_all_conversions): New.\n\t(class_method_index_for_fn): Delete.\n\t* semantics.c (classtype_has_nothrow_assign_or_copy_p): Use\n\tlookup_fnfields_slot.\n\n\t* g++.dg/concepts/memfun-err.C: Adjust diagnostics.\n\t* g++.dg/cpp0x/decltype9.C: Likewise.\n\t* g++.dg/cpp0x/forw_enum9.C: Likewise.\n\t* g++.dg/lookup/decl1.C: Likewise.\n\t* g++.dg/lookup/extern-c-redecl.C: Likewise.\n\t* g++.dg/other/pr28432.C: Likewise.\n\t* g++.dg/parse/crash12.C: Likewise.\n\t* g++.dg/parse/enum3.C: Likewise.\n\t* g++.dg/parse/operator6.C: Likewise.\n\t* g++.dg/template/crash69.C: Likewise.\n\t* g++.dg/template/error27.C: Likewise.\n\t* g++.dg/template/error28.C: Likewise.\n\t* g++.dg/template/memfriend6.C: Likewise.\n\t* g++.old-deja/g++.mike/err1.C: Likewise.\n\t* g++.old-deja/g++.mike/p811.C: Likewise.\n\t* g++.old-deja/g++.other/crash25.C: Likewise.\n\t* g++.old-deja/g++.other/dtor4.C: Likewise.\n\t* g++.old-deja/g++.pt/t37.C: Likewise.\n\nFrom-SVN: r249843", "tree": {"sha": "fc79ce537be5fa1789fba27c6c91096f4669ec07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc79ce537be5fa1789fba27c6c91096f4669ec07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "367e91e1c5c293da8d0999cb2bc5d8cd2c95e6b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/367e91e1c5c293da8d0999cb2bc5d8cd2c95e6b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/367e91e1c5c293da8d0999cb2bc5d8cd2c95e6b4"}], "stats": {"total": 473, "additions": 234, "deletions": 239}, "files": [{"sha": "4260bbff089f9f1103c68599e96452bd332a1150", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,5 +1,21 @@\n 2017-06-30  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (lookup_fnfields_1, class_method_index_for_fn): Don't\n+\tdeclare.\n+\t(lookup_all_conversions): Declare.\n+\t* class.c (get_basefndecls): Use lookup_fnfields_slot.\n+\t* decl.c (register_dtor_fn): Use lookup_fnfields_slot.\n+\t* decl2.c (check_class_fn): Use lookup_fnfields_slot.  Rework\n+\tdiagnostics.\n+\t* pt.c (retrieve_specialization): Use lookup_fnfields_slot.\n+\t(check_explicit_specialization): Use lookup_fnfields_slot_nolazy,\n+\tlookup_all_conversions.\n+\t* search.c (lookup_fnfields_1): Make static.\n+\t(lookup_all_conversions): New.\n+\t(class_method_index_for_fn): Delete.\n+\t* semantics.c (classtype_has_nothrow_assign_or_copy_p): Use\n+\tlookup_fnfields_slot.\n+\n \t* call.c (build_new_method_call_1): Use constructo_name to get\n \tctor name.  Move argument processing earlier to merge cdtor\n \thandling blocks."}, {"sha": "0dca90575c726d3115a48954865acdf0d35acb89", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -2966,29 +2966,25 @@ modify_all_vtables (tree t, tree virtuals)\n static void\n get_basefndecls (tree name, tree t, vec<tree> *base_fndecls)\n {\n-  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n-  int i;\n+  bool found_decls = false;\n \n   /* Find virtual functions in T with the indicated NAME.  */\n-  i = lookup_fnfields_1 (t, name);\n-  bool found_decls = false;\n-  if (i != -1)\n-    for (ovl_iterator iter ((*CLASSTYPE_METHOD_VEC (t))[i]); iter; ++iter)\n-      {\n-\ttree method = *iter;\n+  for (ovl_iterator iter (lookup_fnfields_slot (t, name)); iter; ++iter)\n+    {\n+      tree method = *iter;\n \n-\tif (TREE_CODE (method) == FUNCTION_DECL\n-\t    && DECL_VINDEX (method))\n-\t  {\n-\t    base_fndecls->safe_push (method);\n-\t    found_decls = true;\n-\t  }\n-      }\n+      if (TREE_CODE (method) == FUNCTION_DECL && DECL_VINDEX (method))\n+\t{\n+\t  base_fndecls->safe_push (method);\n+\t  found_decls = true;\n+\t}\n+    }\n \n   if (found_decls)\n     return;\n \n-  for (i = 0; i < n_baseclasses; i++)\n+  int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n+  for (int i = 0; i < n_baseclasses; i++)\n     {\n       tree basetype = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (t), i));\n       get_basefndecls (name, basetype, base_fndecls);"}, {"sha": "4b5ff69a1a82af93fc09f428f22d6ea895a1405a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -6567,10 +6567,9 @@ extern int accessible_p\t\t\t\t(tree, tree, bool);\n extern int accessible_in_template_p\t\t(tree, tree);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n-extern int lookup_fnfields_1\t\t\t(tree, tree);\n extern tree lookup_fnfields_slot\t\t(tree, tree);\n extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n-extern int class_method_index_for_fn\t\t(tree, tree);\n+extern tree lookup_all_conversions\t\t(tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n extern tree lookup_member\t\t\t(tree, tree, int, bool,\n \t\t\t\t\t\t tsubst_flags_t,"}, {"sha": "62877dc2851450a98a8a03a1842683bbe6ca88dd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -7849,12 +7849,8 @@ register_dtor_fn (tree decl)\n   use_dtor = ob_parm && CLASS_TYPE_P (type);\n   if (use_dtor)\n     {\n-      int idx;\n+      cleanup = lookup_fnfields_slot (type, complete_dtor_identifier);\n \n-      /* Find the destructor.  */\n-      idx = lookup_fnfields_1 (type, complete_dtor_identifier);\n-      gcc_assert (idx >= 0);\n-      cleanup = (*CLASSTYPE_METHOD_VEC (type))[idx];\n       /* Make sure it is accessible.  */\n       perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup,\n \t\t\t\t     tf_warning_or_error);"}, {"sha": "877745c546beb89c3d073dd2356333f71575186e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 75, "deletions": 102, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -558,10 +558,6 @@ check_member_template (tree tmpl)\n tree\n check_classfn (tree ctype, tree function, tree template_parms)\n {\n-  int ix;\n-  bool is_template;\n-  tree pushed_scope;\n-  \n   if (DECL_USE_TEMPLATE (function)\n       && !(TREE_CODE (function) == TEMPLATE_DECL\n \t   && DECL_TEMPLATE_SPECIALIZATION (function))\n@@ -594,7 +590,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n     }\n \n   /* OK, is this a definition of a member template?  */\n-  is_template = (template_parms != NULL_TREE);\n+  bool is_template = (template_parms != NULL_TREE);\n \n   /* [temp.mem]\n \n@@ -608,111 +604,88 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   /* We must enter the scope here, because conversion operators are\n      named by target type, and type equivalence relies on typenames\n      resolving within the scope of CTYPE.  */\n-  pushed_scope = push_scope (ctype);\n-  ix = class_method_index_for_fn (complete_type (ctype), function);\n-  if (ix >= 0)\n-    {\n-      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (ctype);\n-\n-      for (ovl_iterator iter ((*methods)[ix]); iter; ++iter)\n-\t{\n-\t  tree fndecl = *iter;\n-\t  tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n-\t  tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-\n-\t  /* We cannot simply call decls_match because this doesn't\n-\t     work for static member functions that are pretending to\n-\t     be methods, and because the name may have been changed by\n-\t     asm(\"new_name\").  */\n-\n-\t   /* Get rid of the this parameter on functions that become\n-\t      static.  */\n-\t  if (DECL_STATIC_FUNCTION_P (fndecl)\n-\t      && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n-\t    p1 = TREE_CHAIN (p1);\n-\n-\t  /* A member template definition only matches a member template\n-\t     declaration.  */\n-\t  if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n-\t    continue;\n-\n-\t  /* ref-qualifier or absence of same must match.  */\n-\t  if (type_memfn_rqual (TREE_TYPE (function))\n-\t      != type_memfn_rqual (TREE_TYPE (fndecl)))\n-\t    continue;\n-\n-\t  // Include constraints in the match.\n-\t  tree c1 = get_constraints (function);\n-\t  tree c2 = get_constraints (fndecl);\n-\n-\t  /* While finding a match, same types and params are not enough\n-\t     if the function is versioned.  Also check version (\"target\")\n-\t     attributes.  */\n-\t  if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n-\t\t\t   TREE_TYPE (TREE_TYPE (fndecl)))\n-\t      && compparms (p1, p2)\n-\t      && !targetm.target_option.function_versions (function, fndecl)\n-\t      && (!is_template\n-\t\t  || comp_template_parms (template_parms,\n-\t\t\t\t\t  DECL_TEMPLATE_PARMS (fndecl)))\n-\t      && equivalent_constraints (c1, c2)\n-\t      && (DECL_TEMPLATE_SPECIALIZATION (function)\n-\t\t  == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n-\t      && (!DECL_TEMPLATE_SPECIALIZATION (function)\n-\t\t  || (DECL_TI_TEMPLATE (function)\n-\t\t      == DECL_TI_TEMPLATE (fndecl))))\n-\t    {\n-\t      if (pushed_scope)\n-\t\tpop_scope (pushed_scope);\n-\t      return fndecl;\n-\t    }\n-\t}\n-\n-      error_at (DECL_SOURCE_LOCATION (function),\n-\t\t\"prototype for %q#D does not match any in class %qT\",\n-\t\tfunction, ctype);\n+  tree pushed_scope = push_scope (ctype);\n+  tree matched = NULL_TREE;\n+  tree fns = lookup_fnfields_slot (ctype, DECL_NAME (function));\n+  \n+  for (ovl_iterator iter (fns); !matched && iter; ++iter)\n+    {\n+      tree fndecl = *iter;\n+      tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n+      tree p2 = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\n+      /* We cannot simply call decls_match because this doesn't work\n+\t for static member functions that are pretending to be\n+\t methods, and because the name may have been changed by\n+\t asm(\"new_name\").  */\n+\n+      /* Get rid of the this parameter on functions that become\n+\t static.  */\n+      if (DECL_STATIC_FUNCTION_P (fndecl)\n+\t  && TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE)\n+\tp1 = TREE_CHAIN (p1);\n+\n+      /* A member template definition only matches a member template\n+\t declaration.  */\n+      if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))\n+\tcontinue;\n \n-      const char *format = NULL;\n-      tree first = OVL_FIRST ((*methods)[ix]);\n-      bool is_conv_op = DECL_CONV_FN_P (first);\n-      tree prev = NULL_TREE;\n+      /* ref-qualifier or absence of same must match.  */\n+      if (type_memfn_rqual (TREE_TYPE (function))\n+\t  != type_memfn_rqual (TREE_TYPE (fndecl)))\n+\tcontinue;\n \n-      if (is_conv_op)\n-\tix = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-      do\n-\t{\n-\t  ovl_iterator iter ((*methods)[ix++]);\n-\t  if (is_conv_op && !DECL_CONV_FN_P (*iter))\n-\t    break;\n-\t  for (; iter; ++iter)\n-\t    {\n-\t      if (prev)\n-\t\t{\n-\t\t  if (!format)\n-\t\t    format = N_(\"candidates are: %+#D\");\n-\t\t  error (format, prev);\n-\t\t  format = \"                %+#D\";\n-\t\t}\n-\t      prev = *iter;\n-\t    }\n-\t}\n-      while (is_conv_op && size_t (ix) < methods->length ());\n-      if (prev)\n+      // Include constraints in the match.\n+      tree c1 = get_constraints (function);\n+      tree c2 = get_constraints (fndecl);\n+\n+      /* While finding a match, same types and params are not enough\n+\t if the function is versioned.  Also check version (\"target\")\n+\t attributes.  */\n+      if (same_type_p (TREE_TYPE (TREE_TYPE (function)),\n+\t\t       TREE_TYPE (TREE_TYPE (fndecl)))\n+\t  && compparms (p1, p2)\n+\t  && !targetm.target_option.function_versions (function, fndecl)\n+\t  && (!is_template\n+\t      || comp_template_parms (template_parms,\n+\t\t\t\t      DECL_TEMPLATE_PARMS (fndecl)))\n+\t  && equivalent_constraints (c1, c2)\n+\t  && (DECL_TEMPLATE_SPECIALIZATION (function)\n+\t      == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n+\t  && (!DECL_TEMPLATE_SPECIALIZATION (function)\n+\t      || (DECL_TI_TEMPLATE (function) == DECL_TI_TEMPLATE (fndecl))))\n+\tmatched = fndecl;\n+    }\n+\n+  if (!matched)\n+    {\n+      if (!COMPLETE_TYPE_P (ctype))\n+\tcxx_incomplete_type_error (function, ctype);\n+      else\n \t{\n-\t  if (!format)\n-\t    format = N_(\"candidate is: %+#D\");\n-\t  error (format, prev);\n+\t  if (DECL_CONV_FN_P (function))\n+\t    fns = lookup_all_conversions (ctype);\n+\n+\t  error_at (DECL_SOURCE_LOCATION (function),\n+\t\t    \"no declaration matches %q#D\", function);\n+\t  if (fns)\n+\t    print_candidates (fns);\n+\t  else if (DECL_CONV_FN_P (function))\n+\t    inform (DECL_SOURCE_LOCATION (function),\n+\t\t    \"no conversion operators declared\");\n+\t  else\n+\t    inform (DECL_SOURCE_LOCATION (function),\n+\t\t    \"no functions named %qD\", function);\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (ctype)),\n+\t\t  \"%#qT defined here\", ctype);\n \t}\n+      matched = error_mark_node;\n     }\n-  else if (!COMPLETE_TYPE_P (ctype))\n-    cxx_incomplete_type_error (function, ctype);\n-  else\n-    error (\"no %q#D member function declared in class %qT\",\n-\t   function, ctype);\n \n   if (pushed_scope)\n     pop_scope (pushed_scope);\n-  return error_mark_node;\n+\n+  return matched;\n }\n \n /* DECL is a function with vague linkage.  Remember it so that at the"}, {"sha": "6b6a1a694b7a958a000ddf9922229920706f3b5a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1196,15 +1196,10 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n \t= retrieve_specialization (class_template, args, 0);\n       if (!class_specialization)\n \treturn NULL_TREE;\n-      /* Now, find the appropriate entry in the CLASSTYPE_METHOD_VEC\n-\t for the specialization.  */\n-      int idx = class_method_index_for_fn (class_specialization, tmpl);\n-      if (idx == -1)\n-\treturn NULL_TREE;\n-      /* Iterate through the methods with the indicated name, looking\n-\t for the one that has an instance of TMPL.  */\n-      vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (class_specialization);\n-      for (ovl_iterator iter ((*methods)[idx]); iter; ++iter)\n+\n+      /* Find the instance of TMPL.  */\n+      tree fns = lookup_fnfields_slot (class_specialization, DECL_NAME (tmpl));\n+      for (ovl_iterator iter (fns); iter; ++iter)\n \t{\n \t  tree fn = *iter;\n \t  if (DECL_TEMPLATE_INFO (fn) && DECL_TI_TEMPLATE (fn) == tmpl\n@@ -2876,8 +2871,6 @@ check_explicit_specialization (tree declarator,\n \t  /* Find the list of functions in ctype that have the same\n \t     name as the declared function.  */\n \t  tree name = TREE_OPERAND (declarator, 0);\n-\t  tree fns = NULL_TREE;\n-\t  int idx;\n \n \t  if (constructor_name_p (name, ctype))\n \t    {\n@@ -2900,39 +2893,16 @@ check_explicit_specialization (tree declarator,\n \t      name = DECL_NAME (decl);\n \t    }\n \n-\t  if (!DECL_CONV_FN_P (decl))\n-\t    {\n-\t      idx = lookup_fnfields_1 (ctype, name);\n-\t      if (idx >= 0)\n-\t\tfns = (*CLASSTYPE_METHOD_VEC (ctype))[idx];\n-\t    }\n+\t  tree fns = NULL_TREE;\n+\t  if (DECL_CONV_FN_P (decl))\n+\t    /* For a type-conversion operator, we cannot do a\n+\t       name-based lookup.  We might be looking for `operator\n+\t       int' which will be a specialization of `operator T'.\n+\t       Grab all the conversion operators, and then select from\n+\t       them.  */\n+\t    fns = lookup_all_conversions (ctype);\n \t  else\n-\t    {\n-\t      vec<tree, va_gc> *methods;\n-\t      tree ovl;\n-\n-\t      /* For a type-conversion operator, we cannot do a\n-\t\t name-based lookup.  We might be looking for `operator\n-\t\t int' which will be a specialization of `operator T'.\n-\t\t So, we find *all* the conversion operators, and then\n-\t\t select from them.  */\n-\t      fns = NULL_TREE;\n-\n-\t      methods = CLASSTYPE_METHOD_VEC (ctype);\n-\t      if (methods)\n-\t\tfor (idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t\t     methods->iterate (idx, &ovl);\n-\t\t     ++idx)\n-\t\t  {\n-\t\t    if (!DECL_CONV_FN_P (OVL_FIRST (ovl)))\n-\t\t      /* There are no more conversion functions.  */\n-\t\t      break;\n-\n-\t\t    /* Glue all these conversion functions together\n-\t\t       with those we already have.  */\n-\t\t    fns = lookup_add (ovl, fns);\n-\t\t  }\n-\t    }\n+\t    fns = lookup_fnfields_slot_nolazy (ctype, name);\n \n \t  if (fns == NULL_TREE)\n \t    {"}, {"sha": "cd06e529fb94d79864f3c59e74d9c13fce0d9fac", "filename": "gcc/cp/search.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1648,7 +1648,7 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n /* TYPE is a class type. Return the index of the fields within\n    the method vector with name NAME, or -1 if no such field exists.  */\n \n-int\n+static int\n lookup_fnfields_1 (tree type, tree name)\n {\n   if (!CLASS_TYPE_P (type))\n@@ -1705,17 +1705,29 @@ lookup_fnfields_slot_nolazy (tree type, tree name)\n   return (*CLASSTYPE_METHOD_VEC (type))[ix];\n }\n \n-/* Like lookup_fnfields_1, except that the name is extracted from\n-   FUNCTION, which is a FUNCTION_DECL or a TEMPLATE_DECL.  */\n+/* Collect all the conversion operators of KLASS.  */\n \n-int\n-class_method_index_for_fn (tree class_type, tree function)\n+tree\n+lookup_all_conversions (tree klass)\n {\n-  gcc_assert (DECL_DECLARES_FUNCTION_P (function));\n+  tree lkp = NULL_TREE;\n \n-  return lookup_fnfields_1 (class_type, DECL_NAME (function));\n-}\n+  if (vec<tree, va_gc> *methods = CLASSTYPE_METHOD_VEC (klass))\n+    {\n+      tree ovl;\n+      for (int idx = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t   methods->iterate (idx, &ovl); ++idx)\n+\t{\n+\t  if (!DECL_CONV_FN_P (OVL_FIRST (ovl)))\n+\t    /* There are no more conversion functions.  */\n+\t    break;\n+\n+\t  lkp = lookup_add (ovl, lkp);\n+\t}\n+    }\n \n+  return lkp;\n+}\n \n /* DECL is the result of a qualified name lookup.  QUALIFYING_SCOPE is\n    the class or namespace used to qualify the name.  CONTEXT_CLASS is"}, {"sha": "e13943aaa322aa54e813fe1ce63471647ec9f49e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -9081,11 +9081,9 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n \n   if (assign_p)\n     {\n-      int ix;\n-      ix = lookup_fnfields_1 (type, cp_assignment_operator_id (NOP_EXPR));\n-      if (ix < 0)\n+      fns = lookup_fnfields_slot (type, cp_assignment_operator_id (NOP_EXPR));\n+      if (!fns)\n \treturn false;\n-      fns = (*CLASSTYPE_METHOD_VEC (type))[ix];\n     } \n   else if (TYPE_HAS_COPY_CTOR (type))\n     {"}, {"sha": "2637ecc6262eba162f97cf9d00a4beee12cd2828", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,3 +1,24 @@\n+2017-06-30  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/concepts/memfun-err.C: Adjust diagnostics.\n+\t* g++.dg/cpp0x/decltype9.C: Likewise.\n+\t* g++.dg/cpp0x/forw_enum9.C: Likewise.\n+\t* g++.dg/lookup/decl1.C: Likewise.\n+\t* g++.dg/lookup/extern-c-redecl.C: Likewise.\n+\t* g++.dg/other/pr28432.C: Likewise.\n+\t* g++.dg/parse/crash12.C: Likewise.\n+\t* g++.dg/parse/enum3.C: Likewise.\n+\t* g++.dg/parse/operator6.C: Likewise.\n+\t* g++.dg/template/crash69.C: Likewise.\n+\t* g++.dg/template/error27.C: Likewise.\n+\t* g++.dg/template/error28.C: Likewise.\n+\t* g++.dg/template/memfriend6.C: Likewise.\n+\t* g++.old-deja/g++.mike/err1.C: Likewise.\n+\t* g++.old-deja/g++.mike/p811.C: Likewise.\n+\t* g++.old-deja/g++.other/crash25.C: Likewise.\n+\t* g++.old-deja/g++.other/dtor4.C: Likewise.\n+\t* g++.old-deja/g++.pt/t37.C: Likewise.\n+\n 2017-06-30  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/81214"}, {"sha": "f44610a6aa0df4fde9f57ddaa05ddd6392bfa590", "filename": "gcc/testsuite/g++.dg/concepts/memfun-err.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun-err.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun-err.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fmemfun-err.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -15,16 +15,16 @@ int called = 0;\n \n // Test constrained member definitions\n template<typename T>\n-  struct S1 {\n+  struct S1 { // { dg-message \"defined here\" }\n     void f1() requires C<T>() { }\n     void g1() requires C<T>() and true;\n     template<C U> void h1(U u) { called = 1; }\n \n-    void g2() requires C<T>(); // { dg-error \"candidate\" }\n+    void g2() requires C<T>(); // { dg-message \"candidate\" }\n   };\n \n template<typename T>\n-  void S1<T>::g2() requires D<T>() { } // { dg-error \"prototype\" }\n+  void S1<T>::g2() requires D<T>() { } // { dg-error \"no declaration matches\" }\n \n int main() {\n   S1<X> sx;"}, {"sha": "45cd9ed7da3ed9db2fe7612310dbb5f26d0a5e15", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype9.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype9.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,9 +1,9 @@\n // PR c++/34271\n // { dg-do compile { target c++11 } }\n \n-template<int> struct A\n-{\n+template<int> struct A { // { dg-message \"defined here\" }\n   static int i;\n };\n \n-template<int N> int A<N>::i(decltype (A::i));\t// { dg-error \"member function|must be an expression\" }\n+template<int N> int A<N>::i(decltype (A::i));\t// { dg-error \"no declaration\" }\n+// { dg-message \"no functions\" \"note\" { target *-*-* } .-1 }"}, {"sha": "acf16c6c8bdd2341c2a7e92619991fe4432693b2", "filename": "gcc/testsuite/g++.dg/cpp0x/forw_enum9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fforw_enum9.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -4,7 +4,7 @@\n template<typename T> struct S1\n {\n     enum E1 : int;\n-    enum class E2 : int;\n+    enum class E2 : T;\n };\n \n template<typename T> enum S1<T>::E1 : int { e1 };"}, {"sha": "205ffcff1d73d10397cd5afe9e28f968d1b36b94", "filename": "gcc/testsuite/g++.dg/lookup/decl1.C", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fdecl1.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -19,14 +19,13 @@ C2<X>::operator C1<Y>()\n   return C1<Y>();\n }\n \n-struct A\n-{\n-  operator int ();\t\t\t// { dg-error \"operator\" }\n-  operator float ();\t\t\t// { dg-error \"operator\" }\n-  operator float () const;\t\t// { dg-error \"operator\" }\n-  template <typename T> operator T * (); // { dg-error \"candidates\" }\n+struct A { // { dg-message \"defined here\" }\n+  operator int ();\t\t\t// { dg-message \"operator\" }\n+  operator float ();\t\t\t// { dg-message \"operator\" }\n+  operator float () const;\t\t// { dg-message \"operator\" }\n+  template <typename T> operator T * (); // { dg-message \"operator\" }\n };\n \n-A::operator short () { // { dg-error \"prototype for\" }\n+A::operator short () { // { dg-error \"no declaration matches\" }\n   return 0;\n }"}, {"sha": "3e901cc7759a7b3a12b623f5dec41ceb55b8e537", "filename": "gcc/testsuite/g++.dg/lookup/extern-c-redecl.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fextern-c-redecl.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fextern-c-redecl.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fextern-c-redecl.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -8,4 +8,4 @@ namespace A {\n // next line should trigger an error because\n // it conflicts with previous declaration of foo_func (), due to\n // different exception specifications.\n-extern \"C\" void foo_func (); // { dg-error \"C language|exception specifications\" }\n+extern \"C\" void foo_func (); // { dg-error \"C language linkage|exception specifications\" }"}, {"sha": "8e2428594d90614a5646871d6c776a250c0363bc", "filename": "gcc/testsuite/g++.dg/other/pr28432.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr28432.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr28432.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr28432.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -3,5 +3,7 @@\n \n // { dg-options \"\" }\n \n-struct A {};\n-void A::foo(); // { dg-error \"member function declared in class|outside of class is not definition\" }\n+struct A {}; // { dg-message \"defined here\" }\n+\n+void A::foo(); // { dg-error \"no declaration matches\" }\n+// { dg-message \"no functions named\" \"note\" { target *-*-* } .-1 }"}, {"sha": "61921fded8f9ac48d6fa0185a2e7faf5afffb5ab", "filename": "gcc/testsuite/g++.dg/parse/crash12.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash12.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -6,15 +6,16 @@\n \n template <class _Tp> class auto_ptr {};\n template <class _Tp>\n-class counted_ptr\n-{\n+class counted_ptr { // { dg-message \"defined here\" }\n public:\n-  counted_ptr(::auto_ptr<_Tp>& __a);\t\t// { dg-error \"candidate\" }\n+  counted_ptr(::auto_ptr<_Tp>& __a);\t\t// { dg-message \"candidate\" }\n   ::auto_ptr<_Tp> auto_ptr();\n };\n \n template <class _Tp>\n-inline counted_ptr<_Tp>::counted_ptr(class auto_ptr& __a) // { dg-error \"required|not match|template\" }\n+inline counted_ptr<_Tp>::counted_ptr(class auto_ptr& __a)\n+// { dg-error \"no declaration matches\" \"\" { target *-*-* } .-1 }\n+// { dg-error \"template argument required\" \"\" { target *-*-* } .-2 }\n {\n }\n "}, {"sha": "81e6963567811aa2141859e83d92aabdcc7c87f1", "filename": "gcc/testsuite/g++.dg/parse/enum3.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fenum3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fenum3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fenum3.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,5 +1,7 @@\n // PR c++/28261\n \n-struct A {}; // { dg-error \"A::A\" }\n+struct A {}; // { dg-message \"A::A\" }\n+// { dg-message \"defined here\" \"\" { target *-*-* } .-1 }\n \n-A::A (enum { e }) {} // { dg-error \"defined|prototype\" }\n+A::A (enum { e }) {} // { dg-error \"no declaration matches\" }\n+// { dg-error \"in parameter types\" \"\" { target *-*-* } .-1 }"}, {"sha": "c13860efd809e501f4cabf4967c0281208dd0019", "filename": "gcc/testsuite/g++.dg/parse/operator6.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Foperator6.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,5 +1,6 @@\n // PR c++/25635\n \n-struct A {};\n+struct A {}; // { dg-message \"defined here\" }\n \n-A::operator int(); // { dg-error \"class\" }\n+A::operator int(); // { dg-error \"no declaration matches\" }\n+// { dg-message \"no conversion operators\" \"\" { target *-*-* } .-1 }"}, {"sha": "21ed91bb27ee451314013e72047ef0530e9a5c6f", "filename": "gcc/testsuite/g++.dg/template/crash69.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash69.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash69.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash69.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -3,10 +3,11 @@\n template<typename T> class A\n {\n   static int i; // { dg-message \"private\" }\n-  friend int T::foo(); // { dg-error \"does not match\" }\n+  friend int T::foo(); // { dg-error \"no declaration matches\" }\n };\n \n struct B\n {\n-  void foo() { A<B>::i; } // { dg-error \"within|candidate\" }\n+  void foo() { A<B>::i; } // { dg-message \"candidate\" }\n+  // { dg-error \"private within\" \"\" { target *-*-* } .-1 }\n };"}, {"sha": "7f15f8c284dabfa68c5655d67b32a989a393448a", "filename": "gcc/testsuite/g++.dg/template/error27.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror27.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,5 +1,6 @@\n // PR c++/27211\n \n-struct A {};\n+struct A {}; // { dg-message \"defined here\" }\n \n-template<int> void A::foo() {} // { dg-error \"member function\" }\n+template<int> void A::foo() {} // { dg-error \"no declaration matches\" }\n+// { dg-message \"no functions named\" \"note\" { target *-*-* } .-1 }"}, {"sha": "d4cf031210b1ecb5475cd7a8c7b81ce38d7d6f4b", "filename": "gcc/testsuite/g++.dg/template/error28.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror28.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,5 +1,6 @@\n // PR c++/27211\n \n-struct A {};\n+struct A {}; // { dg-message \"defined here\" }\n \n-template<int> void A::foo(); // { dg-error \"member function\" }\n+template<int> void A::foo(); // { dg-error \"no declaration matches\" }\n+// { dg-message \"no functions named\" \"note\" { target *-*-* } .-1 }"}, {"sha": "4f1268626706484d1ac4ba363683b5da58fc1336", "filename": "gcc/testsuite/g++.dg/template/memfriend6.C", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend6.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -6,18 +6,21 @@\n // Member function of class template as friend\n // Erroneous case: mismatch during declaration\n \n-template <class T> struct A {\n-  template <class U> void f(U);\t\t// { dg-error \"candidate\" }\n-  void g();\t\t\t\t// { dg-error \"candidate|with\" }\n-  void h();\t\t\t\t// { dg-error \"candidate|with\" }\n-  void i(int);\t\t\t\t// { dg-error \"candidate\" }\n+template <class T> struct A { // { dg-message \"defined here\" }\n+  template <class U> void f(U);\t\t// { dg-message \"candidate\" }\n+  void g();\t\t\t\t// { dg-message \"candidate\" }\n+  void h();\t\t\t\t// { dg-message \"candidate\" }\n+  void i(int);\t\t\t\t// { dg-message \"candidate\" }\n };\n \n class C {\n   int ii;\n-  template <class U> friend void A<U>::f(U);\t// { dg-error \"not match\" }\n+  template <class U>\n+  friend void A<U>::f(U); // { dg-error \"no declaration matches\" }\n   template <class U> template <class V>\n-    friend void A<U>::g();\t\t\t// { dg-error \"not match|cannot be overloaded\" }\n-  template <class U> friend int A<U>::h();\t// { dg-error \"not match|cannot be overloaded\" }\n-  template <class U> friend void A<U>::i(char);\t// { dg-error \"not match\" }\n+    friend void A<U>::g();  // { dg-error \"no declaration matches\" }\n+  template <class U>\n+  friend int A<U>::h();\t// { dg-error \"no declaration matches\" }\n+  template <class U>\n+  friend void A<U>::i(char);\t// { dg-error \"no declaration matches\" }\n };"}, {"sha": "90f4ce68e55366554126f09b242d885fce58059a", "filename": "gcc/testsuite/g++.old-deja/g++.mike/err1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Ferr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Ferr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Ferr1.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,8 +1,8 @@\n // { dg-do assemble  }\n \n-struct gorf {\n+struct gorf { // { dg-message \"defined here\" }\n   int stuff;\n-  void snarf();\t\t\t// { dg-error \"\" } \n+  void snarf();\t\t\t// { dg-message \"\" } \n };\n \n-template <class T> void gorf::snarf() { return; }  // { dg-error \"\" } \n+template <class T> void gorf::snarf() { return; }  // { dg-error \"no declaration\" } "}, {"sha": "5c8260aa1f8ae6b8b2dbbf745e35fabe9b997b00", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p811.C", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp811.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp811.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp811.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -515,21 +515,22 @@ public:\n     virtual char *stringify2() const = 0; // { dg-error \"overriding\" } \n };\n \n-class X: public Y {\n+class X: public Y { // { dg-message \"defined here\" }\n public:\n     X(): Y() {}\n-    const char *stringify();\t\t// { dg-error \"candidate\" }\n-    const char *stringify2() const;  // { dg-error \"candidate|conflicting return type\" }\n+    const char *stringify();\t\t// { dg-message \"candidate\" }\n+    const char *stringify2() const;  // { dg-message \"candidate\" }\n+  // { dg-error \"conflicting return type\" \"\" { target *-*-* } .-1 }\n };\n \n char *\n-X::stringify() const  // { dg-error \"does not match\" }\n+X::stringify() const  // { dg-error \"no declaration matches\" }\n {\n     return \"stringify\";\n }\n \n const char *\n-X::stringify2()   // { dg-error \"does not match\" }\n+X::stringify2()   // { dg-error \"no declaration matches\" }\n {\n     return \"stringify2\";\n }"}, {"sha": "0611286fdc3a11362528fce34827c7575593ac72", "filename": "gcc/testsuite/g++.old-deja/g++.other/crash25.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fcrash25.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -9,7 +9,8 @@ public:\n   virtual ~X();\n }\n \n-X::x()\t// { dg-error \"6:no 'X X::x\\\\(\\\\)' member function declared in class 'X'\" }\n+X::x()\t// { dg-error \"1:no declaration matches\" }\n+// { dg-message \"1:no functions named\" \"note\" { target *-*-* } .-1 }\n {\n }\n "}, {"sha": "b7ae370686430bcf42dd36bb6c67bbbc5b51fc59", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor4.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor4.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,10 +1,10 @@\n // { dg-do assemble  }\n \n-struct S1 {\n-  ~S1(); // { dg-error \"\" } candidate\n+struct S1 { // { dg-message \"defined here\" }\n+  ~S1(); // { dg-message \"candidate\" }\n };\n \n-S1::~S1() const // { dg-error \"\" } prototype does not match \n+S1::~S1() const // { dg-error \"no declaration matches\" }\n {\n }\n \n@@ -15,12 +15,12 @@ struct S2 {\n \n \n template <class T>\n-struct S3 {\n-  ~S3(); // { dg-error \"\" } candidate\n+struct S3 { // { dg-message \"defined here\" }\n+  ~S3(); // { dg-message \"candidate\" }\n };\n \n template <class T>\n-S3<T>::~S3() volatile  // { dg-error \"\" } prototype does not match \n+S3<T>::~S3() volatile  // { dg-error \"no declaration matches\" }\n {\n }\n "}, {"sha": "dbf1f4403b31cdbac292e7887bc280ceea1fd6dd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/t37.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe32bb1b5bd2973305a206a29ed4c7c8749d98c5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft37.C?ref=fe32bb1b5bd2973305a206a29ed4c7c8749d98c5", "patch": "@@ -1,9 +1,10 @@\n-// { dg-do assemble  }\n+// { dg-do compile  }\n \n-class A { // { dg-error \"\" } synthesized copy ctor\n+class A { // { dg-message \"A::A\" } synthesized copy ctor\n+  // { dg-message \"defined here\" \"note\" { target *-*-* } .-1 }\n public:\n-  A(int);\t\t\t// { dg-error \"\" } referenced below\n-  A(float);\t\t\t// { dg-error \"\" } referenced below\n+  A(int);\t\t\t// { dg-message \"A::A\" }\n+  A(float);\t\t\t// { dg-message \"A::A\" }\n   ~A();\n };\n "}]}