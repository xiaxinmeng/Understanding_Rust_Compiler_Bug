{"sha": "3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmM2U1YzZhMmRjZDAyMzNlZTIzN2YyOTFmZGY5YWMyNTA1MmRkNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:53:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:53:58Z"}, "message": "exp_aggr.adb (Gen_Assign): If the expression is an aggregate for a component of an array of arrays in an...\n\n\t* exp_aggr.adb (Gen_Assign): If the expression is an aggregate for a\n\tcomponent of an array of arrays in an assignment context, and the\n\taggregate has component associations that require sliding on\n\tassignment, force reanalysis of the aggregate to generate a temporary\n\tbefore the assignment.\n\t(Must_Slide): Make global to the package, for use in Gen_Assign.\n\nFrom-SVN: r94813", "tree": {"sha": "44499b9077a6544e5f3e3a179c5f89d3b38ff3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44499b9077a6544e5f3e3a179c5f89d3b38ff3d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5/comments", "author": null, "committer": null, "parents": [{"sha": "8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e"}], "stats": {"total": 290, "additions": 158, "deletions": 132}, "files": [{"sha": "ad2dcbe132608e8ac005450459db0b6816bcb3d2", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 158, "deletions": 132, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=3cf3e5c6a2dcd0233ee237f291fdf9ac25052dd5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -67,6 +67,20 @@ package body Exp_Aggr is\n    type Case_Table_Type is array (Nat range <>) of Case_Bounds;\n    --  Table type used by Check_Case_Choices procedure\n \n+   function Must_Slide\n+     (Obj_Type : Entity_Id;\n+      Typ      : Entity_Id) return Boolean;\n+   --  A static array aggregate in an object declaration can in most cases be\n+   --  expanded in place. The one exception is when the aggregate is given\n+   --  with component associations that specify different bounds from those of\n+   --  the type definition in the object declaration. In this pathological\n+   --  case the aggregate must slide, and we must introduce an intermediate\n+   --  temporary to hold it.\n+   --\n+   --  The same holds in an assignment to one-dimensional array of arrays,\n+   --  when a component may be given with bounds that differ from those of the\n+   --  component type.\n+\n    procedure Sort_Case_Table (Case_Table : in out Case_Table_Type);\n    --  Sort the Case Table using the Lower Bound of each Choice as the key.\n    --  A simple insertion sort is used since the number of choices in a case\n@@ -110,16 +124,16 @@ package body Exp_Aggr is\n       Flist                         : Node_Id   := Empty;\n       Obj                           : Entity_Id := Empty;\n       Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id;\n-   --  N is an N_Aggregate or a N_Extension_Aggregate. Typ is the type\n-   --  of the aggregate. Target is an expression containing the\n-   --  location on which the component by component assignments will\n-   --  take place. Returns the list of assignments plus all other\n-   --  adjustments needed for tagged and controlled types. Flist is an\n-   --  expression representing the finalization list on which to\n-   --  attach the controlled components if any. Obj is present in the\n-   --  object declaration and dynamic allocation cases, it contains\n-   --  an entity that allows to know if the value being created needs to be\n-   --  attached to the final list in case of pragma finalize_Storage_Only.\n+   --  N is an N_Aggregate or a N_Extension_Aggregate. Typ is the type of the\n+   --  aggregate. Target is an expression containing the location on which the\n+   --  component by component assignments will take place. Returns the list of\n+   --  assignments plus all other adjustments needed for tagged and controlled\n+   --  types. Flist is an expression representing the finalization list on\n+   --  which to attach the controlled components if any. Obj is present in the\n+   --  object declaration and dynamic allocation cases, it contains an entity\n+   --  that allows to know if the value being created needs to be attached to\n+   --  the final list in case of pragma finalize_Storage_Only.\n+   --\n    --  Is_Limited_Ancestor_Expansion indicates that the function has been\n    --  called recursively to expand the limited ancestor to avoid copying it.\n \n@@ -159,19 +173,19 @@ package body Exp_Aggr is\n       Max_Others_Replicate : Nat     := 5;\n       Handle_Bit_Packed    : Boolean := False);\n    --  If possible, convert named notation to positional notation. This\n-   --  conversion is possible only in some static cases. If the conversion\n-   --  is possible, then N is rewritten with the analyzed converted\n-   --  aggregate. The parameter Max_Others_Replicate controls the maximum\n-   --  number of values corresponding to an others choice that will be\n-   --  converted to positional notation (the default of 5 is the normal\n-   --  limit, and reflects the fact that normally the loop is better than\n-   --  a lot of separate assignments). Note that this limit gets overridden\n-   --  in any case if either of the restrictions No_Elaboration_Code or\n-   --  No_Implicit_Loops is set. The parameter Handle_Bit_Packed is usually\n-   --  set False (since we do not expect the back end to handle bit packed\n-   --  arrays, so the normal case of conversion is pointless), but in the\n-   --  special case of a call from Packed_Array_Aggregate_Handled, we set\n-   --  this parameter to True, since these are cases we handle in there.\n+   --  conversion is possible only in some static cases. If the conversion is\n+   --  possible, then N is rewritten with the analyzed converted aggregate.\n+   --  The parameter Max_Others_Replicate controls the maximum number of\n+   --  values corresponding to an others choice that will be converted to\n+   --  positional notation (the default of 5 is the normal limit, and reflects\n+   --  the fact that normally the loop is better than a lot of separate\n+   --  assignments). Note that this limit gets overridden in any case if\n+   --  either of the restrictions No_Elaboration_Code or No_Implicit_Loops is\n+   --  set. The parameter Handle_Bit_Packed is usually set False (since we do\n+   --  not expect the back end to handle bit packed arrays, so the normal case\n+   --  of conversion is pointless), but in the special case of a call from\n+   --  Packed_Array_Aggregate_Handled, we set this parameter to True, since\n+   --  these are cases we handle in there.\n \n    procedure Expand_Array_Aggregate (N : Node_Id);\n    --  This is the top-level routine to perform array aggregate expansion.\n@@ -220,18 +234,17 @@ package body Exp_Aggr is\n       Target : Node_Id;\n       Flist  : Node_Id := Empty;\n       Obj    : Entity_Id := Empty) return List_Id;\n-   --  N is a nested (record or array) aggregate that has been marked\n-   --  with 'Delay_Expansion'. Typ is the expected type of the\n-   --  aggregate and Target is a (duplicable) expression that will\n-   --  hold the result of the aggregate expansion. Flist is the\n-   --  finalization list to be used to attach controlled\n-   --  components. 'Obj' when non empty, carries the original object\n-   --  being initialized in order to know if it needs to be attached\n-   --  to the previous parameter which may not be the case when\n-   --  Finalize_Storage_Only is set.  Basically this procedure is used\n-   --  to implement top-down expansions of nested aggregates. This is\n-   --  necessary for avoiding temporaries at each level as well as for\n-   --  propagating the right internal finalization list.\n+   --  N is a nested (record or array) aggregate that has been marked with\n+   --  'Delay_Expansion'. Typ is the expected type of the aggregate and Target\n+   --  is a (duplicable) expression that will hold the result of the aggregate\n+   --  expansion. Flist is the finalization list to be used to attach\n+   --  controlled components. 'Obj' when non empty, carries the original\n+   --  object being initialized in order to know if it needs to be attached to\n+   --  the previous parameter which may not be the case in the case where\n+   --  Finalize_Storage_Only is set. Basically this procedure is used to\n+   --  implement top-down expansions of nested aggregates. This is necessary\n+   --  for avoiding temporaries at each level as well as for propagating the\n+   --  right internal finalization list.\n \n    function Make_OK_Assignment_Statement\n      (Sloc       : Source_Ptr;\n@@ -280,10 +293,10 @@ package body Exp_Aggr is\n \n    function Backend_Processing_Possible (N : Node_Id) return Boolean is\n       Typ : constant Entity_Id := Etype (N);\n-      --  Typ is the correct constrained array subtype of the aggregate.\n+      --  Typ is the correct constrained array subtype of the aggregate\n \n       function Static_Check (N : Node_Id; Index : Node_Id) return Boolean;\n-      --  Recursively checks that N is fully positional, returns true if so.\n+      --  Recursively checks that N is fully positional, returns true if so\n \n       ------------------\n       -- Static_Check --\n@@ -352,13 +365,12 @@ package body Exp_Aggr is\n       end if;\n \n       --  Checks 5 (if the component type is tagged, then we may need\n-      --    to do tag adjustments; perhaps this should be refined to\n-      --    check for any component associations that actually\n-      --    need tag adjustment, along the lines of the test that's\n-      --    done in Has_Delayed_Nested_Aggregate_Or_Tagged_Comps\n-      --    for record aggregates with tagged components, but not\n-      --    clear whether it's worthwhile ???; in the case of the\n-      --    JVM, object tags are handled implicitly)\n+      --    to do tag adjustments; perhaps this should be refined to check for\n+      --    any component associations that actually need tag adjustment,\n+      --    along the lines of the test that is carried out in\n+      --    Has_Delayed_Nested_Aggregate_Or_Tagged_Comps for record aggregates\n+      --    with tagged components, but not clear whether it's worthwhile ???;\n+      --    in the case of the JVM, object tags are handled implicitly)\n \n       if Is_Tagged_Type (Component_Type (Typ)) and then not Java_VM then\n          return False;\n@@ -392,11 +404,11 @@ package body Exp_Aggr is\n    --         we are dealing with an expression we emit a sequence of\n    --         assignments instead of a loop.\n \n-   --     (c) Generate the remaining loops to cover the others choice if any.\n+   --     (c) Generate the remaining loops to cover the others choice if any\n \n    --  2. If the aggregate contains positional elements we\n \n-   --     (a) translate the positional elements in a series of assignments.\n+   --     (a) translate the positional elements in a series of assignments\n \n    --     (b) Generate a final loop to cover the others choice if any.\n    --         Note that this final loop has to be a while loop since the case\n@@ -432,18 +444,18 @@ package body Exp_Aggr is\n       Index_Base_H : constant Node_Id := Type_High_Bound (Index_Base);\n \n       function Add (Val : Int; To : Node_Id) return Node_Id;\n-      --  Returns an expression where Val is added to expression To,\n-      --  unless To+Val is provably out of To's base type range.\n-      --  To must be an already analyzed expression.\n+      --  Returns an expression where Val is added to expression To, unless\n+      --  To+Val is provably out of To's base type range. To must be an\n+      --  already analyzed expression.\n \n       function Empty_Range (L, H : Node_Id) return Boolean;\n-      --  Returns True if the range defined by L .. H is certainly empty.\n+      --  Returns True if the range defined by L .. H is certainly empty\n \n       function Equal (L, H : Node_Id) return Boolean;\n-      --  Returns True if L = H for sure.\n+      --  Returns True if L = H for sure\n \n       function Index_Base_Name return Node_Id;\n-      --  Returns a new reference to the index type name.\n+      --  Returns a new reference to the index type name\n \n       function Gen_Assign (Ind : Node_Id; Expr : Node_Id) return List_Id;\n       --  Ind must be a side-effect free expression. If the input aggregate\n@@ -452,7 +464,7 @@ package body Exp_Aggr is\n       --\n       --     Into (Indices, Ind) := Expr;\n       --\n-      --  Otherwise we call Build_Code recursively.\n+      --  Otherwise we call Build_Code recursively\n       --\n       --  Ada 2005 (AI-287): In case of default initialized component, Expr\n       --  is empty and we generate a call to the corresponding IP subprogram.\n@@ -823,9 +835,30 @@ package body Exp_Aggr is\n             end if;\n \n             if Is_Delayed_Aggregate (Expr_Q) then\n-               return\n-                 Add_Loop_Actions (\n-                   Late_Expansion (Expr_Q, Etype (Expr_Q), Indexed_Comp, F));\n+\n+               --  This is either a subaggregate of a multidimentional array,\n+               --  or a component of an array type whose component type is\n+               --  also an array. In the latter case, the expression may have\n+               --  component associations that provide different bounds from\n+               --  those of the component type, and sliding must occur. Instead\n+               --  of decomposing the current aggregate assignment, force the\n+               --  re-analysis of the assignment, so that a temporary will be\n+               --  generated in the usual fashion, and sliding will take place.\n+\n+               if Nkind (Parent (N)) = N_Assignment_Statement\n+                 and then Is_Array_Type (Comp_Type)\n+                 and then Present (Component_Associations (Expr_Q))\n+                 and then Must_Slide (Comp_Type, Etype (Expr_Q))\n+               then\n+                  Set_Expansion_Delayed (Expr_Q, False);\n+                  Set_Analyzed (Expr_Q, False);\n+\n+               else\n+                  return\n+                    Add_Loop_Actions (\n+                      Late_Expansion (\n+                        Expr_Q, Etype (Expr_Q), Indexed_Comp, F));\n+               end if;\n             end if;\n          end if;\n \n@@ -1268,7 +1301,7 @@ package body Exp_Aggr is\n             Sort_Case_Table (Table);\n          end if;\n \n-         --  STEP 1 (b):  take care of the whole set of discrete choices.\n+         --  STEP 1 (b):  take care of the whole set of discrete choices\n \n          for J in 1 .. Nb_Choices loop\n             Low  := Table (J).Choice_Lo;\n@@ -2470,7 +2503,7 @@ package body Exp_Aggr is\n             Next_Elmt (Disc2);\n          end loop;\n \n-         --  If any discriminant constraint is non-static, emit a check.\n+         --  If any discriminant constraint is non-static, emit a check\n \n          if Present (Cond) then\n             Insert_Action (N,\n@@ -2632,10 +2665,11 @@ package body Exp_Aggr is\n         (N   : Node_Id;\n          Ix  : Node_Id;\n          Ixb : Node_Id) return Boolean;\n-      --  Convert the aggregate into a purely positional form if possible.\n+      --  Convert the aggregate into a purely positional form if possible\n \n       function Is_Flat (N : Node_Id; Dims : Int) return Boolean;\n-      --  Non trivial for multidimensional aggregate.\n+      --  Return True iff the array N is flat (which is not rivial\n+      --  in the case of multidimensionsl aggregates).\n \n       -------------\n       -- Flatten --\n@@ -2985,14 +3019,14 @@ package body Exp_Aggr is\n       --  Ctyp is the corresponding component type.\n \n       Aggr_Dimension : constant Pos := Number_Dimensions (Typ);\n-      --  Number of aggregate index dimensions.\n+      --  Number of aggregate index dimensions\n \n       Aggr_Low  : array (1 .. Aggr_Dimension) of Node_Id;\n       Aggr_High : array (1 .. Aggr_Dimension) of Node_Id;\n-      --  Low and High bounds of the constraint for each aggregate index.\n+      --  Low and High bounds of the constraint for each aggregate index\n \n       Aggr_Index_Typ : array (1 .. Aggr_Dimension) of Entity_Id;\n-      --  The type of each index.\n+      --  The type of each index\n \n       Maybe_In_Place_OK : Boolean;\n       --  If the type is neither controlled nor packed and the aggregate\n@@ -3035,14 +3069,6 @@ package body Exp_Aggr is\n       --  be done in place, because none of the new values can depend on the\n       --  components of the target of the assignment.\n \n-      function Must_Slide (N : Node_Id; Typ : Entity_Id) return Boolean;\n-      --  A static aggregate in an object declaration can in most cases be\n-      --  expanded in place. The one exception is when the aggregate is given\n-      --  with component associations that specify different bounds from those\n-      --  of the type definition in the object declaration. In this rather\n-      --  pathological case the aggregate must slide, and we must introduce\n-      --  an intermediate temporary to hold it.\n-\n       procedure Others_Check (Sub_Aggr : Node_Id; Dim : Pos);\n       --  Checks that if an others choice is present in any sub-aggregate no\n       --  aggregate index is outside the bounds of the index constraint.\n@@ -3209,14 +3235,14 @@ package body Exp_Aggr is\n       procedure Check_Same_Aggr_Bounds (Sub_Aggr : Node_Id; Dim : Pos) is\n          Sub_Lo : constant Node_Id := Low_Bound (Aggregate_Bounds (Sub_Aggr));\n          Sub_Hi : constant Node_Id := High_Bound (Aggregate_Bounds (Sub_Aggr));\n-         --  The bounds of this specific sub-aggregate.\n+         --  The bounds of this specific sub-aggregate\n \n          Aggr_Lo : constant Node_Id := Aggr_Low (Dim);\n          Aggr_Hi : constant Node_Id := Aggr_High (Dim);\n          --  The bounds of the aggregate for this dimension\n \n          Ind_Typ : constant Entity_Id := Aggr_Index_Typ (Dim);\n-         --  The index type for this dimension.\n+         --  The index type for this dimension.xxx\n \n          Cond  : Node_Id := Empty;\n \n@@ -3463,7 +3489,7 @@ package body Exp_Aggr is\n             Comp : Node_Id := Expr;\n \n             function Check_Component (Comp : Node_Id) return Boolean;\n-            --  Do the recursive traversal, after copy.\n+            --  Do the recursive traversal, after copy\n \n             ---------------------\n             -- Check_Component --\n@@ -3518,7 +3544,8 @@ package body Exp_Aggr is\n                   return False;\n \n                elsif Nkind (Expr) = N_Allocator then\n-                  --  For now, too complex to analyze.\n+\n+                  --  For now, too complex to analyze\n \n                   return False;\n                end if;\n@@ -3586,66 +3613,22 @@ package body Exp_Aggr is\n             end loop;\n          end if;\n \n-         --  Now check the component values themselves.\n+         --  Now check the component values themselves\n \n          return Safe_Aggregate (N);\n       end In_Place_Assign_OK;\n \n-      ----------------\n-      -- Must_Slide --\n-      ----------------\n-\n-      function Must_Slide (N : Node_Id; Typ : Entity_Id) return Boolean\n-      is\n-         Obj_Type : constant Entity_Id :=\n-                      Etype (Defining_Identifier (Parent (N)));\n-\n-         L1, L2, H1, H2 : Node_Id;\n-\n-      begin\n-         --  No sliding if the type of the object is not established yet, if\n-         --  it is an unconstrained type whose actual subtype comes from the\n-         --  aggregate, or if the two types are identical.\n-\n-         if not Is_Array_Type (Obj_Type) then\n-            return False;\n-\n-         elsif not Is_Constrained (Obj_Type) then\n-            return False;\n-\n-         elsif Typ = Obj_Type then\n-            return False;\n-\n-         else\n-            --  Sliding can only occur along the first dimension\n-\n-            Get_Index_Bounds (First_Index (Typ), L1, H1);\n-            Get_Index_Bounds (First_Index (Obj_Type), L2, H2);\n-\n-            if not Is_Static_Expression (L1)\n-              or else not Is_Static_Expression (L2)\n-              or else not Is_Static_Expression (H1)\n-              or else not Is_Static_Expression (H2)\n-            then\n-               return False;\n-            else\n-               return Expr_Value (L1) /= Expr_Value (L2)\n-                 or else Expr_Value (H1) /= Expr_Value (H2);\n-            end if;\n-         end if;\n-      end Must_Slide;\n-\n       ------------------\n       -- Others_Check --\n       ------------------\n \n       procedure Others_Check (Sub_Aggr : Node_Id; Dim : Pos) is\n          Aggr_Lo : constant Node_Id := Aggr_Low (Dim);\n          Aggr_Hi : constant Node_Id := Aggr_High (Dim);\n-         --  The bounds of the aggregate for this dimension.\n+         --  The bounds of the aggregate for this dimension\n \n          Ind_Typ : constant Entity_Id := Aggr_Index_Typ (Dim);\n-         --  The index type for this dimension.\n+         --  The index type for this dimension\n \n          Need_To_Check : Boolean := False;\n \n@@ -3886,7 +3869,7 @@ package body Exp_Aggr is\n \n       pragma Assert (not Raises_Constraint_Error (N));\n \n-      --  STEP 1a.\n+      --  STEP 1a\n \n       --  Check that the index range defined by aggregate bounds is\n       --  compatible with corresponding index subtype.\n@@ -3934,14 +3917,14 @@ package body Exp_Aggr is\n          end loop;\n       end Index_Compatibility_Check;\n \n-      --  STEP 1b.\n+      --  STEP 1b\n \n       --  If an others choice is present check that no aggregate\n       --  index is outside the bounds of the index constraint.\n \n       Others_Check (N, 1);\n \n-      --  STEP 1c.\n+      --  STEP 1c\n \n       --  For multidimensional arrays make sure that all subaggregates\n       --  corresponding to the same dimension have the same bounds.\n@@ -3950,7 +3933,7 @@ package body Exp_Aggr is\n          Check_Same_Aggr_Bounds (N, 1);\n       end if;\n \n-      --  STEP 2.\n+      --  STEP 2\n \n       --  Here we test for is packed array aggregate that we can handle\n       --  at compile time. If so, return with transformation done. Note\n@@ -4017,7 +4000,7 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      --  STEP 3.\n+      --  STEP 3\n \n       --  Delay expansion for nested aggregates it will be taken care of\n       --  when the parent aggregate is expanded\n@@ -4042,7 +4025,7 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n-      --  STEP 4.\n+      --  STEP 4\n \n       --  Look if in place aggregate expansion is possible\n \n@@ -4086,7 +4069,8 @@ package body Exp_Aggr is\n       if not Has_Default_Init_Comps (N)\n          and then Comes_From_Source (Parent (N))\n          and then Nkind (Parent (N)) = N_Object_Declaration\n-         and then not Must_Slide (N, Typ)\n+         and then not\n+           Must_Slide (Etype (Defining_Identifier (Parent (N))), Typ)\n          and then N = Expression (Parent (N))\n          and then not Is_Bit_Packed_Array (Typ)\n          and then not Has_Controlled_Component (Typ)\n@@ -4120,7 +4104,7 @@ package body Exp_Aggr is\n          Set_Expansion_Delayed (N);\n          return;\n \n-      --  In the remaining cases  the aggregate is the RHS of an assignment.\n+      --  In the remaining cases  the aggregate is the RHS of an assignment\n \n       elsif Maybe_In_Place_OK\n         and then Is_Entity_Name (Name (Parent (N)))\n@@ -4602,7 +4586,7 @@ package body Exp_Aggr is\n \n          if Is_Tagged_Type (Typ) then\n \n-            --  The tagged case, _parent and _tag component must be created.\n+            --  The tagged case, _parent and _tag component must be created\n \n             --  Reset null_present unconditionally. tagged records always have\n             --  at least one field (the tag or the parent)\n@@ -5164,6 +5148,48 @@ package body Exp_Aggr is\n       end if;\n    end Initialize_Discriminants;\n \n+   ----------------\n+   -- Must_Slide --\n+   ----------------\n+\n+   function Must_Slide\n+     (Obj_Type : Entity_Id;\n+      Typ      : Entity_Id) return Boolean\n+   is\n+      L1, L2, H1, H2 : Node_Id;\n+   begin\n+      --  No sliding if the type of the object is not established yet, if\n+      --  it is an unconstrained type whose actual subtype comes from the\n+      --  aggregate, or if the two types are identical.\n+\n+      if not Is_Array_Type (Obj_Type) then\n+         return False;\n+\n+      elsif not Is_Constrained (Obj_Type) then\n+         return False;\n+\n+      elsif Typ = Obj_Type then\n+         return False;\n+\n+      else\n+         --  Sliding can only occur along the first dimension\n+\n+         Get_Index_Bounds (First_Index (Typ), L1, H1);\n+         Get_Index_Bounds (First_Index (Obj_Type), L2, H2);\n+\n+         if not Is_Static_Expression (L1)\n+           or else not Is_Static_Expression (L2)\n+           or else not Is_Static_Expression (H1)\n+           or else not Is_Static_Expression (H2)\n+         then\n+            return False;\n+         else\n+            return Expr_Value (L1) /= Expr_Value (L2)\n+              or else Expr_Value (H1) /= Expr_Value (H2);\n+         end if;\n+      end if;\n+   end Must_Slide;\n+\n    ---------------------------\n    -- Safe_Slice_Assignment --\n    ---------------------------"}]}