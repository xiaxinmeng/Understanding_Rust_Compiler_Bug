{"sha": "a3b38b7781622babb5ca68c621367770a65012fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNiMzhiNzc4MTYyMmJhYmI1Y2E2OGM2MjEzNjc3NzBhNjUwMTJmYQ==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-02-09T14:40:06Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-02-13T11:50:45Z"}, "message": "d: Merge upstream dmd 7132b3537\n\nSplits out all semantic passes for Dsymbol, Type, and TemplateParameter\nnodes into Visitors in separate files, and the copyright years of all\nsources have been updated.\n\nReviewed-on: https://github.com/dlang/dmd/pull/12190\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 7132b3537.\n\t* Make-lang.in (D_FRONTEND_OBJS): Add d/dsymbolsem.o, d/semantic2.o,\n\td/semantic3.o, and d/templateparamsem.o.\n\t* d-compiler.cc (Compiler::genCmain): Update calls to semantic\n\tentrypoint functions.\n\t* d-lang.cc (d_parse_file): Likewise.\n\t* typeinfo.cc (make_frontend_typeinfo): Likewise.", "tree": {"sha": "32ba65cb98047efa6ed8f86b327903ce647c008f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32ba65cb98047efa6ed8f86b327903ce647c008f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3b38b7781622babb5ca68c621367770a65012fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b38b7781622babb5ca68c621367770a65012fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b38b7781622babb5ca68c621367770a65012fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b38b7781622babb5ca68c621367770a65012fa/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f3a743b688f4845e1798eed9b2e2284e891da11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3a743b688f4845e1798eed9b2e2284e891da11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3a743b688f4845e1798eed9b2e2284e891da11"}], "stats": {"total": 19923, "additions": 10039, "deletions": 9884}, "files": [{"sha": "b0fce06e507bb7a4d3d38f34112724ad52543020", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -84,6 +84,7 @@ D_FRONTEND_OBJS = \\\n \td/dscope.o \\\n \td/dstruct.o \\\n \td/dsymbol.o \\\n+\td/dsymbolsem.o \\\n \td/dtemplate.o \\\n \td/dversion.o \\\n \td/entity.o \\\n@@ -115,13 +116,16 @@ D_FRONTEND_OBJS = \\\n \td/rootobject.o \\\n \td/safe.o \\\n \td/sapply.o \\\n+\td/semantic2.o \\\n+\td/semantic3.o \\\n \td/sideeffect.o \\\n \td/speller.o \\\n \td/statement.o \\\n \td/statementsem.o \\\n \td/staticassert.o \\\n \td/staticcond.o \\\n \td/stringtable.o \\\n+\td/templateparamsem.o \\\n \td/tokens.o \\\n \td/traits.o \\\n \td/typesem.o \\"}, {"sha": "512ef4bab3e185c6f70e3efe5bdf87e164031255", "filename": "gcc/d/d-compiler.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -59,9 +59,9 @@ Compiler::genCmain (Scope *sc)\n     {\n       m->importedFrom = m;\n       m->importAll (NULL);\n-      m->semantic (NULL);\n-      m->semantic2 (NULL);\n-      m->semantic3 (NULL);\n+      dsymbolSemantic (m, NULL);\n+      semantic2 (m, NULL);\n+      semantic3 (m, NULL);\n       d_add_entrypoint_module (m, sc->_module);\n     }\n "}, {"sha": "1a51c5e4b7c6d18910568657d8f82b3d74b462e3", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1051,7 +1051,7 @@ d_parse_file (void)\n       if (global.params.verbose)\n \tmessage (\"semantic  %s\", m->toChars ());\n \n-      m->semantic (NULL);\n+      dsymbolSemantic (m, NULL);\n     }\n \n   /* Do deferred semantic analysis.  */\n@@ -1083,7 +1083,7 @@ d_parse_file (void)\n       if (global.params.verbose)\n \tmessage (\"semantic2 %s\", m->toChars ());\n \n-      m->semantic2 (NULL);\n+      semantic2 (m, NULL);\n     }\n \n   Module::runDeferredSemantic2 ();\n@@ -1099,7 +1099,7 @@ d_parse_file (void)\n       if (global.params.verbose)\n \tmessage (\"semantic3 %s\", m->toChars ());\n \n-      m->semantic3 (NULL);\n+      semantic3 (m, NULL);\n     }\n \n   Module::runDeferredSemantic3 ();"}, {"sha": "690fe4072787a533ec918cec66546b293b64abfc", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,4 +1,4 @@\n-46133f76172c26c89e2ebf9cd058cd1f1e8807ed\n+7132b3537dc27cb353da75798082ffe7ea3d69a6\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "11b26c5dc5c3569b0c50aaa95d511faa5ef6ee58", "filename": "gcc/d/dmd/access.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faccess.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faccess.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faccess.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "4935e6a1f5d2e368911d3f5b3791ef8ccb1457b1", "filename": "gcc/d/dmd/aggregate.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faggregate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faggregate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -131,8 +131,6 @@ class AggregateDeclaration : public ScopeDsymbol\n     AggregateDeclaration(Loc loc, Identifier *id);\n     virtual Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n-    void semantic2(Scope *sc);\n-    void semantic3(Scope *sc);\n     bool determineFields();\n     bool determineSize(Loc loc);\n     virtual void finalizeSize() = 0;\n@@ -203,7 +201,6 @@ class StructDeclaration : public AggregateDeclaration\n     StructDeclaration(Loc loc, Identifier *id, bool inObject);\n     static StructDeclaration *create(Loc loc, Identifier *id, bool inObject);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n-    void semantic(Scope *sc);\n     void semanticTypeInfoMembers();\n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n     const char *kind() const;\n@@ -299,7 +296,6 @@ class ClassDeclaration : public AggregateDeclaration\n     static ClassDeclaration *create(Loc loc, Identifier *id, BaseClasses *baseclasses, Dsymbols *members, bool inObject);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    void semantic(Scope *sc);\n     bool isBaseOf2(ClassDeclaration *cd);\n \n     #define OFFSET_RUNTIME 0x76543210\n@@ -313,7 +309,6 @@ class ClassDeclaration : public AggregateDeclaration\n     bool hasMonitor();\n     bool isFuncHidden(FuncDeclaration *fd);\n     FuncDeclaration *findFunc(Identifier *ident, TypeFunction *tf);\n-    void interfaceSemantic(Scope *sc);\n     bool isCOMclass() const;\n     virtual bool isCOMinterface() const;\n     bool isCPPclass() const;\n@@ -337,7 +332,6 @@ class InterfaceDeclaration : public ClassDeclaration\n     InterfaceDeclaration(Loc loc, Identifier *id, BaseClasses *baseclasses);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    void semantic(Scope *sc);\n     bool isBaseOf(ClassDeclaration *cd, int *poffset);\n     bool isBaseOf(BaseClass *bc, int *poffset);\n     const char *kind() const;"}, {"sha": "458416f495099bbc1931ccbd9c9a993c494cf12d", "filename": "gcc/d/dmd/aliasthis.c", "status": "modified", "additions": 4, "deletions": 78, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faliasthis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faliasthis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2009-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2009-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -18,10 +18,9 @@\n #include \"dsymbol.h\"\n #include \"mtype.h\"\n #include \"declaration.h\"\n+#include \"expression.h\"\n #include \"tokens.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-\n Expression *resolveAliasThis(Scope *sc, Expression *e, bool gag)\n {\n     AggregateDeclaration *ad = isAggregate(e->type);\n@@ -33,7 +32,7 @@ Expression *resolveAliasThis(Scope *sc, Expression *e, bool gag)\n         Loc loc = e->loc;\n         Type *tthis = (e->op == TOKtype ? e->type : NULL);\n         e = new DotIdExp(loc, e, ad->aliasthis->ident);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         if (tthis && ad->aliasthis->needThis())\n         {\n             if (e->op == TOKvar)\n@@ -65,7 +64,7 @@ Expression *resolveAliasThis(Scope *sc, Expression *e, bool gag)\n \n         L1:\n             e = new TypeExp(loc, new TypeTypeof(loc, e));\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n         }\n         e = resolveProperties(sc, e);\n \n@@ -89,79 +88,6 @@ Dsymbol *AliasThis::syntaxCopy(Dsymbol *s)\n     return new AliasThis(loc, ident);\n }\n \n-void AliasThis::semantic(Scope *sc)\n-{\n-    if (semanticRun != PASSinit)\n-        return;\n-\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        _scope = NULL;\n-    }\n-\n-    if (!sc)\n-        return;\n-\n-    semanticRun = PASSsemantic;\n-\n-    Dsymbol *p = sc->parent->pastMixin();\n-    AggregateDeclaration *ad = p->isAggregateDeclaration();\n-    if (!ad)\n-    {\n-        ::error(loc, \"alias this can only be a member of aggregate, not %s %s\",\n-            p->kind(), p->toChars());\n-        return;\n-    }\n-\n-    assert(ad->members);\n-    Dsymbol *s = ad->search(loc, ident);\n-    if (!s)\n-    {\n-        s = sc->search(loc, ident, NULL);\n-        if (s)\n-            ::error(loc, \"%s is not a member of %s\", s->toChars(), ad->toChars());\n-        else\n-            ::error(loc, \"undefined identifier %s\", ident->toChars());\n-        return;\n-    }\n-    else if (ad->aliasthis && s != ad->aliasthis)\n-    {\n-        ::error(loc, \"there can be only one alias this\");\n-        return;\n-    }\n-\n-    if (ad->type->ty == Tstruct && ((TypeStruct *)ad->type)->sym != ad)\n-    {\n-        AggregateDeclaration *ad2 = ((TypeStruct *)ad->type)->sym;\n-        assert(ad2->type == Type::terror);\n-        ad->aliasthis = ad2->aliasthis;\n-        return;\n-    }\n-\n-    /* disable the alias this conversion so the implicit conversion check\n-     * doesn't use it.\n-     */\n-    ad->aliasthis = NULL;\n-\n-    Dsymbol *sx = s;\n-    if (sx->isAliasDeclaration())\n-        sx = sx->toAlias();\n-    Declaration *d = sx->isDeclaration();\n-    if (d && !d->isTupleDeclaration())\n-    {\n-        Type *t = d->type;\n-        assert(t);\n-        if (ad->type->implicitConvTo(t) > MATCHnomatch)\n-        {\n-            ::error(loc, \"alias this is not reachable as %s already converts to %s\", ad->toChars(), t->toChars());\n-        }\n-    }\n-\n-    ad->aliasthis = s;\n-    semanticRun = PASSsemanticdone;\n-}\n-\n const char *AliasThis::kind() const\n {\n     return \"alias this\";"}, {"sha": "15905e417108de3bd3b389bb412843a796487b17", "filename": "gcc/d/dmd/aliasthis.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faliasthis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Faliasthis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2009-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2009-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -23,7 +23,6 @@ class AliasThis : public Dsymbol\n     AliasThis(Loc loc, Identifier *ident);\n \n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     AliasThis *isAliasThis() { return this; }\n     void accept(Visitor *v) { v->visit(this); }"}, {"sha": "8a727ae66d144177e7525b12ee159815837f7df3", "filename": "gcc/d/dmd/apply.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fapply.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fapply.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fapply.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "52d596bb87191598f3f3a5c2899be736e92693a6", "filename": "gcc/d/dmd/arrayop.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Farrayop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Farrayop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -25,7 +25,6 @@\n \n void buildArrayIdent(Expression *e, OutBuffer *buf, Expressions *arguments);\n Expression *buildArrayLoop(Expression *e, Parameters *fparams);\n-Expression *semantic(Expression *e, Scope *sc);\n \n /**************************************\n  * Hash table of array op functions already generated or known about.\n@@ -80,10 +79,10 @@ FuncDeclaration *buildArrayOp(Identifier *ident, BinExp *exp, Scope *sc)\n     sc->parent = sc->_module->importedFrom;\n     sc->stc = 0;\n     sc->linkage = LINKc;\n-    fd->semantic(sc);\n-    fd->semantic2(sc);\n+    dsymbolSemantic(fd, sc);\n+    semantic2(fd, sc);\n     unsigned errors = global.startGagging();\n-    fd->semantic3(sc);\n+    semantic3(fd, sc);\n     if (global.endGagging(errors))\n     {\n         fd->type = Type::terror;\n@@ -231,7 +230,7 @@ Expression *arrayOp(BinExp *e, Scope *sc)\n     Expression *ev = new VarExp(e->loc, fd);\n     Expression *ec = new CallExp(e->loc, ev, arguments);\n \n-    return semantic(ec, sc);\n+    return expressionSemantic(ec, sc);\n }\n \n Expression *arrayOp(BinAssignExp *e, Scope *sc)"}, {"sha": "0ecccf170bd011c8685b2a9300158585c1f37ddd", "filename": "gcc/d/dmd/arraytypes.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Farraytypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Farraytypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2006-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2006-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "5576dd74e0da60b3303571018870e163ac35c97b", "filename": "gcc/d/dmd/ast_node.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fast_node.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fast_node.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fast_node.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "56b8ce816beae31f2729407e1158b75a0bce1943", "filename": "gcc/d/dmd/attrib.c", "status": "modified", "additions": 8, "deletions": 463, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fattrib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fattrib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -29,8 +29,6 @@\n #include \"mtype.h\"\n \n bool definitelyValueParameter(Expression *e);\n-Expression *semantic(Expression *e, Scope *sc);\n-StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n Dsymbols *makeTupleForeachStaticDecl(Scope *sc, ForeachStatement *fs, Dsymbols *dbody, bool needExpansion);\n \n /********************************* AttribDeclaration ****************************/\n@@ -169,68 +167,6 @@ void AttribDeclaration::importAll(Scope *sc)\n     }\n }\n \n-void AttribDeclaration::semantic(Scope *sc)\n-{\n-    if (semanticRun != PASSinit)\n-        return;\n-    semanticRun = PASSsemantic;\n-    Dsymbols *d = include(sc);\n-\n-    //printf(\"\\tAttribDeclaration::semantic '%s', d = %p\\n\",toChars(), d);\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->semantic(sc2);\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-    semanticRun = PASSsemanticdone;\n-}\n-\n-void AttribDeclaration::semantic2(Scope *sc)\n-{\n-    Dsymbols *d = include(sc);\n-\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->semantic2(sc2);\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-}\n-\n-void AttribDeclaration::semantic3(Scope *sc)\n-{\n-    Dsymbols *d = include(sc);\n-\n-    if (d)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < d->length; i++)\n-        {\n-            Dsymbol *s = (*d)[i];\n-            s->semantic3(sc2);\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-}\n-\n void AttribDeclaration::addComment(const utf8_t *comment)\n {\n     //printf(\"AttribDeclaration::addComment %s\\n\", comment);\n@@ -474,38 +410,22 @@ void DeprecatedDeclaration::setScope(Scope *sc)\n     return AttribDeclaration::setScope(sc);\n }\n \n-/**\n- * Run the DeprecatedDeclaration's semantic2 phase then its members.\n- *\n- * The message set via a `DeprecatedDeclaration` can be either of:\n- * - a string literal\n- * - an enum\n- * - a static immutable\n- * So we need to call ctfe to resolve it.\n- * Afterward forwards to the members' semantic2.\n- */\n-void DeprecatedDeclaration::semantic2(Scope *sc)\n-{\n-    getMessage();\n-    StorageClassDeclaration::semantic2(sc);\n-}\n-\n const char *DeprecatedDeclaration::getMessage()\n {\n     if (Scope *sc = _scope)\n     {\n         _scope = NULL;\n \n         sc = sc->startCTFE();\n-        msg = ::semantic(msg, sc);\n+        msg = expressionSemantic(msg, sc);\n         msg = resolveProperties(sc, msg);\n         sc = sc->endCTFE();\n         msg = msg->ctfeInterpret();\n \n         if (StringExp *se = msg->toStringExp())\n             msgstr = (char *)se->string;\n         else\n-            msg->error(\"compile time constant expected, not '%s'\", msg->toChars());\n+            msg->error(\"compile time constant expected, not `%s`\", msg->toChars());\n     }\n     return msgstr;\n }\n@@ -613,7 +533,7 @@ Dsymbol *ProtDeclaration::syntaxCopy(Dsymbol *s)\n Scope *ProtDeclaration::newScope(Scope *sc)\n {\n     if (pkg_identifiers)\n-        semantic(sc);\n+        dsymbolSemantic(this, sc);\n     return createNewScope(sc, sc->stc, sc->linkage, sc->cppmangle,\n         this->protection, 1, sc->aligndecl,\n         sc->inlining);\n@@ -634,7 +554,7 @@ void ProtDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n         Module *m = sc->_module;\n         Package* pkg = m->parent ? m->parent->isPackage() : NULL;\n         if (!pkg || !protection.pkg->isAncestorPackageOf(pkg))\n-            error(\"does not bind to one of ancestor packages of module '%s'\",\n+            error(\"does not bind to one of ancestor packages of module `%s`\",\n                m->toPrettyChars(true));\n     }\n \n@@ -682,12 +602,6 @@ Scope *AlignDeclaration::newScope(Scope *sc)\n         sc->inlining);\n }\n \n-void AlignDeclaration::semantic2(Scope *sc)\n-{\n-    getAlignment(sc);\n-    AttribDeclaration::semantic2(sc);\n-}\n-\n structalign_t AlignDeclaration::getAlignment(Scope *sc)\n {\n     if (salign != 0)\n@@ -697,7 +611,7 @@ structalign_t AlignDeclaration::getAlignment(Scope *sc)\n         return salign = STRUCTALIGN_DEFAULT;\n \n     sc = sc->startCTFE();\n-    ealign = ::semantic(ealign, sc);\n+    ealign = expressionSemantic(ealign, sc);\n     ealign = resolveProperties(sc, ealign);\n     sc = sc->endCTFE();\n     ealign = ealign->ctfeInterpret();\n@@ -744,38 +658,6 @@ void AnonDeclaration::setScope(Scope *sc)\n     AttribDeclaration::setScope(sc);\n }\n \n-void AnonDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"\\tAnonDeclaration::semantic %s %p\\n\", isunion ? \"union\" : \"struct\", this);\n-\n-    assert(sc->parent);\n-\n-    Dsymbol *p = sc->parent->pastMixin();\n-    AggregateDeclaration *ad = p->isAggregateDeclaration();\n-    if (!ad)\n-    {\n-        ::error(loc, \"%s can only be a part of an aggregate, not %s %s\",\n-            kind(), p->kind(), p->toChars());\n-        errors = true;\n-        return;\n-    }\n-\n-    if (decl)\n-    {\n-        sc = sc->push();\n-        sc->stc &= ~(STCauto | STCscope | STCstatic | STCtls | STCgshared);\n-        sc->inunion = isunion;\n-        sc->flags = 0;\n-\n-        for (size_t i = 0; i < decl->length; i++)\n-        {\n-            Dsymbol *s = (*decl)[i];\n-            s->semantic(sc);\n-        }\n-        sc = sc->pop();\n-    }\n-}\n-\n void AnonDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion)\n {\n     //printf(\"\\tAnonDeclaration::setFieldOffset %s %p\\n\", isunion ? \"union\" : \"struct\", this);\n@@ -916,269 +798,6 @@ Scope *PragmaDeclaration::newScope(Scope *sc)\n     return sc;\n }\n \n-static unsigned setMangleOverride(Dsymbol *s, char *sym)\n-{\n-    AttribDeclaration *ad = s->isAttribDeclaration();\n-\n-    if (ad)\n-    {\n-        Dsymbols *decls = ad->include(NULL);\n-        unsigned nestedCount = 0;\n-\n-        if (decls && decls->length)\n-            for (size_t i = 0; i < decls->length; ++i)\n-                nestedCount += setMangleOverride((*decls)[i], sym);\n-\n-        return nestedCount;\n-    }\n-    else if (s->isFuncDeclaration() || s->isVarDeclaration())\n-    {\n-        s->isDeclaration()->mangleOverride = sym;\n-        return 1;\n-    }\n-    else\n-        return 0;\n-}\n-\n-void PragmaDeclaration::semantic(Scope *sc)\n-{\n-    // Should be merged with PragmaStatement\n-\n-    //printf(\"\\tPragmaDeclaration::semantic '%s'\\n\",toChars());\n-    if (ident == Id::msg)\n-    {\n-        if (args)\n-        {\n-            for (size_t i = 0; i < args->length; i++)\n-            {\n-                Expression *e = (*args)[i];\n-\n-                sc = sc->startCTFE();\n-                e = ::semantic(e, sc);\n-                e = resolveProperties(sc, e);\n-                sc = sc->endCTFE();\n-\n-                // pragma(msg) is allowed to contain types as well as expressions\n-                e = ctfeInterpretForPragmaMsg(e);\n-                if (e->op == TOKerror)\n-                {\n-                    errorSupplemental(loc, \"while evaluating pragma(msg, %s)\", (*args)[i]->toChars());\n-                    return;\n-                }\n-                StringExp *se = e->toStringExp();\n-                if (se)\n-                {\n-                    se = se->toUTF8(sc);\n-                    fprintf(stderr, \"%.*s\", (int)se->len, (char *)se->string);\n-                }\n-                else\n-                    fprintf(stderr, \"%s\", e->toChars());\n-            }\n-            fprintf(stderr, \"\\n\");\n-        }\n-        goto Lnodecl;\n-    }\n-    else if (ident == Id::lib)\n-    {\n-        if (!args || args->length != 1)\n-            error(\"string expected for library name\");\n-        else\n-        {\n-            StringExp *se = semanticString(sc, (*args)[0], \"library name\");\n-            if (!se)\n-                goto Lnodecl;\n-            (*args)[0] = se;\n-\n-            char *name = (char *)mem.xmalloc(se->len + 1);\n-            memcpy(name, se->string, se->len);\n-            name[se->len] = 0;\n-            if (global.params.verbose)\n-                message(\"library   %s\", name);\n-            if (global.params.moduleDeps && !global.params.moduleDepsFile.length)\n-            {\n-                OutBuffer *ob = global.params.moduleDeps;\n-                Module *imod = sc->instantiatingModule();\n-                ob->writestring(\"depsLib \");\n-                ob->writestring(imod->toPrettyChars());\n-                ob->writestring(\" (\");\n-                escapePath(ob, imod->srcfile->toChars());\n-                ob->writestring(\") : \");\n-                ob->writestring((char *) name);\n-                ob->writenl();\n-            }\n-            mem.xfree(name);\n-        }\n-        goto Lnodecl;\n-    }\n-    else if (ident == Id::startaddress)\n-    {\n-        if (!args || args->length != 1)\n-            error(\"function name expected for start address\");\n-        else\n-        {\n-            /* Bugzilla 11980:\n-             * resolveProperties and ctfeInterpret call are not necessary.\n-             */\n-            Expression *e = (*args)[0];\n-\n-            sc = sc->startCTFE();\n-            e = ::semantic(e, sc);\n-            sc = sc->endCTFE();\n-\n-            (*args)[0] = e;\n-            Dsymbol *sa = getDsymbol(e);\n-            if (!sa || !sa->isFuncDeclaration())\n-                error(\"function name expected for start address, not '%s'\", e->toChars());\n-        }\n-        goto Lnodecl;\n-    }\n-    else if (ident == Id::Pinline)\n-    {\n-        goto Ldecl;\n-    }\n-    else if (ident == Id::mangle)\n-    {\n-        if (!args)\n-            args = new Expressions();\n-        if (args->length != 1)\n-        {\n-            error(\"string expected for mangled name\");\n-            args->setDim(1);\n-            (*args)[0] = new ErrorExp();    // error recovery\n-            goto Ldecl;\n-        }\n-\n-        StringExp *se = semanticString(sc, (*args)[0], \"mangled name\");\n-        if (!se)\n-            goto Ldecl;\n-        (*args)[0] = se; // Will be used for later\n-\n-        if (!se->len)\n-        {\n-            error(\"zero-length string not allowed for mangled name\");\n-            goto Ldecl;\n-        }\n-        if (se->sz != 1)\n-        {\n-            error(\"mangled name characters can only be of type char\");\n-            goto Ldecl;\n-        }\n-\n-        /* Note: D language specification should not have any assumption about backend\n-         * implementation. Ideally pragma(mangle) can accept a string of any content.\n-         *\n-         * Therefore, this validation is compiler implementation specific.\n-         */\n-        for (size_t i = 0; i < se->len; )\n-        {\n-            utf8_t *p = (utf8_t *)se->string;\n-            dchar_t c = p[i];\n-            if (c < 0x80)\n-            {\n-                if ((c >= 'A' && c <= 'Z') ||\n-                    (c >= 'a' && c <= 'z') ||\n-                    (c >= '0' && c <= '9') ||\n-                    (c != 0 && strchr(\"$%().:?@[]_\", c)))\n-                {\n-                    ++i;\n-                    continue;\n-                }\n-                else\n-                {\n-                    error(\"char 0x%02x not allowed in mangled name\", c);\n-                    break;\n-                }\n-            }\n-\n-            if (const char* msg = utf_decodeChar((utf8_t *)se->string, se->len, &i, &c))\n-            {\n-                error(\"%s\", msg);\n-                break;\n-            }\n-\n-            if (!isUniAlpha(c))\n-            {\n-                error(\"char 0x%04x not allowed in mangled name\", c);\n-                break;\n-            }\n-        }\n-    }\n-    else if (global.params.ignoreUnsupportedPragmas)\n-    {\n-        if (global.params.verbose)\n-        {\n-            /* Print unrecognized pragmas\n-             */\n-            OutBuffer buf;\n-            buf.writestring(ident->toChars());\n-            if (args)\n-            {\n-                for (size_t i = 0; i < args->length; i++)\n-                {\n-                    Expression *e = (*args)[i];\n-\n-                    sc = sc->startCTFE();\n-                    e = ::semantic(e, sc);\n-                    e = resolveProperties(sc, e);\n-                    sc = sc->endCTFE();\n-\n-                    e = e->ctfeInterpret();\n-                    if (i == 0)\n-                        buf.writestring(\" (\");\n-                    else\n-                        buf.writeByte(',');\n-                    buf.writestring(e->toChars());\n-                }\n-                if (args->length)\n-                    buf.writeByte(')');\n-            }\n-            message(\"pragma    %s\", buf.peekChars());\n-        }\n-        goto Lnodecl;\n-    }\n-    else\n-        error(\"unrecognized pragma(%s)\", ident->toChars());\n-\n-Ldecl:\n-    if (decl)\n-    {\n-        Scope *sc2 = newScope(sc);\n-\n-        for (size_t i = 0; i < decl->length; i++)\n-        {\n-            Dsymbol *s = (*decl)[i];\n-\n-            s->semantic(sc2);\n-\n-            if (ident == Id::mangle)\n-            {\n-                assert(args && args->length == 1);\n-                if (StringExp *se = (*args)[0]->toStringExp())\n-                {\n-                    char *name = (char *)mem.xmalloc(se->len + 1);\n-                    memcpy(name, se->string, se->len);\n-                    name[se->len] = 0;\n-\n-                    unsigned cnt = setMangleOverride(s, name);\n-                    if (cnt > 1)\n-                        error(\"can only apply to a single declaration\");\n-                }\n-            }\n-        }\n-\n-        if (sc2 != sc)\n-            sc2->pop();\n-    }\n-    return;\n-\n-Lnodecl:\n-    if (decl)\n-    {\n-        error(\"pragma is missing closing ';'\");\n-        goto Ldecl; // do them anyway, to avoid segfaults.\n-    }\n-}\n-\n const char *PragmaDeclaration::kind() const\n {\n     return \"pragma\";\n@@ -1374,11 +993,6 @@ void StaticIfDeclaration::setScope(Scope *sc)\n     Dsymbol::setScope(sc);\n }\n \n-void StaticIfDeclaration::semantic(Scope *sc)\n-{\n-    AttribDeclaration::semantic(sc);\n-}\n-\n const char *StaticIfDeclaration::kind() const\n {\n     return \"static if\";\n@@ -1491,11 +1105,6 @@ void StaticForeachDeclaration::importAll(Scope *)\n     // do not evaluate aggregate before semantic pass\n }\n \n-void StaticForeachDeclaration::semantic(Scope *sc)\n-{\n-    AttribDeclaration::semantic(sc);\n-}\n-\n const char *StaticForeachDeclaration::kind() const\n {\n     return \"static foreach\";\n@@ -1582,50 +1191,6 @@ void CompileDeclaration::setScope(Scope *sc)\n     Dsymbol::setScope(sc);\n }\n \n-void CompileDeclaration::compileIt(Scope *sc)\n-{\n-    //printf(\"CompileDeclaration::compileIt(loc = %d) %s\\n\", loc.linnum, exp->toChars());\n-    StringExp *se = semanticString(sc, exp, \"argument to mixin\");\n-    if (!se)\n-        return;\n-    se = se->toUTF8(sc);\n-\n-    unsigned errors = global.errors;\n-    Parser p(loc, sc->_module, (utf8_t *)se->string, se->len, 0);\n-    p.nextToken();\n-\n-    decl = p.parseDeclDefs(0);\n-    if (p.token.value != TOKeof)\n-        exp->error(\"incomplete mixin declaration (%s)\", se->toChars());\n-    if (p.errors)\n-    {\n-        assert(global.errors != errors);\n-        decl = NULL;\n-    }\n-}\n-\n-void CompileDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"CompileDeclaration::semantic()\\n\");\n-\n-    if (!compiled)\n-    {\n-        compileIt(sc);\n-        AttribDeclaration::addMember(sc, scopesym);\n-        compiled = true;\n-\n-        if (_scope && decl)\n-        {\n-            for (size_t i = 0; i < decl->length; i++)\n-            {\n-                Dsymbol *s = (*decl)[i];\n-                s->setScope(_scope);\n-            }\n-        }\n-    }\n-    AttribDeclaration::semantic(sc);\n-}\n-\n const char *CompileDeclaration::kind() const\n {\n     return \"mixin\";\n@@ -1670,23 +1235,14 @@ void UserAttributeDeclaration::setScope(Scope *sc)\n     return AttribDeclaration::setScope(sc);\n }\n \n-void UserAttributeDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"UserAttributeDeclaration::semantic() %p\\n\", this);\n-    if (decl && !_scope)\n-        Dsymbol::setScope(sc);  // for function local symbols\n-\n-    return AttribDeclaration::semantic(sc);\n-}\n-\n-static void udaExpressionEval(Scope *sc, Expressions *exps)\n+void udaExpressionEval(Scope *sc, Expressions *exps)\n {\n     for (size_t i = 0; i < exps->length; i++)\n     {\n         Expression *e = (*exps)[i];\n         if (e)\n         {\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             if (definitelyValueParameter(e))\n                 e = e->ctfeInterpret();\n             if (e->op == TOKtuple)\n@@ -1699,17 +1255,6 @@ static void udaExpressionEval(Scope *sc, Expressions *exps)\n     }\n }\n \n-void UserAttributeDeclaration::semantic2(Scope *sc)\n-{\n-    if (decl && atts && atts->length && _scope)\n-    {\n-        _scope = NULL;\n-        udaExpressionEval(sc, atts);\n-    }\n-\n-    AttribDeclaration::semantic2(sc);\n-}\n-\n Expressions *UserAttributeDeclaration::concat(Expressions *udas1, Expressions *udas2)\n {\n     Expressions *udas;"}, {"sha": "7436417612886f9b805e074a5e6e94d798a8736c", "filename": "gcc/d/dmd/attrib.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fattrib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fattrib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -37,9 +37,6 @@ class AttribDeclaration : public Dsymbol\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n     void importAll(Scope *sc);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n-    void semantic3(Scope *sc);\n     void addComment(const utf8_t *comment);\n     const char *kind() const;\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n@@ -78,7 +75,6 @@ class DeprecatedDeclaration : public StorageClassDeclaration\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n-    void semantic2(Scope *sc);\n     const char *getMessage();\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -134,7 +130,6 @@ class AlignDeclaration : public AttribDeclaration\n     AlignDeclaration(Loc loc, Expression *ealign, Dsymbols *decl);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    void semantic2(Scope *sc);\n     structalign_t getAlignment(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -151,7 +146,6 @@ class AnonDeclaration : public AttribDeclaration\n     AnonDeclaration(Loc loc, bool isunion, Dsymbols *decl);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     void setScope(Scope *sc);\n-    void semantic(Scope *sc);\n     void setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion);\n     const char *kind() const;\n     AnonDeclaration *isAnonDeclaration() { return this; }\n@@ -166,7 +160,6 @@ class PragmaDeclaration : public AttribDeclaration\n     PragmaDeclaration(Loc loc, Identifier *ident, Expressions *args, Dsymbols *decl);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -199,7 +192,6 @@ class StaticIfDeclaration : public ConditionalDeclaration\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n     void importAll(Scope *sc);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -221,7 +213,6 @@ class StaticForeachDeclaration : public AttribDeclaration\n     void addComment(const utf8_t *comment);\n     void setScope(Scope *sc);\n     void importAll(Scope *sc);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -252,8 +243,6 @@ class CompileDeclaration : public AttribDeclaration\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n-    void compileIt(Scope *sc);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -271,8 +260,6 @@ class UserAttributeDeclaration : public AttribDeclaration\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     Scope *newScope(Scope *sc);\n     void setScope(Scope *sc);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n     static Expressions *concat(Expressions *udas1, Expressions *udas2);\n     Expressions *getAttributes();\n     const char *kind() const;"}, {"sha": "44e3cc13bd3f4086809aadb68d197c51c9e0add6", "filename": "gcc/d/dmd/blockexit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fblockexit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fblockexit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -483,7 +483,7 @@ int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow)\n         void visit(CompoundAsmStatement *s)\n         {\n             if (mustNotThrow && !(s->stc & STCnothrow))\n-                s->deprecation(\"asm statement is assumed to throw - mark it with 'nothrow' if it does not\");\n+                s->deprecation(\"asm statement is assumed to throw - mark it with `nothrow` if it does not\");\n \n             // Assume the worst\n             result = BEfallthru | BEreturn | BEgoto | BEhalt;"}, {"sha": "5d180f54367a68b977a1292ee7237d3644691e9b", "filename": "gcc/d/dmd/canthrow.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcanthrow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcanthrow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -77,15 +77,15 @@ bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n             {\n                 if (ce->f)\n                 {\n-                    ce->error(\"%s '%s' is not nothrow\",\n+                    ce->error(\"%s `%s` is not nothrow\",\n                         ce->f->kind(), ce->f->toPrettyChars());\n                 }\n                 else\n                 {\n                     Expression *e1 = ce->e1;\n                     if (e1->op == TOKstar)   // print 'fp' if e1 is (*fp)\n                         e1 = ((PtrExp *)e1)->e1;\n-                    ce->error(\"'%s' is not nothrow\", e1->toChars());\n+                    ce->error(\"`%s` is not nothrow\", e1->toChars());\n                 }\n             }\n             stop = true;\n@@ -103,7 +103,7 @@ bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n                     {\n                         if (mustNotThrow)\n                         {\n-                            ne->error(\"%s '%s' is not nothrow\",\n+                            ne->error(\"%s `%s` is not nothrow\",\n                                 ne->allocator->kind(), ne->allocator->toPrettyChars());\n                         }\n                         stop = true;\n@@ -115,7 +115,7 @@ bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n                 {\n                     if (mustNotThrow)\n                     {\n-                        ne->error(\"%s '%s' is not nothrow\",\n+                        ne->error(\"%s `%s` is not nothrow\",\n                             ne->member->kind(), ne->member->toPrettyChars());\n                     }\n                     stop = true;\n@@ -163,7 +163,7 @@ bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n                 {\n                     if (mustNotThrow)\n                     {\n-                        de->error(\"%s '%s' is not nothrow\",\n+                        de->error(\"%s `%s` is not nothrow\",\n                             ad->dtor->kind(), ad->dtor->toPrettyChars());\n                     }\n                     stop = true;\n@@ -176,7 +176,7 @@ bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n                 {\n                     if (mustNotThrow)\n                     {\n-                        de->error(\"%s '%s' is not nothrow\",\n+                        de->error(\"%s `%s` is not nothrow\",\n                             ad->aggDelete->kind(), ad->aggDelete->toPrettyChars());\n                     }\n                     stop = true;\n@@ -217,7 +217,7 @@ bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow)\n             {\n                 if (mustNotThrow)\n                 {\n-                    ae->error(\"%s '%s' is not nothrow\",\n+                    ae->error(\"%s `%s` is not nothrow\",\n                         sd->postblit->kind(), sd->postblit->toPrettyChars());\n                 }\n                 stop = true;"}, {"sha": "eb09076b2d207fc0c7c7560353ad7ba3864536e8", "filename": "gcc/d/dmd/clone.c", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fclone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fclone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -23,8 +23,6 @@\n #include \"template.h\"\n #include \"tokens.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-\n /*******************************************\n  * Merge function attributes pure, nothrow, @safe, @nogc, and @disable\n  */\n@@ -326,8 +324,8 @@ FuncDeclaration *buildOpAssign(StructDeclaration *sd, Scope *sc)\n     sc2->stc = 0;\n     sc2->linkage = LINKd;\n \n-    fop->semantic(sc2);\n-    fop->semantic2(sc2);\n+    dsymbolSemantic(fop, sc2);\n+    semantic2(fop, sc2);\n     // Bugzilla 15044: fop->semantic3 isn't run here for lazy forward reference resolution.\n \n     sc2->pop();\n@@ -506,7 +504,7 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n                 parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL, NULL));\n                 tfeqptr = new TypeFunction(ParameterList(parameters), Type::tbool, LINKd);\n                 tfeqptr->mod = MODconst;\n-                tfeqptr = (TypeFunction *)tfeqptr->semantic(Loc(), &scx);\n+                tfeqptr = (TypeFunction *)typeSemantic(tfeqptr, Loc(), &scx);\n             }\n             fd = fd->overloadExactMatch(tfeqptr);\n             if (fd)\n@@ -521,7 +519,7 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n         Expression *e = new IdentifierExp(sd->loc, Id::empty);\n         e = new DotIdExp(sd->loc, e, Id::object);\n         e = new DotIdExp(sd->loc, e, id);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         Dsymbol *s = getDsymbol(e);\n         assert(s);\n         sd->xerreq = s->isFuncDeclaration();\n@@ -549,8 +547,8 @@ FuncDeclaration *buildXopEquals(StructDeclaration *sd, Scope *sc)\n     sc2->stc = 0;\n     sc2->linkage = LINKd;\n \n-    fop->semantic(sc2);\n-    fop->semantic2(sc2);\n+    dsymbolSemantic(fop, sc2);\n+    semantic2(fop, sc2);\n \n     sc2->pop();\n     if (global.endGagging(errors))    // if errors happened\n@@ -586,7 +584,7 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n                 parameters->push(new Parameter(STCref | STCconst, sd->type, NULL, NULL, NULL));\n                 tfcmpptr = new TypeFunction(ParameterList(parameters), Type::tint32, LINKd);\n                 tfcmpptr->mod = MODconst;\n-                tfcmpptr = (TypeFunction *)tfcmpptr->semantic(Loc(), &scx);\n+                tfcmpptr = (TypeFunction *)typeSemantic(tfcmpptr, Loc(), &scx);\n             }\n             fd = fd->overloadExactMatch(tfcmpptr);\n             if (fd)\n@@ -606,7 +604,7 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n         Expression *e = new IdentifierExp(sd->loc, Id::empty);\n         e = new DotIdExp(sd->loc, e, Id::object);\n         e = new DotIdExp(sd->loc, e, id);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         Dsymbol *s = getDsymbol(e);\n         assert(s);\n         sd->xerrcmp = s->isFuncDeclaration();\n@@ -638,8 +636,8 @@ FuncDeclaration *buildXopCmp(StructDeclaration *sd, Scope *sc)\n     sc2->stc = 0;\n     sc2->linkage = LINKd;\n \n-    fop->semantic(sc2);\n-    fop->semantic2(sc2);\n+    dsymbolSemantic(fop, sc2);\n+    semantic2(fop, sc2);\n \n     sc2->pop();\n     if (global.endGagging(errors))    // if errors happened\n@@ -762,8 +760,8 @@ FuncDeclaration *buildXtoHash(StructDeclaration *sd, Scope *sc)\n     sc2->stc = 0;\n     sc2->linkage = LINKd;\n \n-    fop->semantic(sc2);\n-    fop->semantic2(sc2);\n+    dsymbolSemantic(fop, sc2);\n+    semantic2(fop, sc2);\n \n     sc2->pop();\n \n@@ -927,7 +925,7 @@ FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n         dd->fbody = (stc & STCdisable) ? NULL : new CompoundStatement(loc, a);\n         sd->postblits.shift(dd);\n         sd->members->push(dd);\n-        dd->semantic(sc);\n+        dsymbolSemantic(dd, sc);\n     }\n \n     FuncDeclaration *xpostblit = NULL;\n@@ -961,15 +959,15 @@ FuncDeclaration *buildPostBlit(StructDeclaration *sd, Scope *sc)\n             dd->storage_class |= STCinference;\n             dd->fbody = new ExpStatement(loc, e);\n             sd->members->push(dd);\n-            dd->semantic(sc);\n+            dsymbolSemantic(dd, sc);\n             xpostblit = dd;\n             break;\n     }\n     // Add an __xpostblit alias to make the inclusive postblit accessible\n     if (xpostblit)\n     {\n         AliasDeclaration *alias = new AliasDeclaration(Loc(), Id::__xpostblit, xpostblit);\n-        alias->semantic(sc);\n+        dsymbolSemantic(alias, sc);\n         sd->members->push(alias);\n         alias->addMember(sc, sd); // add to symbol table\n     }\n@@ -1074,7 +1072,7 @@ FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc)\n         dd->fbody = new ExpStatement(loc, e);\n         ad->dtors.shift(dd);\n         ad->members->push(dd);\n-        dd->semantic(sc);\n+        dsymbolSemantic(dd, sc);\n     }\n \n     FuncDeclaration *xdtor = NULL;\n@@ -1109,15 +1107,15 @@ FuncDeclaration *buildDtor(AggregateDeclaration *ad, Scope *sc)\n             dd->storage_class |= STCinference;\n             dd->fbody = new ExpStatement(loc, e);\n             ad->members->push(dd);\n-            dd->semantic(sc);\n+            dsymbolSemantic(dd, sc);\n             xdtor = dd;\n             break;\n     }\n     // Add an __xdtor alias to make the inclusive dtor accessible\n     if (xdtor)\n     {\n         AliasDeclaration *alias = new AliasDeclaration(Loc(), Id::__xdtor, xdtor);\n-        alias->semantic(sc);\n+        dsymbolSemantic(alias, sc);\n         ad->members->push(alias);\n         alias->addMember(sc, ad); // add to symbol table\n     }\n@@ -1175,7 +1173,7 @@ FuncDeclaration *buildInv(AggregateDeclaration *ad, Scope *sc)\n             inv = new InvariantDeclaration(declLoc, Loc(), stc | stcx, Id::classInvariant);\n             inv->fbody = new ExpStatement(loc, e);\n             ad->members->push(inv);\n-            inv->semantic(sc);\n+            dsymbolSemantic(inv, sc);\n             return inv;\n     }\n }"}, {"sha": "e7ef5a4ccf753f0bd6a886403ea918226ffa6ba1", "filename": "gcc/d/dmd/compiler.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcompiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcompiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcompiler.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "7f1746064226a6eae04c1b9d58b67228b7256119", "filename": "gcc/d/dmd/complex_t.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcomplex_t.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcomplex_t.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcomplex_t.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "6f112ad909c073fb919f6af8d4997b4826c1851e", "filename": "gcc/d/dmd/cond.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -26,7 +26,6 @@\n #include \"arraytypes.h\"\n #include \"tokens.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors);\n \n int findCondition(Identifiers *ids, Identifier *ident)\n@@ -86,7 +85,7 @@ static void lowerArrayAggregate(StaticForeach *sfe, Scope *sc)\n     Expression *aggr = sfe->aggrfe->aggr;\n     Expression *el = new ArrayLengthExp(aggr->loc, aggr);\n     sc = sc->startCTFE();\n-    el = semantic(el, sc);\n+    el = expressionSemantic(el, sc);\n     sc = sc->endCTFE();\n     el = el->optimize(WANTvalue);\n     el = el->ctfeInterpret();\n@@ -111,7 +110,7 @@ static void lowerArrayAggregate(StaticForeach *sfe, Scope *sc)\n             }\n         }\n         sfe->aggrfe->aggr = new TupleExp(aggr->loc, es);\n-        sfe->aggrfe->aggr = semantic(sfe->aggrfe->aggr, sc);\n+        sfe->aggrfe->aggr = expressionSemantic(sfe->aggrfe->aggr, sc);\n         sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);\n     }\n     else\n@@ -292,9 +291,9 @@ static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n     if (sfe->rangefe)\n     {\n         sc = sc->startCTFE();\n-        sfe->rangefe->lwr = semantic(sfe->rangefe->lwr, sc);\n+        sfe->rangefe->lwr = expressionSemantic(sfe->rangefe->lwr, sc);\n         sfe->rangefe->lwr = resolveProperties(sc, sfe->rangefe->lwr);\n-        sfe->rangefe->upr = semantic(sfe->rangefe->upr, sc);\n+        sfe->rangefe->upr = expressionSemantic(sfe->rangefe->upr, sc);\n         sfe->rangefe->upr = resolveProperties(sc, sfe->rangefe->upr);\n         sc = sc->endCTFE();\n         sfe->rangefe->lwr = sfe->rangefe->lwr->optimize(WANTvalue);\n@@ -321,7 +320,7 @@ static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n     Expression *aggr;\n     Type *indexty;\n \n-    if (sfe->rangefe && (indexty = ety->semantic(aloc, sc))->isintegral())\n+    if (sfe->rangefe && (indexty = typeSemantic(ety, aloc, sc))->isintegral())\n     {\n         sfe->rangefe->lwr->type = indexty;\n         sfe->rangefe->upr->type = indexty;\n@@ -355,7 +354,7 @@ static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n     {\n         aggr = wrapAndCall(aloc, new CompoundStatement(aloc, s2));\n         sc = sc->startCTFE();\n-        aggr = semantic(aggr, sc);\n+        aggr = expressionSemantic(aggr, sc);\n         aggr = resolveProperties(sc, aggr);\n         sc = sc->endCTFE();\n         aggr = aggr->optimize(WANTvalue);\n@@ -382,7 +381,7 @@ void staticForeachPrepare(StaticForeach *sfe, Scope *sc)\n     if (sfe->aggrfe)\n     {\n         sc = sc->startCTFE();\n-        sfe->aggrfe->aggr = semantic(sfe->aggrfe->aggr, sc);\n+        sfe->aggrfe->aggr = expressionSemantic(sfe->aggrfe->aggr, sc);\n         sc = sc->endCTFE();\n         sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);\n         Type *tab = sfe->aggrfe->aggr->type->toBasetype();\n@@ -624,7 +623,7 @@ static bool isReserved(const char *ident)\n void checkReserved(Loc loc, const char *ident)\n {\n     if (isReserved(ident))\n-        error(loc, \"version identifier '%s' is reserved and cannot be set\", ident);\n+        error(loc, \"version identifier `%s` is reserved and cannot be set\", ident);\n }\n \n void VersionCondition::addGlobalIdent(const char *ident)"}, {"sha": "593a98d10b40e6dea4cd551a676b1f090313c012", "filename": "gcc/d/dmd/cond.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcond.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcond.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "8cfeac54e20ae5e745c83306d55e467b0e806ce5", "filename": "gcc/d/dmd/constfold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fconstfold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fconstfold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "a0e0b5fb993278d105df94bcbb0df462268f8319", "filename": "gcc/d/dmd/cppmangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "359739e24a07890e0a2e8b865e63cd5a57c1e001", "filename": "gcc/d/dmd/ctfe.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fctfe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fctfe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfe.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "1d669e595e5ed9042e8b94e74fda0fe5c3af81e2", "filename": "gcc/d/dmd/ctfeexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fctfeexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "61e28fe8d134121225def34c2506f37d802450a7", "filename": "gcc/d/dmd/dcast.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -26,7 +26,6 @@\n FuncDeclaration *isFuncAddress(Expression *e, bool *hasOverloads = NULL);\n bool isCommutative(TOK op);\n MOD MODmerge(MOD mod1, MOD mod2);\n-Expression *semantic(Expression *e, Scope *sc);\n \n /* ==================== implicitCast ====================== */\n \n@@ -1431,7 +1430,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                 TypeVector *tv = (TypeVector *)tob;\n                 result = new CastExp(e->loc, e, tv->elementType());\n                 result = new VectorExp(e->loc, result, tob);\n-                result = ::semantic(result, sc);\n+                result = expressionSemantic(result, sc);\n                 return;\n             }\n             else if (tob->ty != Tvector && t1b->ty == Tvector)\n@@ -1924,7 +1923,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                     {\n                         f->tookAddressOf++;\n                         SymOffExp *se = new SymOffExp(e->loc, f, 0, false);\n-                        ::semantic(se, sc);\n+                        expressionSemantic(se, sc);\n                         // Let SymOffExp::castTo() do the heavy lifting\n                         visit(se);\n                         return;\n@@ -2083,7 +2082,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                     (*ae->elements)[i] = ex;\n                 }\n                 Expression *ev = new VectorExp(e->loc, ae, tb);\n-                ev = ::semantic(ev, sc);\n+                ev = expressionSemantic(ev, sc);\n                 result = ev;\n                 return;\n             }\n@@ -2156,16 +2155,16 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                         if (f->needThis() && hasThis(sc))\n                         {\n                             result = new DelegateExp(e->loc, new ThisExp(e->loc), f, false);\n-                            result = ::semantic(result, sc);\n+                            result = expressionSemantic(result, sc);\n                         }\n                         else if (f->isNested())\n                         {\n                             result = new DelegateExp(e->loc, new IntegerExp(0), f, false);\n-                            result = ::semantic(result, sc);\n+                            result = expressionSemantic(result, sc);\n                         }\n                         else if (f->needThis())\n                         {\n-                            e->error(\"no 'this' to create delegate for %s\", f->toChars());\n+                            e->error(\"no `this` to create delegate for %s\", f->toChars());\n                             result = new ErrorExp();\n                             return;\n                         }\n@@ -2746,7 +2745,7 @@ bool typeMerge(Scope *sc, TOK op, Type **pt, Expression **pe1, Expression **pe2)\n             else\n                 tx = d->pointerTo();\n \n-            tx = tx->semantic(e1->loc, sc);\n+            tx = typeSemantic(tx, e1->loc, sc);\n \n             if (t1->implicitConvTo(tx) && t2->implicitConvTo(tx))\n             {"}, {"sha": "c7dbbbea5d38ea757cb0641f62f6ce8a8897e300", "filename": "gcc/d/dmd/dclass.c", "status": "modified", "additions": 7, "deletions": 910, "changes": 917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -290,599 +290,6 @@ Scope *ClassDeclaration::newScope(Scope *sc)\n     return sc2;\n }\n \n-/* Bugzilla 12078, 12143 and 15733:\n- * While resolving base classes and interfaces, a base may refer\n- * the member of this derived class. In that time, if all bases of\n- * this class can  be determined, we can go forward the semantc process\n- * beyond the Lancestorsdone. To do the recursive semantic analysis,\n- * temporarily set and unset `_scope` around exp().\n- */\n-static Type *resolveBase(ClassDeclaration *cd, Scope *sc, Scope *&scx, Type *type)\n-{\n-    if (!scx)\n-    {\n-        scx = sc->copy();\n-        scx->setNoFree();\n-    }\n-    cd->_scope = scx;\n-    Type *t = type->semantic(cd->loc, sc);\n-    cd->_scope = NULL;\n-    return t;\n-}\n-\n-static void resolveBase(ClassDeclaration *cd, Scope *sc, Scope *&scx, ClassDeclaration *sym)\n-{\n-    if (!scx)\n-    {\n-        scx = sc->copy();\n-        scx->setNoFree();\n-    }\n-    cd->_scope = scx;\n-    sym->semantic(NULL);\n-    cd->_scope = NULL;\n-}\n-\n-static void badObjectDotD(ClassDeclaration *cd)\n-{\n-    cd->error(\"missing or corrupt object.d\");\n-    fatal();\n-}\n-\n-void ClassDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"ClassDeclaration::semantic(%s), type = %p, sizeok = %d, this = %p\\n\", toChars(), type, sizeok, this);\n-    //printf(\"\\tparent = %p, '%s'\\n\", sc->parent, sc->parent ? sc->parent->toChars() : \"\");\n-    //printf(\"sc->stc = %x\\n\", sc->stc);\n-\n-    //{ static int n;  if (++n == 20) *(char*)0=0; }\n-\n-    if (semanticRun >= PASSsemanticdone)\n-        return;\n-    unsigned errors = global.errors;\n-\n-    //printf(\"+ClassDeclaration::semantic(%s), type = %p, sizeok = %d, this = %p\\n\", toChars(), type, sizeok, this);\n-\n-    Scope *scx = NULL;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        scx = _scope;            // save so we don't make redundant copies\n-        _scope = NULL;\n-    }\n-\n-    if (!parent)\n-    {\n-        assert(sc->parent);\n-        parent = sc->parent;\n-    }\n-\n-    if (this->errors)\n-        type = Type::terror;\n-    type = type->semantic(loc, sc);\n-\n-    if (type->ty == Tclass && ((TypeClass *)type)->sym != this)\n-    {\n-        TemplateInstance *ti = ((TypeClass *)type)->sym->isInstantiated();\n-        if (ti && isError(ti))\n-            ((TypeClass *)type)->sym = this;\n-    }\n-\n-    // Ungag errors when not speculative\n-    Ungag ungag = ungagSpeculative();\n-\n-    if (semanticRun == PASSinit)\n-    {\n-        protection = sc->protection;\n-\n-        storage_class |= sc->stc;\n-        if (storage_class & STCdeprecated)\n-            isdeprecated = true;\n-        if (storage_class & STCauto)\n-            error(\"storage class 'auto' is invalid when declaring a class, did you mean to use 'scope'?\");\n-        if (storage_class & STCscope)\n-            isscope = true;\n-        if (storage_class & STCabstract)\n-            isabstract = ABSyes;\n-\n-        userAttribDecl = sc->userAttribDecl;\n-\n-        if (sc->linkage == LINKcpp)\n-            classKind = ClassKind::cpp;\n-        if (sc->linkage == LINKobjc)\n-            objc()->setObjc(this);\n-    }\n-    else if (symtab && !scx)\n-    {\n-        return;\n-    }\n-    semanticRun = PASSsemantic;\n-\n-    if (baseok < BASEOKdone)\n-    {\n-        baseok = BASEOKin;\n-\n-        // Expand any tuples in baseclasses[]\n-        for (size_t i = 0; i < baseclasses->length; )\n-        {\n-            BaseClass *b = (*baseclasses)[i];\n-            b->type = resolveBase(this, sc, scx, b->type);\n-\n-            Type *tb = b->type->toBasetype();\n-            if (tb->ty == Ttuple)\n-            {\n-                TypeTuple *tup = (TypeTuple *)tb;\n-                baseclasses->remove(i);\n-                size_t dim = Parameter::dim(tup->arguments);\n-                for (size_t j = 0; j < dim; j++)\n-                {\n-                    Parameter *arg = Parameter::getNth(tup->arguments, j);\n-                    b = new BaseClass(arg->type);\n-                    baseclasses->insert(i + j, b);\n-                }\n-            }\n-            else\n-                i++;\n-        }\n-\n-        if (baseok >= BASEOKdone)\n-        {\n-            //printf(\"%s already semantic analyzed, semanticRun = %d\\n\", toChars(), semanticRun);\n-            if (semanticRun >= PASSsemanticdone)\n-                return;\n-            goto Lancestorsdone;\n-        }\n-\n-        // See if there's a base class as first in baseclasses[]\n-        if (baseclasses->length)\n-        {\n-            BaseClass *b = (*baseclasses)[0];\n-            Type *tb = b->type->toBasetype();\n-            TypeClass *tc = (tb->ty == Tclass) ? (TypeClass *)tb : NULL;\n-            if (!tc)\n-            {\n-                if (b->type != Type::terror)\n-                    error(\"base type must be class or interface, not %s\", b->type->toChars());\n-                baseclasses->remove(0);\n-                goto L7;\n-            }\n-\n-            if (tc->sym->isDeprecated())\n-            {\n-                if (!isDeprecated())\n-                {\n-                    // Deriving from deprecated class makes this one deprecated too\n-                    isdeprecated = true;\n-\n-                    tc->checkDeprecated(loc, sc);\n-                }\n-            }\n-\n-            if (tc->sym->isInterfaceDeclaration())\n-                goto L7;\n-\n-            for (ClassDeclaration *cdb = tc->sym; cdb; cdb = cdb->baseClass)\n-            {\n-                if (cdb == this)\n-                {\n-                    error(\"circular inheritance\");\n-                    baseclasses->remove(0);\n-                    goto L7;\n-                }\n-            }\n-\n-            /* Bugzilla 11034: Essentially, class inheritance hierarchy\n-             * and instance size of each classes are orthogonal information.\n-             * Therefore, even if tc->sym->sizeof == SIZEOKnone,\n-             * we need to set baseClass field for class covariance check.\n-             */\n-            baseClass = tc->sym;\n-            b->sym = baseClass;\n-\n-            if (tc->sym->baseok < BASEOKdone)\n-                resolveBase(this, sc, scx, tc->sym); // Try to resolve forward reference\n-            if (tc->sym->baseok < BASEOKdone)\n-            {\n-                //printf(\"\\ttry later, forward reference of base class %s\\n\", tc->sym->toChars());\n-                if (tc->sym->_scope)\n-                    tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-                baseok = BASEOKnone;\n-            }\n-         L7: ;\n-        }\n-\n-        // Treat the remaining entries in baseclasses as interfaces\n-        // Check for errors, handle forward references\n-        for (size_t i = (baseClass ? 1 : 0); i < baseclasses->length; )\n-        {\n-            BaseClass *b = (*baseclasses)[i];\n-            Type *tb = b->type->toBasetype();\n-            TypeClass *tc = (tb->ty == Tclass) ? (TypeClass *)tb : NULL;\n-            if (!tc || !tc->sym->isInterfaceDeclaration())\n-            {\n-                if (b->type != Type::terror)\n-                    error(\"base type must be interface, not %s\", b->type->toChars());\n-                baseclasses->remove(i);\n-                continue;\n-            }\n-\n-            // Check for duplicate interfaces\n-            for (size_t j = (baseClass ? 1 : 0); j < i; j++)\n-            {\n-                BaseClass *b2 = (*baseclasses)[j];\n-                if (b2->sym == tc->sym)\n-                {\n-                    error(\"inherits from duplicate interface %s\", b2->sym->toChars());\n-                    baseclasses->remove(i);\n-                    continue;\n-                }\n-            }\n-\n-            if (tc->sym->isDeprecated())\n-            {\n-                if (!isDeprecated())\n-                {\n-                    // Deriving from deprecated class makes this one deprecated too\n-                    isdeprecated = true;\n-\n-                    tc->checkDeprecated(loc, sc);\n-                }\n-            }\n-\n-            b->sym = tc->sym;\n-\n-            if (tc->sym->baseok < BASEOKdone)\n-                resolveBase(this, sc, scx, tc->sym); // Try to resolve forward reference\n-            if (tc->sym->baseok < BASEOKdone)\n-            {\n-                //printf(\"\\ttry later, forward reference of base %s\\n\", tc->sym->toChars());\n-                if (tc->sym->_scope)\n-                    tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-                baseok = BASEOKnone;\n-            }\n-            i++;\n-        }\n-        if (baseok == BASEOKnone)\n-        {\n-            // Forward referencee of one or more bases, try again later\n-            _scope = scx ? scx : sc->copy();\n-            _scope->setNoFree();\n-            _scope->_module->addDeferredSemantic(this);\n-            //printf(\"\\tL%d semantic('%s') failed due to forward references\\n\", __LINE__, toChars());\n-            return;\n-        }\n-        baseok = BASEOKdone;\n-\n-        // If no base class, and this is not an Object, use Object as base class\n-        if (!baseClass && ident != Id::Object && !isCPPclass())\n-        {\n-            if (!object || object->errors)\n-                badObjectDotD(this);\n-\n-            Type *t = object->type;\n-            t = t->semantic(loc, sc)->toBasetype();\n-            if (t->ty == Terror)\n-                badObjectDotD(this);\n-            assert(t->ty == Tclass);\n-            TypeClass *tc = (TypeClass *)t;\n-\n-            BaseClass *b = new BaseClass(tc);\n-            baseclasses->shift(b);\n-\n-            baseClass = tc->sym;\n-            assert(!baseClass->isInterfaceDeclaration());\n-            b->sym = baseClass;\n-        }\n-        if (baseClass)\n-        {\n-            if (baseClass->storage_class & STCfinal)\n-                error(\"cannot inherit from final class %s\", baseClass->toChars());\n-\n-            // Inherit properties from base class\n-            if (baseClass->isCOMclass())\n-                com = true;\n-            if (baseClass->isCPPclass())\n-                classKind = ClassKind::cpp;\n-            if (baseClass->isscope)\n-                isscope = true;\n-            enclosing = baseClass->enclosing;\n-            storage_class |= baseClass->storage_class & STC_TYPECTOR;\n-        }\n-\n-        interfaces.length = baseclasses->length - (baseClass ? 1 : 0);\n-        interfaces.ptr = baseclasses->tdata() + (baseClass ? 1 : 0);\n-\n-        for (size_t i = 0; i < interfaces.length; i++)\n-        {\n-            BaseClass *b = interfaces.ptr[i];\n-            // If this is an interface, and it derives from a COM interface,\n-            // then this is a COM interface too.\n-            if (b->sym->isCOMinterface())\n-                com = true;\n-            if (isCPPclass() && !b->sym->isCPPinterface())\n-            {\n-                ::error(loc, \"C++ class '%s' cannot implement D interface '%s'\",\n-                    toPrettyChars(), b->sym->toPrettyChars());\n-            }\n-        }\n-\n-        interfaceSemantic(sc);\n-    }\n-Lancestorsdone:\n-    //printf(\"\\tClassDeclaration::semantic(%s) baseok = %d\\n\", toChars(), baseok);\n-\n-    if (!members)               // if opaque declaration\n-    {\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-    if (!symtab)\n-    {\n-        symtab = new DsymbolTable();\n-\n-        /* Bugzilla 12152: The semantic analysis of base classes should be finished\n-         * before the members semantic analysis of this class, in order to determine\n-         * vtbl in this class. However if a base class refers the member of this class,\n-         * it can be resolved as a normal forward reference.\n-         * Call addMember() and setScope() to make this class members visible from the base classes.\n-         */\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->addMember(sc, this);\n-        }\n-\n-        Scope *sc2 = newScope(sc);\n-\n-        /* Set scope so if there are forward references, we still might be able to\n-         * resolve individual members like enums.\n-         */\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            //printf(\"[%d] setScope %s %s, sc2 = %p\\n\", i, s->kind(), s->toChars(), sc2);\n-            s->setScope(sc2);\n-        }\n-\n-        sc2->pop();\n-    }\n-\n-    for (size_t i = 0; i < baseclasses->length; i++)\n-    {\n-        BaseClass *b = (*baseclasses)[i];\n-        Type *tb = b->type->toBasetype();\n-        assert(tb->ty == Tclass);\n-        TypeClass *tc = (TypeClass *)tb;\n-\n-        if (tc->sym->semanticRun < PASSsemanticdone)\n-        {\n-            // Forward referencee of one or more bases, try again later\n-            _scope = scx ? scx : sc->copy();\n-            _scope->setNoFree();\n-            if (tc->sym->_scope)\n-                tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-            _scope->_module->addDeferredSemantic(this);\n-            //printf(\"\\tL%d semantic('%s') failed due to forward references\\n\", __LINE__, toChars());\n-            return;\n-        }\n-    }\n-\n-    if (baseok == BASEOKdone)\n-    {\n-        baseok = BASEOKsemanticdone;\n-\n-        // initialize vtbl\n-        if (baseClass)\n-        {\n-            if (isCPPclass() && baseClass->vtbl.length == 0)\n-            {\n-                error(\"C++ base class %s needs at least one virtual function\", baseClass->toChars());\n-            }\n-\n-            // Copy vtbl[] from base class\n-            vtbl.setDim(baseClass->vtbl.length);\n-            memcpy(vtbl.tdata(), baseClass->vtbl.tdata(), sizeof(void *) * vtbl.length);\n-\n-            vthis = baseClass->vthis;\n-        }\n-        else\n-        {\n-            // No base class, so this is the root of the class hierarchy\n-            vtbl.setDim(0);\n-            if (vtblOffset())\n-                vtbl.push(this);            // leave room for classinfo as first member\n-        }\n-\n-        /* If this is a nested class, add the hidden 'this'\n-         * member which is a pointer to the enclosing scope.\n-         */\n-        if (vthis)              // if inheriting from nested class\n-        {\n-            // Use the base class's 'this' member\n-            if (storage_class & STCstatic)\n-                error(\"static class cannot inherit from nested class %s\", baseClass->toChars());\n-            if (toParent2() != baseClass->toParent2() &&\n-                (!toParent2() ||\n-                 !baseClass->toParent2()->getType() ||\n-                 !baseClass->toParent2()->getType()->isBaseOf(toParent2()->getType(), NULL)))\n-            {\n-                if (toParent2())\n-                {\n-                    error(\"is nested within %s, but super class %s is nested within %s\",\n-                        toParent2()->toChars(),\n-                        baseClass->toChars(),\n-                        baseClass->toParent2()->toChars());\n-                }\n-                else\n-                {\n-                    error(\"is not nested, but super class %s is nested within %s\",\n-                        baseClass->toChars(),\n-                        baseClass->toParent2()->toChars());\n-                }\n-                enclosing = NULL;\n-            }\n-        }\n-        else\n-            makeNested();\n-    }\n-\n-    Scope *sc2 = newScope(sc);\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->importAll(sc2);\n-    }\n-\n-    // Note that members.length can grow due to tuple expansion during semantic()\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->semantic(sc2);\n-    }\n-\n-    if (!determineFields())\n-    {\n-        assert(type == Type::terror);\n-        sc2->pop();\n-        return;\n-    }\n-\n-    /* Following special member functions creation needs semantic analysis\n-     * completion of sub-structs in each field types.\n-     */\n-    for (size_t i = 0; i < fields.length; i++)\n-    {\n-        VarDeclaration *v = fields[i];\n-        Type *tb = v->type->baseElemOf();\n-        if (tb->ty != Tstruct)\n-            continue;\n-        StructDeclaration *sd = ((TypeStruct *)tb)->sym;\n-        if (sd->semanticRun >= PASSsemanticdone)\n-            continue;\n-\n-        sc2->pop();\n-\n-        _scope = scx ? scx : sc->copy();\n-        _scope->setNoFree();\n-        _scope->_module->addDeferredSemantic(this);\n-        //printf(\"\\tdeferring %s\\n\", toChars());\n-        return;\n-    }\n-\n-    /* Look for special member functions.\n-     * They must be in this class, not in a base class.\n-     */\n-\n-    // Can be in base class\n-    aggNew    =    (NewDeclaration *)search(Loc(), Id::classNew);\n-    aggDelete = (DeleteDeclaration *)search(Loc(), Id::classDelete);\n-\n-    // Look for the constructor\n-    ctor = searchCtor();\n-\n-    if (!ctor && noDefaultCtor)\n-    {\n-        // A class object is always created by constructor, so this check is legitimate.\n-        for (size_t i = 0; i < fields.length; i++)\n-        {\n-            VarDeclaration *v = fields[i];\n-            if (v->storage_class & STCnodefaultctor)\n-                ::error(v->loc, \"field %s must be initialized in constructor\", v->toChars());\n-        }\n-    }\n-\n-    // If this class has no constructor, but base class has a default\n-    // ctor, create a constructor:\n-    //    this() { }\n-    if (!ctor && baseClass && baseClass->ctor)\n-    {\n-        FuncDeclaration *fd = resolveFuncCall(loc, sc2, baseClass->ctor, NULL, type, NULL, 1);\n-        if (!fd) // try shared base ctor instead\n-            fd = resolveFuncCall(loc, sc2, baseClass->ctor, NULL, type->sharedOf(), NULL, 1);\n-        if (fd && !fd->errors)\n-        {\n-            //printf(\"Creating default this(){} for class %s\\n\", toChars());\n-            TypeFunction *btf = fd->type->toTypeFunction();\n-            TypeFunction *tf = new TypeFunction(ParameterList(), NULL, LINKd, fd->storage_class);\n-            tf->mod = btf->mod;\n-            tf->purity = btf->purity;\n-            tf->isnothrow = btf->isnothrow;\n-            tf->isnogc = btf->isnogc;\n-            tf->trust = btf->trust;\n-\n-            CtorDeclaration *ctor = new CtorDeclaration(loc, Loc(), 0, tf);\n-            ctor->fbody = new CompoundStatement(Loc(), new Statements());\n-\n-            members->push(ctor);\n-            ctor->addMember(sc, this);\n-            ctor->semantic(sc2);\n-\n-            this->ctor = ctor;\n-            defaultCtor = ctor;\n-        }\n-        else\n-        {\n-            error(\"cannot implicitly generate a default ctor when base class %s is missing a default ctor\",\n-                baseClass->toPrettyChars());\n-        }\n-    }\n-\n-    dtor = buildDtor(this, sc2);\n-\n-    if (FuncDeclaration *f = hasIdentityOpAssign(this, sc2))\n-    {\n-        if (!(f->storage_class & STCdisable))\n-            error(f->loc, \"identity assignment operator overload is illegal\");\n-    }\n-\n-    inv = buildInv(this, sc2);\n-\n-    Module::dprogress++;\n-    semanticRun = PASSsemanticdone;\n-    //printf(\"-ClassDeclaration.semantic(%s), type = %p\\n\", toChars(), type);\n-    //members.print();\n-\n-    sc2->pop();\n-\n-    if (type->ty == Tclass && ((TypeClass *)type)->sym != this)\n-    {\n-        // https://issues.dlang.org/show_bug.cgi?id=17492\n-        ClassDeclaration *cd = ((TypeClass *)type)->sym;\n-        error(\"already exists at %s. Perhaps in another function with the same name?\", cd->loc.toChars());\n-    }\n-\n-    if (global.errors != errors)\n-    {\n-        // The type is no good.\n-        type = Type::terror;\n-        this->errors = true;\n-        if (deferred)\n-            deferred->errors = true;\n-    }\n-\n-    // Verify fields of a synchronized class are not public\n-    if (storage_class & STCsynchronized)\n-    {\n-        for (size_t i = 0; i < fields.length; i++)\n-        {\n-            VarDeclaration *vd = fields[i];\n-            if (!vd->isThisDeclaration() &&\n-                !vd->prot().isMoreRestrictiveThan(Prot(Prot::public_)))\n-            {\n-                vd->error(\"Field members of a synchronized class cannot be %s\",\n-                    protectionToChars(vd->prot().kind));\n-            }\n-        }\n-    }\n-\n-    if (deferred && !global.gag)\n-    {\n-        deferred->semantic2(sc);\n-        deferred->semantic3(sc);\n-    }\n-    //printf(\"-ClassDeclaration::semantic(%s), type = %p, sizeok = %d, this = %p\\n\", toChars(), type, sizeok, this);\n-}\n-\n /*********************************************\n  * Determine if 'this' is a base class of cd.\n  * This is used to detect circular inheritance only.\n@@ -917,7 +324,7 @@ bool ClassDeclaration::isBaseOf(ClassDeclaration *cd, int *poffset)\n          */\n         if (!cd->baseClass && cd->semanticRun < PASSsemanticdone && !cd->isInterfaceDeclaration())\n         {\n-            cd->semantic(NULL);\n+            dsymbolSemantic(cd, NULL);\n             if (!cd->baseClass && cd->semanticRun < PASSsemanticdone)\n                 cd->error(\"base class is forward referenced by %s\", toChars());\n         }\n@@ -951,14 +358,14 @@ Dsymbol *ClassDeclaration::search(const Loc &loc, Identifier *ident, int flags)\n         {\n             // must semantic on base class/interfaces\n             ++inuse;\n-            semantic(NULL);\n+            dsymbolSemantic(this, NULL);\n             --inuse;\n         }\n     }\n \n     if (!members || !symtab)    // opaque or addMember is not yet done\n     {\n-        error(\"is forward referenced when looking for '%s'\", ident->toChars());\n+        error(\"is forward referenced when looking for `%s`\", ident->toChars());\n         //*(char*)0=0;\n         return NULL;\n     }\n@@ -1277,19 +684,6 @@ FuncDeclaration *ClassDeclaration::findFunc(Identifier *ident, TypeFunction *tf)\n     return fdmatch;\n }\n \n-void ClassDeclaration::interfaceSemantic(Scope *)\n-{\n-    vtblInterfaces = new BaseClasses();\n-    vtblInterfaces->reserve(interfaces.length);\n-\n-    for (size_t i = 0; i < interfaces.length; i++)\n-    {\n-        BaseClass *b = interfaces.ptr[i];\n-        vtblInterfaces->push(b);\n-        b->copyBaseInterfaces(vtblInterfaces);\n-    }\n-}\n-\n /****************************************\n  */\n \n@@ -1336,7 +730,7 @@ bool ClassDeclaration::isAbstract()\n                 return 0;\n \n             if (fd->_scope)\n-                fd->semantic(NULL);\n+                dsymbolSemantic(fd, NULL);\n \n             if (fd->isAbstract())\n                 return 1;\n@@ -1435,303 +829,6 @@ Scope *InterfaceDeclaration::newScope(Scope *sc)\n     return sc2;\n }\n \n-void InterfaceDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"InterfaceDeclaration::semantic(%s), type = %p\\n\", toChars(), type);\n-    if (semanticRun >= PASSsemanticdone)\n-        return;\n-    unsigned errors = global.errors;\n-\n-    //printf(\"+InterfaceDeclaration.semantic(%s), type = %p\\n\", toChars(), type);\n-\n-    Scope *scx = NULL;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        scx = _scope;            // save so we don't make redundant copies\n-        _scope = NULL;\n-    }\n-\n-    if (!parent)\n-    {\n-        assert(sc->parent && sc->func);\n-        parent = sc->parent;\n-    }\n-    assert(parent && !isAnonymous());\n-\n-    if (this->errors)\n-        type = Type::terror;\n-    type = type->semantic(loc, sc);\n-\n-    if (type->ty == Tclass && ((TypeClass *)type)->sym != this)\n-    {\n-        TemplateInstance *ti = ((TypeClass *)type)->sym->isInstantiated();\n-        if (ti && isError(ti))\n-            ((TypeClass *)type)->sym = this;\n-    }\n-\n-    // Ungag errors when not speculative\n-    Ungag ungag = ungagSpeculative();\n-\n-    if (semanticRun == PASSinit)\n-    {\n-        protection = sc->protection;\n-\n-        storage_class |= sc->stc;\n-        if (storage_class & STCdeprecated)\n-            isdeprecated = true;\n-\n-        userAttribDecl = sc->userAttribDecl;\n-    }\n-    else if (symtab)\n-    {\n-        if (sizeok == SIZEOKdone || !scx)\n-        {\n-            semanticRun = PASSsemanticdone;\n-            return;\n-        }\n-    }\n-    semanticRun = PASSsemantic;\n-\n-    if (baseok < BASEOKdone)\n-    {\n-        baseok = BASEOKin;\n-\n-        // Expand any tuples in baseclasses[]\n-        for (size_t i = 0; i < baseclasses->length; )\n-        {\n-            BaseClass *b = (*baseclasses)[i];\n-            b->type = resolveBase(this, sc, scx, b->type);\n-\n-            Type *tb = b->type->toBasetype();\n-            if (tb->ty == Ttuple)\n-            {\n-                TypeTuple *tup = (TypeTuple *)tb;\n-                baseclasses->remove(i);\n-                size_t dim = Parameter::dim(tup->arguments);\n-                for (size_t j = 0; j < dim; j++)\n-                {\n-                    Parameter *arg = Parameter::getNth(tup->arguments, j);\n-                    b = new BaseClass(arg->type);\n-                    baseclasses->insert(i + j, b);\n-                }\n-            }\n-            else\n-                i++;\n-        }\n-\n-        if (baseok >= BASEOKdone)\n-        {\n-            //printf(\"%s already semantic analyzed, semanticRun = %d\\n\", toChars(), semanticRun);\n-            if (semanticRun >= PASSsemanticdone)\n-                return;\n-            goto Lancestorsdone;\n-        }\n-\n-        if (!baseclasses->length && sc->linkage == LINKcpp)\n-            classKind = ClassKind::cpp;\n-        if (sc->linkage == LINKobjc)\n-            objc()->setObjc(this);\n-\n-        // Check for errors, handle forward references\n-        for (size_t i = 0; i < baseclasses->length; )\n-        {\n-            BaseClass *b = (*baseclasses)[i];\n-            Type *tb = b->type->toBasetype();\n-            TypeClass *tc = (tb->ty == Tclass) ? (TypeClass *)tb : NULL;\n-            if (!tc || !tc->sym->isInterfaceDeclaration())\n-            {\n-                if (b->type != Type::terror)\n-                    error(\"base type must be interface, not %s\", b->type->toChars());\n-                baseclasses->remove(i);\n-                continue;\n-            }\n-\n-            // Check for duplicate interfaces\n-            for (size_t j = 0; j < i; j++)\n-            {\n-                BaseClass *b2 = (*baseclasses)[j];\n-                if (b2->sym == tc->sym)\n-                {\n-                    error(\"inherits from duplicate interface %s\", b2->sym->toChars());\n-                    baseclasses->remove(i);\n-                    continue;\n-                }\n-            }\n-\n-            if (tc->sym == this || isBaseOf2(tc->sym))\n-            {\n-                error(\"circular inheritance of interface\");\n-                baseclasses->remove(i);\n-                continue;\n-            }\n-\n-            if (tc->sym->isDeprecated())\n-            {\n-                if (!isDeprecated())\n-                {\n-                    // Deriving from deprecated class makes this one deprecated too\n-                    isdeprecated = true;\n-\n-                    tc->checkDeprecated(loc, sc);\n-                }\n-            }\n-\n-            b->sym = tc->sym;\n-\n-            if (tc->sym->baseok < BASEOKdone)\n-                resolveBase(this, sc, scx, tc->sym); // Try to resolve forward reference\n-            if (tc->sym->baseok < BASEOKdone)\n-            {\n-                //printf(\"\\ttry later, forward reference of base %s\\n\", tc->sym->toChars());\n-                if (tc->sym->_scope)\n-                    tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-                baseok = BASEOKnone;\n-            }\n-            i++;\n-        }\n-        if (baseok == BASEOKnone)\n-        {\n-            // Forward referencee of one or more bases, try again later\n-            _scope = scx ? scx : sc->copy();\n-            _scope->setNoFree();\n-            _scope->_module->addDeferredSemantic(this);\n-            return;\n-        }\n-        baseok = BASEOKdone;\n-\n-        interfaces.length = baseclasses->length;\n-        interfaces.ptr = baseclasses->tdata();\n-\n-        for (size_t i = 0; i < interfaces.length; i++)\n-        {\n-            BaseClass *b = interfaces.ptr[i];\n-            // If this is an interface, and it derives from a COM interface,\n-            // then this is a COM interface too.\n-            if (b->sym->isCOMinterface())\n-                com = true;\n-            if (b->sym->isCPPinterface())\n-                classKind = ClassKind::cpp;\n-        }\n-\n-        interfaceSemantic(sc);\n-    }\n-Lancestorsdone:\n-\n-    if (!members)               // if opaque declaration\n-    {\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-    if (!symtab)\n-        symtab = new DsymbolTable();\n-\n-    for (size_t i = 0; i < baseclasses->length; i++)\n-    {\n-        BaseClass *b = (*baseclasses)[i];\n-        Type *tb = b->type->toBasetype();\n-        assert(tb->ty == Tclass);\n-        TypeClass *tc = (TypeClass *)tb;\n-\n-        if (tc->sym->semanticRun < PASSsemanticdone)\n-        {\n-            // Forward referencee of one or more bases, try again later\n-            _scope = scx ? scx : sc->copy();\n-            _scope->setNoFree();\n-            if (tc->sym->_scope)\n-                tc->sym->_scope->_module->addDeferredSemantic(tc->sym);\n-            _scope->_module->addDeferredSemantic(this);\n-            return;\n-        }\n-    }\n-\n-    if (baseok == BASEOKdone)\n-    {\n-        baseok = BASEOKsemanticdone;\n-\n-        // initialize vtbl\n-        if (vtblOffset())\n-            vtbl.push(this);                // leave room at vtbl[0] for classinfo\n-\n-        // Cat together the vtbl[]'s from base interfaces\n-        for (size_t i = 0; i < interfaces.length; i++)\n-        {\n-            BaseClass *b = interfaces.ptr[i];\n-\n-            // Skip if b has already appeared\n-            for (size_t k = 0; k < i; k++)\n-            {\n-                if (b == interfaces.ptr[k])\n-                    goto Lcontinue;\n-            }\n-\n-            // Copy vtbl[] from base class\n-            if (b->sym->vtblOffset())\n-            {\n-                size_t d = b->sym->vtbl.length;\n-                if (d > 1)\n-                {\n-                    vtbl.reserve(d - 1);\n-                    for (size_t j = 1; j < d; j++)\n-                        vtbl.push(b->sym->vtbl[j]);\n-                }\n-            }\n-            else\n-            {\n-                vtbl.append(&b->sym->vtbl);\n-            }\n-\n-          Lcontinue:\n-            ;\n-        }\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->addMember(sc, this);\n-    }\n-\n-    Scope *sc2 = newScope(sc);\n-\n-    /* Set scope so if there are forward references, we still might be able to\n-     * resolve individual members like enums.\n-     */\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        //printf(\"setScope %s %s\\n\", s->kind(), s->toChars());\n-        s->setScope(sc2);\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->importAll(sc2);\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->semantic(sc2);\n-    }\n-\n-    Module::dprogress++;\n-    semanticRun = PASSsemanticdone;\n-    //printf(\"-InterfaceDeclaration.semantic(%s), type = %p\\n\", toChars(), type);\n-    //members->print();\n-\n-    sc2->pop();\n-\n-    if (global.errors != errors)\n-    {\n-        // The type is no good.\n-        type = Type::terror;\n-    }\n-\n-    assert(type->ty != Tclass || ((TypeClass *)type)->sym == this);\n-}\n-\n /*******************************************\n  * Determine if 'this' is a base class of cd.\n  * (Actually, if it is an interface supported by cd)\n@@ -1901,7 +998,7 @@ bool BaseClass::fillVtbl(ClassDeclaration *cd, FuncDeclarations *vtbl, int newin\n             //printf(\"newinstance = %d fd->toParent() = %s ifd->toParent() = %s\\n\",\n                 //newinstance, fd->toParent()->toChars(), ifd->toParent()->toChars());\n             if (newinstance && fd->toParent() != cd && ifd->toParent() == sym)\n-                cd->error(\"interface function '%s' is not implemented\", ifd->toFullSignature());\n+                cd->error(\"interface function `%s` is not implemented\", ifd->toFullSignature());\n \n             if (fd->toParent() == cd)\n                 result = true;\n@@ -1911,7 +1008,7 @@ bool BaseClass::fillVtbl(ClassDeclaration *cd, FuncDeclarations *vtbl, int newin\n             //printf(\"            not found %p\\n\", fd);\n             // BUG: should mark this class as abstract?\n             if (!cd->isAbstract())\n-                cd->error(\"interface function '%s' is not implemented\", ifd->toFullSignature());\n+                cd->error(\"interface function `%s` is not implemented\", ifd->toFullSignature());\n \n             fd = NULL;\n         }"}, {"sha": "a9394dcce7fb6bb9efdf7f3deee68c77dee445ed", "filename": "gcc/d/dmd/declaration.c", "status": "modified", "additions": 8, "deletions": 1038, "changes": 1046, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -29,10 +29,6 @@\n #include \"hdrgen.h\"\n \n bool checkNestedRef(Dsymbol *s, Dsymbol *p);\n-VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n-Expression *semantic(Expression *e, Scope *sc);\n-Initializer *inferType(Initializer *init, Scope *sc);\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n \n /************************************\n  * Check to see the aggregate type is nested and its context pointer is\n@@ -81,10 +77,6 @@ Declaration::Declaration(Identifier *id)\n     mangleOverride = NULL;\n }\n \n-void Declaration::semantic(Scope *)\n-{\n-}\n-\n const char *Declaration::kind() const\n {\n     return \"declaration\";\n@@ -139,7 +131,7 @@ int Declaration::checkModify(Loc loc, Scope *sc, Type *, Expression *e1, int fla\n             if (scx->func == parent && (scx->flags & SCOPEcontract))\n             {\n                 const char *s = isParameter() && parent->ident != Id::ensure ? \"parameter\" : \"result\";\n-                if (!flag) error(loc, \"cannot modify %s '%s' in contract\", s, toChars());\n+                if (!flag) error(loc, \"cannot modify %s `%s` in contract\", s, toChars());\n                 return 2;   // do not report type related errors\n             }\n         }\n@@ -291,7 +283,7 @@ Type *TupleDeclaration::getType()\n \n         tupletype = new TypeTuple(args);\n         if (hasdeco)\n-            return tupletype->semantic(Loc(), NULL);\n+            return typeSemantic(tupletype, Loc(), NULL);\n     }\n \n     return tupletype;\n@@ -380,173 +372,6 @@ Dsymbol *AliasDeclaration::syntaxCopy(Dsymbol *s)\n     return sa;\n }\n \n-void AliasDeclaration::semantic(Scope *sc)\n-{\n-    if (semanticRun >= PASSsemanticdone)\n-        return;\n-    assert(semanticRun <= PASSsemantic);\n-\n-    storage_class |= sc->stc & STCdeprecated;\n-    protection = sc->protection;\n-    userAttribDecl = sc->userAttribDecl;\n-\n-    if (!sc->func && inNonRoot())\n-        return;\n-\n-    aliasSemantic(sc);\n-}\n-\n-void AliasDeclaration::aliasSemantic(Scope *sc)\n-{\n-    //printf(\"AliasDeclaration::semantic() %s\\n\", toChars());\n-\n-    // as AliasDeclaration::semantic, in case we're called first.\n-    // see https://issues.dlang.org/show_bug.cgi?id=21001\n-    storage_class |= sc->stc & STCdeprecated;\n-    protection = sc->protection;\n-    userAttribDecl = sc->userAttribDecl;\n-\n-    // TypeTraits needs to know if it's located in an AliasDeclaration\n-    sc->flags |= SCOPEalias;\n-\n-    if (aliassym)\n-    {\n-        FuncDeclaration *fd = aliassym->isFuncLiteralDeclaration();\n-        TemplateDeclaration *td = aliassym->isTemplateDeclaration();\n-        if (fd || (td && td->literal))\n-        {\n-            if (fd && fd->semanticRun >= PASSsemanticdone)\n-            {\n-                sc->flags &= ~SCOPEalias;\n-                return;\n-            }\n-\n-            Expression *e = new FuncExp(loc, aliassym);\n-            e = ::semantic(e, sc);\n-            if (e->op == TOKfunction)\n-            {\n-                FuncExp *fe = (FuncExp *)e;\n-                aliassym = fe->td ? (Dsymbol *)fe->td : fe->fd;\n-            }\n-            else\n-            {\n-                aliassym = NULL;\n-                type = Type::terror;\n-            }\n-            sc->flags &= ~SCOPEalias;\n-            return;\n-        }\n-\n-        if (aliassym->isTemplateInstance())\n-            aliassym->semantic(sc);\n-        sc->flags &= ~SCOPEalias;\n-        return;\n-    }\n-    inuse = 1;\n-\n-    // Given:\n-    //  alias foo.bar.abc def;\n-    // it is not knowable from the syntax whether this is an alias\n-    // for a type or an alias for a symbol. It is up to the semantic()\n-    // pass to distinguish.\n-    // If it is a type, then type is set and getType() will return that\n-    // type. If it is a symbol, then aliassym is set and type is NULL -\n-    // toAlias() will return aliasssym.\n-\n-    unsigned int errors = global.errors;\n-    Type *oldtype = type;\n-\n-    // Ungag errors when not instantiated DeclDefs scope alias\n-    Ungag ungag(global.gag);\n-    //printf(\"%s parent = %s, gag = %d, instantiated = %d\\n\", toChars(), parent, global.gag, isInstantiated());\n-    if (parent && global.gag && !isInstantiated() && !toParent2()->isFuncDeclaration())\n-    {\n-        //printf(\"%s type = %s\\n\", toPrettyChars(), type->toChars());\n-        global.gag = 0;\n-    }\n-\n-    /* This section is needed because Type::resolve() will:\n-     *   const x = 3;\n-     *   alias y = x;\n-     * try to convert identifier x to 3.\n-     */\n-    Dsymbol *s = type->toDsymbol(sc);\n-    if (errors != global.errors)\n-    {\n-        s = NULL;\n-        type = Type::terror;\n-    }\n-    if (s && s == this)\n-    {\n-        error(\"cannot resolve\");\n-        s = NULL;\n-        type = Type::terror;\n-    }\n-    if (!s || !s->isEnumMember())\n-    {\n-        Type *t;\n-        Expression *e;\n-        Scope *sc2 = sc;\n-        if (storage_class & (STCref | STCnothrow | STCnogc | STCpure | STCdisable))\n-        {\n-            // For 'ref' to be attached to function types, and picked\n-            // up by Type::resolve(), it has to go into sc.\n-            sc2 = sc->push();\n-            sc2->stc |= storage_class & (STCref | STCnothrow | STCnogc | STCpure | STCshared | STCdisable);\n-        }\n-        type = type->addSTC(storage_class);\n-        type->resolve(loc, sc2, &e, &t, &s);\n-        if (sc2 != sc)\n-            sc2->pop();\n-\n-        if (e)  // Try to convert Expression to Dsymbol\n-        {\n-            s = getDsymbol(e);\n-            if (!s)\n-            {\n-                if (e->op != TOKerror)\n-                    error(\"cannot alias an expression %s\", e->toChars());\n-                t = Type::terror;\n-            }\n-        }\n-        type = t;\n-    }\n-    if (s == this)\n-    {\n-        assert(global.errors);\n-        type = Type::terror;\n-        s = NULL;\n-    }\n-    if (!s) // it's a type alias\n-    {\n-        //printf(\"alias %s resolved to type %s\\n\", toChars(), type->toChars());\n-        type = type->semantic(loc, sc);\n-        aliassym = NULL;\n-    }\n-    else    // it's a symbolic alias\n-    {\n-        //printf(\"alias %s resolved to %s %s\\n\", toChars(), s->kind(), s->toChars());\n-        type = NULL;\n-        aliassym = s;\n-    }\n-    if (global.gag && errors != global.errors)\n-    {\n-        type = oldtype;\n-        aliassym = NULL;\n-    }\n-    inuse = 0;\n-    semanticRun = PASSsemanticdone;\n-\n-    if (Dsymbol *sx = overnext)\n-    {\n-        overnext = NULL;\n-\n-        if (!overloadInsert(sx))\n-            ScopeDsymbol::multiplyDefined(Loc(), sx, this);\n-    }\n-    sc->flags &= ~SCOPEalias;\n-}\n-\n bool AliasDeclaration::overloadInsert(Dsymbol *s)\n {\n     //printf(\"[%s] AliasDeclaration::overloadInsert('%s') s = %s %s @ [%s]\\n\",\n@@ -684,7 +509,7 @@ Dsymbol *AliasDeclaration::toAlias()\n         }\n         else\n         {\n-            Type *t = type->semantic(loc, _scope);\n+            Type *t = typeSemantic(type, loc, _scope);\n             if (t->ty == Terror)\n                 goto Lerr;\n             if (global.errors != olderrors)\n@@ -723,11 +548,11 @@ Dsymbol *AliasDeclaration::toAlias()\n             /* If this is an internal alias for selective/renamed import,\n              * load the module first.\n              */\n-            _import->semantic(NULL);\n+            dsymbolSemantic(_import, NULL);\n         }\n         if (_scope)\n         {\n-            aliasSemantic(_scope);\n+            aliasSemantic(this, _scope);\n         }\n     }\n \n@@ -783,10 +608,6 @@ const char *OverDeclaration::kind() const\n     return \"overload alias\";    // todo\n }\n \n-void OverDeclaration::semantic(Scope *)\n-{\n-}\n-\n bool OverDeclaration::equals(RootObject *o)\n {\n     if (this == o)\n@@ -922,852 +743,6 @@ Dsymbol *VarDeclaration::syntaxCopy(Dsymbol *s)\n     return v;\n }\n \n-\n-void VarDeclaration::semantic(Scope *sc)\n-{\n-//    if (semanticRun > PASSinit)\n-//      return;\n-//    semanticRun = PASSsemantic;\n-\n-    if (semanticRun >= PASSsemanticdone)\n-        return;\n-\n-    Scope *scx = NULL;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        scx = sc;\n-        _scope = NULL;\n-    }\n-\n-    if (!sc)\n-        return;\n-\n-    semanticRun = PASSsemantic;\n-\n-    /* Pick up storage classes from context, but except synchronized,\n-     * override, abstract, and final.\n-     */\n-    storage_class |= (sc->stc & ~(STCsynchronized | STCoverride | STCabstract | STCfinal));\n-    if (storage_class & STCextern && _init)\n-        error(\"extern symbols cannot have initializers\");\n-\n-    userAttribDecl = sc->userAttribDecl;\n-\n-    AggregateDeclaration *ad = isThis();\n-    if (ad)\n-        storage_class |= ad->storage_class & STC_TYPECTOR;\n-\n-    /* If auto type inference, do the inference\n-     */\n-    int inferred = 0;\n-    if (!type)\n-    {\n-        inuse++;\n-\n-        // Infering the type requires running semantic,\n-        // so mark the scope as ctfe if required\n-        bool needctfe = (storage_class & (STCmanifest | STCstatic)) != 0;\n-        if (needctfe) sc = sc->startCTFE();\n-\n-        //printf(\"inferring type for %s with init %s\\n\", toChars(), _init->toChars());\n-        _init = inferType(_init, sc);\n-        type = initializerToExpression(_init)->type;\n-\n-        if (needctfe) sc = sc->endCTFE();\n-\n-        inuse--;\n-        inferred = 1;\n-\n-        /* This is a kludge to support the existing syntax for RAII\n-         * declarations.\n-         */\n-        storage_class &= ~STCauto;\n-        originalType = type->syntaxCopy();\n-    }\n-    else\n-    {\n-        if (!originalType)\n-            originalType = type->syntaxCopy();\n-\n-        /* Prefix function attributes of variable declaration can affect\n-         * its type:\n-         *      pure nothrow void function() fp;\n-         *      static assert(is(typeof(fp) == void function() pure nothrow));\n-         */\n-        Scope *sc2 = sc->push();\n-        sc2->stc |= (storage_class & STC_FUNCATTR);\n-        inuse++;\n-        type = type->semantic(loc, sc2);\n-        inuse--;\n-        sc2->pop();\n-    }\n-    //printf(\" semantic type = %s\\n\", type ? type->toChars() : \"null\");\n-    if (type->ty == Terror)\n-        errors = true;\n-\n-    type->checkDeprecated(loc, sc);\n-    linkage = sc->linkage;\n-    this->parent = sc->parent;\n-    //printf(\"this = %p, parent = %p, '%s'\\n\", this, parent, parent->toChars());\n-    protection = sc->protection;\n-\n-    /* If scope's alignment is the default, use the type's alignment,\n-     * otherwise the scope overrrides.\n-     */\n-    alignment = sc->alignment();\n-    if (alignment == STRUCTALIGN_DEFAULT)\n-        alignment = type->alignment();          // use type's alignment\n-\n-    //printf(\"sc->stc = %x\\n\", sc->stc);\n-    //printf(\"storage_class = x%x\\n\", storage_class);\n-\n-    if (global.params.vcomplex)\n-        type->checkComplexTransition(loc);\n-\n-    // Calculate type size + safety checks\n-    if (sc->func && !sc->intypeof)\n-    {\n-        if ((storage_class & STCgshared) && !isMember())\n-        {\n-            if (sc->func->setUnsafe())\n-                error(\"__gshared not allowed in safe functions; use shared\");\n-        }\n-    }\n-\n-    Dsymbol *parent = toParent();\n-\n-    Type *tb = type->toBasetype();\n-    Type *tbn = tb->baseElemOf();\n-    if (tb->ty == Tvoid && !(storage_class & STClazy))\n-    {\n-        if (inferred)\n-        {\n-            error(\"type %s is inferred from initializer %s, and variables cannot be of type void\",\n-                type->toChars(), _init->toChars());\n-        }\n-        else\n-            error(\"variables cannot be of type void\");\n-        type = Type::terror;\n-        tb = type;\n-    }\n-    if (tb->ty == Tfunction)\n-    {\n-        error(\"cannot be declared to be a function\");\n-        type = Type::terror;\n-        tb = type;\n-    }\n-    if (tb->ty == Tstruct)\n-    {\n-        TypeStruct *ts = (TypeStruct *)tb;\n-        if (!ts->sym->members)\n-        {\n-            error(\"no definition of struct %s\", ts->toChars());\n-        }\n-    }\n-    if ((storage_class & STCauto) && !inferred)\n-        error(\"storage class 'auto' has no effect if type is not inferred, did you mean 'scope'?\");\n-\n-    if (tb->ty == Ttuple)\n-    {\n-        /* Instead, declare variables for each of the tuple elements\n-         * and add those.\n-         */\n-        TypeTuple *tt = (TypeTuple *)tb;\n-        size_t nelems = Parameter::dim(tt->arguments);\n-        Expression *ie = (_init && !_init->isVoidInitializer()) ? initializerToExpression(_init) : NULL;\n-        if (ie)\n-            ie = ::semantic(ie, sc);\n-\n-        if (nelems > 0 && ie)\n-        {\n-            Expressions *iexps = new Expressions();\n-            iexps->push(ie);\n-\n-            Expressions *exps = new Expressions();\n-\n-            for (size_t pos = 0; pos < iexps->length; pos++)\n-            {\n-            Lexpand1:\n-                Expression *e = (*iexps)[pos];\n-                Parameter *arg = Parameter::getNth(tt->arguments, pos);\n-                arg->type = arg->type->semantic(loc, sc);\n-                //printf(\"[%d] iexps->length = %d, \", pos, iexps->length);\n-                //printf(\"e = (%s %s, %s), \", Token::tochars[e->op], e->toChars(), e->type->toChars());\n-                //printf(\"arg = (%s, %s)\\n\", arg->toChars(), arg->type->toChars());\n-\n-                if (e != ie)\n-                {\n-                if (iexps->length > nelems)\n-                    goto Lnomatch;\n-                if (e->type->implicitConvTo(arg->type))\n-                    continue;\n-                }\n-\n-                if (e->op == TOKtuple)\n-                {\n-                    TupleExp *te = (TupleExp *)e;\n-                    if (iexps->length - 1 + te->exps->length > nelems)\n-                        goto Lnomatch;\n-\n-                    iexps->remove(pos);\n-                    iexps->insert(pos, te->exps);\n-                    (*iexps)[pos] = Expression::combine(te->e0, (*iexps)[pos]);\n-                    goto Lexpand1;\n-                }\n-                else if (isAliasThisTuple(e))\n-                {\n-                    VarDeclaration *v = copyToTemp(0, \"__tup\", e);\n-                    v->semantic(sc);\n-                    VarExp *ve = new VarExp(loc, v);\n-                    ve->type = e->type;\n-\n-                    exps->setDim(1);\n-                    (*exps)[0] = ve;\n-                    expandAliasThisTuples(exps, 0);\n-\n-                    for (size_t u = 0; u < exps->length ; u++)\n-                    {\n-                    Lexpand2:\n-                        Expression *ee = (*exps)[u];\n-                        arg = Parameter::getNth(tt->arguments, pos + u);\n-                        arg->type = arg->type->semantic(loc, sc);\n-                        //printf(\"[%d+%d] exps->length = %d, \", pos, u, exps->length);\n-                        //printf(\"ee = (%s %s, %s), \", Token::tochars[ee->op], ee->toChars(), ee->type->toChars());\n-                        //printf(\"arg = (%s, %s)\\n\", arg->toChars(), arg->type->toChars());\n-\n-                        size_t iexps_dim = iexps->length - 1 + exps->length;\n-                        if (iexps_dim > nelems)\n-                            goto Lnomatch;\n-                        if (ee->type->implicitConvTo(arg->type))\n-                            continue;\n-\n-                        if (expandAliasThisTuples(exps, u) != -1)\n-                            goto Lexpand2;\n-                    }\n-\n-                    if ((*exps)[0] != ve)\n-                    {\n-                        Expression *e0 = (*exps)[0];\n-                        (*exps)[0] = new CommaExp(loc, new DeclarationExp(loc, v), e0);\n-                        (*exps)[0]->type = e0->type;\n-\n-                        iexps->remove(pos);\n-                        iexps->insert(pos, exps);\n-                        goto Lexpand1;\n-                    }\n-                }\n-            }\n-            if (iexps->length < nelems)\n-                goto Lnomatch;\n-\n-            ie = new TupleExp(_init->loc, iexps);\n-        }\n-Lnomatch:\n-\n-        if (ie && ie->op == TOKtuple)\n-        {\n-            TupleExp *te = (TupleExp *)ie;\n-            size_t tedim = te->exps->length;\n-            if (tedim != nelems)\n-            {\n-                ::error(loc, \"tuple of %d elements cannot be assigned to tuple of %d elements\", (int)tedim, (int)nelems);\n-                for (size_t u = tedim; u < nelems; u++) // fill dummy expression\n-                    te->exps->push(new ErrorExp());\n-            }\n-        }\n-\n-        Objects *exps = new Objects();\n-        exps->setDim(nelems);\n-        for (size_t i = 0; i < nelems; i++)\n-        {\n-            Parameter *arg = Parameter::getNth(tt->arguments, i);\n-\n-            OutBuffer buf;\n-            buf.printf(\"__%s_field_%llu\", ident->toChars(), (ulonglong)i);\n-            const char *name = buf.extractChars();\n-            Identifier *id = Identifier::idPool(name);\n-\n-            Initializer *ti;\n-            if (ie)\n-            {\n-                Expression *einit = ie;\n-                if (ie->op == TOKtuple)\n-                {\n-                    TupleExp *te = (TupleExp *)ie;\n-                    einit = (*te->exps)[i];\n-                    if (i == 0)\n-                        einit = Expression::combine(te->e0, einit);\n-                }\n-                ti = new ExpInitializer(einit->loc, einit);\n-            }\n-            else\n-                ti = _init ? _init->syntaxCopy() : NULL;\n-\n-            VarDeclaration *v = new VarDeclaration(loc, arg->type, id, ti);\n-            v->storage_class |= STCtemp | storage_class;\n-            if (arg->storageClass & STCparameter)\n-                v->storage_class |= arg->storageClass;\n-            //printf(\"declaring field %s of type %s\\n\", v->toChars(), v->type->toChars());\n-            v->semantic(sc);\n-\n-            if (sc->scopesym)\n-            {\n-                //printf(\"adding %s to %s\\n\", v->toChars(), sc->scopesym->toChars());\n-                if (sc->scopesym->members)\n-                    sc->scopesym->members->push(v);\n-            }\n-\n-            Expression *e = new DsymbolExp(loc, v);\n-            (*exps)[i] = e;\n-        }\n-        TupleDeclaration *v2 = new TupleDeclaration(loc, ident, exps);\n-        v2->parent = this->parent;\n-        v2->isexp = true;\n-        aliassym = v2;\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-\n-    /* Storage class can modify the type\n-     */\n-    type = type->addStorageClass(storage_class);\n-\n-    /* Adjust storage class to reflect type\n-     */\n-    if (type->isConst())\n-    {\n-        storage_class |= STCconst;\n-        if (type->isShared())\n-            storage_class |= STCshared;\n-    }\n-    else if (type->isImmutable())\n-        storage_class |= STCimmutable;\n-    else if (type->isShared())\n-        storage_class |= STCshared;\n-    else if (type->isWild())\n-        storage_class |= STCwild;\n-\n-    if (StorageClass stc = storage_class & (STCsynchronized | STCoverride | STCabstract | STCfinal))\n-    {\n-        if (stc == STCfinal)\n-            error(\"cannot be final, perhaps you meant const?\");\n-        else\n-        {\n-            OutBuffer buf;\n-            stcToBuffer(&buf, stc);\n-            error(\"cannot be %s\", buf.peekChars());\n-        }\n-        storage_class &= ~stc;  // strip off\n-    }\n-\n-    if (storage_class & STCscope)\n-    {\n-        StorageClass stc = storage_class & (STCstatic | STCextern | STCmanifest | STCtls | STCgshared);\n-        if (stc)\n-        {\n-            OutBuffer buf;\n-            stcToBuffer(&buf, stc);\n-            error(\"cannot be 'scope' and '%s'\", buf.peekChars());\n-        }\n-        else if (isMember())\n-        {\n-            error(\"field cannot be 'scope'\");\n-        }\n-        else if (!type->hasPointers())\n-        {\n-            storage_class &= ~STCscope;     // silently ignore; may occur in generic code\n-        }\n-    }\n-\n-    if (storage_class & (STCstatic | STCextern | STCmanifest | STCtemplateparameter | STCtls | STCgshared | STCctfe))\n-    {\n-    }\n-    else\n-    {\n-        AggregateDeclaration *aad = parent->isAggregateDeclaration();\n-        if (aad)\n-        {\n-            if (global.params.vfield &&\n-                storage_class & (STCconst | STCimmutable) && _init && !_init->isVoidInitializer())\n-            {\n-                const char *s = (storage_class & STCimmutable) ? \"immutable\" : \"const\";\n-                message(loc, \"`%s.%s` is `%s` field\", ad->toPrettyChars(), toChars(), s);\n-            }\n-            storage_class |= STCfield;\n-            if (tbn->ty == Tstruct && ((TypeStruct *)tbn)->sym->noDefaultCtor)\n-            {\n-                if (!isThisDeclaration() && !_init)\n-                    aad->noDefaultCtor = true;\n-            }\n-        }\n-\n-        InterfaceDeclaration *id = parent->isInterfaceDeclaration();\n-        if (id)\n-        {\n-            error(\"field not allowed in interface\");\n-        }\n-        else if (aad && aad->sizeok == SIZEOKdone)\n-        {\n-            error(\"cannot be further field because it will change the determined %s size\", aad->toChars());\n-        }\n-\n-        /* Templates cannot add fields to aggregates\n-         */\n-        TemplateInstance *ti = parent->isTemplateInstance();\n-        if (ti)\n-        {\n-            // Take care of nested templates\n-            while (1)\n-            {\n-                TemplateInstance *ti2 = ti->tempdecl->parent->isTemplateInstance();\n-                if (!ti2)\n-                    break;\n-                ti = ti2;\n-            }\n-\n-            // If it's a member template\n-            AggregateDeclaration *ad2 = ti->tempdecl->isMember();\n-            if (ad2 && storage_class != STCundefined)\n-            {\n-                error(\"cannot use template to add field to aggregate '%s'\", ad2->toChars());\n-            }\n-        }\n-    }\n-\n-    if ((storage_class & (STCref | STCparameter | STCforeach | STCtemp | STCresult)) == STCref && ident != Id::This)\n-    {\n-        error(\"only parameters or foreach declarations can be ref\");\n-    }\n-\n-    if (type->hasWild())\n-    {\n-        if (storage_class & (STCstatic | STCextern | STCtls | STCgshared | STCmanifest | STCfield) ||\n-            isDataseg()\n-            )\n-        {\n-            error(\"only parameters or stack based variables can be inout\");\n-        }\n-        FuncDeclaration *func = sc->func;\n-        if (func)\n-        {\n-            if (func->fes)\n-                func = func->fes->func;\n-            bool isWild = false;\n-            for (FuncDeclaration *fd = func; fd; fd = fd->toParent2()->isFuncDeclaration())\n-            {\n-                if (((TypeFunction *)fd->type)->iswild)\n-                {\n-                    isWild = true;\n-                    break;\n-                }\n-            }\n-            if (!isWild)\n-            {\n-                error(\"inout variables can only be declared inside inout functions\");\n-            }\n-        }\n-    }\n-\n-    if (!(storage_class & (STCctfe | STCref | STCresult)) && tbn->ty == Tstruct &&\n-        ((TypeStruct *)tbn)->sym->noDefaultCtor)\n-    {\n-        if (!_init)\n-        {\n-            if (isField())\n-            {\n-                /* For fields, we'll check the constructor later to make sure it is initialized\n-                 */\n-                storage_class |= STCnodefaultctor;\n-            }\n-            else if (storage_class & STCparameter)\n-                ;\n-            else\n-                error(\"default construction is disabled for type %s\", type->toChars());\n-        }\n-    }\n-\n-    FuncDeclaration *fd = parent->isFuncDeclaration();\n-    if (type->isscope() && !(storage_class & STCnodtor))\n-    {\n-        if (storage_class & (STCfield | STCout | STCref | STCstatic | STCmanifest | STCtls | STCgshared) || !fd)\n-        {\n-            error(\"globals, statics, fields, manifest constants, ref and out parameters cannot be scope\");\n-        }\n-\n-        if (!(storage_class & STCscope))\n-        {\n-            if (!(storage_class & STCparameter) && ident != Id::withSym)\n-                error(\"reference to scope class must be scope\");\n-        }\n-    }\n-\n-    // Calculate type size + safety checks\n-    if (sc->func && !sc->intypeof)\n-    {\n-        if (_init && _init->isVoidInitializer() && type->hasPointers()) // get type size\n-        {\n-            if (sc->func->setUnsafe())\n-                error(\"void initializers for pointers not allowed in safe functions\");\n-        }\n-        else if (!_init &&\n-                 !(storage_class & (STCstatic | STCextern | STCtls | STCgshared | STCmanifest | STCfield | STCparameter)) &&\n-                 type->hasVoidInitPointers())\n-        {\n-            if (sc->func->setUnsafe())\n-                error(\"void initializers for pointers not allowed in safe functions\");\n-        }\n-    }\n-\n-    if (!_init && !fd)\n-    {\n-        // If not mutable, initializable by constructor only\n-        storage_class |= STCctorinit;\n-    }\n-\n-    if (_init)\n-        storage_class |= STCinit;     // remember we had an explicit initializer\n-    else if (storage_class & STCmanifest)\n-        error(\"manifest constants must have initializers\");\n-\n-    bool isBlit = false;\n-    d_uns64 sz = 0;\n-    if (!_init && !sc->inunion && !(storage_class & (STCstatic | STCgshared | STCextern)) && fd &&\n-        (!(storage_class & (STCfield | STCin | STCforeach | STCparameter | STCresult))\n-         || (storage_class & STCout)) &&\n-        (sz = type->size()) != 0)\n-    {\n-        // Provide a default initializer\n-        //printf(\"Providing default initializer for '%s'\\n\", toChars());\n-        if (sz == SIZE_INVALID && type->ty != Terror)\n-            error(\"size of type %s is invalid\", type->toChars());\n-\n-        Type *tv = type;\n-        while (tv->ty == Tsarray)    // Don't skip Tenum\n-            tv = tv->nextOf();\n-        if (tv->needsNested())\n-        {\n-            /* Nested struct requires valid enclosing frame pointer.\n-             * In StructLiteralExp::toElem(), it's calculated.\n-             */\n-            assert(tv->toBasetype()->ty == Tstruct);\n-            checkFrameAccess(loc, sc, ((TypeStruct *)tbn)->sym);\n-\n-            Expression *e = tv->defaultInitLiteral(loc);\n-            e = new BlitExp(loc, new VarExp(loc, this), e);\n-            e = ::semantic(e, sc);\n-            _init = new ExpInitializer(loc, e);\n-            goto Ldtor;\n-        }\n-        if (tv->ty == Tstruct && ((TypeStruct *)tv)->sym->zeroInit == 1)\n-        {\n-            /* If a struct is all zeros, as a special case\n-             * set it's initializer to the integer 0.\n-             * In AssignExp::toElem(), we check for this and issue\n-             * a memset() to initialize the struct.\n-             * Must do same check in interpreter.\n-             */\n-            Expression *e = new IntegerExp(loc, 0, Type::tint32);\n-            e = new BlitExp(loc, new VarExp(loc, this), e);\n-            e->type = type;         // don't type check this, it would fail\n-            _init = new ExpInitializer(loc, e);\n-            goto Ldtor;\n-        }\n-        if (type->baseElemOf()->ty == Tvoid)\n-        {\n-            error(\"%s does not have a default initializer\", type->toChars());\n-        }\n-        else if (Expression *e = type->defaultInit(loc))\n-        {\n-            _init = new ExpInitializer(loc, e);\n-        }\n-        // Default initializer is always a blit\n-        isBlit = true;\n-    }\n-\n-    if (_init)\n-    {\n-        sc = sc->push();\n-        sc->stc &= ~(STC_TYPECTOR | STCpure | STCnothrow | STCnogc | STCref | STCdisable);\n-\n-        ExpInitializer *ei = _init->isExpInitializer();\n-        if (ei)     // Bugzilla 13424: Preset the required type to fail in FuncLiteralDeclaration::semantic3\n-            ei->exp = inferType(ei->exp, type);\n-\n-        // If inside function, there is no semantic3() call\n-        if (sc->func || sc->intypeof == 1)\n-        {\n-            // If local variable, use AssignExp to handle all the various\n-            // possibilities.\n-            if (fd &&\n-                !(storage_class & (STCmanifest | STCstatic | STCtls | STCgshared | STCextern)) &&\n-                !_init->isVoidInitializer())\n-            {\n-                //printf(\"fd = '%s', var = '%s'\\n\", fd->toChars(), toChars());\n-                if (!ei)\n-                {\n-                    ArrayInitializer *ai = _init->isArrayInitializer();\n-                    Expression *e;\n-                    if (ai && tb->ty == Taarray)\n-                        e = ai->toAssocArrayLiteral();\n-                    else\n-                        e = initializerToExpression(_init);\n-                    if (!e)\n-                    {\n-                        // Run semantic, but don't need to interpret\n-                        _init = ::semantic(_init, sc, type, INITnointerpret);\n-                        e = initializerToExpression(_init);\n-                        if (!e)\n-                        {\n-                            error(\"is not a static and cannot have static initializer\");\n-                            e = new ErrorExp();\n-                        }\n-                    }\n-                    ei = new ExpInitializer(_init->loc, e);\n-                    _init = ei;\n-                }\n-\n-                Expression *exp = ei->exp;\n-                Expression *e1 = new VarExp(loc, this);\n-                if (isBlit)\n-                    exp = new BlitExp(loc, e1, exp);\n-                else\n-                    exp = new ConstructExp(loc, e1, exp);\n-                canassign++;\n-                exp = ::semantic(exp, sc);\n-                canassign--;\n-                exp = exp->optimize(WANTvalue);\n-\n-                if (exp->op == TOKerror)\n-                {\n-                    _init = new ErrorInitializer();\n-                    ei = NULL;\n-                }\n-                else\n-                    ei->exp = exp;\n-\n-                if (ei && isScope())\n-                {\n-                    Expression *ex = ei->exp;\n-                    while (ex->op == TOKcomma)\n-                        ex = ((CommaExp *)ex)->e2;\n-                    if (ex->op == TOKblit || ex->op == TOKconstruct)\n-                        ex = ((AssignExp *)ex)->e2;\n-                    if (ex->op == TOKnew)\n-                    {\n-                        // See if initializer is a NewExp that can be allocated on the stack\n-                        NewExp *ne = (NewExp *)ex;\n-                        if (type->toBasetype()->ty == Tclass)\n-                        {\n-                            if (ne->newargs && ne->newargs->length > 1)\n-                            {\n-                                mynew = true;\n-                            }\n-                            else\n-                            {\n-                                ne->onstack = true;\n-                                onstack = true;\n-                            }\n-                        }\n-                    }\n-                    else if (ex->op == TOKfunction)\n-                    {\n-                        // or a delegate that doesn't escape a reference to the function\n-                        FuncDeclaration *f = ((FuncExp *)ex)->fd;\n-                        f->tookAddressOf--;\n-                    }\n-                }\n-            }\n-            else\n-            {\n-                // Bugzilla 14166: Don't run CTFE for the temporary variables inside typeof\n-                _init = ::semantic(_init, sc, type, sc->intypeof == 1 ? INITnointerpret : INITinterpret);\n-            }\n-        }\n-        else if (parent->isAggregateDeclaration())\n-        {\n-            _scope = scx ? scx : sc->copy();\n-            _scope->setNoFree();\n-        }\n-        else if (storage_class & (STCconst | STCimmutable | STCmanifest) ||\n-                 type->isConst() || type->isImmutable())\n-        {\n-            /* Because we may need the results of a const declaration in a\n-             * subsequent type, such as an array dimension, before semantic2()\n-             * gets ordinarily run, try to run semantic2() now.\n-             * Ignore failure.\n-             */\n-\n-            if (!inferred)\n-            {\n-                unsigned errors = global.errors;\n-                inuse++;\n-                if (ei)\n-                {\n-                    Expression *exp = ei->exp->syntaxCopy();\n-\n-                    bool needctfe = isDataseg() || (storage_class & STCmanifest);\n-                    if (needctfe) sc = sc->startCTFE();\n-                    exp = ::semantic(exp, sc);\n-                    exp = resolveProperties(sc, exp);\n-                    if (needctfe) sc = sc->endCTFE();\n-\n-                    Type *tb2 = type->toBasetype();\n-                    Type *ti = exp->type->toBasetype();\n-\n-                    /* The problem is the following code:\n-                     *  struct CopyTest {\n-                     *     double x;\n-                     *     this(double a) { x = a * 10.0;}\n-                     *     this(this) { x += 2.0; }\n-                     *  }\n-                     *  const CopyTest z = CopyTest(5.3);  // ok\n-                     *  const CopyTest w = z;              // not ok, postblit not run\n-                     *  static assert(w.x == 55.0);\n-                     * because the postblit doesn't get run on the initialization of w.\n-                     */\n-                    if (ti->ty == Tstruct)\n-                    {\n-                        StructDeclaration *sd = ((TypeStruct *)ti)->sym;\n-                        /* Look to see if initializer involves a copy constructor\n-                         * (which implies a postblit)\n-                         */\n-                         // there is a copy constructor\n-                         // and exp is the same struct\n-                        if (sd->postblit &&\n-                            tb2->toDsymbol(NULL) == sd)\n-                        {\n-                            // The only allowable initializer is a (non-copy) constructor\n-                            if (exp->isLvalue())\n-                                error(\"of type struct %s uses this(this), which is not allowed in static initialization\", tb2->toChars());\n-                        }\n-                    }\n-                    ei->exp = exp;\n-                }\n-                _init = ::semantic(_init, sc, type, INITinterpret);\n-                inuse--;\n-                if (global.errors > errors)\n-                {\n-                    _init = new ErrorInitializer();\n-                    type = Type::terror;\n-                }\n-            }\n-            else\n-            {\n-                _scope = scx ? scx : sc->copy();\n-                _scope->setNoFree();\n-            }\n-        }\n-        sc = sc->pop();\n-    }\n-\n-Ldtor:\n-    /* Build code to execute destruction, if necessary\n-     */\n-    edtor = callScopeDtor(sc);\n-    if (edtor)\n-    {\n-        if (sc->func && storage_class & (STCstatic | STCgshared))\n-            edtor = ::semantic(edtor, sc->_module->_scope);\n-        else\n-            edtor = ::semantic(edtor, sc);\n-\n-#if 0 // currently disabled because of std.stdio.stdin, stdout and stderr\n-        if (isDataseg() && !(storage_class & STCextern))\n-            error(\"static storage variables cannot have destructors\");\n-#endif\n-    }\n-\n-    semanticRun = PASSsemanticdone;\n-\n-    if (type->toBasetype()->ty == Terror)\n-        errors = true;\n-\n-    if (sc->scopesym && !sc->scopesym->isAggregateDeclaration())\n-    {\n-        for (ScopeDsymbol *sym = sc->scopesym; sym && endlinnum == 0;\n-             sym = sym->parent ? sym->parent->isScopeDsymbol() : NULL)\n-            endlinnum = sym->endlinnum;\n-    }\n-}\n-\n-void VarDeclaration::semantic2(Scope *sc)\n-{\n-    if (semanticRun < PASSsemanticdone && inuse)\n-        return;\n-\n-    //printf(\"VarDeclaration::semantic2('%s')\\n\", toChars());\n-\n-    if (_init && !toParent()->isFuncDeclaration())\n-    {\n-        inuse++;\n-        // Bugzilla 14166: Don't run CTFE for the temporary variables inside typeof\n-        _init = ::semantic(_init, sc, type, sc->intypeof == 1 ? INITnointerpret : INITinterpret);\n-        inuse--;\n-    }\n-    if (_init && storage_class & STCmanifest)\n-    {\n-        /* Cannot initializer enums with CTFE classreferences and addresses of struct literals.\n-         * Scan initializer looking for them. Issue error if found.\n-         */\n-        if (ExpInitializer *ei = _init->isExpInitializer())\n-        {\n-            struct EnumInitializer\n-            {\n-                static bool arrayHasInvalidEnumInitializer(Expressions *elems)\n-                {\n-                    for (size_t i = 0; i < elems->length; i++)\n-                    {\n-                        Expression *e = (*elems)[i];\n-                        if (e && hasInvalidEnumInitializer(e))\n-                            return true;\n-                    }\n-                    return false;\n-                }\n-\n-                static bool hasInvalidEnumInitializer(Expression *e)\n-                {\n-                    if (e->op == TOKclassreference)\n-                        return true;\n-                    if (e->op == TOKaddress && ((AddrExp *)e)->e1->op == TOKstructliteral)\n-                        return true;\n-                    if (e->op == TOKarrayliteral)\n-                        return arrayHasInvalidEnumInitializer(((ArrayLiteralExp *)e)->elements);\n-                    if (e->op == TOKstructliteral)\n-                        return arrayHasInvalidEnumInitializer(((StructLiteralExp *)e)->elements);\n-                    if (e->op == TOKassocarrayliteral)\n-                    {\n-                        AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)e;\n-                        return arrayHasInvalidEnumInitializer(ae->values) ||\n-                            arrayHasInvalidEnumInitializer(ae->keys);\n-                    }\n-                    return false;\n-                }\n-            };\n-            if (EnumInitializer::hasInvalidEnumInitializer(ei->exp))\n-                error(\": Unable to initialize enum with class or pointer to struct. Use static const variable instead.\");\n-        }\n-    }\n-    else if (_init && isThreadlocal())\n-    {\n-        if ((type->ty == Tclass) && type->isMutable() && !type->isShared())\n-        {\n-            ExpInitializer *ei = _init->isExpInitializer();\n-            if (ei && ei->exp->op == TOKclassreference)\n-                error(\"is mutable. Only const or immutable class thread local variable are allowed, not %s\", type->toChars());\n-        }\n-        else if (type->ty == Tpointer && type->nextOf()->ty == Tstruct && type->nextOf()->isMutable() &&!type->nextOf()->isShared())\n-        {\n-            ExpInitializer *ei = _init->isExpInitializer();\n-            if (ei && ei->exp->op == TOKaddress && ((AddrExp *)ei->exp)->e1->op == TOKstructliteral)\n-            {\n-                error(\"is a pointer to mutable struct. Only pointers to const, immutable or shared struct thread local variable are allowed, not %s\", type->toChars());\n-            }\n-        }\n-    }\n-    semanticRun = PASSsemantic2done;\n-}\n-\n void VarDeclaration::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion)\n {\n     //printf(\"VarDeclaration::setFieldOffset(ad = %s) %s\\n\", ad->toChars(), toChars());\n@@ -1863,7 +838,7 @@ Dsymbol *VarDeclaration::toAlias()\n {\n     //printf(\"VarDeclaration::toAlias('%s', this = %p, aliassym = %p)\\n\", toChars(), this, aliassym);\n     if ((!type || !type->deco) && _scope)\n-        semantic(_scope);\n+        dsymbolSemantic(this, _scope);\n \n     assert(this != aliassym);\n     Dsymbol *s = aliassym ? aliassym->toAlias() : this;\n@@ -2035,7 +1010,7 @@ Expression *VarDeclaration::getConstInitializer(bool needFullType)\n     if (_scope)\n     {\n         inuse++;\n-        _init = ::semantic(_init, _scope, type, INITinterpret);\n+        _init = initializerSemantic(_init, _scope, type, INITinterpret);\n         _scope = NULL;\n         inuse--;\n     }\n@@ -2300,11 +1275,6 @@ Dsymbol *TypeInfoDeclaration::syntaxCopy(Dsymbol *)\n     return NULL;\n }\n \n-void TypeInfoDeclaration::semantic(Scope *)\n-{\n-    assert(linkage == LINKc);\n-}\n-\n const char *TypeInfoDeclaration::toChars()\n {\n     //printf(\"TypeInfoDeclaration::toChars() tinfo = %s\\n\", tinfo->toChars());"}, {"sha": "81b563f4b0fe79f3016ed9d506d5dedd498a6abd", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -30,6 +30,7 @@ struct Ensure\n     Ensure syntaxCopy();\n     static Ensures *arraySyntaxCopy(Ensures *a);\n };\n+class AliasDeclaration;\n class FuncDeclaration;\n class ExpInitializer;\n class StructDeclaration;\n@@ -119,6 +120,7 @@ struct Match\n \n void functionResolve(Match *m, Dsymbol *fd, Loc loc, Scope *sc, Objects *tiargs, Type *tthis, Expressions *fargs);\n int overloadApply(Dsymbol *fstart, void *param, int (*fp)(void *, Dsymbol *));\n+void aliasSemantic(AliasDeclaration *ds, Scope *sc);\n \n void ObjectNotFound(Identifier *id);\n \n@@ -136,7 +138,6 @@ class Declaration : public Dsymbol\n     DString mangleOverride;     // overridden symbol with pragma(mangle, \"...\")\n \n     Declaration(Identifier *id);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     d_uns64 size(Loc loc);\n     bool checkDisabled(Loc loc, Scope *sc, bool isAliasedDeclaration = false);\n@@ -211,8 +212,6 @@ class AliasDeclaration : public Declaration\n     AliasDeclaration(Loc loc, Identifier *ident, Dsymbol *s);\n     static AliasDeclaration *create(Loc loc, Identifier *id, Type *type);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n-    void aliasSemantic(Scope *sc);\n     bool overloadInsert(Dsymbol *s);\n     const char *kind() const;\n     Type *getType();\n@@ -235,7 +234,6 @@ class OverDeclaration : public Declaration\n \n     OverDeclaration(Identifier *ident, Dsymbol *s, bool hasOverloads = true);\n     const char *kind() const;\n-    void semantic(Scope *sc);\n     bool equals(RootObject *o);\n     bool overloadInsert(Dsymbol *s);\n \n@@ -279,9 +277,7 @@ class VarDeclaration : public Declaration\n     VarDeclaration(Loc loc, Type *t, Identifier *id, Initializer *init);\n     static VarDeclaration *create(Loc loc, Type *t, Identifier *id, Initializer *init);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     void setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool isunion);\n-    void semantic2(Scope *sc);\n     const char *kind() const;\n     AggregateDeclaration *isThis();\n     bool needThis();\n@@ -330,7 +326,6 @@ class TypeInfoDeclaration : public VarDeclaration\n     TypeInfoDeclaration(Type *tinfo);\n     static TypeInfoDeclaration *create(Type *tinfo);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     const char *toChars();\n \n     TypeInfoDeclaration *isTypeInfoDeclaration() { return this; }\n@@ -648,9 +643,6 @@ class FuncDeclaration : public Declaration\n     FuncDeclaration(Loc loc, Loc endloc, Identifier *id, StorageClass storage_class, Type *type);\n     static FuncDeclaration *create(Loc loc, Loc endloc, Identifier *id, StorageClass storage_class, Type *type);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n-    void semantic3(Scope *sc);\n     bool functionSemantic();\n     bool functionSemantic3();\n     bool checkForwardRef(Loc loc);\n@@ -710,6 +702,8 @@ class FuncDeclaration : public Declaration\n     bool hasNestedFrameRefs();\n     void buildResultVar(Scope *sc, Type *tret);\n     Statement *mergeFrequire(Statement *);\n+    static bool needsFensure(FuncDeclaration *fd);\n+    void buildEnsureRequire();\n     Statement *mergeFensure(Statement *, Identifier *oid);\n     ParameterList getParameterList();\n \n@@ -776,7 +770,6 @@ class CtorDeclaration : public FuncDeclaration\n public:\n     CtorDeclaration(Loc loc, Loc endloc, StorageClass stc, Type *type);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     const char *toChars();\n     bool isVirtual();\n@@ -792,7 +785,6 @@ class PostBlitDeclaration : public FuncDeclaration\n public:\n     PostBlitDeclaration(Loc loc, Loc endloc, StorageClass stc, Identifier *id);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     bool isVirtual();\n     bool addPreInvariant();\n     bool addPostInvariant();\n@@ -808,7 +800,6 @@ class DtorDeclaration : public FuncDeclaration\n     DtorDeclaration(Loc loc, Loc endloc);\n     DtorDeclaration(Loc loc, Loc endloc, StorageClass stc, Identifier *id);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     const char *toChars();\n     bool isVirtual();\n@@ -826,7 +817,6 @@ class StaticCtorDeclaration : public FuncDeclaration\n     StaticCtorDeclaration(Loc loc, Loc endloc, StorageClass stc);\n     StaticCtorDeclaration(Loc loc, Loc endloc, const char *name, StorageClass stc);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     AggregateDeclaration *isThis();\n     bool isVirtual();\n     bool addPreInvariant();\n@@ -855,7 +845,6 @@ class StaticDtorDeclaration : public FuncDeclaration\n     StaticDtorDeclaration(Loc loc, Loc endloc, StorageClass stc);\n     StaticDtorDeclaration(Loc loc, Loc endloc, const char *name, StorageClass stc);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     AggregateDeclaration *isThis();\n     bool isVirtual();\n     bool hasStaticCtorOrDtor();\n@@ -881,7 +870,6 @@ class InvariantDeclaration : public FuncDeclaration\n public:\n     InvariantDeclaration(Loc loc, Loc endloc, StorageClass stc, Identifier *id = NULL);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     bool isVirtual();\n     bool addPreInvariant();\n     bool addPostInvariant();\n@@ -900,7 +888,6 @@ class UnitTestDeclaration : public FuncDeclaration\n \n     UnitTestDeclaration(Loc loc, Loc endloc, StorageClass stc, char *codedoc);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     AggregateDeclaration *isThis();\n     bool isVirtual();\n     bool addPreInvariant();\n@@ -918,7 +905,6 @@ class NewDeclaration : public FuncDeclaration\n \n     NewDeclaration(Loc loc, Loc endloc, StorageClass stc, Parameters *arguments, VarArg varargs);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     bool isVirtual();\n     bool addPreInvariant();\n@@ -936,7 +922,6 @@ class DeleteDeclaration : public FuncDeclaration\n \n     DeleteDeclaration(Loc loc, Loc endloc, StorageClass stc, Parameters *arguments);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     bool isDelete();\n     bool isVirtual();"}, {"sha": "b3019aae4b8d503745c8d9d0319c456611dab842", "filename": "gcc/d/dmd/delegatize.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdelegatize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdelegatize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdelegatize.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -25,7 +25,6 @@\n bool walkPostorder(Expression *e, StoppableVisitor *v);\n void lambdaSetParent(Expression *e, Scope *sc);\n bool lambdaCheckForNestedRef(Expression *e, Scope *sc);\n-Expression *semantic(Expression *e, Scope *sc);\n \n /********************************************\n  * Convert from expression to delegate that returns the expression,\n@@ -62,7 +61,7 @@ Expression *toDelegate(Expression *e, Type* t, Scope *sc)\n     fld->fbody = s;\n \n     e = new FuncExp(loc, fld);\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     return e;\n }\n "}, {"sha": "ca1d3bb771cb54d21ff015df2f615903a55f4f94", "filename": "gcc/d/dmd/denum.c", "status": "modified", "additions": 9, "deletions": 422, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdenum.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdenum.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -22,8 +22,6 @@\n #include \"declaration.h\"\n #include \"init.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-\n /********************************* EnumDeclaration ****************************/\n \n EnumDeclaration::EnumDeclaration(Loc loc, Identifier *id, Type *memtype)\n@@ -86,190 +84,6 @@ void EnumDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n     added = true;\n }\n \n-\n-void EnumDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"EnumDeclaration::semantic(sd = %p, '%s') %s\\n\", sc->scopesym, sc->scopesym->toChars(), toChars());\n-    //printf(\"EnumDeclaration::semantic() %p %s\\n\", this, toChars());\n-    if (semanticRun >= PASSsemanticdone)\n-        return;             // semantic() already completed\n-    if (semanticRun == PASSsemantic)\n-    {\n-        assert(memtype);\n-        ::error(loc, \"circular reference to enum base type %s\", memtype->toChars());\n-        errors = true;\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-    unsigned dprogress_save = Module::dprogress;\n-\n-    Scope *scx = NULL;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        scx = _scope;            // save so we don't make redundant copies\n-        _scope = NULL;\n-    }\n-\n-    if (!sc)\n-        return;\n-\n-    parent = sc->parent;\n-    type = type->semantic(loc, sc);\n-\n-    protection = sc->protection;\n-    if (sc->stc & STCdeprecated)\n-        isdeprecated = true;\n-    userAttribDecl = sc->userAttribDecl;\n-\n-    semanticRun = PASSsemantic;\n-\n-    if (!members && !memtype)               // enum ident;\n-    {\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-\n-    if (!symtab)\n-        symtab = new DsymbolTable();\n-\n-    /* The separate, and distinct, cases are:\n-     *  1. enum { ... }\n-     *  2. enum : memtype { ... }\n-     *  3. enum ident { ... }\n-     *  4. enum ident : memtype { ... }\n-     *  5. enum ident : memtype;\n-     *  6. enum ident;\n-     */\n-\n-    if (memtype)\n-    {\n-        memtype = memtype->semantic(loc, sc);\n-\n-        /* Check to see if memtype is forward referenced\n-         */\n-        if (memtype->ty == Tenum)\n-        {\n-            EnumDeclaration *sym = (EnumDeclaration *)memtype->toDsymbol(sc);\n-            if (!sym->memtype || !sym->members || !sym->symtab || sym->_scope)\n-            {\n-                // memtype is forward referenced, so try again later\n-                _scope = scx ? scx : sc->copy();\n-                _scope->setNoFree();\n-                _scope->_module->addDeferredSemantic(this);\n-                Module::dprogress = dprogress_save;\n-                //printf(\"\\tdeferring %s\\n\", toChars());\n-                semanticRun = PASSinit;\n-                return;\n-            }\n-        }\n-        if (memtype->ty == Tvoid)\n-        {\n-            error(\"base type must not be void\");\n-            memtype = Type::terror;\n-        }\n-        if (memtype->ty == Terror)\n-        {\n-            errors = true;\n-            if (members)\n-            {\n-                for (size_t i = 0; i < members->length; i++)\n-                {\n-                    Dsymbol *s = (*members)[i];\n-                    s->errors = true;               // poison all the members\n-                }\n-            }\n-            semanticRun = PASSsemanticdone;\n-            return;\n-        }\n-    }\n-\n-    semanticRun = PASSsemanticdone;\n-\n-    if (!members)               // enum ident : memtype;\n-        return;\n-\n-    if (members->length == 0)\n-    {\n-        error(\"enum %s must have at least one member\", toChars());\n-        errors = true;\n-        return;\n-    }\n-\n-    Module::dprogress++;\n-\n-    Scope *sce;\n-    if (isAnonymous())\n-        sce = sc;\n-    else\n-    {\n-        sce = sc->push(this);\n-        sce->parent = this;\n-    }\n-    sce = sce->startCTFE();\n-    sce->setNoFree();                   // needed for getMaxMinValue()\n-\n-    /* Each enum member gets the sce scope\n-     */\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        EnumMember *em = (*members)[i]->isEnumMember();\n-        if (em)\n-            em->_scope = sce;\n-    }\n-\n-    if (!added)\n-    {\n-        /* addMember() is not called when the EnumDeclaration appears as a function statement,\n-         * so we have to do what addMember() does and install the enum members in the right symbol\n-         * table\n-         */\n-        ScopeDsymbol *scopesym = NULL;\n-        if (isAnonymous())\n-        {\n-            /* Anonymous enum members get added to enclosing scope.\n-             */\n-            for (Scope *sct = sce; 1; sct = sct->enclosing)\n-            {\n-                assert(sct);\n-                if (sct->scopesym)\n-                {\n-                    scopesym = sct->scopesym;\n-                    if (!sct->scopesym->symtab)\n-                        sct->scopesym->symtab = new DsymbolTable();\n-                    break;\n-                }\n-            }\n-        }\n-        else\n-        {\n-            // Otherwise enum members are in the EnumDeclaration's symbol table\n-            scopesym = this;\n-        }\n-\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            EnumMember *em = (*members)[i]->isEnumMember();\n-            if (em)\n-            {\n-                em->ed = this;\n-                em->addMember(sc, scopesym);\n-            }\n-        }\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        EnumMember *em = (*members)[i]->isEnumMember();\n-        if (em)\n-            em->semantic(em->_scope);\n-    }\n-    //printf(\"defaultval = %lld\\n\", defaultval);\n-\n-    //if (defaultval) printf(\"defaultval: %s %s\\n\", defaultval->toChars(), defaultval->type->toChars());\n-    //printf(\"members = %s\\n\", members->toChars());\n-}\n-\n /******************************\n  * Get the value of the .max/.min property as an Expression\n  * Input:\n@@ -292,7 +106,7 @@ Expression *EnumDeclaration::getMaxMinValue(Loc loc, Identifier *id)\n         goto Ldone;\n \n     if (_scope)\n-        semantic(_scope);\n+        dsymbolSemantic(this, _scope);\n     if (errors)\n         goto Lerrors;\n     if (semanticRun == PASSinit || !members)\n@@ -343,7 +157,7 @@ Expression *EnumDeclaration::getMaxMinValue(Loc loc, Identifier *id)\n              */\n             Expression *ec = new CmpExp(id == Id::max ? TOKgt : TOKlt, em->loc, e, *pval);\n             inuse++;\n-            ec = ::semantic(ec, em->_scope);\n+            ec = expressionSemantic(ec, em->_scope);\n             inuse--;\n             ec = ec->ctfeInterpret();\n             if (ec->toInteger())\n@@ -387,7 +201,7 @@ Expression *EnumDeclaration::getDefaultValue(Loc loc)\n         return defaultval;\n \n     if (_scope)\n-        semantic(_scope);\n+        dsymbolSemantic(this, _scope);\n     if (errors)\n         goto Lerrors;\n     if (semanticRun == PASSinit || !members)\n@@ -428,7 +242,7 @@ Type *EnumDeclaration::getMemtype(Loc loc)\n          * just the base type\n          */\n         if (memtype)\n-            memtype = memtype->semantic(loc, _scope);\n+            memtype = typeSemantic(memtype, loc, _scope);\n         else\n         {\n             if (!isAnonymous() && members)\n@@ -481,12 +295,12 @@ Dsymbol *EnumDeclaration::search(const Loc &loc, Identifier *ident, int flags)\n     if (_scope)\n     {\n         // Try one last time to resolve this enum\n-        semantic(_scope);\n+        dsymbolSemantic(this, _scope);\n     }\n \n     if (!members || !symtab || _scope)\n     {\n-        error(\"is forward referenced when looking for '%s'\", ident->toChars());\n+        error(\"is forward referenced when looking for `%s`\", ident->toChars());\n         //*(char*)0=0;\n         return NULL;\n     }\n@@ -535,236 +349,9 @@ const char *EnumMember::kind() const\n     return \"enum member\";\n }\n \n-void EnumMember::semantic(Scope *sc)\n-{\n-    //printf(\"EnumMember::semantic() %s\\n\", toChars());\n-    if (errors || semanticRun >= PASSsemanticdone)\n-        return;\n-    if (semanticRun == PASSsemantic)\n-    {\n-        error(\"circular reference to enum member\");\n-    Lerrors:\n-        errors = true;\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-    assert(ed);\n-\n-    ed->semantic(sc);\n-    if (ed->errors)\n-        goto Lerrors;\n-\n-    if (errors || semanticRun >= PASSsemanticdone)\n-        return;\n-\n-    if (_scope)\n-        sc = _scope;\n-    if (!sc)\n-        return;\n-\n-    semanticRun = PASSsemantic;\n-\n-    protection = ed->isAnonymous() ? ed->protection : Prot(Prot::public_);\n-    linkage = LINKd;\n-    storage_class |= STCmanifest;\n-\n-    // https://issues.dlang.org/show_bug.cgi?id=9701\n-    if (ed->isAnonymous())\n-    {\n-        if (userAttribDecl)\n-            userAttribDecl->userAttribDecl = ed->userAttribDecl;\n-        else\n-            userAttribDecl = ed->userAttribDecl;\n-    }\n-\n-    // The first enum member is special\n-    bool first = (this == (*ed->members)[0]);\n-\n-    if (origType)\n-    {\n-        origType = origType->semantic(loc, sc);\n-        type = origType;\n-        assert(value());          // \"type id;\" is not a valid enum member declaration\n-    }\n-\n-    if (value())\n-    {\n-        Expression *e = value();\n-        assert(e->dyncast() == DYNCAST_EXPRESSION);\n-        e = ::semantic(e, sc);\n-        e = resolveProperties(sc, e);\n-        e = e->ctfeInterpret();\n-        if (e->op == TOKerror)\n-            goto Lerrors;\n-        if (first && !ed->memtype && !ed->isAnonymous())\n-        {\n-            ed->memtype = e->type;\n-            if (ed->memtype->ty == Terror)\n-            {\n-                ed->errors = true;\n-                goto Lerrors;\n-            }\n-            if (ed->memtype->ty != Terror)\n-            {\n-                /* Bugzilla 11746: All of named enum members should have same type\n-                 * with the first member. If the following members were referenced\n-                 * during the first member semantic, their types should be unified.\n-                 */\n-                for (size_t i = 0; i < ed->members->length; i++)\n-                {\n-                    EnumMember *em = (*ed->members)[i]->isEnumMember();\n-                    if (!em || em == this || em->semanticRun < PASSsemanticdone || em->origType)\n-                        continue;\n-\n-                    //printf(\"[%d] em = %s, em->semanticRun = %d\\n\", i, toChars(), em->semanticRun);\n-                    Expression *ev = em->value();\n-                    ev = ev->implicitCastTo(sc, ed->memtype);\n-                    ev = ev->ctfeInterpret();\n-                    ev = ev->castTo(sc, ed->type);\n-                    if (ev->op == TOKerror)\n-                        ed->errors = true;\n-                    em->value() = ev;\n-                }\n-                if (ed->errors)\n-                {\n-                    ed->memtype = Type::terror;\n-                    goto Lerrors;\n-                }\n-            }\n-        }\n-\n-        if (ed->memtype && !origType)\n-        {\n-            e = e->implicitCastTo(sc, ed->memtype);\n-            e = e->ctfeInterpret();\n-\n-            // save origValue for better json output\n-            origValue = e;\n-\n-            if (!ed->isAnonymous())\n-            {\n-                e = e->castTo(sc, ed->type);\n-                e = e->ctfeInterpret();\n-            }\n-        }\n-        else if (origType)\n-        {\n-            e = e->implicitCastTo(sc, origType);\n-            e = e->ctfeInterpret();\n-            assert(ed->isAnonymous());\n-\n-            // save origValue for better json output\n-            origValue = e;\n-        }\n-        value() = e;\n-    }\n-    else if (first)\n-    {\n-        Type *t;\n-        if (ed->memtype)\n-            t = ed->memtype;\n-        else\n-        {\n-            t = Type::tint32;\n-            if (!ed->isAnonymous())\n-                ed->memtype = t;\n-        }\n-        Expression *e = new IntegerExp(loc, 0, Type::tint32);\n-        e = e->implicitCastTo(sc, t);\n-        e = e->ctfeInterpret();\n-\n-        // save origValue for better json output\n-        origValue = e;\n-\n-        if (!ed->isAnonymous())\n-        {\n-            e = e->castTo(sc, ed->type);\n-            e = e->ctfeInterpret();\n-        }\n-        value() = e;\n-    }\n-    else\n-    {\n-        /* Find the previous enum member,\n-         * and set this to be the previous value + 1\n-         */\n-        EnumMember *emprev = NULL;\n-        for (size_t i = 0; i < ed->members->length; i++)\n-        {\n-            EnumMember *em = (*ed->members)[i]->isEnumMember();\n-            if (em)\n-            {\n-                if (em == this)\n-                    break;\n-                emprev = em;\n-            }\n-        }\n-        assert(emprev);\n-        if (emprev->semanticRun < PASSsemanticdone)    // if forward reference\n-            emprev->semantic(emprev->_scope);    // resolve it\n-        if (emprev->errors)\n-            goto Lerrors;\n-\n-        Expression *eprev = emprev->value();\n-        Type *tprev = eprev->type->equals(ed->type) ? ed->memtype : eprev->type;\n-\n-        Expression *emax = tprev->getProperty(ed->loc, Id::max, 0);\n-        emax = ::semantic(emax, sc);\n-        emax = emax->ctfeInterpret();\n-\n-        // Set value to (eprev + 1).\n-        // But first check that (eprev != emax)\n-        assert(eprev);\n-        Expression *e = new EqualExp(TOKequal, loc, eprev, emax);\n-        e = ::semantic(e, sc);\n-        e = e->ctfeInterpret();\n-        if (e->toInteger())\n-        {\n-            error(\"initialization with (%s.%s + 1) causes overflow for type '%s'\", emprev->ed->toChars(), emprev->toChars(), ed->type->toBasetype()->toChars());\n-            goto Lerrors;\n-        }\n-\n-        // Now set e to (eprev + 1)\n-        e = new AddExp(loc, eprev, new IntegerExp(loc, 1, Type::tint32));\n-        e = ::semantic(e, sc);\n-        e = e->castTo(sc, eprev->type);\n-        e = e->ctfeInterpret();\n-\n-        // save origValue (without cast) for better json output\n-        if (e->op != TOKerror)  // avoid duplicate diagnostics\n-        {\n-            assert(emprev->origValue);\n-            origValue = new AddExp(loc, emprev->origValue, new IntegerExp(loc, 1, Type::tint32));\n-            origValue = ::semantic(origValue, sc);\n-            origValue = origValue->ctfeInterpret();\n-        }\n-\n-        if (e->op == TOKerror)\n-            goto Lerrors;\n-        if (e->type->isfloating())\n-        {\n-            // Check that e != eprev (not always true for floats)\n-            Expression *etest = new EqualExp(TOKequal, loc, e, eprev);\n-            etest = ::semantic(etest, sc);\n-            etest = etest->ctfeInterpret();\n-            if (etest->toInteger())\n-            {\n-                error(\"has inexact value, due to loss of precision\");\n-                goto Lerrors;\n-            }\n-        }\n-        value() = e;\n-    }\n-    if (!origType)\n-        type = value()->type;\n-\n-    assert(origValue);\n-    semanticRun = PASSsemanticdone;\n-}\n-\n Expression *EnumMember::getVarExp(Loc loc, Scope *sc)\n {\n-    semantic(sc);\n+    dsymbolSemantic(this, sc);\n     if (errors)\n         return new ErrorExp();\n     checkDisabled(loc, sc);\n@@ -776,5 +363,5 @@ Expression *EnumMember::getVarExp(Loc loc, Scope *sc)\n     if (errors)\n         return new ErrorExp();\n     Expression *e = new VarExp(loc, this);\n-    return ::semantic(e, sc);\n+    return expressionSemantic(e, sc);\n }"}, {"sha": "0d93ed80e587f3e621af0925564cd786c500b036", "filename": "gcc/d/dmd/dimport.c", "status": "modified", "additions": 2, "deletions": 207, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdimport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdimport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdimport.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -194,211 +194,6 @@ void Import::importAll(Scope *sc)\n     }\n }\n \n-void Import::semantic(Scope *sc)\n-{\n-    //printf(\"Import::semantic('%s') %s\\n\", toPrettyChars(), id->toChars());\n-    if (semanticRun > PASSinit)\n-        return;\n-\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        _scope = NULL;\n-    }\n-    if (!sc)\n-        return;\n-\n-    semanticRun = PASSsemantic;\n-\n-    // Load if not already done so\n-    if (!mod)\n-    {\n-        load(sc);\n-        if (mod)\n-            mod->importAll(NULL);\n-    }\n-\n-    if (mod)\n-    {\n-        // Modules need a list of each imported module\n-        //printf(\"%s imports %s\\n\", sc->_module->toChars(), mod->toChars());\n-        sc->_module->aimports.push(mod);\n-\n-        if (sc->explicitProtection)\n-            protection = sc->protection;\n-\n-        if (!aliasId && !names.length) // neither a selective nor a renamed import\n-        {\n-            ScopeDsymbol *scopesym = NULL;\n-            if (sc->explicitProtection)\n-                protection = sc->protection.kind;\n-            for (Scope *scd = sc; scd; scd = scd->enclosing)\n-            {\n-                if (!scd->scopesym)\n-                    continue;\n-                scopesym = scd->scopesym;\n-                break;\n-            }\n-\n-            if (!isstatic)\n-            {\n-                scopesym->importScope(mod, protection);\n-            }\n-\n-            // Mark the imported packages as accessible from the current\n-            // scope. This access check is necessary when using FQN b/c\n-            // we're using a single global package tree. See Bugzilla 313.\n-            if (packages)\n-            {\n-                // import a.b.c.d;\n-                Package *p = pkg; // a\n-                scopesym->addAccessiblePackage(p, protection);\n-                for (size_t i = 1; i < packages->length; i++) // [b, c]\n-                {\n-                    Identifier *id = (*packages)[i];\n-                    p = (Package *) p->symtab->lookup(id);\n-                    scopesym->addAccessiblePackage(p, protection);\n-                }\n-            }\n-            scopesym->addAccessiblePackage(mod, protection); // d\n-        }\n-\n-        mod->semantic(NULL);\n-\n-        if (mod->needmoduleinfo)\n-        {\n-            //printf(\"module4 %s because of %s\\n\", sc->_module->toChars(), mod->toChars());\n-            sc->_module->needmoduleinfo = 1;\n-        }\n-\n-        sc = sc->push(mod);\n-        sc->protection = protection;\n-        for (size_t i = 0; i < aliasdecls.length; i++)\n-        {\n-            AliasDeclaration *ad = aliasdecls[i];\n-            //printf(\"\\tImport %s alias %s = %s, scope = %p\\n\", toPrettyChars(), aliases[i]->toChars(), names[i]->toChars(), ad->_scope);\n-            if (mod->search(loc, names[i]))\n-            {\n-                ad->semantic(sc);\n-                // If the import declaration is in non-root module,\n-                // analysis of the aliased symbol is deferred.\n-                // Therefore, don't see the ad->aliassym or ad->type here.\n-            }\n-            else\n-            {\n-                Dsymbol *s = mod->search_correct(names[i]);\n-                if (s)\n-                    mod->error(loc, \"import '%s' not found, did you mean %s '%s'?\", names[i]->toChars(), s->kind(), s->toChars());\n-                else\n-                    mod->error(loc, \"import '%s' not found\", names[i]->toChars());\n-                ad->type = Type::terror;\n-            }\n-        }\n-        sc = sc->pop();\n-    }\n-\n-    semanticRun = PASSsemanticdone;\n-\n-    // object self-imports itself, so skip that (Bugzilla 7547)\n-    // don't list pseudo modules __entrypoint.d, __main.d (Bugzilla 11117, 11164)\n-    if (global.params.moduleDeps != NULL &&\n-        !(id == Id::object && sc->_module->ident == Id::object) &&\n-        sc->_module->ident != Id::entrypoint &&\n-        strcmp(sc->_module->ident->toChars(), \"__main\") != 0)\n-    {\n-        /* The grammar of the file is:\n-         *      ImportDeclaration\n-         *          ::= BasicImportDeclaration [ \" : \" ImportBindList ] [ \" -> \"\n-         *      ModuleAliasIdentifier ] \"\\n\"\n-         *\n-         *      BasicImportDeclaration\n-         *          ::= ModuleFullyQualifiedName \" (\" FilePath \") : \" Protection|\"string\"\n-         *              \" [ \" static\" ] : \" ModuleFullyQualifiedName \" (\" FilePath \")\"\n-         *\n-         *      FilePath\n-         *          - any string with '(', ')' and '\\' escaped with the '\\' character\n-         */\n-\n-        OutBuffer *ob = global.params.moduleDeps;\n-        Module* imod = sc->instantiatingModule();\n-        if (!global.params.moduleDepsFile.length)\n-            ob->writestring(\"depsImport \");\n-        ob->writestring(imod->toPrettyChars());\n-        ob->writestring(\" (\");\n-        escapePath(ob,  imod->srcfile->toChars());\n-        ob->writestring(\") : \");\n-\n-        // use protection instead of sc->protection because it couldn't be\n-        // resolved yet, see the comment above\n-        protectionToBuffer(ob, protection);\n-        ob->writeByte(' ');\n-        if (isstatic)\n-        {\n-            stcToBuffer(ob, STCstatic);\n-            ob->writeByte(' ');\n-        }\n-        ob->writestring(\": \");\n-\n-        if (packages)\n-        {\n-            for (size_t i = 0; i < packages->length; i++)\n-            {\n-                Identifier *pid = (*packages)[i];\n-                ob->printf(\"%s.\", pid->toChars());\n-            }\n-        }\n-\n-        ob->writestring(id->toChars());\n-        ob->writestring(\" (\");\n-        if (mod)\n-            escapePath(ob, mod->srcfile->toChars());\n-        else\n-            ob->writestring(\"???\");\n-        ob->writeByte(')');\n-\n-        for (size_t i = 0; i < names.length; i++)\n-        {\n-            if (i == 0)\n-                ob->writeByte(':');\n-            else\n-                ob->writeByte(',');\n-\n-            Identifier *name = names[i];\n-            Identifier *alias = aliases[i];\n-\n-            if (!alias)\n-            {\n-                ob->printf(\"%s\", name->toChars());\n-                alias = name;\n-            }\n-            else\n-                ob->printf(\"%s=%s\", alias->toChars(), name->toChars());\n-        }\n-\n-        if (aliasId)\n-                ob->printf(\" -> %s\", aliasId->toChars());\n-\n-        ob->writenl();\n-    }\n-\n-    //printf(\"-Import::semantic('%s'), pkg = %p\\n\", toChars(), pkg);\n-}\n-\n-void Import::semantic2(Scope *sc)\n-{\n-    //printf(\"Import::semantic2('%s')\\n\", toChars());\n-    if (mod)\n-    {\n-        mod->semantic2(NULL);\n-        if (mod->needmoduleinfo)\n-        {\n-            //printf(\"module5 %s because of %s\\n\", sc->_module->toChars(), mod->toChars());\n-            if (sc)\n-                sc->_module->needmoduleinfo = 1;\n-        }\n-    }\n-}\n-\n Dsymbol *Import::toAlias()\n {\n     if (aliasId)\n@@ -466,7 +261,7 @@ Dsymbol *Import::search(const Loc &loc, Identifier *ident, int flags)\n     {\n         load(NULL);\n         mod->importAll(NULL);\n-        mod->semantic(NULL);\n+        dsymbolSemantic(mod, NULL);\n     }\n \n     // Forward it to the package/module"}, {"sha": "5e71f3b24a1891b454ccdb349c49d349f6fe9375", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -40,8 +40,6 @@ enum CtfeGoal\n bool walkPostorder(Expression *e, StoppableVisitor *v);\n Expression *interpret(Statement *s, InterState *istate);\n Expression *interpret(Expression *e, InterState *istate, CtfeGoal goal = ctfeNeedRvalue);\n-Expression *semantic(Expression *e, Scope *sc);\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n \n static Expression *interpret(UnionExp *pue, Expression *e, InterState *istate, CtfeGoal goal = ctfeNeedRvalue);\n static Expression *interpret(UnionExp *pue, Statement *s, InterState *istate);\n@@ -778,7 +776,7 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n     {\n         // error, no this. Prevent segfault.\n         // Here should be unreachable by the strict 'this' check in front-end.\n-        fd->error(\"need 'this' to access member %s\", fd->toChars());\n+        fd->error(\"need `this` to access member %s\", fd->toChars());\n         return CTFEExp::cantexp;\n     }\n \n@@ -802,7 +800,7 @@ static Expression *interpretFunction(UnionExp *pue, FuncDeclaration *fd, InterSt\n             if (!istate && (fparam->storageClass & STCout))\n             {\n                 // initializing an out parameter involves writing to it.\n-                earg->error(\"global %s cannot be passed as an 'out' parameter at compile time\", earg->toChars());\n+                earg->error(\"global %s cannot be passed as an `out` parameter at compile time\", earg->toChars());\n                 return CTFEExp::cantexp;\n             }\n             // Convert all reference arguments into lvalue references\n@@ -1861,7 +1859,7 @@ class Interpreter : public Visitor\n                    result->op == TOKclassreference);\n             return;\n         }\n-        e->error(\"value of 'this' is not known at compile time\");\n+        e->error(\"value of `this` is not known at compile time\");\n         result = CTFEExp::cantexp;\n     }\n \n@@ -2085,7 +2083,7 @@ class Interpreter : public Visitor\n \n             if (!v->originalType && v->semanticRun < PASSsemanticdone) // semantic() not yet run\n             {\n-                v->semantic(NULL);\n+                dsymbolSemantic(v, NULL);\n                 if (v->type->ty == Terror)\n                     return CTFEExp::cantexp;\n             }\n@@ -2096,13 +2094,13 @@ class Interpreter : public Visitor\n             {\n                 if (v->inuse)\n                 {\n-                    error(loc, \"circular initialization of %s '%s'\", v->kind(), v->toPrettyChars());\n+                    error(loc, \"circular initialization of %s `%s`\", v->kind(), v->toPrettyChars());\n                     return CTFEExp::cantexp;\n                 }\n                 if (v->_scope)\n                 {\n                     v->inuse++;\n-                    v->_init = ::semantic(v->_init, v->_scope, v->type, INITinterpret); // might not be run on aggregate members\n+                    v->_init = initializerSemantic(v->_init, v->_scope, v->type, INITinterpret); // might not be run on aggregate members\n                     v->inuse--;\n                 }\n                 e = initializerToExpression(v->_init, v->type);\n@@ -2196,7 +2194,7 @@ class Interpreter : public Visitor\n             e = s->dsym->type->defaultInitLiteral(loc);\n             if (e->op == TOKerror)\n                 error(loc, \"CTFE failed because of previous errors in %s.init\", s->toChars());\n-            e = ::semantic(e, NULL);\n+            e = expressionSemantic(e, NULL);\n             if (e->op == TOKerror)\n                 e = CTFEExp::cantexp;\n             else // Convert NULL to CTFEExp\n@@ -2394,7 +2392,7 @@ class Interpreter : public Visitor\n \n             if (result->op == TOKnull)\n             {\n-                e->error(\"null pointer dereference evaluating typeid. '%s' is null\", ex->toChars());\n+                e->error(\"null pointer dereference evaluating typeid. `%s` is null\", ex->toChars());\n                 result = CTFEExp::cantexp;\n                 return;\n             }\n@@ -2823,7 +2821,7 @@ class Interpreter : public Visitor\n                     VarDeclaration *v = c->fields[i];\n                     if (v->inuse)\n                     {\n-                        e->error(\"circular reference to '%s'\", v->toPrettyChars());\n+                        e->error(\"circular reference to `%s`\", v->toPrettyChars());\n                         result = CTFEExp::cantexp;\n                         return;\n                     }\n@@ -5478,7 +5476,7 @@ class Interpreter : public Visitor\n         {\n             if (result->op != TOKclassreference)\n             {\n-                e->error(\"delete on invalid class reference '%s'\", result->toChars());\n+                e->error(\"delete on invalid class reference `%s`\", result->toChars());\n                 result = CTFEExp::cantexp;\n                 return;\n             }\n@@ -5509,7 +5507,7 @@ class Interpreter : public Visitor\n                 if (result->op != TOKaddress ||\n                     ((AddrExp *)result)->e1->op != TOKstructliteral)\n                 {\n-                    e->error(\"delete on invalid struct pointer '%s'\", result->toChars());\n+                    e->error(\"delete on invalid struct pointer `%s`\", result->toChars());\n                     result = CTFEExp::cantexp;\n                     return;\n                 }\n@@ -5540,7 +5538,7 @@ class Interpreter : public Visitor\n             {\n                 if (result->op != TOKarrayliteral)\n                 {\n-                    e->error(\"delete on invalid struct array '%s'\", result->toChars());\n+                    e->error(\"delete on invalid struct array `%s`\", result->toChars());\n                     result = CTFEExp::cantexp;\n                     return;\n                 }\n@@ -5899,9 +5897,9 @@ class Interpreter : public Visitor\n         if (result->op != TOKaddress)\n         {\n             if (result->op == TOKnull)\n-                e->error(\"dereference of null pointer '%s'\", e->e1->toChars());\n+                e->error(\"dereference of null pointer `%s`\", e->e1->toChars());\n             else\n-                e->error(\"dereference of invalid pointer '%s'\", result->toChars());\n+                e->error(\"dereference of invalid pointer `%s`\", result->toChars());\n             result = CTFEExp::cantexp;\n             return;\n         }\n@@ -5952,9 +5950,9 @@ class Interpreter : public Visitor\n         if (ex->op == TOKnull)\n         {\n             if (ex->type->toBasetype()->ty == Tclass)\n-                e->error(\"class '%s' is null and cannot be dereferenced\", e->e1->toChars());\n+                e->error(\"class `%s` is null and cannot be dereferenced\", e->e1->toChars());\n             else\n-                e->error(\"CTFE internal error: null this '%s'\", e->e1->toChars());\n+                e->error(\"CTFE internal error: null this `%s`\", e->e1->toChars());\n             result = CTFEExp::cantexp;\n             return;\n         }\n@@ -6181,7 +6179,7 @@ Expression *scrubReturnValue(Loc loc, Expression *e)\n     }\n     else if (e->op == TOKvoid)\n     {\n-        error(loc, \"uninitialized variable '%s' cannot be returned from CTFE\", ((VoidInitExp *)e)->var->toChars());\n+        error(loc, \"uninitialized variable `%s` cannot be returned from CTFE\", ((VoidInitExp *)e)->var->toChars());\n         return new ErrorExp();\n     }\n "}, {"sha": "91cbe50713ce6bd2174e3755cdbe974475416ea3", "filename": "gcc/d/dmd/dmacro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "303ae617874013593bbe3b5ff0abd5a704fc5c6f", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "a2b01f534eb593558e794e91ced6284d7751fcd4", "filename": "gcc/d/dmd/dmodule.c", "status": "modified", "additions": 4, "deletions": 119, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -34,8 +34,6 @@ Dsymbols Module::deferred2; // deferred Dsymbol's needing semantic2() run on the\n Dsymbols Module::deferred3; // deferred Dsymbol's needing semantic3() run on them\n unsigned Module::dprogress;\n \n-StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n-\n void Module::_init()\n {\n     modules = new DsymbolTable();\n@@ -815,113 +813,6 @@ void Module::importAll(Scope *)\n     sc->pop();          // 2 pops because Scope::createGlobal() created 2\n }\n \n-void Module::semantic(Scope *)\n-{\n-    if (semanticRun != PASSinit)\n-        return;\n-\n-    //printf(\"+Module::semantic(this = %p, '%s'): parent = %p\\n\", this, toChars(), parent);\n-    semanticRun = PASSsemantic;\n-\n-    // Note that modules get their own scope, from scratch.\n-    // This is so regardless of where in the syntax a module\n-    // gets imported, it is unaffected by context.\n-    Scope *sc = _scope;                  // see if already got one from importAll()\n-    if (!sc)\n-    {\n-        Scope::createGlobal(this);      // create root scope\n-    }\n-\n-    //printf(\"Module = %p, linkage = %d\\n\", sc->scopesym, sc->linkage);\n-\n-    // Pass 1 semantic routines: do public side of the definition\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-\n-        //printf(\"\\tModule('%s'): '%s'.semantic()\\n\", toChars(), s->toChars());\n-        s->semantic(sc);\n-        runDeferredSemantic();\n-    }\n-\n-    if (userAttribDecl)\n-    {\n-        userAttribDecl->semantic(sc);\n-    }\n-\n-    if (!_scope)\n-    {\n-        sc = sc->pop();\n-        sc->pop();              // 2 pops because Scope::createGlobal() created 2\n-    }\n-    semanticRun = PASSsemanticdone;\n-    //printf(\"-Module::semantic(this = %p, '%s'): parent = %p\\n\", this, toChars(), parent);\n-}\n-\n-void Module::semantic2(Scope*)\n-{\n-    //printf(\"Module::semantic2('%s'): parent = %p\\n\", toChars(), parent);\n-    if (semanticRun != PASSsemanticdone)       // semantic() not completed yet - could be recursive call\n-        return;\n-    semanticRun = PASSsemantic2;\n-\n-    // Note that modules get their own scope, from scratch.\n-    // This is so regardless of where in the syntax a module\n-    // gets imported, it is unaffected by context.\n-    Scope *sc = Scope::createGlobal(this);      // create root scope\n-    //printf(\"Module = %p\\n\", sc.scopesym);\n-\n-    // Pass 2 semantic routines: do initializers and function bodies\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->semantic2(sc);\n-    }\n-\n-    if (userAttribDecl)\n-    {\n-        userAttribDecl->semantic2(sc);\n-    }\n-\n-    sc = sc->pop();\n-    sc->pop();\n-    semanticRun = PASSsemantic2done;\n-    //printf(\"-Module::semantic2('%s'): parent = %p\\n\", toChars(), parent);\n-}\n-\n-void Module::semantic3(Scope*)\n-{\n-    //printf(\"Module::semantic3('%s'): parent = %p\\n\", toChars(), parent);\n-    if (semanticRun != PASSsemantic2done)\n-        return;\n-    semanticRun = PASSsemantic3;\n-\n-    // Note that modules get their own scope, from scratch.\n-    // This is so regardless of where in the syntax a module\n-    // gets imported, it is unaffected by context.\n-    Scope *sc = Scope::createGlobal(this);      // create root scope\n-    //printf(\"Module = %p\\n\", sc.scopesym);\n-\n-    // Pass 3 semantic routines: do initializers and function bodies\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        //printf(\"Module %s: %s.semantic3()\\n\", toChars(), s->toChars());\n-        s->semantic3(sc);\n-\n-        runDeferredSemantic2();\n-    }\n-\n-    if (userAttribDecl)\n-    {\n-        userAttribDecl->semantic3(sc);\n-    }\n-\n-    sc = sc->pop();\n-    sc->pop();\n-    semanticRun = PASSsemantic3done;\n-}\n-\n /**********************************\n  * Determine if we need to generate an instance of ModuleInfo\n  * for this Module.\n@@ -1074,7 +965,7 @@ void Module::runDeferredSemantic()\n         {\n             Dsymbol *s = todo[i];\n \n-            s->semantic(NULL);\n+            dsymbolSemantic(s, NULL);\n             //printf(\"deferred: %s, parent = %s\\n\", s->toChars(), s->parent->toChars());\n         }\n         //printf(\"\\tdeferred.length = %d, len = %d, dprogress = %d\\n\", deferred.length, len, dprogress);\n@@ -1094,7 +985,7 @@ void Module::runDeferredSemantic2()\n     {\n         Dsymbol *s = (*a)[i];\n         //printf(\"[%d] %s semantic2a\\n\", i, s->toPrettyChars());\n-        s->semantic2(NULL);\n+        semantic2(s, NULL);\n \n         if (global.errors)\n             break;\n@@ -1112,7 +1003,7 @@ void Module::runDeferredSemantic3()\n         Dsymbol *s = (*a)[i];\n         //printf(\"[%d] %s semantic3a\\n\", i, s->toPrettyChars());\n \n-        s->semantic3(NULL);\n+        semantic3(s, NULL);\n \n         if (global.errors)\n             break;\n@@ -1296,12 +1187,6 @@ bool Package::isAncestorPackageOf(const Package * const pkg) const\n     return isAncestorPackageOf(pkg->parent->isPackage());\n }\n \n-void Package::semantic(Scope *)\n-{\n-    if (semanticRun < PASSsemanticdone)\n-        semanticRun = PASSsemanticdone;\n-}\n-\n /****************************************************\n  * Input:\n  *      packages[]      the pkg1.pkg2 of pkg1.pkg2.mod"}, {"sha": "5d2da1ccdb91f974c10b1312135716a1037a9123", "filename": "gcc/d/dmd/doc.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -663,7 +663,8 @@ static size_t getCodeIndent(const char *src)\n /** Recursively expand template mixin member docs into the scope. */\n static void expandTemplateMixinComments(TemplateMixin *tm, OutBuffer *buf, Scope *sc)\n {\n-    if (!tm->semanticRun) tm->semantic(sc);\n+    if (!tm->semanticRun)\n+        dsymbolSemantic(tm, sc);\n     TemplateDeclaration *td = (tm && tm->tempdecl) ?\n         tm->tempdecl->isTemplateDeclaration() : NULL;\n     if (td && td->members)\n@@ -1105,9 +1106,9 @@ void toDocBuffer(Dsymbol *s, OutBuffer *buf, Scope *sc)\n             emitProtection(buf, ad->protection);\n             buf->printf(\"alias %s = \", ad->toChars());\n \n-            if (Dsymbol *s = ad->aliassym)  // ident alias\n+            if (Dsymbol *sa = ad->aliassym)  // ident alias\n             {\n-                prettyPrintDsymbol(s, ad->parent);\n+                prettyPrintDsymbol(sa, ad->parent);\n             }\n             else if (Type *type = ad->getType())  // type alias\n             {"}, {"sha": "6d13ab1c1213252dd4e2e1ab9892e2592fc4baea", "filename": "gcc/d/dmd/doc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdoc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdoc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "65e6734b035a73cb7c11854f9f09d09b7b65e392", "filename": "gcc/d/dmd/dscope.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdscope.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdscope.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -398,7 +398,7 @@ static Dsymbol *searchScopes(Scope *scope, Loc loc, Identifier *ident, Dsymbol *\n                 ident == Id::length && sc->scopesym->isArrayScopeSymbol() &&\n                 sc->enclosing && sc->enclosing->search(loc, ident, NULL, flags))\n             {\n-                warning(s->loc, \"array 'length' hides other 'length' name in outer scope\");\n+                warning(s->loc, \"array `length` hides other `length` name in outer scope\");\n             }\n             if (pscopesym)\n                 *pscopesym = sc->scopesym;\n@@ -473,11 +473,11 @@ Dsymbol *Scope::insert(Dsymbol *s)\n     }\n     else if (WithScopeSymbol *ss = s->isWithScopeSymbol())\n     {\n-        if (VarDeclaration *vd = ss->withstate->wthis)\n+        if (VarDeclaration *wthis = ss->withstate->wthis)\n         {\n             if (lastVar)\n-                vd->lastVar = lastVar;\n-            lastVar = vd;\n+                wthis->lastVar = lastVar;\n+            lastVar = wthis;\n         }\n         return NULL;\n     }"}, {"sha": "40c67ceb0844573a05af67b56d72f268a11c30e9", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 12, "deletions": 306, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -247,89 +247,6 @@ void AggregateDeclaration::setScope(Scope *sc)\n         ScopeDsymbol::setScope(sc);\n }\n \n-void AggregateDeclaration::semantic2(Scope *sc)\n-{\n-    //printf(\"AggregateDeclaration::semantic2(%s) type = %s, errors = %d\\n\", toChars(), type->toChars(), errors);\n-    if (!members)\n-        return;\n-\n-    if (_scope)\n-    {\n-        error(\"has forward references\");\n-        return;\n-    }\n-\n-    Scope *sc2 = newScope(sc);\n-\n-    determineSize(loc);\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        //printf(\"\\t[%d] %s\\n\", i, s->toChars());\n-        s->semantic2(sc2);\n-    }\n-\n-    sc2->pop();\n-}\n-\n-void AggregateDeclaration::semantic3(Scope *sc)\n-{\n-    //printf(\"AggregateDeclaration::semantic3(%s) type = %s, errors = %d\\n\", toChars(), type->toChars(), errors);\n-    if (!members)\n-        return;\n-\n-    StructDeclaration *sd = isStructDeclaration();\n-    if (!sc)    // from runDeferredSemantic3 for TypeInfo generation\n-    {\n-        assert(sd);\n-        sd->semanticTypeInfoMembers();\n-        return;\n-    }\n-\n-    Scope *sc2 = newScope(sc);\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->semantic3(sc2);\n-    }\n-\n-    sc2->pop();\n-\n-    // don't do it for unused deprecated types\n-    // or error types\n-    if (!getRTInfo && Type::rtinfo &&\n-        (!isDeprecated() || global.params.useDeprecated != DIAGNOSTICerror) &&\n-        (type && type->ty != Terror))\n-    {\n-        // Evaluate: RTinfo!type\n-        Objects *tiargs = new Objects();\n-        tiargs->push(type);\n-        TemplateInstance *ti = new TemplateInstance(loc, Type::rtinfo, tiargs);\n-\n-        Scope *sc3 = ti->tempdecl->_scope->startCTFE();\n-        sc3->tinst = sc->tinst;\n-        sc3->minst = sc->minst;\n-        if (isDeprecated())\n-            sc3->stc |= STCdeprecated;\n-\n-        ti->semantic(sc3);\n-        ti->semantic2(sc3);\n-        ti->semantic3(sc3);\n-        Expression *e = resolve(Loc(), sc3, ti->toAlias(), false);\n-\n-        sc3->endCTFE();\n-\n-        e = e->ctfeInterpret();\n-        getRTInfo = e;\n-    }\n-\n-    if (sd)\n-        sd->semanticTypeInfoMembers();\n-    semanticRun = PASSsemantic3done;\n-}\n-\n /***************************************\n  * Find all instance fields, then push them into `fields`.\n  *\n@@ -364,7 +281,7 @@ bool AggregateDeclaration::determineFields()\n             AggregateDeclaration *ad = ((SV *)param)->agg;\n \n             if (v->semanticRun < PASSsemanticdone)\n-                v->semantic(NULL);\n+                dsymbolSemantic(v, NULL);\n             // Note: Aggregate fields or size could have determined during v->semantic.\n             if (ad->sizeok != SIZEOKnone)\n                 return 1;\n@@ -437,7 +354,7 @@ bool AggregateDeclaration::determineSize(Loc loc)\n     }\n \n     if (_scope)\n-        semantic(NULL);\n+        dsymbolSemantic(this, NULL);\n \n     // Determine the instance size of base class first.\n     if (ClassDeclaration *cd = isClassDeclaration())\n@@ -480,7 +397,7 @@ void StructDeclaration::semanticTypeInfoMembers()\n         xeq->semanticRun < PASSsemantic3done)\n     {\n         unsigned errors = global.startGagging();\n-        xeq->semantic3(xeq->_scope);\n+        semantic3(xeq, xeq->_scope);\n         if (global.endGagging(errors))\n             xeq = xerreq;\n     }\n@@ -490,7 +407,7 @@ void StructDeclaration::semanticTypeInfoMembers()\n         xcmp->semanticRun < PASSsemantic3done)\n     {\n         unsigned errors = global.startGagging();\n-        xcmp->semantic3(xcmp->_scope);\n+        semantic3(xcmp, xcmp->_scope);\n         if (global.endGagging(errors))\n             xcmp = xerrcmp;\n     }\n@@ -500,28 +417,28 @@ void StructDeclaration::semanticTypeInfoMembers()\n         ftostr->_scope &&\n         ftostr->semanticRun < PASSsemantic3done)\n     {\n-        ftostr->semantic3(ftostr->_scope);\n+        semantic3(ftostr, ftostr->_scope);\n     }\n \n     if (xhash &&\n         xhash->_scope &&\n         xhash->semanticRun < PASSsemantic3done)\n     {\n-        xhash->semantic3(xhash->_scope);\n+        semantic3(xhash, xhash->_scope);\n     }\n \n     if (postblit &&\n         postblit->_scope &&\n         postblit->semanticRun < PASSsemantic3done)\n     {\n-        postblit->semantic3(postblit->_scope);\n+        semantic3(postblit, postblit->_scope);\n     }\n \n     if (dtor &&\n         dtor->_scope &&\n         dtor->semanticRun < PASSsemantic3done)\n     {\n-        dtor->semantic3(dtor->_scope);\n+        semantic3(dtor, dtor->_scope);\n     }\n }\n \n@@ -964,7 +881,7 @@ Dsymbol *AggregateDeclaration::searchCtor()\n             {\n                 CtorDeclaration *f = s->isCtorDeclaration();\n                 if (f && f->semanticRun == PASSinit)\n-                    f->semantic(NULL);\n+                    dsymbolSemantic(f, NULL);\n                 return 0;\n             }\n         };\n@@ -1020,227 +937,16 @@ Dsymbol *StructDeclaration::syntaxCopy(Dsymbol *s)\n     return ScopeDsymbol::syntaxCopy(sd);\n }\n \n-void StructDeclaration::semantic(Scope *sc)\n-{\n-    //printf(\"StructDeclaration::semantic(this=%p, %s '%s', sizeok = %d)\\n\", this, parent->toChars(), toChars(), sizeok);\n-\n-    //static int count; if (++count == 20) halt();\n-\n-    if (semanticRun >= PASSsemanticdone)\n-        return;\n-    unsigned errors = global.errors;\n-\n-    //printf(\"+StructDeclaration::semantic(this=%p, %s '%s', sizeok = %d)\\n\", this, parent->toChars(), toChars(), sizeok);\n-    Scope *scx = NULL;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        scx = _scope;            // save so we don't make redundant copies\n-        _scope = NULL;\n-    }\n-\n-    if (!parent)\n-    {\n-        assert(sc->parent && sc->func);\n-        parent = sc->parent;\n-    }\n-    assert(parent && !isAnonymous());\n-\n-    if (this->errors)\n-        type = Type::terror;\n-    if (semanticRun == PASSinit)\n-        type = type->addSTC(sc->stc | storage_class);\n-    type = type->semantic(loc, sc);\n-\n-    if (type->ty == Tstruct && ((TypeStruct *)type)->sym != this)\n-    {\n-        TemplateInstance *ti = ((TypeStruct *)type)->sym->isInstantiated();\n-        if (ti && isError(ti))\n-            ((TypeStruct *)type)->sym = this;\n-    }\n-\n-    // Ungag errors when not speculative\n-    Ungag ungag = ungagSpeculative();\n-\n-    if (semanticRun == PASSinit)\n-    {\n-        protection = sc->protection;\n-\n-        alignment = sc->alignment();\n-\n-        storage_class |= sc->stc;\n-        if (storage_class & STCdeprecated)\n-            isdeprecated = true;\n-        if (storage_class & STCabstract)\n-            error(\"structs, unions cannot be abstract\");\n-        userAttribDecl = sc->userAttribDecl;\n-\n-        if (sc->linkage == LINKcpp)\n-            classKind = ClassKind::cpp;\n-    }\n-    else if (symtab && !scx)\n-    {\n-        return;\n-    }\n-    semanticRun = PASSsemantic;\n-\n-    if (!members)               // if opaque declaration\n-    {\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-    if (!symtab)\n-    {\n-        symtab = new DsymbolTable();\n-\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            //printf(\"adding member '%s' to '%s'\\n\", s->toChars(), this->toChars());\n-            s->addMember(sc, this);\n-        }\n-    }\n-\n-    Scope *sc2 = newScope(sc);\n-\n-    /* Set scope so if there are forward references, we still might be able to\n-     * resolve individual members like enums.\n-     */\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        //printf(\"struct: setScope %s %s\\n\", s->kind(), s->toChars());\n-        s->setScope(sc2);\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->importAll(sc2);\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->semantic(sc2);\n-    }\n-\n-    if (!determineFields())\n-    {\n-        assert(type->ty == Terror);\n-        sc2->pop();\n-        semanticRun = PASSsemanticdone;\n-        return;\n-    }\n-\n-    /* Following special member functions creation needs semantic analysis\n-     * completion of sub-structs in each field types. For example, buildDtor\n-     * needs to check existence of elaborate dtor in type of each fields.\n-     * See the case in compilable/test14838.d\n-     */\n-    for (size_t i = 0; i < fields.length; i++)\n-    {\n-        VarDeclaration *v = fields[i];\n-        Type *tb = v->type->baseElemOf();\n-        if (tb->ty != Tstruct)\n-            continue;\n-        StructDeclaration *sd = ((TypeStruct *)tb)->sym;\n-        if (sd->semanticRun >= PASSsemanticdone)\n-            continue;\n-\n-        sc2->pop();\n-\n-        _scope = scx ? scx : sc->copy();\n-        _scope->setNoFree();\n-        _scope->_module->addDeferredSemantic(this);\n-\n-        //printf(\"\\tdeferring %s\\n\", toChars());\n-        return;\n-    }\n-\n-    /* Look for special member functions.\n-     */\n-    aggNew =       (NewDeclaration *)search(Loc(), Id::classNew);\n-    aggDelete = (DeleteDeclaration *)search(Loc(), Id::classDelete);\n-\n-    // Look for the constructor\n-    ctor = searchCtor();\n-\n-    dtor = buildDtor(this, sc2);\n-    postblit = buildPostBlit(this, sc2);\n-\n-    buildOpAssign(this, sc2);\n-    buildOpEquals(this, sc2);\n-\n-    if (global.params.useTypeInfo && Type::dtypeinfo)  // these functions are used for TypeInfo\n-    {\n-        xeq = buildXopEquals(this, sc2);\n-        xcmp = buildXopCmp(this, sc2);\n-        xhash = buildXtoHash(this, sc2);\n-    }\n-\n-    inv = buildInv(this, sc2);\n-\n-    Module::dprogress++;\n-    semanticRun = PASSsemanticdone;\n-    //printf(\"-StructDeclaration::semantic(this=%p, '%s')\\n\", this, toChars());\n-\n-    sc2->pop();\n-\n-    if (ctor)\n-    {\n-        Dsymbol *scall = search(Loc(), Id::call);\n-        if (scall)\n-        {\n-            unsigned xerrors = global.startGagging();\n-            sc = sc->push();\n-            sc->tinst = NULL;\n-            sc->minst = NULL;\n-            FuncDeclaration *fcall = resolveFuncCall(loc, sc, scall, NULL, NULL, NULL, 1);\n-            sc = sc->pop();\n-            global.endGagging(xerrors);\n-\n-            if (fcall && fcall->isStatic())\n-            {\n-                error(fcall->loc, \"static opCall is hidden by constructors and can never be called\");\n-                errorSupplemental(fcall->loc, \"Please use a factory method instead, or replace all constructors with static opCall.\");\n-            }\n-        }\n-    }\n-\n-    if (type->ty == Tstruct && ((TypeStruct *)type)->sym != this)\n-    {\n-        // https://issues.dlang.org/show_bug.cgi?id=19024\n-        StructDeclaration *sd = ((TypeStruct *)type)->sym;\n-        error(\"already exists at %s. Perhaps in another function with the same name?\", sd->loc.toChars());\n-    }\n-\n-    if (global.errors != errors)\n-    {\n-        // The type is no good.\n-        type = Type::terror;\n-        this->errors = true;\n-        if (deferred)\n-            deferred->errors = true;\n-    }\n-\n-    if (deferred && !global.gag)\n-    {\n-        deferred->semantic2(sc);\n-        deferred->semantic3(sc);\n-    }\n-}\n-\n Dsymbol *StructDeclaration::search(const Loc &loc, Identifier *ident, int flags)\n {\n     //printf(\"%s.StructDeclaration::search('%s', flags = x%x)\\n\", toChars(), ident->toChars(), flags);\n \n     if (_scope && !symtab)\n-        semantic(_scope);\n+        dsymbolSemantic(this, _scope);\n \n     if (!members || !symtab)    // opaque or semantic() is not yet called\n     {\n-        error(\"is forward referenced when looking for '%s'\", ident->toChars());\n+        error(\"is forward referenced when looking for `%s`\", ident->toChars());\n         return NULL;\n     }\n "}, {"sha": "89c55576a55f88dcde0edc76c36031ade26f5160", "filename": "gcc/d/dmd/dsymbol.c", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -35,7 +35,6 @@\n bool symbolIsVisible(Dsymbol *origin, Dsymbol *s);\n typedef int (*ForeachDg)(void *ctx, size_t idx, Dsymbol *s);\n int ScopeDsymbol_foreach(Scope *sc, Dsymbols *members, ForeachDg dg, void *ctx, size_t *pn = NULL);\n-Expression *semantic(Expression *e, Scope *sc);\n \n \n /****************************** Dsymbol ******************************/\n@@ -462,33 +461,6 @@ void Dsymbol::importAll(Scope *)\n {\n }\n \n-/*************************************\n- * Does semantic analysis on the public face of declarations.\n- */\n-\n-void Dsymbol::semantic(Scope *)\n-{\n-    error(\"%p has no semantic routine\", this);\n-}\n-\n-/*************************************\n- * Does semantic analysis on initializers and members of aggregates.\n- */\n-\n-void Dsymbol::semantic2(Scope *)\n-{\n-    // Most Dsymbols have no further semantic analysis needed\n-}\n-\n-/*************************************\n- * Does semantic analysis on function bodies.\n- */\n-\n-void Dsymbol::semantic3(Scope *)\n-{\n-    // Most Dsymbols have no further semantic analysis needed\n-}\n-\n /*********************************************\n  * Search for ident as member of s.\n  * Params:\n@@ -553,7 +525,7 @@ Dsymbol *Dsymbol::searchX(Loc loc, Scope *sc, RootObject *id)\n     {\n         if (d->inuse)\n         {\n-            ::error(loc, \"circular reference to '%s'\", d->toPrettyChars());\n+            ::error(loc, \"circular reference to `%s`\", d->toPrettyChars());\n             return NULL;\n         }\n     }\n@@ -575,10 +547,10 @@ Dsymbol *Dsymbol::searchX(Loc loc, Scope *sc, RootObject *id)\n             {\n                 sm = s->search_correct(ti->name);\n                 if (sm)\n-                    ::error(loc, \"template identifier '%s' is not a member of %s '%s', did you mean %s '%s'?\",\n+                    ::error(loc, \"template identifier `%s` is not a member of %s `%s`, did you mean %s `%s`?\",\n                           ti->name->toChars(), s->kind(), s->toPrettyChars(), sm->kind(), sm->toChars());\n                 else\n-                    ::error(loc, \"template identifier '%s' is not a member of %s '%s'\",\n+                    ::error(loc, \"template identifier `%s` is not a member of %s `%s`\",\n                           ti->name->toChars(), s->kind(), s->toPrettyChars());\n                 return NULL;\n             }\n@@ -591,7 +563,7 @@ Dsymbol *Dsymbol::searchX(Loc loc, Scope *sc, RootObject *id)\n             }\n             ti->tempdecl = td;\n             if (!ti->semanticRun)\n-                ti->semantic(sc);\n+                dsymbolSemantic(ti, sc);\n             sm = ti->toAlias();\n             break;\n         }\n@@ -612,7 +584,7 @@ bool Dsymbol::overloadInsert(Dsymbol *)\n \n d_uns64 Dsymbol::size(Loc)\n {\n-    error(\"Dsymbol '%s' has no size\", toChars());\n+    error(\"Dsymbol `%s` has no size\", toChars());\n     return SIZE_INVALID;\n }\n \n@@ -1015,10 +987,6 @@ void ForwardingScopeDsymbol::importScope(Dsymbol *s, Prot protection)\n     forward->importScope(s, protection);\n }\n \n-void ForwardingScopeDsymbol::semantic(Scope *)\n-{\n-}\n-\n const char *ForwardingScopeDsymbol::kind() const\n {\n     return \"local scope\";\n@@ -1055,10 +1023,6 @@ Dsymbol *ScopeDsymbol::syntaxCopy(Dsymbol *s)\n     return sds;\n }\n \n-void ScopeDsymbol::semantic(Scope *)\n-{\n-}\n-\n /*****************************************\n  * This function is #1 on the list of functions that eat cpu time.\n  * Be very, very careful about slowing it down.\n@@ -1593,7 +1557,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n             Expression *e = new IntegerExp(Loc(), td->objects->length, Type::tsize_t);\n             v->_init = new ExpInitializer(Loc(), e);\n             v->storage_class |= STCtemp | STCstatic | STCconst;\n-            v->semantic(sc);\n+            dsymbolSemantic(v, sc);\n             return v;\n         }\n \n@@ -1605,7 +1569,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n             Expression *e = new IntegerExp(Loc(), type->arguments->length, Type::tsize_t);\n             v->_init = new ExpInitializer(Loc(), e);\n             v->storage_class |= STCtemp | STCstatic | STCconst;\n-            v->semantic(sc);\n+            dsymbolSemantic(v, sc);\n             return v;\n         }\n \n@@ -1709,7 +1673,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n \n                     Objects *tiargs = new Objects();\n                     Expression *edim = new IntegerExp(Loc(), dim, Type::tsize_t);\n-                    edim = ::semantic(edim, sc);\n+                    edim = expressionSemantic(edim, sc);\n                     tiargs->push(edim);\n                     e = new DotTemplateInstanceExp(loc, ce, td->ident, tiargs);\n                 }\n@@ -1729,7 +1693,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n                     assert(d);\n                     e = new DotVarExp(loc, ce, d);\n                 }\n-                e = ::semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 if (!e->type)\n                     exp->error(\"%s has no value\", e->toChars());\n                 t = e->type->toBasetype();\n@@ -1752,7 +1716,7 @@ Dsymbol *ArrayScopeSymbol::search(const Loc &loc, Identifier *ident, int)\n             }\n             *pvar = v;\n         }\n-        (*pvar)->semantic(sc);\n+        dsymbolSemantic(*pvar, sc);\n         return (*pvar);\n     }\n     return NULL;"}, {"sha": "1ddfe06e6a169a86860129c03e8ac5c9d0c751e9", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -83,6 +83,10 @@ struct Ungag\n     ~Ungag() { global.gag = oldgag; }\n };\n \n+void dsymbolSemantic(Dsymbol *dsym, Scope *sc);\n+void semantic2(Dsymbol *dsym, Scope* sc);\n+void semantic3(Dsymbol *dsym, Scope* sc);\n+\n struct Prot\n {\n     enum Kind\n@@ -201,9 +205,6 @@ class Dsymbol : public ASTNode\n     virtual void addMember(Scope *sc, ScopeDsymbol *sds);\n     virtual void setScope(Scope *sc);\n     virtual void importAll(Scope *sc);\n-    virtual void semantic(Scope *sc);\n-    virtual void semantic2(Scope *sc);\n-    virtual void semantic3(Scope *sc);\n     virtual Dsymbol *search(const Loc &loc, Identifier *ident, int flags = IgnoreNone);\n     Dsymbol *search_correct(Identifier *id);\n     Dsymbol *searchX(Loc loc, Scope *sc, RootObject *id);\n@@ -320,7 +321,6 @@ class ScopeDsymbol : public Dsymbol\n     static Dsymbol *getNth(Dsymbols *members, size_t nth, size_t *pn = NULL);\n \n     ScopeDsymbol *isScopeDsymbol() { return this; }\n-    void semantic(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -382,7 +382,6 @@ class ForwardingScopeDsymbol : public ScopeDsymbol\n     Dsymbol *symtabInsert(Dsymbol *s);\n     Dsymbol *symtabLookup(Dsymbol *s, Identifier *id);\n     void importScope(Dsymbol *s, Prot protection);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n \n     ForwardingScopeDsymbol *isForwardingScopeDsymbol() { return this; }"}, {"sha": "5d5c9fca7691b192c7050fd08935022c32cc65a5", "filename": "gcc/d/dmd/dsymbolsem.c", "status": "added", "additions": 5486, "deletions": 0, "changes": 5486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdsymbolsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdsymbolsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa"}, {"sha": "b868e9ad3887a07af86394e37c695e6c0d9da665", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 44, "deletions": 1140, "changes": 1184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -47,8 +47,7 @@ static size_t templateParameterLookup(Type *tparam, TemplateParameters *paramete\n static int arrayObjectMatch(Objects *oa1, Objects *oa2);\n static unsigned char deduceWildHelper(Type *t, Type **at, Type *tparam);\n static MATCH deduceTypeHelper(Type *t, Type **at, Type *tparam);\n-static bool reliesOnTident(Type *t, TemplateParameters *tparams = NULL, size_t iStart = 0);\n-Expression *semantic(Expression *e, Scope *sc);\n+bool reliesOnTident(Type *t, TemplateParameters *tparams = NULL, size_t iStart = 0);\n bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors);\n \n /********************************************\n@@ -568,127 +567,6 @@ Dsymbol *TemplateDeclaration::syntaxCopy(Dsymbol *)\n         Dsymbol::arraySyntaxCopy(members), ismixin, literal);\n }\n \n-void TemplateDeclaration::semantic(Scope *sc)\n-{\n-    if (semanticRun != PASSinit)\n-        return;         // semantic() already run\n-\n-    // Remember templates defined in module object that we need to know about\n-    if (sc->_module && sc->_module->ident == Id::object)\n-    {\n-        if (ident == Id::RTInfo)\n-            Type::rtinfo = this;\n-    }\n-\n-    /* Remember Scope for later instantiations, but make\n-     * a copy since attributes can change.\n-     */\n-    if (!this->_scope)\n-    {\n-        this->_scope = sc->copy();\n-        this->_scope->setNoFree();\n-    }\n-\n-    semanticRun = PASSsemantic;\n-\n-    parent = sc->parent;\n-    protection = sc->protection;\n-    isstatic = toParent()->isModule() || (_scope->stc & STCstatic);\n-\n-    if (!isstatic)\n-    {\n-        if (AggregateDeclaration *ad = parent->pastMixin()->isAggregateDeclaration())\n-            ad->makeNested();\n-    }\n-\n-    // Set up scope for parameters\n-    ScopeDsymbol *paramsym = new ScopeDsymbol();\n-    paramsym->parent = parent;\n-    Scope *paramscope = sc->push(paramsym);\n-    paramscope->stc = 0;\n-\n-    if (global.params.doDocComments)\n-    {\n-        origParameters = new TemplateParameters();\n-        origParameters->setDim(parameters->length);\n-        for (size_t i = 0; i < parameters->length; i++)\n-        {\n-            TemplateParameter *tp = (*parameters)[i];\n-            (*origParameters)[i] = tp->syntaxCopy();\n-        }\n-    }\n-\n-    for (size_t i = 0; i < parameters->length; i++)\n-    {\n-        TemplateParameter *tp = (*parameters)[i];\n-\n-        if (!tp->declareParameter(paramscope))\n-        {\n-            error(tp->loc, \"parameter '%s' multiply defined\", tp->ident->toChars());\n-            errors = true;\n-        }\n-        if (!tp->semantic(paramscope, parameters))\n-        {\n-            errors = true;\n-        }\n-        if (i + 1 != parameters->length && tp->isTemplateTupleParameter())\n-        {\n-            error(\"template tuple parameter must be last one\");\n-            errors = true;\n-        }\n-    }\n-\n-    /* Calculate TemplateParameter::dependent\n-     */\n-    TemplateParameters tparams;\n-    tparams.setDim(1);\n-    for (size_t i = 0; i < parameters->length; i++)\n-    {\n-        TemplateParameter *tp = (*parameters)[i];\n-        tparams[0] = tp;\n-\n-        for (size_t j = 0; j < parameters->length; j++)\n-        {\n-            // Skip cases like: X(T : T)\n-            if (i == j)\n-                continue;\n-\n-            if (TemplateTypeParameter *ttp = (*parameters)[j]->isTemplateTypeParameter())\n-            {\n-                if (reliesOnTident(ttp->specType, &tparams))\n-                    tp->dependent = true;\n-            }\n-            else if (TemplateAliasParameter *tap = (*parameters)[j]->isTemplateAliasParameter())\n-            {\n-                if (reliesOnTident(tap->specType, &tparams) ||\n-                    reliesOnTident(isType(tap->specAlias), &tparams))\n-                {\n-                    tp->dependent = true;\n-                }\n-            }\n-        }\n-    }\n-\n-    paramscope->pop();\n-\n-    // Compute again\n-    onemember = NULL;\n-    if (members)\n-    {\n-        Dsymbol *s;\n-        if (Dsymbol::oneMembers(members, &s, ident) && s)\n-        {\n-            onemember = s;\n-            s->parent = this;\n-        }\n-    }\n-\n-    /* BUG: should check:\n-     *  o no virtual functions or non-static data members of classes\n-     */\n-    semanticRun = PASSsemanticdone;\n-}\n-\n const char *TemplateDeclaration::kind() const\n {\n     return (onemember && onemember->isAggregateDeclaration())\n@@ -806,7 +684,7 @@ bool TemplateDeclaration::evaluateConstraint(\n                 continue;                       // don't add it, if it has no name\n             VarDeclaration *v = new VarDeclaration(loc, fparam->type, fparam->ident, NULL);\n             v->storage_class = fparam->storageClass;\n-            v->semantic(scx);\n+            dsymbolSemantic(v, scx);\n             if (!ti->symtab)\n                 ti->symtab = new DsymbolTable();\n             if (!scx->insert(v))\n@@ -904,7 +782,7 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n             m = m2;\n \n         if (!flag)\n-            sparam->semantic(paramscope);\n+            dsymbolSemantic(sparam, paramscope);\n         if (!paramscope->insert(sparam))    // TODO: This check can make more early\n             goto Lnomatch;                  // in TemplateDeclaration::semantic, and\n                                             // then we don't need to make sparam if flags == 0\n@@ -951,7 +829,7 @@ MATCH TemplateDeclaration::matchWithInstance(Scope *sc, TemplateInstance *ti,\n             // Resolve parameter types and 'auto ref's.\n             tf->fargs = fargs;\n             unsigned olderrors = global.startGagging();\n-            fd->type = tf->semantic(loc, paramscope);\n+            fd->type = typeSemantic(tf, loc, paramscope);\n             if (global.endGagging(olderrors))\n             {\n                 assert(fd->type->ty != Tfunction);\n@@ -1187,7 +1065,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n             if (m < matchTiargs)\n                 matchTiargs = m;\n \n-            sparam->semantic(paramscope);\n+            dsymbolSemantic(sparam, paramscope);\n             if (!paramscope->insert(sparam))\n                 goto Lnomatch;\n         }\n@@ -1351,7 +1229,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                     Parameter *p = fparameters[j];\n                     if (!reliesOnTident(p->type, parameters, inferStart))\n                     {\n-                        Type *pt = p->type->syntaxCopy()->semantic(fd->loc, paramscope);\n+                        Type *pt = typeSemantic(p->type->syntaxCopy(), fd->loc, paramscope);\n                         rem += pt->ty == Ttuple ? ((TypeTuple *)pt)->arguments->length : 1;\n                     }\n                     else\n@@ -1423,7 +1301,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n         if (!reliesOnTident(prmtype, parameters, inferStart))\n         {\n             // should copy prmtype to avoid affecting semantic result\n-            prmtype = prmtype->syntaxCopy()->semantic(fd->loc, paramscope);\n+            prmtype = typeSemantic(prmtype->syntaxCopy(), fd->loc, paramscope);\n \n             if (prmtype->ty == Ttuple)\n             {\n@@ -1551,7 +1429,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n \n             // Deduce prmtype from the defaultArg.\n             farg = fparam->defaultArg->syntaxCopy();\n-            farg = ::semantic(farg, paramscope);\n+            farg = expressionSemantic(farg, paramscope);\n             farg = resolveProperties(paramscope, farg);\n         }\n         else\n@@ -1773,7 +1651,7 @@ MATCH TemplateDeclaration::deduceFunctionTemplateMatch(\n                         }\n                         else\n                         {\n-                            Type *vt = tvp->valType->semantic(Loc(), sc);\n+                            Type *vt = typeSemantic(tvp->valType, Loc(), sc);\n                             MATCH m = (MATCH)dim->implicitConvTo(vt);\n                             if (m <= MATCHnomatch)\n                                 goto Lnomatch;\n@@ -2079,7 +1957,7 @@ RootObject *TemplateDeclaration::declareParameter(Scope *sc, TemplateParameter *\n \n     if (!sc->insert(d))\n         error(\"declaration %s is already defined\", tp->ident->toChars());\n-    d->semantic(sc);\n+    dsymbolSemantic(d, sc);\n \n     /* So the caller's o gets updated with the result of semantic() being run on o\n      */\n@@ -2176,7 +2054,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n                 fd->semanticRun < PASSsemanticdone)\n             {\n                 Ungag ungag = fd->ungagSpeculative();\n-                fd->semantic(NULL);\n+                dsymbolSemantic(fd, NULL);\n             }\n             if (fd->semanticRun < PASSsemanticdone)\n             {\n@@ -2313,7 +2191,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n             {\n                 // Try to fix forward reference. Ungag errors while doing so.\n                 Ungag ungag = td->ungagSpeculative();\n-                td->semantic(td->_scope);\n+                dsymbolSemantic(td, td->_scope);\n             }\n             if (td->semanticRun == PASSinit)\n             {\n@@ -2341,7 +2219,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n                 if (mta <= MATCHnomatch || mta < ta_last)      // no match or less match\n                     return 0;\n \n-                ti->semantic(sc, fargs);\n+                templateInstanceSemantic(ti, sc, fargs);\n                 if (!ti->inst)                  // if template failed to expand\n                     return 0;\n \n@@ -2583,7 +2461,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n             sc = p.td_best->_scope; // workaround for Type::aliasthisOf\n \n         TemplateInstance *ti = new TemplateInstance(loc, p.td_best, p.ti_best->tiargs);\n-        ti->semantic(sc, fargs);\n+        templateInstanceSemantic(ti, sc, fargs);\n \n         m->lastf = ti->toAlias()->isFuncDeclaration();\n         if (!m->lastf)\n@@ -2623,7 +2501,7 @@ void functionResolve(Match *m, Dsymbol *dstart, Loc loc, Scope *sc,\n          */\n         if (tf->next && !m->lastf->inferRetType)\n         {\n-            m->lastf->type = tf->semantic(loc, sc);\n+            m->lastf->type = typeSemantic(tf, loc, sc);\n         }\n     }\n     else if (m->lastf)\n@@ -2713,7 +2591,7 @@ FuncDeclaration *TemplateDeclaration::doHeaderInstantiation(\n         tf->next = NULL;\n     fd->type = tf;\n     fd->type = fd->type->addSTC(scx->stc);\n-    fd->type = fd->type->semantic(fd->loc, scx);\n+    fd->type = typeSemantic(fd->type, fd->loc, scx);\n     scx = scx->pop();\n \n     if (fd->type->ty != Tfunction)\n@@ -3199,7 +3077,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     /* BUG: what if tparam is a template instance, that\n                      * has as an argument another Tident?\n                      */\n-                    tparam = tparam->semantic(loc, sc);\n+                    tparam = typeSemantic(tparam, loc, sc);\n                     assert(tparam->ty != Tident);\n                     result = deduceType(t, sc, tparam, parameters, dedtypes, wm);\n                     return;\n@@ -3371,7 +3249,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     loc = tp->loc;\n                 }\n \n-                tparam = tparam->semantic(loc, sc);\n+                tparam = typeSemantic(tparam, loc, sc);\n             }\n             if (t->ty != tparam->ty)\n             {\n@@ -3848,7 +3726,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                             // (it may be from a parent template, for example)\n                         }\n \n-                        e2 = ::semantic(e2, sc);      // Bugzilla 13417\n+                        e2 = expressionSemantic(e2, sc);      // Bugzilla 13417\n                         e2 = e2->ctfeInterpret();\n \n                         //printf(\"e1 = %s, type = %s %d\\n\", e1->toChars(), e1->type->toChars(), e1->type->ty);\n@@ -4459,7 +4337,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n                     Type *t = pto->type->syntaxCopy();  // Bugzilla 11774\n                     if (reliesOnTident(t, parameters, inferStart))\n                         return;\n-                    t = t->semantic(e->loc, sc);\n+                    t = typeSemantic(t, e->loc, sc);\n                     if (t->ty == Terror)\n                         return;\n                     tiargs->push(t);\n@@ -4471,7 +4349,7 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n \n                 TemplateInstance *ti = new TemplateInstance(e->loc, e->td, tiargs);\n                 Expression *ex = new ScopeExp(e->loc, ti);\n-                ex = ::semantic(ex, e->td->_scope);\n+                ex = expressionSemantic(ex, e->td->_scope);\n \n                 // Reset inference target for the later re-semantic\n                 e->fd->treq = NULL;\n@@ -5041,16 +4919,6 @@ bool TemplateTypeParameter::declareParameter(Scope *sc)\n     return sc->insert(ad) != NULL;\n }\n \n-bool TemplateTypeParameter::semantic(Scope *sc, TemplateParameters *parameters)\n-{\n-    //printf(\"TemplateTypeParameter::semantic('%s')\\n\", ident->toChars());\n-    if (specType && !reliesOnTident(specType, parameters))\n-    {\n-        specType = specType->semantic(loc, sc);\n-    }\n-    return !(specType && isError(specType));\n-}\n-\n MATCH TemplateTypeParameter::matchArg(Scope *sc, RootObject *oarg,\n         size_t i, TemplateParameters *parameters, Objects *dedtypes,\n         Declaration **psparam)\n@@ -5171,7 +5039,7 @@ RootObject *TemplateTypeParameter::defaultArg(Loc, Scope *sc)\n     if (t)\n     {\n         t = t->syntaxCopy();\n-        t = t->semantic(loc, sc);   // use the parameter loc\n+        t = typeSemantic(t, loc, sc);   // use the parameter loc\n     }\n     return t;\n }\n@@ -5240,42 +5108,6 @@ bool TemplateAliasParameter::declareParameter(Scope *sc)\n     return sc->insert(ad) != NULL;\n }\n \n-static RootObject *aliasParameterSemantic(Loc loc, Scope *sc, RootObject *o, TemplateParameters *parameters)\n-{\n-    if (o)\n-    {\n-        Expression *ea = isExpression(o);\n-        Type *ta = isType(o);\n-        if (ta && (!parameters || !reliesOnTident(ta, parameters)))\n-        {\n-            Dsymbol *s = ta->toDsymbol(sc);\n-            if (s)\n-                o = s;\n-            else\n-                o = ta->semantic(loc, sc);\n-        }\n-        else if (ea)\n-        {\n-            sc = sc->startCTFE();\n-            ea = ::semantic(ea, sc);\n-            sc = sc->endCTFE();\n-            o = ea->ctfeInterpret();\n-        }\n-    }\n-    return o;\n-}\n-\n-bool TemplateAliasParameter::semantic(Scope *sc, TemplateParameters *parameters)\n-{\n-    if (specType && !reliesOnTident(specType, parameters))\n-    {\n-        specType = specType->semantic(loc, sc);\n-    }\n-    specAlias = aliasParameterSemantic(loc, sc, specAlias, parameters);\n-    return !(specType  && isError(specType)) &&\n-           !(specAlias && isError(specAlias));\n-}\n-\n MATCH TemplateAliasParameter::matchArg(Scope *sc, RootObject *oarg,\n         size_t i, TemplateParameters *parameters, Objects *dedtypes,\n         Declaration **psparam)\n@@ -5391,7 +5223,7 @@ MATCH TemplateAliasParameter::matchArg(Scope *sc, RootObject *oarg,\n             Initializer *init = new ExpInitializer(loc, ea);\n             VarDeclaration *v = new VarDeclaration(loc, NULL, ident, init);\n             v->storage_class = STCmanifest;\n-            v->semantic(sc);\n+            dsymbolSemantic(v, sc);\n             *psparam = v;\n         }\n     }\n@@ -5491,13 +5323,6 @@ bool TemplateValueParameter::declareParameter(Scope *sc)\n     return sc->insert(v) != NULL;\n }\n \n-bool TemplateValueParameter::semantic(Scope *sc, TemplateParameters *)\n-{\n-    valType = valType->semantic(loc, sc);\n-\n-    return !isError(valType);\n-}\n-\n MATCH TemplateValueParameter::matchArg(Scope *sc, RootObject *oarg,\n         size_t i, TemplateParameters *, Objects *dedtypes, Declaration **psparam)\n {\n@@ -5516,7 +5341,7 @@ MATCH TemplateValueParameter::matchArg(Scope *sc, RootObject *oarg,\n             goto Lnomatch;\n \n         ei = new VarExp(loc, f);\n-        ei = ::semantic(ei, sc);\n+        ei = expressionSemantic(ei, sc);\n \n         /* If a function is really property-like, and then\n          * it's CTFEable, ei will be a literal expression.\n@@ -5552,7 +5377,7 @@ MATCH TemplateValueParameter::matchArg(Scope *sc, RootObject *oarg,\n     }\n \n     //printf(\"\\tvalType: %s, ty = %d\\n\", valType->toChars(), valType->ty);\n-    vt = valType->semantic(loc, sc);\n+    vt = typeSemantic(valType, loc, sc);\n     //printf(\"ei: %s, ei->type: %s\\n\", ei->toChars(), ei->type->toChars());\n     //printf(\"vt = %s\\n\", vt->toChars());\n \n@@ -5576,15 +5401,15 @@ MATCH TemplateValueParameter::matchArg(Scope *sc, RootObject *oarg,\n         Expression *e = specValue;\n \n         sc = sc->startCTFE();\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         e = resolveProperties(sc, e);\n         sc = sc->endCTFE();\n         e = e->implicitCastTo(sc, vt);\n         e = e->ctfeInterpret();\n \n         ei = ei->syntaxCopy();\n         sc = sc->startCTFE();\n-        ei = ::semantic(ei, sc);\n+        ei = expressionSemantic(ei, sc);\n         sc = sc->endCTFE();\n         ei = ei->implicitCastTo(sc, vt);\n         ei = ei->ctfeInterpret();\n@@ -5660,7 +5485,7 @@ RootObject *TemplateValueParameter::defaultArg(Loc instLoc, Scope *sc)\n     if (e)\n     {\n         e = e->syntaxCopy();\n-        if ((e = ::semantic(e, sc)) == NULL)\n+        if ((e = expressionSemantic(e, sc)) == NULL)\n             return NULL;\n         if ((e = resolveProperties(sc, e)) == NULL)\n             return NULL;\n@@ -5702,11 +5527,6 @@ bool TemplateTupleParameter::declareParameter(Scope *sc)\n     return sc->insert(ad) != NULL;\n }\n \n-bool TemplateTupleParameter::semantic(Scope *, TemplateParameters *)\n-{\n-    return true;\n-}\n-\n MATCH TemplateTupleParameter::matchArg(Loc, Scope *sc, Objects *tiargs,\n         size_t i, TemplateParameters *parameters, Objects *dedtypes,\n         Declaration **psparam)\n@@ -5902,11 +5722,6 @@ Dsymbol *TemplateInstance::syntaxCopy(Dsymbol *s)\n     return ti;\n }\n \n-void TemplateInstance::semantic(Scope *sc)\n-{\n-    semantic(sc, NULL);\n-}\n-\n void TemplateInstance::expandMembers(Scope *sc2)\n {\n     for (size_t i = 0; i < members->length; i++)\n@@ -5929,7 +5744,7 @@ void TemplateInstance::expandMembers(Scope *sc2)\n //      if (enclosing)\n //          s->parent = sc->parent;\n         //printf(\"test3: enclosing = %d, s->parent = %s\\n\", enclosing, s->parent->toChars());\n-        s->semantic(sc2);\n+        dsymbolSemantic(s, sc2);\n         //printf(\"test4: enclosing = %d, s->parent = %s\\n\", enclosing, s->parent->toChars());\n         Module::runDeferredSemantic();\n     }\n@@ -5963,559 +5778,11 @@ void TemplateInstance::trySemantic3(Scope *sc2)\n         error(\"recursive expansion exceeded allowed nesting limit\");\n         fatal();\n     }\n-    semantic3(sc2);\n+    semantic3(this, sc2);\n \n     --nest;\n }\n \n-void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n-{\n-    //printf(\"[%s] TemplateInstance::semantic('%s', this=%p, gag = %d, sc = %p)\\n\", loc.toChars(), toChars(), this, global.gag, sc);\n-    if (inst)           // if semantic() was already run\n-    {\n-        return;\n-    }\n-    if (semanticRun != PASSinit)\n-    {\n-        Ungag ungag(global.gag);\n-        if (!gagged)\n-            global.gag = 0;\n-        error(loc, \"recursive template expansion\");\n-        if (gagged)\n-            semanticRun = PASSinit;\n-        else\n-            inst = this;\n-        errors = true;\n-        return;\n-    }\n-\n-    // Get the enclosing template instance from the scope tinst\n-    tinst = sc->tinst;\n-\n-    // Get the instantiating module from the scope minst\n-    minst = sc->minst;\n-    // Bugzilla 10920: If the enclosing function is non-root symbol,\n-    // this instance should be speculative.\n-    if (!tinst && sc->func && sc->func->inNonRoot())\n-    {\n-        minst = NULL;\n-    }\n-\n-    gagged = (global.gag > 0);\n-\n-    semanticRun = PASSsemantic;\n-\n-    /* Find template declaration first,\n-     * then run semantic on each argument (place results in tiargs[]),\n-     * last find most specialized template from overload list/set.\n-     */\n-    if (!findTempDecl(sc, NULL) ||\n-        !semanticTiargs(sc) ||\n-        !findBestMatch(sc, fargs))\n-    {\n-Lerror:\n-        if (gagged)\n-        {\n-            // Bugzilla 13220: Rollback status for later semantic re-running.\n-            semanticRun = PASSinit;\n-        }\n-        else\n-            inst = this;\n-        errors = true;\n-        return;\n-    }\n-    TemplateDeclaration *tempdecl = this->tempdecl->isTemplateDeclaration();\n-    assert(tempdecl);\n-\n-    // If tempdecl is a mixin, disallow it\n-    if (tempdecl->ismixin)\n-    {\n-        error(\"mixin templates are not regular templates\");\n-        goto Lerror;\n-    }\n-\n-    hasNestedArgs(tiargs, tempdecl->isstatic);\n-    if (errors)\n-        goto Lerror;\n-\n-    /* See if there is an existing TemplateInstantiation that already\n-     * implements the typeargs. If so, just refer to that one instead.\n-     */\n-    inst = tempdecl->findExistingInstance(this, fargs);\n-    TemplateInstance *errinst = NULL;\n-    if (!inst)\n-    {\n-        // So, we need to implement 'this' instance.\n-    }\n-    else if (inst->gagged && !gagged && inst->errors)\n-    {\n-        // If the first instantiation had failed, re-run semantic,\n-        // so that error messages are shown.\n-        errinst = inst;\n-    }\n-    else\n-    {\n-        // It's a match\n-        parent = inst->parent;\n-        errors = inst->errors;\n-\n-        // If both this and the previous instantiation were gagged,\n-        // use the number of errors that happened last time.\n-        global.errors += errors;\n-        global.gaggedErrors += errors;\n-\n-        // If the first instantiation was gagged, but this is not:\n-        if (inst->gagged)\n-        {\n-            // It had succeeded, mark it is a non-gagged instantiation,\n-            // and reuse it.\n-            inst->gagged = gagged;\n-        }\n-\n-        this->tnext = inst->tnext;\n-        inst->tnext = this;\n-\n-        /* A module can have explicit template instance and its alias\n-         * in module scope (e,g, `alias Base64 = Base64Impl!('+', '/');`).\n-         * If the first instantiation 'inst' had happened in non-root module,\n-         * compiler can assume that its instantiated code would be included\n-         * in the separately compiled obj/lib file (e.g. phobos.lib).\n-         *\n-         * However, if 'this' second instantiation happened in root module,\n-         * compiler might need to invoke its codegen (Bugzilla 2500 & 2644).\n-         * But whole import graph is not determined until all semantic pass finished,\n-         * so 'inst' should conservatively finish the semantic3 pass for the codegen.\n-         */\n-        if (minst && minst->isRoot() && !(inst->minst && inst->minst->isRoot()))\n-        {\n-            /* Swap the position of 'inst' and 'this' in the instantiation graph.\n-             * Then, the primary instance `inst` will be changed to a root instance,\n-             * along with all members of `inst` having their scopes updated.\n-             *\n-             * Before:\n-             *  non-root -> A!() -> B!()[inst] -> C!() { members[non-root] }\n-             *                      |\n-             *  root     -> D!() -> B!()[this]\n-             *\n-             * After:\n-             *  non-root -> A!() -> B!()[this]\n-             *                      |\n-             *  root     -> D!() -> B!()[inst] -> C!() { members[root] }\n-             */\n-            Module *mi = minst;\n-            TemplateInstance *ti = tinst;\n-            minst = inst->minst;\n-            tinst = inst->tinst;\n-            inst->minst = mi;\n-            inst->tinst = ti;\n-\n-            /* https://issues.dlang.org/show_bug.cgi?id=21299\n-               `minst` has been updated on the primary instance `inst` so it is\n-               now coming from a root module, however all Dsymbol `inst.members`\n-               of the instance still have their `_scope.minst` pointing at the\n-               original non-root module. We must now propagate `minst` to all\n-               members so that forward referenced dependencies that get\n-               instantiated will also be appended to the root module, otherwise\n-               there will be undefined references at link-time.  */\n-            class InstMemberWalker : public Visitor\n-            {\n-            public:\n-                TemplateInstance *inst;\n-\n-                InstMemberWalker(TemplateInstance *inst)\n-                    : inst(inst) { }\n-\n-                void visit(Dsymbol *d)\n-                {\n-                    if (d->_scope)\n-                        d->_scope->minst = inst->minst;\n-                }\n-\n-                void visit(ScopeDsymbol *sds)\n-                {\n-                    if (!sds->members)\n-                        return;\n-                    for (size_t i = 0; i < sds->members->length; i++)\n-                    {\n-                        Dsymbol *s = (*sds->members)[i];\n-                        s->accept(this);\n-                    }\n-                    visit((Dsymbol *)sds);\n-                }\n-\n-                void visit(AttribDeclaration *ad)\n-                {\n-                    Dsymbols *d = ad->include(NULL);\n-                    if (!d)\n-                        return;\n-                    for (size_t i = 0; i < d->length; i++)\n-                    {\n-                        Dsymbol *s = (*d)[i];\n-                        s->accept(this);\n-                    }\n-                    visit((Dsymbol *)ad);\n-                }\n-\n-                void visit(ConditionalDeclaration *cd)\n-                {\n-                    if (cd->condition->inc)\n-                        visit((AttribDeclaration *)cd);\n-                    else\n-                        visit((Dsymbol *)cd);\n-                }\n-            };\n-            InstMemberWalker v(inst);\n-            inst->accept(&v);\n-\n-            if (minst)  // if inst was not speculative\n-            {\n-                /* Add 'inst' once again to the root module members[], then the\n-                 * instance members will get codegen chances.\n-                 */\n-                inst->appendToModuleMember();\n-            }\n-        }\n-\n-        return;\n-    }\n-    unsigned errorsave = global.errors;\n-\n-    inst = this;\n-    parent = enclosing ? enclosing : tempdecl->parent;\n-    //printf(\"parent = '%s'\\n\", parent->kind());\n-\n-    TemplateInstance *tempdecl_instance_idx = tempdecl->addInstance(this);\n-\n-    //getIdent();\n-\n-    // Store the place we added it to in target_symbol_list(_idx) so we can\n-    // remove it later if we encounter an error.\n-    Dsymbols *target_symbol_list = appendToModuleMember();\n-    size_t target_symbol_list_idx = target_symbol_list ? target_symbol_list->length - 1 : 0;\n-\n-    // Copy the syntax trees from the TemplateDeclaration\n-    members = Dsymbol::arraySyntaxCopy(tempdecl->members);\n-\n-    // resolve TemplateThisParameter\n-    for (size_t i = 0; i < tempdecl->parameters->length; i++)\n-    {\n-        if ((*tempdecl->parameters)[i]->isTemplateThisParameter() == NULL)\n-            continue;\n-        Type *t = isType((*tiargs)[i]);\n-        assert(t);\n-        if (StorageClass stc = ModToStc(t->mod))\n-        {\n-            //printf(\"t = %s, stc = x%llx\\n\", t->toChars(), stc);\n-            Dsymbols *s = new Dsymbols();\n-            s->push(new StorageClassDeclaration(stc, members));\n-            members = s;\n-        }\n-        break;\n-    }\n-\n-    // Create our own scope for the template parameters\n-    Scope *scope = tempdecl->_scope;\n-    if (tempdecl->semanticRun == PASSinit)\n-    {\n-        error(\"template instantiation %s forward references template declaration %s\", toChars(), tempdecl->toChars());\n-        return;\n-    }\n-\n-    argsym = new ScopeDsymbol();\n-    argsym->parent = scope->parent;\n-    scope = scope->push(argsym);\n-    scope->tinst = this;\n-    scope->minst = minst;\n-    //scope->stc = 0;\n-\n-    // Declare each template parameter as an alias for the argument type\n-    Scope *paramscope = scope->push();\n-    paramscope->stc = 0;\n-    paramscope->protection = Prot(Prot::public_);  // Bugzilla 14169: template parameters should be public\n-    declareParameters(paramscope);\n-    paramscope->pop();\n-\n-    // Add members of template instance to template instance symbol table\n-//    parent = scope->scopesym;\n-    symtab = new DsymbolTable();\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->addMember(scope, this);\n-    }\n-\n-    /* See if there is only one member of template instance, and that\n-     * member has the same name as the template instance.\n-     * If so, this template instance becomes an alias for that member.\n-     */\n-    //printf(\"members->length = %d\\n\", members->length);\n-    if (members->length)\n-    {\n-        Dsymbol *s;\n-        if (Dsymbol::oneMembers(members, &s, tempdecl->ident) && s)\n-        {\n-            //printf(\"tempdecl->ident = %s, s = '%s'\\n\", tempdecl->ident->toChars(), s->kind(), s->toPrettyChars());\n-            //printf(\"setting aliasdecl\\n\");\n-            aliasdecl = s;\n-        }\n-    }\n-\n-    /* If function template declaration\n-     */\n-    if (fargs && aliasdecl)\n-    {\n-        FuncDeclaration *fd = aliasdecl->isFuncDeclaration();\n-        if (fd)\n-        {\n-            /* Transmit fargs to type so that TypeFunction::semantic() can\n-             * resolve any \"auto ref\" storage classes.\n-             */\n-            TypeFunction *tf = (TypeFunction *)fd->type;\n-            if (tf && tf->ty == Tfunction)\n-                tf->fargs = fargs;\n-        }\n-    }\n-\n-    // Do semantic() analysis on template instance members\n-    Scope *sc2;\n-    sc2 = scope->push(this);\n-    //printf(\"enclosing = %d, sc->parent = %s\\n\", enclosing, sc->parent->toChars());\n-    sc2->parent = this;\n-    sc2->tinst = this;\n-    sc2->minst = minst;\n-\n-    tryExpandMembers(sc2);\n-\n-    semanticRun = PASSsemanticdone;\n-\n-    /* ConditionalDeclaration may introduce eponymous declaration,\n-     * so we should find it once again after semantic.\n-     */\n-    if (members->length)\n-    {\n-        Dsymbol *s;\n-        if (Dsymbol::oneMembers(members, &s, tempdecl->ident) && s)\n-        {\n-            if (!aliasdecl || aliasdecl != s)\n-            {\n-                //printf(\"tempdecl->ident = %s, s = '%s'\\n\", tempdecl->ident->toChars(), s->kind(), s->toPrettyChars());\n-                //printf(\"setting aliasdecl 2\\n\");\n-                aliasdecl = s;\n-            }\n-        }\n-    }\n-\n-    if (global.errors != errorsave)\n-        goto Laftersemantic;\n-\n-    /* If any of the instantiation members didn't get semantic() run\n-     * on them due to forward references, we cannot run semantic2()\n-     * or semantic3() yet.\n-     */\n-    {\n-    bool found_deferred_ad = false;\n-    for (size_t i = 0; i < Module::deferred.length; i++)\n-    {\n-        Dsymbol *sd = Module::deferred[i];\n-        AggregateDeclaration *ad = sd->isAggregateDeclaration();\n-        if (ad && ad->parent && ad->parent->isTemplateInstance())\n-        {\n-            //printf(\"deferred template aggregate: %s %s\\n\",\n-            //        sd->parent->toChars(), sd->toChars());\n-            found_deferred_ad = true;\n-            if (ad->parent == this)\n-            {\n-                ad->deferred = this;\n-                break;\n-            }\n-        }\n-    }\n-    if (found_deferred_ad || Module::deferred.length)\n-        goto Laftersemantic;\n-    }\n-\n-    /* The problem is when to parse the initializer for a variable.\n-     * Perhaps VarDeclaration::semantic() should do it like it does\n-     * for initializers inside a function.\n-     */\n-    //if (sc->parent->isFuncDeclaration())\n-    {\n-        /* BUG 782: this has problems if the classes this depends on\n-         * are forward referenced. Find a way to defer semantic()\n-         * on this template.\n-         */\n-        semantic2(sc2);\n-    }\n-    if (global.errors != errorsave)\n-        goto Laftersemantic;\n-\n-    if ((sc->func || (sc->flags & SCOPEfullinst)) && !tinst)\n-    {\n-        /* If a template is instantiated inside function, the whole instantiation\n-         * should be done at that position. But, immediate running semantic3 of\n-         * dependent templates may cause unresolved forward reference (Bugzilla 9050).\n-         * To avoid the issue, don't run semantic3 until semantic and semantic2 done.\n-         */\n-        TemplateInstances deferred;\n-        this->deferred = &deferred;\n-\n-        //printf(\"Run semantic3 on %s\\n\", toChars());\n-        trySemantic3(sc2);\n-\n-        for (size_t i = 0; i < deferred.length; i++)\n-        {\n-            //printf(\"+ run deferred semantic3 on %s\\n\", deferred[i]->toChars());\n-            deferred[i]->semantic3(NULL);\n-        }\n-\n-        this->deferred = NULL;\n-    }\n-    else if (tinst)\n-    {\n-        bool doSemantic3 = false;\n-        if (sc->func && aliasdecl && aliasdecl->toAlias()->isFuncDeclaration())\n-        {\n-            /* Template function instantiation should run semantic3 immediately\n-             * for attribute inference.\n-             */\n-            trySemantic3(sc2);\n-        }\n-        else if (sc->func)\n-        {\n-            /* A lambda function in template arguments might capture the\n-             * instantiated scope context. For the correct context inference,\n-             * all instantiated functions should run the semantic3 immediately.\n-             * See also compilable/test14973.d\n-             */\n-            for (size_t i = 0; i < tdtypes.length; i++)\n-            {\n-                RootObject *oarg = tdtypes[i];\n-                Dsymbol *s = getDsymbol(oarg);\n-                if (!s)\n-                    continue;\n-\n-                if (TemplateDeclaration *td = s->isTemplateDeclaration())\n-                {\n-                    if (!td->literal)\n-                        continue;\n-                    assert(td->members && td->members->length == 1);\n-                    s = (*td->members)[0];\n-                }\n-                if (FuncLiteralDeclaration *fld = s->isFuncLiteralDeclaration())\n-                {\n-                    if (fld->tok == TOKreserved)\n-                    {\n-                        doSemantic3 = true;\n-                        break;\n-                    }\n-                }\n-            }\n-            //printf(\"[%s] %s doSemantic3 = %d\\n\", loc.toChars(), toChars(), doSemantic3);\n-        }\n-        if (doSemantic3)\n-            trySemantic3(sc2);\n-\n-        TemplateInstance *ti = tinst;\n-        int nest = 0;\n-        while (ti && !ti->deferred && ti->tinst)\n-        {\n-            ti = ti->tinst;\n-            if (++nest > global.recursionLimit)\n-            {\n-                global.gag = 0;            // ensure error message gets printed\n-                error(\"recursive expansion\");\n-                fatal();\n-            }\n-        }\n-        if (ti && ti->deferred)\n-        {\n-            //printf(\"deferred semantic3 of %p %s, ti = %s, ti->deferred = %p\\n\", this, toChars(), ti->toChars());\n-            for (size_t i = 0; ; i++)\n-            {\n-                if (i == ti->deferred->length)\n-                {\n-                    ti->deferred->push(this);\n-                    break;\n-                }\n-                if ((*ti->deferred)[i] == this)\n-                    break;\n-            }\n-        }\n-    }\n-\n-    if (aliasdecl)\n-    {\n-        /* Bugzilla 13816: AliasDeclaration tries to resolve forward reference\n-         * twice (See inuse check in AliasDeclaration::toAlias()). It's\n-         * necessary to resolve mutual references of instantiated symbols, but\n-         * it will left a true recursive alias in tuple declaration - an\n-         * AliasDeclaration A refers TupleDeclaration B, and B contains A\n-         * in its elements.  To correctly make it an error, we strictly need to\n-         * resolve the alias of eponymous member.\n-         */\n-        aliasdecl = aliasdecl->toAlias2();\n-    }\n-\n-  Laftersemantic:\n-    sc2->pop();\n-\n-    scope->pop();\n-\n-    // Give additional context info if error occurred during instantiation\n-    if (global.errors != errorsave)\n-    {\n-        if (!errors)\n-        {\n-            if (!tempdecl->literal)\n-                error(loc, \"error instantiating\");\n-            if (tinst)\n-                tinst->printInstantiationTrace();\n-        }\n-        errors = true;\n-        if (gagged)\n-        {\n-            // Errors are gagged, so remove the template instance from the\n-            // instance/symbol lists we added it to and reset our state to\n-            // finish clean and so we can try to instantiate it again later\n-            // (see bugzilla 4302 and 6602).\n-            tempdecl->removeInstance(tempdecl_instance_idx);\n-            if (target_symbol_list)\n-            {\n-                // Because we added 'this' in the last position above, we\n-                // should be able to remove it without messing other indices up.\n-                assert((*target_symbol_list)[target_symbol_list_idx] == this);\n-                target_symbol_list->remove(target_symbol_list_idx);\n-                memberOf = NULL;                    // no longer a member\n-            }\n-            semanticRun = PASSinit;\n-            inst = NULL;\n-            symtab = NULL;\n-        }\n-    }\n-    else if (errinst)\n-    {\n-        /* Bugzilla 14541: If the previous gagged instance had failed by\n-         * circular references, currrent \"error reproduction instantiation\"\n-         * might succeed, because of the difference of instantiated context.\n-         * On such case, the cached error instance needs to be overridden by the\n-         * succeeded instance.\n-         */\n-        //printf(\"replaceInstance()\\n\");\n-        TemplateInstances *tinstances = (TemplateInstances *)dmd_aaGetRvalue((AA *)tempdecl->instances, (void *)hash);\n-        assert(tinstances);\n-        for (size_t i = 0; i < tinstances->length; i++)\n-        {\n-            TemplateInstance *ti = (*tinstances)[i];\n-            if (ti == errinst)\n-            {\n-                (*tinstances)[i] = this;     // override\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-\n /**********************************************\n  * Find template declaration corresponding to template instance.\n  *\n@@ -6549,9 +5816,9 @@ bool TemplateInstance::findTempDecl(Scope *sc, WithScopeSymbol **pwithsym)\n         {\n             s = sc->search_correct(id);\n             if (s)\n-                error(\"template '%s' is not defined, did you mean %s?\", id->toChars(), s->toChars());\n+                error(\"template `%s` is not defined, did you mean %s?\", id->toChars(), s->toChars());\n             else\n-                error(\"template '%s' is not defined\", id->toChars());\n+                error(\"template `%s` is not defined\", id->toChars());\n             return false;\n         }\n \n@@ -6601,7 +5868,7 @@ bool TemplateInstance::findTempDecl(Scope *sc, WithScopeSymbol **pwithsym)\n             {\n                 // Try to fix forward reference. Ungag errors while doing so.\n                 Ungag ungag = td->ungagSpeculative();\n-                td->semantic(td->_scope);\n+                dsymbolSemantic(td, td->_scope);\n             }\n             if (td->semanticRun == PASSinit)\n             {\n@@ -6667,7 +5934,7 @@ bool TemplateInstance::updateTempDecl(Scope *sc, Dsymbol *s)\n             }\n             if (!s)\n             {\n-                error(\"template '%s' is not defined\", id->toChars());\n+                error(\"template `%s` is not defined\", id->toChars());\n                 return false;\n             }\n         }\n@@ -6827,7 +6094,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n             //printf(\"+[%d] ea = %s %s\\n\", j, Token::toChars(ea->op), ea->toChars());\n             if (flags & 1) // only used by __traits\n             {\n-                ea = ::semantic(ea, sc);\n+                ea = expressionSemantic(ea, sc);\n \n                 // must not interpret the args, excepting template parameters\n                 if (ea->op != TOKvar ||\n@@ -6839,7 +6106,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n             else\n             {\n                 sc = sc->startCTFE();\n-                ea = ::semantic(ea, sc);\n+                ea = expressionSemantic(ea, sc);\n                 sc = sc->endCTFE();\n \n                 if (ea->op == TOKvar)\n@@ -6966,7 +6233,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n             TemplateDeclaration *td = sa->isTemplateDeclaration();\n             if (td && td->semanticRun == PASSinit && td->literal)\n             {\n-                td->semantic(sc);\n+                dsymbolSemantic(td, sc);\n             }\n             FuncDeclaration *fd = sa->isFuncDeclaration();\n             if (fd)\n@@ -7286,7 +6553,7 @@ bool TemplateInstance::needsTypeInference(Scope *sc, int flag)\n                 {\n                     // Try to fix forward reference. Ungag errors while doing so.\n                     Ungag ungag = td->ungagSpeculative();\n-                    td->semantic(td->_scope);\n+                    dsymbolSemantic(td, td->_scope);\n                 }\n                 if (td->semanticRun == PASSinit)\n                 {\n@@ -7449,7 +6716,7 @@ bool TemplateInstance::hasNestedArgs(Objects *args, bool isstatic)\n                 }\n                 else\n                 {\n-                    error(\"cannot use local '%s' as parameter to non-global template %s\", sa->toChars(), tempdecl->toChars());\n+                    error(\"cannot use local `%s` as parameter to non-global template %s\", sa->toChars(), tempdecl->toChars());\n                     errors = true;\n                 }\n             }\n@@ -7588,111 +6855,6 @@ void TemplateInstance::declareParameters(Scope *sc)\n     }\n }\n \n-void TemplateInstance::semantic2(Scope *sc)\n-{\n-    if (semanticRun >= PASSsemantic2)\n-        return;\n-    semanticRun = PASSsemantic2;\n-    if (!errors && members)\n-    {\n-        TemplateDeclaration *tempdecl = this->tempdecl->isTemplateDeclaration();\n-        assert(tempdecl);\n-\n-        sc = tempdecl->_scope;\n-        assert(sc);\n-        sc = sc->push(argsym);\n-        sc = sc->push(this);\n-        sc->tinst = this;\n-        sc->minst = minst;\n-\n-        int needGagging = (gagged && !global.gag);\n-        unsigned int olderrors = global.errors;\n-        int oldGaggedErrors = -1;       // dead-store to prevent spurious warning\n-        if (needGagging)\n-            oldGaggedErrors = global.startGagging();\n-\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic2(sc);\n-            if (gagged && global.errors != olderrors)\n-                break;\n-        }\n-\n-        if (global.errors != olderrors)\n-        {\n-            if (!errors)\n-            {\n-                if (!tempdecl->literal)\n-                    error(loc, \"error instantiating\");\n-                if (tinst)\n-                    tinst->printInstantiationTrace();\n-            }\n-            errors = true;\n-        }\n-        if (needGagging)\n-            global.endGagging(oldGaggedErrors);\n-\n-        sc = sc->pop();\n-        sc->pop();\n-    }\n-}\n-\n-void TemplateInstance::semantic3(Scope *sc)\n-{\n-//if (toChars()[0] == 'D') *(char*)0=0;\n-    if (semanticRun >= PASSsemantic3)\n-        return;\n-    semanticRun = PASSsemantic3;\n-    if (!errors && members)\n-    {\n-        TemplateDeclaration *tempdecl = this->tempdecl->isTemplateDeclaration();\n-        assert(tempdecl);\n-\n-        sc = tempdecl->_scope;\n-        sc = sc->push(argsym);\n-        sc = sc->push(this);\n-        sc->tinst = this;\n-        sc->minst = minst;\n-\n-        int needGagging = (gagged && !global.gag);\n-        unsigned int olderrors = global.errors;\n-        int oldGaggedErrors = -1;       // dead-store to prevent spurious warning\n-        /* If this is a gagged instantiation, gag errors.\n-         * Future optimisation: If the results are actually needed, errors\n-         * would already be gagged, so we don't really need to run semantic\n-         * on the members.\n-         */\n-        if (needGagging)\n-            oldGaggedErrors = global.startGagging();\n-\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic3(sc);\n-            if (gagged && global.errors != olderrors)\n-                break;\n-        }\n-\n-        if (global.errors != olderrors)\n-        {\n-            if (!errors)\n-            {\n-                if (!tempdecl->literal)\n-                    error(loc, \"error instantiating\");\n-                if (tinst)\n-                    tinst->printInstantiationTrace();\n-            }\n-            errors = true;\n-        }\n-        if (needGagging)\n-            global.endGagging(oldGaggedErrors);\n-\n-        sc = sc->pop();\n-        sc->pop();\n-    }\n-}\n-\n /**************************************\n  * Given an error instantiating the TemplateInstance,\n  * give the nested TemplateInstance instantiations that got\n@@ -7781,7 +6943,7 @@ Dsymbol *TemplateInstance::toAlias()\n         // Maybe we can resolve it\n         if (_scope)\n         {\n-            semantic(_scope);\n+            dsymbolSemantic(this, _scope);\n         }\n         if (!inst)\n         {\n@@ -8209,7 +7371,7 @@ bool TemplateMixin::findTempDecl(Scope *sc)\n         if (td->semanticRun == PASSinit)\n         {\n             if (td->_scope)\n-                td->semantic(td->_scope);\n+                dsymbolSemantic(td, td->_scope);\n             else\n             {\n                 tm->semanticRun = PASSinit;\n@@ -8230,264 +7392,6 @@ bool TemplateMixin::findTempDecl(Scope *sc)\n     return true;\n }\n \n-void TemplateMixin::semantic(Scope *sc)\n-{\n-    if (semanticRun != PASSinit)\n-    {\n-        // When a class/struct contains mixin members, and is done over\n-        // because of forward references, never reach here so semanticRun\n-        // has been reset to PASSinit.\n-        return;\n-    }\n-    semanticRun = PASSsemantic;\n-\n-    Scope *scx = NULL;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        scx = _scope;            // save so we don't make redundant copies\n-        _scope = NULL;\n-    }\n-\n-    /* Run semantic on each argument, place results in tiargs[],\n-     * then find best match template with tiargs\n-     */\n-    if (!findTempDecl(sc) ||\n-        !semanticTiargs(sc) ||\n-        !findBestMatch(sc, NULL))\n-    {\n-        if (semanticRun == PASSinit)    // forward reference had occured\n-        {\n-            //printf(\"forward reference - deferring\\n\");\n-            _scope = scx ? scx : sc->copy();\n-            _scope->setNoFree();\n-            _scope->_module->addDeferredSemantic(this);\n-            return;\n-        }\n-\n-        inst = this;\n-        errors = true;\n-        return;         // error recovery\n-    }\n-    TemplateDeclaration *tempdecl = this->tempdecl->isTemplateDeclaration();\n-    assert(tempdecl);\n-\n-    if (!ident)\n-    {\n-        /* Assign scope local unique identifier, as same as lambdas.\n-         */\n-        const char *s = \"__mixin\";\n-\n-        DsymbolTable *symtab;\n-        if (FuncDeclaration *func = sc->parent->isFuncDeclaration())\n-        {\n-            symtab = func->localsymtab;\n-            if (symtab)\n-            {\n-                // Inside template constraint, symtab is not set yet.\n-                goto L1;\n-            }\n-        }\n-        else\n-        {\n-            symtab = sc->parent->isScopeDsymbol()->symtab;\n-        L1:\n-            assert(symtab);\n-            int num = (int)dmd_aaLen(symtab->tab) + 1;\n-            ident = Identifier::generateId(s, num);\n-            symtab->insert(this);\n-        }\n-    }\n-\n-    inst = this;\n-    parent = sc->parent;\n-\n-    /* Detect recursive mixin instantiations.\n-     */\n-    for (Dsymbol *s = parent; s; s = s->parent)\n-    {\n-        //printf(\"\\ts = '%s'\\n\", s->toChars());\n-        TemplateMixin *tm = s->isTemplateMixin();\n-        if (!tm || tempdecl != tm->tempdecl)\n-            continue;\n-\n-        /* Different argument list lengths happen with variadic args\n-         */\n-        if (tiargs->length != tm->tiargs->length)\n-            continue;\n-\n-        for (size_t i = 0; i < tiargs->length; i++)\n-        {\n-            RootObject *o = (*tiargs)[i];\n-            Type *ta = isType(o);\n-            Expression *ea = isExpression(o);\n-            Dsymbol *sa = isDsymbol(o);\n-            RootObject *tmo = (*tm->tiargs)[i];\n-            if (ta)\n-            {\n-                Type *tmta = isType(tmo);\n-                if (!tmta)\n-                    goto Lcontinue;\n-                if (!ta->equals(tmta))\n-                    goto Lcontinue;\n-            }\n-            else if (ea)\n-            {\n-                Expression *tme = isExpression(tmo);\n-                if (!tme || !ea->equals(tme))\n-                    goto Lcontinue;\n-            }\n-            else if (sa)\n-            {\n-                Dsymbol *tmsa = isDsymbol(tmo);\n-                if (sa != tmsa)\n-                    goto Lcontinue;\n-            }\n-            else\n-                assert(0);\n-        }\n-        error(\"recursive mixin instantiation\");\n-        return;\n-\n-    Lcontinue:\n-        continue;\n-    }\n-\n-    // Copy the syntax trees from the TemplateDeclaration\n-    members = Dsymbol::arraySyntaxCopy(tempdecl->members);\n-    if (!members)\n-        return;\n-\n-    symtab = new DsymbolTable();\n-\n-    for (Scope *sce = sc; 1; sce = sce->enclosing)\n-    {\n-        ScopeDsymbol *sds = (ScopeDsymbol *)sce->scopesym;\n-        if (sds)\n-        {\n-            sds->importScope(this, Prot(Prot::public_));\n-            break;\n-        }\n-    }\n-\n-    Scope *scy = sc->push(this);\n-    scy->parent = this;\n-\n-    argsym = new ScopeDsymbol();\n-    argsym->parent = scy->parent;\n-    Scope *argscope = scy->push(argsym);\n-\n-    unsigned errorsave = global.errors;\n-\n-    // Declare each template parameter as an alias for the argument type\n-    declareParameters(argscope);\n-\n-    // Add members to enclosing scope, as well as this scope\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->addMember(argscope, this);\n-        //printf(\"sc->parent = %p, sc->scopesym = %p\\n\", sc->parent, sc->scopesym);\n-        //printf(\"s->parent = %s\\n\", s->parent->toChars());\n-    }\n-\n-    // Do semantic() analysis on template instance members\n-    Scope *sc2 = argscope->push(this);\n-    //size_t deferred_dim = Module::deferred.length;\n-\n-    static int nest;\n-    //printf(\"%d\\n\", nest);\n-    if (++nest > global.recursionLimit)\n-    {\n-        global.gag = 0;                 // ensure error message gets printed\n-        error(\"recursive expansion\");\n-        fatal();\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->setScope(sc2);\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->importAll(sc2);\n-    }\n-\n-    for (size_t i = 0; i < members->length; i++)\n-    {\n-        Dsymbol *s = (*members)[i];\n-        s->semantic(sc2);\n-    }\n-\n-    nest--;\n-\n-    /* In DeclDefs scope, TemplateMixin does not have to handle deferred symbols.\n-     * Because the members would already call Module::addDeferredSemantic() for themselves.\n-     * See Struct, Class, Interface, and EnumDeclaration::semantic().\n-     */\n-    //if (!sc->func && Module::deferred.length > deferred_dim) {}\n-\n-    AggregateDeclaration *ad = toParent()->isAggregateDeclaration();\n-    if (sc->func && !ad)\n-    {\n-        semantic2(sc2);\n-        semantic3(sc2);\n-    }\n-\n-    // Give additional context info if error occurred during instantiation\n-    if (global.errors != errorsave)\n-    {\n-        error(\"error instantiating\");\n-        errors = true;\n-    }\n-\n-    sc2->pop();\n-    argscope->pop();\n-    scy->pop();\n-}\n-\n-void TemplateMixin::semantic2(Scope *sc)\n-{\n-    if (semanticRun >= PASSsemantic2)\n-        return;\n-    semanticRun = PASSsemantic2;\n-    if (members)\n-    {\n-        assert(sc);\n-        sc = sc->push(argsym);\n-        sc = sc->push(this);\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic2(sc);\n-        }\n-        sc = sc->pop();\n-        sc->pop();\n-    }\n-}\n-\n-void TemplateMixin::semantic3(Scope *sc)\n-{\n-    if (semanticRun >= PASSsemantic3)\n-        return;\n-    semanticRun = PASSsemantic3;\n-    if (members)\n-    {\n-        sc = sc->push(argsym);\n-        sc = sc->push(this);\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic3(sc);\n-        }\n-        sc = sc->pop();\n-        sc->pop();\n-    }\n-}\n-\n const char *TemplateMixin::kind() const\n {\n     return \"mixin\";\n@@ -8501,7 +7405,7 @@ bool TemplateMixin::oneMember(Dsymbol **ps, Identifier *ident)\n int TemplateMixin::apply(Dsymbol_apply_ft_t fp, void *param)\n {\n     if (_scope) // if fwd reference\n-        semantic(NULL); // try to resolve it\n+        dsymbolSemantic(this, NULL); // try to resolve it\n     if (members)\n     {\n         for (size_t i = 0; i < members->length; i++)\n@@ -8540,7 +7444,7 @@ void TemplateMixin::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset,\n {\n     //printf(\"TemplateMixin::setFieldOffset() %s\\n\", toChars());\n     if (_scope)                  // if fwd reference\n-        semantic(NULL);         // try to resolve it\n+        dsymbolSemantic(this, NULL);         // try to resolve it\n     if (members)\n     {\n         for (size_t i = 0; i < members->length; i++)"}, {"sha": "269d92466cdf3784177e959283176242919dd29d", "filename": "gcc/d/dmd/dversion.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fdversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdversion.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -97,13 +97,6 @@ void DebugSymbol::addMember(Scope *, ScopeDsymbol *sds)\n     }\n }\n \n-void DebugSymbol::semantic(Scope *)\n-{\n-    //printf(\"DebugSymbol::semantic() %s\\n\", toChars());\n-    if (semanticRun < PASSsemanticdone)\n-        semanticRun = PASSsemanticdone;\n-}\n-\n const char *DebugSymbol::kind() const\n {\n     return \"debug\";\n@@ -188,12 +181,6 @@ void VersionSymbol::addMember(Scope *, ScopeDsymbol *sds)\n     }\n }\n \n-void VersionSymbol::semantic(Scope *)\n-{\n-    if (semanticRun < PASSsemanticdone)\n-        semanticRun = PASSsemanticdone;\n-}\n-\n const char *VersionSymbol::kind() const\n {\n     return \"version\";"}, {"sha": "cac901d1a6e9ea9c3a86ec0ebcb754e9bf01c9b7", "filename": "gcc/d/dmd/entity.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fentity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fentity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fentity.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "ae5ea214a735e04497fa2f9573b99b29aa59ff6e", "filename": "gcc/d/dmd/enum.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fenum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fenum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fenum.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -47,7 +47,6 @@ class EnumDeclaration : public ScopeDsymbol\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n-    void semantic(Scope *sc);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     Type *getType();\n     const char *kind() const;\n@@ -89,7 +88,6 @@ class EnumMember : public VarDeclaration\n         StorageClass stc, UserAttributeDeclaration *uad, DeprecatedDeclaration *dd);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     const char *kind() const;\n-    void semantic(Scope *sc);\n     Expression *getVarExp(Loc loc, Scope *sc);\n \n     EnumMember *isEnumMember() { return this; }"}, {"sha": "a92ae2abbc4c2d78c9dfc17c694949e00adf9cb4", "filename": "gcc/d/dmd/errors.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ferrors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ferrors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ferrors.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "cd0382b0a22cdf27266160285ce77a114053fd0e", "filename": "gcc/d/dmd/escape.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fescape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fescape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "c90392d16a283c313d3b7f4fb39c7a66e1307422", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 95, "deletions": 100, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -45,11 +45,6 @@ char *MODtoChars(MOD mod);\n bool MODimplicitConv(MOD modfrom, MOD modto);\n MOD MODmerge(MOD mod1, MOD mod2);\n void MODMatchToBuffer(OutBuffer *buf, unsigned char lhsMod, unsigned char rhsMod);\n-Expression *trySemantic(Expression *e, Scope *sc);\n-Expression *semantic(Expression *e, Scope *sc);\n-Expression *semanticX(DotIdExp *exp, Scope *sc);\n-Expression *semanticY(DotIdExp *exp, Scope *sc, int flag);\n-Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n bool checkUnsafeAccess(Scope *sc, Expression *e, bool readonly, bool printmsg);\n \n@@ -103,7 +98,7 @@ Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad,\n                 e1->type = tcd->vthis->type;\n                 e1->type = e1->type->addMod(t->mod);\n                 // Do not call checkNestedRef()\n-                //e1 = semantic(e1, sc);\n+                //e1 = expressionSemantic(e1, sc);\n \n                 // Skip up over nested functions, and get the enclosing\n                 // class type.\n@@ -122,7 +117,7 @@ Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad,\n                     }\n                     else\n                     {\n-                        e1->error(\"need 'this' of type %s to access member %s\"\n+                        e1->error(\"need `this` of type %s to access member %s\"\n                                   \" from static function %s\",\n                             ad->toChars(), var->toChars(), f->toChars());\n                         e1 = new ErrorExp();\n@@ -134,10 +129,10 @@ Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad,\n                     e1->type = s->isClassDeclaration()->type;\n                     e1->type = e1->type->addMod(t->mod);\n                     if (n > 1)\n-                        e1 = semantic(e1, sc);\n+                        e1 = expressionSemantic(e1, sc);\n                 }\n                 else\n-                    e1 = semantic(e1, sc);\n+                    e1 = expressionSemantic(e1, sc);\n                 goto L1;\n             }\n \n@@ -269,7 +264,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n         FuncDeclaration *fd = NULL;\n         if (e2)\n         {\n-            e2 = semantic(e2, sc);\n+            e2 = expressionSemantic(e2, sc);\n             if (e2->op == TOKerror)\n                 return new ErrorExp();\n             e2 = resolveProperties(sc, e2);\n@@ -291,7 +286,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n             if (fd)\n             {\n                 Expression *e = new CallExp(loc, e1, e2);\n-                return semantic(e, sc);\n+                return expressionSemantic(e, sc);\n             }\n         }\n         {\n@@ -314,7 +309,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n                 Expression *e = new CallExp(loc, e1);\n                 if (e2)\n                     e = new AssignExp(loc, e, e2);\n-                return semantic(e, sc);\n+                return expressionSemantic(e, sc);\n             }\n         }\n         if (e2)\n@@ -383,7 +378,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n         assert(s);\n         if (e2)\n         {\n-            e2 = semantic(e2, sc);\n+            e2 = expressionSemantic(e2, sc);\n             if (e2->op == TOKerror)\n                 return new ErrorExp();\n             e2 = resolveProperties(sc, e2);\n@@ -398,7 +393,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n                     return new ErrorExp();\n                 assert(fd->type->ty == Tfunction);\n                 Expression *e = new CallExp(loc, e1, e2);\n-                return semantic(e, sc);\n+                return expressionSemantic(e, sc);\n             }\n         }\n         {\n@@ -414,7 +409,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n                     Expression *e = new CallExp(loc, e1);\n                     if (e2)\n                         e = new AssignExp(loc, e, e2);\n-                    return semantic(e, sc);\n+                    return expressionSemantic(e, sc);\n                 }\n             }\n         }\n@@ -423,7 +418,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n             // Keep better diagnostic message for invalid property usage of functions\n             assert(fd->type->ty == Tfunction);\n             Expression *e = new CallExp(loc, e1, e2);\n-            return semantic(e, sc);\n+            return expressionSemantic(e, sc);\n         }\n         if (e2)\n             goto Leprop;\n@@ -450,7 +445,7 @@ Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL)\n             if (ve->var->storage_class & STClazy)\n             {\n                 Expression *e = new CallExp(loc, e1);\n-                return semantic(e, sc);\n+                return expressionSemantic(e, sc);\n             }\n         }\n         else if (e1->op == TOKdotvar)\n@@ -518,7 +513,7 @@ static bool checkPropertyCall(Expression *e)\n              */\n             if (!tf->deco && ce->f->semanticRun < PASSsemanticdone)\n             {\n-                ce->f->semantic(NULL);\n+                dsymbolSemantic(ce->f, NULL);\n                 tf = (TypeFunction *)ce->f->type;\n             }\n         }\n@@ -787,7 +782,7 @@ Expression *resolveUFCS(Scope *sc, CallExp *ce)\n                     return new ErrorExp();\n                 }\n                 Expression *key = (*ce->arguments)[0];\n-                key = semantic(key, sc);\n+                key = expressionSemantic(key, sc);\n                 key = resolveProperties(sc, key);\n \n                 TypeAArray *taa = (TypeAArray *)t;\n@@ -811,7 +806,7 @@ Expression *resolveUFCS(Scope *sc, CallExp *ce)\n                 if (isDotOpDispatch(ey))\n                 {\n                     unsigned errors = global.startGagging();\n-                    e = semantic(ce->syntaxCopy(), sc);\n+                    e = expressionSemantic(ce->syntaxCopy(), sc);\n                     if (!global.endGagging(errors))\n                         return e;\n                     /* fall down to UFCS */\n@@ -878,7 +873,7 @@ Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NU\n     if (e2)\n     {\n         // run semantic without gagging\n-        e2 = semantic(e2, sc);\n+        e2 = expressionSemantic(e2, sc);\n \n         /* f(e1) = e2\n          */\n@@ -902,12 +897,12 @@ Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NU\n             if (!e)\n             {   checkPropertyCall(ex);\n                 ex = new AssignExp(loc, ex, e2);\n-                return semantic(ex, sc);\n+                return expressionSemantic(ex, sc);\n             }\n         }\n         else\n         {   // strict setter prints errors if fails\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n         }\n         checkPropertyCall(e);\n         return e;\n@@ -920,9 +915,9 @@ Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NU\n         arguments->setDim(1);\n         (*arguments)[0] = eleft;\n         e = new CallExp(loc, e, arguments);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         checkPropertyCall(e);\n-        return semantic(e, sc);\n+        return expressionSemantic(e, sc);\n     }\n }\n \n@@ -940,7 +935,7 @@ bool arrayExpressionSemantic(Expressions *exps, Scope *sc, bool preserveErrors)\n             Expression *e = (*exps)[i];\n             if (e)\n             {\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 if (e->op == TOKerror)\n                     err = true;\n                 if (preserveErrors || e->op != TOKerror)\n@@ -1137,7 +1132,7 @@ bool arrayExpressionToCommonType(Scope *sc, Expressions *exps, Type **pt)\n             condexp.e1 = e0;\n             condexp.e2 = e;\n             condexp.loc = e->loc;\n-            Expression *ex = semantic(&condexp, sc);\n+            Expression *ex = expressionSemantic(&condexp, sc);\n             if (ex->op == TOKerror)\n                 e = ex;\n             else\n@@ -1298,7 +1293,7 @@ Expression *callCpCtor(Scope *sc, Expression *e)\n              */\n             VarDeclaration *tmp = copyToTemp(STCrvalue, \"__copytmp\", e);\n             tmp->storage_class |= STCnodtor;\n-            tmp->semantic(sc);\n+            dsymbolSemantic(tmp, sc);\n             Expression *de = new DeclarationExp(e->loc, tmp);\n             Expression *ve = new VarExp(e->loc, tmp);\n             de->type = Type::tvoid;\n@@ -1508,7 +1503,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                         }\n                         break;\n                 }\n-                arg = semantic(arg, sc);\n+                arg = expressionSemantic(arg, sc);\n                 //printf(\"\\targ = '%s'\\n\", arg->toChars());\n                 arguments->setDim(i + 1);\n                 (*arguments)[i] =  arg;\n@@ -1810,10 +1805,10 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n             Identifier *idtmp = Identifier::generateId(\"__gate\");\n             gate = new VarDeclaration(loc, Type::tbool, idtmp, NULL);\n             gate->storage_class |= STCtemp | STCctfe | STCvolatile;\n-            gate->semantic(sc);\n+            dsymbolSemantic(gate, sc);\n \n             Expression *ae = new DeclarationExp(loc, gate);\n-            eprefix = semantic(ae, sc);\n+            eprefix = expressionSemantic(ae, sc);\n         }\n \n         for (ptrdiff_t i = start; i != end; i += step)\n@@ -1844,7 +1839,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                 VarDeclaration *tmp = copyToTemp(0,\n                     needsDtor ? \"__pfx\" : \"__pfy\",\n                     !isRef ? arg : arg->addressOf());\n-                tmp->semantic(sc);\n+                dsymbolSemantic(tmp, sc);\n \n                 /* Modify the destructor so it only runs if gate==false, i.e.,\n                  * only if there was a throw while constructing the args\n@@ -1863,21 +1858,21 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                     assert(tmp->edtor);\n                     Expression *e = tmp->edtor;\n                     e = new LogicalExp(e->loc, TOKoror, new VarExp(e->loc, gate), e);\n-                    tmp->edtor = semantic(e, sc);\n+                    tmp->edtor = expressionSemantic(e, sc);\n                     //printf(\"edtor: %s\\n\", tmp->edtor->toChars());\n                 }\n \n                 // eprefix => (eprefix, auto __pfx/y = arg)\n                 DeclarationExp *ae = new DeclarationExp(loc, tmp);\n-                eprefix = Expression::combine(eprefix, semantic(ae, sc));\n+                eprefix = Expression::combine(eprefix, expressionSemantic(ae, sc));\n \n                 // arg => __pfx/y\n                 arg = new VarExp(loc, tmp);\n-                arg = semantic(arg, sc);\n+                arg = expressionSemantic(arg, sc);\n                 if (isRef)\n                 {\n                     arg = new PtrExp(loc, arg);\n-                    arg = semantic(arg, sc);\n+                    arg = expressionSemantic(arg, sc);\n                 }\n \n                 /* Last throwing arg? Then finalize eprefix => (eprefix, gate = true),\n@@ -1891,7 +1886,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n                 if (i == lastthrow)\n                 {\n                     Expression *e = new AssignExp(gate->loc, new VarExp(gate->loc, gate), new IntegerExp(gate->loc, 1, Type::tbool));\n-                    eprefix = Expression::combine(eprefix, semantic(e, sc));\n+                    eprefix = Expression::combine(eprefix, expressionSemantic(e, sc));\n                     gate = NULL;\n                 }\n             }\n@@ -1926,7 +1921,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,\n \n         TypeTuple *tup = new TypeTuple(args);\n         Expression *e = new TypeidExp(loc, tup);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         arguments->insert(0, e);\n     }\n \n@@ -2179,7 +2174,7 @@ Expression *Expression::toLvalue(Scope *, Expression *e)\n         loc = e->loc;\n \n     if (e->op == TOKtype)\n-        error(\"%s '%s' is a type, not an lvalue\", e->type->kind(), e->type->toChars());\n+        error(\"%s `%s` is a type, not an lvalue\", e->type->kind(), e->type->toChars());\n     else\n         error(\"%s is not an lvalue\", e->toChars());\n \n@@ -2263,7 +2258,7 @@ bool Expression::checkScalar()\n         return true;\n     if (!type->isscalar())\n     {\n-        error(\"'%s' is not a scalar, it is a %s\", toChars(), type->toChars());\n+        error(\"`%s` is not a scalar, it is a %s\", toChars(), type->toChars());\n         return true;\n     }\n     return checkValue();\n@@ -2277,7 +2272,7 @@ bool Expression::checkNoBool()\n         return true;\n     if (type->toBasetype()->ty == Tbool)\n     {\n-        error(\"operation not allowed on bool '%s'\", toChars());\n+        error(\"operation not allowed on bool `%s`\", toChars());\n         return true;\n     }\n     return false;\n@@ -2291,7 +2286,7 @@ bool Expression::checkIntegral()\n         return true;\n     if (!type->isintegral())\n     {\n-        error(\"'%s' is not of integral type, it is a %s\", toChars(), type->toChars());\n+        error(\"`%s` is not of integral type, it is a %s\", toChars(), type->toChars());\n         return true;\n     }\n     return checkValue();\n@@ -2305,7 +2300,7 @@ bool Expression::checkArithmetic()\n         return true;\n     if (!type->isintegral() && !type->isfloating())\n     {\n-        error(\"'%s' is not of arithmetic type, it is a %s\", toChars(), type->toChars());\n+        error(\"`%s` is not of arithmetic type, it is a %s\", toChars(), type->toChars());\n         return true;\n     }\n     return checkValue();\n@@ -2413,7 +2408,7 @@ bool Expression::checkPurity(Scope *sc, FuncDeclaration *f)\n         FuncDeclaration *ff = outerfunc;\n         if (sc->flags & SCOPEcompile ? ff->isPureBypassingInference() >= PUREweak : ff->setImpure())\n         {\n-            error(\"pure %s '%s' cannot call impure %s '%s'\",\n+            error(\"pure %s `%s` cannot call impure %s `%s`\",\n                 ff->kind(), ff->toPrettyChars(), f->kind(), f->toPrettyChars());\n             return true;\n         }\n@@ -2478,7 +2473,7 @@ bool Expression::checkPurity(Scope *sc, VarDeclaration *v)\n                 break;\n             if (sc->flags & SCOPEcompile ? ff->isPureBypassingInference() >= PUREweak : ff->setImpure())\n             {\n-                error(\"pure %s '%s' cannot access mutable static data '%s'\",\n+                error(\"pure %s `%s` cannot access mutable static data `%s`\",\n                     ff->kind(), ff->toPrettyChars(), v->toChars());\n                 err = true;\n                 break;\n@@ -2532,7 +2527,7 @@ bool Expression::checkPurity(Scope *sc, VarDeclaration *v)\n                     OutBuffer vbuf;\n                     MODMatchToBuffer(&ffbuf, ff->type->mod, v->type->mod);\n                     MODMatchToBuffer(&vbuf, v->type->mod, ff->type->mod);\n-                    error(\"%s%s '%s' cannot access %sdata '%s'\",\n+                    error(\"%s%s `%s` cannot access %sdata `%s`\",\n                         ffbuf.peekChars(), ff->kind(), ff->toPrettyChars(), vbuf.peekChars(), v->toChars());\n                     err = true;\n                     break;\n@@ -2549,7 +2544,7 @@ bool Expression::checkPurity(Scope *sc, VarDeclaration *v)\n     {\n         if (sc->func->setUnsafe())\n         {\n-            error(\"safe %s '%s' cannot access __gshared data '%s'\",\n+            error(\"safe %s `%s` cannot access __gshared data `%s`\",\n                 sc->func->kind(), sc->func->toChars(), v->toChars());\n             err = true;\n         }\n@@ -2582,7 +2577,7 @@ bool Expression::checkSafety(Scope *sc, FuncDeclaration *f)\n             if (loc.linnum == 0)  // e.g. implicitly generated dtor\n                 loc = sc->func->loc;\n \n-            error(\"@safe %s '%s' cannot call @system %s '%s'\",\n+            error(\"@safe %s `%s` cannot call @system %s `%s`\",\n                 sc->func->kind(), sc->func->toPrettyChars(), f->kind(), f->toPrettyChars());\n             return true;\n         }\n@@ -2614,7 +2609,7 @@ bool Expression::checkNogc(Scope *sc, FuncDeclaration *f)\n             if (loc.linnum == 0)  // e.g. implicitly generated dtor\n                 loc = sc->func->loc;\n \n-            error(\"@nogc %s '%s' cannot call non-@nogc %s '%s'\",\n+            error(\"@nogc %s `%s` cannot call non-@nogc %s `%s`\",\n                 sc->func->kind(), sc->func->toPrettyChars(), f->kind(), f->toPrettyChars());\n             return true;\n         }\n@@ -2661,7 +2656,7 @@ bool Expression::checkRightThis(Scope *sc)\n         {\n             //printf(\"checkRightThis sc->intypeof = %d, ad = %p, func = %p, fdthis = %p\\n\",\n             //        sc->intypeof, sc->getStructClassScope(), func, fdthis);\n-            error(\"need 'this' for '%s' of type '%s'\", ve->var->toChars(), ve->var->type->toChars());\n+            error(\"need `this` for `%s` of type `%s`\", ve->var->toChars(), ve->var->type->toChars());\n             return true;\n         }\n     }\n@@ -2729,7 +2724,7 @@ Expression *Expression::toBoolean(Scope *sc)\n         if (fd)\n         {\n             e = new CastExp(loc, e, Type::tbool);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n \n@@ -3717,9 +3712,9 @@ Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads)\n             (!v->type->deco && v->inuse))  // during variable type semantic\n         {\n             if (v->inuse)    // variable type depends on the variable itself\n-                ::error(loc, \"circular reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                ::error(loc, \"circular reference to %s `%s`\", v->kind(), v->toPrettyChars());\n             else             // variable type cannot be determined\n-                ::error(loc, \"forward reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                ::error(loc, \"forward reference to %s `%s`\", v->kind(), v->toPrettyChars());\n             return new ErrorExp();\n         }\n         if (v->type->ty == Terror)\n@@ -3729,13 +3724,13 @@ Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads)\n         {\n             if (v->inuse)\n             {\n-                ::error(loc, \"circular initialization of %s '%s'\", v->kind(), v->toPrettyChars());\n+                ::error(loc, \"circular initialization of %s `%s`\", v->kind(), v->toPrettyChars());\n                 return new ErrorExp();\n             }\n \n             e = v->expandInitializer(loc);\n             v->inuse++;\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             v->inuse--;\n             return e;\n         }\n@@ -3748,14 +3743,14 @@ Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads)\n             e = new DotVarExp(loc, new ThisExp(loc), v);\n         else\n             e = new VarExp(loc, v);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     if (FuncLiteralDeclaration *fld = s->isFuncLiteralDeclaration())\n     {\n         //printf(\"'%s' is a function literal\\n\", fld->toChars());\n         e = new FuncExp(loc, fld);\n-        return semantic(e, sc);\n+        return expressionSemantic(e, sc);\n     }\n     if (FuncDeclaration *f = s->isFuncDeclaration())\n     {\n@@ -3790,28 +3785,28 @@ Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads)\n             return new ErrorExp();\n         }\n         ScopeExp *ie = new ScopeExp(loc, imp->pkg);\n-        return semantic(ie, sc);\n+        return expressionSemantic(ie, sc);\n     }\n     if (Package *pkg = s->isPackage())\n     {\n         ScopeExp *ie = new ScopeExp(loc, pkg);\n-        return semantic(ie, sc);\n+        return expressionSemantic(ie, sc);\n     }\n     if (Module *mod = s->isModule())\n     {\n         ScopeExp *ie = new ScopeExp(loc, mod);\n-        return semantic(ie, sc);\n+        return expressionSemantic(ie, sc);\n     }\n \n     if (Nspace *ns = s->isNspace())\n     {\n         ScopeExp *ie = new ScopeExp(loc, ns);\n-        return semantic(ie, sc);\n+        return expressionSemantic(ie, sc);\n     }\n \n     if (Type *t = s->getType())\n     {\n-        return semantic(new TypeExp(loc, t), sc);\n+        return expressionSemantic(new TypeExp(loc, t), sc);\n     }\n \n     if (TupleDeclaration *tup = s->isTupleDeclaration())\n@@ -3820,20 +3815,20 @@ Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads)\n             e = new DotVarExp(loc, new ThisExp(loc), tup);\n         else\n             e = new TupleExp(loc, tup);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n \n     if (TemplateInstance *ti = s->isTemplateInstance())\n     {\n-        ti->semantic(sc);\n+        dsymbolSemantic(ti, sc);\n         if (!ti->inst || ti->errors)\n             return new ErrorExp();\n         s = ti->toAlias();\n         if (!s->isTemplateInstance())\n             goto Lagain;\n         e = new ScopeExp(loc, ti);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     if (TemplateDeclaration *td = s->isTemplateDeclaration())\n@@ -3848,11 +3843,11 @@ Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads)\n         }\n         else\n             e = new TemplateExp(loc, td);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n \n-    ::error(loc, \"%s '%s' is not a variable\", s->kind(), s->toChars());\n+    ::error(loc, \"%s `%s` is not a variable\", s->kind(), s->toChars());\n     return new ErrorExp();\n }\n \n@@ -4553,7 +4548,7 @@ Expression *StructLiteralExp::addDtorHook(Scope *sc)\n         VarDeclaration *tmp = copyToTemp(0, buf, this);\n         Expression *ae = new DeclarationExp(loc, tmp);\n         Expression *e = new CommaExp(loc, ae, new VarExp(loc, tmp));\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     return this;\n@@ -4850,7 +4845,7 @@ SymOffExp::SymOffExp(Loc loc, Declaration *var, dinteger_t offset, bool hasOverl\n         // FIXME: This error report will never be handled anyone.\n         // It should be done before the SymOffExp construction.\n         if (v->needThis())\n-            ::error(loc, \"need 'this' for address of %s\", v->toChars());\n+            ::error(loc, \"need `this` for address of %s\", v->toChars());\n     }\n     this->offset = offset;\n }\n@@ -4903,7 +4898,7 @@ Expression *VarExp::toLvalue(Scope *, Expression *)\n {\n     if (var->storage_class & STCmanifest)\n     {\n-        error(\"manifest constant '%s' is not lvalue\", var->toChars());\n+        error(\"manifest constant `%s` is not lvalue\", var->toChars());\n         return new ErrorExp();\n     }\n     if (var->storage_class & STClazy)\n@@ -4918,7 +4913,7 @@ Expression *VarExp::toLvalue(Scope *, Expression *)\n     }\n     if (var->ident == Id::dollar)   // Bugzilla 13574\n     {\n-        error(\"'$' is not an lvalue\");\n+        error(\"`$` is not an lvalue\");\n         return new ErrorExp();\n     }\n     return this;\n@@ -4936,7 +4931,7 @@ Expression *VarExp::modifiableLvalue(Scope *sc, Expression *e)\n     //printf(\"VarExp::modifiableLvalue('%s')\\n\", var->toChars());\n     if (var->storage_class & STCmanifest)\n     {\n-        error(\"cannot modify manifest constant '%s'\", toChars());\n+        error(\"cannot modify manifest constant `%s`\", toChars());\n         return new ErrorExp();\n     }\n     // See if this expression is a modifiable lvalue (i.e. not const)\n@@ -5146,7 +5141,7 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n         if (tok == TOKfunction)\n         {\n             if (!flag)\n-                error(\"cannot match function literal to delegate type '%s'\", to->toChars());\n+                error(\"cannot match function literal to delegate type `%s`\", to->toChars());\n             return MATCHnomatch;\n         }\n         tof = (TypeFunction *)to->nextOf();\n@@ -5156,7 +5151,7 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n         if (tok == TOKdelegate)\n         {\n             if (!flag)\n-                error(\"cannot match delegate literal to function pointer type '%s'\", to->toChars());\n+                error(\"cannot match delegate literal to function pointer type `%s`\", to->toChars());\n             return MATCHnomatch;\n         }\n         tof = (TypeFunction *)to->nextOf();\n@@ -5213,7 +5208,7 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)\n \n         TemplateInstance *ti = new TemplateInstance(loc, td, tiargs);\n         Expression *ex = new ScopeExp(loc, ti);\n-        ex = ::semantic(ex, td->_scope);\n+        ex = expressionSemantic(ex, td->_scope);\n \n         // Reset inference target for the later re-semantic\n         fd->treq = NULL;\n@@ -5453,12 +5448,12 @@ Expression *UnaExp::incompatibleTypes()\n \n     if (e1->op == TOKtype)\n     {\n-        error(\"incompatible type for (%s(%s)): cannot use '%s' with types\",\n+        error(\"incompatible type for (%s(%s)): cannot use `%s` with types\",\n               Token::toChars(op), e1->toChars(), Token::toChars(op));\n     }\n     else\n     {\n-        error(\"incompatible type for (%s(%s)): '%s'\",\n+        error(\"incompatible type for (%s(%s)): `%s`\",\n               Token::toChars(op), e1->toChars(), e1->type->toChars());\n     }\n     return new ErrorExp();\n@@ -5646,12 +5641,12 @@ Expression *BinExp::incompatibleTypes()\n     TOK thisOp = (op == TOKquestion) ? TOKcolon : op;\n     if (e1->op == TOKtype || e2->op == TOKtype)\n     {\n-        error(\"incompatible types for ((%s) %s (%s)): cannot use '%s' with types\",\n+        error(\"incompatible types for ((%s) %s (%s)): cannot use `%s` with types\",\n             e1->toChars(), Token::toChars(thisOp), e2->toChars(), Token::toChars(op));\n     }\n     else\n     {\n-        error(\"incompatible types for ((%s) %s (%s)): '%s' and '%s'\",\n+        error(\"incompatible types for ((%s) %s (%s)): `%s` and `%s`\",\n             e1->toChars(), Token::toChars(thisOp), e2->toChars(),\n             e1->type->toChars(), e2->type->toChars());\n     }\n@@ -5820,7 +5815,7 @@ int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\n                     else\n                     {\n                         const char *modStr = !var->type->isMutable() ? MODtoChars(var->type->mod) : MODtoChars(e1->type->mod);\n-                        ::error(loc, \"%s field '%s' initialized multiple times\", modStr, var->toChars());\n+                        ::error(loc, \"%s field `%s` initialized multiple times\", modStr, var->toChars());\n                     }\n                 }\n                 else if (sc->noctor || (fi & CSXlabel))\n@@ -5830,7 +5825,7 @@ int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\n                     else\n                     {\n                         const char *modStr = !var->type->isMutable() ? MODtoChars(var->type->mod) : MODtoChars(e1->type->mod);\n-                        ::error(loc, \"%s field '%s' initialization is not allowed in loops or after labels\", modStr, var->toChars());\n+                        ::error(loc, \"%s field `%s` initialization is not allowed in loops or after labels\", modStr, var->toChars());\n                     }\n                 }\n                 sc->fieldinit[i] |= CSXthis_ctor;\n@@ -5853,13 +5848,13 @@ int modifyFieldVar(Loc loc, Scope *sc, VarDeclaration *var, Expression *e1)\n                 else if (sc->func->fes)\n                 {\n                     const char *p = var->isField() ? \"field\" : var->kind();\n-                    ::error(loc, \"%s %s '%s' initialization is not allowed in foreach loop\",\n+                    ::error(loc, \"%s %s `%s` initialization is not allowed in foreach loop\",\n                         MODtoChars(var->type->mod), p, var->toChars());\n                 }\n                 else\n                 {\n                     const char *p = var->isField() ? \"field\" : var->kind();\n-                    ::error(loc, \"%s %s '%s' initialization is not allowed in nested function '%s'\",\n+                    ::error(loc, \"%s %s `%s` initialization is not allowed in nested function `%s`\",\n                         MODtoChars(var->type->mod), p, var->toChars(), sc->func->toChars());\n                 }\n             }\n@@ -5930,7 +5925,7 @@ bool DotTemplateInstanceExp::findTempDecl(Scope *sc)\n         return true;\n \n     Expression *e = new DotIdExp(loc, e1, ti->name);\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     if (e->op == TOKdot)\n         e = ((DotExp *)e)->e2;\n \n@@ -6079,7 +6074,7 @@ Expression *CallExp::addDtorHook(Scope *sc)\n             DeclarationExp *de = new DeclarationExp(loc, tmp);\n             VarExp *ve = new VarExp(loc, tmp);\n             Expression *e = new CommaExp(loc, de, ve);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n     }\n@@ -7062,10 +7057,10 @@ void CondExp::hookDtors(Scope *sc)\n                     if (!vcond)\n                     {\n                         vcond = copyToTemp(STCvolatile, \"__cond\", ce->econd);\n-                        vcond->semantic(sc);\n+                        dsymbolSemantic(vcond, sc);\n \n                         Expression *de = new DeclarationExp(ce->econd->loc, vcond);\n-                        de = semantic(de, sc);\n+                        de = expressionSemantic(de, sc);\n \n                         Expression *ve = new VarExp(ce->econd->loc, vcond);\n                         ce->econd = Expression::combine(de, ve);\n@@ -7077,7 +7072,7 @@ void CondExp::hookDtors(Scope *sc)\n                         v->edtor = new LogicalExp(v->edtor->loc, TOKandand, ve, v->edtor);\n                     else\n                         v->edtor = new LogicalExp(v->edtor->loc, TOKoror, ve, v->edtor);\n-                    v->edtor = semantic(v->edtor, sc);\n+                    v->edtor = expressionSemantic(v->edtor, sc);\n                     //printf(\"\\t--v = %s, v->edtor = %s\\n\", v->toChars(), v->edtor->toChars());\n                 }\n             }\n@@ -7158,7 +7153,7 @@ Expression *FileInitExp::resolveLoc(Loc loc, Scope *sc)\n         s = loc.filename != NULL ? loc.filename : sc->_module->ident->toChars();\n \n     Expression *e = new StringExp(loc, const_cast<char *>(s));\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     e = e->castTo(sc, type);\n     return e;\n }\n@@ -7192,7 +7187,7 @@ Expression *ModuleInitExp::resolveLoc(Loc loc, Scope *sc)\n     else\n         s = sc->_module->toPrettyChars();\n     Expression *e = new StringExp(loc, const_cast<char *>(s));\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     e = e->castTo(sc, type);\n     return e;\n }\n@@ -7214,7 +7209,7 @@ Expression *FuncInitExp::resolveLoc(Loc loc, Scope *sc)\n     else\n         s = \"\";\n     Expression *e = new StringExp(loc, const_cast<char *>(s));\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     e = e->castTo(sc, type);\n     return e;\n }\n@@ -7248,7 +7243,7 @@ Expression *PrettyFuncInitExp::resolveLoc(Loc loc, Scope *sc)\n     }\n \n     Expression *e = new StringExp(loc, const_cast<char *>(s));\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     e = e->castTo(sc, type);\n     return e;\n }\n@@ -7318,14 +7313,14 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n         ae->lengthVar = NULL;       // Create it only if required\n         ae->currentDimension = i;   // Dimension for $, if required\n \n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         e = resolveProperties(sc, e);\n \n         if (ae->lengthVar && sc->func)\n         {\n             // If $ was used, declare it now\n             Expression *de = new DeclarationExp(ae->loc, ae->lengthVar);\n-            de = semantic(de, sc);\n+            de = expressionSemantic(de, sc);\n             *pe0 = Expression::combine(*pe0, de);\n         }\n         sc = sc->pop();\n@@ -7336,7 +7331,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n \n             Objects *tiargs = new Objects();\n             Expression *edim = new IntegerExp(ae->loc, i, Type::tsize_t);\n-            edim = semantic(edim, sc);\n+            edim = expressionSemantic(edim, sc);\n             tiargs->push(edim);\n \n             Expressions *fargs = new Expressions();\n@@ -7353,7 +7348,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n \n             e = new DotTemplateInstanceExp(ae->loc, ae->e1, slice->ident, tiargs);\n             e = new CallExp(ae->loc, e, fargs);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n         }\n \n         if (!e->type)\n@@ -7382,7 +7377,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, Expression **pe0)\n StringExp *semanticString(Scope *sc, Expression *exp, const char *s)\n {\n     sc = sc->startCTFE();\n-    exp = semantic(exp, sc);\n+    exp = expressionSemantic(exp, sc);\n     exp = resolveProperties(sc, exp);\n     sc = sc->endCTFE();\n \n@@ -7428,7 +7423,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, IntervalExp *ie, Expression\n     for (size_t i = 0; i < 2; ++i)\n     {\n         Expression *e = i == 0 ? ie->lwr : ie->upr;\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         e = resolveProperties(sc, e);\n         if (!e->type)\n         {\n@@ -7442,7 +7437,7 @@ Expression *resolveOpDollar(Scope *sc, ArrayExp *ae, IntervalExp *ie, Expression\n     {\n         // If $ was used, declare it now\n         Expression *de = new DeclarationExp(ae->loc, ae->lengthVar);\n-        de = semantic(de, sc);\n+        de = expressionSemantic(de, sc);\n         *pe0 = Expression::combine(*pe0, de);\n     }\n     sc = sc->pop();"}, {"sha": "f0ae2805df453f59fd586c838f866c65b87ed67f", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -43,6 +43,9 @@ class TemplateInstance;\n class TemplateDeclaration;\n class ClassDeclaration;\n class BinExp;\n+class UnaExp;\n+class DotIdExp;\n+class DotTemplateInstanceExp;\n class OverloadSet;\n class Initializer;\n class StringExp;\n@@ -55,6 +58,16 @@ typedef union tree_node Symbol;\n struct Symbol;          // back end symbol\n #endif\n \n+Expression *expressionSemantic(Expression *e, Scope *sc);\n+Expression *semanticX(DotIdExp *exp, Scope *sc);\n+Expression *semanticY(DotIdExp *exp, Scope *sc, int flag);\n+Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag);\n+Expression *trySemantic(Expression *e, Scope *sc);\n+Expression *unaSemantic(UnaExp *e, Scope *sc);\n+Expression *binSemantic(BinExp *e, Scope *sc);\n+Expression *binSemanticProp(BinExp *e, Scope *sc);\n+StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n+\n Expression *resolveProperties(Scope *sc, Expression *e);\n Expression *resolvePropertiesOnly(Scope *sc, Expression *e1);\n bool checkAccess(Loc loc, Scope *sc, Expression *e, Declaration *d);"}, {"sha": "7cccd95696647559f0b350fa4b8411c04cbf0644", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 227, "deletions": 236, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -67,15 +67,6 @@ Expression *callCpCtor(Scope *sc, Expression *e);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n Expression *resolveUFCSProperties(Scope *sc, Expression *e1, Expression *e2 = NULL);\n Expression *resolvePropertiesX(Scope *sc, Expression *e1, Expression *e2 = NULL);\n-Expression *trySemantic(Expression *e, Scope *sc);\n-Expression *unaSemantic(UnaExp *e, Scope *sc);\n-Expression *binSemantic(BinExp *e, Scope *sc);\n-Expression *binSemanticProp(BinExp *e, Scope *sc);\n-Expression *semantic(Expression *e, Scope *sc);\n-Expression *semanticY(DotIdExp *exp, Scope *sc, int flag);\n-Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag);\n-StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n \n /****************************************\n  * Preprocess arguments to function.\n@@ -278,7 +269,7 @@ class ExpressionSemanticVisitor : public Visitor\n     void visit(Expression *e)\n     {\n         if (e->type)\n-            e->type = e->type->semantic(e->loc, sc);\n+            e->type = typeSemantic(e->type, e->loc, sc);\n         else\n             e->type = Type::tvoid;\n         result = e;\n@@ -299,7 +290,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (!e->type)\n             e->type = Type::tfloat64;\n         else\n-            e->type = e->type->semantic(e->loc, sc);\n+            e->type = typeSemantic(e->type, e->loc, sc);\n         result = e;\n     }\n \n@@ -308,7 +299,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (!e->type)\n             e->type = Type::tcomplex80;\n         else\n-            e->type = e->type->semantic(e->loc, sc);\n+            e->type = typeSemantic(e->type, e->loc, sc);\n         result = e;\n     }\n \n@@ -363,7 +354,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 //  The redudancy should be removed.\n                 e = new VarExp(exp->loc, withsym->withstate->wthis);\n                 e = new DotIdExp(exp->loc, e, exp->ident);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n             }\n             else\n             {\n@@ -381,7 +372,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         e = withsym->withstate->exp;\n                     }\n                     e = new DotIdExp(exp->loc, e, exp->ident);\n-                    result = semantic(e, sc);\n+                    result = expressionSemantic(e, sc);\n                     return;\n                 }\n \n@@ -397,7 +388,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         if (td->overroot)       // if not start of overloaded list of TemplateDeclaration's\n                             td = td->overroot;  // then get the start\n                         e = new TemplateExp(exp->loc, td, f);\n-                        e = semantic(e, sc);\n+                        e = expressionSemantic(e, sc);\n                         result = e;\n                         return;\n                     }\n@@ -440,7 +431,7 @@ class ExpressionSemanticVisitor : public Visitor\n             vd->storage_class |= STCtemp;\n             vd->semanticRun = PASSsemanticdone;\n             Expression *e = new VarExp(exp->loc, vd);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -544,7 +535,7 @@ class ExpressionSemanticVisitor : public Visitor\n         return;\n \n     Lerr:\n-        e->error(\"'this' is only defined in non-static member functions, not %s\", sc->parent->toChars());\n+        e->error(\"`this` is only defined in non-static member functions, not %s\", sc->parent->toChars());\n         return setError();\n     }\n \n@@ -579,7 +570,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     cd = cd->baseClass;\n                     if (!cd)\n                     {\n-                        e->error(\"class %s has no 'super'\", s->toChars());\n+                        e->error(\"class %s has no `super`\", s->toChars());\n                         goto Lerr;\n                     }\n                     e->type = cd->type;\n@@ -624,7 +615,7 @@ class ExpressionSemanticVisitor : public Visitor\n         return;\n \n     Lerr:\n-        e->error(\"'super' is only allowed in non-static class member functions\");\n+        e->error(\"`super` is only allowed in non-static class member functions\");\n         return setError();\n     }\n \n@@ -712,7 +703,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 e->type = new TypeDArray(Type::tchar->immutableOf());\n                 break;\n         }\n-        e->type = e->type->semantic(e->loc, sc);\n+        e->type = typeSemantic(e->type, e->loc, sc);\n         //e->type = e->type->immutableOf();\n         //printf(\"type = %s\\n\", e->type->toChars());\n \n@@ -731,7 +722,7 @@ class ExpressionSemanticVisitor : public Visitor\n         */\n \n         if (e->basis)\n-            e->basis = semantic(e->basis, sc);\n+            e->basis = expressionSemantic(e->basis, sc);\n         if (arrayExpressionSemantic(e->elements, sc) || (e->basis && e->basis->op == TOKerror))\n             return setError();\n         expandTuples(e->elements);\n@@ -746,7 +737,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return setError();\n \n         e->type = t0->arrayOf();\n-        e->type = e->type->semantic(e->loc, sc);\n+        e->type = typeSemantic(e->type, e->loc, sc);\n \n         /* Disallow array literals of type void being used.\n         */\n@@ -794,7 +785,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return setError();\n \n         e->type = new TypeAArray(tvalue, tkey);\n-        e->type = e->type->semantic(e->loc, sc);\n+        e->type = typeSemantic(e->type, e->loc, sc);\n \n         semanticTypeInfo(sc, e->type);\n \n@@ -865,12 +856,12 @@ class ExpressionSemanticVisitor : public Visitor\n                 e = new DotVarExp(exp->loc, new ThisExp(exp->loc), ve->var, false);\n             }\n             //printf(\"e = %s %s\\n\", Token::toChars(e->op), e->toChars());\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n         }\n         else if (t)\n         {\n             //printf(\"t = %d %s\\n\", t->ty, t->toChars());\n-            exp->type = t->semantic(exp->loc, sc);\n+            exp->type = typeSemantic(t, exp->loc, sc);\n             e = exp;\n         }\n         else if (s)\n@@ -907,7 +898,7 @@ class ExpressionSemanticVisitor : public Visitor\n             {\n                 Expression *e = new VarExp(exp->loc, withsym->withstate->wthis);\n                 e = new DotTemplateInstanceExp(exp->loc, e, ti);\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n                 return;\n             }\n             if (ti->needsTypeInference(sc))\n@@ -921,7 +912,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         (td->_scope->stc & STCstatic) == 0)\n                     {\n                         Expression *e = new DotTemplateInstanceExp(exp->loc, new ThisExp(exp->loc), ti->name, ti->tiargs);\n-                        result = semantic(e, sc);\n+                        result = expressionSemantic(e, sc);\n                         return;\n                     }\n                 }\n@@ -932,7 +923,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     if (fdthis && ad && isAggregate(fdthis->vthis->type) == ad)\n                     {\n                         Expression *e = new DotTemplateInstanceExp(exp->loc, new ThisExp(exp->loc), ti->name, ti->tiargs);\n-                        result = semantic(e, sc);\n+                        result = expressionSemantic(e, sc);\n                         return;\n                     }\n                 }\n@@ -942,7 +933,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 result = exp;\n                 return;\n             }\n-            ti->semantic(sc);\n+            dsymbolSemantic(ti, sc);\n             if (!ti->inst || ti->errors)\n                 return setError();\n \n@@ -987,13 +978,13 @@ class ExpressionSemanticVisitor : public Visitor\n                      */\n                     if (ti->inuse)\n                     {\n-                        exp->error(\"recursive expansion of %s '%s'\", ti->kind(), ti->toPrettyChars());\n+                        exp->error(\"recursive expansion of %s `%s`\", ti->kind(), ti->toPrettyChars());\n                         return setError();\n                     }\n \n                     Expression *e = v->expandInitializer(exp->loc);\n                     ti->inuse++;\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     ti->inuse--;\n                     result = e;\n                     return;\n@@ -1009,18 +1000,18 @@ class ExpressionSemanticVisitor : public Visitor\n \n         //printf(\"sds2 = %s, '%s'\\n\", sds2->kind(), sds2->toChars());\n         //printf(\"\\tparent = '%s'\\n\", sds2->parent->toChars());\n-        sds2->semantic(sc);\n+        dsymbolSemantic(sds2, sc);\n \n         if (Type *t = sds2->getType())    // (Aggregate|Enum)Declaration\n         {\n             Expression *ex = new TypeExp(exp->loc, t);\n-            result = semantic(ex, sc);\n+            result = expressionSemantic(ex, sc);\n             return;\n         }\n \n         if (TemplateDeclaration *td = sds2->isTemplateDeclaration())\n         {\n-            result = semantic(new TemplateExp(exp->loc, td), sc);\n+            result = expressionSemantic(new TemplateExp(exp->loc, td), sc);\n             return;\n         }\n \n@@ -1051,23 +1042,23 @@ class ExpressionSemanticVisitor : public Visitor\n         ClassDeclaration *cdthis = NULL;\n         if (exp->thisexp)\n         {\n-            exp->thisexp = semantic(exp->thisexp, sc);\n+            exp->thisexp = expressionSemantic(exp->thisexp, sc);\n             if (exp->thisexp->op == TOKerror)\n                 return setError();\n             cdthis = exp->thisexp->type->isClassHandle();\n             if (!cdthis)\n             {\n-                exp->error(\"'this' for nested class must be a class type, not %s\", exp->thisexp->type->toChars());\n+                exp->error(\"`this` for nested class must be a class type, not %s\", exp->thisexp->type->toChars());\n                 return setError();\n             }\n \n             sc = sc->push(cdthis);\n-            exp->type = exp->newtype->semantic(exp->loc, sc);\n+            exp->type = typeSemantic(exp->newtype, exp->loc, sc);\n             sc = sc->pop();\n         }\n         else\n         {\n-            exp->type = exp->newtype->semantic(exp->loc, sc);\n+            exp->type = typeSemantic(exp->newtype, exp->loc, sc);\n         }\n         if (exp->type->ty == Terror)\n             return setError();\n@@ -1078,7 +1069,7 @@ class ExpressionSemanticVisitor : public Visitor\n             {\n                 // --> new T[edim]\n                 exp->type = new TypeSArray(exp->type, edim);\n-                exp->type = exp->type->semantic(exp->loc, sc);\n+                exp->type = typeSemantic(exp->type, exp->loc, sc);\n                 if (exp->type->ty == Terror)\n                     return setError();\n             }\n@@ -1141,7 +1132,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 {\n                     FuncDeclaration *fd = cd->vtbl[i]->isFuncDeclaration();\n                     if (fd && fd->isAbstract())\n-                        errorSupplemental(exp->loc, \"function '%s' is not implemented\", fd->toFullSignature());\n+                        errorSupplemental(exp->loc, \"function `%s` is not implemented\", fd->toFullSignature());\n                 }\n                 return setError();\n             }\n@@ -1164,7 +1155,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         {\n                             if (!sp)\n                             {\n-                                exp->error(\"outer class %s 'this' needed to 'new' nested class %s\", cdn->toChars(), cd->toChars());\n+                                exp->error(\"outer class %s `this` needed to `new` nested class %s\", cdn->toChars(), cd->toChars());\n                                 return setError();\n                             }\n                             ClassDeclaration *cdp = sp->isClassDeclaration();\n@@ -1175,15 +1166,15 @@ class ExpressionSemanticVisitor : public Visitor\n                             // Add a '.outer' and try again\n                             exp->thisexp = new DotIdExp(exp->loc, exp->thisexp, Id::outer);\n                         }\n-                        exp->thisexp = semantic(exp->thisexp, sc);\n+                        exp->thisexp = expressionSemantic(exp->thisexp, sc);\n                         if (exp->thisexp->op == TOKerror)\n                             return setError();\n                         cdthis = exp->thisexp->type->isClassHandle();\n                     }\n                     if (cdthis != cdn && !cdn->isBaseOf(cdthis, NULL))\n                     {\n                         //printf(\"cdthis = %s\\n\", cdthis->toChars());\n-                        exp->error(\"'this' for nested class must be of type %s, not %s\",\n+                        exp->error(\"`this` for nested class must be of type %s, not %s\",\n                             cdn->toChars(), exp->thisexp->type->toChars());\n                         return setError();\n                     }\n@@ -1204,7 +1195,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     // make sure the parent context fdn of cd is reachable from sc\n                     if (checkNestedRef(sc->parent, fdn))\n                     {\n-                        exp->error(\"outer function context of %s is needed to 'new' nested class %s\",\n+                        exp->error(\"outer function context of %s is needed to `new` nested class %s\",\n                             fdn->toPrettyChars(), cd->toPrettyChars());\n                         return setError();\n                     }\n@@ -1294,7 +1285,7 @@ class ExpressionSemanticVisitor : public Visitor\n                             v->_init->isVoidInitializer())\n                             continue;\n                         v->inuse++;\n-                        v->_init = semantic(v->_init, v->_scope, v->type, INITinterpret);\n+                        v->_init = initializerSemantic(v->_init, v->_scope, v->type, INITinterpret);\n                         v->inuse--;\n                     }\n                 }\n@@ -1462,7 +1453,7 @@ class ExpressionSemanticVisitor : public Visitor\n         Expression *d = new DeclarationExp(e->loc, e->cd);\n         sc = sc->push();            // just create new scope\n         sc->flags &= ~SCOPEctfe;    // temporary stop CTFE\n-        d = semantic(d, sc);\n+        d = expressionSemantic(d, sc);\n         sc = sc->pop();\n \n         if (!e->cd->errors && sc->intypeof && !sc->parent->inNonRoot())\n@@ -1474,12 +1465,12 @@ class ExpressionSemanticVisitor : public Visitor\n         Expression *n = new NewExp(e->loc, e->thisexp, e->newargs, e->cd->type, e->arguments);\n \n         Expression *c = new CommaExp(e->loc, d, n);\n-        result = semantic(c, sc);\n+        result = expressionSemantic(c, sc);\n     }\n \n     void visit(SymOffExp *e)\n     {\n-        //var->semantic(sc);\n+        //dsymbolSemantic(var, sc);\n         if (!e->type)\n             e->type = e->var->type->pointerTo();\n         if (VarDeclaration *v = e->var->isVarDeclaration())\n@@ -1515,7 +1506,7 @@ class ExpressionSemanticVisitor : public Visitor\n             Declaration *decl = e->var->isDeclaration();\n             if (decl)\n                 decl->inuse++;\n-            e->type = e->type->semantic(e->loc, sc);\n+            e->type = typeSemantic(e->type, e->loc, sc);\n             if (decl)\n                 decl->inuse--;\n         }\n@@ -1559,14 +1550,14 @@ class ExpressionSemanticVisitor : public Visitor\n         }\n \n         if (exp->e0)\n-            exp->e0 = semantic(exp->e0, sc);\n+            exp->e0 = expressionSemantic(exp->e0, sc);\n \n         // Run semantic() on each argument\n         bool err = false;\n         for (size_t i = 0; i < exp->exps->length; i++)\n         {\n             Expression *e = (*exp->exps)[i];\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             if (!e->type)\n             {\n                 exp->error(\"%s has no value\", e->toChars());\n@@ -1582,7 +1573,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         expandTuples(exp->exps);\n         exp->type = new TypeTuple(exp->exps);\n-        exp->type = exp->type->semantic(exp->loc, sc);\n+        exp->type = typeSemantic(exp->type, exp->loc, sc);\n         //printf(\"-TupleExp::semantic(%s)\\n\", exp->toChars());\n         result = exp;\n     }\n@@ -1603,7 +1594,7 @@ class ExpressionSemanticVisitor : public Visitor\n              * foo(a=>a); // in IFTI, treq == T delegate(int)\n              */\n             //if (exp->fd->treq)\n-            //    exp->fd->treq = exp->fd->treq->semantic(exp->loc, sc);\n+            //    exp->fd->treq = typeSemantic(exp->fd->treq, exp->loc, sc);\n \n             exp->genIdent(sc);\n \n@@ -1625,7 +1616,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (exp->td)\n             {\n                 assert(exp->td->parameters && exp->td->parameters->length);\n-                exp->td->semantic(sc);\n+                dsymbolSemantic(exp->td, sc);\n                 exp->type = Type::tvoid; // temporary type\n \n                 if (exp->fd->treq)       // defer type determination\n@@ -1640,12 +1631,12 @@ class ExpressionSemanticVisitor : public Visitor\n             }\n \n             unsigned olderrors = global.errors;\n-            exp->fd->semantic(sc);\n+            dsymbolSemantic(exp->fd, sc);\n             if (olderrors == global.errors)\n             {\n-                exp->fd->semantic2(sc);\n+                semantic2(exp->fd, sc);\n                 if (olderrors == global.errors)\n-                    exp->fd->semantic3(sc);\n+                    semantic3(exp->fd, sc);\n             }\n             if (olderrors != global.errors)\n             {\n@@ -1660,14 +1651,14 @@ class ExpressionSemanticVisitor : public Visitor\n                 (exp->tok == TOKreserved && exp->fd->treq && exp->fd->treq->ty == Tdelegate))\n             {\n                 exp->type = new TypeDelegate(exp->fd->type);\n-                exp->type = exp->type->semantic(exp->loc, sc);\n+                exp->type = typeSemantic(exp->type, exp->loc, sc);\n \n                 exp->fd->tok = TOKdelegate;\n             }\n             else\n             {\n                 exp->type = new TypePointer(exp->fd->type);\n-                exp->type = exp->type->semantic(exp->loc, sc);\n+                exp->type = typeSemantic(exp->type, exp->loc, sc);\n                 //exp->type = exp->fd->type->pointerTo();\n \n                 /* A lambda expression deduced to function pointer might become\n@@ -1706,7 +1697,7 @@ class ExpressionSemanticVisitor : public Visitor\n             exp->genIdent(sc);\n \n             assert(exp->td->parameters && exp->td->parameters->length);\n-            exp->td->semantic(sc);\n+            dsymbolSemantic(exp->td, sc);\n \n             TypeFunction *tfl = (TypeFunction *)exp->fd->type;\n             size_t dim = tfl->parameterList.length();\n@@ -1739,12 +1730,12 @@ class ExpressionSemanticVisitor : public Visitor\n \n                 TemplateInstance *ti = new TemplateInstance(exp->loc, exp->td, tiargs);\n                 Expression *se = new ScopeExp(exp->loc, ti);\n-                return semantic(se, sc);\n+                return expressionSemantic(se, sc);\n             }\n             exp->error(\"cannot infer function literal type\");\n             return new ErrorExp();\n         }\n-        return semantic(exp, sc);\n+        return expressionSemantic(exp, sc);\n     }\n \n     void visit(DeclarationExp *e)\n@@ -1783,7 +1774,7 @@ class ExpressionSemanticVisitor : public Visitor\n             // Do semantic() on initializer first, so:\n             //      int a = a;\n             // will be illegal.\n-            e->declaration->semantic(sc);\n+            dsymbolSemantic(e->declaration, sc);\n             s->parent = sc->parent;\n         }\n \n@@ -1848,17 +1839,17 @@ class ExpressionSemanticVisitor : public Visitor\n             if (sc2->stc & (STCpure | STCnothrow | STCnogc))\n                 sc2 = sc->push();\n             sc2->stc &= ~(STCpure | STCnothrow | STCnogc);\n-            e->declaration->semantic(sc2);\n+            dsymbolSemantic(e->declaration, sc2);\n             if (sc2 != sc)\n                 sc2->pop();\n             s->parent = sc->parent;\n         }\n         if (global.errors == olderrors)\n         {\n-            e->declaration->semantic2(sc);\n+            semantic2(e->declaration, sc);\n             if (global.errors == olderrors)\n             {\n-                e->declaration->semantic3(sc);\n+                semantic3(e->declaration, sc);\n             }\n         }\n         // todo: error in declaration should be propagated.\n@@ -1885,7 +1876,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (Dsymbol *sym = getDsymbol(ea))\n                 ea = resolve(exp->loc, sc, sym, false);\n             else\n-                ea = semantic(ea, sc);\n+                ea = expressionSemantic(ea, sc);\n             ea = resolveProperties(sc, ea);\n             ta = ea->type;\n             if (ea->op == TOKtype)\n@@ -1914,7 +1905,7 @@ class ExpressionSemanticVisitor : public Visitor\n             {\n                 /* Get the dynamic type, which is .classinfo\n                 */\n-                ea = semantic(ea, sc);\n+                ea = expressionSemantic(ea, sc);\n                 e = new TypeidExp(ea->loc, ea);\n                 e->type = Type::typeinfoclass->type;\n             }\n@@ -1934,7 +1925,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (ea)\n             {\n                 e = new CommaExp(exp->loc, ea, e);       // execute ea\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n             }\n         }\n         result = e;\n@@ -2063,7 +2054,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         Parameters *args = new Parameters;\n                         args->reserve(cd->baseclasses->length);\n                         if (cd->semanticRun < PASSsemanticdone)\n-                            cd->semantic(NULL);\n+                            dsymbolSemantic(cd, NULL);\n                         for (size_t i = 0; i < cd->baseclasses->length; i++)\n                         {\n                             BaseClass *b = (*cd->baseclasses)[i];\n@@ -2171,7 +2162,7 @@ class ExpressionSemanticVisitor : public Visitor\n              * is(targ == tspec)\n              * is(targ : tspec)\n              */\n-            e->tspec = e->tspec->semantic(e->loc, sc);\n+            e->tspec = typeSemantic(e->tspec, e->loc, sc);\n             //printf(\"targ  = %s, %s\\n\", e->targ->toChars(), e->targ->deco);\n             //printf(\"tspec = %s, %s\\n\", e->tspec->toChars(), e->tspec->deco);\n             if (e->tok == TOKcolon)\n@@ -2235,7 +2226,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     m = tp->matchArg(e->loc, sc, &tiargs, i, e->parameters, &dedtypes, &s);\n                     if (m <= MATCHnomatch)\n                         goto Lno;\n-                    s->semantic(sc);\n+                    dsymbolSemantic(s, sc);\n                     if (!sc->insert(s))\n                         e->error(\"declaration %s is already defined\", s->toChars());\n \n@@ -2262,7 +2253,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 s = new TupleDeclaration(e->loc, e->id, &(tup->objects));\n             else\n                 s = new AliasDeclaration(e->loc, e->id, tded);\n-            s->semantic(sc);\n+            dsymbolSemantic(s, sc);\n             /* The reason for the !tup is unclear. It fails Phobos unittests if it is not there.\n              * More investigation is needed.\n              */\n@@ -2302,7 +2293,7 @@ class ExpressionSemanticVisitor : public Visitor\n         {\n             // arr.length op= e2;\n             e = ArrayLengthExp::rewriteOpAssign(exp);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -2330,7 +2321,7 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        exp->e1 = semantic(exp->e1, sc);\n+        exp->e1 = expressionSemantic(exp->e1, sc);\n         exp->e1 = exp->e1->optimize(WANTvalue);\n         exp->e1 = exp->e1->modifiableLvalue(sc, exp->e1);\n         exp->type = exp->e1->type;\n@@ -2412,7 +2403,7 @@ class ExpressionSemanticVisitor : public Visitor\n             exp->error(\"incomplete mixin expression (%s)\", se->toChars());\n             return setError();\n         }\n-        result = semantic(e, sc);\n+        result = expressionSemantic(e, sc);\n     }\n \n     void visit(ImportExp *e)\n@@ -2477,7 +2468,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 se = new StringExp(e->loc, f.buffer, f.len);\n             }\n         }\n-        result = semantic(se, sc);\n+        result = expressionSemantic(se, sc);\n     }\n \n     void visit(AssertExp *exp)\n@@ -2493,7 +2484,7 @@ class ExpressionSemanticVisitor : public Visitor\n         exp->e1 = exp->e1->toBoolean(sc);\n         if (exp->msg)\n         {\n-            exp->msg = semantic(exp->msg, sc);\n+            exp->msg = expressionSemantic(exp->msg, sc);\n             exp->msg = resolveProperties(sc, exp->msg);\n             exp->msg = exp->msg->implicitCastTo(sc, Type::tchar->constOf()->arrayOf());\n             exp->msg = exp->msg->optimize(WANTvalue);\n@@ -2530,7 +2521,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (global.params.useAssert == CHECKENABLEoff)\n             {\n                 Expression *e = new HaltExp(exp->loc);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 result = e;\n                 return;\n             }\n@@ -2586,7 +2577,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         exp->var = exp->var->toAlias()->isDeclaration();\n \n-        exp->e1 = semantic(exp->e1, sc);\n+        exp->e1 = expressionSemantic(exp->e1, sc);\n \n         if (TupleDeclaration *tup = exp->var->isTupleDeclaration())\n         {\n@@ -2630,7 +2621,7 @@ class ExpressionSemanticVisitor : public Visitor\n             }\n \n             Expression *e = new TupleExp(exp->loc, e0, exps);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -2688,7 +2679,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 /* Later checkRightThis will report correct error for invalid field variable access.\n                 */\n                 Expression *e = new VarExp(exp->loc, exp->var);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 result = e;\n                 return;\n             }\n@@ -2711,7 +2702,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 checkAccess(exp->loc, sc, exp->e1, v);\n                 Expression *e = new VarExp(exp->loc, v);\n                 e = new CommaExp(exp->loc, exp->e1, e);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 result = e;\n                 return;\n             }\n@@ -2738,9 +2729,9 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        e->e1 = semantic(e->e1, sc);\n+        e->e1 = expressionSemantic(e->e1, sc);\n         e->type = new TypeDelegate(e->func->type);\n-        e->type = e->type->semantic(e->loc, sc);\n+        e->type = typeSemantic(e->type, e->loc, sc);\n         FuncDeclaration *f = e->func->toAliasFunc();\n         AggregateDeclaration *ad = f->toParent()->isAggregateDeclaration();\n         if (f->needThis())\n@@ -2762,7 +2753,7 @@ class ExpressionSemanticVisitor : public Visitor\n         {\n             // A downcast is required for interfaces, see Bugzilla 3706\n             e->e1 = new CastExp(e->loc, e->e1, ad->type);\n-            e->e1 = semantic(e->e1, sc);\n+            e->e1 = expressionSemantic(e->e1, sc);\n         }\n         result = e;\n     }\n@@ -2806,15 +2797,15 @@ class ExpressionSemanticVisitor : public Visitor\n             CommaExp *ce = (CommaExp *)exp->e1;\n             exp->e1 = ce->e2;\n             ce->e2 = exp;\n-            result = semantic(ce, sc);\n+            result = expressionSemantic(ce, sc);\n             return;\n         }\n \n         if (exp->e1->op == TOKdelegate)\n         {\n             DelegateExp *de = (DelegateExp *)exp->e1;\n             exp->e1 = new DotVarExp(de->loc, de->e1, de->func, de->hasOverloads);\n-            result = semantic(exp, sc);\n+            result = expressionSemantic(exp, sc);\n             return;\n         }\n \n@@ -2881,7 +2872,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 }\n                 else\n                 {\n-                    Expression *e1x = semantic(exp->e1, sc);\n+                    Expression *e1x = expressionSemantic(exp->e1, sc);\n                     if (e1x->op == TOKerror)\n                     {\n                         result = e1x;\n@@ -2926,7 +2917,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 }\n                 else\n                 {\n-                    Expression *e1x = semantic(exp->e1, sc);\n+                    Expression *e1x = expressionSemantic(exp->e1, sc);\n                     if (e1x->op == TOKerror)\n                     {\n                         result =e1x;\n@@ -2949,7 +2940,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (exp->e1->op == TOKdotid)\n             {\n                 DotIdExp *die = (DotIdExp *)exp->e1;\n-                exp->e1 = semantic(die, sc);\n+                exp->e1 = expressionSemantic(die, sc);\n                 /* Look for e1 having been rewritten to expr.opDispatch!(string)\n                  * We handle such earlier, so go back.\n                  * Note that in the rewrite, we carefully did not run semantic() on e1\n@@ -2988,9 +2979,9 @@ class ExpressionSemanticVisitor : public Visitor\n                     Type *tw = ve->var->type;\n                     Type *tc = ve->var->type->substWildTo(MODconst);\n                     TypeFunction *tf = new TypeFunction(ParameterList(), tc, LINKd, STCsafe | STCpure);\n-                    (tf = (TypeFunction *)tf->semantic(exp->loc, sc))->next = tw;    // hack for bug7757\n+                    (tf = (TypeFunction *)typeSemantic(tf, exp->loc, sc))->next = tw;    // hack for bug7757\n                     TypeDelegate *t = new TypeDelegate(tf);\n-                    ve->type = t->semantic(exp->loc, sc);\n+                    ve->type = typeSemantic(t, exp->loc, sc);\n                 }\n                 VarDeclaration *v = ve->var->isVarDeclaration();\n                 if (v && ve->checkPurity(sc, v))\n@@ -3001,7 +2992,7 @@ class ExpressionSemanticVisitor : public Visitor\n             {\n                 SymOffExp *se = (SymOffExp *)exp->e1;\n                 exp->e1 = new VarExp(se->loc, se->var, true);\n-                exp->e1 = semantic(exp->e1, sc);\n+                exp->e1 = expressionSemantic(exp->e1, sc);\n             }\n             else if (exp->e1->op == TOKdot)\n             {\n@@ -3081,7 +3072,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     else\n                         assert(0);\n                     e = new CallExp(exp->loc, e, exp->arguments);\n-                    result = semantic(e, sc);\n+                    result = expressionSemantic(e, sc);\n                     return;\n                 }\n                 // No constructor, look for overload of opCall\n@@ -3105,7 +3096,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 */\n             Lx:\n                 Expression *e = new StructLiteralExp(exp->loc, sd, exp->arguments, exp->e1->type);\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n                 return;\n             }\n             else if (t1->ty == Tclass)\n@@ -3114,7 +3105,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 // Rewrite as e1.call(arguments)\n                 Expression *e = new DotIdExp(exp->loc, exp->e1, Id::call);\n                 e = new CallExp(exp->loc, e, exp->arguments);\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n                 return;\n             }\n             else if (exp->e1->op == TOKtype && t1->isscalar())\n@@ -3143,7 +3134,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     exp->error(\"more than one argument for construction of %s\", t1->toChars());\n                     e = new ErrorExp();\n                 }\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n                 return;\n             }\n         }\n@@ -3192,7 +3183,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 BaseClass *b = exp->f->interfaceVirtual;\n                 ClassDeclaration *ad2 = b->sym;\n                 ue->e1 = ue->e1->castTo(sc, ad2->type->addMod(ue->e1->type->mod));\n-                ue->e1 = semantic(ue->e1, sc);\n+                ue->e1 = expressionSemantic(ue->e1, sc);\n                 ue1 = ue->e1;\n                 int vi = exp->f->findVtblIndex((Dsymbols*)&ad2->vtbl, (int)ad2->vtbl.length);\n                 assert(vi >= 0);\n@@ -3251,7 +3242,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 else\n                 {\n                     exp->e1 = new DotVarExp(exp->loc, dte->e1, exp->f, false);\n-                    exp->e1 = semantic(exp->e1, sc);\n+                    exp->e1 = expressionSemantic(exp->e1, sc);\n                     if (exp->e1->op == TOKerror)\n                         return setError();\n                     ue = (UnaExp *)exp->e1;\n@@ -3275,7 +3266,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     if (ad != cd)\n                     {\n                         ue->e1 = ue->e1->castTo(sc, ad->type->addMod(ue->e1->type->mod));\n-                        ue->e1 = semantic(ue->e1, sc);\n+                        ue->e1 = expressionSemantic(ue->e1, sc);\n                     }\n                 }\n             }\n@@ -3331,7 +3322,7 @@ class ExpressionSemanticVisitor : public Visitor\n             checkAccess(exp->loc, sc, NULL, exp->f);\n \n             exp->e1 = new DotVarExp(exp->e1->loc, exp->e1, exp->f, false);\n-            exp->e1 = semantic(exp->e1, sc);\n+            exp->e1 = expressionSemantic(exp->e1, sc);\n             t1 = exp->e1->type;\n         }\n         else if (exp->e1->op == TOKthis)\n@@ -3377,7 +3368,7 @@ class ExpressionSemanticVisitor : public Visitor\n             //checkAccess(exp->loc, sc, NULL, exp->f);    // necessary?\n \n             exp->e1 = new DotVarExp(exp->e1->loc, exp->e1, exp->f, false);\n-            exp->e1 = semantic(exp->e1, sc);\n+            exp->e1 = expressionSemantic(exp->e1, sc);\n             t1 = exp->e1->type;\n \n             // BUG: this should really be done by checking the static\n@@ -3402,7 +3393,7 @@ class ExpressionSemanticVisitor : public Visitor\n         }\n         else if (!t1)\n         {\n-            exp->error(\"function expected before (), not '%s'\", exp->e1->toChars());\n+            exp->error(\"function expected before (), not `%s`\", exp->e1->toChars());\n             return setError();\n         }\n         else if (t1->ty == Terror)\n@@ -3451,7 +3442,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 }\n                 exp->e1 = new VarExp(dve->loc, exp->f, false);\n                 Expression *e = new CommaExp(exp->loc, dve->e1, exp);\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n                 return;\n             }\n             else if (exp->e1->op == TOKvar &&\n@@ -3474,13 +3465,13 @@ class ExpressionSemanticVisitor : public Visitor\n                         // Supply an implicit 'this', as in\n                         //    this.ident\n                         Expression *ex = new ThisExp(exp->loc);\n-                        ex = semantic(ex, sc);\n+                        ex = expressionSemantic(ex, sc);\n                         exp->e1 = new DotVarExp(exp->loc, ex, exp->f, false);\n                         goto Lagain;\n                     }\n                     else if (isNeedThisScope(sc, exp->f))\n                     {\n-                        exp->error(\"need 'this' for '%s' of type '%s'\", exp->f->toChars(), exp->f->type->toChars());\n+                        exp->error(\"need `this` for `%s` of type `%s`\", exp->f->toChars(), exp->f->type->toChars());\n                         return setError();\n                     }\n                 }\n@@ -3525,19 +3516,19 @@ class ExpressionSemanticVisitor : public Visitor\n                 bool err = false;\n                 if (!tf->purity && !(sc->flags & SCOPEdebug) && sc->func->setImpure())\n                 {\n-                    exp->error(\"pure %s '%s' cannot call impure %s '%s'\",\n+                    exp->error(\"pure %s `%s` cannot call impure %s `%s`\",\n                           sc->func->kind(), sc->func->toPrettyChars(), p, exp->e1->toChars());\n                     err = true;\n                 }\n                 if (!tf->isnogc && sc->func->setGC())\n                 {\n-                    exp->error(\"@nogc %s '%s' cannot call non-@nogc %s '%s'\",\n+                    exp->error(\"@nogc %s `%s` cannot call non-@nogc %s `%s`\",\n                           sc->func->kind(), sc->func->toPrettyChars(), p, exp->e1->toChars());\n                     err = true;\n                 }\n                 if (tf->trust <= TRUSTsystem && sc->func->setUnsafe())\n                 {\n-                    exp->error(\"@safe %s '%s' cannot call @system %s '%s'\",\n+                    exp->error(\"@safe %s `%s` cannot call @system %s `%s`\",\n                           sc->func->kind(), sc->func->toPrettyChars(), p, exp->e1->toChars());\n                     err = true;\n                 }\n@@ -3599,15 +3590,15 @@ class ExpressionSemanticVisitor : public Visitor\n                     //    this.ident\n \n                     Expression *ex = new ThisExp(exp->loc);\n-                    ex = semantic(ex, sc);\n+                    ex = expressionSemantic(ex, sc);\n                     exp->e1 = new DotVarExp(exp->loc, ex, ve->var);\n                     // Note: we cannot use f directly, because further overload resolution\n                     // through the supplied 'this' may cause different result.\n                     goto Lagain;\n                 }\n                 else if (isNeedThisScope(sc, exp->f))\n                 {\n-                    exp->error(\"need 'this' for '%s' of type '%s'\", exp->f->toChars(), exp->f->type->toChars());\n+                    exp->error(\"need `this` for `%s` of type `%s`\", exp->f->toChars(), exp->f->type->toChars());\n                     return setError();\n                 }\n             }\n@@ -3642,7 +3633,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (!exp->type)\n         {\n             exp->e1 = e1org;     // Bugzilla 10922, avoid recursive expression printing\n-            exp->error(\"forward reference to inferred return type of function call '%s'\", exp->toChars());\n+            exp->error(\"forward reference to inferred return type of function call `%s`\", exp->toChars());\n             return setError();\n         }\n \n@@ -3690,15 +3681,15 @@ class ExpressionSemanticVisitor : public Visitor\n             TemplateInstance *ti = dti->ti;\n             {\n                 //assert(ti->needsTypeInference(sc));\n-                ti->semantic(sc);\n+                dsymbolSemantic(ti, sc);\n                 if (!ti->inst || ti->errors)    // if template failed to expand\n                     return setError();\n                 Dsymbol *s = ti->toAlias();\n                 FuncDeclaration *f = s->isFuncDeclaration();\n                 if (f)\n                 {\n                     exp->e1 = new DotVarExp(exp->e1->loc, dti->e1, f);\n-                    exp->e1 = semantic(exp->e1, sc);\n+                    exp->e1 = expressionSemantic(exp->e1, sc);\n                 }\n             }\n         }\n@@ -3708,15 +3699,15 @@ class ExpressionSemanticVisitor : public Visitor\n             if (ti)\n             {\n                 //assert(ti->needsTypeInference(sc));\n-                ti->semantic(sc);\n+                dsymbolSemantic(ti, sc);\n                 if (!ti->inst || ti->errors)    // if template failed to expand\n                     return setError();\n                 Dsymbol *s = ti->toAlias();\n                 FuncDeclaration *f = s->isFuncDeclaration();\n                 if (f)\n                 {\n                     exp->e1 = new VarExp(exp->e1->loc, f);\n-                    exp->e1 = semantic(exp->e1, sc);\n+                    exp->e1 = expressionSemantic(exp->e1, sc);\n                 }\n             }\n         }\n@@ -3772,7 +3763,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     e = new DelegateExp(exp->loc, dve->e1, f, dve->hasOverloads);\n                 else // It is a function pointer. Convert &v.f() --> (v, &V.f())\n                     e = new CommaExp(exp->loc, dve->e1, new AddrExp(exp->loc, new VarExp(exp->loc, f, dve->hasOverloads)));\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 result = e;\n                 return;\n             }\n@@ -3833,13 +3824,13 @@ class ExpressionSemanticVisitor : public Visitor\n                             /* Supply a 'null' for a this pointer if no this is available\n                             */\n                             Expression *e = new DelegateExp(exp->loc, new NullExp(exp->loc, Type::tnull), f, ve->hasOverloads);\n-                            e = semantic(e, sc);\n+                            e = expressionSemantic(e, sc);\n                             result = e;\n                             return;\n                         }\n                     }\n                     Expression *e = new DelegateExp(exp->loc, exp->e1, f, ve->hasOverloads);\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     result = e;\n                     return;\n                 }\n@@ -3852,15 +3843,15 @@ class ExpressionSemanticVisitor : public Visitor\n                          */\n                         Expression *ethis = new ThisExp(exp->loc);\n                         Expression *e = new DelegateExp(exp->loc, ethis, f, ve->hasOverloads);\n-                        e = semantic(e, sc);\n+                        e = expressionSemantic(e, sc);\n                         result = e;\n                         return;\n                     }\n                     if (sc->func && !sc->intypeof)\n                     {\n                         if (sc->func->setUnsafe())\n                         {\n-                            exp->error(\"'this' reference necessary to take address of member %s in @safe function %s\",\n+                            exp->error(\"`this` reference necessary to take address of member %s in @safe function %s\",\n                                 f->toChars(), sc->func->toChars());\n                         }\n                     }\n@@ -3926,9 +3917,9 @@ class ExpressionSemanticVisitor : public Visitor\n \n             // Re-run semantic on the address expressions only\n             ce->e1->type = NULL;\n-            ce->e1 = semantic(ce->e1, sc);\n+            ce->e1 = expressionSemantic(ce->e1, sc);\n             ce->e2->type = NULL;\n-            ce->e2 = semantic(ce->e2, sc);\n+            ce->e2 = expressionSemantic(ce->e2, sc);\n         }\n \n         result = exp->optimize(WANTvalue);\n@@ -3964,7 +3955,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 break;\n \n             default:\n-                exp->error(\"can only * a pointer, not a '%s'\", exp->e1->type->toChars());\n+                exp->error(\"can only * a pointer, not a `%s`\", exp->e1->type->toChars());\n                 /* fall through */\n \n             case Terror:\n@@ -4184,7 +4175,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 if (fd && f)\n                 {\n                     v = copyToTemp(0, \"__tmpea\", exp->e1);\n-                    v->semantic(sc);\n+                    dsymbolSemantic(v, sc);\n                     ea = new DeclarationExp(exp->loc, v);\n                     ea->type = v->type;\n                 }\n@@ -4194,15 +4185,15 @@ class ExpressionSemanticVisitor : public Visitor\n                     Expression *e = ea ? new VarExp(exp->loc, v) : exp->e1;\n                     e = new DotVarExp(Loc(), e, fd, false);\n                     eb = new CallExp(exp->loc, e);\n-                    eb = semantic(eb, sc);\n+                    eb = expressionSemantic(eb, sc);\n                 }\n \n                 if (f)\n                 {\n                     Type *tpv = Type::tvoid->pointerTo();\n                     Expression *e = ea ? new VarExp(exp->loc, v) : exp->e1->castTo(sc, tpv);\n                     e = new CallExp(exp->loc, new VarExp(exp->loc, f, false), e);\n-                    ec = semantic(e, sc);\n+                    ec = expressionSemantic(e, sc);\n                 }\n                 ea = Expression::combine(ea, eb);\n                 ea = Expression::combine(ea, ec);\n@@ -4271,7 +4262,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         if (exp->to)\n         {\n-            exp->to = exp->to->semantic(exp->loc, sc);\n+            exp->to = typeSemantic(exp->to, exp->loc, sc);\n             if (exp->to == Type::terror)\n                 return setError();\n \n@@ -4307,7 +4298,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (!exp->to)    // Handle cast(const) and cast(immutable), etc.\n         {\n             exp->to = exp->e1->type->castMod(exp->mod);\n-            exp->to = exp->to->semantic(exp->loc, sc);\n+            exp->to = typeSemantic(exp->to, exp->loc, sc);\n             if (exp->to == Type::terror)\n                 return setError();\n         }\n@@ -4405,8 +4396,8 @@ class ExpressionSemanticVisitor : public Visitor\n             return;\n         }\n \n-        exp->e1 = semantic(exp->e1, sc);\n-        exp->type = exp->to->semantic(exp->loc, sc);\n+        exp->e1 = expressionSemantic(exp->e1, sc);\n+        exp->type = typeSemantic(exp->to, exp->loc, sc);\n         if (exp->e1->op == TOKerror || exp->type->ty == Terror)\n         {\n             result = exp->e1;\n@@ -4477,11 +4468,11 @@ class ExpressionSemanticVisitor : public Visitor\n         {\n             if (exp->lwr || exp->upr)\n             {\n-                exp->error(\"cannot slice type '%s'\", exp->e1->toChars());\n+                exp->error(\"cannot slice type `%s`\", exp->e1->toChars());\n                 return setError();\n             }\n             Expression *e = new TypeExp(exp->loc, exp->e1->type->arrayOf());\n-            result = semantic(e, sc);\n+            result = expressionSemantic(e, sc);\n             return;\n         }\n         if (!exp->lwr && !exp->upr)\n@@ -4630,15 +4621,15 @@ class ExpressionSemanticVisitor : public Visitor\n         if (exp->lwr)\n         {\n             if (t1b->ty == Ttuple) sc = sc->startCTFE();\n-            exp->lwr = semantic(exp->lwr, sc);\n+            exp->lwr = expressionSemantic(exp->lwr, sc);\n             exp->lwr = resolveProperties(sc, exp->lwr);\n             if (t1b->ty == Ttuple) sc = sc->endCTFE();\n             exp->lwr = exp->lwr->implicitCastTo(sc, Type::tsize_t);\n         }\n         if (exp->upr)\n         {\n             if (t1b->ty == Ttuple) sc = sc->startCTFE();\n-            exp->upr = semantic(exp->upr, sc);\n+            exp->upr = expressionSemantic(exp->upr, sc);\n             exp->upr = resolveProperties(sc, exp->upr);\n             if (t1b->ty == Ttuple) sc = sc->endCTFE();\n             exp->upr = exp->upr->implicitCastTo(sc, Type::tsize_t);\n@@ -4706,7 +4697,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 }\n                 e = new TypeExp(exp->e1->loc, new TypeTuple(args));\n             }\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -4727,7 +4718,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (t1b->ty == Tsarray || t1b->ty == Tarray)\n             {\n                 Expression *el = new ArrayLengthExp(exp->loc, exp->e1);\n-                el = semantic(el, sc);\n+                el = expressionSemantic(el, sc);\n                 el = el->optimize(WANTvalue);\n                 if (el->op == TOKint64)\n                 {\n@@ -4779,11 +4770,11 @@ class ExpressionSemanticVisitor : public Visitor\n         }\n \n         Expression *le = e->lwr;\n-        le = semantic(le, sc);\n+        le = expressionSemantic(le, sc);\n         le = resolveProperties(sc, le);\n \n         Expression *ue = e->upr;\n-        ue = semantic(ue, sc);\n+        ue = expressionSemantic(ue, sc);\n         ue = resolveProperties(sc, ue);\n \n         if (le->op == TOKerror)\n@@ -4858,8 +4849,8 @@ class ExpressionSemanticVisitor : public Visitor\n \n     void visit(DotExp *exp)\n     {\n-        exp->e1 = semantic(exp->e1, sc);\n-        exp->e2 = semantic(exp->e2, sc);\n+        exp->e1 = expressionSemantic(exp->e1, sc);\n+        exp->e2 = expressionSemantic(exp->e2, sc);\n \n         if (exp->e1->op == TOKtype)\n         {\n@@ -4875,7 +4866,7 @@ class ExpressionSemanticVisitor : public Visitor\n         {\n             TemplateDeclaration *td = ((TemplateExp *)exp->e2)->td;\n             Expression *e = new DotTemplateExp(exp->loc, exp->e1, td);\n-            result = semantic(e, sc);\n+            result = expressionSemantic(e, sc);\n             return;\n         }\n         if (!exp->type)\n@@ -4927,19 +4918,19 @@ class ExpressionSemanticVisitor : public Visitor\n         // operator overloading should be handled in ArrayExp already.\n \n         if (!exp->e1->type)\n-            exp->e1 = semantic(exp->e1, sc);\n+            exp->e1 = expressionSemantic(exp->e1, sc);\n         assert(exp->e1->type);           // semantic() should already be run on it\n         if (exp->e1->op == TOKtype && exp->e1->type->ty != Ttuple)\n         {\n-            exp->e2 = semantic(exp->e2, sc);\n+            exp->e2 = expressionSemantic(exp->e2, sc);\n             exp->e2 = resolveProperties(sc, exp->e2);\n             Type *nt;\n             if (exp->e2->op == TOKtype)\n                 nt = new TypeAArray(exp->e1->type, exp->e2->type);\n             else\n                 nt = new TypeSArray(exp->e1->type, exp->e2);\n             Expression *e = new TypeExp(exp->loc, nt);\n-            result = semantic(e, sc);\n+            result = expressionSemantic(e, sc);\n             return;\n         }\n         if (exp->e1->op == TOKerror)\n@@ -4975,7 +4966,7 @@ class ExpressionSemanticVisitor : public Visitor\n             sc = sc->push(sym);\n         }\n         if (t1b->ty == Ttuple) sc = sc->startCTFE();\n-        exp->e2 = semantic(exp->e2, sc);\n+        exp->e2 = expressionSemantic(exp->e2, sc);\n         exp->e2 = resolveProperties(sc, exp->e2);\n         if (t1b->ty == Ttuple) sc = sc->endCTFE();\n         if (exp->e2->op == TOKtuple)\n@@ -5008,7 +4999,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     ;\n                 else if (sc->func && sc->func->setUnsafe())\n                 {\n-                    exp->error(\"safe function '%s' cannot index pointer '%s'\",\n+                    exp->error(\"safe function `%s` cannot index pointer `%s`\",\n                         sc->func->toPrettyChars(), exp->e1->toChars());\n                     return setError();\n                 }\n@@ -5104,7 +5095,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (t1b->ty == Tsarray || t1b->ty == Tarray)\n         {\n             Expression *el = new ArrayLengthExp(exp->loc, exp->e1);\n-            el = semantic(el, sc);\n+            el = expressionSemantic(el, sc);\n             el = el->optimize(WANTvalue);\n             if (el->op == TOKint64)\n             {\n@@ -5154,7 +5145,7 @@ class ExpressionSemanticVisitor : public Visitor\n         if (exp->e1->op == TOKslice)\n         {\n             const char *s = exp->op == TOKplusplus ? \"increment\" : \"decrement\";\n-            exp->error(\"cannot post-%s array slice '%s', use pre-%s instead\", s, exp->e1->toChars(), s);\n+            exp->error(\"cannot post-%s array slice `%s`, use pre-%s instead\", s, exp->e1->toChars(), s);\n             return setError();\n         }\n \n@@ -5194,7 +5185,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 ea = new CommaExp(exp->loc, de, ea);\n             e = new CommaExp(exp->loc, ea, eb);\n             e = new CommaExp(exp->loc, e, ec);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -5231,7 +5222,7 @@ class ExpressionSemanticVisitor : public Visitor\n             e = new AddAssignExp(exp->loc, exp->e1, new IntegerExp(exp->loc, 1, Type::tint32));\n         else\n             e = new MinAssignExp(exp->loc, exp->e1, new IntegerExp(exp->loc, 1, Type::tint32));\n-        result = semantic(e, sc);\n+        result = expressionSemantic(e, sc);\n     }\n \n     void visit(AssignExp *exp)\n@@ -5255,7 +5246,7 @@ class ExpressionSemanticVisitor : public Visitor\n             Expression *e0;\n             exp->e2 = Expression::extractLast(exp->e2, &e0);\n             Expression *e = Expression::combine(e0, exp);\n-            result = semantic(e, sc);\n+            result = expressionSemantic(e, sc);\n             return;\n         }\n \n@@ -5268,7 +5259,7 @@ class ExpressionSemanticVisitor : public Visitor\n             Expression *res;\n \n             ArrayExp *ae = (ArrayExp *)exp->e1;\n-            ae->e1 = semantic(ae->e1, sc);\n+            ae->e1 = expressionSemantic(ae->e1, sc);\n             ae->e1 = resolveProperties(sc, ae->e1);\n             Expression *ae1old = ae->e1;\n \n@@ -5309,7 +5300,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         return;\n                     }\n \n-                    res = semantic(exp->e2, sc);\n+                    res = expressionSemantic(exp->e2, sc);\n                     if (res->op == TOKerror)\n                     {\n                         result = res;\n@@ -5327,7 +5318,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     if (maybeSlice) // a[] = e2 might be: a.opSliceAssign(e2)\n                         res = trySemantic(res, sc);\n                     else\n-                        res = semantic(res, sc);\n+                        res = expressionSemantic(res, sc);\n                     if (res)\n                     {\n                         res = Expression::combine(e0, res);\n@@ -5346,7 +5337,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         return;\n                     }\n \n-                    res = semantic(exp->e2, sc);\n+                    res = expressionSemantic(exp->e2, sc);\n                     if (res->op == TOKerror)\n                     {\n                         result = res;\n@@ -5366,7 +5357,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     }\n                     res = new DotIdExp(exp->loc, ae->e1, Id::sliceass);\n                     res = new CallExp(exp->loc, res, a);\n-                    res = semantic(res, sc);\n+                    res = expressionSemantic(res, sc);\n                     res = Expression::combine(e0, res);\n                     result = res;\n                     return;\n@@ -5442,7 +5433,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 if (e1x->op == TOKslice)\n                     ((SliceExp *)e1x)->arrayop = true;\n \n-                e1x = semantic(e1x, sc);\n+                e1x = expressionSemantic(e1x, sc);\n             }\n \n             /* We have f = value.\n@@ -5470,7 +5461,7 @@ class ExpressionSemanticVisitor : public Visitor\n         {\n             Expression *e2x = inferType(exp->e2, t1->baseElemOf());\n \n-            e2x = semantic(e2x, sc);\n+            e2x = expressionSemantic(e2x, sc);\n             e2x = resolveProperties(sc, e2x);\n \n             if (e2x->op == TOKtype)\n@@ -5520,7 +5511,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     }\n                     e = new TupleExp(exp->loc, Expression::combine(tup1->e0, tup2->e0), exps);\n                 }\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n                 return;\n             }\n \n@@ -5564,7 +5555,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     }\n                 }\n                 e2x = new TupleExp(e2x->loc, e0, iexps);\n-                e2x = semantic(e2x, sc);\n+                e2x = expressionSemantic(e2x, sc);\n                 if (e2x->op == TOKerror)\n                 {\n                     result = e2x;\n@@ -5673,7 +5664,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n                         Expression *e = Expression::combine(ae, cx);\n                         e = Expression::combine(e0, e);\n-                        e = semantic(e, sc);\n+                        e = expressionSemantic(e, sc);\n                         result = e;\n                         return;\n                     }\n@@ -5690,7 +5681,7 @@ class ExpressionSemanticVisitor : public Visitor\n                             Expression *ea1 = new ConstructExp(econd->e1->loc, e1x, econd->e1);\n                             Expression *ea2 = new ConstructExp(econd->e1->loc, e1x, econd->e2);\n                             Expression *e = new CondExp(exp->loc, econd->econd, ea1, ea2);\n-                            result = semantic(e, sc);\n+                            result = expressionSemantic(e, sc);\n                             return;\n                         }\n \n@@ -5713,7 +5704,7 @@ class ExpressionSemanticVisitor : public Visitor\n                             e = new BlitExp(exp->loc, e, e2x);\n                             e = new DotVarExp(exp->loc, e, sd->postblit, false);\n                             e = new CallExp(exp->loc, e);\n-                            result = semantic(e, sc);\n+                            result = expressionSemantic(e, sc);\n                             return;\n                         }\n                         else\n@@ -5747,7 +5738,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         e = new DotIdExp(exp->loc, e1x, Id::ctor);\n                         e = new CallExp(exp->loc, e, e2x);\n                         e = new CommaExp(exp->loc, einit, e);\n-                        e = semantic(e, sc);\n+                        e = expressionSemantic(e, sc);\n                         result = e;\n                         return;\n                     }\n@@ -5761,7 +5752,7 @@ class ExpressionSemanticVisitor : public Visitor\n                         e2x = typeDotIdExp(e2x->loc, e1x->type, Id::call);\n                         e2x = new CallExp(exp->loc, e2x, exp->e2);\n \n-                        e2x = semantic(e2x, sc);\n+                        e2x = expressionSemantic(e2x, sc);\n                         e2x = resolveProperties(sc, e2x);\n                         if (e2x->op == TOKerror)\n                         {\n@@ -5784,7 +5775,7 @@ class ExpressionSemanticVisitor : public Visitor\n                          *      (e1 op e2.aliasthis)\n                          */\n                         exp->e2 = new DotIdExp(exp->e2->loc, exp->e2, ad2->aliasthis->ident);\n-                        result = semantic(exp, sc);\n+                        result = expressionSemantic(exp, sc);\n                         return;\n                     }\n                 }\n@@ -5815,7 +5806,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n                     AssignExp *ae = (AssignExp *)exp->copy();\n                     ae->e1 = new IndexExp(exp->loc, ea, ek);\n-                    ae->e1 = semantic(ae->e1, sc);\n+                    ae->e1 = expressionSemantic(ae->e1, sc);\n                     ae->e1 = ae->e1->optimize(WANTvalue);\n                     ae->e2 = ev;\n                     Expression *e = ae->op_overload(sc);\n@@ -5839,11 +5830,11 @@ class ExpressionSemanticVisitor : public Visitor\n                         {\n                             Expression *ex;\n                             ex = new IndexExp(exp->loc, ea, ek);\n-                            ex = semantic(ex, sc);\n+                            ex = expressionSemantic(ex, sc);\n                             ex = ex->optimize(WANTvalue);\n                             ex = ex->modifiableLvalue(sc, ex);  // allocate new slot\n                             ey = new ConstructExp(exp->loc, ex, ey);\n-                            ey = semantic(ey, sc);\n+                            ey = expressionSemantic(ey, sc);\n                             if (ey->op == TOKerror)\n                             {\n                                 result = ey;\n@@ -5863,7 +5854,7 @@ class ExpressionSemanticVisitor : public Visitor\n                             e = new CondExp(exp->loc, new InExp(exp->loc, ek, ea), ex, ey);\n                         }\n                         e = Expression::combine(e0, e);\n-                        e = semantic(e, sc);\n+                        e = expressionSemantic(e, sc);\n                         result = e;\n                         return;\n                     }\n@@ -5923,7 +5914,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     // e.g. e1[] = a[] + b[];\n                     SliceExp *sle = new SliceExp(e1x->loc, e1x, NULL, NULL);\n                     sle->arrayop = true;\n-                    e1x = semantic(sle, sc);\n+                    e1x = expressionSemantic(sle, sc);\n                 }\n                 else\n                 {\n@@ -5965,7 +5956,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 }\n                 SliceExp *sle = new SliceExp(e1x->loc, e1x, NULL, NULL);\n                 sle->arrayop = true;\n-                e1x = semantic(sle, sc);\n+                e1x = expressionSemantic(sle, sc);\n             }\n             if (e1x->op == TOKerror)\n             {\n@@ -6421,7 +6412,7 @@ class ExpressionSemanticVisitor : public Visitor\n                 e = new CommaExp(exp->loc, de, e);\n             }\n             e = Expression::combine(e0, e);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -6939,7 +6930,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     exp->e1->type = exp->type;\n                     exp->e2->type = exp->type;\n                     e = new NegExp(exp->loc, exp);\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     result = e;\n                     return;\n                 }\n@@ -7013,7 +7004,7 @@ class ExpressionSemanticVisitor : public Visitor\n                     // x/iv = i(-x/v)\n                     exp->e2->type = t1;\n                     e = new NegExp(exp->loc, exp);\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     result = e;\n                     return;\n                 }\n@@ -7130,7 +7121,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (s->mod)\n             {\n                 s->mod->importAll(NULL);\n-                s->mod->semantic(NULL);\n+                dsymbolSemantic(s->mod, NULL);\n             }\n             impStdMath = s;\n         }\n@@ -7192,7 +7183,7 @@ class ExpressionSemanticVisitor : public Visitor\n         e = exp->optimize(WANTvalue);\n         if (e->op != TOKpow)\n         {\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -7219,7 +7210,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (intpow == 3)\n                 me = new MulExp(exp->loc, me, ve);\n             e = new CommaExp(exp->loc, de, me);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             result = e;\n             return;\n         }\n@@ -7252,7 +7243,7 @@ class ExpressionSemanticVisitor : public Visitor\n             // Replace e1 ^^ e2 with .std.math.pow(e1, e2)\n             e = new CallExp(exp->loc, new DotIdExp(exp->loc, e, Id::_pow), exp->e1, exp->e2);\n         }\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         result = e;\n     }\n \n@@ -7543,7 +7534,7 @@ class ExpressionSemanticVisitor : public Visitor\n \n         setNoderefOperands(exp);\n \n-        Expression *e1x = semantic(exp->e1, sc);\n+        Expression *e1x = expressionSemantic(exp->e1, sc);\n \n         // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n         if (e1x->op == TOKtype)\n@@ -7565,7 +7556,7 @@ class ExpressionSemanticVisitor : public Visitor\n             }\n         }\n \n-        Expression *e2x = semantic(exp->e2, sc);\n+        Expression *e2x = expressionSemantic(exp->e2, sc);\n         sc->mergeCallSuper(exp->loc, cs1);\n \n         // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n@@ -7706,7 +7697,7 @@ class ExpressionSemanticVisitor : public Visitor\n             if (e->op == TOKcall)\n             {\n                 e = new CmpExp(exp->op, exp->loc, e, new IntegerExp(exp->loc, 0, Type::tint32));\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n             }\n             result = e;\n             return;\n@@ -7796,7 +7787,7 @@ class ExpressionSemanticVisitor : public Visitor\n             (t1->ty == Tarray || t1->ty == Tsarray ||\n              t2->ty == Tarray || t2->ty == Tsarray))\n         {\n-            exp->error(\"'%s' is not defined for array comparisons\", Token::toChars(exp->op));\n+            exp->error(\"`%s` is not defined for array comparisons\", Token::toChars(exp->op));\n             return setError();\n         }\n         if (altop != TOKreserved)\n@@ -7806,18 +7797,18 @@ class ExpressionSemanticVisitor : public Visitor\n                 if (altop == TOKerror)\n                 {\n                     const char *s = exp->op == TOKunord ? \"false\" : \"true\";\n-                    exp->error(\"floating point operator '%s' always returns %s for non-floating comparisons\",\n+                    exp->error(\"floating point operator `%s` always returns %s for non-floating comparisons\",\n                         Token::toChars(exp->op), s);\n                 }\n                 else\n                 {\n-                    exp->error(\"use '%s' for non-floating comparisons rather than floating point operator '%s'\",\n+                    exp->error(\"use `%s` for non-floating comparisons rather than floating point operator `%s`\",\n                         Token::toChars(altop), Token::toChars(exp->op));\n                 }\n             }\n             else\n             {\n-                exp->error(\"use std.math.isNaN to deal with NaN operands rather than floating point operator '%s'\",\n+                exp->error(\"use std.math.isNaN to deal with NaN operands rather than floating point operator `%s`\",\n                     Token::toChars(exp->op));\n             }\n             return setError();\n@@ -7987,20 +7978,20 @@ class ExpressionSemanticVisitor : public Visitor\n         if (exp->econd->op == TOKdotid)\n             ((DotIdExp *)exp->econd)->noderef = true;\n \n-        Expression *ec = semantic(exp->econd, sc);\n+        Expression *ec = expressionSemantic(exp->econd, sc);\n         ec = resolveProperties(sc, ec);\n         ec = ec->toBoolean(sc);\n \n         unsigned cs0 = sc->callSuper;\n         unsigned *fi0 = sc->saveFieldInit();\n-        Expression *e1x = semantic(exp->e1, sc);\n+        Expression *e1x = expressionSemantic(exp->e1, sc);\n         e1x = resolveProperties(sc, e1x);\n \n         unsigned cs1 = sc->callSuper;\n         unsigned *fi1 = sc->fieldinit;\n         sc->callSuper = cs0;\n         sc->fieldinit = fi0;\n-        Expression *e2x = semantic(exp->e2, sc);\n+        Expression *e2x = expressionSemantic(exp->e2, sc);\n         e2x = resolveProperties(sc, e2x);\n \n         sc->mergeCallSuper(exp->loc, cs1);\n@@ -8151,7 +8142,7 @@ Expression *trySemantic(Expression *exp, Scope* sc)\n {\n     //printf(\"+trySemantic(%s)\\n\", toChars());\n     unsigned errors = global.startGagging();\n-    Expression *e = semantic(exp, sc);\n+    Expression *e = expressionSemantic(exp, sc);\n     if (global.endGagging(errors))\n     {\n         e = NULL;\n@@ -8166,7 +8157,7 @@ Expression *trySemantic(Expression *exp, Scope* sc)\n  */\n Expression *unaSemantic(UnaExp *e, Scope *sc)\n {\n-    Expression *e1x = semantic(e->e1, sc);\n+    Expression *e1x = expressionSemantic(e->e1, sc);\n     if (e1x->op == TOKerror)\n         return e1x;\n     e->e1 = e1x;\n@@ -8179,8 +8170,8 @@ Expression *unaSemantic(UnaExp *e, Scope *sc)\n  */\n Expression *binSemantic(BinExp *e, Scope *sc)\n {\n-    Expression *e1x = semantic(e->e1, sc);\n-    Expression *e2x = semantic(e->e2, sc);\n+    Expression *e1x = expressionSemantic(e->e1, sc);\n+    Expression *e2x = expressionSemantic(e->e2, sc);\n \n     // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n     if (e1x->op == TOKtype)\n@@ -8213,7 +8204,7 @@ Expression *binSemanticProp(BinExp *e, Scope *sc)\n }\n \n // entrypoint for semantic ExpressionSemanticVisitor\n-Expression *semantic(Expression *e, Scope *sc)\n+Expression *expressionSemantic(Expression *e, Scope *sc)\n {\n     ExpressionSemanticVisitor v = ExpressionSemanticVisitor(sc);\n     e->accept(&v);\n@@ -8261,7 +8252,7 @@ Expression *semanticX(DotIdExp *exp, Scope *sc)\n                     mangleToBuffer(ds, &buf);\n                     const char *s = buf.extractChars();\n                     Expression *e = new StringExp(exp->loc, const_cast<char*>(s), strlen(s));\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     return e;\n                 }\n             default:\n@@ -8292,13 +8283,13 @@ Expression *semanticX(DotIdExp *exp, Scope *sc)\n         for (size_t i = 0; i < exps->length; i++)\n         {\n             Expression *e = (*te->exps)[i];\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             e = new DotIdExp(e->loc, e, Id::offsetof);\n             (*exps)[i] = e;\n         }\n         // Don't evaluate te->e0 in runtime\n         Expression *e = new TupleExp(exp->loc, NULL, exps);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     if (exp->e1->op == TOKtuple && exp->ident == Id::length)\n@@ -8312,13 +8303,13 @@ Expression *semanticX(DotIdExp *exp, Scope *sc)\n     // Bugzilla 14416: Template has no built-in properties except for 'stringof'.\n     if ((exp->e1->op == TOKdottd || exp->e1->op == TOKtemplate) && exp->ident != Id::stringof)\n     {\n-        exp->error(\"template %s does not have property '%s'\", exp->e1->toChars(), exp->ident->toChars());\n+        exp->error(\"template %s does not have property `%s`\", exp->e1->toChars(), exp->ident->toChars());\n         return new ErrorExp();\n     }\n \n     if (!exp->e1->type)\n     {\n-        exp->error(\"expression %s does not have property '%s'\", exp->e1->toChars(), exp->ident->toChars());\n+        exp->error(\"expression %s does not have property `%s`\", exp->e1->toChars(), exp->ident->toChars());\n         return new ErrorExp();\n     }\n \n@@ -8425,9 +8416,9 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                     (!v->type->deco && v->inuse))\n                 {\n                     if (v->inuse)\n-                        exp->error(\"circular reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                        exp->error(\"circular reference to %s `%s`\", v->kind(), v->toPrettyChars());\n                     else\n-                        exp->error(\"forward reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                        exp->error(\"forward reference to %s `%s`\", v->kind(), v->toPrettyChars());\n                     return new ErrorExp();\n                 }\n                 if (v->type->ty == Terror)\n@@ -8441,12 +8432,12 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                      */\n                     if (v->inuse)\n                     {\n-                        ::error(exp->loc, \"circular initialization of %s '%s'\", v->kind(), v->toPrettyChars());\n+                        ::error(exp->loc, \"circular initialization of %s `%s`\", v->kind(), v->toPrettyChars());\n                         return new ErrorExp();\n                     }\n                     e = v->expandInitializer(exp->loc);\n                     v->inuse++;\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     v->inuse--;\n                     return e;\n                 }\n@@ -8456,7 +8447,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                     if (!eleft)\n                         eleft = new ThisExp(exp->loc);\n                     e = new DotVarExp(exp->loc, eleft, v);\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                 }\n                 else\n                 {\n@@ -8467,7 +8458,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                     }\n                 }\n                 e = e->deref();\n-                return semantic(e, sc);\n+                return expressionSemantic(e, sc);\n             }\n \n             FuncDeclaration *f = s->isFuncDeclaration();\n@@ -8481,7 +8472,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                     if (!eleft)\n                         eleft = new ThisExp(exp->loc);\n                     e = new DotVarExp(exp->loc, eleft, f, true);\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                 }\n                 else\n                 {\n@@ -8499,7 +8490,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                     e = new DotTemplateExp(exp->loc, eleft, td);\n                 else\n                     e = new TemplateExp(exp->loc, td);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 return e;\n             }\n             if (OverDeclaration *od = s->isOverDeclaration())\n@@ -8520,7 +8511,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n \n             if (Type *t = s->getType())\n             {\n-                return semantic(new TypeExp(exp->loc, t), sc);\n+                return expressionSemantic(new TypeExp(exp->loc, t), sc);\n             }\n \n             TupleDeclaration *tup = s->isTupleDeclaration();\n@@ -8529,11 +8520,11 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                 if (eleft)\n                 {\n                     e = new DotVarExp(exp->loc, eleft, tup);\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     return e;\n                 }\n                 e = new TupleExp(exp->loc, tup);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 return e;\n             }\n \n@@ -8542,7 +8533,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n             {\n                 //printf(\"it's a ScopeDsymbol %s\\n\", exp->ident->toChars());\n                 e = new ScopeExp(exp->loc, sds);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 if (eleft)\n                     e = new DotExp(exp->loc, eleft, e);\n                 return e;\n@@ -8552,7 +8543,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n             if (imp)\n             {\n                 ie = new ScopeExp(exp->loc, imp->pkg);\n-                return semantic(ie, sc);\n+                return expressionSemantic(ie, sc);\n             }\n \n             // BUG: handle other cases like in IdentifierExp::semantic()\n@@ -8562,7 +8553,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n         {\n             const char *p = ie->toChars();\n             e = new StringExp(exp->loc, const_cast<char *>(p), strlen(p));\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n         if (ie->sds->isPackage() ||\n@@ -8580,11 +8571,11 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n                 exp->error(\"undefined identifier `%s` in %s `%s`, perhaps add `static import %s;`\",\n                     exp->ident->toChars(), ie->sds->kind(), ie->sds->toPrettyChars(), s->toPrettyChars());\n             else\n-                exp->error(\"undefined identifier '%s' in %s '%s', did you mean %s '%s'?\",\n+                exp->error(\"undefined identifier `%s` in %s `%s`, did you mean %s `%s`?\",\n                     exp->ident->toChars(), ie->sds->kind(), ie->sds->toPrettyChars(), s->kind(), s->toChars());\n         }\n         else\n-            exp->error(\"undefined identifier '%s' in %s '%s'\",\n+            exp->error(\"undefined identifier `%s` in %s `%s`\",\n                        exp->ident->toChars(), ie->sds->kind(), ie->sds->toPrettyChars());\n         return new ErrorExp();\n     }\n@@ -8609,7 +8600,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n         if (flag && t1bn->ty == Tvoid)\n             return NULL;\n         e = new PtrExp(exp->loc, exp->e1);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e->type->dotExp(sc, e, exp->ident, flag | (exp->noderef ? 2 : 0));\n     }\n     else\n@@ -8618,7 +8609,7 @@ Expression *semanticY(DotIdExp *exp, Scope *sc, int flag)\n             flag = 0;\n         e = exp->e1->type->dotExp(sc, exp->e1, exp->ident, flag | (exp->noderef ? 2 : 0));\n         if (e)\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n         return e;\n     }\n }\n@@ -8668,7 +8659,7 @@ Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag)\n             if (td)\n             {\n                 e = new DotTemplateExp(dve->loc, dve->e1, td);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n             }\n         }\n         else if (dve->var->isOverDeclaration())\n@@ -8678,22 +8669,22 @@ Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag)\n                 goto Lerr;\n             if (exp->ti->needsTypeInference(sc))\n                 return exp;\n-            exp->ti->semantic(sc);\n+            dsymbolSemantic(exp->ti, sc);\n             if (!exp->ti->inst || exp->ti->errors)    // if template failed to expand\n                 return new ErrorExp();\n             Dsymbol *s = exp->ti->toAlias();\n             Declaration *v = s->isDeclaration();\n             if (v)\n             {\n                 if (v->type && !v->type->deco)\n-                    v->type = v->type->semantic(v->loc, sc);\n+                    v->type = typeSemantic(v->type, v->loc, sc);\n                 e = new DotVarExp(exp->loc, exp->e1, v);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 return e;\n             }\n             e = new ScopeExp(exp->loc, exp->ti);\n             e = new DotExp(exp->loc, exp->e1, e);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n     }\n@@ -8706,14 +8697,14 @@ Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag)\n             if (td)\n             {\n                 e = new TemplateExp(ve->loc, td);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n             }\n         }\n         else if (OverDeclaration *od = ve->var->isOverDeclaration())\n         {\n             exp->ti->tempdecl = od;\n             e = new ScopeExp(exp->loc, exp->ti);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n     }\n@@ -8727,27 +8718,27 @@ Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag)\n             return new ErrorExp();\n         if (exp->ti->needsTypeInference(sc))\n             return exp;\n-        exp->ti->semantic(sc);\n+        dsymbolSemantic(exp->ti, sc);\n         if (!exp->ti->inst || exp->ti->errors)    // if template failed to expand\n             return new ErrorExp();\n         Dsymbol *s = exp->ti->toAlias();\n         Declaration *v = s->isDeclaration();\n         if (v && (v->isFuncDeclaration() || v->isVarDeclaration()))\n         {\n             e = new DotVarExp(exp->loc, exp->e1, v);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n         e = new ScopeExp(exp->loc, exp->ti);\n         e = new DotExp(exp->loc, exp->e1, e);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     else if (e->op == TOKtemplate)\n     {\n         exp->ti->tempdecl = ((TemplateExp *)e)->td;\n         e = new ScopeExp(exp->loc, exp->ti);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     else if (e->op == TOKdot)\n@@ -8763,22 +8754,22 @@ Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag)\n             }\n             if (exp->ti->needsTypeInference(sc))\n                 return exp;\n-            exp->ti->semantic(sc);\n+            dsymbolSemantic(exp->ti, sc);\n             if (!exp->ti->inst || exp->ti->errors)    // if template failed to expand\n                 return new ErrorExp();\n             Dsymbol *s = exp->ti->toAlias();\n             Declaration *v = s->isDeclaration();\n             if (v)\n             {\n                 if (v->type && !v->type->deco)\n-                    v->type = v->type->semantic(v->loc, sc);\n+                    v->type = typeSemantic(v->type, v->loc, sc);\n                 e = new DotVarExp(exp->loc, exp->e1, v);\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 return e;\n             }\n             e = new ScopeExp(exp->loc, exp->ti);\n             e = new DotExp(exp->loc, exp->e1, e);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n     }\n@@ -8787,7 +8778,7 @@ Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag)\n         OverExp *oe = (OverExp *)e;\n         exp->ti->tempdecl = oe->vars;\n         e = new ScopeExp(exp->loc, exp->ti);\n-        e = semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n Lerr:"}, {"sha": "7a216a97941b1aee81dd3f7a2bcfe32ec45421c0", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 145, "deletions": 2811, "changes": 2956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=a3b38b7781622babb5ca68c621367770a65012fa"}, {"sha": "d9d59d685cad749107146e48dbcc15f949e46748", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "a11c9c353d9130b35e9c66f74b456b0d1cd4eb19", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Dave Fladebo\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "d464d4aa618a6d46811a6b9e9fee806c0529e79b", "filename": "gcc/d/dmd/hdrgen.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fhdrgen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fhdrgen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Dave Fladebo\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "fc58a3c4462fd64a22efdfd2193df620a6fbac73", "filename": "gcc/d/dmd/iasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fiasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fiasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasm.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2018-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2018-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "e3940a8adbf4da0d4f1ce9114f5028e1b395959a", "filename": "gcc/d/dmd/iasmgcc.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fiasmgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fiasmgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fiasmgcc.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2018-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2018-2021 by The D Language Foundation, All Rights Reserved\n  * written by Iain Buclaw\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -12,14 +12,12 @@\n  */\n \n #include \"scope.h\"\n+#include \"expression.h\"\n #include \"declaration.h\"\n #include \"errors.h\"\n #include \"parse.h\"\n #include \"statement.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-Statement *semantic(Statement *s, Scope *sc);\n-\n /***********************************\n  * Parse list of extended asm input or output operands.\n  * Grammar:\n@@ -321,7 +319,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n     s->stc = sc->stc;\n \n     // Fold the instruction template string.\n-    s->insn = semantic(s->insn, sc);\n+    s->insn = expressionSemantic(s->insn, sc);\n     s->insn = s->insn->ctfeInterpret();\n \n     if (s->insn->op != TOKstring || ((StringExp *) s->insn)->sz != 1)\n@@ -336,7 +334,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n         for (size_t i = 0; i < s->args->length; i++)\n         {\n             Expression *e = (*s->args)[i];\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             // Check argument is a valid lvalue/rvalue.\n             if (i < s->outputargs)\n                 e = e->modifiableLvalue(sc, NULL);\n@@ -345,7 +343,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n             (*s->args)[i] = e;\n \n             e = (*s->constraints)[i];\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             assert(e->op == TOKstring && ((StringExp *) e)->sz == 1);\n             (*s->constraints)[i] = e;\n         }\n@@ -357,7 +355,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n         for (size_t i = 0; i < s->clobbers->length; i++)\n         {\n             Expression *e = (*s->clobbers)[i];\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             assert(e->op == TOKstring && ((StringExp *) e)->sz == 1);\n             (*s->clobbers)[i] = e;\n         }\n@@ -373,7 +371,7 @@ Statement *gccAsmSemantic(GccAsmStatement *s, Scope *sc)\n             if (!s->gotos)\n                 s->gotos = new GotoStatements();\n             s->gotos->push(gs);\n-            semantic(gs, sc);\n+            statementSemantic(gs, sc);\n         }\n     }\n "}, {"sha": "197d288e5323a7270c63f952823df05a21989014", "filename": "gcc/d/dmd/identifier.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fidentifier.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fidentifier.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "278ce9b8a7671c6918d0cefcbdd96e1268a0ee07", "filename": "gcc/d/dmd/identifier.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fidentifier.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fidentifier.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidentifier.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "59faa993b9bb473958a7fbc8703496b36162e431", "filename": "gcc/d/dmd/idgen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fidgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fidgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidgen.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "d7c27eaa7714051be4b1db40d1b23dd972cf8e10", "filename": "gcc/d/dmd/impcnvgen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fimpcnvgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fimpcnvgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimpcnvgen.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "239cb07333266b2c3054c3481982899a2adb8230", "filename": "gcc/d/dmd/imphint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fimphint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fimphint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimphint.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2010-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "e49ad15c2d30e6eb2cfca115d8788b122d4c7e1c", "filename": "gcc/d/dmd/import.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimport.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -47,8 +47,6 @@ class Import : public Dsymbol\n     Dsymbol *syntaxCopy(Dsymbol *s);    // copy only syntax trees\n     void load(Scope *sc);\n     void importAll(Scope *sc);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n     Dsymbol *toAlias();\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope* sc);"}, {"sha": "d18e0549aace1411b2505c11484462a8f8262bed", "filename": "gcc/d/dmd/init.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -25,9 +25,6 @@\n #include \"id.h\"\n #include \"tokens.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n-\n /********************************** Initializer *******************************/\n \n Initializer::Initializer(Loc loc)"}, {"sha": "4ba18d6a47457fc86eebaaf2a0dd3a14c02750e7", "filename": "gcc/d/dmd/init.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Finit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Finit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -21,6 +21,7 @@ class Expression;\n struct Scope;\n class Type;\n class AggregateDeclaration;\n+class Initializer;\n class ErrorInitializer;\n class VoidInitializer;\n class StructInitializer;\n@@ -29,6 +30,8 @@ class ExpInitializer;\n \n enum NeedInterpret { INITnointerpret, INITinterpret };\n \n+Initializer *initializerSemantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n+\n class Initializer : public ASTNode\n {\n public:"}, {"sha": "c7d1dfe0deb8a5e84f6bb59353186ff11b2027f9", "filename": "gcc/d/dmd/initsem.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Finitsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Finitsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -20,9 +20,7 @@\n #include \"id.h\"\n \n FuncDeclaration *isFuncAddress(Expression *e, bool *hasOverloads = NULL);\n-Expression *semantic(Expression *e, Scope *sc);\n Initializer *inferType(Initializer *init, Scope *sc);\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n bool hasNonConstPointers(Expression *e);\n \n class InitializerSemanticVisitor : public Visitor\n@@ -97,10 +95,10 @@ class InitializerSemanticVisitor : public Visitor\n                     {\n                         s = sd->search_correct(id);\n                         if (s)\n-                            error(i->loc, \"'%s' is not a member of '%s', did you mean %s '%s'?\",\n+                            error(i->loc, \"`%s` is not a member of `%s`, did you mean %s `%s`?\",\n                                   id->toChars(), sd->toChars(), s->kind(), s->toChars());\n                         else\n-                            error(i->loc, \"'%s' is not a member of '%s'\", id->toChars(), sd->toChars());\n+                            error(i->loc, \"`%s` is not a member of `%s`\", id->toChars(), sd->toChars());\n                         result = new ErrorInitializer();\n                         return;\n                     }\n@@ -130,7 +128,7 @@ class InitializerSemanticVisitor : public Visitor\n                 VarDeclaration *vd = sd->fields[fieldi];\n                 if ((*elements)[fieldi])\n                 {\n-                    error(i->loc, \"duplicate initializer for field '%s'\", vd->toChars());\n+                    error(i->loc, \"duplicate initializer for field `%s`\", vd->toChars());\n                     errors = true;\n                     continue;\n                 }\n@@ -148,7 +146,7 @@ class InitializerSemanticVisitor : public Visitor\n \n                 assert(sc);\n                 Initializer *iz = i->value[j];\n-                iz = ::semantic(iz, sc, vd->type->addMod(t->mod), needInterpret);\n+                iz = initializerSemantic(iz, sc, vd->type->addMod(t->mod), needInterpret);\n                 Expression *ex = initializerToExpression(iz);\n                 if (ex->op == TOKerror)\n                 {\n@@ -174,7 +172,7 @@ class InitializerSemanticVisitor : public Visitor\n             sle->type = t;\n \n             ExpInitializer *ie = new ExpInitializer(i->loc, sle);\n-            result = ::semantic(ie, sc, t, needInterpret);\n+            result = initializerSemantic(ie, sc, t, needInterpret);\n             return;\n         }\n         else if ((t->ty == Tdelegate || (t->ty == Tpointer && t->nextOf()->ty == Tfunction)) && i->value.length == 0)\n@@ -188,7 +186,7 @@ class InitializerSemanticVisitor : public Visitor\n             fd->endloc = i->loc;\n             Expression *e = new FuncExp(i->loc, fd);\n             ExpInitializer *ie = new ExpInitializer(i->loc, e);\n-            result = ::semantic(ie, sc, t, needInterpret);\n+            result = initializerSemantic(ie, sc, t, needInterpret);\n             return;\n         }\n \n@@ -235,7 +233,7 @@ class InitializerSemanticVisitor : public Visitor\n                         goto Lerr;\n                     }\n                     ExpInitializer *ei = new ExpInitializer(e->loc, e);\n-                    result = ::semantic(ei, sc, t, needInterpret);\n+                    result = initializerSemantic(ei, sc, t, needInterpret);\n                     return;\n                 }\n             case Tpointer:\n@@ -257,7 +255,7 @@ class InitializerSemanticVisitor : public Visitor\n             if (idx)\n             {\n                 sc = sc->startCTFE();\n-                idx = ::semantic(idx, sc);\n+                idx = expressionSemantic(idx, sc);\n                 sc = sc->endCTFE();\n                 idx = idx->ctfeInterpret();\n                 i->index[j] = idx;\n@@ -276,7 +274,7 @@ class InitializerSemanticVisitor : public Visitor\n             ExpInitializer *ei = val->isExpInitializer();\n             if (ei && !idx)\n                 ei->expandTuples = true;\n-            val = ::semantic(val, sc, t->nextOf(), needInterpret);\n+            val = initializerSemantic(val, sc, t->nextOf(), needInterpret);\n             if (val->isErrorInitializer())\n                 errors = true;\n \n@@ -344,7 +342,7 @@ class InitializerSemanticVisitor : public Visitor\n     {\n         //printf(\"ExpInitializer::semantic(%s), type = %s\\n\", i->exp->toChars(), t->toChars());\n         if (needInterpret) sc = sc->startCTFE();\n-        i->exp = ::semantic(i->exp, sc);\n+        i->exp = expressionSemantic(i->exp, sc);\n         i->exp = resolveProperties(sc, i->exp);\n         if (needInterpret) sc = sc->endCTFE();\n         if (i->exp->op == TOKerror)\n@@ -388,15 +386,15 @@ class InitializerSemanticVisitor : public Visitor\n         }\n         if (i->exp->op == TOKtype)\n         {\n-            i->exp->error(\"initializer must be an expression, not '%s'\", i->exp->toChars());\n+            i->exp->error(\"initializer must be an expression, not `%s`\", i->exp->toChars());\n             result = new ErrorInitializer();\n             return;\n         }\n \n         // Make sure all pointers are constants\n         if (needInterpret && hasNonConstPointers(i->exp))\n         {\n-            i->exp->error(\"cannot use non-constant CTFE pointer in an initializer '%s'\", i->exp->toChars());\n+            i->exp->error(\"cannot use non-constant CTFE pointer in an initializer `%s`\", i->exp->toChars());\n             result = new ErrorInitializer();\n             return;\n         }\n@@ -444,7 +442,7 @@ class InitializerSemanticVisitor : public Visitor\n                 e = new StructLiteralExp(i->loc, sd, NULL);\n                 e = new DotIdExp(i->loc, e, Id::ctor);\n                 e = new CallExp(i->loc, e, i->exp);\n-                e = ::semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 if (needInterpret)\n                     i->exp = e->ctfeInterpret();\n                 else\n@@ -513,7 +511,7 @@ class InitializerSemanticVisitor : public Visitor\n };\n \n // Performs semantic analisys on Initializer AST nodes\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret)\n+Initializer *initializerSemantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret)\n {\n     InitializerSemanticVisitor v = InitializerSemanticVisitor(sc, t, needInterpret);\n     init->accept(&v);\n@@ -633,7 +631,7 @@ class InferTypeVisitor : public Visitor\n     void visit(ExpInitializer *init)\n     {\n         //printf(\"ExpInitializer::inferType() %s\\n\", init->toChars());\n-        init->exp = ::semantic(init->exp, sc);\n+        init->exp = expressionSemantic(init->exp, sc);\n         init->exp = resolveProperties(sc, init->exp);\n \n         if (init->exp->op == TOKscope)\n@@ -897,8 +895,8 @@ class InitToExpressionVisitor : public Visitor\n                 size_t d = (size_t)tsa->dim->toInteger();\n                 Expressions *elements = new Expressions();\n                 elements->setDim(d);\n-                for (size_t i = 0; i < d; i++)\n-                    (*elements)[i] = e;\n+                for (size_t j = 0; j < d; j++)\n+                    (*elements)[j] = e;\n                 ArrayLiteralExp *ae = new ArrayLiteralExp(e->loc, itype, elements);\n                 result = ae;\n                 return;"}, {"sha": "36af8dac9eedadfa0e576d0d9b90c8f3225df399", "filename": "gcc/d/dmd/intrange.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fintrange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fintrange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by KennyTM\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "fd6153205c91e3da847164da00298fd46a6a9488", "filename": "gcc/d/dmd/intrange.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fintrange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fintrange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by KennyTM\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "832e559a875c2613ef87de3f44aaf8db9582c837", "filename": "gcc/d/dmd/json.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fjson.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fjson.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "d680001000fe4f4248102c229127276b53fe5fe3", "filename": "gcc/d/dmd/json.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fjson.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fjson.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "3ea932c036eb38adcb8a8a4c8d1337bfb37ab493", "filename": "gcc/d/dmd/lexer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Flexer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Flexer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -1699,7 +1699,7 @@ TOK Lexer::number(Token *t)\n                 ++p;\n                 if (base < 10 && !err)\n                 {\n-                    error(\"radix %d digit expected, not '%c'\", base, c);\n+                    error(\"radix %d digit expected, not `%c`\", base, c);\n                     err = true;\n                 }\n                 d = c - '0';\n@@ -1714,7 +1714,7 @@ TOK Lexer::number(Token *t)\n                         goto Lreal;\n                     if (!err)\n                     {\n-                        error(\"radix %d digit expected, not '%c'\", base, c);\n+                        error(\"radix %d digit expected, not `%c`\", base, c);\n                         err = true;\n                     }\n                 }\n@@ -2049,7 +2049,7 @@ TOK Lexer::inreal(Token *t)\n     if (isOutOfRange && !isLong)\n     {\n         const char *suffix = (result == TOKfloat32v || result == TOKimaginary32v) ? \"f\" : \"\";\n-        error(scanloc, \"number '%s%s' is not representable\", (char *)stringbuffer.slice().ptr, suffix);\n+        error(scanloc, \"number `%s%s` is not representable\", (char *)stringbuffer.slice().ptr, suffix);\n     }\n     return result;\n }"}, {"sha": "b36e7f7bdaf3dbc527085f4fa1db499160b9cd33", "filename": "gcc/d/dmd/lexer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Flexer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Flexer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "80ec36e00e6b5303cf3817b964257cecb5122128", "filename": "gcc/d/dmd/macro.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmacro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmacro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmacro.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "544f77b8b0ba0ca95071df0fdd502b55b2b3e85c", "filename": "gcc/d/dmd/mangle.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmangle.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "9b9c278c8a78842d50f96ce6ec0e04171006ca5a", "filename": "gcc/d/dmd/mars.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmars.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmars.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmars.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "03078b5e83307e5c4256f22de39eed6a34a179ac", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -43,7 +43,6 @@ class Package : public ScopeDsymbol\n \n     bool isAncestorPackageOf(const Package * const pkg) const;\n \n-    void semantic(Scope *);\n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n     void accept(Visitor *v) { v->visit(this); }\n \n@@ -124,9 +123,6 @@ class Module : public Package\n     bool read(Loc loc); // read file, returns 'true' if succeed, 'false' otherwise.\n     Module *parse();    // syntactic parse\n     void importAll(Scope *sc);\n-    void semantic(Scope *);    // semantic analysis\n-    void semantic2(Scope *);   // pass 2 semantic analysis\n-    void semantic3(Scope *);   // pass 3 semantic analysis\n     int needModuleInfo();\n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n     bool isPackageAccessible(Package *p, Prot protection, int flags = 0);"}, {"sha": "c1071b2f278ea11641ec3b0481e4764474191a49", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 85, "deletions": 1288, "changes": 1373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -37,12 +37,8 @@ int Parameter_foreach(Parameters *parameters, ForeachDg dg, void *ctx, size_t *p\n FuncDeclaration *isFuncAddress(Expression *e, bool *hasOverloads = NULL);\n Expression *extractSideEffect(Scope *sc, const char *name, Expression **e0, Expression *e, bool alwaysCopy = false);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n-Expression *semantic(Expression *e, Scope *sc);\n-Expression *semanticY(DotIdExp *exp, Scope *sc, int flag);\n-Expression *semanticY(DotTemplateInstanceExp *exp, Scope *sc, int flag);\n Expression *typeToExpression(Type *t);\n Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i = 0);\n-Initializer *semantic(Initializer *init, Scope *sc, Type *t, NeedInterpret needInterpret);\n \n /***************************** Type *****************************/\n \n@@ -282,22 +278,11 @@ unsigned Type::alignsize()\n     return (unsigned)size(Loc());\n }\n \n-Type *Type::semantic(Loc loc, Scope *)\n-{\n-    if (ty == Tint128 || ty == Tuns128)\n-    {\n-        error(loc, \"cent and ucent types not implemented\");\n-        return terror;\n-    }\n-\n-    return merge();\n-}\n-\n Type *Type::trySemantic(Loc loc, Scope *sc)\n {\n     //printf(\"+trySemantic(%s) %d\\n\", toChars(), global.errors);\n     unsigned errors = global.startGagging();\n-    Type *t = semantic(loc, sc);\n+    Type *t = typeSemantic(this, loc, sc);\n     if (global.endGagging(errors) || t->ty == Terror)        // if any errors happened\n     {\n         t = NULL;\n@@ -2070,15 +2055,15 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)\n         {\n             e = new StringExp(loc, (char *)deco, strlen(deco));\n             Scope sc;\n-            e = ::semantic(e, &sc);\n+            e = expressionSemantic(e, &sc);\n         }\n     }\n     else if (ident == Id::stringof)\n     {\n         const char *s = toChars();\n         e = new StringExp(loc, const_cast<char *>(s), strlen(s));\n         Scope sc;\n-        e = ::semantic(e, &sc);\n+        e = expressionSemantic(e, &sc);\n     }\n     else if (flag && this != Type::terror)\n     {\n@@ -2094,9 +2079,9 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)\n         if (this != Type::terror)\n         {\n             if (s)\n-                error(loc, \"no property '%s' for type '%s', did you mean '%s'?\", ident->toChars(), toChars(), s->toChars());\n+                error(loc, \"no property `%s` for type `%s`, did you mean `%s`?\", ident->toChars(), toChars(), s->toChars());\n             else\n-                error(loc, \"no property '%s' for type '%s'\", ident->toChars(), toChars());\n+                error(loc, \"no property `%s` for type `%s`\", ident->toChars(), toChars());\n         }\n         e = new ErrorExp();\n     }\n@@ -2164,7 +2149,7 @@ Expression *Type::dotExp(Scope *sc, Expression *e, Identifier *ident, int flag)\n \n Lreturn:\n     if (e)\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -2223,7 +2208,7 @@ Expression *Type::noMember(Scope *sc, Expression *e, Identifier *ident, int flag\n              */\n             e = build_overload(e->loc, sc, e, NULL, fd);\n             e = new DotIdExp(e->loc, e, ident);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             --nest;\n             return e;\n         }\n@@ -2442,7 +2427,7 @@ TypeFunction *Type::toTypeFunction()\n void Type::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool)\n {\n     //printf(\"Type::resolve() %s, %d\\n\", toChars(), ty);\n-    Type *t = semantic(loc, sc);\n+    Type *t = typeSemantic(this, loc, sc);\n     *pt = t;\n     *pe = NULL;\n     *ps = NULL;\n@@ -3576,7 +3561,7 @@ Expression *TypeBasic::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n         return Type::dotExp(sc, e, ident, flag);\n     }\n     if (!(flag & 1) || e)\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -3803,39 +3788,6 @@ Type *TypeVector::syntaxCopy()\n     return new TypeVector(basetype->syntaxCopy());\n }\n \n-Type *TypeVector::semantic(Loc loc, Scope *sc)\n-{\n-    unsigned int errors = global.errors;\n-    basetype = basetype->semantic(loc, sc);\n-    if (errors != global.errors)\n-        return terror;\n-    basetype = basetype->toBasetype()->mutableOf();\n-    if (basetype->ty != Tsarray)\n-    {\n-        error(loc, \"T in __vector(T) must be a static array, not %s\", basetype->toChars());\n-        return terror;\n-    }\n-    TypeSArray *t = (TypeSArray *)basetype;\n-    int sz = (int)t->size(loc);\n-    switch (target.isVectorTypeSupported(sz, t->nextOf()))\n-    {\n-    case 0: // valid\n-        break;\n-    case 1: // no support at all\n-        error(loc, \"SIMD vector types not supported on this platform\");\n-        return terror;\n-    case 2: // invalid base type\n-        error(loc, \"vector type %s is not supported on this platform\", toChars());\n-        return terror;\n-    case 3: // invalid size\n-        error(loc, \"%d byte vector type %s is not supported on this platform\", sz, toChars());\n-        return terror;\n-    default:\n-        assert(0);\n-    }\n-    return merge();\n-}\n-\n TypeBasic *TypeVector::elementType()\n {\n     assert(basetype->ty == Tsarray);\n@@ -3873,7 +3825,7 @@ Expression *TypeVector::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n          * __vector(float[4]), and a type paint won't do.\n          */\n         e = new AddrExp(e->loc, e);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         e = e->castTo(sc, basetype->nextOf()->pointerTo());\n         return e;\n     }\n@@ -3882,7 +3834,7 @@ Expression *TypeVector::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         //e = e->castTo(sc, basetype);\n         // Keep lvalue-ness\n         e = new VectorArrayExp(e->loc, e);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n     if (ident == Id::_init || ident == Id::offsetof || ident == Id::stringof || ident == Id::__xalignof)\n@@ -3984,7 +3936,7 @@ Expression *TypeArray::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n     e = Type::dotExp(sc, e, ident, flag);\n \n     if (!(flag & 1) || e)\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -4033,48 +3985,6 @@ unsigned TypeSArray::alignsize()\n     return next->alignsize();\n }\n \n-/**************************\n- * This evaluates exp while setting length to be the number\n- * of elements in the tuple t.\n- */\n-Expression *semanticLength(Scope *sc, Type *t, Expression *exp)\n-{\n-    if (t->ty == Ttuple)\n-    {\n-        ScopeDsymbol *sym = new ArrayScopeSymbol(sc, (TypeTuple *)t);\n-        sym->parent = sc->scopesym;\n-        sc = sc->push(sym);\n-\n-        sc = sc->startCTFE();\n-        exp = ::semantic(exp, sc);\n-        sc = sc->endCTFE();\n-\n-        sc->pop();\n-    }\n-    else\n-    {\n-        sc = sc->startCTFE();\n-        exp = ::semantic(exp, sc);\n-        sc = sc->endCTFE();\n-    }\n-\n-    return exp;\n-}\n-\n-Expression *semanticLength(Scope *sc, TupleDeclaration *s, Expression *exp)\n-{\n-    ScopeDsymbol *sym = new ArrayScopeSymbol(sc, s);\n-    sym->parent = sc->scopesym;\n-    sc = sc->push(sym);\n-\n-    sc = sc->startCTFE();\n-    exp = ::semantic(exp, sc);\n-    sc = sc->endCTFE();\n-\n-    sc->pop();\n-    return exp;\n-}\n-\n void TypeSArray::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid)\n {\n     //printf(\"TypeSArray::resolve() %s\\n\", toChars());\n@@ -4097,7 +4007,7 @@ void TypeSArray::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n             sym->parent = sc->scopesym;\n             sc = sc->push(sym);\n             sc = sc->startCTFE();\n-            dim = ::semantic(dim, sc);\n+            dim = expressionSemantic(dim, sc);\n             sc = sc->endCTFE();\n             sc = sc->pop();\n \n@@ -4163,140 +4073,6 @@ void TypeSArray::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n     }\n }\n \n-Type *TypeSArray::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeSArray::semantic() %s\\n\", toChars());\n-\n-    Type *t;\n-    Expression *e;\n-    Dsymbol *s;\n-    next->resolve(loc, sc, &e, &t, &s);\n-    if (dim && s && s->isTupleDeclaration())\n-    {   TupleDeclaration *sd = s->isTupleDeclaration();\n-\n-        dim = semanticLength(sc, sd, dim);\n-        dim = dim->ctfeInterpret();\n-        uinteger_t d = dim->toUInteger();\n-\n-        if (d >= sd->objects->length)\n-        {   error(loc, \"tuple index %llu exceeds %u\", d, sd->objects->length);\n-            return Type::terror;\n-        }\n-        RootObject *o = (*sd->objects)[(size_t)d];\n-        if (o->dyncast() != DYNCAST_TYPE)\n-        {   error(loc, \"%s is not a type\", toChars());\n-            return Type::terror;\n-        }\n-        t = ((Type *)o)->addMod(this->mod);\n-        return t;\n-    }\n-\n-    Type *tn = next->semantic(loc, sc);\n-    if (tn->ty == Terror)\n-        return terror;\n-\n-    Type *tbn = tn->toBasetype();\n-\n-    if (dim)\n-    {\n-        unsigned int errors = global.errors;\n-        dim = semanticLength(sc, tbn, dim);\n-        if (errors != global.errors)\n-            goto Lerror;\n-\n-        dim = dim->optimize(WANTvalue);\n-        dim = dim->ctfeInterpret();\n-        if (dim->op == TOKerror)\n-            goto Lerror;\n-        errors = global.errors;\n-        dinteger_t d1 = dim->toInteger();\n-        if (errors != global.errors)\n-            goto Lerror;\n-\n-        dim = dim->implicitCastTo(sc, tsize_t);\n-        dim = dim->optimize(WANTvalue);\n-        if (dim->op == TOKerror)\n-            goto Lerror;\n-        errors = global.errors;\n-        dinteger_t d2 = dim->toInteger();\n-        if (errors != global.errors)\n-            goto Lerror;\n-\n-        if (dim->op == TOKerror)\n-            goto Lerror;\n-\n-        if (d1 != d2)\n-        {\n-        Loverflow:\n-            error(loc, \"%s size %llu * %llu exceeds 0x%llx size limit for static array\",\n-                toChars(), (unsigned long long)tbn->size(loc), (unsigned long long)d1, target.maxStaticDataSize);\n-            goto Lerror;\n-        }\n-\n-        Type *tbx = tbn->baseElemOf();\n-        if ((tbx->ty == Tstruct && !((TypeStruct *)tbx)->sym->members) ||\n-            (tbx->ty == Tenum && !((TypeEnum *)tbx)->sym->members))\n-        {\n-            /* To avoid meaningless error message, skip the total size limit check\n-             * when the bottom of element type is opaque.\n-             */\n-        }\n-        else if (tbn->isTypeBasic() ||\n-                 tbn->ty == Tpointer ||\n-                 tbn->ty == Tarray ||\n-                 tbn->ty == Tsarray ||\n-                 tbn->ty == Taarray ||\n-                 (tbn->ty == Tstruct && (((TypeStruct *)tbn)->sym->sizeok == SIZEOKdone)) ||\n-                 tbn->ty == Tclass)\n-        {\n-            /* Only do this for types that don't need to have semantic()\n-             * run on them for the size, since they may be forward referenced.\n-             */\n-            bool overflow = false;\n-            if (mulu(tbn->size(loc), d2, overflow) >= target.maxStaticDataSize || overflow)\n-                goto Loverflow;\n-        }\n-    }\n-    switch (tbn->ty)\n-    {\n-        case Ttuple:\n-        {   // Index the tuple to get the type\n-            assert(dim);\n-            TypeTuple *tt = (TypeTuple *)tbn;\n-            uinteger_t d = dim->toUInteger();\n-\n-            if (d >= tt->arguments->length)\n-            {   error(loc, \"tuple index %llu exceeds %u\", d, tt->arguments->length);\n-                goto Lerror;\n-            }\n-            Type *telem = (*tt->arguments)[(size_t)d]->type;\n-            return telem->addMod(this->mod);\n-        }\n-        case Tfunction:\n-        case Tnone:\n-            error(loc, \"can't have array of %s\", tbn->toChars());\n-            goto Lerror;\n-        default:\n-            break;\n-    }\n-    if (tbn->isscope())\n-    {   error(loc, \"cannot have array of scope %s\", tbn->toChars());\n-        goto Lerror;\n-    }\n-\n-    /* Ensure things like const(immutable(T)[3]) become immutable(T[3])\n-     * and const(T)[3] become const(T[3])\n-     */\n-    next = tn;\n-    transitive();\n-    t = addMod(tn->mod);\n-\n-    return t->merge();\n-\n-Lerror:\n-    return Type::terror;\n-}\n-\n Expression *TypeSArray::dotExp(Scope *sc, Expression *e, Identifier *ident, int flag)\n {\n     if (ident == Id::length)\n@@ -4324,7 +4100,7 @@ Expression *TypeSArray::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         e = TypeArray::dotExp(sc, e, ident, flag);\n     }\n     if (!(flag & 1) || e)\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -4502,32 +4278,6 @@ unsigned TypeDArray::alignsize()\n     return target.ptrsize;\n }\n \n-Type *TypeDArray::semantic(Loc loc, Scope *sc)\n-{\n-    Type *tn = next->semantic(loc,sc);\n-    Type *tbn = tn->toBasetype();\n-    switch (tbn->ty)\n-    {\n-        case Ttuple:\n-            return tbn;\n-        case Tfunction:\n-        case Tnone:\n-            error(loc, \"can't have array of %s\", tbn->toChars());\n-            return Type::terror;\n-        case Terror:\n-            return Type::terror;\n-        default:\n-            break;\n-    }\n-    if (tn->isscope())\n-    {   error(loc, \"cannot have array of scope %s\", tn->toChars());\n-        return Type::terror;\n-    }\n-    next = tn;\n-    transitive();\n-    return merge();\n-}\n-\n void TypeDArray::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid)\n {\n     //printf(\"TypeDArray::resolve() %s\\n\", toChars());\n@@ -4694,188 +4444,6 @@ d_uns64 TypeAArray::size(Loc)\n     return target.ptrsize;\n }\n \n-Type *TypeAArray::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeAArray::semantic() %s index->ty = %d\\n\", toChars(), index->ty);\n-    if (deco)\n-        return this;\n-\n-    this->loc = loc;\n-    this->sc = sc;\n-    if (sc)\n-        sc->setNoFree();\n-\n-    // Deal with the case where we thought the index was a type, but\n-    // in reality it was an expression.\n-    if (index->ty == Tident || index->ty == Tinstance || index->ty == Tsarray ||\n-        index->ty == Ttypeof || index->ty == Treturn)\n-    {\n-        Expression *e;\n-        Type *t;\n-        Dsymbol *s;\n-\n-        index->resolve(loc, sc, &e, &t, &s);\n-        if (e)\n-        {\n-            // It was an expression -\n-            // Rewrite as a static array\n-            TypeSArray *tsa = new TypeSArray(next, e);\n-            return tsa->semantic(loc, sc);\n-        }\n-        else if (t)\n-            index = t->semantic(loc, sc);\n-        else\n-        {\n-            index->error(loc, \"index is not a type or an expression\");\n-            return Type::terror;\n-        }\n-    }\n-    else\n-        index = index->semantic(loc,sc);\n-    index = index->merge2();\n-\n-    if (index->nextOf() && !index->nextOf()->isImmutable())\n-    {\n-        index = index->constOf()->mutableOf();\n-    }\n-\n-    switch (index->toBasetype()->ty)\n-    {\n-        case Tfunction:\n-        case Tvoid:\n-        case Tnone:\n-        case Ttuple:\n-            error(loc, \"can't have associative array key of %s\", index->toBasetype()->toChars());\n-            /* fall through */\n-        case Terror:\n-            return Type::terror;\n-        default:\n-            break;\n-    }\n-    Type *tbase = index->baseElemOf();\n-    while (tbase->ty == Tarray)\n-        tbase = tbase->nextOf()->baseElemOf();\n-    if (tbase->ty == Tstruct)\n-    {\n-        /* AA's need typeid(index).equals() and getHash(). Issue error if not correctly set up.\n-         */\n-        StructDeclaration *sd = ((TypeStruct *)tbase)->sym;\n-        if (sd->semanticRun < PASSsemanticdone)\n-            sd->semantic(NULL);\n-\n-        // duplicate a part of StructDeclaration::semanticTypeInfoMembers\n-        //printf(\"AA = %s, key: xeq = %p, xerreq = %p xhash = %p\\n\", toChars(), sd->xeq, sd->xerreq, sd->xhash);\n-        if (sd->xeq &&\n-            sd->xeq->_scope &&\n-            sd->xeq->semanticRun < PASSsemantic3done)\n-        {\n-            unsigned errors = global.startGagging();\n-            sd->xeq->semantic3(sd->xeq->_scope);\n-            if (global.endGagging(errors))\n-                sd->xeq = sd->xerreq;\n-        }\n-\n-        const char *s = (index->toBasetype()->ty != Tstruct) ? \"bottom of \" : \"\";\n-        if (!sd->xeq)\n-        {\n-            // If sd->xhash != NULL:\n-            //   sd or its fields have user-defined toHash.\n-            //   AA assumes that its result is consistent with bitwise equality.\n-            // else:\n-            //   bitwise equality & hashing\n-        }\n-        else if (sd->xeq == sd->xerreq)\n-        {\n-            if (search_function(sd, Id::eq))\n-            {\n-                error(loc, \"%sAA key type %s does not have 'bool opEquals(ref const %s) const'\",\n-                        s, sd->toChars(), sd->toChars());\n-            }\n-            else\n-            {\n-                error(loc, \"%sAA key type %s does not support const equality\",\n-                        s, sd->toChars());\n-            }\n-            return Type::terror;\n-        }\n-        else if (!sd->xhash)\n-        {\n-            if (search_function(sd, Id::eq))\n-            {\n-                error(loc, \"%sAA key type %s should have 'size_t toHash() const nothrow @safe' if opEquals defined\",\n-                        s, sd->toChars());\n-            }\n-            else\n-            {\n-                error(loc, \"%sAA key type %s supports const equality but doesn't support const hashing\",\n-                        s, sd->toChars());\n-            }\n-            return Type::terror;\n-        }\n-        else\n-        {\n-            // defined equality & hashing\n-            assert(sd->xeq && sd->xhash);\n-\n-            /* xeq and xhash may be implicitly defined by compiler. For example:\n-             *   struct S { int[] arr; }\n-             * With 'arr' field equality and hashing, compiler will implicitly\n-             * generate functions for xopEquals and xtoHash in TypeInfo_Struct.\n-             */\n-        }\n-    }\n-    else if (tbase->ty == Tclass && !((TypeClass *)tbase)->sym->isInterfaceDeclaration())\n-    {\n-        ClassDeclaration *cd = ((TypeClass *)tbase)->sym;\n-        if (cd->semanticRun < PASSsemanticdone)\n-            cd->semantic(NULL);\n-\n-        if (!ClassDeclaration::object)\n-        {\n-            error(Loc(), \"missing or corrupt object.d\");\n-            fatal();\n-        }\n-\n-        static FuncDeclaration *feq   = NULL;\n-        static FuncDeclaration *fcmp  = NULL;\n-        static FuncDeclaration *fhash = NULL;\n-        if (!feq)   feq   = search_function(ClassDeclaration::object, Id::eq)->isFuncDeclaration();\n-        if (!fcmp)  fcmp  = search_function(ClassDeclaration::object, Id::cmp)->isFuncDeclaration();\n-        if (!fhash) fhash = search_function(ClassDeclaration::object, Id::tohash)->isFuncDeclaration();\n-        assert(fcmp && feq && fhash);\n-\n-        if (feq->vtblIndex < (int)cd->vtbl.length && cd->vtbl[feq ->vtblIndex] == feq)\n-        {\n-            if (fcmp->vtblIndex < (int)cd->vtbl.length && cd->vtbl[fcmp->vtblIndex] != fcmp)\n-            {\n-                const char *s = (index->toBasetype()->ty != Tclass) ? \"bottom of \" : \"\";\n-                error(loc, \"%sAA key type %s now requires equality rather than comparison\",\n-                    s, cd->toChars());\n-                errorSupplemental(loc, \"Please override Object.opEquals and toHash.\");\n-            }\n-        }\n-    }\n-    next = next->semantic(loc,sc)->merge2();\n-    transitive();\n-\n-    switch (next->toBasetype()->ty)\n-    {\n-        case Tfunction:\n-        case Tvoid:\n-        case Tnone:\n-        case Ttuple:\n-            error(loc, \"can't have associative array of %s\", next->toChars());\n-            /* fall through */\n-        case Terror:\n-            return Type::terror;\n-    }\n-    if (next->isscope())\n-    {   error(loc, \"cannot have array of scope %s\", next->toChars());\n-        return Type::terror;\n-    }\n-    return merge();\n-}\n-\n void TypeAArray::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid)\n {\n     //printf(\"TypeAArray::resolve() %s\\n\", toChars());\n@@ -5018,40 +4586,6 @@ Type *TypePointer::syntaxCopy()\n     return t;\n }\n \n-Type *TypePointer::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypePointer::semantic() %s\\n\", toChars());\n-    if (deco)\n-        return this;\n-    Type *n = next->semantic(loc, sc);\n-    switch (n->toBasetype()->ty)\n-    {\n-        case Ttuple:\n-            error(loc, \"can't have pointer to %s\", n->toChars());\n-            /* fall through */\n-        case Terror:\n-            return Type::terror;\n-        default:\n-            break;\n-    }\n-    if (n != next)\n-    {\n-        deco = NULL;\n-    }\n-    next = n;\n-    if (next->ty != Tfunction)\n-    {   transitive();\n-        return merge();\n-    }\n-    deco = merge()->deco;\n-    /* Don't return merge(), because arg identifiers and default args\n-     * can be different\n-     * even though the types match\n-     */\n-    return this;\n-}\n-\n-\n d_uns64 TypePointer::size(Loc)\n {\n     return target.ptrsize;\n@@ -5184,18 +4718,6 @@ Type *TypeReference::syntaxCopy()\n     return t;\n }\n \n-Type *TypeReference::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeReference::semantic()\\n\");\n-    Type *n = next->semantic(loc, sc);\n-    if (n != next)\n-        deco = NULL;\n-    next = n;\n-    transitive();\n-    return merge();\n-}\n-\n-\n d_uns64 TypeReference::size(Loc)\n {\n     return target.ptrsize;\n@@ -5425,7 +4947,7 @@ int Type::covariant(Type *t, StorageClass *pstc, bool fix17349)\n         // If t1n is forward referenced:\n         ClassDeclaration *cd = ((TypeClass *)t1n)->sym;\n         if (cd->semanticRun < PASSsemanticdone && !cd->isBaseInfoComplete())\n-            cd->semantic(NULL);\n+            dsymbolSemantic(cd, NULL);\n         if (!cd->isBaseInfoComplete())\n         {\n             return 3;   // forward references\n@@ -5524,379 +5046,6 @@ int Type::covariant(Type *t, StorageClass *pstc, bool fix17349)\n     return 2;\n }\n \n-Type *TypeFunction::semantic(Loc loc, Scope *sc)\n-{\n-    if (deco)                   // if semantic() already run\n-    {\n-        //printf(\"already done\\n\");\n-        return this;\n-    }\n-    //printf(\"TypeFunction::semantic() this = %p\\n\", this);\n-    //printf(\"TypeFunction::semantic() %s, sc->stc = %llx, fargs = %p\\n\", toChars(), sc->stc, fargs);\n-\n-    bool errors = false;\n-\n-    if (inuse > global.recursionLimit)\n-    {\n-        inuse = 0;\n-        ::error(loc, \"recursive type\");\n-        return Type::terror;\n-    }\n-\n-    /* Copy in order to not mess up original.\n-     * This can produce redundant copies if inferring return type,\n-     * as semantic() will get called again on this.\n-     */\n-    TypeFunction *tf = copy()->toTypeFunction();\n-    if (parameterList.parameters)\n-    {\n-        tf->parameterList.parameters = parameterList.parameters->copy();\n-        for (size_t i = 0; i < parameterList.parameters->length; i++)\n-        {\n-            void *pp = mem.xmalloc(sizeof(Parameter));\n-            Parameter *p = (Parameter *)memcpy(pp, (void *)(*parameterList.parameters)[i],\n-                                               sizeof(Parameter));\n-            (*tf->parameterList.parameters)[i] = p;\n-        }\n-    }\n-\n-    if (sc->stc & STCpure)\n-        tf->purity = PUREfwdref;\n-    if (sc->stc & STCnothrow)\n-        tf->isnothrow = true;\n-    if (sc->stc & STCnogc)\n-        tf->isnogc = true;\n-    if (sc->stc & STCref)\n-        tf->isref = true;\n-    if (sc->stc & STCreturn)\n-        tf->isreturn = true;\n-    if (sc->stc & STCscope)\n-        tf->isscope = true;\n-    if (sc->stc & STCscopeinferred)\n-        tf->isscopeinferred = true;\n-\n-//    if ((sc->stc & (STCreturn | STCref)) == STCreturn)\n-//        tf->isscope = true;                                 // return by itself means 'return scope'\n-\n-    if (tf->trust == TRUSTdefault)\n-    {\n-        if (sc->stc & STCsafe)\n-            tf->trust = TRUSTsafe;\n-        if (sc->stc & STCsystem)\n-            tf->trust = TRUSTsystem;\n-        if (sc->stc & STCtrusted)\n-            tf->trust = TRUSTtrusted;\n-    }\n-\n-    if (sc->stc & STCproperty)\n-        tf->isproperty = true;\n-\n-    tf->linkage = sc->linkage;\n-    bool wildreturn = false;\n-    if (tf->next)\n-    {\n-        sc = sc->push();\n-        sc->stc &= ~(STC_TYPECTOR | STC_FUNCATTR);\n-        tf->next = tf->next->semantic(loc, sc);\n-        sc = sc->pop();\n-        errors |= tf->checkRetType(loc);\n-        if (tf->next->isscope() && !(sc->flags & SCOPEctor))\n-        {\n-            error(loc, \"functions cannot return scope %s\", tf->next->toChars());\n-            errors = true;\n-        }\n-        if (tf->next->hasWild())\n-            wildreturn = true;\n-\n-        if (tf->isreturn && !tf->isref && !tf->next->hasPointers())\n-        {\n-            error(loc, \"function type '%s' has 'return' but does not return any indirections\", tf->toChars());\n-        }\n-    }\n-\n-    unsigned char wildparams = 0;\n-    if (tf->parameterList.parameters)\n-    {\n-        /* Create a scope for evaluating the default arguments for the parameters\n-         */\n-        Scope *argsc = sc->push();\n-        argsc->stc = 0;                 // don't inherit storage class\n-        argsc->protection = Prot(Prot::public_);\n-        argsc->func = NULL;\n-\n-        size_t dim = tf->parameterList.length();\n-        for (size_t i = 0; i < dim; i++)\n-        {\n-            Parameter *fparam = tf->parameterList[i];\n-            inuse++;\n-            fparam->type = fparam->type->semantic(loc, argsc);\n-            inuse--;\n-\n-            if (fparam->type->ty == Terror)\n-            {\n-                errors = true;\n-                continue;\n-            }\n-\n-            fparam->type = fparam->type->addStorageClass(fparam->storageClass);\n-\n-            if (fparam->storageClass & (STCauto | STCalias | STCstatic))\n-            {\n-                if (!fparam->type)\n-                    continue;\n-            }\n-\n-            Type *t = fparam->type->toBasetype();\n-\n-            if (t->ty == Tfunction)\n-            {\n-                error(loc, \"cannot have parameter of function type %s\", fparam->type->toChars());\n-                errors = true;\n-            }\n-            else if (!(fparam->storageClass & (STCref | STCout)) &&\n-                     (t->ty == Tstruct || t->ty == Tsarray || t->ty == Tenum))\n-            {\n-                Type *tb2 = t->baseElemOf();\n-                if ((tb2->ty == Tstruct && !((TypeStruct *)tb2)->sym->members) ||\n-                    (tb2->ty == Tenum && !((TypeEnum *)tb2)->sym->memtype))\n-                {\n-                    error(loc, \"cannot have parameter of opaque type %s by value\", fparam->type->toChars());\n-                    errors = true;\n-                }\n-            }\n-            else if (!(fparam->storageClass & STClazy) && t->ty == Tvoid)\n-            {\n-                error(loc, \"cannot have parameter of type %s\", fparam->type->toChars());\n-                errors = true;\n-            }\n-\n-            if ((fparam->storageClass & (STCref | STCwild)) == (STCref | STCwild))\n-            {\n-                // 'ref inout' implies 'return'\n-                fparam->storageClass |= STCreturn;\n-            }\n-\n-            if (fparam->storageClass & STCreturn)\n-            {\n-                if (fparam->storageClass & (STCref | STCout))\n-                {\n-                    // Disabled for the moment awaiting improvement to allow return by ref\n-                    // to be transformed into return by scope.\n-                    if (0 && !tf->isref)\n-                    {\n-                        StorageClass stc = fparam->storageClass & (STCref | STCout);\n-                        error(loc, \"parameter %s is 'return %s' but function does not return by ref\",\n-                            fparam->ident ? fparam->ident->toChars() : \"\",\n-                            stcToChars(stc));\n-                        errors = true;\n-                    }\n-                }\n-                else\n-                {\n-                    fparam->storageClass |= STCscope;        // 'return' implies 'scope'\n-                    if (tf->isref)\n-                    {\n-                    }\n-                    else if (!tf->isref && tf->next && !tf->next->hasPointers())\n-                    {\n-                        error(loc, \"parameter %s is 'return' but function does not return any indirections\",\n-                            fparam->ident ? fparam->ident->toChars() : \"\");\n-                        errors = true;\n-                    }\n-                }\n-            }\n-\n-            if (fparam->storageClass & (STCref | STClazy))\n-            {\n-            }\n-            else if (fparam->storageClass & STCout)\n-            {\n-                if (unsigned char m = fparam->type->mod & (MODimmutable | MODconst | MODwild))\n-                {\n-                    error(loc, \"cannot have %s out parameter of type %s\", MODtoChars(m), t->toChars());\n-                    errors = true;\n-                }\n-                else\n-                {\n-                    Type *tv = t;\n-                    while (tv->ty == Tsarray)\n-                        tv = tv->nextOf()->toBasetype();\n-                    if (tv->ty == Tstruct && ((TypeStruct *)tv)->sym->noDefaultCtor)\n-                    {\n-                        error(loc, \"cannot have out parameter of type %s because the default construction is disabled\",\n-                            fparam->type->toChars());\n-                        errors = true;\n-                    }\n-                }\n-            }\n-\n-            if (fparam->storageClass & STCscope && !fparam->type->hasPointers() && fparam->type->ty != Ttuple)\n-            {\n-                fparam->storageClass &= ~STCscope;\n-                if (!(fparam->storageClass & STCref))\n-                    fparam->storageClass &= ~STCreturn;\n-            }\n-\n-            if (t->hasWild())\n-            {\n-                wildparams |= 1;\n-                //if (tf->next && !wildreturn)\n-                //    error(loc, \"inout on parameter means inout must be on return type as well (if from D1 code, replace with 'ref')\");\n-            }\n-\n-            if (fparam->defaultArg)\n-            {\n-                Expression *e = fparam->defaultArg;\n-                if (fparam->storageClass & (STCref | STCout))\n-                {\n-                    e = ::semantic(e, argsc);\n-                    e = resolveProperties(argsc, e);\n-                }\n-                else\n-                {\n-                    e = inferType(e, fparam->type);\n-                    Initializer *iz = new ExpInitializer(e->loc, e);\n-                    iz = ::semantic(iz, argsc, fparam->type, INITnointerpret);\n-                    e = initializerToExpression(iz);\n-                }\n-                if (e->op == TOKfunction)               // see Bugzilla 4820\n-                {\n-                    FuncExp *fe = (FuncExp *)e;\n-                    // Replace function literal with a function symbol,\n-                    // since default arg expression must be copied when used\n-                    // and copying the literal itself is wrong.\n-                    e = new VarExp(e->loc, fe->fd, false);\n-                    e = new AddrExp(e->loc, e);\n-                    e = ::semantic(e, argsc);\n-                }\n-                e = e->implicitCastTo(argsc, fparam->type);\n-\n-                // default arg must be an lvalue\n-                if (fparam->storageClass & (STCout | STCref))\n-                    e = e->toLvalue(argsc, e);\n-\n-                fparam->defaultArg = e;\n-                if (e->op == TOKerror)\n-                    errors = true;\n-            }\n-\n-            /* If fparam after semantic() turns out to be a tuple, the number of parameters may\n-             * change.\n-             */\n-            if (t->ty == Ttuple)\n-            {\n-                /* TypeFunction::parameter also is used as the storage of\n-                 * Parameter objects for FuncDeclaration. So we should copy\n-                 * the elements of TypeTuple::arguments to avoid unintended\n-                 * sharing of Parameter object among other functions.\n-                 */\n-                TypeTuple *tt = (TypeTuple *)t;\n-                if (tt->arguments && tt->arguments->length)\n-                {\n-                    /* Propagate additional storage class from tuple parameters to their\n-                     * element-parameters.\n-                     * Make a copy, as original may be referenced elsewhere.\n-                     */\n-                    size_t tdim = tt->arguments->length;\n-                    Parameters *newparams = new Parameters();\n-                    newparams->setDim(tdim);\n-                    for (size_t j = 0; j < tdim; j++)\n-                    {\n-                        Parameter *narg = (*tt->arguments)[j];\n-\n-                        // Bugzilla 12744: If the storage classes of narg\n-                        // conflict with the ones in fparam, it's ignored.\n-                        StorageClass stc  = fparam->storageClass | narg->storageClass;\n-                        StorageClass stc1 = fparam->storageClass & (STCref | STCout | STClazy);\n-                        StorageClass stc2 =   narg->storageClass & (STCref | STCout | STClazy);\n-                        if (stc1 && stc2 && stc1 != stc2)\n-                        {\n-                            OutBuffer buf1;  stcToBuffer(&buf1, stc1 | ((stc1 & STCref) ? (fparam->storageClass & STCauto) : 0));\n-                            OutBuffer buf2;  stcToBuffer(&buf2, stc2);\n-\n-                            error(loc, \"incompatible parameter storage classes '%s' and '%s'\",\n-                                      buf1.peekChars(), buf2.peekChars());\n-                            errors = true;\n-                            stc = stc1 | (stc & ~(STCref | STCout | STClazy));\n-                        }\n-\n-                        (*newparams)[j] = new Parameter(\n-                                stc, narg->type, narg->ident, narg->defaultArg, narg->userAttribDecl);\n-                    }\n-                    fparam->type = new TypeTuple(newparams);\n-                }\n-                fparam->storageClass = 0;\n-\n-                /* Reset number of parameters, and back up one to do this fparam again,\n-                 * now that it is a tuple\n-                 */\n-                dim = tf->parameterList.length();\n-                i--;\n-                continue;\n-            }\n-\n-            /* Resolve \"auto ref\" storage class to be either ref or value,\n-             * based on the argument matching the parameter\n-             */\n-            if (fparam->storageClass & STCauto)\n-            {\n-                if (fargs && i < fargs->length && (fparam->storageClass & STCref))\n-                {\n-                    Expression *farg = (*fargs)[i];\n-                    if (farg->isLvalue())\n-                        ;                               // ref parameter\n-                    else\n-                        fparam->storageClass &= ~STCref;        // value parameter\n-                    fparam->storageClass &= ~STCauto;    // Bugzilla 14656\n-                    fparam->storageClass |= STCautoref;\n-                }\n-                else\n-                {\n-                    error(loc, \"'auto' can only be used as part of 'auto ref' for template function parameters\");\n-                    errors = true;\n-                }\n-            }\n-\n-            // Remove redundant storage classes for type, they are already applied\n-            fparam->storageClass &= ~(STC_TYPECTOR | STCin);\n-        }\n-        argsc->pop();\n-    }\n-    if (tf->isWild())\n-        wildparams |= 2;\n-\n-    if (wildreturn && !wildparams)\n-    {\n-        error(loc, \"inout on return means inout must be on a parameter as well for %s\", toChars());\n-        errors = true;\n-    }\n-    tf->iswild = wildparams;\n-\n-    if (tf->isproperty && (tf->parameterList.varargs != VARARGnone || tf->parameterList.length() > 2))\n-    {\n-        error(loc, \"properties can only have zero, one, or two parameter\");\n-        errors = true;\n-    }\n-\n-    if (tf->parameterList.varargs == VARARGvariadic && tf->linkage != LINKd && tf->parameterList.length() == 0)\n-    {\n-        error(loc, \"variadic functions with non-D linkage must have at least one parameter\");\n-        errors = true;\n-    }\n-\n-    if (errors)\n-        return terror;\n-\n-    if (tf->next)\n-        tf->deco = tf->merge()->deco;\n-\n-    /* Don't return merge(), because arg identifiers and default args\n-     * can be different\n-     * even though the types match\n-     */\n-    return tf;\n-}\n-\n bool TypeFunction::checkRetType(Loc loc)\n {\n     Type *tb = next->toBasetype();\n@@ -6525,30 +5674,6 @@ Type *TypeDelegate::syntaxCopy()\n     return t;\n }\n \n-Type *TypeDelegate::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeDelegate::semantic() %s\\n\", toChars());\n-    if (deco)                   // if semantic() already run\n-    {\n-        //printf(\"already done\\n\");\n-        return this;\n-    }\n-    next = next->semantic(loc,sc);\n-    if (next->ty != Tfunction)\n-        return terror;\n-\n-    /* In order to deal with Bugzilla 4028, perhaps default arguments should\n-     * be removed from next before the merge.\n-     */\n-\n-    /* Don't return merge(), because arg identifiers and default args\n-     * can be different\n-     * even though the types match\n-     */\n-    deco = merge()->deco;\n-    return this;\n-}\n-\n Type *TypeDelegate::addStorageClass(StorageClass stc)\n {\n     TypeDelegate *t = (TypeDelegate*)Type::addStorageClass(stc);\n@@ -6630,7 +5755,7 @@ Expression *TypeDelegate::dotExp(Scope *sc, Expression *e, Identifier *ident, in\n     if (ident == Id::ptr)\n     {\n         e = new DelegatePtrExp(e->loc, e);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n     }\n     else if (ident == Id::funcptr)\n     {\n@@ -6640,7 +5765,7 @@ Expression *TypeDelegate::dotExp(Scope *sc, Expression *e, Identifier *ident, in\n             return new ErrorExp();\n         }\n         e = new DelegateFuncptrExp(e->loc, e);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n     }\n     else\n     {\n@@ -6672,128 +5797,13 @@ Type *TypeTraits::syntaxCopy()\n     return tt;\n }\n \n-Type *TypeTraits::semantic(Loc, Scope *sc)\n-{\n-    if (ty == Terror)\n-        return this;\n-\n-    const int inAlias = (sc->flags & SCOPEalias) != 0;\n-    if (exp->ident != Id::allMembers &&\n-        exp->ident != Id::derivedMembers &&\n-        exp->ident != Id::getMember &&\n-        exp->ident != Id::parent &&\n-        exp->ident != Id::child &&\n-        exp->ident != Id::getOverloads &&\n-        exp->ident != Id::getVirtualFunctions &&\n-        exp->ident != Id::getVirtualMethods &&\n-        exp->ident != Id::getAttributes &&\n-        exp->ident != Id::getUnitTests &&\n-        exp->ident != Id::getAliasThis)\n-    {\n-        static const char *ctxt[2] = {\"as type\", \"in alias\"};\n-        ::error(loc, \"trait `%s` is either invalid or not supported %s\",\n-                exp->ident->toChars(), ctxt[inAlias]);\n-        ty = Terror;\n-        return this;\n-    }\n-\n-    Type *result = NULL;\n-\n-    if (Expression *e = semanticTraits(exp, sc))\n-    {\n-        switch (e->op)\n-        {\n-        case TOKdotvar:\n-            sym = ((DotVarExp *)e)->var;\n-            break;\n-        case TOKvar:\n-            sym = ((VarExp *)e)->var;\n-            break;\n-        case TOKfunction:\n-        {\n-            FuncExp *fe = (FuncExp *)e;\n-            if (fe->td)\n-                sym = fe->td;\n-            else\n-                sym = fe->fd;\n-            break;\n-        }\n-        case TOKdottd:\n-            sym = ((DotTemplateExp*)e)->td;\n-            break;\n-        case TOKdsymbol:\n-            sym = ((DsymbolExp *)e)->s;\n-            break;\n-        case TOKtemplate:\n-            sym = ((TemplateExp *)e)->td;\n-            break;\n-        case TOKscope:\n-            sym = ((ScopeExp *)e)->sds;\n-            break;\n-        case TOKtuple:\n-        {\n-            TupleExp *te = e->toTupleExp();\n-            Objects *elems = new Objects;\n-            elems->setDim(te->exps->length);\n-            for (size_t i = 0; i < elems->length; i++)\n-            {\n-                Expression *src = (*te->exps)[i];\n-                switch (src->op)\n-                {\n-                case TOKtype:\n-                    (*elems)[i] = ((TypeExp *)src)->type;\n-                    break;\n-                case TOKdottype:\n-                    (*elems)[i] = ((DotTypeExp *)src)->type;\n-                    break;\n-                case TOKoverloadset:\n-                    (*elems)[i] = ((OverExp *)src)->type;\n-                    break;\n-                default:\n-                    if (Dsymbol *sym = isDsymbol(src))\n-                        (*elems)[i] = sym;\n-                    else\n-                        (*elems)[i] = src;\n-                }\n-            }\n-            TupleDeclaration *td = new TupleDeclaration(e->loc,\n-                Identifier::generateId(\"__aliastup\"), elems);\n-            sym = td;\n-            break;\n-        }\n-        case TOKdottype:\n-            result = isType(((DotTypeExp *)e)->sym);\n-            break;\n-        case TOKtype:\n-            result = ((TypeExp *)e)->type;\n-            break;\n-        case TOKoverloadset:\n-            result = ((OverExp *)e)->type;\n-            break;\n-        default:\n-            break;\n-        }\n-    }\n-\n-    if (result)\n-        result = result->addMod(mod);\n-    if (!inAlias && !result)\n-    {\n-        if (!global.errors)\n-            ::error(loc, \"`%s` does not give a valid type\", toChars());\n-        return Type::terror;\n-    }\n-\n-    return result;\n-}\n-\n void TypeTraits::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool)\n {\n     *pt = NULL;\n     *pe = NULL;\n     *ps = NULL;\n \n-    if (Type *t = semantic(loc, sc))\n+    if (Type *t = typeSemantic(this, loc, sc))\n         *pt = t;\n     else if (sym)\n         *ps = sym;\n@@ -6889,7 +5899,7 @@ void TypeQualified::resolveTupleIndex(Loc loc, Scope *sc, Dsymbol *s,\n         else if (sindex)\n             eindex = ::resolve(loc, sc, sindex, false);\n         Expression *e = new IndexExp(loc, ::resolve(loc, sc, s, false), eindex);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         resolveExp(e, pt, pe, ps);\n         return;\n     }\n@@ -6906,7 +5916,7 @@ void TypeQualified::resolveTupleIndex(Loc loc, Scope *sc, Dsymbol *s,\n         return;\n     }\n     sc = sc->startCTFE();\n-    eindex = ::semantic(eindex, sc);\n+    eindex = expressionSemantic(eindex, sc);\n     sc = sc->endCTFE();\n \n     eindex = eindex->ctfeInterpret();\n@@ -6930,7 +5940,7 @@ void TypeQualified::resolveTupleIndex(Loc loc, Scope *sc, Dsymbol *s,\n     *pe = isExpression(o);\n \n     if (*pt)\n-        *pt = (*pt)->semantic(loc, sc);\n+        *pt = typeSemantic(*pt, loc, sc);\n     if (*pe)\n         resolveExp(*pe, pt, pe, ps);\n }\n@@ -6986,7 +5996,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n                 assert(ex);\n \n                 ex = typeToExpressionHelper(this, ex, i + 1);\n-                ex = ::semantic(ex, sc);\n+                ex = expressionSemantic(ex, sc);\n                 resolveExp(ex, pt, pe, ps);\n                 return;\n             }\n@@ -7012,7 +6022,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n                 // https://issues.dlang.org/show_bug.cgi?id=19913\n                 // v->type would be null if it is a forward referenced member.\n                 if (v->type == NULL)\n-                    v->semantic(sc);\n+                    dsymbolSemantic(v, sc);\n                 if (v->storage_class & (STCconst | STCimmutable | STCmanifest) ||\n                     v->type->isConst() || v->type->isImmutable())\n                 {\n@@ -7056,7 +6066,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n                         e = new VarExp(loc, s->isDeclaration(), true);\n \n                     e = typeToExpressionHelper(this, e, i);\n-                    e = ::semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     resolveExp(e, pt, pe, ps);\n                     return;\n                 }\n@@ -7072,10 +6082,10 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n                         assert(id->dyncast() == DYNCAST_IDENTIFIER);\n                         sm = s->search_correct((Identifier *)id);\n                         if (sm)\n-                            error(loc, \"identifier '%s' of '%s' is not defined, did you mean %s '%s'?\",\n+                            error(loc, \"identifier `%s` of `%s` is not defined, did you mean %s `%s`?\",\n                                   id->toChars(), toChars(), sm->kind(), sm->toChars());\n                         else\n-                            error(loc, \"identifier '%s' of '%s' is not defined\", id->toChars(), toChars());\n+                            error(loc, \"identifier `%s` of `%s` is not defined\", id->toChars(), toChars());\n                     }\n                     *pe = new ErrorExp();\n                 }\n@@ -7107,9 +6117,9 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n                 (!v->type->deco && v->inuse))\n             {\n                 if (v->inuse)   // Bugzilla 9494\n-                    error(loc, \"circular reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                    error(loc, \"circular reference to %s `%s`\", v->kind(), v->toPrettyChars());\n                 else\n-                    error(loc, \"forward reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                    error(loc, \"forward reference to %s `%s`\", v->kind(), v->toPrettyChars());\n                 *pt = Type::terror;\n                 return;\n             }\n@@ -7123,7 +6133,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n         {\n             //printf(\"'%s' is a function literal\\n\", fld->toChars());\n             *pe = new FuncExp(loc, fld);\n-            *pe = ::semantic(*pe, sc);\n+            *pe = expressionSemantic(*pe, sc);\n             return;\n         }\n L1:\n@@ -7144,7 +6154,7 @@ void TypeQualified::resolveHelper(Loc loc, Scope *sc,\n         if (t->ty == Tinstance && t != this && !t->deco)\n         {\n             if (!((TypeInstance *)t)->tempinst->errors)\n-                error(loc, \"forward reference to '%s'\", t->toChars());\n+                error(loc, \"forward reference to `%s`\", t->toChars());\n             *pt = Type::terror;\n             return;\n         }\n@@ -7267,34 +6277,6 @@ Dsymbol *TypeIdentifier::toDsymbol(Scope *sc)\n     return s;\n }\n \n-Type *TypeIdentifier::semantic(Loc loc, Scope *sc)\n-{\n-    Type *t;\n-    Expression *e;\n-    Dsymbol *s;\n-\n-    //printf(\"TypeIdentifier::semantic(%s)\\n\", toChars());\n-    resolve(loc, sc, &e, &t, &s);\n-    if (t)\n-    {\n-        //printf(\"\\tit's a type %d, %s, %s\\n\", t->ty, t->toChars(), t->deco);\n-        t = t->addMod(mod);\n-    }\n-    else\n-    {\n-        if (s)\n-        {\n-            s->error(loc, \"is used as a type\");\n-            //halt();\n-        }\n-        else\n-            error(loc, \"%s is used as a type\", toChars());\n-        t = terror;\n-    }\n-    //t->print();\n-    return t;\n-}\n-\n /***************************** TypeInstance *****************************/\n \n TypeInstance::TypeInstance(Loc loc, TemplateInstance *tempinst)\n@@ -7324,7 +6306,7 @@ void TypeInstance::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymb\n     *pt = NULL;\n     *ps = NULL;\n     //printf(\"TypeInstance::resolve(sc = %p, tempinst = '%s')\\n\", sc, tempinst->toChars());\n-    tempinst->semantic(sc);\n+    dsymbolSemantic(tempinst, sc);\n     if (!global.gag && tempinst->errors)\n     {\n         *pt = terror;\n@@ -7337,36 +6319,6 @@ void TypeInstance::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymb\n     //if (*pt) printf(\"pt = '%s'\\n\", (*pt)->toChars());\n }\n \n-Type *TypeInstance::semantic(Loc loc, Scope *sc)\n-{\n-    Type *t;\n-    Expression *e;\n-    Dsymbol *s;\n-\n-    //printf(\"TypeInstance::semantic(%p, %s)\\n\", this, toChars());\n-    {\n-        unsigned errors = global.errors;\n-        resolve(loc, sc, &e, &t, &s);\n-        // if we had an error evaluating the symbol, suppress further errors\n-        if (!t && errors != global.errors)\n-            return terror;\n-    }\n-\n-    if (!t)\n-    {\n-        if (!e && s && s->errors)\n-        {\n-            // if there was an error evaluating the symbol, it might actually\n-            // be a type. Avoid misleading error messages.\n-            error(loc, \"%s had previous errors\", toChars());\n-        }\n-        else\n-            error(loc, \"%s is used as a type\", toChars());\n-        t = terror;\n-    }\n-    return t;\n-}\n-\n Dsymbol *TypeInstance::toDsymbol(Scope *sc)\n {\n     Type *t;\n@@ -7456,7 +6408,7 @@ void TypeTypeof::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n          */\n         Scope *sc2 = sc->push();\n         sc2->intypeof = 1;\n-        Expression *exp2 = ::semantic(exp, sc2);\n+        Expression *exp2 = expressionSemantic(exp, sc2);\n         exp2 = resolvePropertiesOnly(sc2, exp2);\n         sc2->pop();\n \n@@ -7514,7 +6466,7 @@ void TypeTypeof::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n         else\n         {\n             Expression *e = typeToExpressionHelper(this, new TypeExp(loc, t));\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             resolveExp(e, pt, pe, ps);\n         }\n     }\n@@ -7524,24 +6476,6 @@ void TypeTypeof::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n     return;\n }\n \n-Type *TypeTypeof::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeTypeof::semantic() %s\\n\", toChars());\n-\n-    Expression *e;\n-    Type *t;\n-    Dsymbol *s;\n-    resolve(loc, sc, &e, &t, &s);\n-    if (s && (t = s->getType()) != NULL)\n-        t = t->addMod(mod);\n-    if (!t)\n-    {\n-        error(loc, \"%s is used as a type\", toChars());\n-        t = Type::terror;\n-    }\n-    return t;\n-}\n-\n d_uns64 TypeTypeof::size(Loc loc)\n {\n     if (exp->type)\n@@ -7616,7 +6550,7 @@ void TypeReturn::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n         else\n         {\n             Expression *e = typeToExpressionHelper(this, new TypeExp(loc, t));\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             resolveExp(e, pt, pe, ps);\n         }\n     }\n@@ -7629,24 +6563,6 @@ void TypeReturn::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n     return;\n }\n \n-Type *TypeReturn::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeReturn::semantic() %s\\n\", toChars());\n-\n-    Expression *e;\n-    Type *t;\n-    Dsymbol *s;\n-    resolve(loc, sc, &e, &t, &s);\n-    if (s && (t = s->getType()) != NULL)\n-        t = t->addMod(mod);\n-    if (!t)\n-    {\n-        error(loc, \"%s is used as a type\", toChars());\n-        t = Type::terror;\n-    }\n-    return t;\n-}\n-\n /***************************** TypeEnum *****************************/\n \n TypeEnum::TypeEnum(EnumDeclaration *sym)\n@@ -7665,14 +6581,6 @@ Type *TypeEnum::syntaxCopy()\n     return this;\n }\n \n-Type *TypeEnum::semantic(Loc, Scope *)\n-{\n-    //printf(\"TypeEnum::semantic() %s\\n\", toChars());\n-    if (deco)\n-        return this;\n-    return merge();\n-}\n-\n d_uns64 TypeEnum::size(Loc loc)\n {\n     return sym->getMemtype(loc)->size(loc);\n@@ -7706,7 +6614,7 @@ Expression *TypeEnum::dotExp(Scope *sc, Expression *e, Identifier *ident, int fl\n         return getProperty(e->loc, ident, flag & 1);\n \n     if (sym->semanticRun < PASSsemanticdone)\n-        sym->semantic(NULL);\n+        dsymbolSemantic(sym, NULL);\n     if (!sym->members)\n     {\n         if (sym->isSpecial())\n@@ -7717,7 +6625,7 @@ Expression *TypeEnum::dotExp(Scope *sc, Expression *e, Identifier *ident, int fl\n         }\n         else if (!(flag & 1))\n         {\n-            sym->error(\"is forward referenced when looking for '%s'\", ident->toChars());\n+            sym->error(\"is forward referenced when looking for `%s`\", ident->toChars());\n             e = new ErrorExp();\n         }\n         else\n@@ -7738,10 +6646,10 @@ Expression *TypeEnum::dotExp(Scope *sc, Expression *e, Identifier *ident, int fl\n         if (!(flag & 1) && !res)\n         {\n             if (Dsymbol *ns = sym->search_correct(ident))\n-                e->error(\"no property '%s' for type '%s'. Did you mean '%s.%s' ?\",\n+                e->error(\"no property `%s` for type `%s`. Did you mean `%s.%s` ?\",\n                     ident->toChars(), toChars(), toChars(), ns->toChars());\n             else\n-                e->error(\"no property '%s' for type '%s'\",\n+                e->error(\"no property `%s` for type `%s`\",\n                     ident->toChars(), toChars());\n \n             return new ErrorExp();\n@@ -7768,7 +6676,7 @@ Expression *TypeEnum::getProperty(Loc loc, Identifier *ident, int flag)\n         const char *s = toChars();\n         e = new StringExp(loc, const_cast<char *>(s), strlen(s));\n         Scope sc;\n-        e = ::semantic(e, &sc);\n+        e = expressionSemantic(e, &sc);\n     }\n     else if (ident == Id::_mangleof)\n     {\n@@ -7921,34 +6829,6 @@ Type *TypeStruct::syntaxCopy()\n     return this;\n }\n \n-Type *TypeStruct::semantic(Loc, Scope *sc)\n-{\n-    //printf(\"TypeStruct::semantic('%s')\\n\", sym->toChars());\n-    if (deco)\n-    {\n-        if (sc && sc->cppmangle != CPPMANGLEdefault)\n-        {\n-            if (this->cppmangle == CPPMANGLEdefault)\n-                this->cppmangle = sc->cppmangle;\n-            else\n-                assert(this->cppmangle == sc->cppmangle);\n-        }\n-        return this;\n-    }\n-\n-    /* Don't semantic for sym because it should be deferred until\n-     * sizeof needed or its members accessed.\n-     */\n-    // instead, parent should be set correctly\n-    assert(sym->parent);\n-\n-    if (sym->type->ty == Terror)\n-        return Type::terror;\n-    if (sc)\n-        this->cppmangle = sc->cppmangle;\n-    return merge();\n-}\n-\n d_uns64 TypeStruct::size(Loc loc)\n {\n     return sym->size(loc);\n@@ -7982,7 +6862,7 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         /* Create a TupleExp out of the fields of the struct e:\n          * (e.field0, e.field1, e.field2, ...)\n          */\n-        e = ::semantic(e, sc);  // do this before turning on noaccesscheck\n+        e = expressionSemantic(e, sc);  // do this before turning on noaccesscheck\n \n         sym->size(e->loc);      // do semantic of type\n \n@@ -8010,7 +6890,7 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         e = new TupleExp(e->loc, e0, exps);\n         Scope *sc2 = sc->push();\n         sc2->flags = sc->flags | SCOPEnoaccesscheck;\n-        e = ::semantic(e, sc2);\n+        e = expressionSemantic(e, sc2);\n         sc2->pop();\n         return e;\n     }\n@@ -8046,9 +6926,9 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n             (!v->type->deco && v->inuse))\n         {\n             if (v->inuse) // Bugzilla 9494\n-                e->error(\"circular reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                e->error(\"circular reference to %s `%s`\", v->kind(), v->toPrettyChars());\n             else\n-                e->error(\"forward reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                e->error(\"forward reference to %s `%s`\", v->kind(), v->toPrettyChars());\n             return new ErrorExp();\n         }\n         if (v->type->ty == Terror)\n@@ -8058,19 +6938,19 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         {\n             if (v->inuse)\n             {\n-                e->error(\"circular initialization of %s '%s'\", v->kind(), v->toPrettyChars());\n+                e->error(\"circular initialization of %s `%s`\", v->kind(), v->toPrettyChars());\n                 return new ErrorExp();\n             }\n             checkAccess(e->loc, sc, NULL, v);\n             Expression *ve = new VarExp(e->loc, v);\n-            ve = ::semantic(ve, sc);\n+            ve = expressionSemantic(ve, sc);\n             return ve;\n         }\n     }\n \n     if (Type *t = s->getType())\n     {\n-        return ::semantic(new TypeExp(e->loc, t), sc);\n+        return expressionSemantic(new TypeExp(e->loc, t), sc);\n     }\n \n     TemplateMixin *tm = s->isTemplateMixin();\n@@ -8088,7 +6968,7 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n             e = new TemplateExp(e->loc, td);\n         else\n             e = new DotTemplateExp(e->loc, e, td);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n \n@@ -8097,7 +6977,7 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n     {\n         if (!ti->semanticRun)\n         {\n-            ti->semantic(sc);\n+            dsymbolSemantic(ti, sc);\n             if (!ti->inst || ti->errors)    // if template failed to expand\n                 return new ErrorExp();\n         }\n@@ -8108,7 +6988,7 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n             e = new ScopeExp(e->loc, ti);\n         else\n             e = new DotExp(e->loc, e, new ScopeExp(e->loc, ti));\n-        return ::semantic(e, sc);\n+        return expressionSemantic(e, sc);\n     }\n \n     if (s->isImport() || s->isModule() || s->isPackage())\n@@ -8141,7 +7021,7 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         if (TupleDeclaration *tup = d->isTupleDeclaration())\n         {\n             e = new TupleExp(e->loc, tup);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n         if (d->needThis() && sc->intypeof != 1)\n@@ -8152,12 +7032,12 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n             if (hasThis(sc))\n             {\n                 e = new DotVarExp(e->loc, new ThisExp(e->loc), d);\n-                e = ::semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 return e;\n             }\n         }\n         if (d->semanticRun == PASSinit)\n-            d->semantic(NULL);\n+            dsymbolSemantic(d, NULL);\n         checkAccess(e->loc, sc, e, d);\n         VarExp *ve = new VarExp(e->loc, d);\n         if (d->isVarDeclaration() && d->needThis())\n@@ -8172,12 +7052,12 @@ Expression *TypeStruct::dotExp(Scope *sc, Expression *e, Identifier *ident, int\n         checkAccess(e->loc, sc, e, d);\n         Expression *ve = new VarExp(e->loc, d);\n         e = unreal ? ve : new CommaExp(e->loc, e, ve);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n \n     e = new DotVarExp(e->loc, e, d);\n-    e = ::semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -8215,7 +7095,7 @@ Expression *TypeStruct::defaultInitLiteral(Loc loc)\n         Expression *e;\n         if (vd->inuse)\n         {\n-            error(loc, \"circular reference to '%s'\", vd->toPrettyChars());\n+            error(loc, \"circular reference to `%s`\", vd->toPrettyChars());\n             return new ErrorExp();\n         }\n         if (vd->offset < offset || vd->type->size() == 0)\n@@ -8463,34 +7343,6 @@ Type *TypeClass::syntaxCopy()\n     return this;\n }\n \n-Type *TypeClass::semantic(Loc, Scope *sc)\n-{\n-    //printf(\"TypeClass::semantic(%s)\\n\", sym->toChars());\n-    if (deco)\n-    {\n-        if (sc && sc->cppmangle != CPPMANGLEdefault)\n-        {\n-            if (this->cppmangle == CPPMANGLEdefault)\n-                this->cppmangle = sc->cppmangle;\n-            else\n-                assert(this->cppmangle == sc->cppmangle);\n-        }\n-        return this;\n-    }\n-\n-    /* Don't semantic for sym because it should be deferred until\n-     * sizeof needed or its members accessed.\n-     */\n-    // instead, parent should be set correctly\n-    assert(sym->parent);\n-\n-    if (sym->type->ty == Terror)\n-        return Type::terror;\n-    if (sc)\n-        this->cppmangle = sc->cppmangle;\n-    return merge();\n-}\n-\n d_uns64 TypeClass::size(Loc)\n {\n     return target.ptrsize;\n@@ -8518,7 +7370,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n     {\n         /* Create a TupleExp\n          */\n-        e = ::semantic(e, sc);  // do this before turning on noaccesscheck\n+        e = expressionSemantic(e, sc);  // do this before turning on noaccesscheck\n \n         sym->size(e->loc); // do semantic of type\n \n@@ -8549,7 +7401,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n         e = new TupleExp(e->loc, e0, exps);\n         Scope *sc2 = sc->push();\n         sc2->flags = sc->flags | SCOPEnoaccesscheck;\n-        e = ::semantic(e, sc2);\n+        e = expressionSemantic(e, sc2);\n         sc2->pop();\n         return e;\n     }\n@@ -8566,7 +7418,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             if (e->op == TOKtype)\n                 return Type::getProperty(e->loc, ident, 0);\n             e = new DotTypeExp(e->loc, e, sym);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n         if (ClassDeclaration *cbase = sym->searchBase(ident))\n@@ -8577,7 +7429,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n                 e = new CastExp(e->loc, e, ifbase->type);\n             else\n                 e = new DotTypeExp(e->loc, e, cbase);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n \n@@ -8640,7 +7492,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n              */\n             e = e->castTo(sc, tvoidptr->immutableOf()->pointerTo()->pointerTo());\n             e = new PtrExp(e->loc, e);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n \n@@ -8652,14 +7504,14 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             e = e->castTo(sc, tvoidptr->pointerTo());\n             e = new AddExp(e->loc, e, new IntegerExp(1));\n             e = new PtrExp(e->loc, e);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n \n         if (ident == Id::outer && sym->vthis)\n         {\n             if (sym->vthis->semanticRun == PASSinit)\n-                sym->vthis->semantic(NULL);\n+                dsymbolSemantic(sym->vthis, NULL);\n \n             if (ClassDeclaration *cdp = sym->toParent2()->isClassDeclaration())\n             {\n@@ -8726,9 +7578,9 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             (!v->type->deco && v->inuse))\n         {\n             if (v->inuse) // Bugzilla 9494\n-                e->error(\"circular reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                e->error(\"circular reference to %s `%s`\", v->kind(), v->toPrettyChars());\n             else\n-                e->error(\"forward reference to %s '%s'\", v->kind(), v->toPrettyChars());\n+                e->error(\"forward reference to %s `%s`\", v->kind(), v->toPrettyChars());\n             return new ErrorExp();\n         }\n         if (v->type->ty == Terror)\n@@ -8738,19 +7590,19 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n         {\n             if (v->inuse)\n             {\n-                e->error(\"circular initialization of %s '%s'\", v->kind(), v->toPrettyChars());\n+                e->error(\"circular initialization of %s `%s`\", v->kind(), v->toPrettyChars());\n                 return new ErrorExp();\n             }\n             checkAccess(e->loc, sc, NULL, v);\n             Expression *ve = new VarExp(e->loc, v);\n-            ve = ::semantic(ve, sc);\n+            ve = expressionSemantic(ve, sc);\n             return ve;\n         }\n     }\n \n     if (Type *t = s->getType())\n     {\n-        return ::semantic(new TypeExp(e->loc, t), sc);\n+        return expressionSemantic(new TypeExp(e->loc, t), sc);\n     }\n \n     TemplateMixin *tm = s->isTemplateMixin();\n@@ -8768,7 +7620,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             e = new TemplateExp(e->loc, td);\n         else\n             e = new DotTemplateExp(e->loc, e, td);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n \n@@ -8777,7 +7629,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n     {\n         if (!ti->semanticRun)\n         {\n-            ti->semantic(sc);\n+            dsymbolSemantic(ti, sc);\n             if (!ti->inst || ti->errors)    // if template failed to expand\n                 return new ErrorExp();\n         }\n@@ -8788,7 +7640,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             e = new ScopeExp(e->loc, ti);\n         else\n             e = new DotExp(e->loc, e, new ScopeExp(e->loc, ti));\n-        return ::semantic(e, sc);\n+        return expressionSemantic(e, sc);\n     }\n \n     if (s->isImport() || s->isModule() || s->isPackage())\n@@ -8821,7 +7673,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n         if (TupleDeclaration *tup = d->isTupleDeclaration())\n         {\n             e = new TupleExp(e->loc, tup);\n-            e = ::semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             return e;\n         }\n         if (d->needThis() && sc->intypeof != 1)\n@@ -8833,7 +7685,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n             {\n                 // This is almost same as getRightThis() in expression.c\n                 Expression *e1 = new ThisExp(e->loc);\n-                e1 = ::semantic(e1, sc);\n+                e1 = expressionSemantic(e1, sc);\n             L2:\n                 Type *t = e1->type->toBasetype();\n                 ClassDeclaration *cd = e->type->isClassHandle();\n@@ -8842,7 +7694,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n                 {\n                     e = new DotTypeExp(e1->loc, e1, cd);\n                     e = new DotVarExp(e->loc, e, d);\n-                    e = ::semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     return e;\n                 }\n                 if (tcd && tcd->isNested())\n@@ -8854,7 +7706,7 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n                     e1->type = tcd->vthis->type;\n                     e1->type = e1->type->addMod(t->mod);\n                     // Do not call checkNestedRef()\n-                    //e1 = ::semantic(e1, sc);\n+                    //e1 = expressionSemantic(e1, sc);\n \n                     // Skip up over nested functions, and get the enclosing\n                     // class type.\n@@ -8879,17 +7731,17 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n                     {   e1->type = s->isClassDeclaration()->type;\n                         e1->type = e1->type->addMod(t->mod);\n                         if (n > 1)\n-                            e1 = ::semantic(e1, sc);\n+                            e1 = expressionSemantic(e1, sc);\n                     }\n                     else\n-                        e1 = ::semantic(e1, sc);\n+                        e1 = expressionSemantic(e1, sc);\n                     goto L2;\n                 }\n             }\n         }\n         //printf(\"e = %s, d = %s\\n\", e->toChars(), d->toChars());\n         if (d->semanticRun == PASSinit)\n-            d->semantic(NULL);\n+            dsymbolSemantic(d, NULL);\n         checkAccess(e->loc, sc, e, d);\n         VarExp *ve = new VarExp(e->loc, d);\n         if (d->isVarDeclaration() && d->needThis())\n@@ -8904,12 +7756,12 @@ Expression *TypeClass::dotExp(Scope *sc, Expression *e, Identifier *ident, int f\n         checkAccess(e->loc, sc, e, d);\n         Expression *ve = new VarExp(e->loc, d);\n         e = unreal ? ve : new CommaExp(e->loc, e, ve);\n-        e = ::semantic(e, sc);\n+        e = expressionSemantic(e, sc);\n         return e;\n     }\n \n     e = new DotVarExp(e->loc, e, d);\n-    e = ::semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -8946,9 +7798,9 @@ MATCH TypeClass::implicitConvTo(Type *to)\n     {\n         //printf(\"TypeClass::implicitConvTo(to = '%s') %s, isbase = %d %d\\n\", to->toChars(), toChars(), cdto->isBaseInfoComplete(), sym->isBaseInfoComplete());\n         if (cdto->semanticRun < PASSsemanticdone && !cdto->isBaseInfoComplete())\n-            cdto->semantic(NULL);\n+            dsymbolSemantic(cdto, NULL);\n         if (sym->semanticRun < PASSsemanticdone && !sym->isBaseInfoComplete())\n-            sym->semantic(NULL);\n+            dsymbolSemantic(sym, NULL);\n         if (cdto->isBaseOf(sym, NULL) && MODimplicitConv(mod, to->mod))\n         {\n             //printf(\"'to' is base\\n\");\n@@ -9110,19 +7962,6 @@ Type *TypeTuple::syntaxCopy()\n     return t;\n }\n \n-Type *TypeTuple::semantic(Loc, Scope *)\n-{\n-    //printf(\"TypeTuple::semantic(this = %p)\\n\", this);\n-    //printf(\"TypeTuple::semantic() %p, %s\\n\", this, toChars());\n-    if (!deco)\n-        deco = merge()->deco;\n-\n-    /* Don't return merge(), because a tuple with one type has the\n-     * same deco as that type.\n-     */\n-    return this;\n-}\n-\n bool TypeTuple::equals(RootObject *o)\n {\n     Type *t = (Type *)o;\n@@ -9165,7 +8004,7 @@ Expression *TypeTuple::getProperty(Loc loc, Identifier *ident, int flag)\n     }\n     else\n     {\n-        error(loc, \"no property '%s' for tuple '%s'\", ident->toChars(), toChars());\n+        error(loc, \"no property `%s` for tuple `%s`\", ident->toChars(), toChars());\n         e = new ErrorExp();\n     }\n     return e;\n@@ -9211,48 +8050,6 @@ Type *TypeSlice::syntaxCopy()\n     return t;\n }\n \n-Type *TypeSlice::semantic(Loc loc, Scope *sc)\n-{\n-    //printf(\"TypeSlice::semantic() %s\\n\", toChars());\n-    Type *tn = next->semantic(loc, sc);\n-    //printf(\"next: %s\\n\", tn->toChars());\n-\n-    Type *tbn = tn->toBasetype();\n-    if (tbn->ty != Ttuple)\n-    {\n-        error(loc, \"can only slice tuple types, not %s\", tbn->toChars());\n-        return Type::terror;\n-    }\n-    TypeTuple *tt = (TypeTuple *)tbn;\n-\n-    lwr = semanticLength(sc, tbn, lwr);\n-    lwr = lwr->ctfeInterpret();\n-    uinteger_t i1 = lwr->toUInteger();\n-\n-    upr = semanticLength(sc, tbn, upr);\n-    upr = upr->ctfeInterpret();\n-    uinteger_t i2 = upr->toUInteger();\n-\n-    if (!(i1 <= i2 && i2 <= tt->arguments->length))\n-    {\n-        error(loc, \"slice [%llu..%llu] is out of range of [0..%u]\", i1, i2, tt->arguments->length);\n-        return Type::terror;\n-    }\n-\n-    next = tn;\n-    transitive();\n-\n-    Parameters *args = new Parameters;\n-    args->reserve((size_t)(i2 - i1));\n-    for (size_t i = (size_t)i1; i < (size_t)i2; i++)\n-    {\n-        Parameter *arg = (*tt->arguments)[i];\n-        args->push(arg);\n-    }\n-    Type *t = new TypeTuple(args);\n-    return t->semantic(loc, sc);\n-}\n-\n void TypeSlice::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid)\n {\n     next->resolve(loc, sc, pe, pt, ps, intypeid);\n@@ -9275,8 +8072,8 @@ void TypeSlice::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol\n             sym->parent = sc->scopesym;\n             sc = sc->push(sym);\n             sc = sc->startCTFE();\n-            lwr = ::semantic(lwr, sc);\n-            upr = ::semantic(upr, sc);\n+            lwr = expressionSemantic(lwr, sc);\n+            upr = expressionSemantic(upr, sc);\n             sc = sc->endCTFE();\n             sc = sc->pop();\n "}, {"sha": "083d707f8f30863d522a61f1d80ea9cd953991b7", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -40,6 +40,7 @@ typedef union tree_node type;\n typedef struct TYPE type;\n #endif\n \n+Type *typeSemantic(Type *type, const Loc &loc, Scope *sc);\n void semanticTypeInfo(Scope *sc, Type *t);\n MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *parameters, Objects *dedtypes, unsigned *wm = NULL, size_t inferStart = 0);\n StorageClass ModToStc(unsigned mod);\n@@ -245,7 +246,6 @@ class Type : public ASTNode\n     d_uns64 size();\n     virtual d_uns64 size(Loc loc);\n     virtual unsigned alignsize();\n-    virtual Type *semantic(Loc loc, Scope *sc);\n     Type *trySemantic(Loc loc, Scope *sc);\n     Type *merge();\n     Type *merge2();\n@@ -448,7 +448,6 @@ class TypeVector : public Type\n     static TypeVector *create(Type *basetype);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     d_uns64 size(Loc loc);\n     unsigned alignsize();\n     Expression *getProperty(Loc loc, Identifier *ident, int flag);\n@@ -486,7 +485,6 @@ class TypeSArray : public TypeArray\n     Type *syntaxCopy();\n     d_uns64 size(Loc loc);\n     unsigned alignsize();\n-    Type *semantic(Loc loc, Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     bool isString();\n@@ -512,7 +510,6 @@ class TypeDArray : public TypeArray\n     Type *syntaxCopy();\n     d_uns64 size(Loc loc) /*const*/;\n     unsigned alignsize() /*const*/;\n-    Type *semantic(Loc loc, Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     bool isString();\n@@ -537,7 +534,6 @@ class TypeAArray : public TypeArray\n     const char *kind();\n     Type *syntaxCopy();\n     d_uns64 size(Loc loc);\n-    Type *semantic(Loc loc, Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     Expression *defaultInit(Loc loc);\n@@ -557,7 +553,6 @@ class TypePointer : public TypeNext\n     static TypePointer *create(Type *t);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     d_uns64 size(Loc loc) /*const*/;\n     MATCH implicitConvTo(Type *to);\n     MATCH constConv(Type *to);\n@@ -575,7 +570,6 @@ class TypeReference : public TypeNext\n     TypeReference(Type *t);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     d_uns64 size(Loc loc) /*const*/;\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     Expression *defaultInit(Loc loc);\n@@ -680,7 +674,6 @@ class TypeFunction : public TypeNext\n     static TypeFunction *create(Parameters *parameters, Type *treturn, VarArg varargs, LINK linkage, StorageClass stc = 0);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     void purityLevel();\n     bool hasLazyParameters();\n     bool isDstyleVariadic() const;\n@@ -709,7 +702,6 @@ class TypeDelegate : public TypeNext\n     static TypeDelegate *create(Type *t);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     Type *addStorageClass(StorageClass stc);\n     d_uns64 size(Loc loc) /*const*/;\n     unsigned alignsize() /*const*/;\n@@ -734,7 +726,6 @@ class TypeTraits : public Type\n \n     TypeTraits(const Loc &loc, TraitsExp *exp);\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     d_uns64 size(Loc loc);\n     void accept(Visitor *v) { v->visit(this); }\n@@ -774,7 +765,6 @@ class TypeIdentifier : public TypeQualified\n     Type *syntaxCopy();\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     Dsymbol *toDsymbol(Scope *sc);\n-    Type *semantic(Loc loc, Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -789,7 +779,6 @@ class TypeInstance : public TypeQualified\n     const char *kind();\n     Type *syntaxCopy();\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n-    Type *semantic(Loc loc, Scope *sc);\n     Dsymbol *toDsymbol(Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -805,7 +794,6 @@ class TypeTypeof : public TypeQualified\n     Type *syntaxCopy();\n     Dsymbol *toDsymbol(Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n-    Type *semantic(Loc loc, Scope *sc);\n     d_uns64 size(Loc loc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -818,7 +806,6 @@ class TypeReturn : public TypeQualified\n     Type *syntaxCopy();\n     Dsymbol *toDsymbol(Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n-    Type *semantic(Loc loc, Scope *sc);\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n@@ -847,7 +834,6 @@ class TypeStruct : public Type\n     d_uns64 size(Loc loc);\n     unsigned alignsize();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     Dsymbol *toDsymbol(Scope *sc);\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     structalign_t alignment();\n@@ -878,7 +864,6 @@ class TypeEnum : public Type\n     Type *syntaxCopy();\n     d_uns64 size(Loc loc);\n     unsigned alignsize();\n-    Type *semantic(Loc loc, Scope *sc);\n     Dsymbol *toDsymbol(Scope *sc);\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     Expression *getProperty(Loc loc, Identifier *ident, int flag);\n@@ -917,7 +902,6 @@ class TypeClass : public Type\n     const char *kind();\n     d_uns64 size(Loc loc) /*const*/;\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     Dsymbol *toDsymbol(Scope *sc);\n     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);\n     ClassDeclaration *isClassHandle();\n@@ -948,7 +932,6 @@ class TypeTuple : public Type\n     TypeTuple(Type *t1, Type *t2);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     bool equals(RootObject *o);\n     Expression *getProperty(Loc loc, Identifier *ident, int flag);\n     Expression *defaultInit(Loc loc);\n@@ -964,7 +947,6 @@ class TypeSlice : public TypeNext\n     TypeSlice(Type *next, Expression *lwr, Expression *upr);\n     const char *kind();\n     Type *syntaxCopy();\n-    Type *semantic(Loc loc, Scope *sc);\n     void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n     void accept(Visitor *v) { v->visit(this); }\n };"}, {"sha": "12c8b490cfb4936778c2adb0c12481e7c3301a6a", "filename": "gcc/d/dmd/nogc.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fnogc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fnogc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -83,7 +83,7 @@ class NOGCVisitor : public StoppableVisitor\n \n         if (f->setGC())\n         {\n-            e->error(\"array literal in @nogc %s '%s' may cause GC allocation\",\n+            e->error(\"array literal in @nogc %s `%s` may cause GC allocation\",\n                 f->kind(), f->toPrettyChars());\n             err = true;\n             return;\n@@ -98,7 +98,7 @@ class NOGCVisitor : public StoppableVisitor\n \n         if (f->setGC())\n         {\n-            e->error(\"associative array literal in @nogc %s '%s' may cause GC allocation\",\n+            e->error(\"associative array literal in @nogc %s `%s` may cause GC allocation\",\n                 f->kind(), f->toPrettyChars());\n             err = true;\n             return;\n@@ -120,12 +120,12 @@ class NOGCVisitor : public StoppableVisitor\n \n         if (f->setGC())\n         {\n-            e->error(\"cannot use 'new' in @nogc %s '%s'\",\n+            e->error(\"cannot use `new` in @nogc %s `%s`\",\n                 f->kind(), f->toPrettyChars());\n             err = true;\n             return;\n         }\n-        f->printGCUsage(e->loc, \"'new' causes GC allocation\");\n+        f->printGCUsage(e->loc, \"`new` causes GC allocation\");\n     }\n \n     void visit(DeleteExp *e)\n@@ -159,12 +159,12 @@ class NOGCVisitor : public StoppableVisitor\n \n         if (f->setGC())\n         {\n-            e->error(\"cannot use 'delete' in @nogc %s '%s'\",\n+            e->error(\"cannot use `delete` in @nogc %s `%s`\",\n                 f->kind(), f->toPrettyChars());\n             err = true;\n             return;\n         }\n-        f->printGCUsage(e->loc, \"'delete' requires GC\");\n+        f->printGCUsage(e->loc, \"`delete` requires GC\");\n     }\n \n     void visit(IndexExp* e)\n@@ -174,7 +174,7 @@ class NOGCVisitor : public StoppableVisitor\n         {\n             if (f->setGC())\n             {\n-                e->error(\"indexing an associative array in @nogc %s '%s' may cause GC allocation\",\n+                e->error(\"indexing an associative array in @nogc %s `%s` may cause GC allocation\",\n                     f->kind(), f->toPrettyChars());\n                 err = true;\n                 return;\n@@ -189,20 +189,20 @@ class NOGCVisitor : public StoppableVisitor\n         {\n             if (f->setGC())\n             {\n-                e->error(\"setting 'length' in @nogc %s '%s' may cause GC allocation\",\n+                e->error(\"setting `length` in @nogc %s `%s` may cause GC allocation\",\n                     f->kind(), f->toPrettyChars());\n                 err = true;\n                 return;\n             }\n-            f->printGCUsage(e->loc, \"setting 'length' may cause GC allocation\");\n+            f->printGCUsage(e->loc, \"setting `length` may cause GC allocation\");\n         }\n     }\n \n     void visit(CatAssignExp *e)\n     {\n         if (f->setGC())\n         {\n-            e->error(\"cannot use operator ~= in @nogc %s '%s'\",\n+            e->error(\"cannot use operator ~= in @nogc %s `%s`\",\n                 f->kind(), f->toPrettyChars());\n             err = true;\n             return;\n@@ -214,7 +214,7 @@ class NOGCVisitor : public StoppableVisitor\n     {\n         if (f->setGC())\n         {\n-            e->error(\"cannot use operator ~ in @nogc %s '%s'\",\n+            e->error(\"cannot use operator ~ in @nogc %s `%s`\",\n                 f->kind(), f->toPrettyChars());\n             err = true;\n             return;"}, {"sha": "95cfb6f0d346fd87fbf4f6ab528e86d777121d00", "filename": "gcc/d/dmd/nspace.c", "status": "modified", "additions": 4, "deletions": 78, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fnspace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fnspace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n // Compiler implementation of the D programming language\n-// Copyright: Copyright (C) 2014-2020 by The D Language Foundation, All Rights Reserved\n+// Copyright: Copyright (C) 2014-2021 by The D Language Foundation, All Rights Reserved\n // Authors: Walter Bright, http://www.digitalmars.com\n // License: http://boost.org/LICENSE_1_0.txt\n // Source: https://github.com/D-Programming-Language/dmd/blob/master/src/nspace.c\n@@ -86,80 +86,6 @@ void Nspace::setScope(Scope *sc)\n     }\n }\n \n-void Nspace::semantic(Scope *sc)\n-{\n-    if (semanticRun != PASSinit)\n-        return;\n-    if (_scope)\n-    {\n-        sc = _scope;\n-        _scope = NULL;\n-    }\n-    if (!sc)\n-        return;\n-\n-    semanticRun = PASSsemantic;\n-    parent = sc->parent;\n-    if (members)\n-    {\n-        assert(sc);\n-        sc = sc->push(this);\n-        sc->linkage = LINKcpp;          // note that namespaces imply C++ linkage\n-        sc->parent = this;\n-\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->importAll(sc);\n-        }\n-\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic(sc);\n-        }\n-        sc->pop();\n-    }\n-    semanticRun = PASSsemanticdone;\n-}\n-\n-void Nspace::semantic2(Scope *sc)\n-{\n-    if (semanticRun >= PASSsemantic2)\n-        return;\n-    semanticRun = PASSsemantic2;\n-    if (members)\n-    {\n-        assert(sc);\n-        sc = sc->push(this);\n-        sc->linkage = LINKcpp;\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic2(sc);\n-        }\n-        sc->pop();\n-    }\n-}\n-\n-void Nspace::semantic3(Scope *sc)\n-{\n-    if (semanticRun >= PASSsemantic3)\n-        return;\n-    semanticRun = PASSsemantic3;\n-    if (members)\n-    {\n-        sc = sc->push(this);\n-        sc->linkage = LINKcpp;\n-        for (size_t i = 0; i < members->length; i++)\n-        {\n-            Dsymbol *s = (*members)[i];\n-            s->semantic3(sc);\n-        }\n-        sc->pop();\n-    }\n-}\n-\n const char *Nspace::kind() const\n {\n     return \"namespace\";\n@@ -174,11 +100,11 @@ Dsymbol *Nspace::search(const Loc &loc, Identifier *ident, int flags)\n {\n     //printf(\"%s::Nspace::search('%s')\\n\", toChars(), ident->toChars());\n     if (_scope && !symtab)\n-        semantic(_scope);\n+        dsymbolSemantic(this, _scope);\n \n     if (!members || !symtab) // opaque or semantic() is not yet called\n     {\n-        error(\"is forward referenced when looking for '%s'\", ident->toChars());\n+        error(\"is forward referenced when looking for `%s`\", ident->toChars());\n         return NULL;\n     }\n \n@@ -225,7 +151,7 @@ void Nspace::setFieldOffset(AggregateDeclaration *ad, unsigned *poffset, bool is\n {\n     //printf(\"Nspace::setFieldOffset() %s\\n\", toChars());\n     if (_scope)                  // if fwd reference\n-        semantic(NULL);         // try to resolve it\n+        dsymbolSemantic(this, NULL);         // try to resolve it\n     if (members)\n     {\n         for (size_t i = 0; i < members->length; i++)"}, {"sha": "71dafb2553d230d8789199727a57f560c01826df", "filename": "gcc/d/dmd/nspace.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fnspace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fnspace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -25,9 +25,6 @@ class Nspace : public ScopeDsymbol\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     void setScope(Scope *sc);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n-    void semantic3(Scope *sc);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     Dsymbol *search(const Loc &loc, Identifier *ident, int flags = SearchLocalsOnly);\n     int apply(Dsymbol_apply_ft_t fp, void *param);"}, {"sha": "3199a0164ee3f0839e59262ba15b3b01e076a8e8", "filename": "gcc/d/dmd/objc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fobjc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fobjc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2015-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2015-2021 by The D Language Foundation, All Rights Reserved\n  * written by Michel Fortin\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "f3da5a3755f2abf0f30488720f9850b8ff452298", "filename": "gcc/d/dmd/objc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2015-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2015-2021 by The D Language Foundation, All Rights Reserved\n  * written by Michel Fortin\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "0aff8b43551788b840ddaa31ba453da7e8aec11f", "filename": "gcc/d/dmd/opover.c", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fopover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fopover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -27,9 +27,6 @@ static Dsymbol *inferApplyArgTypesX(Expression *ethis, FuncDeclaration *fstart,\n static int inferApplyArgTypesY(TypeFunction *tf, Parameters *parameters, int flags = 0);\n Expression *compare_overload(BinExp *e, Scope *sc, Identifier *id);\n bool MODimplicitConv(MOD modfrom, MOD modto);\n-Expression *trySemantic(Expression *e, Scope *sc);\n-Expression *binSemanticProp(BinExp *e, Scope *sc);\n-Expression *semantic(Expression *e, Scope *sc);\n \n /******************************** Expression **************************/\n \n@@ -195,7 +192,7 @@ Objects *opToArg(Scope *sc, TOK op)\n         default:                     break;\n     }\n     Expression *e = new StringExp(Loc(), const_cast<char *>(Token::toChars(op)));\n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     Objects *tiargs = new Objects();\n     tiargs->push(e);\n     return tiargs;\n@@ -234,7 +231,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n             if (e->e1->op == TOKarray)\n             {\n                 ArrayExp *ae = (ArrayExp *)e->e1;\n-                ae->e1 = semantic(ae->e1, sc);\n+                ae->e1 = expressionSemantic(ae->e1, sc);\n                 ae->e1 = resolveProperties(sc, ae->e1);\n                 Expression *ae1old = ae->e1;\n \n@@ -282,7 +279,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         if (maybeSlice) // op(a[]) might be: a.opSliceUnary!(op)()\n                             result = trySemantic(result, sc);\n                         else\n-                            result = semantic(result, sc);\n+                            result = expressionSemantic(result, sc);\n                         if (result)\n                         {\n                             result = Expression::combine(e0, result);\n@@ -309,7 +306,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         Objects *tiargs = opToArg(sc, e->op);\n                         result = new DotTemplateInstanceExp(e->loc, ae->e1, Id::opSliceUnary, tiargs);\n                         result = new CallExp(e->loc, result, a);\n-                        result = semantic(result, sc);\n+                        result = expressionSemantic(result, sc);\n                         result = Expression::combine(e0, result);\n                         return;\n                     }\n@@ -333,7 +330,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                 ae->lengthVar = NULL;\n             }\n \n-            e->e1 = semantic(e->e1, sc);\n+            e->e1 = expressionSemantic(e->e1, sc);\n             e->e1 = resolveProperties(sc, e->e1);\n             if (e->e1->op == TOKerror)\n             {\n@@ -367,7 +364,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     Objects *tiargs = opToArg(sc, e->op);\n                     result = new DotTemplateInstanceExp(e->loc, e->e1, fd->ident, tiargs);\n                     result = new CallExp(e->loc, result);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                     return;\n                 }\n \n@@ -392,7 +389,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n         void visit(ArrayExp *ae)\n         {\n             //printf(\"ArrayExp::op_overload() (%s)\\n\", ae->toChars());\n-            ae->e1 = semantic(ae->e1, sc);\n+            ae->e1 = expressionSemantic(ae->e1, sc);\n             ae->e1 = resolveProperties(sc, ae->e1);\n             Expression *ae1old = ae->e1;\n \n@@ -435,14 +432,14 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         if (maybeSlice)\n                         {\n                             result = new SliceExp(ae->loc, ae->e1, ie);\n-                            result = semantic(result, sc);\n+                            result = expressionSemantic(result, sc);\n                             return;\n                         }\n                         // Convert to IndexExp\n                         if (ae->arguments->length == 1)\n                         {\n                             result = new IndexExp(ae->loc, ae->e1, (*ae->arguments)[0]);\n-                            result = semantic(result, sc);\n+                            result = expressionSemantic(result, sc);\n                             return;\n                         }\n                     }\n@@ -466,7 +463,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     if (maybeSlice) // a[] might be: a.opSlice()\n                         result = trySemantic(result, sc);\n                     else\n-                        result = semantic(result, sc);\n+                        result = expressionSemantic(result, sc);\n                     if (result)\n                     {\n                         result = Expression::combine(e0, result);\n@@ -477,7 +474,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                 if (maybeSlice && ae->e1->op == TOKtype)\n                 {\n                     result = new SliceExp(ae->loc, ae->e1, ie);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                     result = Expression::combine(e0, result);\n                     return;\n                 }\n@@ -499,7 +496,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     }\n                     result = new DotIdExp(ae->loc, ae->e1, Id::slice);\n                     result = new CallExp(ae->loc, result, a);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                     result = Expression::combine(e0, result);\n                     return;\n                 }\n@@ -553,7 +550,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     tiargs->push(e->to);\n                     result = new DotTemplateInstanceExp(e->loc, e->e1, fd->ident, tiargs);\n                     result = new CallExp(e->loc, result);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                     return;\n                 }\n \n@@ -942,7 +939,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n             if ((t1->ty == Tclass && e->e2->op == TOKnull) ||\n                 (t2->ty == Tclass && e->e1->op == TOKnull))\n             {\n-                e->error(\"use '%s' instead of '%s' when comparing with null\",\n+                e->error(\"use `%s` instead of `%s` when comparing with null\",\n                     Token::toChars(e->op == TOKequal ? TOKidentity : TOKnotidentity),\n                     Token::toChars(e->op));\n                 result = new ErrorExp();\n@@ -985,7 +982,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     result = new CallExp(e->loc, result, e1x, e2x);\n                     if (e->op == TOKnotequal)\n                         result = new NotExp(e->loc, result);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                     return;\n                 }\n             }\n@@ -996,7 +993,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                 if (result->op == TOKcall && e->op == TOKnotequal)\n                 {\n                     result = new NotExp(result->loc, result);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                 }\n                 return;\n             }\n@@ -1015,7 +1012,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                  */\n                 TOK op2 = e->op == TOKequal ? TOKidentity : TOKnotidentity;\n                 result = new IdentityExp(op2, e->loc, e->e1, e->e2);\n-                result = semantic(result, sc);\n+                result = expressionSemantic(result, sc);\n                 return;\n             }\n \n@@ -1032,7 +1029,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     // Use bitwise equality.\n                     TOK op2 = e->op == TOKequal ? TOKidentity : TOKnotidentity;\n                     result = new IdentityExp(op2, e->loc, e->e1, e->e2);\n-                    result = semantic(result, sc);\n+                    result = expressionSemantic(result, sc);\n                     return;\n                 }\n \n@@ -1058,7 +1055,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     e->att2 = t2;\n                 e->e1 = new DotIdExp(e->loc, e->e1, Id::_tupleof);\n                 e->e2 = new DotIdExp(e->loc, e->e2, Id::_tupleof);\n-                result = semantic(e, sc);\n+                result = expressionSemantic(e, sc);\n \n                 /* Bugzilla 15292, if the rewrite result is same with the original,\n                  * the equality is unresolvable because it has recursive definition.\n@@ -1113,7 +1110,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                     assert(result);\n                 }\n                 result = Expression::combine(Expression::combine(tup1->e0, tup2->e0), result);\n-                result = semantic(result, sc);\n+                result = expressionSemantic(result, sc);\n                 return;\n             }\n         }\n@@ -1135,7 +1132,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n             if (e->e1->op == TOKarray)\n             {\n                 ArrayExp *ae = (ArrayExp *)e->e1;\n-                ae->e1 = semantic(ae->e1, sc);\n+                ae->e1 = expressionSemantic(ae->e1, sc);\n                 ae->e1 = resolveProperties(sc, ae->e1);\n                 Expression *ae1old = ae->e1;\n \n@@ -1173,7 +1170,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         if (result->op == TOKerror)\n                             return;\n \n-                        result = semantic(e->e2, sc);\n+                        result = expressionSemantic(e->e2, sc);\n                         if (result->op == TOKerror)\n                             return;\n                         e->e2 = result;\n@@ -1189,7 +1186,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         if (maybeSlice) // (a[] op= e2) might be: a.opSliceOpAssign!(op)(e2)\n                             result = trySemantic(result, sc);\n                         else\n-                            result = semantic(result, sc);\n+                            result = expressionSemantic(result, sc);\n                         if (result)\n                         {\n                             result = Expression::combine(e0, result);\n@@ -1204,7 +1201,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         if (result->op == TOKerror)\n                             return;\n \n-                        result = semantic(e->e2, sc);\n+                        result = expressionSemantic(e->e2, sc);\n                         if (result->op == TOKerror)\n                             return;\n                         e->e2 = result;\n@@ -1222,7 +1219,7 @@ Expression *op_overload(Expression *e, Scope *sc)\n                         Objects *tiargs = opToArg(sc, e->op);\n                         result = new DotTemplateInstanceExp(e->loc, ae->e1, Id::opSliceOpAssign, tiargs);\n                         result = new CallExp(e->loc, result, a);\n-                        result = semantic(result, sc);\n+                        result = expressionSemantic(result, sc);\n                         result = Expression::combine(e0, result);\n                         return;\n                     }\n@@ -1570,7 +1567,7 @@ Expression *build_overload(Loc loc, Scope *sc, Expression *ethis, Expression *ea\n         e = new DotIdExp(loc, ethis, d->ident);\n     e = new CallExp(loc, e, earg);\n \n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     return e;\n }\n \n@@ -1611,7 +1608,7 @@ bool inferAggregate(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n \n     while (1)\n     {\n-        aggr = semantic(aggr, sc);\n+        aggr = expressionSemantic(aggr, sc);\n         aggr = resolveProperties(sc, aggr);\n         aggr = aggr->optimize(WANTvalue);\n         if (!aggr->type || aggr->op == TOKerror)\n@@ -1714,7 +1711,7 @@ bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply)\n             Parameter *p = (*fes->parameters)[u];\n             if (p->type)\n             {\n-                p->type = p->type->semantic(fes->loc, sc);\n+                p->type = typeSemantic(p->type, fes->loc, sc);\n                 p->type = p->type->addStorageClass(p->storageClass);\n             }\n         }"}, {"sha": "44dedd84038a9829b1c69db9e1d7d93a65d6b4c3", "filename": "gcc/d/dmd/optimize.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0\n@@ -21,8 +21,6 @@\n #include \"ctfe.h\"\n #include \"errors.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-\n /*************************************\n  * If variable has a const initializer,\n  * return that initializer.\n@@ -36,7 +34,7 @@ Expression *expandVar(int result, VarDeclaration *v)\n     if (!v)\n         return e;\n     if (!v->originalType && v->semanticRun < PASSsemanticdone) // semantic() not yet run\n-        v->semantic(NULL);\n+        dsymbolSemantic(v, NULL);\n \n     if (v->isConst() || v->isImmutable() || v->storage_class & STCmanifest)\n     {\n@@ -97,7 +95,7 @@ Expression *expandVar(int result, VarDeclaration *v)\n                     {\n                         // const var initialized with non-const expression\n                         ei = ei->implicitCastTo(NULL, v->type);\n-                        ei = semantic(ei, NULL);\n+                        ei = expressionSemantic(ei, NULL);\n                     }\n                     else\n                         goto L1;"}, {"sha": "c050b0504048524d87b117ea5ff916b7b6d85562", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -144,7 +144,7 @@ Dsymbols *Parser::parseModule()\n                 }\n                 default:\n                 {\n-                    error(\"'module' expected instead of %s\", token.toChars());\n+                    error(\"`module` expected instead of %s\", token.toChars());\n                     nextToken();\n                     break;\n                 }\n@@ -195,7 +195,7 @@ Dsymbols *Parser::parseModule()\n             md->msg = msg;\n \n             if (token.value != TOKsemicolon)\n-                error(\"';' expected following module declaration instead of %s\", token.toChars());\n+                error(\"`;` expected following module declaration instead of %s\", token.toChars());\n             nextToken();\n             addComment(mod, comment);\n         }\n@@ -399,7 +399,7 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                 }\n                 else\n                 {\n-                    error(\"invariant body expected, not '%s'\", token.toChars());\n+                    error(\"invariant body expected, not `%s`\", token.toChars());\n                     goto Lerror;\n                 }\n                 break;\n@@ -458,13 +458,13 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n \n             case TOKcolon:\n             case TOKlcurly:\n-                error(\"declaration expected, not '%s'\",token.toChars());\n+                error(\"declaration expected, not `%s`\",token.toChars());\n                 goto Lerror;\n \n             case TOKrcurly:\n             case TOKeof:\n                 if (once)\n-                    error(\"declaration expected, not '%s'\", token.toChars());\n+                    error(\"declaration expected, not `%s`\", token.toChars());\n                 return decldefs;\n \n             case TOKstatic:\n@@ -749,10 +749,10 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                 if (pAttrs->protection.kind != Prot::undefined)\n                 {\n                     if (pAttrs->protection.kind != prot)\n-                        error(\"conflicting protection attribute '%s' and '%s'\",\n+                        error(\"conflicting protection attribute `%s` and `%s`\",\n                             protectionToChars(pAttrs->protection.kind), protectionToChars(prot));\n                     else\n-                        error(\"redundant protection attribute '%s'\", protectionToChars(prot));\n+                        error(\"redundant protection attribute `%s`\", protectionToChars(prot));\n                 }\n                 pAttrs->protection.kind = prot;\n \n@@ -942,7 +942,7 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                 continue;\n \n             default:\n-                error(\"declaration expected, not '%s'\",token.toChars());\n+                error(\"declaration expected, not `%s`\",token.toChars());\n             Lerror:\n                 while (token.value != TOKsemicolon && token.value != TOKeof)\n                     nextToken();\n@@ -985,9 +985,9 @@ StorageClass Parser::appendStorageClass(StorageClass storageClass, StorageClass\n         OutBuffer buf;\n         stcToBuffer(&buf, stc);\n         if (deprec)\n-            deprecation(\"redundant attribute '%s'\", buf.peekChars());\n+            deprecation(\"redundant attribute `%s`\", buf.peekChars());\n         else\n-            error(\"redundant attribute '%s'\", buf.peekChars());\n+            error(\"redundant attribute `%s`\", buf.peekChars());\n         return storageClass | stc;\n     }\n \n@@ -997,19 +997,19 @@ StorageClass Parser::appendStorageClass(StorageClass storageClass, StorageClass\n     {\n         StorageClass u = storageClass & (STCconst | STCimmutable | STCmanifest);\n         if (u & (u - 1))\n-            error(\"conflicting attribute '%s'\", Token::toChars(token.value));\n+            error(\"conflicting attribute `%s`\", Token::toChars(token.value));\n     }\n     if (stc & (STCgshared | STCshared | STCtls))\n     {\n         StorageClass u = storageClass & (STCgshared | STCshared | STCtls);\n         if (u & (u - 1))\n-            error(\"conflicting attribute '%s'\", Token::toChars(token.value));\n+            error(\"conflicting attribute `%s`\", Token::toChars(token.value));\n     }\n     if (stc & (STCsafe | STCsystem | STCtrusted))\n     {\n         StorageClass u = storageClass & (STCsafe | STCsystem | STCtrusted);\n         if (u & (u - 1))\n-            error(\"conflicting attribute '@%s'\", token.toChars());\n+            error(\"conflicting attribute `@%s`\", token.toChars());\n     }\n \n     return storageClass;\n@@ -1170,7 +1170,7 @@ Dsymbols *Parser::parseBlock(Dsymbol **pLastDecl, PrefixAttributes *pAttrs)\n     switch (token.value)\n     {\n         case TOKsemicolon:\n-            error(\"declaration expected following attribute, not ';'\");\n+            error(\"declaration expected following attribute, not `;`\");\n             nextToken();\n             break;\n \n@@ -1188,7 +1188,7 @@ Dsymbols *Parser::parseBlock(Dsymbol **pLastDecl, PrefixAttributes *pAttrs)\n             if (token.value != TOKrcurly)\n             {\n                 /* { */\n-                error(\"matching '}' expected, not %s\", token.toChars());\n+                error(\"matching `}` expected, not %s\", token.toChars());\n             }\n             else\n                 nextToken();\n@@ -1439,7 +1439,7 @@ Identifiers *Parser::parseQualifiedIdentifier(const char *entity)\n         nextToken();\n         if (token.value != TOKidentifier)\n         {\n-            error(\"%s expected as dot-separated identifiers, got '%s'\",\n+            error(\"%s expected as dot-separated identifiers, got `%s`\",\n                     entity, token.toChars());\n             return NULL;\n         }\n@@ -1620,9 +1620,9 @@ Dsymbol *Parser::parseCtor(PrefixAttributes *pAttrs)\n     else if (StorageClass ss = stc & (STCshared | STCstatic))   // this()\n     {\n         if (ss == STCstatic)\n-            error(loc, \"use 'static this()' to declare a static constructor\");\n+            error(loc, \"use `static this()` to declare a static constructor\");\n         else if (ss == (STCshared | STCstatic))\n-            error(loc, \"use 'shared static this()' to declare a shared static constructor\");\n+            error(loc, \"use `shared static this()` to declare a shared static constructor\");\n     }\n \n     Expression *constraint = tpl ? parseConstraint() : NULL;\n@@ -1674,9 +1674,9 @@ Dsymbol *Parser::parseDtor(PrefixAttributes *pAttrs)\n     if (StorageClass ss = stc & (STCshared | STCstatic))\n     {\n         if (ss == STCstatic)\n-            error(loc, \"use 'static ~this()' to declare a static destructor\");\n+            error(loc, \"use `static ~this()` to declare a static destructor\");\n         else if (ss == (STCshared | STCstatic))\n-            error(loc, \"use 'shared static ~this()' to declare a shared static destructor\");\n+            error(loc, \"use `shared static ~this()` to declare a shared static destructor\");\n     }\n \n     DtorDeclaration *f = new DtorDeclaration(loc, Loc(), stc, Id::dtor);\n@@ -1711,7 +1711,7 @@ Dsymbol *Parser::parseStaticCtor(PrefixAttributes *pAttrs)\n \n     stc = parsePostfix(stc & ~STC_TYPECTOR, NULL) | stc;\n     if (stc & STCshared)\n-        error(loc, \"use 'shared static this()' to declare a shared static constructor\");\n+        error(loc, \"use `shared static this()` to declare a shared static constructor\");\n     else if (stc & STCstatic)\n         appendStorageClass(stc, STCstatic);     // complaint for the redundancy\n     else if (StorageClass modStc = stc & STC_TYPECTOR)\n@@ -1749,7 +1749,7 @@ Dsymbol *Parser::parseStaticDtor(PrefixAttributes *pAttrs)\n \n     stc = parsePostfix(stc & ~STC_TYPECTOR, &udas) | stc;\n     if (stc & STCshared)\n-        error(loc, \"use 'shared static ~this()' to declare a shared static destructor\");\n+        error(loc, \"use `shared static ~this()` to declare a shared static destructor\");\n     else if (stc & STCstatic)\n         appendStorageClass(stc, STCstatic);     // complaint for the redundancy\n     else if (StorageClass modStc = stc & STC_TYPECTOR)\n@@ -2856,7 +2856,7 @@ Dsymbol *Parser::parseMixin()\n         nextToken();\n         if (token.value != TOKidentifier)\n         {\n-            error(\"identifier expected following '.' instead of '%s'\", token.toChars());\n+            error(\"identifier expected following `.` instead of `%s`\", token.toChars());\n             break;\n         }\n         loc = token.loc;\n@@ -2874,7 +2874,7 @@ Dsymbol *Parser::parseMixin()\n \n     tm = new TemplateMixin(locMixin, id, tqual, tiargs);\n     if (token.value != TOKsemicolon)\n-        error(\"';' expected after mixin\");\n+        error(\"`;` expected after mixin\");\n     nextToken();\n \n     return tm;\n@@ -3144,7 +3144,7 @@ Dsymbols *Parser::parseImport()\n         nextToken();\n     else\n     {\n-        error(\"';' expected\");\n+        error(\"`;` expected\");\n         nextToken();\n     }\n \n@@ -3373,7 +3373,7 @@ Type *Parser::parseBasicTypeStartingAt(TypeQualified *tid, bool dontLookDotIdent\n                 nextToken();\n                 if (token.value != TOKidentifier)\n                 {\n-                    error(\"identifier expected following '.' instead of '%s'\", token.toChars());\n+                    error(\"identifier expected following `.` instead of `%s`\", token.toChars());\n                     break;\n                 }\n                 if (maybeArray)\n@@ -3602,7 +3602,7 @@ Type *Parser::parseDeclarator(Type *t, int *palt, Identifier **pident,\n             if (pident)\n                 *pident = token.ident;\n             else\n-                error(\"unexpected identifer '%s' in declarator\", token.ident->toChars());\n+                error(\"unexpected identifer `%s` in declarator\", token.ident->toChars());\n             ts = t;\n             nextToken();\n             break;\n@@ -3635,7 +3635,7 @@ Type *Parser::parseDeclarator(Type *t, int *palt, Identifier **pident,\n              */\n             if (isParameters(&peekt))\n             {\n-                error(\"function declaration without return type. (Note that constructors are always named 'this')\");\n+                error(\"function declaration without return type. (Note that constructors are always named `this`)\");\n             }\n             else\n                 error(\"unexpected ( in declarator\");\n@@ -4188,7 +4188,7 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n             if (init)\n             {\n                 if (isThis)\n-                    error(\"cannot use syntax 'alias this = %s', use 'alias %s this' instead\",\n+                    error(\"cannot use syntax `alias this = %s`, use `alias %s this` instead\",\n                           init->toChars(), init->toChars());\n                 else\n                     error(\"alias cannot have initializer\");\n@@ -4332,7 +4332,7 @@ Dsymbols *Parser::parseDeclarations(bool autodecl, PrefixAttributes *pAttrs, con\n                     continue;\n \n                 default:\n-                    error(\"semicolon expected, not '%s'\", token.toChars());\n+                    error(\"semicolon expected, not `%s`\", token.toChars());\n                     break;\n             }\n         }\n@@ -4511,7 +4511,7 @@ Dsymbols *Parser::parseAutoDeclarations(StorageClass storageClass, const utf8_t\n                 continue;\n \n             default:\n-                error(\"semicolon expected following auto declaration, not '%s'\", token.toChars());\n+                error(\"semicolon expected following auto declaration, not `%s`\", token.toChars());\n                 break;\n         }\n         break;\n@@ -4758,7 +4758,7 @@ Initializer *Parser::parseInitializer()\n \n                     case TOKcomma:\n                         if (comma == 2)\n-                            error(\"expression expected, not ','\");\n+                            error(\"expression expected, not `,`\");\n                         nextToken();\n                         comma = 2;\n                         continue;\n@@ -4778,7 +4778,7 @@ Initializer *Parser::parseInitializer()\n                         is->addInit(NULL, value);\n                         comma = 1;\n                         continue;\n-                        //error(\"found '%s' instead of field initializer\", token.toChars());\n+                        //error(\"found `%s` instead of field initializer\", token.toChars());\n                         //break;\n                 }\n                 break;\n@@ -4868,7 +4868,7 @@ Initializer *Parser::parseInitializer()\n \n                     case TOKcomma:\n                         if (comma == 2)\n-                            error(\"expression expected, not ','\");\n+                            error(\"expression expected, not `,`\");\n                         nextToken();\n                         comma = 2;\n                         continue;\n@@ -4878,7 +4878,7 @@ Initializer *Parser::parseInitializer()\n                         break;\n \n                     case TOKeof:\n-                        error(\"found '%s' instead of array initializer\", token.toChars());\n+                        error(\"found `%s` instead of array initializer\", token.toChars());\n                         break;\n                 }\n                 break;\n@@ -4965,9 +4965,9 @@ void Parser::checkCstyleTypeSyntax(Loc loc, Type *t, int alt, Identifier *ident)\n     const char *sp = !ident ? \"\" : \" \";\n     const char *s  = !ident ? \"\" : ident->toChars();\n     if (alt & 1)    // contains C-style function pointer syntax\n-        error(loc, \"instead of C-style syntax, use D-style '%s%s%s'\", t->toChars(), sp, s);\n+        error(loc, \"instead of C-style syntax, use D-style `%s%s%s`\", t->toChars(), sp, s);\n     else\n-        ::warning(loc, \"instead of C-style syntax, use D-style syntax '%s%s%s'\", t->toChars(), sp, s);\n+        ::warning(loc, \"instead of C-style syntax, use D-style syntax `%s%s%s`\", t->toChars(), sp, s);\n \n }\n \n@@ -5408,7 +5408,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n \n             nextToken();\n             //if (token.value == TOKsemicolon)\n-                //error(\"use '{ }' for an empty statement, not a ';'\");\n+                //error(\"use `{ }` for an empty statement, not a `;`\");\n             Statements *statements = new Statements();\n             while (token.value != TOKrcurly && token.value != TOKeof)\n             {\n@@ -5445,9 +5445,9 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n             if (!(flags & PSsemi_ok))\n             {\n                 if (flags & PSsemi)\n-                    deprecation(\"use '{ }' for an empty statement, not a ';'\");\n+                    deprecation(\"use `{ }` for an empty statement, not a `;`\");\n                 else\n-                    error(\"use '{ }' for an empty statement, not a ';'\");\n+                    error(\"use `{ }` for an empty statement, not a `;`\");\n             }\n             nextToken();\n             s = new ExpStatement(loc, (Expression *)NULL);\n@@ -5469,7 +5469,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n             if (token.value == TOKsemicolon)\n                 nextToken();\n             else\n-                error(\"terminating ';' required after do-while statement\");\n+                error(\"terminating `;` required after do-while statement\");\n             s = new DoStatement(loc, body, condition, token.loc);\n             break;\n         }\n@@ -6052,7 +6052,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n \n                         if (toklist || label)\n                         {\n-                            error(\"asm statements must end in ';'\");\n+                            error(\"asm statements must end in `;`\");\n                         }\n                         break;\n \n@@ -6078,7 +6078,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n \n                     case TOKeof:\n                         /* { */\n-                        error(\"matching '}' expected, not end of file\");\n+                        error(\"matching `}` expected, not end of file\");\n                         goto Lerror;\n                         /* fall through */\n \n@@ -6116,7 +6116,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n         }\n \n         default:\n-            error(\"found '%s' instead of statement\", token.toChars());\n+            error(\"found `%s` instead of statement\", token.toChars());\n             goto Lerror;\n \n         Lerror:\n@@ -6142,14 +6142,14 @@ void Parser::check(TOK value)\n void Parser::check(Loc loc, TOK value)\n {\n     if (token.value != value)\n-        error(loc, \"found '%s' when expecting '%s'\", token.toChars(), Token::toChars(value));\n+        error(loc, \"found `%s` when expecting `%s`\", token.toChars(), Token::toChars(value));\n     nextToken();\n }\n \n void Parser::check(TOK value, const char *string)\n {\n     if (token.value != value)\n-        error(\"found '%s' when expecting '%s' following %s\",\n+        error(\"found `%s` when expecting `%s` following %s\",\n             token.toChars(), Token::toChars(value), string);\n     nextToken();\n }\n@@ -6992,7 +6992,7 @@ Expression *Parser::parsePrimaryExp()\n \n         case TOKdollar:\n             if (!inBrackets)\n-                error(\"'$' is valid only inside [] of index or slice\");\n+                error(\"`$` is valid only inside [] of index or slice\");\n             e = new DollarExp(loc);\n             nextToken();\n             break;\n@@ -7148,7 +7148,7 @@ Expression *Parser::parsePrimaryExp()\n                 {\n                     if (token.postfix)\n                     {   if (token.postfix != postfix)\n-                            error(\"mismatched string literal postfixes '%c' and '%c'\", postfix, token.postfix);\n+                            error(\"mismatched string literal postfixes `'%c'` and `'%c'`\", postfix, token.postfix);\n                         postfix = token.postfix;\n                     }\n \n@@ -7204,7 +7204,7 @@ Expression *Parser::parsePrimaryExp()\n             }\n             check(TOKdot, t->toChars());\n             if (token.value != TOKidentifier)\n-            {   error(\"found '%s' when expecting identifier following '%s.'\", token.toChars(), t->toChars());\n+            {   error(\"found `%s` when expecting identifier following `%s.`\", token.toChars(), t->toChars());\n                 goto Lerr;\n             }\n             e = typeDotIdExp(loc, t, token.ident);\n@@ -7418,7 +7418,7 @@ Expression *Parser::parsePrimaryExp()\n                         e = parseAssignExp();\n                     }\n                     else if (keys)\n-                    {   error(\"'key:value' expected for associative array literal\");\n+                    {   error(\"`key:value` expected for associative array literal\");\n                         delete keys;\n                         keys = NULL;\n                     }\n@@ -7447,7 +7447,7 @@ Expression *Parser::parsePrimaryExp()\n         }\n \n         default:\n-            error(\"expression expected, not '%s'\", token.toChars());\n+            error(\"expression expected, not `%s`\", token.toChars());\n         Lerr:\n             // Anything for e, as long as it's not NULL\n             e = new IntegerExp(loc, 0, Type::tint32);\n@@ -7487,7 +7487,7 @@ Expression *Parser::parsePostExp(Expression *e)\n                     continue;\n                 }\n                 else\n-                    error(\"identifier expected following '.', not '%s'\", token.toChars());\n+                    error(\"identifier expected following `.`, not `%s`\", token.toChars());\n                 break;\n \n             case TOKplusplus:"}, {"sha": "82ce32546073346cac005049797dfa71db966948", "filename": "gcc/d/dmd/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "992a117da2af7e8cad4136cf1657aa1995a756d1", "filename": "gcc/d/dmd/root/aav.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Faav.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Faav.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 2010-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "c65b674a7f51da80d365512224de6a18970fd224", "filename": "gcc/d/dmd/root/aav.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Faav.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Faav.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 2010-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "f7cb0c75184f2ca7077bce7874e30cbbccbaa315", "filename": "gcc/d/dmd/root/array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2011-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2011-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "004c43caa541cd93c1c715e61733a62289d14dd1", "filename": "gcc/d/dmd/root/bitarray.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2011-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2011-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "af7b56f145c6ab1c312ab09a1ab153edeee7b15a", "filename": "gcc/d/dmd/root/checkedint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -21,7 +21,7 @@\n  * to recognize them and generate equivalent and faster code.\n  *\n  * References: $(LINK2 http://blog.regehr.org/archives/1139, Fast Integer Overflow Checks)\n- * Copyright: Copyright (C) 2014-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright: Copyright (C) 2014-2021 by The D Language Foundation, All Rights Reserved\n  * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n  * Authors:   Walter Bright\n  * Source:    https://github.com/D-Programming-Language/dmd/blob/master/src/root/checkedint.c"}, {"sha": "8a7d9c90d9f4b57f520fa8d8111e15f6215ad80e", "filename": "gcc/d/dmd/root/checkedint.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fcheckedint.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2003-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2003-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "0a829f3e051edc26535d01f7114fe80bda36914d", "filename": "gcc/d/dmd/root/ctfloat.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fctfloat.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "9fd176ebcb15be2a331d4c6c60123df535c955f5", "filename": "gcc/d/dmd/root/dcompat.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fdcompat.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "314b5b512c8bbd385c7088c7e39fdfe04f506af1", "filename": "gcc/d/dmd/root/file.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "51358182b7cb04affe0a982fe360ea82ed85a9c4", "filename": "gcc/d/dmd/root/file.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "0c5138b6ddf8f802e65e11b2625c65b5f47e6fd6", "filename": "gcc/d/dmd/root/filename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "52cd963d7085feb2a669dd7240274cb11778c9ea", "filename": "gcc/d/dmd/root/filename.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "6a3220062132cdf7154bb8e354e4f453936d4de2", "filename": "gcc/d/dmd/root/hash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fhash.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -2,7 +2,7 @@\n  * Compiler implementation of the D programming language\n  * http://dlang.org\n  *\n- * Copyright: Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright: Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * Authors:   Martin Nowak, Walter Bright, http://www.digitalmars.com\n  * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n  * Source:    $(DMDSRC root/_hash.h)"}, {"sha": "d5e3b2b090d48f24e3f0f2c1fa240b0b2ce890c3", "filename": "gcc/d/dmd/root/object.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fobject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fobject.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "7fbbfe57db32d57216a861be04a403bec79dfc96", "filename": "gcc/d/dmd/root/outbuffer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "186fbb7eb8483e510c3d73deb7f5ee15859a9bc1", "filename": "gcc/d/dmd/root/outbuffer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "94651cdd5a49431fe8044534577f0c0062bd624d", "filename": "gcc/d/dmd/root/port.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fport.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "768b75d27154c1e14c321597d5bd7583b73c09ca", "filename": "gcc/d/dmd/root/rmem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Frmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Frmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frmem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 2000-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2000-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "1f603b8c658eee81bf0e18f1d45f7463938e8926", "filename": "gcc/d/dmd/root/rmem.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Frmem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Frmem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frmem.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "d998d95be7666d9dde4309121986785caaacff05", "filename": "gcc/d/dmd/root/root.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Froot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Froot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Froot.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "7fee0d7297b2282e0051c064b33aa340d2c0f695", "filename": "gcc/d/dmd/root/rootobject.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Frootobject.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Frootobject.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Frootobject.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "3957c112a0782952710abd65c3d6f1c40d7c93f3", "filename": "gcc/d/dmd/root/speller.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fspeller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fspeller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fspeller.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 2010-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "bd53fc452c9e7d2825c2335cbb066c9edecabbd6", "filename": "gcc/d/dmd/root/speller.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fspeller.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fspeller.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fspeller.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 2010-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 2010-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "fe14807791d628a8d45899a05c153052b006d231", "filename": "gcc/d/dmd/root/stringtable.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * (See accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)"}, {"sha": "51304d32c3f041fe6aa13a5783082f67c52d6b61", "filename": "gcc/d/dmd/root/stringtable.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+/* Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "7d83dd170ade10f1fdd4ab5c4cbedfd609fe73ac", "filename": "gcc/d/dmd/safe.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsafe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsafe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsafe.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "ce0892606b8b532a37bd694f93f3d76ae3e23c81", "filename": "gcc/d/dmd/sapply.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsapply.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsapply.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "ea3bf3874e15f0613f9fc4e77f789a853c5de1b4", "filename": "gcc/d/dmd/scope.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fscope.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "7bcf6ce4f33c398e0db61b7335ce3f99e7d7e167", "filename": "gcc/d/dmd/semantic2.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsemantic2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsemantic2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -0,0 +1,410 @@\n+\n+/* Compiler implementation of the D programming language\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * written by Walter Bright\n+ * http://www.digitalmars.com\n+ * Distributed under the Boost Software License, Version 1.0.\n+ * http://www.boost.org/LICENSE_1_0.txt\n+ */\n+\n+#include \"dsymbol.h\"\n+#include \"aggregate.h\"\n+#include \"attrib.h\"\n+#include \"declaration.h\"\n+#include \"errors.h\"\n+#include \"import.h\"\n+#include \"init.h\"\n+#include \"module.h\"\n+#include \"nspace.h\"\n+#include \"objc.h\"\n+#include \"scope.h\"\n+#include \"staticassert.h\"\n+#include \"template.h\"\n+#include \"visitor.h\"\n+\n+bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors);\n+void udaExpressionEval(Scope *sc, Expressions *exps);\n+Objc *objc();\n+\n+class Semantic2Visitor : public Visitor\n+{\n+public:\n+    Scope *sc;\n+\n+    Semantic2Visitor(Scope *sc)\n+    {\n+        this->sc = sc;\n+    }\n+\n+    void visit(Dsymbol *)\n+    {\n+        // Most Dsymbols have no further semantic analysis needed\n+    }\n+\n+    void visit(StaticAssert *sa)\n+    {\n+        //printf(\"StaticAssert::semantic2() %s\\n\", toChars());\n+        ScopeDsymbol *sds = new ScopeDsymbol();\n+        sc = sc->push(sds);\n+        sc->tinst = NULL;\n+        sc->minst = NULL;\n+\n+        bool errors = false;\n+        bool result = evalStaticCondition(sc, sa->exp, sa->exp, errors);\n+        sc = sc->pop();\n+        if (errors)\n+        {\n+            errorSupplemental(sa->loc, \"while evaluating: static assert(%s)\", sa->exp->toChars());\n+        }\n+        else if (!result)\n+        {\n+            if (sa->msg)\n+            {\n+                sc = sc->startCTFE();\n+                sa->msg = expressionSemantic(sa->msg, sc);\n+                sa->msg = resolveProperties(sc, sa->msg);\n+                sc = sc->endCTFE();\n+                sa->msg = sa->msg->ctfeInterpret();\n+                if (StringExp * se = sa->msg->toStringExp())\n+                {\n+                    // same with pragma(msg)\n+                    se = se->toUTF8(sc);\n+                    sa->error(\"\\\"%.*s\\\"\", (int)se->len, (char *)se->string);\n+                }\n+                else\n+                    sa->error(\"%s\", sa->msg->toChars());\n+            }\n+            else\n+                sa->error(\"(%s) is false\", sa->exp->toChars());\n+            if (sc->tinst)\n+                sc->tinst->printInstantiationTrace();\n+            if (!global.gag)\n+                fatal();\n+        }\n+    }\n+\n+    void visit(TemplateInstance *tempinst)\n+    {\n+        if (tempinst->semanticRun >= PASSsemantic2)\n+            return;\n+        tempinst->semanticRun = PASSsemantic2;\n+        if (!tempinst->errors && tempinst->members)\n+        {\n+            TemplateDeclaration *tempdecl = tempinst->tempdecl->isTemplateDeclaration();\n+            assert(tempdecl);\n+\n+            sc = tempdecl->_scope;\n+            assert(sc);\n+            sc = sc->push(tempinst->argsym);\n+            sc = sc->push(tempinst);\n+            sc->tinst = tempinst;\n+            sc->minst = tempinst->minst;\n+\n+            int needGagging = (tempinst->gagged && !global.gag);\n+            unsigned int olderrors = global.errors;\n+            int oldGaggedErrors = -1;       // dead-store to prevent spurious warning\n+            if (needGagging)\n+                oldGaggedErrors = global.startGagging();\n+\n+            for (size_t i = 0; i < tempinst->members->length; i++)\n+            {\n+                Dsymbol *s = (*tempinst->members)[i];\n+                semantic2(s, sc);\n+                if (tempinst->gagged && global.errors != olderrors)\n+                    break;\n+            }\n+\n+            if (global.errors != olderrors)\n+            {\n+                if (!tempinst->errors)\n+                {\n+                    if (!tempdecl->literal)\n+                        tempinst->error(tempinst->loc, \"error instantiating\");\n+                    if (tempinst->tinst)\n+                        tempinst->tinst->printInstantiationTrace();\n+                }\n+                tempinst->errors = true;\n+            }\n+            if (needGagging)\n+                global.endGagging(oldGaggedErrors);\n+\n+            sc = sc->pop();\n+            sc->pop();\n+        }\n+    }\n+\n+    void visit(TemplateMixin *tmix)\n+    {\n+        if (tmix->semanticRun >= PASSsemantic2)\n+            return;\n+        tmix->semanticRun = PASSsemantic2;\n+        if (tmix->members)\n+        {\n+            assert(sc);\n+            sc = sc->push(tmix->argsym);\n+            sc = sc->push(tmix);\n+            for (size_t i = 0; i < tmix->members->length; i++)\n+            {\n+                Dsymbol *s = (*tmix->members)[i];\n+                semantic2(s, sc);\n+            }\n+            sc = sc->pop();\n+            sc->pop();\n+        }\n+    }\n+\n+    void visit(VarDeclaration *vd)\n+    {\n+        if (vd->semanticRun < PASSsemanticdone && vd->inuse)\n+            return;\n+\n+        //printf(\"VarDeclaration::semantic2('%s')\\n\", toChars());\n+\n+        if (vd->_init && !vd->toParent()->isFuncDeclaration())\n+        {\n+            vd->inuse++;\n+            // Bugzilla 14166: Don't run CTFE for the temporary variables inside typeof\n+            vd->_init = initializerSemantic(vd->_init, sc, vd->type, sc->intypeof == 1 ? INITnointerpret : INITinterpret);\n+            vd->inuse--;\n+        }\n+        if (vd->_init && (vd->storage_class & STCmanifest))\n+        {\n+            /* Cannot initializer enums with CTFE classreferences and addresses of struct literals.\n+             * Scan initializer looking for them. Issue error if found.\n+             */\n+            if (ExpInitializer *ei = vd->_init->isExpInitializer())\n+            {\n+                struct EnumInitializer\n+                {\n+                    static bool arrayHasInvalidEnumInitializer(Expressions *elems)\n+                    {\n+                        for (size_t i = 0; i < elems->length; i++)\n+                        {\n+                            Expression *e = (*elems)[i];\n+                            if (e && hasInvalidEnumInitializer(e))\n+                                return true;\n+                        }\n+                        return false;\n+                    }\n+\n+                    static bool hasInvalidEnumInitializer(Expression *e)\n+                    {\n+                        if (e->op == TOKclassreference)\n+                            return true;\n+                        if (e->op == TOKaddress && ((AddrExp *)e)->e1->op == TOKstructliteral)\n+                            return true;\n+                        if (e->op == TOKarrayliteral)\n+                            return arrayHasInvalidEnumInitializer(((ArrayLiteralExp *)e)->elements);\n+                        if (e->op == TOKstructliteral)\n+                            return arrayHasInvalidEnumInitializer(((StructLiteralExp *)e)->elements);\n+                        if (e->op == TOKassocarrayliteral)\n+                        {\n+                            AssocArrayLiteralExp *ae = (AssocArrayLiteralExp *)e;\n+                            return arrayHasInvalidEnumInitializer(ae->values) ||\n+                                arrayHasInvalidEnumInitializer(ae->keys);\n+                        }\n+                        return false;\n+                    }\n+                };\n+                if (EnumInitializer::hasInvalidEnumInitializer(ei->exp))\n+                    vd->error(\": Unable to initialize enum with class or pointer to struct. Use static const variable instead.\");\n+            }\n+        }\n+        else if (vd->_init && vd->isThreadlocal())\n+        {\n+            if ((vd->type->ty == Tclass) && vd->type->isMutable() && !vd->type->isShared())\n+            {\n+                ExpInitializer *ei = vd->_init->isExpInitializer();\n+                if (ei && ei->exp->op == TOKclassreference)\n+                    vd->error(\"is mutable. Only const or immutable class thread local variable are allowed, not %s\", vd->type->toChars());\n+            }\n+            else if (vd->type->ty == Tpointer && vd->type->nextOf()->ty == Tstruct && vd->type->nextOf()->isMutable() && !vd->type->nextOf()->isShared())\n+            {\n+                ExpInitializer *ei = vd->_init->isExpInitializer();\n+                if (ei && ei->exp->op == TOKaddress && ((AddrExp *)ei->exp)->e1->op == TOKstructliteral)\n+                {\n+                    vd->error(\"is a pointer to mutable struct. Only pointers to const, immutable or shared struct thread local variable are allowed, not %s\", vd->type->toChars());\n+                }\n+            }\n+        }\n+        vd->semanticRun = PASSsemantic2done;\n+    }\n+\n+    void visit(Module *mod)\n+    {\n+        //printf(\"Module::semantic2('%s'): parent = %p\\n\", toChars(), mod->parent);\n+        if (mod->semanticRun != PASSsemanticdone)       // semantic() not completed yet - could be recursive call\n+            return;\n+        mod->semanticRun = PASSsemantic2;\n+\n+        // Note that modules get their own scope, from scratch.\n+        // This is so regardless of where in the syntax a module\n+        // gets imported, it is unaffected by context.\n+        Scope *sc = Scope::createGlobal(mod);      // create root scope\n+        //printf(\"Module = %p\\n\", sc.scopesym);\n+\n+        // Pass 2 semantic routines: do initializers and function bodies\n+        for (size_t i = 0; i < mod->members->length; i++)\n+        {\n+            Dsymbol *s = (*mod->members)[i];\n+            semantic2(s, sc);\n+        }\n+\n+        if (mod->userAttribDecl)\n+        {\n+            semantic2(mod->userAttribDecl, sc);\n+        }\n+\n+        sc = sc->pop();\n+        sc->pop();\n+        mod->semanticRun = PASSsemantic2done;\n+        //printf(\"-Module::semantic2('%s'): parent = %p\\n\", toChars(), mod->parent);\n+    }\n+\n+    void visit(FuncDeclaration *fd)\n+    {\n+        if (fd->semanticRun >= PASSsemantic2done)\n+            return;\n+        assert(fd->semanticRun <= PASSsemantic2);\n+        fd->semanticRun = PASSsemantic2;\n+\n+        objc()->setSelector(fd, sc);\n+        objc()->validateSelector(fd);\n+\n+        if (fd->parent->isClassDeclaration())\n+        {\n+            objc()->checkLinkage(fd);\n+        }\n+        if (!fd->type || fd->type->ty != Tfunction)\n+            return;\n+        TypeFunction *f = fd->type->toTypeFunction();\n+        const size_t nparams = f->parameterList.length();\n+        // semantic for parameters' UDAs\n+        for (size_t i = 0; i < nparams; i++)\n+        {\n+            Parameter *param = f->parameterList[i];\n+            if (param && param->userAttribDecl)\n+                semantic2(param->userAttribDecl, sc);\n+        }\n+    }\n+\n+    void visit(Import *i)\n+    {\n+        //printf(\"Import::semantic2('%s')\\n\", toChars());\n+        if (i->mod)\n+        {\n+            semantic2(i->mod, NULL);\n+            if (i->mod->needmoduleinfo)\n+            {\n+                //printf(\"module5 %s because of %s\\n\", sc->_module->toChars(), i->mod->toChars());\n+                if (sc)\n+                    sc->_module->needmoduleinfo = 1;\n+            }\n+        }\n+    }\n+\n+    void visit(Nspace *ns)\n+    {\n+        if (ns->semanticRun >= PASSsemantic2)\n+            return;\n+        ns->semanticRun = PASSsemantic2;\n+        if (ns->members)\n+        {\n+            assert(sc);\n+            sc = sc->push(ns);\n+            sc->linkage = LINKcpp;\n+            for (size_t i = 0; i < ns->members->length; i++)\n+            {\n+                Dsymbol *s = (*ns->members)[i];\n+                semantic2(s, sc);\n+            }\n+            sc->pop();\n+        }\n+    }\n+\n+    void visit(AttribDeclaration *ad)\n+    {\n+        Dsymbols *d = ad->include(sc);\n+\n+        if (d)\n+        {\n+            Scope *sc2 = ad->newScope(sc);\n+\n+            for (size_t i = 0; i < d->length; i++)\n+            {\n+                Dsymbol *s = (*d)[i];\n+                semantic2(s, sc2);\n+            }\n+\n+            if (sc2 != sc)\n+                sc2->pop();\n+        }\n+    }\n+\n+    /**\n+     * Run the DeprecatedDeclaration's semantic2 phase then its members.\n+     *\n+     * The message set via a `DeprecatedDeclaration` can be either of:\n+     * - a string literal\n+     * - an enum\n+     * - a static immutable\n+     * So we need to call ctfe to resolve it.\n+     * Afterward forwards to the members' semantic2.\n+     */\n+    void visit(DeprecatedDeclaration *dd)\n+    {\n+        dd->getMessage();\n+        visit((AttribDeclaration *)dd);\n+    }\n+\n+    void visit(AlignDeclaration *ad)\n+    {\n+        ad->getAlignment(sc);\n+        visit((AttribDeclaration *)ad);\n+    }\n+\n+    void visit(UserAttributeDeclaration *uad)\n+    {\n+        if (uad->decl && uad->atts && uad->atts->length && uad->_scope)\n+        {\n+            uad->_scope = NULL;\n+            udaExpressionEval(sc, uad->atts);\n+        }\n+        visit((AttribDeclaration *)uad);\n+    }\n+\n+    void visit(AggregateDeclaration *ad)\n+    {\n+        //printf(\"AggregateDeclaration::semantic2(%s) type = %s, errors = %d\\n\", toChars(), ad->type->toChars(), ad->errors);\n+        if (!ad->members)\n+            return;\n+\n+        if (ad->_scope)\n+        {\n+            ad->error(\"has forward references\");\n+            return;\n+        }\n+\n+        Scope *sc2 = ad->newScope(sc);\n+\n+        ad->determineSize(ad->loc);\n+\n+        for (size_t i = 0; i < ad->members->length; i++)\n+        {\n+            Dsymbol *s = (*ad->members)[i];\n+            //printf(\"\\t[%d] %s\\n\", i, s->toChars());\n+            semantic2(s, sc2);\n+        }\n+\n+        sc2->pop();\n+    }\n+};\n+\n+/*************************************\n+ * Does semantic analysis on initializers and members of aggregates.\n+ */\n+void semantic2(Dsymbol *dsym, Scope *sc)\n+{\n+    Semantic2Visitor v(sc);\n+    dsym->accept(&v);\n+}"}, {"sha": "304eaeeb1190417f5a1448187c3fbb2016a832e8", "filename": "gcc/d/dmd/semantic3.c", "status": "added", "additions": 1421, "deletions": 0, "changes": 1421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsemantic3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsemantic3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -0,0 +1,1421 @@\n+\n+/* Compiler implementation of the D programming language\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * written by Walter Bright\n+ * http://www.digitalmars.com\n+ * Distributed under the Boost Software License, Version 1.0.\n+ * http://www.boost.org/LICENSE_1_0.txt\n+ */\n+\n+#include \"dsymbol.h\"\n+#include \"aggregate.h\"\n+#include \"attrib.h\"\n+#include \"declaration.h\"\n+#include \"errors.h\"\n+#include \"id.h\"\n+#include \"init.h\"\n+#include \"module.h\"\n+#include \"nspace.h\"\n+#include \"scope.h\"\n+#include \"statement.h\"\n+#include \"statement_rewrite_walker.h\"\n+#include \"target.h\"\n+#include \"template.h\"\n+#include \"visitor.h\"\n+\n+bool allowsContractWithoutBody(FuncDeclaration *funcdecl);\n+int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow);\n+bool checkReturnEscape(Scope *sc, Expression *e, bool gag);\n+bool checkReturnEscapeRef(Scope *sc, Expression *e, bool gag);\n+TypeIdentifier *getThrowable();\n+char *MODtoChars(MOD mod);\n+Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n+void allocFieldinit(Scope *sc, size_t dim);\n+void freeFieldinit(Scope *sc);\n+\n+/* Determine if function should add `return 0;`\n+ */\n+static bool addReturn0(FuncDeclaration *funcdecl)\n+{\n+    TypeFunction *f = (TypeFunction *)funcdecl->type;\n+\n+    return f->next->ty == Tvoid &&\n+        (funcdecl->isMain() || (global.params.betterC && funcdecl->isCMain()));\n+}\n+\n+/********************************************************\n+ * Generate Expression to call the invariant.\n+ * Input:\n+ *      ad      aggregate with the invariant\n+ *      vthis   variable with 'this'\n+ * Returns:\n+ *      void expression that calls the invariant\n+ */\n+static Expression *addInvariant(AggregateDeclaration *ad, VarDeclaration *vthis)\n+{\n+    Expression *e = NULL;\n+\n+    // Call invariant directly only if it exists\n+    FuncDeclaration *inv = ad->inv;\n+    ClassDeclaration *cd = ad->isClassDeclaration();\n+\n+    while (!inv && cd)\n+    {\n+        cd = cd->baseClass;\n+        if (!cd)\n+            break;\n+        inv = cd->inv;\n+    }\n+    if (inv)\n+    {\n+    #if 1\n+        // Workaround for bugzilla 13394: For the correct mangling,\n+        // run attribute inference on inv if needed.\n+        inv->functionSemantic();\n+    #endif\n+\n+        //e = new DsymbolExp(Loc(), inv);\n+        //e = new CallExp(Loc(), e);\n+        //dsymbolSemantic(e, sc2);\n+\n+        /* https://issues.dlang.org/show_bug.cgi?id=13113\n+         * Currently virtual invariant calls completely\n+         * bypass attribute enforcement.\n+         * Change the behavior of pre-invariant call by following it.\n+         */\n+        e = new ThisExp(Loc());\n+        e->type = vthis->type;\n+        e = new DotVarExp(Loc(), e, inv, false);\n+        e->type = inv->type;\n+        e = new CallExp(Loc(), e);\n+        e->type = Type::tvoid;\n+    }\n+    return e;\n+}\n+\n+/* Tweak all return statements and dtor call for nrvo_var, for correct NRVO.\n+ */\n+class NrvoWalker : public StatementRewriteWalker\n+{\n+public:\n+    FuncDeclaration *fd;\n+    Scope *sc;\n+\n+    void visit(ReturnStatement *s)\n+    {\n+        // See if all returns are instead to be replaced with a goto returnLabel;\n+        if (fd->returnLabel)\n+        {\n+            /* Rewrite:\n+             *  return exp;\n+             * as:\n+             *  vresult = exp; goto Lresult;\n+             */\n+            GotoStatement *gs = new GotoStatement(s->loc, Id::returnLabel);\n+            gs->label = fd->returnLabel;\n+\n+            Statement *s1 = gs;\n+            if (s->exp)\n+                s1 = new CompoundStatement(s->loc, new ExpStatement(s->loc, s->exp), gs);\n+\n+            replaceCurrent(s1);\n+        }\n+    }\n+    void visit(TryFinallyStatement *s)\n+    {\n+        DtorExpStatement *des;\n+        if (fd->nrvo_can &&\n+            s->finalbody && (des = s->finalbody->isDtorExpStatement()) != NULL &&\n+            fd->nrvo_var == des->var)\n+        {\n+            if (!(global.params.useExceptions && ClassDeclaration::throwable))\n+            {\n+                /* Don't need to call destructor at all, since it is nrvo\n+                 */\n+                replaceCurrent(s->_body);\n+                s->_body->accept(this);\n+                return;\n+            }\n+\n+            /* Normally local variable dtors are called regardless exceptions.\n+             * But for nrvo_var, its dtor should be called only when exception is thrown.\n+             *\n+             * Rewrite:\n+             *      try { s->body; } finally { nrvo_var->edtor; }\n+             *      // equivalent with:\n+             *      //    s->body; scope(exit) nrvo_var->edtor;\n+             * as:\n+             *      try { s->body; } catch(Throwable __o) { nrvo_var->edtor; throw __o; }\n+             *      // equivalent with:\n+             *      //    s->body; scope(failure) nrvo_var->edtor;\n+             */\n+            Statement *sexception = new DtorExpStatement(Loc(), fd->nrvo_var->edtor, fd->nrvo_var);\n+            Identifier *id = Identifier::generateId(\"__o\");\n+\n+            Statement *handler = new PeelStatement(sexception);\n+            if (blockExit(sexception, fd, false) & BEfallthru)\n+            {\n+                ThrowStatement *ts = new ThrowStatement(Loc(), new IdentifierExp(Loc(), id));\n+                ts->internalThrow = true;\n+                handler = new CompoundStatement(Loc(), handler, ts);\n+            }\n+\n+            Catches *catches = new Catches();\n+            Catch *ctch = new Catch(Loc(), getThrowable(), id, handler);\n+            ctch->internalCatch = true;\n+            catchSemantic(ctch, sc);     // Run semantic to resolve identifier '__o'\n+            catches->push(ctch);\n+\n+            Statement *s2 = new TryCatchStatement(Loc(), s->_body, catches);\n+            replaceCurrent(s2);\n+            s2->accept(this);\n+        }\n+        else\n+            StatementRewriteWalker::visit(s);\n+    }\n+};\n+\n+class Semantic3Visitor : public Visitor\n+{\n+public:\n+    Scope *sc;\n+\n+    Semantic3Visitor(Scope *sc)\n+    {\n+        this->sc = sc;\n+    }\n+\n+    void visit(Dsymbol *)\n+    {\n+        // Most Dsymbols have no further semantic analysis needed\n+    }\n+\n+    void visit(TemplateInstance *tempinst)\n+    {\n+        //if (tempinst->toChars()[0] == 'D') *(char*)0=0;\n+        if (tempinst->semanticRun >= PASSsemantic3)\n+            return;\n+        tempinst->semanticRun = PASSsemantic3;\n+        if (!tempinst->errors && tempinst->members)\n+        {\n+            TemplateDeclaration *tempdecl = tempinst->tempdecl->isTemplateDeclaration();\n+            assert(tempdecl);\n+\n+            sc = tempdecl->_scope;\n+            sc = sc->push(tempinst->argsym);\n+            sc = sc->push(tempinst);\n+            sc->tinst = tempinst;\n+            sc->minst = tempinst->minst;\n+\n+            int needGagging = (tempinst->gagged && !global.gag);\n+            unsigned int olderrors = global.errors;\n+            int oldGaggedErrors = -1;       // dead-store to prevent spurious warning\n+            /* If this is a gagged instantiation, gag errors.\n+             * Future optimisation: If the results are actually needed, errors\n+             * would already be gagged, so we don't really need to run semantic\n+             * on the members.\n+             */\n+            if (needGagging)\n+                oldGaggedErrors = global.startGagging();\n+\n+            for (size_t i = 0; i < tempinst->members->length; i++)\n+            {\n+                Dsymbol *s = (*tempinst->members)[i];\n+                semantic3(s, sc);\n+                if (tempinst->gagged && global.errors != olderrors)\n+                    break;\n+            }\n+\n+            if (global.errors != olderrors)\n+            {\n+                if (!tempinst->errors)\n+                {\n+                    if (!tempdecl->literal)\n+                        tempinst->error(tempinst->loc, \"error instantiating\");\n+                    if (tempinst->tinst)\n+                        tempinst->tinst->printInstantiationTrace();\n+                }\n+                tempinst->errors = true;\n+            }\n+            if (needGagging)\n+                global.endGagging(oldGaggedErrors);\n+\n+            sc = sc->pop();\n+            sc->pop();\n+        }\n+    }\n+\n+    void visit(TemplateMixin *tmix)\n+    {\n+        if (tmix->semanticRun >= PASSsemantic3)\n+            return;\n+        tmix->semanticRun = PASSsemantic3;\n+        if (tmix->members)\n+        {\n+            sc = sc->push(tmix->argsym);\n+            sc = sc->push(tmix);\n+            for (size_t i = 0; i < tmix->members->length; i++)\n+            {\n+                Dsymbol *s = (*tmix->members)[i];\n+                semantic3(s, sc);\n+            }\n+            sc = sc->pop();\n+            sc->pop();\n+        }\n+    }\n+\n+    void visit(Module *mod)\n+    {\n+        //printf(\"Module::semantic3('%s'): parent = %p\\n\", mod->toChars(), mod->parent);\n+        if (mod->semanticRun != PASSsemantic2done)\n+            return;\n+        mod->semanticRun = PASSsemantic3;\n+\n+        // Note that modules get their own scope, from scratch.\n+        // This is so regardless of where in the syntax a module\n+        // gets imported, it is unaffected by context.\n+        Scope *sc = Scope::createGlobal(mod);      // create root scope\n+        //printf(\"Module = %p\\n\", sc.scopesym);\n+\n+        // Pass 3 semantic routines: do initializers and function bodies\n+        for (size_t i = 0; i < mod->members->length; i++)\n+        {\n+            Dsymbol *s = (*mod->members)[i];\n+            //printf(\"Module %s: %s.semantic3()\\n\", mod->toChars(), s->toChars());\n+            semantic3(s, sc);\n+\n+            mod->runDeferredSemantic2();\n+        }\n+\n+        if (mod->userAttribDecl)\n+        {\n+            semantic3(mod->userAttribDecl, sc);\n+        }\n+\n+        sc = sc->pop();\n+        sc->pop();\n+        mod->semanticRun = PASSsemantic3done;\n+    }\n+\n+    void visit(FuncDeclaration *funcdecl)\n+    {\n+        VarDeclaration *_arguments = NULL;\n+\n+        if (!funcdecl->parent)\n+        {\n+            if (global.errors)\n+                return;\n+            //printf(\"FuncDeclaration::semantic3(%s '%s', sc = %p)\\n\", funcdecl->kind(), funcdecl->toChars(), sc);\n+            assert(0);\n+        }\n+        if (funcdecl->errors || isError(funcdecl->parent))\n+        {\n+            funcdecl->errors = true;\n+            return;\n+        }\n+        //printf(\"FuncDeclaration::semantic3('%s.%s', %p, sc = %p, loc = %s)\\n\", funcdecl->parent->toChars(), funcdecl->toChars(), funcdecl, sc, funcdecl->loc.toChars());\n+        //fflush(stdout);\n+        //printf(\"storage class = x%x %x\\n\", sc->stc, funcdecl->storage_class);\n+        //{ static int x; if (++x == 2) *(char*)0=0; }\n+        //printf(\"\\tlinkage = %d\\n\", sc->linkage);\n+\n+        if (funcdecl->ident == Id::assign && !funcdecl->inuse)\n+        {\n+            if (funcdecl->storage_class & STCinference)\n+            {\n+                /* Bugzilla 15044: For generated opAssign function, any errors\n+                 * from its body need to be gagged.\n+                 */\n+                unsigned oldErrors = global.startGagging();\n+                funcdecl->inuse++;\n+                semantic3(funcdecl, sc);\n+                funcdecl->inuse--;\n+                if (global.endGagging(oldErrors))   // if errors happened\n+                {\n+                    // Disable generated opAssign, because some members forbid identity assignment.\n+                    funcdecl->storage_class |= STCdisable;\n+                    funcdecl->fbody = NULL;   // remove fbody which contains the error\n+                    funcdecl->semantic3Errors = false;\n+                }\n+                return;\n+            }\n+        }\n+\n+        //printf(\" sc->incontract = %d\\n\", (sc->flags & SCOPEcontract));\n+        if (funcdecl->semanticRun >= PASSsemantic3)\n+            return;\n+        funcdecl->semanticRun = PASSsemantic3;\n+        funcdecl->semantic3Errors = false;\n+\n+        if (!funcdecl->type || funcdecl->type->ty != Tfunction)\n+            return;\n+        TypeFunction *f = (TypeFunction *)funcdecl->type;\n+        if (!funcdecl->inferRetType && f->next->ty == Terror)\n+            return;\n+\n+        if (!funcdecl->fbody && funcdecl->inferRetType && !f->next)\n+        {\n+            funcdecl->error(\"has no function body with return type inference\");\n+            return;\n+        }\n+\n+        unsigned oldErrors = global.errors;\n+\n+        if (funcdecl->frequires)\n+        {\n+            for (size_t i = 0; i < funcdecl->foverrides.length; i++)\n+            {\n+                FuncDeclaration *fdv = funcdecl->foverrides[i];\n+\n+                if (fdv->fbody && !fdv->frequires)\n+                {\n+                    funcdecl->error(\"cannot have an in contract when overriden function %s does not have an in contract\", fdv->toPrettyChars());\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // Remember whether we need to generate an 'out' contract.\n+        const bool needEnsure = FuncDeclaration::needsFensure(funcdecl);\n+\n+        if (funcdecl->fbody || funcdecl->frequires || needEnsure)\n+        {\n+            /* Symbol table into which we place parameters and nested functions,\n+             * solely to diagnose name collisions.\n+             */\n+            funcdecl->localsymtab = new DsymbolTable();\n+\n+            // Establish function scope\n+            ScopeDsymbol *ss = new ScopeDsymbol();\n+            // find enclosing scope symbol, might skip symbol-less CTFE and/or FuncExp scopes\n+            for (Scope *scx = sc; ; scx = scx->enclosing)\n+            {\n+                if (scx->scopesym)\n+                {\n+                    ss->parent = scx->scopesym;\n+                    break;\n+                }\n+            }\n+            ss->loc = funcdecl->loc;\n+            ss->endlinnum = funcdecl->endloc.linnum;\n+            Scope *sc2 = sc->push(ss);\n+            sc2->func = funcdecl;\n+            sc2->parent = funcdecl;\n+            sc2->callSuper = 0;\n+            sc2->sbreak = NULL;\n+            sc2->scontinue = NULL;\n+            sc2->sw = NULL;\n+            sc2->fes = funcdecl->fes;\n+            sc2->linkage = LINKd;\n+            sc2->stc &= ~(STCauto | STCscope | STCstatic | STCextern | STCabstract |\n+                          STCdeprecated | STCoverride |\n+                          STC_TYPECTOR | STCfinal | STCtls | STCgshared | STCref | STCreturn |\n+                          STCproperty | STCnothrow | STCpure | STCsafe | STCtrusted | STCsystem);\n+            sc2->protection = Prot(Prot::public_);\n+            sc2->explicitProtection = 0;\n+            sc2->aligndecl = NULL;\n+            if (funcdecl->ident != Id::require && funcdecl->ident != Id::ensure)\n+                sc2->flags = sc->flags & ~SCOPEcontract;\n+            sc2->flags &= ~SCOPEcompile;\n+            sc2->tf = NULL;\n+            sc2->os = NULL;\n+            sc2->noctor = 0;\n+            sc2->userAttribDecl = NULL;\n+            if (sc2->intypeof == 1) sc2->intypeof = 2;\n+            sc2->fieldinit = NULL;\n+            sc2->fieldinit_dim = 0;\n+\n+            /* Note: When a lambda is defined immediately under aggregate member\n+             * scope, it should be contextless due to prevent interior pointers.\n+             * e.g.\n+             *      // dg points 'this' - it's interior pointer\n+             *      class C { int x; void delegate() dg = (){ this.x = 1; }; }\n+             *\n+             * However, lambdas could be used inside typeof, in order to check\n+             * some expressions varidity at compile time. For such case the lambda\n+             * body can access aggregate instance members.\n+             * e.g.\n+             *      class C { int x; static assert(is(typeof({ this.x = 1; }))); }\n+             *\n+             * To properly accept it, mark these lambdas as member functions.\n+             */\n+            if (FuncLiteralDeclaration *fld = funcdecl->isFuncLiteralDeclaration())\n+            {\n+                if (AggregateDeclaration *ad = funcdecl->isMember2())\n+                {\n+                    if (!sc->intypeof)\n+                    {\n+                        if (fld->tok == TOKdelegate)\n+                            funcdecl->error(\"cannot be %s members\", ad->kind());\n+                        else\n+                            fld->tok = TOKfunction;\n+                    }\n+                    else\n+                    {\n+                        if (fld->tok != TOKfunction)\n+                            fld->tok = TOKdelegate;\n+                    }\n+                }\n+            }\n+\n+            // Declare 'this'\n+            AggregateDeclaration *ad = funcdecl->isThis();\n+            funcdecl->vthis = funcdecl->declareThis(sc2, ad);\n+            //printf(\"[%s] ad = %p vthis = %p\\n\", funcdecl->loc.toChars(), ad, funcdecl->vthis);\n+            //if (funcdecl->vthis) printf(\"\\tvthis->type = %s\\n\", funcdecl->vthis->type->toChars());\n+\n+            // Declare hidden variable _arguments[] and _argptr\n+            if (f->parameterList.varargs == VARARGvariadic)\n+            {\n+                if (f->linkage == LINKd)\n+                {\n+                    // Variadic arguments depend on Typeinfo being defined\n+                    if (!global.params.useTypeInfo || !Type::dtypeinfo || !Type::typeinfotypelist)\n+                    {\n+                        if (!global.params.useTypeInfo)\n+                            funcdecl->error(\"D-style variadic functions cannot be used with -betterC\");\n+                        else if (!Type::typeinfotypelist)\n+                            funcdecl->error(\"`object.TypeInfo_Tuple` could not be found, but is implicitly used in D-style variadic functions\");\n+                        else\n+                            funcdecl->error(\"`object.TypeInfo` could not be found, but is implicitly used in D-style variadic functions\");\n+                        fatal();\n+                    }\n+\n+                    // Declare _arguments[]\n+                    funcdecl->v_arguments = new VarDeclaration(Loc(), Type::typeinfotypelist->type, Id::_arguments_typeinfo, NULL);\n+                    funcdecl->v_arguments->storage_class |= STCtemp | STCparameter;\n+                    dsymbolSemantic(funcdecl->v_arguments, sc2);\n+                    sc2->insert(funcdecl->v_arguments);\n+                    funcdecl->v_arguments->parent = funcdecl;\n+\n+                    //Type *t = Type::typeinfo->type->constOf()->arrayOf();\n+                    Type *t = Type::dtypeinfo->type->arrayOf();\n+                    _arguments = new VarDeclaration(Loc(), t, Id::_arguments, NULL);\n+                    _arguments->storage_class |= STCtemp;\n+                    dsymbolSemantic(_arguments, sc2);\n+                    sc2->insert(_arguments);\n+                    _arguments->parent = funcdecl;\n+                }\n+                if (f->linkage == LINKd || f->parameterList.length())\n+                {\n+                    // Declare _argptr\n+                    Type *t = target.va_listType(funcdecl->loc, sc);\n+                    funcdecl->v_argptr = new VarDeclaration(Loc(), t, Id::_argptr, NULL);\n+                    funcdecl->v_argptr->storage_class |= STCtemp;\n+                    dsymbolSemantic(funcdecl->v_argptr, sc2);\n+                    sc2->insert(funcdecl->v_argptr);\n+                    funcdecl->v_argptr->parent = funcdecl;\n+                }\n+            }\n+\n+            /* Declare all the function parameters as variables\n+             * and install them in parameters[]\n+             */\n+            size_t nparams = f->parameterList.length();\n+            if (nparams)\n+            {\n+                /* parameters[] has all the tuples removed, as the back end\n+                 * doesn't know about tuples\n+                 */\n+                funcdecl->parameters = new VarDeclarations();\n+                funcdecl->parameters->reserve(nparams);\n+                for (size_t i = 0; i < nparams; i++)\n+                {\n+                    Parameter *fparam = f->parameterList[i];\n+                    Identifier *id = fparam->ident;\n+                    StorageClass stc = 0;\n+                    if (!id)\n+                    {\n+                        /* Generate identifier for un-named parameter,\n+                         * because we need it later on.\n+                         */\n+                        fparam->ident = id = Identifier::generateId(\"_param_\", i);\n+                        stc |= STCtemp;\n+                    }\n+                    Type *vtype = fparam->type;\n+                    VarDeclaration *v = new VarDeclaration(funcdecl->loc, vtype, id, NULL);\n+                    //printf(\"declaring parameter %s of type %s\\n\", v->toChars(), v->type->toChars());\n+                    stc |= STCparameter;\n+                    if (f->parameterList.varargs == VARARGtypesafe && i + 1 == nparams)\n+                        stc |= STCvariadic;\n+                    if (funcdecl->flags & FUNCFLAGinferScope && !(fparam->storageClass & STCscope))\n+                        stc |= STCmaybescope;\n+                    stc |= fparam->storageClass & (STCin | STCout | STCref | STCreturn | STCscope | STClazy | STCfinal | STC_TYPECTOR | STCnodtor);\n+                    v->storage_class = stc;\n+                    dsymbolSemantic(v, sc2);\n+                    if (!sc2->insert(v))\n+                        funcdecl->error(\"parameter %s.%s is already defined\", funcdecl->toChars(), v->toChars());\n+                    else\n+                        funcdecl->parameters->push(v);\n+                    funcdecl->localsymtab->insert(v);\n+                    v->parent = funcdecl;\n+                    if (fparam->userAttribDecl)\n+                        v->userAttribDecl = fparam->userAttribDecl;\n+                }\n+            }\n+\n+            // Declare the tuple symbols and put them in the symbol table,\n+            // but not in parameters[].\n+            if (f->parameterList.parameters)\n+            {\n+                for (size_t i = 0; i < f->parameterList.parameters->length; i++)\n+                {\n+                    Parameter *fparam = (*f->parameterList.parameters)[i];\n+\n+                    if (!fparam->ident)\n+                        continue;                   // never used, so ignore\n+                    if (fparam->type->ty == Ttuple)\n+                    {\n+                        TypeTuple *t = (TypeTuple *)fparam->type;\n+                        size_t dim = Parameter::dim(t->arguments);\n+                        Objects *exps = new Objects();\n+                        exps->setDim(dim);\n+                        for (size_t j = 0; j < dim; j++)\n+                        {\n+                            Parameter *narg = Parameter::getNth(t->arguments, j);\n+                            assert(narg->ident);\n+                            VarDeclaration *v = sc2->search(Loc(), narg->ident, NULL)->isVarDeclaration();\n+                            assert(v);\n+                            Expression *e = new VarExp(v->loc, v);\n+                            (*exps)[j] = e;\n+                        }\n+                        assert(fparam->ident);\n+                        TupleDeclaration *v = new TupleDeclaration(funcdecl->loc, fparam->ident, exps);\n+                        //printf(\"declaring tuple %s\\n\", v->toChars());\n+                        v->isexp = true;\n+                        if (!sc2->insert(v))\n+                            funcdecl->error(\"parameter %s.%s is already defined\", funcdecl->toChars(), v->toChars());\n+                        funcdecl->localsymtab->insert(v);\n+                        v->parent = funcdecl;\n+                    }\n+                }\n+            }\n+\n+            // Precondition invariant\n+            Statement *fpreinv = NULL;\n+            if (funcdecl->addPreInvariant())\n+            {\n+                Expression *e = addInvariant(ad, funcdecl->vthis);\n+                if (e)\n+                    fpreinv = new ExpStatement(Loc(), e);\n+            }\n+\n+            // Postcondition invariant\n+            Statement *fpostinv = NULL;\n+            if (funcdecl->addPostInvariant())\n+            {\n+                Expression *e = addInvariant(ad, funcdecl->vthis);\n+                if (e)\n+                    fpostinv = new ExpStatement(Loc(), e);\n+            }\n+\n+            // Pre/Postcondition contract\n+            if (!funcdecl->fbody)\n+                funcdecl->buildEnsureRequire();\n+\n+            Scope *scout = NULL;\n+            if (needEnsure || funcdecl->addPostInvariant())\n+            {\n+                if ((needEnsure && global.params.useOut == CHECKENABLEon) || fpostinv)\n+                {\n+                    funcdecl->returnLabel = new LabelDsymbol(Id::returnLabel);\n+                }\n+\n+                // scope of out contract (need for vresult->semantic)\n+                ScopeDsymbol *sym = new ScopeDsymbol();\n+                sym->parent = sc2->scopesym;\n+                sym->loc = funcdecl->loc;\n+                sym->endlinnum = funcdecl->endloc.linnum;\n+                scout = sc2->push(sym);\n+            }\n+\n+            if (funcdecl->fbody)\n+            {\n+                ScopeDsymbol *sym = new ScopeDsymbol();\n+                sym->parent = sc2->scopesym;\n+                sym->loc = funcdecl->loc;\n+                sym->endlinnum = funcdecl->endloc.linnum;\n+                sc2 = sc2->push(sym);\n+\n+                AggregateDeclaration *ad2 = funcdecl->isMember2();\n+\n+                /* If this is a class constructor\n+                */\n+                if (ad2 && funcdecl->isCtorDeclaration())\n+                {\n+                    allocFieldinit(sc2, ad2->fields.length);\n+                    for (size_t i = 0; i < ad2->fields.length; i++)\n+                    {\n+                        VarDeclaration *v = ad2->fields[i];\n+                        v->ctorinit = 0;\n+                    }\n+                }\n+\n+                bool inferRef = (f->isref && (funcdecl->storage_class & STCauto));\n+\n+                funcdecl->fbody = statementSemantic(funcdecl->fbody, sc2);\n+                if (!funcdecl->fbody)\n+                    funcdecl->fbody = new CompoundStatement(Loc(), new Statements());\n+\n+                if (funcdecl->naked)\n+                {\n+                    fpreinv = NULL;         // can't accommodate with no stack frame\n+                    fpostinv = NULL;\n+                }\n+\n+                assert(funcdecl->type == f ||\n+                       (funcdecl->type->ty == Tfunction &&\n+                        f->purity == PUREimpure &&\n+                        ((TypeFunction *)funcdecl->type)->purity >= PUREfwdref));\n+                f = (TypeFunction *)funcdecl->type;\n+\n+                if (funcdecl->inferRetType)\n+                {\n+                    // If no return type inferred yet, then infer a void\n+                    if (!f->next)\n+                        f->next = Type::tvoid;\n+                    if (f->checkRetType(funcdecl->loc))\n+                        funcdecl->fbody = new ErrorStatement();\n+                }\n+                if (global.params.vcomplex && f->next != NULL)\n+                    f->next->checkComplexTransition(funcdecl->loc);\n+\n+                if (funcdecl->returns && !funcdecl->fbody->isErrorStatement())\n+                {\n+                    for (size_t i = 0; i < funcdecl->returns->length; )\n+                    {\n+                        Expression *exp = (*funcdecl->returns)[i]->exp;\n+                        if (exp->op == TOKvar && ((VarExp *)exp)->var == funcdecl->vresult)\n+                        {\n+                            if (addReturn0(funcdecl))\n+                                exp->type = Type::tint32;\n+                            else\n+                                exp->type = f->next;\n+                            // Remove `return vresult;` from returns\n+                            funcdecl->returns->remove(i);\n+                            continue;\n+                        }\n+                        if (inferRef && f->isref && !exp->type->constConv(f->next))     // Bugzilla 13336\n+                            f->isref = false;\n+                        i++;\n+                    }\n+                }\n+                if (f->isref)   // Function returns a reference\n+                {\n+                    if (funcdecl->storage_class & STCauto)\n+                        funcdecl->storage_class &= ~STCauto;\n+                }\n+                if (!target.isReturnOnStack(f, funcdecl->needThis()) || !funcdecl->checkNRVO())\n+                    funcdecl->nrvo_can = 0;\n+\n+                if (funcdecl->fbody->isErrorStatement())\n+                    ;\n+                else if (funcdecl->isStaticCtorDeclaration())\n+                {\n+                    /* It's a static constructor. Ensure that all\n+                     * ctor consts were initialized.\n+                     */\n+                    ScopeDsymbol *pd = funcdecl->toParent()->isScopeDsymbol();\n+                    for (size_t i = 0; i < pd->members->length; i++)\n+                    {\n+                        Dsymbol *s = (*pd->members)[i];\n+                        s->checkCtorConstInit();\n+                    }\n+                }\n+                else if (ad2 && funcdecl->isCtorDeclaration())\n+                {\n+                    ClassDeclaration *cd = ad2->isClassDeclaration();\n+\n+                    // Verify that all the ctorinit fields got initialized\n+                    if (!(sc2->callSuper & CSXthis_ctor))\n+                    {\n+                        for (size_t i = 0; i < ad2->fields.length; i++)\n+                        {\n+                            VarDeclaration *v = ad2->fields[i];\n+                            if (v->isThisDeclaration())\n+                                continue;\n+                            if (v->ctorinit == 0)\n+                            {\n+                                /* Current bugs in the flow analysis:\n+                                 * 1. union members should not produce error messages even if\n+                                 *    not assigned to\n+                                 * 2. structs should recognize delegating opAssign calls as well\n+                                 *    as delegating calls to other constructors\n+                                 */\n+                                if (v->isCtorinit() && !v->type->isMutable() && cd)\n+                                    funcdecl->error(\"missing initializer for %s field %s\", MODtoChars(v->type->mod), v->toChars());\n+                                else if (v->storage_class & STCnodefaultctor)\n+                                    error(funcdecl->loc, \"field %s must be initialized in constructor\", v->toChars());\n+                                else if (v->type->needsNested())\n+                                    error(funcdecl->loc, \"field %s must be initialized in constructor, because it is nested struct\", v->toChars());\n+                            }\n+                            else\n+                            {\n+                                bool mustInit = (v->storage_class & STCnodefaultctor ||\n+                                                 v->type->needsNested());\n+                                if (mustInit && !(sc2->fieldinit[i] & CSXthis_ctor))\n+                                {\n+                                    funcdecl->error(\"field %s must be initialized but skipped\", v->toChars());\n+                                }\n+                            }\n+                        }\n+                    }\n+                    freeFieldinit(sc2);\n+\n+                    if (cd &&\n+                        !(sc2->callSuper & CSXany_ctor) &&\n+                        cd->baseClass && cd->baseClass->ctor)\n+                    {\n+                        sc2->callSuper = 0;\n+\n+                        // Insert implicit super() at start of fbody\n+                        FuncDeclaration *fd = resolveFuncCall(Loc(), sc2, cd->baseClass->ctor, NULL, funcdecl->vthis->type, NULL, 1);\n+                        if (!fd)\n+                        {\n+                            funcdecl->error(\"no match for implicit super() call in constructor\");\n+                        }\n+                        else if (fd->storage_class & STCdisable)\n+                        {\n+                            funcdecl->error(\"cannot call super() implicitly because it is annotated with @disable\");\n+                        }\n+                        else\n+                        {\n+                            Expression *e1 = new SuperExp(Loc());\n+                            Expression *e = new CallExp(Loc(), e1);\n+                            e = expressionSemantic(e, sc2);\n+\n+                            Statement *s = new ExpStatement(Loc(), e);\n+                            funcdecl->fbody = new CompoundStatement(Loc(), s, funcdecl->fbody);\n+                        }\n+                    }\n+                    //printf(\"callSuper = x%x\\n\", sc2->callSuper);\n+                }\n+\n+                /* https://issues.dlang.org/show_bug.cgi?id=17502\n+                 * Wait until after the return type has been inferred before\n+                 * generating the contracts for this function, and merging contracts\n+                 * from overrides.\n+                 *\n+                 * https://issues.dlang.org/show_bug.cgi?id=17893\n+                 * However should take care to generate this before inferered\n+                 * function attributes are applied, such as 'nothrow'.\n+                 *\n+                 * This was originally at the end of the first semantic pass, but\n+                 * required a fix-up to be done here for the '__result' variable\n+                 * type of __ensure() inside auto functions, but this didn't work\n+                 * if the out parameter was implicit.\n+                 */\n+                funcdecl->buildEnsureRequire();\n+\n+                int blockexit = BEnone;\n+                if (!funcdecl->fbody->isErrorStatement())\n+                {\n+                    // Check for errors related to 'nothrow'.\n+                    unsigned int nothrowErrors = global.errors;\n+                    blockexit = blockExit(funcdecl->fbody, funcdecl, f->isnothrow);\n+                    if (f->isnothrow && (global.errors != nothrowErrors))\n+                        error(funcdecl->loc, \"nothrow %s `%s` may throw\", funcdecl->kind(), funcdecl->toPrettyChars());\n+                    if (funcdecl->flags & FUNCFLAGnothrowInprocess)\n+                    {\n+                        if (funcdecl->type == f) f = (TypeFunction *)f->copy();\n+                        f->isnothrow = !(blockexit & BEthrow);\n+                    }\n+                }\n+\n+                if (funcdecl->fbody->isErrorStatement())\n+                    ;\n+                else if (ad2 && funcdecl->isCtorDeclaration())\n+                {\n+                    /* Append:\n+                     *  return this;\n+                     * to function body\n+                     */\n+                    if (blockexit & BEfallthru)\n+                    {\n+                        Statement *s = new ReturnStatement(funcdecl->loc, NULL);\n+                        s = statementSemantic(s, sc2);\n+                        funcdecl->fbody = new CompoundStatement(funcdecl->loc, funcdecl->fbody, s);\n+                        funcdecl->hasReturnExp |= (funcdecl->hasReturnExp & 1 ? 16 : 1);\n+                    }\n+                }\n+                else if (funcdecl->fes)\n+                {\n+                    // For foreach(){} body, append a return 0;\n+                    if (blockexit & BEfallthru)\n+                    {\n+                        Expression *e = new IntegerExp(0);\n+                        Statement *s = new ReturnStatement(Loc(), e);\n+                        funcdecl->fbody = new CompoundStatement(Loc(), funcdecl->fbody, s);\n+                        funcdecl->hasReturnExp |= (funcdecl->hasReturnExp & 1 ? 16 : 1);\n+                    }\n+                    assert(!funcdecl->returnLabel);\n+                }\n+                else\n+                {\n+                    const bool inlineAsm = (funcdecl->hasReturnExp & 8) != 0;\n+                    if ((blockexit & BEfallthru) && f->next->ty != Tvoid && !inlineAsm)\n+                    {\n+                        Expression *e;\n+                        if (!funcdecl->hasReturnExp)\n+                            funcdecl->error(\"has no return statement, but is expected to return a value of type %s\", f->next->toChars());\n+                        else\n+                            funcdecl->error(\"no return exp; or assert(0); at end of function\");\n+                        if (global.params.useAssert == CHECKENABLEon &&\n+                            !global.params.useInline)\n+                        {\n+                            /* Add an assert(0, msg); where the missing return\n+                             * should be.\n+                             */\n+                            e = new AssertExp(funcdecl->endloc,\n+                                              new IntegerExp(0),\n+                                              new StringExp(funcdecl->loc, const_cast<char *>(\"missing return expression\")));\n+                        }\n+                        else\n+                            e = new HaltExp(funcdecl->endloc);\n+                        e = new CommaExp(Loc(), e, f->next->defaultInit());\n+                        e = expressionSemantic(e, sc2);\n+                        Statement *s = new ExpStatement(Loc(), e);\n+                        funcdecl->fbody = new CompoundStatement(Loc(), funcdecl->fbody, s);\n+                    }\n+                }\n+\n+                if (funcdecl->returns)\n+                {\n+                    bool implicit0 = addReturn0(funcdecl);\n+                    Type *tret = implicit0 ? Type::tint32 : f->next;\n+                    assert(tret->ty != Tvoid);\n+                    if (funcdecl->vresult || funcdecl->returnLabel)\n+                        funcdecl->buildResultVar(scout ? scout : sc2, tret);\n+\n+                    /* Cannot move this loop into NrvoWalker, because\n+                     * returns[i] may be in the nested delegate for foreach-body.\n+                     */\n+                    for (size_t i = 0; i < funcdecl->returns->length; i++)\n+                    {\n+                        ReturnStatement *rs = (*funcdecl->returns)[i];\n+                        Expression *exp = rs->exp;\n+                        if (exp->op == TOKerror)\n+                            continue;\n+                        if (tret->ty == Terror)\n+                        {\n+                            // Bugzilla 13702\n+                            exp = checkGC(sc2, exp);\n+                            continue;\n+                        }\n+\n+                        if (!exp->implicitConvTo(tret) &&\n+                            funcdecl->parametersIntersect(exp->type))\n+                        {\n+                            if (exp->type->immutableOf()->implicitConvTo(tret))\n+                                exp = exp->castTo(sc2, exp->type->immutableOf());\n+                            else if (exp->type->wildOf()->implicitConvTo(tret))\n+                                exp = exp->castTo(sc2, exp->type->wildOf());\n+                        }\n+                        exp = exp->implicitCastTo(sc2, tret);\n+\n+                        if (f->isref)\n+                        {\n+                            // Function returns a reference\n+                            exp = exp->toLvalue(sc2, exp);\n+                            checkReturnEscapeRef(sc2, exp, false);\n+                        }\n+                        else\n+                        {\n+                            exp = exp->optimize(WANTvalue);\n+\n+                            /* Bugzilla 10789:\n+                             * If NRVO is not possible, all returned lvalues should call their postblits.\n+                             */\n+                            if (!funcdecl->nrvo_can)\n+                                exp = doCopyOrMove(sc2, exp);\n+\n+                            if (tret->hasPointers())\n+                                checkReturnEscape(sc2, exp, false);\n+                        }\n+\n+                        exp = checkGC(sc2, exp);\n+\n+                        if (funcdecl->vresult)\n+                        {\n+                            // Create: return vresult = exp;\n+                            exp = new BlitExp(rs->loc, funcdecl->vresult, exp);\n+                            exp->type = funcdecl->vresult->type;\n+\n+                            if (rs->caseDim)\n+                                exp = Expression::combine(exp, new IntegerExp(rs->caseDim));\n+                        }\n+                        else if (funcdecl->tintro && !tret->equals(funcdecl->tintro->nextOf()))\n+                        {\n+                            exp = exp->implicitCastTo(sc2, funcdecl->tintro->nextOf());\n+                        }\n+                        rs->exp = exp;\n+                    }\n+                }\n+                if (funcdecl->nrvo_var || funcdecl->returnLabel)\n+                {\n+                    NrvoWalker nw;\n+                    nw.fd = funcdecl;\n+                    nw.sc = sc2;\n+                    nw.visitStmt(funcdecl->fbody);\n+                }\n+\n+                sc2 = sc2->pop();\n+            }\n+\n+            funcdecl->frequire = funcdecl->mergeFrequire(funcdecl->frequire);\n+            funcdecl->fensure = funcdecl->mergeFensure(funcdecl->fensure, Id::result);\n+\n+            Statement *freq = funcdecl->frequire;\n+            Statement *fens = funcdecl->fensure;\n+\n+            /* Do the semantic analysis on the [in] preconditions and\n+             * [out] postconditions.\n+             */\n+            if (freq)\n+            {\n+                /* frequire is composed of the [in] contracts\n+                */\n+                ScopeDsymbol *sym = new ScopeDsymbol();\n+                sym->parent = sc2->scopesym;\n+                sym->loc = funcdecl->loc;\n+                sym->endlinnum = funcdecl->endloc.linnum;\n+                sc2 = sc2->push(sym);\n+                sc2->flags = (sc2->flags & ~SCOPEcontract) | SCOPErequire;\n+\n+                // BUG: need to error if accessing out parameters\n+                // BUG: need to disallow returns and throws\n+                // BUG: verify that all in and ref parameters are read\n+                freq = statementSemantic(freq, sc2);\n+                blockExit(freq, funcdecl, false);\n+\n+                sc2 = sc2->pop();\n+\n+                if (global.params.useIn == CHECKENABLEoff)\n+                    freq = NULL;\n+            }\n+\n+            if (fens)\n+            {\n+                /* fensure is composed of the [out] contracts\n+                */\n+                if (f->next->ty == Tvoid && funcdecl->fensures)\n+                {\n+                    for (size_t i = 0; i < funcdecl->fensures->length; i++)\n+                    {\n+                        Ensure e = (*funcdecl->fensures)[i];\n+                        if (e.id)\n+                        {\n+                            funcdecl->error(e.ensure->loc, \"`void` functions have no result\");\n+                            //fens = NULL;\n+                        }\n+                    }\n+                }\n+\n+                sc2 = scout;    //push\n+                sc2->flags = (sc2->flags & ~SCOPEcontract) | SCOPEensure;\n+\n+                // BUG: need to disallow returns and throws\n+                if (funcdecl->fensure && f->next->ty != Tvoid)\n+                    funcdecl->buildResultVar(scout, f->next);\n+\n+                fens = statementSemantic(fens, sc2);\n+                blockExit(fens, funcdecl, false);\n+\n+                sc2 = sc2->pop();\n+\n+                if (global.params.useOut == CHECKENABLEoff)\n+                    fens = NULL;\n+            }\n+\n+            if (funcdecl->fbody && funcdecl->fbody->isErrorStatement())\n+                ;\n+            else\n+            {\n+                Statements *a = new Statements();\n+\n+                // Merge in initialization of 'out' parameters\n+                if (funcdecl->parameters)\n+                {\n+                    for (size_t i = 0; i < funcdecl->parameters->length; i++)\n+                    {\n+                        VarDeclaration *v = (*funcdecl->parameters)[i];\n+                        if (v->storage_class & STCout)\n+                        {\n+                            assert(v->_init);\n+                            ExpInitializer *ie = v->_init->isExpInitializer();\n+                            assert(ie);\n+                            if (ie->exp->op == TOKconstruct)\n+                                ie->exp->op = TOKassign; // construction occured in parameter processing\n+                            a->push(new ExpStatement(Loc(), ie->exp));\n+                        }\n+                    }\n+                }\n+\n+                if (funcdecl->v_argptr)\n+                {\n+                    // Handled in FuncDeclaration::toObjFile\n+                    funcdecl->v_argptr->_init = new VoidInitializer(funcdecl->loc);\n+                }\n+\n+                if (_arguments)\n+                {\n+                    /* Advance to elements[] member of TypeInfo_Tuple with:\n+                     *  _arguments = v_arguments.elements;\n+                     */\n+                    Expression *e = new VarExp(Loc(), funcdecl->v_arguments);\n+                    e = new DotIdExp(Loc(), e, Id::elements);\n+                    e = new ConstructExp(Loc(), _arguments, e);\n+                    e = expressionSemantic(e, sc2);\n+\n+                    _arguments->_init = new ExpInitializer(Loc(), e);\n+                    DeclarationExp *de = new DeclarationExp(Loc(), _arguments);\n+                    a->push(new ExpStatement(Loc(), de));\n+                }\n+\n+                // Merge contracts together with body into one compound statement\n+\n+                if (freq || fpreinv)\n+                {\n+                    if (!freq)\n+                        freq = fpreinv;\n+                    else if (fpreinv)\n+                        freq = new CompoundStatement(Loc(), freq, fpreinv);\n+\n+                    a->push(freq);\n+                }\n+\n+                if (funcdecl->fbody)\n+                    a->push(funcdecl->fbody);\n+\n+                if (fens || fpostinv)\n+                {\n+                    if (!fens)\n+                        fens = fpostinv;\n+                    else if (fpostinv)\n+                        fens = new CompoundStatement(Loc(), fpostinv, fens);\n+\n+                    LabelStatement *ls = new LabelStatement(Loc(), Id::returnLabel, fens);\n+                    funcdecl->returnLabel->statement = ls;\n+                    a->push(funcdecl->returnLabel->statement);\n+\n+                    if (f->next->ty != Tvoid && funcdecl->vresult)\n+                    {\n+                        // Create: return vresult;\n+                        Expression *e = new VarExp(Loc(), funcdecl->vresult);\n+                        if (funcdecl->tintro)\n+                        {\n+                            e = e->implicitCastTo(sc, funcdecl->tintro->nextOf());\n+                            e = expressionSemantic(e, sc);\n+                        }\n+                        ReturnStatement *s = new ReturnStatement(Loc(), e);\n+                        a->push(s);\n+                    }\n+                }\n+                if (addReturn0(funcdecl))\n+                {\n+                    // Add a return 0; statement\n+                    Statement *s = new ReturnStatement(Loc(), new IntegerExp(0));\n+                    a->push(s);\n+                }\n+\n+                Statement *sbody = new CompoundStatement(Loc(), a);\n+                /* Append destructor calls for parameters as finally blocks.\n+                */\n+                if (funcdecl->parameters)\n+                {\n+                    for (size_t i = 0; i < funcdecl->parameters->length; i++)\n+                    {\n+                        VarDeclaration *v = (*funcdecl->parameters)[i];\n+\n+                        if (v->storage_class & (STCref | STCout | STClazy))\n+                            continue;\n+\n+                        if (v->needsScopeDtor())\n+                        {\n+                            // same with ExpStatement.scopeCode()\n+                            Statement *s = new DtorExpStatement(Loc(), v->edtor, v);\n+                            v->storage_class |= STCnodtor;\n+\n+                            s = statementSemantic(s, sc2);\n+\n+                            bool isnothrow = f->isnothrow & !(funcdecl->flags & FUNCFLAGnothrowInprocess);\n+                            int blockexit = blockExit(s, funcdecl, isnothrow);\n+                            if (f->isnothrow && isnothrow && blockexit & BEthrow)\n+                                error(funcdecl->loc, \"nothrow %s `%s` may throw\", funcdecl->kind(), funcdecl->toPrettyChars());\n+                            if (funcdecl->flags & FUNCFLAGnothrowInprocess && blockexit & BEthrow)\n+                                f->isnothrow = false;\n+                            if (blockExit(sbody, funcdecl, f->isnothrow) == BEfallthru)\n+                                sbody = new CompoundStatement(Loc(), sbody, s);\n+                            else\n+                                sbody = new TryFinallyStatement(Loc(), sbody, s);\n+                        }\n+                    }\n+                }\n+                // from this point on all possible 'throwers' are checked\n+                funcdecl->flags &= ~FUNCFLAGnothrowInprocess;\n+\n+                if (funcdecl->isSynchronized())\n+                {\n+                    /* Wrap the entire function body in a synchronized statement\n+                    */\n+                    ClassDeclaration *cd = funcdecl->isThis() ? funcdecl->isThis()->isClassDeclaration() : funcdecl->parent->isClassDeclaration();\n+\n+                    if (cd)\n+                    {\n+                        if (!global.params.is64bit &&\n+                            global.params.isWindows &&\n+                            !funcdecl->isStatic() && !sbody->usesEH() && !global.params.trace)\n+                        {\n+                            /* The back end uses the \"jmonitor\" hack for syncing;\n+                             * no need to do the sync at this level.\n+                             */\n+                        }\n+                        else\n+                        {\n+                            Expression *vsync;\n+                            if (funcdecl->isStatic())\n+                            {\n+                                // The monitor is in the ClassInfo\n+                                vsync = new DotIdExp(funcdecl->loc, resolve(funcdecl->loc, sc2, cd, false), Id::classinfo);\n+                            }\n+                            else\n+                            {\n+                                // 'this' is the monitor\n+                                vsync = new VarExp(funcdecl->loc, funcdecl->vthis);\n+                            }\n+                            sbody = new PeelStatement(sbody);       // don't redo semantic()\n+                            sbody = new SynchronizedStatement(funcdecl->loc, vsync, sbody);\n+                            sbody = statementSemantic(sbody, sc2);\n+                        }\n+                    }\n+                    else\n+                    {\n+                        funcdecl->error(\"synchronized function %s must be a member of a class\", funcdecl->toChars());\n+                    }\n+                }\n+\n+                // If declaration has no body, don't set sbody to prevent incorrect codegen.\n+                if (funcdecl->fbody || allowsContractWithoutBody(funcdecl))\n+                    funcdecl->fbody = sbody;\n+            }\n+\n+            // Fix up forward-referenced gotos\n+            if (funcdecl->gotos)\n+            {\n+                for (size_t i = 0; i < funcdecl->gotos->length; ++i)\n+                {\n+                    (*funcdecl->gotos)[i]->checkLabel();\n+                }\n+            }\n+\n+            if (funcdecl->naked && (funcdecl->fensures || funcdecl->frequires))\n+                funcdecl->error(\"naked assembly functions with contracts are not supported\");\n+\n+            sc2->callSuper = 0;\n+            sc2->pop();\n+        }\n+\n+        if (funcdecl->checkClosure())\n+        {\n+            // We should be setting errors here instead of relying on the global error count.\n+            //errors = true;\n+        }\n+\n+        /* If function survived being marked as impure, then it is pure\n+        */\n+        if (funcdecl->flags & FUNCFLAGpurityInprocess)\n+        {\n+            funcdecl->flags &= ~FUNCFLAGpurityInprocess;\n+            if (funcdecl->type == f)\n+                f = (TypeFunction *)f->copy();\n+            f->purity = PUREfwdref;\n+        }\n+\n+        if (funcdecl->flags & FUNCFLAGsafetyInprocess)\n+        {\n+            funcdecl->flags &= ~FUNCFLAGsafetyInprocess;\n+            if (funcdecl->type == f)\n+                f = (TypeFunction *)f->copy();\n+            f->trust = TRUSTsafe;\n+        }\n+\n+        if (funcdecl->flags & FUNCFLAGnogcInprocess)\n+        {\n+            funcdecl->flags &= ~FUNCFLAGnogcInprocess;\n+            if (funcdecl->type == f)\n+                f = (TypeFunction *)f->copy();\n+            f->isnogc = true;\n+        }\n+\n+        if (funcdecl->flags & FUNCFLAGreturnInprocess)\n+        {\n+            funcdecl->flags &= ~FUNCFLAGreturnInprocess;\n+            if (funcdecl->storage_class & STCreturn)\n+            {\n+                if (funcdecl->type == f)\n+                    f = (TypeFunction *)f->copy();\n+                f->isreturn = true;\n+            }\n+        }\n+\n+        funcdecl->flags &= ~FUNCFLAGinferScope;\n+\n+        // Infer STCscope\n+        if (funcdecl->parameters)\n+        {\n+            size_t nfparams = f->parameterList.length();\n+            assert(nfparams == funcdecl->parameters->length);\n+            for (size_t u = 0; u < funcdecl->parameters->length; u++)\n+            {\n+                VarDeclaration *v = (*funcdecl->parameters)[u];\n+                if (v->storage_class & STCmaybescope)\n+                {\n+                    //printf(\"Inferring scope for %s\\n\", v->toChars());\n+                    Parameter *p = f->parameterList[u];\n+                    v->storage_class &= ~STCmaybescope;\n+                    v->storage_class |= STCscope | STCscopeinferred;\n+                    p->storageClass |= STCscope | STCscopeinferred;\n+                    assert(!(p->storageClass & STCmaybescope));\n+                }\n+            }\n+        }\n+\n+        if (funcdecl->vthis && funcdecl->vthis->storage_class & STCmaybescope)\n+        {\n+            funcdecl->vthis->storage_class &= ~STCmaybescope;\n+            funcdecl->vthis->storage_class |= STCscope | STCscopeinferred;\n+            f->isscope = true;\n+            f->isscopeinferred = true;\n+        }\n+\n+        // reset deco to apply inference result to mangled name\n+        if (f != funcdecl->type)\n+            f->deco = NULL;\n+\n+        // Do semantic type AFTER pure/nothrow inference.\n+        if (!f->deco && funcdecl->ident != Id::xopEquals && funcdecl->ident != Id::xopCmp)\n+        {\n+            sc = sc->push();\n+            if (funcdecl->isCtorDeclaration()) // Bugzilla #15665\n+                sc->flags |= SCOPEctor;\n+            sc->stc = 0;\n+            sc->linkage = funcdecl->linkage;  // Bugzilla 8496\n+            funcdecl->type = typeSemantic(f, funcdecl->loc, sc);\n+            sc = sc->pop();\n+        }\n+\n+        /* If this function had instantiated with gagging, error reproduction will be\n+         * done by TemplateInstance::semantic.\n+         * Otherwise, error gagging should be temporarily ungagged by functionSemantic3.\n+         */\n+        funcdecl->semanticRun = PASSsemantic3done;\n+        funcdecl->semantic3Errors = (global.errors != oldErrors) || (funcdecl->fbody && funcdecl->fbody->isErrorStatement());\n+        if (funcdecl->type->ty == Terror)\n+            funcdecl->errors = true;\n+        //printf(\"-FuncDeclaration::semantic3('%s.%s', sc = %p, loc = %s)\\n\", funcdecl->parent->toChars(), funcdecl->toChars(), sc, funcdecl->loc.toChars());\n+        //fflush(stdout);\n+    }\n+\n+    void visit(Nspace *ns)\n+    {\n+        if (ns->semanticRun >= PASSsemantic3)\n+            return;\n+        ns->semanticRun = PASSsemantic3;\n+        if (ns->members)\n+        {\n+            sc = sc->push(ns);\n+            sc->linkage = LINKcpp;\n+            for (size_t i = 0; i < ns->members->length; i++)\n+            {\n+                Dsymbol *s = (*ns->members)[i];\n+                semantic3(s, sc);\n+            }\n+            sc->pop();\n+        }\n+    }\n+\n+    void visit(AttribDeclaration *ad)\n+    {\n+        Dsymbols *d = ad->include(sc);\n+\n+        if (d)\n+        {\n+            Scope *sc2 = ad->newScope(sc);\n+\n+            for (size_t i = 0; i < d->length; i++)\n+            {\n+                Dsymbol *s = (*d)[i];\n+                semantic3(s, sc2);\n+            }\n+\n+            if (sc2 != sc)\n+                sc2->pop();\n+        }\n+    }\n+\n+    void visit(AggregateDeclaration *ad)\n+    {\n+        //printf(\"AggregateDeclaration::semantic3(%s) type = %s, errors = %d\\n\", ad->toChars(), ad->type->toChars(), ad->errors);\n+        if (!ad->members)\n+            return;\n+\n+        StructDeclaration *sd = ad->isStructDeclaration();\n+        if (!sc)    // from runDeferredSemantic3 for TypeInfo generation\n+        {\n+            assert(sd);\n+            sd->semanticTypeInfoMembers();\n+            return;\n+        }\n+\n+        Scope *sc2 = ad->newScope(sc);\n+\n+        for (size_t i = 0; i < ad->members->length; i++)\n+        {\n+            Dsymbol *s = (*ad->members)[i];\n+            semantic3(s, sc2);\n+        }\n+\n+        sc2->pop();\n+\n+        // don't do it for unused deprecated types\n+        // or error types\n+        if (!ad->getRTInfo && Type::rtinfo &&\n+            (!ad->isDeprecated() || global.params.useDeprecated != DIAGNOSTICerror) &&\n+            (ad->type && ad->type->ty != Terror))\n+        {\n+            // Evaluate: RTinfo!type\n+            Objects *tiargs = new Objects();\n+            tiargs->push(ad->type);\n+            TemplateInstance *ti = new TemplateInstance(ad->loc, Type::rtinfo, tiargs);\n+\n+            Scope *sc3 = ti->tempdecl->_scope->startCTFE();\n+            sc3->tinst = sc->tinst;\n+            sc3->minst = sc->minst;\n+            if (ad->isDeprecated())\n+                sc3->stc |= STCdeprecated;\n+\n+            dsymbolSemantic(ti, sc3);\n+            semantic2(ti, sc3);\n+            semantic3(ti, sc3);\n+            Expression *e = resolve(Loc(), sc3, ti->toAlias(), false);\n+\n+            sc3->endCTFE();\n+\n+            e = e->ctfeInterpret();\n+            ad->getRTInfo = e;\n+        }\n+\n+        if (sd)\n+            sd->semanticTypeInfoMembers();\n+        ad->semanticRun = PASSsemantic3done;\n+    }\n+};\n+\n+/*************************************\n+ * Does semantic analysis on function bodies.\n+ */\n+void semantic3(Dsymbol *dsym, Scope *sc)\n+{\n+    Semantic3Visitor v(sc);\n+    dsym->accept(&v);\n+}"}, {"sha": "661bd43134c8ee5c2d44b818ab2fcafe56a3a9db", "filename": "gcc/d/dmd/sideeffect.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsideeffect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fsideeffect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -25,7 +25,6 @@\n \n bool walkPostorder(Expression *e, StoppableVisitor *v);\n bool lambdaHasSideEffect(Expression *e);\n-Expression *semantic(Expression *e, Scope *sc);\n \n /**************************************************\n  * Front-end expression rewriting should create temporary variables for\n@@ -425,8 +424,8 @@ Expression *extractSideEffect(Scope *sc, const char *name,\n \n     Expression *de = new DeclarationExp(vd->loc, vd);\n     Expression *ve = new VarExp(vd->loc, vd);\n-    de = semantic(de, sc);\n-    ve = semantic(ve, sc);\n+    de = expressionSemantic(de, sc);\n+    ve = expressionSemantic(ve, sc);\n \n     *e0 = Expression::combine(*e0, de);\n     return ve;"}, {"sha": "2f7b7e13ffcb3a5f41a0565f7b9d3816de4ab5d2", "filename": "gcc/d/dmd/statement.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -30,8 +30,6 @@ bool walkPostorder(Statement *s, StoppableVisitor *v);\n StorageClass mergeFuncAttrs(StorageClass s1, FuncDeclaration *f);\n bool checkEscapeRef(Scope *sc, Expression *e, bool gag);\n VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n-Expression *semantic(Expression *e, Scope *sc);\n-StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n Statement *makeTupleForeachStatic(Scope *sc, ForeachStatement *fs, bool needExpansion);\n \n Identifier *fixupLabelName(Scope *sc, Identifier *ident)\n@@ -470,7 +468,7 @@ Statements *ExpStatement::flatten(Scope *sc)\n         Dsymbol *d = ((DeclarationExp *)exp)->declaration;\n         if (TemplateMixin *tm = d->isTemplateMixin())\n         {\n-            Expression *e = semantic(exp, sc);\n+            Expression *e = expressionSemantic(exp, sc);\n             if (e->op == TOKerror || tm->errors)\n             {\n                 Statements *a = new Statements();\n@@ -1143,12 +1141,12 @@ static bool checkVar(SwitchStatement *s, VarDeclaration *vd)\n     }\n     else if (vd->ident == Id::withSym)\n     {\n-        s->deprecation(\"'switch' skips declaration of 'with' temporary at %s\", vd->loc.toChars());\n+        s->deprecation(\"`switch` skips declaration of `with` temporary at %s\", vd->loc.toChars());\n         return true;\n     }\n     else\n     {\n-        s->deprecation(\"'switch' skips declaration of variable %s at %s\", vd->toPrettyChars(), vd->loc.toChars());\n+        s->deprecation(\"`switch` skips declaration of variable %s at %s\", vd->toPrettyChars(), vd->loc.toChars());\n         return true;\n     }\n \n@@ -1471,7 +1469,7 @@ Statement *ScopeGuardStatement::scopeCode(Scope *sc, Statement **sentry, Stateme\n              *  sfinally: if (!x) statement;\n              */\n             VarDeclaration *v = copyToTemp(0, \"__os\", new IntegerExp(Loc(), 0, Type::tbool));\n-            v->semantic(sc);\n+            dsymbolSemantic(v, sc);\n             *sentry = new ExpStatement(loc, v);\n \n             Expression *e = new IntegerExp(Loc(), 1, Type::tbool);\n@@ -1558,7 +1556,7 @@ bool GotoStatement::checkLabel()\n {\n     if (!label->statement)\n     {\n-        error(\"label '%s' is undefined\", label->toChars());\n+        error(\"label `%s` is undefined\", label->toChars());\n         return true;\n     }\n "}, {"sha": "2d8b46c94874d22a298416ba3b7cf94133372ec9", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -23,6 +23,7 @@ struct Scope;\n class Expression;\n class LabelDsymbol;\n class Identifier;\n+class Statement;\n class IfStatement;\n class ExpStatement;\n class DefaultStatement;\n@@ -38,6 +39,7 @@ class StaticAssert;\n class AsmStatement;\n class GotoStatement;\n class ScopeStatement;\n+class Catch;\n class TryCatchStatement;\n class TryFinallyStatement;\n class CaseStatement;\n@@ -48,6 +50,11 @@ class StaticForeach;\n // Back end\n struct code;\n \n+Statement *statementSemantic(Statement *s, Scope *sc);\n+Statement *semanticNoScope(Statement *s, Scope *sc);\n+Statement *semanticScope(Statement *s, Scope *sc, Statement *sbreak, Statement *scontinue);\n+void catchSemantic(Catch *c, Scope *sc);\n+\n bool inferAggregate(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply);\n bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply);\n "}, {"sha": "28a930a28bc63e68407a78dce3950d9fe5e9396d", "filename": "gcc/d/dmd/statement_rewrite_walker.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement_rewrite_walker.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -0,0 +1,172 @@\n+\n+/* Compiler implementation of the D programming language\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * written by Walter Bright\n+ * http://www.digitalmars.com\n+ * Distributed under the Boost Software License, Version 1.0.\n+ * http://www.boost.org/LICENSE_1_0.txt\n+ */\n+\n+#include \"statement.h\"\n+#include \"visitor.h\"\n+\n+/* A visitor to walk entire statements and provides ability to replace any sub-statements.\n+ */\n+class StatementRewriteWalker : public Visitor\n+{\n+    /* Point the currently visited statement.\n+     * By using replaceCurrent() method, you can replace AST during walking.\n+     */\n+    Statement **ps;\n+public:\n+    void visitStmt(Statement *&s) { ps = &s; s->accept(this); }\n+    void replaceCurrent(Statement *s) { *ps = s; }\n+\n+    void visit(ErrorStatement *) {  }\n+    void visit(PeelStatement *s)\n+    {\n+        if (s->s)\n+            visitStmt(s->s);\n+    }\n+    void visit(ExpStatement *) {  }\n+    void visit(DtorExpStatement *) {  }\n+    void visit(CompileStatement *) {  }\n+    void visit(CompoundStatement *s)\n+    {\n+        if (s->statements && s->statements->length)\n+        {\n+            for (size_t i = 0; i < s->statements->length; i++)\n+            {\n+                if ((*s->statements)[i])\n+                    visitStmt((*s->statements)[i]);\n+            }\n+        }\n+    }\n+    void visit(CompoundDeclarationStatement *s) { visit((CompoundStatement *)s); }\n+    void visit(UnrolledLoopStatement *s)\n+    {\n+        if (s->statements && s->statements->length)\n+        {\n+            for (size_t i = 0; i < s->statements->length; i++)\n+            {\n+                if ((*s->statements)[i])\n+                    visitStmt((*s->statements)[i]);\n+            }\n+        }\n+    }\n+    void visit(ScopeStatement *s)\n+    {\n+        if (s->statement)\n+            visitStmt(s->statement);\n+    }\n+    void visit(WhileStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(DoStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(ForStatement *s)\n+    {\n+        if (s->_init)\n+            visitStmt(s->_init);\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(ForeachStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(ForeachRangeStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(IfStatement *s)\n+    {\n+        if (s->ifbody)\n+            visitStmt(s->ifbody);\n+        if (s->elsebody)\n+            visitStmt(s->elsebody);\n+    }\n+    void visit(ConditionalStatement *) {  }\n+    void visit(PragmaStatement *) {  }\n+    void visit(StaticAssertStatement *) {  }\n+    void visit(SwitchStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(CaseStatement *s)\n+    {\n+        if (s->statement)\n+            visitStmt(s->statement);\n+    }\n+    void visit(CaseRangeStatement *s)\n+    {\n+        if (s->statement)\n+            visitStmt(s->statement);\n+    }\n+    void visit(DefaultStatement *s)\n+    {\n+        if (s->statement)\n+            visitStmt(s->statement);\n+    }\n+    void visit(GotoDefaultStatement *) {  }\n+    void visit(GotoCaseStatement *) {  }\n+    void visit(SwitchErrorStatement *) {  }\n+    void visit(ReturnStatement *) {  }\n+    void visit(BreakStatement *) {  }\n+    void visit(ContinueStatement *) {  }\n+    void visit(SynchronizedStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(WithStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+    }\n+    void visit(TryCatchStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+        if (s->catches && s->catches->length)\n+        {\n+            for (size_t i = 0; i < s->catches->length; i++)\n+            {\n+                Catch *c = (*s->catches)[i];\n+                if (c && c->handler)\n+                    visitStmt(c->handler);\n+            }\n+        }\n+    }\n+    void visit(TryFinallyStatement *s)\n+    {\n+        if (s->_body)\n+            visitStmt(s->_body);\n+        if (s->finalbody)\n+            visitStmt(s->finalbody);\n+    }\n+    void visit(ScopeGuardStatement *) {  }\n+    void visit(ThrowStatement *) {  }\n+    void visit(DebugStatement *s)\n+    {\n+        if (s->statement)\n+            visitStmt(s->statement);\n+    }\n+    void visit(GotoStatement *) {  }\n+    void visit(LabelStatement *s)\n+    {\n+        if (s->statement)\n+            visitStmt(s->statement);\n+    }\n+    void visit(AsmStatement *) {  }\n+    void visit(ImportStatement *) {  }\n+};\n+"}, {"sha": "5579c1ca8938a7f9029469fd7f5e733c5f03738c", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 113, "deletions": 118, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -39,11 +39,6 @@ VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n Expression *checkAssignmentAsCondition(Expression *e);\n TypeIdentifier *getThrowable();\n \n-Expression *semantic(Expression *e, Scope *sc);\n-Statement *semantic(Statement *s, Scope *sc);\n-void semantic(Catch *c, Scope *sc);\n-Statement *semanticNoScope(Statement *s, Scope *sc);\n-Statement *semanticScope(Statement *s, Scope *sc, Statement *sbreak, Statement *scontinue);\n int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow);\n \n class StatementSemanticVisitor : public Visitor\n@@ -93,7 +88,7 @@ class StatementSemanticVisitor : public Visitor\n             if (s->exp->op == TOKcomma)\n                 ((CommaExp *)s->exp)->allowCommaExp = true;\n \n-            s->exp = semantic(s->exp, sc);\n+            s->exp = expressionSemantic(s->exp, sc);\n             s->exp = resolveProperties(sc, s->exp);\n             s->exp = s->exp->addDtorHook(sc);\n             if (checkNonAssignmentArrayOp(s->exp))\n@@ -121,7 +116,7 @@ class StatementSemanticVisitor : public Visitor\n         if (!a)\n             return;\n         Statement *s = new CompoundStatement(cs->loc, a);\n-        result = semantic(s, sc);\n+        result = statementSemantic(s, sc);\n     }\n \n     void visit(CompoundStatement *cs)\n@@ -139,7 +134,7 @@ class StatementSemanticVisitor : public Visitor\n                     cs->statements->insert(i, flt);\n                     continue;\n                 }\n-                s = semantic(s, sc);\n+                s = statementSemantic(s, sc);\n                 (*cs->statements)[i] = s;\n                 if (s)\n                 {\n@@ -150,12 +145,12 @@ class StatementSemanticVisitor : public Visitor\n                     (*cs->statements)[i] = s->scopeCode(sc, &sentry, &sexception, &sfinally);\n                     if (sentry)\n                     {\n-                        sentry = semantic(sentry, sc);\n+                        sentry = statementSemantic(sentry, sc);\n                         cs->statements->insert(i, sentry);\n                         i++;\n                     }\n                     if (sexception)\n-                        sexception = semantic(sexception, sc);\n+                        sexception = statementSemantic(sexception, sc);\n                     if (sexception)\n                     {\n                         if (i + 1 == cs->statements->length && !sfinally)\n@@ -197,7 +192,7 @@ class StatementSemanticVisitor : public Visitor\n                             s = new TryCatchStatement(Loc(), body, catches);\n                             if (sfinally)\n                                 s = new TryFinallyStatement(Loc(), s, sfinally);\n-                            s = semantic(s, sc);\n+                            s = statementSemantic(s, sc);\n \n                             cs->statements->setDim(i + 1);\n                             cs->statements->push(s);\n@@ -224,7 +219,7 @@ class StatementSemanticVisitor : public Visitor\n                             }\n                             Statement *body = new CompoundStatement(Loc(), a);\n                             s = new TryFinallyStatement(Loc(), body, sfinally);\n-                            s = semantic(s, sc);\n+                            s = statementSemantic(s, sc);\n                             cs->statements->setDim(i + 1);\n                             cs->statements->push(s);\n                             break;\n@@ -290,7 +285,7 @@ class StatementSemanticVisitor : public Visitor\n             if (s)\n             {\n                 //printf(\"[%d]: %s\\n\", i, s->toChars());\n-                s = semantic(s, scd);\n+                s = statementSemantic(s, scd);\n                 (*uls->statements)[i] = s;\n \n                 if (s && !serror)\n@@ -318,7 +313,7 @@ class StatementSemanticVisitor : public Visitor\n                 ss->statement = new CompoundStatement(ss->loc, a);\n             }\n \n-            ss->statement = semantic(ss->statement, sc);\n+            ss->statement = statementSemantic(ss->statement, sc);\n             if (ss->statement)\n             {\n                 if (ss->statement->isErrorStatement())\n@@ -338,7 +333,7 @@ class StatementSemanticVisitor : public Visitor\n                 if (sfinally)\n                 {\n                     //printf(\"adding sfinally\\n\");\n-                    sfinally = semantic(sfinally, sc);\n+                    sfinally = statementSemantic(sfinally, sc);\n                     ss->statement = new CompoundStatement(ss->loc, ss->statement, sfinally);\n                 }\n             }\n@@ -359,7 +354,7 @@ class StatementSemanticVisitor : public Visitor\n         sc = sc->push(ss->sym);\n         sc->sbreak = ss;\n         sc->scontinue = ss;\n-        ss->statement = semantic(ss->statement, sc);\n+        ss->statement = statementSemantic(ss->statement, sc);\n         sc = sc->pop();\n         result = ss->statement;\n     }\n@@ -369,7 +364,7 @@ class StatementSemanticVisitor : public Visitor\n         /* Rewrite as a for(;condition;) loop\n          */\n         Statement *s = new ForStatement(ws->loc, NULL, ws->condition, NULL, ws->_body, ws->endloc);\n-        s = semantic(s, sc);\n+        s = statementSemantic(s, sc);\n         result = s;\n     }\n \n@@ -386,7 +381,7 @@ class StatementSemanticVisitor : public Visitor\n         // check in syntax level\n         ds->condition = checkAssignmentAsCondition(ds->condition);\n \n-        ds->condition = semantic(ds->condition, sc);\n+        ds->condition = expressionSemantic(ds->condition, sc);\n         ds->condition = resolveProperties(sc, ds->condition);\n         if (checkNonAssignmentArrayOp(ds->condition))\n             ds->condition = new ErrorExp();\n@@ -432,7 +427,7 @@ class StatementSemanticVisitor : public Visitor\n             ainit->push(fs);\n             Statement *s = new CompoundStatement(fs->loc, ainit);\n             s = new ScopeStatement(fs->loc, s, fs->endloc);\n-            s = semantic(s, sc);\n+            s = statementSemantic(s, sc);\n             if (!s->isErrorStatement())\n             {\n                 if (LabelStatement *ls = checkLabeledLoop(sc, fs))\n@@ -458,7 +453,7 @@ class StatementSemanticVisitor : public Visitor\n             // check in syntax level\n             fs->condition = checkAssignmentAsCondition(fs->condition);\n \n-            fs->condition = semantic(fs->condition, sc);\n+            fs->condition = expressionSemantic(fs->condition, sc);\n             fs->condition = resolveProperties(sc, fs->condition);\n             if (checkNonAssignmentArrayOp(fs->condition))\n                 fs->condition = new ErrorExp();\n@@ -470,7 +465,7 @@ class StatementSemanticVisitor : public Visitor\n         {\n             if (fs->increment->op == TOKcomma)\n                 ((CommaExp *)fs->increment)->allowCommaExp = true;\n-            fs->increment = semantic(fs->increment, sc);\n+            fs->increment = expressionSemantic(fs->increment, sc);\n             fs->increment = resolveProperties(sc, fs->increment);\n             if (checkNonAssignmentArrayOp(fs->increment))\n                 fs->increment = new ErrorExp();\n@@ -650,7 +645,7 @@ class StatementSemanticVisitor : public Visitor\n                     p->type = Type::tsize_t;\n                 }\n             }\n-            p->type = p->type->semantic(loc, sc);\n+            p->type = typeSemantic(p->type, loc, sc);\n             TY keyty = p->type->ty;\n             if (keyty != Tint32 && keyty != Tuns32)\n             {\n@@ -698,15 +693,15 @@ class StatementSemanticVisitor : public Visitor\n                             0, e->type, ident, e, NULL);\n             Identifier *field = Identifier::idPool(\"tuple\");\n             Expression *access = new DotIdExp(loc, e, field);\n-            access = semantic(access, sc);\n+            access = expressionSemantic(access, sc);\n             if (!tuple)\n                 return false;\n             //printf(\"%s\\n\", tuple->toChars());\n             for (size_t l = 0; l < dim; l++)\n             {\n                 Parameter *cp = (*fs->parameters)[l];\n                 Expression *init_ = new IndexExp(loc, access, new IntegerExp(loc, l, Type::tsize_t));\n-                init_ = semantic(init_, sc);\n+                init_ = expressionSemantic(init_, sc);\n                 assert(init_->type);\n                 declareVariable(fs, paramtype, te, needExpansion, isStatic, stmts, decls,\n                                 p->storageClass, init_->type, cp->ident, init_, NULL);\n@@ -782,7 +777,7 @@ class StatementSemanticVisitor : public Visitor\n         Type *paramtype = (*fs->parameters)[dim-1]->type;\n         if (paramtype)\n         {\n-            paramtype = paramtype->semantic(loc, sc);\n+            paramtype = typeSemantic(paramtype, loc, sc);\n             if (paramtype->ty == Terror)\n                 return false;\n         }\n@@ -853,7 +848,7 @@ class StatementSemanticVisitor : public Visitor\n             fs->func = fs->func->fes->func;\n \n         VarDeclaration *vinit = NULL;\n-        fs->aggr = semantic(fs->aggr, sc);\n+        fs->aggr = expressionSemantic(fs->aggr, sc);\n         fs->aggr = resolveProperties(sc, fs->aggr);\n         fs->aggr = fs->aggr->optimize(WANTvalue);\n         if (fs->aggr->op == TOKerror)\n@@ -866,7 +861,7 @@ class StatementSemanticVisitor : public Visitor\n         {\n             // Bugzilla 14653: Extend the life of rvalue aggregate till the end of foreach.\n             vinit = copyToTemp(STCrvalue, \"__aggr\", fs->aggr);\n-            vinit->semantic(sc);\n+            dsymbolSemantic(vinit, sc);\n             fs->aggr = new VarExp(fs->aggr->loc, vinit);\n         }\n \n@@ -946,7 +941,7 @@ class StatementSemanticVisitor : public Visitor\n             }\n             if (vinit)\n                 result = new CompoundStatement(loc, new ExpStatement(loc, vinit), result);\n-            result = semantic(result, sc);\n+            result = statementSemantic(result, sc);\n             return;\n         }\n \n@@ -991,7 +986,7 @@ class StatementSemanticVisitor : public Visitor\n                     for (size_t i = 0; i < dim; i++)\n                     {\n                         Parameter *p = (*fs->parameters)[i];\n-                        p->type = p->type->semantic(loc, sc2);\n+                        p->type = typeSemantic(p->type, loc, sc2);\n                         p->type = p->type->addStorageClass(p->storageClass);\n                     }\n \n@@ -1080,7 +1075,7 @@ class StatementSemanticVisitor : public Visitor\n                                 IntRange dimrange = getIntRange(ta->dim);\n                                 if (!IntRange::fromType(var->type).contains(dimrange))\n                                 {\n-                                    fs->error(\"index type '%s' cannot cover index range 0..%llu\", p->type->toChars(), ta->dim->toInteger());\n+                                    fs->error(\"index type `%s` cannot cover index range 0..%llu\", p->type->toChars(), ta->dim->toInteger());\n                                     goto Lerror2;\n                                 }\n                                 fs->key->range = new IntRange(SignExtendedNumber(0), dimrange.imax);\n@@ -1221,7 +1216,7 @@ class StatementSemanticVisitor : public Visitor\n                     s = new ForStatement(loc, forinit, cond, increment, fs->_body, fs->endloc);\n                     if (LabelStatement *ls = checkLabeledLoop(sc, fs))   // Bugzilla 15450: don't use sc2\n                         ls->gotoTarget = s;\n-                    s = semantic(s, sc2);\n+                    s = statementSemantic(s, sc2);\n                     break;\n                 }\n \n@@ -1290,7 +1285,7 @@ class StatementSemanticVisitor : public Visitor\n                     else\n                     {\n                         r = copyToTemp(0, \"__r\", fs->aggr);\n-                        r->semantic(sc);\n+                        dsymbolSemantic(r, sc);\n                         init = new ExpStatement(loc, r);\n                         if (vinit)\n                             init = new CompoundStatement(loc, new ExpStatement(loc, vinit), init);\n@@ -1323,7 +1318,7 @@ class StatementSemanticVisitor : public Visitor\n                     else\n                     {\n                         VarDeclaration *vd = copyToTemp(STCref, \"__front\", einit);\n-                        vd->semantic(sc);\n+                        dsymbolSemantic(vd, sc);\n                         makeargs = new ExpStatement(loc, vd);\n \n                         Type *tfront = NULL;\n@@ -1383,7 +1378,7 @@ class StatementSemanticVisitor : public Visitor\n                             Expression *exp = (*exps)[i];\n                             if (!p->type)\n                                 p->type = exp->type;\n-                            p->type = p->type->addStorageClass(p->storageClass)->semantic(loc, sc2);\n+                            p->type = typeSemantic(p->type->addStorageClass(p->storageClass), loc, sc2);\n                             if (!exp->implicitConvTo(p->type))\n                                 goto Lrangeerr;\n \n@@ -1400,7 +1395,7 @@ class StatementSemanticVisitor : public Visitor\n                     s = new ForStatement(loc, init, condition, increment, forbody, fs->endloc);\n                     if (LabelStatement *ls = checkLabeledLoop(sc, fs))\n                         ls->gotoTarget = s;\n-                    s = semantic(s, sc2);\n+                    s = statementSemantic(s, sc2);\n                     break;\n \n                 Lrangeerr:\n@@ -1426,7 +1421,7 @@ class StatementSemanticVisitor : public Visitor\n                         if (fdapply)\n                         {\n                             assert(fdapply->type && fdapply->type->ty == Tfunction);\n-                            tfld = (TypeFunction *)fdapply->type->semantic(loc, sc2);\n+                            tfld = (TypeFunction *)typeSemantic(fdapply->type, loc, sc2);\n                             goto Lget;\n                         }\n                         else if (tab->ty == Tdelegate)\n@@ -1439,7 +1434,7 @@ class StatementSemanticVisitor : public Visitor\n                                 Parameter *p = tfld->parameterList[0];\n                                 if (p->type && p->type->ty == Tdelegate)\n                                 {\n-                                    Type *t = p->type->semantic(loc, sc2);\n+                                    Type *t = typeSemantic(p->type, loc, sc2);\n                                     assert(t->ty == Tdelegate);\n                                     tfld = (TypeFunction *)t->nextOf();\n                                 }\n@@ -1457,7 +1452,7 @@ class StatementSemanticVisitor : public Visitor\n                         StorageClass stc = STCref;\n                         Identifier *id;\n \n-                        p->type = p->type->semantic(loc, sc2);\n+                        p->type = typeSemantic(p->type, loc, sc2);\n                         p->type = p->type->addStorageClass(p->storageClass);\n                         if (tfld)\n                         {\n@@ -1504,7 +1499,7 @@ class StatementSemanticVisitor : public Visitor\n                     FuncLiteralDeclaration *fld = new FuncLiteralDeclaration(loc, Loc(), tfld, TOKdelegate, fs);\n                     fld->fbody = fs->_body;\n                     Expression *flde = new FuncExp(loc, fld);\n-                    flde = semantic(flde, sc2);\n+                    flde = expressionSemantic(flde, sc2);\n                     fld->tookAddressOf = 0;\n \n                     // Resolve any forward referenced goto's\n@@ -1525,7 +1520,7 @@ class StatementSemanticVisitor : public Visitor\n                     if (vinit)\n                     {\n                         e = new DeclarationExp(loc, vinit);\n-                        e = semantic(e, sc2);\n+                        e = expressionSemantic(e, sc2);\n                         if (e->op == TOKerror)\n                             goto Lerror2;\n                     }\n@@ -1672,7 +1667,7 @@ class StatementSemanticVisitor : public Visitor\n                             fs->aggr = ((DelegateExp *)fs->aggr)->e1;\n                         }\n                         ec = new CallExp(loc, fs->aggr, flde);\n-                        ec = semantic(ec, sc2);\n+                        ec = expressionSemantic(ec, sc2);\n                         if (ec->op == TOKerror)\n                             goto Lerror2;\n                         if (ec->type != Type::tint32)\n@@ -1693,7 +1688,7 @@ class StatementSemanticVisitor : public Visitor\n                          */\n                         ec = new DotIdExp(loc, fs->aggr, sapply->ident);\n                         ec = new CallExp(loc, ec, flde);\n-                        ec = semantic(ec, sc2);\n+                        ec = expressionSemantic(ec, sc2);\n                         if (ec->op == TOKerror)\n                             goto Lerror2;\n                         if (ec->type != Type::tint32)\n@@ -1732,7 +1727,7 @@ class StatementSemanticVisitor : public Visitor\n                         s = new CompoundStatement(loc, a);\n                         s = new SwitchStatement(loc, e, s, false);\n                     }\n-                    s = semantic(s, sc2);\n+                    s = statementSemantic(s, sc2);\n                     break;\n                 }\n             case Terror:\n@@ -1753,7 +1748,7 @@ class StatementSemanticVisitor : public Visitor\n     {\n         //printf(\"ForeachRangeStatement::semantic() %p\\n\", fs);\n         Loc loc = fs->loc;\n-        fs->lwr = semantic(fs->lwr, sc);\n+        fs->lwr = expressionSemantic(fs->lwr, sc);\n         fs->lwr = resolveProperties(sc, fs->lwr);\n         fs->lwr = fs->lwr->optimize(WANTvalue);\n         if (!fs->lwr->type)\n@@ -1763,7 +1758,7 @@ class StatementSemanticVisitor : public Visitor\n             return setError();\n         }\n \n-        fs->upr = semantic(fs->upr, sc);\n+        fs->upr = expressionSemantic(fs->upr, sc);\n         fs->upr = resolveProperties(sc, fs->upr);\n         fs->upr = fs->upr->optimize(WANTvalue);\n         if (!fs->upr->type)\n@@ -1774,7 +1769,7 @@ class StatementSemanticVisitor : public Visitor\n \n         if (fs->prm->type)\n         {\n-            fs->prm->type = fs->prm->type->semantic(loc, sc);\n+            fs->prm->type = typeSemantic(fs->prm->type, loc, sc);\n             fs->prm->type = fs->prm->type->addStorageClass(fs->prm->storageClass);\n             fs->lwr = fs->lwr->implicitCastTo(sc, fs->prm->type);\n \n@@ -1786,7 +1781,7 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 // See if upr-1 fits in prm->type\n                 Expression *limit = new MinExp(loc, fs->upr, new IntegerExp(1));\n-                limit = semantic(limit, sc);\n+                limit = expressionSemantic(limit, sc);\n                 limit = limit->optimize(WANTvalue);\n                 if (!limit->implicitConvTo(fs->prm->type))\n                 {\n@@ -1934,7 +1929,7 @@ class StatementSemanticVisitor : public Visitor\n         ForStatement *s = new ForStatement(loc, forinit, cond, increment, fs->_body, fs->endloc);\n         if (LabelStatement *ls = checkLabeledLoop(sc, fs))\n             ls->gotoTarget = s;\n-        result = semantic(s, sc);\n+        result = statementSemantic(s, sc);\n     }\n \n     void visit(IfStatement *ifs)\n@@ -1961,12 +1956,12 @@ class StatementSemanticVisitor : public Visitor\n             ifs->match = new VarDeclaration(ifs->loc, ifs->prm->type, ifs->prm->ident, ei);\n             ifs->match->parent = sc->func;\n             ifs->match->storage_class |= ifs->prm->storageClass;\n-            ifs->match->semantic(scd);\n+            dsymbolSemantic(ifs->match, scd);\n \n             DeclarationExp *de = new DeclarationExp(ifs->loc, ifs->match);\n             VarExp *ve = new VarExp(ifs->loc, ifs->match);\n             ifs->condition = new CommaExp(ifs->loc, de, ve);\n-            ifs->condition = semantic(ifs->condition, scd);\n+            ifs->condition = expressionSemantic(ifs->condition, scd);\n \n             if (ifs->match->edtor)\n             {\n@@ -1981,7 +1976,7 @@ class StatementSemanticVisitor : public Visitor\n             if (ifs->condition->op == TOKdotid)\n                 ((DotIdExp *)ifs->condition)->noderef = true;\n \n-            ifs->condition = semantic(ifs->condition, sc);\n+            ifs->condition = expressionSemantic(ifs->condition, sc);\n             ifs->condition = resolveProperties(sc, ifs->condition);\n             ifs->condition = ifs->condition->addDtorHook(sc);\n         }\n@@ -2033,17 +2028,17 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 sc = sc->push();\n                 sc->flags |= SCOPEdebug;\n-                cs->ifbody = semantic(cs->ifbody, sc);\n+                cs->ifbody = statementSemantic(cs->ifbody, sc);\n                 sc->pop();\n             }\n             else\n-                cs->ifbody = semantic(cs->ifbody, sc);\n+                cs->ifbody = statementSemantic(cs->ifbody, sc);\n             result = cs->ifbody;\n         }\n         else\n         {\n             if (cs->elsebody)\n-                cs->elsebody = semantic(cs->elsebody, sc);\n+                cs->elsebody = statementSemantic(cs->elsebody, sc);\n             result = cs->elsebody;\n         }\n     }\n@@ -2062,7 +2057,7 @@ class StatementSemanticVisitor : public Visitor\n                     Expression *e = (*ps->args)[i];\n \n                     sc = sc->startCTFE();\n-                    e = semantic(e, sc);\n+                    e = expressionSemantic(e, sc);\n                     e = resolveProperties(sc, e);\n                     sc = sc->endCTFE();\n                     // pragma(msg) is allowed to contain types as well as expressions\n@@ -2100,7 +2095,7 @@ class StatementSemanticVisitor : public Visitor\n                 Expression *e = (*ps->args)[0];\n \n                 sc = sc->startCTFE();\n-                e = semantic(e, sc);\n+                e = expressionSemantic(e, sc);\n                 e = resolveProperties(sc, e);\n                 sc = sc->endCTFE();\n \n@@ -2109,12 +2104,12 @@ class StatementSemanticVisitor : public Visitor\n                 Dsymbol *sa = getDsymbol(e);\n                 if (!sa || !sa->isFuncDeclaration())\n                 {\n-                    ps->error(\"function name expected for start address, not '%s'\", e->toChars());\n+                    ps->error(\"function name expected for start address, not `%s`\", e->toChars());\n                     goto Lerror;\n                 }\n                 if (ps->_body)\n                 {\n-                    ps->_body = semantic(ps->_body, sc);\n+                    ps->_body = statementSemantic(ps->_body, sc);\n                     if (ps->_body->isErrorStatement())\n                     {\n                         result = ps->_body;\n@@ -2172,7 +2167,7 @@ class StatementSemanticVisitor : public Visitor\n                 ps->error(\"`pragma(%s)` is missing a terminating `;`\", ps->ident->toChars());\n                 return setError();\n             }\n-            ps->_body = semantic(ps->_body, sc);\n+            ps->_body = statementSemantic(ps->_body, sc);\n         }\n         result = ps->_body;\n         return;\n@@ -2183,7 +2178,7 @@ class StatementSemanticVisitor : public Visitor\n \n     void visit(StaticAssertStatement *s)\n     {\n-        s->sa->semantic2(sc);\n+        semantic2(s->sa, sc);\n     }\n \n     void visit(SwitchStatement *ss)\n@@ -2196,7 +2191,7 @@ class StatementSemanticVisitor : public Visitor\n             return;\n         }\n         bool conditionError = false;\n-        ss->condition = semantic(ss->condition, sc);\n+        ss->condition = expressionSemantic(ss->condition, sc);\n         ss->condition = resolveProperties(sc, ss->condition);\n \n         Type *att = NULL;\n@@ -2234,7 +2229,7 @@ class StatementSemanticVisitor : public Visitor\n \n             if (ss->condition->op != TOKerror)\n             {\n-                ss->error(\"'%s' must be of integral or string type, it is a %s\",\n+                ss->error(\"`%s` must be of integral or string type, it is a %s\",\n                     ss->condition->toChars(), ss->condition->type->toChars());\n                 conditionError = true;\n                 break;\n@@ -2257,7 +2252,7 @@ class StatementSemanticVisitor : public Visitor\n \n         ss->cases = new CaseStatements();\n         sc->noctor++;       // BUG: should use Scope::mergeCallSuper() for each case instead\n-        ss->_body = semantic(ss->_body, sc);\n+        ss->_body = statementSemantic(ss->_body, sc);\n         sc->noctor--;\n \n         if (conditionError || (ss->_body && ss->_body->isErrorStatement()))\n@@ -2337,7 +2332,7 @@ class StatementSemanticVisitor : public Visitor\n             ss->hasNoDefault = 1;\n \n             if (!ss->isFinal && (!ss->_body || !ss->_body->isErrorStatement()))\n-                ss->error(\"switch statement without a default; use 'final switch' or add 'default: assert(0);' or add 'default: break;'\");\n+                ss->error(\"switch statement without a default; use `final switch` or add `default: assert(0);` or add `default: break;`\");\n \n             // Generate runtime error if the default is hit\n             Statements *a = new Statements();\n@@ -2389,7 +2384,7 @@ class StatementSemanticVisitor : public Visitor\n \n         //printf(\"CaseStatement::semantic() %s\\n\", cs->toChars());\n         sc = sc->startCTFE();\n-        cs->exp = semantic(cs->exp, sc);\n+        cs->exp = expressionSemantic(cs->exp, sc);\n         cs->exp = resolveProperties(sc, cs->exp);\n         sc = sc->endCTFE();\n         if (sw)\n@@ -2502,7 +2497,7 @@ class StatementSemanticVisitor : public Visitor\n             cs->error(\"case not in switch statement\");\n             errors = true;\n         }\n-        cs->statement = semantic(cs->statement, sc);\n+        cs->statement = statementSemantic(cs->statement, sc);\n         if (cs->statement->isErrorStatement())\n         {\n             result = cs->statement;\n@@ -2533,14 +2528,14 @@ class StatementSemanticVisitor : public Visitor\n         }\n \n         sc = sc->startCTFE();\n-        crs->first = semantic(crs->first, sc);\n+        crs->first = expressionSemantic(crs->first, sc);\n         crs->first = resolveProperties(sc, crs->first);\n         sc = sc->endCTFE();\n         crs->first = crs->first->implicitCastTo(sc, sw->condition->type);\n         crs->first = crs->first->ctfeInterpret();\n \n         sc = sc->startCTFE();\n-        crs->last = semantic(crs->last, sc);\n+        crs->last = expressionSemantic(crs->last, sc);\n         crs->last = resolveProperties(sc, crs->last);\n         sc = sc->endCTFE();\n         crs->last = crs->last->implicitCastTo(sc, sw->condition->type);\n@@ -2549,7 +2544,7 @@ class StatementSemanticVisitor : public Visitor\n         if (crs->first->op == TOKerror || crs->last->op == TOKerror || errors)\n         {\n             if (crs->statement)\n-                semantic(crs->statement, sc);\n+                statementSemantic(crs->statement, sc);\n             return setError();\n         }\n \n@@ -2597,7 +2592,7 @@ class StatementSemanticVisitor : public Visitor\n             statements->push(cs);\n         }\n         Statement *s = new CompoundStatement(crs->loc, statements);\n-        s = semantic(s, sc);\n+        s = statementSemantic(s, sc);\n         result = s;\n     }\n \n@@ -2630,7 +2625,7 @@ class StatementSemanticVisitor : public Visitor\n             ds->error(\"default not in switch statement\");\n             errors = true;\n         }\n-        ds->statement = semantic(ds->statement, sc);\n+        ds->statement = statementSemantic(ds->statement, sc);\n         if (errors || ds->statement->isErrorStatement())\n             return setError();\n \n@@ -2664,7 +2659,7 @@ class StatementSemanticVisitor : public Visitor\n \n         if (gcs->exp)\n         {\n-            gcs->exp = semantic(gcs->exp, sc);\n+            gcs->exp = expressionSemantic(gcs->exp, sc);\n             gcs->exp = gcs->exp->implicitCastTo(sc, sc->sw->condition->type);\n             gcs->exp = gcs->exp->optimize(WANTvalue);\n             if (gcs->exp->op == TOKerror)\n@@ -2757,7 +2752,7 @@ class StatementSemanticVisitor : public Visitor\n                 rs->exp = inferType(rs->exp, tret);\n             else if (fld && fld->treq)\n                 rs->exp = inferType(rs->exp, fld->treq->nextOf()->nextOf());\n-            rs->exp = semantic(rs->exp, sc);\n+            rs->exp = expressionSemantic(rs->exp, sc);\n \n             // for static alias this: https://issues.dlang.org/show_bug.cgi?id=17684\n             if (rs->exp->op == TOKtype)\n@@ -2793,7 +2788,7 @@ class StatementSemanticVisitor : public Visitor\n                     errors = true;\n \n                     rs->exp = new CastExp(rs->loc, rs->exp, Type::tvoid);\n-                    rs->exp = semantic(rs->exp, sc);\n+                    rs->exp = expressionSemantic(rs->exp, sc);\n                 }\n \n                 /* Replace:\n@@ -3021,7 +3016,7 @@ class StatementSemanticVisitor : public Visitor\n                     Statement *s = ls->statement;\n \n                     if (!s || !s->hasBreak())\n-                        bs->error(\"label '%s' has no break\", bs->ident->toChars());\n+                        bs->error(\"label `%s` has no break\", bs->ident->toChars());\n                     else if (ls->tf != sc->tf)\n                         bs->error(\"cannot break out of finally block\");\n                     else\n@@ -3033,7 +3028,7 @@ class StatementSemanticVisitor : public Visitor\n                     return setError();\n                 }\n             }\n-            bs->error(\"enclosing label '%s' for break not found\", bs->ident->toChars());\n+            bs->error(\"enclosing label `%s` for break not found\", bs->ident->toChars());\n             return setError();\n         }\n         else if (!sc->sbreak)\n@@ -3108,7 +3103,7 @@ class StatementSemanticVisitor : public Visitor\n                     Statement *s = ls->statement;\n \n                     if (!s || !s->hasContinue())\n-                        cs->error(\"label '%s' has no continue\", cs->ident->toChars());\n+                        cs->error(\"label `%s` has no continue\", cs->ident->toChars());\n                     else if (ls->tf != sc->tf)\n                         cs->error(\"cannot continue out of finally block\");\n                     else\n@@ -3119,7 +3114,7 @@ class StatementSemanticVisitor : public Visitor\n                     return setError();\n                 }\n             }\n-            cs->error(\"enclosing label '%s' for continue not found\", cs->ident->toChars());\n+            cs->error(\"enclosing label `%s` for continue not found\", cs->ident->toChars());\n             return setError();\n         }\n         else if (!sc->scontinue)\n@@ -3149,7 +3144,7 @@ class StatementSemanticVisitor : public Visitor\n     {\n         if (ss->exp)\n         {\n-            ss->exp = semantic(ss->exp, sc);\n+            ss->exp = expressionSemantic(ss->exp, sc);\n             ss->exp = resolveProperties(sc, ss->exp);\n             ss->exp = ss->exp->optimize(WANTvalue);\n             ss->exp = checkGC(sc, ss->exp);\n@@ -3158,7 +3153,7 @@ class StatementSemanticVisitor : public Visitor\n             ClassDeclaration *cd = ss->exp->type->isClassHandle();\n             if (!cd)\n             {\n-                ss->error(\"can only synchronize on class objects, not '%s'\", ss->exp->type->toChars());\n+                ss->error(\"can only synchronize on class objects, not `%s`\", ss->exp->type->toChars());\n                 return setError();\n             }\n             else if (cd->isInterfaceDeclaration())\n@@ -3173,11 +3168,11 @@ class StatementSemanticVisitor : public Visitor\n                 }\n \n                 Type *t = ClassDeclaration::object->type;\n-                t = t->semantic(Loc(), sc)->toBasetype();\n+                t = typeSemantic(t, Loc(), sc)->toBasetype();\n                 assert(t->ty == Tclass);\n \n                 ss->exp = new CastExp(ss->loc, ss->exp, t);\n-                ss->exp = semantic(ss->exp, sc);\n+                ss->exp = expressionSemantic(ss->exp, sc);\n             }\n \n             /* Rewrite as:\n@@ -3186,7 +3181,7 @@ class StatementSemanticVisitor : public Visitor\n              *  try { body } finally { _d_monitorexit(tmp); }\n              */\n             VarDeclaration *tmp = copyToTemp(0, \"__sync\", ss->exp);\n-            tmp->semantic(sc);\n+            dsymbolSemantic(tmp, sc);\n \n             Statements *cs = new Statements();\n             cs->push(new ExpStatement(ss->loc, tmp));\n@@ -3207,7 +3202,7 @@ class StatementSemanticVisitor : public Visitor\n             cs->push(s);\n \n             s = new CompoundStatement(ss->loc, cs);\n-            result = semantic(s, sc);\n+            result = statementSemantic(s, sc);\n             return;\n         }\n         else\n@@ -3230,34 +3225,34 @@ class StatementSemanticVisitor : public Visitor\n              * Backend optimizer could remove this unused variable.\n              */\n             VarDeclaration *v = new VarDeclaration(ss->loc, Type::tvoidptr, Identifier::generateId(\"__sync\"), NULL);\n-            v->semantic(sc);\n+            dsymbolSemantic(v, sc);\n             cs->push(new ExpStatement(ss->loc, v));\n \n             Parameters* args = new Parameters;\n             args->push(new Parameter(0, t->pointerTo(), NULL, NULL, NULL));\n \n             FuncDeclaration *fdenter = FuncDeclaration::genCfunc(args, Type::tvoid, Id::criticalenter, STCnothrow);\n             Expression *e = new AddrExp(ss->loc, tmpExp);\n-            e = semantic(e, sc);\n+            e = expressionSemantic(e, sc);\n             e = new CallExp(ss->loc, new VarExp(ss->loc, fdenter, false), e);\n             e->type = Type::tvoid;                  // do not run semantic on e\n             cs->push(new ExpStatement(ss->loc, e));\n \n             FuncDeclaration *fdexit = FuncDeclaration::genCfunc(args, Type::tvoid, Id::criticalexit, STCnothrow);\n-            e = semantic(tmpExp, sc);\n+            e = expressionSemantic(tmpExp, sc);\n             e = new CallExp(ss->loc, new VarExp(ss->loc, fdexit, false), e);\n             e->type = Type::tvoid;                  // do not run semantic on e\n             Statement *s = new ExpStatement(ss->loc, e);\n             s = new TryFinallyStatement(ss->loc, ss->_body, s);\n             cs->push(s);\n \n             s = new CompoundStatement(ss->loc, cs);\n-            result = semantic(s, sc);\n+            result = statementSemantic(s, sc);\n             return;\n         }\n     Lbody:\n         if (ss->_body)\n-            ss->_body = semantic(ss->_body, sc);\n+            ss->_body = statementSemantic(ss->_body, sc);\n         if (ss->_body && ss->_body->isErrorStatement())\n         {\n             result = ss->_body;\n@@ -3272,7 +3267,7 @@ class StatementSemanticVisitor : public Visitor\n         Initializer *init;\n \n         //printf(\"WithStatement::semantic()\\n\");\n-        ws->exp = semantic(ws->exp, sc);\n+        ws->exp = expressionSemantic(ws->exp, sc);\n         ws->exp = resolveProperties(sc, ws->exp);\n         ws->exp = ws->exp->optimize(WANTvalue);\n         ws->exp = checkGC(sc, ws->exp);\n@@ -3304,7 +3299,7 @@ class StatementSemanticVisitor : public Visitor\n             if (t->ty == Tpointer)\n             {\n                 ws->exp = new PtrExp(ws->loc, ws->exp);\n-                ws->exp = semantic(ws->exp, sc);\n+                ws->exp = expressionSemantic(ws->exp, sc);\n                 t = ws->exp->type->toBasetype();\n             }\n \n@@ -3314,7 +3309,7 @@ class StatementSemanticVisitor : public Visitor\n             {\n                 init = new ExpInitializer(ws->loc, ws->exp);\n                 ws->wthis = new VarDeclaration(ws->loc, ws->exp->type, Id::withSym, init);\n-                ws->wthis->semantic(sc);\n+                dsymbolSemantic(ws->wthis, sc);\n \n                 sym = new WithScopeSymbol(ws);\n                 sym->parent = sc->scopesym;\n@@ -3334,17 +3329,17 @@ class StatementSemanticVisitor : public Visitor\n                      * }\n                      */\n                     VarDeclaration *tmp = copyToTemp(0, \"__withtmp\", ws->exp);\n-                    tmp->semantic(sc);\n+                    dsymbolSemantic(tmp, sc);\n                     ExpStatement *es = new ExpStatement(ws->loc, tmp);\n                     ws->exp = new VarExp(ws->loc, tmp);\n                     Statement *ss = new ScopeStatement(ws->loc, new CompoundStatement(ws->loc, es, ws), ws->endloc);\n-                    result = semantic(ss, sc);\n+                    result = statementSemantic(ss, sc);\n                     return;\n                 }\n                 Expression *e = ws->exp->addressOf();\n                 init = new ExpInitializer(ws->loc, e);\n                 ws->wthis = new VarDeclaration(ws->loc, e->type, Id::withSym, init);\n-                ws->wthis->semantic(sc);\n+                dsymbolSemantic(ws->wthis, sc);\n                 sym = new WithScopeSymbol(ws);\n                 // Need to set the scope to make use of resolveAliasThis\n                 sym->setScope(sc);\n@@ -3353,7 +3348,7 @@ class StatementSemanticVisitor : public Visitor\n             }\n             else\n             {\n-                ws->error(\"with expressions must be aggregate types or pointers to them, not '%s'\", olde->type->toChars());\n+                ws->error(\"with expressions must be aggregate types or pointers to them, not `%s`\", olde->type->toChars());\n                 return setError();\n             }\n         }\n@@ -3363,7 +3358,7 @@ class StatementSemanticVisitor : public Visitor\n             sym->_scope = sc;\n             sc = sc->push(sym);\n             sc->insert(sym);\n-            ws->_body = semantic(ws->_body, sc);\n+            ws->_body = statementSemantic(ws->_body, sc);\n             sc->pop();\n             if (ws->_body && ws->_body->isErrorStatement())\n             {\n@@ -3402,7 +3397,7 @@ class StatementSemanticVisitor : public Visitor\n         for (size_t i = 0; i < tcs->catches->length; i++)\n         {\n             Catch *c = (*tcs->catches)[i];\n-            semantic(c, sc);\n+            catchSemantic(c, sc);\n             if (c->errors)\n             {\n                 catchErrors = true;\n@@ -3478,7 +3473,7 @@ class StatementSemanticVisitor : public Visitor\n     void visit(TryFinallyStatement *tfs)\n     {\n         //printf(\"TryFinallyStatement::semantic()\\n\");\n-        tfs->_body = semantic(tfs->_body, sc);\n+        tfs->_body = statementSemantic(tfs->_body, sc);\n         sc = sc->push();\n         sc->tf = tfs;\n         sc->sbreak = NULL;\n@@ -3572,7 +3567,7 @@ class StatementSemanticVisitor : public Visitor\n         FuncDeclaration *fd = sc->parent->isFuncDeclaration();\n         fd->hasReturnExp |= 2;\n \n-        ts->exp = semantic(ts->exp, sc);\n+        ts->exp = expressionSemantic(ts->exp, sc);\n         ts->exp = resolveProperties(sc, ts->exp);\n         ts->exp = checkGC(sc, ts->exp);\n         if (ts->exp->op == TOKerror)\n@@ -3596,7 +3591,7 @@ class StatementSemanticVisitor : public Visitor\n         {\n             sc = sc->push();\n             sc->flags |= SCOPEdebug;\n-            ds->statement = semantic(ds->statement, sc);\n+            ds->statement = statementSemantic(ds->statement, sc);\n             sc->pop();\n         }\n         result = ds->statement;\n@@ -3653,7 +3648,7 @@ class StatementSemanticVisitor : public Visitor\n         LabelDsymbol *ls2 = fd->searchLabel(ls->ident);\n         if (ls2->statement)\n         {\n-            ls->error(\"label '%s' already defined\", ls2->toChars());\n+            ls->error(\"label `%s` already defined\", ls2->toChars());\n             return setError();\n         }\n         else\n@@ -3670,7 +3665,7 @@ class StatementSemanticVisitor : public Visitor\n         }\n         sc->slabel = ls;\n         if (ls->statement)\n-            ls->statement = semantic(ls->statement, sc);\n+            ls->statement = statementSemantic(ls->statement, sc);\n         sc->pop();\n \n         result = ls;\n@@ -3690,18 +3685,18 @@ class StatementSemanticVisitor : public Visitor\n         for (size_t i = 0; i < cas->statements->length; i++)\n         {\n             Statement *s = (*cas->statements)[i];\n-            (*cas->statements)[i] = s ? semantic(s, sc) : NULL;\n+            (*cas->statements)[i] = s ? statementSemantic(s, sc) : NULL;\n         }\n \n         assert(sc->func);\n         // use setImpure/setGC when the deprecation cycle is over\n         PURE purity;\n         if (!(cas->stc & STCpure) && (purity = sc->func->isPureBypassingInference()) != PUREimpure && purity != PUREfwdref)\n-            cas->deprecation(\"asm statement is assumed to be impure - mark it with 'pure' if it is not\");\n+            cas->deprecation(\"asm statement is assumed to be impure - mark it with `pure` if it is not\");\n         if (!(cas->stc & STCnogc) && sc->func->isNogcBypassingInference())\n-            cas->deprecation(\"asm statement is assumed to use the GC - mark it with '@nogc' if it does not\");\n+            cas->deprecation(\"asm statement is assumed to use the GC - mark it with `@nogc` if it does not\");\n         if (!(cas->stc & (STCtrusted|STCsafe)) && sc->func->setUnsafe())\n-            cas->error(\"asm statement is assumed to be @system - mark it with '@trusted' if it is not\");\n+            cas->error(\"asm statement is assumed to be @system - mark it with `@trusted` if it is not\");\n \n         sc->pop();\n         result = cas;\n@@ -3727,7 +3722,7 @@ class StatementSemanticVisitor : public Visitor\n                 s->aliasdecls.push(ad);\n             }\n \n-            s->semantic(sc);\n+            dsymbolSemantic(s, sc);\n             // https://issues.dlang.org/show_bug.cgi?id=19942\n             // If the module that's being imported doesn't exist, don't add it to the symbol table\n             // for the current scope.\n@@ -3746,14 +3741,14 @@ class StatementSemanticVisitor : public Visitor\n     }\n };\n \n-Statement *semantic(Statement *s, Scope *sc)\n+Statement *statementSemantic(Statement *s, Scope *sc)\n {\n     StatementSemanticVisitor v = StatementSemanticVisitor(sc);\n     s->accept(&v);\n     return v.result;\n }\n \n-void semantic(Catch *c, Scope *sc)\n+void catchSemantic(Catch *c, Scope *sc)\n {\n     //printf(\"Catch::semantic(%s)\\n\", ident->toChars());\n \n@@ -3786,15 +3781,15 @@ void semantic(Catch *c, Scope *sc)\n         // reference .object.Throwable\n         c->type = getThrowable();\n     }\n-    c->type = c->type->semantic(c->loc, sc);\n+    c->type = typeSemantic(c->type, c->loc, sc);\n     if (c->type == Type::terror)\n         c->errors = true;\n     else\n     {\n         ClassDeclaration *cd = c->type->toBasetype()->isClassHandle();\n         if (!cd)\n         {\n-            error(c->loc, \"can only catch class objects, not '%s'\", c->type->toChars());\n+            error(c->loc, \"can only catch class objects, not `%s`\", c->type->toChars());\n             c->errors = true;\n         }\n         else if (cd->isCPPclass())\n@@ -3812,24 +3807,24 @@ void semantic(Catch *c, Scope *sc)\n         }\n         else if (cd != ClassDeclaration::throwable && !ClassDeclaration::throwable->isBaseOf(cd, NULL))\n         {\n-            error(c->loc, \"can only catch class objects derived from Throwable, not '%s'\", c->type->toChars());\n+            error(c->loc, \"can only catch class objects derived from Throwable, not `%s`\", c->type->toChars());\n             c->errors = true;\n         }\n         else if (sc->func && !sc->intypeof && !c->internalCatch &&\n                  cd != ClassDeclaration::exception && !ClassDeclaration::exception->isBaseOf(cd, NULL) &&\n                  sc->func->setUnsafe())\n         {\n-            error(c->loc, \"can only catch class objects derived from Exception in @safe code, not '%s'\", c->type->toChars());\n+            error(c->loc, \"can only catch class objects derived from Exception in @safe code, not `%s`\", c->type->toChars());\n             c->errors = true;\n         }\n \n         if (c->ident)\n         {\n             c->var = new VarDeclaration(c->loc, c->type, c->ident, NULL);\n-            c->var->semantic(sc);\n+            dsymbolSemantic(c->var, sc);\n             sc->insert(c->var);\n         }\n-        c->handler = semantic(c->handler, sc);\n+        c->handler = statementSemantic(c->handler, sc);\n         if (c->handler && c->handler->isErrorStatement())\n             c->errors = true;\n     }\n@@ -3843,7 +3838,7 @@ Statement *semanticNoScope(Statement *s, Scope *sc)\n     {\n         s = new CompoundStatement(s->loc, s); // so scopeCode() gets called\n     }\n-    s = semantic(s, sc);\n+    s = statementSemantic(s, sc);\n     return s;\n }\n "}, {"sha": "c2d0f5b65c280ac68368be33ec2871bff9f5c024", "filename": "gcc/d/dmd/staticassert.c", "status": "modified", "additions": 1, "deletions": 48, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstaticassert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstaticassert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticassert.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -19,7 +19,6 @@\n #include \"template.h\"\n #include \"declaration.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors);\n \n /********************************* AttribDeclaration ****************************/\n@@ -43,52 +42,6 @@ void StaticAssert::addMember(Scope *, ScopeDsymbol *)\n     // we didn't add anything\n }\n \n-void StaticAssert::semantic(Scope *)\n-{\n-}\n-\n-void StaticAssert::semantic2(Scope *sc)\n-{\n-    //printf(\"StaticAssert::semantic2() %s\\n\", toChars());\n-    ScopeDsymbol *sds = new ScopeDsymbol();\n-    sc = sc->push(sds);\n-    sc->tinst = NULL;\n-    sc->minst = NULL;\n-\n-    bool errors = false;\n-    bool result = evalStaticCondition(sc, exp, exp, errors);\n-    sc = sc->pop();\n-    if (errors)\n-    {\n-        errorSupplemental(loc, \"while evaluating: static assert(%s)\", exp->toChars());\n-    }\n-    else if (!result)\n-    {\n-        if (msg)\n-        {\n-            sc = sc->startCTFE();\n-            msg = ::semantic(msg, sc);\n-            msg = resolveProperties(sc, msg);\n-            sc = sc->endCTFE();\n-            msg = msg->ctfeInterpret();\n-            if (StringExp * se = msg->toStringExp())\n-            {\n-                // same with pragma(msg)\n-                se = se->toUTF8(sc);\n-                error(\"\\\"%.*s\\\"\", (int)se->len, (char *)se->string);\n-            }\n-            else\n-                error(\"%s\", msg->toChars());\n-        }\n-        else\n-            error(\"(%s) is false\", exp->toChars());\n-        if (sc->tinst)\n-            sc->tinst->printInstantiationTrace();\n-        if (!global.gag)\n-              fatal();\n-    }\n-}\n-\n bool StaticAssert::oneMember(Dsymbol **ps, Identifier *)\n {\n     //printf(\"StaticAssert::oneMember())\\n\");"}, {"sha": "6d43cb73a0d233330ded8947d180c1598c386614", "filename": "gcc/d/dmd/staticassert.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstaticassert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstaticassert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticassert.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -24,8 +24,6 @@ class StaticAssert : public Dsymbol\n \n     Dsymbol *syntaxCopy(Dsymbol *s);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }"}, {"sha": "ef0a35ff38211e4eb424e243566c13e85a25ae50", "filename": "gcc/d/dmd/staticcond.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstaticcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fstaticcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -13,8 +13,6 @@\n #include \"mtype.h\"\n #include \"scope.h\"\n \n-Expression *semantic(Expression *e, Scope *sc);\n-\n /********************************************\n  * Semantically analyze and then evaluate a static condition at compile time.\n  * This is special because short circuit operators &&, || and ?: at the top\n@@ -64,7 +62,7 @@ bool evalStaticCondition(Scope *sc, Expression *exp, Expression *e, bool &errors\n     sc = sc->startCTFE();\n     sc->flags |= SCOPEcondition;\n \n-    e = semantic(e, sc);\n+    e = expressionSemantic(e, sc);\n     e = resolveProperties(sc, e);\n \n     sc = sc->endCTFE();"}, {"sha": "a91880fd0fc86d87a343c1144f9ddc4b166fb4e4", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2013-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2013-2021 by The D Language Foundation, All Rights Reserved\n  * written by Iain Buclaw\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "dac1e85b433ac06f9f818619d8d95f4e0b207f97", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -35,6 +35,10 @@ class Parameter;\n enum MATCH;\n enum PASS;\n \n+bool tpsemantic(TemplateParameter *tp, Scope *sc, TemplateParameters *parameters);\n+RootObject *aliasParameterSemantic(Loc loc, Scope *sc, RootObject *o, TemplateParameters *parameters);\n+void templateInstanceSemantic(TemplateInstance *tempinst, Scope *sc, Expressions *fargs);\n+\n class Tuple : public RootObject\n {\n public:\n@@ -80,7 +84,6 @@ class TemplateDeclaration : public ScopeDsymbol\n     TemplateDeclaration(Loc loc, Identifier *id, TemplateParameters *parameters,\n         Expression *constraint, Dsymbols *decldefs, bool ismixin = false, bool literal = false);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc);\n     bool overloadInsert(Dsymbol *s);\n     bool hasStaticCtorOrDtor();\n     const char *kind() const;\n@@ -145,7 +148,6 @@ class TemplateParameter : public ASTNode\n \n     virtual TemplateParameter *syntaxCopy() = 0;\n     virtual bool declareParameter(Scope *sc) = 0;\n-    virtual bool semantic(Scope *sc, TemplateParameters *parameters) = 0;\n     virtual void print(RootObject *oarg, RootObject *oded) = 0;\n     virtual RootObject *specialization() = 0;\n     virtual RootObject *defaultArg(Loc instLoc, Scope *sc) = 0;\n@@ -179,7 +181,6 @@ class TemplateTypeParameter : public TemplateParameter\n     TemplateTypeParameter *isTemplateTypeParameter();\n     TemplateParameter *syntaxCopy();\n     bool declareParameter(Scope *sc);\n-    bool semantic(Scope *sc, TemplateParameters *parameters);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n     RootObject *defaultArg(Loc instLoc, Scope *sc);\n@@ -220,7 +221,6 @@ class TemplateValueParameter : public TemplateParameter\n     TemplateValueParameter *isTemplateValueParameter();\n     TemplateParameter *syntaxCopy();\n     bool declareParameter(Scope *sc);\n-    bool semantic(Scope *sc, TemplateParameters *parameters);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n     RootObject *defaultArg(Loc instLoc, Scope *sc);\n@@ -248,7 +248,6 @@ class TemplateAliasParameter : public TemplateParameter\n     TemplateAliasParameter *isTemplateAliasParameter();\n     TemplateParameter *syntaxCopy();\n     bool declareParameter(Scope *sc);\n-    bool semantic(Scope *sc, TemplateParameters *parameters);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n     RootObject *defaultArg(Loc instLoc, Scope *sc);\n@@ -269,7 +268,6 @@ class TemplateTupleParameter : public TemplateParameter\n     TemplateTupleParameter *isTemplateTupleParameter();\n     TemplateParameter *syntaxCopy();\n     bool declareParameter(Scope *sc);\n-    bool semantic(Scope *sc, TemplateParameters *parameters);\n     void print(RootObject *oarg, RootObject *oded);\n     RootObject *specialization();\n     RootObject *defaultArg(Loc instLoc, Scope *sc);\n@@ -326,10 +324,6 @@ class TemplateInstance : public ScopeDsymbol\n     TemplateInstance(Loc loc, TemplateDeclaration *tempdecl, Objects *tiargs);\n     static Objects *arraySyntaxCopy(Objects *objs);\n     Dsymbol *syntaxCopy(Dsymbol *);\n-    void semantic(Scope *sc, Expressions *fargs);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n-    void semantic3(Scope *sc);\n     Dsymbol *toAlias();                 // resolve real symbol\n     const char *kind() const;\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n@@ -368,9 +362,6 @@ class TemplateMixin : public TemplateInstance\n \n     TemplateMixin(Loc loc, Identifier *ident, TypeQualified *tqual, Objects *tiargs);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n-    void semantic(Scope *sc);\n-    void semantic2(Scope *sc);\n-    void semantic3(Scope *sc);\n     const char *kind() const;\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     int apply(Dsymbol_apply_ft_t fp, void *param);"}, {"sha": "11cd52e351bff172c8c414eda80530f74f8753a7", "filename": "gcc/d/dmd/templateparamsem.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplateparamsem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -0,0 +1,116 @@\n+\n+/* Compiler implementation of the D programming language\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n+ * written by Walter Bright\n+ * http://www.digitalmars.com\n+ * Distributed under the Boost Software License, Version 1.0.\n+ * http://www.boost.org/LICENSE_1_0.txt\n+ */\n+\n+#include \"template.h\"\n+#include \"mtype.h\"\n+#include \"scope.h\"\n+#include \"visitor.h\"\n+\n+bool reliesOnTident(Type *t, TemplateParameters *tparams = NULL, size_t iStart = 0);\n+\n+class TemplateParameterSemanticVisitor : public Visitor\n+{\n+public:\n+    Scope *sc;\n+    TemplateParameters *parameters;\n+    bool result;\n+\n+    TemplateParameterSemanticVisitor(Scope *sc, TemplateParameters *parameters)\n+    {\n+        this->sc = sc;\n+        this->parameters = parameters;\n+\tthis->result = false;\n+    }\n+\n+    void visit(TemplateTypeParameter *ttp)\n+    {\n+        //printf(\"TemplateTypeParameter::semantic('%s')\\n\", ident->toChars());\n+        if (ttp->specType && !reliesOnTident(ttp->specType, parameters))\n+        {\n+            ttp->specType = typeSemantic(ttp->specType, ttp->loc, sc);\n+        }\n+        result = !(ttp->specType && isError(ttp->specType));\n+    }\n+\n+    void visit(TemplateValueParameter *tvp)\n+    {\n+        tvp->valType = typeSemantic(tvp->valType, tvp->loc, sc);\n+\n+        result = !isError(tvp->valType);\n+    }\n+\n+    void visit(TemplateAliasParameter *tap)\n+    {\n+        if (tap->specType && !reliesOnTident(tap->specType, parameters))\n+        {\n+            tap->specType = typeSemantic(tap->specType, tap->loc, sc);\n+        }\n+        tap->specAlias = aliasParameterSemantic(tap->loc, sc, tap->specAlias, parameters);\n+        result = !(tap->specType  && isError(tap->specType)) &&\n+            !(tap->specAlias && isError(tap->specAlias));\n+    }\n+\n+    void visit(TemplateTupleParameter *)\n+    {\n+        result = true;\n+    }\n+};\n+\n+/************************************************\n+ * Performs semantic on TemplateParameter AST nodes.\n+ *\n+ * Params:\n+ *      tp = element of `parameters` to be semantically analyzed\n+ *      sc = context\n+ *      parameters = array of `TemplateParameters` supplied to the `TemplateDeclaration`\n+ * Returns:\n+ *      `true` if no errors\n+ */\n+bool tpsemantic(TemplateParameter *tp, Scope *sc, TemplateParameters *parameters)\n+{\n+    TemplateParameterSemanticVisitor v(sc, parameters);\n+    tp->accept(&v);\n+    return v.result;\n+}\n+\n+/***********************************************\n+ * Support function for performing semantic analysis on `TemplateAliasParameter`.\n+ *\n+ * Params:\n+ *      loc = location (for error messages)\n+ *      sc = context\n+ *      o = object to run semantic() on, the `TemplateAliasParameter`s `specAlias` or `defaultAlias`\n+ *      parameters = array of `TemplateParameters` supplied to the `TemplateDeclaration`\n+ * Returns:\n+ *      object resulting from running `semantic` on `o`\n+ */\n+RootObject *aliasParameterSemantic(Loc loc, Scope *sc, RootObject *o, TemplateParameters *parameters)\n+{\n+    if (o)\n+    {\n+        Expression *ea = isExpression(o);\n+        Type *ta = isType(o);\n+        if (ta && (!parameters || !reliesOnTident(ta, parameters)))\n+        {\n+            Dsymbol *s = ta->toDsymbol(sc);\n+            if (s)\n+                o = s;\n+            else\n+                o = typeSemantic(ta, loc, sc);\n+        }\n+        else if (ea)\n+        {\n+            sc = sc->startCTFE();\n+            ea = expressionSemantic(ea, sc);\n+            sc = sc->endCTFE();\n+            o = ea->ctfeInterpret();\n+        }\n+    }\n+    return o;\n+}"}, {"sha": "eb06beed9b64ba09637ba2cc16ea7dea2f376b8e", "filename": "gcc/d/dmd/tokens.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftokens.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftokens.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "f79d8419c900d3bc3097c11d615099e66178a640", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "b7c612c2af2868d72ee81c1ca308b543cabe8a4d", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -39,8 +39,6 @@ int ScopeDsymbol_foreach(Scope *sc, Dsymbols *members, ForeachDg dg, void *ctx,\n void freeFieldinit(Scope *sc);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n Package *resolveIsPackage(Dsymbol *sym);\n-Expression *trySemantic(Expression *e, Scope *sc);\n-Expression *semantic(Expression *e, Scope *sc);\n Expression *typeToExpression(Type *t);\n \n \n@@ -803,7 +801,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return f->isNested() ? True(e) : False(e);\n         }\n \n-        e->error(\"aggregate or function expected instead of '%s'\", o->toChars());\n+        e->error(\"aggregate or function expected instead of `%s`\", o->toChars());\n         return new ErrorExp();\n     }\n     else if (e->ident == Id::isDisabled)\n@@ -925,7 +923,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         }\n \n         StringExp *se = new StringExp(e->loc, const_cast<char *>(id->toChars()));\n-        return semantic(se, sc);\n+        return expressionSemantic(se, sc);\n     }\n     else if (e->ident == Id::getProtection || e->ident == Id::getVisibility)\n     {\n@@ -948,12 +946,12 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return new ErrorExp();\n         }\n         if (s->semanticRun == PASSinit)\n-            s->semantic(NULL);\n+            dsymbolSemantic(s, NULL);\n \n         const char *protName = protectionToChars(s->prot().kind);   // TODO: How about package(names)\n         assert(protName);\n         StringExp *se = new StringExp(e->loc, const_cast<char *>(protName));\n-        return semantic(se, sc);\n+        return expressionSemantic(se, sc);\n     }\n     else if (e->ident == Id::parent)\n     {\n@@ -982,15 +980,15 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                 if (td->overroot)       // if not start of overloaded list of TemplateDeclaration's\n                     td = td->overroot;  // then get the start\n                 Expression *ex = new TemplateExp(e->loc, td, f);\n-                ex = semantic(ex, sc);\n+                ex = expressionSemantic(ex, sc);\n                 return ex;\n             }\n \n             if (FuncLiteralDeclaration *fld = f->isFuncLiteralDeclaration())\n             {\n                 // Directly translate to VarExp instead of FuncExp\n                 Expression *ex = new VarExp(e->loc, fld, true);\n-                return semantic(ex, sc);\n+                return expressionSemantic(ex, sc);\n             }\n         }\n \n@@ -1013,7 +1011,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return new ErrorExp();\n         }\n \n-        ex = semantic(ex, sc);\n+        ex = expressionSemantic(ex, sc);\n         RootObject *oc = (*e->args)[1];\n         Dsymbol *symc = getDsymbol(oc);\n         if (!symc)\n@@ -1031,7 +1029,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         else\n             assert(0);\n \n-        ex = semantic(ex, sc);\n+        ex = expressionSemantic(ex, sc);\n         return ex;\n     }\n     else if (e->ident == Id::hasMember ||\n@@ -1120,7 +1118,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             if (ex->op == TOKdotid)\n                 // Prevent semantic() from replacing Symbol with its initializer\n                 ((DotIdExp *)ex)->wantsym = true;\n-            ex = semantic(ex, scx);\n+            ex = expressionSemantic(ex, scx);\n             scx->pop();\n             return ex;\n         }\n@@ -1130,7 +1128,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         {\n             unsigned errors = global.errors;\n             Expression *eorig = ex;\n-            ex = semantic(ex, scx);\n+            ex = expressionSemantic(ex, scx);\n             if (errors < global.errors)\n                 e->error(\"%s cannot be resolved\", eorig->toChars());\n             //ex->print();\n@@ -1193,7 +1191,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                 overloadApply(f, &p, &fptraits);\n \n             ex = new TupleExp(e->loc, exps);\n-            ex = semantic(ex, scx);\n+            ex = expressionSemantic(ex, scx);\n             scx->pop();\n             return ex;\n         }\n@@ -1243,7 +1241,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         if (ad->aliasthis)\n             exps->push(new StringExp(e->loc, const_cast<char *>(ad->aliasthis->ident->toChars())));\n         Expression *ex = new TupleExp(e->loc, exps);\n-        ex = semantic(ex, sc);\n+        ex = expressionSemantic(ex, sc);\n         return ex;\n     }\n     else if (e->ident == Id::getAttributes)\n@@ -1283,7 +1281,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n         Expressions *exps = udad ? udad->getAttributes() : new Expressions();\n         TupleExp *tup = new TupleExp(e->loc, exps);\n-        return semantic(tup, sc);\n+        return expressionSemantic(tup, sc);\n     }\n     else if (e->ident == Id::getFunctionAttributes)\n     {\n@@ -1308,7 +1306,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         tf->attributesApply(&pa, &PushAttributes::fp, TRUSTformatSystem);\n \n         TupleExp *tup = new TupleExp(e->loc, mods);\n-        return semantic(tup, sc);\n+        return expressionSemantic(tup, sc);\n     }\n     else if (e->ident == Id::isReturnOnStack)\n     {\n@@ -1375,7 +1373,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                 assert(0);\n         }\n         StringExp *se = new StringExp(e->loc, const_cast<char*>(style));\n-        return semantic(se, sc);\n+        return expressionSemantic(se, sc);\n     }\n     else if (e->ident == Id::getParameterStorageClasses)\n     {\n@@ -1464,7 +1462,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             exps->push(new StringExp(e->loc, const_cast<char *>(\"scope\")));\n \n         TupleExp *tup = new TupleExp(e->loc, exps);\n-        return semantic(tup, sc);\n+        return expressionSemantic(tup, sc);\n     }\n     else if (e->ident == Id::getLinkage)\n     {\n@@ -1512,7 +1510,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         }\n         const char *linkage = linkageToChars(link);\n         StringExp *se = new StringExp(e->loc, const_cast<char *>(linkage));\n-        return semantic(se, sc);\n+        return expressionSemantic(se, sc);\n     }\n     else if (e->ident == Id::allMembers ||\n              e->ident == Id::derivedMembers)\n@@ -1620,7 +1618,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         if (cd && e->ident == Id::allMembers)\n         {\n             if (cd->semanticRun < PASSsemanticdone)\n-                cd->semantic(NULL);    // Bugzilla 13668: Try to resolve forward reference\n+                dsymbolSemantic(cd, NULL);    // Bugzilla 13668: Try to resolve forward reference\n \n             struct PushBaseMembers\n             {\n@@ -1654,7 +1652,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n          *   [ __traits(allMembers, ...) ]\n          */\n         Expression *ex = new TupleExp(e->loc, exps);\n-        ex = semantic(ex, sc);\n+        ex = expressionSemantic(ex, sc);\n         return ex;\n     }\n     else if (e->ident == Id::compiles)\n@@ -1683,7 +1681,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                 t->resolve(e->loc, sc2, &ex, &t, &s);\n                 if (t)\n                 {\n-                    t->semantic(e->loc, sc2);\n+                    typeSemantic(t, e->loc, sc2);\n                     if (t->ty == Terror)\n                         err = true;\n                 }\n@@ -1692,7 +1690,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             }\n             if (ex)\n             {\n-                ex = semantic(ex, sc2);\n+                ex = expressionSemantic(ex, sc2);\n                 ex = resolvePropertiesOnly(sc2, ex);\n                 ex = ex->optimize(WANTvalue);\n                 if (sc2->func && sc2->func->type->ty == Tfunction)\n@@ -1795,7 +1793,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             collectUnitTests(sds->members, uniqueUnitTests, exps);\n         }\n         TupleExp *te= new TupleExp(e->loc, exps);\n-        return semantic(te, sc);\n+        return expressionSemantic(te, sc);\n     }\n     else if (e->ident == Id::getVirtualIndex)\n     {\n@@ -1856,7 +1854,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             e->error(\"`getTargetInfo` key `\\\"%s\\\"` not supported by this implementation\", se->toPtr());\n             return new ErrorExp();\n         }\n-        return semantic(r, sc);\n+        return expressionSemantic(r, sc);\n     }\n     else if (e->ident == Id::getLocation)\n     {\n@@ -1886,13 +1884,13 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         (*exps)[1] = new IntegerExp(e->loc, s->loc.linnum, Type::tint32);\n         (*exps)[2] = new IntegerExp(e->loc, s->loc.charnum, Type::tint32);\n         TupleExp *tup = new TupleExp(e->loc, exps);\n-        return semantic(tup, sc);\n+        return expressionSemantic(tup, sc);\n     }\n \n     if (const char *sub = (const char *)speller(e->ident->toChars(), &trait_search_fp, NULL, idchars))\n-        e->error(\"unrecognized trait '%s', did you mean '%s'?\", e->ident->toChars(), sub);\n+        e->error(\"unrecognized trait `%s`, did you mean `%s`?\", e->ident->toChars(), sub);\n     else\n-        e->error(\"unrecognized trait '%s'\", e->ident->toChars());\n+        e->error(\"unrecognized trait `%s`\", e->ident->toChars());\n     return new ErrorExp();\n \n     e->error(\"wrong number of arguments %d\", (int)dim);"}, {"sha": "496cfe3a8559bfb0ea5c634dc249501ae5436372", "filename": "gcc/d/dmd/typesem.c", "status": "modified", "additions": 1271, "deletions": 1, "changes": 1272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftypesem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Ftypesem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,18 +1,31 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt\n  */\n \n+#include \"root/dsystem.h\"\n+#include \"root/checkedint.h\"\n+\n #include \"mtype.h\"\n+#include \"aggregate.h\"\n+#include \"enum.h\"\n+#include \"errors.h\"\n #include \"expression.h\"\n+#include \"hdrgen.h\"\n+#include \"id.h\"\n+#include \"init.h\"\n+#include \"scope.h\"\n+#include \"target.h\"\n #include \"template.h\"\n+#include \"visitor.h\"\n \n Expression *typeToExpression(Type *t);\n Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i = 0);\n+char *MODtoChars(MOD mod);\n \n class TypeToExpressionVisitor : public Visitor\n {\n@@ -121,3 +134,1260 @@ Expression *typeToExpressionHelper(TypeQualified *t, Expression *e, size_t i)\n     }\n     return e;\n }\n+\n+/**************************\n+ * This evaluates exp while setting length to be the number\n+ * of elements in the tuple t.\n+ */\n+static Expression *semanticLength(Scope *sc, Type *t, Expression *exp)\n+{\n+    if (t->ty == Ttuple)\n+    {\n+        ScopeDsymbol *sym = new ArrayScopeSymbol(sc, (TypeTuple *)t);\n+        sym->parent = sc->scopesym;\n+        sc = sc->push(sym);\n+\n+        sc = sc->startCTFE();\n+        exp = expressionSemantic(exp, sc);\n+        sc = sc->endCTFE();\n+\n+        sc->pop();\n+    }\n+    else\n+    {\n+        sc = sc->startCTFE();\n+        exp = expressionSemantic(exp, sc);\n+        sc = sc->endCTFE();\n+    }\n+\n+    return exp;\n+}\n+\n+static Expression *semanticLength(Scope *sc, TupleDeclaration *s, Expression *exp)\n+{\n+    ScopeDsymbol *sym = new ArrayScopeSymbol(sc, s);\n+    sym->parent = sc->scopesym;\n+    sc = sc->push(sym);\n+\n+    sc = sc->startCTFE();\n+    exp = expressionSemantic(exp, sc);\n+    sc = sc->endCTFE();\n+\n+    sc->pop();\n+    return exp;\n+}\n+\n+/******************************************\n+ * Perform semantic analysis on a type.\n+ * Params:\n+ *      type = Type AST node\n+ *      loc = the location of the type\n+ *      sc = context\n+ * Returns:\n+ *      `Type` with completed semantic analysis, `Terror` if errors\n+ *      were encountered\n+ */\n+Type *typeSemantic(Type *type, const Loc &loc, Scope *sc)\n+{\n+    class TypeSemanticVisitor : public Visitor\n+    {\n+    public:\n+        Loc loc;\n+        Scope *sc;\n+        Type *result;\n+\n+        TypeSemanticVisitor(const Loc &loc, Scope *sc)\n+        {\n+            this->loc = loc;\n+            this->sc = sc;\n+            this->result = NULL;\n+        }\n+\n+    private:\n+        void error()\n+        {\n+            result = Type::terror;\n+        }\n+\n+    public:\n+        void visit(Type *t)\n+        {\n+            if (t->ty == Tint128 || t->ty == Tuns128)\n+            {\n+                ::error(loc, \"cent and ucent types not implemented\");\n+                return error();\n+            }\n+\n+            result = t->merge();\n+        }\n+\n+        void visit(TypeVector *mtype)\n+        {\n+            unsigned int errors = global.errors;\n+            mtype->basetype = typeSemantic(mtype->basetype, loc, sc);\n+            if (errors != global.errors)\n+                return error();\n+            mtype->basetype = mtype->basetype->toBasetype()->mutableOf();\n+            if (mtype->basetype->ty != Tsarray)\n+            {\n+                ::error(loc, \"T in __vector(T) must be a static array, not %s\", mtype->basetype->toChars());\n+                return error();\n+            }\n+            TypeSArray *t = (TypeSArray *)mtype->basetype;\n+            int sz = (int)t->size(loc);\n+            switch (target.isVectorTypeSupported(sz, t->nextOf()))\n+            {\n+            case 0: // valid\n+                break;\n+            case 1: // no support at all\n+                ::error(loc, \"SIMD vector types not supported on this platform\");\n+                return error();\n+            case 2: // invalid base type\n+                ::error(loc, \"vector type %s is not supported on this platform\", mtype->toChars());\n+                return error();\n+            case 3: // invalid size\n+                ::error(loc, \"%d byte vector type %s is not supported on this platform\", sz, mtype->toChars());\n+                return error();\n+            default:\n+                assert(0);\n+            }\n+            result = mtype->merge();\n+        }\n+\n+        void visit(TypeSArray *mtype)\n+        {\n+            //printf(\"TypeSArray::semantic() %s\\n\", mtype->toChars());\n+\n+            Type *t;\n+            Expression *e;\n+            Dsymbol *s;\n+            mtype->next->resolve(loc, sc, &e, &t, &s);\n+\n+            if (mtype->dim && s && s->isTupleDeclaration())\n+            {\n+                TupleDeclaration *sd = s->isTupleDeclaration();\n+\n+                mtype->dim = semanticLength(sc, sd, mtype->dim);\n+                mtype->dim = mtype->dim->ctfeInterpret();\n+                if(mtype->dim->op == TOKerror)\n+                    return error();\n+\n+                uinteger_t d = mtype->dim->toUInteger();\n+                if (d >= sd->objects->length)\n+                {\n+                    ::error(loc, \"tuple index %llu exceeds %llu\", (unsigned long long)d, (unsigned long long)sd->objects->length);\n+                    return error();\n+                }\n+\n+                RootObject *o = (*sd->objects)[(size_t)d];\n+                if (o->dyncast() != DYNCAST_TYPE)\n+                {\n+                    ::error(loc, \"%s is not a type\", mtype->toChars());\n+                    return error();\n+                }\n+                result = ((Type *)o)->addMod(mtype->mod);\n+                return;\n+            }\n+\n+            if (t && t->ty == Terror)\n+                return error();\n+\n+            Type *tn = typeSemantic(mtype->next, loc, sc);\n+            if (tn->ty == Terror)\n+                return error();\n+\n+            Type *tbn = tn->toBasetype();\n+            if (mtype->dim)\n+            {\n+                unsigned int errors = global.errors;\n+                mtype->dim = semanticLength(sc, tbn, mtype->dim);\n+                if (errors != global.errors)\n+                    return error();\n+\n+                mtype->dim = mtype->dim->optimize(WANTvalue);\n+                mtype->dim = mtype->dim->ctfeInterpret();\n+                if (mtype->dim->op == TOKerror)\n+                    return error();\n+                errors = global.errors;\n+                dinteger_t d1 = mtype->dim->toInteger();\n+                if (errors != global.errors)\n+                    return error();\n+\n+                mtype->dim = mtype->dim->implicitCastTo(sc, Type::tsize_t);\n+                mtype->dim = mtype->dim->optimize(WANTvalue);\n+                if (mtype->dim->op == TOKerror)\n+                    return error();\n+                errors = global.errors;\n+                dinteger_t d2 = mtype->dim->toInteger();\n+                if (errors != global.errors)\n+                    return error();\n+\n+                if (mtype->dim->op == TOKerror)\n+                    return error();\n+\n+                if (d1 != d2)\n+                {\n+                Loverflow:\n+                    ::error(loc, \"%s size %llu * %llu exceeds 0x%llx size limit for static array\",\n+                          mtype->toChars(), (unsigned long long)tbn->size(loc), (unsigned long long)d1, target.maxStaticDataSize);\n+                    return error();\n+                }\n+\n+                Type *tbx = tbn->baseElemOf();\n+                if ((tbx->ty == Tstruct && !((TypeStruct *)tbx)->sym->members) ||\n+                    (tbx->ty == Tenum && !((TypeEnum *)tbx)->sym->members))\n+                {\n+                    /* To avoid meaningless error message, skip the total size limit check\n+                     * when the bottom of element type is opaque.\n+                     */\n+                }\n+                else if (tbn->isTypeBasic() ||\n+                         tbn->ty == Tpointer ||\n+                         tbn->ty == Tarray ||\n+                         tbn->ty == Tsarray ||\n+                         tbn->ty == Taarray ||\n+                         (tbn->ty == Tstruct && (((TypeStruct *)tbn)->sym->sizeok == SIZEOKdone)) ||\n+                         tbn->ty == Tclass)\n+                {\n+                    /* Only do this for types that don't need to have semantic()\n+                     * run on them for the size, since they may be forward referenced.\n+                     */\n+                    bool overflow = false;\n+                    if (mulu(tbn->size(loc), d2, overflow) >= target.maxStaticDataSize || overflow)\n+                        goto Loverflow;\n+                }\n+            }\n+            switch (tbn->ty)\n+            {\n+                case Ttuple:\n+                {\n+                    // Index the tuple to get the type\n+                    assert(mtype->dim);\n+                    TypeTuple *tt = (TypeTuple *)tbn;\n+                    uinteger_t d = mtype->dim->toUInteger();\n+                    if (d >= tt->arguments->length)\n+                    {\n+                        ::error(loc, \"tuple index %llu exceeds %llu\", (unsigned long long)d, (unsigned long long)tt->arguments->length);\n+                        return error();\n+                    }\n+                    Type *telem = (*tt->arguments)[(size_t)d]->type;\n+                    result = telem->addMod(mtype->mod);\n+                    return;\n+                }\n+                case Tfunction:\n+                case Tnone:\n+                    ::error(loc, \"cannot have array of %s\", tbn->toChars());\n+                    return error();\n+                default:\n+                    break;\n+            }\n+            if (tbn->isscope())\n+            {\n+                ::error(loc, \"cannot have array of scope %s\", tbn->toChars());\n+                return error();\n+            }\n+\n+            /* Ensure things like const(immutable(T)[3]) become immutable(T[3])\n+             * and const(T)[3] become const(T[3])\n+             */\n+            mtype->next = tn;\n+            mtype->transitive();\n+            result = mtype->addMod(tn->mod)->merge();\n+        }\n+\n+        void visit(TypeDArray *mtype)\n+        {\n+            Type *tn = typeSemantic(mtype->next, loc,sc);\n+            Type *tbn = tn->toBasetype();\n+            switch (tbn->ty)\n+            {\n+                case Ttuple:\n+                    result = tbn;\n+                    return;\n+                case Tfunction:\n+                case Tnone:\n+                    ::error(loc, \"cannot have array of %s\", tbn->toChars());\n+                    return error();\n+                case Terror:\n+                    return error();\n+                default:\n+                    break;\n+            }\n+            if (tn->isscope())\n+            {\n+                ::error(loc, \"cannot have array of scope %s\", tn->toChars());\n+                return error();\n+            }\n+            mtype->next = tn;\n+            mtype->transitive();\n+            result = mtype->merge();\n+        }\n+\n+        void visit(TypeAArray *mtype)\n+        {\n+            //printf(\"TypeAArray::semantic() %s index->ty = %d\\n\", mtype->toChars(), mtype->index->ty);\n+            if (mtype->deco)\n+            {\n+                result = mtype;\n+                return;\n+            }\n+\n+            mtype->loc = loc;\n+            mtype->sc = sc;\n+            if (sc)\n+                sc->setNoFree();\n+\n+            // Deal with the case where we thought the index was a type, but\n+            // in reality it was an expression.\n+            if (mtype->index->ty == Tident || mtype->index->ty == Tinstance || mtype->index->ty == Tsarray ||\n+                mtype->index->ty == Ttypeof || mtype->index->ty == Treturn)\n+            {\n+                Expression *e;\n+                Type *t;\n+                Dsymbol *s;\n+\n+                mtype->index->resolve(loc, sc, &e, &t, &s);\n+                if (e)\n+                {\n+                    // It was an expression -\n+                    // Rewrite as a static array\n+                    TypeSArray *tsa = new TypeSArray(mtype->next, e);\n+                    result = typeSemantic(tsa, loc, sc);\n+                    return;\n+                }\n+                else if (t)\n+                    mtype->index = typeSemantic(t, loc, sc);\n+                else\n+                {\n+                    mtype->index->error(loc, \"index is not a type or an expression\");\n+                    return error();\n+                }\n+            }\n+            else\n+                mtype->index = typeSemantic(mtype->index, loc,sc);\n+            mtype->index = mtype->index->merge2();\n+\n+            if (mtype->index->nextOf() && !mtype->index->nextOf()->isImmutable())\n+            {\n+                mtype->index = mtype->index->constOf()->mutableOf();\n+            }\n+\n+            switch (mtype->index->toBasetype()->ty)\n+            {\n+                case Tfunction:\n+                case Tvoid:\n+                case Tnone:\n+                case Ttuple:\n+                    ::error(loc, \"cannot have associative array key of %s\", mtype->index->toBasetype()->toChars());\n+                    /* fall through */\n+                case Terror:\n+                    return error();\n+                default:\n+                    break;\n+            }\n+            Type *tbase = mtype->index->baseElemOf();\n+            while (tbase->ty == Tarray)\n+                tbase = tbase->nextOf()->baseElemOf();\n+            if (tbase->ty == Tstruct)\n+            {\n+                /* AA's need typeid(index).equals() and getHash(). Issue error if not correctly set up.\n+                 */\n+                StructDeclaration *sd = ((TypeStruct *)tbase)->sym;\n+                if (sd->semanticRun < PASSsemanticdone)\n+                    dsymbolSemantic(sd, NULL);\n+\n+                // duplicate a part of StructDeclaration::semanticTypeInfoMembers\n+                //printf(\"AA = %s, key: xeq = %p, xerreq = %p xhash = %p\\n\", mtype->toChars(), sd->xeq, sd->xerreq, sd->xhash);\n+                if (sd->xeq &&\n+                    sd->xeq->_scope &&\n+                    sd->xeq->semanticRun < PASSsemantic3done)\n+                {\n+                    unsigned errors = global.startGagging();\n+                    semantic3(sd->xeq, sd->xeq->_scope);\n+                    if (global.endGagging(errors))\n+                        sd->xeq = sd->xerreq;\n+                }\n+\n+                const char *s = (mtype->index->toBasetype()->ty != Tstruct) ? \"bottom of \" : \"\";\n+                if (!sd->xeq)\n+                {\n+                    // If sd->xhash != NULL:\n+                    //   sd or its fields have user-defined toHash.\n+                    //   AA assumes that its result is consistent with bitwise equality.\n+                    // else:\n+                    //   bitwise equality & hashing\n+                }\n+                else if (sd->xeq == sd->xerreq)\n+                {\n+                    if (search_function(sd, Id::eq))\n+                    {\n+                        ::error(loc, \"%sAA key type %s does not have `bool opEquals(ref const %s) const`\",\n+                                s, sd->toChars(), sd->toChars());\n+                    }\n+                    else\n+                    {\n+                        ::error(loc, \"%sAA key type %s does not support const equality\",\n+                                s, sd->toChars());\n+                    }\n+                    return error();\n+                }\n+                else if (!sd->xhash)\n+                {\n+                    if (search_function(sd, Id::eq))\n+                    {\n+                        ::error(loc, \"%sAA key type %s should have `size_t toHash() const nothrow @safe` if opEquals defined\",\n+                                s, sd->toChars());\n+                    }\n+                    else\n+                    {\n+                        ::error(loc, \"%sAA key type %s supports const equality but doesn't support const hashing\",\n+                                s, sd->toChars());\n+                    }\n+                    return error();\n+                }\n+                else\n+                {\n+                    // defined equality & hashing\n+                    assert(sd->xeq && sd->xhash);\n+\n+                    /* xeq and xhash may be implicitly defined by compiler. For example:\n+                     *   struct S { int[] arr; }\n+                     * With 'arr' field equality and hashing, compiler will implicitly\n+                     * generate functions for xopEquals and xtoHash in TypeInfo_Struct.\n+                     */\n+                }\n+            }\n+            else if (tbase->ty == Tclass && !((TypeClass *)tbase)->sym->isInterfaceDeclaration())\n+            {\n+                ClassDeclaration *cd = ((TypeClass *)tbase)->sym;\n+                if (cd->semanticRun < PASSsemanticdone)\n+                    dsymbolSemantic(cd, NULL);\n+\n+                if (!ClassDeclaration::object)\n+                {\n+                    ::error(Loc(), \"missing or corrupt object.d\");\n+                    fatal();\n+                }\n+\n+                static FuncDeclaration *feq   = NULL;\n+                static FuncDeclaration *fcmp  = NULL;\n+                static FuncDeclaration *fhash = NULL;\n+                if (!feq)   feq   = search_function(ClassDeclaration::object, Id::eq)->isFuncDeclaration();\n+                if (!fcmp)  fcmp  = search_function(ClassDeclaration::object, Id::cmp)->isFuncDeclaration();\n+                if (!fhash) fhash = search_function(ClassDeclaration::object, Id::tohash)->isFuncDeclaration();\n+                assert(fcmp && feq && fhash);\n+\n+                if (feq->vtblIndex < (int)cd->vtbl.length && cd->vtbl[feq ->vtblIndex] == feq)\n+                {\n+                    if (fcmp->vtblIndex < (int)cd->vtbl.length && cd->vtbl[fcmp->vtblIndex] != fcmp)\n+                    {\n+                        const char *s = (mtype->index->toBasetype()->ty != Tclass) ? \"bottom of \" : \"\";\n+                        ::error(loc, \"%sAA key type %s now requires equality rather than comparison\",\n+                            s, cd->toChars());\n+                        errorSupplemental(loc, \"Please override Object.opEquals and toHash.\");\n+                    }\n+                }\n+            }\n+            mtype->next = typeSemantic(mtype->next, loc,sc)->merge2();\n+            mtype->transitive();\n+\n+            switch (mtype->next->toBasetype()->ty)\n+            {\n+                case Tfunction:\n+                case Tvoid:\n+                case Tnone:\n+                case Ttuple:\n+                    ::error(loc, \"cannot have associative array of %s\", mtype->next->toChars());\n+                    /* fall through */\n+                case Terror:\n+                    return error();\n+            }\n+            if (mtype->next->isscope())\n+            {\n+                ::error(loc, \"cannot have array of scope %s\", mtype->next->toChars());\n+                return error();\n+            }\n+            result = mtype->merge();\n+        }\n+\n+        void visit(TypePointer *mtype)\n+        {\n+            //printf(\"TypePointer::semantic() %s\\n\", mtype->toChars());\n+            if (mtype->deco)\n+            {\n+                result = mtype;\n+                return;\n+            }\n+            Type *n = typeSemantic(mtype->next, loc, sc);\n+            switch (n->toBasetype()->ty)\n+            {\n+                case Ttuple:\n+                    ::error(loc, \"cannot have pointer to %s\", n->toChars());\n+                    /* fall through */\n+                case Terror:\n+                    return error();\n+                default:\n+                    break;\n+            }\n+            if (n != mtype->next)\n+            {\n+                mtype->deco = NULL;\n+            }\n+            mtype->next = n;\n+            if (mtype->next->ty != Tfunction)\n+            {\n+                mtype->transitive();\n+                result = mtype->merge();\n+                return;\n+            }\n+            mtype->deco = mtype->merge()->deco;\n+            /* Don't return merge(), because arg identifiers and default args\n+             * can be different\n+             * even though the types match\n+             */\n+            result = mtype;\n+        }\n+\n+        void visit(TypeReference *mtype)\n+        {\n+            //printf(\"TypeReference::semantic()\\n\");\n+            Type *n = typeSemantic(mtype->next, loc, sc);\n+            if (n != mtype->next)\n+                mtype->deco = NULL;\n+            mtype->next = n;\n+            mtype->transitive();\n+            result = mtype->merge();\n+        }\n+\n+\n+        void visit(TypeFunction *mtype)\n+        {\n+            if (mtype->deco)                   // if semantic() already run\n+            {\n+                //printf(\"already done\\n\");\n+                result = mtype;\n+                return;\n+            }\n+            //printf(\"TypeFunction::semantic() this = %p\\n\", this);\n+            //printf(\"TypeFunction::semantic() %s, sc->stc = %llx, fargs = %p\\n\", mtype->toChars(), sc->stc, mtype->fargs);\n+\n+            bool errors = false;\n+\n+            if (mtype->inuse > global.recursionLimit)\n+            {\n+                mtype->inuse = 0;\n+                ::error(loc, \"recursive type\");\n+                return error();\n+            }\n+\n+            /* Copy in order to not mess up original.\n+             * This can produce redundant copies if inferring return type,\n+             * as semantic() will get called again on this.\n+             */\n+            TypeFunction *tf = mtype->copy()->toTypeFunction();\n+            if (mtype->parameterList.parameters)\n+            {\n+                tf->parameterList.parameters = mtype->parameterList.parameters->copy();\n+                for (size_t i = 0; i < mtype->parameterList.parameters->length; i++)\n+                {\n+                    void *pp = mem.xmalloc(sizeof(Parameter));\n+                    Parameter *p = (Parameter *)memcpy(pp, (void *)(*mtype->parameterList.parameters)[i],\n+                                                       sizeof(Parameter));\n+                    (*tf->parameterList.parameters)[i] = p;\n+                }\n+            }\n+\n+            if (sc->stc & STCpure)\n+                tf->purity = PUREfwdref;\n+            if (sc->stc & STCnothrow)\n+                tf->isnothrow = true;\n+            if (sc->stc & STCnogc)\n+                tf->isnogc = true;\n+            if (sc->stc & STCref)\n+                tf->isref = true;\n+            if (sc->stc & STCreturn)\n+                tf->isreturn = true;\n+            if (sc->stc & STCscope)\n+                tf->isscope = true;\n+            if (sc->stc & STCscopeinferred)\n+                tf->isscopeinferred = true;\n+            //if ((sc->stc & (STCreturn | STCref)) == STCreturn)\n+            //    tf->isscope = true; // return by itself means 'return scope'\n+\n+            if (tf->trust == TRUSTdefault)\n+            {\n+                if (sc->stc & STCsafe)\n+                    tf->trust = TRUSTsafe;\n+                if (sc->stc & STCsystem)\n+                    tf->trust = TRUSTsystem;\n+                if (sc->stc & STCtrusted)\n+                    tf->trust = TRUSTtrusted;\n+            }\n+\n+            if (sc->stc & STCproperty)\n+                tf->isproperty = true;\n+\n+            tf->linkage = sc->linkage;\n+            bool wildreturn = false;\n+            if (tf->next)\n+            {\n+                sc = sc->push();\n+                sc->stc &= ~(STC_TYPECTOR | STC_FUNCATTR);\n+                tf->next = typeSemantic(tf->next, loc, sc);\n+                sc = sc->pop();\n+                errors |= tf->checkRetType(loc);\n+                if (tf->next->isscope() && !(sc->flags & SCOPEctor))\n+                {\n+                    ::error(loc, \"functions cannot return scope %s\", tf->next->toChars());\n+                    errors = true;\n+                }\n+                if (tf->next->hasWild())\n+                    wildreturn = true;\n+\n+                if (tf->isreturn && !tf->isref && !tf->next->hasPointers())\n+                {\n+                    ::error(loc, \"function type `%s` has `return` but does not return any indirections\", tf->toChars());\n+                }\n+            }\n+\n+            unsigned char wildparams = 0;\n+            if (tf->parameterList.parameters)\n+            {\n+                /* Create a scope for evaluating the default arguments for the parameters\n+                 */\n+                Scope *argsc = sc->push();\n+                argsc->stc = 0;                 // don't inherit storage class\n+                argsc->protection = Prot(Prot::public_);\n+                argsc->func = NULL;\n+\n+                size_t dim = tf->parameterList.length();\n+                for (size_t i = 0; i < dim; i++)\n+                {\n+                    Parameter *fparam = tf->parameterList[i];\n+                    mtype->inuse++;\n+                    fparam->type = typeSemantic(fparam->type, loc, argsc);\n+                    mtype->inuse--;\n+\n+                    if (fparam->type->ty == Terror)\n+                    {\n+                        errors = true;\n+                        continue;\n+                    }\n+\n+                    fparam->type = fparam->type->addStorageClass(fparam->storageClass);\n+\n+                    if (fparam->storageClass & (STCauto | STCalias | STCstatic))\n+                    {\n+                        if (!fparam->type)\n+                            continue;\n+                    }\n+\n+                    Type *t = fparam->type->toBasetype();\n+\n+                    if (t->ty == Tfunction)\n+                    {\n+                        ::error(loc, \"cannot have parameter of function type %s\", fparam->type->toChars());\n+                        errors = true;\n+                    }\n+                    else if (!(fparam->storageClass & (STCref | STCout)) &&\n+                             (t->ty == Tstruct || t->ty == Tsarray || t->ty == Tenum))\n+                    {\n+                        Type *tb2 = t->baseElemOf();\n+                        if ((tb2->ty == Tstruct && !((TypeStruct *)tb2)->sym->members) ||\n+                            (tb2->ty == Tenum && !((TypeEnum *)tb2)->sym->memtype))\n+                        {\n+                            ::error(loc, \"cannot have parameter of opaque type %s by value\", fparam->type->toChars());\n+                            errors = true;\n+                        }\n+                    }\n+                    else if (!(fparam->storageClass & STClazy) && t->ty == Tvoid)\n+                    {\n+                        ::error(loc, \"cannot have parameter of type %s\", fparam->type->toChars());\n+                        errors = true;\n+                    }\n+\n+                    if ((fparam->storageClass & (STCref | STCwild)) == (STCref | STCwild))\n+                    {\n+                        // 'ref inout' implies 'return'\n+                        fparam->storageClass |= STCreturn;\n+                    }\n+\n+                    if (fparam->storageClass & STCreturn)\n+                    {\n+                        if (fparam->storageClass & (STCref | STCout))\n+                        {\n+                            // Disabled for the moment awaiting improvement to allow return by ref\n+                            // to be transformed into return by scope.\n+                            if (0 && !tf->isref)\n+                            {\n+                                StorageClass stc = fparam->storageClass & (STCref | STCout);\n+                                ::error(loc, \"parameter %s is `return %s` but function does not return by ref\",\n+                                    fparam->ident ? fparam->ident->toChars() : \"\",\n+                                    stcToChars(stc));\n+                                errors = true;\n+                            }\n+                        }\n+                        else\n+                        {\n+                            fparam->storageClass |= STCscope;        // 'return' implies 'scope'\n+                            if (tf->isref)\n+                            {\n+                            }\n+                            else if (!tf->isref && tf->next && !tf->next->hasPointers())\n+                            {\n+                                ::error(loc, \"parameter %s is `return` but function does not return any indirections\",\n+                                    fparam->ident ? fparam->ident->toChars() : \"\");\n+                                errors = true;\n+                            }\n+                        }\n+                    }\n+\n+                    if (fparam->storageClass & (STCref | STClazy))\n+                    {\n+                    }\n+                    else if (fparam->storageClass & STCout)\n+                    {\n+                        if (unsigned char m = fparam->type->mod & (MODimmutable | MODconst | MODwild))\n+                        {\n+                            ::error(loc, \"cannot have %s out parameter of type %s\", MODtoChars(m), t->toChars());\n+                            errors = true;\n+                        }\n+                        else\n+                        {\n+                            Type *tv = t;\n+                            while (tv->ty == Tsarray)\n+                                tv = tv->nextOf()->toBasetype();\n+                            if (tv->ty == Tstruct && ((TypeStruct *)tv)->sym->noDefaultCtor)\n+                            {\n+                                ::error(loc, \"cannot have out parameter of type %s because the default construction is disabled\",\n+                                    fparam->type->toChars());\n+                                errors = true;\n+                            }\n+                        }\n+                    }\n+\n+                    if (fparam->storageClass & STCscope && !fparam->type->hasPointers() && fparam->type->ty != Ttuple)\n+                    {\n+                        fparam->storageClass &= ~STCscope;\n+                        if (!(fparam->storageClass & STCref))\n+                            fparam->storageClass &= ~STCreturn;\n+                    }\n+\n+                    if (t->hasWild())\n+                    {\n+                        wildparams |= 1;\n+                        //if (tf->next && !wildreturn)\n+                        //    ::error(loc, \"inout on parameter means inout must be on return type as well (if from D1 code, replace with `ref`)\");\n+                    }\n+\n+                    if (fparam->defaultArg)\n+                    {\n+                        Expression *e = fparam->defaultArg;\n+                        if (fparam->storageClass & (STCref | STCout))\n+                        {\n+                            e = expressionSemantic(e, argsc);\n+                            e = resolveProperties(argsc, e);\n+                        }\n+                        else\n+                        {\n+                            e = inferType(e, fparam->type);\n+                            Initializer *iz = new ExpInitializer(e->loc, e);\n+                            iz = initializerSemantic(iz, argsc, fparam->type, INITnointerpret);\n+                            e = initializerToExpression(iz);\n+                        }\n+                        if (e->op == TOKfunction)               // see Bugzilla 4820\n+                        {\n+                            FuncExp *fe = (FuncExp *)e;\n+                            // Replace function literal with a function symbol,\n+                            // since default arg expression must be copied when used\n+                            // and copying the literal itself is wrong.\n+                            e = new VarExp(e->loc, fe->fd, false);\n+                            e = new AddrExp(e->loc, e);\n+                            e = expressionSemantic(e, argsc);\n+                        }\n+                        e = e->implicitCastTo(argsc, fparam->type);\n+\n+                        // default arg must be an lvalue\n+                        if (fparam->storageClass & (STCout | STCref))\n+                            e = e->toLvalue(argsc, e);\n+\n+                        fparam->defaultArg = e;\n+                        if (e->op == TOKerror)\n+                            errors = true;\n+                    }\n+\n+                    /* If fparam after semantic() turns out to be a tuple, the number of parameters may\n+                     * change.\n+                     */\n+                    if (t->ty == Ttuple)\n+                    {\n+                        /* TypeFunction::parameter also is used as the storage of\n+                         * Parameter objects for FuncDeclaration. So we should copy\n+                         * the elements of TypeTuple::arguments to avoid unintended\n+                         * sharing of Parameter object among other functions.\n+                         */\n+                        TypeTuple *tt = (TypeTuple *)t;\n+                        if (tt->arguments && tt->arguments->length)\n+                        {\n+                            /* Propagate additional storage class from tuple parameters to their\n+                             * element-parameters.\n+                             * Make a copy, as original may be referenced elsewhere.\n+                             */\n+                            size_t tdim = tt->arguments->length;\n+                            Parameters *newparams = new Parameters();\n+                            newparams->setDim(tdim);\n+                            for (size_t j = 0; j < tdim; j++)\n+                            {\n+                                Parameter *narg = (*tt->arguments)[j];\n+\n+                                // Bugzilla 12744: If the storage classes of narg\n+                                // conflict with the ones in fparam, it's ignored.\n+                                StorageClass stc  = fparam->storageClass | narg->storageClass;\n+                                StorageClass stc1 = fparam->storageClass & (STCref | STCout | STClazy);\n+                                StorageClass stc2 =   narg->storageClass & (STCref | STCout | STClazy);\n+                                if (stc1 && stc2 && stc1 != stc2)\n+                                {\n+                                    OutBuffer buf1;  stcToBuffer(&buf1, stc1 | ((stc1 & STCref) ? (fparam->storageClass & STCauto) : 0));\n+                                    OutBuffer buf2;  stcToBuffer(&buf2, stc2);\n+\n+                                    ::error(loc, \"incompatible parameter storage classes `%s` and `%s`\",\n+                                              buf1.peekChars(), buf2.peekChars());\n+                                    errors = true;\n+                                    stc = stc1 | (stc & ~(STCref | STCout | STClazy));\n+                                }\n+\n+                                (*newparams)[j] = new Parameter(\n+                                        stc, narg->type, narg->ident, narg->defaultArg, narg->userAttribDecl);\n+                            }\n+                            fparam->type = new TypeTuple(newparams);\n+                        }\n+                        fparam->storageClass = 0;\n+\n+                        /* Reset number of parameters, and back up one to do this fparam again,\n+                         * now that it is a tuple\n+                         */\n+                        dim = tf->parameterList.length();\n+                        i--;\n+                        continue;\n+                    }\n+\n+                    /* Resolve \"auto ref\" storage class to be either ref or value,\n+                     * based on the argument matching the parameter\n+                     */\n+                    if (fparam->storageClass & STCauto)\n+                    {\n+                        if (mtype->fargs && i < mtype->fargs->length && (fparam->storageClass & STCref))\n+                        {\n+                            Expression *farg = (*mtype->fargs)[i];\n+                            if (farg->isLvalue())\n+                                ;                               // ref parameter\n+                            else\n+                                fparam->storageClass &= ~STCref;        // value parameter\n+                            fparam->storageClass &= ~STCauto;    // Bugzilla 14656\n+                            fparam->storageClass |= STCautoref;\n+                        }\n+                        else\n+                        {\n+                            ::error(loc, \"`auto` can only be used as part of `auto ref` for template function parameters\");\n+                            errors = true;\n+                        }\n+                    }\n+\n+                    // Remove redundant storage classes for type, they are already applied\n+                    fparam->storageClass &= ~(STC_TYPECTOR | STCin);\n+                }\n+                argsc->pop();\n+            }\n+            if (tf->isWild())\n+                wildparams |= 2;\n+\n+            if (wildreturn && !wildparams)\n+            {\n+                ::error(loc, \"inout on return means inout must be on a parameter as well for %s\", mtype->toChars());\n+                errors = true;\n+            }\n+            tf->iswild = wildparams;\n+\n+            if (tf->isproperty && (tf->parameterList.varargs != VARARGnone || tf->parameterList.length() > 2))\n+            {\n+                ::error(loc, \"properties can only have zero, one, or two parameter\");\n+                errors = true;\n+            }\n+\n+            if (tf->parameterList.varargs == VARARGvariadic && tf->linkage != LINKd && tf->parameterList.length() == 0)\n+            {\n+                ::error(loc, \"variadic functions with non-D linkage must have at least one parameter\");\n+                errors = true;\n+            }\n+\n+            if (errors)\n+                return error();\n+\n+            if (tf->next)\n+                tf->deco = tf->merge()->deco;\n+\n+            /* Don't return merge(), because arg identifiers and default args\n+             * can be different\n+             * even though the types match\n+             */\n+            result = tf;\n+        }\n+\n+        void visit(TypeDelegate *mtype)\n+        {\n+            //printf(\"TypeDelegate::semantic() %s\\n\", mtype->toChars());\n+            if (mtype->deco)                   // if semantic() already run\n+            {\n+                //printf(\"already done\\n\");\n+                result = mtype;\n+                return;\n+            }\n+            mtype->next = typeSemantic(mtype->next, loc,sc);\n+            if (mtype->next->ty != Tfunction)\n+                return error();\n+\n+            /* In order to deal with Bugzilla 4028, perhaps default arguments should\n+             * be removed from next before the merge.\n+             */\n+\n+            /* Don't return merge(), because arg identifiers and default args\n+             * can be different\n+             * even though the types match\n+             */\n+            mtype->deco = mtype->merge()->deco;\n+            result = mtype;\n+        }\n+\n+        void visit(TypeTraits *mtype)\n+        {\n+            if (mtype->ty == Terror)\n+            {\n+                result = mtype;\n+                return;\n+            }\n+\n+            const int inAlias = (sc->flags & SCOPEalias) != 0;\n+            if (mtype->exp->ident != Id::allMembers &&\n+                mtype->exp->ident != Id::derivedMembers &&\n+                mtype->exp->ident != Id::getMember &&\n+                mtype->exp->ident != Id::parent &&\n+                mtype->exp->ident != Id::child &&\n+                mtype->exp->ident != Id::getOverloads &&\n+                mtype->exp->ident != Id::getVirtualFunctions &&\n+                mtype->exp->ident != Id::getVirtualMethods &&\n+                mtype->exp->ident != Id::getAttributes &&\n+                mtype->exp->ident != Id::getUnitTests &&\n+                mtype->exp->ident != Id::getAliasThis)\n+            {\n+                static const char *ctxt[2] = {\"as type\", \"in alias\"};\n+                ::error(loc, \"trait `%s` is either invalid or not supported %s\",\n+                        mtype->exp->ident->toChars(), ctxt[inAlias]);\n+                mtype->ty = Terror;\n+                result = mtype;\n+                return;\n+            }\n+\n+            if (Expression *e = semanticTraits(mtype->exp, sc))\n+            {\n+                switch (e->op)\n+                {\n+                case TOKdotvar:\n+                    mtype->sym = ((DotVarExp *)e)->var;\n+                    break;\n+                case TOKvar:\n+                    mtype->sym = ((VarExp *)e)->var;\n+                    break;\n+                case TOKfunction:\n+                {\n+                    FuncExp *fe = (FuncExp *)e;\n+                    if (fe->td)\n+                        mtype->sym = fe->td;\n+                    else\n+                        mtype->sym = fe->fd;\n+                    break;\n+                }\n+                case TOKdottd:\n+                    mtype->sym = ((DotTemplateExp*)e)->td;\n+                    break;\n+                case TOKdsymbol:\n+                    mtype->sym = ((DsymbolExp *)e)->s;\n+                    break;\n+                case TOKtemplate:\n+                    mtype->sym = ((TemplateExp *)e)->td;\n+                    break;\n+                case TOKscope:\n+                    mtype->sym = ((ScopeExp *)e)->sds;\n+                    break;\n+                case TOKtuple:\n+                {\n+                    TupleExp *te = e->toTupleExp();\n+                    Objects *elems = new Objects;\n+                    elems->setDim(te->exps->length);\n+                    for (size_t i = 0; i < elems->length; i++)\n+                    {\n+                        Expression *src = (*te->exps)[i];\n+                        switch (src->op)\n+                        {\n+                        case TOKtype:\n+                            (*elems)[i] = ((TypeExp *)src)->type;\n+                            break;\n+                        case TOKdottype:\n+                            (*elems)[i] = ((DotTypeExp *)src)->type;\n+                            break;\n+                        case TOKoverloadset:\n+                            (*elems)[i] = ((OverExp *)src)->type;\n+                            break;\n+                        default:\n+                            if (Dsymbol *sym = isDsymbol(src))\n+                                (*elems)[i] = sym;\n+                            else\n+                                (*elems)[i] = src;\n+                        }\n+                    }\n+                    TupleDeclaration *td = new TupleDeclaration(e->loc,\n+                        Identifier::generateId(\"__aliastup\"), elems);\n+                    mtype->sym = td;\n+                    break;\n+                }\n+                case TOKdottype:\n+                    result = isType(((DotTypeExp *)e)->sym);\n+                    break;\n+                case TOKtype:\n+                    result = ((TypeExp *)e)->type;\n+                    break;\n+                case TOKoverloadset:\n+                    result = ((OverExp *)e)->type;\n+                    break;\n+                default:\n+                    break;\n+                }\n+            }\n+\n+            if (result)\n+                result = result->addMod(mtype->mod);\n+            if (!inAlias && !result)\n+            {\n+                if (!global.errors)\n+                    ::error(loc, \"`%s` does not give a valid type\", mtype->toChars());\n+                return error();\n+            }\n+        }\n+\n+        void visit(TypeIdentifier *mtype)\n+        {\n+            Type *t;\n+            Expression *e;\n+            Dsymbol *s;\n+\n+            //printf(\"TypeIdentifier::semantic(%s)\\n\", mtype->toChars());\n+            mtype->resolve(loc, sc, &e, &t, &s);\n+            if (t)\n+            {\n+                //printf(\"\\tit's a type %d, %s, %s\\n\", t->ty, t->toChars(), t->deco);\n+                t = t->addMod(mtype->mod);\n+            }\n+            else\n+            {\n+                if (s)\n+                {\n+                    s->error(loc, \"is used as a type\");\n+                    //halt();\n+                }\n+                else\n+                    ::error(loc, \"%s is used as a type\", mtype->toChars());\n+                return error();\n+            }\n+            //t->print();\n+            result = t;\n+        }\n+\n+        void visit(TypeInstance *mtype)\n+        {\n+            Type *t;\n+            Expression *e;\n+            Dsymbol *s;\n+\n+            //printf(\"TypeInstance::semantic(%p, %s)\\n\", this, mtype->toChars());\n+            {\n+                unsigned errors = global.errors;\n+                mtype->resolve(loc, sc, &e, &t, &s);\n+                // if we had an error evaluating the symbol, suppress further errors\n+                if (!t && errors != global.errors)\n+                    return error();\n+            }\n+\n+            if (!t)\n+            {\n+                if (!e && s && s->errors)\n+                {\n+                    // if there was an error evaluating the symbol, it might actually\n+                    // be a type. Avoid misleading error messages.\n+                    ::error(loc, \"%s had previous errors\", mtype->toChars());\n+                }\n+                else\n+                    ::error(loc, \"%s is used as a type\", mtype->toChars());\n+                return error();\n+            }\n+            result = t;\n+        }\n+\n+        void visit(TypeTypeof *mtype)\n+        {\n+            //printf(\"TypeTypeof::semantic() %s\\n\", mtype->toChars());\n+\n+            Expression *e;\n+            Type *t;\n+            Dsymbol *s;\n+            mtype->resolve(loc, sc, &e, &t, &s);\n+            if (s && (t = s->getType()) != NULL)\n+                t = t->addMod(mtype->mod);\n+            if (!t)\n+            {\n+                ::error(loc, \"%s is used as a type\", mtype->toChars());\n+                return error();\n+            }\n+            result = t;\n+        }\n+\n+        void visit(TypeReturn *mtype)\n+        {\n+            //printf(\"TypeReturn::semantic() %s\\n\", mtype->toChars());\n+\n+            Expression *e;\n+            Type *t;\n+            Dsymbol *s;\n+            mtype->resolve(loc, sc, &e, &t, &s);\n+            if (s && (t = s->getType()) != NULL)\n+                t = t->addMod(mtype->mod);\n+            if (!t)\n+            {\n+                ::error(loc, \"%s is used as a type\", mtype->toChars());\n+                return error();\n+            }\n+            result = t;\n+        }\n+\n+        void visit(TypeEnum *mtype)\n+        {\n+            //printf(\"TypeEnum::semantic() %s\\n\", mtype->toChars());\n+            result = mtype->deco ? mtype : mtype->merge();\n+        }\n+\n+        void visit(TypeStruct *mtype)\n+        {\n+            //printf(\"TypeStruct::semantic('%s')\\n\", mtype->sym->toChars());\n+            if (mtype->deco)\n+            {\n+                if (sc && sc->cppmangle != CPPMANGLEdefault)\n+                {\n+                    if (mtype->cppmangle == CPPMANGLEdefault)\n+                        mtype->cppmangle = sc->cppmangle;\n+                    else\n+                        assert(mtype->cppmangle == sc->cppmangle);\n+                }\n+                result = mtype;\n+                return;\n+            }\n+\n+            /* Don't semantic for sym because it should be deferred until\n+             * sizeof needed or its members accessed.\n+             */\n+            // instead, parent should be set correctly\n+            assert(mtype->sym->parent);\n+\n+            if (mtype->sym->type->ty == Terror)\n+                return error();\n+            if (sc)\n+                mtype->cppmangle = sc->cppmangle;\n+            result = mtype->merge();\n+        }\n+\n+        void visit(TypeClass *mtype)\n+        {\n+            //printf(\"TypeClass::semantic(%s)\\n\", mtype->sym->toChars());\n+            if (mtype->deco)\n+            {\n+                if (sc && sc->cppmangle != CPPMANGLEdefault)\n+                {\n+                    if (mtype->cppmangle == CPPMANGLEdefault)\n+                        mtype->cppmangle = sc->cppmangle;\n+                    else\n+                        assert(mtype->cppmangle == sc->cppmangle);\n+                }\n+                result = mtype;\n+                return;\n+            }\n+\n+            /* Don't semantic for sym because it should be deferred until\n+             * sizeof needed or its members accessed.\n+             */\n+            // instead, parent should be set correctly\n+            assert(mtype->sym->parent);\n+\n+            if (mtype->sym->type->ty == Terror)\n+                return error();\n+            if (sc)\n+                mtype->cppmangle = sc->cppmangle;\n+            result = mtype->merge();\n+        }\n+\n+        void visit(TypeTuple *mtype)\n+        {\n+            //printf(\"TypeTuple::semantic(this = %p)\\n\", this);\n+            //printf(\"TypeTuple::semantic() %p, %s\\n\", this, mtype->toChars());\n+            if (!mtype->deco)\n+                mtype->deco = mtype->merge()->deco;\n+\n+            /* Don't return merge(), because a tuple with one type has the\n+             * same deco as that type.\n+             */\n+            result = mtype;\n+        }\n+\n+        void visit(TypeSlice *mtype)\n+        {\n+            //printf(\"TypeSlice::semantic() %s\\n\", mtype->toChars());\n+            Type *tn = typeSemantic(mtype->next, loc, sc);\n+            //printf(\"next: %s\\n\", tn->toChars());\n+\n+            Type *tbn = tn->toBasetype();\n+            if (tbn->ty != Ttuple)\n+            {\n+                ::error(loc, \"can only slice tuple types, not %s\", tbn->toChars());\n+                return error();\n+            }\n+            TypeTuple *tt = (TypeTuple *)tbn;\n+\n+            mtype->lwr = semanticLength(sc, tbn, mtype->lwr);\n+            mtype->lwr = mtype->lwr->ctfeInterpret();\n+            uinteger_t i1 = mtype->lwr->toUInteger();\n+\n+            mtype->upr = semanticLength(sc, tbn, mtype->upr);\n+            mtype->upr = mtype->upr->ctfeInterpret();\n+            uinteger_t i2 = mtype->upr->toUInteger();\n+\n+            if (!(i1 <= i2 && i2 <= tt->arguments->length))\n+            {\n+                ::error(loc, \"slice `[%llu..%llu]` is out of range of [0..%llu]\",\n+                    (unsigned long long)i1, (unsigned long long)i2, (unsigned long long)tt->arguments->length);\n+                return error();\n+            }\n+\n+            mtype->next = tn;\n+            mtype->transitive();\n+\n+            Parameters *args = new Parameters;\n+            args->reserve((size_t)(i2 - i1));\n+            for (size_t i = (size_t)i1; i < (size_t)i2; i++)\n+            {\n+                Parameter *arg = (*tt->arguments)[i];\n+                args->push(arg);\n+            }\n+            Type *t = new TypeTuple(args);\n+            result = typeSemantic(t, loc, sc);\n+        }\n+    };\n+    TypeSemanticVisitor v(loc, sc);\n+    type->accept(&v);\n+    return v.result;\n+}"}, {"sha": "f6b543590f2165602fa3c892010f768f83f2d8bb", "filename": "gcc/d/dmd/utf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Futf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Futf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futf.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2003-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2003-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "b3782afe78b0fc9f4d518376f024c2c1b025c883", "filename": "gcc/d/dmd/utf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Futf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Futf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futf.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2003-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2003-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "c9e632234efdf7c5dbb49072c0ce7fa0fc264e8c", "filename": "gcc/d/dmd/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.c?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0."}, {"sha": "9e7fd5ea75d1cbfbfe142c6fb66ba7df02370578", "filename": "gcc/d/dmd/version.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fversion.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 1999-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 1999-2021 by The D Language Foundation, All Rights Reserved\n  * written by Walter Bright\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n@@ -23,7 +23,6 @@ class DebugSymbol : public Dsymbol\n \n     const char *toChars();\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };\n@@ -39,7 +38,6 @@ class VersionSymbol : public Dsymbol\n \n     const char *toChars();\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n-    void semantic(Scope *sc);\n     const char *kind() const;\n     void accept(Visitor *v) { v->visit(this); }\n };"}, {"sha": "a274e6f083e916faac2a875bb2ef76228831bfd1", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -1,6 +1,6 @@\n \n /* Compiler implementation of the D programming language\n- * Copyright (C) 2013-2020 by The D Language Foundation, All Rights Reserved\n+ * Copyright (C) 2013-2021 by The D Language Foundation, All Rights Reserved\n  * http://www.digitalmars.com\n  * Distributed under the Boost Software License, Version 1.0.\n  * http://www.boost.org/LICENSE_1_0.txt"}, {"sha": "698e7669884bfd87ee426b5a713b1521c645f7ba", "filename": "gcc/d/typeinfo.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Ftypeinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3b38b7781622babb5ca68c621367770a65012fa/gcc%2Fd%2Ftypeinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypeinfo.cc?ref=a3b38b7781622babb5ca68c621367770a65012fa", "patch": "@@ -210,7 +210,7 @@ make_frontend_typeinfo (Identifier *ident, ClassDeclaration *base = NULL)\n   ClassDeclaration *tinfo = ClassDeclaration::create (loc, ident, NULL, NULL,\n \t\t\t\t\t\t      true);\n   tinfo->parent = object_module;\n-  tinfo->semantic (object_module->_scope);\n+  dsymbolSemantic (tinfo, object_module->_scope);\n   tinfo->baseClass = base;\n   /* This is a compiler generated class, and shouldn't be mistaken for being\n      the type declared in the runtime library.  */"}]}