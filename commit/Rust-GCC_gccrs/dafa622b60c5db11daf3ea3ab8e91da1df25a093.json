{"sha": "dafa622b60c5db11daf3ea3ab8e91da1df25a093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFmYTYyMmI2MGM1ZGIxMWRhZjNlYTNhYjhlOTFkYTFkZjI1YTA5Mw==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2004-07-04T16:32:32Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2004-07-04T16:32:32Z"}, "message": "* verify.c: Correct array element access formatting thinko.\n\nFrom-SVN: r84086", "tree": {"sha": "ae575b47b229ab2f8849bb425b7bf3d61793650c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae575b47b229ab2f8849bb425b7bf3d61793650c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dafa622b60c5db11daf3ea3ab8e91da1df25a093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dafa622b60c5db11daf3ea3ab8e91da1df25a093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dafa622b60c5db11daf3ea3ab8e91da1df25a093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dafa622b60c5db11daf3ea3ab8e91da1df25a093/comments", "author": null, "committer": null, "parents": [{"sha": "74fa958ec75a3573b763ffb154dfd4863eb14411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74fa958ec75a3573b763ffb154dfd4863eb14411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74fa958ec75a3573b763ffb154dfd4863eb14411"}], "stats": {"total": 100, "additions": 52, "deletions": 48}, "files": [{"sha": "1c558ae165f7f9e13b6d59eb8b92ce0c80be0802", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dafa622b60c5db11daf3ea3ab8e91da1df25a093/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dafa622b60c5db11daf3ea3ab8e91da1df25a093/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dafa622b60c5db11daf3ea3ab8e91da1df25a093", "patch": "@@ -1,3 +1,7 @@\n+2004-07-04  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* verify.c: Correct array element access formatting thinko.\n+\n 2004-07-04  Ranjit Mathew  <rmathew@hotmail.com>\n \n \t* verify.c: Insert a short blurb at the start referring to the JVMS."}, {"sha": "06f834db29c21630c7ff6179d785e0a80beb1ba9", "filename": "gcc/java/verify.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dafa622b60c5db11daf3ea3ab8e91da1df25a093/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dafa622b60c5db11daf3ea3ab8e91da1df25a093/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=dafa622b60c5db11daf3ea3ab8e91da1df25a093", "patch": "@@ -259,7 +259,7 @@ merge_type_state (tree label)\n       LABEL_TYPE_STATE (label) = vec;\n \n       while (--cur_length >= 0)\n-\tTREE_VEC_ELT (vec, cur_length) = type_map [cur_length];\n+\tTREE_VEC_ELT (vec, cur_length) = type_map[cur_length];\n       return 1;\n     }\n   else\n@@ -278,7 +278,7 @@ merge_type_state (tree label)\n       for (i = 0; i < cur_length; i++)\n \t{\n \t  tree old_type = TREE_VEC_ELT (vec, i);\n-\t  tree new_type = merge_types (old_type, type_map [i]);\n+\t  tree new_type = merge_types (old_type, type_map[i]);\n \t  if (TREE_VEC_ELT (vec, i) != new_type)\n \t    {\n \t      /* If there has been a change, note that since we must re-verify.\n@@ -309,33 +309,33 @@ merge_type_state (tree label)\n static void\n type_stack_dup (int size, int offset)\n {\n-  tree type [4];\n+  tree type[4];\n   int index;\n   for (index = 0;  index < size + offset; index++)\n     {\n-      type [index] = stack_type_map [stack_pointer - 1];\n-      if (type [index] == void_type_node)\n+      type[index] = stack_type_map[stack_pointer - 1];\n+      if (type[index] == void_type_node)\n \t{\n \t  index++;\n-\t  type [index] = stack_type_map [stack_pointer - 2];\n-\t  if (! TYPE_IS_WIDE (type [index]))\n+\t  type[index] = stack_type_map[stack_pointer - 2];\n+\t  if (! TYPE_IS_WIDE (type[index]))\n \t    abort ();\n \t  if (index == size || index == size + offset)\n \t    /* Dup operation splits 64-bit number.  */\n \t    abort ();\n \t}\n-      pop_type (type [index]);\n+      pop_type (type[index]);\n     }\n   for (index = size;  --index >= 0; )\n     {\n-      if (type [index] != void_type_node)\n-\tpush_type (type [index]);\n+      if (type[index] != void_type_node)\n+\tpush_type (type[index]);\n     }\n \n   for (index = size + offset;  --index >= 0; )\n     {\n-      if (type [index] != void_type_node)\n-\tpush_type (type [index]);\n+      if (type[index] != void_type_node)\n+\tpush_type (type[index]);\n     }\n }\n \n@@ -452,16 +452,16 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n   starts = xmalloc (eh_count * sizeof (struct pc_index));\n   for (i = 0; i < eh_count; ++i)\n     {\n-      starts [i].start_pc = GET_u2 (jcf->read_ptr + 8 * i);\n-      starts [i].index = i;\n+      starts[i].start_pc = GET_u2 (jcf->read_ptr + 8 * i);\n+      starts[i].index = i;\n     }\n   qsort (starts, eh_count, sizeof (struct pc_index), start_pc_cmp);\n \n   for (i = 0; i < eh_count; ++i)\n     {\n       int start_pc, end_pc, handler_pc, catch_type;\n \n-      p = jcf->read_ptr + 8 * starts [i].index;\n+      p = jcf->read_ptr + 8 * starts[i].index;\n \n       start_pc = GET_u2 (p);\n       end_pc = GET_u2 (p+2);\n@@ -471,10 +471,10 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n       if (start_pc < 0 || start_pc >= length\n \t  || end_pc < 0 || end_pc > length || start_pc >= end_pc\n \t  || handler_pc < 0 || handler_pc >= length\n-\t  || ! (instruction_bits [start_pc] & BCODE_INSTRUCTION_START)\n+\t  || ! (instruction_bits[start_pc] & BCODE_INSTRUCTION_START)\n \t  || (end_pc < length &&\n-\t     ! (instruction_bits [end_pc] & BCODE_INSTRUCTION_START))\n-\t  || ! (instruction_bits [handler_pc] & BCODE_INSTRUCTION_START))\n+\t     ! (instruction_bits[end_pc] & BCODE_INSTRUCTION_START))\n+\t  || ! (instruction_bits[handler_pc] & BCODE_INSTRUCTION_START))\n \t{\n \t  error (\"bad pc in exception_table\");\n \t  free (starts);\n@@ -486,7 +486,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t   catch_type == 0 ? NULL_TREE\n \t\t   : get_class_constant (jcf, catch_type));\n \n-      instruction_bits [handler_pc] |= BCODE_EXCEPTION_TARGET;\n+      instruction_bits[handler_pc] |= BCODE_EXCEPTION_TARGET;\n     }\n \n   free (starts);\n@@ -497,7 +497,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n       tree type, tmp;\n \n       if (((PC != INVALID_PC\n-\t   && instruction_bits [PC] & BCODE_TARGET) != 0)\n+\t   && instruction_bits[PC] & BCODE_TARGET) != 0)\n \t  || PC == 0)\n \t{\n \t  PUSH_PENDING (lookup_label (PC));\n@@ -553,11 +553,11 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t\t     that were in effect at the jsr.  */\n \t\t\t  for (index = size; --index >= 0; )\n \t\t\t    {\n-\t\t\t      type_map [index]\n+\t\t\t      type_map[index]\n                                 = TREE_VEC_ELT (ret_map, index);\n \n-\t\t\t      if (type_map [index] == TYPE_UNUSED)\n-\t\t\t\ttype_map [index]\n+\t\t\t      if (type_map[index] == TYPE_UNUSED)\n+\t\t\t\ttype_map[index]\n \t\t\t\t  = TREE_VEC_ELT (return_state, index);\n \t\t\t    }\n \t\t\t}\n@@ -595,14 +595,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n       oldpc = PC;\n \n-      if (! (instruction_bits [PC] & BCODE_INSTRUCTION_START) && ! wide)\n+      if (! (instruction_bits[PC] & BCODE_INSTRUCTION_START) && ! wide)\n \tVERIFICATION_ERROR (\"PC not at instruction start\");\n \n-      instruction_bits [PC] |= BCODE_VERIFIED;\n+      instruction_bits[PC] |= BCODE_VERIFIED;\n \n       eh_ranges = find_handler (oldpc);\n \n-      op_code = byte_ops [PC++];\n+      op_code = byte_ops[PC++];\n       switch (op_code)\n \t{\n \t  int is_static, is_putting;\n@@ -616,8 +616,8 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  i = op_code - OPCODE_iconst_0;\n \t  goto push_int;\n \tpush_int:\n-\t  if (byte_ops [PC] == OPCODE_newarray\n-\t      || byte_ops [PC] == OPCODE_anewarray)\n+\t  if (byte_ops[PC] == OPCODE_newarray\n+\t      || byte_ops[PC] == OPCODE_anewarray)\n \t    int_value = i;\n \t  PUSH_TYPE (int_type_node);  break;\n \n@@ -673,13 +673,13 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t>= DECL_MAX_LOCALS (current_function_decl)))\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"invalid local variable index %d in load\");\n-\ttmp = type_map [index];\n+\ttmp = type_map[index];\n \tif (tmp == TYPE_UNKNOWN)\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"loading local variable %d which has unknown type\");\n \telse if (tmp == TYPE_SECOND\n \t    || (TYPE_IS_WIDE (type)\n-\t\t&& type_map [index+1] != void_type_node)\n+\t\t&& type_map[index+1] != void_type_node)\n \t    || (type == ptr_type_node\n \t\t? TREE_CODE (tmp) != POINTER_TYPE\n \t\t: type == int_type_node\n@@ -728,7 +728,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    return 0;\n \t  }\n \tPOP_TYPE_CONV (type, type, NULL);\n-\ttype_map [index] = type;\n+\ttype_map[index] = type;\n \n \t/* If a local variable has changed, we need to reconsider exception\n         handlers.  */\n@@ -739,7 +739,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tfind_local_variable (index, type, oldpc);\n \n         if (TYPE_IS_WIDE (type))\n-          type_map [index+1] = TYPE_SECOND;\n+          type_map[index+1] = TYPE_SECOND;\n \n \t/* ... fall through to note_used ... */\n \tnote_used:\n@@ -821,7 +821,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  wide = 0;\n \t  if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl))\n \t    VERIFICATION_ERROR (\"invalid local variable index in iinc\");\n-\t  tmp = type_map [index];\n+\t  tmp = type_map[index];\n \t  if (tmp == NULL_TREE\n \t      || ! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n \t    VERIFICATION_ERROR (\"invalid local variable type in iinc\");\n@@ -896,7 +896,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  break;\n \n \tcase OPCODE_wide:\n-\t  switch (byte_ops [PC])\n+\t  switch (byte_ops[PC])\n \t    {\n \t    case OPCODE_iload:  case OPCODE_lload:\n \t    case OPCODE_fload:  case OPCODE_dload:  case OPCODE_aload:\n@@ -1011,14 +1011,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    VERIFICATION_ERROR (\"stack underflow (in swap)\");\n \t  else\n \t    {\n-\t      tree type1 = stack_type_map [stack_pointer - 1];\n-\t      tree type2 = stack_type_map [stack_pointer - 2];\n+\t      tree type1 = stack_type_map[stack_pointer - 1];\n+\t      tree type2 = stack_type_map[stack_pointer - 2];\n \n \t      if (type1 == void_type_node || type2 == void_type_node)\n \t\tVERIFICATION_ERROR (\"verifier (swap):  double or long value\");\n \n-\t      stack_type_map [stack_pointer - 2] = type1;\n-\t      stack_type_map [stack_pointer - 1] = type2;\n+\t      stack_type_map[stack_pointer - 2] = type1;\n+\t      stack_type_map[stack_pointer - 1] = type2;\n \t    }\n \t  break;\n \n@@ -1210,7 +1210,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    {\n \t      /* If the previous instruction pushed an int constant,\n \t\t we want to use it. */\n-\t      switch (byte_ops [prevpc])\n+\t      switch (byte_ops[prevpc])\n \t\t{\n \t\tcase OPCODE_iconst_0: case OPCODE_iconst_1:\n \t\tcase OPCODE_iconst_2: case OPCODE_iconst_3:\n@@ -1279,7 +1279,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n \t    while (PC%4)\n \t      {\n-\t        if (byte_ops [PC++])\n+\t        if (byte_ops[PC++])\n \t\t  VERIFICATION_ERROR (\"bad alignment in tableswitch pad\");\n \t      }\n \n@@ -1305,7 +1305,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n \t    while (PC%4)\n \t      {\n-\t        if (byte_ops [PC++])\n+\t        if (byte_ops[PC++])\n \t\t  VERIFICATION_ERROR (\"bad alignment in lookupswitch pad\");\n \t      }\n \n@@ -1400,7 +1400,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\twhile (--len >= 0)\n \t\t  {\n \t\t    if (TREE_VEC_ELT (return_map, len) != TYPE_UNUSED)\n-\t\t      type_map [len] = TREE_VEC_ELT (return_map, len);\n+\t\t      type_map[len] = TREE_VEC_ELT (return_map, len);\n \t\t  }\n \t\tcurrent_subr = LABEL_SUBR_CONTEXT (target);\n \t\tif (RETURN_MAP_ADJUSTED (return_map))\n@@ -1423,7 +1423,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t      wide = 0;\n \t      INVALIDATE_PC;\n \t      if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl)\n-\t\t  || type_map [index] != TYPE_RETURN_ADDR)\n+\t\t  || type_map[index] != TYPE_RETURN_ADDR)\n \t\tVERIFICATION_ERROR (\"invalid ret index\");\n \n \t      /* The next chunk of code is similar to an inlined version of\n@@ -1440,7 +1440,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t  for (index = size;  --index >= 0; )\n \t\t    {\n \t\t      if (TREE_VEC_ELT (ret_map, index) != TYPE_UNUSED)\n-\t\t\tTREE_VEC_ELT (ret_map, index) = type_map [index];\n+\t\t\tTREE_VEC_ELT (ret_map, index) = type_map[index];\n \t\t    }\n \t\t  RETURN_MAP_ADJUSTED (ret_map) = 1;\n \t\t}\n@@ -1453,7 +1453,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t      tree type = TREE_VEC_ELT (ret_map, index);\n \t\t      if (type != TYPE_UNUSED)\n \t\t\t{\n-\t\t\t  type = merge_types (type, type_map [index]);\n+\t\t\t  type = merge_types (type, type_map[index]);\n \t\t\t  TREE_VEC_ELT (ret_map, index) = type;\n \t\t\t  if (type == TYPE_UNKNOWN)\n \t\t\t    {\n@@ -1487,7 +1487,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t{\n \t  int save_stack_pointer = stack_pointer;\n \t  int index = DECL_MAX_LOCALS (current_function_decl);\n-\t  tree save_type = type_map [index];\n+\t  tree save_type = type_map[index];\n \t  tree save_current_subr = current_subr;\n \t  struct eh_range *ranges = find_handler (oldpc);\n \t  stack_pointer = 1;\n@@ -1532,14 +1532,14 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t  if (type == NULL_TREE)  /* a finally handler */\n \t\t    type = throwable_type_node;\n \n-\t\t  type_map [index] = promote_type (type);\n+\t\t  type_map[index] = promote_type (type);\n \n \t\t  PUSH_PENDING (handler);\n \t\t}\n \t    }\n \t  stack_pointer = save_stack_pointer;\n \t  current_subr = save_current_subr;\n-\t  type_map [index] = save_type;\n+\t  type_map[index] = save_type;\n \t  prev_eh_ranges = eh_ranges;\n \t}\n     }"}]}