{"sha": "2f388d2db6113fc8113d983c7370b7c45b1024ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYzODhkMmRiNjExM2ZjODExM2Q5ODNjNzM3MGI3YzQ1YjEwMjRhYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-03-15T15:53:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T15:53:10Z"}, "message": "re PR ada/13470 (64bits Ada bootstrap failure:xnmake etc. crash generating nmake.adb etc.)\n\n2005-03-08  Robert Dewar  <dewar@adacore.com>\n\n\tPR ada/13470\n\n\t* a-stunau.ads, a-stunau.adb:\n\tChange interface to allow efficient (and correct) implementation\n\tThe previous changes to allow extra space in unbounded strings had\n\tleft this interface a bit broken.\n\n\t* a-suteio.adb: Avoid unnecessary use of Get/Set_String\n\n\t* g-spipat.ads, g-spipat.adb: New interface for Get_String\n\tMinor reformatting (function specs)\n\n\t* g-spitbo.adb: New interface for Get_String\n\n\t* g-spitbo.ads: Minor reformatting\n\n\t* a-swunau.ads, a-swunau.adb: New interface for Get_Wide_String\n\n\t* a-szunau.ads, a-szunau.adb: New interface for Get_Wide_Wide_String\n\nFrom-SVN: r96488", "tree": {"sha": "5ce32e503ea5e4af6010553a51d8e39be3fbf801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ce32e503ea5e4af6010553a51d8e39be3fbf801"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f388d2db6113fc8113d983c7370b7c45b1024ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f388d2db6113fc8113d983c7370b7c45b1024ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f388d2db6113fc8113d983c7370b7c45b1024ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f388d2db6113fc8113d983c7370b7c45b1024ab/comments", "author": null, "committer": null, "parents": [{"sha": "798a90555d7d72881c3d81d773328dc4156b4e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798a90555d7d72881c3d81d773328dc4156b4e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798a90555d7d72881c3d81d773328dc4156b4e6e"}], "stats": {"total": 922, "additions": 498, "deletions": 424}, "files": [{"sha": "0dbd3fd48c711dbf2f257c543fca31c75d265c8a", "filename": "gcc/ada/a-stunau.adb", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-stunau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-stunau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunau.adb?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,31 +37,14 @@ package body Ada.Strings.Unbounded.Aux is\n    -- Get_String --\n    ----------------\n \n-   function Get_String (U : Unbounded_String) return String_Access is\n+   procedure Get_String\n+     (U : Unbounded_String;\n+      S : out String_Access;\n+      L : out Natural)\n+   is\n    begin\n-      if U.Last = U.Reference'Length then\n-         return U.Reference;\n-\n-      else\n-         declare\n-            type Unbounded_String_Access is access all Unbounded_String;\n-\n-            U_Ptr : constant Unbounded_String_Access := U'Unrestricted_Access;\n-            --  Unbounded_String is a controlled type which is always passed\n-            --  by reference.  It is always safe to take the pointer to such\n-            --  object here.  This pointer is used to set the U.Reference\n-            --  value which would not be possible otherwise as U is read-only.\n-\n-            Old : String_Access := U.Reference;\n-            Ret : String_Access;\n-\n-         begin\n-            Ret := new String'(U.Reference (1 .. U.Last));\n-            U_Ptr.Reference := Ret;\n-            Free (Old);\n-            return Ret;\n-         end;\n-      end if;\n+      S := U.Reference;\n+      L := U.Last;\n    end Get_String;\n \n    ----------------\n@@ -70,21 +53,13 @@ package body Ada.Strings.Unbounded.Aux is\n \n    procedure Set_String (UP : in out Unbounded_String; S : String) is\n    begin\n-      if UP.Last = S'Length then\n-         UP.Reference.all := S;\n-\n-      else\n-         declare\n-            subtype String_1 is String (1 .. S'Length);\n-            Tmp : String_Access;\n-\n-         begin\n-            Tmp := new String'(String_1 (S));\n-            Finalize (UP);\n-            UP.Reference := Tmp;\n-            UP.Last := UP.Reference'Length;\n-         end;\n+      if S'Length > UP.Last then\n+         Finalize (UP);\n+         UP.Reference := new String (1 .. S'Length);\n       end if;\n+\n+      UP.Reference (1 .. S'Length) := S;\n+      UP.Last := S'Length;\n    end Set_String;\n \n    procedure Set_String (UP : in out Unbounded_String; S : String_Access) is"}, {"sha": "05fbe126623b2c071586e202cd29587187212c7b", "filename": "gcc/ada/a-stunau.ads", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-stunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-stunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-stunau.ads?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -39,19 +39,22 @@\n package Ada.Strings.Unbounded.Aux is\n pragma Preelaborate (Aux);\n \n-   function Get_String (U : Unbounded_String) return String_Access;\n+   procedure Get_String\n+     (U : Unbounded_String;\n+      S : out String_Access;\n+      L : out Natural);\n    pragma Inline (Get_String);\n-   --  This function returns the internal string pointer used in the\n-   --  representation of an unbounded string. There is no copy involved,\n-   --  so the value obtained references the same string as the original\n-   --  unbounded string. The characters of this string may not be modified\n-   --  via the returned pointer, and are valid only as long as the original\n-   --  unbounded string is not modified. Violating either of these two\n-   --  rules results in erroneous execution.\n+   --  This procedure returns the internal string pointer used in the\n+   --  representation of an unbounded string as well as the actual current\n+   --  length (which may be less than S.all'Length because in general there\n+   --  can be extra space assigned). The characters of this string may be\n+   --  not be modified via the returned pointer,  and are valid only as\n+   --  long as the original unbounded string is not accessed or modified.\n    --\n-   --  This function is much more efficient than the use of To_String\n+   --  This procedure is much more efficient than the use of To_String\n    --  since it avoids the need to copy the string. The lower bound of the\n-   --  referenced string returned by this call is always one.\n+   --  referenced string returned by this call is always one, so the actual\n+   --  string data is always accessible as S (1 .. L).\n \n    procedure Set_String (UP : in out Unbounded_String; S : String);\n    pragma Inline (Set_String);"}, {"sha": "2f4c127b71b85908177d59a368021da291dadc70", "filename": "gcc/ada/a-swunau.adb", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-swunau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-swunau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunau.adb?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -37,33 +37,14 @@ package body Ada.Strings.Wide_Unbounded.Aux is\n    -- Get_Wide_String --\n    ---------------------\n \n-   function Get_Wide_String\n-     (U : Unbounded_Wide_String) return Wide_String_Access\n+   procedure Get_Wide_String\n+     (U : Unbounded_Wide_String;\n+      S : out Wide_String_Access;\n+      L : out Natural)\n    is\n    begin\n-      if U.Last = U.Reference'Length then\n-         return U.Reference;\n-\n-      else\n-         declare\n-            type Unbounded_Wide_String_Access is\n-              access all Unbounded_Wide_String;\n-\n-            U_Ptr : constant Unbounded_Wide_String_Access :=\n-                      U'Unrestricted_Access;\n-            --  Unbounded_Wide_String is a controlled type which is always\n-            --  passed by copy it is always safe to take the pointer to such\n-            --  object here. This pointer is used to set the U.Reference value\n-            --  which would not be possible otherwise as U is read-only.\n-\n-            Old : Wide_String_Access := U.Reference;\n-\n-         begin\n-            U_Ptr.Reference := new Wide_String'(U.Reference (1 .. U.Last));\n-            Free (Old);\n-            return U.Reference;\n-         end;\n-      end if;\n+      S := U.Reference;\n+      L := U.Last;\n    end Get_Wide_String;\n \n    ---------------------\n@@ -75,20 +56,13 @@ package body Ada.Strings.Wide_Unbounded.Aux is\n       S  : Wide_String)\n    is\n    begin\n-      if UP.Last = S'Length then\n-         UP.Reference.all := S;\n-\n-      else\n-         declare\n-            subtype String_1 is Wide_String (1 .. S'Length);\n-            Tmp : Wide_String_Access;\n-         begin\n-            Tmp := new Wide_String'(String_1 (S));\n-            Finalize (UP);\n-            UP.Reference := Tmp;\n-            UP.Last := UP.Reference'Length;\n-         end;\n+      if S'Length > UP.Last then\n+         Finalize (UP);\n+         UP.Reference := new Wide_String (1 .. S'Length);\n       end if;\n+\n+      UP.Reference (1 .. S'Length) := S;\n+      UP.Last := S'Length;\n    end Set_Wide_String;\n \n    procedure Set_Wide_String"}, {"sha": "da8bfc02342bad12bf4bd9f28fc9b22b77a5fa45", "filename": "gcc/ada/a-swunau.ads", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-swunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-swunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-swunau.ads?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -39,20 +39,22 @@\n package Ada.Strings.Wide_Unbounded.Aux is\n pragma Preelaborate (Aux);\n \n-   function Get_Wide_String\n-     (U : Unbounded_Wide_String) return Wide_String_Access;\n+   procedure Get_Wide_String\n+     (U : Unbounded_Wide_String;\n+      S : out Wide_String_Access;\n+      L : out Natural);\n    pragma Inline (Get_Wide_String);\n-   --  This function returns the internal string pointer used in the\n-   --  representation of an unbounded string. There is no copy involved,\n-   --  so the value obtained references the same string as the original\n-   --  unbounded string. The characters of this string may not be modified\n-   --  via the returned pointer, and are valid only as long as the original\n-   --  unbounded string is not modified. Violating either of these two\n-   --  rules results in erroneous execution.\n+   --  This procedure returns the internal string pointer used in the\n+   --  representation of an unbounded string as well as the actual current\n+   --  length (which may be less than S.all'Length because in general there\n+   --  can be extra space assigned). The characters of this string may be\n+   --  not be modified via the returned pointer,  and are valid only as\n+   --  long as the original unbounded string is not accessed or modified.\n    --\n-   --  This function is much more efficient than the use of To_Wide_String\n+   --  This procedure is much more efficient than the use of To_Wide_String\n    --  since it avoids the need to copy the string. The lower bound of the\n-   --  referenced string returned by this call is always one.\n+   --  referenced string returned by this call is always one, so the actual\n+   --  string data is always accessible as S (1 .. L).\n \n    procedure Set_Wide_String\n      (UP : in out Unbounded_Wide_String;"}, {"sha": "c022a5b28e3a1ff446426946470b9bf56cf4759a", "filename": "gcc/ada/a-szunau.adb", "status": "modified", "additions": 16, "deletions": 43, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-szunau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-szunau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunau.adb?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -33,63 +33,36 @@\n \n package body Ada.Strings.Wide_Wide_Unbounded.Aux is\n \n-   --------------------------\n+   --------------------\n    -- Get_Wide_Wide_String --\n-   --------------------------\n+   ---------------------\n \n-   function Get_Wide_Wide_String\n-     (U : Unbounded_Wide_Wide_String) return Wide_Wide_String_Access\n+   procedure Get_Wide_Wide_String\n+     (U : Unbounded_Wide_Wide_String;\n+      S : out Wide_Wide_String_Access;\n+      L : out Natural)\n    is\n    begin\n-      if U.Last = U.Reference'Length then\n-         return U.Reference;\n-\n-      else\n-         declare\n-            type Unbounded_Wide_Wide_String_Access is\n-              access all Unbounded_Wide_Wide_String;\n-\n-            U_Ptr : constant Unbounded_Wide_Wide_String_Access :=\n-                      U'Unrestricted_Access;\n-            --  Unbounded_Wide_Wide_String is a controlled type which is always\n-            --  passed by copy it is always safe to take the pointer to such\n-            --  object here. This pointer is used to set the U.Reference value\n-            --  which would not be possible otherwise as U is read-only.\n-\n-            Old : Wide_Wide_String_Access := U.Reference;\n-\n-         begin\n-            U_Ptr.Reference :=\n-              new Wide_Wide_String'(U.Reference (1 .. U.Last));\n-            Free (Old);\n-            return U.Reference;\n-         end;\n-      end if;\n+      S := U.Reference;\n+      L := U.Last;\n    end Get_Wide_Wide_String;\n \n-   --------------------------\n+   ---------------------\n    -- Set_Wide_Wide_String --\n-   --------------------------\n+   ---------------------\n \n    procedure Set_Wide_Wide_String\n      (UP : in out Unbounded_Wide_Wide_String;\n       S  : Wide_Wide_String)\n    is\n    begin\n-      if UP.Last = S'Length then\n-         UP.Reference.all := S;\n-\n-      else\n-         declare\n-            subtype String_1 is Wide_Wide_String (1 .. S'Length);\n-            Tmp : Wide_Wide_String_Access;\n-         begin\n-            Tmp := new Wide_Wide_String'(String_1 (S));\n-            Finalize (UP);\n-            UP.Reference := Tmp;\n-            UP.Last := UP.Reference'Length;\n-         end;\n+      if S'Length > UP.Last then\n+         Finalize (UP);\n+         UP.Reference := new Wide_Wide_String (1 .. S'Length);\n       end if;\n+\n+      UP.Reference (1 .. S'Length) := S;\n+      UP.Last := S'Length;\n    end Set_Wide_Wide_String;\n \n    procedure Set_Wide_Wide_String"}, {"sha": "6333a1e7459b99b19748dcc273ecb7105328054b", "filename": "gcc/ada/a-szunau.ads", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-szunau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fa-szunau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-szunau.ads?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -39,20 +39,22 @@\n package Ada.Strings.Wide_Wide_Unbounded.Aux is\n pragma Preelaborate (Aux);\n \n-   function Get_Wide_Wide_String\n-     (U : Unbounded_Wide_Wide_String) return Wide_Wide_String_Access;\n+   procedure Get_Wide_Wide_String\n+     (U : Unbounded_Wide_Wide_String;\n+      S : out Wide_Wide_String_Access;\n+      L : out Natural);\n    pragma Inline (Get_Wide_Wide_String);\n-   --  This function returns the internal string pointer used in the\n-   --  representation of an unbounded string. There is no copy involved,\n-   --  so the value obtained references the same string as the original\n-   --  unbounded string. The characters of this string may not be modified\n-   --  via the returned pointer, and are valid only as long as the original\n-   --  unbounded string is not modified. Violating either of these two\n-   --  rules results in erroneous execution.\n+   --  This procedure returns the internal string pointer used in the\n+   --  representation of an unbounded string as well as the actual current\n+   --  length (which may be less than S.all'Length because in general there\n+   --  can be extra space assigned). The characters of this string may be\n+   --  not be modified via the returned pointer,  and are valid only as\n+   --  long as the original unbounded string is not accessed or modified.\n    --\n-   --  This function is much more efficient than the use of To_Wide_Wide_String\n+   --  This procedure is more efficient than the use of To_Wide_Wide_String\n    --  since it avoids the need to copy the string. The lower bound of the\n-   --  referenced string returned by this call is always one.\n+   --  referenced string returned by this call is always one, so the actual\n+   --  string data is always accessible as S (1 .. L).\n \n    procedure Set_Wide_Wide_String\n      (UP : in out Unbounded_Wide_Wide_String;"}, {"sha": "6bc5f2480d956f549c8c7b68c4e53e3251fb014b", "filename": "gcc/ada/g-spipat.adb", "status": "modified", "additions": 322, "deletions": 184, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spipat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spipat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.adb?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1998-2004, Ada Core Technologies, Inc.           --\n+--           Copyright (C) 1998-2005, Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2802,25 +2802,28 @@ package body GNAT.Spitbol.Patterns is\n \n    function Match\n      (Subject : VString;\n-      Pat     : Pattern)\n-      return    Boolean\n+      Pat     : Pattern) return Boolean\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       return Start /= 0;\n    end Match;\n \n    function Match\n      (Subject : String;\n-      Pat     : Pattern)\n-      return    Boolean\n+      Pat     : Pattern) return Boolean\n    is\n       Start, Stop : Natural;\n       subtype String1 is String (1 .. Subject'Length);\n@@ -2838,41 +2841,49 @@ package body GNAT.Spitbol.Patterns is\n    function Match\n      (Subject : VString_Var;\n       Pat     : Pattern;\n-      Replace : VString)\n-      return    Boolean\n+      Replace : VString) return Boolean\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       if Start = 0 then\n          return False;\n       else\n+         Get_String (Replace, S, L);\n          Replace_Slice\n-           (Subject'Unrestricted_Access.all,\n-            Start, Stop, Get_String (Replace).all);\n+           (Subject'Unrestricted_Access.all, Start, Stop, S (1 .. L));\n          return True;\n       end if;\n    end Match;\n \n    function Match\n      (Subject : VString_Var;\n       Pat     : Pattern;\n-      Replace : String)\n-      return    Boolean\n+      Replace : String) return Boolean\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       if Start = 0 then\n@@ -2888,15 +2899,19 @@ package body GNAT.Spitbol.Patterns is\n      (Subject : VString;\n       Pat     : Pattern)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n-\n    end Match;\n \n    procedure Match\n@@ -2918,17 +2933,23 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : Pattern;\n       Replace : VString)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       if Start /= 0 then\n-         Replace_Slice (Subject, Start, Stop, Get_String (Replace).all);\n+         Get_String (Replace, S, L);\n+         Replace_Slice (Subject, Start, Stop, S (1 .. L));\n       end if;\n    end Match;\n \n@@ -2937,13 +2958,18 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : Pattern;\n       Replace : String)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       if Start /= 0 then\n@@ -2953,24 +2979,25 @@ package body GNAT.Spitbol.Patterns is\n \n    function Match\n      (Subject : VString;\n-      Pat     : PString)\n-      return    Boolean\n+      Pat     : PString) return Boolean\n    is\n-      Pat_Len : constant Natural       := Pat'Length;\n-      Sub_Len : constant Natural       := Length (Subject);\n-      Sub_Str : constant String_Access := Get_String (Subject);\n+      Pat_Len : constant Natural := Pat'Length;\n+      S       : String_Access;\n+      L       : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Anchored_Mode then\n-         if Pat_Len > Sub_Len then\n+         if Pat_Len > L then\n             return False;\n          else\n-            return Pat = Sub_Str.all (1 .. Pat_Len);\n+            return Pat = S (1 .. Pat_Len);\n          end if;\n \n       else\n-         for J in 1 .. Sub_Len - Pat_Len + 1 loop\n-            if Pat = Sub_Str.all (J .. J + (Pat_Len - 1)) then\n+         for J in 1 .. L - Pat_Len + 1 loop\n+            if Pat = S (J .. J + (Pat_Len - 1)) then\n                return True;\n             end if;\n          end loop;\n@@ -2981,8 +3008,7 @@ package body GNAT.Spitbol.Patterns is\n \n    function Match\n      (Subject : String;\n-      Pat     : PString)\n-      return    Boolean\n+      Pat     : PString) return Boolean\n    is\n       Pat_Len : constant Natural := Pat'Length;\n       Sub_Len : constant Natural := Subject'Length;\n@@ -3010,41 +3036,49 @@ package body GNAT.Spitbol.Patterns is\n    function Match\n      (Subject : VString_Var;\n       Pat     : PString;\n-      Replace : VString)\n-      return    Boolean\n+      Replace : VString) return Boolean\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatchD (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatch  (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       end if;\n \n       if Start = 0 then\n          return False;\n       else\n+         Get_String (Replace, S, L);\n          Replace_Slice\n-           (Subject'Unrestricted_Access.all,\n-            Start, Stop, Get_String (Replace).all);\n+           (Subject'Unrestricted_Access.all, Start, Stop, S (1 .. L));\n          return True;\n       end if;\n    end Match;\n \n    function Match\n      (Subject : VString_Var;\n       Pat     : PString;\n-      Replace : String)\n-      return    Boolean\n+      Replace : String) return Boolean\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatchD (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatch  (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       end if;\n \n       if Start = 0 then\n@@ -3060,13 +3094,18 @@ package body GNAT.Spitbol.Patterns is\n      (Subject : VString;\n       Pat     : PString)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatchD (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatch  (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       end if;\n    end Match;\n \n@@ -3090,17 +3129,23 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : PString;\n       Replace : VString)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatchD (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatch  (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       end if;\n \n       if Start /= 0 then\n-         Replace_Slice (Subject, Start, Stop, Get_String (Replace).all);\n+         Get_String (Replace, S, L);\n+         Replace_Slice (Subject, Start, Stop, S (1 .. L));\n       end if;\n    end Match;\n \n@@ -3109,13 +3154,18 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : PString;\n       Replace : String)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatchD (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, S_To_PE (Pat), 0, Start, Stop);\n+         XMatch  (S (1 .. L), S_To_PE (Pat), 0, Start, Stop);\n       end if;\n \n       if Start /= 0 then\n@@ -3126,16 +3176,20 @@ package body GNAT.Spitbol.Patterns is\n    function Match\n      (Subject : VString_Var;\n       Pat     : Pattern;\n-      Result  : Match_Result_Var)\n-      return    Boolean\n+      Result  : Match_Result_Var) return Boolean\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       if Start = 0 then\n@@ -3155,18 +3209,22 @@ package body GNAT.Spitbol.Patterns is\n       Pat     : Pattern;\n       Result  : out Match_Result)\n    is\n-      Start, Stop : Natural;\n+      Start : Natural;\n+      Stop  : Natural;\n+      S     : String_Access;\n+      L     : Natural;\n \n    begin\n+      Get_String (Subject, S, L);\n+\n       if Debug_Mode then\n-         XMatchD (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatchD (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       else\n-         XMatch  (Get_String (Subject).all, Pat.P, Pat.Stk, Start, Stop);\n+         XMatch  (S (1 .. L), Pat.P, Pat.Stk, Start, Stop);\n       end if;\n \n       if Start = 0 then\n          Result.Var := null;\n-\n       else\n          Result.Var   := Subject'Unrestricted_Access;\n          Result.Start := Start;\n@@ -3302,13 +3360,14 @@ package body GNAT.Spitbol.Patterns is\n      (Result  : in out Match_Result;\n       Replace : VString)\n    is\n+      S : String_Access;\n+      L : Natural;\n+\n    begin\n+      Get_String (Replace, S, L);\n+\n       if Result.Var /= null then\n-         Replace_Slice\n-           (Result.Var.all,\n-            Result.Start,\n-            Result.Stop,\n-            Get_String (Replace).all);\n+         Replace_Slice (Result.Var.all, Result.Start, Result.Stop, S (1 .. L));\n          Result.Var := null;\n       end if;\n    end Replace;\n@@ -3487,7 +3546,6 @@ package body GNAT.Spitbol.Patterns is\n \n    function Str_BF (A : Boolean_Func) return String is\n       function To_A is new Unchecked_Conversion (Boolean_Func, Address);\n-\n    begin\n       return \"BF(\" & Image (To_A (A)) & ')';\n    end Str_BF;\n@@ -3507,7 +3565,6 @@ package body GNAT.Spitbol.Patterns is\n \n    function Str_NF (A : Natural_Func) return String is\n       function To_A is new Unchecked_Conversion (Natural_Func, Address);\n-\n    begin\n       return \"NF(\" & Image (To_A (A)) & ')';\n    end Str_NF;\n@@ -3536,7 +3593,6 @@ package body GNAT.Spitbol.Patterns is\n \n    function Str_VF (A : VString_Func) return String is\n       function To_A is new Unchecked_Conversion (VString_Func, Address);\n-\n    begin\n       return \"VF(\" & Image (To_A (A)) & ')';\n    end Str_VF;\n@@ -3897,12 +3953,15 @@ package body GNAT.Spitbol.Patterns is\n          --  Any (string function case)\n \n          when PC_Any_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             if Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -3914,11 +3973,15 @@ package body GNAT.Spitbol.Patterns is\n          --  Any (string pointer case)\n \n          when PC_Any_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             if Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -4077,12 +4140,15 @@ package body GNAT.Spitbol.Patterns is\n          --  Break (string function case)\n \n          when PC_Break_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -4095,11 +4161,15 @@ package body GNAT.Spitbol.Patterns is\n          --  Break (string pointer case)\n \n          when PC_Break_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -4138,12 +4208,15 @@ package body GNAT.Spitbol.Patterns is\n          --  BreakX (string function case)\n \n          when PC_BreakX_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -4156,11 +4229,15 @@ package body GNAT.Spitbol.Patterns is\n          --  BreakX (string pointer case)\n \n          when PC_BreakX_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -4298,13 +4375,16 @@ package body GNAT.Spitbol.Patterns is\n          --  NotAny (string function case)\n \n          when PC_NotAny_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             if Cursor < Length\n               and then\n-                not Is_In (Subject (Cursor + 1), Str.all)\n+                not Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -4316,12 +4396,16 @@ package body GNAT.Spitbol.Patterns is\n          --  NotAny (string pointer case)\n \n          when PC_NotAny_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             if Cursor < Length\n               and then\n-                not Is_In (Subject (Cursor + 1), Str.all)\n+                not Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -4355,12 +4439,15 @@ package body GNAT.Spitbol.Patterns is\n          --  NSpan (string function case)\n \n          when PC_NSpan_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             while Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             loop\n                Cursor := Cursor + 1;\n             end loop;\n@@ -4371,11 +4458,15 @@ package body GNAT.Spitbol.Patterns is\n          --  NSpan (string pointer case)\n \n          when PC_NSpan_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n             while Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             loop\n                Cursor := Cursor + 1;\n             end loop;\n@@ -4591,13 +4682,17 @@ package body GNAT.Spitbol.Patterns is\n          --  Span (string function case)\n \n          when PC_Span_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n-            P   : Natural := Cursor;\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n+            P : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n+            P := Cursor;\n             while P < Length\n-              and then Is_In (Subject (P + 1), Str.all)\n+              and then Is_In (Subject (P + 1), S (1 .. L))\n             loop\n                P := P + 1;\n             end loop;\n@@ -4613,12 +4708,17 @@ package body GNAT.Spitbol.Patterns is\n          --  Span (string pointer case)\n \n          when PC_Span_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n-            P   : Natural := Cursor;\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n+            P : Natural;\n \n          begin\n+            Get_String (U, S, L);\n+\n+            P := Cursor;\n             while P < Length\n-              and then Is_In (Subject (P + 1), Str.all)\n+              and then Is_In (Subject (P + 1), S (1 .. L))\n             loop\n                P := P + 1;\n             end loop;\n@@ -4710,15 +4810,17 @@ package body GNAT.Spitbol.Patterns is\n          --  String (function case)\n \n          when PC_String_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n-            Len : constant Natural       := Str'Length;\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            if (Length - Cursor) >= Len\n-              and then Str.all = Subject (Cursor + 1 .. Cursor + Len)\n+            Get_String (U, S, L);\n+\n+            if (Length - Cursor) >= L\n+              and then S (1 .. L) = Subject (Cursor + 1 .. Cursor + L)\n             then\n-               Cursor := Cursor + Len;\n+               Cursor := Cursor + L;\n                goto Succeed;\n             else\n                goto Fail;\n@@ -4728,14 +4830,17 @@ package body GNAT.Spitbol.Patterns is\n          --  String (pointer case)\n \n          when PC_String_VP => declare\n-            S   : constant String_Access := Get_String (Node.VP.all);\n-            Len : constant Natural       := S'Length;\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            if (Length - Cursor) >= Len\n-              and then S.all = Subject (Cursor + 1 .. Cursor + Len)\n+            Get_String (U, S, L);\n+\n+            if (Length - Cursor) >= L\n+              and then S (1 .. L) = Subject (Cursor + 1 .. Cursor + L)\n             then\n-               Cursor := Cursor + Len;\n+               Cursor := Cursor + L;\n                goto Succeed;\n             else\n                goto Fail;\n@@ -5251,14 +5356,17 @@ package body GNAT.Spitbol.Patterns is\n          --  Any (string function case)\n \n          when PC_Any_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching Any\", Str.all);\n+            Get_String (U, S, L);\n+\n+            Dout (Img (Node) & \"matching Any\", S (1 .. L));\n \n             if Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -5270,13 +5378,16 @@ package body GNAT.Spitbol.Patterns is\n          --  Any (string pointer case)\n \n          when PC_Any_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching Any\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching Any\", S (1 .. L));\n \n             if Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -5454,14 +5565,16 @@ package body GNAT.Spitbol.Patterns is\n          --  Break (string function case)\n \n          when PC_Break_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching Break\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching Break\", S (1 .. L));\n \n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -5474,13 +5587,16 @@ package body GNAT.Spitbol.Patterns is\n          --  Break (string pointer case)\n \n          when PC_Break_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching Break\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching Break\", S (1 .. L));\n \n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -5523,14 +5639,16 @@ package body GNAT.Spitbol.Patterns is\n          --  BreakX (string function case)\n \n          when PC_BreakX_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching BreakX\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching BreakX\", S (1 .. L));\n \n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -5543,13 +5661,16 @@ package body GNAT.Spitbol.Patterns is\n          --  BreakX (string pointer case)\n \n          when PC_BreakX_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching BreakX\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching BreakX\", S (1 .. L));\n \n             while Cursor < Length loop\n-               if Is_In (Subject (Cursor + 1), Str.all) then\n+               if Is_In (Subject (Cursor + 1), S (1 .. L)) then\n                   goto Succeed;\n                else\n                   Cursor := Cursor + 1;\n@@ -5565,7 +5686,6 @@ package body GNAT.Spitbol.Patterns is\n \n          when PC_BreakX_X =>\n             Dout (Img (Node) & \"extending BreakX\");\n-\n             Cursor := Cursor + 1;\n             goto Succeed;\n \n@@ -5708,15 +5828,17 @@ package body GNAT.Spitbol.Patterns is\n          --  NotAny (string function case)\n \n          when PC_NotAny_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching NotAny\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching NotAny\", S (1 .. L));\n \n             if Cursor < Length\n               and then\n-                not Is_In (Subject (Cursor + 1), Str.all)\n+                not Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -5728,14 +5850,17 @@ package body GNAT.Spitbol.Patterns is\n          --  NotAny (string pointer case)\n \n          when PC_NotAny_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching NotAny\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching NotAny\", S (1 .. L));\n \n             if Cursor < Length\n               and then\n-                not Is_In (Subject (Cursor + 1), Str.all)\n+                not Is_In (Subject (Cursor + 1), S (1 .. L))\n             then\n                Cursor := Cursor + 1;\n                goto Succeed;\n@@ -5773,14 +5898,16 @@ package body GNAT.Spitbol.Patterns is\n          --  NSpan (string function case)\n \n          when PC_NSpan_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching NSpan\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching NSpan\", S (1 .. L));\n \n             while Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             loop\n                Cursor := Cursor + 1;\n             end loop;\n@@ -5791,13 +5918,16 @@ package body GNAT.Spitbol.Patterns is\n          --  NSpan (string pointer case)\n \n          when PC_NSpan_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching NSpan\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching NSpan\", S (1 .. L));\n \n             while Cursor < Length\n-              and then Is_In (Subject (Cursor + 1), Str.all)\n+              and then Is_In (Subject (Cursor + 1), S (1 .. L))\n             loop\n                Cursor := Cursor + 1;\n             end loop;\n@@ -6044,15 +6174,18 @@ package body GNAT.Spitbol.Patterns is\n          --  Span (string function case)\n \n          when PC_Span_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n-            P   : Natural := Cursor;\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n+            P : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching Span\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching Span\", S (1 .. L));\n \n+            P := Cursor;\n             while P < Length\n-              and then Is_In (Subject (P + 1), Str.all)\n+              and then Is_In (Subject (P + 1), S (1 .. L))\n             loop\n                P := P + 1;\n             end loop;\n@@ -6068,14 +6201,18 @@ package body GNAT.Spitbol.Patterns is\n          --  Span (string pointer case)\n \n          when PC_Span_VP => declare\n-            Str : constant String_Access := Get_String (Node.VP.all);\n-            P   : Natural := Cursor;\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n+            P : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching Span\", Str.all);\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching Span\", S (1 .. L));\n \n+            P := Cursor;\n             while P < Length\n-              and then Is_In (Subject (P + 1), Str.all)\n+              and then Is_In (Subject (P + 1), S (1 .. L))\n             loop\n                P := P + 1;\n             end loop;\n@@ -6179,17 +6316,18 @@ package body GNAT.Spitbol.Patterns is\n          --  String (function case)\n \n          when PC_String_VF => declare\n-            U   : constant VString       := Node.VF.all;\n-            Str : constant String_Access := Get_String (U);\n-            Len : constant Natural       := Str'Length;\n+            U : constant VString := Node.VF.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout (Img (Node) & \"matching \" & Image (Str.all));\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching \" & Image (S (1 .. L)));\n \n-            if (Length - Cursor) >= Len\n-              and then Str.all = Subject (Cursor + 1 .. Cursor + Len)\n+            if (Length - Cursor) >= L\n+              and then S (1 .. L) = Subject (Cursor + 1 .. Cursor + L)\n             then\n-               Cursor := Cursor + Len;\n+               Cursor := Cursor + L;\n                goto Succeed;\n             else\n                goto Fail;\n@@ -6199,18 +6337,18 @@ package body GNAT.Spitbol.Patterns is\n          --  String (vstring pointer case)\n \n          when PC_String_VP => declare\n-            S   : constant String_Access := Get_String (Node.VP.all);\n-            Len : constant Natural :=\n-                    Ada.Strings.Unbounded.Length (Node.VP.all);\n+            U : constant VString := Node.VP.all;\n+            S : String_Access;\n+            L : Natural;\n \n          begin\n-            Dout\n-              (Img (Node) & \"matching \" & Image (S.all));\n+            Get_String (U, S, L);\n+            Dout (Img (Node) & \"matching \" & Image (S (1 .. L)));\n \n-            if (Length - Cursor) >= Len\n-              and then S.all = Subject (Cursor + 1 .. Cursor + Len)\n+            if (Length - Cursor) >= L\n+              and then S (1 .. L) = Subject (Cursor + 1 .. Cursor + L)\n             then\n-               Cursor := Cursor + Len;\n+               Cursor := Cursor + L;\n                goto Succeed;\n             else\n                goto Fail;"}, {"sha": "4574da1d589d6660e940392a82ec26dbb2175c38", "filename": "gcc/ada/g-spipat.ads", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spipat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spipat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spipat.ads?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1997-2002 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1997-2005 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -953,23 +953,19 @@ pragma Elaborate_Body (Patterns);\n \n    function Match\n      (Subject : VString;\n-      Pat     : Pattern)\n-      return    Boolean;\n+      Pat     : Pattern) return Boolean;\n \n    function Match\n      (Subject : VString;\n-      Pat     : PString)\n-      return    Boolean;\n+      Pat     : PString) return Boolean;\n \n    function Match\n      (Subject : String;\n-      Pat     : Pattern)\n-      return    Boolean;\n+      Pat     : Pattern) return Boolean;\n \n    function Match\n      (Subject : String;\n-      Pat     : PString)\n-      return    Boolean;\n+      Pat     : PString) return Boolean;\n \n    --  Replacement functions. The subject is matched against the pattern.\n    --  Any immediate or deferred assignments or writes are executed, and\n@@ -980,26 +976,22 @@ pragma Elaborate_Body (Patterns);\n    function Match\n      (Subject : VString_Var;\n       Pat     : Pattern;\n-      Replace : VString)\n-      return    Boolean;\n+      Replace : VString) return Boolean;\n \n    function Match\n      (Subject : VString_Var;\n       Pat     : PString;\n-      Replace : VString)\n-      return    Boolean;\n+      Replace : VString) return Boolean;\n \n    function Match\n      (Subject : VString_Var;\n       Pat     : Pattern;\n-      Replace : String)\n-      return    Boolean;\n+      Replace : String) return Boolean;\n \n    function Match\n      (Subject : VString_Var;\n       Pat     : PString;\n-      Replace : String)\n-      return    Boolean;\n+      Replace : String) return Boolean;\n \n    --  Simple match procedures. The subject is matched against the pattern.\n    --  Any immediate or deferred assignments or writes are executed. No\n@@ -1063,8 +1055,7 @@ pragma Elaborate_Body (Patterns);\n    function Match\n      (Subject : VString_Var;\n       Pat     : Pattern;\n-      Result  : Match_Result_Var)\n-      return    Boolean;\n+      Result  : Match_Result_Var) return Boolean;\n \n    procedure Match\n      (Subject : in out VString;"}, {"sha": "68eec8928422f04712129fae787d617d4e202359", "filename": "gcc/ada/g-spitbo.adb", "status": "modified", "additions": 70, "deletions": 48, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spitbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spitbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spitbo.adb?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---            Copyright (C) 1998-2002 Ada Core Technologies, Inc.           --\n+--            Copyright (C) 1998-2005 Ada Core Technologies, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -79,10 +79,9 @@ package body GNAT.Spitbol is\n    ----------\n \n    function Lpad\n-     (Str  : VString;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString\n+     (Str : VString;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString\n    is\n    begin\n       if Length (Str) >= Len then\n@@ -93,10 +92,9 @@ package body GNAT.Spitbol is\n    end Lpad;\n \n    function Lpad\n-     (Str  : String;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString\n+     (Str : String;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString\n    is\n    begin\n       if Str'Length >= Len then\n@@ -135,25 +133,34 @@ package body GNAT.Spitbol is\n    -------\n \n    function N (Str : VString) return Integer is\n+      S : String_Access;\n+      L : Natural;\n    begin\n-      return Integer'Value (Get_String (Str).all);\n+      Get_String (Str, S, L);\n+      return Integer'Value (S (1 .. L));\n    end N;\n \n    --------------------\n    -- Reverse_String --\n    --------------------\n \n    function Reverse_String (Str : VString) return VString is\n-      Len    : constant Natural       := Length (Str);\n-      Chars  : constant String_Access := Get_String (Str);\n-      Result : String (1 .. Len);\n+      S : String_Access;\n+      L : Natural;\n \n    begin\n-      for J in 1 .. Len loop\n-         Result (J) := Chars (Len + 1 - J);\n-      end loop;\n+      Get_String (Str, S, L);\n \n-      return V (Result);\n+      declare\n+         Result : String (1 .. L);\n+\n+      begin\n+         for J in 1 .. L loop\n+            Result (J) := S (L + 1 - J);\n+         end loop;\n+\n+         return V (Result);\n+      end;\n    end Reverse_String;\n \n    function Reverse_String (Str : String) return VString is\n@@ -168,27 +175,32 @@ package body GNAT.Spitbol is\n    end Reverse_String;\n \n    procedure Reverse_String (Str : in out VString) is\n-      Len    : constant Natural := Length (Str);\n-      Chars  : constant String_Access := Get_String (Str);\n-      Temp   : Character;\n+      S : String_Access;\n+      L : Natural;\n \n    begin\n-      for J in 1 .. Len / 2 loop\n-         Temp := Chars (J);\n-         Chars (J) := Chars (Len + 1 - J);\n-         Chars (Len + 1 - J) := Temp;\n-      end loop;\n+      Get_String (Str, S, L);\n+\n+      declare\n+         Result : String (1 .. L);\n+\n+      begin\n+         for J in 1 .. L loop\n+            Result (J) := S (L + 1 - J);\n+         end loop;\n+\n+         Set_String (Str, Result);\n+      end;\n    end Reverse_String;\n \n    ----------\n    -- Rpad --\n    ----------\n \n    function Rpad\n-     (Str  : VString;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString\n+     (Str : VString;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString\n    is\n    begin\n       if Length (Str) >= Len then\n@@ -199,10 +211,9 @@ package body GNAT.Spitbol is\n    end Rpad;\n \n    function Rpad\n-     (Str  : String;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString\n+     (Str : String;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString\n    is\n    begin\n       if Str'Length >= Len then\n@@ -269,34 +280,33 @@ package body GNAT.Spitbol is\n    function Substr\n      (Str   : VString;\n       Start : Positive;\n-      Len   : Natural)\n-      return  VString\n+      Len   : Natural) return VString\n    is\n+      S : String_Access;\n+      L : Natural;\n+\n    begin\n-      if Start > Length (Str) then\n-         raise Index_Error;\n+      Get_String (Str, S, L);\n \n-      elsif Start + Len - 1 > Length (Str) then\n+      if Start > L then\n+         raise Index_Error;\n+      elsif Start + Len - 1 > L then\n          raise Length_Error;\n-\n       else\n-         return V (Get_String (Str).all (Start .. Start + Len - 1));\n+         return V (S (Start .. Start + Len - 1));\n       end if;\n    end Substr;\n \n    function Substr\n      (Str   : String;\n       Start : Positive;\n-      Len   : Natural)\n-      return  VString\n+      Len   : Natural) return VString\n    is\n    begin\n       if Start > Str'Length then\n          raise Index_Error;\n-\n       elsif Start + Len > Str'Length then\n          raise Length_Error;\n-\n       else\n          return\n            V (Str (Str'First + Start - 1 .. Str'First + Start + Len - 2));\n@@ -446,8 +456,11 @@ package body GNAT.Spitbol is\n       end Delete;\n \n       procedure Delete (T : in out Table; Name  : VString) is\n+         S : String_Access;\n+         L : Natural;\n       begin\n-         Delete (T, Get_String (Name).all);\n+         Get_String (Name, S, L);\n+         Delete (T, S (1 .. L));\n       end Delete;\n \n       procedure Delete (T : in out Table; Name  : String) is\n@@ -569,8 +582,11 @@ package body GNAT.Spitbol is\n       end Get;\n \n       function Get (T : Table; Name : VString) return Value_Type is\n+         S : String_Access;\n+         L : Natural;\n       begin\n-         return Get (T, Get_String (Name).all);\n+         Get_String (Name, S, L);\n+         return Get (T, S (1 .. L));\n       end Get;\n \n       function Get (T : Table; Name : String) return Value_Type is\n@@ -623,8 +639,11 @@ package body GNAT.Spitbol is\n       end Present;\n \n       function Present (T : Table; Name : VString) return Boolean is\n+         S : String_Access;\n+         L : Natural;\n       begin\n-         return Present (T, Get_String (Name).all);\n+         Get_String (Name, S, L);\n+         return Present (T, S (1 .. L));\n       end Present;\n \n       function Present (T : Table; Name : String) return Boolean is\n@@ -656,8 +675,11 @@ package body GNAT.Spitbol is\n       ---------\n \n       procedure Set (T : in out Table; Name : VString; Value : Value_Type) is\n+         S : String_Access;\n+         L : Natural;\n       begin\n-         Set (T, Get_String (Name).all, Value);\n+         Get_String (Name, S, L);\n+         Set (T, S (1 .. L), Value);\n       end Set;\n \n       procedure Set (T : in out Table; Name : Character; Value : Value_Type) is"}, {"sha": "0a96ca57a6ffa46ef849d38755b6e47a514fab66", "filename": "gcc/ada/g-spitbo.ads", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spitbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f388d2db6113fc8113d983c7370b7c45b1024ab/gcc%2Fada%2Fg-spitbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-spitbo.ads?ref=2f388d2db6113fc8113d983c7370b7c45b1024ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---           Copyright (C) 1997-1999 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1997-2005 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -120,15 +120,13 @@ pragma Preelaborate (Spitbol);\n    --  Equivalent to Character'Val (Num)\n \n    function Lpad\n-     (Str  : VString;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString;\n+     (Str : VString;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString;\n    function Lpad\n-     (Str  : String;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString;\n+     (Str : String;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString;\n    --  If the length of Str is greater than or equal to Len, then Str is\n    --  returned unchanged. Otherwise, The value returned is obtained by\n    --  concatenating Length (Str) - Len instances of the Pad character to\n@@ -151,15 +149,13 @@ pragma Preelaborate (Spitbol);\n    --  result overwrites the input argument Str.\n \n    function Rpad\n-     (Str  : VString;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString;\n+     (Str : VString;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString;\n    function Rpad\n-     (Str  : String;\n-      Len  : Natural;\n-      Pad  : Character := ' ')\n-      return VString;\n+     (Str : String;\n+      Len : Natural;\n+      Pad : Character := ' ') return VString;\n    --  If the length of Str is greater than or equal to Len, then Str is\n    --  returned unchanged. Otherwise, The value returned is obtained by\n    --  concatenating Length (Str) - Len instances of the Pad character to\n@@ -178,13 +174,11 @@ pragma Preelaborate (Spitbol);\n    function Substr\n      (Str   : VString;\n       Start : Positive;\n-      Len   : Natural)\n-      return  VString;\n+      Len   : Natural) return  VString;\n    function Substr\n      (Str   : String;\n       Start : Positive;\n-      Len   : Natural)\n-      return  VString;\n+      Len   : Natural) return  VString;\n    --  Returns the substring starting at the given character position (which\n    --  is always counted from the start of the string, regardless of bounds,\n    --  e.g. 2 means starting with the second character of the string), and"}]}