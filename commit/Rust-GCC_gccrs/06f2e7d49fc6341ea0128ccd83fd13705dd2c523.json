{"sha": "06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "node_id": "C_kwDOANBUbNoAKDA2ZjJlN2Q0OWZjNjM0MWVhMDEyOGNjZDgzZmQxMzcwNWRkMmM1MjM", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-12-03T15:25:44Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-12-03T15:25:44Z"}, "message": "sve: combine nested if predicates\n\nThe following example\n\nvoid f5(float * restrict z0, float * restrict z1, float *restrict x,\n\tfloat * restrict y, float c, int n)\n{\n    for (int i = 0; i < n; i++) {\n        float a = x[i];\n        float b = y[i];\n        if (a > b) {\n            z0[i] = a + b;\n            if (a > c) {\n                z1[i] = a - b;\n            }\n        }\n    }\n}\n\ngenerates currently:\n\n        ptrue   p3.b, all\n        ld1w    z1.s, p1/z, [x2, x5, lsl 2]\n        ld1w    z2.s, p1/z, [x3, x5, lsl 2]\n        fcmgt   p0.s, p3/z, z1.s, z0.s\n        fcmgt   p2.s, p1/z, z1.s, z2.s\n        fcmgt   p0.s, p0/z, z1.s, z2.s\n        and     p0.b, p0/z, p1.b, p1.b\n\nThe conditions for a > b and a > c become separate comparisons.\n\nAfter this patch we generate:\n\n        ld1w    z1.s, p0/z, [x2, x5, lsl 2]\n        ld1w    z2.s, p0/z, [x3, x5, lsl 2]\n        fcmgt   p1.s, p0/z, z1.s, z2.s\n        fcmgt   p1.s, p1/z, z1.s, z0.s\n\nWhere the condition a > b && a > c are folded by using the predicate result of\nthe previous compare and thus allows the removal of one of the compares.\n\nWhen never a mask is being generated from an BIT_AND we mask the operands of\nthe and instead and then just AND the result.\n\nThis allows us to be able to CSE the masks and generate the right combination.\nHowever because re-assoc will try to re-order the masks in the & we have to now\nperform a small local CSE on the vectorized loop is vectorization is successful.\n\nNote: This patch series is working incrementally towards generating the most\n      efficient code for this and other loops in small steps.\n\ngcc/ChangeLog:\n\n\t* tree-vect-stmts.c (prepare_load_store_mask): Rename to...\n\t(prepare_vec_mask): ...This and record operations that have already been\n\tmasked.\n\t(vectorizable_call): Use it.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t* tree-vectorizer.h (class _loop_vec_info): Add vec_cond_masked_set.\n\t(vec_cond_masked_set_type, tree_cond_mask_hash): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/sve/pred-combine-and.c: New test.", "tree": {"sha": "b1f63d8af9c2ef415a57ec8f5981e0675e29100d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1f63d8af9c2ef415a57ec8f5981e0675e29100d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7854b908977adce4ff669c4e0332ef868568b7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7854b908977adce4ff669c4e0332ef868568b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7854b908977adce4ff669c4e0332ef868568b7c"}], "stats": {"total": 97, "additions": 82, "deletions": 15}, "files": [{"sha": "ee927346abe518caa3cba397b11dfd1ee7e93630", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pred-combine-and.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-combine-and.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-combine-and.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpred-combine-and.c?ref=06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+void f5(float * restrict z0, float * restrict z1, float *restrict x, float * restrict y, float c, int n)\n+{\n+    for (int i = 0; i < n; i++) {\n+        float a = x[i];\n+        float b = y[i];\n+        if (a > b) {\n+            z0[i] = a + b;\n+            if (a > c) {\n+                z1[i] = a - b;\n+            }\n+        }\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-9]+\\.s, p[0-9]+/z, z[0-9]+\\.s, z[0-9]+\\.s} 2 } } */"}, {"sha": "84c6d9777dbd5147014baa56adf0096e4703eae5", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 55, "deletions": 15, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "patch": "@@ -1795,23 +1795,29 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n /* Return the mask input to a masked load or store.  VEC_MASK is the vectorized\n    form of the scalar mask condition and LOOP_MASK, if nonnull, is the mask\n    that needs to be applied to all loads and stores in a vectorized loop.\n-   Return VEC_MASK if LOOP_MASK is null, otherwise return VEC_MASK & LOOP_MASK.\n+   Return VEC_MASK if LOOP_MASK is null or if VEC_MASK is already masked,\n+   otherwise return VEC_MASK & LOOP_MASK.\n \n    MASK_TYPE is the type of both masks.  If new statements are needed,\n    insert them before GSI.  */\n \n static tree\n-prepare_load_store_mask (tree mask_type, tree loop_mask, tree vec_mask,\n-\t\t\t gimple_stmt_iterator *gsi)\n+prepare_vec_mask (loop_vec_info loop_vinfo, tree mask_type, tree loop_mask,\n+\t\t  tree vec_mask, gimple_stmt_iterator *gsi)\n {\n   gcc_assert (useless_type_conversion_p (mask_type, TREE_TYPE (vec_mask)));\n   if (!loop_mask)\n     return vec_mask;\n \n   gcc_assert (TREE_TYPE (loop_mask) == mask_type);\n+\n+  if (loop_vinfo->vec_cond_masked_set.contains ({ vec_mask, loop_mask }))\n+    return vec_mask;\n+\n   tree and_res = make_temp_ssa_name (mask_type, NULL, \"vec_mask_and\");\n   gimple *and_stmt = gimple_build_assign (and_res, BIT_AND_EXPR,\n \t\t\t\t\t  vec_mask, loop_mask);\n+\n   gsi_insert_before (gsi, and_stmt, GSI_SAME_STMT);\n   return and_res;\n }\n@@ -3568,8 +3574,9 @@ vectorizable_call (vec_info *vinfo,\n \t\t\t  gcc_assert (ncopies == 1);\n \t\t\t  tree mask = vect_get_loop_mask (gsi, masks, vec_num,\n \t\t\t\t\t\t\t  vectype_out, i);\n-\t\t\t  vargs[mask_opno] = prepare_load_store_mask\n-\t\t\t    (TREE_TYPE (mask), mask, vargs[mask_opno], gsi);\n+\t\t\t  vargs[mask_opno] = prepare_vec_mask\n+\t\t\t    (loop_vinfo, TREE_TYPE (mask), mask,\n+\t\t\t     vargs[mask_opno], gsi);\n \t\t\t}\n \n \t\t      gcall *call;\n@@ -3612,8 +3619,8 @@ vectorizable_call (vec_info *vinfo,\n \t      tree mask = vect_get_loop_mask (gsi, masks, ncopies,\n \t\t\t\t\t      vectype_out, j);\n \t      vargs[mask_opno]\n-\t\t= prepare_load_store_mask (TREE_TYPE (mask), mask,\n-\t\t\t\t\t   vargs[mask_opno], gsi);\n+\t\t= prepare_vec_mask (loop_vinfo, TREE_TYPE (mask), mask,\n+\t\t\t\t    vargs[mask_opno], gsi);\n \t    }\n \n \t  gimple *new_stmt;\n@@ -6350,10 +6357,43 @@ vectorizable_operation (vec_info *vinfo,\n \t}\n       else\n \t{\n+\t  tree mask = NULL_TREE;\n+\t  /* When combining two masks check if either of them is elsewhere\n+\t     combined with a loop mask, if that's the case we can mark that the\n+\t     new combined mask doesn't need to be combined with a loop mask.  */\n+\t  if (masked_loop_p && code == BIT_AND_EXPR)\n+\t    {\n+\t      if (loop_vinfo->scalar_cond_masked_set.contains ({ op0,\n+\t\t\t\t\t\t\t\t ncopies}))\n+\t\t{\n+\t\t  mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n+\t\t\t\t\t     vectype, i);\n+\n+\t\t  vop0 = prepare_vec_mask (loop_vinfo, TREE_TYPE (mask), mask,\n+\t\t\t\t\t   vop0, gsi);\n+\t\t}\n+\n+\t      if (loop_vinfo->scalar_cond_masked_set.contains ({ op1,\n+\t\t\t\t\t\t\t\t ncopies }))\n+\t\t{\n+\t\t  mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n+\t\t\t\t\t     vectype, i);\n+\n+\t\t  vop1 = prepare_vec_mask (loop_vinfo, TREE_TYPE (mask), mask,\n+\t\t\t\t\t   vop1, gsi);\n+\t\t}\n+\t    }\n+\n \t  new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n \t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\n+\t  /* Enter the combined value into the vector cond hash so we don't\n+\t     AND it with a loop mask again.  */\n+\t  if (mask)\n+\t    loop_vinfo->vec_cond_masked_set.add ({ new_temp, mask });\n+\n \t  if (vec_cvt_dest)\n \t    {\n \t      new_temp = build1 (VIEW_CONVERT_EXPR, vectype_out, new_temp);\n@@ -8214,8 +8254,8 @@ vectorizable_store (vec_info *vinfo,\n \t    final_mask = vect_get_loop_mask (gsi, loop_masks, ncopies,\n \t\t\t\t\t     vectype, j);\n \t  if (vec_mask)\n-\t    final_mask = prepare_load_store_mask (mask_vectype, final_mask,\n-\t\t\t\t\t\t  vec_mask, gsi);\n+\t    final_mask = prepare_vec_mask (loop_vinfo, mask_vectype,\n+\t\t\t\t\t   final_mask, vec_mask, gsi);\n \n \t  gcall *call;\n \t  if (final_mask)\n@@ -8269,8 +8309,8 @@ vectorizable_store (vec_info *vinfo,\n \t\t\t\t\t\t vec_num * ncopies,\n \t\t\t\t\t\t vectype, vec_num * j + i);\n \t      if (vec_mask)\n-\t\tfinal_mask = prepare_load_store_mask (mask_vectype, final_mask,\n-\t\t\t\t\t\t      vec_mask, gsi);\n+\t\tfinal_mask = prepare_vec_mask (loop_vinfo, mask_vectype,\n+\t\t\t\t\t       final_mask, vec_mask, gsi);\n \n \t      if (memory_access_type == VMAT_GATHER_SCATTER)\n \t\t{\n@@ -9497,8 +9537,8 @@ vectorizable_load (vec_info *vinfo,\n \t    final_mask = vect_get_loop_mask (gsi, loop_masks, ncopies,\n \t\t\t\t\t     vectype, j);\n \t  if (vec_mask)\n-\t    final_mask = prepare_load_store_mask (mask_vectype, final_mask,\n-\t\t\t\t\t\t  vec_mask, gsi);\n+\t    final_mask = prepare_vec_mask (loop_vinfo, mask_vectype,\n+\t\t\t\t\t   final_mask, vec_mask, gsi);\n \n \t  gcall *call;\n \t  if (final_mask)\n@@ -9549,8 +9589,8 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t\t\t\t vec_num * ncopies,\n \t\t\t\t\t\t vectype, vec_num * j + i);\n \t      if (vec_mask)\n-\t\tfinal_mask = prepare_load_store_mask (mask_vectype, final_mask,\n-\t\t\t\t\t\t      vec_mask, gsi);\n+\t\tfinal_mask = prepare_vec_mask (loop_vinfo, mask_vectype,\n+\t\t\t\t\t       final_mask, vec_mask, gsi);\n \n \t      if (i > 0)\n \t\tdataref_ptr = bump_vector_ptr (vinfo, dataref_ptr, ptr_incr,"}, {"sha": "2f6e1e268fb07e9de065ff9c45af87546e565d66", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06f2e7d49fc6341ea0128ccd83fd13705dd2c523/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=06f2e7d49fc6341ea0128ccd83fd13705dd2c523", "patch": "@@ -328,6 +328,12 @@ struct default_hash_traits<scalar_cond_masked_key>\n \n typedef hash_set<scalar_cond_masked_key> scalar_cond_masked_set_type;\n \n+/* Key and map that records association between vector conditions and\n+   corresponding loop mask, and is populated by prepare_vec_mask.  */\n+\n+typedef pair_hash<tree_operand_hash, tree_operand_hash> tree_cond_mask_hash;\n+typedef hash_set<tree_cond_mask_hash> vec_cond_masked_set_type;\n+\n /* Describes two objects whose addresses must be unequal for the vectorized\n    loop to be valid.  */\n typedef std::pair<tree, tree> vec_object_pair;\n@@ -647,6 +653,9 @@ typedef class _loop_vec_info : public vec_info {\n   /* Set of scalar conditions that have loop mask applied.  */\n   scalar_cond_masked_set_type scalar_cond_masked_set;\n \n+  /* Set of vector conditions that have loop mask applied.  */\n+  vec_cond_masked_set_type vec_cond_masked_set;\n+\n   /* If we are using a loop mask to align memory addresses, this variable\n      contains the number of vector elements that we should skip in the\n      first iteration of the vector loop (i.e. the number of leading"}]}