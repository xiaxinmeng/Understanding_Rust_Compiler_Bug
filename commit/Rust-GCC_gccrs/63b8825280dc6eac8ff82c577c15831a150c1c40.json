{"sha": "63b8825280dc6eac8ff82c577c15831a150c1c40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNiODgyNTI4MGRjNmVhYzhmZjgyYzU3N2MxNTgzMWExNTBjMWM0MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-07T20:16:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-07T20:16:00Z"}, "message": "tree-flow-inline.h (may_propagate_copy): Move...\n\n        * tree-flow-inline.h (may_propagate_copy): Move...\n        * tree-ssa-copy.c (may_propagate_copy): ... here.  Fail if we\n        attempt to copy between types requiring conversion.\n        * tree-flow.h (may_propagate_copy): Update decl.\n        * tree-ssa-dom.c (cprop_operand): Tidy redundant tests.\n\nFrom-SVN: r84225", "tree": {"sha": "c942eab68cbe4fd2928d53b1721538ff35b54f5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c942eab68cbe4fd2928d53b1721538ff35b54f5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63b8825280dc6eac8ff82c577c15831a150c1c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b8825280dc6eac8ff82c577c15831a150c1c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b8825280dc6eac8ff82c577c15831a150c1c40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b8825280dc6eac8ff82c577c15831a150c1c40/comments", "author": null, "committer": null, "parents": [{"sha": "6c4918da7335aa1a76ad468594762cffbef822a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c4918da7335aa1a76ad468594762cffbef822a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c4918da7335aa1a76ad468594762cffbef822a7"}], "stats": {"total": 222, "additions": 118, "deletions": 104}, "files": [{"sha": "659885e4d7d0f4e9754682aecf512bb2e75456c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63b8825280dc6eac8ff82c577c15831a150c1c40", "patch": "@@ -1,3 +1,11 @@\n+2004-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-flow-inline.h (may_propagate_copy): Move...\n+\t* tree-ssa-copy.c (may_propagate_copy): ... here.  Fail if we\n+\tattempt to copy between types requiring conversion.\n+\t* tree-flow.h (may_propagate_copy): Update decl.\n+\t* tree-ssa-dom.c (cprop_operand): Tidy redundant tests.\n+\n 2004-07-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (override_options): Don't set x86_prefetch_sse"}, {"sha": "e68e63eb8ed7f75888ca256c6d3b3e505ddd0790", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=63b8825280dc6eac8ff82c577c15831a150c1c40", "patch": "@@ -467,97 +467,6 @@ is_label_stmt (tree t)\n   return false;\n }\n \n-/* Return true if we may propagate ORIG into DEST, false otherwise.  */\n-static inline bool\n-may_propagate_copy (tree dest, tree orig)\n-{\n-  /* FIXME.  GIMPLE is allowing pointer assignments and comparisons of\n-     pointers that have different alias sets.  This means that these\n-     pointers will have different memory tags associated to them.\n-     \n-     If we allow copy propagation in these cases, statements de-referencing\n-     the new pointer will now have a reference to a different memory tag\n-     with potentially incorrect SSA information.\n-\n-     This was showing up in libjava/java/util/zip/ZipFile.java with code\n-     like:\n-\n-     \tstruct java.io.BufferedInputStream *T.660;\n-\tstruct java.io.BufferedInputStream *T.647;\n-\tstruct java.io.InputStream *is;\n-\tstruct java.io.InputStream *is.662;\n-\t[ ... ]\n-\tT.660 = T.647;\n-\tis = T.660;\t<-- This ought to be type-casted\n-\tis.662 = is;\n-\n-     Also, f/name.c exposed a similar problem with a COND_EXPR predicate\n-     that was causing DOM to generate and equivalence with two pointers of\n-     alias-incompatible types:\n-\n-     \tstruct _ffename_space *n;\n-\tstruct _ffename *ns;\n-\t[ ... ]\n-\tif (n == ns)\n-\t  goto lab;\n-\t...\n-\tlab:\n-\treturn n;\n-\n-     I think that GIMPLE should emit the appropriate type-casts.  For the\n-     time being, blocking copy-propagation in these cases is the safe thing\n-     to do.  */\n-  if (TREE_CODE (dest) == SSA_NAME\n-      && TREE_CODE (orig) == SSA_NAME\n-      && POINTER_TYPE_P (TREE_TYPE (dest))\n-      && POINTER_TYPE_P (TREE_TYPE (orig)))\n-    {\n-      tree mt_dest = var_ann (SSA_NAME_VAR (dest))->type_mem_tag;\n-      tree mt_orig = var_ann (SSA_NAME_VAR (orig))->type_mem_tag;\n-      if (mt_dest && mt_orig && mt_dest != mt_orig)\n-\treturn false;\n-    }\n-\n-  /* If the destination is a SSA_NAME for a virtual operand, then we have\n-     some special cases to handle.  */\n-  if (TREE_CODE (dest) == SSA_NAME && !is_gimple_reg (dest))\n-    {\n-      /* If both operands are SSA_NAMEs referring to virtual operands, then\n-\t we can always propagate.  */\n-      if (TREE_CODE (orig) == SSA_NAME)\n-\t{\n-\t  if (!is_gimple_reg (orig))\n-\t    return true;\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* If we have one real and one virtual operand, then something has\n-\t     gone terribly wrong.  */\n-\t  if (is_gimple_reg (orig))\n-\t    abort ();\n-#endif\n-\t}\n-\n-      /* We have a \"copy\" from something like a constant into a virtual\n-\t operand.  Reject these.  */\n-      return false;\n-    }\n-\n-  /* If ORIG flows in from an abnormal edge, it cannot be propagated.  */\n-  if (TREE_CODE (orig) == SSA_NAME\n-      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig))\n-    return false;\n-\n-  /* If DEST is an SSA_NAME that flows from an abnormal edge or if it\n-     represents a hard register, then it cannot be replaced.  */\n-  if (TREE_CODE (dest) == SSA_NAME\n-      && (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (dest)\n-\t  || DECL_HARD_REGISTER (SSA_NAME_VAR (dest))))\n-    return false;\n-\n-  /* Anything else is OK.  */\n-  return true;\n-}\n-\n /* Set the default definition for VAR to DEF.  */\n static inline void\n set_default_def (tree var, tree def)"}, {"sha": "dc4ddb2d7a4fc7367b9a5886b89ffd4291d0facc", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=63b8825280dc6eac8ff82c577c15831a150c1c40", "patch": "@@ -591,10 +591,10 @@ extern void debug_dominator_optimization_stats (void);\n extern void propagate_value (use_operand_p, tree);\n extern void propagate_tree_value (tree *, tree);\n extern void replace_exp (use_operand_p, tree);\n+extern bool may_propagate_copy (tree, tree);\n \n /* In tree-flow-inline.h  */\n static inline int phi_arg_from_edge (tree, edge);\n-static inline bool may_propagate_copy (tree, tree);\n static inline bool is_call_clobbered (tree);\n static inline void mark_call_clobbered (tree);\n "}, {"sha": "5d96fae8e5b582243ffc45e42de608f85ee1501c", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=63b8825280dc6eac8ff82c577c15831a150c1c40", "patch": "@@ -55,6 +55,103 @@ Boston, MA 02111-1307, USA.  */\n    APIs defined in this file.  */\n \n \n+/* Return true if we may propagate ORIG into DEST, false otherwise.  */\n+\n+bool\n+may_propagate_copy (tree dest, tree orig)\n+{\n+  tree type_d = TREE_TYPE (dest);\n+  tree type_o = TREE_TYPE (orig);\n+\n+  /* Do not copy between types for which we *do* need a conversion.  */\n+  if (!tree_ssa_useless_type_conversion_1 (type_d, type_o))\n+    return false;\n+\n+  /* FIXME.  GIMPLE is allowing pointer assignments and comparisons of\n+     pointers that have different alias sets.  This means that these\n+     pointers will have different memory tags associated to them.\n+     \n+     If we allow copy propagation in these cases, statements de-referencing\n+     the new pointer will now have a reference to a different memory tag\n+     with potentially incorrect SSA information.\n+\n+     This was showing up in libjava/java/util/zip/ZipFile.java with code\n+     like:\n+\n+     \tstruct java.io.BufferedInputStream *T.660;\n+\tstruct java.io.BufferedInputStream *T.647;\n+\tstruct java.io.InputStream *is;\n+\tstruct java.io.InputStream *is.662;\n+\t[ ... ]\n+\tT.660 = T.647;\n+\tis = T.660;\t<-- This ought to be type-casted\n+\tis.662 = is;\n+\n+     Also, f/name.c exposed a similar problem with a COND_EXPR predicate\n+     that was causing DOM to generate and equivalence with two pointers of\n+     alias-incompatible types:\n+\n+     \tstruct _ffename_space *n;\n+\tstruct _ffename *ns;\n+\t[ ... ]\n+\tif (n == ns)\n+\t  goto lab;\n+\t...\n+\tlab:\n+\treturn n;\n+\n+     I think that GIMPLE should emit the appropriate type-casts.  For the\n+     time being, blocking copy-propagation in these cases is the safe thing\n+     to do.  */\n+  if (TREE_CODE (dest) == SSA_NAME && TREE_CODE (orig) == SSA_NAME\n+      && POINTER_TYPE_P (type_d) && POINTER_TYPE_P (type_o))\n+    {\n+      tree mt_dest = var_ann (SSA_NAME_VAR (dest))->type_mem_tag;\n+      tree mt_orig = var_ann (SSA_NAME_VAR (orig))->type_mem_tag;\n+      if (mt_dest && mt_orig && mt_dest != mt_orig)\n+\treturn false;\n+    }\n+\n+  /* If the destination is a SSA_NAME for a virtual operand, then we have\n+     some special cases to handle.  */\n+  if (TREE_CODE (dest) == SSA_NAME && !is_gimple_reg (dest))\n+    {\n+      /* If both operands are SSA_NAMEs referring to virtual operands, then\n+\t we can always propagate.  */\n+      if (TREE_CODE (orig) == SSA_NAME)\n+\t{\n+\t  if (!is_gimple_reg (orig))\n+\t    return true;\n+\n+#ifdef ENABLE_CHECKING\n+\t  /* If we have one real and one virtual operand, then something has\n+\t     gone terribly wrong.  */\n+\t  if (is_gimple_reg (orig))\n+\t    abort ();\n+#endif\n+\t}\n+\n+      /* We have a \"copy\" from something like a constant into a virtual\n+\t operand.  Reject these.  */\n+      return false;\n+    }\n+\n+  /* If ORIG flows in from an abnormal edge, it cannot be propagated.  */\n+  if (TREE_CODE (orig) == SSA_NAME\n+      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (orig))\n+    return false;\n+\n+  /* If DEST is an SSA_NAME that flows from an abnormal edge or if it\n+     represents a hard register, then it cannot be replaced.  */\n+  if (TREE_CODE (dest) == SSA_NAME\n+      && (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (dest)\n+\t  || DECL_HARD_REGISTER (SSA_NAME_VAR (dest))))\n+    return false;\n+\n+  /* Anything else is OK.  */\n+  return true;\n+}\n+\n /* Given two SSA_NAMEs, replace the annotations for the one referred to by OP \n    with VAR's annotations.\n "}, {"sha": "c03e2bb06752cb6063d0cdf0c9af009edf3b8e09", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63b8825280dc6eac8ff82c577c15831a150c1c40/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=63b8825280dc6eac8ff82c577c15831a150c1c40", "patch": "@@ -2906,24 +2906,24 @@ cprop_operand (stmt_ann_t ann, use_operand_p op_p, varray_type const_and_copies)\n \t  val_type = TREE_TYPE (val_type);\n \t}\n \n-      /* Make sure underlying types match before propagating a\n-\t constant by converting the constant to the proper type.  Note\n-\t that convert may return a non-gimple expression, in which case\n-\t we ignore this propagation opportunity.  */\n-     if (!lang_hooks.types_compatible_p (op_type, val_type)\n-           && TREE_CODE (val) != SSA_NAME)\n+      /* Make sure underlying types match before propagating a constant by\n+\t converting the constant to the proper type.  Note that convert may\n+\t return a non-gimple expression, in which case we ignore this\n+\t propagation opportunity.  */\n+      if (TREE_CODE (val) != SSA_NAME)\n \t{\n-\t  val = fold_convert (TREE_TYPE (op), val);\n-\t  if (!is_gimple_min_invariant (val)\n-\t      && TREE_CODE (val) != SSA_NAME)\n-\t    return false;\n+\t  if (!lang_hooks.types_compatible_p (op_type, val_type))\n+\t    {\n+\t      val = fold_convert (TREE_TYPE (op), val);\n+\t      if (!is_gimple_min_invariant (val))\n+\t\treturn false;\n+\t    }\n \t}\n \n       /* Certain operands are not allowed to be copy propagated due\n \t to their interaction with exception handling and some GCC\n \t extensions.  */\n-      if (TREE_CODE (val) == SSA_NAME\n-\t  && !may_propagate_copy (op, val))\n+      else if (!may_propagate_copy (op, val))\n \treturn false;\n \n       /* Dump details.  */"}]}