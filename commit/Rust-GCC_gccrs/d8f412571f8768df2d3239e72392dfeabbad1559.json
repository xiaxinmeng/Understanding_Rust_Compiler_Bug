{"sha": "d8f412571f8768df2d3239e72392dfeabbad1559", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhmNDEyNTcxZjg3NjhkZjJkMzIzOWU3MjM5MmRmZWFiYmFkMTU1OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-26T23:57:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-10-26T23:57:58Z"}, "message": "Update Go library to last weekly.\n\nFrom-SVN: r180552", "tree": {"sha": "19d182df05ead7ff8ba7ee00a7d57555e1383fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19d182df05ead7ff8ba7ee00a7d57555e1383fdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8f412571f8768df2d3239e72392dfeabbad1559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f412571f8768df2d3239e72392dfeabbad1559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8f412571f8768df2d3239e72392dfeabbad1559", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f412571f8768df2d3239e72392dfeabbad1559/comments", "author": null, "committer": null, "parents": [{"sha": "e0c39d66d4f0607177b1cf8995dda56a667e07b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c39d66d4f0607177b1cf8995dda56a667e07b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c39d66d4f0607177b1cf8995dda56a667e07b3"}], "stats": {"total": 56610, "additions": 43688, "deletions": 12922}, "files": [{"sha": "9a7ab15406c54001810b452e4e4a98975b2f7bd9", "filename": "gcc/testsuite/go.test/test/chan/sieve2.go", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fsieve2.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -13,7 +13,6 @@ package main\n import (\n \t\"container/heap\"\n \t\"container/ring\"\n-\t\"container/vector\"\n )\n \n // Return a chan of odd numbers, starting from 5.\n@@ -47,13 +46,28 @@ type PeekCh struct {\n \tch   chan int\n }\n \n-// Heap of PeekCh, sorting by head values.\n-type PeekChHeap struct {\n-\t*vector.Vector\n-}\n+// Heap of PeekCh, sorting by head values, satisfies Heap interface.\n+type PeekChHeap []*PeekCh\n \n func (h *PeekChHeap) Less(i, j int) bool {\n-\treturn h.At(i).(*PeekCh).head < h.At(j).(*PeekCh).head\n+\treturn (*h)[i].head < (*h)[j].head\n+}\n+\n+func (h *PeekChHeap) Swap(i, j int) {\n+\t(*h)[i], (*h)[j] = (*h)[j], (*h)[i]\n+}\n+\n+func (h *PeekChHeap) Len() int {\n+\treturn len(*h)\n+}\n+\n+func (h *PeekChHeap) Pop() (v interface{}) {\n+\t*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]\n+\treturn\n+}\n+\n+func (h *PeekChHeap) Push(v interface{}) {\n+\t*h = append(*h, v.(*PeekCh))\n }\n \n // Return a channel to serve as a sending proxy to 'out'.\n@@ -108,26 +122,26 @@ func Sieve() chan int {\n \n \t// Merge channels of multiples of 'primes' into 'composites'.\n \tgo func() {\n-\t\th := &PeekChHeap{new(vector.Vector)}\n+\t\tvar h PeekChHeap\n \t\tmin := 15\n \t\tfor {\n \t\t\tm := multiples(<-primes)\n \t\t\thead := <-m\n \t\t\tfor min < head {\n \t\t\t\tcomposites <- min\n-\t\t\t\tminchan := heap.Pop(h).(*PeekCh)\n+\t\t\t\tminchan := heap.Pop(&h).(*PeekCh)\n \t\t\t\tmin = minchan.head\n \t\t\t\tminchan.head = <-minchan.ch\n-\t\t\t\theap.Push(h, minchan)\n+\t\t\t\theap.Push(&h, minchan)\n \t\t\t}\n \t\t\tfor min == head {\n-\t\t\t\tminchan := heap.Pop(h).(*PeekCh)\n+\t\t\t\tminchan := heap.Pop(&h).(*PeekCh)\n \t\t\t\tmin = minchan.head\n \t\t\t\tminchan.head = <-minchan.ch\n-\t\t\t\theap.Push(h, minchan)\n+\t\t\t\theap.Push(&h, minchan)\n \t\t\t}\n \t\t\tcomposites <- head\n-\t\t\theap.Push(h, &PeekCh{<-m, m})\n+\t\t\theap.Push(&h, &PeekCh{<-m, m})\n \t\t}\n \t}()\n "}, {"sha": "ed5905da30cd2dda47763d248978dbd490539565", "filename": "gcc/testsuite/go.test/test/vectors.go", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fvectors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fvectors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fvectors.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,64 +0,0 @@\n-// $G $F.go && $L $F.$A && ./$A.out\n-\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import \"container/vector\"\n-\n-\n-type S struct {\n-\tval int\n-}\n-\n-\n-func (p *S) Init(val int) *S {\n-\tp.val = val\n-\treturn p\n-}\n-\n-\n-func test0() {\n-\tv := new(vector.Vector)\n-\tif v.Len() != 0 {\n-\t\tprint(\"len = \", v.Len(), \"\\n\")\n-\t\tpanic(\"fail\")\n-\t}\n-}\n-\n-\n-func test1() {\n-\tvar a [1000]*S\n-\tfor i := 0; i < len(a); i++ {\n-\t\ta[i] = new(S).Init(i)\n-\t}\n-\n-\tv := new(vector.Vector)\n-\tfor i := 0; i < len(a); i++ {\n-\t\tv.Insert(0, a[i])\n-\t\tif v.Len() != i+1 {\n-\t\t\tprint(\"len = \", v.Len(), \"\\n\")\n-\t\t\tpanic(\"fail\")\n-\t\t}\n-\t}\n-\n-\tfor i := 0; i < v.Len(); i++ {\n-\t\tx := v.At(i).(*S)\n-\t\tif x.val != v.Len()-i-1 {\n-\t\t\tprint(\"expected \", i, \", found \", x.val, \"\\n\")\n-\t\t\tpanic(\"fail\")\n-\t\t}\n-\t}\n-\n-\tfor v.Len() > 10 {\n-\t\tv.Delete(10)\n-\t}\n-}\n-\n-\n-func main() {\n-\ttest0()\n-\ttest1()\n-}"}, {"sha": "8ba17deb09edeca9fa35edb64a90d99faf21826b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -1,4 +1,4 @@\n-c1702f36df03\n+6d7136d74b65\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "e3b33a83bdca3decb760a4c4a7ed42fa66409caf", "filename": "libgo/Makefile.am", "status": "modified", "additions": 292, "deletions": 201, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -107,7 +107,6 @@ toolexeclibgo_DATA = \\\n \tcmath.gox \\\n \tcrypto.gox \\\n \tcsv.gox \\\n-\tebnf.gox \\\n \texec.gox \\\n \texpvar.gox \\\n \tflag.gox \\\n@@ -124,7 +123,6 @@ toolexeclibgo_DATA = \\\n \tmail.gox \\\n \tmime.gox \\\n \tnet.gox \\\n-\tnetchan.gox \\\n \tos.gox \\\n \tpatch.gox \\\n \tpath.gox \\\n@@ -145,7 +143,6 @@ toolexeclibgo_DATA = \\\n \ttemplate.gox \\\n \ttesting.gox \\\n \ttime.gox \\\n-\ttry.gox \\\n \tunicode.gox \\\n \turl.gox \\\n \tutf16.gox \\\n@@ -173,13 +170,13 @@ toolexeclibgocontainerdir = $(toolexeclibgodir)/container\n toolexeclibgocontainer_DATA = \\\n \tcontainer/heap.gox \\\n \tcontainer/list.gox \\\n-\tcontainer/ring.gox \\\n-\tcontainer/vector.gox\n+\tcontainer/ring.gox\n \n toolexeclibgocryptodir = $(toolexeclibgodir)/crypto\n \n toolexeclibgocrypto_DATA = \\\n \tcrypto/aes.gox \\\n+\tcrypto/bcrypt.gox \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n@@ -242,19 +239,24 @@ toolexeclibgoencoding_DATA = \\\n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n \n toolexeclibgoexp_DATA = \\\n+\texp/ebnf.gox \\\n \texp/gui.gox \\\n \texp/norm.gox \\\n-\texp/regexp.gox\n+\texp/spdy.gox \\\n+\texp/sql.gox \\\n+\texp/ssh.gox \\\n+\texp/terminal.gox \\\n+\texp/types.gox\n \n toolexeclibgoexpguidir = $(toolexeclibgoexpdir)/gui\n \n toolexeclibgoexpgui_DATA = \\\n \texp/gui/x11.gox\n \n-toolexeclibgoexpregexpdir = $(toolexeclibgoexpdir)/regexp\n+toolexeclibgoexpsqldir = $(toolexeclibgoexpdir)/sql\n \n-toolexeclibgoexpregexp_DATA = \\\n-\texp/regexp/syntax.gox\n+toolexeclibgoexpsql_DATA = \\\n+\texp/sql/driver.gox\n \n toolexeclibgoexptemplatedir = $(toolexeclibgoexpdir)/template\n \n@@ -270,9 +272,7 @@ toolexeclibgogo_DATA = \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n-\tgo/token.gox \\\n-\tgo/typechecker.gox \\\n-\tgo/types.gox\n+\tgo/token.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n \n@@ -288,13 +288,13 @@ toolexeclibgohttp_DATA = \\\n \thttp/cgi.gox \\\n \thttp/fcgi.gox \\\n \thttp/httptest.gox \\\n-\thttp/pprof.gox \\\n-\thttp/spdy.gox\n+\thttp/pprof.gox\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n \n toolexeclibgoimage_DATA = \\\n \timage/bmp.gox \\\n+\timage/color.gox \\\n \timage/draw.gox \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n@@ -326,6 +326,8 @@ toolexeclibgonet_DATA = \\\n toolexeclibgoolddir = $(toolexeclibgodir)/old\n \n toolexeclibgoold_DATA = \\\n+\told/netchan.gox \\\n+\told/regexp.gox \\\n \told/template.gox\n \n toolexeclibgoosdir = $(toolexeclibgodir)/os\n@@ -347,6 +349,11 @@ toolexeclibgopathdir = $(toolexeclibgodir)/path\n toolexeclibgopath_DATA = \\\n \tpath/filepath.gox\n \n+toolexeclibgoregexpdir = $(toolexeclibgodir)/regexp\n+\n+toolexeclibgoregexp_DATA = \\\n+\tregexp/syntax.gox\n+\n toolexeclibgorpcdir = $(toolexeclibgodir)/rpc\n \n toolexeclibgorpc_DATA = \\\n@@ -479,6 +486,7 @@ runtime_files = \\\n \truntime/msize.c \\\n \truntime/proc.c \\\n \truntime/thread.c \\\n+\truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \tchan.c \\\n \tiface.c \\\n@@ -559,10 +567,6 @@ go_csv_files = \\\n \tgo/csv/reader.go \\\n \tgo/csv/writer.go\n \n-go_ebnf_files = \\\n-\tgo/ebnf/ebnf.go \\\n-\tgo/ebnf/parser.go\n-\n go_exec_files = \\\n \tgo/exec/exec.go \\\n \tgo/exec/lp_unix.go\n@@ -598,13 +602,15 @@ go_html_files = \\\n \tgo/html/escape.go \\\n \tgo/html/node.go \\\n \tgo/html/parse.go \\\n+\tgo/html/render.go \\\n \tgo/html/token.go\n \n go_http_files = \\\n \tgo/http/chunked.go \\\n \tgo/http/client.go \\\n \tgo/http/cookie.go \\\n \tgo/http/dump.go \\\n+\tgo/http/filetransport.go \\\n \tgo/http/fs.go \\\n \tgo/http/header.go \\\n \tgo/http/lex.go \\\n@@ -619,7 +625,6 @@ go_http_files = \\\n \tgo/http/transport.go\n \n go_image_files = \\\n-\tgo/image/color.go \\\n \tgo/image/format.go \\\n \tgo/image/geom.go \\\n \tgo/image/image.go \\\n@@ -642,6 +647,7 @@ go_log_files = \\\n \tgo/log/log.go\n \n go_math_files = \\\n+\tgo/math/abs.go \\\n \tgo/math/acosh.go \\\n \tgo/math/asin.go \\\n \tgo/math/asinh.go \\\n@@ -652,15 +658,13 @@ go_math_files = \\\n \tgo/math/cbrt.go \\\n \tgo/math/const.go \\\n \tgo/math/copysign.go \\\n+\tgo/math/dim.go \\\n \tgo/math/erf.go \\\n \tgo/math/exp.go \\\n \tgo/math/exp_port.go \\\n \tgo/math/exp2.go \\\n \tgo/math/expm1.go \\\n-\tgo/math/fabs.go \\\n-\tgo/math/fdim.go \\\n \tgo/math/floor.go \\\n-\tgo/math/fmod.go \\\n \tgo/math/frexp.go \\\n \tgo/math/gamma.go \\\n \tgo/math/hypot.go \\\n@@ -674,6 +678,7 @@ go_math_files = \\\n \tgo/math/log1p.go \\\n \tgo/math/log10.go \\\n \tgo/math/logb.go \\\n+\tgo/math/mod.go \\\n \tgo/math/modf.go \\\n \tgo/math/nextafter.go \\\n \tgo/math/pow.go \\\n@@ -777,11 +782,6 @@ go_net_files = \\\n \tgo/net/unixsock.go \\\n \tgo/net/unixsock_posix.go\n \n-go_netchan_files = \\\n-\tgo/netchan/common.go \\\n-\tgo/netchan/export.go \\\n-\tgo/netchan/import.go\n-\n if LIBGO_IS_SOLARIS\n if LIBGO_IS_386\n go_os_dir_file = go/os/dir_largefile.go\n@@ -865,6 +865,7 @@ go_reflect_files = \\\n \tgo/reflect/value.go\n \n go_regexp_files = \\\n+\tgo/regexp/exec.go \\\n \tgo/regexp/regexp.go\n \n go_rpc_files = \\\n@@ -915,6 +916,7 @@ go_strconv_files = \\\n \n go_strings_files = \\\n \tgo/strings/reader.go \\\n+\tgo/strings/replace.go \\\n \tgo/strings/strings.go\n \n go_sync_files = \\\n@@ -953,21 +955,19 @@ go_template_files = \\\n \n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n+\tgo/testing/example.go \\\n \tgo/testing/testing.go\n \n go_time_files = \\\n \tgo/time/format.go \\\n \tgo/time/sleep.go \\\n \tgo/time/sys.go \\\n-\tgo/time/sys_posix.go \\\n+\tgo/time/sys_unix.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n \tgo/time/zoneinfo_posix.go \\\n \tgo/time/zoneinfo_unix.go\n \n-go_try_files = \\\n-\tgo/try/try.go\n-\n go_unicode_files = \\\n \tgo/unicode/casetables.go \\\n \tgo/unicode/digit.go \\\n@@ -987,6 +987,8 @@ go_utf8_files = \\\n \n go_websocket_files = \\\n \tgo/websocket/client.go \\\n+\tgo/websocket/hixie.go \\\n+\tgo/websocket/hybi.go \\\n \tgo/websocket/server.go \\\n \tgo/websocket/websocket.go\n \n@@ -1041,16 +1043,13 @@ go_container_list_files = \\\n go_container_ring_files = \\\n \tgo/container/ring/ring.go\n \n-go_container_vector_files = \\\n-\tgo/container/vector/defs.go \\\n-\tgo/container/vector/intvector.go \\\n-\tgo/container/vector/stringvector.go \\\n-\tgo/container/vector/vector.go\n-\n go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/const.go\n+go_crypto_bcrypt_files = \\\n+\tgo/crypto/bcrypt/base64.go \\\n+\tgo/crypto/bcrypt/bcrypt.go\n go_crypto_blowfish_files = \\\n \tgo/crypto/blowfish/block.go \\\n \tgo/crypto/blowfish/const.go \\\n@@ -1123,11 +1122,13 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/handshake_server.go \\\n \tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n+\tgo/crypto/tls/root_unix.go \\\n \tgo/crypto/tls/tls.go\n go_crypto_twofish_files = \\\n \tgo/crypto/twofish/twofish.go\n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n+\tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n go_crypto_xtea_files = \\\n@@ -1187,41 +1188,75 @@ go_encoding_base32_files = \\\n go_encoding_base64_files = \\\n \tgo/encoding/base64/base64.go\n go_encoding_binary_files = \\\n-\tgo/encoding/binary/binary.go\n+\tgo/encoding/binary/binary.go \\\n+\tgo/encoding/binary/varint.go\n go_encoding_git85_files = \\\n \tgo/encoding/git85/git.go\n go_encoding_hex_files = \\\n \tgo/encoding/hex/hex.go\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n+go_exp_ebnf_files = \\\n+\tgo/exp/ebnf/ebnf.go \\\n+\tgo/exp/ebnf/parser.go\n go_exp_gui_files = \\\n \tgo/exp/gui/gui.go\n go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n+\tgo/exp/norm/input.go \\\n \tgo/exp/norm/normalize.go \\\n+\tgo/exp/norm/readwriter.go \\\n \tgo/exp/norm/tables.go \\\n \tgo/exp/norm/trie.go\n-go_exp_regexp_files = \\\n-\tgo/exp/regexp/exec.go \\\n-\tgo/exp/regexp/regexp.go\n+go_exp_spdy_files = \\\n+\tgo/exp/spdy/read.go \\\n+\tgo/exp/spdy/types.go \\\n+\tgo/exp/spdy/write.go\n+go_exp_sql_files = \\\n+\tgo/exp/sql/convert.go \\\n+\tgo/exp/sql/sql.go\n+go_exp_ssh_files = \\\n+\tgo/exp/ssh/channel.go \\\n+\tgo/exp/ssh/common.go \\\n+\tgo/exp/ssh/doc.go \\\n+\tgo/exp/ssh/messages.go \\\n+\tgo/exp/ssh/server.go \\\n+\tgo/exp/ssh/server_shell.go \\\n+\tgo/exp/ssh/transport.go\n+go_exp_terminal_files = \\\n+\tgo/exp/terminal/shell.go \\\n+\tgo/exp/terminal/terminal.go\n+go_exp_types_files = \\\n+\tgo/exp/types/check.go \\\n+\tgo/exp/types/const.go \\\n+\tgo/exp/types/exportdata.go \\\n+\tgo/exp/types/gcimporter.go \\\n+\tgo/exp/types/types.go \\\n+\tgo/exp/types/universe.go\n \n go_exp_gui_x11_files = \\\n \tgo/exp/gui/x11/auth.go \\\n \tgo/exp/gui/x11/conn.go\n \n+go_exp_sql_driver_files = \\\n+\tgo/exp/sql/driver/driver.go \\\n+\tgo/exp/sql/driver/types.go\n+\n go_exp_template_html_files = \\\n+\tgo/exp/template/html/attr.go \\\n+\tgo/exp/template/html/clone.go \\\n+\tgo/exp/template/html/content.go \\\n \tgo/exp/template/html/context.go \\\n-\tgo/exp/template/html/escape.go\n-\n-go_exp_regexp_syntax_files = \\\n-\tgo/exp/regexp/syntax/compile.go \\\n-\tgo/exp/regexp/syntax/parse.go \\\n-\tgo/exp/regexp/syntax/perl_groups.go \\\n-\tgo/exp/regexp/syntax/prog.go \\\n-\tgo/exp/regexp/syntax/regexp.go \\\n-\tgo/exp/regexp/syntax/simplify.go\n+\tgo/exp/template/html/css.go \\\n+\tgo/exp/template/html/doc.go \\\n+\tgo/exp/template/html/error.go \\\n+\tgo/exp/template/html/escape.go \\\n+\tgo/exp/template/html/html.go \\\n+\tgo/exp/template/html/js.go \\\n+\tgo/exp/template/html/transition.go \\\n+\tgo/exp/template/html/url.go\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n@@ -1237,7 +1272,8 @@ go_go_build_files = \\\n \tsyslist.go\n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n-\tgo/go/doc/doc.go\n+\tgo/go/doc/doc.go \\\n+\tgo/go/doc/example.go\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1249,19 +1285,8 @@ go_go_scanner_files = \\\n \tgo/go/scanner/scanner.go\n go_go_token_files = \\\n \tgo/go/token/position.go \\\n+\tgo/go/token/serialize.go \\\n \tgo/go/token/token.go\n-go_go_typechecker_files = \\\n-\tgo/go/typechecker/scope.go \\\n-\tgo/go/typechecker/type.go \\\n-\tgo/go/typechecker/typechecker.go \\\n-\tgo/go/typechecker/universe.go\n-go_go_types_files = \\\n-\tgo/go/types/check.go \\\n-\tgo/go/types/const.go \\\n-\tgo/go/types/exportdata.go \\\n-\tgo/go/types/gcimporter.go \\\n-\tgo/go/types/types.go \\\n-\tgo/go/types/universe.go\n \n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n@@ -1284,14 +1309,13 @@ go_http_httptest_files = \\\n \tgo/http/httptest/server.go\n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n-go_http_spdy_files = \\\n-\tgo/http/spdy/read.go \\\n-\tgo/http/spdy/types.go \\\n-\tgo/http/spdy/write.go\n \n go_image_bmp_files = \\\n \tgo/image/bmp/reader.go\n \n+go_image_color_files = \\\n+\tgo/image/color/color.go\n+\n go_image_draw_files = \\\n \tgo/image/draw/draw.go\n \n@@ -1311,6 +1335,7 @@ go_image_png_files = \\\n \n go_image_tiff_files = \\\n \tgo/image/tiff/buffer.go \\\n+\tgo/image/tiff/compress.go \\\n \tgo/image/tiff/consts.go \\\n \tgo/image/tiff/reader.go\n \n@@ -1340,6 +1365,12 @@ go_net_textproto_files = \\\n \tgo/net/textproto/textproto.go \\\n \tgo/net/textproto/writer.go\n \n+go_old_netchan_files = \\\n+\tgo/old/netchan/common.go \\\n+\tgo/old/netchan/export.go \\\n+\tgo/old/netchan/import.go\n+go_old_regexp_files = \\\n+\tgo/old/regexp/regexp.go\n go_old_template_files = \\\n \tgo/old/template/doc.go \\\n \tgo/old/template/execute.go \\\n@@ -1361,6 +1392,14 @@ go_path_filepath_files = \\\n \tgo/path/filepath/path.go \\\n \tgo/path/filepath/path_unix.go\n \n+go_regexp_syntax_files = \\\n+\tgo/regexp/syntax/compile.go \\\n+\tgo/regexp/syntax/parse.go \\\n+\tgo/regexp/syntax/perl_groups.go \\\n+\tgo/regexp/syntax/prog.go \\\n+\tgo/regexp/syntax/regexp.go \\\n+\tgo/regexp/syntax/simplify.go\n+\n go_rpc_jsonrpc_files = \\\n \tgo/rpc/jsonrpc/client.go \\\n \tgo/rpc/jsonrpc/server.go\n@@ -1559,7 +1598,6 @@ libgo_go_objs = \\\n \tcmath/cmath.lo \\\n \tcrypto/crypto.lo \\\n \tcsv/csv.lo \\\n-\tebnf/ebnf.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n \tflag/flag.lo \\\n@@ -1576,7 +1614,6 @@ libgo_go_objs = \\\n \tmail/mail.lo \\\n \tmime/mime.lo \\\n \tnet/net.lo \\\n-\tnetchan/netchan.lo \\\n \tos/os.lo \\\n \tpatch/patch.lo \\\n \tpath/path.lo \\\n@@ -1596,7 +1633,6 @@ libgo_go_objs = \\\n \ttabwriter/tabwriter.lo \\\n \ttemplate/template.lo \\\n \ttime/time.lo \\\n-\ttry/try.lo \\\n \tunicode/unicode.lo \\\n \turl/url.lo \\\n \tutf16/utf16.lo \\\n@@ -1613,8 +1649,8 @@ libgo_go_objs = \\\n \tcontainer/heap.lo \\\n \tcontainer/list.lo \\\n \tcontainer/ring.lo \\\n-\tcontainer/vector.lo \\\n \tcrypto/aes.lo \\\n+\tcrypto/bcrypt.lo \\\n \tcrypto/blowfish.lo \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n@@ -1657,11 +1693,16 @@ libgo_go_objs = \\\n \tencoding/git85.lo \\\n \tencoding/hex.lo \\\n \tencoding/pem.lo \\\n+\texp/ebnf.lo \\\n \texp/gui.lo \\\n \texp/norm.lo \\\n-\texp/regexp.lo \\\n+\texp/spdy.lo \\\n+\texp/sql.lo \\\n+\texp/ssh.lo \\\n+\texp/terminal.lo \\\n+\texp/types.lo \\\n \texp/gui/x11.lo \\\n-\texp/regexp/syntax.lo \\\n+\texp/sql/driver.lo \\\n \texp/template/html.lo \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n@@ -1670,8 +1711,6 @@ libgo_go_objs = \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n-\tgo/typechecker.lo \\\n-\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -1680,8 +1719,8 @@ libgo_go_objs = \\\n \thttp/fcgi.lo \\\n \thttp/httptest.lo \\\n \thttp/pprof.lo \\\n-\thttp/spdy.lo \\\n \timage/bmp.lo \\\n+\timage/color.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n@@ -1693,11 +1732,14 @@ libgo_go_objs = \\\n \tmime/multipart.lo \\\n \tnet/dict.lo \\\n \tnet/textproto.lo \\\n+\told/netchan.lo \\\n+\told/regexp.lo \\\n \told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/user.lo \\\n \tos/signal.lo \\\n \tpath/filepath.lo \\\n+\tregexp/syntax.lo \\\n \trpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n@@ -1853,13 +1895,6 @@ csv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: csv/check\n \n-ebnf/ebnf.lo: $(go_ebnf_files) container/vector.gox go/scanner.gox \\\n-\t\tgo/token.gox os.gox strconv.gox unicode.gox utf8.gox\n-\t$(BUILDPACKAGE)\n-ebnf/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: ebnf/check\n-\n exec/exec.lo: $(go_exec_files) bytes.gox io.gox os.gox strconv.gox \\\n \t\tstrings.gox syscall.gox\n \t$(BUILDPACKAGE)\n@@ -1881,7 +1916,7 @@ flag/check: $(CHECK_DEPS)\n .PHONY: flag/check\n \n fmt/fmt.lo: $(go_fmt_files) bytes.gox io.gox math.gox os.gox reflect.gox \\\n-\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n+\t\tstrconv.gox strings.gox sync.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n fmt/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1901,8 +1936,8 @@ hash/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/check\n \n-html/html.lo: $(go_html_files) bytes.gox io.gox os.gox strconv.gox strings.gox \\\n-\t\tutf8.gox\n+html/html.lo: $(go_html_files) bufio.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\tstrconv.gox strings.gox utf8.gox\n \t$(BUILDPACKAGE)\n html/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1919,7 +1954,8 @@ http/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/check\n \n-image/image.lo: $(go_image_files) bufio.gox io.gox os.gox strconv.gox\n+image/image.lo: $(go_image_files) bufio.gox image/color.gox io.gox os.gox \\\n+\t\tstrconv.gox\n \t$(BUILDPACKAGE)\n image/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -1975,13 +2011,6 @@ net/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: net/check\n \n-netchan/netchan.lo: $(go_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n-\t\treflect.gox strconv.gox sync.gox time.gox\n-\t$(BUILDPACKAGE)\n-netchan/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: netchan/check\n-\n os/os.lo: $(go_os_files) runtime.gox sync.gox syscall.gox\n \t$(BUILDPACKAGE)\n os/check: $(CHECK_DEPS)\n@@ -2019,8 +2048,8 @@ reflect/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: reflect/check\n \n-regexp/regexp.lo: $(go_regexp_files) bytes.gox io.gox os.gox strings.gox \\\n-\t\tutf8.gox\n+regexp/regexp.lo: $(go_regexp_files) bytes.gox io.gox os.gox \\\n+\t\tregexp/syntax.gox strconv.gox strings.gox sync.gox utf8.gox\n \t$(BUILDPACKAGE)\n regexp/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -2067,7 +2096,7 @@ strconv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: strconv/check\n \n-strings/strings.lo: $(go_strings_files) os.gox unicode.gox utf8.gox\n+strings/strings.lo: $(go_strings_files) io.gox os.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n strings/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -2102,8 +2131,9 @@ template/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: template/check\n \n-testing/testing.lo: $(go_testing_files) flag.gox fmt.gox os.gox regexp.gox \\\n-\t\truntime.gox runtime/pprof.gox strings.gox strconv.gox time.gox\n+testing/testing.lo: $(go_testing_files) bytes.gox flag.gox fmt.gox io.gox \\\n+\t\tos.gox regexp.gox runtime.gox runtime/pprof.gox strings.gox \\\n+\t\tstrconv.gox time.gox\n \t$(BUILDPACKAGE)\n testing/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -2116,12 +2146,6 @@ time/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: time/check\n \n-try/try.lo: $(go_try_files) fmt.gox io.gox os.gox reflect.gox unicode.gox\n-\t$(BUILDPACKAGE)\n-try/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: try/check\n-\n unicode/unicode.lo: $(go_unicode_files)\n \t$(BUILDPACKAGE)\n unicode/check: $(CHECK_DEPS)\n@@ -2147,8 +2171,10 @@ utf8/check: $(CHECK_DEPS)\n .PHONY: utf8/check\n \n websocket/websocket.lo: $(go_websocket_files) bufio.gox bytes.gox \\\n-\t\tcrypto/md5.gox crypto/tls.gox encoding/binary.gox fmt.gox \\\n-\t\thttp.gox io.gox net.gox os.gox rand.gox strings.gox url.gox\n+\t\tcrypto/md5.gox crypto/rand.gox crypto/sha1.gox crypto/tls.gox \\\n+\t\tencoding/base64.gox encoding/binary.gox fmt.gox http.gox \\\n+\t\tio.gox io/ioutil.gox json.gox net.gox os.gox rand.gox \\\n+\t\tstrings.gox strconv.gox sync.gox url.gox\n \t$(BUILDPACKAGE)\n websocket/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -2237,20 +2263,22 @@ container/ring/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: container/ring/check\n \n-container/vector.lo: $(go_container_vector_files)\n-\t$(BUILDPACKAGE)\n-container/vector/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) container/vector\n-\t@$(CHECK)\n-.PHONY: container/vector/check\n-\n crypto/aes.lo: $(go_crypto_aes_files) os.gox strconv.gox\n \t$(BUILDPACKAGE)\n crypto/aes/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/aes\n \t@$(CHECK)\n .PHONY: crypto/aes/check\n \n+crypto/bcrypt.lo: $(go_crypto_bcrypt_files) crypto/blowfish.gox \\\n+\t\tcrypto/rand.gox crypto/subtle.gox encoding/base64.gox \\\n+\t\tfmt.gox io.gox os.gox strconv.gox\n+\t$(BUILDPACKAGE)\n+crypto/bcrypt/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/bcrypt\n+\t@$(CHECK)\n+.PHONY: crypto/bcrypt/check\n+\n crypto/blowfish.lo: $(go_crypto_blowfish_files) os.gox strconv.gox\n \t$(BUILDPACKAGE)\n crypto/blowfish/check: $(CHECK_DEPS)\n@@ -2403,12 +2431,12 @@ crypto/subtle/check: $(CHECK_DEPS)\n .PHONY: crypto/subtle/check\n \n crypto/tls.lo: $(go_crypto_tls_files) big.gox bytes.gox crypto.gox \\\n-\t\tcrypto/aes.gox crypto/cipher.gox crypto/elliptic.gox \\\n-\t\tcrypto/hmac.gox crypto/md5.gox crypto/rand.gox crypto/rc4.gox \\\n-\t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n-\t\tcrypto/x509.gox crypto/x509/pkix.gox encoding/pem.gox \\\n-\t\thash.gox io.gox io/ioutil.gox net.gox os.gox strconv.gox \\\n-\t\tstrings.gox sync.gox time.gox\n+\t\tcrypto/aes.gox crypto/cipher.gox crypto/des.gox \\\n+\t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n+\t\tcrypto/rand.gox crypto/rc4.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox crypto/x509.gox crypto/x509/pkix.gox \\\n+\t\tencoding/pem.gox hash.gox io.gox io/ioutil.gox net.gox os.gox \\\n+\t\tstrconv.gox strings.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n@@ -2583,27 +2611,70 @@ encoding/pem/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/pem/check\n \n+exp/ebnf.lo: $(go_exp_ebnf_files) go/scanner.gox go/token.gox os.gox \\\n+\t\tstrconv.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+exp/ebnf/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/ebnf\n+\t@$(CHECK)\n+.PHONY: exp/ebnf/check\n+\n exp/gui.lo: $(go_exp_gui_files) image.gox image/draw.gox os.gox\n \t$(BUILDPACKAGE)\n exp/gui/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/gui\n \t@$(CHECK)\n .PHONY: exp/gui/check\n \n-exp/norm.lo: $(go_exp_norm_files) utf8.gox\n+exp/norm.lo: $(go_exp_norm_files) io.gox os.gox utf8.gox\n \t$(BUILDPACKAGE)\n exp/norm/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/norm\n \t@$(CHECK)\n .PHONY: exp/norm/check\n \n-exp/regexp.lo: $(go_exp_regexp_files) bytes.gox exp/regexp/syntax.gox io.gox \\\n-\t\tos.gox strings.gox sync.gox utf8.gox\n+exp/spdy.lo: $(go_exp_spdy_files) bytes.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox http.gox io.gox os.gox strings.gox\n+\t$(BUILDPACKAGE)\n+exp/spdy/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/spdy\n+\t@$(CHECK)\n+.PHONY: exp/spdy/check\n+\n+exp/sql.lo: $(go_exp_sql_files) exp/sql/driver.gox fmt.gox os.gox reflect.gox \\\n+\t\truntime.gox strconv.gox sync.gox\n+\t$(BUILDPACKAGE)\n+exp/sql/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/sql\n+\t@$(CHECK)\n+.PHONY: exp/sql/check\n+\n+exp/ssh.lo: $(go_exp_ssh_files) big.gox bufio.gox bytes.gox crypto.gox \\\n+\t\tcrypto/aes.gox crypto/cipher.gox crypto/hmac.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox crypto/x509.gox encoding/pem.gox hash.gox \\\n+\t\tio.gox net.gox os.gox reflect.gox strconv.gox sync.gox\n+\t$(BUILDPACKAGE)\n+exp/ssh/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/ssh\n+\t@$(CHECK)\n+.PHONY: exp/ssh/check\n+\n+exp/terminal.lo: $(go_exp_terminal_files) io.gox os.gox syscall.gox\n+\t$(BUILDPACKAGE)\n+exp/terminal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/terminal\n+\t@$(CHECK)\n+.PHONY: exp/terminal/check\n+\n+exp/types.lo: $(go_exp_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n+\t\tscanner.gox sort.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n-exp/regexp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/regexp\n+exp/types/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/types\n \t@$(CHECK)\n-.PHONY: exp/regexp/check\n+.PHONY: exp/types/check\n \n exp/gui/x11.lo: $(go_exp_gui_x11_files) bufio.gox exp/gui.gox image.gox \\\n \t\timage/draw.gox io.gox log.gox net.gox os.gox strconv.gox \\\n@@ -2614,15 +2685,17 @@ exp/gui/x11/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/gui/x11/check\n \n-exp/regexp/syntax.lo: $(go_exp_regexp_syntax_files) bytes.gox os.gox sort.gox strconv.gox strings.gox unicode.gox utf8.gox\n+exp/sql/driver.lo: $(go_exp_sql_driver_files) fmt.gox os.gox reflect.gox \\\n+\t\tstrconv.gox\n \t$(BUILDPACKAGE)\n-exp/regexp/syntax/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/regexp/syntax\n+exp/sql/driver/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/sql/driver\n \t@$(CHECK)\n-.PHONY: exp/regexp/syntax/check\n+.PHONY: exp/sql/driver/check\n \n-exp/template/html.lo: $(go_exp_template_html_files) fmt.gox template.gox \\\n-\t\ttemplate/parse.gox\n+exp/template/html.lo: $(go_exp_template_html_files) bytes.gox fmt.gox \\\n+\t\thtml.gox json.gox os.gox strings.gox template.gox \\\n+\t\ttemplate/parse.gox unicode.gox utf8.gox \n \t$(BUILDPACKAGE)\n exp/template/html/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/template/html\n@@ -2637,9 +2710,10 @@ go/ast/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/ast/check\n \n-go/build.lo: $(go_go_build_files) bytes.gox exec.gox fmt.gox go/parser.gox \\\n-\t\tgo/token.gox log.gox os.gox path/filepath.gox regexp.gox \\\n-\t\truntime.gox strconv.gox strings.gox runtime.gox\n+go/build.lo: $(go_go_build_files) bytes.gox exec.gox fmt.gox go/ast.gox \\\n+\t\tgo/doc.gox go/parser.gox go/token.gox io/ioutil.gox log.gox \\\n+\t\tos.gox path.gox path/filepath.gox regexp.gox runtime.gox \\\n+\t\tsort.gox strconv.gox strings.gox runtime.gox unicode.gox\n \t$(BUILDPACKAGE)\n go/build/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/build\n@@ -2656,7 +2730,7 @@ s-syslist: Makefile\n \t$(STAMP) $@\n \n go/doc.lo: $(go_go_doc_files) go/ast.gox go/token.gox io.gox regexp.gox \\\n-\t\tsort.gox strings.gox template.gox\n+\t\tsort.gox strings.gox template.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/doc/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/doc\n@@ -2674,7 +2748,7 @@ go/parser/check: $(CHECK_DEPS)\n \n go/printer.lo: $(go_go_printer_files) bytes.gox fmt.gox go/ast.gox \\\n \t\tgo/token.gox io.gox os.gox path/filepath.gox reflect.gox \\\n-\t\truntime.gox strings.gox tabwriter.gox\n+\t\tstrings.gox tabwriter.gox\n \t$(BUILDPACKAGE)\n go/printer/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/printer\n@@ -2690,30 +2764,14 @@ go/scanner/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/scanner/check\n \n-go/token.lo: $(go_go_token_files) fmt.gox strconv.gox\n+go/token.lo: $(go_go_token_files) fmt.gox gob.gox io.gox os.gox sort.gox \\\n+\t\tstrconv.gox sync.gox\n \t$(BUILDPACKAGE)\n go/token/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/token\n \t@$(CHECK)\n .PHONY: go/token/check\n \n-go/typechecker.lo: $(go_go_typechecker_files) fmt.gox go/ast.gox go/token.gox \\\n-\t\tgo/scanner.gox os.gox\n-\t$(BUILDPACKAGE)\n-go/typechecker/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) go/typechecker\n-\t@$(CHECK)\n-.PHONY: go/typechecker/check\n-\n-go/types.lo: $(go_go_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n-\t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n-\t\tscanner.gox sort.gox strconv.gox strings.gox\n-\t$(BUILDPACKAGE)\n-go/types/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) go/types\n-\t@$(CHECK)\n-.PHONY: go/types/check\n-\n hash/adler32.lo: $(go_hash_adler32_files) hash.gox os.gox\n \t$(BUILDPACKAGE)\n hash/adler32/check: $(CHECK_DEPS)\n@@ -2777,70 +2835,70 @@ http/pprof/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/pprof/check\n \n-http/spdy.lo: $(go_http_spdy_files) bytes.gox compress/zlib.gox \\\n-\t\tencoding/binary.gox http.gox io.gox os.gox strconv.gox \\\n-\t\tstrings.gox sync.gox\n-\t$(BUILDPACKAGE)\n-http/spdy/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) http/spdy\n-\t@$(CHECK)\n-.PHONY: http/spdy/check\n-\n-image/bmp.lo: $(go_image_bmp_files) image.gox io.gox os.gox\n+image/bmp.lo: $(go_image_bmp_files) image.gox image/color.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n image/bmp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/bmp\n \t@$(CHECK)\n .PHONY: image/bmp/check\n \n-image/draw.lo: $(go_image_draw_files) image.gox image/ycbcr.gox\n+image/color.lo: $(go_image_color_files)\n+\t$(BUILDPACKAGE)\n+image/color/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/color\n+\t@$(CHECK)\n+.PHONY: image/color/check\n+\n+image/draw.lo: $(go_image_draw_files) image.gox image/color.gox image/ycbcr.gox\n \t$(BUILDPACKAGE)\n image/draw/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/draw\n \t@$(CHECK)\n .PHONY: image/draw/check\n \n image/gif.lo: $(go_image_gif_files) bufio.gox compress/lzw.gox fmt.gox \\\n-\t\timage.gox io.gox os.gox\n+\t\timage.gox image/color.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n image/gif/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/gif\n \t@$(CHECK)\n .PHONY: image/gif/check\n \n-image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox image/ycbcr.gox \\\n-\t\tio.gox os.gox\n+image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox image/color.gox \\\n+\t\timage/ycbcr.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n image/jpeg/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/jpeg\n \t@$(CHECK)\n .PHONY: image/jpeg/check\n \n-image/png.lo: $(go_image_png_files) bufio.gox compress/zlib.gox fmt.gox \\\n-\t\thash.gox hash/crc32.gox image.gox io.gox os.gox strconv.gox\n+image/png.lo: $(go_image_png_files) bufio.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox fmt.gox hash.gox hash/crc32.gox image.gox \\\n+\t\timage/color.gox io.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n image/png/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/png\n \t@$(CHECK)\n .PHONY: image/png/check\n \n-image/tiff.lo: $(go_image_tiff_files) compress/lzw.gox compress/zlib.gox \\\n-\t\tencoding/binary.gox image.gox io.gox io/ioutil.gox os.gox\n+image/tiff.lo: $(go_image_tiff_files) bufio.gox compress/lzw.gox \\\n+\t\tcompress/zlib.gox encoding/binary.gox image.gox \\\n+\t\timage/color.gox io.gox io/ioutil.gox os.gox\n \t$(BUILDPACKAGE)\n image/tiff/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/tiff\n \t@$(CHECK)\n .PHONY: image/tiff/check\n \n-image/ycbcr.lo: $(go_image_ycbcr_files) image.gox\n+image/ycbcr.lo: $(go_image_ycbcr_files) image.gox image/color.gox\n \t$(BUILDPACKAGE)\n image/ycbcr/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/ycbcr\n \t@$(CHECK)\n .PHONY: image/ycbcr/check\n \n-index/suffixarray.lo: $(go_index_suffixarray_files) bytes.gox regexp.gox \\\n-\t\tsort.gox\n+index/suffixarray.lo: $(go_index_suffixarray_files) bytes.gox \\\n+\t\tencoding/binary.gox io.gox os.gox regexp.gox sort.gox\n \t$(BUILDPACKAGE)\n index/suffixarray/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) index/suffixarray\n@@ -2869,13 +2927,30 @@ net/dict.lo: $(go_net_dict_files) net/textproto.gox os.gox strconv.gox \\\n \t$(BUILDPACKAGE)\n \n net/textproto.lo: $(go_net_textproto_files) bufio.gox bytes.gox fmt.gox \\\n-\t\tio.gox io/ioutil.gox net.gox os.gox strconv.gox sync.gox\n+\t\tio.gox io/ioutil.gox net.gox os.gox strings.gox strconv.gox \\\n+\t\tsync.gox\n \t$(BUILDPACKAGE)\n net/textproto/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) net/textproto\n \t@$(CHECK)\n .PHONY: net/textproto/check\n \n+old/netchan.lo: $(go_old_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n+\t\treflect.gox strconv.gox sync.gox time.gox\n+\t$(BUILDPACKAGE)\n+old/netchan/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) old/netchan\n+\t@$(CHECK)\n+.PHONY: old/netchan/check\n+\n+old/regexp.lo: $(go_old_regexp_files) bytes.gox io.gox os.gox strings.gox \\\n+\t\tutf8.gox\n+\t$(BUILDPACKAGE)\n+old/regexp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) old/regexp\n+\t@$(CHECK)\n+.PHONY: old/regexp/check\n+\n old/template.lo: $(go_old_template_files) bytes.gox fmt.gox io.gox \\\n \t\tio/ioutil.gox os.gox reflect.gox strconv.gox strings.gox \\\n \t\tunicode.gox utf8.gox\n@@ -2915,6 +2990,14 @@ path/filepath/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: path/filepath/check\n \n+regexp/syntax.lo: $(go_regexp_syntax_files) bytes.gox os.gox sort.gox \\\n+\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+regexp/syntax/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) regexp/syntax\n+\t@$(CHECK)\n+.PHONY: regexp/syntax/check\n+\n rpc/jsonrpc.lo: $(go_rpc_jsonrpc_files) fmt.gox io.gox json.gox net.gox \\\n \t\tos.gox rpc.gox sync.gox\n \t$(BUILDPACKAGE)\n@@ -3005,8 +3088,6 @@ crypto.gox: crypto/crypto.lo\n \t$(BUILDGOX)\n csv.gox: csv/csv.lo\n \t$(BUILDGOX)\n-ebnf.gox: ebnf/ebnf.lo\n-\t$(BUILDGOX)\n exec.gox: exec/exec.lo\n \t$(BUILDGOX)\n expvar.gox: expvar/expvar.lo\n@@ -3039,8 +3120,6 @@ mime.gox: mime/mime.lo\n \t$(BUILDGOX)\n net.gox: net/net.lo\n \t$(BUILDGOX)\n-netchan.gox: netchan/netchan.lo\n-\t$(BUILDGOX)\n os.gox: os/os.lo\n \t$(BUILDGOX)\n patch.gox: patch/patch.lo\n@@ -3081,8 +3160,6 @@ testing.gox: testing/testing.lo\n \t$(BUILDGOX)\n time.gox: time/time.lo\n \t$(BUILDGOX)\n-try.gox: try/try.lo\n-\t$(BUILDGOX)\n unicode.gox: unicode/unicode.lo\n \t$(BUILDGOX)\n url.gox: url/url.lo\n@@ -3118,11 +3195,11 @@ container/list.gox: container/list.lo\n \t$(BUILDGOX)\n container/ring.gox: container/ring.lo\n \t$(BUILDGOX)\n-container/vector.gox: container/vector.lo\n-\t$(BUILDGOX)\n \n crypto/aes.gox: crypto/aes.lo\n \t$(BUILDGOX)\n+crypto/bcrypt.gox: crypto/bcrypt.lo\n+\t$(BUILDGOX)\n crypto/blowfish.gox: crypto/blowfish.lo\n \t$(BUILDGOX)\n crypto/cast5.gox: crypto/cast5.lo\n@@ -3212,17 +3289,27 @@ encoding/hex.gox: encoding/hex.lo\n encoding/pem.gox: encoding/pem.lo\n \t$(BUILDGOX)\n \n+exp/ebnf.gox: exp/ebnf.lo\n+\t$(BUILDGOX)\n exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n-exp/regexp.gox: exp/regexp.lo\n+exp/spdy.gox: exp/spdy.lo\n+\t$(BUILDGOX)\n+exp/sql.gox: exp/sql.lo\n+\t$(BUILDGOX)\n+exp/ssh.gox: exp/ssh.lo\n+\t$(BUILDGOX)\n+exp/terminal.gox: exp/terminal.lo\n+\t$(BUILDGOX)\n+exp/types.gox: exp/types.lo\n \t$(BUILDGOX)\n \n exp/gui/x11.gox: exp/gui/x11.lo\n \t$(BUILDGOX)\n \n-exp/regexp/syntax.gox: exp/regexp/syntax.lo\n+exp/sql/driver.gox: exp/sql/driver.lo\n \t$(BUILDGOX)\n \n exp/template/html.gox: exp/template/html.lo\n@@ -3242,10 +3329,6 @@ go/scanner.gox: go/scanner.lo\n \t$(BUILDGOX)\n go/token.gox: go/token.lo\n \t$(BUILDGOX)\n-go/typechecker.gox: go/typechecker.lo\n-\t$(BUILDGOX)\n-go/types.gox: go/types.lo\n-\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -3264,11 +3347,11 @@ http/httptest.gox: http/httptest.lo\n \t$(BUILDGOX)\n http/pprof.gox: http/pprof.lo\n \t$(BUILDGOX)\n-http/spdy.gox: http/spdy.lo\n-\t$(BUILDGOX)\n \n image/bmp.gox: image/bmp.lo\n \t$(BUILDGOX)\n+image/color.gox: image/color.lo\n+\t$(BUILDGOX)\n image/draw.gox: image/draw.lo\n \t$(BUILDGOX)\n image/gif.gox: image/gif.lo\n@@ -3296,6 +3379,10 @@ net/dict.gox: net/dict.lo\n net/textproto.gox: net/textproto.lo\n \t$(BUILDGOX)\n \n+old/netchan.gox: old/netchan.lo\n+\t$(BUILDGOX)\n+old/regexp.gox: old/regexp.lo\n+\t$(BUILDGOX)\n old/template.gox: old/template.lo\n \t$(BUILDGOX)\n \n@@ -3309,6 +3396,9 @@ os/signal.gox: os/signal.lo\n path/filepath.gox: path/filepath.lo\n \t$(BUILDGOX)\n \n+regexp/syntax.gox: regexp/syntax.lo\n+\t$(BUILDGOX)\n+\n rpc/jsonrpc.gox: rpc/jsonrpc.lo\n \t$(BUILDGOX)\n \n@@ -3344,7 +3434,6 @@ TEST_PACKAGES = \\\n \tbytes/check \\\n \tcmath/check \\\n \tcsv/check \\\n-\tebnf/check \\\n \texec/check \\\n \texpvar/check \\\n \tflag/check \\\n@@ -3360,7 +3449,6 @@ TEST_PACKAGES = \\\n \tmail/check \\\n \tmime/check \\\n \tnet/check \\\n-\tnetchan/check \\\n \tos/check \\\n \tpatch/check \\\n \tpath/check \\\n@@ -3379,7 +3467,6 @@ TEST_PACKAGES = \\\n \ttabwriter/check \\\n \ttemplate/check \\\n \ttime/check \\\n-\ttry/check \\\n \tunicode/check \\\n \turl/check \\\n \tutf16/check \\\n@@ -3396,8 +3483,8 @@ TEST_PACKAGES = \\\n \tcontainer/heap/check \\\n \tcontainer/list/check \\\n \tcontainer/ring/check \\\n-\tcontainer/vector/check \\\n \tcrypto/aes/check \\\n+\tcrypto/bcrypt/check \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n@@ -3437,25 +3524,26 @@ TEST_PACKAGES = \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n \tencoding/pem/check \\\n+\texp/ebnf/check \\\n \texp/norm/check \\\n-\texp/regexp/check \\\n-\texp/regexp/syntax/check \\\n+\texp/spdy/check \\\n+\texp/sql/check \\\n+\texp/ssh/check \\\n+\texp/terminal/check \\\n \texp/template/html/check \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n-\tgo/typechecker/check \\\n \t$(go_types_check_omitted_since_it_calls_6g) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n \thash/fnv/check \\\n \thttp/cgi/check \\\n \thttp/fcgi/check \\\n-\thttp/spdy/check \\\n \timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n@@ -3465,11 +3553,14 @@ TEST_PACKAGES = \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n+\told/netchan/check \\\n+\told/regexp/check \\\n \told/template/check \\\n \t$(os_inotify_check) \\\n \tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n+\tregexp/syntax/check \\\n \trpc/jsonrpc/check \\\n \tsync/atomic/check \\\n \ttemplate/parse/check \\"}, {"sha": "05223a6dc5b51e34a55959ba93a38e1e62a11a73", "filename": "libgo/Makefile.in", "status": "modified", "additions": 388, "deletions": 258, "changes": 646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -103,7 +103,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoencodingdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexpguidir)\" \\\n-\t\"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgogodir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgohashdir)\" \\\n@@ -116,6 +116,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoolddir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoosdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgopathdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgoregexpdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgorpcdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoruntimedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgosyncdir)\" \\\n@@ -131,22 +132,21 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tbytes/bytes.lo bytes/index.lo cmath/cmath.lo crypto/crypto.lo \\\n-\tcsv/csv.lo ebnf/ebnf.lo exec/exec.lo expvar/expvar.lo \\\n-\tflag/flag.lo fmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo \\\n-\thttp/http.lo image/image.lo io/io.lo json/json.lo log/log.lo \\\n-\tmath/math.lo mail/mail.lo mime/mime.lo net/net.lo \\\n-\tnetchan/netchan.lo os/os.lo patch/patch.lo path/path.lo \\\n-\trand/rand.lo reflect/reflect.lo regexp/regexp.lo rpc/rpc.lo \\\n-\truntime/runtime.lo scanner/scanner.lo smtp/smtp.lo \\\n+\tcsv/csv.lo exec/exec.lo expvar/expvar.lo flag/flag.lo \\\n+\tfmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo http/http.lo \\\n+\timage/image.lo io/io.lo json/json.lo log/log.lo math/math.lo \\\n+\tmail/mail.lo mime/mime.lo net/net.lo os/os.lo patch/patch.lo \\\n+\tpath/path.lo rand/rand.lo reflect/reflect.lo regexp/regexp.lo \\\n+\trpc/rpc.lo runtime/runtime.lo scanner/scanner.lo smtp/smtp.lo \\\n \tsort/sort.lo strconv/strconv.lo strings/strings.lo \\\n \tsync/sync.lo syslog/syslog.lo syslog/syslog_c.lo \\\n \ttabwriter/tabwriter.lo template/template.lo time/time.lo \\\n-\ttry/try.lo unicode/unicode.lo url/url.lo utf16/utf16.lo \\\n-\tutf8/utf8.lo websocket/websocket.lo xml/xml.lo archive/tar.lo \\\n+\tunicode/unicode.lo url/url.lo utf16/utf16.lo utf8/utf8.lo \\\n+\twebsocket/websocket.lo xml/xml.lo archive/tar.lo \\\n \tarchive/zip.lo compress/bzip2.lo compress/flate.lo \\\n \tcompress/gzip.lo compress/lzw.lo compress/zlib.lo \\\n \tcontainer/heap.lo container/list.lo container/ring.lo \\\n-\tcontainer/vector.lo crypto/aes.lo crypto/blowfish.lo \\\n+\tcrypto/aes.lo crypto/bcrypt.lo crypto/blowfish.lo \\\n \tcrypto/cast5.lo crypto/cipher.lo crypto/des.lo crypto/dsa.lo \\\n \tcrypto/ecdsa.lo crypto/elliptic.lo crypto/hmac.lo \\\n \tcrypto/md4.lo crypto/md5.lo crypto/ocsp.lo crypto/openpgp.lo \\\n@@ -159,22 +159,23 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tcrypto/x509/pkix.lo debug/dwarf.lo debug/elf.lo debug/gosym.lo \\\n \tdebug/macho.lo debug/pe.lo encoding/ascii85.lo \\\n \tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n-\tencoding/git85.lo encoding/hex.lo encoding/pem.lo exp/gui.lo \\\n-\texp/norm.lo exp/regexp.lo exp/gui/x11.lo exp/regexp/syntax.lo \\\n+\tencoding/git85.lo encoding/hex.lo encoding/pem.lo exp/ebnf.lo \\\n+\texp/gui.lo exp/norm.lo exp/spdy.lo exp/sql.lo exp/ssh.lo \\\n+\texp/terminal.lo exp/types.lo exp/gui/x11.lo exp/sql/driver.lo \\\n \texp/template/html.lo go/ast.lo go/build.lo go/doc.lo \\\n \tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n-\tgo/typechecker.lo go/types.lo hash/adler32.lo hash/crc32.lo \\\n-\thash/crc64.lo hash/fnv.lo http/cgi.lo http/fcgi.lo \\\n-\thttp/httptest.lo http/pprof.lo http/spdy.lo image/bmp.lo \\\n-\timage/draw.lo image/gif.lo image/jpeg.lo image/png.lo \\\n-\timage/tiff.lo image/ycbcr.lo index/suffixarray.lo io/ioutil.lo \\\n-\tmime/multipart.lo net/dict.lo net/textproto.lo old/template.lo \\\n-\t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n-\trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n-\tsync/atomic.lo sync/atomic_c.lo syscall/syscall.lo \\\n-\tsyscall/errno.lo syscall/wait.lo template/parse.lo \\\n-\ttesting/testing.lo testing/iotest.lo testing/quick.lo \\\n-\ttesting/script.lo\n+\thash/adler32.lo hash/crc32.lo hash/crc64.lo hash/fnv.lo \\\n+\thttp/cgi.lo http/fcgi.lo http/httptest.lo http/pprof.lo \\\n+\timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo image/tiff.lo image/ycbcr.lo \\\n+\tindex/suffixarray.lo io/ioutil.lo mime/multipart.lo \\\n+\tnet/dict.lo net/textproto.lo old/netchan.lo old/regexp.lo \\\n+\told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n+\tpath/filepath.lo regexp/syntax.lo rpc/jsonrpc.lo \\\n+\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n+\tsync/atomic_c.lo syscall/syscall.lo syscall/errno.lo \\\n+\tsyscall/wait.lo template/parse.lo testing/testing.lo \\\n+\ttesting/iotest.lo testing/quick.lo testing/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -221,8 +222,8 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/mem_posix_memalign.c runtime/mem.c runtime/mfinal.c \\\n \truntime/mfixalloc.c runtime/mgc0.c runtime/mheap.c \\\n \truntime/msize.c runtime/proc.c runtime/thread.c \\\n-\truntime/rtems-task-variable-add.c chan.c iface.c malloc.c \\\n-\tmap.c mprof.c reflect.c sigqueue.c string.c\n+\truntime/yield.c runtime/rtems-task-variable-add.c chan.c \\\n+\tiface.c malloc.c map.c mprof.c reflect.c sigqueue.c string.c\n @HAVE_SYS_MMAN_H_FALSE@am__objects_1 = mem_posix_memalign.lo\n @HAVE_SYS_MMAN_H_TRUE@am__objects_1 = mem.lo\n @LIBGO_IS_RTEMS_TRUE@am__objects_2 = rtems-task-variable-add.lo\n@@ -253,9 +254,9 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n \tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo mcache.lo \\\n \tmcentral.lo $(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo \\\n-\tmheap.lo msize.lo proc.lo thread.lo $(am__objects_2) chan.lo \\\n-\tiface.lo malloc.lo map.lo mprof.lo reflect.lo sigqueue.lo \\\n-\tstring.lo\n+\tmheap.lo msize.lo proc.lo thread.lo yield.lo $(am__objects_2) \\\n+\tchan.lo iface.lo malloc.lo map.lo mprof.lo reflect.lo \\\n+\tsigqueue.lo string.lo\n am_libgo_la_OBJECTS = $(am__objects_3)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -294,16 +295,16 @@ DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgocrypto_DATA) $(toolexeclibgocryptoopenpgp_DATA) \\\n \t$(toolexeclibgocryptox509_DATA) $(toolexeclibgodebug_DATA) \\\n \t$(toolexeclibgoencoding_DATA) $(toolexeclibgoexp_DATA) \\\n-\t$(toolexeclibgoexpgui_DATA) $(toolexeclibgoexpregexp_DATA) \\\n+\t$(toolexeclibgoexpgui_DATA) $(toolexeclibgoexpsql_DATA) \\\n \t$(toolexeclibgoexptemplate_DATA) $(toolexeclibgogo_DATA) \\\n \t$(toolexeclibgohash_DATA) $(toolexeclibgohttp_DATA) \\\n \t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n \t$(toolexeclibgoio_DATA) $(toolexeclibgomime_DATA) \\\n \t$(toolexeclibgonet_DATA) $(toolexeclibgoold_DATA) \\\n \t$(toolexeclibgoos_DATA) $(toolexeclibgopath_DATA) \\\n-\t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgosync_DATA) $(toolexeclibgotemplate_DATA) \\\n-\t$(toolexeclibgotesting_DATA)\n+\t$(toolexeclibgoregexp_DATA) $(toolexeclibgorpc_DATA) \\\n+\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgotemplate_DATA) $(toolexeclibgotesting_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -575,7 +576,6 @@ toolexeclibgo_DATA = \\\n \tcmath.gox \\\n \tcrypto.gox \\\n \tcsv.gox \\\n-\tebnf.gox \\\n \texec.gox \\\n \texpvar.gox \\\n \tflag.gox \\\n@@ -592,7 +592,6 @@ toolexeclibgo_DATA = \\\n \tmail.gox \\\n \tmime.gox \\\n \tnet.gox \\\n-\tnetchan.gox \\\n \tos.gox \\\n \tpatch.gox \\\n \tpath.gox \\\n@@ -613,7 +612,6 @@ toolexeclibgo_DATA = \\\n \ttemplate.gox \\\n \ttesting.gox \\\n \ttime.gox \\\n-\ttry.gox \\\n \tunicode.gox \\\n \turl.gox \\\n \tutf16.gox \\\n@@ -638,12 +636,12 @@ toolexeclibgocontainerdir = $(toolexeclibgodir)/container\n toolexeclibgocontainer_DATA = \\\n \tcontainer/heap.gox \\\n \tcontainer/list.gox \\\n-\tcontainer/ring.gox \\\n-\tcontainer/vector.gox\n+\tcontainer/ring.gox\n \n toolexeclibgocryptodir = $(toolexeclibgodir)/crypto\n toolexeclibgocrypto_DATA = \\\n \tcrypto/aes.gox \\\n+\tcrypto/bcrypt.gox \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n@@ -701,17 +699,22 @@ toolexeclibgoencoding_DATA = \\\n \n toolexeclibgoexpdir = $(toolexeclibgodir)/exp\n toolexeclibgoexp_DATA = \\\n+\texp/ebnf.gox \\\n \texp/gui.gox \\\n \texp/norm.gox \\\n-\texp/regexp.gox\n+\texp/spdy.gox \\\n+\texp/sql.gox \\\n+\texp/ssh.gox \\\n+\texp/terminal.gox \\\n+\texp/types.gox\n \n toolexeclibgoexpguidir = $(toolexeclibgoexpdir)/gui\n toolexeclibgoexpgui_DATA = \\\n \texp/gui/x11.gox\n \n-toolexeclibgoexpregexpdir = $(toolexeclibgoexpdir)/regexp\n-toolexeclibgoexpregexp_DATA = \\\n-\texp/regexp/syntax.gox\n+toolexeclibgoexpsqldir = $(toolexeclibgoexpdir)/sql\n+toolexeclibgoexpsql_DATA = \\\n+\texp/sql/driver.gox\n \n toolexeclibgoexptemplatedir = $(toolexeclibgoexpdir)/template\n toolexeclibgoexptemplate_DATA = \\\n@@ -725,9 +728,7 @@ toolexeclibgogo_DATA = \\\n \tgo/parser.gox \\\n \tgo/printer.gox \\\n \tgo/scanner.gox \\\n-\tgo/token.gox \\\n-\tgo/typechecker.gox \\\n-\tgo/types.gox\n+\tgo/token.gox\n \n toolexeclibgohashdir = $(toolexeclibgodir)/hash\n toolexeclibgohash_DATA = \\\n@@ -741,12 +742,12 @@ toolexeclibgohttp_DATA = \\\n \thttp/cgi.gox \\\n \thttp/fcgi.gox \\\n \thttp/httptest.gox \\\n-\thttp/pprof.gox \\\n-\thttp/spdy.gox\n+\thttp/pprof.gox\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n toolexeclibgoimage_DATA = \\\n \timage/bmp.gox \\\n+\timage/color.gox \\\n \timage/draw.gox \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n@@ -773,6 +774,8 @@ toolexeclibgonet_DATA = \\\n \n toolexeclibgoolddir = $(toolexeclibgodir)/old\n toolexeclibgoold_DATA = \\\n+\told/netchan.gox \\\n+\told/regexp.gox \\\n \told/template.gox\n \n toolexeclibgoosdir = $(toolexeclibgodir)/os\n@@ -789,6 +792,10 @@ toolexeclibgopathdir = $(toolexeclibgodir)/path\n toolexeclibgopath_DATA = \\\n \tpath/filepath.gox\n \n+toolexeclibgoregexpdir = $(toolexeclibgodir)/regexp\n+toolexeclibgoregexp_DATA = \\\n+\tregexp/syntax.gox\n+\n toolexeclibgorpcdir = $(toolexeclibgodir)/rpc\n toolexeclibgorpc_DATA = \\\n \trpc/jsonrpc.gox\n@@ -908,6 +915,7 @@ runtime_files = \\\n \truntime/msize.c \\\n \truntime/proc.c \\\n \truntime/thread.c \\\n+\truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \tchan.c \\\n \tiface.c \\\n@@ -963,10 +971,6 @@ go_csv_files = \\\n \tgo/csv/reader.go \\\n \tgo/csv/writer.go\n \n-go_ebnf_files = \\\n-\tgo/ebnf/ebnf.go \\\n-\tgo/ebnf/parser.go\n-\n go_exec_files = \\\n \tgo/exec/exec.go \\\n \tgo/exec/lp_unix.go\n@@ -1002,13 +1006,15 @@ go_html_files = \\\n \tgo/html/escape.go \\\n \tgo/html/node.go \\\n \tgo/html/parse.go \\\n+\tgo/html/render.go \\\n \tgo/html/token.go\n \n go_http_files = \\\n \tgo/http/chunked.go \\\n \tgo/http/client.go \\\n \tgo/http/cookie.go \\\n \tgo/http/dump.go \\\n+\tgo/http/filetransport.go \\\n \tgo/http/fs.go \\\n \tgo/http/header.go \\\n \tgo/http/lex.go \\\n@@ -1023,7 +1029,6 @@ go_http_files = \\\n \tgo/http/transport.go\n \n go_image_files = \\\n-\tgo/image/color.go \\\n \tgo/image/format.go \\\n \tgo/image/geom.go \\\n \tgo/image/image.go \\\n@@ -1046,6 +1051,7 @@ go_log_files = \\\n \tgo/log/log.go\n \n go_math_files = \\\n+\tgo/math/abs.go \\\n \tgo/math/acosh.go \\\n \tgo/math/asin.go \\\n \tgo/math/asinh.go \\\n@@ -1056,15 +1062,13 @@ go_math_files = \\\n \tgo/math/cbrt.go \\\n \tgo/math/const.go \\\n \tgo/math/copysign.go \\\n+\tgo/math/dim.go \\\n \tgo/math/erf.go \\\n \tgo/math/exp.go \\\n \tgo/math/exp_port.go \\\n \tgo/math/exp2.go \\\n \tgo/math/expm1.go \\\n-\tgo/math/fabs.go \\\n-\tgo/math/fdim.go \\\n \tgo/math/floor.go \\\n-\tgo/math/fmod.go \\\n \tgo/math/frexp.go \\\n \tgo/math/gamma.go \\\n \tgo/math/hypot.go \\\n@@ -1078,6 +1082,7 @@ go_math_files = \\\n \tgo/math/log1p.go \\\n \tgo/math/log10.go \\\n \tgo/math/logb.go \\\n+\tgo/math/mod.go \\\n \tgo/math/modf.go \\\n \tgo/math/nextafter.go \\\n \tgo/math/pow.go \\\n@@ -1156,11 +1161,6 @@ go_net_files = \\\n \tgo/net/unixsock.go \\\n \tgo/net/unixsock_posix.go\n \n-go_netchan_files = \\\n-\tgo/netchan/common.go \\\n-\tgo/netchan/export.go \\\n-\tgo/netchan/import.go\n-\n @LIBGO_IS_386_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_FALSE@go_os_dir_file = go/os/dir_regfile.go\n @LIBGO_IS_386_FALSE@@LIBGO_IS_SOLARIS_TRUE@@LIBGO_IS_SPARC_TRUE@go_os_dir_file = go/os/dir_largefile.go\n @LIBGO_IS_386_TRUE@@LIBGO_IS_SOLARIS_TRUE@go_os_dir_file = go/os/dir_largefile.go\n@@ -1218,6 +1218,7 @@ go_reflect_files = \\\n \tgo/reflect/value.go\n \n go_regexp_files = \\\n+\tgo/regexp/exec.go \\\n \tgo/regexp/regexp.go\n \n go_rpc_files = \\\n@@ -1257,6 +1258,7 @@ go_strconv_files = \\\n \n go_strings_files = \\\n \tgo/strings/reader.go \\\n+\tgo/strings/replace.go \\\n \tgo/strings/strings.go\n \n go_sync_files = \\\n@@ -1289,21 +1291,19 @@ go_template_files = \\\n \n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n+\tgo/testing/example.go \\\n \tgo/testing/testing.go\n \n go_time_files = \\\n \tgo/time/format.go \\\n \tgo/time/sleep.go \\\n \tgo/time/sys.go \\\n-\tgo/time/sys_posix.go \\\n+\tgo/time/sys_unix.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n \tgo/time/zoneinfo_posix.go \\\n \tgo/time/zoneinfo_unix.go\n \n-go_try_files = \\\n-\tgo/try/try.go\n-\n go_unicode_files = \\\n \tgo/unicode/casetables.go \\\n \tgo/unicode/digit.go \\\n@@ -1323,6 +1323,8 @@ go_utf8_files = \\\n \n go_websocket_files = \\\n \tgo/websocket/client.go \\\n+\tgo/websocket/hixie.go \\\n+\tgo/websocket/hybi.go \\\n \tgo/websocket/server.go \\\n \tgo/websocket/websocket.go\n \n@@ -1377,17 +1379,15 @@ go_container_list_files = \\\n go_container_ring_files = \\\n \tgo/container/ring/ring.go\n \n-go_container_vector_files = \\\n-\tgo/container/vector/defs.go \\\n-\tgo/container/vector/intvector.go \\\n-\tgo/container/vector/stringvector.go \\\n-\tgo/container/vector/vector.go\n-\n go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/const.go\n \n+go_crypto_bcrypt_files = \\\n+\tgo/crypto/bcrypt/base64.go \\\n+\tgo/crypto/bcrypt/bcrypt.go\n+\n go_crypto_blowfish_files = \\\n \tgo/crypto/blowfish/block.go \\\n \tgo/crypto/blowfish/const.go \\\n@@ -1480,13 +1480,15 @@ go_crypto_tls_files = \\\n \tgo/crypto/tls/handshake_server.go \\\n \tgo/crypto/tls/key_agreement.go \\\n \tgo/crypto/tls/prf.go \\\n+\tgo/crypto/tls/root_unix.go \\\n \tgo/crypto/tls/tls.go\n \n go_crypto_twofish_files = \\\n \tgo/crypto/twofish/twofish.go\n \n go_crypto_x509_files = \\\n \tgo/crypto/x509/cert_pool.go \\\n+\tgo/crypto/x509/pkcs1.go \\\n \tgo/crypto/x509/verify.go \\\n \tgo/crypto/x509/x509.go\n \n@@ -1558,7 +1560,8 @@ go_encoding_base64_files = \\\n \tgo/encoding/base64/base64.go\n \n go_encoding_binary_files = \\\n-\tgo/encoding/binary/binary.go\n+\tgo/encoding/binary/binary.go \\\n+\tgo/encoding/binary/varint.go\n \n go_encoding_git85_files = \\\n \tgo/encoding/git85/git.go\n@@ -1569,35 +1572,73 @@ go_encoding_hex_files = \\\n go_encoding_pem_files = \\\n \tgo/encoding/pem/pem.go\n \n+go_exp_ebnf_files = \\\n+\tgo/exp/ebnf/ebnf.go \\\n+\tgo/exp/ebnf/parser.go\n+\n go_exp_gui_files = \\\n \tgo/exp/gui/gui.go\n \n go_exp_norm_files = \\\n \tgo/exp/norm/composition.go \\\n \tgo/exp/norm/forminfo.go \\\n+\tgo/exp/norm/input.go \\\n \tgo/exp/norm/normalize.go \\\n+\tgo/exp/norm/readwriter.go \\\n \tgo/exp/norm/tables.go \\\n \tgo/exp/norm/trie.go\n \n-go_exp_regexp_files = \\\n-\tgo/exp/regexp/exec.go \\\n-\tgo/exp/regexp/regexp.go\n+go_exp_spdy_files = \\\n+\tgo/exp/spdy/read.go \\\n+\tgo/exp/spdy/types.go \\\n+\tgo/exp/spdy/write.go\n+\n+go_exp_sql_files = \\\n+\tgo/exp/sql/convert.go \\\n+\tgo/exp/sql/sql.go\n+\n+go_exp_ssh_files = \\\n+\tgo/exp/ssh/channel.go \\\n+\tgo/exp/ssh/common.go \\\n+\tgo/exp/ssh/doc.go \\\n+\tgo/exp/ssh/messages.go \\\n+\tgo/exp/ssh/server.go \\\n+\tgo/exp/ssh/server_shell.go \\\n+\tgo/exp/ssh/transport.go\n+\n+go_exp_terminal_files = \\\n+\tgo/exp/terminal/shell.go \\\n+\tgo/exp/terminal/terminal.go\n+\n+go_exp_types_files = \\\n+\tgo/exp/types/check.go \\\n+\tgo/exp/types/const.go \\\n+\tgo/exp/types/exportdata.go \\\n+\tgo/exp/types/gcimporter.go \\\n+\tgo/exp/types/types.go \\\n+\tgo/exp/types/universe.go\n \n go_exp_gui_x11_files = \\\n \tgo/exp/gui/x11/auth.go \\\n \tgo/exp/gui/x11/conn.go\n \n+go_exp_sql_driver_files = \\\n+\tgo/exp/sql/driver/driver.go \\\n+\tgo/exp/sql/driver/types.go\n+\n go_exp_template_html_files = \\\n+\tgo/exp/template/html/attr.go \\\n+\tgo/exp/template/html/clone.go \\\n+\tgo/exp/template/html/content.go \\\n \tgo/exp/template/html/context.go \\\n-\tgo/exp/template/html/escape.go\n-\n-go_exp_regexp_syntax_files = \\\n-\tgo/exp/regexp/syntax/compile.go \\\n-\tgo/exp/regexp/syntax/parse.go \\\n-\tgo/exp/regexp/syntax/perl_groups.go \\\n-\tgo/exp/regexp/syntax/prog.go \\\n-\tgo/exp/regexp/syntax/regexp.go \\\n-\tgo/exp/regexp/syntax/simplify.go\n+\tgo/exp/template/html/css.go \\\n+\tgo/exp/template/html/doc.go \\\n+\tgo/exp/template/html/error.go \\\n+\tgo/exp/template/html/escape.go \\\n+\tgo/exp/template/html/html.go \\\n+\tgo/exp/template/html/js.go \\\n+\tgo/exp/template/html/transition.go \\\n+\tgo/exp/template/html/url.go\n \n go_go_ast_files = \\\n \tgo/go/ast/ast.go \\\n@@ -1615,7 +1656,8 @@ go_go_build_files = \\\n \n go_go_doc_files = \\\n \tgo/go/doc/comment.go \\\n-\tgo/go/doc/doc.go\n+\tgo/go/doc/doc.go \\\n+\tgo/go/doc/example.go\n \n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n@@ -1631,22 +1673,9 @@ go_go_scanner_files = \\\n \n go_go_token_files = \\\n \tgo/go/token/position.go \\\n+\tgo/go/token/serialize.go \\\n \tgo/go/token/token.go\n \n-go_go_typechecker_files = \\\n-\tgo/go/typechecker/scope.go \\\n-\tgo/go/typechecker/type.go \\\n-\tgo/go/typechecker/typechecker.go \\\n-\tgo/go/typechecker/universe.go\n-\n-go_go_types_files = \\\n-\tgo/go/types/check.go \\\n-\tgo/go/types/const.go \\\n-\tgo/go/types/exportdata.go \\\n-\tgo/go/types/gcimporter.go \\\n-\tgo/go/types/types.go \\\n-\tgo/go/types/universe.go\n-\n go_hash_adler32_files = \\\n \tgo/hash/adler32/adler32.go\n \n@@ -1675,14 +1704,12 @@ go_http_httptest_files = \\\n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n \n-go_http_spdy_files = \\\n-\tgo/http/spdy/read.go \\\n-\tgo/http/spdy/types.go \\\n-\tgo/http/spdy/write.go\n-\n go_image_bmp_files = \\\n \tgo/image/bmp/reader.go\n \n+go_image_color_files = \\\n+\tgo/image/color/color.go\n+\n go_image_draw_files = \\\n \tgo/image/draw/draw.go\n \n@@ -1702,6 +1729,7 @@ go_image_png_files = \\\n \n go_image_tiff_files = \\\n \tgo/image/tiff/buffer.go \\\n+\tgo/image/tiff/compress.go \\\n \tgo/image/tiff/consts.go \\\n \tgo/image/tiff/reader.go\n \n@@ -1731,6 +1759,14 @@ go_net_textproto_files = \\\n \tgo/net/textproto/textproto.go \\\n \tgo/net/textproto/writer.go\n \n+go_old_netchan_files = \\\n+\tgo/old/netchan/common.go \\\n+\tgo/old/netchan/export.go \\\n+\tgo/old/netchan/import.go\n+\n+go_old_regexp_files = \\\n+\tgo/old/regexp/regexp.go\n+\n go_old_template_files = \\\n \tgo/old/template/doc.go \\\n \tgo/old/template/execute.go \\\n@@ -1752,6 +1788,14 @@ go_path_filepath_files = \\\n \tgo/path/filepath/path.go \\\n \tgo/path/filepath/path_unix.go\n \n+go_regexp_syntax_files = \\\n+\tgo/regexp/syntax/compile.go \\\n+\tgo/regexp/syntax/parse.go \\\n+\tgo/regexp/syntax/perl_groups.go \\\n+\tgo/regexp/syntax/prog.go \\\n+\tgo/regexp/syntax/regexp.go \\\n+\tgo/regexp/syntax/simplify.go\n+\n go_rpc_jsonrpc_files = \\\n \tgo/rpc/jsonrpc/client.go \\\n \tgo/rpc/jsonrpc/server.go\n@@ -1878,7 +1922,6 @@ libgo_go_objs = \\\n \tcmath/cmath.lo \\\n \tcrypto/crypto.lo \\\n \tcsv/csv.lo \\\n-\tebnf/ebnf.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n \tflag/flag.lo \\\n@@ -1895,7 +1938,6 @@ libgo_go_objs = \\\n \tmail/mail.lo \\\n \tmime/mime.lo \\\n \tnet/net.lo \\\n-\tnetchan/netchan.lo \\\n \tos/os.lo \\\n \tpatch/patch.lo \\\n \tpath/path.lo \\\n@@ -1915,7 +1957,6 @@ libgo_go_objs = \\\n \ttabwriter/tabwriter.lo \\\n \ttemplate/template.lo \\\n \ttime/time.lo \\\n-\ttry/try.lo \\\n \tunicode/unicode.lo \\\n \turl/url.lo \\\n \tutf16/utf16.lo \\\n@@ -1932,8 +1973,8 @@ libgo_go_objs = \\\n \tcontainer/heap.lo \\\n \tcontainer/list.lo \\\n \tcontainer/ring.lo \\\n-\tcontainer/vector.lo \\\n \tcrypto/aes.lo \\\n+\tcrypto/bcrypt.lo \\\n \tcrypto/blowfish.lo \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n@@ -1976,11 +2017,16 @@ libgo_go_objs = \\\n \tencoding/git85.lo \\\n \tencoding/hex.lo \\\n \tencoding/pem.lo \\\n+\texp/ebnf.lo \\\n \texp/gui.lo \\\n \texp/norm.lo \\\n-\texp/regexp.lo \\\n+\texp/spdy.lo \\\n+\texp/sql.lo \\\n+\texp/ssh.lo \\\n+\texp/terminal.lo \\\n+\texp/types.lo \\\n \texp/gui/x11.lo \\\n-\texp/regexp/syntax.lo \\\n+\texp/sql/driver.lo \\\n \texp/template/html.lo \\\n \tgo/ast.lo \\\n \tgo/build.lo \\\n@@ -1989,8 +2035,6 @@ libgo_go_objs = \\\n \tgo/printer.lo \\\n \tgo/scanner.lo \\\n \tgo/token.lo \\\n-\tgo/typechecker.lo \\\n-\tgo/types.lo \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n@@ -1999,8 +2043,8 @@ libgo_go_objs = \\\n \thttp/fcgi.lo \\\n \thttp/httptest.lo \\\n \thttp/pprof.lo \\\n-\thttp/spdy.lo \\\n \timage/bmp.lo \\\n+\timage/color.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n@@ -2012,11 +2056,14 @@ libgo_go_objs = \\\n \tmime/multipart.lo \\\n \tnet/dict.lo \\\n \tnet/textproto.lo \\\n+\told/netchan.lo \\\n+\told/regexp.lo \\\n \told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/user.lo \\\n \tos/signal.lo \\\n \tpath/filepath.lo \\\n+\tregexp/syntax.lo \\\n \trpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n@@ -2135,7 +2182,6 @@ TEST_PACKAGES = \\\n \tbytes/check \\\n \tcmath/check \\\n \tcsv/check \\\n-\tebnf/check \\\n \texec/check \\\n \texpvar/check \\\n \tflag/check \\\n@@ -2151,7 +2197,6 @@ TEST_PACKAGES = \\\n \tmail/check \\\n \tmime/check \\\n \tnet/check \\\n-\tnetchan/check \\\n \tos/check \\\n \tpatch/check \\\n \tpath/check \\\n@@ -2170,7 +2215,6 @@ TEST_PACKAGES = \\\n \ttabwriter/check \\\n \ttemplate/check \\\n \ttime/check \\\n-\ttry/check \\\n \tunicode/check \\\n \turl/check \\\n \tutf16/check \\\n@@ -2187,8 +2231,8 @@ TEST_PACKAGES = \\\n \tcontainer/heap/check \\\n \tcontainer/list/check \\\n \tcontainer/ring/check \\\n-\tcontainer/vector/check \\\n \tcrypto/aes/check \\\n+\tcrypto/bcrypt/check \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n@@ -2228,25 +2272,26 @@ TEST_PACKAGES = \\\n \tencoding/git85/check \\\n \tencoding/hex/check \\\n \tencoding/pem/check \\\n+\texp/ebnf/check \\\n \texp/norm/check \\\n-\texp/regexp/check \\\n-\texp/regexp/syntax/check \\\n+\texp/spdy/check \\\n+\texp/sql/check \\\n+\texp/ssh/check \\\n+\texp/terminal/check \\\n \texp/template/html/check \\\n \tgo/ast/check \\\n \t$(go_build_check_omitted_since_it_calls_6g) \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n \tgo/token/check \\\n-\tgo/typechecker/check \\\n \t$(go_types_check_omitted_since_it_calls_6g) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n \thash/fnv/check \\\n \thttp/cgi/check \\\n \thttp/fcgi/check \\\n-\thttp/spdy/check \\\n \timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n@@ -2256,11 +2301,14 @@ TEST_PACKAGES = \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n+\told/netchan/check \\\n+\told/regexp/check \\\n \told/template/check \\\n \t$(os_inotify_check) \\\n \tos/user/check \\\n \tos/signal/check \\\n \tpath/filepath/check \\\n+\tregexp/syntax/check \\\n \trpc/jsonrpc/check \\\n \tsync/atomic/check \\\n \ttemplate/parse/check \\\n@@ -2503,6 +2551,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sigqueue.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/yield.Plo@am__quote@\n \n .c.o:\n @am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@@ -3183,6 +3232,13 @@ thread.lo: runtime/thread.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o thread.lo `test -f 'runtime/thread.c' || echo '$(srcdir)/'`runtime/thread.c\n \n+yield.lo: runtime/yield.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT yield.lo -MD -MP -MF $(DEPDIR)/yield.Tpo -c -o yield.lo `test -f 'runtime/yield.c' || echo '$(srcdir)/'`runtime/yield.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/yield.Tpo $(DEPDIR)/yield.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/yield.c' object='yield.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o yield.lo `test -f 'runtime/yield.c' || echo '$(srcdir)/'`runtime/yield.c\n+\n rtems-task-variable-add.lo: runtime/rtems-task-variable-add.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT rtems-task-variable-add.lo -MD -MP -MF $(DEPDIR)/rtems-task-variable-add.Tpo -c -o rtems-task-variable-add.lo `test -f 'runtime/rtems-task-variable-add.c' || echo '$(srcdir)/'`runtime/rtems-task-variable-add.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/rtems-task-variable-add.Tpo $(DEPDIR)/rtems-task-variable-add.Plo\n@@ -3435,26 +3491,26 @@ uninstall-toolexeclibgoexpguiDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpguidir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoexpguidir)\" && rm -f $$files\n-install-toolexeclibgoexpregexpDATA: $(toolexeclibgoexpregexp_DATA)\n+install-toolexeclibgoexpsqlDATA: $(toolexeclibgoexpsql_DATA)\n \t@$(NORMAL_INSTALL)\n-\ttest -z \"$(toolexeclibgoexpregexpdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\"\n-\t@list='$(toolexeclibgoexpregexp_DATA)'; test -n \"$(toolexeclibgoexpregexpdir)\" || list=; \\\n+\ttest -z \"$(toolexeclibgoexpsqldir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexpsqldir)\"\n+\t@list='$(toolexeclibgoexpsql_DATA)'; test -n \"$(toolexeclibgoexpsqldir)\" || list=; \\\n \tfor p in $$list; do \\\n \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; \\\n \tdone | $(am__base_list) | \\\n \twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpregexpdir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" || exit $$?; \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoexpsqldir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" || exit $$?; \\\n \tdone\n \n-uninstall-toolexeclibgoexpregexpDATA:\n+uninstall-toolexeclibgoexpsqlDATA:\n \t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclibgoexpregexp_DATA)'; test -n \"$(toolexeclibgoexpregexpdir)\" || list=; \\\n+\t@list='$(toolexeclibgoexpsql_DATA)'; test -n \"$(toolexeclibgoexpsqldir)\" || list=; \\\n \tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n \ttest -n \"$$files\" || exit 0; \\\n-\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpregexpdir)' && rm -f\" $$files \")\"; \\\n-\tcd \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" && rm -f $$files\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoexpsqldir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" && rm -f $$files\n install-toolexeclibgoexptemplateDATA: $(toolexeclibgoexptemplate_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgoexptemplatedir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\"\n@@ -3695,6 +3751,26 @@ uninstall-toolexeclibgopathDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgopathdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgopathdir)\" && rm -f $$files\n+install-toolexeclibgoregexpDATA: $(toolexeclibgoregexp_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgoregexpdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgoregexpdir)\"\n+\t@list='$(toolexeclibgoregexp_DATA)'; test -n \"$(toolexeclibgoregexpdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgoregexpdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgoregexpdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgoregexpDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgoregexp_DATA)'; test -n \"$(toolexeclibgoregexpdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgoregexpdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgoregexpdir)\" && rm -f $$files\n install-toolexeclibgorpcDATA: $(toolexeclibgorpc_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgorpcdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgorpcdir)\"\n@@ -4112,7 +4188,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexpguidir)\" \"$(DESTDIR)$(toolexeclibgoexpregexpdir)\" \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotemplatedir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgocryptox509dir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgoexpguidir)\" \"$(DESTDIR)$(toolexeclibgoexpsqldir)\" \"$(DESTDIR)$(toolexeclibgoexptemplatedir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoolddir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgoregexpdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotemplatedir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -4183,15 +4259,16 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n \tinstall-toolexeclibgoexpguiDATA \\\n-\tinstall-toolexeclibgoexpregexpDATA \\\n+\tinstall-toolexeclibgoexpsqlDATA \\\n \tinstall-toolexeclibgoexptemplateDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n \tinstall-toolexeclibgooldDATA install-toolexeclibgoosDATA \\\n-\tinstall-toolexeclibgopathDATA install-toolexeclibgorpcDATA \\\n-\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n+\tinstall-toolexeclibgopathDATA install-toolexeclibgoregexpDATA \\\n+\tinstall-toolexeclibgorpcDATA install-toolexeclibgoruntimeDATA \\\n+\tinstall-toolexeclibgosyncDATA \\\n \tinstall-toolexeclibgotemplateDATA \\\n \tinstall-toolexeclibgotestingDATA\n \n@@ -4247,15 +4324,17 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgoencodingDATA \\\n \tuninstall-toolexeclibgoexpDATA \\\n \tuninstall-toolexeclibgoexpguiDATA \\\n-\tuninstall-toolexeclibgoexpregexpDATA \\\n+\tuninstall-toolexeclibgoexpsqlDATA \\\n \tuninstall-toolexeclibgoexptemplateDATA \\\n \tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohttpDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n \tuninstall-toolexeclibgooldDATA uninstall-toolexeclibgoosDATA \\\n-\tuninstall-toolexeclibgopathDATA uninstall-toolexeclibgorpcDATA \\\n+\tuninstall-toolexeclibgopathDATA \\\n+\tuninstall-toolexeclibgoregexpDATA \\\n+\tuninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n \tuninstall-toolexeclibgotemplateDATA \\\n@@ -4290,15 +4369,16 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgodebugDATA \\\n \tinstall-toolexeclibgoencodingDATA install-toolexeclibgoexpDATA \\\n \tinstall-toolexeclibgoexpguiDATA \\\n-\tinstall-toolexeclibgoexpregexpDATA \\\n+\tinstall-toolexeclibgoexpsqlDATA \\\n \tinstall-toolexeclibgoexptemplateDATA \\\n \tinstall-toolexeclibgogoDATA install-toolexeclibgohashDATA \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n \tinstall-toolexeclibgooldDATA install-toolexeclibgoosDATA \\\n-\tinstall-toolexeclibgopathDATA install-toolexeclibgorpcDATA \\\n-\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n+\tinstall-toolexeclibgopathDATA install-toolexeclibgoregexpDATA \\\n+\tinstall-toolexeclibgorpcDATA install-toolexeclibgoruntimeDATA \\\n+\tinstall-toolexeclibgosyncDATA \\\n \tinstall-toolexeclibgotemplateDATA \\\n \tinstall-toolexeclibgotestingDATA installcheck installcheck-am \\\n \tinstalldirs installdirs-am maintainer-clean \\\n@@ -4318,15 +4398,17 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgoencodingDATA \\\n \tuninstall-toolexeclibgoexpDATA \\\n \tuninstall-toolexeclibgoexpguiDATA \\\n-\tuninstall-toolexeclibgoexpregexpDATA \\\n+\tuninstall-toolexeclibgoexpsqlDATA \\\n \tuninstall-toolexeclibgoexptemplateDATA \\\n \tuninstall-toolexeclibgogoDATA uninstall-toolexeclibgohashDATA \\\n \tuninstall-toolexeclibgohttpDATA \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n \tuninstall-toolexeclibgooldDATA uninstall-toolexeclibgoosDATA \\\n-\tuninstall-toolexeclibgopathDATA uninstall-toolexeclibgorpcDATA \\\n+\tuninstall-toolexeclibgopathDATA \\\n+\tuninstall-toolexeclibgoregexpDATA \\\n+\tuninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n \tuninstall-toolexeclibgotemplateDATA \\\n@@ -4440,13 +4522,6 @@ csv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: csv/check\n \n-ebnf/ebnf.lo: $(go_ebnf_files) container/vector.gox go/scanner.gox \\\n-\t\tgo/token.gox os.gox strconv.gox unicode.gox utf8.gox\n-\t$(BUILDPACKAGE)\n-ebnf/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: ebnf/check\n-\n exec/exec.lo: $(go_exec_files) bytes.gox io.gox os.gox strconv.gox \\\n \t\tstrings.gox syscall.gox\n \t$(BUILDPACKAGE)\n@@ -4468,7 +4543,7 @@ flag/check: $(CHECK_DEPS)\n .PHONY: flag/check\n \n fmt/fmt.lo: $(go_fmt_files) bytes.gox io.gox math.gox os.gox reflect.gox \\\n-\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n+\t\tstrconv.gox strings.gox sync.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n fmt/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4488,8 +4563,8 @@ hash/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/check\n \n-html/html.lo: $(go_html_files) bytes.gox io.gox os.gox strconv.gox strings.gox \\\n-\t\tutf8.gox\n+html/html.lo: $(go_html_files) bufio.gox bytes.gox fmt.gox io.gox os.gox \\\n+\t\tstrconv.gox strings.gox utf8.gox\n \t$(BUILDPACKAGE)\n html/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4506,7 +4581,8 @@ http/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/check\n \n-image/image.lo: $(go_image_files) bufio.gox io.gox os.gox strconv.gox\n+image/image.lo: $(go_image_files) bufio.gox image/color.gox io.gox os.gox \\\n+\t\tstrconv.gox\n \t$(BUILDPACKAGE)\n image/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4562,13 +4638,6 @@ net/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: net/check\n \n-netchan/netchan.lo: $(go_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n-\t\treflect.gox strconv.gox sync.gox time.gox\n-\t$(BUILDPACKAGE)\n-netchan/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: netchan/check\n-\n os/os.lo: $(go_os_files) runtime.gox sync.gox syscall.gox\n \t$(BUILDPACKAGE)\n os/check: $(CHECK_DEPS)\n@@ -4606,8 +4675,8 @@ reflect/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: reflect/check\n \n-regexp/regexp.lo: $(go_regexp_files) bytes.gox io.gox os.gox strings.gox \\\n-\t\tutf8.gox\n+regexp/regexp.lo: $(go_regexp_files) bytes.gox io.gox os.gox \\\n+\t\tregexp/syntax.gox strconv.gox strings.gox sync.gox utf8.gox\n \t$(BUILDPACKAGE)\n regexp/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4654,7 +4723,7 @@ strconv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: strconv/check\n \n-strings/strings.lo: $(go_strings_files) os.gox unicode.gox utf8.gox\n+strings/strings.lo: $(go_strings_files) io.gox os.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n strings/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4689,8 +4758,9 @@ template/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: template/check\n \n-testing/testing.lo: $(go_testing_files) flag.gox fmt.gox os.gox regexp.gox \\\n-\t\truntime.gox runtime/pprof.gox strings.gox strconv.gox time.gox\n+testing/testing.lo: $(go_testing_files) bytes.gox flag.gox fmt.gox io.gox \\\n+\t\tos.gox regexp.gox runtime.gox runtime/pprof.gox strings.gox \\\n+\t\tstrconv.gox time.gox\n \t$(BUILDPACKAGE)\n testing/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4703,12 +4773,6 @@ time/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: time/check\n \n-try/try.lo: $(go_try_files) fmt.gox io.gox os.gox reflect.gox unicode.gox\n-\t$(BUILDPACKAGE)\n-try/check: $(CHECK_DEPS)\n-\t@$(CHECK)\n-.PHONY: try/check\n-\n unicode/unicode.lo: $(go_unicode_files)\n \t$(BUILDPACKAGE)\n unicode/check: $(CHECK_DEPS)\n@@ -4734,8 +4798,10 @@ utf8/check: $(CHECK_DEPS)\n .PHONY: utf8/check\n \n websocket/websocket.lo: $(go_websocket_files) bufio.gox bytes.gox \\\n-\t\tcrypto/md5.gox crypto/tls.gox encoding/binary.gox fmt.gox \\\n-\t\thttp.gox io.gox net.gox os.gox rand.gox strings.gox url.gox\n+\t\tcrypto/md5.gox crypto/rand.gox crypto/sha1.gox crypto/tls.gox \\\n+\t\tencoding/base64.gox encoding/binary.gox fmt.gox http.gox \\\n+\t\tio.gox io/ioutil.gox json.gox net.gox os.gox rand.gox \\\n+\t\tstrings.gox strconv.gox sync.gox url.gox\n \t$(BUILDPACKAGE)\n websocket/check: $(CHECK_DEPS)\n \t@$(CHECK)\n@@ -4824,20 +4890,22 @@ container/ring/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: container/ring/check\n \n-container/vector.lo: $(go_container_vector_files)\n-\t$(BUILDPACKAGE)\n-container/vector/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) container/vector\n-\t@$(CHECK)\n-.PHONY: container/vector/check\n-\n crypto/aes.lo: $(go_crypto_aes_files) os.gox strconv.gox\n \t$(BUILDPACKAGE)\n crypto/aes/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/aes\n \t@$(CHECK)\n .PHONY: crypto/aes/check\n \n+crypto/bcrypt.lo: $(go_crypto_bcrypt_files) crypto/blowfish.gox \\\n+\t\tcrypto/rand.gox crypto/subtle.gox encoding/base64.gox \\\n+\t\tfmt.gox io.gox os.gox strconv.gox\n+\t$(BUILDPACKAGE)\n+crypto/bcrypt/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/bcrypt\n+\t@$(CHECK)\n+.PHONY: crypto/bcrypt/check\n+\n crypto/blowfish.lo: $(go_crypto_blowfish_files) os.gox strconv.gox\n \t$(BUILDPACKAGE)\n crypto/blowfish/check: $(CHECK_DEPS)\n@@ -4990,12 +5058,12 @@ crypto/subtle/check: $(CHECK_DEPS)\n .PHONY: crypto/subtle/check\n \n crypto/tls.lo: $(go_crypto_tls_files) big.gox bytes.gox crypto.gox \\\n-\t\tcrypto/aes.gox crypto/cipher.gox crypto/elliptic.gox \\\n-\t\tcrypto/hmac.gox crypto/md5.gox crypto/rand.gox crypto/rc4.gox \\\n-\t\tcrypto/rsa.gox crypto/sha1.gox crypto/subtle.gox \\\n-\t\tcrypto/x509.gox crypto/x509/pkix.gox encoding/pem.gox \\\n-\t\thash.gox io.gox io/ioutil.gox net.gox os.gox strconv.gox \\\n-\t\tstrings.gox sync.gox time.gox\n+\t\tcrypto/aes.gox crypto/cipher.gox crypto/des.gox \\\n+\t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n+\t\tcrypto/rand.gox crypto/rc4.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox crypto/x509.gox crypto/x509/pkix.gox \\\n+\t\tencoding/pem.gox hash.gox io.gox io/ioutil.gox net.gox os.gox \\\n+\t\tstrconv.gox strings.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/tls/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/tls\n@@ -5170,27 +5238,70 @@ encoding/pem/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: encoding/pem/check\n \n+exp/ebnf.lo: $(go_exp_ebnf_files) go/scanner.gox go/token.gox os.gox \\\n+\t\tstrconv.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+exp/ebnf/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/ebnf\n+\t@$(CHECK)\n+.PHONY: exp/ebnf/check\n+\n exp/gui.lo: $(go_exp_gui_files) image.gox image/draw.gox os.gox\n \t$(BUILDPACKAGE)\n exp/gui/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/gui\n \t@$(CHECK)\n .PHONY: exp/gui/check\n \n-exp/norm.lo: $(go_exp_norm_files) utf8.gox\n+exp/norm.lo: $(go_exp_norm_files) io.gox os.gox utf8.gox\n \t$(BUILDPACKAGE)\n exp/norm/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/norm\n \t@$(CHECK)\n .PHONY: exp/norm/check\n \n-exp/regexp.lo: $(go_exp_regexp_files) bytes.gox exp/regexp/syntax.gox io.gox \\\n-\t\tos.gox strings.gox sync.gox utf8.gox\n+exp/spdy.lo: $(go_exp_spdy_files) bytes.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox http.gox io.gox os.gox strings.gox\n+\t$(BUILDPACKAGE)\n+exp/spdy/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/spdy\n+\t@$(CHECK)\n+.PHONY: exp/spdy/check\n+\n+exp/sql.lo: $(go_exp_sql_files) exp/sql/driver.gox fmt.gox os.gox reflect.gox \\\n+\t\truntime.gox strconv.gox sync.gox\n+\t$(BUILDPACKAGE)\n+exp/sql/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/sql\n+\t@$(CHECK)\n+.PHONY: exp/sql/check\n+\n+exp/ssh.lo: $(go_exp_ssh_files) big.gox bufio.gox bytes.gox crypto.gox \\\n+\t\tcrypto/aes.gox crypto/cipher.gox crypto/hmac.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox crypto/x509.gox encoding/pem.gox hash.gox \\\n+\t\tio.gox net.gox os.gox reflect.gox strconv.gox sync.gox\n+\t$(BUILDPACKAGE)\n+exp/ssh/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/ssh\n+\t@$(CHECK)\n+.PHONY: exp/ssh/check\n+\n+exp/terminal.lo: $(go_exp_terminal_files) io.gox os.gox syscall.gox\n \t$(BUILDPACKAGE)\n-exp/regexp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/regexp\n+exp/terminal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/terminal\n \t@$(CHECK)\n-.PHONY: exp/regexp/check\n+.PHONY: exp/terminal/check\n+\n+exp/types.lo: $(go_exp_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n+\t\tscanner.gox sort.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+exp/types/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/types\n+\t@$(CHECK)\n+.PHONY: exp/types/check\n \n exp/gui/x11.lo: $(go_exp_gui_x11_files) bufio.gox exp/gui.gox image.gox \\\n \t\timage/draw.gox io.gox log.gox net.gox os.gox strconv.gox \\\n@@ -5201,15 +5312,17 @@ exp/gui/x11/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/gui/x11/check\n \n-exp/regexp/syntax.lo: $(go_exp_regexp_syntax_files) bytes.gox os.gox sort.gox strconv.gox strings.gox unicode.gox utf8.gox\n+exp/sql/driver.lo: $(go_exp_sql_driver_files) fmt.gox os.gox reflect.gox \\\n+\t\tstrconv.gox\n \t$(BUILDPACKAGE)\n-exp/regexp/syntax/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) exp/regexp/syntax\n+exp/sql/driver/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/sql/driver\n \t@$(CHECK)\n-.PHONY: exp/regexp/syntax/check\n+.PHONY: exp/sql/driver/check\n \n-exp/template/html.lo: $(go_exp_template_html_files) fmt.gox template.gox \\\n-\t\ttemplate/parse.gox\n+exp/template/html.lo: $(go_exp_template_html_files) bytes.gox fmt.gox \\\n+\t\thtml.gox json.gox os.gox strings.gox template.gox \\\n+\t\ttemplate/parse.gox unicode.gox utf8.gox \n \t$(BUILDPACKAGE)\n exp/template/html/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) exp/template/html\n@@ -5224,9 +5337,10 @@ go/ast/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/ast/check\n \n-go/build.lo: $(go_go_build_files) bytes.gox exec.gox fmt.gox go/parser.gox \\\n-\t\tgo/token.gox log.gox os.gox path/filepath.gox regexp.gox \\\n-\t\truntime.gox strconv.gox strings.gox runtime.gox\n+go/build.lo: $(go_go_build_files) bytes.gox exec.gox fmt.gox go/ast.gox \\\n+\t\tgo/doc.gox go/parser.gox go/token.gox io/ioutil.gox log.gox \\\n+\t\tos.gox path.gox path/filepath.gox regexp.gox runtime.gox \\\n+\t\tsort.gox strconv.gox strings.gox runtime.gox unicode.gox\n \t$(BUILDPACKAGE)\n go/build/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/build\n@@ -5243,7 +5357,7 @@ s-syslist: Makefile\n \t$(STAMP) $@\n \n go/doc.lo: $(go_go_doc_files) go/ast.gox go/token.gox io.gox regexp.gox \\\n-\t\tsort.gox strings.gox template.gox\n+\t\tsort.gox strings.gox template.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/doc/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/doc\n@@ -5261,7 +5375,7 @@ go/parser/check: $(CHECK_DEPS)\n \n go/printer.lo: $(go_go_printer_files) bytes.gox fmt.gox go/ast.gox \\\n \t\tgo/token.gox io.gox os.gox path/filepath.gox reflect.gox \\\n-\t\truntime.gox strings.gox tabwriter.gox\n+\t\tstrings.gox tabwriter.gox\n \t$(BUILDPACKAGE)\n go/printer/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/printer\n@@ -5277,30 +5391,14 @@ go/scanner/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: go/scanner/check\n \n-go/token.lo: $(go_go_token_files) fmt.gox strconv.gox\n+go/token.lo: $(go_go_token_files) fmt.gox gob.gox io.gox os.gox sort.gox \\\n+\t\tstrconv.gox sync.gox\n \t$(BUILDPACKAGE)\n go/token/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/token\n \t@$(CHECK)\n .PHONY: go/token/check\n \n-go/typechecker.lo: $(go_go_typechecker_files) fmt.gox go/ast.gox go/token.gox \\\n-\t\tgo/scanner.gox os.gox\n-\t$(BUILDPACKAGE)\n-go/typechecker/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) go/typechecker\n-\t@$(CHECK)\n-.PHONY: go/typechecker/check\n-\n-go/types.lo: $(go_go_types_files) big.gox bufio.gox fmt.gox go/ast.gox \\\n-\t\tgo/token.gox io.gox os.gox path/filepath.gox runtime.gox \\\n-\t\tscanner.gox sort.gox strconv.gox strings.gox\n-\t$(BUILDPACKAGE)\n-go/types/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) go/types\n-\t@$(CHECK)\n-.PHONY: go/types/check\n-\n hash/adler32.lo: $(go_hash_adler32_files) hash.gox os.gox\n \t$(BUILDPACKAGE)\n hash/adler32/check: $(CHECK_DEPS)\n@@ -5364,70 +5462,70 @@ http/pprof/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/pprof/check\n \n-http/spdy.lo: $(go_http_spdy_files) bytes.gox compress/zlib.gox \\\n-\t\tencoding/binary.gox http.gox io.gox os.gox strconv.gox \\\n-\t\tstrings.gox sync.gox\n-\t$(BUILDPACKAGE)\n-http/spdy/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) http/spdy\n-\t@$(CHECK)\n-.PHONY: http/spdy/check\n-\n-image/bmp.lo: $(go_image_bmp_files) image.gox io.gox os.gox\n+image/bmp.lo: $(go_image_bmp_files) image.gox image/color.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n image/bmp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/bmp\n \t@$(CHECK)\n .PHONY: image/bmp/check\n \n-image/draw.lo: $(go_image_draw_files) image.gox image/ycbcr.gox\n+image/color.lo: $(go_image_color_files)\n+\t$(BUILDPACKAGE)\n+image/color/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) image/color\n+\t@$(CHECK)\n+.PHONY: image/color/check\n+\n+image/draw.lo: $(go_image_draw_files) image.gox image/color.gox image/ycbcr.gox\n \t$(BUILDPACKAGE)\n image/draw/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/draw\n \t@$(CHECK)\n .PHONY: image/draw/check\n \n image/gif.lo: $(go_image_gif_files) bufio.gox compress/lzw.gox fmt.gox \\\n-\t\timage.gox io.gox os.gox\n+\t\timage.gox image/color.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n image/gif/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/gif\n \t@$(CHECK)\n .PHONY: image/gif/check\n \n-image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox image/ycbcr.gox \\\n-\t\tio.gox os.gox\n+image/jpeg.lo: $(go_image_jpeg_files) bufio.gox image.gox image/color.gox \\\n+\t\timage/ycbcr.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n image/jpeg/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/jpeg\n \t@$(CHECK)\n .PHONY: image/jpeg/check\n \n-image/png.lo: $(go_image_png_files) bufio.gox compress/zlib.gox fmt.gox \\\n-\t\thash.gox hash/crc32.gox image.gox io.gox os.gox strconv.gox\n+image/png.lo: $(go_image_png_files) bufio.gox compress/zlib.gox \\\n+\t\tencoding/binary.gox fmt.gox hash.gox hash/crc32.gox image.gox \\\n+\t\timage/color.gox io.gox os.gox strconv.gox\n \t$(BUILDPACKAGE)\n image/png/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/png\n \t@$(CHECK)\n .PHONY: image/png/check\n \n-image/tiff.lo: $(go_image_tiff_files) compress/lzw.gox compress/zlib.gox \\\n-\t\tencoding/binary.gox image.gox io.gox io/ioutil.gox os.gox\n+image/tiff.lo: $(go_image_tiff_files) bufio.gox compress/lzw.gox \\\n+\t\tcompress/zlib.gox encoding/binary.gox image.gox \\\n+\t\timage/color.gox io.gox io/ioutil.gox os.gox\n \t$(BUILDPACKAGE)\n image/tiff/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/tiff\n \t@$(CHECK)\n .PHONY: image/tiff/check\n \n-image/ycbcr.lo: $(go_image_ycbcr_files) image.gox\n+image/ycbcr.lo: $(go_image_ycbcr_files) image.gox image/color.gox\n \t$(BUILDPACKAGE)\n image/ycbcr/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) image/ycbcr\n \t@$(CHECK)\n .PHONY: image/ycbcr/check\n \n-index/suffixarray.lo: $(go_index_suffixarray_files) bytes.gox regexp.gox \\\n-\t\tsort.gox\n+index/suffixarray.lo: $(go_index_suffixarray_files) bytes.gox \\\n+\t\tencoding/binary.gox io.gox os.gox regexp.gox sort.gox\n \t$(BUILDPACKAGE)\n index/suffixarray/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) index/suffixarray\n@@ -5456,13 +5554,30 @@ net/dict.lo: $(go_net_dict_files) net/textproto.gox os.gox strconv.gox \\\n \t$(BUILDPACKAGE)\n \n net/textproto.lo: $(go_net_textproto_files) bufio.gox bytes.gox fmt.gox \\\n-\t\tio.gox io/ioutil.gox net.gox os.gox strconv.gox sync.gox\n+\t\tio.gox io/ioutil.gox net.gox os.gox strings.gox strconv.gox \\\n+\t\tsync.gox\n \t$(BUILDPACKAGE)\n net/textproto/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) net/textproto\n \t@$(CHECK)\n .PHONY: net/textproto/check\n \n+old/netchan.lo: $(go_old_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n+\t\treflect.gox strconv.gox sync.gox time.gox\n+\t$(BUILDPACKAGE)\n+old/netchan/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) old/netchan\n+\t@$(CHECK)\n+.PHONY: old/netchan/check\n+\n+old/regexp.lo: $(go_old_regexp_files) bytes.gox io.gox os.gox strings.gox \\\n+\t\tutf8.gox\n+\t$(BUILDPACKAGE)\n+old/regexp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) old/regexp\n+\t@$(CHECK)\n+.PHONY: old/regexp/check\n+\n old/template.lo: $(go_old_template_files) bytes.gox fmt.gox io.gox \\\n \t\tio/ioutil.gox os.gox reflect.gox strconv.gox strings.gox \\\n \t\tunicode.gox utf8.gox\n@@ -5502,6 +5617,14 @@ path/filepath/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: path/filepath/check\n \n+regexp/syntax.lo: $(go_regexp_syntax_files) bytes.gox os.gox sort.gox \\\n+\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+regexp/syntax/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) regexp/syntax\n+\t@$(CHECK)\n+.PHONY: regexp/syntax/check\n+\n rpc/jsonrpc.lo: $(go_rpc_jsonrpc_files) fmt.gox io.gox json.gox net.gox \\\n \t\tos.gox rpc.gox sync.gox\n \t$(BUILDPACKAGE)\n@@ -5587,8 +5710,6 @@ crypto.gox: crypto/crypto.lo\n \t$(BUILDGOX)\n csv.gox: csv/csv.lo\n \t$(BUILDGOX)\n-ebnf.gox: ebnf/ebnf.lo\n-\t$(BUILDGOX)\n exec.gox: exec/exec.lo\n \t$(BUILDGOX)\n expvar.gox: expvar/expvar.lo\n@@ -5621,8 +5742,6 @@ mime.gox: mime/mime.lo\n \t$(BUILDGOX)\n net.gox: net/net.lo\n \t$(BUILDGOX)\n-netchan.gox: netchan/netchan.lo\n-\t$(BUILDGOX)\n os.gox: os/os.lo\n \t$(BUILDGOX)\n patch.gox: patch/patch.lo\n@@ -5663,8 +5782,6 @@ testing.gox: testing/testing.lo\n \t$(BUILDGOX)\n time.gox: time/time.lo\n \t$(BUILDGOX)\n-try.gox: try/try.lo\n-\t$(BUILDGOX)\n unicode.gox: unicode/unicode.lo\n \t$(BUILDGOX)\n url.gox: url/url.lo\n@@ -5700,11 +5817,11 @@ container/list.gox: container/list.lo\n \t$(BUILDGOX)\n container/ring.gox: container/ring.lo\n \t$(BUILDGOX)\n-container/vector.gox: container/vector.lo\n-\t$(BUILDGOX)\n \n crypto/aes.gox: crypto/aes.lo\n \t$(BUILDGOX)\n+crypto/bcrypt.gox: crypto/bcrypt.lo\n+\t$(BUILDGOX)\n crypto/blowfish.gox: crypto/blowfish.lo\n \t$(BUILDGOX)\n crypto/cast5.gox: crypto/cast5.lo\n@@ -5794,17 +5911,27 @@ encoding/hex.gox: encoding/hex.lo\n encoding/pem.gox: encoding/pem.lo\n \t$(BUILDGOX)\n \n+exp/ebnf.gox: exp/ebnf.lo\n+\t$(BUILDGOX)\n exp/gui.gox: exp/gui.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n-exp/regexp.gox: exp/regexp.lo\n+exp/spdy.gox: exp/spdy.lo\n+\t$(BUILDGOX)\n+exp/sql.gox: exp/sql.lo\n+\t$(BUILDGOX)\n+exp/ssh.gox: exp/ssh.lo\n+\t$(BUILDGOX)\n+exp/terminal.gox: exp/terminal.lo\n+\t$(BUILDGOX)\n+exp/types.gox: exp/types.lo\n \t$(BUILDGOX)\n \n exp/gui/x11.gox: exp/gui/x11.lo\n \t$(BUILDGOX)\n \n-exp/regexp/syntax.gox: exp/regexp/syntax.lo\n+exp/sql/driver.gox: exp/sql/driver.lo\n \t$(BUILDGOX)\n \n exp/template/html.gox: exp/template/html.lo\n@@ -5824,10 +5951,6 @@ go/scanner.gox: go/scanner.lo\n \t$(BUILDGOX)\n go/token.gox: go/token.lo\n \t$(BUILDGOX)\n-go/typechecker.gox: go/typechecker.lo\n-\t$(BUILDGOX)\n-go/types.gox: go/types.lo\n-\t$(BUILDGOX)\n \n hash/adler32.gox: hash/adler32.lo\n \t$(BUILDGOX)\n@@ -5846,11 +5969,11 @@ http/httptest.gox: http/httptest.lo\n \t$(BUILDGOX)\n http/pprof.gox: http/pprof.lo\n \t$(BUILDGOX)\n-http/spdy.gox: http/spdy.lo\n-\t$(BUILDGOX)\n \n image/bmp.gox: image/bmp.lo\n \t$(BUILDGOX)\n+image/color.gox: image/color.lo\n+\t$(BUILDGOX)\n image/draw.gox: image/draw.lo\n \t$(BUILDGOX)\n image/gif.gox: image/gif.lo\n@@ -5878,6 +6001,10 @@ net/dict.gox: net/dict.lo\n net/textproto.gox: net/textproto.lo\n \t$(BUILDGOX)\n \n+old/netchan.gox: old/netchan.lo\n+\t$(BUILDGOX)\n+old/regexp.gox: old/regexp.lo\n+\t$(BUILDGOX)\n old/template.gox: old/template.lo\n \t$(BUILDGOX)\n \n@@ -5891,6 +6018,9 @@ os/signal.gox: os/signal.lo\n path/filepath.gox: path/filepath.lo\n \t$(BUILDGOX)\n \n+regexp/syntax.gox: regexp/syntax.lo\n+\t$(BUILDGOX)\n+\n rpc/jsonrpc.gox: rpc/jsonrpc.lo\n \t$(BUILDGOX)\n "}, {"sha": "67355086a639af3286692360ace5a4c727d74a58", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -15,36 +15,37 @@ const (\n \tblockSize = 512\n \n \t// Types\n-\tTypeReg           = '0'\n-\tTypeRegA          = '\\x00'\n-\tTypeLink          = '1'\n-\tTypeSymlink       = '2'\n-\tTypeChar          = '3'\n-\tTypeBlock         = '4'\n-\tTypeDir           = '5'\n-\tTypeFifo          = '6'\n-\tTypeCont          = '7'\n-\tTypeXHeader       = 'x'\n-\tTypeXGlobalHeader = 'g'\n+\tTypeReg           = '0'    // regular file.\n+\tTypeRegA          = '\\x00' // regular file.\n+\tTypeLink          = '1'    // hard link.\n+\tTypeSymlink       = '2'    // symbolic link.\n+\tTypeChar          = '3'    // character device node.\n+\tTypeBlock         = '4'    // block device node.\n+\tTypeDir           = '5'    // directory.\n+\tTypeFifo          = '6'    // fifo node.\n+\tTypeCont          = '7'    // reserved.\n+\tTypeXHeader       = 'x'    // extended header.\n+\tTypeXGlobalHeader = 'g'    // global extended header.\n )\n \n // A Header represents a single header in a tar archive.\n // Some fields may not be populated.\n type Header struct {\n-\tName     string\n-\tMode     int64\n-\tUid      int\n-\tGid      int\n-\tSize     int64\n-\tMtime    int64\n-\tTypeflag byte\n-\tLinkname string\n-\tUname    string\n-\tGname    string\n-\tDevmajor int64\n-\tDevminor int64\n-\tAtime    int64\n-\tCtime    int64\n+\tName     string // name of header file entry.\n+\tMode     int64  // permission and mode bits.\n+\tUid      int    // user id of owner.\n+\tGid      int    // group id of owner.\n+\tSize     int64  // length in bytes.\n+\tMtime    int64  // modified time; seconds since epoch.\n+\tTypeflag byte   // type of header entry.\n+\tLinkname string // target name of link.\n+\tUname    string // user name of owner.\n+\tGname    string // group name of owner.\n+\tDevmajor int64  // major number of character or block device.\n+\tDevminor int64  // minor number of character or block device.\n+\tAtime    int64  // access time; seconds since epoch.\n+\tCtime    int64  // status change time; seconds since epoch.\n+\n }\n \n var zeroBlock = make([]byte, blockSize)"}, {"sha": "12de2ada0830140d012eba5c1b0fcfab0dd5eca4", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -94,7 +94,7 @@ func (tr *Reader) skipUnread() {\n \t\t\treturn\n \t\t}\n \t}\n-\t_, tr.err = io.Copyn(ioutil.Discard, tr.r, nr)\n+\t_, tr.err = io.CopyN(ioutil.Discard, tr.r, nr)\n }\n \n func (tr *Reader) verifyChecksum(header []byte) bool {"}, {"sha": "e6d816ad0775d56d09242d6f5d1dbe56af310a32", "filename": "libgo/go/archive/tar/testdata/writer.tar", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter.tar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter.tar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftestdata%2Fwriter.tar?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "c6ce2241af03de5ae334b0deb81be0244dc01a27", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -134,7 +134,7 @@ func (tw *Writer) WriteHeader(hdr *Header) os.Error {\n \ttw.numeric(s.next(12), hdr.Mtime)      // 136:148\n \ts.next(8)                              // chksum (148:156)\n \ts.next(1)[0] = hdr.Typeflag            // 156:157\n-\ts.next(100)                            // linkname (157:257)\n+\ttw.cString(s.next(100), hdr.Linkname)  // linkname (157:257)\n \tcopy(s.next(8), []byte(\"ustar\\x0000\")) // 257:265\n \ttw.cString(s.next(32), hdr.Uname)      // 265:297\n \ttw.cString(s.next(32), hdr.Gname)      // 297:329"}, {"sha": "6cc93868820eb37386d43094cd8fabbc2df6afad", "filename": "libgo/go/archive/tar/writer_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -24,6 +24,10 @@ type writerTest struct {\n }\n \n var writerTests = []*writerTest{\n+\t// The writer test file was produced with this command:\n+\t// tar (GNU tar) 1.26\n+\t//   ln -s small.txt link.txt\n+\t//   tar -b 1 --format=ustar -c -f writer.tar small.txt small2.txt link.txt\n \t&writerTest{\n \t\tfile: \"testdata/writer.tar\",\n \t\tentries: []*writerTestEntry{\n@@ -55,6 +59,21 @@ var writerTests = []*writerTest{\n \t\t\t\t},\n \t\t\t\tcontents: \"Google.com\\n\",\n \t\t\t},\n+\t\t\t&writerTestEntry{\n+\t\t\t\theader: &Header{\n+\t\t\t\t\tName:     \"link.txt\",\n+\t\t\t\t\tMode:     0777,\n+\t\t\t\t\tUid:      1000,\n+\t\t\t\t\tGid:      1000,\n+\t\t\t\t\tSize:     0,\n+\t\t\t\t\tMtime:    1314603082,\n+\t\t\t\t\tTypeflag: '2',\n+\t\t\t\t\tLinkname: \"small.txt\",\n+\t\t\t\t\tUname:    \"strings\",\n+\t\t\t\t\tGname:    \"strings\",\n+\t\t\t\t},\n+\t\t\t\t// no contents\n+\t\t\t},\n \t\t},\n \t},\n \t// The truncated test file was produced using these commands:"}, {"sha": "b0a559936bd2a2dcdf23fa34fed252bd949ba1b5", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -238,7 +238,7 @@ func readDirectoryHeader(f *File, r io.Reader) os.Error {\n \tcommentLen := int(c.Uint16(b[32:34]))\n \t// startDiskNumber := c.Uint16(b[34:36])    // Unused\n \t// internalAttributes := c.Uint16(b[36:38]) // Unused\n-\t// externalAttributes := c.Uint32(b[38:42]) // Unused\n+\tf.ExternalAttrs = c.Uint32(b[38:42])\n \tf.headerOffset = int64(c.Uint32(b[42:46]))\n \td := make([]byte, filenameLen+extraLen+commentLen)\n \tif _, err := io.ReadFull(r, d); err != nil {"}, {"sha": "3b7b0dc130441655e4fda4e6ababb8a60e1df613", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -26,6 +26,7 @@ type ZipTestFile struct {\n \tContent []byte // if blank, will attempt to compare against File\n \tFile    string // name of file to compare to (relative to testdata/)\n \tMtime   string // modified time in format \"mm-dd-yy hh:mm:ss\"\n+\tMode    uint32\n }\n \n // Caution: The Mtime values found for the test files should correspond to\n@@ -47,11 +48,13 @@ var tests = []ZipTest{\n \t\t\t\tName:    \"test.txt\",\n \t\t\t\tContent: []byte(\"This is a test text file.\\n\"),\n \t\t\t\tMtime:   \"09-05-10 12:12:02\",\n+\t\t\t\tMode:    0x81a4,\n \t\t\t},\n \t\t\t{\n \t\t\t\tName:  \"gophercolor16x16.png\",\n \t\t\t\tFile:  \"gophercolor16x16.png\",\n \t\t\t\tMtime: \"09-05-10 15:52:58\",\n+\t\t\t\tMode:  0x81a4,\n \t\t\t},\n \t\t},\n \t},\n@@ -162,6 +165,8 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t\tt.Errorf(\"%s: mtime=%s (%d); want %s (%d)\", f.Name, time.SecondsToUTC(got), got, mtime, want)\n \t}\n \n+\ttestFileMode(t, f, ft.Mode)\n+\n \tsize0 := f.UncompressedSize\n \n \tvar b bytes.Buffer\n@@ -203,6 +208,19 @@ func readTestFile(t *testing.T, ft ZipTestFile, f *File) {\n \t}\n }\n \n+func testFileMode(t *testing.T, f *File, want uint32) {\n+\tmode, err := f.Mode()\n+\tif want == 0 {\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"%s mode: got %v, want none\", f.Name, mode)\n+\t\t}\n+\t} else if err != nil {\n+\t\tt.Errorf(\"%s mode: %s\", f.Name, err)\n+\t} else if mode != want {\n+\t\tt.Errorf(\"%s mode: want 0x%x, got 0x%x\", f.Name, want, mode)\n+\t}\n+}\n+\n func TestInvalidFiles(t *testing.T) {\n \tconst size = 1024 * 70 // 70kb\n \tb := make([]byte, size)"}, {"sha": "a32de5a9e0d49fa783a599488e435890170eb614", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -28,6 +28,9 @@ const (\n \tdirectoryHeaderLen       = 46 // + filename + extra + comment\n \tdirectoryEndLen          = 22 // + comment\n \tdataDescriptorLen        = 12\n+\n+\t// Constants for the first byte in CreatorVersion\n+\tcreatorUnix = 3\n )\n \n type FileHeader struct {\n@@ -42,6 +45,7 @@ type FileHeader struct {\n \tCompressedSize   uint32\n \tUncompressedSize uint32\n \tExtra            []byte\n+\tExternalAttrs    uint32 // Meaning depends on CreatorVersion\n \tComment          string\n }\n \n@@ -89,3 +93,18 @@ func (h *FileHeader) Mtime_ns() int64 {\n \tt := msDosTimeToTime(h.ModifiedDate, h.ModifiedTime)\n \treturn t.Seconds() * 1e9\n }\n+\n+// Mode returns the permission and mode bits for the FileHeader.\n+// An error is returned in case the information is not available.\n+func (h *FileHeader) Mode() (mode uint32, err os.Error) {\n+\tif h.CreatorVersion>>8 == creatorUnix {\n+\t\treturn h.ExternalAttrs >> 16, nil\n+\t}\n+\treturn 0, os.NewError(\"file mode not available\")\n+}\n+\n+// SetMode changes the permission and mode bits for the FileHeader.\n+func (h *FileHeader) SetMode(mode uint32) {\n+\th.CreatorVersion = h.CreatorVersion&0xff | creatorUnix<<8\n+\th.ExternalAttrs = mode << 16\n+}"}, {"sha": "3a6dc38e20fedc78477d8e855a542cec49aeb7e8", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -69,7 +69,7 @@ func (w *Writer) Close() (err os.Error) {\n \t\twrite(w, uint16(len(h.Comment)))\n \t\twrite(w, uint16(0)) // disk number start\n \t\twrite(w, uint16(0)) // internal file attributes\n-\t\twrite(w, uint32(0)) // external file attributes\n+\t\twrite(w, h.ExternalAttrs)\n \t\twrite(w, h.offset)\n \t\twriteBytes(w, []byte(h.Name))\n \t\twriteBytes(w, h.Extra)\n@@ -115,7 +115,7 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, os.Error) {\n \t}\n \n \tfh.Flags |= 0x8 // we will write a data descriptor\n-\tfh.CreatorVersion = 0x14\n+\tfh.CreatorVersion = fh.CreatorVersion&0xff00 | 0x14\n \tfh.ReaderVersion = 0x14\n \n \tfw := &fileWriter{"}, {"sha": "b562f8430538e51425a70d2e8edc63beaa86a07b", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -13,19 +13,45 @@ import (\n \n // TODO(adg): a more sophisticated test suite\n \n-const testString = \"Rabbits, guinea pigs, gophers, marsupial rats, and quolls.\"\n+type WriteTest struct {\n+\tName   string\n+\tData   []byte\n+\tMethod uint16\n+\tMode   uint32\n+}\n+\n+var writeTests = []WriteTest{\n+\tWriteTest{\n+\t\tName:   \"foo\",\n+\t\tData:   []byte(\"Rabbits, guinea pigs, gophers, marsupial rats, and quolls.\"),\n+\t\tMethod: Store,\n+\t},\n+\tWriteTest{\n+\t\tName:   \"bar\",\n+\t\tData:   nil, // large data set in the test\n+\t\tMethod: Deflate,\n+\t\tMode:   0x81ed,\n+\t},\n+}\n \n func TestWriter(t *testing.T) {\n \tlargeData := make([]byte, 1<<17)\n \tfor i := range largeData {\n \t\tlargeData[i] = byte(rand.Int())\n \t}\n+\twriteTests[1].Data = largeData\n+\tdefer func() {\n+\t\twriteTests[1].Data = nil\n+\t}()\n \n \t// write a zip file\n \tbuf := new(bytes.Buffer)\n \tw := NewWriter(buf)\n-\ttestCreate(t, w, \"foo\", []byte(testString), Store)\n-\ttestCreate(t, w, \"bar\", largeData, Deflate)\n+\n+\tfor _, wt := range writeTests {\n+\t\ttestCreate(t, w, &wt)\n+\t}\n+\n \tif err := w.Close(); err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -35,26 +61,34 @@ func TestWriter(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\ttestReadFile(t, r.File[0], []byte(testString))\n-\ttestReadFile(t, r.File[1], largeData)\n+\tfor i, wt := range writeTests {\n+\t\ttestReadFile(t, r.File[i], &wt)\n+\t}\n }\n \n-func testCreate(t *testing.T, w *Writer, name string, data []byte, method uint16) {\n+func testCreate(t *testing.T, w *Writer, wt *WriteTest) {\n \theader := &FileHeader{\n-\t\tName:   name,\n-\t\tMethod: method,\n+\t\tName:   wt.Name,\n+\t\tMethod: wt.Method,\n+\t}\n+\tif wt.Mode != 0 {\n+\t\theader.SetMode(wt.Mode)\n \t}\n \tf, err := w.CreateHeader(header)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\t_, err = f.Write(data)\n+\t_, err = f.Write(wt.Data)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n }\n \n-func testReadFile(t *testing.T, f *File, data []byte) {\n+func testReadFile(t *testing.T, f *File, wt *WriteTest) {\n+\tif f.Name != wt.Name {\n+\t\tt.Fatalf(\"File name: got %q, want %q\", f.Name, wt.Name)\n+\t}\n+\ttestFileMode(t, f, wt.Mode)\n \trc, err := f.Open()\n \tif err != nil {\n \t\tt.Fatal(\"opening:\", err)\n@@ -67,7 +101,7 @@ func testReadFile(t *testing.T, f *File, data []byte) {\n \tif err != nil {\n \t\tt.Fatal(\"closing:\", err)\n \t}\n-\tif !bytes.Equal(b, data) {\n-\t\tt.Errorf(\"File contents %q, want %q\", b, data)\n+\tif !bytes.Equal(b, wt.Data) {\n+\t\tt.Errorf(\"File contents %q, want %q\", b, wt.Data)\n \t}\n }"}, {"sha": "e7bd62ee0a7aa90ae787109c9d9c6ed85575fdf0", "filename": "libgo/go/asn1/asn1.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -516,6 +516,8 @@ func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParam\n \t\t\t\tresult, err = parseIA5String(innerBytes)\n \t\t\tcase tagT61String:\n \t\t\t\tresult, err = parseT61String(innerBytes)\n+\t\t\tcase tagUTF8String:\n+\t\t\t\tresult, err = parseUTF8String(innerBytes)\n \t\t\tcase tagInteger:\n \t\t\t\tresult, err = parseInt64(innerBytes)\n \t\t\tcase tagBitString:"}, {"sha": "1c529bdb30ca0482dce8d1a73ac38dd4a397c9fe", "filename": "libgo/go/asn1/asn1_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fasn1_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -206,10 +206,10 @@ type timeTest struct {\n }\n \n var utcTestData = []timeTest{\n-\t{\"910506164540-0700\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 0, -7 * 60 * 60, \"\"}},\n-\t{\"910506164540+0730\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 0, 7*60*60 + 30*60, \"\"}},\n-\t{\"910506234540Z\", true, &time.Time{1991, 05, 06, 23, 45, 40, 0, 0, 0, \"UTC\"}},\n-\t{\"9105062345Z\", true, &time.Time{1991, 05, 06, 23, 45, 0, 0, 0, 0, \"UTC\"}},\n+\t{\"910506164540-0700\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, -7 * 60 * 60, \"\"}},\n+\t{\"910506164540+0730\", true, &time.Time{1991, 05, 06, 16, 45, 40, 0, 7*60*60 + 30*60, \"\"}},\n+\t{\"910506234540Z\", true, &time.Time{1991, 05, 06, 23, 45, 40, 0, 0, \"UTC\"}},\n+\t{\"9105062345Z\", true, &time.Time{1991, 05, 06, 23, 45, 0, 0, 0, \"UTC\"}},\n \t{\"a10506234540Z\", false, nil},\n \t{\"91a506234540Z\", false, nil},\n \t{\"9105a6234540Z\", false, nil},\n@@ -235,10 +235,10 @@ func TestUTCTime(t *testing.T) {\n }\n \n var generalizedTimeTestData = []timeTest{\n-\t{\"20100102030405Z\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, 0, \"UTC\"}},\n+\t{\"20100102030405Z\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, \"UTC\"}},\n \t{\"20100102030405\", false, nil},\n-\t{\"20100102030405+0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, 6*60*60 + 7*60, \"\"}},\n-\t{\"20100102030405-0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 0, -6*60*60 - 7*60, \"\"}},\n+\t{\"20100102030405+0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, 6*60*60 + 7*60, \"\"}},\n+\t{\"20100102030405-0607\", true, &time.Time{2010, 01, 02, 03, 04, 05, 0, -6*60*60 - 7*60, \"\"}},\n }\n \n func TestGeneralizedTime(t *testing.T) {\n@@ -475,7 +475,7 @@ var derEncodedSelfSignedCert = Certificate{\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{2, 5, 4, 3}, Value: \"false.example.com\"}},\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{1, 2, 840, 113549, 1, 9, 1}, Value: \"false@example.com\"}},\n \t\t},\n-\t\tValidity: Validity{NotBefore: &time.Time{Year: 2009, Month: 10, Day: 8, Hour: 0, Minute: 25, Second: 53, Weekday: 0, ZoneOffset: 0, Zone: \"UTC\"}, NotAfter: &time.Time{Year: 2010, Month: 10, Day: 8, Hour: 0, Minute: 25, Second: 53, Weekday: 0, ZoneOffset: 0, Zone: \"UTC\"}},\n+\t\tValidity: Validity{NotBefore: &time.Time{Year: 2009, Month: 10, Day: 8, Hour: 0, Minute: 25, Second: 53, ZoneOffset: 0, Zone: \"UTC\"}, NotAfter: &time.Time{Year: 2010, Month: 10, Day: 8, Hour: 0, Minute: 25, Second: 53, ZoneOffset: 0, Zone: \"UTC\"}},\n \t\tSubject: RDNSequence{\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{2, 5, 4, 6}, Value: \"XX\"}},\n \t\t\tRelativeDistinguishedNameSET{AttributeTypeAndValue{Type: ObjectIdentifier{2, 5, 4, 8}, Value: \"Some-State\"}},"}, {"sha": "6d1f78bcc10b13fbbde55cf31ae64913bed3d911", "filename": "libgo/go/asn1/marshal.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -464,11 +464,15 @@ func marshalField(out *forkableWriter, v reflect.Value, params fieldParameters)\n \n \tif v.Type() == rawValueType {\n \t\trv := v.Interface().(RawValue)\n-\t\terr = marshalTagAndLength(out, tagAndLength{rv.Class, rv.Tag, len(rv.Bytes), rv.IsCompound})\n-\t\tif err != nil {\n-\t\t\treturn\n+\t\tif len(rv.FullBytes) != 0 {\n+\t\t\t_, err = out.Write(rv.FullBytes)\n+\t\t} else {\n+\t\t\terr = marshalTagAndLength(out, tagAndLength{rv.Class, rv.Tag, len(rv.Bytes), rv.IsCompound})\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t_, err = out.Write(rv.Bytes)\n \t\t}\n-\t\t_, err = out.Write(rv.Bytes)\n \t\treturn\n \t}\n "}, {"sha": "9e1d1ae1318dfed2d68402ebb0fa9be6740e4acc", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -163,7 +163,7 @@ func (z *Int) Binomial(n, k int64) *Int {\n \n // Quo sets z to the quotient x/y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n-// See QuoRem for more details.\n+// Quo implements truncated division (like Go); see QuoRem for more details.\n func (z *Int) Quo(x, y *Int) *Int {\n \tz.abs, _ = z.abs.div(nil, x.abs, y.abs)\n \tz.neg = len(z.abs) > 0 && x.neg != y.neg // 0 has no sign\n@@ -172,7 +172,7 @@ func (z *Int) Quo(x, y *Int) *Int {\n \n // Rem sets z to the remainder x%y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n-// See QuoRem for more details.\n+// Rem implements truncated modulus (like Go); see QuoRem for more details.\n func (z *Int) Rem(x, y *Int) *Int {\n \t_, z.abs = nat(nil).div(z.abs, x.abs, y.abs)\n \tz.neg = len(z.abs) > 0 && x.neg // 0 has no sign\n@@ -198,7 +198,7 @@ func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int) {\n \n // Div sets z to the quotient x/y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n-// See DivMod for more details.\n+// Div implements Euclidean division (unlike Go); see DivMod for more details.\n func (z *Int) Div(x, y *Int) *Int {\n \ty_neg := y.neg // z may be an alias for y\n \tvar r Int\n@@ -215,7 +215,7 @@ func (z *Int) Div(x, y *Int) *Int {\n \n // Mod sets z to the modulus x%y for y != 0 and returns z.\n // If y == 0, a division-by-zero run-time panic occurs.\n-// See DivMod for more details.\n+// Mod implements Euclidean modulus (unlike Go); see DivMod for more details.\n func (z *Int) Mod(x, y *Int) *Int {\n \ty0 := y // save y\n \tif z == y || alias(z.abs, y.abs) {"}, {"sha": "b2e1692179943f90e0aa7e4a1b01555f2a77f0f4", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -301,6 +301,9 @@ func TestGetString(t *testing.T) {\n func TestSetString(t *testing.T) {\n \ttmp := new(Int)\n \tfor i, test := range stringTests {\n+\t\t// initialize to a non-zero value so that issues with parsing\n+\t\t// 0 are detected\n+\t\ttmp.SetInt64(1234567890)\n \t\tn1, ok1 := new(Int).SetString(test.in, test.base)\n \t\tn2, ok2 := tmp.SetString(test.in, test.base)\n \t\texpected := NewInt(test.val)"}, {"sha": "33d6bb16ffd8b6bd2839c678315ee2310f9371d8", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -646,7 +646,7 @@ func (z nat) scan(r io.RuneScanner, base int) (nat, int, os.Error) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\tcase os.EOF:\n-\t\t\t\treturn z, 10, nil\n+\t\t\t\treturn z.make(0), 10, nil\n \t\t\tdefault:\n \t\t\t\treturn z, 10, err\n \t\t\t}"}, {"sha": "f435e637f191a5b3af153de1443e1d8cbd6ab9ec", "filename": "libgo/go/big/rat.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -27,9 +27,13 @@ func NewRat(a, b int64) *Rat {\n \n // SetFrac sets z to a/b and returns z.\n func (z *Rat) SetFrac(a, b *Int) *Rat {\n-\tz.a.Set(a)\n \tz.a.neg = a.neg != b.neg\n-\tz.b = z.b.set(b.abs)\n+\tbabs := b.abs\n+\tif &z.a == b || alias(z.a.abs, babs) {\n+\t\tbabs = nat(nil).set(babs) // make a copy\n+\t}\n+\tz.a.abs = z.a.abs.set(a.abs)\n+\tz.b = z.b.set(babs)\n \treturn z.norm()\n }\n "}, {"sha": "a2b905525eed0e65c63f6b637170779b9337621a", "filename": "libgo/go/big/rat_test.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -330,3 +330,43 @@ func TestRatGobEncoding(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestIssue2379(t *testing.T) {\n+\t// 1) no aliasing\n+\tq := NewRat(3, 2)\n+\tx := new(Rat)\n+\tx.SetFrac(NewInt(3), NewInt(2))\n+\tif x.Cmp(q) != 0 {\n+\t\tt.Errorf(\"1) got %s want %s\", x, q)\n+\t}\n+\n+\t// 2) aliasing of numerator\n+\tx = NewRat(2, 3)\n+\tx.SetFrac(NewInt(3), x.Num())\n+\tif x.Cmp(q) != 0 {\n+\t\tt.Errorf(\"2) got %s want %s\", x, q)\n+\t}\n+\n+\t// 3) aliasing of denominator\n+\tx = NewRat(2, 3)\n+\tx.SetFrac(x.Denom(), NewInt(2))\n+\tif x.Cmp(q) != 0 {\n+\t\tt.Errorf(\"3) got %s want %s\", x, q)\n+\t}\n+\n+\t// 4) aliasing of numerator and denominator\n+\tx = NewRat(2, 3)\n+\tx.SetFrac(x.Denom(), x.Num())\n+\tif x.Cmp(q) != 0 {\n+\t\tt.Errorf(\"4) got %s want %s\", x, q)\n+\t}\n+\n+\t// 5) numerator and denominator are the same\n+\tq = NewRat(1, 1)\n+\tx = new(Rat)\n+\tn := NewInt(7)\n+\tx.SetFrac(n, n)\n+\tif x.Cmp(q) != 0 {\n+\t\tt.Errorf(\"5) got %s want %s\", x, q)\n+\t}\n+}"}, {"sha": "2ea7af3e25b0b7f85ffe76b303d2e91d0db5d3d4", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -54,11 +54,11 @@ type Reader struct {\n }\n \n // NewReaderSize creates a new Reader whose buffer has the specified size,\n-// which must be greater than zero.  If the argument io.Reader is already a\n+// which must be greater than one.  If the argument io.Reader is already a\n // Reader with large enough size, it returns the underlying Reader.\n // It returns the Reader and any error.\n func NewReaderSize(rd io.Reader, size int) (*Reader, os.Error) {\n-\tif size <= 0 {\n+\tif size <= 1 {\n \t\treturn nil, BufSizeError(size)\n \t}\n \t// Is it already a Reader?\n@@ -298,6 +298,17 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n func (b *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n \tline, err = b.ReadSlice('\\n')\n \tif err == ErrBufferFull {\n+\t\t// Handle the case where \"\\r\\n\" straddles the buffer.\n+\t\tif len(line) > 0 && line[len(line)-1] == '\\r' {\n+\t\t\t// Put the '\\r' back on buf and drop it from line.\n+\t\t\t// Let the next call to ReadLine check for \"\\r\\n\".\n+\t\t\tif b.r == 0 {\n+\t\t\t\t// should be unreachable\n+\t\t\t\tpanic(\"bufio: tried to rewind past start of buffer\")\n+\t\t\t}\n+\t\t\tb.r--\n+\t\t\tline = line[:len(line)-1]\n+\t\t}\n \t\treturn line, true, nil\n \t}\n \n@@ -307,10 +318,11 @@ func (b *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n \terr = nil\n \n \tif line[len(line)-1] == '\\n' {\n-\t\tline = line[:len(line)-1]\n-\t}\n-\tif len(line) > 0 && line[len(line)-1] == '\\r' {\n-\t\tline = line[:len(line)-1]\n+\t\tdrop := 1\n+\t\tif len(line) > 1 && line[len(line)-2] == '\\r' {\n+\t\t\tdrop = 2\n+\t\t}\n+\t\tline = line[:len(line)-drop]\n \t}\n \treturn\n }"}, {"sha": "38213ffe788648b1ddf71726ea1bfee7b02307bf", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -137,7 +137,7 @@ var bufreaders = []bufReader{\n }\n \n var bufsizes = []int{\n-\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n+\t2, 3, 4, 5, 6, 7, 8, 9, 10,\n \t23, 32, 46, 64, 93, 128, 1024, 4096,\n }\n \n@@ -697,3 +697,71 @@ func TestLinesAfterRead(t *testing.T) {\n \t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n \t}\n }\n+\n+type readLineResult struct {\n+\tline     []byte\n+\tisPrefix bool\n+\terr      os.Error\n+}\n+\n+var readLineNewlinesTests = []struct {\n+\tinput   string\n+\tbufSize int\n+\texpect  []readLineResult\n+}{\n+\t{\"h\\r\\nb\\r\\n\", 2, []readLineResult{\n+\t\t{[]byte(\"h\"), true, nil},\n+\t\t{nil, false, nil},\n+\t\t{[]byte(\"b\"), true, nil},\n+\t\t{nil, false, nil},\n+\t\t{nil, false, os.EOF},\n+\t}},\n+\t{\"hello\\r\\nworld\\r\\n\", 6, []readLineResult{\n+\t\t{[]byte(\"hello\"), true, nil},\n+\t\t{nil, false, nil},\n+\t\t{[]byte(\"world\"), true, nil},\n+\t\t{nil, false, nil},\n+\t\t{nil, false, os.EOF},\n+\t}},\n+\t{\"hello\\rworld\\r\", 6, []readLineResult{\n+\t\t{[]byte(\"hello\"), true, nil},\n+\t\t{[]byte(\"\\rworld\"), true, nil},\n+\t\t{[]byte(\"\\r\"), false, nil},\n+\t\t{nil, false, os.EOF},\n+\t}},\n+\t{\"h\\ri\\r\\n\\r\", 2, []readLineResult{\n+\t\t{[]byte(\"h\"), true, nil},\n+\t\t{[]byte(\"\\ri\"), true, nil},\n+\t\t{nil, false, nil},\n+\t\t{[]byte(\"\\r\"), false, nil},\n+\t\t{nil, false, os.EOF},\n+\t}},\n+}\n+\n+func TestReadLineNewlines(t *testing.T) {\n+\tfor _, e := range readLineNewlinesTests {\n+\t\ttestReadLineNewlines(t, e.input, e.bufSize, e.expect)\n+\t}\n+}\n+\n+func testReadLineNewlines(t *testing.T, input string, bufSize int, expect []readLineResult) {\n+\tb, err := NewReaderSize(strings.NewReader(input), bufSize)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, e := range expect {\n+\t\tline, isPrefix, err := b.ReadLine()\n+\t\tif bytes.Compare(line, e.line) != 0 {\n+\t\t\tt.Errorf(\"%q call %d, line == %q, want %q\", input, i, line, e.line)\n+\t\t\treturn\n+\t\t}\n+\t\tif isPrefix != e.isPrefix {\n+\t\t\tt.Errorf(\"%q call %d, isPrefix == %v, want %v\", input, i, isPrefix, e.isPrefix)\n+\t\t\treturn\n+\t\t}\n+\t\tif err != e.err {\n+\t\t\tt.Errorf(\"%q call %d, err == %v, want %v\", input, i, err, e.err)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}"}, {"sha": "975031bfa4f39f45b45eda3fc1b9a76e585cd01f", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -336,13 +336,18 @@ func (b *Buffer) ReadString(delim byte) (line string, err os.Error) {\n \n // NewBuffer creates and initializes a new Buffer using buf as its initial\n // contents.  It is intended to prepare a Buffer to read existing data.  It\n-// can also be used to size the internal buffer for writing.  To do that,\n+// can also be used to size the internal buffer for writing. To do that,\n // buf should have the desired capacity but a length of zero.\n+//\n+// In most cases, new(Buffer) (or just declaring a Buffer variable) is\n+// preferable to NewBuffer.  In particular, passing a non-empty buf to\n+// NewBuffer and then writing to the Buffer will overwrite buf, not append to\n+// it.\n func NewBuffer(buf []byte) *Buffer { return &Buffer{buf: buf} }\n \n // NewBufferString creates and initializes a new Buffer using string s as its\n // initial contents.  It is intended to prepare a buffer to read an existing\n-// string.\n+// string.  See the warnings about NewBuffer; similar issues apply here.\n func NewBufferString(s string) *Buffer {\n \treturn &Buffer{buf: []byte(s)}\n }"}, {"sha": "2fb456900a7b510707c846747a4e8fd41f904b37", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -572,13 +572,18 @@ func Runes(s []byte) []int {\n // non-overlapping instances of old replaced by new.\n // If n < 0, there is no limit on the number of replacements.\n func Replace(s, old, new []byte, n int) []byte {\n-\tif n == 0 {\n-\t\treturn s // avoid allocation\n-\t}\n-\t// Compute number of replacements.\n-\tif m := Count(s, old); m == 0 {\n-\t\treturn s // avoid allocation\n-\t} else if n <= 0 || m < n {\n+\tm := 0\n+\tif n != 0 {\n+\t\t// Compute number of replacements.\n+\t\tm = Count(s, old)\n+\t}\n+\tif m == 0 {\n+\t\t// Nothing to do. Just copy.\n+\t\tt := make([]byte, len(s))\n+\t\tcopy(t, s)\n+\t\treturn t\n+\t}\n+\tif n < 0 || m < n {\n \t\tn = m\n \t}\n \n@@ -603,3 +608,58 @@ func Replace(s, old, new []byte, n int) []byte {\n \tw += copy(t[w:], s[start:])\n \treturn t[0:w]\n }\n+\n+// EqualFold reports whether s and t, interpreted as UTF-8 strings,\n+// are equal under Unicode case-folding.\n+func EqualFold(s, t []byte) bool {\n+\tfor len(s) != 0 && len(t) != 0 {\n+\t\t// Extract first rune from each.\n+\t\tvar sr, tr int\n+\t\tif s[0] < utf8.RuneSelf {\n+\t\t\tsr, s = int(s[0]), s[1:]\n+\t\t} else {\n+\t\t\tr, size := utf8.DecodeRune(s)\n+\t\t\tsr, s = r, s[size:]\n+\t\t}\n+\t\tif t[0] < utf8.RuneSelf {\n+\t\t\ttr, t = int(t[0]), t[1:]\n+\t\t} else {\n+\t\t\tr, size := utf8.DecodeRune(t)\n+\t\t\ttr, t = r, t[size:]\n+\t\t}\n+\n+\t\t// If they match, keep going; if not, return false.\n+\n+\t\t// Easy case.\n+\t\tif tr == sr {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// Make sr < tr to simplify what follows.\n+\t\tif tr < sr {\n+\t\t\ttr, sr = sr, tr\n+\t\t}\n+\t\t// Fast check for ASCII.\n+\t\tif tr < utf8.RuneSelf && 'A' <= sr && sr <= 'Z' {\n+\t\t\t// ASCII, and sr is upper case.  tr must be lower case.\n+\t\t\tif tr == sr+'a'-'A' {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// General case.  SimpleFold(x) returns the next equivalent rune > x\n+\t\t// or wraps around to smaller values.\n+\t\tr := unicode.SimpleFold(sr)\n+\t\tfor r != sr && r < tr {\n+\t\t\tr = unicode.SimpleFold(r)\n+\t\t}\n+\t\tif r == tr {\n+\t\t\tcontinue\n+\t\t}\n+\t\treturn false\n+\t}\n+\n+\t// One string is empty.  Are both?\n+\treturn len(s) == len(t)\n+}"}, {"sha": "ce3f37e4de22ed1df513fd72a43bbb5cba6909bf", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -829,9 +829,15 @@ var ReplaceTests = []ReplaceTest{\n \n func TestReplace(t *testing.T) {\n \tfor _, tt := range ReplaceTests {\n-\t\tif s := string(Replace([]byte(tt.in), []byte(tt.old), []byte(tt.new), tt.n)); s != tt.out {\n+\t\tin := append([]byte(tt.in), \"<spare>\"...)\n+\t\tin = in[:len(tt.in)]\n+\t\tout := Replace(in, []byte(tt.old), []byte(tt.new), tt.n)\n+\t\tif s := string(out); s != tt.out {\n \t\t\tt.Errorf(\"Replace(%q, %q, %q, %d) = %q, want %q\", tt.in, tt.old, tt.new, tt.n, s, tt.out)\n \t\t}\n+\t\tif cap(in) == cap(out) && &in[:1][0] == &out[:1][0] {\n+\t\t\tt.Errorf(\"Replace(%q, %q, %q, %d) didn't copy\", tt.in, tt.old, tt.new, tt.n)\n+\t\t}\n \t}\n }\n \n@@ -856,3 +862,31 @@ func TestTitle(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var EqualFoldTests = []struct {\n+\ts, t string\n+\tout  bool\n+}{\n+\t{\"abc\", \"abc\", true},\n+\t{\"ABcd\", \"ABcd\", true},\n+\t{\"123abc\", \"123ABC\", true},\n+\t{\"\u03b1\u03b2\u03b4\", \"\u0391\u0392\u0394\", true},\n+\t{\"abc\", \"xyz\", false},\n+\t{\"abc\", \"XYZ\", false},\n+\t{\"abcdefghijk\", \"abcdefghijX\", false},\n+\t{\"abcdefghijk\", \"abcdefghij\\u212A\", true},\n+\t{\"abcdefghijK\", \"abcdefghij\\u212A\", true},\n+\t{\"abcdefghijkz\", \"abcdefghij\\u212Ay\", false},\n+\t{\"abcdefghijKz\", \"abcdefghij\\u212Ay\", false},\n+}\n+\n+func TestEqualFold(t *testing.T) {\n+\tfor _, tt := range EqualFoldTests {\n+\t\tif out := EqualFold([]byte(tt.s), []byte(tt.t)); out != tt.out {\n+\t\t\tt.Errorf(\"EqualFold(%#q, %#q) = %v, want %v\", tt.s, tt.t, out, tt.out)\n+\t\t}\n+\t\tif out := EqualFold([]byte(tt.t), []byte(tt.s)); out != tt.out {\n+\t\t\tt.Errorf(\"EqualFold(%#q, %#q) = %v, want %v\", tt.t, tt.s, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "01ce80a194620981959a601d9085290196fac488", "filename": "libgo/go/cmath/asin.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Fasin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Fasin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fasin.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -50,7 +50,7 @@ import \"math\"\n // Asin returns the inverse sine of x.\n func Asin(x complex128) complex128 {\n \tif imag(x) == 0 {\n-\t\tif math.Fabs(real(x)) > 1 {\n+\t\tif math.Abs(real(x)) > 1 {\n \t\t\treturn complex(math.Pi/2, 0) // DOMAIN error\n \t\t}\n \t\treturn complex(math.Asin(real(x)), 0)\n@@ -67,7 +67,7 @@ func Asin(x complex128) complex128 {\n func Asinh(x complex128) complex128 {\n \t// TODO check range\n \tif imag(x) == 0 {\n-\t\tif math.Fabs(real(x)) > 1 {\n+\t\tif math.Abs(real(x)) > 1 {\n \t\t\treturn complex(math.Pi/2, 0) // DOMAIN error\n \t\t}\n \t\treturn complex(math.Asinh(real(x)), 0)"}, {"sha": "486b717877e036743c642a99a53b39ec7e3ce860", "filename": "libgo/go/cmath/sin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fsin.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -122,7 +122,7 @@ func Cosh(x complex128) complex128 {\n \n // calculate sinh and cosh\n func sinhcosh(x float64) (sh, ch float64) {\n-\tif math.Fabs(x) <= 0.5 {\n+\tif math.Abs(x) <= 0.5 {\n \t\treturn math.Sinh(x), math.Cosh(x)\n \t}\n \te := math.Exp(x)"}, {"sha": "4e7e8050f944c32006147ddb1a53e60fa7286d47", "filename": "libgo/go/cmath/sqrt.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Fsqrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Fsqrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Fsqrt.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -76,7 +76,7 @@ func Sqrt(x complex128) complex128 {\n \tb := imag(x)\n \tvar scale float64\n \t// Rescale to avoid internal overflow or underflow.\n-\tif math.Fabs(a) > 4 || math.Fabs(b) > 4 {\n+\tif math.Abs(a) > 4 || math.Abs(b) > 4 {\n \t\ta *= 0.25\n \t\tb *= 0.25\n \t\tscale = 2\n@@ -89,11 +89,11 @@ func Sqrt(x complex128) complex128 {\n \tvar t float64\n \tif a > 0 {\n \t\tt = math.Sqrt(0.5*r + 0.5*a)\n-\t\tr = scale * math.Fabs((0.5*b)/t)\n+\t\tr = scale * math.Abs((0.5*b)/t)\n \t\tt *= scale\n \t} else {\n \t\tr = math.Sqrt(0.5*r - 0.5*a)\n-\t\tt = scale * math.Fabs((0.5*b)/r)\n+\t\tt = scale * math.Abs((0.5*b)/r)\n \t\tr *= scale\n \t}\n \tif b < 0 {"}, {"sha": "67dc22ad0fd39b242440b1eac9c12411236e14ea", "filename": "libgo/go/cmath/tan.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Ftan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcmath%2Ftan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmath%2Ftan.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -58,7 +58,7 @@ import \"math\"\n // Tan returns the tangent of x.\n func Tan(x complex128) complex128 {\n \td := math.Cos(2*real(x)) + math.Cosh(2*imag(x))\n-\tif math.Fabs(d) < 0.25 {\n+\tif math.Abs(d) < 0.25 {\n \t\td = tanSeries(x)\n \t}\n \tif d == 0 {\n@@ -109,8 +109,8 @@ func reducePi(x float64) float64 {\n // Taylor series expansion for cosh(2y) - cos(2x)\n func tanSeries(z complex128) float64 {\n \tconst MACHEP = 1.0 / (1 << 53)\n-\tx := math.Fabs(2 * real(z))\n-\ty := math.Fabs(2 * imag(z))\n+\tx := math.Abs(2 * real(z))\n+\ty := math.Abs(2 * imag(z))\n \tx = reducePi(x)\n \tx = x * x\n \ty = y * y\n@@ -139,7 +139,7 @@ func tanSeries(z complex128) float64 {\n \t\tt = y2 - x2\n \t\tt /= f\n \t\td += t\n-\t\tif math.Fabs(t/d) <= MACHEP {\n+\t\tif math.Abs(t/d) <= MACHEP {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -174,7 +174,7 @@ func tanSeries(z complex128) float64 {\n // Cot returns the cotangent of x.\n func Cot(x complex128) complex128 {\n \td := math.Cosh(2*imag(x)) - math.Cos(2*real(x))\n-\tif math.Fabs(d) < 0.25 {\n+\tif math.Abs(d) < 0.25 {\n \t\td = tanSeries(x)\n \t}\n \tif d == 0 {"}, {"sha": "6625e3a2b0f8db13c581c7857241f0f066be522d", "filename": "libgo/go/container/heap/heap_test.go", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -6,32 +6,46 @@ package heap_test\n \n import (\n \t\"testing\"\n-\t\"container/vector\"\n \t. \"container/heap\"\n )\n \n-type myHeap struct {\n-\t// A vector.Vector implements sort.Interface except for Less,\n-\t// and it implements Push and Pop as required for heap.Interface.\n-\tvector.Vector\n+type myHeap []int\n+\n+func (h *myHeap) Less(i, j int) bool {\n+\treturn (*h)[i] < (*h)[j]\n+}\n+\n+func (h *myHeap) Swap(i, j int) {\n+\t(*h)[i], (*h)[j] = (*h)[j], (*h)[i]\n+}\n+\n+func (h *myHeap) Len() int {\n+\treturn len(*h)\n+}\n+\n+func (h *myHeap) Pop() (v interface{}) {\n+\t*h, v = (*h)[:h.Len()-1], (*h)[h.Len()-1]\n+\treturn\n }\n \n-func (h *myHeap) Less(i, j int) bool { return h.At(i).(int) < h.At(j).(int) }\n+func (h *myHeap) Push(v interface{}) {\n+\t*h = append(*h, v.(int))\n+}\n \n-func (h *myHeap) verify(t *testing.T, i int) {\n+func (h myHeap) verify(t *testing.T, i int) {\n \tn := h.Len()\n \tj1 := 2*i + 1\n \tj2 := 2*i + 2\n \tif j1 < n {\n \t\tif h.Less(j1, i) {\n-\t\t\tt.Errorf(\"heap invariant invalidated [%d] = %d > [%d] = %d\", i, h.At(i), j1, h.At(j1))\n+\t\t\tt.Errorf(\"heap invariant invalidated [%d] = %d > [%d] = %d\", i, h[i], j1, h[j1])\n \t\t\treturn\n \t\t}\n \t\th.verify(t, j1)\n \t}\n \tif j2 < n {\n \t\tif h.Less(j2, i) {\n-\t\t\tt.Errorf(\"heap invariant invalidated [%d] = %d > [%d] = %d\", i, h.At(i), j1, h.At(j2))\n+\t\t\tt.Errorf(\"heap invariant invalidated [%d] = %d > [%d] = %d\", i, h[i], j1, h[j2])\n \t\t\treturn\n \t\t}\n \t\th.verify(t, j2)"}, {"sha": "6d6b2ac81a32ed873d159453cfaa7604032be330", "filename": "libgo/go/container/vector/defs.go", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fdefs.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,43 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package vector implements containers for managing sequences of elements.\n-// Vectors grow and shrink dynamically as necessary.\n-package vector\n-\n-// Vector is a container for numbered sequences of elements of type interface{}.\n-// A vector's length and capacity adjusts automatically as necessary.\n-// The zero value for Vector is an empty vector ready to use.\n-type Vector []interface{}\n-\n-// IntVector is a container for numbered sequences of elements of type int.\n-// A vector's length and capacity adjusts automatically as necessary.\n-// The zero value for IntVector is an empty vector ready to use.\n-type IntVector []int\n-\n-// StringVector is a container for numbered sequences of elements of type string.\n-// A vector's length and capacity adjusts automatically as necessary.\n-// The zero value for StringVector is an empty vector ready to use.\n-type StringVector []string\n-\n-// Initial underlying array size\n-const initialSize = 8\n-\n-// Partial sort.Interface support\n-\n-// LessInterface provides partial support of the sort.Interface.\n-type LessInterface interface {\n-\tLess(y interface{}) bool\n-}\n-\n-// Less returns a boolean denoting whether the i'th element is less than the j'th element.\n-func (p *Vector) Less(i, j int) bool { return (*p)[i].(LessInterface).Less((*p)[j]) }\n-\n-// sort.Interface support\n-\n-// Less returns a boolean denoting whether the i'th element is less than the j'th element.\n-func (p *IntVector) Less(i, j int) bool { return (*p)[i] < (*p)[j] }\n-\n-// Less returns a boolean denoting whether the i'th element is less than the j'th element.\n-func (p *StringVector) Less(i, j int) bool { return (*p)[i] < (*p)[j] }"}, {"sha": "aa88cfeb367b44c3684cba0d77e453c4a2e207b8", "filename": "libgo/go/container/vector/intvector.go", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,188 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CAUTION: If this file is not vector.go, it was generated\n-// automatically from vector.go - DO NOT EDIT in that case!\n-\n-package vector\n-\n-func (p *IntVector) realloc(length, capacity int) (b []int) {\n-\tif capacity < initialSize {\n-\t\tcapacity = initialSize\n-\t}\n-\tif capacity < length {\n-\t\tcapacity = length\n-\t}\n-\tb = make(IntVector, length, capacity)\n-\tcopy(b, *p)\n-\t*p = b\n-\treturn\n-}\n-\n-// Insert n elements at position i.\n-func (p *IntVector) Expand(i, n int) {\n-\ta := *p\n-\n-\t// make sure we have enough space\n-\tlen0 := len(a)\n-\tlen1 := len0 + n\n-\tif len1 <= cap(a) {\n-\t\t// enough space - just expand\n-\t\ta = a[0:len1]\n-\t} else {\n-\t\t// not enough space - double capacity\n-\t\tcapb := cap(a) * 2\n-\t\tif capb < len1 {\n-\t\t\t// still not enough - use required length\n-\t\t\tcapb = len1\n-\t\t}\n-\t\t// capb >= len1\n-\t\ta = p.realloc(len1, capb)\n-\t}\n-\n-\t// make a hole\n-\tfor j := len0 - 1; j >= i; j-- {\n-\t\ta[j+n] = a[j]\n-\t}\n-\n-\t*p = a\n-}\n-\n-// Insert n elements at the end of a vector.\n-func (p *IntVector) Extend(n int) { p.Expand(len(*p), n) }\n-\n-// Resize changes the length and capacity of a vector.\n-// If the new length is shorter than the current length, Resize discards\n-// trailing elements. If the new length is longer than the current length,\n-// Resize adds the respective zero values for the additional elements. The capacity\n-// parameter is ignored unless the new length or capacity is longer than the current\n-// capacity. The resized vector's capacity may be larger than the requested capacity.\n-func (p *IntVector) Resize(length, capacity int) *IntVector {\n-\ta := *p\n-\n-\tif length > cap(a) || capacity > cap(a) {\n-\t\t// not enough space or larger capacity requested explicitly\n-\t\ta = p.realloc(length, capacity)\n-\t} else if length < len(a) {\n-\t\t// clear trailing elements\n-\t\tfor i := range a[length:] {\n-\t\t\tvar zero int\n-\t\t\ta[length+i] = zero\n-\t\t}\n-\t}\n-\n-\t*p = a[0:length]\n-\treturn p\n-}\n-\n-// Len returns the number of elements in the vector.\n-// Same as len(*p).\n-func (p *IntVector) Len() int { return len(*p) }\n-\n-// Cap returns the capacity of the vector; that is, the\n-// maximum length the vector can grow without resizing.\n-// Same as cap(*p).\n-func (p *IntVector) Cap() int { return cap(*p) }\n-\n-// At returns the i'th element of the vector.\n-func (p *IntVector) At(i int) int { return (*p)[i] }\n-\n-// Set sets the i'th element of the vector to value x.\n-func (p *IntVector) Set(i int, x int) { (*p)[i] = x }\n-\n-// Last returns the element in the vector of highest index.\n-func (p *IntVector) Last() int { return (*p)[len(*p)-1] }\n-\n-// Copy makes a copy of the vector and returns it.\n-func (p *IntVector) Copy() IntVector {\n-\tarr := make(IntVector, len(*p))\n-\tcopy(arr, *p)\n-\treturn arr\n-}\n-\n-// Insert inserts into the vector an element of value x before\n-// the current element at index i.\n-func (p *IntVector) Insert(i int, x int) {\n-\tp.Expand(i, 1)\n-\t(*p)[i] = x\n-}\n-\n-// Delete deletes the i'th element of the vector.  The gap is closed so the old\n-// element at index i+1 has index i afterwards.\n-func (p *IntVector) Delete(i int) {\n-\ta := *p\n-\tn := len(a)\n-\n-\tcopy(a[i:n-1], a[i+1:n])\n-\tvar zero int\n-\ta[n-1] = zero // support GC, zero out entry\n-\t*p = a[0 : n-1]\n-}\n-\n-// InsertVector inserts into the vector the contents of the vector\n-// x such that the 0th element of x appears at index i after insertion.\n-func (p *IntVector) InsertVector(i int, x *IntVector) {\n-\tb := *x\n-\n-\tp.Expand(i, len(b))\n-\tcopy((*p)[i:i+len(b)], b)\n-}\n-\n-// Cut deletes elements i through j-1, inclusive.\n-func (p *IntVector) Cut(i, j int) {\n-\ta := *p\n-\tn := len(a)\n-\tm := n - (j - i)\n-\n-\tcopy(a[i:m], a[j:n])\n-\tfor k := m; k < n; k++ { //TODO(bflm) don't zero out the elements unless it's a Vector.\n-\t\tvar zero int\n-\t\ta[k] = zero // support GC, zero out entries\n-\t}\n-\n-\t*p = a[0:m]\n-}\n-\n-// Slice returns a new sub-vector by slicing the old one to extract slice [i:j].\n-// The elements are copied. The original vector is unchanged.\n-func (p *IntVector) Slice(i, j int) *IntVector {\n-\tvar s IntVector\n-\ts.realloc(j-i, 0) // will fail in Init() if j < i\n-\tcopy(s, (*p)[i:j])\n-\treturn &s\n-}\n-\n-// Convenience wrappers\n-\n-// Push appends x to the end of the vector.\n-func (p *IntVector) Push(x int) { p.Insert(len(*p), x) }\n-\n-// Pop deletes the last element of the vector.\n-func (p *IntVector) Pop() int {\n-\ta := *p\n-\n-\ti := len(a) - 1\n-\tx := a[i]\n-\tvar zero int\n-\ta[i] = zero // support GC, zero out entry\n-\t*p = a[0:i]\n-\treturn x\n-}\n-\n-// AppendVector appends the entire vector x to the end of this vector.\n-func (p *IntVector) AppendVector(x *IntVector) { p.InsertVector(len(*p), x) }\n-\n-// Swap exchanges the elements at indexes i and j.\n-func (p *IntVector) Swap(i, j int) {\n-\ta := *p\n-\ta[i], a[j] = a[j], a[i]\n-}\n-\n-// Do calls function f for each element of the vector, in order.\n-// The behavior of Do is undefined if f changes *p.\n-func (p *IntVector) Do(f func(elem int)) {\n-\tfor _, e := range *p {\n-\t\tf(e)\n-\t}\n-}"}, {"sha": "b825af912218e979e89a06115dc41d9fd1fd2008", "filename": "libgo/go/container/vector/intvector_test.go", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fintvector_test.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CAUTION: If this file is not vector_test.go, it was generated\n-// automatically from vector_test.go - DO NOT EDIT in that case!\n-\n-package vector\n-\n-import \"testing\"\n-\n-func TestIntZeroLen(t *testing.T) {\n-\ta := new(IntVector)\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: B1) expected 0, got %d\", a, a.Len())\n-\t}\n-\tif len(*a) != 0 {\n-\t\tt.Errorf(\"%T: B2) expected 0, got %d\", a, len(*a))\n-\t}\n-\tvar b IntVector\n-\tif b.Len() != 0 {\n-\t\tt.Errorf(\"%T: B3) expected 0, got %d\", b, b.Len())\n-\t}\n-\tif len(b) != 0 {\n-\t\tt.Errorf(\"%T: B4) expected 0, got %d\", b, len(b))\n-\t}\n-}\n-\n-func TestIntResize(t *testing.T) {\n-\tvar a IntVector\n-\tcheckSize(t, &a, 0, 0)\n-\tcheckSize(t, a.Resize(0, 5), 0, 5)\n-\tcheckSize(t, a.Resize(1, 0), 1, 5)\n-\tcheckSize(t, a.Resize(10, 0), 10, 10)\n-\tcheckSize(t, a.Resize(5, 0), 5, 10)\n-\tcheckSize(t, a.Resize(3, 8), 3, 10)\n-\tcheckSize(t, a.Resize(0, 100), 0, 100)\n-\tcheckSize(t, a.Resize(11, 100), 11, 100)\n-}\n-\n-func TestIntResize2(t *testing.T) {\n-\tvar a IntVector\n-\tcheckSize(t, &a, 0, 0)\n-\ta.Push(int2IntValue(1))\n-\ta.Push(int2IntValue(2))\n-\ta.Push(int2IntValue(3))\n-\ta.Push(int2IntValue(4))\n-\tcheckSize(t, &a, 4, 4)\n-\tcheckSize(t, a.Resize(10, 0), 10, 10)\n-\tfor i := 4; i < a.Len(); i++ {\n-\t\tif a.At(i) != intzero {\n-\t\t\tt.Errorf(\"%T: expected a.At(%d) == %v; found %v!\", a, i, intzero, a.At(i))\n-\t\t}\n-\t}\n-\tfor i := 4; i < len(a); i++ {\n-\t\tif a[i] != intzero {\n-\t\t\tt.Errorf(\"%T: expected a[%d] == %v; found %v\", a, i, intzero, a[i])\n-\t\t}\n-\t}\n-}\n-\n-func checkIntZero(t *testing.T, a *IntVector, i int) {\n-\tfor j := 0; j < i; j++ {\n-\t\tif a.At(j) == intzero {\n-\t\t\tt.Errorf(\"%T: 1 expected a.At(%d) == %d; found %v\", a, j, j, a.At(j))\n-\t\t}\n-\t\tif (*a)[j] == intzero {\n-\t\t\tt.Errorf(\"%T: 2 expected (*a)[%d] == %d; found %v\", a, j, j, (*a)[j])\n-\t\t}\n-\t}\n-\tfor ; i < a.Len(); i++ {\n-\t\tif a.At(i) != intzero {\n-\t\t\tt.Errorf(\"%T: 3 expected a.At(%d) == %v; found %v\", a, i, intzero, a.At(i))\n-\t\t}\n-\t\tif (*a)[i] != intzero {\n-\t\t\tt.Errorf(\"%T: 4 expected (*a)[%d] == %v; found %v\", a, i, intzero, (*a)[i])\n-\t\t}\n-\t}\n-}\n-\n-func TestIntTrailingElements(t *testing.T) {\n-\tvar a IntVector\n-\tfor i := 0; i < 10; i++ {\n-\t\ta.Push(int2IntValue(i + 1))\n-\t}\n-\tcheckIntZero(t, &a, 10)\n-\tcheckSize(t, &a, 10, 16)\n-\tcheckSize(t, a.Resize(5, 0), 5, 16)\n-\tcheckSize(t, a.Resize(10, 0), 10, 16)\n-\tcheckIntZero(t, &a, 5)\n-}\n-\n-func TestIntAccess(t *testing.T) {\n-\tconst n = 100\n-\tvar a IntVector\n-\ta.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Set(i, int2IntValue(val(i)))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tif elem2IntValue(a.At(i)) != int2IntValue(val(i)) {\n-\t\t\tt.Error(i)\n-\t\t}\n-\t}\n-\tvar b IntVector\n-\tb.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\tb[i] = int2IntValue(val(i))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tif elem2IntValue(b[i]) != int2IntValue(val(i)) {\n-\t\t\tt.Error(i)\n-\t\t}\n-\t}\n-}\n-\n-func TestIntInsertDeleteClear(t *testing.T) {\n-\tconst n = 100\n-\tvar a IntVector\n-\n-\tfor i := 0; i < n; i++ {\n-\t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"%T: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n-\t\t}\n-\t\tif len(a) != i {\n-\t\t\tt.Errorf(\"%T: A) wrong len() %d (expected %d)\", a, len(a), i)\n-\t\t}\n-\t\ta.Insert(0, int2IntValue(val(i)))\n-\t\tif elem2IntValue(a.Last()) != int2IntValue(val(0)) {\n-\t\t\tt.Errorf(\"%T: B\", a)\n-\t\t}\n-\t}\n-\tfor i := n - 1; i >= 0; i-- {\n-\t\tif elem2IntValue(a.Last()) != int2IntValue(val(0)) {\n-\t\t\tt.Errorf(\"%T: C\", a)\n-\t\t}\n-\t\tif elem2IntValue(a.At(0)) != int2IntValue(val(i)) {\n-\t\t\tt.Errorf(\"%T: D\", a)\n-\t\t}\n-\t\tif elem2IntValue(a[0]) != int2IntValue(val(i)) {\n-\t\t\tt.Errorf(\"%T: D2\", a)\n-\t\t}\n-\t\ta.Delete(0)\n-\t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"%T: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n-\t\t}\n-\t\tif len(a) != i {\n-\t\t\tt.Errorf(\"%T: E) wrong len() %d (expected %d)\", a, len(a), i)\n-\t\t}\n-\t}\n-\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: F) wrong Len() %d (expected 0)\", a, a.Len())\n-\t}\n-\tif len(a) != 0 {\n-\t\tt.Errorf(\"%T: F) wrong len() %d (expected 0)\", a, len(a))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Push(int2IntValue(val(i)))\n-\t\tif a.Len() != i+1 {\n-\t\t\tt.Errorf(\"%T: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n-\t\t}\n-\t\tif len(a) != i+1 {\n-\t\t\tt.Errorf(\"%T: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n-\t\t}\n-\t\tif elem2IntValue(a.Last()) != int2IntValue(val(i)) {\n-\t\t\tt.Errorf(\"%T: H\", a)\n-\t\t}\n-\t}\n-\ta.Resize(0, 0)\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: I wrong Len() %d (expected 0)\", a, a.Len())\n-\t}\n-\tif len(a) != 0 {\n-\t\tt.Errorf(\"%T: I wrong len() %d (expected 0)\", a, len(a))\n-\t}\n-\n-\tconst m = 5\n-\tfor j := 0; j < m; j++ {\n-\t\ta.Push(int2IntValue(j))\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\tx := val(i)\n-\t\t\ta.Push(int2IntValue(x))\n-\t\t\tif elem2IntValue(a.Pop()) != int2IntValue(x) {\n-\t\t\t\tt.Errorf(\"%T: J\", a)\n-\t\t\t}\n-\t\t\tif a.Len() != j+1 {\n-\t\t\t\tt.Errorf(\"%T: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n-\t\t\t}\n-\t\t\tif len(a) != j+1 {\n-\t\t\t\tt.Errorf(\"%T: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif a.Len() != m {\n-\t\tt.Errorf(\"%T: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n-\t}\n-\tif len(a) != m {\n-\t\tt.Errorf(\"%T: L) wrong len() %d (expected %d)\", a, len(a), m)\n-\t}\n-}\n-\n-func verify_sliceInt(t *testing.T, x *IntVector, elt, i, j int) {\n-\tfor k := i; k < j; k++ {\n-\t\tif elem2IntValue(x.At(k)) != int2IntValue(elt) {\n-\t\t\tt.Errorf(\"%T: M) wrong [%d] element %v (expected %v)\", x, k, elem2IntValue(x.At(k)), int2IntValue(elt))\n-\t\t}\n-\t}\n-\n-\ts := x.Slice(i, j)\n-\tfor k, n := 0, j-i; k < n; k++ {\n-\t\tif elem2IntValue(s.At(k)) != int2IntValue(elt) {\n-\t\t\tt.Errorf(\"%T: N) wrong [%d] element %v (expected %v)\", x, k, elem2IntValue(x.At(k)), int2IntValue(elt))\n-\t\t}\n-\t}\n-}\n-\n-func verify_patternInt(t *testing.T, x *IntVector, a, b, c int) {\n-\tn := a + b + c\n-\tif x.Len() != n {\n-\t\tt.Errorf(\"%T: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n-\t}\n-\tif len(*x) != n {\n-\t\tt.Errorf(\"%T: O) wrong len() %d (expected %d)\", x, len(*x), n)\n-\t}\n-\tverify_sliceInt(t, x, 0, 0, a)\n-\tverify_sliceInt(t, x, 1, a, a+b)\n-\tverify_sliceInt(t, x, 0, a+b, n)\n-}\n-\n-func make_vectorInt(elt, len int) *IntVector {\n-\tx := new(IntVector).Resize(len, 0)\n-\tfor i := 0; i < len; i++ {\n-\t\tx.Set(i, int2IntValue(elt))\n-\t}\n-\treturn x\n-}\n-\n-func TestIntInsertVector(t *testing.T) {\n-\t// 1\n-\ta := make_vectorInt(0, 0)\n-\tb := make_vectorInt(1, 10)\n-\ta.InsertVector(0, b)\n-\tverify_patternInt(t, a, 0, 10, 0)\n-\t// 2\n-\ta = make_vectorInt(0, 10)\n-\tb = make_vectorInt(1, 0)\n-\ta.InsertVector(5, b)\n-\tverify_patternInt(t, a, 5, 0, 5)\n-\t// 3\n-\ta = make_vectorInt(0, 10)\n-\tb = make_vectorInt(1, 3)\n-\ta.InsertVector(3, b)\n-\tverify_patternInt(t, a, 3, 3, 7)\n-\t// 4\n-\ta = make_vectorInt(0, 10)\n-\tb = make_vectorInt(1, 1000)\n-\ta.InsertVector(8, b)\n-\tverify_patternInt(t, a, 8, 1000, 2)\n-}\n-\n-func TestIntDo(t *testing.T) {\n-\tconst n = 25\n-\tconst salt = 17\n-\ta := new(IntVector).Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Set(i, int2IntValue(salt*i))\n-\t}\n-\tcount := 0\n-\ta.Do(func(e int) {\n-\t\ti := intf2IntValue(e)\n-\t\tif i != int2IntValue(count*salt) {\n-\t\t\tt.Error(tname(a), \"value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(a), \"should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-\tb := new(IntVector).Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\t(*b)[i] = int2IntValue(salt * i)\n-\t}\n-\tcount = 0\n-\tb.Do(func(e int) {\n-\t\ti := intf2IntValue(e)\n-\t\tif i != int2IntValue(count*salt) {\n-\t\t\tt.Error(tname(b), \"b) value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(b), \"b) should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-\tvar c IntVector\n-\tc.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\tc[i] = int2IntValue(salt * i)\n-\t}\n-\tcount = 0\n-\tc.Do(func(e int) {\n-\t\ti := intf2IntValue(e)\n-\t\tif i != int2IntValue(count*salt) {\n-\t\t\tt.Error(tname(c), \"c) value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(c), \"c) should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-}\n-\n-func TestIntVectorCopy(t *testing.T) {\n-\t// verify Copy() returns a copy, not simply a slice of the original vector\n-\tconst Len = 10\n-\tvar src IntVector\n-\tfor i := 0; i < Len; i++ {\n-\t\tsrc.Push(int2IntValue(i * i))\n-\t}\n-\tdest := src.Copy()\n-\tfor i := 0; i < Len; i++ {\n-\t\tsrc[i] = int2IntValue(-1)\n-\t\tv := elem2IntValue(dest[i])\n-\t\tif v != int2IntValue(i*i) {\n-\t\t\tt.Error(tname(src), \"expected\", i*i, \"got\", v)\n-\t\t}\n-\t}\n-}"}, {"sha": "7b6a25952b12fecd80215e043768d8c96d8b3e9f", "filename": "libgo/go/container/vector/nogen_test.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fnogen_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fnogen_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fnogen_test.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package vector\n-\n-import (\n-\t\"fmt\"\n-\t\"sort\"\n-\t\"testing\"\n-)\n-\n-var (\n-\tzero    interface{}\n-\tintzero int\n-\tstrzero string\n-)\n-\n-func int2Value(x int) int       { return x }\n-func int2IntValue(x int) int    { return x }\n-func int2StrValue(x int) string { return string(x) }\n-\n-func elem2Value(x interface{}) int  { return x.(int) }\n-func elem2IntValue(x int) int       { return x }\n-func elem2StrValue(x string) string { return x }\n-\n-func intf2Value(x interface{}) int       { return x.(int) }\n-func intf2IntValue(x interface{}) int    { return x.(int) }\n-func intf2StrValue(x interface{}) string { return x.(string) }\n-\n-type VectorInterface interface {\n-\tLen() int\n-\tCap() int\n-}\n-\n-func checkSize(t *testing.T, v VectorInterface, len, cap int) {\n-\tif v.Len() != len {\n-\t\tt.Errorf(\"%T expected len = %d; found %d\", v, len, v.Len())\n-\t}\n-\tif v.Cap() < cap {\n-\t\tt.Errorf(\"%T expected cap >= %d; found %d\", v, cap, v.Cap())\n-\t}\n-}\n-\n-func val(i int) int { return i*991 - 1234 }\n-\n-func TestSorting(t *testing.T) {\n-\tconst n = 100\n-\n-\ta := new(IntVector).Resize(n, 0)\n-\tfor i := n - 1; i >= 0; i-- {\n-\t\ta.Set(i, n-1-i)\n-\t}\n-\tif sort.IsSorted(a) {\n-\t\tt.Error(\"int vector not sorted\")\n-\t}\n-\n-\tb := new(StringVector).Resize(n, 0)\n-\tfor i := n - 1; i >= 0; i-- {\n-\t\tb.Set(i, fmt.Sprint(n-1-i))\n-\t}\n-\tif sort.IsSorted(b) {\n-\t\tt.Error(\"string vector not sorted\")\n-\t}\n-}\n-\n-func tname(x interface{}) string { return fmt.Sprintf(\"%T: \", x) }"}, {"sha": "abe01a8fb180371c4d45c61b36018e8b39edbf23", "filename": "libgo/go/container/vector/numbers_test.go", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fnumbers_test.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package vector\n-\n-import (\n-\t\"fmt\"\n-\t\"runtime\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-const memTestN = 1000000\n-\n-func s(n uint64) string {\n-\tstr := fmt.Sprintf(\"%d\", n)\n-\tlens := len(str)\n-\ta := make([]string, (lens+2)/3)\n-\tstart := lens\n-\tfor i := range a {\n-\t\tstart -= 3\n-\t\tif start < 0 {\n-\t\t\tstart = 0\n-\t\t}\n-\t\ta[len(a)-i-1] = str[start:lens]\n-\t\tlens -= 3\n-\t}\n-\treturn strings.Join(a, \" \")\n-}\n-\n-func TestVectorNums(t *testing.T) {\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n-\tvar v Vector\n-\tc := int(0)\n-\truntime.GC()\n-\tm0 := runtime.MemStats\n-\tv.Resize(memTestN, memTestN)\n-\tfor i := 0; i < memTestN; i++ {\n-\t\tv.Set(i, c)\n-\t}\n-\truntime.GC()\n-\tm := runtime.MemStats\n-\tv.Resize(0, 0)\n-\truntime.GC()\n-\tn := m.Alloc - m0.Alloc\n-\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n-}\n-\n-func TestIntVectorNums(t *testing.T) {\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n-\tvar v IntVector\n-\tc := int(0)\n-\truntime.GC()\n-\tm0 := runtime.MemStats\n-\tv.Resize(memTestN, memTestN)\n-\tfor i := 0; i < memTestN; i++ {\n-\t\tv.Set(i, c)\n-\t}\n-\truntime.GC()\n-\tm := runtime.MemStats\n-\tv.Resize(0, 0)\n-\truntime.GC()\n-\tn := m.Alloc - m0.Alloc\n-\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n-}\n-\n-func TestStringVectorNums(t *testing.T) {\n-\tif testing.Short() {\n-\t\treturn\n-\t}\n-\tvar v StringVector\n-\tc := \"\"\n-\truntime.GC()\n-\tm0 := runtime.MemStats\n-\tv.Resize(memTestN, memTestN)\n-\tfor i := 0; i < memTestN; i++ {\n-\t\tv.Set(i, c)\n-\t}\n-\truntime.GC()\n-\tm := runtime.MemStats\n-\tv.Resize(0, 0)\n-\truntime.GC()\n-\tn := m.Alloc - m0.Alloc\n-\tt.Logf(\"%T.Push(%#v), n = %s: Alloc/n = %.2f\\n\", v, c, s(memTestN), float64(n)/memTestN)\n-}\n-\n-func BenchmarkVectorNums(b *testing.B) {\n-\tc := int(0)\n-\tvar v Vector\n-\tb.StopTimer()\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tv.Push(c)\n-\t}\n-}\n-\n-func BenchmarkIntVectorNums(b *testing.B) {\n-\tc := int(0)\n-\tvar v IntVector\n-\tb.StopTimer()\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tv.Push(c)\n-\t}\n-}\n-\n-func BenchmarkStringVectorNums(b *testing.B) {\n-\tc := \"\"\n-\tvar v StringVector\n-\tb.StopTimer()\n-\truntime.GC()\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\tv.Push(c)\n-\t}\n-}"}, {"sha": "dc81f06b74dfe992a7f87869d2d8b1c56654a1c6", "filename": "libgo/go/container/vector/stringvector.go", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,188 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CAUTION: If this file is not vector.go, it was generated\n-// automatically from vector.go - DO NOT EDIT in that case!\n-\n-package vector\n-\n-func (p *StringVector) realloc(length, capacity int) (b []string) {\n-\tif capacity < initialSize {\n-\t\tcapacity = initialSize\n-\t}\n-\tif capacity < length {\n-\t\tcapacity = length\n-\t}\n-\tb = make(StringVector, length, capacity)\n-\tcopy(b, *p)\n-\t*p = b\n-\treturn\n-}\n-\n-// Insert n elements at position i.\n-func (p *StringVector) Expand(i, n int) {\n-\ta := *p\n-\n-\t// make sure we have enough space\n-\tlen0 := len(a)\n-\tlen1 := len0 + n\n-\tif len1 <= cap(a) {\n-\t\t// enough space - just expand\n-\t\ta = a[0:len1]\n-\t} else {\n-\t\t// not enough space - double capacity\n-\t\tcapb := cap(a) * 2\n-\t\tif capb < len1 {\n-\t\t\t// still not enough - use required length\n-\t\t\tcapb = len1\n-\t\t}\n-\t\t// capb >= len1\n-\t\ta = p.realloc(len1, capb)\n-\t}\n-\n-\t// make a hole\n-\tfor j := len0 - 1; j >= i; j-- {\n-\t\ta[j+n] = a[j]\n-\t}\n-\n-\t*p = a\n-}\n-\n-// Insert n elements at the end of a vector.\n-func (p *StringVector) Extend(n int) { p.Expand(len(*p), n) }\n-\n-// Resize changes the length and capacity of a vector.\n-// If the new length is shorter than the current length, Resize discards\n-// trailing elements. If the new length is longer than the current length,\n-// Resize adds the respective zero values for the additional elements. The capacity\n-// parameter is ignored unless the new length or capacity is longer than the current\n-// capacity. The resized vector's capacity may be larger than the requested capacity.\n-func (p *StringVector) Resize(length, capacity int) *StringVector {\n-\ta := *p\n-\n-\tif length > cap(a) || capacity > cap(a) {\n-\t\t// not enough space or larger capacity requested explicitly\n-\t\ta = p.realloc(length, capacity)\n-\t} else if length < len(a) {\n-\t\t// clear trailing elements\n-\t\tfor i := range a[length:] {\n-\t\t\tvar zero string\n-\t\t\ta[length+i] = zero\n-\t\t}\n-\t}\n-\n-\t*p = a[0:length]\n-\treturn p\n-}\n-\n-// Len returns the number of elements in the vector.\n-// Same as len(*p).\n-func (p *StringVector) Len() int { return len(*p) }\n-\n-// Cap returns the capacity of the vector; that is, the\n-// maximum length the vector can grow without resizing.\n-// Same as cap(*p).\n-func (p *StringVector) Cap() int { return cap(*p) }\n-\n-// At returns the i'th element of the vector.\n-func (p *StringVector) At(i int) string { return (*p)[i] }\n-\n-// Set sets the i'th element of the vector to value x.\n-func (p *StringVector) Set(i int, x string) { (*p)[i] = x }\n-\n-// Last returns the element in the vector of highest index.\n-func (p *StringVector) Last() string { return (*p)[len(*p)-1] }\n-\n-// Copy makes a copy of the vector and returns it.\n-func (p *StringVector) Copy() StringVector {\n-\tarr := make(StringVector, len(*p))\n-\tcopy(arr, *p)\n-\treturn arr\n-}\n-\n-// Insert inserts into the vector an element of value x before\n-// the current element at index i.\n-func (p *StringVector) Insert(i int, x string) {\n-\tp.Expand(i, 1)\n-\t(*p)[i] = x\n-}\n-\n-// Delete deletes the i'th element of the vector.  The gap is closed so the old\n-// element at index i+1 has index i afterwards.\n-func (p *StringVector) Delete(i int) {\n-\ta := *p\n-\tn := len(a)\n-\n-\tcopy(a[i:n-1], a[i+1:n])\n-\tvar zero string\n-\ta[n-1] = zero // support GC, zero out entry\n-\t*p = a[0 : n-1]\n-}\n-\n-// InsertVector inserts into the vector the contents of the vector\n-// x such that the 0th element of x appears at index i after insertion.\n-func (p *StringVector) InsertVector(i int, x *StringVector) {\n-\tb := *x\n-\n-\tp.Expand(i, len(b))\n-\tcopy((*p)[i:i+len(b)], b)\n-}\n-\n-// Cut deletes elements i through j-1, inclusive.\n-func (p *StringVector) Cut(i, j int) {\n-\ta := *p\n-\tn := len(a)\n-\tm := n - (j - i)\n-\n-\tcopy(a[i:m], a[j:n])\n-\tfor k := m; k < n; k++ { //TODO(bflm) don't zero out the elements unless it's a Vector.\n-\t\tvar zero string\n-\t\ta[k] = zero // support GC, zero out entries\n-\t}\n-\n-\t*p = a[0:m]\n-}\n-\n-// Slice returns a new sub-vector by slicing the old one to extract slice [i:j].\n-// The elements are copied. The original vector is unchanged.\n-func (p *StringVector) Slice(i, j int) *StringVector {\n-\tvar s StringVector\n-\ts.realloc(j-i, 0) // will fail in Init() if j < i\n-\tcopy(s, (*p)[i:j])\n-\treturn &s\n-}\n-\n-// Convenience wrappers\n-\n-// Push appends x to the end of the vector.\n-func (p *StringVector) Push(x string) { p.Insert(len(*p), x) }\n-\n-// Pop deletes the last element of the vector.\n-func (p *StringVector) Pop() string {\n-\ta := *p\n-\n-\ti := len(a) - 1\n-\tx := a[i]\n-\tvar zero string\n-\ta[i] = zero // support GC, zero out entry\n-\t*p = a[0:i]\n-\treturn x\n-}\n-\n-// AppendVector appends the entire vector x to the end of this vector.\n-func (p *StringVector) AppendVector(x *StringVector) { p.InsertVector(len(*p), x) }\n-\n-// Swap exchanges the elements at indexes i and j.\n-func (p *StringVector) Swap(i, j int) {\n-\ta := *p\n-\ta[i], a[j] = a[j], a[i]\n-}\n-\n-// Do calls function f for each element of the vector, in order.\n-// The behavior of Do is undefined if f changes *p.\n-func (p *StringVector) Do(f func(elem string)) {\n-\tfor _, e := range *p {\n-\t\tf(e)\n-\t}\n-}"}, {"sha": "c75676f786c0e364d49e947cf2fba08e42e67338", "filename": "libgo/go/container/vector/stringvector_test.go", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fstringvector_test.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CAUTION: If this file is not vector_test.go, it was generated\n-// automatically from vector_test.go - DO NOT EDIT in that case!\n-\n-package vector\n-\n-import \"testing\"\n-\n-func TestStrZeroLen(t *testing.T) {\n-\ta := new(StringVector)\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: B1) expected 0, got %d\", a, a.Len())\n-\t}\n-\tif len(*a) != 0 {\n-\t\tt.Errorf(\"%T: B2) expected 0, got %d\", a, len(*a))\n-\t}\n-\tvar b StringVector\n-\tif b.Len() != 0 {\n-\t\tt.Errorf(\"%T: B3) expected 0, got %d\", b, b.Len())\n-\t}\n-\tif len(b) != 0 {\n-\t\tt.Errorf(\"%T: B4) expected 0, got %d\", b, len(b))\n-\t}\n-}\n-\n-func TestStrResize(t *testing.T) {\n-\tvar a StringVector\n-\tcheckSize(t, &a, 0, 0)\n-\tcheckSize(t, a.Resize(0, 5), 0, 5)\n-\tcheckSize(t, a.Resize(1, 0), 1, 5)\n-\tcheckSize(t, a.Resize(10, 0), 10, 10)\n-\tcheckSize(t, a.Resize(5, 0), 5, 10)\n-\tcheckSize(t, a.Resize(3, 8), 3, 10)\n-\tcheckSize(t, a.Resize(0, 100), 0, 100)\n-\tcheckSize(t, a.Resize(11, 100), 11, 100)\n-}\n-\n-func TestStrResize2(t *testing.T) {\n-\tvar a StringVector\n-\tcheckSize(t, &a, 0, 0)\n-\ta.Push(int2StrValue(1))\n-\ta.Push(int2StrValue(2))\n-\ta.Push(int2StrValue(3))\n-\ta.Push(int2StrValue(4))\n-\tcheckSize(t, &a, 4, 4)\n-\tcheckSize(t, a.Resize(10, 0), 10, 10)\n-\tfor i := 4; i < a.Len(); i++ {\n-\t\tif a.At(i) != strzero {\n-\t\t\tt.Errorf(\"%T: expected a.At(%d) == %v; found %v!\", a, i, strzero, a.At(i))\n-\t\t}\n-\t}\n-\tfor i := 4; i < len(a); i++ {\n-\t\tif a[i] != strzero {\n-\t\t\tt.Errorf(\"%T: expected a[%d] == %v; found %v\", a, i, strzero, a[i])\n-\t\t}\n-\t}\n-}\n-\n-func checkStrZero(t *testing.T, a *StringVector, i int) {\n-\tfor j := 0; j < i; j++ {\n-\t\tif a.At(j) == strzero {\n-\t\t\tt.Errorf(\"%T: 1 expected a.At(%d) == %d; found %v\", a, j, j, a.At(j))\n-\t\t}\n-\t\tif (*a)[j] == strzero {\n-\t\t\tt.Errorf(\"%T: 2 expected (*a)[%d] == %d; found %v\", a, j, j, (*a)[j])\n-\t\t}\n-\t}\n-\tfor ; i < a.Len(); i++ {\n-\t\tif a.At(i) != strzero {\n-\t\t\tt.Errorf(\"%T: 3 expected a.At(%d) == %v; found %v\", a, i, strzero, a.At(i))\n-\t\t}\n-\t\tif (*a)[i] != strzero {\n-\t\t\tt.Errorf(\"%T: 4 expected (*a)[%d] == %v; found %v\", a, i, strzero, (*a)[i])\n-\t\t}\n-\t}\n-}\n-\n-func TestStrTrailingElements(t *testing.T) {\n-\tvar a StringVector\n-\tfor i := 0; i < 10; i++ {\n-\t\ta.Push(int2StrValue(i + 1))\n-\t}\n-\tcheckStrZero(t, &a, 10)\n-\tcheckSize(t, &a, 10, 16)\n-\tcheckSize(t, a.Resize(5, 0), 5, 16)\n-\tcheckSize(t, a.Resize(10, 0), 10, 16)\n-\tcheckStrZero(t, &a, 5)\n-}\n-\n-func TestStrAccess(t *testing.T) {\n-\tconst n = 100\n-\tvar a StringVector\n-\ta.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Set(i, int2StrValue(val(i)))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tif elem2StrValue(a.At(i)) != int2StrValue(val(i)) {\n-\t\t\tt.Error(i)\n-\t\t}\n-\t}\n-\tvar b StringVector\n-\tb.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\tb[i] = int2StrValue(val(i))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tif elem2StrValue(b[i]) != int2StrValue(val(i)) {\n-\t\t\tt.Error(i)\n-\t\t}\n-\t}\n-}\n-\n-func TestStrInsertDeleteClear(t *testing.T) {\n-\tconst n = 100\n-\tvar a StringVector\n-\n-\tfor i := 0; i < n; i++ {\n-\t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"%T: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n-\t\t}\n-\t\tif len(a) != i {\n-\t\t\tt.Errorf(\"%T: A) wrong len() %d (expected %d)\", a, len(a), i)\n-\t\t}\n-\t\ta.Insert(0, int2StrValue(val(i)))\n-\t\tif elem2StrValue(a.Last()) != int2StrValue(val(0)) {\n-\t\t\tt.Errorf(\"%T: B\", a)\n-\t\t}\n-\t}\n-\tfor i := n - 1; i >= 0; i-- {\n-\t\tif elem2StrValue(a.Last()) != int2StrValue(val(0)) {\n-\t\t\tt.Errorf(\"%T: C\", a)\n-\t\t}\n-\t\tif elem2StrValue(a.At(0)) != int2StrValue(val(i)) {\n-\t\t\tt.Errorf(\"%T: D\", a)\n-\t\t}\n-\t\tif elem2StrValue(a[0]) != int2StrValue(val(i)) {\n-\t\t\tt.Errorf(\"%T: D2\", a)\n-\t\t}\n-\t\ta.Delete(0)\n-\t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"%T: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n-\t\t}\n-\t\tif len(a) != i {\n-\t\t\tt.Errorf(\"%T: E) wrong len() %d (expected %d)\", a, len(a), i)\n-\t\t}\n-\t}\n-\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: F) wrong Len() %d (expected 0)\", a, a.Len())\n-\t}\n-\tif len(a) != 0 {\n-\t\tt.Errorf(\"%T: F) wrong len() %d (expected 0)\", a, len(a))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Push(int2StrValue(val(i)))\n-\t\tif a.Len() != i+1 {\n-\t\t\tt.Errorf(\"%T: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n-\t\t}\n-\t\tif len(a) != i+1 {\n-\t\t\tt.Errorf(\"%T: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n-\t\t}\n-\t\tif elem2StrValue(a.Last()) != int2StrValue(val(i)) {\n-\t\t\tt.Errorf(\"%T: H\", a)\n-\t\t}\n-\t}\n-\ta.Resize(0, 0)\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: I wrong Len() %d (expected 0)\", a, a.Len())\n-\t}\n-\tif len(a) != 0 {\n-\t\tt.Errorf(\"%T: I wrong len() %d (expected 0)\", a, len(a))\n-\t}\n-\n-\tconst m = 5\n-\tfor j := 0; j < m; j++ {\n-\t\ta.Push(int2StrValue(j))\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\tx := val(i)\n-\t\t\ta.Push(int2StrValue(x))\n-\t\t\tif elem2StrValue(a.Pop()) != int2StrValue(x) {\n-\t\t\t\tt.Errorf(\"%T: J\", a)\n-\t\t\t}\n-\t\t\tif a.Len() != j+1 {\n-\t\t\t\tt.Errorf(\"%T: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n-\t\t\t}\n-\t\t\tif len(a) != j+1 {\n-\t\t\t\tt.Errorf(\"%T: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif a.Len() != m {\n-\t\tt.Errorf(\"%T: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n-\t}\n-\tif len(a) != m {\n-\t\tt.Errorf(\"%T: L) wrong len() %d (expected %d)\", a, len(a), m)\n-\t}\n-}\n-\n-func verify_sliceStr(t *testing.T, x *StringVector, elt, i, j int) {\n-\tfor k := i; k < j; k++ {\n-\t\tif elem2StrValue(x.At(k)) != int2StrValue(elt) {\n-\t\t\tt.Errorf(\"%T: M) wrong [%d] element %v (expected %v)\", x, k, elem2StrValue(x.At(k)), int2StrValue(elt))\n-\t\t}\n-\t}\n-\n-\ts := x.Slice(i, j)\n-\tfor k, n := 0, j-i; k < n; k++ {\n-\t\tif elem2StrValue(s.At(k)) != int2StrValue(elt) {\n-\t\t\tt.Errorf(\"%T: N) wrong [%d] element %v (expected %v)\", x, k, elem2StrValue(x.At(k)), int2StrValue(elt))\n-\t\t}\n-\t}\n-}\n-\n-func verify_patternStr(t *testing.T, x *StringVector, a, b, c int) {\n-\tn := a + b + c\n-\tif x.Len() != n {\n-\t\tt.Errorf(\"%T: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n-\t}\n-\tif len(*x) != n {\n-\t\tt.Errorf(\"%T: O) wrong len() %d (expected %d)\", x, len(*x), n)\n-\t}\n-\tverify_sliceStr(t, x, 0, 0, a)\n-\tverify_sliceStr(t, x, 1, a, a+b)\n-\tverify_sliceStr(t, x, 0, a+b, n)\n-}\n-\n-func make_vectorStr(elt, len int) *StringVector {\n-\tx := new(StringVector).Resize(len, 0)\n-\tfor i := 0; i < len; i++ {\n-\t\tx.Set(i, int2StrValue(elt))\n-\t}\n-\treturn x\n-}\n-\n-func TestStrInsertVector(t *testing.T) {\n-\t// 1\n-\ta := make_vectorStr(0, 0)\n-\tb := make_vectorStr(1, 10)\n-\ta.InsertVector(0, b)\n-\tverify_patternStr(t, a, 0, 10, 0)\n-\t// 2\n-\ta = make_vectorStr(0, 10)\n-\tb = make_vectorStr(1, 0)\n-\ta.InsertVector(5, b)\n-\tverify_patternStr(t, a, 5, 0, 5)\n-\t// 3\n-\ta = make_vectorStr(0, 10)\n-\tb = make_vectorStr(1, 3)\n-\ta.InsertVector(3, b)\n-\tverify_patternStr(t, a, 3, 3, 7)\n-\t// 4\n-\ta = make_vectorStr(0, 10)\n-\tb = make_vectorStr(1, 1000)\n-\ta.InsertVector(8, b)\n-\tverify_patternStr(t, a, 8, 1000, 2)\n-}\n-\n-func TestStrDo(t *testing.T) {\n-\tconst n = 25\n-\tconst salt = 17\n-\ta := new(StringVector).Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Set(i, int2StrValue(salt*i))\n-\t}\n-\tcount := 0\n-\ta.Do(func(e string) {\n-\t\ti := intf2StrValue(e)\n-\t\tif i != int2StrValue(count*salt) {\n-\t\t\tt.Error(tname(a), \"value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(a), \"should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-\tb := new(StringVector).Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\t(*b)[i] = int2StrValue(salt * i)\n-\t}\n-\tcount = 0\n-\tb.Do(func(e string) {\n-\t\ti := intf2StrValue(e)\n-\t\tif i != int2StrValue(count*salt) {\n-\t\t\tt.Error(tname(b), \"b) value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(b), \"b) should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-\tvar c StringVector\n-\tc.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\tc[i] = int2StrValue(salt * i)\n-\t}\n-\tcount = 0\n-\tc.Do(func(e string) {\n-\t\ti := intf2StrValue(e)\n-\t\tif i != int2StrValue(count*salt) {\n-\t\t\tt.Error(tname(c), \"c) value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(c), \"c) should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-}\n-\n-func TestStrVectorCopy(t *testing.T) {\n-\t// verify Copy() returns a copy, not simply a slice of the original vector\n-\tconst Len = 10\n-\tvar src StringVector\n-\tfor i := 0; i < Len; i++ {\n-\t\tsrc.Push(int2StrValue(i * i))\n-\t}\n-\tdest := src.Copy()\n-\tfor i := 0; i < Len; i++ {\n-\t\tsrc[i] = int2StrValue(-1)\n-\t\tv := elem2StrValue(dest[i])\n-\t\tif v != int2StrValue(i*i) {\n-\t\t\tt.Error(tname(src), \"expected\", i*i, \"got\", v)\n-\t\t}\n-\t}\n-}"}, {"sha": "8470ec067ac1ab5707ecbc40def98da6a8c64e72", "filename": "libgo/go/container/vector/vector.go", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,188 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CAUTION: If this file is not vector.go, it was generated\n-// automatically from vector.go - DO NOT EDIT in that case!\n-\n-package vector\n-\n-func (p *Vector) realloc(length, capacity int) (b []interface{}) {\n-\tif capacity < initialSize {\n-\t\tcapacity = initialSize\n-\t}\n-\tif capacity < length {\n-\t\tcapacity = length\n-\t}\n-\tb = make(Vector, length, capacity)\n-\tcopy(b, *p)\n-\t*p = b\n-\treturn\n-}\n-\n-// Insert n elements at position i.\n-func (p *Vector) Expand(i, n int) {\n-\ta := *p\n-\n-\t// make sure we have enough space\n-\tlen0 := len(a)\n-\tlen1 := len0 + n\n-\tif len1 <= cap(a) {\n-\t\t// enough space - just expand\n-\t\ta = a[0:len1]\n-\t} else {\n-\t\t// not enough space - double capacity\n-\t\tcapb := cap(a) * 2\n-\t\tif capb < len1 {\n-\t\t\t// still not enough - use required length\n-\t\t\tcapb = len1\n-\t\t}\n-\t\t// capb >= len1\n-\t\ta = p.realloc(len1, capb)\n-\t}\n-\n-\t// make a hole\n-\tfor j := len0 - 1; j >= i; j-- {\n-\t\ta[j+n] = a[j]\n-\t}\n-\n-\t*p = a\n-}\n-\n-// Insert n elements at the end of a vector.\n-func (p *Vector) Extend(n int) { p.Expand(len(*p), n) }\n-\n-// Resize changes the length and capacity of a vector.\n-// If the new length is shorter than the current length, Resize discards\n-// trailing elements. If the new length is longer than the current length,\n-// Resize adds the respective zero values for the additional elements. The capacity\n-// parameter is ignored unless the new length or capacity is longer than the current\n-// capacity. The resized vector's capacity may be larger than the requested capacity.\n-func (p *Vector) Resize(length, capacity int) *Vector {\n-\ta := *p\n-\n-\tif length > cap(a) || capacity > cap(a) {\n-\t\t// not enough space or larger capacity requested explicitly\n-\t\ta = p.realloc(length, capacity)\n-\t} else if length < len(a) {\n-\t\t// clear trailing elements\n-\t\tfor i := range a[length:] {\n-\t\t\tvar zero interface{}\n-\t\t\ta[length+i] = zero\n-\t\t}\n-\t}\n-\n-\t*p = a[0:length]\n-\treturn p\n-}\n-\n-// Len returns the number of elements in the vector.\n-// Same as len(*p).\n-func (p *Vector) Len() int { return len(*p) }\n-\n-// Cap returns the capacity of the vector; that is, the\n-// maximum length the vector can grow without resizing.\n-// Same as cap(*p).\n-func (p *Vector) Cap() int { return cap(*p) }\n-\n-// At returns the i'th element of the vector.\n-func (p *Vector) At(i int) interface{} { return (*p)[i] }\n-\n-// Set sets the i'th element of the vector to value x.\n-func (p *Vector) Set(i int, x interface{}) { (*p)[i] = x }\n-\n-// Last returns the element in the vector of highest index.\n-func (p *Vector) Last() interface{} { return (*p)[len(*p)-1] }\n-\n-// Copy makes a copy of the vector and returns it.\n-func (p *Vector) Copy() Vector {\n-\tarr := make(Vector, len(*p))\n-\tcopy(arr, *p)\n-\treturn arr\n-}\n-\n-// Insert inserts into the vector an element of value x before\n-// the current element at index i.\n-func (p *Vector) Insert(i int, x interface{}) {\n-\tp.Expand(i, 1)\n-\t(*p)[i] = x\n-}\n-\n-// Delete deletes the i'th element of the vector.  The gap is closed so the old\n-// element at index i+1 has index i afterwards.\n-func (p *Vector) Delete(i int) {\n-\ta := *p\n-\tn := len(a)\n-\n-\tcopy(a[i:n-1], a[i+1:n])\n-\tvar zero interface{}\n-\ta[n-1] = zero // support GC, zero out entry\n-\t*p = a[0 : n-1]\n-}\n-\n-// InsertVector inserts into the vector the contents of the vector\n-// x such that the 0th element of x appears at index i after insertion.\n-func (p *Vector) InsertVector(i int, x *Vector) {\n-\tb := *x\n-\n-\tp.Expand(i, len(b))\n-\tcopy((*p)[i:i+len(b)], b)\n-}\n-\n-// Cut deletes elements i through j-1, inclusive.\n-func (p *Vector) Cut(i, j int) {\n-\ta := *p\n-\tn := len(a)\n-\tm := n - (j - i)\n-\n-\tcopy(a[i:m], a[j:n])\n-\tfor k := m; k < n; k++ { //TODO(bflm) don't zero out the elements unless it's a Vector.\n-\t\tvar zero interface{}\n-\t\ta[k] = zero // support GC, zero out entries\n-\t}\n-\n-\t*p = a[0:m]\n-}\n-\n-// Slice returns a new sub-vector by slicing the old one to extract slice [i:j].\n-// The elements are copied. The original vector is unchanged.\n-func (p *Vector) Slice(i, j int) *Vector {\n-\tvar s Vector\n-\ts.realloc(j-i, 0) // will fail in Init() if j < i\n-\tcopy(s, (*p)[i:j])\n-\treturn &s\n-}\n-\n-// Convenience wrappers\n-\n-// Push appends x to the end of the vector.\n-func (p *Vector) Push(x interface{}) { p.Insert(len(*p), x) }\n-\n-// Pop deletes the last element of the vector.\n-func (p *Vector) Pop() interface{} {\n-\ta := *p\n-\n-\ti := len(a) - 1\n-\tx := a[i]\n-\tvar zero interface{}\n-\ta[i] = zero // support GC, zero out entry\n-\t*p = a[0:i]\n-\treturn x\n-}\n-\n-// AppendVector appends the entire vector x to the end of this vector.\n-func (p *Vector) AppendVector(x *Vector) { p.InsertVector(len(*p), x) }\n-\n-// Swap exchanges the elements at indexes i and j.\n-func (p *Vector) Swap(i, j int) {\n-\ta := *p\n-\ta[i], a[j] = a[j], a[i]\n-}\n-\n-// Do calls function f for each element of the vector, in order.\n-// The behavior of Do is undefined if f changes *p.\n-func (p *Vector) Do(f func(elem interface{})) {\n-\tfor _, e := range *p {\n-\t\tf(e)\n-\t}\n-}"}, {"sha": "a7f47b8c2a568df3732a414f0c3b0ffdba391340", "filename": "libgo/go/container/vector/vector_test.go", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fvector%2Fvector_test.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CAUTION: If this file is not vector_test.go, it was generated\n-// automatically from vector_test.go - DO NOT EDIT in that case!\n-\n-package vector\n-\n-import \"testing\"\n-\n-func TestZeroLen(t *testing.T) {\n-\ta := new(Vector)\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: B1) expected 0, got %d\", a, a.Len())\n-\t}\n-\tif len(*a) != 0 {\n-\t\tt.Errorf(\"%T: B2) expected 0, got %d\", a, len(*a))\n-\t}\n-\tvar b Vector\n-\tif b.Len() != 0 {\n-\t\tt.Errorf(\"%T: B3) expected 0, got %d\", b, b.Len())\n-\t}\n-\tif len(b) != 0 {\n-\t\tt.Errorf(\"%T: B4) expected 0, got %d\", b, len(b))\n-\t}\n-}\n-\n-func TestResize(t *testing.T) {\n-\tvar a Vector\n-\tcheckSize(t, &a, 0, 0)\n-\tcheckSize(t, a.Resize(0, 5), 0, 5)\n-\tcheckSize(t, a.Resize(1, 0), 1, 5)\n-\tcheckSize(t, a.Resize(10, 0), 10, 10)\n-\tcheckSize(t, a.Resize(5, 0), 5, 10)\n-\tcheckSize(t, a.Resize(3, 8), 3, 10)\n-\tcheckSize(t, a.Resize(0, 100), 0, 100)\n-\tcheckSize(t, a.Resize(11, 100), 11, 100)\n-}\n-\n-func TestResize2(t *testing.T) {\n-\tvar a Vector\n-\tcheckSize(t, &a, 0, 0)\n-\ta.Push(int2Value(1))\n-\ta.Push(int2Value(2))\n-\ta.Push(int2Value(3))\n-\ta.Push(int2Value(4))\n-\tcheckSize(t, &a, 4, 4)\n-\tcheckSize(t, a.Resize(10, 0), 10, 10)\n-\tfor i := 4; i < a.Len(); i++ {\n-\t\tif a.At(i) != zero {\n-\t\t\tt.Errorf(\"%T: expected a.At(%d) == %v; found %v!\", a, i, zero, a.At(i))\n-\t\t}\n-\t}\n-\tfor i := 4; i < len(a); i++ {\n-\t\tif a[i] != zero {\n-\t\t\tt.Errorf(\"%T: expected a[%d] == %v; found %v\", a, i, zero, a[i])\n-\t\t}\n-\t}\n-}\n-\n-func checkZero(t *testing.T, a *Vector, i int) {\n-\tfor j := 0; j < i; j++ {\n-\t\tif a.At(j) == zero {\n-\t\t\tt.Errorf(\"%T: 1 expected a.At(%d) == %d; found %v\", a, j, j, a.At(j))\n-\t\t}\n-\t\tif (*a)[j] == zero {\n-\t\t\tt.Errorf(\"%T: 2 expected (*a)[%d] == %d; found %v\", a, j, j, (*a)[j])\n-\t\t}\n-\t}\n-\tfor ; i < a.Len(); i++ {\n-\t\tif a.At(i) != zero {\n-\t\t\tt.Errorf(\"%T: 3 expected a.At(%d) == %v; found %v\", a, i, zero, a.At(i))\n-\t\t}\n-\t\tif (*a)[i] != zero {\n-\t\t\tt.Errorf(\"%T: 4 expected (*a)[%d] == %v; found %v\", a, i, zero, (*a)[i])\n-\t\t}\n-\t}\n-}\n-\n-func TestTrailingElements(t *testing.T) {\n-\tvar a Vector\n-\tfor i := 0; i < 10; i++ {\n-\t\ta.Push(int2Value(i + 1))\n-\t}\n-\tcheckZero(t, &a, 10)\n-\tcheckSize(t, &a, 10, 16)\n-\tcheckSize(t, a.Resize(5, 0), 5, 16)\n-\tcheckSize(t, a.Resize(10, 0), 10, 16)\n-\tcheckZero(t, &a, 5)\n-}\n-\n-func TestAccess(t *testing.T) {\n-\tconst n = 100\n-\tvar a Vector\n-\ta.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Set(i, int2Value(val(i)))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tif elem2Value(a.At(i)) != int2Value(val(i)) {\n-\t\t\tt.Error(i)\n-\t\t}\n-\t}\n-\tvar b Vector\n-\tb.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\tb[i] = int2Value(val(i))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tif elem2Value(b[i]) != int2Value(val(i)) {\n-\t\t\tt.Error(i)\n-\t\t}\n-\t}\n-}\n-\n-func TestInsertDeleteClear(t *testing.T) {\n-\tconst n = 100\n-\tvar a Vector\n-\n-\tfor i := 0; i < n; i++ {\n-\t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"%T: A) wrong Len() %d (expected %d)\", a, a.Len(), i)\n-\t\t}\n-\t\tif len(a) != i {\n-\t\t\tt.Errorf(\"%T: A) wrong len() %d (expected %d)\", a, len(a), i)\n-\t\t}\n-\t\ta.Insert(0, int2Value(val(i)))\n-\t\tif elem2Value(a.Last()) != int2Value(val(0)) {\n-\t\t\tt.Errorf(\"%T: B\", a)\n-\t\t}\n-\t}\n-\tfor i := n - 1; i >= 0; i-- {\n-\t\tif elem2Value(a.Last()) != int2Value(val(0)) {\n-\t\t\tt.Errorf(\"%T: C\", a)\n-\t\t}\n-\t\tif elem2Value(a.At(0)) != int2Value(val(i)) {\n-\t\t\tt.Errorf(\"%T: D\", a)\n-\t\t}\n-\t\tif elem2Value(a[0]) != int2Value(val(i)) {\n-\t\t\tt.Errorf(\"%T: D2\", a)\n-\t\t}\n-\t\ta.Delete(0)\n-\t\tif a.Len() != i {\n-\t\t\tt.Errorf(\"%T: E) wrong Len() %d (expected %d)\", a, a.Len(), i)\n-\t\t}\n-\t\tif len(a) != i {\n-\t\t\tt.Errorf(\"%T: E) wrong len() %d (expected %d)\", a, len(a), i)\n-\t\t}\n-\t}\n-\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: F) wrong Len() %d (expected 0)\", a, a.Len())\n-\t}\n-\tif len(a) != 0 {\n-\t\tt.Errorf(\"%T: F) wrong len() %d (expected 0)\", a, len(a))\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Push(int2Value(val(i)))\n-\t\tif a.Len() != i+1 {\n-\t\t\tt.Errorf(\"%T: G) wrong Len() %d (expected %d)\", a, a.Len(), i+1)\n-\t\t}\n-\t\tif len(a) != i+1 {\n-\t\t\tt.Errorf(\"%T: G) wrong len() %d (expected %d)\", a, len(a), i+1)\n-\t\t}\n-\t\tif elem2Value(a.Last()) != int2Value(val(i)) {\n-\t\t\tt.Errorf(\"%T: H\", a)\n-\t\t}\n-\t}\n-\ta.Resize(0, 0)\n-\tif a.Len() != 0 {\n-\t\tt.Errorf(\"%T: I wrong Len() %d (expected 0)\", a, a.Len())\n-\t}\n-\tif len(a) != 0 {\n-\t\tt.Errorf(\"%T: I wrong len() %d (expected 0)\", a, len(a))\n-\t}\n-\n-\tconst m = 5\n-\tfor j := 0; j < m; j++ {\n-\t\ta.Push(int2Value(j))\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\tx := val(i)\n-\t\t\ta.Push(int2Value(x))\n-\t\t\tif elem2Value(a.Pop()) != int2Value(x) {\n-\t\t\t\tt.Errorf(\"%T: J\", a)\n-\t\t\t}\n-\t\t\tif a.Len() != j+1 {\n-\t\t\t\tt.Errorf(\"%T: K) wrong Len() %d (expected %d)\", a, a.Len(), j+1)\n-\t\t\t}\n-\t\t\tif len(a) != j+1 {\n-\t\t\t\tt.Errorf(\"%T: K) wrong len() %d (expected %d)\", a, len(a), j+1)\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif a.Len() != m {\n-\t\tt.Errorf(\"%T: L) wrong Len() %d (expected %d)\", a, a.Len(), m)\n-\t}\n-\tif len(a) != m {\n-\t\tt.Errorf(\"%T: L) wrong len() %d (expected %d)\", a, len(a), m)\n-\t}\n-}\n-\n-func verify_slice(t *testing.T, x *Vector, elt, i, j int) {\n-\tfor k := i; k < j; k++ {\n-\t\tif elem2Value(x.At(k)) != int2Value(elt) {\n-\t\t\tt.Errorf(\"%T: M) wrong [%d] element %v (expected %v)\", x, k, elem2Value(x.At(k)), int2Value(elt))\n-\t\t}\n-\t}\n-\n-\ts := x.Slice(i, j)\n-\tfor k, n := 0, j-i; k < n; k++ {\n-\t\tif elem2Value(s.At(k)) != int2Value(elt) {\n-\t\t\tt.Errorf(\"%T: N) wrong [%d] element %v (expected %v)\", x, k, elem2Value(x.At(k)), int2Value(elt))\n-\t\t}\n-\t}\n-}\n-\n-func verify_pattern(t *testing.T, x *Vector, a, b, c int) {\n-\tn := a + b + c\n-\tif x.Len() != n {\n-\t\tt.Errorf(\"%T: O) wrong Len() %d (expected %d)\", x, x.Len(), n)\n-\t}\n-\tif len(*x) != n {\n-\t\tt.Errorf(\"%T: O) wrong len() %d (expected %d)\", x, len(*x), n)\n-\t}\n-\tverify_slice(t, x, 0, 0, a)\n-\tverify_slice(t, x, 1, a, a+b)\n-\tverify_slice(t, x, 0, a+b, n)\n-}\n-\n-func make_vector(elt, len int) *Vector {\n-\tx := new(Vector).Resize(len, 0)\n-\tfor i := 0; i < len; i++ {\n-\t\tx.Set(i, int2Value(elt))\n-\t}\n-\treturn x\n-}\n-\n-func TestInsertVector(t *testing.T) {\n-\t// 1\n-\ta := make_vector(0, 0)\n-\tb := make_vector(1, 10)\n-\ta.InsertVector(0, b)\n-\tverify_pattern(t, a, 0, 10, 0)\n-\t// 2\n-\ta = make_vector(0, 10)\n-\tb = make_vector(1, 0)\n-\ta.InsertVector(5, b)\n-\tverify_pattern(t, a, 5, 0, 5)\n-\t// 3\n-\ta = make_vector(0, 10)\n-\tb = make_vector(1, 3)\n-\ta.InsertVector(3, b)\n-\tverify_pattern(t, a, 3, 3, 7)\n-\t// 4\n-\ta = make_vector(0, 10)\n-\tb = make_vector(1, 1000)\n-\ta.InsertVector(8, b)\n-\tverify_pattern(t, a, 8, 1000, 2)\n-}\n-\n-func TestDo(t *testing.T) {\n-\tconst n = 25\n-\tconst salt = 17\n-\ta := new(Vector).Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\ta.Set(i, int2Value(salt*i))\n-\t}\n-\tcount := 0\n-\ta.Do(func(e interface{}) {\n-\t\ti := intf2Value(e)\n-\t\tif i != int2Value(count*salt) {\n-\t\t\tt.Error(tname(a), \"value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(a), \"should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-\tb := new(Vector).Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\t(*b)[i] = int2Value(salt * i)\n-\t}\n-\tcount = 0\n-\tb.Do(func(e interface{}) {\n-\t\ti := intf2Value(e)\n-\t\tif i != int2Value(count*salt) {\n-\t\t\tt.Error(tname(b), \"b) value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(b), \"b) should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-\tvar c Vector\n-\tc.Resize(n, 0)\n-\tfor i := 0; i < n; i++ {\n-\t\tc[i] = int2Value(salt * i)\n-\t}\n-\tcount = 0\n-\tc.Do(func(e interface{}) {\n-\t\ti := intf2Value(e)\n-\t\tif i != int2Value(count*salt) {\n-\t\t\tt.Error(tname(c), \"c) value at\", count, \"should be\", count*salt, \"not\", i)\n-\t\t}\n-\t\tcount++\n-\t})\n-\tif count != n {\n-\t\tt.Error(tname(c), \"c) should visit\", n, \"values; did visit\", count)\n-\t}\n-\n-}\n-\n-func TestVectorCopy(t *testing.T) {\n-\t// verify Copy() returns a copy, not simply a slice of the original vector\n-\tconst Len = 10\n-\tvar src Vector\n-\tfor i := 0; i < Len; i++ {\n-\t\tsrc.Push(int2Value(i * i))\n-\t}\n-\tdest := src.Copy()\n-\tfor i := 0; i < Len; i++ {\n-\t\tsrc[i] = int2Value(-1)\n-\t\tv := elem2Value(dest[i])\n-\t\tif v != int2Value(i*i) {\n-\t\t\tt.Error(tname(src), \"expected\", i*i, \"got\", v)\n-\t\t}\n-\t}\n-}"}, {"sha": "ed6cea70c59d3d0319c7f8aed5e3143bd24bf54d", "filename": "libgo/go/crypto/bcrypt/base64.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbase64.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bcrypt\n+\n+import (\n+\t\"encoding/base64\"\n+\t\"os\"\n+)\n+\n+const alphabet = \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n+\n+var bcEncoding = base64.NewEncoding(alphabet)\n+\n+func base64Encode(src []byte) []byte {\n+\tn := bcEncoding.EncodedLen(len(src))\n+\tdst := make([]byte, n)\n+\tbcEncoding.Encode(dst, src)\n+\tfor dst[n-1] == '=' {\n+\t\tn--\n+\t}\n+\treturn dst[:n]\n+}\n+\n+func base64Decode(src []byte) ([]byte, os.Error) {\n+\tnumOfEquals := 4 - (len(src) % 4)\n+\tfor i := 0; i < numOfEquals; i++ {\n+\t\tsrc = append(src, '=')\n+\t}\n+\n+\tdst := make([]byte, bcEncoding.DecodedLen(len(src)))\n+\tn, err := bcEncoding.Decode(dst, src)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn dst[:n], nil\n+}"}, {"sha": "1e8ccfac195fae15f10a41aad83202b0dd2ceaac", "filename": "libgo/go/crypto/bcrypt/bcrypt.go", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,282 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package bcrypt implements Provos and Mazi\u00e8res's bcrypt adapative hashing\n+// algorithm. See http://www.usenix.org/event/usenix99/provos/provos.pdf\n+package bcrypt\n+\n+// The code is a port of Provos and Mazi\u00e8res's C implementation. \n+import (\n+\t\"crypto/blowfish\"\n+\t\"crypto/rand\"\n+\t\"crypto/subtle\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+const (\n+\tMinCost     int = 4  // the minimum allowable cost as passed in to GenerateFromPassword\n+\tMaxCost     int = 31 // the maximum allowable cost as passed in to GenerateFromPassword\n+\tDefaultCost int = 10 // the cost that will actually be set if a cost below MinCost is passed into GenerateFromPassword\n+)\n+\n+// The error returned from CompareHashAndPassword when a password and hash do\n+// not match.\n+var MismatchedHashAndPasswordError = os.NewError(\"crypto/bcrypt: hashedPassword is not the hash of the given password\")\n+\n+// The error returned from CompareHashAndPassword when a hash is too short to\n+// be a bcrypt hash.\n+var HashTooShortError = os.NewError(\"crypto/bcrypt: hashedSecret too short to be a bcrypted password\")\n+\n+// The error returned from CompareHashAndPassword when a hash was created with\n+// a bcrypt algorithm newer than this implementation.\n+type HashVersionTooNewError byte\n+\n+func (hv HashVersionTooNewError) String() string {\n+\treturn fmt.Sprintf(\"crypto/bcrypt: bcrypt algorithm version '%c' requested is newer than current version '%c'\", byte(hv), majorVersion)\n+}\n+\n+// The error returned from CompareHashAndPassword when a hash starts with something other than '$'\n+type InvalidHashPrefixError byte\n+\n+func (ih InvalidHashPrefixError) String() string {\n+\treturn fmt.Sprintf(\"crypto/bcrypt: bcrypt hashes must start with '$', but hashedSecret started with '%c'\", byte(ih))\n+}\n+\n+type InvalidCostError int\n+\n+func (ic InvalidCostError) String() string {\n+\treturn fmt.Sprintf(\"crypto/bcrypt: cost %d is outside allowed range (%d,%d)\", int(ic), int(MinCost), int(MaxCost))\n+}\n+\n+const (\n+\tmajorVersion       = '2'\n+\tminorVersion       = 'a'\n+\tmaxSaltSize        = 16\n+\tmaxCryptedHashSize = 23\n+\tencodedSaltSize    = 22\n+\tencodedHashSize    = 31\n+\tminHashSize        = 59\n+)\n+\n+// magicCipherData is an IV for the 64 Blowfish encryption calls in\n+// bcrypt(). It's the string \"OrpheanBeholderScryDoubt\" in big-endian bytes.\n+var magicCipherData = []byte{\n+\t0x4f, 0x72, 0x70, 0x68,\n+\t0x65, 0x61, 0x6e, 0x42,\n+\t0x65, 0x68, 0x6f, 0x6c,\n+\t0x64, 0x65, 0x72, 0x53,\n+\t0x63, 0x72, 0x79, 0x44,\n+\t0x6f, 0x75, 0x62, 0x74,\n+}\n+\n+type hashed struct {\n+\thash  []byte\n+\tsalt  []byte\n+\tcost  uint32 // allowed range is MinCost to MaxCost\n+\tmajor byte\n+\tminor byte\n+}\n+\n+// GenerateFromPassword returns the bcrypt hash of the password at the given\n+// cost. If the cost given is less than MinCost, the cost will be set to\n+// MinCost, instead. Use CompareHashAndPassword, as defined in this package,\n+// to compare the returned hashed password with its cleartext version.\n+func GenerateFromPassword(password []byte, cost int) ([]byte, os.Error) {\n+\tp, err := newFromPassword(password, cost)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn p.Hash(), nil\n+}\n+\n+// CompareHashAndPassword compares a bcrypt hashed password with its possible\n+// plaintext equivalent. Note: Using bytes.Equal for this job is\n+// insecure. Returns nil on success, or an error on failure.\n+func CompareHashAndPassword(hashedPassword, password []byte) os.Error {\n+\tp, err := newFromHash(hashedPassword)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\totherHash, err := bcrypt(password, p.cost, p.salt)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\totherP := &hashed{otherHash, p.salt, p.cost, p.major, p.minor}\n+\tif subtle.ConstantTimeCompare(p.Hash(), otherP.Hash()) == 1 {\n+\t\treturn nil\n+\t}\n+\n+\treturn MismatchedHashAndPasswordError\n+}\n+\n+func newFromPassword(password []byte, cost int) (*hashed, os.Error) {\n+\tif cost < MinCost {\n+\t\tcost = DefaultCost\n+\t}\n+\tp := new(hashed)\n+\tp.major = majorVersion\n+\tp.minor = minorVersion\n+\n+\terr := checkCost(cost)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tp.cost = uint32(cost)\n+\n+\tunencodedSalt := make([]byte, maxSaltSize)\n+\t_, err = io.ReadFull(rand.Reader, unencodedSalt)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tp.salt = base64Encode(unencodedSalt)\n+\thash, err := bcrypt(password, p.cost, p.salt)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tp.hash = hash\n+\treturn p, err\n+}\n+\n+func newFromHash(hashedSecret []byte) (*hashed, os.Error) {\n+\tif len(hashedSecret) < minHashSize {\n+\t\treturn nil, HashTooShortError\n+\t}\n+\tp := new(hashed)\n+\tn, err := p.decodeVersion(hashedSecret)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\thashedSecret = hashedSecret[n:]\n+\tn, err = p.decodeCost(hashedSecret)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\thashedSecret = hashedSecret[n:]\n+\n+\t// The \"+2\" is here because we'll have to append at most 2 '=' to the salt\n+\t// when base64 decoding it in expensiveBlowfishSetup().\n+\tp.salt = make([]byte, encodedSaltSize, encodedSaltSize+2)\n+\tcopy(p.salt, hashedSecret[:encodedSaltSize])\n+\n+\thashedSecret = hashedSecret[encodedSaltSize:]\n+\tp.hash = make([]byte, len(hashedSecret))\n+\tcopy(p.hash, hashedSecret)\n+\n+\treturn p, nil\n+}\n+\n+func bcrypt(password []byte, cost uint32, salt []byte) ([]byte, os.Error) {\n+\tcipherData := make([]byte, len(magicCipherData))\n+\tcopy(cipherData, magicCipherData)\n+\n+\tc, err := expensiveBlowfishSetup(password, cost, salt)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfor i := 0; i < 24; i += 8 {\n+\t\tfor j := 0; j < 64; j++ {\n+\t\t\tc.Encrypt(cipherData[i:i+8], cipherData[i:i+8])\n+\t\t}\n+\t}\n+\n+\t// Bug compatibility with C bcrypt implementations. We only encode 23 of\n+\t// the 24 bytes encrypted.\n+\thsh := base64Encode(cipherData[:maxCryptedHashSize])\n+\treturn hsh, nil\n+}\n+\n+func expensiveBlowfishSetup(key []byte, cost uint32, salt []byte) (*blowfish.Cipher, os.Error) {\n+\n+\tcsalt, err := base64Decode(salt)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Bug compatibility with C bcrypt implementations. They use the trailing\n+\t// NULL in the key string during expansion.\n+\tckey := append(key, 0)\n+\n+\tc, err := blowfish.NewSaltedCipher(ckey, csalt)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\trounds := 1 << cost\n+\tfor i := 0; i < rounds; i++ {\n+\t\tblowfish.ExpandKey(ckey, c)\n+\t\tblowfish.ExpandKey(csalt, c)\n+\t}\n+\n+\treturn c, nil\n+}\n+\n+func (p *hashed) Hash() []byte {\n+\tarr := make([]byte, 60)\n+\tarr[0] = '$'\n+\tarr[1] = p.major\n+\tn := 2\n+\tif p.minor != 0 {\n+\t\tarr[2] = p.minor\n+\t\tn = 3\n+\t}\n+\tarr[n] = '$'\n+\tn += 1\n+\tcopy(arr[n:], []byte(fmt.Sprintf(\"%02d\", p.cost)))\n+\tn += 2\n+\tarr[n] = '$'\n+\tn += 1\n+\tcopy(arr[n:], p.salt)\n+\tn += encodedSaltSize\n+\tcopy(arr[n:], p.hash)\n+\tn += encodedHashSize\n+\treturn arr[:n]\n+}\n+\n+func (p *hashed) decodeVersion(sbytes []byte) (int, os.Error) {\n+\tif sbytes[0] != '$' {\n+\t\treturn -1, InvalidHashPrefixError(sbytes[0])\n+\t}\n+\tif sbytes[1] > majorVersion {\n+\t\treturn -1, HashVersionTooNewError(sbytes[1])\n+\t}\n+\tp.major = sbytes[1]\n+\tn := 3\n+\tif sbytes[2] != '$' {\n+\t\tp.minor = sbytes[2]\n+\t\tn++\n+\t}\n+\treturn n, nil\n+}\n+\n+// sbytes should begin where decodeVersion left off.\n+func (p *hashed) decodeCost(sbytes []byte) (int, os.Error) {\n+\tcost, err := strconv.Atoi(string(sbytes[0:2]))\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\terr = checkCost(cost)\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\tp.cost = uint32(cost)\n+\treturn 3, nil\n+}\n+\n+func (p *hashed) String() string {\n+\treturn fmt.Sprintf(\"&{hash: %#v, salt: %#v, cost: %d, major: %c, minor: %c}\", string(p.hash), p.salt, p.cost, p.major, p.minor)\n+}\n+\n+func checkCost(cost int) os.Error {\n+\tif cost < MinCost || cost > MaxCost {\n+\t\treturn InvalidCostError(cost)\n+\t}\n+\treturn nil\n+}"}, {"sha": "89eca0a4488db62d0d01d6ae450564938184aefb", "filename": "libgo/go/crypto/bcrypt/bcrypt_test.go", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bcrypt\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestBcryptingIsEasy(t *testing.T) {\n+\tpass := []byte(\"mypassword\")\n+\thp, err := GenerateFromPassword(pass, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"GenerateFromPassword error: %s\", err)\n+\t}\n+\n+\tif CompareHashAndPassword(hp, pass) != nil {\n+\t\tt.Errorf(\"%v should hash %s correctly\", hp, pass)\n+\t}\n+\n+\tnotPass := \"notthepass\"\n+\terr = CompareHashAndPassword(hp, []byte(notPass))\n+\tif err != MismatchedHashAndPasswordError {\n+\t\tt.Errorf(\"%v and %s should be mismatched\", hp, notPass)\n+\t}\n+}\n+\n+func TestBcryptingIsCorrect(t *testing.T) {\n+\tpass := []byte(\"allmine\")\n+\tsalt := []byte(\"XajjQvNhvvRt5GSeFk1xFe\")\n+\texpectedHash := []byte(\"$2a$10$XajjQvNhvvRt5GSeFk1xFeyqRrsxkhBkUiQeg0dt.wU1qD4aFDcga\")\n+\n+\thash, err := bcrypt(pass, 10, salt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"bcrypt blew up: %v\", err)\n+\t}\n+\tif !bytes.HasSuffix(expectedHash, hash) {\n+\t\tt.Errorf(\"%v should be the suffix of %v\", hash, expectedHash)\n+\t}\n+\n+\th, err := newFromHash(expectedHash)\n+\tif err != nil {\n+\t\tt.Errorf(\"Unable to parse %s: %v\", string(expectedHash), err)\n+\t}\n+\n+\t// This is not the safe way to compare these hashes. We do this only for\n+\t// testing clarity. Use bcrypt.CompareHashAndPassword()\n+\tif err == nil && !bytes.Equal(expectedHash, h.Hash()) {\n+\t\tt.Errorf(\"Parsed hash %v should equal %v\", h.Hash(), expectedHash)\n+\t}\n+}\n+\n+func TestTooLongPasswordsWork(t *testing.T) {\n+\tsalt := []byte(\"XajjQvNhvvRt5GSeFk1xFe\")\n+\t// One byte over the usual 56 byte limit that blowfish has\n+\ttooLongPass := []byte(\"012345678901234567890123456789012345678901234567890123456\")\n+\ttooLongExpected := []byte(\"$2a$10$XajjQvNhvvRt5GSeFk1xFe5l47dONXg781AmZtd869sO8zfsHuw7C\")\n+\thash, err := bcrypt(tooLongPass, 10, salt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"bcrypt blew up on long password: %v\", err)\n+\t}\n+\tif !bytes.HasSuffix(tooLongExpected, hash) {\n+\t\tt.Errorf(\"%v should be the suffix of %v\", hash, tooLongExpected)\n+\t}\n+}\n+\n+type InvalidHashTest struct {\n+\terr  os.Error\n+\thash []byte\n+}\n+\n+var invalidTests = []InvalidHashTest{\n+\t{HashTooShortError, []byte(\"$2a$10$fooo\")},\n+\t{HashTooShortError, []byte(\"$2a\")},\n+\t{HashVersionTooNewError('3'), []byte(\"$3a$10$sssssssssssssssssssssshhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\")},\n+\t{InvalidHashPrefixError('%'), []byte(\"%2a$10$sssssssssssssssssssssshhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\")},\n+\t{InvalidCostError(32), []byte(\"$2a$32$sssssssssssssssssssssshhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\")},\n+}\n+\n+func TestInvalidHashErrors(t *testing.T) {\n+\tcheck := func(name string, expected, err os.Error) {\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"%s: Should have returned an error\", name)\n+\t\t}\n+\t\tif err != nil && err != expected {\n+\t\t\tt.Errorf(\"%s gave err %v but should have given %v\", name, err.String(), expected.String())\n+\t\t}\n+\t}\n+\tfor _, iht := range invalidTests {\n+\t\t_, err := newFromHash(iht.hash)\n+\t\tcheck(\"newFromHash\", iht.err, err)\n+\t\terr = CompareHashAndPassword(iht.hash, []byte(\"anything\"))\n+\t\tcheck(\"CompareHashAndPassword\", iht.err, err)\n+\t}\n+}\n+\n+func TestUnpaddedBase64Encoding(t *testing.T) {\n+\toriginal := []byte{101, 201, 101, 75, 19, 227, 199, 20, 239, 236, 133, 32, 30, 109, 243, 30}\n+\tencodedOriginal := []byte(\"XajjQvNhvvRt5GSeFk1xFe\")\n+\n+\tencoded := base64Encode(original)\n+\n+\tif !bytes.Equal(encodedOriginal, encoded) {\n+\t\tt.Errorf(\"Encoded %v should have equaled %v\", encoded, encodedOriginal)\n+\t}\n+\n+\tdecoded, err := base64Decode(encodedOriginal)\n+\tif err != nil {\n+\t\tt.Fatalf(\"base64Decode blew up: %s\", err)\n+\t}\n+\n+\tif !bytes.Equal(decoded, original) {\n+\t\tt.Errorf(\"Decoded %v should have equaled %v\", decoded, original)\n+\t}\n+}\n+\n+func TestCost(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\tpass := []byte(\"mypassword\")\n+\n+\tfor c := 0; c < MinCost; c++ {\n+\t\tp, _ := newFromPassword(pass, c)\n+\t\tif p.cost != uint32(DefaultCost) {\n+\t\t\tt.Errorf(\"newFromPassword should default costs below %d to %d, but was %d\", MinCost, DefaultCost, p.cost)\n+\t\t}\n+\t}\n+\n+\tp, _ := newFromPassword(pass, 14)\n+\tif p.cost != 14 {\n+\t\tt.Errorf(\"newFromPassword should default cost to 14, but was %d\", p.cost)\n+\t}\n+\n+\thp, _ := newFromHash(p.Hash())\n+\tif p.cost != hp.cost {\n+\t\tt.Errorf(\"newFromHash should maintain the cost at %d, but was %d\", p.cost, hp.cost)\n+\t}\n+\n+\t_, err := newFromPassword(pass, 32)\n+\tif err == nil {\n+\t\tt.Fatalf(\"newFromPassword: should return a cost error\")\n+\t}\n+\tif err != InvalidCostError(32) {\n+\t\tt.Errorf(\"newFromPassword: should return cost error, got %#v\", err)\n+\t}\n+}\n+\n+func TestCostReturnsWithLeadingZeroes(t *testing.T) {\n+\thp, _ := newFromPassword([]byte(\"abcdefgh\"), 7)\n+\tcost := hp.Hash()[4:7]\n+\texpected := []byte(\"07$\")\n+\n+\tif !bytes.Equal(expected, cost) {\n+\t\tt.Errorf(\"single digit costs in hash should have leading zeros: was %v instead of %v\", cost, expected)\n+\t}\n+}\n+\n+func TestMinorNotRequired(t *testing.T) {\n+\tnoMinorHash := []byte(\"$2$10$XajjQvNhvvRt5GSeFk1xFeyqRrsxkhBkUiQeg0dt.wU1qD4aFDcga\")\n+\th, err := newFromHash(noMinorHash)\n+\tif err != nil {\n+\t\tt.Fatalf(\"No minor hash blew up: %s\", err)\n+\t}\n+\tif h.minor != 0 {\n+\t\tt.Errorf(\"Should leave minor version at 0, but was %d\", h.minor)\n+\t}\n+\n+\tif !bytes.Equal(noMinorHash, h.Hash()) {\n+\t\tt.Errorf(\"Should generate hash %v, but created %v\", noMinorHash, h.Hash())\n+\t}\n+}\n+\n+func BenchmarkEqual(b *testing.B) {\n+\tb.StopTimer()\n+\tpasswd := []byte(\"somepasswordyoulike\")\n+\thash, _ := GenerateFromPassword(passwd, 10)\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tCompareHashAndPassword(hash, passwd)\n+\t}\n+}\n+\n+func BenchmarkGeneration(b *testing.B) {\n+\tb.StopTimer()\n+\tpasswd := []byte(\"mylongpassword1234\")\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tGenerateFromPassword(passwd, 10)\n+\t}\n+}"}, {"sha": "326292dfc3c294e0d324280463597535d1c29173", "filename": "libgo/go/crypto/blowfish/block.go", "status": "modified", "additions": 98, "deletions": 7, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblock.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -4,13 +4,12 @@\n \n package blowfish\n \n-func expandKey(key []byte, c *Cipher) {\n-\tcopy(c.p[0:], p[0:])\n-\tcopy(c.s0[0:], s0[0:])\n-\tcopy(c.s1[0:], s1[0:])\n-\tcopy(c.s2[0:], s2[0:])\n-\tcopy(c.s3[0:], s3[0:])\n-\n+// ExpandKey performs a key expansion on the given *Cipher. Specifically, it\n+// performs the Blowfish algorithm's key schedule which sets up the *Cipher's\n+// pi and substitution tables for calls to Encrypt. This is used, primarily,\n+// by the bcrypt package to reuse the Blowfish key schedule during its\n+// set up. It's unlikely that you need to use this directly.\n+func ExpandKey(key []byte, c *Cipher) {\n \tj := 0\n \tfor i := 0; i < 18; i++ {\n \t\tvar d uint32\n@@ -48,6 +47,98 @@ func expandKey(key []byte, c *Cipher) {\n \t}\n }\n \n+// This is similar to ExpandKey, but folds the salt during the key\n+// schedule. While ExpandKey is essentially expandKeyWithSalt with an all-zero\n+// salt passed in, reusing ExpandKey turns out to be a place of inefficiency\n+// and specializing it here is useful.\n+func expandKeyWithSalt(key []byte, salt []byte, c *Cipher) {\n+\tj := 0\n+\texpandedKey := make([]uint32, 18)\n+\tfor i := 0; i < 18; i++ {\n+\t\tvar d uint32\n+\t\tfor k := 0; k < 4; k++ {\n+\t\t\td = d<<8 | uint32(key[j])&0x000000FF\n+\t\t\tj++\n+\t\t\tif j >= len(key) {\n+\t\t\t\tj = 0\n+\t\t\t}\n+\t\t}\n+\t\texpandedKey[i] = d\n+\t\tc.p[i] ^= d\n+\t}\n+\n+\tj = 0\n+\texpandedSalt := make([]uint32, 18)\n+\tfor i := 0; i < 18; i++ {\n+\t\tvar d uint32\n+\t\tfor k := 0; k < 4; k++ {\n+\t\t\td = d<<8 | uint32(salt[j])&0x000000FF\n+\t\t\tj++\n+\t\t\tif j >= len(salt) {\n+\t\t\t\tj = 0\n+\t\t\t}\n+\t\t}\n+\t\texpandedSalt[i] = d\n+\t}\n+\n+\tvar l, r uint32\n+\tfor i := 0; i < 18; i += 2 {\n+\t\tl ^= expandedSalt[i&2]\n+\t\tr ^= expandedSalt[(i&2)+1]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.p[i], c.p[i+1] = l, r\n+\t}\n+\n+\tfor i := 0; i < 256; i += 4 {\n+\t\tl ^= expandedSalt[2]\n+\t\tr ^= expandedSalt[3]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s0[i], c.s0[i+1] = l, r\n+\n+\t\tl ^= expandedSalt[0]\n+\t\tr ^= expandedSalt[1]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s0[i+2], c.s0[i+3] = l, r\n+\n+\t}\n+\n+\tfor i := 0; i < 256; i += 4 {\n+\t\tl ^= expandedSalt[2]\n+\t\tr ^= expandedSalt[3]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s1[i], c.s1[i+1] = l, r\n+\n+\t\tl ^= expandedSalt[0]\n+\t\tr ^= expandedSalt[1]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s1[i+2], c.s1[i+3] = l, r\n+\t}\n+\n+\tfor i := 0; i < 256; i += 4 {\n+\t\tl ^= expandedSalt[2]\n+\t\tr ^= expandedSalt[3]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s2[i], c.s2[i+1] = l, r\n+\n+\t\tl ^= expandedSalt[0]\n+\t\tr ^= expandedSalt[1]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s2[i+2], c.s2[i+3] = l, r\n+\t}\n+\n+\tfor i := 0; i < 256; i += 4 {\n+\t\tl ^= expandedSalt[2]\n+\t\tr ^= expandedSalt[3]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s3[i], c.s3[i+1] = l, r\n+\n+\t\tl ^= expandedSalt[0]\n+\t\tr ^= expandedSalt[1]\n+\t\tl, r = encryptBlock(l, r, c)\n+\t\tc.s3[i+2], c.s3[i+3] = l, r\n+\t}\n+}\n+\n func encryptBlock(l, r uint32, c *Cipher) (uint32, uint32) {\n \txl, xr := l, r\n \txl ^= c.p[0]"}, {"sha": "1038d2e39eed798256433114ecbfc350f9784ba1", "filename": "libgo/go/crypto/blowfish/blowfish_test.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblowfish_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblowfish_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fblowfish_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -190,3 +190,21 @@ func TestCipherDecrypt(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestSaltedCipherKeyLength(t *testing.T) {\n+\tvar key []byte\n+\tfor i := 0; i < 4; i++ {\n+\t\t_, err := NewSaltedCipher(key, []byte{'a'})\n+\t\tif err != KeySizeError(i) {\n+\t\t\tt.Errorf(\"NewSaltedCipher with short key, gave error %#v, expected %#v\", err, KeySizeError(i))\n+\t\t}\n+\t\tkey = append(key, 'a')\n+\t}\n+\n+\t// A 57-byte key. One over the typical blowfish restriction.\n+\tkey = []byte(\"012345678901234567890123456789012345678901234567890123456\")\n+\t_, err := NewSaltedCipher(key, []byte{'a'})\n+\tif err != nil {\n+\t\tt.Errorf(\"NewSaltedCipher with long key, gave error %#v\", err)\n+\t}\n+}"}, {"sha": "3439825e893166d3f8b7e462233d291afbf9576c", "filename": "libgo/go/crypto/blowfish/cipher.go", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -31,12 +31,28 @@ func (k KeySizeError) String() string {\n // NewCipher creates and returns a Cipher.\n // The key argument should be the Blowfish key, 4 to 56 bytes.\n func NewCipher(key []byte) (*Cipher, os.Error) {\n+\tvar result Cipher\n \tk := len(key)\n \tif k < 4 || k > 56 {\n \t\treturn nil, KeySizeError(k)\n \t}\n+\tinitCipher(key, &result)\n+\tExpandKey(key, &result)\n+\treturn &result, nil\n+}\n+\n+// NewSaltedCipher creates a returns a Cipher that folds a salt into its key\n+// schedule. For most purposes, NewCipher, instead of NewSaltedCipher, is\n+// sufficient and desirable. For bcrypt compatiblity, the key can be over 56\n+// bytes.\n+func NewSaltedCipher(key, salt []byte) (*Cipher, os.Error) {\n \tvar result Cipher\n-\texpandKey(key, &result)\n+\tk := len(key)\n+\tif k < 4 {\n+\t\treturn nil, KeySizeError(k)\n+\t}\n+\tinitCipher(key, &result)\n+\texpandKeyWithSalt(key, salt, &result)\n \treturn &result, nil\n }\n \n@@ -77,3 +93,11 @@ func (c *Cipher) Reset() {\n \tzero(c.s2[0:])\n \tzero(c.s3[0:])\n }\n+\n+func initCipher(key []byte, c *Cipher) {\n+\tcopy(c.p[0:], p[0:])\n+\tcopy(c.s0[0:], s0[0:])\n+\tcopy(c.s1[0:], s1[0:])\n+\tcopy(c.s2[0:], s2[0:])\n+\tcopy(c.s3[0:], s3[0:])\n+}"}, {"sha": "9578364b58f7e80b70824884eb7a5f0198d2c6ea", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -295,7 +295,7 @@ func TestBaseMult(t *testing.T) {\n \t\t}\n \t\tx, y := p224.ScalarBaseMult(k.Bytes())\n \t\tif fmt.Sprintf(\"%x\", x) != e.x || fmt.Sprintf(\"%x\", y) != e.y {\n-\t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %s), want (%s, %s)\", i, e.k, x, y, e.x, e.y)\n+\t\t\tt.Errorf(\"%d: bad output for k=%s: got (%x, %s), want (%x, %s)\", i, e.k, x, y, e.x, e.y)\n \t\t}\n \t\tif testing.Short() && i > 5 {\n \t\t\tbreak"}, {"sha": "7be37211c106f2ea176a288bfe1bcb989ed46bc7", "filename": "libgo/go/crypto/ocsp/ocsp_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -15,7 +15,7 @@ func TestOCSPDecode(t *testing.T) {\n \t\tt.Error(err)\n \t}\n \n-\texpected := Response{Status: 0, SerialNumber: []byte{0x1, 0xd0, 0xfa}, RevocationReason: 0, ThisUpdate: &time.Time{Year: 2010, Month: 7, Day: 7, Hour: 15, Minute: 1, Second: 5, Weekday: 0, ZoneOffset: 0, Zone: \"UTC\"}, NextUpdate: &time.Time{Year: 2010, Month: 7, Day: 7, Hour: 18, Minute: 35, Second: 17, Weekday: 0, ZoneOffset: 0, Zone: \"UTC\"}}\n+\texpected := Response{Status: 0, SerialNumber: []byte{0x1, 0xd0, 0xfa}, RevocationReason: 0, ThisUpdate: &time.Time{Year: 2010, Month: 7, Day: 7, Hour: 15, Minute: 1, Second: 5, ZoneOffset: 0, Zone: \"UTC\"}, NextUpdate: &time.Time{Year: 2010, Month: 7, Day: 7, Hour: 18, Minute: 35, Second: 17, ZoneOffset: 0, Zone: \"UTC\"}}\n \n \tif !reflect.DeepEqual(resp.ThisUpdate, resp.ThisUpdate) {\n \t\tt.Errorf(\"resp.ThisUpdate: got %d, want %d\", resp.ThisUpdate, expected.ThisUpdate)"}, {"sha": "76a7365b7fe694819494079ad4716505dd99e250", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux openbsd\n+\n // Unix cryptographically secure pseudorandom number\n // generator.\n "}, {"sha": "0c62251a7cdbbd3db84743560180ce274595dd2a", "filename": "libgo/go/crypto/tls/cipher_suites.go", "status": "modified", "additions": 93, "deletions": 12, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcipher_suites.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -7,8 +7,10 @@ package tls\n import (\n \t\"crypto/aes\"\n \t\"crypto/cipher\"\n+\t\"crypto/des\"\n \t\"crypto/hmac\"\n \t\"crypto/rc4\"\n+\t\"crypto/sha1\"\n \t\"crypto/x509\"\n \t\"hash\"\n \t\"os\"\n@@ -23,7 +25,7 @@ type keyAgreement interface {\n \t// ServerKeyExchange message, generateServerKeyExchange can return nil,\n \t// nil.\n \tgenerateServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, os.Error)\n-\tprocessClientKeyExchange(*Config, *clientKeyExchangeMsg) ([]byte, os.Error)\n+\tprocessClientKeyExchange(*Config, *clientKeyExchangeMsg, uint16) ([]byte, os.Error)\n \n \t// On the client side, the next two methods are called in order.\n \n@@ -46,21 +48,31 @@ type cipherSuite struct {\n \t// and point format that we can handle.\n \telliptic bool\n \tcipher   func(key, iv []byte, isRead bool) interface{}\n-\tmac      func(macKey []byte) hash.Hash\n+\tmac      func(version uint16, macKey []byte) macFunction\n }\n \n var cipherSuites = map[uint16]*cipherSuite{\n-\tTLS_RSA_WITH_RC4_128_SHA:           &cipherSuite{16, 20, 0, rsaKA, false, cipherRC4, hmacSHA1},\n-\tTLS_RSA_WITH_AES_128_CBC_SHA:       &cipherSuite{16, 20, 16, rsaKA, false, cipherAES, hmacSHA1},\n-\tTLS_ECDHE_RSA_WITH_RC4_128_SHA:     &cipherSuite{16, 20, 0, ecdheRSAKA, true, cipherRC4, hmacSHA1},\n-\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: &cipherSuite{16, 20, 16, ecdheRSAKA, true, cipherAES, hmacSHA1},\n+\tTLS_RSA_WITH_RC4_128_SHA:            &cipherSuite{16, 20, 0, rsaKA, false, cipherRC4, macSHA1},\n+\tTLS_RSA_WITH_3DES_EDE_CBC_SHA:       &cipherSuite{24, 20, 8, rsaKA, false, cipher3DES, macSHA1},\n+\tTLS_RSA_WITH_AES_128_CBC_SHA:        &cipherSuite{16, 20, 16, rsaKA, false, cipherAES, macSHA1},\n+\tTLS_ECDHE_RSA_WITH_RC4_128_SHA:      &cipherSuite{16, 20, 0, ecdheRSAKA, true, cipherRC4, macSHA1},\n+\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: &cipherSuite{24, 20, 8, ecdheRSAKA, true, cipher3DES, macSHA1},\n+\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:  &cipherSuite{16, 20, 16, ecdheRSAKA, true, cipherAES, macSHA1},\n }\n \n func cipherRC4(key, iv []byte, isRead bool) interface{} {\n \tcipher, _ := rc4.NewCipher(key)\n \treturn cipher\n }\n \n+func cipher3DES(key, iv []byte, isRead bool) interface{} {\n+\tblock, _ := des.NewTripleDESCipher(key)\n+\tif isRead {\n+\t\treturn cipher.NewCBCDecrypter(block, iv)\n+\t}\n+\treturn cipher.NewCBCEncrypter(block, iv)\n+}\n+\n func cipherAES(key, iv []byte, isRead bool) interface{} {\n \tblock, _ := aes.NewCipher(key)\n \tif isRead {\n@@ -69,8 +81,75 @@ func cipherAES(key, iv []byte, isRead bool) interface{} {\n \treturn cipher.NewCBCEncrypter(block, iv)\n }\n \n-func hmacSHA1(key []byte) hash.Hash {\n-\treturn hmac.NewSHA1(key)\n+// macSHA1 returns a macFunction for the given protocol version.\n+func macSHA1(version uint16, key []byte) macFunction {\n+\tif version == versionSSL30 {\n+\t\tmac := ssl30MAC{\n+\t\t\th:   sha1.New(),\n+\t\t\tkey: make([]byte, len(key)),\n+\t\t}\n+\t\tcopy(mac.key, key)\n+\t\treturn mac\n+\t}\n+\treturn tls10MAC{hmac.NewSHA1(key)}\n+}\n+\n+type macFunction interface {\n+\tSize() int\n+\tMAC(seq, data []byte) []byte\n+}\n+\n+// ssl30MAC implements the SSLv3 MAC function, as defined in\n+// www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 5.2.3.1\n+type ssl30MAC struct {\n+\th   hash.Hash\n+\tkey []byte\n+}\n+\n+func (s ssl30MAC) Size() int {\n+\treturn s.h.Size()\n+}\n+\n+var ssl30Pad1 = [48]byte{0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36}\n+\n+var ssl30Pad2 = [48]byte{0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c}\n+\n+func (s ssl30MAC) MAC(seq, record []byte) []byte {\n+\tpadLength := 48\n+\tif s.h.Size() == 20 {\n+\t\tpadLength = 40\n+\t}\n+\n+\ts.h.Reset()\n+\ts.h.Write(s.key)\n+\ts.h.Write(ssl30Pad1[:padLength])\n+\ts.h.Write(seq)\n+\ts.h.Write(record[:1])\n+\ts.h.Write(record[3:5])\n+\ts.h.Write(record[recordHeaderLen:])\n+\tdigest := s.h.Sum()\n+\n+\ts.h.Reset()\n+\ts.h.Write(s.key)\n+\ts.h.Write(ssl30Pad2[:padLength])\n+\ts.h.Write(digest)\n+\treturn s.h.Sum()\n+}\n+\n+// tls10MAC implements the TLS 1.0 MAC function. RFC 2246, section 6.2.3.\n+type tls10MAC struct {\n+\th hash.Hash\n+}\n+\n+func (s tls10MAC) Size() int {\n+\treturn s.h.Size()\n+}\n+\n+func (s tls10MAC) MAC(seq, record []byte) []byte {\n+\ts.h.Reset()\n+\ts.h.Write(seq)\n+\ts.h.Write(record)\n+\treturn s.h.Sum()\n }\n \n func rsaKA() keyAgreement {\n@@ -95,8 +174,10 @@ func mutualCipherSuite(have []uint16, want uint16) (suite *cipherSuite, id uint1\n // A list of the possible cipher suite ids. Taken from\n // http://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n const (\n-\tTLS_RSA_WITH_RC4_128_SHA           uint16 = 0x0005\n-\tTLS_RSA_WITH_AES_128_CBC_SHA       uint16 = 0x002f\n-\tTLS_ECDHE_RSA_WITH_RC4_128_SHA     uint16 = 0xc011\n-\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0xc013\n+\tTLS_RSA_WITH_RC4_128_SHA            uint16 = 0x0005\n+\tTLS_RSA_WITH_3DES_EDE_CBC_SHA       uint16 = 0x000a\n+\tTLS_RSA_WITH_AES_128_CBC_SHA        uint16 = 0x002f\n+\tTLS_ECDHE_RSA_WITH_RC4_128_SHA      uint16 = 0xc011\n+\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xc012\n+\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA  uint16 = 0xc013\n )"}, {"sha": "ea520859b827c9267a85fd283525cdeeef76c179", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 83, "deletions": 27, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/x509\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"strings\"\n \t\"sync\"\n \t\"time\"\n )\n@@ -20,8 +20,11 @@ const (\n \trecordHeaderLen = 5            // record header length\n \tmaxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)\n \n-\tminVersion = 0x0301 // minimum supported version - TLS 1.0\n-\tmaxVersion = 0x0301 // maximum supported version - TLS 1.0\n+\tversionSSL30 = 0x0300\n+\tversionTLS10 = 0x0301\n+\n+\tminVersion = versionSSL30\n+\tmaxVersion = versionTLS10\n )\n \n // TLS record types.\n@@ -98,6 +101,10 @@ type ConnectionState struct {\n \tNegotiatedProtocol         string\n \tNegotiatedProtocolIsMutual bool\n \n+\t// ServerName contains the server name indicated by the client, if any.\n+\t// (Only valid for server connections.)\n+\tServerName string\n+\n \t// the certificate chain that was presented by the other side\n \tPeerCertificates []*x509.Certificate\n \t// the verified certificate chains built from PeerCertificates.\n@@ -121,6 +128,14 @@ type Config struct {\n \t// Server configurations must include at least one certificate.\n \tCertificates []Certificate\n \n+\t// NameToCertificate maps from a certificate name to an element of\n+\t// Certificates. Note that a certificate name can be of the form\n+\t// '*.example.com' and so doesn't have to be a domain name as such.\n+\t// See Config.BuildNameToCertificate\n+\t// The nil value causes the first element of Certificates to be used\n+\t// for all connections.\n+\tNameToCertificate map[string]*Certificate\n+\n \t// RootCAs defines the set of root certificate authorities\n \t// that clients use when verifying server certificates.\n \t// If RootCAs is nil, TLS uses the host's root CA set.\n@@ -139,6 +154,14 @@ type Config struct {\n \t// anything more than self-signed.\n \tAuthenticateClient bool\n \n+\t// InsecureSkipVerify controls whether a client verifies the\n+\t// server's certificate chain and host name.\n+\t// If InsecureSkipVerify is true, TLS accepts any certificate\n+\t// presented by the server and any host name in that certificate.\n+\t// In this mode, TLS is susceptible to man-in-the-middle attacks.\n+\t// This should be used only for testing.\n+\tInsecureSkipVerify bool\n+\n \t// CipherSuites is a list of supported cipher suites. If CipherSuites\n \t// is nil, TLS uses a list of suites supported by the implementation.\n \tCipherSuites []uint16\n@@ -176,6 +199,59 @@ func (c *Config) cipherSuites() []uint16 {\n \treturn s\n }\n \n+// getCertificateForName returns the best certificate for the given name,\n+// defaulting to the first element of c.Certificates if there are no good\n+// options.\n+func (c *Config) getCertificateForName(name string) *Certificate {\n+\tif len(c.Certificates) == 1 || c.NameToCertificate == nil {\n+\t\t// There's only one choice, so no point doing any work.\n+\t\treturn &c.Certificates[0]\n+\t}\n+\n+\tname = strings.ToLower(name)\n+\tfor len(name) > 0 && name[len(name)-1] == '.' {\n+\t\tname = name[:len(name)-1]\n+\t}\n+\n+\tif cert, ok := c.NameToCertificate[name]; ok {\n+\t\treturn cert\n+\t}\n+\n+\t// try replacing labels in the name with wildcards until we get a\n+\t// match.\n+\tlabels := strings.Split(name, \".\")\n+\tfor i := range labels {\n+\t\tlabels[i] = \"*\"\n+\t\tcandidate := strings.Join(labels, \".\")\n+\t\tif cert, ok := c.NameToCertificate[candidate]; ok {\n+\t\t\treturn cert\n+\t\t}\n+\t}\n+\n+\t// If nothing matches, return the first certificate.\n+\treturn &c.Certificates[0]\n+}\n+\n+// BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate\n+// from the CommonName and SubjectAlternateName fields of each of the leaf\n+// certificates.\n+func (c *Config) BuildNameToCertificate() {\n+\tc.NameToCertificate = make(map[string]*Certificate)\n+\tfor i := range c.Certificates {\n+\t\tcert := &c.Certificates[i]\n+\t\tx509Cert, err := x509.ParseCertificate(cert.Certificate[0])\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif len(x509Cert.Subject.CommonName) > 0 {\n+\t\t\tc.NameToCertificate[x509Cert.Subject.CommonName] = cert\n+\t\t}\n+\t\tfor _, san := range x509Cert.DNSNames {\n+\t\t\tc.NameToCertificate[san] = cert\n+\t\t}\n+\t}\n+}\n+\n // A Certificate is a chain of one or more certificates, leaf first.\n type Certificate struct {\n \tCertificate [][]byte\n@@ -215,15 +291,6 @@ func defaultConfig() *Config {\n \treturn &emptyConfig\n }\n \n-// Possible certificate files; stop after finding one.\n-// On OS X we should really be using the Directory Services keychain\n-// but that requires a lot of Mach goo to get at.  Instead we use\n-// the same root set that curl uses.\n-var certFiles = []string{\n-\t\"/etc/ssl/certs/ca-certificates.crt\", // Linux etc\n-\t\"/usr/share/curl/curl-ca-bundle.crt\", // OS X\n-}\n-\n var once sync.Once\n \n func defaultRoots() *x509.CertPool {\n@@ -241,21 +308,10 @@ func initDefaults() {\n \tinitDefaultCipherSuites()\n }\n \n-var varDefaultRoots *x509.CertPool\n-\n-func initDefaultRoots() {\n-\troots := x509.NewCertPool()\n-\tfor _, file := range certFiles {\n-\t\tdata, err := ioutil.ReadFile(file)\n-\t\tif err == nil {\n-\t\t\troots.AppendCertsFromPEM(data)\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tvarDefaultRoots = roots\n-}\n-\n-var varDefaultCipherSuites []uint16\n+var (\n+\tvarDefaultRoots        *x509.CertPool\n+\tvarDefaultCipherSuites []uint16\n+)\n \n func initDefaultCipherSuites() {\n \tvarDefaultCipherSuites = make([]uint16, len(cipherSuites))"}, {"sha": "9bca7d95d90000d5fd76e9daede8e69fba76b2bc", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"crypto/cipher\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n-\t\"hash\"\n \t\"io\"\n \t\"net\"\n \t\"os\"\n@@ -37,6 +36,8 @@ type Conn struct {\n \t// verifiedChains contains the certificate chains that we built, as\n \t// opposed to the ones presented by the server.\n \tverifiedChains [][]*x509.Certificate\n+\t// serverName contains the server name indicated by the client, if any.\n+\tserverName string\n \n \tclientProtocol         string\n \tclientProtocolFallback bool\n@@ -108,18 +109,20 @@ func (c *Conn) SetWriteTimeout(nsec int64) os.Error {\n // connection, either sending or receiving.\n type halfConn struct {\n \tsync.Mutex\n-\tcipher interface{} // cipher algorithm\n-\tmac    hash.Hash   // MAC algorithm\n-\tseq    [8]byte     // 64-bit sequence number\n-\tbfree  *block      // list of free blocks\n+\tversion uint16      // protocol version\n+\tcipher  interface{} // cipher algorithm\n+\tmac     macFunction\n+\tseq     [8]byte // 64-bit sequence number\n+\tbfree   *block  // list of free blocks\n \n \tnextCipher interface{} // next encryption state\n-\tnextMac    hash.Hash   // next MAC algorithm\n+\tnextMac    macFunction // next MAC algorithm\n }\n \n // prepareCipherSpec sets the encryption and MAC states\n // that a subsequent changeCipherSpec will use.\n-func (hc *halfConn) prepareCipherSpec(cipher interface{}, mac hash.Hash) {\n+func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac macFunction) {\n+\thc.version = version\n \thc.nextCipher = cipher\n \thc.nextMac = mac\n }\n@@ -197,6 +200,22 @@ func removePadding(payload []byte) ([]byte, byte) {\n \treturn payload[:len(payload)-int(toRemove)], good\n }\n \n+// removePaddingSSL30 is a replacement for removePadding in the case that the\n+// protocol version is SSLv3. In this version, the contents of the padding\n+// are random and cannot be checked.\n+func removePaddingSSL30(payload []byte) ([]byte, byte) {\n+\tif len(payload) < 1 {\n+\t\treturn payload, 0\n+\t}\n+\n+\tpaddingLen := int(payload[len(payload)-1]) + 1\n+\tif paddingLen > len(payload) {\n+\t\treturn payload, 0\n+\t}\n+\n+\treturn payload[:len(payload)-paddingLen], 255\n+}\n+\n func roundUp(a, b int) int {\n \treturn a + (b-a%b)%b\n }\n@@ -226,7 +245,11 @@ func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t\t\t}\n \n \t\t\tc.CryptBlocks(payload, payload)\n-\t\t\tpayload, paddingGood = removePadding(payload)\n+\t\t\tif hc.version == versionSSL30 {\n+\t\t\t\tpayload, paddingGood = removePaddingSSL30(payload)\n+\t\t\t} else {\n+\t\t\t\tpayload, paddingGood = removePadding(payload)\n+\t\t\t}\n \t\t\tb.resize(recordHeaderLen + len(payload))\n \n \t\t\t// note that we still have a timing side-channel in the\n@@ -256,13 +279,10 @@ func (hc *halfConn) decrypt(b *block) (bool, alert) {\n \t\tb.data[4] = byte(n)\n \t\tb.resize(recordHeaderLen + n)\n \t\tremoteMAC := payload[n:]\n-\n-\t\thc.mac.Reset()\n-\t\thc.mac.Write(hc.seq[0:])\n+\t\tlocalMAC := hc.mac.MAC(hc.seq[0:], b.data)\n \t\thc.incSeq()\n-\t\thc.mac.Write(b.data)\n \n-\t\tif subtle.ConstantTimeCompare(hc.mac.Sum(), remoteMAC) != 1 || paddingGood != 255 {\n+\t\tif subtle.ConstantTimeCompare(localMAC, remoteMAC) != 1 || paddingGood != 255 {\n \t\t\treturn false, alertBadRecordMAC\n \t\t}\n \t}\n@@ -291,11 +311,9 @@ func padToBlockSize(payload []byte, blockSize int) (prefix, finalBlock []byte) {\n func (hc *halfConn) encrypt(b *block) (bool, alert) {\n \t// mac\n \tif hc.mac != nil {\n-\t\thc.mac.Reset()\n-\t\thc.mac.Write(hc.seq[0:])\n+\t\tmac := hc.mac.MAC(hc.seq[0:], b.data)\n \t\thc.incSeq()\n-\t\thc.mac.Write(b.data)\n-\t\tmac := hc.mac.Sum()\n+\n \t\tn := len(b.data)\n \t\tb.resize(n + len(mac))\n \t\tcopy(b.data[n:], mac)\n@@ -470,6 +488,19 @@ Again:\n \tif n > maxCiphertext {\n \t\treturn c.sendAlert(alertRecordOverflow)\n \t}\n+\tif !c.haveVers {\n+\t\t// First message, be extra suspicious:\n+\t\t// this might not be a TLS client.\n+\t\t// Bail out before reading a full 'body', if possible.\n+\t\t// The current max version is 3.1. \n+\t\t// If the version is >= 16.0, it's probably not real.\n+\t\t// Similarly, a clientHello message encodes in\n+\t\t// well under a kilobyte.  If the length is >= 12 kB,\n+\t\t// it's probably not real.\n+\t\tif (typ != recordTypeAlert && typ != want) || vers >= 0x1000 || n >= 0x3000 {\n+\t\t\treturn c.sendAlert(alertUnexpectedMessage)\n+\t\t}\n+\t}\n \tif err := b.readFromUntil(c.conn, recordHeaderLen+n); err != nil {\n \t\tif err == os.EOF {\n \t\t\terr = io.ErrUnexpectedEOF\n@@ -627,7 +658,9 @@ func (c *Conn) readHandshake() (interface{}, os.Error) {\n \t\tif c.err != nil {\n \t\t\treturn nil, c.err\n \t\t}\n-\t\tc.readRecord(recordTypeHandshake)\n+\t\tif err := c.readRecord(recordTypeHandshake); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n \n \tdata := c.hand.Bytes()\n@@ -640,7 +673,9 @@ func (c *Conn) readHandshake() (interface{}, os.Error) {\n \t\tif c.err != nil {\n \t\t\treturn nil, c.err\n \t\t}\n-\t\tc.readRecord(recordTypeHandshake)\n+\t\tif err := c.readRecord(recordTypeHandshake); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n \tdata = c.hand.Next(4 + n)\n \tvar m handshakeMessage\n@@ -731,10 +766,18 @@ func (c *Conn) Read(b []byte) (n int, err os.Error) {\n \n // Close closes the connection.\n func (c *Conn) Close() os.Error {\n-\tif err := c.Handshake(); err != nil {\n+\tvar alertErr os.Error\n+\n+\tc.handshakeMutex.Lock()\n+\tdefer c.handshakeMutex.Unlock()\n+\tif c.handshakeComplete {\n+\t\talertErr = c.sendAlert(alertCloseNotify)\n+\t}\n+\n+\tif err := c.conn.Close(); err != nil {\n \t\treturn err\n \t}\n-\treturn c.sendAlert(alertCloseNotify)\n+\treturn alertErr\n }\n \n // Handshake runs the client or server handshake\n@@ -769,6 +812,7 @@ func (c *Conn) ConnectionState() ConnectionState {\n \t\tstate.CipherSuite = c.cipherSuite\n \t\tstate.PeerCertificates = c.peerCertificates\n \t\tstate.VerifiedChains = c.verifiedChains\n+\t\tstate.ServerName = c.serverName\n \t}\n \n \treturn state"}, {"sha": "5c555147ca893fb043613ccf9532f7819f964750", "filename": "libgo/go/crypto/tls/conn_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -50,3 +50,57 @@ func TestRemovePadding(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var certExampleCom = `308201403081eda003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313138353835325a170d3132303933303138353835325a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31a301830160603551d11040f300d820b6578616d706c652e636f6d300b06092a864886f70d0101050341001a0b419d2c74474c6450654e5f10b32bf426ffdf55cad1c52602e7a9151513a3424c70f5960dcd682db0c33769cc1daa3fcdd3db10809d2392ed4a1bf50ced18`\n+\n+var certWildcardExampleCom = `308201423081efa003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313139303034365a170d3132303933303139303034365a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31c301a30180603551d110411300f820d2a2e6578616d706c652e636f6d300b06092a864886f70d0101050341001676f0c9e7c33c1b656ed5a6476c4e2ee9ec8e62df7407accb1875272b2edd0a22096cb2c22598d11604104d604f810eb4b5987ca6bb319c7e6ce48725c54059`\n+\n+var certFooExampleCom = `308201443081f1a003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313139303131345a170d3132303933303139303131345a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31e301c301a0603551d1104133011820f666f6f2e6578616d706c652e636f6d300b06092a864886f70d010105034100646a2a51f2aa2477add854b462cf5207ba16d3213ffb5d3d0eed473fbf09935019192d1d5b8ca6a2407b424cf04d97c4cd9197c83ecf81f0eab9464a1109d09f`\n+\n+var certDoubleWildcardExampleCom = `308201443081f1a003020102020101300b06092a864886f70d010105301e311c301a060355040a131354657374696e67204365727469666963617465301e170d3131313030313139303134315a170d3132303933303139303134315a301e311c301a060355040a131354657374696e67204365727469666963617465305a300b06092a864886f70d010101034b003048024100bced6e32368599eeddf18796bfd03958a154f87e5b084f96e85136a56b886733592f493f0fc68b0d6b3551781cb95e13c5de458b28d6fb60d20a9129313261410203010001a31e301c301a0603551d1104133011820f2a2e2a2e6578616d706c652e636f6d300b06092a864886f70d0101050341001c3de267975f56ef57771c6218ef95ecc65102e57bd1defe6f7efea90d9b26cf40de5bd7ad75e46201c7f2a92aaa3e907451e9409f65e28ddb6db80d726290f6`\n+\n+func TestCertificateSelection(t *testing.T) {\n+\tconfig := Config{\n+\t\tCertificates: []Certificate{\n+\t\t\t{\n+\t\t\t\tCertificate: [][]byte{fromHex(certExampleCom)},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tCertificate: [][]byte{fromHex(certWildcardExampleCom)},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tCertificate: [][]byte{fromHex(certFooExampleCom)},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tCertificate: [][]byte{fromHex(certDoubleWildcardExampleCom)},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tconfig.BuildNameToCertificate()\n+\n+\tpointerToIndex := func(c *Certificate) int {\n+\t\tfor i := range config.Certificates {\n+\t\t\tif c == &config.Certificates[i] {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\n+\tif n := pointerToIndex(config.getCertificateForName(\"example.com\")); n != 0 {\n+\t\tt.Errorf(\"example.com returned certificate %d, not 0\", n)\n+\t}\n+\tif n := pointerToIndex(config.getCertificateForName(\"bar.example.com\")); n != 1 {\n+\t\tt.Errorf(\"bar.example.com returned certificate %d, not 1\", n)\n+\t}\n+\tif n := pointerToIndex(config.getCertificateForName(\"foo.example.com\")); n != 2 {\n+\t\tt.Errorf(\"foo.example.com returned certificate %d, not 2\", n)\n+\t}\n+\tif n := pointerToIndex(config.getCertificateForName(\"foo.bar.example.com\")); n != 3 {\n+\t\tt.Errorf(\"foo.bar.example.com returned certificate %d, not 3\", n)\n+\t}\n+\tif n := pointerToIndex(config.getCertificateForName(\"foo.bar.baz.example.com\")); n != 0 {\n+\t\tt.Errorf(\"foo.bar.baz.example.com returned certificate %d, not 0\", n)\n+\t}\n+}"}, {"sha": "575a121f391ed60e16a35f6ce90dc5e8a422fb1c", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -14,7 +14,7 @@ import (\n )\n \n func (c *Conn) clientHandshake() os.Error {\n-\tfinishedHash := newFinishedHash()\n+\tfinishedHash := newFinishedHash(versionTLS10)\n \n \tif c.config == nil {\n \t\tc.config = defaultConfig()\n@@ -97,11 +97,9 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tcerts[i] = cert\n \t}\n \n-\t// If we don't have a root CA set configured then anything is accepted.\n-\t// TODO(rsc): Find certificates for OS X 10.6.\n-\tif c.config.RootCAs != nil {\n+\tif !c.config.InsecureSkipVerify {\n \t\topts := x509.VerifyOptions{\n-\t\t\tRoots:         c.config.RootCAs,\n+\t\t\tRoots:         c.config.rootCAs(),\n \t\t\tCurrentTime:   c.config.time(),\n \t\t\tDNSName:       c.config.ServerName,\n \t\t\tIntermediates: x509.NewCertPool(),\n@@ -247,11 +245,11 @@ func (c *Conn) clientHandshake() os.Error {\n \t}\n \n \tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n-\t\tkeysFromPreMasterSecret10(preMasterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n+\t\tkeysFromPreMasterSecret(c.vers, preMasterSecret, hello.random, serverHello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n \tclientCipher := suite.cipher(clientKey, clientIV, false /* not for reading */ )\n-\tclientHash := suite.mac(clientMAC)\n-\tc.out.prepareCipherSpec(clientCipher, clientHash)\n+\tclientHash := suite.mac(c.vers, clientMAC)\n+\tc.out.prepareCipherSpec(c.vers, clientCipher, clientHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n \tif serverHello.nextProtoNeg {\n@@ -271,8 +269,8 @@ func (c *Conn) clientHandshake() os.Error {\n \tc.writeRecord(recordTypeHandshake, finished.marshal())\n \n \tserverCipher := suite.cipher(serverKey, serverIV, true /* for reading */ )\n-\tserverHash := suite.mac(serverMAC)\n-\tc.in.prepareCipherSpec(serverCipher, serverHash)\n+\tserverHash := suite.mac(c.vers, serverMAC)\n+\tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n \tif c.err != nil {\n \t\treturn c.err"}, {"sha": "c0abcda200155dafc130781d575fb2d2ce79e182", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -18,6 +18,7 @@ func testClientScript(t *testing.T, name string, clientScript [][]byte, config *\n \tgo func() {\n \t\tcli.Write([]byte(\"hello\\n\"))\n \t\tcli.Close()\n+\t\tc.Close()\n \t}()\n \n \tdefer c.Close()"}, {"sha": "f11232d8ee57ef268bb96df0cac7c6cfe986f20d", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -676,17 +676,17 @@ func (m *finishedMsg) marshal() (x []byte) {\n \t\treturn m.raw\n \t}\n \n-\tx = make([]byte, 16)\n+\tx = make([]byte, 4+len(m.verifyData))\n \tx[0] = typeFinished\n-\tx[3] = 12\n+\tx[3] = byte(len(m.verifyData))\n \tcopy(x[4:], m.verifyData)\n \tm.raw = x\n \treturn\n }\n \n func (m *finishedMsg) unmarshal(data []byte) bool {\n \tm.raw = data\n-\tif len(data) != 4+12 {\n+\tif len(data) < 4 {\n \t\treturn false\n \t}\n \tm.verifyData = data[4:]"}, {"sha": "dc68a12239a4eb849213c3f9ba9794d3eb609ceb", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -14,13 +14,13 @@ import (\n var tests = []interface{}{\n \t&clientHelloMsg{},\n \t&serverHelloMsg{},\n+\t&finishedMsg{},\n \n \t&certificateMsg{},\n \t&certificateRequestMsg{},\n \t&certificateVerifyMsg{},\n \t&certificateStatusMsg{},\n \t&clientKeyExchangeMsg{},\n-\t&finishedMsg{},\n \t&nextProtoMsg{},\n }\n \n@@ -59,11 +59,12 @@ func TestMarshalUnmarshal(t *testing.T) {\n \t\t\t\tbreak\n \t\t\t}\n \n-\t\t\tif i >= 2 {\n-\t\t\t\t// The first two message types (ClientHello and\n-\t\t\t\t// ServerHello) are allowed to have parsable\n-\t\t\t\t// prefixes because the extension data is\n-\t\t\t\t// optional.\n+\t\t\tif i >= 3 {\n+\t\t\t\t// The first three message types (ClientHello,\n+\t\t\t\t// ServerHello and Finished) are allowed to\n+\t\t\t\t// have parsable prefixes because the extension\n+\t\t\t\t// data is optional and the length of the\n+\t\t\t\t// Finished varies across versions.\n \t\t\t\tfor j := 0; j < len(marshaled); j++ {\n \t\t\t\t\tif m2.unmarshal(marshaled[0:j]) {\n \t\t\t\t\t\tt.Errorf(\"#%d unmarshaled a prefix of length %d of %#v\", i, j, m1)"}, {"sha": "ed9a2e6a512ac189d728a17dd47ad07461ccdbe4", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -30,7 +30,7 @@ func (c *Conn) serverHandshake() os.Error {\n \tc.vers = vers\n \tc.haveVers = true\n \n-\tfinishedHash := newFinishedHash()\n+\tfinishedHash := newFinishedHash(vers)\n \tfinishedHash.Write(clientHello.marshal())\n \n \thello := new(serverHelloMsg)\n@@ -115,7 +115,12 @@ FindCipherSuite:\n \t}\n \n \tcertMsg := new(certificateMsg)\n-\tcertMsg.certificates = config.Certificates[0].Certificate\n+\tif len(clientHello.serverName) > 0 {\n+\t\tc.serverName = clientHello.serverName\n+\t\tcertMsg.certificates = config.getCertificateForName(clientHello.serverName).Certificate\n+\t} else {\n+\t\tcertMsg.certificates = config.Certificates[0].Certificate\n+\t}\n \tfinishedHash.Write(certMsg.marshal())\n \tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \n@@ -128,7 +133,6 @@ FindCipherSuite:\n \t}\n \n \tkeyAgreement := suite.ka()\n-\n \tskx, err := keyAgreement.generateServerKeyExchange(config, clientHello, hello)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n@@ -235,18 +239,18 @@ FindCipherSuite:\n \t\tfinishedHash.Write(certVerify.marshal())\n \t}\n \n-\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, ckx)\n+\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(config, ckx, c.vers)\n \tif err != nil {\n \t\tc.sendAlert(alertHandshakeFailure)\n \t\treturn err\n \t}\n \n \tmasterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n-\t\tkeysFromPreMasterSecret10(preMasterSecret, clientHello.random, hello.random, suite.macLen, suite.keyLen, suite.ivLen)\n+\t\tkeysFromPreMasterSecret(c.vers, preMasterSecret, clientHello.random, hello.random, suite.macLen, suite.keyLen, suite.ivLen)\n \n \tclientCipher := suite.cipher(clientKey, clientIV, true /* for reading */ )\n-\tclientHash := suite.mac(clientMAC)\n-\tc.in.prepareCipherSpec(clientCipher, clientHash)\n+\tclientHash := suite.mac(c.vers, clientMAC)\n+\tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n \tc.readRecord(recordTypeChangeCipherSpec)\n \tif err := c.error(); err != nil {\n \t\treturn err\n@@ -283,8 +287,8 @@ FindCipherSuite:\n \tfinishedHash.Write(clientFinished.marshal())\n \n \tserverCipher := suite.cipher(serverKey, serverIV, false /* not for reading */ )\n-\tserverHash := suite.mac(serverMAC)\n-\tc.out.prepareCipherSpec(serverCipher, serverHash)\n+\tserverHash := suite.mac(c.vers, serverMAC)\n+\tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n \tc.writeRecord(recordTypeChangeCipherSpec, []byte{1})\n \n \tfinished := new(finishedMsg)"}, {"sha": "1939f3dba36f154c52acad9f8e72e7cbba0edc60", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 366, "deletions": 3, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -13,6 +13,8 @@ import (\n \t\"io\"\n \t\"net\"\n \t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -36,6 +38,7 @@ func init() {\n \ttestConfig.Certificates[0].Certificate = [][]byte{testCertificate}\n \ttestConfig.Certificates[0].PrivateKey = testPrivateKey\n \ttestConfig.CipherSuites = []uint16{TLS_RSA_WITH_RC4_128_SHA}\n+\ttestConfig.InsecureSkipVerify = true\n }\n \n func testClientHelloFailure(t *testing.T, m handshakeMessage, expected os.Error) {\n@@ -62,7 +65,7 @@ func TestSimpleError(t *testing.T) {\n \ttestClientHelloFailure(t, &serverHelloDoneMsg{}, alertUnexpectedMessage)\n }\n \n-var badProtocolVersions = []uint16{0x0000, 0x0005, 0x0100, 0x0105, 0x0200, 0x0205, 0x0300}\n+var badProtocolVersions = []uint16{0x0000, 0x0005, 0x0100, 0x0105, 0x0200, 0x0205}\n \n func TestRejectBadProtocolVersion(t *testing.T) {\n \tfor _, v := range badProtocolVersions {\n@@ -112,6 +115,7 @@ func testServerScript(t *testing.T, name string, serverScript [][]byte, config *\n \tgo func() {\n \t\tsrv.Write([]byte(\"hello, world\\n\"))\n \t\tsrv.Close()\n+\t\ts.Close()\n \t}()\n \n \tdefer c.Close()\n@@ -121,9 +125,9 @@ func testServerScript(t *testing.T, name string, serverScript [][]byte, config *\n \t\t\tcontinue\n \t\t}\n \t\tbb := make([]byte, len(b))\n-\t\t_, err := io.ReadFull(c, bb)\n+\t\tn, err := io.ReadFull(c, bb)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s #%d: %s\", name, i, err)\n+\t\t\tt.Fatalf(\"%s #%d: %s\\nRead %d, wanted %d, got %x, wanted %x\\n\", name, i, err, n, len(bb), bb[:n], b)\n \t\t}\n \t\tif !bytes.Equal(b, bb) {\n \t\t\tt.Fatalf(\"%s #%d: mismatch on read: got:%x want:%x\", name, i, bb, b)\n@@ -135,20 +139,44 @@ func TestHandshakeServerRC4(t *testing.T) {\n \ttestServerScript(t, \"RC4\", rc4ServerScript, testConfig)\n }\n \n+func TestHandshakeServer3DES(t *testing.T) {\n+\tdes3Config := new(Config)\n+\t*des3Config = *testConfig\n+\tdes3Config.CipherSuites = []uint16{TLS_RSA_WITH_3DES_EDE_CBC_SHA}\n+\ttestServerScript(t, \"3DES\", des3ServerScript, des3Config)\n+}\n+\n func TestHandshakeServerAES(t *testing.T) {\n \taesConfig := new(Config)\n \t*aesConfig = *testConfig\n \taesConfig.CipherSuites = []uint16{TLS_RSA_WITH_AES_128_CBC_SHA}\n \ttestServerScript(t, \"AES\", aesServerScript, aesConfig)\n }\n \n+func TestHandshakeServerSSLv3(t *testing.T) {\n+\ttestServerScript(t, \"SSLv3\", sslv3ServerScript, testConfig)\n+}\n+\n var serve = flag.Bool(\"serve\", false, \"run a TLS server on :10443\")\n+var testCipherSuites = flag.String(\"ciphersuites\",\n+\t\"0x\"+strconv.Itob(int(TLS_RSA_WITH_RC4_128_SHA), 16),\n+\t\"cipher suites to accept in serving mode\")\n \n func TestRunServer(t *testing.T) {\n \tif !*serve {\n \t\treturn\n \t}\n \n+\tsuites := strings.Split(*testCipherSuites, \",\")\n+\ttestConfig.CipherSuites = make([]uint16, len(suites))\n+\tfor i := range suites {\n+\t\tsuite, err := strconv.Btoui64(suites[i], 0)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\ttestConfig.CipherSuites[i] = uint16(suite)\n+\t}\n+\n \tl, err := Listen(\"tcp\", \":10443\", testConfig)\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -356,6 +384,179 @@ var rc4ServerScript = [][]byte{\n \t},\n }\n \n+var des3ServerScript = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n+\t\t0x76, 0x03, 0x02, 0x4e, 0x84, 0xf4, 0x3c, 0xe4,\n+\t\t0xb8, 0xc7, 0xa0, 0x30, 0x55, 0x2a, 0xbc, 0xb7,\n+\t\t0x04, 0x6b, 0x6f, 0x87, 0x93, 0x96, 0xbd, 0x1a,\n+\t\t0x7a, 0x1e, 0xce, 0xd2, 0x0d, 0xf3, 0x01, 0x03,\n+\t\t0xbe, 0x7b, 0x17, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n+\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n+\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n+\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n+\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n+\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n+\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n+\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n+\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t},\n+\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x16,\n+\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n+\t\t0x00, 0x00, 0x00,\n+\t},\n+\n+\t{\n+\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t0x82, 0x00, 0x80, 0xae, 0xcf, 0x4f, 0x70, 0x0e,\n+\t\t0xe5, 0xe7, 0xba, 0xef, 0x0c, 0x66, 0xe9, 0xae,\n+\t\t0x76, 0xf4, 0xe0, 0xbc, 0x1c, 0x22, 0x5b, 0x72,\n+\t\t0xc9, 0x68, 0x63, 0x44, 0xec, 0x72, 0xc2, 0xca,\n+\t\t0xac, 0xc2, 0xf5, 0x5c, 0x28, 0xa1, 0xaf, 0xd0,\n+\t\t0xc2, 0xf7, 0x79, 0x71, 0x32, 0x73, 0x86, 0xea,\n+\t\t0x39, 0xf6, 0x04, 0x26, 0x19, 0x84, 0x1d, 0x7d,\n+\t\t0xa1, 0x21, 0xa6, 0x88, 0xbf, 0x33, 0x5a, 0x64,\n+\t\t0xb0, 0xc2, 0xcc, 0x19, 0x7a, 0x8b, 0x6e, 0x94,\n+\t\t0x9e, 0x2e, 0x20, 0xbe, 0xdc, 0xe9, 0x8e, 0xae,\n+\t\t0x5c, 0x39, 0xc8, 0xcd, 0x0e, 0x19, 0x9a, 0xa2,\n+\t\t0xfc, 0x3f, 0x61, 0x9a, 0xca, 0x58, 0x69, 0x0d,\n+\t\t0xa8, 0x7b, 0xbe, 0x98, 0x8f, 0xb9, 0x9d, 0x8b,\n+\t\t0x68, 0x65, 0xa9, 0x74, 0xcc, 0x8d, 0x0c, 0xb2,\n+\t\t0xc4, 0x0f, 0xdc, 0x56, 0x3e, 0x44, 0x61, 0x0a,\n+\t\t0x26, 0x93, 0x99, 0xef, 0x67, 0xff, 0x6e, 0x73,\n+\t\t0x01, 0xa1, 0x90, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x60, 0x49, 0x36,\n+\t\t0xc8, 0x38, 0x95, 0xe4, 0x5d, 0x8e, 0x80, 0x10,\n+\t\t0x26, 0x9f, 0x87, 0x7d, 0xcd, 0xb9, 0x32, 0x6c,\n+\t\t0xff, 0xaa, 0xe0, 0x07, 0xec, 0x33, 0xe2, 0x36,\n+\t\t0x9d, 0xd5, 0x83, 0x2c, 0xf0, 0x0a, 0xa0, 0xa8,\n+\t\t0x12, 0x9f, 0xca, 0x72, 0xda, 0x70, 0x7d, 0x76,\n+\t\t0x80, 0x12, 0x88, 0x07, 0xaa, 0x27, 0x62, 0x33,\n+\t\t0xab, 0x55, 0xad, 0x3c, 0x2b, 0x54, 0xc4, 0x1c,\n+\t\t0x91, 0xfd, 0x8f, 0x9c, 0xa7, 0x8b, 0x75, 0x10,\n+\t\t0xa8, 0x6e, 0xfc, 0x30, 0x52, 0x8a, 0x61, 0x02,\n+\t\t0xdb, 0x9c, 0x6f, 0xc8, 0x19, 0x93, 0x5d, 0x41,\n+\t\t0x1d, 0x36, 0x68, 0x0b, 0xec, 0x30, 0xae, 0xfb,\n+\t\t0x90, 0xdb, 0x6d, 0x83, 0xb0, 0xf2,\n+\t},\n+\n+\t{\n+\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x01, 0x00, 0x28, 0x07, 0xf3, 0x33, 0x84, 0xb1,\n+\t\t0x5d, 0x2b, 0x52, 0xa4, 0x63, 0x3c, 0x32, 0xe0,\n+\t\t0x0d, 0x22, 0xf5, 0x23, 0xec, 0xf9, 0xa6, 0xec,\n+\t\t0xc0, 0x12, 0x69, 0x88, 0xf6, 0x7d, 0x37, 0xcd,\n+\t\t0xc2, 0x74, 0x2f, 0xef, 0xf6, 0x49, 0x15, 0xea,\n+\t\t0x88, 0x3f, 0x55, 0x17, 0x03, 0x01, 0x00, 0x28,\n+\t\t0xaf, 0x00, 0x84, 0xff, 0x11, 0x01, 0x6d, 0xba,\n+\t\t0x39, 0x5e, 0x45, 0xe1, 0x52, 0x5e, 0xc1, 0xab,\n+\t\t0xde, 0x5b, 0x16, 0xdd, 0xd6, 0x61, 0x57, 0xb8,\n+\t\t0x66, 0x8b, 0x2d, 0xde, 0x51, 0x41, 0xc5, 0x09,\n+\t\t0xb3, 0x6a, 0x06, 0x43, 0xb4, 0x73, 0x5c, 0xf1,\n+\t\t0x15, 0x03, 0x01, 0x00, 0x18, 0xbd, 0x65, 0xb2,\n+\t\t0xce, 0x77, 0x2e, 0xf9, 0x11, 0xc4, 0x80, 0x43,\n+\t\t0x5a, 0x73, 0x8b, 0x73, 0xdd, 0xf0, 0x54, 0x44,\n+\t\t0x7c, 0x56, 0x19, 0x54, 0xda,\n+\t},\n+}\n+\n var aesServerScript = [][]byte{\n \t{\n \t\t0x16, 0x03, 0x02, 0x00, 0x7f, 0x01, 0x00, 0x00,\n@@ -515,3 +716,165 @@ var aesServerScript = [][]byte{\n \t\t0xcd, 0x84, 0xf0,\n \t},\n }\n+\n+var sslv3ServerScript = [][]byte{\n+\t{\n+\t\t0x16, 0x03, 0x00, 0x00, 0x41, 0x01, 0x00, 0x00,\n+\t\t0x3d, 0x03, 0x00, 0x4e, 0x70, 0xe2, 0x18, 0x86,\n+\t\t0xd6, 0xc6, 0x6f, 0xf3, 0xc8, 0xf4, 0x02, 0xd6,\n+\t\t0x4d, 0xee, 0x17, 0x32, 0x4b, 0xd2, 0x78, 0xd8,\n+\t\t0xa1, 0x03, 0x5d, 0x68, 0x82, 0x89, 0xbe, 0xfd,\n+\t\t0x12, 0xb9, 0x06, 0x00, 0x00, 0x16, 0x00, 0x33,\n+\t\t0x00, 0x39, 0x00, 0x16, 0x00, 0x32, 0x00, 0x38,\n+\t\t0x00, 0x13, 0x00, 0x2f, 0x00, 0x35, 0x00, 0x0a,\n+\t\t0x00, 0x05, 0x00, 0x04, 0x01, 0x00,\n+\t},\n+\n+\t{\n+\t\t0x16, 0x03, 0x00, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t0x26, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t0x03, 0x00, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t0xbd, 0xd9, 0x16, 0x03, 0x00, 0x00, 0x04, 0x0e,\n+\t\t0x00, 0x00, 0x00,\n+\t},\n+\n+\t{\n+\t\t0x16, 0x03, 0x00, 0x00, 0x84, 0x10, 0x00, 0x00,\n+\t\t0x80, 0x74, 0x0e, 0x3a, 0xcf, 0xba, 0x9f, 0x1a,\n+\t\t0x9b, 0xb2, 0xa4, 0xc7, 0x5d, 0xf3, 0x0c, 0x80,\n+\t\t0x06, 0x80, 0xf3, 0x57, 0xb2, 0xd9, 0x36, 0x24,\n+\t\t0x6a, 0x06, 0x13, 0x40, 0xf9, 0x7c, 0xb9, 0x3e,\n+\t\t0x4b, 0x68, 0x4f, 0x21, 0x90, 0x2d, 0xbd, 0xca,\n+\t\t0xd4, 0x83, 0xf0, 0x7a, 0xeb, 0x7a, 0x74, 0x1b,\n+\t\t0xcd, 0xfe, 0x69, 0xef, 0xc0, 0x86, 0xa0, 0x24,\n+\t\t0x31, 0x65, 0x40, 0xd2, 0xdd, 0x6f, 0xb9, 0xd7,\n+\t\t0x8d, 0xc1, 0x69, 0x60, 0x44, 0x7a, 0x75, 0xfb,\n+\t\t0x42, 0x6a, 0x0f, 0x66, 0x45, 0x10, 0x73, 0xee,\n+\t\t0x87, 0x28, 0x37, 0x83, 0x86, 0xd8, 0x5a, 0xc8,\n+\t\t0x60, 0x87, 0xda, 0x33, 0x87, 0xaf, 0x34, 0x8b,\n+\t\t0xf5, 0x61, 0x63, 0x7a, 0x5c, 0x60, 0x26, 0xb9,\n+\t\t0xdb, 0xa1, 0xb7, 0xe3, 0x60, 0x38, 0x94, 0x5c,\n+\t\t0x83, 0x23, 0xd6, 0x8d, 0xc2, 0x14, 0x4a, 0x0f,\n+\t\t0x0e, 0x4f, 0xf9, 0x4e, 0x7b, 0x15, 0xcd, 0x18,\n+\t\t0x04, 0x14, 0x03, 0x00, 0x00, 0x01, 0x01, 0x16,\n+\t\t0x03, 0x00, 0x00, 0x3c, 0xbd, 0xbc, 0xec, 0xdc,\n+\t\t0x79, 0xb1, 0xae, 0x16, 0xc9, 0x26, 0x9a, 0xc0,\n+\t\t0xc0, 0x2c, 0x33, 0x36, 0x13, 0x91, 0x58, 0x5d,\n+\t\t0x7d, 0xee, 0x4e, 0xd8, 0x7e, 0xac, 0x88, 0x87,\n+\t\t0x0a, 0x75, 0x66, 0xb1, 0x44, 0x79, 0x2f, 0x42,\n+\t\t0xe8, 0x92, 0x74, 0x4c, 0xab, 0x36, 0xc8, 0x17,\n+\t\t0x5f, 0x02, 0x8a, 0x20, 0x53, 0xe9, 0x1d, 0xb4,\n+\t\t0xfe, 0x5c, 0x2b, 0xd9, 0x0a, 0xfb, 0xc6, 0x63,\n+\t},\n+\n+\t{\n+\t\t0x14, 0x03, 0x00, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t0x00, 0x00, 0x3c, 0xaa, 0xa1, 0x98, 0xc4, 0x6b,\n+\t\t0x5a, 0x16, 0x3f, 0x5f, 0xa4, 0x96, 0x3e, 0x78,\n+\t\t0xe4, 0x6f, 0x49, 0x05, 0x47, 0xc4, 0x05, 0x60,\n+\t\t0xeb, 0x0b, 0x45, 0xe3, 0xbc, 0x50, 0x11, 0x24,\n+\t\t0x5f, 0x01, 0xd7, 0xb8, 0x8f, 0x60, 0x63, 0x66,\n+\t\t0xbd, 0x3e, 0xd9, 0xa8, 0x80, 0x43, 0x9f, 0x0b,\n+\t\t0x51, 0x61, 0xed, 0x13, 0xc6, 0x21, 0xd0, 0xfe,\n+\t\t0xbc, 0x17, 0x3c, 0x36, 0xb0, 0x82, 0x7f, 0x17,\n+\t\t0x03, 0x00, 0x00, 0x21, 0xee, 0x44, 0xf3, 0xa6,\n+\t\t0x88, 0x9d, 0x78, 0x44, 0xde, 0xdf, 0xeb, 0xc5,\n+\t\t0xad, 0xc4, 0xcc, 0x56, 0x5c, 0x54, 0x96, 0x52,\n+\t\t0x3f, 0xd9, 0x40, 0x6e, 0x79, 0xd8, 0x58, 0x78,\n+\t\t0x4f, 0x5a, 0xe9, 0x06, 0xef, 0x15, 0x03, 0x00,\n+\t\t0x00, 0x16, 0xd3, 0xc2, 0x52, 0x99, 0x2a, 0x84,\n+\t\t0xc4, 0x52, 0x5f, 0x3b, 0x19, 0xe7, 0xfc, 0x65,\n+\t\t0xaf, 0xd3, 0xb7, 0xa3, 0xcc, 0x4a, 0x1d, 0x2e,\n+\t},\n+}"}, {"sha": "e347528b581c58d2118c5e290d82899f8e2afab5", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -24,7 +24,7 @@ func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, clientHello\n \treturn nil, nil\n }\n \n-func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg) ([]byte, os.Error) {\n+func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg, version uint16) ([]byte, os.Error) {\n \tpreMasterSecret := make([]byte, 48)\n \t_, err := io.ReadFull(config.rand(), preMasterSecret[2:])\n \tif err != nil {\n@@ -34,11 +34,15 @@ func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKe\n \tif len(ckx.ciphertext) < 2 {\n \t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n \t}\n-\tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n-\tif ciphertextLen != len(ckx.ciphertext)-2 {\n-\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n+\n+\tciphertext := ckx.ciphertext\n+\tif version != versionSSL30 {\n+\t\tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n+\t\tif ciphertextLen != len(ckx.ciphertext)-2 {\n+\t\t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n+\t\t}\n+\t\tciphertext = ckx.ciphertext[2:]\n \t}\n-\tciphertext := ckx.ciphertext[2:]\n \n \terr = rsa.DecryptPKCS1v15SessionKey(config.rand(), config.Certificates[0].PrivateKey, ciphertext, preMasterSecret)\n \tif err != nil {\n@@ -159,7 +163,7 @@ Curve:\n \treturn skx, nil\n }\n \n-func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg) ([]byte, os.Error) {\n+func (ka *ecdheRSAKeyAgreement) processClientKeyExchange(config *Config, ckx *clientKeyExchangeMsg, version uint16) ([]byte, os.Error) {\n \tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n \t\treturn nil, os.NewError(\"bad ClientKeyExchange\")\n \t}"}, {"sha": "2d58dc520dcf79788e3a464ddc75f205b3b48e10", "filename": "libgo/go/crypto/tls/prf.go", "status": "modified", "additions": 95, "deletions": 12, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -63,6 +63,39 @@ func pRF10(result, secret, label, seed []byte) {\n \t}\n }\n \n+// pRF30 implements the SSL 3.0 pseudo-random function, as defined in\n+// www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt section 6.\n+func pRF30(result, secret, label, seed []byte) {\n+\thashSHA1 := sha1.New()\n+\thashMD5 := md5.New()\n+\n+\tdone := 0\n+\ti := 0\n+\t// RFC5246 section 6.3 says that the largest PRF output needed is 128\n+\t// bytes. Since no more ciphersuites will be added to SSLv3, this will\n+\t// remain true. Each iteration gives us 16 bytes so 10 iterations will\n+\t// be sufficient.\n+\tvar b [11]byte\n+\tfor done < len(result) {\n+\t\tfor j := 0; j <= i; j++ {\n+\t\t\tb[j] = 'A' + byte(i)\n+\t\t}\n+\n+\t\thashSHA1.Reset()\n+\t\thashSHA1.Write(b[:i+1])\n+\t\thashSHA1.Write(secret)\n+\t\thashSHA1.Write(seed)\n+\t\tdigest := hashSHA1.Sum()\n+\n+\t\thashMD5.Reset()\n+\t\thashMD5.Write(secret)\n+\t\thashMD5.Write(digest)\n+\n+\t\tdone += copy(result[done:], hashMD5.Sum())\n+\t\ti++\n+\t}\n+}\n+\n const (\n \ttlsRandomLength      = 32 // Length of a random nonce in TLS 1.1.\n \tmasterSecretLength   = 48 // Length of a master secret in TLS 1.1.\n@@ -77,19 +110,24 @@ var serverFinishedLabel = []byte(\"server finished\")\n // keysFromPreMasterSecret generates the connection keys from the pre master\n // secret, given the lengths of the MAC key, cipher key and IV, as defined in\n // RFC 2246, section 6.3.\n-func keysFromPreMasterSecret10(preMasterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (masterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n+func keysFromPreMasterSecret(version uint16, preMasterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (masterSecret, clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n+\tprf := pRF10\n+\tif version == versionSSL30 {\n+\t\tprf = pRF30\n+\t}\n+\n \tvar seed [tlsRandomLength * 2]byte\n \tcopy(seed[0:len(clientRandom)], clientRandom)\n \tcopy(seed[len(clientRandom):], serverRandom)\n \tmasterSecret = make([]byte, masterSecretLength)\n-\tpRF10(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n+\tprf(masterSecret, preMasterSecret, masterSecretLabel, seed[0:])\n \n \tcopy(seed[0:len(clientRandom)], serverRandom)\n \tcopy(seed[len(serverRandom):], clientRandom)\n \n \tn := 2*macLen + 2*keyLen + 2*ivLen\n \tkeyMaterial := make([]byte, n)\n-\tpRF10(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])\n+\tprf(keyMaterial, masterSecret, keyExpansionLabel, seed[0:])\n \tclientMAC = keyMaterial[:macLen]\n \tkeyMaterial = keyMaterial[macLen:]\n \tserverMAC = keyMaterial[:macLen]\n@@ -104,17 +142,18 @@ func keysFromPreMasterSecret10(preMasterSecret, clientRandom, serverRandom []byt\n \treturn\n }\n \n+func newFinishedHash(version uint16) finishedHash {\n+\treturn finishedHash{md5.New(), sha1.New(), md5.New(), sha1.New(), version}\n+}\n+\n // A finishedHash calculates the hash of a set of handshake messages suitable\n // for including in a Finished message.\n type finishedHash struct {\n \tclientMD5  hash.Hash\n \tclientSHA1 hash.Hash\n \tserverMD5  hash.Hash\n \tserverSHA1 hash.Hash\n-}\n-\n-func newFinishedHash() finishedHash {\n-\treturn finishedHash{md5.New(), sha1.New(), md5.New(), sha1.New()}\n+\tversion    uint16\n }\n \n func (h finishedHash) Write(msg []byte) (n int, err os.Error) {\n@@ -125,9 +164,10 @@ func (h finishedHash) Write(msg []byte) (n int, err os.Error) {\n \treturn len(msg), nil\n }\n \n-// finishedSum calculates the contents of the verify_data member of a Finished\n-// message given the MD5 and SHA1 hashes of a set of handshake messages.\n-func finishedSum(md5, sha1, label, masterSecret []byte) []byte {\n+// finishedSum10 calculates the contents of the verify_data member of a TLSv1\n+// Finished message given the MD5 and SHA1 hashes of a set of handshake\n+// messages.\n+func finishedSum10(md5, sha1, label, masterSecret []byte) []byte {\n \tseed := make([]byte, len(md5)+len(sha1))\n \tcopy(seed, md5)\n \tcopy(seed[len(md5):], sha1)\n@@ -136,18 +176,61 @@ func finishedSum(md5, sha1, label, masterSecret []byte) []byte {\n \treturn out\n }\n \n+// finishedSum30 calculates the contents of the verify_data member of a SSLv3\n+// Finished message given the MD5 and SHA1 hashes of a set of handshake\n+// messages.\n+func finishedSum30(md5, sha1 hash.Hash, masterSecret []byte, magic [4]byte) []byte {\n+\tmd5.Write(magic[:])\n+\tmd5.Write(masterSecret)\n+\tmd5.Write(ssl30Pad1[:])\n+\tmd5Digest := md5.Sum()\n+\n+\tmd5.Reset()\n+\tmd5.Write(masterSecret)\n+\tmd5.Write(ssl30Pad2[:])\n+\tmd5.Write(md5Digest)\n+\tmd5Digest = md5.Sum()\n+\n+\tsha1.Write(magic[:])\n+\tsha1.Write(masterSecret)\n+\tsha1.Write(ssl30Pad1[:40])\n+\tsha1Digest := sha1.Sum()\n+\n+\tsha1.Reset()\n+\tsha1.Write(masterSecret)\n+\tsha1.Write(ssl30Pad2[:40])\n+\tsha1.Write(sha1Digest)\n+\tsha1Digest = sha1.Sum()\n+\n+\tret := make([]byte, len(md5Digest)+len(sha1Digest))\n+\tcopy(ret, md5Digest)\n+\tcopy(ret[len(md5Digest):], sha1Digest)\n+\treturn ret\n+}\n+\n+var ssl3ClientFinishedMagic = [4]byte{0x43, 0x4c, 0x4e, 0x54}\n+var ssl3ServerFinishedMagic = [4]byte{0x53, 0x52, 0x56, 0x52}\n+\n // clientSum returns the contents of the verify_data member of a client's\n // Finished message.\n func (h finishedHash) clientSum(masterSecret []byte) []byte {\n+\tif h.version == versionSSL30 {\n+\t\treturn finishedSum30(h.clientMD5, h.clientSHA1, masterSecret, ssl3ClientFinishedMagic)\n+\t}\n+\n \tmd5 := h.clientMD5.Sum()\n \tsha1 := h.clientSHA1.Sum()\n-\treturn finishedSum(md5, sha1, clientFinishedLabel, masterSecret)\n+\treturn finishedSum10(md5, sha1, clientFinishedLabel, masterSecret)\n }\n \n // serverSum returns the contents of the verify_data member of a server's\n // Finished message.\n func (h finishedHash) serverSum(masterSecret []byte) []byte {\n+\tif h.version == versionSSL30 {\n+\t\treturn finishedSum30(h.serverMD5, h.serverSHA1, masterSecret, ssl3ServerFinishedMagic)\n+\t}\n+\n \tmd5 := h.serverMD5.Sum()\n \tsha1 := h.serverSHA1.Sum()\n-\treturn finishedSum(md5, sha1, serverFinishedLabel, masterSecret)\n+\treturn finishedSum10(md5, sha1, serverFinishedLabel, masterSecret)\n }"}, {"sha": "a32392cef799f0f8e4fdc7b611455bdb7c12dace", "filename": "libgo/go/crypto/tls/prf_test.go", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fprf_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -34,6 +34,7 @@ func TestSplitPreMasterSecret(t *testing.T) {\n }\n \n type testKeysFromTest struct {\n+\tversion                    uint16\n \tpreMasterSecret            string\n \tclientRandom, serverRandom string\n \tmasterSecret               string\n@@ -47,7 +48,7 @@ func TestKeysFromPreMasterSecret(t *testing.T) {\n \t\tin, _ := hex.DecodeString(test.preMasterSecret)\n \t\tclientRandom, _ := hex.DecodeString(test.clientRandom)\n \t\tserverRandom, _ := hex.DecodeString(test.serverRandom)\n-\t\tmaster, clientMAC, serverMAC, clientKey, serverKey, _, _ := keysFromPreMasterSecret10(in, clientRandom, serverRandom, test.macLen, test.keyLen, 0)\n+\t\tmaster, clientMAC, serverMAC, clientKey, serverKey, _, _ := keysFromPreMasterSecret(test.version, in, clientRandom, serverRandom, test.macLen, test.keyLen, 0)\n \t\tmasterString := hex.EncodeToString(master)\n \t\tclientMACString := hex.EncodeToString(clientMAC)\n \t\tserverMACString := hex.EncodeToString(serverMAC)\n@@ -58,14 +59,15 @@ func TestKeysFromPreMasterSecret(t *testing.T) {\n \t\t\tserverMACString != test.serverMAC ||\n \t\t\tclientKeyString != test.clientKey ||\n \t\t\tserverKeyString != test.serverKey {\n-\t\t\tt.Errorf(\"#%d: got: (%s, %s, %s, %s, %s) want: (%s, %s, %s, %s %s)\", i, masterString, clientMACString, serverMACString, clientKeyString, serverMACString, test.masterSecret, test.clientMAC, test.serverMAC, test.clientKey, test.serverKey)\n+\t\t\tt.Errorf(\"#%d: got: (%s, %s, %s, %s, %s) want: (%s, %s, %s, %s, %s)\", i, masterString, clientMACString, serverMACString, clientKeyString, serverKeyString, test.masterSecret, test.clientMAC, test.serverMAC, test.clientKey, test.serverKey)\n \t\t}\n \t}\n }\n \n // These test vectors were generated from GnuTLS using `gnutls-cli --insecure -d 9 `\n var testKeysFromTests = []testKeysFromTest{\n \t{\n+\t\tversionTLS10,\n \t\t\"0302cac83ad4b1db3b9ab49ad05957de2a504a634a386fc600889321e1a971f57479466830ac3e6f468e87f5385fa0c5\",\n \t\t\"4ae66303755184a3917fcb44880605fcc53baa01912b22ed94473fc69cebd558\",\n \t\t\"4ae663020ec16e6bb5130be918cfcafd4d765979a3136a5d50c593446e4e44db\",\n@@ -78,6 +80,7 @@ var testKeysFromTests = []testKeysFromTest{\n \t\t16,\n \t},\n \t{\n+\t\tversionTLS10,\n \t\t\"03023f7527316bc12cbcd69e4b9e8275d62c028f27e65c745cfcddc7ce01bd3570a111378b63848127f1c36e5f9e4890\",\n \t\t\"4ae66364b5ea56b20ce4e25555aed2d7e67f42788dd03f3fee4adae0459ab106\",\n \t\t\"4ae66363ab815cbf6a248b87d6b556184e945e9b97fbdf247858b0bdafacfa1c\",\n@@ -90,6 +93,7 @@ var testKeysFromTests = []testKeysFromTest{\n \t\t16,\n \t},\n \t{\n+\t\tversionTLS10,\n \t\t\"832d515f1d61eebb2be56ba0ef79879efb9b527504abb386fb4310ed5d0e3b1f220d3bb6b455033a2773e6d8bdf951d278a187482b400d45deb88a5d5a6bb7d6a7a1decc04eb9ef0642876cd4a82d374d3b6ff35f0351dc5d411104de431375355addc39bfb1f6329fb163b0bc298d658338930d07d313cd980a7e3d9196cac1\",\n \t\t\"4ae663b2ee389c0de147c509d8f18f5052afc4aaf9699efe8cb05ece883d3a5e\",\n \t\t\"4ae664d503fd4cff50cfc1fb8fc606580f87b0fcdac9554ba0e01d785bdf278e\",\n@@ -101,4 +105,17 @@ var testKeysFromTests = []testKeysFromTest{\n \t\t20,\n \t\t16,\n \t},\n+\t{\n+\t\tversionSSL30,\n+\t\t\"832d515f1d61eebb2be56ba0ef79879efb9b527504abb386fb4310ed5d0e3b1f220d3bb6b455033a2773e6d8bdf951d278a187482b400d45deb88a5d5a6bb7d6a7a1decc04eb9ef0642876cd4a82d374d3b6ff35f0351dc5d411104de431375355addc39bfb1f6329fb163b0bc298d658338930d07d313cd980a7e3d9196cac1\",\n+\t\t\"4ae663b2ee389c0de147c509d8f18f5052afc4aaf9699efe8cb05ece883d3a5e\",\n+\t\t\"4ae664d503fd4cff50cfc1fb8fc606580f87b0fcdac9554ba0e01d785bdf278e\",\n+\t\t\"a614863e56299dcffeea2938f22c2ba023768dbe4b3f6877bc9c346c6ae529b51d9cb87ff9695ea4d01f2205584405b2\",\n+\t\t\"2c450d5b6f6e2013ac6bea6a0b32200d4e1ffb94\",\n+\t\t\"7a7a7438769536f2fb1ae49a61f0703b79b2dc53\",\n+\t\t\"f8f6b26c10f12855c9aafb1e0e839ccf\",\n+\t\t\"2b9d4b4a60cb7f396780ebff50650419\",\n+\t\t20,\n+\t\t16,\n+\t},\n }"}, {"sha": "15122416bd1ec162c14ebbcb7e00eb4c8b2ed2b7", "filename": "libgo/go/crypto/tls/root_darwin.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_darwin.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+/*\n+// Note: We disable -Werror here because the code in this file uses a deprecated API to stay\n+// compatible with both Mac OS X 10.6 and 10.7. Using a deprecated function on Darwin generates\n+// a warning.\n+#cgo CFLAGS: -Wno-error\n+#cgo LDFLAGS: -framework CoreFoundation -framework Security\n+#include <CoreFoundation/CoreFoundation.h>\n+#include <Security/Security.h>\n+\n+// FetchPEMRoots fetches the system's list of trusted X.509 root certificates.\n+//\n+// On success it returns 0 and fills pemRoots with a CFDataRef that contains the extracted root\n+// certificates of the system. On failure, the function returns -1.\n+//\n+// Note: The CFDataRef returned in pemRoots must be released (using CFRelease) after\n+// we've consumed its content.\n+int FetchPEMRoots(CFDataRef *pemRoots) {\n+\tif (pemRoots == NULL) {\n+\t\treturn -1;\n+\t}\n+\n+\tCFArrayRef certs = NULL;\n+\tOSStatus err = SecTrustCopyAnchorCertificates(&certs);\n+\tif (err != noErr) {\n+\t\treturn -1;\n+\t}\n+\n+\tCFMutableDataRef combinedData = CFDataCreateMutable(kCFAllocatorDefault, 0);\n+\tint i, ncerts = CFArrayGetCount(certs);\n+\tfor (i = 0; i < ncerts; i++) {\n+\t\tCFDataRef data = NULL;\n+\t\tSecCertificateRef cert = (SecCertificateRef)CFArrayGetValueAtIndex(certs, i);\n+\t\tif (cert == NULL) {\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t// SecKeychainImportExport is deprecated in >= OS X 10.7, and has been replaced by\n+\t\t// SecItemExport.  If we're built on a host with a Lion SDK, this code gets conditionally\n+\t\t// included in the output, also for binaries meant for 10.6.\n+\t\t//\n+\t\t// To make sure that we run on both Mac OS X 10.6 and 10.7 we use weak linking\n+\t\t// and check whether SecItemExport is available before we attempt to call it. On\n+\t\t// 10.6, this won't be the case, and we'll fall back to calling SecKeychainItemExport.\n+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1070\n+\t\tif (SecItemExport) {\n+\t\t\terr = SecItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);\n+\t\t\tif (err != noErr) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t} else\n+#endif\n+\t\tif (data == NULL) {\n+\t\t\terr = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);\n+\t\t\tif (err != noErr) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (data != NULL) {\n+\t\t\tCFDataAppendBytes(combinedData, CFDataGetBytePtr(data), CFDataGetLength(data));\n+\t\t\tCFRelease(data);\n+\t\t}\n+\t}\n+\n+\tCFRelease(certs);\n+\n+\t*pemRoots = combinedData;\n+\treturn 0;\n+}\n+*/\n+import \"C\"\n+import (\n+\t\"crypto/x509\"\n+\t\"unsafe\"\n+)\n+\n+func initDefaultRoots() {\n+\troots := x509.NewCertPool()\n+\n+\tvar data C.CFDataRef = nil\n+\terr := C.FetchPEMRoots(&data)\n+\tif err != -1 {\n+\t\tdefer C.CFRelease(C.CFTypeRef(data))\n+\t\tbuf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))\n+\t\troots.AppendCertsFromPEM(buf)\n+\t}\n+\n+\tvarDefaultRoots = roots\n+}"}, {"sha": "1903eed81384010966e4864381c9cf6fa1fbcb34", "filename": "libgo/go/crypto/tls/root_stub.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_stub.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+func initDefaultRoots() {\n+}"}, {"sha": "95a89d843c8d20bbc538367eda827fb430e1a4cb", "filename": "libgo/go/crypto/tls/root_test.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var tlsServers = []string{\n+\t\"google.com:443\",\n+\t\"github.com:443\",\n+\t\"twitter.com:443\",\n+}\n+\n+func TestOSCertBundles(t *testing.T) {\n+\tdefaultRoots()\n+\n+\tif testing.Short() {\n+\t\tt.Logf(\"skipping certificate tests in short mode\")\n+\t\treturn\n+\t}\n+\n+\tfor _, addr := range tlsServers {\n+\t\tconn, err := Dial(\"tcp\", addr, nil)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"unable to verify %v: %v\", addr, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\terr = conn.Close()\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t}\n+}"}, {"sha": "095beec104aaacaf93e4e02ee16ee5be84c48e48", "filename": "libgo/go/crypto/tls/root_unix.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_unix.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"crypto/x509\"\n+\t\"io/ioutil\"\n+)\n+\n+// Possible certificate files; stop after finding one.\n+var certFiles = []string{\n+\t\"/etc/ssl/certs/ca-certificates.crt\", // Linux etc\n+\t\"/etc/pki/tls/certs/ca-bundle.crt\",   // Fedora/RHEL\n+\t\"/etc/ssl/ca-bundle.pem\",             // OpenSUSE\n+}\n+\n+func initDefaultRoots() {\n+\troots := x509.NewCertPool()\n+\tfor _, file := range certFiles {\n+\t\tdata, err := ioutil.ReadFile(file)\n+\t\tif err == nil {\n+\t\t\troots.AppendCertsFromPEM(data)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tvarDefaultRoots = roots\n+}"}, {"sha": "b8e27a9a5d261899759f324f667a3ab54b04af0b", "filename": "libgo/go/crypto/tls/root_windows.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package tls\n+\n+import (\n+\t\"crypto/x509\"\n+\t\"reflect\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+\n+func loadStore(roots *x509.CertPool, name string) {\n+\tstore, errno := syscall.CertOpenSystemStore(syscall.InvalidHandle, syscall.StringToUTF16Ptr(name))\n+\tif errno != 0 {\n+\t\treturn\n+\t}\n+\n+\tvar cert *syscall.CertContext\n+\tfor {\n+\t\tcert = syscall.CertEnumCertificatesInStore(store, cert)\n+\t\tif cert == nil {\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tvar asn1Slice []byte\n+\t\thdrp := (*reflect.SliceHeader)(unsafe.Pointer(&asn1Slice))\n+\t\thdrp.Data = cert.EncodedCert\n+\t\thdrp.Len = int(cert.Length)\n+\t\thdrp.Cap = int(cert.Length)\n+\n+\t\tbuf := make([]byte, len(asn1Slice))\n+\t\tcopy(buf, asn1Slice)\n+\n+\t\tif cert, err := x509.ParseCertificate(buf); err == nil {\n+\t\t\troots.AddCert(cert)\n+\t\t}\n+\t}\n+\n+\tsyscall.CertCloseStore(store, 0)\n+}\n+\n+func initDefaultRoots() {\n+\troots := x509.NewCertPool()\n+\n+\t// Roots\n+\tloadStore(roots, \"ROOT\")\n+\n+\t// Intermediates\n+\tloadStore(roots, \"CA\")\n+\n+\tvarDefaultRoots = roots\n+}"}, {"sha": "b9196ed46ed8fb9b028ae30bda8b09ec63e91ff4", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -5,9 +5,7 @@\n package x509\n \n import (\n-\t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n-\t\"strings\"\n )\n \n // Roots is a set of certificates.\n@@ -26,10 +24,6 @@ func NewCertPool() *CertPool {\n \t}\n }\n \n-func nameToKey(name *pkix.Name) string {\n-\treturn strings.Join(name.Country, \",\") + \"/\" + strings.Join(name.Organization, \",\") + \"/\" + strings.Join(name.OrganizationalUnit, \",\") + \"/\" + name.CommonName\n-}\n-\n // findVerifiedParents attempts to find certificates in s which have signed the\n // given certificate. If no such certificate can be found or the signature\n // doesn't match, it returns nil.\n@@ -40,7 +34,7 @@ func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int) {\n \t\tcandidates = s.bySubjectKeyId[string(cert.AuthorityKeyId)]\n \t}\n \tif len(candidates) == 0 {\n-\t\tcandidates = s.byName[nameToKey(&cert.Issuer)]\n+\t\tcandidates = s.byName[string(cert.RawIssuer)]\n \t}\n \n \tfor _, c := range candidates {\n@@ -72,7 +66,7 @@ func (s *CertPool) AddCert(cert *Certificate) {\n \t\tkeyId := string(cert.SubjectKeyId)\n \t\ts.bySubjectKeyId[keyId] = append(s.bySubjectKeyId[keyId], n)\n \t}\n-\tname := nameToKey(&cert.Subject)\n+\tname := string(cert.RawSubject)\n \ts.byName[name] = append(s.byName[name], n)\n }\n "}, {"sha": "42afcb4dad65216e8cd68e89e736af3eab8f21a3", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package x509\n+\n+import (\n+\t\"asn1\"\n+\t\"big\"\n+\t\"os\"\n+\t\"crypto/rsa\"\n+)\n+\n+// pkcs1PrivateKey is a structure which mirrors the PKCS#1 ASN.1 for an RSA private key.\n+type pkcs1PrivateKey struct {\n+\tVersion int\n+\tN       *big.Int\n+\tE       int\n+\tD       *big.Int\n+\tP       *big.Int\n+\tQ       *big.Int\n+\t// We ignore these values, if present, because rsa will calculate them.\n+\tDp   *big.Int `asn1:\"optional\"`\n+\tDq   *big.Int `asn1:\"optional\"`\n+\tQinv *big.Int `asn1:\"optional\"`\n+\n+\tAdditionalPrimes []pkcs1AdditionalRSAPrime `asn1:\"optional\"`\n+}\n+\n+type pkcs1AdditionalRSAPrime struct {\n+\tPrime *big.Int\n+\n+\t// We ignore these values because rsa will calculate them.\n+\tExp   *big.Int\n+\tCoeff *big.Int\n+}\n+\n+// ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n+func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n+\tvar priv pkcs1PrivateKey\n+\trest, err := asn1.Unmarshal(der, &priv)\n+\tif len(rest) > 0 {\n+\t\terr = asn1.SyntaxError{\"trailing data\"}\n+\t\treturn\n+\t}\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif priv.Version > 1 {\n+\t\treturn nil, os.NewError(\"x509: unsupported private key version\")\n+\t}\n+\n+\tif priv.N.Sign() <= 0 || priv.D.Sign() <= 0 || priv.P.Sign() <= 0 || priv.Q.Sign() <= 0 {\n+\t\treturn nil, os.NewError(\"private key contains zero or negative value\")\n+\t}\n+\n+\tkey = new(rsa.PrivateKey)\n+\tkey.PublicKey = rsa.PublicKey{\n+\t\tE: priv.E,\n+\t\tN: priv.N,\n+\t}\n+\n+\tkey.D = priv.D\n+\tkey.Primes = make([]*big.Int, 2+len(priv.AdditionalPrimes))\n+\tkey.Primes[0] = priv.P\n+\tkey.Primes[1] = priv.Q\n+\tfor i, a := range priv.AdditionalPrimes {\n+\t\tif a.Prime.Sign() <= 0 {\n+\t\t\treturn nil, os.NewError(\"private key contains zero or negative prime\")\n+\t\t}\n+\t\tkey.Primes[i+2] = a.Prime\n+\t\t// We ignore the other two values because rsa will calculate\n+\t\t// them as needed.\n+\t}\n+\n+\terr = key.Validate()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tkey.Precompute()\n+\n+\treturn\n+}\n+\n+// MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n+func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n+\tkey.Precompute()\n+\n+\tversion := 0\n+\tif len(key.Primes) > 2 {\n+\t\tversion = 1\n+\t}\n+\n+\tpriv := pkcs1PrivateKey{\n+\t\tVersion: version,\n+\t\tN:       key.N,\n+\t\tE:       key.PublicKey.E,\n+\t\tD:       key.D,\n+\t\tP:       key.Primes[0],\n+\t\tQ:       key.Primes[1],\n+\t\tDp:      key.Precomputed.Dp,\n+\t\tDq:      key.Precomputed.Dq,\n+\t\tQinv:    key.Precomputed.Qinv,\n+\t}\n+\n+\tpriv.AdditionalPrimes = make([]pkcs1AdditionalRSAPrime, len(key.Precomputed.CRTValues))\n+\tfor i, values := range key.Precomputed.CRTValues {\n+\t\tpriv.AdditionalPrimes[i].Prime = key.Primes[2+i]\n+\t\tpriv.AdditionalPrimes[i].Exp = values.Exp\n+\t\tpriv.AdditionalPrimes[i].Coeff = values.Coeff\n+\t}\n+\n+\tb, _ := asn1.Marshal(priv)\n+\treturn b\n+}\n+\n+// rsaPublicKey reflects the ASN.1 structure of a PKCS#1 public key.\n+type rsaPublicKey struct {\n+\tN *big.Int\n+\tE int\n+}"}, {"sha": "332a39462120a3a8b114cab77c24e18f2ad245de", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -43,6 +43,8 @@ type Name struct {\n \tLocality, Province                        []string\n \tStreetAddress, PostalCode                 []string\n \tSerialNumber, CommonName                  string\n+\n+\tNames []AttributeTypeAndValue\n }\n \n func (n *Name) FillFromRDNSequence(rdns *RDNSequence) {\n@@ -51,6 +53,7 @@ func (n *Name) FillFromRDNSequence(rdns *RDNSequence) {\n \t\t\tcontinue\n \t\t}\n \t\tatv := rdn[0]\n+\t\tn.Names = append(n.Names, atv)\n \t\tvalue, ok := atv.Value.(string)\n \t\tif !ok {\n \t\t\tcontinue"}, {"sha": "eaa8169b0da7341a601b38f27f658370c6540f4d", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -5,6 +5,7 @@\n package x509\n \n import (\n+\t\"crypto/x509/pkix\"\n \t\"encoding/pem\"\n \t\"os\"\n \t\"strings\"\n@@ -31,7 +32,7 @@ var verifyTests = []verifyTest{\n \t\tdnsName:       \"www.google.com\",\n \n \t\texpectedChains: [][]string{\n-\t\t\t[]string{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t\t{\"Google\", \"Thawte\", \"VeriSign\"},\n \t\t},\n \t},\n \t{\n@@ -68,7 +69,7 @@ var verifyTests = []verifyTest{\n \t\tdnsName:       \"www.google.com\",\n \n \t\texpectedChains: [][]string{\n-\t\t\t[]string{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t\t{\"Google\", \"Thawte\", \"VeriSign\"},\n \t\t},\n \t},\n \t{\n@@ -78,7 +79,7 @@ var verifyTests = []verifyTest{\n \t\tcurrentTime:   1302726541,\n \n \t\texpectedChains: [][]string{\n-\t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n+\t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n \t{\n@@ -88,8 +89,8 @@ var verifyTests = []verifyTest{\n \t\tcurrentTime:   1302726541,\n \n \t\texpectedChains: [][]string{\n-\t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n-\t\t\t[]string{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\", \"StartCom Certification Authority\"},\n+\t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\"},\n+\t\t\t{\"dnssec-exp\", \"StartCom Class 1\", \"StartCom Certification Authority\", \"StartCom Certification Authority\"},\n \t\t},\n \t},\n }\n@@ -211,6 +212,10 @@ func chainToDebugString(chain []*Certificate) string {\n \treturn chainStr\n }\n \n+func nameToKey(name *pkix.Name) string {\n+\treturn strings.Join(name.Country, \",\") + \"/\" + strings.Join(name.Organization, \",\") + \"/\" + strings.Join(name.OrganizationalUnit, \",\") + \"/\" + name.CommonName\n+}\n+\n const verisignRoot = `-----BEGIN CERTIFICATE-----\n MIICPDCCAaUCEHC65B0Q2Sk0tjjKewPMur8wDQYJKoZIhvcNAQECBQAwXzELMAkG\n A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMTcwNQYDVQQLEy5DbGFz"}, {"sha": "4b8ecc56c5e18441dee80d118907bd8e430304d3", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 70, "deletions": 101, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -20,108 +20,59 @@ import (\n \t\"time\"\n )\n \n-// pkcs1PrivateKey is a structure which mirrors the PKCS#1 ASN.1 for an RSA private key.\n-type pkcs1PrivateKey struct {\n-\tVersion int\n-\tN       *big.Int\n-\tE       int\n-\tD       *big.Int\n-\tP       *big.Int\n-\tQ       *big.Int\n-\t// We ignore these values, if present, because rsa will calculate them.\n-\tDp   *big.Int `asn1:\"optional\"`\n-\tDq   *big.Int `asn1:\"optional\"`\n-\tQinv *big.Int `asn1:\"optional\"`\n-\n-\tAdditionalPrimes []pkcs1AdditionalRSAPrime `asn1:\"optional\"`\n+// pkixPublicKey reflects a PKIX public key structure. See SubjectPublicKeyInfo\n+// in RFC 3280.\n+type pkixPublicKey struct {\n+\tAlgo      pkix.AlgorithmIdentifier\n+\tBitString asn1.BitString\n }\n \n-type pkcs1AdditionalRSAPrime struct {\n-\tPrime *big.Int\n-\n-\t// We ignore these values because rsa will calculate them.\n-\tExp   *big.Int\n-\tCoeff *big.Int\n-}\n-\n-// ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n-func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n-\tvar priv pkcs1PrivateKey\n-\trest, err := asn1.Unmarshal(der, &priv)\n-\tif len(rest) > 0 {\n-\t\terr = asn1.SyntaxError{\"trailing data\"}\n-\t\treturn\n-\t}\n-\tif err != nil {\n+// ParsePKIXPublicKey parses a DER encoded public key. These values are\n+// typically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n+func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err os.Error) {\n+\tvar pki publicKeyInfo\n+\tif _, err = asn1.Unmarshal(derBytes, &pki); err != nil {\n \t\treturn\n \t}\n-\n-\tif priv.Version > 1 {\n-\t\treturn nil, os.NewError(\"x509: unsupported private key version\")\n-\t}\n-\n-\tif priv.N.Sign() <= 0 || priv.D.Sign() <= 0 || priv.P.Sign() <= 0 || priv.Q.Sign() <= 0 {\n-\t\treturn nil, os.NewError(\"private key contains zero or negative value\")\n-\t}\n-\n-\tkey = new(rsa.PrivateKey)\n-\tkey.PublicKey = rsa.PublicKey{\n-\t\tE: priv.E,\n-\t\tN: priv.N,\n+\talgo := getPublicKeyAlgorithmFromOID(pki.Algorithm.Algorithm)\n+\tif algo == UnknownPublicKeyAlgorithm {\n+\t\treturn nil, os.NewError(\"ParsePKIXPublicKey: unknown public key algorithm\")\n \t}\n-\n-\tkey.D = priv.D\n-\tkey.Primes = make([]*big.Int, 2+len(priv.AdditionalPrimes))\n-\tkey.Primes[0] = priv.P\n-\tkey.Primes[1] = priv.Q\n-\tfor i, a := range priv.AdditionalPrimes {\n-\t\tif a.Prime.Sign() <= 0 {\n-\t\t\treturn nil, os.NewError(\"private key contains zero or negative prime\")\n-\t\t}\n-\t\tkey.Primes[i+2] = a.Prime\n-\t\t// We ignore the other two values because rsa will calculate\n-\t\t// them as needed.\n-\t}\n-\n-\terr = key.Validate()\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tkey.Precompute()\n-\n-\treturn\n+\treturn parsePublicKey(algo, &pki)\n }\n \n-// MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n-func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n-\tkey.Precompute()\n-\n-\tversion := 0\n-\tif len(key.Primes) > 2 {\n-\t\tversion = 1\n-\t}\n+// MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n+func MarshalPKIXPublicKey(pub interface{}) ([]byte, os.Error) {\n+\tvar pubBytes []byte\n \n-\tpriv := pkcs1PrivateKey{\n-\t\tVersion: version,\n-\t\tN:       key.N,\n-\t\tE:       key.PublicKey.E,\n-\t\tD:       key.D,\n-\t\tP:       key.Primes[0],\n-\t\tQ:       key.Primes[1],\n-\t\tDp:      key.Precomputed.Dp,\n-\t\tDq:      key.Precomputed.Dq,\n-\t\tQinv:    key.Precomputed.Qinv,\n+\tswitch pub := pub.(type) {\n+\tcase *rsa.PublicKey:\n+\t\tpubBytes, _ = asn1.Marshal(rsaPublicKey{\n+\t\t\tN: pub.N,\n+\t\t\tE: pub.E,\n+\t\t})\n+\tdefault:\n+\t\treturn nil, os.NewError(\"MarshalPKIXPublicKey: unknown public key type\")\n \t}\n \n-\tpriv.AdditionalPrimes = make([]pkcs1AdditionalRSAPrime, len(key.Precomputed.CRTValues))\n-\tfor i, values := range key.Precomputed.CRTValues {\n-\t\tpriv.AdditionalPrimes[i].Prime = key.Primes[2+i]\n-\t\tpriv.AdditionalPrimes[i].Exp = values.Exp\n-\t\tpriv.AdditionalPrimes[i].Coeff = values.Coeff\n+\tpkix := pkixPublicKey{\n+\t\tAlgo: pkix.AlgorithmIdentifier{\n+\t\t\tAlgorithm: []int{1, 2, 840, 113549, 1, 1, 1},\n+\t\t\t// This is a NULL parameters value which is technically\n+\t\t\t// superfluous, but most other code includes it and, by\n+\t\t\t// doing this, we match their public key hashes.\n+\t\t\tParameters: asn1.RawValue{\n+\t\t\t\tTag: 5,\n+\t\t\t},\n+\t\t},\n+\t\tBitString: asn1.BitString{\n+\t\t\tBytes:     pubBytes,\n+\t\t\tBitLength: 8 * len(pubBytes),\n+\t\t},\n \t}\n \n-\tb, _ := asn1.Marshal(priv)\n-\treturn b\n+\tret, _ := asn1.Marshal(pkix)\n+\treturn ret, nil\n }\n \n // These structures reflect the ASN.1 structure of X.509 certificates.:\n@@ -138,9 +89,9 @@ type tbsCertificate struct {\n \tVersion            int `asn1:\"optional,explicit,default:1,tag:0\"`\n \tSerialNumber       *big.Int\n \tSignatureAlgorithm pkix.AlgorithmIdentifier\n-\tIssuer             pkix.RDNSequence\n+\tIssuer             asn1.RawValue\n \tValidity           validity\n-\tSubject            pkix.RDNSequence\n+\tSubject            asn1.RawValue\n \tPublicKey          publicKeyInfo\n \tUniqueId           asn1.BitString   `asn1:\"optional,tag:1\"`\n \tSubjectUniqueId    asn1.BitString   `asn1:\"optional,tag:2\"`\n@@ -339,6 +290,8 @@ type Certificate struct {\n \tRaw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n \tRawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.\n \tRawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.\n+\tRawSubject              []byte // DER encoded Subject\n+\tRawIssuer               []byte // DER encoded Issuer\n \n \tSignature          []byte\n \tSignatureAlgorithm SignatureAlgorithm\n@@ -483,11 +436,6 @@ type basicConstraints struct {\n \tMaxPathLen int  `asn1:\"optional\"`\n }\n \n-type rsaPublicKey struct {\n-\tN *big.Int\n-\tE int\n-}\n-\n // RFC 5280 4.2.1.4\n type policyInformation struct {\n \tPolicy asn1.ObjectIdentifier\n@@ -556,6 +504,8 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \tout.Raw = in.Raw\n \tout.RawTBSCertificate = in.TBSCertificate.Raw\n \tout.RawSubjectPublicKeyInfo = in.TBSCertificate.PublicKey.Raw\n+\tout.RawSubject = in.TBSCertificate.Subject.FullBytes\n+\tout.RawIssuer = in.TBSCertificate.Issuer.FullBytes\n \n \tout.Signature = in.SignatureValue.RightAlign()\n \tout.SignatureAlgorithm =\n@@ -575,8 +525,18 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \n \tout.Version = in.TBSCertificate.Version + 1\n \tout.SerialNumber = in.TBSCertificate.SerialNumber\n-\tout.Issuer.FillFromRDNSequence(&in.TBSCertificate.Issuer)\n-\tout.Subject.FillFromRDNSequence(&in.TBSCertificate.Subject)\n+\n+\tvar issuer, subject pkix.RDNSequence\n+\tif _, err := asn1.Unmarshal(in.TBSCertificate.Subject.FullBytes, &subject); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif _, err := asn1.Unmarshal(in.TBSCertificate.Issuer.FullBytes, &issuer); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tout.Issuer.FillFromRDNSequence(&issuer)\n+\tout.Subject.FillFromRDNSequence(&subject)\n+\n \tout.NotBefore = in.TBSCertificate.Validity.NotBefore\n \tout.NotAfter = in.TBSCertificate.Validity.NotAfter\n \n@@ -968,14 +928,23 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \t\treturn\n \t}\n \n+\tasn1Issuer, err := asn1.Marshal(parent.Issuer.ToRDNSequence())\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tasn1Subject, err := asn1.Marshal(parent.Subject.ToRDNSequence())\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n \tencodedPublicKey := asn1.BitString{BitLength: len(asn1PublicKey) * 8, Bytes: asn1PublicKey}\n \tc := tbsCertificate{\n \t\tVersion:            2,\n \t\tSerialNumber:       template.SerialNumber,\n \t\tSignatureAlgorithm: pkix.AlgorithmIdentifier{Algorithm: oidSHA1WithRSA},\n-\t\tIssuer:             parent.Subject.ToRDNSequence(),\n+\t\tIssuer:             asn1.RawValue{FullBytes: asn1Issuer},\n \t\tValidity:           validity{template.NotBefore, template.NotAfter},\n-\t\tSubject:            template.Subject.ToRDNSequence(),\n+\t\tSubject:            asn1.RawValue{FullBytes: asn1Subject},\n \t\tPublicKey:          publicKeyInfo{nil, pkix.AlgorithmIdentifier{Algorithm: oidRSA}, encodedPublicKey},\n \t\tExtensions:         extensions,\n \t}"}, {"sha": "dbc5273ca1244dcf0d8b259b0b39348bf402c8ae", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -6,6 +6,7 @@ package x509\n \n import (\n \t\"asn1\"\n+\t\"bytes\"\n \t\"big\"\n \t\"crypto/dsa\"\n \t\"crypto/rand\"\n@@ -34,6 +35,40 @@ func TestParsePKCS1PrivateKey(t *testing.T) {\n \t}\n }\n \n+func TestParsePKIXPublicKey(t *testing.T) {\n+\tblock, _ := pem.Decode([]byte(pemPublicKey))\n+\tpub, err := ParsePKIXPublicKey(block.Bytes)\n+\tif err != nil {\n+\t\tt.Errorf(\"Failed to parse RSA public key: %s\", err)\n+\t\treturn\n+\t}\n+\trsaPub, ok := pub.(*rsa.PublicKey)\n+\tif !ok {\n+\t\tt.Errorf(\"Value returned from ParsePKIXPublicKey was not an RSA public key\")\n+\t\treturn\n+\t}\n+\n+\tpubBytes2, err := MarshalPKIXPublicKey(rsaPub)\n+\tif err != nil {\n+\t\tt.Errorf(\"Failed to marshal RSA public key for the second time: %s\", err)\n+\t\treturn\n+\t}\n+\tif !bytes.Equal(pubBytes2, block.Bytes) {\n+\t\tt.Errorf(\"Reserialization of public key didn't match. got %x, want %x\", pubBytes2, block.Bytes)\n+\t}\n+}\n+\n+var pemPublicKey = `-----BEGIN PUBLIC KEY-----\n+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3VoPN9PKUjKFLMwOge6+\n+wnDi8sbETGIx2FKXGgqtAKpzmem53kRGEQg8WeqRmp12wgp74TGpkEXsGae7RS1k\n+enJCnma4fii+noGH7R0qKgHvPrI2Bwa9hzsH8tHxpyM3qrXslOmD45EH9SxIDUBJ\n+FehNdaPbLP1gFyahKMsdfxFJLUvbUycuZSJ2ZnIgeVxwm4qbSvZInL9Iu4FzuPtg\n+fINKcbbovy1qq4KvPIrXzhbY3PWDc6btxCf3SE0JdE1MCPThntB62/bLMSQ7xdDR\n+FF53oIpvxe/SCOymfWq/LW849Ytv3Xwod0+wzAP8STXG4HSELS4UedPYeHJJJYcZ\n++QIDAQAB\n+-----END PUBLIC KEY-----\n+`\n+\n var pemPrivateKey = `-----BEGIN RSA PRIVATE KEY-----\n MIIBOgIBAAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0\n fd7Ai2KW5ToIwzFofvJcS/STa6HA5gQenRUCAwEAAQJBAIq9amn00aS0h/CrjXqu"}, {"sha": "29ceeae85b480382706c78a5930f429ed2318ad2", "filename": "libgo/go/csv/reader.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -267,7 +267,7 @@ func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n \t}\n \n \tif r.TrimLeadingSpace {\n-\t\tfor unicode.IsSpace(rune) {\n+\t\tfor rune != '\\n' && unicode.IsSpace(rune) {\n \t\t\trune, err = r.readRune()\n \t\t\tif err != nil {\n \t\t\t\treturn false, 0, err\n@@ -355,7 +355,7 @@ func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n \t\tc := r.column\n \t\trune, err = r.readRune()\n \t\tif r.TrimLeadingSpace {\n-\t\t\tfor unicode.IsSpace(rune) {\n+\t\t\tfor rune != '\\n' && unicode.IsSpace(rune) {\n \t\t\t\trune, err = r.readRune()\n \t\t\t\tif err != nil {\n \t\t\t\t\tbreak"}, {"sha": "967f96b8d1bee854f0df4977d76dcf9255acdd7e", "filename": "libgo/go/csv/reader_test.go", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -127,10 +127,9 @@ field\"`,\n \t\tOutput:     [][]string{{`a\"\"b`, `c`}},\n \t},\n \t{\n-\t\tName:   \"BadDoubleQuotes\",\n-\t\tInput:  `a\"\"b,c`,\n-\t\tOutput: [][]string{{`a\"\"b`, `c`}},\n-\t\tError:  `bare \" in non-quoted-field`, Line: 1, Column: 1,\n+\t\tName:  \"BadDoubleQuotes\",\n+\t\tInput: `a\"\"b,c`,\n+\t\tError: `bare \" in non-quoted-field`, Line: 1, Column: 1,\n \t},\n \t{\n \t\tName:             \"TrimQuote\",\n@@ -231,6 +230,23 @@ x,,,\n \t\t\t{\"\", \"\", \"\", \"\"},\n \t\t},\n \t},\n+\t{\n+\t\tName:             \"Issue 2366\",\n+\t\tTrailingComma:    true,\n+\t\tTrimLeadingSpace: true,\n+\t\tInput:            \"a,b,\\nc,d,e\",\n+\t\tOutput: [][]string{\n+\t\t\t{\"a\", \"b\", \"\"},\n+\t\t\t{\"c\", \"d\", \"e\"},\n+\t\t},\n+\t},\n+\t{\n+\t\tName:             \"Issue 2366a\",\n+\t\tTrailingComma:    false,\n+\t\tTrimLeadingSpace: true,\n+\t\tInput:            \"a,b,\\nc,d,e\",\n+\t\tError:            \"extra delimiter at end of line\",\n+\t},\n }\n \n func TestRead(t *testing.T) {"}, {"sha": "9fa221b090252e21307734dada6f57a7d32bed1a", "filename": "libgo/go/debug/dwarf/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -579,6 +579,6 @@ Error:\n \t// If the parse fails, take the type out of the cache\n \t// so that the next call with this offset doesn't hit\n \t// the cache and return success.\n-\td.typeCache[off] = nil, false\n+\tdelete(d.typeCache, off)\n \treturn nil, err\n }"}, {"sha": "c58f73694b8a63937651b4dc030130fdd89336cf", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -17,9 +17,9 @@ import (\n // A ByteOrder specifies how to convert byte sequences into\n // 16-, 32-, or 64-bit unsigned integers.\n type ByteOrder interface {\n-\tUint16(b []byte) uint16\n-\tUint32(b []byte) uint32\n-\tUint64(b []byte) uint64\n+\tUint16([]byte) uint16\n+\tUint32([]byte) uint32\n+\tUint64([]byte) uint64\n \tPutUint16([]byte, uint16)\n \tPutUint32([]byte, uint32)\n \tPutUint64([]byte, uint64)"}, {"sha": "c98e0e2bf575baa3ae0085e9eee0075dcf869802", "filename": "libgo/go/encoding/binary/varint.go", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package binary\n+\n+// This file implements \"varint\" encoding of 64-bit integers.\n+// The encoding is:\n+// - unsigned integers are serialized 7 bits at a time, starting with the\n+//   least significant bits\n+// - the most significant bit (msb) in each output byte indicates if there\n+//   is a continuation byte (msb = 1)\n+// - signed integers are mapped to unsigned integers using \"zig-zag\"\n+//   encoding: Positive values x are written as 2*x + 0, negative values\n+//   are written as 2*(^x) + 1; that is, negative numbers are complemented\n+//   and whether to complement is encoded in bit 0.\n+//\n+// Design note:\n+// At most 10 bytes are needed for 64-bit values. The encoding could\n+// be more dense: a full 64-bit value needs an extra byte just to hold bit 63.\n+// Instead, the msb of the previous byte could be used to hold bit 63 since we\n+// know there can't be more than 64 bits. This is a trivial improvement and\n+// would reduce the maximum encoding length to 9 bytes. However, it breaks the\n+// invariant that the msb is always the \"continuation bit\" and thus makes the\n+// format incompatible with a varint encoding for larger numbers (say 128-bit).\n+\n+import (\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.\n+const (\n+\tMaxVarintLen16 = 3\n+\tMaxVarintLen32 = 5\n+\tMaxVarintLen64 = 10\n+)\n+\n+// PutUvarint encodes a uint64 into buf and returns the number of bytes written.\n+func PutUvarint(buf []byte, x uint64) int {\n+\ti := 0\n+\tfor x >= 0x80 {\n+\t\tbuf[i] = byte(x) | 0x80\n+\t\tx >>= 7\n+\t\ti++\n+\t}\n+\tbuf[i] = byte(x)\n+\treturn i + 1\n+}\n+\n+// Uvarint decodes a uint64 from buf and returns that value and the\n+// number of bytes read (> 0). If an error occurred, the value is 0\n+// and the number of bytes n is <= 0 meaning:\n+//\n+//\tn == 0: buf too small\n+//\tn  < 0: value larger than 64 bits (overflow)\n+//              and -n is the number of bytes read\n+//\n+func Uvarint(buf []byte) (uint64, int) {\n+\tvar x uint64\n+\tvar s uint\n+\tfor i, b := range buf {\n+\t\tif b < 0x80 {\n+\t\t\tif i > 9 || i == 9 && b > 1 {\n+\t\t\t\treturn 0, -(i + 1) // overflow\n+\t\t\t}\n+\t\t\treturn x | uint64(b)<<s, i + 1\n+\t\t}\n+\t\tx |= uint64(b&0x7f) << s\n+\t\ts += 7\n+\t}\n+\treturn 0, 0\n+}\n+\n+// PutVarint encodes an int64 into buf and returns the number of bytes written.\n+func PutVarint(buf []byte, x int64) int {\n+\tux := uint64(x) << 1\n+\tif x < 0 {\n+\t\tux = ^ux\n+\t}\n+\treturn PutUvarint(buf, ux)\n+}\n+\n+// Varint decodes an int64 from buf and returns that value and the\n+// number of bytes read (> 0). If an error occurred, the value is 0\n+// and the number of bytes n is <= 0 with the following meaning:\n+//\n+//\tn == 0: buf too small\n+//\tn  < 0: value larger than 64 bits (overflow)\n+//              and -n is the number of bytes read\n+//\n+func Varint(buf []byte) (int64, int) {\n+\tux, n := Uvarint(buf) // ok to continue in presence of error\n+\tx := int64(ux >> 1)\n+\tif ux&1 != 0 {\n+\t\tx = ^x\n+\t}\n+\treturn x, n\n+}\n+\n+// WriteUvarint encodes x and writes the result to w.\n+func WriteUvarint(w io.Writer, x uint64) os.Error {\n+\tvar buf [MaxVarintLen64]byte\n+\tn := PutUvarint(buf[:], x)\n+\t_, err := w.Write(buf[0:n])\n+\treturn err\n+}\n+\n+var overflow = os.NewError(\"binary: varint overflows a 64-bit integer\")\n+\n+// ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n+func ReadUvarint(r io.ByteReader) (uint64, os.Error) {\n+\tvar x uint64\n+\tvar s uint\n+\tfor i := 0; ; i++ {\n+\t\tb, err := r.ReadByte()\n+\t\tif err != nil {\n+\t\t\treturn x, err\n+\t\t}\n+\t\tif b < 0x80 {\n+\t\t\tif i > 9 || i == 9 && b > 1 {\n+\t\t\t\treturn x, overflow\n+\t\t\t}\n+\t\t\treturn x | uint64(b)<<s, nil\n+\t\t}\n+\t\tx |= uint64(b&0x7f) << s\n+\t\ts += 7\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+// WriteVarint encodes x and writes the result to w.\n+func WriteVarint(w io.Writer, x int64) os.Error {\n+\tux := uint64(x) << 1\n+\tif x < 0 {\n+\t\tux = ^ux\n+\t}\n+\treturn WriteUvarint(w, ux)\n+}\n+\n+// ReadVarint reads an encoded unsigned integer from r and returns it as a uint64.\n+func ReadVarint(r io.ByteReader) (int64, os.Error) {\n+\tux, err := ReadUvarint(r) // ok to continue in presence of error\n+\tx := int64(ux >> 1)\n+\tif ux&1 != 0 {\n+\t\tx = ^x\n+\t}\n+\treturn x, err\n+}"}, {"sha": "ef51f09293b6d33614c11d15d825045fd9bc99c5", "filename": "libgo/go/encoding/binary/varint_test.go", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,182 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package binary\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func testConstant(t *testing.T, w uint, max int) {\n+\tbuf := make([]byte, MaxVarintLen64)\n+\tn := PutUvarint(buf, 1<<w-1)\n+\tif n != max {\n+\t\tt.Errorf(\"MaxVarintLen%d = %d; want %d\", w, max, n)\n+\t}\n+}\n+\n+func TestConstants(t *testing.T) {\n+\ttestConstant(t, 16, MaxVarintLen16)\n+\ttestConstant(t, 32, MaxVarintLen32)\n+\ttestConstant(t, 64, MaxVarintLen64)\n+}\n+\n+func testVarint(t *testing.T, x int64) {\n+\tbuf1 := make([]byte, MaxVarintLen64)\n+\tn := PutVarint(buf1[:], x)\n+\ty, m := Varint(buf1[0:n])\n+\tif x != y {\n+\t\tt.Errorf(\"Varint(%d): got %d\", x, y)\n+\t}\n+\tif n != m {\n+\t\tt.Errorf(\"Varint(%d): got n = %d; want %d\", x, m, n)\n+\t}\n+\n+\tvar buf2 bytes.Buffer\n+\terr := WriteVarint(&buf2, x)\n+\tif err != nil {\n+\t\tt.Errorf(\"WriteVarint(%d): %s\", x, err)\n+\t}\n+\tif n != buf2.Len() {\n+\t\tt.Errorf(\"WriteVarint(%d): got n = %d; want %d\", x, buf2.Len(), n)\n+\t}\n+\ty, err = ReadVarint(&buf2)\n+\tif err != nil {\n+\t\tt.Errorf(\"ReadVarint(%d): %s\", x, err)\n+\t}\n+\tif x != y {\n+\t\tt.Errorf(\"ReadVarint(%d): got %d\", x, y)\n+\t}\n+}\n+\n+func testUvarint(t *testing.T, x uint64) {\n+\tbuf1 := make([]byte, MaxVarintLen64)\n+\tn := PutUvarint(buf1[:], x)\n+\ty, m := Uvarint(buf1[0:n])\n+\tif x != y {\n+\t\tt.Errorf(\"Uvarint(%d): got %d\", x, y)\n+\t}\n+\tif n != m {\n+\t\tt.Errorf(\"Uvarint(%d): got n = %d; want %d\", x, m, n)\n+\t}\n+\n+\tvar buf2 bytes.Buffer\n+\terr := WriteUvarint(&buf2, x)\n+\tif err != nil {\n+\t\tt.Errorf(\"WriteUvarint(%d): %s\", x, err)\n+\t}\n+\tif n != buf2.Len() {\n+\t\tt.Errorf(\"WriteUvarint(%d): got n = %d; want %d\", x, buf2.Len(), n)\n+\t}\n+\ty, err = ReadUvarint(&buf2)\n+\tif err != nil {\n+\t\tt.Errorf(\"ReadUvarint(%d): %s\", x, err)\n+\t}\n+\tif x != y {\n+\t\tt.Errorf(\"ReadUvarint(%d): got %d\", x, y)\n+\t}\n+}\n+\n+var tests = []int64{\n+\t-1 << 63,\n+\t-1<<63 + 1,\n+\t-1,\n+\t0,\n+\t1,\n+\t2,\n+\t10,\n+\t20,\n+\t63,\n+\t64,\n+\t65,\n+\t127,\n+\t128,\n+\t129,\n+\t255,\n+\t256,\n+\t257,\n+\t1<<63 - 1,\n+}\n+\n+func TestVarint(t *testing.T) {\n+\tfor _, x := range tests {\n+\t\ttestVarint(t, x)\n+\t\ttestVarint(t, -x)\n+\t}\n+\tfor x := int64(0x7); x != 0; x <<= 1 {\n+\t\ttestVarint(t, x)\n+\t\ttestVarint(t, -x)\n+\t}\n+}\n+\n+func TestUvarint(t *testing.T) {\n+\tfor _, x := range tests {\n+\t\ttestUvarint(t, uint64(x))\n+\t}\n+\tfor x := uint64(0x7); x != 0; x <<= 1 {\n+\t\ttestUvarint(t, x)\n+\t}\n+}\n+\n+func TestBufferTooSmall(t *testing.T) {\n+\tbuf := []byte{0x80, 0x80, 0x80, 0x80}\n+\tfor i := 0; i <= len(buf); i++ {\n+\t\tbuf := buf[0:i]\n+\t\tx, n := Uvarint(buf)\n+\t\tif x != 0 || n != 0 {\n+\t\t\tt.Errorf(\"Uvarint(%v): got x = %d, n = %d\", buf, x, n)\n+\t\t}\n+\n+\t\tx, err := ReadUvarint(bytes.NewBuffer(buf))\n+\t\tif x != 0 || err != os.EOF {\n+\t\t\tt.Errorf(\"ReadUvarint(%v): got x = %d, err = %s\", buf, x, err)\n+\t\t}\n+\t}\n+}\n+\n+func testOverflow(t *testing.T, buf []byte, n0 int, err0 os.Error) {\n+\tx, n := Uvarint(buf)\n+\tif x != 0 || n != n0 {\n+\t\tt.Errorf(\"Uvarint(%v): got x = %d, n = %d; want 0, %d\", buf, x, n, n0)\n+\t}\n+\n+\tx, err := ReadUvarint(bytes.NewBuffer(buf))\n+\tif x != 0 || err != err0 {\n+\t\tt.Errorf(\"ReadUvarint(%v): got x = %d, err = %s; want 0, %s\", buf, x, err, err0)\n+\t}\n+}\n+\n+func TestOverflow(t *testing.T) {\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x2}, -10, overflow)\n+\ttestOverflow(t, []byte{0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1, 0, 0}, -13, overflow)\n+}\n+\n+func TestNonCanonicalZero(t *testing.T) {\n+\tbuf := []byte{0x80, 0x80, 0x80, 0}\n+\tx, n := Uvarint(buf)\n+\tif x != 0 || n != 4 {\n+\t\tt.Errorf(\"Uvarint(%v): got x = %d, n = %d; want 0, 4\", buf, x, n)\n+\n+\t}\n+}\n+\n+func BenchmarkPutUvarint32(b *testing.B) {\n+\tbuf := make([]byte, MaxVarintLen32)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor j := uint(0); j < MaxVarintLen32; j++ {\n+\t\t\tPutUvarint(buf, 1<<(j*7))\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkPutUvarint64(b *testing.B) {\n+\tbuf := make([]byte, MaxVarintLen64)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tfor j := uint(0); j < MaxVarintLen64; j++ {\n+\t\t\tPutUvarint(buf, 1<<(j*7))\n+\t\t}\n+\t}\n+}"}, {"sha": "aaad50846ea7d88b4a67b52eab185c682fa38643", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -63,6 +63,11 @@ type Cmd struct {\n \tStdout io.Writer\n \tStderr io.Writer\n \n+\t// ExtraFiles specifies additional open files to be inherited by the\n+\t// new process. It does not include standard input, standard output, or\n+\t// standard error. If non-nil, entry i becomes file descriptor 3+i.\n+\tExtraFiles []*os.File\n+\n \t// SysProcAttr holds optional, operating system-specific attributes.\n \t// Run passes it to os.StartProcess as the os.ProcAttr's Sys field.\n \tSysProcAttr *syscall.SysProcAttr\n@@ -224,6 +229,7 @@ func (c *Cmd) Start() os.Error {\n \t\t}\n \t\tc.childFiles = append(c.childFiles, fd)\n \t}\n+\tc.childFiles = append(c.childFiles, c.ExtraFiles...)\n \n \tvar err os.Error\n \tc.Process, err = os.StartProcess(c.Path, c.argv(), &os.ProcAttr{"}, {"sha": "2b36e2535a4def27c788d6664ccf4b58aa3d5431", "filename": "libgo/go/exec/exec_test.go", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -9,8 +9,10 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"testing\"\n \t\"os\"\n+\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n )\n@@ -139,6 +141,39 @@ func TestPipes(t *testing.T) {\n \tcheck(\"Wait\", err)\n }\n \n+func TestExtraFiles(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Logf(\"no operating system support; skipping\")\n+\t\treturn\n+\t}\n+\ttf, err := ioutil.TempFile(\"\", \"\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"TempFile: %v\", err)\n+\t}\n+\tdefer os.Remove(tf.Name())\n+\tdefer tf.Close()\n+\n+\tconst text = \"Hello, fd 3!\"\n+\t_, err = tf.Write([]byte(text))\n+\tif err != nil {\n+\t\tt.Fatalf(\"Write: %v\", err)\n+\t}\n+\t_, err = tf.Seek(0, os.SEEK_SET)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Seek: %v\", err)\n+\t}\n+\n+\tc := helperCommand(\"read3\")\n+\tc.ExtraFiles = []*os.File{tf}\n+\tbs, err := c.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"CombinedOutput: %v\", err)\n+\t}\n+\tif string(bs) != text {\n+\t\tt.Errorf(\"got %q; want %q\", string(bs), text)\n+\t}\n+}\n+\n // TestHelperProcess isn't a real test. It's used as a helper process\n // for TestParameterRun.\n func TestHelperProcess(*testing.T) {\n@@ -204,6 +239,14 @@ func TestHelperProcess(*testing.T) {\n \t\t\t\tos.Exit(1)\n \t\t\t}\n \t\t}\n+\tcase \"read3\": // read fd 3\n+\t\tfd3 := os.NewFile(3, \"fd3\")\n+\t\tbs, err := ioutil.ReadAll(fd3)\n+\t\tif err != nil {\n+\t\t\tfmt.Printf(\"ReadAll from fd 3: %v\", err)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tos.Stderr.Write(bs)\n \tcase \"exit\":\n \t\tn, _ := strconv.Atoi(args[0])\n \t\tos.Exit(n)"}, {"sha": "0cd19e7ac9004e89a0791e0ca16254d83e6a1442", "filename": "libgo/go/exec/lp_unix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_unix.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -2,6 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// +build darwin freebsd linux openbsd\n+\n package exec\n \n import ("}, {"sha": "2ec7f00800dc96b4b83f54b077932180d5d92f35", "filename": "libgo/go/exp/ebnf/ebnf.go", "status": "renamed", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -23,21 +23,47 @@\n package ebnf\n \n import (\n-\t\"go/scanner\"\n-\t\"go/token\"\n+\t\"fmt\"\n \t\"os\"\n+\t\"scanner\"\n \t\"unicode\"\n \t\"utf8\"\n )\n \n+// ----------------------------------------------------------------------------\n+// Error handling\n+\n+type errorList []os.Error\n+\n+func (list errorList) Error() os.Error {\n+\tif len(list) == 0 {\n+\t\treturn nil\n+\t}\n+\treturn list\n+}\n+\n+func (list errorList) String() string {\n+\tswitch len(list) {\n+\tcase 0:\n+\t\treturn \"no errors\"\n+\tcase 1:\n+\t\treturn list[0].String()\n+\t}\n+\treturn fmt.Sprintf(\"%s (and %d more errors)\", list[0], len(list)-1)\n+}\n+\n+func newError(pos scanner.Position, msg string) os.Error {\n+\treturn os.NewError(fmt.Sprintf(\"%s: %s\", pos, msg))\n+}\n+\n // ----------------------------------------------------------------------------\n // Internal representation\n \n type (\n \t// An Expression node represents a production expression.\n \tExpression interface {\n \t\t// Pos is the position of the first character of the syntactic construct\n-\t\tPos() token.Pos\n+\t\tPos() scanner.Position\n \t}\n \n \t// An Alternative node represents a non-empty list of alternative expressions.\n@@ -48,13 +74,13 @@ type (\n \n \t// A Name node represents a production name.\n \tName struct {\n-\t\tStringPos token.Pos\n+\t\tStringPos scanner.Position\n \t\tString    string\n \t}\n \n \t// A Token node represents a literal.\n \tToken struct {\n-\t\tStringPos token.Pos\n+\t\tStringPos scanner.Position\n \t\tString    string\n \t}\n \n@@ -65,50 +91,50 @@ type (\n \n \t// A Group node represents a grouped expression.\n \tGroup struct {\n-\t\tLparen token.Pos\n+\t\tLparen scanner.Position\n \t\tBody   Expression // (body)\n \t}\n \n \t// An Option node represents an optional expression.\n \tOption struct {\n-\t\tLbrack token.Pos\n+\t\tLbrack scanner.Position\n \t\tBody   Expression // [body]\n \t}\n \n \t// A Repetition node represents a repeated expression.\n \tRepetition struct {\n-\t\tLbrace token.Pos\n+\t\tLbrace scanner.Position\n \t\tBody   Expression // {body}\n \t}\n \n-\t// A Bad node stands for pieces of source code that lead to a parse error.\n-\tBad struct {\n-\t\tTokPos token.Pos\n-\t\tError  string // parser error message\n-\t}\n-\n \t// A Production node represents an EBNF production.\n \tProduction struct {\n \t\tName *Name\n \t\tExpr Expression\n \t}\n \n+\t// A Bad node stands for pieces of source code that lead to a parse error.\n+\tBad struct {\n+\t\tTokPos scanner.Position\n+\t\tError  string // parser error message\n+\t}\n+\n \t// A Grammar is a set of EBNF productions. The map\n \t// is indexed by production name.\n \t//\n \tGrammar map[string]*Production\n )\n \n-func (x Alternative) Pos() token.Pos { return x[0].Pos() } // the parser always generates non-empty Alternative\n-func (x Sequence) Pos() token.Pos    { return x[0].Pos() } // the parser always generates non-empty Sequences\n-func (x *Name) Pos() token.Pos       { return x.StringPos }\n-func (x *Token) Pos() token.Pos      { return x.StringPos }\n-func (x *Range) Pos() token.Pos      { return x.Begin.Pos() }\n-func (x *Group) Pos() token.Pos      { return x.Lparen }\n-func (x *Option) Pos() token.Pos     { return x.Lbrack }\n-func (x *Repetition) Pos() token.Pos { return x.Lbrace }\n-func (x *Bad) Pos() token.Pos        { return x.TokPos }\n-func (x *Production) Pos() token.Pos { return x.Name.Pos() }\n+func (x Alternative) Pos() scanner.Position { return x[0].Pos() } // the parser always generates non-empty Alternative\n+func (x Sequence) Pos() scanner.Position    { return x[0].Pos() } // the parser always generates non-empty Sequences\n+func (x *Name) Pos() scanner.Position       { return x.StringPos }\n+func (x *Token) Pos() scanner.Position      { return x.StringPos }\n+func (x *Range) Pos() scanner.Position      { return x.Begin.Pos() }\n+func (x *Group) Pos() scanner.Position      { return x.Lparen }\n+func (x *Option) Pos() scanner.Position     { return x.Lbrack }\n+func (x *Repetition) Pos() scanner.Position { return x.Lbrace }\n+func (x *Production) Pos() scanner.Position { return x.Name.Pos() }\n+func (x *Bad) Pos() scanner.Position        { return x.TokPos }\n \n // ----------------------------------------------------------------------------\n // Grammar verification\n@@ -119,15 +145,14 @@ func isLexical(name string) bool {\n }\n \n type verifier struct {\n-\tfset *token.FileSet\n-\tscanner.ErrorVector\n+\terrors   errorList\n \tworklist []*Production\n \treached  Grammar // set of productions reached from (and including) the root production\n \tgrammar  Grammar\n }\n \n-func (v *verifier) error(pos token.Pos, msg string) {\n-\tv.Error(v.fset.Position(pos), msg)\n+func (v *verifier) error(pos scanner.Position, msg string) {\n+\tv.errors = append(v.errors, newError(pos, msg))\n }\n \n func (v *verifier) push(prod *Production) {\n@@ -187,24 +212,23 @@ func (v *verifier) verifyExpr(expr Expression, lexical bool) {\n \t\tv.verifyExpr(x.Body, lexical)\n \tcase *Repetition:\n \t\tv.verifyExpr(x.Body, lexical)\n+\tcase *Bad:\n+\t\tv.error(x.Pos(), x.Error)\n \tdefault:\n-\t\tpanic(\"unreachable\")\n+\t\tpanic(fmt.Sprintf(\"internal error: unexpected type %T\", expr))\n \t}\n }\n \n-func (v *verifier) verify(fset *token.FileSet, grammar Grammar, start string) {\n+func (v *verifier) verify(grammar Grammar, start string) {\n \t// find root production\n \troot, found := grammar[start]\n \tif !found {\n-\t\t// token.NoPos doesn't require a file set;\n-\t\t// ok to set v.fset only afterwards\n-\t\tv.error(token.NoPos, \"no start production \"+start)\n+\t\tvar noPos scanner.Position\n+\t\tv.error(noPos, \"no start production \"+start)\n \t\treturn\n \t}\n \n \t// initialize verifier\n-\tv.fset = fset\n-\tv.ErrorVector.Reset()\n \tv.worklist = v.worklist[0:0]\n \tv.reached = make(Grammar)\n \tv.grammar = grammar\n@@ -238,8 +262,8 @@ func (v *verifier) verify(fset *token.FileSet, grammar Grammar, start string) {\n //\n // Position information is interpreted relative to the file set fset.\n //\n-func Verify(fset *token.FileSet, grammar Grammar, start string) os.Error {\n+func Verify(grammar Grammar, start string) os.Error {\n \tvar v verifier\n-\tv.verify(fset, grammar, start)\n-\treturn v.GetError(scanner.Sorted)\n+\tv.verify(grammar, start)\n+\treturn v.errors.Error()\n }", "previous_filename": "libgo/go/ebnf/ebnf.go"}, {"sha": "8cfd6b9c37037ca1753df4580ac71581f540766a", "filename": "libgo/go/exp/ebnf/ebnf_test.go", "status": "renamed", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnf%2Febnf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnf%2Febnf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Febnf_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -5,13 +5,10 @@\n package ebnf\n \n import (\n-\t\"go/token\"\n-\t\"io/ioutil\"\n+\t\"bytes\"\n \t\"testing\"\n )\n \n-var fset = token.NewFileSet()\n-\n var goodGrammars = []string{\n \t`Program = .`,\n \n@@ -46,42 +43,29 @@ var badGrammars = []string{\n \t`Program = {} .`,\n }\n \n-func checkGood(t *testing.T, filename string, src []byte) {\n-\tgrammar, err := Parse(fset, filename, src)\n+func checkGood(t *testing.T, src string) {\n+\tgrammar, err := Parse(\"\", bytes.NewBuffer([]byte(src)))\n \tif err != nil {\n \t\tt.Errorf(\"Parse(%s) failed: %v\", src, err)\n+\t\treturn\n \t}\n-\tif err = Verify(fset, grammar, \"Program\"); err != nil {\n+\tif err = Verify(grammar, \"Program\"); err != nil {\n \t\tt.Errorf(\"Verify(%s) failed: %v\", src, err)\n \t}\n }\n \n-func checkBad(t *testing.T, filename string, src []byte) {\n-\t_, err := Parse(fset, filename, src)\n+func checkBad(t *testing.T, src string) {\n+\t_, err := Parse(\"\", bytes.NewBuffer([]byte(src)))\n \tif err == nil {\n \t\tt.Errorf(\"Parse(%s) should have failed\", src)\n \t}\n }\n \n func TestGrammars(t *testing.T) {\n \tfor _, src := range goodGrammars {\n-\t\tcheckGood(t, \"\", []byte(src))\n+\t\tcheckGood(t, src)\n \t}\n \tfor _, src := range badGrammars {\n-\t\tcheckBad(t, \"\", []byte(src))\n-\t}\n-}\n-\n-var files = []string{\n-// TODO(gri) add some test files\n-}\n-\n-func TestFiles(t *testing.T) {\n-\tfor _, filename := range files {\n-\t\tsrc, err := ioutil.ReadFile(filename)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tcheckGood(t, filename, src)\n+\t\tcheckBad(t, src)\n \t}\n }", "previous_filename": "libgo/go/ebnf/ebnf_test.go"}, {"sha": "2dbbefb751946b3506b3c9aa013acde72adc4860", "filename": "libgo/go/exp/ebnf/parser.go", "status": "renamed", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -5,51 +5,47 @@\n package ebnf\n \n import (\n-\t\"go/scanner\"\n-\t\"go/token\"\n+\t\"io\"\n \t\"os\"\n+\t\"scanner\"\n \t\"strconv\"\n )\n \n type parser struct {\n-\tfset *token.FileSet\n-\tscanner.ErrorVector\n+\terrors  errorList\n \tscanner scanner.Scanner\n-\tpos     token.Pos   // token position\n-\ttok     token.Token // one token look-ahead\n-\tlit     string      // token literal\n+\tpos     scanner.Position // token position\n+\ttok     int              // one token look-ahead\n+\tlit     string           // token literal\n }\n \n func (p *parser) next() {\n-\tp.pos, p.tok, p.lit = p.scanner.Scan()\n-\tif p.tok.IsKeyword() {\n-\t\t// TODO Should keyword mapping always happen outside scanner?\n-\t\t//      Or should there be a flag to scanner to enable keyword mapping?\n-\t\tp.tok = token.IDENT\n-\t}\n+\tp.tok = p.scanner.Scan()\n+\tp.pos = p.scanner.Position\n+\tp.lit = p.scanner.TokenText()\n }\n \n-func (p *parser) error(pos token.Pos, msg string) {\n-\tp.Error(p.fset.Position(pos), msg)\n+func (p *parser) error(pos scanner.Position, msg string) {\n+\tp.errors = append(p.errors, newError(pos, msg))\n }\n \n-func (p *parser) errorExpected(pos token.Pos, msg string) {\n-\tmsg = \"expected \" + msg\n-\tif pos == p.pos {\n+func (p *parser) errorExpected(pos scanner.Position, msg string) {\n+\tmsg = `expected \"` + msg + `\"`\n+\tif pos.Offset == p.pos.Offset {\n \t\t// the error happened at the current position;\n \t\t// make the error message more specific\n-\t\tmsg += \", found '\" + p.tok.String() + \"'\"\n-\t\tif p.tok.IsLiteral() {\n+\t\tmsg += \", found \" + scanner.TokenString(p.tok)\n+\t\tif p.tok < 0 {\n \t\t\tmsg += \" \" + p.lit\n \t\t}\n \t}\n \tp.error(pos, msg)\n }\n \n-func (p *parser) expect(tok token.Token) token.Pos {\n+func (p *parser) expect(tok int) scanner.Position {\n \tpos := p.pos\n \tif p.tok != tok {\n-\t\tp.errorExpected(pos, \"'\"+tok.String()+\"'\")\n+\t\tp.errorExpected(pos, scanner.TokenString(tok))\n \t}\n \tp.next() // make progress in any case\n \treturn pos\n@@ -58,21 +54,21 @@ func (p *parser) expect(tok token.Token) token.Pos {\n func (p *parser) parseIdentifier() *Name {\n \tpos := p.pos\n \tname := p.lit\n-\tp.expect(token.IDENT)\n+\tp.expect(scanner.Ident)\n \treturn &Name{pos, name}\n }\n \n func (p *parser) parseToken() *Token {\n \tpos := p.pos\n \tvalue := \"\"\n-\tif p.tok == token.STRING {\n+\tif p.tok == scanner.String {\n \t\tvalue, _ = strconv.Unquote(p.lit)\n \t\t// Unquote may fail with an error, but only if the scanner found\n \t\t// an illegal string in the first place. In this case the error\n \t\t// has already been reported.\n \t\tp.next()\n \t} else {\n-\t\tp.expect(token.STRING)\n+\t\tp.expect(scanner.String)\n \t}\n \treturn &Token{pos, value}\n }\n@@ -82,32 +78,32 @@ func (p *parser) parseTerm() (x Expression) {\n \tpos := p.pos\n \n \tswitch p.tok {\n-\tcase token.IDENT:\n+\tcase scanner.Ident:\n \t\tx = p.parseIdentifier()\n \n-\tcase token.STRING:\n+\tcase scanner.String:\n \t\ttok := p.parseToken()\n \t\tx = tok\n-\t\tconst ellipsis = \"\u2026\" // U+2026, the horizontal ellipsis character\n-\t\tif p.tok == token.ILLEGAL && p.lit == ellipsis {\n+\t\tconst ellipsis = '\u2026' // U+2026, the horizontal ellipsis character\n+\t\tif p.tok == ellipsis {\n \t\t\tp.next()\n \t\t\tx = &Range{tok, p.parseToken()}\n \t\t}\n \n-\tcase token.LPAREN:\n+\tcase '(':\n \t\tp.next()\n \t\tx = &Group{pos, p.parseExpression()}\n-\t\tp.expect(token.RPAREN)\n+\t\tp.expect(')')\n \n-\tcase token.LBRACK:\n+\tcase '[':\n \t\tp.next()\n \t\tx = &Option{pos, p.parseExpression()}\n-\t\tp.expect(token.RBRACK)\n+\t\tp.expect(']')\n \n-\tcase token.LBRACE:\n+\tcase '{':\n \t\tp.next()\n \t\tx = &Repetition{pos, p.parseExpression()}\n-\t\tp.expect(token.RBRACE)\n+\t\tp.expect('}')\n \t}\n \n \treturn x\n@@ -137,7 +133,7 @@ func (p *parser) parseExpression() Expression {\n \n \tfor {\n \t\tlist = append(list, p.parseSequence())\n-\t\tif p.tok != token.OR {\n+\t\tif p.tok != '|' {\n \t\t\tbreak\n \t\t}\n \t\tp.next()\n@@ -154,24 +150,22 @@ func (p *parser) parseExpression() Expression {\n \n func (p *parser) parseProduction() *Production {\n \tname := p.parseIdentifier()\n-\tp.expect(token.ASSIGN)\n+\tp.expect('=')\n \tvar expr Expression\n-\tif p.tok != token.PERIOD {\n+\tif p.tok != '.' {\n \t\texpr = p.parseExpression()\n \t}\n-\tp.expect(token.PERIOD)\n+\tp.expect('.')\n \treturn &Production{name, expr}\n }\n \n-func (p *parser) parse(fset *token.FileSet, filename string, src []byte) Grammar {\n-\t// initialize parser\n-\tp.fset = fset\n-\tp.ErrorVector.Reset()\n-\tp.scanner.Init(fset.AddFile(filename, fset.Base(), len(src)), src, p, scanner.AllowIllegalChars)\n+func (p *parser) parse(filename string, src io.Reader) Grammar {\n+\tp.scanner.Init(src)\n+\tp.scanner.Filename = filename\n \tp.next() // initializes pos, tok, lit\n \n \tgrammar := make(Grammar)\n-\tfor p.tok != token.EOF {\n+\tfor p.tok != scanner.EOF {\n \t\tprod := p.parseProduction()\n \t\tname := prod.Name.String\n \t\tif _, found := grammar[name]; !found {\n@@ -187,11 +181,11 @@ func (p *parser) parse(fset *token.FileSet, filename string, src []byte) Grammar\n // Parse parses a set of EBNF productions from source src.\n // It returns a set of productions. Errors are reported\n // for incorrect syntax and if a production is declared\n-// more than once. Position information is recorded relative\n-// to the file set fset.\n+// more than once; the filename is used only for error\n+// positions.\n //\n-func Parse(fset *token.FileSet, filename string, src []byte) (Grammar, os.Error) {\n+func Parse(filename string, src io.Reader) (Grammar, os.Error) {\n \tvar p parser\n-\tgrammar := p.parse(fset, filename, src)\n-\treturn grammar, p.GetError(scanner.Sorted)\n+\tgrammar := p.parse(filename, src)\n+\treturn grammar, p.errors.Error()\n }", "previous_filename": "libgo/go/ebnf/parser.go"}, {"sha": "f35976eea73012d27788d20e5bf837dab342814f", "filename": "libgo/go/exp/ebnflint/doc.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnflint%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnflint%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Fdoc.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+\n+Ebnflint verifies that EBNF productions are consistent and gramatically correct.\n+It reads them from an HTML document such as the Go specification.\n+\n+Grammar productions are grouped in boxes demarcated by the HTML elements\n+\t<pre class=\"ebnf\">\n+\t</pre>\n+\n+\n+Usage:\n+\tebnflint [--start production] [file]\n+\n+The --start flag specifies the name of the start production for\n+the grammar; it defaults to \"Start\".\n+\n+*/\n+package documentation"}, {"sha": "c827716c44c9453af812240afde424810efa856c", "filename": "libgo/go/exp/ebnflint/ebnflint.go", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"exp/ebnf\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+)\n+\n+var fset = token.NewFileSet()\n+var start = flag.String(\"start\", \"Start\", \"name of start production\")\n+\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: ebnflint [flags] [filename]\\n\")\n+\tflag.PrintDefaults()\n+\tos.Exit(1)\n+}\n+\n+// Markers around EBNF sections in .html files\n+var (\n+\topen  = []byte(`<pre class=\"ebnf\">`)\n+\tclose = []byte(`</pre>`)\n+)\n+\n+func report(err os.Error) {\n+\tscanner.PrintError(os.Stderr, err)\n+\tos.Exit(1)\n+}\n+\n+func extractEBNF(src []byte) []byte {\n+\tvar buf bytes.Buffer\n+\n+\tfor {\n+\t\t// i = beginning of EBNF text\n+\t\ti := bytes.Index(src, open)\n+\t\tif i < 0 {\n+\t\t\tbreak // no EBNF found - we are done\n+\t\t}\n+\t\ti += len(open)\n+\n+\t\t// write as many newlines as found in the excluded text\n+\t\t// to maintain correct line numbers in error messages\n+\t\tfor _, ch := range src[0:i] {\n+\t\t\tif ch == '\\n' {\n+\t\t\t\tbuf.WriteByte('\\n')\n+\t\t\t}\n+\t\t}\n+\n+\t\t// j = end of EBNF text (or end of source)\n+\t\tj := bytes.Index(src[i:], close) // close marker\n+\t\tif j < 0 {\n+\t\t\tj = len(src) - i\n+\t\t}\n+\t\tj += i\n+\n+\t\t// copy EBNF text\n+\t\tbuf.Write(src[i:j])\n+\n+\t\t// advance\n+\t\tsrc = src[j:]\n+\t}\n+\n+\treturn buf.Bytes()\n+}\n+\n+func main() {\n+\tflag.Parse()\n+\n+\tvar (\n+\t\tfilename string\n+\t\tsrc      []byte\n+\t\terr      os.Error\n+\t)\n+\tswitch flag.NArg() {\n+\tcase 0:\n+\t\tfilename = \"<stdin>\"\n+\t\tsrc, err = ioutil.ReadAll(os.Stdin)\n+\tcase 1:\n+\t\tfilename = flag.Arg(0)\n+\t\tsrc, err = ioutil.ReadFile(filename)\n+\tdefault:\n+\t\tusage()\n+\t}\n+\tif err != nil {\n+\t\treport(err)\n+\t}\n+\n+\tif filepath.Ext(filename) == \".html\" || bytes.Index(src, open) >= 0 {\n+\t\tsrc = extractEBNF(src)\n+\t}\n+\n+\tgrammar, err := ebnf.Parse(filename, bytes.NewBuffer(src))\n+\tif err != nil {\n+\t\treport(err)\n+\t}\n+\n+\tif err = ebnf.Verify(grammar, *start); err != nil {\n+\t\treport(err)\n+\t}\n+}"}, {"sha": "1aa0faa751a17daa1073444e7d5491f9f08a0eb3", "filename": "libgo/go/exp/gotype/doc.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fdoc.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+The gotype command does syntactic and semantic analysis of Go files\n+and packages similar to the analysis performed by the front-end of\n+a Go compiler. Errors are reported if the analysis fails; otherwise\n+gotype is quiet (unless -v is set).\n+\n+Without a list of paths, gotype processes the standard input, which must\n+be the source of a single package file.\n+\n+Given a list of file names, each file must be a source file belonging to\n+the same package unless the package name is explicitly specified with the\n+-p flag.\n+\n+Given a directory name, gotype collects all .go files in the directory\n+and processes them as if they were provided as an explicit list of file\n+names. Each directory is processed independently. Files starting with .\n+or not ending in .go are ignored.\n+\n+Usage:\n+\tgotype [flags] [path ...]\n+\n+The flags are:\n+\t-e\n+\t\tPrint all (including spurious) errors.\n+\t-p pkgName\n+\t\tProcess only those files in package pkgName.\n+\t-r\n+\t\tRecursively process subdirectories.\n+\t-v\n+\t\tVerbose mode.\n+\n+Debugging flags:\n+\t-ast\n+\t\tPrint AST (disables concurrent parsing).\n+\t-trace\n+\t\tPrint parse trace (disables concurrent parsing).\n+\n+\n+Examples\n+\n+To check the files file.go, old.saved, and .ignored:\n+\n+\tgotype file.go old.saved .ignored\n+\n+To check all .go files belonging to package main in the current directory\n+and recursively in all subdirectories:\n+\n+\tgotype -p main -r .\n+\n+To verify the output of a pipe:\n+\n+\techo \"package foo\" | gotype\n+\n+*/\n+package documentation\n+\n+// BUG(gri): At the moment, only single-file scope analysis is performed."}, {"sha": "9199213007793601c06de9e557bbf7ba991616bf", "filename": "libgo/go/exp/gotype/gotype.go", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"exp/types\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/scanner\"\n+\t\"go/token\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+var (\n+\t// main operation modes\n+\tpkgName   = flag.String(\"p\", \"\", \"process only those files in package pkgName\")\n+\trecursive = flag.Bool(\"r\", false, \"recursively process subdirectories\")\n+\tverbose   = flag.Bool(\"v\", false, \"verbose mode\")\n+\tallErrors = flag.Bool(\"e\", false, \"print all (including spurious) errors\")\n+\n+\t// debugging support\n+\tprintTrace = flag.Bool(\"trace\", false, \"print parse trace\")\n+\tprintAST   = flag.Bool(\"ast\", false, \"print AST\")\n+)\n+\n+var exitCode = 0\n+\n+func usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: gotype [flags] [path ...]\\n\")\n+\tflag.PrintDefaults()\n+\tos.Exit(2)\n+}\n+\n+func report(err os.Error) {\n+\tscanner.PrintError(os.Stderr, err)\n+\texitCode = 2\n+}\n+\n+// parse returns the AST for the Go source src.\n+// The filename is for error reporting only.\n+// The result is nil if there were errors or if\n+// the file does not belong to the -p package.\n+func parse(fset *token.FileSet, filename string, src []byte) *ast.File {\n+\tif *verbose {\n+\t\tfmt.Println(filename)\n+\t}\n+\n+\t// ignore files with different package name\n+\tif *pkgName != \"\" {\n+\t\tfile, err := parser.ParseFile(fset, filename, src, parser.PackageClauseOnly)\n+\t\tif err != nil {\n+\t\t\treport(err)\n+\t\t\treturn nil\n+\t\t}\n+\t\tif file.Name.Name != *pkgName {\n+\t\t\tif *verbose {\n+\t\t\t\tfmt.Printf(\"\\tignored (package %s)\\n\", file.Name.Name)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\t// parse entire file\n+\tmode := parser.DeclarationErrors\n+\tif *allErrors {\n+\t\tmode |= parser.SpuriousErrors\n+\t}\n+\tif *printTrace {\n+\t\tmode |= parser.Trace\n+\t}\n+\tfile, err := parser.ParseFile(fset, filename, src, mode)\n+\tif err != nil {\n+\t\treport(err)\n+\t\treturn nil\n+\t}\n+\tif *printAST {\n+\t\tast.Print(fset, file)\n+\t}\n+\n+\treturn file\n+}\n+\n+func parseStdin(fset *token.FileSet) (files map[string]*ast.File) {\n+\tfiles = make(map[string]*ast.File)\n+\tsrc, err := ioutil.ReadAll(os.Stdin)\n+\tif err != nil {\n+\t\treport(err)\n+\t\treturn\n+\t}\n+\tconst filename = \"<standard input>\"\n+\tif file := parse(fset, filename, src); file != nil {\n+\t\tfiles[filename] = file\n+\t}\n+\treturn\n+}\n+\n+func parseFiles(fset *token.FileSet, filenames []string) (files map[string]*ast.File) {\n+\tfiles = make(map[string]*ast.File)\n+\tfor _, filename := range filenames {\n+\t\tsrc, err := ioutil.ReadFile(filename)\n+\t\tif err != nil {\n+\t\t\treport(err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif file := parse(fset, filename, src); file != nil {\n+\t\t\tif files[filename] != nil {\n+\t\t\t\treport(os.NewError(fmt.Sprintf(\"%q: duplicate file\", filename)))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tfiles[filename] = file\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func isGoFilename(filename string) bool {\n+\t// ignore non-Go files\n+\treturn !strings.HasPrefix(filename, \".\") && strings.HasSuffix(filename, \".go\")\n+}\n+\n+func processDirectory(dirname string) {\n+\tf, err := os.Open(dirname)\n+\tif err != nil {\n+\t\treport(err)\n+\t\treturn\n+\t}\n+\tfilenames, err := f.Readdirnames(-1)\n+\tf.Close()\n+\tif err != nil {\n+\t\treport(err)\n+\t\t// continue since filenames may not be empty\n+\t}\n+\tfor i, filename := range filenames {\n+\t\tfilenames[i] = filepath.Join(dirname, filename)\n+\t}\n+\tprocessFiles(filenames, false)\n+}\n+\n+func processFiles(filenames []string, allFiles bool) {\n+\ti := 0\n+\tfor _, filename := range filenames {\n+\t\tswitch info, err := os.Stat(filename); {\n+\t\tcase err != nil:\n+\t\t\treport(err)\n+\t\tcase info.IsRegular():\n+\t\t\tif allFiles || isGoFilename(info.Name) {\n+\t\t\t\tfilenames[i] = filename\n+\t\t\t\ti++\n+\t\t\t}\n+\t\tcase info.IsDirectory():\n+\t\t\tif allFiles || *recursive {\n+\t\t\t\tprocessDirectory(filename)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfset := token.NewFileSet()\n+\tprocessPackage(fset, parseFiles(fset, filenames[0:i]))\n+}\n+\n+func processPackage(fset *token.FileSet, files map[string]*ast.File) {\n+\t// make a package (resolve all identifiers)\n+\tpkg, err := ast.NewPackage(fset, files, types.GcImporter, types.Universe)\n+\tif err != nil {\n+\t\treport(err)\n+\t\treturn\n+\t}\n+\t_, err = types.Check(fset, pkg)\n+\tif err != nil {\n+\t\treport(err)\n+\t}\n+}\n+\n+func main() {\n+\tflag.Usage = usage\n+\tflag.Parse()\n+\n+\tif flag.NArg() == 0 {\n+\t\tfset := token.NewFileSet()\n+\t\tprocessPackage(fset, parseStdin(fset))\n+\t} else {\n+\t\tprocessFiles(flag.Args(), true)\n+\t}\n+\n+\tos.Exit(exitCode)\n+}"}, {"sha": "8732d4c5aa83b7d1b47beae434fd36f267b189a9", "filename": "libgo/go/exp/gotype/gotype_test.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Fgotype_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func runTest(t *testing.T, path, pkg string) {\n+\texitCode = 0\n+\t*pkgName = pkg\n+\t*recursive = false\n+\n+\tif pkg == \"\" {\n+\t\tprocessFiles([]string{path}, true)\n+\t} else {\n+\t\tprocessDirectory(path)\n+\t}\n+\n+\tif exitCode != 0 {\n+\t\tt.Errorf(\"processing %s failed: exitCode = %d\", path, exitCode)\n+\t}\n+}\n+\n+var tests = []struct {\n+\tpath string\n+\tpkg  string\n+}{\n+\t// individual files\n+\t{\"testdata/test1.go\", \"\"},\n+\n+\t// directories\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/ast\"), \"ast\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/doc\"), \"doc\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/token\"), \"scanner\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/scanner\"), \"scanner\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/go/parser\"), \"parser\"},\n+\t{filepath.Join(runtime.GOROOT(), \"src/pkg/exp/types\"), \"types\"},\n+}\n+\n+func Test(t *testing.T) {\n+\tfor _, test := range tests {\n+\t\trunTest(t, test.path, test.pkg)\n+\t}\n+}"}, {"sha": "a3298e6e5fe61d55ae4b18b3c72e2d28c00fe25b", "filename": "libgo/go/exp/gotype/testdata/test1.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgotype%2Ftestdata%2Ftest1.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,23 @@\n+package p\n+\n+func _() {\n+\t// the scope of a local type declaration starts immediately after the type name\n+\ttype T struct{ _ *T }\n+}\n+\n+func _(x interface{}) {\n+\t// the variable defined by a TypeSwitchGuard is declared in each TypeCaseClause\n+\tswitch t := x.(type) {\n+\tcase int:\n+\t\t_ = t\n+\tcase float32:\n+\t\t_ = t\n+\tdefault:\n+\t\t_ = t\n+\t}\n+\n+\t// the variable defined by a TypeSwitchGuard must not conflict with other\n+\t// variables declared in the initial simple statement\n+\tswitch t := 0; t := x.(type) {\n+\t}\n+}"}, {"sha": "bf94bcaabb4d02cfbcacb44f2f35ce658f3c6dd3", "filename": "libgo/go/exp/gui/x11/conn.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -621,7 +621,7 @@ func NewWindowDisplay(display string) (gui.Window, os.Error) {\n \t\treturn nil, err\n \t}\n \n-\tc.img = image.NewRGBA(windowWidth, windowHeight)\n+\tc.img = image.NewRGBA(image.Rect(0, 0, windowWidth, windowHeight))\n \tc.eventc = make(chan interface{}, 16)\n \tc.flush = make(chan bool, 1)\n \tgo c.readSocket()"}, {"sha": "1d722230d6f9da49f37b8442508f38b84337abc8", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -7,27 +7,46 @@ package norm\n import \"utf8\"\n \n const (\n-\tmaxCombiningChars = 30 + 2 // +2 to hold CGJ and Hangul overflow.\n+\tmaxCombiningChars = 30\n+\tmaxBufferSize     = maxCombiningChars + 2 // +1 to hold starter +1 to hold CGJ\n \tmaxBackRunes      = maxCombiningChars - 1\n \tmaxNFCExpansion   = 3  // NFC(0x1D160)\n \tmaxNFKCExpansion  = 18 // NFKC(0xFDFA)\n \n-\tmaxRuneSizeInDecomp = 4\n-\t// Need to multiply by 2 as we don't reuse byte buffer space for recombining.\n-\tmaxByteBufferSize = 2 * maxRuneSizeInDecomp * maxCombiningChars // 256\n+\tmaxByteBufferSize = utf8.UTFMax * maxBufferSize // 128\n )\n \n // reorderBuffer is used to normalize a single segment.  Characters inserted with\n-// insert() are decomposed and reordered based on CCC. The compose() method can\n+// insert are decomposed and reordered based on CCC. The compose method can\n // be used to recombine characters.  Note that the byte buffer does not hold\n // the UTF-8 characters in order.  Only the rune array is maintained in sorted\n-// order. flush() writes the resulting segment to a byte array.\n+// order. flush writes the resulting segment to a byte array.\n type reorderBuffer struct {\n-\trune  [maxCombiningChars]runeInfo // Per character info.\n-\tbyte  [maxByteBufferSize]byte     // UTF-8 buffer. Referenced by runeInfo.pos.\n-\tnrune int                         // Number of runeInfos.\n-\tnbyte uint8                       // Number or bytes.\n+\trune  [maxBufferSize]runeInfo // Per character info.\n+\tbyte  [maxByteBufferSize]byte // UTF-8 buffer. Referenced by runeInfo.pos.\n+\tnrune int                     // Number of runeInfos.\n+\tnbyte uint8                   // Number or bytes.\n \tf     formInfo\n+\n+\tsrc       input\n+\tnsrc      int\n+\tsrcBytes  inputBytes\n+\tsrcString inputString\n+\ttmpBytes  inputBytes\n+}\n+\n+func (rb *reorderBuffer) init(f Form, src []byte) {\n+\trb.f = *formTable[f]\n+\trb.srcBytes = inputBytes(src)\n+\trb.src = &rb.srcBytes\n+\trb.nsrc = len(src)\n+}\n+\n+func (rb *reorderBuffer) initString(f Form, src string) {\n+\trb.f = *formTable[f]\n+\trb.srcString = inputString(src)\n+\trb.src = &rb.srcString\n+\trb.nsrc = len(src)\n }\n \n // reset discards all characters from the buffer.\n@@ -49,10 +68,10 @@ func (rb *reorderBuffer) flush(out []byte) []byte {\n \n // insertOrdered inserts a rune in the buffer, ordered by Canonical Combining Class.\n // It returns false if the buffer is not large enough to hold the rune.\n-// It is used internally by insert.\n+// It is used internally by insert and insertString only.\n func (rb *reorderBuffer) insertOrdered(info runeInfo) bool {\n \tn := rb.nrune\n-\tif n >= maxCombiningChars {\n+\tif n >= maxCombiningChars+1 {\n \t\treturn false\n \t}\n \tb := rb.rune[:]\n@@ -68,61 +87,40 @@ func (rb *reorderBuffer) insertOrdered(info runeInfo) bool {\n \t}\n \trb.nrune += 1\n \tpos := uint8(rb.nbyte)\n-\trb.nbyte += info.size\n+\trb.nbyte += utf8.UTFMax\n \tinfo.pos = pos\n \tb[n] = info\n \treturn true\n }\n \n // insert inserts the given rune in the buffer ordered by CCC.\n // It returns true if the buffer was large enough to hold the decomposed rune.\n-func (rb *reorderBuffer) insert(src []byte, info runeInfo) bool {\n-\tif info.size == 3 && isHangul(src) {\n-\t\trune, _ := utf8.DecodeRune(src)\n-\t\treturn rb.decomposeHangul(uint32(rune))\n-\t}\n-\tpos := rb.nbyte\n-\tif info.flags.hasDecomposition() {\n-\t\tdcomp := rb.f.decompose(src)\n-\t\tfor i := 0; i < len(dcomp); i += int(info.size) {\n-\t\t\tinfo = rb.f.info(dcomp[i:])\n-\t\t\tif !rb.insertOrdered(info) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t\tcopy(rb.byte[pos:], dcomp)\n-\t} else {\n-\t\tif !rb.insertOrdered(info) {\n-\t\t\treturn false\n+func (rb *reorderBuffer) insert(src input, i int, info runeInfo) bool {\n+\tif info.size == 3 {\n+\t\tif rune := src.hangul(i); rune != 0 {\n+\t\t\treturn rb.decomposeHangul(uint32(rune))\n \t\t}\n-\t\tcopy(rb.byte[pos:], src[:info.size])\n \t}\n-\treturn true\n-}\n-\n-// insertString inserts the given rune in the buffer ordered by CCC.\n-// It returns true if the buffer was large enough to hold the decomposed rune.\n-func (rb *reorderBuffer) insertString(src string, info runeInfo) bool {\n-\tif info.size == 3 && isHangulString(src) {\n-\t\trune, _ := utf8.DecodeRuneInString(src)\n-\t\treturn rb.decomposeHangul(uint32(rune))\n-\t}\n-\tpos := rb.nbyte\n-\tdcomp := rb.f.decomposeString(src)\n-\tdn := len(dcomp)\n-\tif dn != 0 {\n-\t\tfor i := 0; i < dn; i += int(info.size) {\n-\t\t\tinfo = rb.f.info(dcomp[i:])\n+\tif info.flags.hasDecomposition() {\n+\t\tdcomp := rb.f.decompose(src, i)\n+\t\trb.tmpBytes = inputBytes(dcomp)\n+\t\tfor i := 0; i < len(dcomp); {\n+\t\t\tinfo = rb.f.info(&rb.tmpBytes, i)\n+\t\t\tpos := rb.nbyte\n \t\t\tif !rb.insertOrdered(info) {\n \t\t\t\treturn false\n \t\t\t}\n+\t\t\tend := i + int(info.size)\n+\t\t\tcopy(rb.byte[pos:], dcomp[i:end])\n+\t\t\ti = end\n \t\t}\n-\t\tcopy(rb.byte[pos:], dcomp)\n \t} else {\n+\t\t// insertOrder changes nbyte\n+\t\tpos := rb.nbyte\n \t\tif !rb.insertOrdered(info) {\n \t\t\treturn false\n \t\t}\n-\t\tcopy(rb.byte[pos:], src[:info.size])\n+\t\tsrc.copySlice(rb.byte[pos:], i, i+int(info.size))\n \t}\n \treturn true\n }\n@@ -131,17 +129,16 @@ func (rb *reorderBuffer) insertString(src string, info runeInfo) bool {\n func (rb *reorderBuffer) appendRune(rune uint32) {\n \tbn := rb.nbyte\n \tsz := utf8.EncodeRune(rb.byte[bn:], int(rune))\n-\trb.nbyte += uint8(sz)\n+\trb.nbyte += utf8.UTFMax\n \trb.rune[rb.nrune] = runeInfo{bn, uint8(sz), 0, 0}\n \trb.nrune++\n }\n \n // assignRune sets a rune at position pos. It is used for Hangul and recomposition.\n func (rb *reorderBuffer) assignRune(pos int, rune uint32) {\n-\tbn := rb.nbyte\n+\tbn := rb.rune[pos].pos\n \tsz := utf8.EncodeRune(rb.byte[bn:], int(rune))\n \trb.rune[pos] = runeInfo{bn, uint8(sz), 0, 0}\n-\trb.nbyte += uint8(sz)\n }\n \n // runeAt returns the rune at position n. It is used for Hangul and recomposition.\n@@ -259,11 +256,10 @@ func (rb *reorderBuffer) decomposeHangul(rune uint32) bool {\n \n // combineHangul algorithmically combines Jamo character components into Hangul.\n // See http://unicode.org/reports/tr15/#Hangul for details on combining Hangul.\n-func (rb *reorderBuffer) combineHangul() {\n-\tk := 1\n+func (rb *reorderBuffer) combineHangul(s, i, k int) {\n \tb := rb.rune[:]\n \tbn := rb.nrune\n-\tfor s, i := 0, 1; i < bn; i++ {\n+\tfor ; i < bn; i++ {\n \t\tcccB := b[k-1].ccc\n \t\tcccC := b[i].ccc\n \t\tif cccB == 0 {\n@@ -305,14 +301,17 @@ func (rb *reorderBuffer) compose() {\n \t//  blocked from S if and only if there is some character B between S\n \t//  and C, and either B is a starter or it has the same or higher\n \t//  combining class as C.\"\n+\tbn := rb.nrune\n+\tif bn == 0 {\n+\t\treturn\n+\t}\n \tk := 1\n \tb := rb.rune[:]\n-\tbn := rb.nrune\n \tfor s, i := 0, 1; i < bn; i++ {\n \t\tif isJamoVT(rb.bytesAt(i)) {\n \t\t\t// Redo from start in Hangul mode. Necessary to support\n \t\t\t// U+320E..U+321E in NFKC mode.\n-\t\t\trb.combineHangul()\n+\t\t\trb.combineHangul(s, i, k)\n \t\t\treturn\n \t\t}\n \t\tii := b[i]"}, {"sha": "ce9caaff160f186431a6c7f8bd6d6cdcc3eb4fd1", "filename": "libgo/go/exp/norm/composition_test.go", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -15,21 +15,19 @@ type TestCase struct {\n type insertFunc func(rb *reorderBuffer, rune int) bool\n \n func insert(rb *reorderBuffer, rune int) bool {\n-\tb := []byte(string(rune))\n-\treturn rb.insert(b, rb.f.info(b))\n+\tsrc := inputString(string(rune))\n+\treturn rb.insert(src, 0, rb.f.info(src, 0))\n }\n \n-func insertString(rb *reorderBuffer, rune int) bool {\n-\ts := string(rune)\n-\treturn rb.insertString(s, rb.f.infoString(s))\n-}\n-\n-func runTests(t *testing.T, name string, rb *reorderBuffer, f insertFunc, tests []TestCase) {\n+func runTests(t *testing.T, name string, fm Form, f insertFunc, tests []TestCase) {\n+\trb := reorderBuffer{}\n+\trb.init(fm, nil)\n \tfor i, test := range tests {\n \t\trb.reset()\n \t\tfor j, rune := range test.in {\n \t\t\tb := []byte(string(rune))\n-\t\t\tif !rb.insert(b, rb.f.info(b)) {\n+\t\t\tsrc := inputBytes(b)\n+\t\t\tif !rb.insert(src, 0, rb.f.info(src, 0)) {\n \t\t\t\tt.Errorf(\"%s:%d: insert failed for rune %d\", name, i, j)\n \t\t\t}\n \t\t}\n@@ -50,7 +48,8 @@ func runTests(t *testing.T, name string, rb *reorderBuffer, f insertFunc, tests\n }\n \n func TestFlush(t *testing.T) {\n-\trb := &reorderBuffer{f: *formTable[NFC]}\n+\trb := reorderBuffer{}\n+\trb.init(NFC, nil)\n \tout := make([]byte, 0)\n \n \tout = rb.flush(out)\n@@ -59,7 +58,7 @@ func TestFlush(t *testing.T) {\n \t}\n \n \tfor _, r := range []int(\"world!\") {\n-\t\tinsert(rb, r)\n+\t\tinsert(&rb, r)\n \t}\n \n \tout = []byte(\"Hello \")\n@@ -88,13 +87,7 @@ var insertTests = []TestCase{\n }\n \n func TestInsert(t *testing.T) {\n-\trb := &reorderBuffer{f: *formTable[NFD]}\n-\trunTests(t, \"TestInsert\", rb, insert, insertTests)\n-}\n-\n-func TestInsertString(t *testing.T) {\n-\trb := &reorderBuffer{f: *formTable[NFD]}\n-\trunTests(t, \"TestInsertString\", rb, insertString, insertTests)\n+\trunTests(t, \"TestInsert\", NFD, insert, insertTests)\n }\n \n var decompositionNFDTest = []TestCase{\n@@ -113,11 +106,8 @@ var decompositionNFKDTest = []TestCase{\n }\n \n func TestDecomposition(t *testing.T) {\n-\trb := &reorderBuffer{}\n-\trb.f = *formTable[NFD]\n-\trunTests(t, \"TestDecompositionNFD\", rb, insert, decompositionNFDTest)\n-\trb.f = *formTable[NFKD]\n-\trunTests(t, \"TestDecompositionNFKD\", rb, insert, decompositionNFKDTest)\n+\trunTests(t, \"TestDecompositionNFD\", NFD, insert, decompositionNFDTest)\n+\trunTests(t, \"TestDecompositionNFKD\", NFKD, insert, decompositionNFKDTest)\n }\n \n var compositionTest = []TestCase{\n@@ -133,6 +123,5 @@ var compositionTest = []TestCase{\n }\n \n func TestComposition(t *testing.T) {\n-\trb := &reorderBuffer{f: *formTable[NFC]}\n-\trunTests(t, \"TestComposition\", rb, insert, compositionTest)\n+\trunTests(t, \"TestComposition\", NFC, insert, compositionTest)\n }"}, {"sha": "d06a00602f84fcbf6ddcf52baec96a9d07764da3", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -15,23 +15,19 @@ type runeInfo struct {\n \n // functions dispatchable per form\n type boundaryFunc func(f *formInfo, info runeInfo) bool\n-type lookupFunc func(b []byte) runeInfo\n-type lookupFuncString func(s string) runeInfo\n-type decompFunc func(b []byte) []byte\n-type decompFuncString func(s string) []byte\n+type lookupFunc func(b input, i int) runeInfo\n+type decompFunc func(b input, i int) []byte\n \n // formInfo holds Form-specific functions and tables.\n type formInfo struct {\n \tform Form\n \n \tcomposing, compatibility bool // form type\n \n-\tdecompose       decompFunc\n-\tdecomposeString decompFuncString\n-\tinfo            lookupFunc\n-\tinfoString      lookupFuncString\n-\tboundaryBefore  boundaryFunc\n-\tboundaryAfter   boundaryFunc\n+\tdecompose      decompFunc\n+\tinfo           lookupFunc\n+\tboundaryBefore boundaryFunc\n+\tboundaryAfter  boundaryFunc\n }\n \n var formTable []*formInfo\n@@ -46,14 +42,10 @@ func init() {\n \t\tif Form(i) == NFKD || Form(i) == NFKC {\n \t\t\tf.compatibility = true\n \t\t\tf.decompose = decomposeNFKC\n-\t\t\tf.decomposeString = decomposeStringNFKC\n \t\t\tf.info = lookupInfoNFKC\n-\t\t\tf.infoString = lookupInfoStringNFKC\n \t\t} else {\n \t\t\tf.decompose = decomposeNFC\n-\t\t\tf.decomposeString = decomposeStringNFC\n \t\t\tf.info = lookupInfoNFC\n-\t\t\tf.infoString = lookupInfoStringNFC\n \t\t}\n \t\tif Form(i) == NFC || Form(i) == NFKC {\n \t\t\tf.composing = true\n@@ -77,7 +69,7 @@ func decompBoundary(f *formInfo, info runeInfo) bool {\n }\n \n func compBoundaryBefore(f *formInfo, info runeInfo) bool {\n-\tif info.ccc == 0 && info.flags.isYesC() {\n+\tif info.ccc == 0 && !info.flags.combinesBackward() {\n \t\treturn true\n \t}\n \t// We assume that the CCC of the first character in a decomposition\n@@ -89,9 +81,7 @@ func compBoundaryBefore(f *formInfo, info runeInfo) bool {\n func compBoundaryAfter(f *formInfo, info runeInfo) bool {\n \t// This misses values where the last char in a decomposition is a\n \t// boundary such as Hangul with JamoT.\n-\t// TODO(mpvl): verify this does not lead to segments that do\n-\t// not fit in the reorderBuffer.\n-\treturn info.flags.isInert()\n+\treturn info.isInert()\n }\n \n // We pack quick check data in 4 bits:\n@@ -110,41 +100,30 @@ func (i qcInfo) isNoC() bool   { return i&0x6 == 0x2 }\n func (i qcInfo) isMaybe() bool { return i&0x4 != 0 }\n func (i qcInfo) isYesD() bool  { return i&0x1 == 0 }\n func (i qcInfo) isNoD() bool   { return i&0x1 != 0 }\n-func (i qcInfo) isInert() bool { return i&0xf == 0 }\n \n func (i qcInfo) combinesForward() bool  { return i&0x8 != 0 }\n func (i qcInfo) combinesBackward() bool { return i&0x4 != 0 } // == isMaybe\n func (i qcInfo) hasDecomposition() bool { return i&0x1 != 0 } // == isNoD\n \n+func (r runeInfo) isInert() bool {\n+\treturn r.flags&0xf == 0 && r.ccc == 0\n+}\n+\n // Wrappers for tables.go\n \n // The 16-bit value of the decompostion tries is an index into a byte\n // array of UTF-8 decomposition sequences. The first byte is the number\n // of bytes in the decomposition (excluding this length byte). The actual\n // sequence starts at the offset+1.\n-func decomposeNFC(b []byte) []byte {\n-\tp := nfcDecompTrie.lookupUnsafe(b)\n-\tn := decomps[p]\n-\tp++\n-\treturn decomps[p : p+uint16(n)]\n-}\n-\n-func decomposeNFKC(b []byte) []byte {\n-\tp := nfkcDecompTrie.lookupUnsafe(b)\n-\tn := decomps[p]\n-\tp++\n-\treturn decomps[p : p+uint16(n)]\n-}\n-\n-func decomposeStringNFC(s string) []byte {\n-\tp := nfcDecompTrie.lookupStringUnsafe(s)\n+func decomposeNFC(s input, i int) []byte {\n+\tp := s.decomposeNFC(i)\n \tn := decomps[p]\n \tp++\n \treturn decomps[p : p+uint16(n)]\n }\n \n-func decomposeStringNFKC(s string) []byte {\n-\tp := nfkcDecompTrie.lookupStringUnsafe(s)\n+func decomposeNFKC(s input, i int) []byte {\n+\tp := s.decomposeNFKC(i)\n \tn := decomps[p]\n \tp++\n \treturn decomps[p : p+uint16(n)]\n@@ -167,22 +146,12 @@ func combine(a, b uint32) uint32 {\n //    0..7   CCC value.\n //    8..11  qcInfo for NFC/NFD\n //   12..15  qcInfo for NFKC/NFKD\n-func lookupInfoNFC(b []byte) runeInfo {\n-\tv, sz := charInfoTrie.lookup(b)\n+func lookupInfoNFC(b input, i int) runeInfo {\n+\tv, sz := b.charinfo(i)\n \treturn runeInfo{0, uint8(sz), uint8(v), qcInfo(v >> 8)}\n }\n \n-func lookupInfoStringNFC(s string) runeInfo {\n-\tv, sz := charInfoTrie.lookupString(s)\n-\treturn runeInfo{0, uint8(sz), uint8(v), qcInfo(v >> 8)}\n-}\n-\n-func lookupInfoNFKC(b []byte) runeInfo {\n-\tv, sz := charInfoTrie.lookup(b)\n-\treturn runeInfo{0, uint8(sz), uint8(v), qcInfo(v >> 12)}\n-}\n-\n-func lookupInfoStringNFKC(s string) runeInfo {\n-\tv, sz := charInfoTrie.lookupString(s)\n+func lookupInfoNFKC(b input, i int) runeInfo {\n+\tv, sz := b.charinfo(i)\n \treturn runeInfo{0, uint8(sz), uint8(v), qcInfo(v >> 12)}\n }"}, {"sha": "12360a8fda1e22419d69ae1cf3de144c6e90ef45", "filename": "libgo/go/exp/norm/input.go", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm\n+\n+import \"utf8\"\n+\n+type input interface {\n+\tskipASCII(p int) int\n+\tskipNonStarter() int\n+\tappendSlice(buf []byte, s, e int) []byte\n+\tcopySlice(buf []byte, s, e int)\n+\tcharinfo(p int) (uint16, int)\n+\tdecomposeNFC(p int) uint16\n+\tdecomposeNFKC(p int) uint16\n+\thangul(p int) uint32\n+}\n+\n+type inputString string\n+\n+func (s inputString) skipASCII(p int) int {\n+\tfor ; p < len(s) && s[p] < utf8.RuneSelf; p++ {\n+\t}\n+\treturn p\n+}\n+\n+func (s inputString) skipNonStarter() int {\n+\tp := 0\n+\tfor ; p < len(s) && !utf8.RuneStart(s[p]); p++ {\n+\t}\n+\treturn p\n+}\n+\n+func (s inputString) appendSlice(buf []byte, b, e int) []byte {\n+\tfor i := b; i < e; i++ {\n+\t\tbuf = append(buf, s[i])\n+\t}\n+\treturn buf\n+}\n+\n+func (s inputString) copySlice(buf []byte, b, e int) {\n+\tcopy(buf, s[b:e])\n+}\n+\n+func (s inputString) charinfo(p int) (uint16, int) {\n+\treturn charInfoTrie.lookupString(string(s[p:]))\n+}\n+\n+func (s inputString) decomposeNFC(p int) uint16 {\n+\treturn nfcDecompTrie.lookupStringUnsafe(string(s[p:]))\n+}\n+\n+func (s inputString) decomposeNFKC(p int) uint16 {\n+\treturn nfkcDecompTrie.lookupStringUnsafe(string(s[p:]))\n+}\n+\n+func (s inputString) hangul(p int) uint32 {\n+\tif !isHangulString(string(s[p:])) {\n+\t\treturn 0\n+\t}\n+\trune, _ := utf8.DecodeRuneInString(string(s[p:]))\n+\treturn uint32(rune)\n+}\n+\n+type inputBytes []byte\n+\n+func (s inputBytes) skipASCII(p int) int {\n+\tfor ; p < len(s) && s[p] < utf8.RuneSelf; p++ {\n+\t}\n+\treturn p\n+}\n+\n+func (s inputBytes) skipNonStarter() int {\n+\tp := 0\n+\tfor ; p < len(s) && !utf8.RuneStart(s[p]); p++ {\n+\t}\n+\treturn p\n+}\n+\n+func (s inputBytes) appendSlice(buf []byte, b, e int) []byte {\n+\treturn append(buf, s[b:e]...)\n+}\n+\n+func (s inputBytes) copySlice(buf []byte, b, e int) {\n+\tcopy(buf, s[b:e])\n+}\n+\n+func (s inputBytes) charinfo(p int) (uint16, int) {\n+\treturn charInfoTrie.lookup(s[p:])\n+}\n+\n+func (s inputBytes) decomposeNFC(p int) uint16 {\n+\treturn nfcDecompTrie.lookupUnsafe(s[p:])\n+}\n+\n+func (s inputBytes) decomposeNFKC(p int) uint16 {\n+\treturn nfkcDecompTrie.lookupUnsafe(s[p:])\n+}\n+\n+func (s inputBytes) hangul(p int) uint32 {\n+\tif !isHangul(s[p:]) {\n+\t\treturn 0\n+\t}\n+\trune, _ := utf8.DecodeRune(s[p:])\n+\treturn uint32(rune)\n+}"}, {"sha": "14718c5cd226a48ebf81bafa3d29d60b449b2343", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -515,9 +515,13 @@ func completeCharFields(form int) {\n \t\t\tf.quickCheck[MComposed] = QCNo\n \t\tcase (i & 0xffff00) == JamoLBase:\n \t\t\tf.quickCheck[MComposed] = QCYes\n+\t\t\tif JamoLBase <= i && i < JamoLEnd {\n+\t\t\t\tf.combinesForward = true\n+\t\t\t}\n \t\t\tif JamoVBase <= i && i < JamoVEnd {\n \t\t\t\tf.quickCheck[MComposed] = QCMaybe\n \t\t\t\tf.combinesBackward = true\n+\t\t\t\tf.combinesForward = true\n \t\t\t}\n \t\t\tif JamoTBase <= i && i < JamoTEnd {\n \t\t\t\tf.quickCheck[MComposed] = QCMaybe\n@@ -562,7 +566,7 @@ func makeEntry(f *FormInfo) uint16 {\n \tcase QCMaybe:\n \t\te |= 0x6\n \tdefault:\n-\t\tlog.Fatalf(\"Illegal quickcheck value %d.\", f.quickCheck[MComposed])\n+\t\tlog.Fatalf(\"Illegal quickcheck value %v.\", f.quickCheck[MComposed])\n \t}\n \treturn e\n }"}, {"sha": "fdcc114be23f967d77813bda94dbd1ea5bc0d1ff", "filename": "libgo/go/exp/norm/maketesttables.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -21,6 +21,7 @@ var testRunes = []int{\n \t0x80, 0x100, 0x7FF, // 2-byte sequences\n \t0x800, 0x999, 0xFFFF, // 3-byte sequences\n \t0x10000, 0x10101, 0x10FFFF, // 4-byte sequences\n+\t0x200, 0x201, 0x202, 0x210, 0x215, // five entries in one sparse block\n }\n \n const fileHeader = `// Generated by running"}, {"sha": "391bc4184f26bede29f42cd065d6ca7ad89ead8e", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 393, "deletions": 28, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -5,6 +5,8 @@\n // Package norm contains types and functions for normalizing Unicode strings.\n package norm\n \n+import \"utf8\"\n+\n // A Form denotes a canonical representation of Unicode code points.\n // The Unicode-defined normalization and equivalence forms are:\n //\n@@ -32,68 +34,431 @@ const (\n \n // Bytes returns f(b). May return b if f(b) = b.\n func (f Form) Bytes(b []byte) []byte {\n-\tpanic(\"not implemented\")\n+\tn := f.QuickSpan(b)\n+\tif n == len(b) {\n+\t\treturn b\n+\t}\n+\tout := make([]byte, n, len(b))\n+\tcopy(out, b[0:n])\n+\treturn f.Append(out, b[n:]...)\n }\n \n // String returns f(s).\n func (f Form) String(s string) string {\n-\tpanic(\"not implemented\")\n+\tn := f.QuickSpanString(s)\n+\tif n == len(s) {\n+\t\treturn s\n+\t}\n+\tout := make([]byte, 0, len(s))\n+\tcopy(out, s[0:n])\n+\treturn string(f.AppendString(out, s[n:]))\n }\n \n // IsNormal returns true if b == f(b).\n func (f Form) IsNormal(b []byte) bool {\n-\tpanic(\"not implemented\")\n+\trb := reorderBuffer{}\n+\trb.init(f, b)\n+\tbp := quickSpan(&rb, 0)\n+\tif bp == len(b) {\n+\t\treturn true\n+\t}\n+\tfor bp < len(b) {\n+\t\tdecomposeSegment(&rb, bp)\n+\t\tif rb.f.composing {\n+\t\t\trb.compose()\n+\t\t}\n+\t\tfor i := 0; i < rb.nrune; i++ {\n+\t\t\tinfo := rb.rune[i]\n+\t\t\tif bp+int(info.size) > len(b) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tp := info.pos\n+\t\t\tpe := p + info.size\n+\t\t\tfor ; p < pe; p++ {\n+\t\t\t\tif b[bp] != rb.byte[p] {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tbp++\n+\t\t\t}\n+\t\t}\n+\t\trb.reset()\n+\t\tbp = quickSpan(&rb, bp)\n+\t}\n+\treturn true\n }\n \n // IsNormalString returns true if s == f(s).\n func (f Form) IsNormalString(s string) bool {\n-\tpanic(\"not implemented\")\n+\trb := reorderBuffer{}\n+\trb.initString(f, s)\n+\tbp := quickSpan(&rb, 0)\n+\tif bp == len(s) {\n+\t\treturn true\n+\t}\n+\tfor bp < len(s) {\n+\t\tdecomposeSegment(&rb, bp)\n+\t\tif rb.f.composing {\n+\t\t\trb.compose()\n+\t\t}\n+\t\tfor i := 0; i < rb.nrune; i++ {\n+\t\t\tinfo := rb.rune[i]\n+\t\t\tif bp+int(info.size) > len(s) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tp := info.pos\n+\t\t\tpe := p + info.size\n+\t\t\tfor ; p < pe; p++ {\n+\t\t\t\tif s[bp] != rb.byte[p] {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tbp++\n+\t\t\t}\n+\t\t}\n+\t\trb.reset()\n+\t\tbp = quickSpan(&rb, bp)\n+\t}\n+\treturn true\n+}\n+\n+// patchTail fixes a case where a rune may be incorrectly normalized\n+// if it is followed by illegal continuation bytes. It returns the\n+// patched buffer and the number of trailing continuation bytes that\n+// have been dropped.\n+func patchTail(rb *reorderBuffer, buf []byte) ([]byte, int) {\n+\tinfo, p := lastRuneStart(&rb.f, buf)\n+\tif p == -1 || info.size == 0 {\n+\t\treturn buf, 0\n+\t}\n+\tend := p + int(info.size)\n+\textra := len(buf) - end\n+\tif extra > 0 {\n+\t\tbuf = decomposeToLastBoundary(rb, buf[:end])\n+\t\tif rb.f.composing {\n+\t\t\trb.compose()\n+\t\t}\n+\t\treturn rb.flush(buf), extra\n+\t}\n+\treturn buf, 0\n+}\n+\n+func appendQuick(rb *reorderBuffer, dst []byte, i int) ([]byte, int) {\n+\tif rb.nsrc == i {\n+\t\treturn dst, i\n+\t}\n+\tend := quickSpan(rb, i)\n+\treturn rb.src.appendSlice(dst, i, end), end\n }\n \n // Append returns f(append(out, b...)).\n-// The buffer out must be empty or equal to f(out).\n-func (f Form) Append(out, b []byte) []byte {\n-\tpanic(\"not implemented\")\n+// The buffer out must be nil, empty, or equal to f(out).\n+func (f Form) Append(out []byte, src ...byte) []byte {\n+\tif len(src) == 0 {\n+\t\treturn out\n+\t}\n+\trb := reorderBuffer{}\n+\trb.init(f, src)\n+\treturn doAppend(&rb, out)\n+}\n+\n+func doAppend(rb *reorderBuffer, out []byte) []byte {\n+\tsrc, n := rb.src, rb.nsrc\n+\tdoMerge := len(out) > 0\n+\tp := 0\n+\tif p = src.skipNonStarter(); p > 0 {\n+\t\t// Move leading non-starters to destination.\n+\t\tout = src.appendSlice(out, 0, p)\n+\t\tbuf, ndropped := patchTail(rb, out)\n+\t\tif ndropped > 0 {\n+\t\t\tout = src.appendSlice(buf, p-ndropped, p)\n+\t\t\tdoMerge = false // no need to merge, ends with illegal UTF-8\n+\t\t} else {\n+\t\t\tout = decomposeToLastBoundary(rb, buf) // force decomposition\n+\t\t}\n+\t}\n+\tfd := &rb.f\n+\tif doMerge {\n+\t\tvar info runeInfo\n+\t\tif p < n {\n+\t\t\tinfo = fd.info(src, p)\n+\t\t\tif p == 0 && !fd.boundaryBefore(fd, info) {\n+\t\t\t\tout = decomposeToLastBoundary(rb, out)\n+\t\t\t}\n+\t\t}\n+\t\tif info.size == 0 || fd.boundaryBefore(fd, info) {\n+\t\t\tif fd.composing {\n+\t\t\t\trb.compose()\n+\t\t\t}\n+\t\t\tout = rb.flush(out)\n+\t\t\tif info.size == 0 {\n+\t\t\t\t// Append incomplete UTF-8 encoding.\n+\t\t\t\treturn src.appendSlice(out, p, n)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif rb.nrune == 0 {\n+\t\tout, p = appendQuick(rb, out, p)\n+\t}\n+\tfor p < n {\n+\t\tp = decomposeSegment(rb, p)\n+\t\tif fd.composing {\n+\t\t\trb.compose()\n+\t\t}\n+\t\tout = rb.flush(out)\n+\t\tout, p = appendQuick(rb, out, p)\n+\t}\n+\treturn out\n }\n \n // AppendString returns f(append(out, []byte(s))).\n-// The buffer out must be empty or equal to f(out).\n-func (f Form) AppendString(out []byte, s string) []byte {\n-\tpanic(\"not implemented\")\n+// The buffer out must be nil, empty, or equal to f(out).\n+func (f Form) AppendString(out []byte, src string) []byte {\n+\tif len(src) == 0 {\n+\t\treturn out\n+\t}\n+\trb := reorderBuffer{}\n+\trb.initString(f, src)\n+\treturn doAppend(&rb, out)\n }\n \n // QuickSpan returns a boundary n such that b[0:n] == f(b[0:n]).\n // It is not guaranteed to return the largest such n.\n func (f Form) QuickSpan(b []byte) int {\n-\tpanic(\"not implemented\")\n+\trb := reorderBuffer{}\n+\trb.init(f, b)\n+\treturn quickSpan(&rb, 0)\n+}\n+\n+func quickSpan(rb *reorderBuffer, i int) int {\n+\tvar lastCC uint8\n+\tvar nc int\n+\tlastSegStart := i\n+\tsrc, n := rb.src, rb.nsrc\n+\tfor i < n {\n+\t\tif j := src.skipASCII(i); i != j {\n+\t\t\ti = j\n+\t\t\tlastSegStart = i - 1\n+\t\t\tlastCC = 0\n+\t\t\tnc = 0\n+\t\t\tcontinue\n+\t\t}\n+\t\tinfo := rb.f.info(src, i)\n+\t\tif info.size == 0 {\n+\t\t\t// include incomplete runes\n+\t\t\treturn n\n+\t\t}\n+\t\tcc := info.ccc\n+\t\tif rb.f.composing {\n+\t\t\tif !info.flags.isYesC() {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif !info.flags.isYesD() {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif cc == 0 {\n+\t\t\tlastSegStart = i\n+\t\t\tnc = 0\n+\t\t} else {\n+\t\t\tif nc >= maxCombiningChars {\n+\t\t\t\tlastSegStart = i\n+\t\t\t\tlastCC = cc\n+\t\t\t\tnc = 1\n+\t\t\t} else {\n+\t\t\t\tif lastCC > cc {\n+\t\t\t\t\treturn lastSegStart\n+\t\t\t\t}\n+\t\t\t\tnc++\n+\t\t\t}\n+\t\t}\n+\t\tlastCC = cc\n+\t\ti += int(info.size)\n+\t}\n+\tif i == n {\n+\t\treturn n\n+\t}\n+\tif rb.f.composing {\n+\t\treturn lastSegStart\n+\t}\n+\treturn i\n }\n \n // QuickSpanString returns a boundary n such that b[0:n] == f(s[0:n]).\n // It is not guaranteed to return the largest such n.\n func (f Form) QuickSpanString(s string) int {\n-\tpanic(\"not implemented\")\n+\trb := reorderBuffer{}\n+\trb.initString(f, s)\n+\treturn quickSpan(&rb, 0)\n+}\n+\n+// FirstBoundary returns the position i of the first boundary in b\n+// or -1 if b contains no boundary.\n+func (f Form) FirstBoundary(b []byte) int {\n+\trb := reorderBuffer{}\n+\trb.init(f, b)\n+\treturn firstBoundary(&rb)\n+}\n+\n+func firstBoundary(rb *reorderBuffer) int {\n+\tsrc, nsrc := rb.src, rb.nsrc\n+\ti := src.skipNonStarter()\n+\tif i >= nsrc {\n+\t\treturn -1\n+\t}\n+\tfd := &rb.f\n+\tinfo := fd.info(src, i)\n+\tfor n := 0; info.size != 0 && !fd.boundaryBefore(fd, info); {\n+\t\ti += int(info.size)\n+\t\tif n++; n >= maxCombiningChars {\n+\t\t\treturn i\n+\t\t}\n+\t\tif i >= nsrc {\n+\t\t\tif !fd.boundaryAfter(fd, info) {\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\treturn nsrc\n+\t\t}\n+\t\tinfo = fd.info(src, i)\n+\t}\n+\tif info.size == 0 {\n+\t\treturn -1\n+\t}\n+\treturn i\n+}\n+\n+// FirstBoundaryInString returns the position i of the first boundary in s\n+// or -1 if s contains no boundary.\n+func (f Form) FirstBoundaryInString(s string) int {\n+\trb := reorderBuffer{}\n+\trb.initString(f, s)\n+\treturn firstBoundary(&rb)\n+}\n+\n+// LastBoundary returns the position i of the last boundary in b\n+// or -1 if b contains no boundary.\n+func (f Form) LastBoundary(b []byte) int {\n+\treturn lastBoundary(formTable[f], b)\n }\n \n-// FirstBoundary returns the position i of the first boundary in b.\n-// It returns len(b), false if b contains no boundaries.\n-func (f Form) FirstBoundary(b []byte) (i int, ok bool) {\n-\tpanic(\"not implemented\")\n+func lastBoundary(fd *formInfo, b []byte) int {\n+\ti := len(b)\n+\tinfo, p := lastRuneStart(fd, b)\n+\tif p == -1 {\n+\t\treturn -1\n+\t}\n+\tif info.size == 0 { // ends with incomplete rune\n+\t\tif p == 0 { // starts wtih incomplete rune\n+\t\t\treturn -1\n+\t\t}\n+\t\ti = p\n+\t\tinfo, p = lastRuneStart(fd, b[:i])\n+\t\tif p == -1 { // incomplete UTF-8 encoding or non-starter bytes without a starter\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\tif p+int(info.size) != i { // trailing non-starter bytes: illegal UTF-8\n+\t\treturn i\n+\t}\n+\tif fd.boundaryAfter(fd, info) {\n+\t\treturn i\n+\t}\n+\ti = p\n+\tfor n := 0; i >= 0 && !fd.boundaryBefore(fd, info); {\n+\t\tinfo, p = lastRuneStart(fd, b[:i])\n+\t\tif n++; n >= maxCombiningChars {\n+\t\t\treturn len(b)\n+\t\t}\n+\t\tif p+int(info.size) != i {\n+\t\t\tif p == -1 { // no boundary found\n+\t\t\t\treturn -1\n+\t\t\t}\n+\t\t\treturn i // boundary after an illegal UTF-8 encoding\n+\t\t}\n+\t\ti = p\n+\t}\n+\treturn i\n }\n \n-// FirstBoundaryInString return the position i of the first boundary in s.\n-// It returns len(s), false if s contains no boundaries.\n-func (f Form) FirstBoundaryInString(s string) (i int, ok bool) {\n-\tpanic(\"not implemented\")\n+// decomposeSegment scans the first segment in src into rb.\n+// It returns the number of bytes consumed from src.\n+// TODO(mpvl): consider inserting U+034f (Combining Grapheme Joiner)\n+// when we detect a sequence of 30+ non-starter chars.\n+func decomposeSegment(rb *reorderBuffer, sp int) int {\n+\t// Force one character to be consumed.\n+\tinfo := rb.f.info(rb.src, sp)\n+\tif info.size == 0 {\n+\t\treturn 0\n+\t}\n+\tfor rb.insert(rb.src, sp, info) {\n+\t\tsp += int(info.size)\n+\t\tif sp >= rb.nsrc {\n+\t\t\tbreak\n+\t\t}\n+\t\tinfo = rb.f.info(rb.src, sp)\n+\t\tbound := rb.f.boundaryBefore(&rb.f, info)\n+\t\tif bound || info.size == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn sp\n }\n \n-// LastBoundaryIn returns the position i of the last boundary in b.\n-// It returns 0, false if b contains no boundary.\n-func (f Form) LastBoundary(b []byte) (i int, ok bool) {\n-\tpanic(\"not implemented\")\n+// lastRuneStart returns the runeInfo and position of the last\n+// rune in buf or the zero runeInfo and -1 if no rune was found.\n+func lastRuneStart(fd *formInfo, buf []byte) (runeInfo, int) {\n+\tp := len(buf) - 1\n+\tfor ; p >= 0 && !utf8.RuneStart(buf[p]); p-- {\n+\t}\n+\tif p < 0 {\n+\t\treturn runeInfo{0, 0, 0, 0}, -1\n+\t}\n+\treturn fd.info(inputBytes(buf), p), p\n }\n \n-// LastBoundaryInString returns the position i of the last boundary in s.\n-// It returns 0, false if s contains no boundary.\n-func (f Form) LastBoundaryInString(s string) (i int, ok bool) {\n-\tpanic(\"not implemented\")\n+// decomposeToLastBoundary finds an open segment at the end of the buffer\n+// and scans it into rb. Returns the buffer minus the last segment.\n+func decomposeToLastBoundary(rb *reorderBuffer, buf []byte) []byte {\n+\tfd := &rb.f\n+\tinfo, i := lastRuneStart(fd, buf)\n+\tif int(info.size) != len(buf)-i {\n+\t\t// illegal trailing continuation bytes\n+\t\treturn buf\n+\t}\n+\tif rb.f.boundaryAfter(fd, info) {\n+\t\treturn buf\n+\t}\n+\tvar add [maxBackRunes]runeInfo // stores runeInfo in reverse order\n+\tadd[0] = info\n+\tpadd := 1\n+\tn := 1\n+\tp := len(buf) - int(info.size)\n+\tfor ; p >= 0 && !rb.f.boundaryBefore(fd, info); p -= int(info.size) {\n+\t\tinfo, i = lastRuneStart(fd, buf[:p])\n+\t\tif int(info.size) != p-i {\n+\t\t\tbreak\n+\t\t}\n+\t\t// Check that decomposition doesn't result in overflow.\n+\t\tif info.flags.hasDecomposition() {\n+\t\t\tdcomp := rb.f.decompose(inputBytes(buf), p-int(info.size))\n+\t\t\tfor i := 0; i < len(dcomp); {\n+\t\t\t\tinf := rb.f.info(inputBytes(dcomp), i)\n+\t\t\t\ti += int(inf.size)\n+\t\t\t\tn++\n+\t\t\t}\n+\t\t} else {\n+\t\t\tn++\n+\t\t}\n+\t\tif n > maxBackRunes {\n+\t\t\tbreak\n+\t\t}\n+\t\tadd[padd] = info\n+\t\tpadd++\n+\t}\n+\tpp := p\n+\tfor padd--; padd >= 0; padd-- {\n+\t\tinfo = add[padd]\n+\t\trb.insert(inputBytes(buf), pp, info)\n+\t\tpp += int(info.size)\n+\t}\n+\treturn buf[:p]\n }"}, {"sha": "e374edf0abb43d585be0e830a792bbde7741f6e5", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,644 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+type PositionTest struct {\n+\tinput  string\n+\tpos    int\n+\tbuffer string // expected contents of reorderBuffer, if applicable\n+}\n+\n+type positionFunc func(rb *reorderBuffer, s string) int\n+\n+func runPosTests(t *testing.T, name string, f Form, fn positionFunc, tests []PositionTest) {\n+\trb := reorderBuffer{}\n+\trb.init(f, nil)\n+\tfor i, test := range tests {\n+\t\trb.reset()\n+\t\trb.src = inputString(test.input)\n+\t\trb.nsrc = len(test.input)\n+\t\tpos := fn(&rb, test.input)\n+\t\tif pos != test.pos {\n+\t\t\tt.Errorf(\"%s:%d: position is %d; want %d\", name, i, pos, test.pos)\n+\t\t}\n+\t\trunes := []int(test.buffer)\n+\t\tif rb.nrune != len(runes) {\n+\t\t\tt.Errorf(\"%s:%d: reorder buffer lenght is %d; want %d\", name, i, rb.nrune, len(runes))\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor j, want := range runes {\n+\t\t\tfound := int(rb.runeAt(j))\n+\t\t\tif found != want {\n+\t\t\t\tt.Errorf(\"%s:%d: rune at %d is %U; want %U\", name, i, j, found, want)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var decomposeSegmentTests = []PositionTest{\n+\t// illegal runes\n+\t{\"\\xC0\", 0, \"\"},\n+\t{\"\\u00E0\\x80\", 2, \"\\u0061\\u0300\"},\n+\t// starter\n+\t{\"a\", 1, \"a\"},\n+\t{\"ab\", 1, \"a\"},\n+\t// starter + composing\n+\t{\"a\\u0300\", 3, \"a\\u0300\"},\n+\t{\"a\\u0300b\", 3, \"a\\u0300\"},\n+\t// with decomposition\n+\t{\"\\u00C0\", 2, \"A\\u0300\"},\n+\t{\"\\u00C0b\", 2, \"A\\u0300\"},\n+\t// long\n+\t{strings.Repeat(\"\\u0300\", 31), 62, strings.Repeat(\"\\u0300\", 31)},\n+\t// ends with incomplete UTF-8 encoding\n+\t{\"\\xCC\", 0, \"\"},\n+\t{\"\\u0300\\xCC\", 2, \"\\u0300\"},\n+}\n+\n+func decomposeSegmentF(rb *reorderBuffer, s string) int {\n+\trb.src = inputString(s)\n+\trb.nsrc = len(s)\n+\treturn decomposeSegment(rb, 0)\n+}\n+\n+func TestDecomposeSegment(t *testing.T) {\n+\trunPosTests(t, \"TestDecomposeSegment\", NFC, decomposeSegmentF, decomposeSegmentTests)\n+}\n+\n+var firstBoundaryTests = []PositionTest{\n+\t// no boundary\n+\t{\"\", -1, \"\"},\n+\t{\"\\u0300\", -1, \"\"},\n+\t{\"\\x80\\x80\", -1, \"\"},\n+\t// illegal runes\n+\t{\"\\xff\", 0, \"\"},\n+\t{\"\\u0300\\xff\", 2, \"\"},\n+\t{\"\\u0300\\xc0\\x80\\x80\", 2, \"\"},\n+\t// boundaries\n+\t{\"a\", 0, \"\"},\n+\t{\"\\u0300a\", 2, \"\"},\n+\t// Hangul\n+\t{\"\\u1103\\u1161\", 0, \"\"},\n+\t{\"\\u110B\\u1173\\u11B7\", 0, \"\"},\n+\t{\"\\u1161\\u110B\\u1173\\u11B7\", 3, \"\"},\n+\t{\"\\u1173\\u11B7\\u1103\\u1161\", 6, \"\"},\n+\t// too many combining characters.\n+\t{strings.Repeat(\"\\u0300\", maxCombiningChars-1), -1, \"\"},\n+\t{strings.Repeat(\"\\u0300\", maxCombiningChars), 60, \"\"},\n+\t{strings.Repeat(\"\\u0300\", maxCombiningChars+1), 60, \"\"},\n+}\n+\n+func firstBoundaryF(rb *reorderBuffer, s string) int {\n+\treturn rb.f.form.FirstBoundary([]byte(s))\n+}\n+\n+func firstBoundaryStringF(rb *reorderBuffer, s string) int {\n+\treturn rb.f.form.FirstBoundaryInString(s)\n+}\n+\n+func TestFirstBoundary(t *testing.T) {\n+\trunPosTests(t, \"TestFirstBoundary\", NFC, firstBoundaryF, firstBoundaryTests)\n+\trunPosTests(t, \"TestFirstBoundaryInString\", NFC, firstBoundaryStringF, firstBoundaryTests)\n+}\n+\n+var decomposeToLastTests = []PositionTest{\n+\t// ends with inert character\n+\t{\"Hello!\", 6, \"\"},\n+\t{\"\\u0632\", 2, \"\"},\n+\t{\"a\\u0301\\u0635\", 5, \"\"},\n+\t// ends with non-inert starter\n+\t{\"a\", 0, \"a\"},\n+\t{\"a\\u0301a\", 3, \"a\"},\n+\t{\"a\\u0301\\u03B9\", 3, \"\\u03B9\"},\n+\t{\"a\\u0327\", 0, \"a\\u0327\"},\n+\t// illegal runes\n+\t{\"\\xFF\", 1, \"\"},\n+\t{\"aa\\xFF\", 3, \"\"},\n+\t{\"\\xC0\\x80\\x80\", 3, \"\"},\n+\t{\"\\xCC\\x80\\x80\", 3, \"\"},\n+\t// ends with incomplete UTF-8 encoding\n+\t{\"a\\xCC\", 2, \"\"},\n+\t// ends with combining characters\n+\t{\"\\u0300\\u0301\", 0, \"\\u0300\\u0301\"},\n+\t{\"a\\u0300\\u0301\", 0, \"a\\u0300\\u0301\"},\n+\t{\"a\\u0301\\u0308\", 0, \"a\\u0301\\u0308\"},\n+\t{\"a\\u0308\\u0301\", 0, \"a\\u0308\\u0301\"},\n+\t{\"aaaa\\u0300\\u0301\", 3, \"a\\u0300\\u0301\"},\n+\t{\"\\u0300a\\u0300\\u0301\", 2, \"a\\u0300\\u0301\"},\n+\t{\"\\u00C0\", 0, \"A\\u0300\"},\n+\t{\"a\\u00C0\", 1, \"A\\u0300\"},\n+\t// decomposing\n+\t{\"a\\u0300\\uFDC0\", 3, \"\\u0645\\u062C\\u064A\"},\n+\t{\"\\uFDC0\" + strings.Repeat(\"\\u0300\", 26), 0, \"\\u0645\\u062C\\u064A\" + strings.Repeat(\"\\u0300\", 26)},\n+\t// Hangul\n+\t{\"a\\u1103\", 1, \"\\u1103\"},\n+\t{\"a\\u110B\", 1, \"\\u110B\"},\n+\t{\"a\\u110B\\u1173\", 1, \"\\u110B\\u1173\"},\n+\t// See comment in composition.go:compBoundaryAfter.\n+\t{\"a\\u110B\\u1173\\u11B7\", 1, \"\\u110B\\u1173\\u11B7\"},\n+\t{\"a\\uC73C\", 1, \"\\u110B\\u1173\"},\n+\t{\"\ub2e4\uc74c\", 3, \"\\u110B\\u1173\\u11B7\"},\n+\t{\"\ub2e4\", 0, \"\\u1103\\u1161\"},\n+\t{\"\\u1103\\u1161\\u110B\\u1173\\u11B7\", 6, \"\\u110B\\u1173\\u11B7\"},\n+\t{\"\\u110B\\u1173\\u11B7\\u1103\\u1161\", 9, \"\\u1103\\u1161\"},\n+\t{\"\ub2e4\uc74c\uc74c\", 6, \"\\u110B\\u1173\\u11B7\"},\n+\t{\"\uc74c\ub2e4\ub2e4\", 6, \"\\u1103\\u1161\"},\n+\t// buffer overflow\n+\t{\"a\" + strings.Repeat(\"\\u0300\", 30), 3, strings.Repeat(\"\\u0300\", 29)},\n+\t{\"\\uFDFA\" + strings.Repeat(\"\\u0300\", 14), 3, strings.Repeat(\"\\u0300\", 14)},\n+\t// weird UTF-8\n+\t{\"a\\u0300\\u11B7\", 0, \"a\\u0300\\u11B7\"},\n+}\n+\n+func decomposeToLast(rb *reorderBuffer, s string) int {\n+\tbuf := decomposeToLastBoundary(rb, []byte(s))\n+\treturn len(buf)\n+}\n+\n+func TestDecomposeToLastBoundary(t *testing.T) {\n+\trunPosTests(t, \"TestDecomposeToLastBoundary\", NFKC, decomposeToLast, decomposeToLastTests)\n+}\n+\n+var lastBoundaryTests = []PositionTest{\n+\t// ends with inert character\n+\t{\"Hello!\", 6, \"\"},\n+\t{\"\\u0632\", 2, \"\"},\n+\t// ends with non-inert starter\n+\t{\"a\", 0, \"\"},\n+\t// illegal runes\n+\t{\"\\xff\", 1, \"\"},\n+\t{\"aa\\xff\", 3, \"\"},\n+\t{\"a\\xff\\u0300\", 1, \"\"},\n+\t{\"\\xc0\\x80\\x80\", 3, \"\"},\n+\t{\"\\xc0\\x80\\x80\\u0300\", 3, \"\"},\n+\t// ends with incomplete UTF-8 encoding\n+\t{\"\\xCC\", -1, \"\"},\n+\t{\"\\xE0\\x80\", -1, \"\"},\n+\t{\"\\xF0\\x80\\x80\", -1, \"\"},\n+\t{\"a\\xCC\", 0, \"\"},\n+\t{\"\\x80\\xCC\", 1, \"\"},\n+\t{\"\\xCC\\xCC\", 1, \"\"},\n+\t// ends with combining characters\n+\t{\"a\\u0300\\u0301\", 0, \"\"},\n+\t{\"aaaa\\u0300\\u0301\", 3, \"\"},\n+\t{\"\\u0300a\\u0300\\u0301\", 2, \"\"},\n+\t{\"\\u00C0\", 0, \"\"},\n+\t{\"a\\u00C0\", 1, \"\"},\n+\t// decomposition may recombine\n+\t{\"\\u0226\", 0, \"\"},\n+\t// no boundary\n+\t{\"\", -1, \"\"},\n+\t{\"\\u0300\\u0301\", -1, \"\"},\n+\t{\"\\u0300\", -1, \"\"},\n+\t{\"\\x80\\x80\", -1, \"\"},\n+\t{\"\\x80\\x80\\u0301\", -1, \"\"},\n+\t// Hangul\n+\t{\"\ub2e4\uc74c\", 3, \"\"},\n+\t{\"\ub2e4\", 0, \"\"},\n+\t{\"\\u1103\\u1161\\u110B\\u1173\\u11B7\", 6, \"\"},\n+\t{\"\\u110B\\u1173\\u11B7\\u1103\\u1161\", 9, \"\"},\n+\t// too many combining characters.\n+\t{strings.Repeat(\"\\u0300\", maxCombiningChars-1), -1, \"\"},\n+\t{strings.Repeat(\"\\u0300\", maxCombiningChars), 60, \"\"},\n+\t{strings.Repeat(\"\\u0300\", maxCombiningChars+1), 62, \"\"},\n+}\n+\n+func lastBoundaryF(rb *reorderBuffer, s string) int {\n+\treturn rb.f.form.LastBoundary([]byte(s))\n+}\n+\n+func TestLastBoundary(t *testing.T) {\n+\trunPosTests(t, \"TestLastBoundary\", NFC, lastBoundaryF, lastBoundaryTests)\n+}\n+\n+var quickSpanTests = []PositionTest{\n+\t{\"\", 0, \"\"},\n+\t// starters\n+\t{\"a\", 1, \"\"},\n+\t{\"abc\", 3, \"\"},\n+\t{\"\\u043Eb\", 3, \"\"},\n+\t// incomplete last rune.\n+\t{\"\\xCC\", 1, \"\"},\n+\t{\"a\\xCC\", 2, \"\"},\n+\t// incorrectly ordered combining characters\n+\t{\"\\u0300\\u0316\", 0, \"\"},\n+\t{\"\\u0300\\u0316cd\", 0, \"\"},\n+\t// have a maximum number of combining characters.\n+\t{strings.Repeat(\"\\u035D\", 30) + \"\\u035B\", 62, \"\"},\n+\t{\"a\" + strings.Repeat(\"\\u035D\", 30) + \"\\u035B\", 63, \"\"},\n+\t{\"\u019f\" + strings.Repeat(\"\\u035D\", 30) + \"\\u035B\", 64, \"\"},\n+\t{\"aa\" + strings.Repeat(\"\\u035D\", 30) + \"\\u035B\", 64, \"\"},\n+}\n+\n+var quickSpanNFDTests = []PositionTest{\n+\t// needs decomposing\n+\t{\"\\u00C0\", 0, \"\"},\n+\t{\"abc\\u00C0\", 3, \"\"},\n+\t// correctly ordered combining characters\n+\t{\"\\u0300\", 2, \"\"},\n+\t{\"ab\\u0300\", 4, \"\"},\n+\t{\"ab\\u0300cd\", 6, \"\"},\n+\t{\"\\u0300cd\", 4, \"\"},\n+\t{\"\\u0316\\u0300\", 4, \"\"},\n+\t{\"ab\\u0316\\u0300\", 6, \"\"},\n+\t{\"ab\\u0316\\u0300cd\", 8, \"\"},\n+\t{\"ab\\u0316\\u0300\\u00C0\", 6, \"\"},\n+\t{\"\\u0316\\u0300cd\", 6, \"\"},\n+\t{\"\\u043E\\u0308b\", 5, \"\"},\n+\t// incorrectly ordered combining characters\n+\t{\"ab\\u0300\\u0316\", 1, \"\"}, // TODO(mpvl): we could skip 'b' as well.\n+\t{\"ab\\u0300\\u0316cd\", 1, \"\"},\n+\t// Hangul\n+\t{\"\uac19\uc740\", 0, \"\"},\n+}\n+\n+var quickSpanNFCTests = []PositionTest{\n+\t// okay composed\n+\t{\"\\u00C0\", 2, \"\"},\n+\t{\"abc\\u00C0\", 5, \"\"},\n+\t// correctly ordered combining characters\n+\t{\"ab\\u0300\", 1, \"\"},\n+\t{\"ab\\u0300cd\", 1, \"\"},\n+\t{\"ab\\u0316\\u0300\", 1, \"\"},\n+\t{\"ab\\u0316\\u0300cd\", 1, \"\"},\n+\t{\"\\u00C0\\u035D\", 4, \"\"},\n+\t// we do not special case leading combining characters\n+\t{\"\\u0300cd\", 0, \"\"},\n+\t{\"\\u0300\", 0, \"\"},\n+\t{\"\\u0316\\u0300\", 0, \"\"},\n+\t{\"\\u0316\\u0300cd\", 0, \"\"},\n+\t// incorrectly ordered combining characters\n+\t{\"ab\\u0300\\u0316\", 1, \"\"},\n+\t{\"ab\\u0300\\u0316cd\", 1, \"\"},\n+\t// Hangul\n+\t{\"\uac19\uc740\", 6, \"\"},\n+}\n+\n+func doQuickSpan(rb *reorderBuffer, s string) int {\n+\treturn rb.f.form.QuickSpan([]byte(s))\n+}\n+\n+func doQuickSpanString(rb *reorderBuffer, s string) int {\n+\treturn rb.f.form.QuickSpanString(s)\n+}\n+\n+func TestQuickSpan(t *testing.T) {\n+\trunPosTests(t, \"TestQuickSpanNFD1\", NFD, doQuickSpan, quickSpanTests)\n+\trunPosTests(t, \"TestQuickSpanNFD2\", NFD, doQuickSpan, quickSpanNFDTests)\n+\trunPosTests(t, \"TestQuickSpanNFC1\", NFC, doQuickSpan, quickSpanTests)\n+\trunPosTests(t, \"TestQuickSpanNFC2\", NFC, doQuickSpan, quickSpanNFCTests)\n+\n+\trunPosTests(t, \"TestQuickSpanStringNFD1\", NFD, doQuickSpanString, quickSpanTests)\n+\trunPosTests(t, \"TestQuickSpanStringNFD2\", NFD, doQuickSpanString, quickSpanNFDTests)\n+\trunPosTests(t, \"TestQuickSpanStringNFC1\", NFC, doQuickSpanString, quickSpanTests)\n+\trunPosTests(t, \"TestQuickSpanStringNFC2\", NFC, doQuickSpanString, quickSpanNFCTests)\n+}\n+\n+var isNormalTests = []PositionTest{\n+\t{\"\", 1, \"\"},\n+\t// illegal runes\n+\t{\"\\xff\", 1, \"\"},\n+\t// starters\n+\t{\"a\", 1, \"\"},\n+\t{\"abc\", 1, \"\"},\n+\t{\"\\u043Eb\", 1, \"\"},\n+\t// incorrectly ordered combining characters\n+\t{\"\\u0300\\u0316\", 0, \"\"},\n+\t{\"ab\\u0300\\u0316\", 0, \"\"},\n+\t{\"ab\\u0300\\u0316cd\", 0, \"\"},\n+\t{\"\\u0300\\u0316cd\", 0, \"\"},\n+}\n+var isNormalNFDTests = []PositionTest{\n+\t// needs decomposing\n+\t{\"\\u00C0\", 0, \"\"},\n+\t{\"abc\\u00C0\", 0, \"\"},\n+\t// correctly ordered combining characters\n+\t{\"\\u0300\", 1, \"\"},\n+\t{\"ab\\u0300\", 1, \"\"},\n+\t{\"ab\\u0300cd\", 1, \"\"},\n+\t{\"\\u0300cd\", 1, \"\"},\n+\t{\"\\u0316\\u0300\", 1, \"\"},\n+\t{\"ab\\u0316\\u0300\", 1, \"\"},\n+\t{\"ab\\u0316\\u0300cd\", 1, \"\"},\n+\t{\"\\u0316\\u0300cd\", 1, \"\"},\n+\t{\"\\u043E\\u0308b\", 1, \"\"},\n+\t// Hangul\n+\t{\"\uac19\uc740\", 0, \"\"},\n+}\n+var isNormalNFCTests = []PositionTest{\n+\t// okay composed\n+\t{\"\\u00C0\", 1, \"\"},\n+\t{\"abc\\u00C0\", 1, \"\"},\n+\t// need reordering\n+\t{\"a\\u0300\", 0, \"\"},\n+\t{\"a\\u0300cd\", 0, \"\"},\n+\t{\"a\\u0316\\u0300\", 0, \"\"},\n+\t{\"a\\u0316\\u0300cd\", 0, \"\"},\n+\t// correctly ordered combining characters\n+\t{\"ab\\u0300\", 1, \"\"},\n+\t{\"ab\\u0300cd\", 1, \"\"},\n+\t{\"ab\\u0316\\u0300\", 1, \"\"},\n+\t{\"ab\\u0316\\u0300cd\", 1, \"\"},\n+\t{\"\\u00C0\\u035D\", 1, \"\"},\n+\t{\"\\u0300\", 1, \"\"},\n+\t{\"\\u0316\\u0300cd\", 1, \"\"},\n+\t// Hangul\n+\t{\"\uac19\uc740\", 1, \"\"},\n+}\n+\n+func isNormalF(rb *reorderBuffer, s string) int {\n+\tif rb.f.form.IsNormal([]byte(s)) {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+func TestIsNormal(t *testing.T) {\n+\trunPosTests(t, \"TestIsNormalNFD1\", NFD, isNormalF, isNormalTests)\n+\trunPosTests(t, \"TestIsNormalNFD2\", NFD, isNormalF, isNormalNFDTests)\n+\trunPosTests(t, \"TestIsNormalNFC1\", NFC, isNormalF, isNormalTests)\n+\trunPosTests(t, \"TestIsNormalNFC2\", NFC, isNormalF, isNormalNFCTests)\n+}\n+\n+type AppendTest struct {\n+\tleft  string\n+\tright string\n+\tout   string\n+}\n+\n+type appendFunc func(f Form, out []byte, s string) []byte\n+\n+func runAppendTests(t *testing.T, name string, f Form, fn appendFunc, tests []AppendTest) {\n+\tfor i, test := range tests {\n+\t\tout := []byte(test.left)\n+\t\tout = fn(f, out, test.right)\n+\t\touts := string(out)\n+\t\tif len(outs) != len(test.out) {\n+\t\t\tt.Errorf(\"%s:%d: length is %d; want %d\", name, i, len(outs), len(test.out))\n+\t\t}\n+\t\tif outs != test.out {\n+\t\t\t// Find first rune that differs and show context.\n+\t\t\tir := []int(outs)\n+\t\t\tig := []int(test.out)\n+\t\t\tfor j := 0; j < len(ir) && j < len(ig); j++ {\n+\t\t\t\tif ir[j] == ig[j] {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif j -= 3; j < 0 {\n+\t\t\t\t\tj = 0\n+\t\t\t\t}\n+\t\t\t\tfor e := j + 7; j < e && j < len(ir) && j < len(ig); j++ {\n+\t\t\t\t\tt.Errorf(\"%s:%d: runeAt(%d) = %U; want %U\", name, i, j, ir[j], ig[j])\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var appendTests = []AppendTest{\n+\t// empty buffers\n+\t{\"\", \"\", \"\"},\n+\t{\"a\", \"\", \"a\"},\n+\t{\"\", \"a\", \"a\"},\n+\t{\"\", \"\\u0041\\u0307\\u0304\", \"\\u01E0\"},\n+\t// segment split across buffers\n+\t{\"\", \"a\\u0300b\", \"\\u00E0b\"},\n+\t{\"a\", \"\\u0300b\", \"\\u00E0b\"},\n+\t{\"a\", \"\\u0300\\u0316\", \"\\u00E0\\u0316\"},\n+\t{\"a\", \"\\u0316\\u0300\", \"\\u00E0\\u0316\"},\n+\t{\"a\", \"\\u0300a\\u0300\", \"\\u00E0\\u00E0\"},\n+\t{\"a\", \"\\u0300a\\u0300a\\u0300\", \"\\u00E0\\u00E0\\u00E0\"},\n+\t{\"a\", \"\\u0300aaa\\u0300aaa\\u0300\", \"\\u00E0aa\\u00E0aa\\u00E0\"},\n+\t{\"a\\u0300\", \"\\u0327\", \"\\u00E0\\u0327\"},\n+\t{\"a\\u0327\", \"\\u0300\", \"\\u00E0\\u0327\"},\n+\t{\"a\\u0316\", \"\\u0300\", \"\\u00E0\\u0316\"},\n+\t{\"\\u0041\\u0307\", \"\\u0304\", \"\\u01E0\"},\n+\t// Hangul\n+\t{\"\", \"\\u110B\\u1173\", \"\\uC73C\"},\n+\t{\"\", \"\\u1103\\u1161\", \"\\uB2E4\"},\n+\t{\"\", \"\\u110B\\u1173\\u11B7\", \"\\uC74C\"},\n+\t{\"\", \"\\u320E\", \"\\x28\\uAC00\\x29\"},\n+\t{\"\", \"\\x28\\u1100\\u1161\\x29\", \"\\x28\\uAC00\\x29\"},\n+\t{\"\\u1103\", \"\\u1161\", \"\\uB2E4\"},\n+\t{\"\\u110B\", \"\\u1173\\u11B7\", \"\\uC74C\"},\n+\t{\"\\u110B\\u1173\", \"\\u11B7\", \"\\uC74C\"},\n+\t{\"\\uC73C\", \"\\u11B7\", \"\\uC74C\"},\n+\t// UTF-8 encoding split across buffers\n+\t{\"a\\xCC\", \"\\x80\", \"\\u00E0\"},\n+\t{\"a\\xCC\", \"\\x80b\", \"\\u00E0b\"},\n+\t{\"a\\xCC\", \"\\x80a\\u0300\", \"\\u00E0\\u00E0\"},\n+\t{\"a\\xCC\", \"\\x80\\x80\", \"\\u00E0\\x80\"},\n+\t{\"a\\xCC\", \"\\x80\\xCC\", \"\\u00E0\\xCC\"},\n+\t{\"a\\u0316\\xCC\", \"\\x80a\\u0316\\u0300\", \"\\u00E0\\u0316\\u00E0\\u0316\"},\n+\t// ending in incomplete UTF-8 encoding\n+\t{\"\", \"\\xCC\", \"\\xCC\"},\n+\t{\"a\", \"\\xCC\", \"a\\xCC\"},\n+\t{\"a\", \"b\\xCC\", \"ab\\xCC\"},\n+\t{\"\\u0226\", \"\\xCC\", \"\\u0226\\xCC\"},\n+\t// illegal runes\n+\t{\"\", \"\\x80\", \"\\x80\"},\n+\t{\"\", \"\\x80\\x80\\x80\", \"\\x80\\x80\\x80\"},\n+\t{\"\", \"\\xCC\\x80\\x80\\x80\", \"\\xCC\\x80\\x80\\x80\"},\n+\t{\"\", \"a\\x80\", \"a\\x80\"},\n+\t{\"\", \"a\\x80\\x80\\x80\", \"a\\x80\\x80\\x80\"},\n+\t{\"\", \"a\\x80\\x80\\x80\\x80\\x80\\x80\", \"a\\x80\\x80\\x80\\x80\\x80\\x80\"},\n+\t{\"a\", \"\\x80\\x80\\x80\", \"a\\x80\\x80\\x80\"},\n+\t// overflow\n+\t{\"\", strings.Repeat(\"\\x80\", 33), strings.Repeat(\"\\x80\", 33)},\n+\t{strings.Repeat(\"\\x80\", 33), \"\", strings.Repeat(\"\\x80\", 33)},\n+\t{strings.Repeat(\"\\x80\", 33), strings.Repeat(\"\\x80\", 33), strings.Repeat(\"\\x80\", 66)},\n+\t// overflow of combining characters\n+\t{strings.Repeat(\"\\u0300\", 33), \"\", strings.Repeat(\"\\u0300\", 33)},\n+\t// weird UTF-8\n+\t{\"\\u00E0\\xE1\", \"\\x86\", \"\\u00E0\\xE1\\x86\"},\n+\t{\"a\\u0300\\u11B7\", \"\\u0300\", \"\\u00E0\\u11B7\\u0300\"},\n+\t{\"a\\u0300\\u11B7\\u0300\", \"\\u0300\", \"\\u00E0\\u11B7\\u0300\\u0300\"},\n+\t{\"\\u0300\", \"\\xF8\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\\xF8\\x80\\x80\\x80\\x80\\u0300\"},\n+\t{\"\\u0300\", \"\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\"},\n+\t{\"\\xF8\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\", \"\\xF8\\x80\\x80\\x80\\x80\\u0300\\u0300\"},\n+\t{\"\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\", \"\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\\u0300\"},\n+}\n+\n+func appendF(f Form, out []byte, s string) []byte {\n+\treturn f.Append(out, []byte(s)...)\n+}\n+\n+func appendStringF(f Form, out []byte, s string) []byte {\n+\treturn f.AppendString(out, s)\n+}\n+\n+func TestAppend(t *testing.T) {\n+\trunAppendTests(t, \"TestAppend\", NFKC, appendF, appendTests)\n+\trunAppendTests(t, \"TestAppendString\", NFKC, appendStringF, appendTests)\n+}\n+\n+func doFormBenchmark(b *testing.B, f Form, s string) {\n+\tb.StopTimer()\n+\tin := []byte(s)\n+\tbuf := make([]byte, 2*len(in))\n+\tb.SetBytes(int64(len(s)))\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf = f.Append(buf[0:0], in...)\n+\t\tbuf = buf[0:0]\n+\t}\n+}\n+\n+var ascii = strings.Repeat(\"There is nothing to change here! \", 500)\n+\n+func BenchmarkNormalizeAsciiNFC(b *testing.B) {\n+\tdoFormBenchmark(b, NFC, ascii)\n+}\n+func BenchmarkNormalizeAsciiNFD(b *testing.B) {\n+\tdoFormBenchmark(b, NFD, ascii)\n+}\n+func BenchmarkNormalizeAsciiNFKC(b *testing.B) {\n+\tdoFormBenchmark(b, NFKC, ascii)\n+}\n+func BenchmarkNormalizeAsciiNFKD(b *testing.B) {\n+\tdoFormBenchmark(b, NFKD, ascii)\n+}\n+\n+func doTextBenchmark(b *testing.B, s string) {\n+\tb.StopTimer()\n+\tb.SetBytes(int64(len(s)) * 4)\n+\tin := []byte(s)\n+\tvar buf = make([]byte, 0, 2*len(in))\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tNFC.Append(buf, in...)\n+\t\tNFD.Append(buf, in...)\n+\t\tNFKC.Append(buf, in...)\n+\t\tNFKD.Append(buf, in...)\n+\t}\n+}\n+\n+func BenchmarkCanonicalOrdering(b *testing.B) {\n+\tdoTextBenchmark(b, txt_canon)\n+}\n+func BenchmarkExtendedLatin(b *testing.B) {\n+\tdoTextBenchmark(b, txt_vn)\n+}\n+func BenchmarkMiscTwoByteUtf8(b *testing.B) {\n+\tdoTextBenchmark(b, twoByteUtf8)\n+}\n+func BenchmarkMiscThreeByteUtf8(b *testing.B) {\n+\tdoTextBenchmark(b, threeByteUtf8)\n+}\n+func BenchmarkHangul(b *testing.B) {\n+\tdoTextBenchmark(b, txt_kr)\n+}\n+func BenchmarkJapanese(b *testing.B) {\n+\tdoTextBenchmark(b, txt_jp)\n+}\n+func BenchmarkChinese(b *testing.B) {\n+\tdoTextBenchmark(b, txt_cn)\n+}\n+\n+// Tests sampled from the Canonical ordering tests (Part 2) of\n+// http://unicode.org/Public/UNIDATA/NormalizationTest.txt\n+const txt_canon = `\\u0061\\u0315\\u0300\\u05AE\\u0300\\u0062 \\u0061\\u0300\\u0315\\u0300\\u05AE\\u0062\n+\\u0061\\u0302\\u0315\\u0300\\u05AE\\u0062 \\u0061\\u0307\\u0315\\u0300\\u05AE\\u0062\n+\\u0061\\u0315\\u0300\\u05AE\\u030A\\u0062 \\u0061\\u059A\\u0316\\u302A\\u031C\\u0062\n+\\u0061\\u032E\\u059A\\u0316\\u302A\\u0062 \\u0061\\u0338\\u093C\\u0334\\u0062 \n+\\u0061\\u059A\\u0316\\u302A\\u0339       \\u0061\\u0341\\u0315\\u0300\\u05AE\\u0062\n+\\u0061\\u0348\\u059A\\u0316\\u302A\\u0062 \\u0061\\u0361\\u0345\\u035D\\u035C\\u0062\n+\\u0061\\u0366\\u0315\\u0300\\u05AE\\u0062 \\u0061\\u0315\\u0300\\u05AE\\u0486\\u0062\n+\\u0061\\u05A4\\u059A\\u0316\\u302A\\u0062 \\u0061\\u0315\\u0300\\u05AE\\u0613\\u0062\n+\\u0061\\u0315\\u0300\\u05AE\\u0615\\u0062 \\u0061\\u0617\\u0315\\u0300\\u05AE\\u0062\n+\\u0061\\u0619\\u0618\\u064D\\u064E\\u0062 \\u0061\\u0315\\u0300\\u05AE\\u0654\\u0062\n+\\u0061\\u0315\\u0300\\u05AE\\u06DC\\u0062 \\u0061\\u0733\\u0315\\u0300\\u05AE\\u0062\n+\\u0061\\u0744\\u059A\\u0316\\u302A\\u0062 \\u0061\\u0315\\u0300\\u05AE\\u0745\\u0062\n+\\u0061\\u09CD\\u05B0\\u094D\\u3099\\u0062 \\u0061\\u0E38\\u0E48\\u0E38\\u0C56\\u0062\n+\\u0061\\u0EB8\\u0E48\\u0E38\\u0E49\\u0062 \\u0061\\u0F72\\u0F71\\u0EC8\\u0F71\\u0062\n+\\u0061\\u1039\\u05B0\\u094D\\u3099\\u0062 \\u0061\\u05B0\\u094D\\u3099\\u1A60\\u0062\n+\\u0061\\u3099\\u093C\\u0334\\u1BE6\\u0062 \\u0061\\u3099\\u093C\\u0334\\u1C37\\u0062\n+\\u0061\\u1CD9\\u059A\\u0316\\u302A\\u0062 \\u0061\\u2DED\\u0315\\u0300\\u05AE\\u0062\n+\\u0061\\u2DEF\\u0315\\u0300\\u05AE\\u0062 \\u0061\\u302D\\u302E\\u059A\\u0316\\u0062`\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/3.0/vn/\n+const txt_vn = `V\u1edbi c\u00e1c \u0111i\u1ec1u ki\u1ec7n sau: Ghi nh\u1eadn c\u00f4ng c\u1ee7a t\u00e1c gi\u1ea3. \n+N\u1ebfu b\u1ea1n s\u1eed d\u1ee5ng, chuy\u1ec3n \u0111\u1ed5i, ho\u1eb7c x\u00e2y d\u1ef1ng d\u1ef1 \u00e1n t\u1eeb \n+n\u1ed9i dung \u0111\u01b0\u1ee3c chia s\u1ebb n\u00e0y, b\u1ea1n ph\u1ea3i \u00e1p d\u1ee5ng gi\u1ea5y ph\u00e9p n\u00e0y ho\u1eb7c \n+m\u1ed9t gi\u1ea5y ph\u00e9p kh\u00e1c c\u00f3 c\u00e1c \u0111i\u1ec1u kho\u1ea3n t\u01b0\u01a1ng t\u1ef1 nh\u01b0 gi\u1ea5y ph\u00e9p n\u00e0y\n+cho d\u1ef1 \u00e1n c\u1ee7a b\u1ea1n. Hi\u1ec3u r\u1eb1ng: Mi\u1ec5n \u2014 B\u1ea5t k\u1ef3 c\u00e1c \u0111i\u1ec1u ki\u1ec7n n\u00e0o\n+tr\u00ean \u0111\u00e2y c\u0169ng c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c mi\u1ec5n b\u1ecf n\u1ebfu b\u1ea1n \u0111\u01b0\u1ee3c s\u1ef1 cho ph\u00e9p c\u1ee7a\n+ng\u01b0\u1eddi s\u1edf h\u1eefu b\u1ea3n quy\u1ec1n. Ph\u1ea1m vi c\u00f4ng ch\u00fang \u2014 Khi t\u00e1c ph\u1ea9m ho\u1eb7c\n+b\u1ea5t k\u1ef3 ch\u01b0\u01a1ng n\u00e0o c\u1ee7a t\u00e1c ph\u1ea9m \u0111\u00e3 trong v\u00f9ng d\u00e0nh cho c\u00f4ng\n+ch\u00fang theo quy \u0111\u1ecbnh c\u1ee7a ph\u00e1p lu\u1eadt th\u00ec t\u00ecnh tr\u1ea1ng c\u1ee7a n\u00f3 kh\u00f4ng \n+b\u1ecb \u1ea3nh h\u01b0\u1edfng b\u1edfi gi\u1ea5y ph\u00e9p trong b\u1ea5t k\u1ef3 tr\u01b0\u1eddng h\u1ee3p n\u00e0o.`\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/1.0/deed.ru\n+const txt_ru = `\u041f\u0440\u0438 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u043c \u0441\u043e\u0431\u043b\u044e\u0434\u0435\u043d\u0438\u0438 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0445 \u0443\u0441\u043b\u043e\u0432\u0438\u0439:\n+Attribution \u2014 \u0412\u044b \u0434\u043e\u043b\u0436\u043d\u044b \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435 (\u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c\n+\u0430\u0432\u0442\u043e\u0440\u0430 \u0438 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a) \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435, \u043f\u0440\u0435\u0434\u0443\u0441\u043c\u043e\u0442\u0440\u0435\u043d\u043d\u043e\u043c \u0430\u0432\u0442\u043e\u0440\u043e\u043c \u0438\u043b\u0438\n+\u043b\u0438\u0446\u0435\u043d\u0437\u0438\u0430\u0440\u043e\u043c (\u043d\u043e \u0442\u043e\u043b\u044c\u043a\u043e \u0442\u0430\u043a, \u0447\u0442\u043e\u0431\u044b \u043d\u0438\u043a\u043e\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c \u043d\u0435 \u043f\u043e\u0434\u0440\u0430\u0437\u0443\u043c\u0435\u0432\u0430\u043b\u043e\u0441\u044c,\n+\u0447\u0442\u043e \u043e\u043d\u0438 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u044e\u0442 \u0432\u0430\u0441 \u0438\u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0432\u0430\u043c\u0438 \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f).\n+\u03a5\u03c0\u03cc \u03c4\u03b9\u03c2 \u03b1\u03ba\u03cc\u03bb\u03bf\u03c5\u03b8\u03b5\u03c2 \u03c0\u03c1\u03bf\u03cb\u03c0\u03bf\u03b8\u03ad\u03c3\u03b5\u03b9\u03c2:`\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/3.0/gr/\n+const txt_gr = `\u0391\u03bd\u03b1\u03c6\u03bf\u03c1\u03ac \u0394\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03bf\u03cd \u2014 \u0398\u03b1 \u03c0\u03c1\u03ad\u03c0\u03b5\u03b9 \u03bd\u03b1 \u03ba\u03ac\u03bd\u03b5\u03c4\u03b5 \u03c4\u03b7\u03bd \u03b1\u03bd\u03b1\u03c6\u03bf\u03c1\u03ac \u03c3\u03c4\u03bf \u03ad\u03c1\u03b3\u03bf \u03bc\u03b5 \u03c4\u03bf\u03bd\n+\u03c4\u03c1\u03cc\u03c0\u03bf \u03c0\u03bf\u03c5 \u03ad\u03c7\u03b5\u03b9 \u03bf\u03c1\u03b9\u03c3\u03c4\u03b5\u03af \u03b1\u03c0\u03cc \u03c4\u03bf \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03cc \u03ae \u03c4\u03bf \u03c7\u03bf\u03c1\u03b7\u03b3\u03bf\u03cd\u03bd\u03c4\u03bf \u03c4\u03b7\u03bd \u03ac\u03b4\u03b5\u03b9\u03b1\n+(\u03c7\u03c9\u03c1\u03af\u03c2 \u03cc\u03bc\u03c9\u03c2 \u03bd\u03b1 \u03b5\u03bd\u03bd\u03bf\u03b5\u03af\u03c4\u03b1\u03b9 \u03bc\u03b5 \u03bf\u03c0\u03bf\u03b9\u03bf\u03bd\u03b4\u03ae\u03c0\u03bf\u03c4\u03b5 \u03c4\u03c1\u03cc\u03c0\u03bf \u03cc\u03c4\u03b9 \u03b5\u03b3\u03ba\u03c1\u03af\u03bd\u03bf\u03c5\u03bd \u03b5\u03c3\u03ac\u03c2 \u03ae\n+\u03c4\u03b7 \u03c7\u03c1\u03ae\u03c3\u03b7 \u03c4\u03bf\u03c5 \u03ad\u03c1\u03b3\u03bf\u03c5 \u03b1\u03c0\u03cc \u03b5\u03c3\u03ac\u03c2). \u03a0\u03b1\u03c1\u03cc\u03bc\u03bf\u03b9\u03b1 \u0394\u03b9\u03b1\u03bd\u03bf\u03bc\u03ae \u2014 \u0395\u03ac\u03bd \u03b1\u03bb\u03bb\u03bf\u03b9\u03ce\u03c3\u03b5\u03c4\u03b5,\n+\u03c4\u03c1\u03bf\u03c0\u03bf\u03c0\u03bf\u03b9\u03ae\u03c3\u03b5\u03c4\u03b5 \u03ae \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03ae\u03c3\u03b5\u03c4\u03b5 \u03c0\u03b5\u03c1\u03b1\u03b9\u03c4\u03ad\u03c1\u03c9 \u03b2\u03b1\u03c3\u03b9\u03c3\u03bc\u03ad\u03bd\u03bf\u03b9 \u03c3\u03c4\u03bf \u03ad\u03c1\u03b3\u03bf \u03b8\u03b1\n+\u03bc\u03c0\u03bf\u03c1\u03b5\u03af\u03c4\u03b5 \u03bd\u03b1 \u03b4\u03b9\u03b1\u03bd\u03ad\u03bc\u03b5\u03c4\u03b5 \u03c4\u03bf \u03ad\u03c1\u03b3\u03bf \u03c0\u03bf\u03c5 \u03b8\u03b1 \u03c0\u03c1\u03bf\u03ba\u03cd\u03c8\u03b5\u03b9 \u03bc\u03cc\u03bd\u03bf \u03bc\u03b5 \u03c4\u03b7\u03bd \u03af\u03b4\u03b9\u03b1 \u03ae\n+\u03c0\u03b1\u03c1\u03cc\u03bc\u03bf\u03b9\u03b1 \u03ac\u03b4\u03b5\u03b9\u03b1.`\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/3.0/deed.ar\n+const txt_ar = `\u0628\u0645\u0648\u062c\u0628 \u0627\u0644\u0634\u0631\u0648\u0637 \u0627\u0644\u062a\u0627\u0644\u064a\u0629 \u0646\u0633\u0628 \u0627\u0644\u0645\u0635\u0646\u0641 \u2014 \u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u0623\u0646\n+\u062a\u0646\u0633\u0628 \u0627\u0644\u0639\u0645\u0644 \u0628\u0627\u0644\u0637\u0631\u064a\u0642\u0629 \u0627\u0644\u062a\u064a \u062a\u062d\u062f\u062f\u0647\u0627 \u0627\u0644\u0645\u0624\u0644\u0641 \u0623\u0648 \u0627\u0644\u0645\u0631\u062e\u0635 (\u0648\u0644\u0643\u0646 \u0644\u064a\u0633 \u0628\u0623\u064a \u062d\u0627\u0644 \u0645\u0646\n+\u0627\u0644\u0623\u062d\u0648\u0627\u0644 \u0623\u0646 \u062a\u0648\u062d\u064a \u0648\u062a\u0642\u062a\u0631\u062d \u0628\u062a\u062d\u0648\u0644 \u0623\u0648 \u0627\u0633\u062a\u062e\u062f\u0627\u0645\u0643 \u0644\u0644\u0639\u0645\u0644).\n+\u0627\u0644\u0645\u0634\u0627\u0631\u0643\u0629 \u0639\u0644\u0649 \u0642\u062f\u0645 \u0627\u0644\u0645\u0633\u0627\u0648\u0627\u0629 \u2014 \u0625\u0630\u0627 \u0643\u0646\u062a \u064a\u0639\u062f\u0644 \u060c \u0648\u0627\u0644\u062a\u063a\u064a\u064a\u0631 \u060c \u0623\u0648 \u0627\u0644\u0627\u0633\u062a\u0641\u0627\u062f\u0629\n+\u0645\u0646 \u0647\u0630\u0627 \u0627\u0644\u0639\u0645\u0644 \u060c \u0642\u062f \u064a\u0646\u062a\u062c \u0639\u0646 \u062a\u0648\u0632\u064a\u0639 \u0627\u0644\u0639\u0645\u0644 \u0625\u0644\u0627 \u0641\u064a \u0638\u0644 \u062a\u0634\u0627\u0628\u0647 \u0627\u0648 \u062a\u0637\u0627\u0628\u0642 \u0641\u0649 \u0648\u0627\u062d\u062f\n+\u0644\u0647\u0630\u0627 \u0627\u0644\u062a\u0631\u062e\u064a\u0635.`\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/1.0/il/\n+const txt_il = `\u05d1\u05db\u05e4\u05d5\u05e3 \u05dc\u05ea\u05e0\u05d0\u05d9\u05dd \u05d4\u05d1\u05d0\u05d9\u05dd: \u05d9\u05d9\u05d7\u05d5\u05e1 \u2014 \u05e2\u05dc\u05d9\u05da \u05dc\u05d9\u05d9\u05d7\u05e1 \u05d0\u05ea \u05d4\u05d9\u05e6\u05d9\u05e8\u05d4 (\u05dc\u05ea\u05ea \u05e7\u05e8\u05d3\u05d9\u05d8) \u05d1\u05d0\u05d5\u05e4\u05df\n+\u05d4\u05de\u05e6\u05d5\u05d9\u05d9\u05df \u05e2\u05dc-\u05d9\u05d3\u05d9 \u05d4\u05d9\u05d5\u05e6\u05e8 \u05d0\u05d5 \u05de\u05e2\u05e0\u05d9\u05e7 \u05d4\u05e8\u05d9\u05e9\u05d9\u05d5\u05df (\u05d0\u05da \u05dc\u05d0 \u05d1\u05e9\u05d5\u05dd \u05d0\u05d5\u05e4\u05df \u05d4\u05de\u05e8\u05de\u05d6 \u05e2\u05dc \u05db\u05da\n+\u05e9\u05d4\u05dd \u05ea\u05d5\u05de\u05db\u05d9\u05dd \u05d1\u05da \u05d0\u05d5 \u05d1\u05e9\u05d9\u05de\u05d5\u05e9 \u05e9\u05dc\u05da \u05d1\u05d9\u05e6\u05d9\u05e8\u05d4). \u05e9\u05d9\u05ea\u05d5\u05e3 \u05d6\u05d4\u05d4 \u2014 \u05d0\u05dd \u05ea\u05d7\u05dc\u05d9\u05d8/\u05d9 \u05dc\u05e9\u05e0\u05d5\u05ea,\n+\u05dc\u05e2\u05d1\u05d3 \u05d0\u05d5 \u05dc\u05d9\u05e6\u05d5\u05e8 \u05d9\u05e6\u05d9\u05e8\u05d4 \u05e0\u05d2\u05d6\u05e8\u05ea \u05d1\u05d4\u05e1\u05ea\u05de\u05da \u05e2\u05dc \u05d9\u05e6\u05d9\u05e8\u05d4 \u05d6\u05d5, \u05ea\u05d5\u05db\u05dc/\u05d9 \u05dc\u05d4\u05e4\u05d9\u05e5 \u05d0\u05ea \u05d9\u05e6\u05d9\u05e8\u05ea\u05da\n+\u05d4\u05d7\u05d3\u05e9\u05d4 \u05e8\u05e7 \u05ea\u05d7\u05ea \u05d0\u05d5\u05ea\u05d5 \u05d4\u05e8\u05d9\u05e9\u05d9\u05d5\u05df \u05d0\u05d5 \u05e8\u05d9\u05e9\u05d9\u05d5\u05df \u05d3\u05d5\u05de\u05d4 \u05dc\u05e8\u05d9\u05e9\u05d9\u05d5\u05df \u05d6\u05d4.`\n+\n+const twoByteUtf8 = txt_ru + txt_gr + txt_ar + txt_il\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/2.0/kr/\n+const txt_kr = `\ub2e4\uc74c\uacfc \uac19\uc740 \uc870\uac74\uc744 \ub530\ub77c\uc57c \ud569\ub2c8\ub2e4: \uc800\uc791\uc790\ud45c\uc2dc\n+(Attribution) \u2014 \uc800\uc791\uc790\ub098 \uc774\uc6a9\ud5c8\ub77d\uc790\uac00 \uc815\ud55c \ubc29\ubc95\uc73c\ub85c \uc800\uc791\ubb3c\uc758\n+\uc6d0\uc800\uc791\uc790\ub97c \ud45c\uc2dc\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4(\uadf8\ub7ec\ub098 \uc6d0\uc800\uc791\uc790\uac00 \uc774\uc6a9\uc790\ub098 \uc774\uc6a9\uc790\uc758\n+\uc774\uc6a9\uc744 \ubcf4\uc99d\ud558\uac70\ub098 \ucd94\ucc9c\ud55c\ub2e4\ub294 \uc758\ubbf8\ub85c \ud45c\uc2dc\ud574\uc11c\ub294 \uc548\ub429\ub2c8\ub2e4). \n+\ub3d9\uc77c\uc870\uac74\ubcc0\uacbd\ud5c8\ub77d \u2014 \uc774 \uc800\uc791\ubb3c\uc744 \uc774\uc6a9\ud558\uc5ec \ub9cc\ub4e0 \uc774\ucc28\uc801 \uc800\uc791\ubb3c\uc5d0\ub294 \ubcf8\n+\ub77c\uc774\uc120\uc2a4\uc640 \ub3d9\uc77c\ud55c \ub77c\uc774\uc120\uc2a4\ub97c \uc801\uc6a9\ud574\uc57c \ud569\ub2c8\ub2e4.`\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/3.0/th/\n+const txt_th = `\u0e20\u0e32\u0e22\u0e43\u0e15\u0e49\u0e40\u0e07\u0e37\u0e48\u0e2d\u0e19\u0e44\u0e02 \u0e14\u0e31\u0e07\u0e15\u0e48\u0e2d\u0e44\u0e1b\u0e19\u0e35\u0e49 : \u0e41\u0e2a\u0e14\u0e07\u0e17\u0e35\u0e48\u0e21\u0e32 \u2014 \u0e04\u0e38\u0e13\u0e15\u0e49\u0e2d\u0e07\u0e41\u0e2a\u0e14\u0e07\u0e17\u0e35\u0e48\n+\u0e21\u0e32\u0e02\u0e2d\u0e07\u0e07\u0e32\u0e19\u0e14\u0e31\u0e07\u0e01\u0e25\u0e48\u0e32\u0e27 \u0e15\u0e32\u0e21\u0e23\u0e39\u0e1b\u0e41\u0e1a\u0e1a\u0e17\u0e35\u0e48\u0e1c\u0e39\u0e49\u0e2a\u0e23\u0e49\u0e32\u0e07\u0e2a\u0e23\u0e23\u0e04\u0e4c\u0e2b\u0e23\u0e37\u0e2d\u0e1c\u0e39\u0e49\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15\u0e01\u0e33\u0e2b\u0e19\u0e14 (\u0e41\u0e15\u0e48\n+\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48\u0e43\u0e19\u0e25\u0e31\u0e01\u0e29\u0e13\u0e30\u0e17\u0e35\u0e48\u0e27\u0e48\u0e32 \u0e1e\u0e27\u0e01\u0e40\u0e02\u0e32\u0e2a\u0e19\u0e31\u0e1a\u0e2a\u0e19\u0e38\u0e19\u0e04\u0e38\u0e13\u0e2b\u0e23\u0e37\u0e2d\u0e2a\u0e19\u0e31\u0e1a\u0e2a\u0e19\u0e38\u0e19\u0e01\u0e32\u0e23\u0e17\u0e35\u0e48\n+\u0e04\u0e38\u0e13\u0e19\u0e33\u0e07\u0e32\u0e19\u0e44\u0e1b\u0e43\u0e0a\u0e49) \u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15\u0e41\u0e1a\u0e1a\u0e40\u0e14\u0e35\u0e22\u0e27\u0e01\u0e31\u0e19 \u2014 \u0e2b\u0e32\u0e01\u0e04\u0e38\u0e13\u0e14\u0e31\u0e14\u0e41\u0e1b\u0e25\u0e07 \u0e40\u0e1b\u0e25\u0e35\u0e48\u0e22\u0e19\u0e23\u0e39\u0e1b \u0e2b\u0e23\u0e37\n+\u0e2d\u0e15\u0e48\u0e2d\u0e40\u0e15\u0e34\u0e21\u0e07\u0e32\u0e19\u0e19\u0e35\u0e49 \u0e04\u0e38\u0e13\u0e15\u0e49\u0e2d\u0e07\u0e43\u0e0a\u0e49\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15\u0e41\u0e1a\u0e1a\u0e40\u0e14\u0e35\u0e22\u0e27\u0e01\u0e31\u0e19\u0e2b\u0e23\u0e37\u0e2d\u0e41\u0e1a\u0e1a\u0e17\u0e35\u0e48\u0e40\u0e2b\u0e21\u0e37\n+\u0e2d\u0e19\u0e01\u0e31\u0e1a\u0e2a\u0e31\u0e0d\u0e0d\u0e32\u0e2d\u0e19\u0e38\u0e0d\u0e32\u0e15\u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e01\u0e31\u0e1a\u0e07\u0e32\u0e19\u0e19\u0e35\u0e49\u0e40\u0e17\u0e48\u0e32\u0e19\u0e31\u0e49\u0e19`\n+\n+const threeByteUtf8 = txt_th\n+\n+// Taken from http://creativecommons.org/licenses/by-sa/2.0/jp/\n+const txt_jp = `\u3042\u306a\u305f\u306e\u5f93\u3046\u3079\u304d\u6761\u4ef6\u306f\u4ee5\u4e0b\u306e\u901a\u308a\u3067\u3059\u3002\n+\u8868\u793a \u2014 \u3042\u306a\u305f\u306f\u539f\u8457\u4f5c\u8005\u306e\u30af\u30ec\u30b8\u30c3\u30c8\u3092\u8868\u793a\u3057\u306a\u3051\u308c\u3070\u306a\u308a\u307e\u305b\u3093\u3002\n+\u7d99\u627f \u2014 \u3082\u3057\u3042\u306a\u305f\u304c\u3053\u306e\u4f5c\u54c1\u3092\u6539\u5909\u3001\u5909\u5f62\u307e\u305f\u306f\u52a0\u5de5\u3057\u305f\u5834\u5408\u3001\n+\u3042\u306a\u305f\u306f\u305d\u306e\u7d50\u679c\u751f\u3058\u305f\u4f5c\u54c1\u3092\u3053\u306e\u4f5c\u54c1\u3068\u540c\u4e00\u306e\u8a31\u8afe\u6761\u4ef6\u306e\u4e0b\u3067\u306e\u307f\n+\u9812\u5e03\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002`\n+\n+// http://creativecommons.org/licenses/by-sa/2.5/cn/\n+const txt_cn = `\u60a8\u53ef\u4ee5\u81ea\u7531\uff1a \u590d\u5236\u3001\u53d1\u884c\u3001\u5c55\u89c8\u3001\u8868\u6f14\u3001\u653e\u6620\u3001\n+\u5e7f\u64ad\u6216\u901a\u8fc7\u4fe1\u606f\u7f51\u7edc\u4f20\u64ad\u672c\u4f5c\u54c1 \u521b\u4f5c\u6f14\u7ece\u4f5c\u54c1\n+\u5bf9\u672c\u4f5c\u54c1\u8fdb\u884c\u5546\u4e1a\u6027\u4f7f\u7528 \u60df\u987b\u9075\u5b88\u4e0b\u5217\u6761\u4ef6\uff1a\n+\u7f72\u540d \u2014 \u60a8\u5fc5\u987b\u6309\u7167\u4f5c\u8005\u6216\u8005\u8bb8\u53ef\u4eba\u6307\u5b9a\u7684\u65b9\u5f0f\u5bf9\u4f5c\u54c1\u8fdb\u884c\u7f72\u540d\u3002\n+\u76f8\u540c\u65b9\u5f0f\u5171\u4eab \u2014 \u5982\u679c\u60a8\u6539\u53d8\u3001\u8f6c\u6362\u672c\u4f5c\u54c1\u6216\u8005\u4ee5\u672c\u4f5c\u54c1\u4e3a\u57fa\u7840\u8fdb\u884c\u521b\u4f5c\uff0c\n+\u60a8\u53ea\u80fd\u91c7\u7528\u4e0e\u672c\u534f\u8bae\u76f8\u540c\u7684\u8bb8\u53ef\u534f\u8bae\u53d1\u5e03\u57fa\u4e8e\u672c\u4f5c\u54c1\u7684\u6f14\u7ece\u4f5c\u54c1\u3002`"}, {"sha": "cbd73ffa7590b73633c5a31eec436d04fe2bfa1d", "filename": "libgo/go/exp/norm/normregtest.go", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,295 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"exp/norm\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"http\"\n+\t\"log\"\n+\t\"os\"\n+\t\"path\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"strconv\"\n+\t\"time\"\n+\t\"utf8\"\n+)\n+\n+func main() {\n+\tflag.Parse()\n+\tloadTestData()\n+\tCharacterByCharacterTests()\n+\tStandardTests()\n+\tPerformanceTest()\n+\tif errorCount == 0 {\n+\t\tfmt.Println(\"PASS\")\n+\t}\n+}\n+\n+const file = \"NormalizationTest.txt\"\n+\n+var url = flag.String(\"url\",\n+\t\"http://www.unicode.org/Public/6.0.0/ucd/\"+file,\n+\t\"URL of Unicode database directory\")\n+var localFiles = flag.Bool(\"local\",\n+\tfalse,\n+\t\"data files have been copied to the current directory; for debugging only\")\n+\n+var logger = log.New(os.Stderr, \"\", log.Lshortfile)\n+\n+// This regression test runs the test set in NormalizationTest.txt\n+// (taken from http://www.unicode.org/Public/6.0.0/ucd/).\n+//\n+// NormalizationTest.txt has form:\n+// @Part0 # Specific cases\n+// #\n+// 1E0A;1E0A;0044 0307;1E0A;0044 0307; # (\u1e0a; \u1e0a; D\u25cc\u0307; \u1e0a; D\u25cc\u0307; ) LATIN CAPITAL LETTER D WITH DOT ABOVE\n+// 1E0C;1E0C;0044 0323;1E0C;0044 0323; # (\u1e0c; \u1e0c; D\u25cc\u0323; \u1e0c; D\u25cc\u0323; ) LATIN CAPITAL LETTER D WITH DOT BELOW\n+//\n+// Each test has 5 columns (c1, c2, c3, c4, c5), where \n+// (c1, c2, c3, c4, c5) == (c1, NFC(c1), NFD(c1), NFKC(c1), NFKD(c1))\n+//\n+// CONFORMANCE:\n+// 1. The following invariants must be true for all conformant implementations\n+//\n+//    NFC\n+//      c2 ==  NFC(c1) ==  NFC(c2) ==  NFC(c3)\n+//      c4 ==  NFC(c4) ==  NFC(c5)\n+//\n+//    NFD\n+//      c3 ==  NFD(c1) ==  NFD(c2) ==  NFD(c3)\n+//      c5 ==  NFD(c4) ==  NFD(c5)\n+//\n+//    NFKC\n+//      c4 == NFKC(c1) == NFKC(c2) == NFKC(c3) == NFKC(c4) == NFKC(c5)\n+//\n+//    NFKD\n+//      c5 == NFKD(c1) == NFKD(c2) == NFKD(c3) == NFKD(c4) == NFKD(c5)\n+//\n+// 2. For every code point X assigned in this version of Unicode that is not\n+//    specifically listed in Part 1, the following invariants must be true\n+//    for all conformant implementations:\n+//\n+//      X == NFC(X) == NFD(X) == NFKC(X) == NFKD(X)\n+//\n+\n+// Column types.\n+const (\n+\tcRaw = iota\n+\tcNFC\n+\tcNFD\n+\tcNFKC\n+\tcNFKD\n+\tcMaxColumns\n+)\n+\n+// Holds data from NormalizationTest.txt\n+var part []Part\n+\n+type Part struct {\n+\tname   string\n+\tnumber int\n+\ttests  []Test\n+}\n+\n+type Test struct {\n+\tname   string\n+\tpartnr int\n+\tnumber int\n+\trune   int                 // used for character by character test\n+\tcols   [cMaxColumns]string // Each has 5 entries, see below.\n+}\n+\n+func (t Test) Name() string {\n+\tif t.number < 0 {\n+\t\treturn part[t.partnr].name\n+\t}\n+\treturn fmt.Sprintf(\"%s:%d\", part[t.partnr].name, t.number)\n+}\n+\n+var partRe = regexp.MustCompile(`@Part(\\d) # (.*)\\n$`)\n+var testRe = regexp.MustCompile(`^` + strings.Repeat(`([\\dA-F ]+);`, 5) + ` # (.*)\\n?$`)\n+\n+var counter int\n+\n+// Load the data form NormalizationTest.txt\n+func loadTestData() {\n+\tif *localFiles {\n+\t\tpwd, _ := os.Getwd()\n+\t\t*url = \"file://\" + path.Join(pwd, file)\n+\t}\n+\tt := &http.Transport{}\n+\tt.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n+\tc := &http.Client{Transport: t}\n+\tresp, err := c.Get(*url)\n+\tif err != nil {\n+\t\tlogger.Fatal(err)\n+\t}\n+\tif resp.StatusCode != 200 {\n+\t\tlogger.Fatal(\"bad GET status for \"+file, resp.Status)\n+\t}\n+\tf := resp.Body\n+\tdefer f.Close()\n+\tinput := bufio.NewReader(f)\n+\tfor {\n+\t\tline, err := input.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tif err == os.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tlogger.Fatal(err)\n+\t\t}\n+\t\tif len(line) == 0 || line[0] == '#' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tm := partRe.FindStringSubmatch(line)\n+\t\tif m != nil {\n+\t\t\tif len(m) < 3 {\n+\t\t\t\tlogger.Fatal(\"Failed to parse Part: \", line)\n+\t\t\t}\n+\t\t\ti, err := strconv.Atoi(m[1])\n+\t\t\tif err != nil {\n+\t\t\t\tlogger.Fatal(err)\n+\t\t\t}\n+\t\t\tname := m[2]\n+\t\t\tpart = append(part, Part{name: name[:len(name)-1], number: i})\n+\t\t\tcontinue\n+\t\t}\n+\t\tm = testRe.FindStringSubmatch(line)\n+\t\tif m == nil || len(m) < 7 {\n+\t\t\tlogger.Fatalf(`Failed to parse: \"%s\" result: %#v`, line, m)\n+\t\t}\n+\t\ttest := Test{name: m[6], partnr: len(part) - 1, number: counter}\n+\t\tcounter++\n+\t\tfor j := 1; j < len(m)-1; j++ {\n+\t\t\tfor _, split := range strings.Split(m[j], \" \") {\n+\t\t\t\tr, err := strconv.Btoui64(split, 16)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tlogger.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tif test.rune == 0 {\n+\t\t\t\t\t// save for CharacterByCharacterTests\n+\t\t\t\t\ttest.rune = int(r)\n+\t\t\t\t}\n+\t\t\t\tvar buf [utf8.UTFMax]byte\n+\t\t\t\tsz := utf8.EncodeRune(buf[:], int(r))\n+\t\t\t\ttest.cols[j-1] += string(buf[:sz])\n+\t\t\t}\n+\t\t}\n+\t\tpart := &part[len(part)-1]\n+\t\tpart.tests = append(part.tests, test)\n+\t}\n+}\n+\n+var fstr = []string{\"NFC\", \"NFD\", \"NFKC\", \"NFKD\"}\n+\n+var errorCount int\n+\n+func cmpResult(t *Test, name string, f norm.Form, gold, test, result string) {\n+\tif gold != result {\n+\t\terrorCount++\n+\t\tif errorCount > 20 {\n+\t\t\treturn\n+\t\t}\n+\t\tst, sr, sg := []int(test), []int(result), []int(gold)\n+\t\tlogger.Printf(\"%s:%s: %s(%X)=%X; want:%X: %s\",\n+\t\t\tt.Name(), name, fstr[f], st, sr, sg, t.name)\n+\t}\n+}\n+\n+func cmpIsNormal(t *Test, name string, f norm.Form, test string, result, want bool) {\n+\tif result != want {\n+\t\terrorCount++\n+\t\tif errorCount > 20 {\n+\t\t\treturn\n+\t\t}\n+\t\tlogger.Printf(\"%s:%s: %s(%X)=%v; want: %v\", t.Name(), name, fstr[f], []int(test), result, want)\n+\t}\n+}\n+\n+func doTest(t *Test, f norm.Form, gold, test string) {\n+\tresult := f.Bytes([]byte(test))\n+\tcmpResult(t, \"Bytes\", f, gold, test, string(result))\n+\tfor i := range test {\n+\t\tout := f.Append(f.Bytes([]byte(test[:i])), []byte(test[i:])...)\n+\t\tcmpResult(t, fmt.Sprintf(\":Append:%d\", i), f, gold, test, string(out))\n+\t}\n+\tcmpIsNormal(t, \"IsNormal\", f, test, f.IsNormal([]byte(test)), test == gold)\n+}\n+\n+func doConformanceTests(t *Test, partn int) {\n+\tfor i := 0; i <= 2; i++ {\n+\t\tdoTest(t, norm.NFC, t.cols[1], t.cols[i])\n+\t\tdoTest(t, norm.NFD, t.cols[2], t.cols[i])\n+\t\tdoTest(t, norm.NFKC, t.cols[3], t.cols[i])\n+\t\tdoTest(t, norm.NFKD, t.cols[4], t.cols[i])\n+\t}\n+\tfor i := 3; i <= 4; i++ {\n+\t\tdoTest(t, norm.NFC, t.cols[3], t.cols[i])\n+\t\tdoTest(t, norm.NFD, t.cols[4], t.cols[i])\n+\t\tdoTest(t, norm.NFKC, t.cols[3], t.cols[i])\n+\t\tdoTest(t, norm.NFKD, t.cols[4], t.cols[i])\n+\t}\n+}\n+\n+func CharacterByCharacterTests() {\n+\ttests := part[1].tests\n+\tlast := 0\n+\tfor i := 0; i <= len(tests); i++ { // last one is special case\n+\t\tvar rune int\n+\t\tif i == len(tests) {\n+\t\t\trune = 0x2FA1E // Don't have to go to 0x10FFFF\n+\t\t} else {\n+\t\t\trune = tests[i].rune\n+\t\t}\n+\t\tfor last++; last < rune; last++ {\n+\t\t\t// Check all characters that were not explicitly listed in the test.\n+\t\t\tt := &Test{partnr: 1, number: -1}\n+\t\t\tchar := string(last)\n+\t\t\tdoTest(t, norm.NFC, char, char)\n+\t\t\tdoTest(t, norm.NFD, char, char)\n+\t\t\tdoTest(t, norm.NFKC, char, char)\n+\t\t\tdoTest(t, norm.NFKD, char, char)\n+\t\t}\n+\t\tif i < len(tests) {\n+\t\t\tdoConformanceTests(&tests[i], 1)\n+\t\t}\n+\t}\n+}\n+\n+func StandardTests() {\n+\tfor _, j := range []int{0, 2, 3} {\n+\t\tfor _, test := range part[j].tests {\n+\t\t\tdoConformanceTests(&test, j)\n+\t\t}\n+\t}\n+}\n+\n+// PerformanceTest verifies that normalization is O(n). If any of the\n+// code does not properly check for maxCombiningChars, normalization\n+// may exhibit O(n**2) behavior.\n+func PerformanceTest() {\n+\truntime.GOMAXPROCS(2)\n+\tsuccess := make(chan bool, 1)\n+\tgo func() {\n+\t\tbuf := bytes.Repeat([]byte(\"\\u035D\"), 1024*1024)\n+\t\tbuf = append(buf, \"\\u035B\"...)\n+\t\tnorm.NFC.Append(nil, buf...)\n+\t\tsuccess <- true\n+\t}()\n+\ttimeout := time.After(1e9)\n+\tselect {\n+\tcase <-success:\n+\t\t// test completed before the timeout\n+\tcase <-timeout:\n+\t\terrorCount++\n+\t\tlogger.Printf(`unexpectedly long time to complete PerformanceTest`)\n+\t}\n+}"}, {"sha": "48ae135620130f85b2a8c2d6f08456e69ced6622", "filename": "libgo/go/exp/norm/readwriter.go", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm\n+\n+import (\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+type normWriter struct {\n+\trb  reorderBuffer\n+\tw   io.Writer\n+\tbuf []byte\n+}\n+\n+// Write implements the standard write interface.  If the last characters are\n+// not at a normalization boundary, the bytes will be buffered for the next\n+// write. The remaining bytes will be written on close.\n+func (w *normWriter) Write(data []byte) (n int, err os.Error) {\n+\t// Process data in pieces to keep w.buf size bounded.\n+\tconst chunk = 4000\n+\n+\tfor len(data) > 0 {\n+\t\t// Normalize into w.buf.\n+\t\tm := len(data)\n+\t\tif m > chunk {\n+\t\t\tm = chunk\n+\t\t}\n+\t\tw.rb.src = inputBytes(data[:m])\n+\t\tw.rb.nsrc = m\n+\t\tw.buf = doAppend(&w.rb, w.buf)\n+\t\tdata = data[m:]\n+\t\tn += m\n+\n+\t\t// Write out complete prefix, save remainder.\n+\t\t// Note that lastBoundary looks back at most 30 runes.\n+\t\ti := lastBoundary(&w.rb.f, w.buf)\n+\t\tif i == -1 {\n+\t\t\ti = 0\n+\t\t}\n+\t\tif i > 0 {\n+\t\t\tif _, err = w.w.Write(w.buf[:i]); err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tbn := copy(w.buf, w.buf[i:])\n+\t\t\tw.buf = w.buf[:bn]\n+\t\t}\n+\t}\n+\treturn n, err\n+}\n+\n+// Close forces data that remains in the buffer to be written.\n+func (w *normWriter) Close() os.Error {\n+\tif len(w.buf) > 0 {\n+\t\t_, err := w.w.Write(w.buf)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Writer returns a new writer that implements Write(b)\n+// by writing f(b) to w.  The returned writer may use an\n+// an internal buffer to maintain state across Write calls.\n+// Calling its Close method writes any buffered data to w.\n+func (f Form) Writer(w io.Writer) io.WriteCloser {\n+\twr := &normWriter{rb: reorderBuffer{}, w: w}\n+\twr.rb.init(f, nil)\n+\treturn wr\n+}\n+\n+type normReader struct {\n+\trb           reorderBuffer\n+\tr            io.Reader\n+\tinbuf        []byte\n+\toutbuf       []byte\n+\tbufStart     int\n+\tlastBoundary int\n+\terr          os.Error\n+}\n+\n+// Read implements the standard read interface.\n+func (r *normReader) Read(p []byte) (int, os.Error) {\n+\tfor {\n+\t\tif r.lastBoundary-r.bufStart > 0 {\n+\t\t\tn := copy(p, r.outbuf[r.bufStart:r.lastBoundary])\n+\t\t\tr.bufStart += n\n+\t\t\tif r.lastBoundary-r.bufStart > 0 {\n+\t\t\t\treturn n, nil\n+\t\t\t}\n+\t\t\treturn n, r.err\n+\t\t}\n+\t\tif r.err != nil {\n+\t\t\treturn 0, r.err\n+\t\t}\n+\t\toutn := copy(r.outbuf, r.outbuf[r.lastBoundary:])\n+\t\tr.outbuf = r.outbuf[0:outn]\n+\t\tr.bufStart = 0\n+\n+\t\tn, err := r.r.Read(r.inbuf)\n+\t\tr.rb.src = inputBytes(r.inbuf[0:n])\n+\t\tr.rb.nsrc, r.err = n, err\n+\t\tif n > 0 {\n+\t\t\tr.outbuf = doAppend(&r.rb, r.outbuf)\n+\t\t}\n+\t\tif err == os.EOF {\n+\t\t\tr.lastBoundary = len(r.outbuf)\n+\t\t} else {\n+\t\t\tr.lastBoundary = lastBoundary(&r.rb.f, r.outbuf)\n+\t\t\tif r.lastBoundary == -1 {\n+\t\t\t\tr.lastBoundary = 0\n+\t\t\t}\n+\t\t}\n+\t}\n+\tpanic(\"should not reach here\")\n+}\n+\n+// Reader returns a new reader that implements Read\n+// by reading data from r and returning f(data).\n+func (f Form) Reader(r io.Reader) io.Reader {\n+\tconst chunk = 4000\n+\tbuf := make([]byte, chunk)\n+\trr := &normReader{rb: reorderBuffer{}, r: r, inbuf: buf}\n+\trr.rb.init(f, buf)\n+\treturn rr\n+}"}, {"sha": "68652efa65b175ab6bc9ec6ef40f42fb08833165", "filename": "libgo/go/exp/norm/readwriter_test.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package norm\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var ioTests = []AppendTest{\n+\t{\"\", strings.Repeat(\"a\\u0316\\u0300\", 6), strings.Repeat(\"\\u00E0\\u0316\", 6)},\n+\t{\"\", strings.Repeat(\"a\\u0300\\u0316\", 4000), strings.Repeat(\"\\u00E0\\u0316\", 4000)},\n+\t{\"\", strings.Repeat(\"\\x80\\x80\", 4000), strings.Repeat(\"\\x80\\x80\", 4000)},\n+\t{\"\", \"\\u0041\\u0307\\u0304\", \"\\u01E0\"},\n+}\n+\n+var bufSizes = []int{1, 2, 3, 4, 5, 6, 7, 8, 100, 101, 102, 103, 4000, 4001, 4002, 4003}\n+\n+func readFunc(size int) appendFunc {\n+\treturn func(f Form, out []byte, s string) []byte {\n+\t\tout = append(out, s...)\n+\t\tr := f.Reader(bytes.NewBuffer(out))\n+\t\tbuf := make([]byte, size)\n+\t\tresult := []byte{}\n+\t\tfor n, err := 0, os.Error(nil); err == nil; {\n+\t\t\tn, err = r.Read(buf)\n+\t\t\tresult = append(result, buf[:n]...)\n+\t\t}\n+\t\treturn result\n+\t}\n+}\n+\n+func TestReader(t *testing.T) {\n+\tfor _, s := range bufSizes {\n+\t\tname := fmt.Sprintf(\"TestReader%da\", s)\n+\t\trunAppendTests(t, name, NFKC, readFunc(s), appendTests)\n+\t\tname = fmt.Sprintf(\"TestReader%db\", s)\n+\t\trunAppendTests(t, name, NFKC, readFunc(s), ioTests)\n+\t}\n+}\n+\n+func writeFunc(size int) appendFunc {\n+\treturn func(f Form, out []byte, s string) []byte {\n+\t\tin := append(out, s...)\n+\t\tresult := new(bytes.Buffer)\n+\t\tw := f.Writer(result)\n+\t\tbuf := make([]byte, size)\n+\t\tfor n := 0; len(in) > 0; in = in[n:] {\n+\t\t\tn = copy(buf, in)\n+\t\t\t_, _ = w.Write(buf[:n])\n+\t\t}\n+\t\tw.Close()\n+\t\treturn result.Bytes()\n+\t}\n+}\n+\n+func TestWriter(t *testing.T) {\n+\tfor _, s := range bufSizes {\n+\t\tname := fmt.Sprintf(\"TestWriter%da\", s)\n+\t\trunAppendTests(t, name, NFKC, writeFunc(s), appendTests)\n+\t\tname = fmt.Sprintf(\"TestWriter%db\", s)\n+\t\trunAppendTests(t, name, NFKC, writeFunc(s), ioTests)\n+\t}\n+}"}, {"sha": "55ff052dcbc3b0ec7934ce20097a71e597bebb30", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 3136, "deletions": 2945, "changes": 6081, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "93cb9c3390324524ec4ab5400956a162dc1932a1", "filename": "libgo/go/exp/norm/trie.go", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -4,9 +4,44 @@\n \n package norm\n \n+type valueRange struct {\n+\tvalue  uint16 // header: value:stride\n+\tlo, hi byte   // header: lo:n\n+}\n+\n type trie struct {\n-\tindex  []uint8\n-\tvalues []uint16\n+\tindex        []uint8\n+\tvalues       []uint16\n+\tsparse       []valueRange\n+\tsparseOffset []uint16\n+\tcutoff       uint8 // indices >= cutoff are sparse\n+}\n+\n+// lookupValue determines the type of block n and looks up the value for b.\n+// For n < t.cutoff, the block is a simple lookup table. Otherwise, the block\n+// is a list of ranges with an accompanying value. Given a matching range r,\n+// the value for b is by r.value + (b - r.lo) * stride.\n+func (t *trie) lookupValue(n uint8, b byte) uint16 {\n+\tif n < t.cutoff {\n+\t\treturn t.values[uint16(n)<<6+uint16(b&maskx)]\n+\t}\n+\toffset := t.sparseOffset[n-t.cutoff]\n+\theader := t.sparse[offset]\n+\tlo := offset + 1\n+\thi := lo + uint16(header.lo)\n+\tfor lo < hi {\n+\t\tm := lo + (hi-lo)/2\n+\t\tr := t.sparse[m]\n+\t\tif r.lo <= b && b <= r.hi {\n+\t\t\treturn r.value + uint16(b-r.lo)*header.value\n+\t\t}\n+\t\tif b < r.lo {\n+\t\t\thi = m\n+\t\t} else {\n+\t\t\tlo = m + 1\n+\t\t}\n+\t}\n+\treturn 0\n }\n \n const (\n@@ -44,8 +79,7 @@ func (t *trie) lookup(s []byte) (v uint16, sz int) {\n \t\tif c1 < tx || t2 <= c1 {\n \t\t\treturn 0, 1\n \t\t}\n-\t\to := uint16(i)<<6 + uint16(c1)&maskx\n-\t\treturn t.values[o], 2\n+\t\treturn t.lookupValue(i, c1), 2\n \tcase c0 < t4:\n \t\tif len(s) < 3 {\n \t\t\treturn 0, 0\n@@ -61,8 +95,7 @@ func (t *trie) lookup(s []byte) (v uint16, sz int) {\n \t\tif c2 < tx || t2 <= c2 {\n \t\t\treturn 0, 2\n \t\t}\n-\t\to = uint16(i)<<6 + uint16(c2)&maskx\n-\t\treturn t.values[o], 3\n+\t\treturn t.lookupValue(i, c2), 3\n \tcase c0 < t5:\n \t\tif len(s) < 4 {\n \t\t\treturn 0, 0\n@@ -84,18 +117,7 @@ func (t *trie) lookup(s []byte) (v uint16, sz int) {\n \t\tif c3 < tx || t2 <= c3 {\n \t\t\treturn 0, 3\n \t\t}\n-\t\to = uint16(i)<<6 + uint16(c3)&maskx\n-\t\treturn t.values[o], 4\n-\tcase c0 < t6:\n-\t\tif len(s) < 5 {\n-\t\t\treturn 0, 0\n-\t\t}\n-\t\treturn 0, 5\n-\tcase c0 < te:\n-\t\tif len(s) < 6 {\n-\t\t\treturn 0, 0\n-\t\t}\n-\t\treturn 0, 6\n+\t\treturn t.lookupValue(i, c3), 4\n \t}\n \t// Illegal rune\n \treturn 0, 1\n@@ -120,8 +142,7 @@ func (t *trie) lookupString(s string) (v uint16, sz int) {\n \t\tif c1 < tx || t2 <= c1 {\n \t\t\treturn 0, 1\n \t\t}\n-\t\to := uint16(i)<<6 + uint16(c1)&maskx\n-\t\treturn t.values[o], 2\n+\t\treturn t.lookupValue(i, c1), 2\n \tcase c0 < t4:\n \t\tif len(s) < 3 {\n \t\t\treturn 0, 0\n@@ -137,8 +158,7 @@ func (t *trie) lookupString(s string) (v uint16, sz int) {\n \t\tif c2 < tx || t2 <= c2 {\n \t\t\treturn 0, 2\n \t\t}\n-\t\to = uint16(i)<<6 + uint16(c2)&maskx\n-\t\treturn t.values[o], 3\n+\t\treturn t.lookupValue(i, c2), 3\n \tcase c0 < t5:\n \t\tif len(s) < 4 {\n \t\t\treturn 0, 0\n@@ -160,18 +180,7 @@ func (t *trie) lookupString(s string) (v uint16, sz int) {\n \t\tif c3 < tx || t2 <= c3 {\n \t\t\treturn 0, 3\n \t\t}\n-\t\to = uint16(i)<<6 + uint16(c3)&maskx\n-\t\treturn t.values[o], 4\n-\tcase c0 < t6:\n-\t\tif len(s) < 5 {\n-\t\t\treturn 0, 0\n-\t\t}\n-\t\treturn 0, 5\n-\tcase c0 < te:\n-\t\tif len(s) < 6 {\n-\t\t\treturn 0, 0\n-\t\t}\n-\t\treturn 0, 6\n+\t\treturn t.lookupValue(i, c3), 4\n \t}\n \t// Illegal rune\n \treturn 0, 1\n@@ -188,19 +197,16 @@ func (t *trie) lookupUnsafe(s []byte) uint16 {\n \t\treturn 0\n \t}\n \ti := t.index[c0]\n-\to := uint16(i)<<6 + uint16(s[1])&maskx\n \tif c0 < t3 {\n-\t\treturn t.values[o]\n+\t\treturn t.lookupValue(i, s[1])\n \t}\n-\ti = t.index[o]\n-\to = uint16(i)<<6 + uint16(s[2])&maskx\n+\ti = t.index[uint16(i)<<6+uint16(s[1])&maskx]\n \tif c0 < t4 {\n-\t\treturn t.values[o]\n+\t\treturn t.lookupValue(i, s[2])\n \t}\n-\ti = t.index[o]\n-\to = uint16(i)<<6 + uint16(s[3])&maskx\n+\ti = t.index[uint16(i)<<6+uint16(s[2])&maskx]\n \tif c0 < t5 {\n-\t\treturn t.values[o]\n+\t\treturn t.lookupValue(i, s[3])\n \t}\n \treturn 0\n }\n@@ -216,19 +222,16 @@ func (t *trie) lookupStringUnsafe(s string) uint16 {\n \t\treturn 0\n \t}\n \ti := t.index[c0]\n-\to := uint16(i)<<6 + uint16(s[1])&maskx\n \tif c0 < t3 {\n-\t\treturn t.values[o]\n+\t\treturn t.lookupValue(i, s[1])\n \t}\n-\ti = t.index[o]\n-\to = uint16(i)<<6 + uint16(s[2])&maskx\n+\ti = t.index[uint16(i)<<6+uint16(s[1])&maskx]\n \tif c0 < t4 {\n-\t\treturn t.values[o]\n+\t\treturn t.lookupValue(i, s[2])\n \t}\n-\ti = t.index[o]\n-\to = uint16(i)<<6 + uint16(s[3])&maskx\n+\ti = t.index[uint16(i)<<6+uint16(s[2])&maskx]\n \tif c0 < t5 {\n-\t\treturn t.values[o]\n+\t\treturn t.lookupValue(i, s[3])\n \t}\n \treturn 0\n }"}, {"sha": "5649fb7eea7b09b3f16da3a8f74b3871a4963f6e", "filename": "libgo/go/exp/norm/trie_test.go", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -8,6 +8,41 @@ import (\n // Test data is located in triedata_test.go; generated by maketesttables.\n var testdata = testdataTrie\n \n+type rangeTest struct {\n+\tblock   uint8\n+\tlookup  byte\n+\tresult  uint16\n+\ttable   []valueRange\n+\toffsets []uint16\n+}\n+\n+var range1Off = []uint16{0, 2}\n+var range1 = []valueRange{\n+\t{0, 1, 0},\n+\t{1, 0x80, 0x80},\n+\t{0, 2, 0},\n+\t{1, 0x80, 0x80},\n+\t{9, 0xff, 0xff},\n+}\n+\n+var rangeTests = []rangeTest{\n+\t{10, 0x80, 1, range1, range1Off},\n+\t{10, 0x00, 0, range1, range1Off},\n+\t{11, 0x80, 1, range1, range1Off},\n+\t{11, 0xff, 9, range1, range1Off},\n+\t{11, 0x00, 0, range1, range1Off},\n+}\n+\n+func TestLookupSparse(t *testing.T) {\n+\tfor i, test := range rangeTests {\n+\t\tn := trie{sparse: test.table, sparseOffset: test.offsets, cutoff: 10}\n+\t\tv := n.lookupValue(test.block, test.lookup)\n+\t\tif v != test.result {\n+\t\t\tt.Errorf(\"LookupSparse:%d: found %X; want %X\", i, v, test.result)\n+\t\t}\n+\t}\n+}\n+\n // Test cases for illegal runes.\n type trietest struct {\n \tsize  int\n@@ -32,8 +67,10 @@ var tests = []trietest{\n \t{0, []byte{t2}},\n \t{0, []byte{t3, tx}},\n \t{0, []byte{t4, tx, tx}},\n-\t{0, []byte{t5, tx, tx, tx}},\n-\t{0, []byte{t6, tx, tx, tx, tx}},\n+\n+\t// we only support UTF-8 up to utf8.UTFMax bytes (4 bytes)\n+\t{1, []byte{t5, tx, tx, tx, tx}},\n+\t{1, []byte{t6, tx, tx, tx, tx, tx}},\n }\n \n func mkUtf8(rune int) ([]byte, int) {\n@@ -47,10 +84,10 @@ func TestLookup(t *testing.T) {\n \t\tb, szg := mkUtf8(tt)\n \t\tv, szt := testdata.lookup(b)\n \t\tif int(v) != i {\n-\t\t\tt.Errorf(\"lookup(%U): found value %#x, expected %#x\", i, v, i)\n+\t\t\tt.Errorf(\"lookup(%U): found value %#x, expected %#x\", tt, v, i)\n \t\t}\n \t\tif szt != szg {\n-\t\t\tt.Errorf(\"lookup(%U): found size %d, expected %d\", i, szt, szg)\n+\t\t\tt.Errorf(\"lookup(%U): found size %d, expected %d\", tt, szt, szg)\n \t\t}\n \t}\n \tfor i, tt := range tests {"}, {"sha": "e8898e5d4251ba4b34b19806a813987039d8917b", "filename": "libgo/go/exp/norm/triedata_test.go", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -4,34 +4,55 @@\n \n package norm\n \n-var testRunes = []int{1, 12, 127, 128, 256, 2047, 2048, 2457, 65535, 65536, 65793, 1114111}\n+var testRunes = []int{1, 12, 127, 128, 256, 2047, 2048, 2457, 65535, 65536, 65793, 1114111, 512, 513, 514, 528, 533}\n \n-// testdataValues: 768 entries, 1536 bytes\n+// testdataValues: 192 entries, 384 bytes\n // Block 2 is the null block.\n-var testdataValues = [768]uint16{\n+var testdataValues = [192]uint16{\n \t// Block 0x0, offset 0x0\n \t0x000c: 0x0001,\n \t// Block 0x1, offset 0x40\n \t0x007f: 0x0002,\n \t// Block 0x2, offset 0x80\n-\t// Block 0x3, offset 0xc0\n-\t0x00c0: 0x0003,\n-\t// Block 0x4, offset 0x100\n-\t0x0100: 0x0004,\n-\t// Block 0x5, offset 0x140\n-\t0x017f: 0x0005,\n-\t// Block 0x6, offset 0x180\n-\t0x0180: 0x0006,\n-\t// Block 0x7, offset 0x1c0\n-\t0x01d9: 0x0007,\n-\t// Block 0x8, offset 0x200\n-\t0x023f: 0x0008,\n-\t// Block 0x9, offset 0x240\n-\t0x0240: 0x0009,\n-\t// Block 0xa, offset 0x280\n-\t0x0281: 0x000a,\n-\t// Block 0xb, offset 0x2c0\n-\t0x02ff: 0x000b,\n+}\n+\n+// testdataSparseOffset: 10 entries, 20 bytes\n+var testdataSparseOffset = []uint16{0x0, 0x2, 0x4, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14}\n+\n+// testdataSparseValues: 22 entries, 88 bytes\n+var testdataSparseValues = [22]valueRange{\n+\t// Block 0x0, offset 0x1\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0003, lo: 0x80, hi: 0x80},\n+\t// Block 0x1, offset 0x2\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0004, lo: 0x80, hi: 0x80},\n+\t// Block 0x2, offset 0x3\n+\t{value: 0x0001, lo: 0x03},\n+\t{value: 0x000c, lo: 0x80, hi: 0x82},\n+\t{value: 0x000f, lo: 0x90, hi: 0x90},\n+\t{value: 0x0010, lo: 0x95, hi: 0x95},\n+\t// Block 0x3, offset 0x4\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0005, lo: 0xbf, hi: 0xbf},\n+\t// Block 0x4, offset 0x5\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0006, lo: 0x80, hi: 0x80},\n+\t// Block 0x5, offset 0x6\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0007, lo: 0x99, hi: 0x99},\n+\t// Block 0x6, offset 0x7\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0008, lo: 0xbf, hi: 0xbf},\n+\t// Block 0x7, offset 0x8\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x0009, lo: 0x80, hi: 0x80},\n+\t// Block 0x8, offset 0x9\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x000a, lo: 0x81, hi: 0x81},\n+\t// Block 0x9, offset 0xa\n+\t{value: 0x0000, lo: 0x01},\n+\t{value: 0x000b, lo: 0xbf, hi: 0xbf},\n }\n \n // testdataLookup: 640 bytes\n@@ -42,22 +63,23 @@ var testdataLookup = [640]uint8{\n \t// Block 0x2, offset 0x80\n \t// Block 0x3, offset 0xc0\n \t0x0c2: 0x03, 0x0c4: 0x04,\n-\t0x0df: 0x05,\n+\t0x0c8: 0x05,\n+\t0x0df: 0x06,\n \t0x0e0: 0x04,\n \t0x0ef: 0x05,\n \t0x0f0: 0x07, 0x0f4: 0x09,\n \t// Block 0x4, offset 0x100\n-\t0x120: 0x06, 0x126: 0x07,\n+\t0x120: 0x07, 0x126: 0x08,\n \t// Block 0x5, offset 0x140\n-\t0x17f: 0x08,\n+\t0x17f: 0x09,\n \t// Block 0x6, offset 0x180\n-\t0x180: 0x09, 0x184: 0x0a,\n+\t0x180: 0x0a, 0x184: 0x0b,\n \t// Block 0x7, offset 0x1c0\n \t0x1d0: 0x06,\n \t// Block 0x8, offset 0x200\n-\t0x23f: 0x0b,\n+\t0x23f: 0x0c,\n \t// Block 0x9, offset 0x240\n \t0x24f: 0x08,\n }\n \n-var testdataTrie = trie{testdataLookup[:], testdataValues[:]}\n+var testdataTrie = trie{testdataLookup[:], testdataValues[:], testdataSparseValues[:], testdataSparseOffset[:], 3}"}, {"sha": "515e1c7860bb6f99c4109c87985dda2d12e77a57", "filename": "libgo/go/exp/norm/triegen.go", "status": "modified", "additions": 129, "deletions": 30, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -17,10 +17,13 @@ import (\n \t\"utf8\"\n )\n \n+const blockSize = 64\n+const maxSparseEntries = 16\n+\n // Intermediate trie structure\n type trieNode struct {\n \ttable [256]*trieNode\n-\tvalue uint16\n+\tvalue int\n \tb     byte\n \tleaf  bool\n }\n@@ -53,6 +56,44 @@ func (n trieNode) isInternal() bool {\n \treturn internal\n }\n \n+func (n trieNode) mostFrequentStride() int {\n+\tcounts := make(map[int]int)\n+\tv := 0\n+\tfor _, t := range n.table[0x80 : 0x80+blockSize] {\n+\t\tif t != nil {\n+\t\t\tif stride := t.value - v; v != 0 && stride >= 0 {\n+\t\t\t\tcounts[stride]++\n+\t\t\t}\n+\t\t\tv = t.value\n+\t\t}\n+\t}\n+\tvar maxs, maxc int\n+\tfor stride, cnt := range counts {\n+\t\tif cnt > maxc {\n+\t\t\tmaxs, maxc = stride, cnt\n+\t\t}\n+\t}\n+\treturn maxs\n+}\n+\n+func (n trieNode) countSparseEntries() int {\n+\tstride := n.mostFrequentStride()\n+\tvar count, v int\n+\tfor _, t := range n.table[0x80 : 0x80+blockSize] {\n+\t\ttv := 0\n+\t\tif t != nil {\n+\t\t\ttv = t.value\n+\t\t}\n+\t\tif tv-v != stride {\n+\t\t\tif tv != 0 {\n+\t\t\t\tcount++\n+\t\t\t}\n+\t\t}\n+\t\tv = tv\n+\t}\n+\treturn count\n+}\n+\n func (n *trieNode) insert(rune int, value uint16) {\n \tvar p [utf8.UTFMax]byte\n \tsz := utf8.EncodeRune(p[:], rune)\n@@ -69,35 +110,40 @@ func (n *trieNode) insert(rune int, value uint16) {\n \t\t}\n \t\tn = nn\n \t}\n-\tn.value = value\n+\tn.value = int(value)\n \tn.leaf = true\n }\n \n type nodeIndex struct {\n \tlookupBlocks []*trieNode\n \tvalueBlocks  []*trieNode\n+\tsparseBlocks []*trieNode\n+\tsparseOffset []uint16\n+\tsparseCount  int\n \n-\tlookupBlockIdx map[uint32]uint16\n-\tvalueBlockIdx  map[uint32]uint16\n+\tlookupBlockIdx map[uint32]int\n+\tvalueBlockIdx  map[uint32]int\n }\n \n func newIndex() *nodeIndex {\n \tindex := &nodeIndex{}\n \tindex.lookupBlocks = make([]*trieNode, 0)\n \tindex.valueBlocks = make([]*trieNode, 0)\n-\tindex.lookupBlockIdx = make(map[uint32]uint16)\n-\tindex.valueBlockIdx = make(map[uint32]uint16)\n+\tindex.sparseBlocks = make([]*trieNode, 0)\n+\tindex.sparseOffset = make([]uint16, 1)\n+\tindex.lookupBlockIdx = make(map[uint32]int)\n+\tindex.valueBlockIdx = make(map[uint32]int)\n \treturn index\n }\n \n-func computeOffsets(index *nodeIndex, n *trieNode) uint16 {\n+func computeOffsets(index *nodeIndex, n *trieNode) int {\n \tif n.leaf {\n \t\treturn n.value\n \t}\n \thasher := crc32.New(crc32.MakeTable(crc32.IEEE))\n \t// We only index continuation bytes.\n-\tfor i := 0; i < 64; i++ {\n-\t\tvar v uint16 = 0\n+\tfor i := 0; i < blockSize; i++ {\n+\t\tv := 0\n \t\tif nn := n.table[0x80+i]; nn != nil {\n \t\t\tv = computeOffsets(index, nn)\n \t\t}\n@@ -107,32 +153,40 @@ func computeOffsets(index *nodeIndex, n *trieNode) uint16 {\n \tif n.isInternal() {\n \t\tv, ok := index.lookupBlockIdx[h]\n \t\tif !ok {\n-\t\t\tv = uint16(len(index.lookupBlocks))\n+\t\t\tv = len(index.lookupBlocks)\n \t\t\tindex.lookupBlocks = append(index.lookupBlocks, n)\n \t\t\tindex.lookupBlockIdx[h] = v\n \t\t}\n \t\tn.value = v\n \t} else {\n \t\tv, ok := index.valueBlockIdx[h]\n \t\tif !ok {\n-\t\t\tv = uint16(len(index.valueBlocks))\n-\t\t\tindex.valueBlocks = append(index.valueBlocks, n)\n-\t\t\tindex.valueBlockIdx[h] = v\n+\t\t\tif c := n.countSparseEntries(); c > maxSparseEntries {\n+\t\t\t\tv = len(index.valueBlocks)\n+\t\t\t\tindex.valueBlocks = append(index.valueBlocks, n)\n+\t\t\t\tindex.valueBlockIdx[h] = v\n+\t\t\t} else {\n+\t\t\t\tv = -len(index.sparseOffset)\n+\t\t\t\tindex.sparseBlocks = append(index.sparseBlocks, n)\n+\t\t\t\tindex.sparseOffset = append(index.sparseOffset, uint16(index.sparseCount))\n+\t\t\t\tindex.sparseCount += c + 1\n+\t\t\t\tindex.valueBlockIdx[h] = v\n+\t\t\t}\n \t\t}\n \t\tn.value = v\n \t}\n \treturn n.value\n }\n \n func printValueBlock(nr int, n *trieNode, offset int) {\n-\tboff := nr * 64\n+\tboff := nr * blockSize\n \tfmt.Printf(\"\\n// Block %#x, offset %#x\", nr, boff)\n \tvar printnewline bool\n-\tfor i := 0; i < 64; i++ {\n+\tfor i := 0; i < blockSize; i++ {\n \t\tif i%6 == 0 {\n \t\t\tprintnewline = true\n \t\t}\n-\t\tv := uint16(0)\n+\t\tv := 0\n \t\tif nn := n.table[i+offset]; nn != nil {\n \t\t\tv = nn.value\n \t\t}\n@@ -141,24 +195,55 @@ func printValueBlock(nr int, n *trieNode, offset int) {\n \t\t\t\tfmt.Printf(\"\\n\")\n \t\t\t\tprintnewline = false\n \t\t\t}\n-\t\t\tfmt.Printf(\"%#04x:%#04x, \", nr*64+i, v)\n+\t\t\tfmt.Printf(\"%#04x:%#04x, \", boff+i, v)\n \t\t}\n \t}\n }\n \n-func printLookupBlock(nr int, n *trieNode, offset int) {\n-\tboff := nr * 64\n+func printSparseBlock(nr int, n *trieNode) {\n+\tboff := -n.value\n+\tfmt.Printf(\"\\n// Block %#x, offset %#x\", nr, boff)\n+\tv := 0\n+\t//stride := f(n)\n+\tstride := n.mostFrequentStride()\n+\tc := n.countSparseEntries()\n+\tfmt.Printf(\"\\n{value:%#04x,lo:%#02x},\", stride, uint8(c))\n+\tfor i, nn := range n.table[0x80 : 0x80+blockSize] {\n+\t\tnv := 0\n+\t\tif nn != nil {\n+\t\t\tnv = nn.value\n+\t\t}\n+\t\tif nv-v != stride {\n+\t\t\tif v != 0 {\n+\t\t\t\tfmt.Printf(\",hi:%#02x},\", 0x80+i-1)\n+\t\t\t}\n+\t\t\tif nv != 0 {\n+\t\t\t\tfmt.Printf(\"\\n{value:%#04x,lo:%#02x\", nv, nn.b)\n+\t\t\t}\n+\t\t}\n+\t\tv = nv\n+\t}\n+\tif v != 0 {\n+\t\tfmt.Printf(\",hi:%#02x},\", 0x80+blockSize-1)\n+\t}\n+}\n+\n+func printLookupBlock(nr int, n *trieNode, offset, cutoff int) {\n+\tboff := nr * blockSize\n \tfmt.Printf(\"\\n// Block %#x, offset %#x\", nr, boff)\n \tvar printnewline bool\n-\tfor i := 0; i < 64; i++ {\n+\tfor i := 0; i < blockSize; i++ {\n \t\tif i%8 == 0 {\n \t\t\tprintnewline = true\n \t\t}\n-\t\tv := uint16(0)\n+\t\tv := 0\n \t\tif nn := n.table[i+offset]; nn != nil {\n \t\t\tv = nn.value\n \t\t}\n \t\tif v != 0 {\n+\t\t\tif v < 0 {\n+\t\t\t\tv = -v - 1 + cutoff\n+\t\t\t}\n \t\t\tif printnewline {\n \t\t\t\tfmt.Printf(\"\\n\")\n \t\t\t\tprintnewline = false\n@@ -182,7 +267,7 @@ func (t *trieNode) printTables(name string) int {\n \t\t}\n \t}\n \n-\tnv := len(index.valueBlocks) * 64\n+\tnv := len(index.valueBlocks) * blockSize\n \tfmt.Printf(\"// %sValues: %d entries, %d bytes\\n\", name, nv, nv*2)\n \tfmt.Printf(\"// Block 2 is the null block.\\n\")\n \tfmt.Printf(\"var %sValues = [%d]uint16 {\", name, nv)\n@@ -194,18 +279,32 @@ func (t *trieNode) printTables(name string) int {\n \t}\n \tfmt.Print(\"\\n}\\n\\n\")\n \n-\tni := len(index.lookupBlocks) * 64\n+\tls := len(index.sparseBlocks)\n+\tfmt.Printf(\"// %sSparseOffset: %d entries, %d bytes\\n\", name, ls, ls*2)\n+\tfmt.Printf(\"var %sSparseOffset = %#v\\n\\n\", name, index.sparseOffset[1:])\n+\n+\tns := index.sparseCount\n+\tfmt.Printf(\"// %sSparseValues: %d entries, %d bytes\\n\", name, ns, ns*4)\n+\tfmt.Printf(\"var %sSparseValues = [%d]valueRange {\", name, ns)\n+\tfor i, n := range index.sparseBlocks {\n+\t\tprintSparseBlock(i, n)\n+\t}\n+\tfmt.Print(\"\\n}\\n\\n\")\n+\n+\tcutoff := len(index.valueBlocks)\n+\tni := len(index.lookupBlocks) * blockSize\n \tfmt.Printf(\"// %sLookup: %d bytes\\n\", name, ni)\n \tfmt.Printf(\"// Block 0 is the null block.\\n\")\n \tfmt.Printf(\"var %sLookup = [%d]uint8 {\", name, ni)\n-\tprintLookupBlock(0, newNode(), 0)\n-\tprintLookupBlock(1, newNode(), 0)\n-\tprintLookupBlock(2, newNode(), 0)\n-\tprintLookupBlock(3, t, 0xC0)\n+\tprintLookupBlock(0, newNode(), 0, cutoff)\n+\tprintLookupBlock(1, newNode(), 0, cutoff)\n+\tprintLookupBlock(2, newNode(), 0, cutoff)\n+\tprintLookupBlock(3, t, 0xC0, cutoff)\n \tfor i := 4; i < len(index.lookupBlocks); i++ {\n-\t\tprintLookupBlock(i, index.lookupBlocks[i], 0x80)\n+\t\tprintLookupBlock(i, index.lookupBlocks[i], 0x80, cutoff)\n \t}\n \tfmt.Print(\"\\n}\\n\\n\")\n-\tfmt.Printf(\"var %sTrie = trie{ %sLookup[:], %sValues[:] }\\n\\n\", name, name, name)\n-\treturn nv*2 + ni\n+\tfmt.Printf(\"var %sTrie = trie{ %sLookup[:], %sValues[:], %sSparseValues[:], %sSparseOffset[:], %d}\\n\\n\",\n+\t\tname, name, name, name, name, cutoff)\n+\treturn nv*2 + ns*4 + ni + ls*2\n }"}, {"sha": "2b1fd3d0d4241d51745888de233afaf9af405b41", "filename": "libgo/go/exp/spdy/read.go", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fread.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -214,7 +214,7 @@ func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame)\n \t}\n \t// Remove this condition when we bump Version to 3.\n \tif Version >= 3 {\n-\t\tfor h, _ := range frame.Headers {\n+\t\tfor h := range frame.Headers {\n \t\t\tif invalidReqHeaders[h] {\n \t\t\t\treturn &Error{InvalidHeaderPresent, frame.StreamId}\n \t\t\t}\n@@ -247,7 +247,7 @@ func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) o\n \t}\n \t// Remove this condition when we bump Version to 3.\n \tif Version >= 3 {\n-\t\tfor h, _ := range frame.Headers {\n+\t\tfor h := range frame.Headers {\n \t\t\tif invalidRespHeaders[h] {\n \t\t\t\treturn &Error{InvalidHeaderPresent, frame.StreamId}\n \t\t\t}\n@@ -287,7 +287,7 @@ func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) os.\n \t\t} else {\n \t\t\tinvalidHeaders = invalidRespHeaders\n \t\t}\n-\t\tfor h, _ := range frame.Headers {\n+\t\tfor h := range frame.Headers {\n \t\t\tif invalidHeaders[h] {\n \t\t\t\treturn &Error{InvalidHeaderPresent, frame.StreamId}\n \t\t\t}", "previous_filename": "libgo/go/http/spdy/read.go"}, {"sha": "cb91e028613c5be13b57dd9a413df8211b4951c8", "filename": "libgo/go/exp/spdy/spdy_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Fspdy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Fspdy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fspdy_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/http/spdy/spdy_test.go"}, {"sha": "41cafb1741f2a3723f88ef93f809d5bab3f6b285", "filename": "libgo/go/exp/spdy/types.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Ftypes.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/http/spdy/types.go"}, {"sha": "7d40bbe9fe2b6a030a1c8003e62947c057b2b5e2", "filename": "libgo/go/exp/spdy/write.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fspdy%2Fwrite.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/http/spdy/write.go"}, {"sha": "a35e0be9cbee6b8313aca01e1c02b78f4a977ef3", "filename": "libgo/go/exp/sql/convert.go", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Type conversions for Scan.\n+\n+package sql\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"strconv\"\n+)\n+\n+// convertAssign copies to dest the value in src, converting it if possible.\n+// An error is returned if the copy would result in loss of information.\n+// dest should be a pointer type.\n+func convertAssign(dest, src interface{}) os.Error {\n+\t// Common cases, without reflect.  Fall through.\n+\tswitch s := src.(type) {\n+\tcase string:\n+\t\tswitch d := dest.(type) {\n+\t\tcase *string:\n+\t\t\t*d = s\n+\t\t\treturn nil\n+\t\t}\n+\tcase []byte:\n+\t\tswitch d := dest.(type) {\n+\t\tcase *string:\n+\t\t\t*d = string(s)\n+\t\t\treturn nil\n+\t\tcase *[]byte:\n+\t\t\t*d = s\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tsv := reflect.ValueOf(src)\n+\n+\tswitch d := dest.(type) {\n+\tcase *string:\n+\t\tswitch sv.Kind() {\n+\t\tcase reflect.Bool,\n+\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n+\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n+\t\t\treflect.Float32, reflect.Float64:\n+\t\t\t*d = fmt.Sprintf(\"%v\", src)\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tif scanner, ok := dest.(ScannerInto); ok {\n+\t\treturn scanner.ScanInto(src)\n+\t}\n+\n+\tdpv := reflect.ValueOf(dest)\n+\tif dpv.Kind() != reflect.Ptr {\n+\t\treturn os.NewError(\"destination not a pointer\")\n+\t}\n+\n+\tdv := reflect.Indirect(dpv)\n+\tif dv.Kind() == sv.Kind() {\n+\t\tdv.Set(sv)\n+\t\treturn nil\n+\t}\n+\n+\tswitch dv.Kind() {\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\tif s, ok := asString(src); ok {\n+\t\t\ti64, err := strconv.Atoi64(s)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"converting string %q to a %s: %v\", s, dv.Kind(), err)\n+\t\t\t}\n+\t\t\tif dv.OverflowInt(i64) {\n+\t\t\t\treturn fmt.Errorf(\"string %q overflows %s\", s, dv.Kind())\n+\t\t\t}\n+\t\t\tdv.SetInt(i64)\n+\t\t\treturn nil\n+\t\t}\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n+\t\tif s, ok := asString(src); ok {\n+\t\t\tu64, err := strconv.Atoui64(s)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"converting string %q to a %s: %v\", s, dv.Kind(), err)\n+\t\t\t}\n+\t\t\tif dv.OverflowUint(u64) {\n+\t\t\t\treturn fmt.Errorf(\"string %q overflows %s\", s, dv.Kind())\n+\t\t\t}\n+\t\t\tdv.SetUint(u64)\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\treturn fmt.Errorf(\"unsupported driver -> Scan pair: %T -> %T\", src, dest)\n+}\n+\n+func asString(src interface{}) (s string, ok bool) {\n+\tswitch v := src.(type) {\n+\tcase string:\n+\t\treturn v, true\n+\tcase []byte:\n+\t\treturn string(v), true\n+\t}\n+\treturn \"\", false\n+}"}, {"sha": "88ba8e7a77a92b78d83576caa09436e3f8da066f", "filename": "libgo/go/exp/sql/convert_test.go", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sql\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+type conversionTest struct {\n+\ts, d interface{} // source and destination\n+\n+\t// following are used if they're non-zero\n+\twantint  int64\n+\twantuint uint64\n+\twantstr  string\n+\twanterr  string\n+}\n+\n+// Target variables for scanning into.\n+var (\n+\tscanstr    string\n+\tscanint    int\n+\tscanint8   int8\n+\tscanint16  int16\n+\tscanint32  int32\n+\tscanuint8  uint8\n+\tscanuint16 uint16\n+)\n+\n+var conversionTests = []conversionTest{\n+\t// Exact conversions (destination pointer type matches source type)\n+\t{s: \"foo\", d: &scanstr, wantstr: \"foo\"},\n+\t{s: 123, d: &scanint, wantint: 123},\n+\n+\t// To strings\n+\t{s: []byte(\"byteslice\"), d: &scanstr, wantstr: \"byteslice\"},\n+\t{s: 123, d: &scanstr, wantstr: \"123\"},\n+\t{s: int8(123), d: &scanstr, wantstr: \"123\"},\n+\t{s: int64(123), d: &scanstr, wantstr: \"123\"},\n+\t{s: uint8(123), d: &scanstr, wantstr: \"123\"},\n+\t{s: uint16(123), d: &scanstr, wantstr: \"123\"},\n+\t{s: uint32(123), d: &scanstr, wantstr: \"123\"},\n+\t{s: uint64(123), d: &scanstr, wantstr: \"123\"},\n+\t{s: 1.5, d: &scanstr, wantstr: \"1.5\"},\n+\n+\t// Strings to integers\n+\t{s: \"255\", d: &scanuint8, wantuint: 255},\n+\t{s: \"256\", d: &scanuint8, wanterr: `string \"256\" overflows uint8`},\n+\t{s: \"256\", d: &scanuint16, wantuint: 256},\n+\t{s: \"-1\", d: &scanint, wantint: -1},\n+\t{s: \"foo\", d: &scanint, wanterr: `converting string \"foo\" to a int: parsing \"foo\": Invalid argument`},\n+}\n+\n+func intValue(intptr interface{}) int64 {\n+\treturn reflect.Indirect(reflect.ValueOf(intptr)).Int()\n+}\n+\n+func uintValue(intptr interface{}) uint64 {\n+\treturn reflect.Indirect(reflect.ValueOf(intptr)).Uint()\n+}\n+\n+func TestConversions(t *testing.T) {\n+\tfor n, ct := range conversionTests {\n+\t\terr := convertAssign(ct.d, ct.s)\n+\t\terrstr := \"\"\n+\t\tif err != nil {\n+\t\t\terrstr = err.String()\n+\t\t}\n+\t\terrf := func(format string, args ...interface{}) {\n+\t\t\tbase := fmt.Sprintf(\"convertAssign #%d: for %v (%T) -> %T, \", n, ct.s, ct.s, ct.d)\n+\t\t\tt.Errorf(base+format, args...)\n+\t\t}\n+\t\tif errstr != ct.wanterr {\n+\t\t\terrf(\"got error %q, want error %q\", errstr, ct.wanterr)\n+\t\t}\n+\t\tif ct.wantstr != \"\" && ct.wantstr != scanstr {\n+\t\t\terrf(\"want string %q, got %q\", ct.wantstr, scanstr)\n+\t\t}\n+\t\tif ct.wantint != 0 && ct.wantint != intValue(ct.d) {\n+\t\t\terrf(\"want int %d, got %d\", ct.wantint, intValue(ct.d))\n+\t\t}\n+\t\tif ct.wantuint != 0 && ct.wantuint != uintValue(ct.d) {\n+\t\t\terrf(\"want uint %d, got %d\", ct.wantuint, uintValue(ct.d))\n+\t\t}\n+\t}\n+}\n+\n+func TestNullableString(t *testing.T) {\n+\tvar ns NullableString\n+\tconvertAssign(&ns, []byte(\"foo\"))\n+\tif !ns.Valid {\n+\t\tt.Errorf(\"expecting not null\")\n+\t}\n+\tif ns.String != \"foo\" {\n+\t\tt.Errorf(\"expecting foo; got %q\", ns.String)\n+\t}\n+\tconvertAssign(&ns, nil)\n+\tif ns.Valid {\n+\t\tt.Errorf(\"expecting null on nil\")\n+\t}\n+\tif ns.String != \"\" {\n+\t\tt.Errorf(\"expecting blank on nil; got %q\", ns.String)\n+\t}\n+}"}, {"sha": "7508b19fa199f9db9b1038552b521531cfeb197a", "filename": "libgo/go/exp/sql/driver/driver.go", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package driver defines interfaces to be implemented by database\n+// drivers as used by package sql.\n+//\n+// Code simply using databases should use package sql.\n+//\n+// Drivers only need to be aware of a subset of Go's types.  The db package\n+// will convert all types into one of the following:\n+//\n+//   int64\n+//   float64\n+//   bool\n+//   nil\n+//   []byte\n+//   string   [*] everywhere except from Rows.Next.\n+//\n+package driver\n+\n+import (\n+\t\"os\"\n+)\n+\n+// Driver is the interface that must be implemented by a database\n+// driver.\n+type Driver interface {\n+\t// Open returns a new or cached connection to the database.\n+\t// The name is a string in a driver-specific format.\n+\t//\n+\t// The returned connection is only used by one goroutine at a\n+\t// time.\n+\tOpen(name string) (Conn, os.Error)\n+}\n+\n+// Execer is an optional interface that may be implemented by a Driver\n+// or a Conn.\n+//\n+// If a Driver does not implement Execer, the sql package's DB.Exec\n+// method first obtains a free connection from its free pool or from\n+// the driver's Open method. Execer should only be implemented by\n+// drivers that can provide a more efficient implementation.\n+//\n+// If a Conn does not implement Execer, the db package's DB.Exec will\n+// first prepare a query, execute the statement, and then close the\n+// statement.\n+//\n+// All arguments are of a subset type as defined in the package docs.\n+type Execer interface {\n+\tExec(query string, args []interface{}) (Result, os.Error)\n+}\n+\n+// Conn is a connection to a database. It is not used concurrently\n+// by multiple goroutines.\n+//\n+// Conn is assumed to be stateful.\n+type Conn interface {\n+\t// Prepare returns a prepared statement, bound to this connection.\n+\tPrepare(query string) (Stmt, os.Error)\n+\n+\t// Close invalidates and potentially stops any current\n+\t// prepared statements and transactions, marking this\n+\t// connection as no longer in use.  The driver may cache or\n+\t// close its underlying connection to its database.\n+\tClose() os.Error\n+\n+\t// Begin starts and returns a new transaction.\n+\tBegin() (Tx, os.Error)\n+}\n+\n+// Result is the result of a query execution.\n+type Result interface {\n+\t// LastInsertId returns the database's auto-generated ID\n+\t// after, for example, an INSERT into a table with primary\n+\t// key.\n+\tLastInsertId() (int64, os.Error)\n+\n+\t// RowsAffected returns the number of rows affected by the\n+\t// query.\n+\tRowsAffected() (int64, os.Error)\n+}\n+\n+// Stmt is a prepared statement. It is bound to a Conn and not\n+// used by multiple goroutines concurrently.\n+type Stmt interface {\n+\t// Close closes the statement.\n+\tClose() os.Error\n+\n+\t// NumInput returns the number of placeholder parameters.\n+\tNumInput() int\n+\n+\t// Exec executes a query that doesn't return rows, such\n+\t// as an INSERT or UPDATE.  The args are all of a subset\n+\t// type as defined above.\n+\tExec(args []interface{}) (Result, os.Error)\n+\n+\t// Exec executes a query that may return rows, such as a\n+\t// SELECT.  The args of all of a subset type as defined above.\n+\tQuery(args []interface{}) (Rows, os.Error)\n+}\n+\n+// ColumnConverter may be optionally implemented by Stmt if the\n+// the statement is aware of its own columns' types and can\n+// convert from any type to a driver subset type.\n+type ColumnConverter interface {\n+\t// ColumnConverter returns a ValueConverter for the provided\n+\t// column index.  If the type of a specific column isn't known\n+\t// or shouldn't be handled specially, DefaultValueConverter\n+\t// can be returned.\n+\tColumnConverter(idx int) ValueConverter\n+}\n+\n+// Rows is an iterator over an executed query's results.\n+type Rows interface {\n+\t// Columns returns the names of the columns. The number of\n+\t// columns of the result is inferred from the length of the\n+\t// slice.  If a particular column name isn't known, an empty\n+\t// string should be returned for that entry.\n+\tColumns() []string\n+\n+\t// Close closes the rows iterator.\n+\tClose() os.Error\n+\n+\t// Next is called to populate the next row of data into\n+\t// the provided slice. The provided slice will be the same\n+\t// size as the Columns() are wide.\n+\t//\n+\t// The dest slice may be populated with only with values\n+\t// of subset types defined above, but excluding string.\n+\t// All string values must be converted to []byte.\n+\tNext(dest []interface{}) os.Error\n+}\n+\n+// Tx is a transaction.\n+type Tx interface {\n+\tCommit() os.Error\n+\tRollback() os.Error\n+}\n+\n+// RowsAffected implements Result for an INSERT or UPDATE operation\n+// which mutates a number of rows.\n+type RowsAffected int64\n+\n+var _ Result = RowsAffected(0)\n+\n+func (RowsAffected) LastInsertId() (int64, os.Error) {\n+\treturn 0, os.NewError(\"no LastInsertId available\")\n+}\n+\n+func (v RowsAffected) RowsAffected() (int64, os.Error) {\n+\treturn int64(v), nil\n+}\n+\n+// DDLSuccess is a pre-defined Result for drivers to return when a DDL\n+// command succeeds.\n+var DDLSuccess ddlSuccess\n+\n+type ddlSuccess struct{}\n+\n+var _ Result = ddlSuccess{}\n+\n+func (ddlSuccess) LastInsertId() (int64, os.Error) {\n+\treturn 0, os.NewError(\"no LastInsertId available after DDL statement\")\n+}\n+\n+func (ddlSuccess) RowsAffected() (int64, os.Error) {\n+\treturn 0, os.NewError(\"no RowsAffected available after DDL statement\")\n+}"}, {"sha": "5521d5389c3ff6a4b66507cc98c2d73fcb27608e", "filename": "libgo/go/exp/sql/driver/types.go", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package driver\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"strconv\"\n+)\n+\n+// ValueConverter is the interface providing the ConvertValue method.\n+type ValueConverter interface {\n+\t// ConvertValue converts a value to a restricted subset type.\n+\tConvertValue(v interface{}) (interface{}, os.Error)\n+}\n+\n+// Bool is a ValueConverter that converts input values to bools.\n+//\n+// The conversion rules are:\n+//  - .... TODO(bradfitz): TBD\n+var Bool boolType\n+\n+type boolType struct{}\n+\n+var _ ValueConverter = boolType{}\n+\n+func (boolType) ConvertValue(v interface{}) (interface{}, os.Error) {\n+\treturn nil, fmt.Errorf(\"TODO(bradfitz): bool conversions\")\n+}\n+\n+// Int32 is a ValueConverter that converts input values to int64,\n+// respecting the limits of an int32 value.\n+var Int32 int32Type\n+\n+type int32Type struct{}\n+\n+var _ ValueConverter = int32Type{}\n+\n+func (int32Type) ConvertValue(v interface{}) (interface{}, os.Error) {\n+\trv := reflect.ValueOf(v)\n+\tswitch rv.Kind() {\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\ti64 := rv.Int()\n+\t\tif i64 > (1<<31)-1 || i64 < -(1<<31) {\n+\t\t\treturn nil, fmt.Errorf(\"sql/driver: value %d overflows int32\", v)\n+\t\t}\n+\t\treturn i64, nil\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n+\t\tu64 := rv.Uint()\n+\t\tif u64 > (1<<31)-1 {\n+\t\t\treturn nil, fmt.Errorf(\"sql/driver: value %d overflows int32\", v)\n+\t\t}\n+\t\treturn int64(u64), nil\n+\tcase reflect.String:\n+\t\ti, err := strconv.Atoi(rv.String())\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"sql/driver: value %q can't be converted to int32\", v)\n+\t\t}\n+\t\treturn int64(i), nil\n+\t}\n+\treturn nil, fmt.Errorf(\"sql/driver: unsupported value %v (type %T) converting to int32\", v, v)\n+}\n+\n+// String is a ValueConverter that converts its input to a string.\n+// If the value is already a string or []byte, it's unchanged.\n+// If the value is of another type, conversion to string is done\n+// with fmt.Sprintf(\"%v\", v).\n+var String stringType\n+\n+type stringType struct{}\n+\n+func (stringType) ConvertValue(v interface{}) (interface{}, os.Error) {\n+\tswitch v.(type) {\n+\tcase string, []byte:\n+\t\treturn v, nil\n+\t}\n+\treturn fmt.Sprintf(\"%v\", v), nil\n+}\n+\n+// IsParameterSubsetType reports whether v is of a valid type for a\n+// parameter. These types are:\n+//\n+//   int64\n+//   float64\n+//   bool\n+//   nil\n+//   []byte\n+//   string\n+//\n+// This is the ame list as IsScanSubsetType, with the addition of\n+// string.\n+func IsParameterSubsetType(v interface{}) bool {\n+\tif IsScanSubsetType(v) {\n+\t\treturn true\n+\t}\n+\tif _, ok := v.(string); ok {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// IsScanSubsetType reports whether v is of a valid type for a\n+// value populated by Rows.Next. These types are:\n+//\n+//   int64\n+//   float64\n+//   bool\n+//   nil\n+//   []byte\n+//\n+// This is the same list as IsParameterSubsetType, without string.\n+func IsScanSubsetType(v interface{}) bool {\n+\tif v == nil {\n+\t\treturn true\n+\t}\n+\tswitch v.(type) {\n+\tcase int64, float64, []byte, bool:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// DefaultParameterConverter is the default implementation of\n+// ValueConverter that's used when a Stmt doesn't implement\n+// ColumnConverter.\n+//\n+// DefaultParameterConverter returns the given value directly if\n+// IsSubsetType(value).  Otherwise integer type are converted to\n+// int64, floats to float64, and strings to []byte.  Other types are\n+// an error.\n+var DefaultParameterConverter defaultConverter\n+\n+type defaultConverter struct{}\n+\n+var _ ValueConverter = defaultConverter{}\n+\n+func (defaultConverter) ConvertValue(v interface{}) (interface{}, os.Error) {\n+\tif IsParameterSubsetType(v) {\n+\t\treturn v, nil\n+\t}\n+\n+\trv := reflect.ValueOf(v)\n+\tswitch rv.Kind() {\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn rv.Int(), nil\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:\n+\t\treturn int64(rv.Uint()), nil\n+\tcase reflect.Uint64:\n+\t\tu64 := rv.Uint()\n+\t\tif u64 >= 1<<63 {\n+\t\t\treturn nil, fmt.Errorf(\"uint64 values with high bit set are not supported\")\n+\t\t}\n+\t\treturn int64(u64), nil\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn rv.Float(), nil\n+\t}\n+\treturn nil, fmt.Errorf(\"unsupported type %s\", rv.Kind())\n+}"}, {"sha": "c906185e5842309f8d91e69c7a9fe10dd9063a36", "filename": "libgo/go/exp/sql/fakedb_test.go", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,497 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sql\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"exp/sql/driver\"\n+)\n+\n+var _ = log.Printf\n+\n+// fakeDriver is a fake database that implements Go's driver.Driver\n+// interface, just for testing.\n+//\n+// It speaks a query language that's semantically similar to but\n+// syntantically different and simpler than SQL.  The syntax is as\n+// follows:\n+//\n+//   WIPE\n+//   CREATE|<tablename>|<col>=<type>,<col>=<type>,...\n+//     where types are: \"string\", [u]int{8,16,32,64}, \"bool\"\n+//   INSERT|<tablename>|col=val,col2=val2,col3=?\n+//   SELECT|<tablename>|projectcol1,projectcol2|filtercol=?,filtercol2=?\n+//\n+// When opening a a fakeDriver's database, it starts empty with no\n+// tables.  All tables and data are stored in memory only.\n+type fakeDriver struct {\n+\tmu        sync.Mutex\n+\topenCount int\n+\tdbs       map[string]*fakeDB\n+}\n+\n+type fakeDB struct {\n+\tname string\n+\n+\tmu     sync.Mutex\n+\tfree   []*fakeConn\n+\ttables map[string]*table\n+}\n+\n+type table struct {\n+\tmu      sync.Mutex\n+\tcolname []string\n+\tcoltype []string\n+\trows    []*row\n+}\n+\n+func (t *table) columnIndex(name string) int {\n+\tfor n, nname := range t.colname {\n+\t\tif name == nname {\n+\t\t\treturn n\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+type row struct {\n+\tcols []interface{} // must be same size as its table colname + coltype\n+}\n+\n+func (r *row) clone() *row {\n+\tnrow := &row{cols: make([]interface{}, len(r.cols))}\n+\tcopy(nrow.cols, r.cols)\n+\treturn nrow\n+}\n+\n+type fakeConn struct {\n+\tdb *fakeDB // where to return ourselves to\n+\n+\tcurrTx *fakeTx\n+}\n+\n+type fakeTx struct {\n+\tc *fakeConn\n+}\n+\n+type fakeStmt struct {\n+\tc *fakeConn\n+\tq string // just for debugging\n+\n+\tcmd   string\n+\ttable string\n+\n+\tcolName      []string      // used by CREATE, INSERT, SELECT (selected columns)\n+\tcolType      []string      // used by CREATE\n+\tcolValue     []interface{} // used by INSERT (mix of strings and \"?\" for bound params)\n+\tplaceholders int           // used by INSERT/SELECT: number of ? params\n+\n+\twhereCol []string // used by SELECT (all placeholders)\n+\n+\tplaceholderConverter []driver.ValueConverter // used by INSERT\n+}\n+\n+var fdriver driver.Driver = &fakeDriver{}\n+\n+func init() {\n+\tRegister(\"test\", fdriver)\n+}\n+\n+// Supports dsn forms:\n+//    <dbname>\n+//    <dbname>;wipe\n+func (d *fakeDriver) Open(dsn string) (driver.Conn, os.Error) {\n+\td.mu.Lock()\n+\tdefer d.mu.Unlock()\n+\td.openCount++\n+\tif d.dbs == nil {\n+\t\td.dbs = make(map[string]*fakeDB)\n+\t}\n+\tparts := strings.Split(dsn, \";\")\n+\tif len(parts) < 1 {\n+\t\treturn nil, os.NewError(\"fakedb: no database name\")\n+\t}\n+\tname := parts[0]\n+\tdb, ok := d.dbs[name]\n+\tif !ok {\n+\t\tdb = &fakeDB{name: name}\n+\t\td.dbs[name] = db\n+\t}\n+\treturn &fakeConn{db: db}, nil\n+}\n+\n+func (db *fakeDB) wipe() {\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tdb.tables = nil\n+}\n+\n+func (db *fakeDB) createTable(name string, columnNames, columnTypes []string) os.Error {\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tif db.tables == nil {\n+\t\tdb.tables = make(map[string]*table)\n+\t}\n+\tif _, exist := db.tables[name]; exist {\n+\t\treturn fmt.Errorf(\"table %q already exists\", name)\n+\t}\n+\tif len(columnNames) != len(columnTypes) {\n+\t\treturn fmt.Errorf(\"create table of %q len(names) != len(types): %d vs %d\",\n+\t\t\tname, len(columnNames), len(columnTypes))\n+\t}\n+\tdb.tables[name] = &table{colname: columnNames, coltype: columnTypes}\n+\treturn nil\n+}\n+\n+// must be called with db.mu lock held\n+func (db *fakeDB) table(table string) (*table, bool) {\n+\tif db.tables == nil {\n+\t\treturn nil, false\n+\t}\n+\tt, ok := db.tables[table]\n+\treturn t, ok\n+}\n+\n+func (db *fakeDB) columnType(table, column string) (typ string, ok bool) {\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tt, ok := db.table(table)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\tfor n, cname := range t.colname {\n+\t\tif cname == column {\n+\t\t\treturn t.coltype[n], true\n+\t\t}\n+\t}\n+\treturn \"\", false\n+}\n+\n+func (c *fakeConn) Begin() (driver.Tx, os.Error) {\n+\tif c.currTx != nil {\n+\t\treturn nil, os.NewError(\"already in a transaction\")\n+\t}\n+\tc.currTx = &fakeTx{c: c}\n+\treturn c.currTx, nil\n+}\n+\n+func (c *fakeConn) Close() os.Error {\n+\tif c.currTx != nil {\n+\t\treturn os.NewError(\"can't close; in a Transaction\")\n+\t}\n+\tif c.db == nil {\n+\t\treturn os.NewError(\"can't close; already closed\")\n+\t}\n+\tc.db = nil\n+\treturn nil\n+}\n+\n+func errf(msg string, args ...interface{}) os.Error {\n+\treturn os.NewError(\"fakedb: \" + fmt.Sprintf(msg, args...))\n+}\n+\n+// parts are table|selectCol1,selectCol2|whereCol=?,whereCol2=?\n+// (note that where where columns must always contain ? marks,\n+//  just a limitation for fakedb)\n+func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, os.Error) {\n+\tif len(parts) != 3 {\n+\t\treturn nil, errf(\"invalid SELECT syntax with %d parts; want 3\", len(parts))\n+\t}\n+\tstmt.table = parts[0]\n+\tstmt.colName = strings.Split(parts[1], \",\")\n+\tfor n, colspec := range strings.Split(parts[2], \",\") {\n+\t\tnameVal := strings.Split(colspec, \"=\")\n+\t\tif len(nameVal) != 2 {\n+\t\t\treturn nil, errf(\"SELECT on table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n+\t\t}\n+\t\tcolumn, value := nameVal[0], nameVal[1]\n+\t\t_, ok := c.db.columnType(stmt.table, column)\n+\t\tif !ok {\n+\t\t\treturn nil, errf(\"SELECT on table %q references non-existent column %q\", stmt.table, column)\n+\t\t}\n+\t\tif value != \"?\" {\n+\t\t\treturn nil, errf(\"SELECT on table %q has pre-bound value for where column %q; need a question mark\",\n+\t\t\t\tstmt.table, column)\n+\t\t}\n+\t\tstmt.whereCol = append(stmt.whereCol, column)\n+\t\tstmt.placeholders++\n+\t}\n+\treturn stmt, nil\n+}\n+\n+// parts are table|col=type,col2=type2\n+func (c *fakeConn) prepareCreate(stmt *fakeStmt, parts []string) (driver.Stmt, os.Error) {\n+\tif len(parts) != 2 {\n+\t\treturn nil, errf(\"invalid CREATE syntax with %d parts; want 2\", len(parts))\n+\t}\n+\tstmt.table = parts[0]\n+\tfor n, colspec := range strings.Split(parts[1], \",\") {\n+\t\tnameType := strings.Split(colspec, \"=\")\n+\t\tif len(nameType) != 2 {\n+\t\t\treturn nil, errf(\"CREATE table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n+\t\t}\n+\t\tstmt.colName = append(stmt.colName, nameType[0])\n+\t\tstmt.colType = append(stmt.colType, nameType[1])\n+\t}\n+\treturn stmt, nil\n+}\n+\n+// parts are table|col=?,col2=val\n+func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, os.Error) {\n+\tif len(parts) != 2 {\n+\t\treturn nil, errf(\"invalid INSERT syntax with %d parts; want 2\", len(parts))\n+\t}\n+\tstmt.table = parts[0]\n+\tfor n, colspec := range strings.Split(parts[1], \",\") {\n+\t\tnameVal := strings.Split(colspec, \"=\")\n+\t\tif len(nameVal) != 2 {\n+\t\t\treturn nil, errf(\"INSERT table %q has invalid column spec of %q (index %d)\", stmt.table, colspec, n)\n+\t\t}\n+\t\tcolumn, value := nameVal[0], nameVal[1]\n+\t\tctype, ok := c.db.columnType(stmt.table, column)\n+\t\tif !ok {\n+\t\t\treturn nil, errf(\"INSERT table %q references non-existent column %q\", stmt.table, column)\n+\t\t}\n+\t\tstmt.colName = append(stmt.colName, column)\n+\n+\t\tif value != \"?\" {\n+\t\t\tvar subsetVal interface{}\n+\t\t\t// Convert to driver subset type\n+\t\t\tswitch ctype {\n+\t\t\tcase \"string\":\n+\t\t\t\tsubsetVal = []byte(value)\n+\t\t\tcase \"int32\":\n+\t\t\t\ti, err := strconv.Atoi(value)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, errf(\"invalid conversion to int32 from %q\", value)\n+\t\t\t\t}\n+\t\t\t\tsubsetVal = int64(i) // int64 is a subset type, but not int32\n+\t\t\tdefault:\n+\t\t\t\treturn nil, errf(\"unsupported conversion for pre-bound parameter %q to type %q\", value, ctype)\n+\t\t\t}\n+\t\t\tstmt.colValue = append(stmt.colValue, subsetVal)\n+\t\t} else {\n+\t\t\tstmt.placeholders++\n+\t\t\tstmt.placeholderConverter = append(stmt.placeholderConverter, converterForType(ctype))\n+\t\t\tstmt.colValue = append(stmt.colValue, \"?\")\n+\t\t}\n+\t}\n+\treturn stmt, nil\n+}\n+\n+func (c *fakeConn) Prepare(query string) (driver.Stmt, os.Error) {\n+\tif c.db == nil {\n+\t\tpanic(\"nil c.db; conn = \" + fmt.Sprintf(\"%#v\", c))\n+\t}\n+\tparts := strings.Split(query, \"|\")\n+\tif len(parts) < 1 {\n+\t\treturn nil, errf(\"empty query\")\n+\t}\n+\tcmd := parts[0]\n+\tparts = parts[1:]\n+\tstmt := &fakeStmt{q: query, c: c, cmd: cmd}\n+\tswitch cmd {\n+\tcase \"WIPE\":\n+\t\t// Nothing\n+\tcase \"SELECT\":\n+\t\treturn c.prepareSelect(stmt, parts)\n+\tcase \"CREATE\":\n+\t\treturn c.prepareCreate(stmt, parts)\n+\tcase \"INSERT\":\n+\t\treturn c.prepareInsert(stmt, parts)\n+\tdefault:\n+\t\treturn nil, errf(\"unsupported command type %q\", cmd)\n+\t}\n+\treturn stmt, nil\n+}\n+\n+func (s *fakeStmt) ColumnConverter(idx int) driver.ValueConverter {\n+\treturn s.placeholderConverter[idx]\n+}\n+\n+func (s *fakeStmt) Close() os.Error {\n+\treturn nil\n+}\n+\n+func (s *fakeStmt) Exec(args []interface{}) (driver.Result, os.Error) {\n+\tdb := s.c.db\n+\tswitch s.cmd {\n+\tcase \"WIPE\":\n+\t\tdb.wipe()\n+\t\treturn driver.DDLSuccess, nil\n+\tcase \"CREATE\":\n+\t\tif err := db.createTable(s.table, s.colName, s.colType); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn driver.DDLSuccess, nil\n+\tcase \"INSERT\":\n+\t\treturn s.execInsert(args)\n+\t}\n+\tfmt.Printf(\"EXEC statement, cmd=%q: %#v\\n\", s.cmd, s)\n+\treturn nil, fmt.Errorf(\"unimplemented statement Exec command type of %q\", s.cmd)\n+}\n+\n+func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, os.Error) {\n+\tdb := s.c.db\n+\tif len(args) != s.placeholders {\n+\t\tpanic(\"error in pkg db; should only get here if size is correct\")\n+\t}\n+\tdb.mu.Lock()\n+\tt, ok := db.table(s.table)\n+\tdb.mu.Unlock()\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"fakedb: table %q doesn't exist\", s.table)\n+\t}\n+\n+\tt.mu.Lock()\n+\tdefer t.mu.Unlock()\n+\n+\tcols := make([]interface{}, len(t.colname))\n+\targPos := 0\n+\tfor n, colname := range s.colName {\n+\t\tcolidx := t.columnIndex(colname)\n+\t\tif colidx == -1 {\n+\t\t\treturn nil, fmt.Errorf(\"fakedb: column %q doesn't exist or dropped since prepared statement was created\", colname)\n+\t\t}\n+\t\tvar val interface{}\n+\t\tif strvalue, ok := s.colValue[n].(string); ok && strvalue == \"?\" {\n+\t\t\tval = args[argPos]\n+\t\t\targPos++\n+\t\t} else {\n+\t\t\tval = s.colValue[n]\n+\t\t}\n+\t\tcols[colidx] = val\n+\t}\n+\n+\tt.rows = append(t.rows, &row{cols: cols})\n+\treturn driver.RowsAffected(1), nil\n+}\n+\n+func (s *fakeStmt) Query(args []interface{}) (driver.Rows, os.Error) {\n+\tdb := s.c.db\n+\tif len(args) != s.placeholders {\n+\t\tpanic(\"error in pkg db; should only get here if size is correct\")\n+\t}\n+\n+\tdb.mu.Lock()\n+\tt, ok := db.table(s.table)\n+\tdb.mu.Unlock()\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"fakedb: table %q doesn't exist\", s.table)\n+\t}\n+\tt.mu.Lock()\n+\tdefer t.mu.Unlock()\n+\n+\tcolIdx := make(map[string]int) // select column name -> column index in table\n+\tfor _, name := range s.colName {\n+\t\tidx := t.columnIndex(name)\n+\t\tif idx == -1 {\n+\t\t\treturn nil, fmt.Errorf(\"fakedb: unknown column name %q\", name)\n+\t\t}\n+\t\tcolIdx[name] = idx\n+\t}\n+\n+\tmrows := []*row{}\n+rows:\n+\tfor _, trow := range t.rows {\n+\t\t// Process the where clause, skipping non-match rows. This is lazy\n+\t\t// and just uses fmt.Sprintf(\"%v\") to test equality.  Good enough\n+\t\t// for test code.\n+\t\tfor widx, wcol := range s.whereCol {\n+\t\t\tidx := t.columnIndex(wcol)\n+\t\t\tif idx == -1 {\n+\t\t\t\treturn nil, fmt.Errorf(\"db: invalid where clause column %q\", wcol)\n+\t\t\t}\n+\t\t\ttcol := trow.cols[idx]\n+\t\t\tif bs, ok := tcol.([]byte); ok {\n+\t\t\t\t// lazy hack to avoid sprintf %v on a []byte\n+\t\t\t\ttcol = string(bs)\n+\t\t\t}\n+\t\t\tif fmt.Sprintf(\"%v\", tcol) != fmt.Sprintf(\"%v\", args[widx]) {\n+\t\t\t\tcontinue rows\n+\t\t\t}\n+\t\t}\n+\t\tmrow := &row{cols: make([]interface{}, len(s.colName))}\n+\t\tfor seli, name := range s.colName {\n+\t\t\tmrow.cols[seli] = trow.cols[colIdx[name]]\n+\t\t}\n+\t\tmrows = append(mrows, mrow)\n+\t}\n+\n+\tcursor := &rowsCursor{\n+\t\tpos:  -1,\n+\t\trows: mrows,\n+\t\tcols: s.colName,\n+\t}\n+\treturn cursor, nil\n+}\n+\n+func (s *fakeStmt) NumInput() int {\n+\treturn s.placeholders\n+}\n+\n+func (tx *fakeTx) Commit() os.Error {\n+\ttx.c.currTx = nil\n+\treturn nil\n+}\n+\n+func (tx *fakeTx) Rollback() os.Error {\n+\ttx.c.currTx = nil\n+\treturn nil\n+}\n+\n+type rowsCursor struct {\n+\tcols   []string\n+\tpos    int\n+\trows   []*row\n+\tclosed bool\n+}\n+\n+func (rc *rowsCursor) Close() os.Error {\n+\trc.closed = true\n+\treturn nil\n+}\n+\n+func (rc *rowsCursor) Columns() []string {\n+\treturn rc.cols\n+}\n+\n+func (rc *rowsCursor) Next(dest []interface{}) os.Error {\n+\tif rc.closed {\n+\t\treturn os.NewError(\"fakedb: cursor is closed\")\n+\t}\n+\trc.pos++\n+\tif rc.pos >= len(rc.rows) {\n+\t\treturn os.EOF // per interface spec\n+\t}\n+\tfor i, v := range rc.rows[rc.pos].cols {\n+\t\t// TODO(bradfitz): convert to subset types? naah, I\n+\t\t// think the subset types should only be input to\n+\t\t// driver, but the db package should be able to handle\n+\t\t// a wider range of types coming out of drivers. all\n+\t\t// for ease of drivers, and to prevent drivers from\n+\t\t// messing up conversions or doing them differently.\n+\t\tdest[i] = v\n+\t}\n+\treturn nil\n+}\n+\n+func converterForType(typ string) driver.ValueConverter {\n+\tswitch typ {\n+\tcase \"bool\":\n+\t\treturn driver.Bool\n+\tcase \"int32\":\n+\t\treturn driver.Int32\n+\tcase \"string\":\n+\t\treturn driver.String\n+\t}\n+\tpanic(\"invalid fakedb column type of \" + typ)\n+}"}, {"sha": "7f0e0b28425bdf750d4e2fb459442a7dad8f3b43", "filename": "libgo/go/exp/sql/sql.go", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,578 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package sql provides a generic interface around SQL (or SQL-like)\n+// databases.\n+package sql\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"sync\"\n+\n+\t\"exp/sql/driver\"\n+)\n+\n+var drivers = make(map[string]driver.Driver)\n+\n+// Register makes a database driver available by the provided name.\n+// If Register is called twice with the same name or if driver is nil,\n+// it panics.\n+func Register(name string, driver driver.Driver) {\n+\tif driver == nil {\n+\t\tpanic(\"db: Register driver is nil\")\n+\t}\n+\tif _, dup := drivers[name]; dup {\n+\t\tpanic(\"db: Register called twice for driver \" + name)\n+\t}\n+\tdrivers[name] = driver\n+}\n+\n+// NullableString represents a string that may be null.\n+// NullableString implements the ScannerInto interface so\n+// it can be used as a scan destination:\n+//\n+//  var s NullableString\n+//  err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&s)\n+//  ...\n+//  if s.Valid {\n+//     // use s.String\n+//  } else {\n+//     // NULL value\n+//  }\n+//\n+// TODO(bradfitz): add other types.\n+type NullableString struct {\n+\tString string\n+\tValid  bool // Valid is true if String is not NULL\n+}\n+\n+// ScanInto implements the ScannerInto interface.\n+func (ms *NullableString) ScanInto(value interface{}) os.Error {\n+\tif value == nil {\n+\t\tms.String, ms.Valid = \"\", false\n+\t\treturn nil\n+\t}\n+\tms.Valid = true\n+\treturn convertAssign(&ms.String, value)\n+}\n+\n+// ScannerInto is an interface used by Scan.\n+type ScannerInto interface {\n+\t// ScanInto assigns a value from a database driver.\n+\t//\n+\t// The value will be of one of the following restricted\n+\t// set of types:\n+\t//\n+\t//    int64\n+\t//    float64\n+\t//    bool\n+\t//    []byte\n+\t//    nil - for NULL values\n+\t//\n+\t// An error should be returned if the value can not be stored\n+\t// without loss of information.\n+\tScanInto(value interface{}) os.Error\n+}\n+\n+// ErrNoRows is returned by Scan when QueryRow doesn't return a\n+// row. In such a case, QueryRow returns a placeholder *Row value that\n+// defers this error until a Scan.\n+var ErrNoRows = os.NewError(\"db: no rows in result set\")\n+\n+// DB is a database handle. It's safe for concurrent use by multiple\n+// goroutines.\n+type DB struct {\n+\tdriver driver.Driver\n+\tdsn    string\n+\n+\tmu       sync.Mutex\n+\tfreeConn []driver.Conn\n+}\n+\n+// Open opens a database specified by its database driver name and a\n+// driver-specific data source name, usually consisting of at least a\n+// database name and connection information.\n+//\n+// Most users will open a database via a driver-specific connection\n+// helper function that returns a *DB.\n+func Open(driverName, dataSourceName string) (*DB, os.Error) {\n+\tdriver, ok := drivers[driverName]\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"db: unknown driver %q (forgotten import?)\", driverName)\n+\t}\n+\treturn &DB{driver: driver, dsn: dataSourceName}, nil\n+}\n+\n+func (db *DB) maxIdleConns() int {\n+\tconst defaultMaxIdleConns = 2\n+\t// TODO(bradfitz): ask driver, if supported, for its default preference\n+\t// TODO(bradfitz): let users override?\n+\treturn defaultMaxIdleConns\n+}\n+\n+// conn returns a newly-opened or cached driver.Conn\n+func (db *DB) conn() (driver.Conn, os.Error) {\n+\tdb.mu.Lock()\n+\tif n := len(db.freeConn); n > 0 {\n+\t\tconn := db.freeConn[n-1]\n+\t\tdb.freeConn = db.freeConn[:n-1]\n+\t\tdb.mu.Unlock()\n+\t\treturn conn, nil\n+\t}\n+\tdb.mu.Unlock()\n+\treturn db.driver.Open(db.dsn)\n+}\n+\n+func (db *DB) connIfFree(wanted driver.Conn) (conn driver.Conn, ok bool) {\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tfor n, conn := range db.freeConn {\n+\t\tif conn == wanted {\n+\t\t\tdb.freeConn[n] = db.freeConn[len(db.freeConn)-1]\n+\t\t\tdb.freeConn = db.freeConn[:len(db.freeConn)-1]\n+\t\t\treturn wanted, true\n+\t\t}\n+\t}\n+\treturn nil, false\n+}\n+\n+func (db *DB) putConn(c driver.Conn) {\n+\tif n := len(db.freeConn); n < db.maxIdleConns() {\n+\t\tdb.freeConn = append(db.freeConn, c)\n+\t\treturn\n+\t}\n+\tdb.closeConn(c)\n+}\n+\n+func (db *DB) closeConn(c driver.Conn) {\n+\t// TODO: check to see if we need this Conn for any prepared statements\n+\t// that are active.\n+\tc.Close()\n+}\n+\n+// Prepare creates a prepared statement for later execution.\n+func (db *DB) Prepare(query string) (*Stmt, os.Error) {\n+\t// TODO: check if db.driver supports an optional\n+\t// driver.Preparer interface and call that instead, if so,\n+\t// otherwise we make a prepared statement that's bound\n+\t// to a connection, and to execute this prepared statement\n+\t// we either need to use this connection (if it's free), else\n+\t// get a new connection + re-prepare + execute on that one.\n+\tci, err := db.conn()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer db.putConn(ci)\n+\tsi, err := ci.Prepare(query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tstmt := &Stmt{\n+\t\tdb:    db,\n+\t\tquery: query,\n+\t\tcss:   []connStmt{{ci, si}},\n+\t}\n+\treturn stmt, nil\n+}\n+\n+// Exec executes a query without returning any rows.\n+func (db *DB) Exec(query string, args ...interface{}) (Result, os.Error) {\n+\t// Optional fast path, if the driver implements driver.Execer.\n+\tif execer, ok := db.driver.(driver.Execer); ok {\n+\t\tresi, err := execer.Exec(query, args)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn result{resi}, nil\n+\t}\n+\n+\t// If the driver does not implement driver.Execer, we need\n+\t// a connection.\n+\tconn, err := db.conn()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer db.putConn(conn)\n+\n+\tif execer, ok := conn.(driver.Execer); ok {\n+\t\tresi, err := execer.Exec(query, args)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn result{resi}, nil\n+\t}\n+\n+\tsti, err := conn.Prepare(query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer sti.Close()\n+\tresi, err := sti.Exec(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn result{resi}, nil\n+}\n+\n+// Query executes a query that returns rows, typically a SELECT.\n+func (db *DB) Query(query string, args ...interface{}) (*Rows, os.Error) {\n+\tstmt, err := db.Prepare(query)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer stmt.Close()\n+\treturn stmt.Query(args...)\n+}\n+\n+// QueryRow executes a query that is expected to return at most one row.\n+// QueryRow always return a non-nil value. Errors are deferred until\n+// Row's Scan method is called.\n+func (db *DB) QueryRow(query string, args ...interface{}) *Row {\n+\trows, err := db.Query(query, args...)\n+\tif err != nil {\n+\t\treturn &Row{err: err}\n+\t}\n+\treturn &Row{rows: rows}\n+}\n+\n+// Begin starts a transaction.  The isolation level is dependent on\n+// the driver.\n+func (db *DB) Begin() (*Tx, os.Error) {\n+\t// TODO(bradfitz): add another method for beginning a transaction\n+\t// at a specific isolation level.\n+\tpanic(todo())\n+}\n+\n+// DriverDatabase returns the database's underlying driver.\n+func (db *DB) Driver() driver.Driver {\n+\treturn db.driver\n+}\n+\n+// Tx is an in-progress database transaction.\n+type Tx struct {\n+\n+}\n+\n+// Commit commits the transaction.\n+func (tx *Tx) Commit() os.Error {\n+\tpanic(todo())\n+}\n+\n+// Rollback aborts the transaction.\n+func (tx *Tx) Rollback() os.Error {\n+\tpanic(todo())\n+}\n+\n+// Prepare creates a prepared statement.\n+func (tx *Tx) Prepare(query string) (*Stmt, os.Error) {\n+\tpanic(todo())\n+}\n+\n+// Exec executes a query that doesn't return rows.\n+// For example: an INSERT and UPDATE.\n+func (tx *Tx) Exec(query string, args ...interface{}) {\n+\tpanic(todo())\n+}\n+\n+// Query executes a query that returns rows, typically a SELECT.\n+func (tx *Tx) Query(query string, args ...interface{}) (*Rows, os.Error) {\n+\tpanic(todo())\n+}\n+\n+// QueryRow executes a query that is expected to return at most one row.\n+// QueryRow always return a non-nil value. Errors are deferred until\n+// Row's Scan method is called.\n+func (tx *Tx) QueryRow(query string, args ...interface{}) *Row {\n+\tpanic(todo())\n+}\n+\n+// connStmt is a prepared statement on a particular connection.\n+type connStmt struct {\n+\tci driver.Conn\n+\tsi driver.Stmt\n+}\n+\n+// Stmt is a prepared statement. Stmt is safe for concurrent use by multiple goroutines.\n+type Stmt struct {\n+\t// Immutable:\n+\tdb    *DB    // where we came from\n+\tquery string // that created the Sttm\n+\n+\tmu     sync.Mutex\n+\tclosed bool\n+\tcss    []connStmt // can use any that have idle connections\n+}\n+\n+func todo() string {\n+\t_, file, line, _ := runtime.Caller(1)\n+\treturn fmt.Sprintf(\"%s:%d: TODO: implement\", file, line)\n+}\n+\n+// Exec executes a prepared statement with the given arguments and\n+// returns a Result summarizing the effect of the statement.\n+func (s *Stmt) Exec(args ...interface{}) (Result, os.Error) {\n+\tci, si, err := s.connStmt()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer s.db.putConn(ci)\n+\n+\tif want := si.NumInput(); len(args) != want {\n+\t\treturn nil, fmt.Errorf(\"db: expected %d arguments, got %d\", want, len(args))\n+\t}\n+\n+\t// Convert args to subset types.\n+\tif cc, ok := si.(driver.ColumnConverter); ok {\n+\t\tfor n, arg := range args {\n+\t\t\targs[n], err = cc.ColumnConverter(n).ConvertValue(arg)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"db: converting Exec argument #%d's type: %v\", n, err)\n+\t\t\t}\n+\t\t\tif !driver.IsParameterSubsetType(args[n]) {\n+\t\t\t\treturn nil, fmt.Errorf(\"db: driver ColumnConverter error converted %T to unsupported type %T\",\n+\t\t\t\t\targ, args[n])\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor n, arg := range args {\n+\t\t\targs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"db: converting Exec argument #%d's type: %v\", n, err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tresi, err := si.Exec(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn result{resi}, nil\n+}\n+\n+func (s *Stmt) connStmt(args ...interface{}) (driver.Conn, driver.Stmt, os.Error) {\n+\ts.mu.Lock()\n+\tif s.closed {\n+\t\treturn nil, nil, os.NewError(\"db: statement is closed\")\n+\t}\n+\tvar cs connStmt\n+\tmatch := false\n+\tfor _, v := range s.css {\n+\t\t// TODO(bradfitz): lazily clean up entries in this\n+\t\t// list with dead conns while enumerating\n+\t\tif _, match = s.db.connIfFree(cs.ci); match {\n+\t\t\tcs = v\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\ts.mu.Unlock()\n+\n+\t// Make a new conn if all are busy.\n+\t// TODO(bradfitz): or wait for one? make configurable later?\n+\tif !match {\n+\t\tci, err := s.db.conn()\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\tsi, err := ci.Prepare(s.query)\n+\t\tif err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t\ts.mu.Lock()\n+\t\tcs = connStmt{ci, si}\n+\t\ts.css = append(s.css, cs)\n+\t\ts.mu.Unlock()\n+\t}\n+\n+\treturn cs.ci, cs.si, nil\n+}\n+\n+// Query executes a prepared query statement with the given arguments\n+// and returns the query results as a *Rows.\n+func (s *Stmt) Query(args ...interface{}) (*Rows, os.Error) {\n+\tci, si, err := s.connStmt(args...)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif len(args) != si.NumInput() {\n+\t\treturn nil, fmt.Errorf(\"db: statement expects %d inputs; got %d\", si.NumInput(), len(args))\n+\t}\n+\trowsi, err := si.Query(args)\n+\tif err != nil {\n+\t\ts.db.putConn(ci)\n+\t\treturn nil, err\n+\t}\n+\t// Note: ownership of ci passes to the *Rows\n+\trows := &Rows{\n+\t\tdb:    s.db,\n+\t\tci:    ci,\n+\t\trowsi: rowsi,\n+\t}\n+\treturn rows, nil\n+}\n+\n+// QueryRow executes a prepared query statement with the given arguments.\n+// If an error occurs during the execution of the statement, that error will\n+// be returned by a call to Scan on the returned *Row, which is always non-nil.\n+// If the query selects no rows, the *Row's Scan will return ErrNoRows.\n+// Otherwise, the *Row's Scan scans the first selected row and discards\n+// the rest.\n+//\n+// Example usage:\n+//\n+//  var name string\n+//  err := nameByUseridStmt.QueryRow(id).Scan(&s)\n+func (s *Stmt) QueryRow(args ...interface{}) *Row {\n+\trows, err := s.Query(args...)\n+\tif err != nil {\n+\t\treturn &Row{err: err}\n+\t}\n+\treturn &Row{rows: rows}\n+}\n+\n+// Close closes the statement.\n+func (s *Stmt) Close() os.Error {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock() // TODO(bradfitz): move this unlock after 'closed = true'?\n+\tif s.closed {\n+\t\treturn nil\n+\t}\n+\ts.closed = true\n+\tfor _, v := range s.css {\n+\t\tif ci, match := s.db.connIfFree(v.ci); match {\n+\t\t\tv.si.Close()\n+\t\t\ts.db.putConn(ci)\n+\t\t} else {\n+\t\t\t// TODO(bradfitz): care that we can't close\n+\t\t\t// this statement because the statement's\n+\t\t\t// connection is in use?\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Rows is the result of a query. Its cursor starts before the first row\n+// of the result set. Use Next to advance through the rows:\n+//\n+//     rows, err := db.Query(\"SELECT ...\")\n+//     ...\n+//     for rows.Next() {\n+//         var id int\n+//         var name string\n+//         err = rows.Scan(&id, &name)\n+//         ...\n+//     }\n+//     err = rows.Error() // get any Error encountered during iteration\n+//     ...\n+type Rows struct {\n+\tdb    *DB\n+\tci    driver.Conn // owned; must be returned when Rows is closed\n+\trowsi driver.Rows\n+\n+\tclosed   bool\n+\tlastcols []interface{}\n+\tlasterr  os.Error\n+}\n+\n+// Next prepares the next result row for reading with the Scan method.\n+// It returns true on success, false if there is no next result row.\n+// Every call to Scan, even the first one, must be preceded by a call\n+// to Next.\n+func (rs *Rows) Next() bool {\n+\tif rs.closed {\n+\t\treturn false\n+\t}\n+\tif rs.lasterr != nil {\n+\t\treturn false\n+\t}\n+\tif rs.lastcols == nil {\n+\t\trs.lastcols = make([]interface{}, len(rs.rowsi.Columns()))\n+\t}\n+\trs.lasterr = rs.rowsi.Next(rs.lastcols)\n+\treturn rs.lasterr == nil\n+}\n+\n+// Error returns the error, if any, that was encountered during iteration.\n+func (rs *Rows) Error() os.Error {\n+\tif rs.lasterr == os.EOF {\n+\t\treturn nil\n+\t}\n+\treturn rs.lasterr\n+}\n+\n+// Scan copies the columns in the current row into the values pointed\n+// at by dest. If dest contains pointers to []byte, the slices should\n+// not be modified and should only be considered valid until the next\n+// call to Next or Scan.\n+func (rs *Rows) Scan(dest ...interface{}) os.Error {\n+\tif rs.closed {\n+\t\treturn os.NewError(\"db: Rows closed\")\n+\t}\n+\tif rs.lasterr != nil {\n+\t\treturn rs.lasterr\n+\t}\n+\tif rs.lastcols == nil {\n+\t\treturn os.NewError(\"db: Scan called without calling Next\")\n+\t}\n+\tif len(dest) != len(rs.lastcols) {\n+\t\treturn fmt.Errorf(\"db: expected %d destination arguments in Scan, not %d\", len(rs.lastcols), len(dest))\n+\t}\n+\tfor i, sv := range rs.lastcols {\n+\t\terr := convertAssign(dest[i], sv)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"db: Scan error on column index %d: %v\", i, err)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// Close closes the Rows, preventing further enumeration. If the\n+// end is encountered, the Rows are closed automatically. Close\n+// is idempotent.\n+func (rs *Rows) Close() os.Error {\n+\tif rs.closed {\n+\t\treturn nil\n+\t}\n+\trs.closed = true\n+\terr := rs.rowsi.Close()\n+\trs.db.putConn(rs.ci)\n+\treturn err\n+}\n+\n+// Row is the result of calling QueryRow to select a single row.\n+type Row struct {\n+\t// One of these two will be non-nil:\n+\terr  os.Error // deferred error for easy chaining\n+\trows *Rows\n+}\n+\n+// Scan copies the columns from the matched row into the values\n+// pointed at by dest.  If more than one row matches the query,\n+// Scan uses the first row and discards the rest.  If no row matches\n+// the query, Scan returns ErrNoRows.\n+//\n+// If dest contains pointers to []byte, the slices should not be\n+// modified and should only be considered valid until the next call to\n+// Next or Scan.\n+func (r *Row) Scan(dest ...interface{}) os.Error {\n+\tif r.err != nil {\n+\t\treturn r.err\n+\t}\n+\tdefer r.rows.Close()\n+\tif !r.rows.Next() {\n+\t\treturn ErrNoRows\n+\t}\n+\treturn r.rows.Scan(dest...)\n+}\n+\n+// A Result summarizes an executed SQL command.\n+type Result interface {\n+\tLastInsertId() (int64, os.Error)\n+\tRowsAffected() (int64, os.Error)\n+}\n+\n+type result struct {\n+\tdriver.Result\n+}"}, {"sha": "eaa0a90356b0ad2cf96a1812f6133f70096feb8e", "filename": "libgo/go/exp/sql/sql_test.go", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sql\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func newTestDB(t *testing.T, name string) *DB {\n+\tdb, err := Open(\"test\", \"foo\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Open: %v\", err)\n+\t}\n+\tif _, err := db.Exec(\"WIPE\"); err != nil {\n+\t\tt.Fatalf(\"exec wipe: %v\", err)\n+\t}\n+\tif name == \"people\" {\n+\t\texec(t, db, \"CREATE|people|name=string,age=int32,dead=bool\")\n+\t\texec(t, db, \"INSERT|people|name=Alice,age=?\", 1)\n+\t\texec(t, db, \"INSERT|people|name=Bob,age=?\", 2)\n+\t\texec(t, db, \"INSERT|people|name=Chris,age=?\", 3)\n+\n+\t}\n+\treturn db\n+}\n+\n+func exec(t *testing.T, db *DB, query string, args ...interface{}) {\n+\t_, err := db.Exec(query, args...)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Exec of %q: %v\", query, err)\n+\t}\n+}\n+\n+func TestQuery(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tvar name string\n+\tvar age int\n+\n+\terr := db.QueryRow(\"SELECT|people|age,name|age=?\", 3).Scan(&age)\n+\tif err == nil || !strings.Contains(err.String(), \"expected 2 destination arguments\") {\n+\t\tt.Errorf(\"expected error from wrong number of arguments; actually got: %v\", err)\n+\t}\n+\n+\terr = db.QueryRow(\"SELECT|people|age,name|age=?\", 2).Scan(&age, &name)\n+\tif err != nil {\n+\t\tt.Fatalf(\"age QueryRow+Scan: %v\", err)\n+\t}\n+\tif name != \"Bob\" {\n+\t\tt.Errorf(\"expected name Bob, got %q\", name)\n+\t}\n+\tif age != 2 {\n+\t\tt.Errorf(\"expected age 2, got %d\", age)\n+\t}\n+\n+\terr = db.QueryRow(\"SELECT|people|age,name|name=?\", \"Alice\").Scan(&age, &name)\n+\tif err != nil {\n+\t\tt.Fatalf(\"name QueryRow+Scan: %v\", err)\n+\t}\n+\tif name != \"Alice\" {\n+\t\tt.Errorf(\"expected name Alice, got %q\", name)\n+\t}\n+\tif age != 1 {\n+\t\tt.Errorf(\"expected age 1, got %d\", age)\n+\t}\n+}\n+\n+func TestStatementQueryRow(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tstmt, err := db.Prepare(\"SELECT|people|age|name=?\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Prepare: %v\", err)\n+\t}\n+\tvar age int\n+\tfor n, tt := range []struct {\n+\t\tname string\n+\t\twant int\n+\t}{\n+\t\t{\"Alice\", 1},\n+\t\t{\"Bob\", 2},\n+\t\t{\"Chris\", 3},\n+\t} {\n+\t\tif err := stmt.QueryRow(tt.name).Scan(&age); err != nil {\n+\t\t\tt.Errorf(\"%d: on %q, QueryRow/Scan: %v\", n, tt.name, err)\n+\t\t} else if age != tt.want {\n+\t\t\tt.Errorf(\"%d: age=%d, want %d\", n, age, tt.want)\n+\t\t}\n+\t}\n+\n+}\n+\n+// just a test of fakedb itself\n+func TestBogusPreboundParameters(t *testing.T) {\n+\tdb := newTestDB(t, \"foo\")\n+\texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n+\t_, err := db.Prepare(\"INSERT|t1|name=?,age=bogusconversion\")\n+\tif err == nil {\n+\t\tt.Fatalf(\"expected error\")\n+\t}\n+\tif err.String() != `fakedb: invalid conversion to int32 from \"bogusconversion\"` {\n+\t\tt.Errorf(\"unexpected error: %v\", err)\n+\t}\n+}\n+\n+func TestDb(t *testing.T) {\n+\tdb := newTestDB(t, \"foo\")\n+\texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n+\tstmt, err := db.Prepare(\"INSERT|t1|name=?,age=?\")\n+\tif err != nil {\n+\t\tt.Errorf(\"Stmt, err = %v, %v\", stmt, err)\n+\t}\n+\n+\ttype execTest struct {\n+\t\targs    []interface{}\n+\t\twantErr string\n+\t}\n+\texecTests := []execTest{\n+\t\t// Okay:\n+\t\t{[]interface{}{\"Brad\", 31}, \"\"},\n+\t\t{[]interface{}{\"Brad\", int64(31)}, \"\"},\n+\t\t{[]interface{}{\"Bob\", \"32\"}, \"\"},\n+\t\t{[]interface{}{7, 9}, \"\"},\n+\n+\t\t// Invalid conversions:\n+\t\t{[]interface{}{\"Brad\", int64(0xFFFFFFFF)}, \"db: converting Exec argument #1's type: sql/driver: value 4294967295 overflows int32\"},\n+\t\t{[]interface{}{\"Brad\", \"strconv fail\"}, \"db: converting Exec argument #1's type: sql/driver: value \\\"strconv fail\\\" can't be converted to int32\"},\n+\n+\t\t// Wrong number of args:\n+\t\t{[]interface{}{}, \"db: expected 2 arguments, got 0\"},\n+\t\t{[]interface{}{1, 2, 3}, \"db: expected 2 arguments, got 3\"},\n+\t}\n+\tfor n, et := range execTests {\n+\t\t_, err := stmt.Exec(et.args...)\n+\t\terrStr := \"\"\n+\t\tif err != nil {\n+\t\t\terrStr = err.String()\n+\t\t}\n+\t\tif errStr != et.wantErr {\n+\t\t\tt.Errorf(\"stmt.Execute #%d: for %v, got error %q, want error %q\",\n+\t\t\t\tn, et.args, errStr, et.wantErr)\n+\t\t}\n+\t}\n+}"}, {"sha": "922584f63175ac7862ce15f1cb225cf04db67ae0", "filename": "libgo/go/exp/ssh/channel.go", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fchannel.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,317 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+// A Channel is an ordered, reliable, duplex stream that is multiplexed over an\n+// SSH connection.\n+type Channel interface {\n+\t// Accept accepts the channel creation request.\n+\tAccept() os.Error\n+\t// Reject rejects the channel creation request. After calling this, no\n+\t// other methods on the Channel may be called. If they are then the\n+\t// peer is likely to signal a protocol error and drop the connection.\n+\tReject(reason RejectionReason, message string) os.Error\n+\n+\t// Read may return a ChannelRequest as an os.Error.\n+\tRead(data []byte) (int, os.Error)\n+\tWrite(data []byte) (int, os.Error)\n+\tClose() os.Error\n+\n+\t// AckRequest either sends an ack or nack to the channel request.\n+\tAckRequest(ok bool) os.Error\n+\n+\t// ChannelType returns the type of the channel, as supplied by the\n+\t// client.\n+\tChannelType() string\n+\t// ExtraData returns the arbitary payload for this channel, as supplied\n+\t// by the client. This data is specific to the channel type.\n+\tExtraData() []byte\n+}\n+\n+// ChannelRequest represents a request sent on a channel, outside of the normal\n+// stream of bytes. It may result from calling Read on a Channel.\n+type ChannelRequest struct {\n+\tRequest   string\n+\tWantReply bool\n+\tPayload   []byte\n+}\n+\n+func (c ChannelRequest) String() string {\n+\treturn \"channel request received\"\n+}\n+\n+// RejectionReason is an enumeration used when rejecting channel creation\n+// requests. See RFC 4254, section 5.1.\n+type RejectionReason int\n+\n+const (\n+\tProhibited RejectionReason = iota + 1\n+\tConnectionFailed\n+\tUnknownChannelType\n+\tResourceShortage\n+)\n+\n+type channel struct {\n+\t// immutable once created\n+\tchanType  string\n+\textraData []byte\n+\n+\ttheyClosed  bool\n+\ttheySentEOF bool\n+\tweClosed    bool\n+\tdead        bool\n+\n+\tserverConn            *ServerConnection\n+\tmyId, theirId         uint32\n+\tmyWindow, theirWindow uint32\n+\tmaxPacketSize         uint32\n+\terr                   os.Error\n+\n+\tpendingRequests []ChannelRequest\n+\tpendingData     []byte\n+\thead, length    int\n+\n+\t// This lock is inferior to serverConn.lock\n+\tlock sync.Mutex\n+\tcond *sync.Cond\n+}\n+\n+func (c *channel) Accept() os.Error {\n+\tc.serverConn.lock.Lock()\n+\tdefer c.serverConn.lock.Unlock()\n+\n+\tif c.serverConn.err != nil {\n+\t\treturn c.serverConn.err\n+\t}\n+\n+\tconfirm := channelOpenConfirmMsg{\n+\t\tPeersId:       c.theirId,\n+\t\tMyId:          c.myId,\n+\t\tMyWindow:      c.myWindow,\n+\t\tMaxPacketSize: c.maxPacketSize,\n+\t}\n+\treturn c.serverConn.writePacket(marshal(msgChannelOpenConfirm, confirm))\n+}\n+\n+func (c *channel) Reject(reason RejectionReason, message string) os.Error {\n+\tc.serverConn.lock.Lock()\n+\tdefer c.serverConn.lock.Unlock()\n+\n+\tif c.serverConn.err != nil {\n+\t\treturn c.serverConn.err\n+\t}\n+\n+\treject := channelOpenFailureMsg{\n+\t\tPeersId:  c.theirId,\n+\t\tReason:   uint32(reason),\n+\t\tMessage:  message,\n+\t\tLanguage: \"en\",\n+\t}\n+\treturn c.serverConn.writePacket(marshal(msgChannelOpenFailure, reject))\n+}\n+\n+func (c *channel) handlePacket(packet interface{}) {\n+\tc.lock.Lock()\n+\tdefer c.lock.Unlock()\n+\n+\tswitch packet := packet.(type) {\n+\tcase *channelRequestMsg:\n+\t\treq := ChannelRequest{\n+\t\t\tRequest:   packet.Request,\n+\t\t\tWantReply: packet.WantReply,\n+\t\t\tPayload:   packet.RequestSpecificData,\n+\t\t}\n+\n+\t\tc.pendingRequests = append(c.pendingRequests, req)\n+\t\tc.cond.Signal()\n+\tcase *channelCloseMsg:\n+\t\tc.theyClosed = true\n+\t\tc.cond.Signal()\n+\tcase *channelEOFMsg:\n+\t\tc.theySentEOF = true\n+\t\tc.cond.Signal()\n+\tdefault:\n+\t\tpanic(\"unknown packet type\")\n+\t}\n+}\n+\n+func (c *channel) handleData(data []byte) {\n+\tc.lock.Lock()\n+\tdefer c.lock.Unlock()\n+\n+\t// The other side should never send us more than our window.\n+\tif len(data)+c.length > len(c.pendingData) {\n+\t\t// TODO(agl): we should tear down the channel with a protocol\n+\t\t// error.\n+\t\treturn\n+\t}\n+\n+\tc.myWindow -= uint32(len(data))\n+\tfor i := 0; i < 2; i++ {\n+\t\ttail := c.head + c.length\n+\t\tif tail > len(c.pendingData) {\n+\t\t\ttail -= len(c.pendingData)\n+\t\t}\n+\t\tn := copy(c.pendingData[tail:], data)\n+\t\tdata = data[n:]\n+\t\tc.length += n\n+\t}\n+\n+\tc.cond.Signal()\n+}\n+\n+func (c *channel) Read(data []byte) (n int, err os.Error) {\n+\tc.lock.Lock()\n+\tdefer c.lock.Unlock()\n+\n+\tif c.err != nil {\n+\t\treturn 0, c.err\n+\t}\n+\n+\tif c.myWindow <= uint32(len(c.pendingData))/2 {\n+\t\tpacket := marshal(msgChannelWindowAdjust, windowAdjustMsg{\n+\t\t\tPeersId:         c.theirId,\n+\t\t\tAdditionalBytes: uint32(len(c.pendingData)) - c.myWindow,\n+\t\t})\n+\t\tif err := c.serverConn.writePacket(packet); err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t}\n+\n+\tfor {\n+\t\tif c.theySentEOF || c.theyClosed || c.dead {\n+\t\t\treturn 0, os.EOF\n+\t\t}\n+\n+\t\tif len(c.pendingRequests) > 0 {\n+\t\t\treq := c.pendingRequests[0]\n+\t\t\tif len(c.pendingRequests) == 1 {\n+\t\t\t\tc.pendingRequests = nil\n+\t\t\t} else {\n+\t\t\t\toldPendingRequests := c.pendingRequests\n+\t\t\t\tc.pendingRequests = make([]ChannelRequest, len(oldPendingRequests)-1)\n+\t\t\t\tcopy(c.pendingRequests, oldPendingRequests[1:])\n+\t\t\t}\n+\n+\t\t\treturn 0, req\n+\t\t}\n+\n+\t\tif c.length > 0 {\n+\t\t\ttail := c.head + c.length\n+\t\t\tif tail > len(c.pendingData) {\n+\t\t\t\ttail -= len(c.pendingData)\n+\t\t\t}\n+\t\t\tn = copy(data, c.pendingData[c.head:tail])\n+\t\t\tc.head += n\n+\t\t\tc.length -= n\n+\t\t\tif c.head == len(c.pendingData) {\n+\t\t\t\tc.head = 0\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tc.cond.Wait()\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+func (c *channel) Write(data []byte) (n int, err os.Error) {\n+\tfor len(data) > 0 {\n+\t\tc.lock.Lock()\n+\t\tif c.dead || c.weClosed {\n+\t\t\treturn 0, os.EOF\n+\t\t}\n+\n+\t\tif c.theirWindow == 0 {\n+\t\t\tc.cond.Wait()\n+\t\t\tcontinue\n+\t\t}\n+\t\tc.lock.Unlock()\n+\n+\t\ttodo := data\n+\t\tif uint32(len(todo)) > c.theirWindow {\n+\t\t\ttodo = todo[:c.theirWindow]\n+\t\t}\n+\n+\t\tpacket := make([]byte, 1+4+4+len(todo))\n+\t\tpacket[0] = msgChannelData\n+\t\tpacket[1] = byte(c.theirId) >> 24\n+\t\tpacket[2] = byte(c.theirId) >> 16\n+\t\tpacket[3] = byte(c.theirId) >> 8\n+\t\tpacket[4] = byte(c.theirId)\n+\t\tpacket[5] = byte(len(todo)) >> 24\n+\t\tpacket[6] = byte(len(todo)) >> 16\n+\t\tpacket[7] = byte(len(todo)) >> 8\n+\t\tpacket[8] = byte(len(todo))\n+\t\tcopy(packet[9:], todo)\n+\n+\t\tc.serverConn.lock.Lock()\n+\t\tif err = c.serverConn.writePacket(packet); err != nil {\n+\t\t\tc.serverConn.lock.Unlock()\n+\t\t\treturn\n+\t\t}\n+\t\tc.serverConn.lock.Unlock()\n+\n+\t\tn += len(todo)\n+\t\tdata = data[len(todo):]\n+\t}\n+\n+\treturn\n+}\n+\n+func (c *channel) Close() os.Error {\n+\tc.serverConn.lock.Lock()\n+\tdefer c.serverConn.lock.Unlock()\n+\n+\tif c.serverConn.err != nil {\n+\t\treturn c.serverConn.err\n+\t}\n+\n+\tif c.weClosed {\n+\t\treturn os.NewError(\"ssh: channel already closed\")\n+\t}\n+\tc.weClosed = true\n+\n+\tcloseMsg := channelCloseMsg{\n+\t\tPeersId: c.theirId,\n+\t}\n+\treturn c.serverConn.writePacket(marshal(msgChannelClose, closeMsg))\n+}\n+\n+func (c *channel) AckRequest(ok bool) os.Error {\n+\tc.serverConn.lock.Lock()\n+\tdefer c.serverConn.lock.Unlock()\n+\n+\tif c.serverConn.err != nil {\n+\t\treturn c.serverConn.err\n+\t}\n+\n+\tif ok {\n+\t\tack := channelRequestSuccessMsg{\n+\t\t\tPeersId: c.theirId,\n+\t\t}\n+\t\treturn c.serverConn.writePacket(marshal(msgChannelSuccess, ack))\n+\t} else {\n+\t\tack := channelRequestFailureMsg{\n+\t\t\tPeersId: c.theirId,\n+\t\t}\n+\t\treturn c.serverConn.writePacket(marshal(msgChannelFailure, ack))\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+func (c *channel) ChannelType() string {\n+\treturn c.chanType\n+}\n+\n+func (c *channel) ExtraData() []byte {\n+\treturn c.extraData\n+}"}, {"sha": "739bd2f9c5f36c6f556a3450eee6905e3d0c80c2", "filename": "libgo/go/exp/ssh/common.go", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"big\"\n+\t\"strconv\"\n+\t\"sync\"\n+)\n+\n+// These are string constants in the SSH protocol.\n+const (\n+\tkexAlgoDH14SHA1 = \"diffie-hellman-group14-sha1\"\n+\thostAlgoRSA     = \"ssh-rsa\"\n+\tcipherAES128CTR = \"aes128-ctr\"\n+\tmacSHA196       = \"hmac-sha1-96\"\n+\tcompressionNone = \"none\"\n+\tserviceUserAuth = \"ssh-userauth\"\n+\tserviceSSH      = \"ssh-connection\"\n+)\n+\n+var supportedKexAlgos = []string{kexAlgoDH14SHA1}\n+var supportedHostKeyAlgos = []string{hostAlgoRSA}\n+var supportedCiphers = []string{cipherAES128CTR}\n+var supportedMACs = []string{macSHA196}\n+var supportedCompressions = []string{compressionNone}\n+\n+// dhGroup is a multiplicative group suitable for implementing Diffie-Hellman key agreement.\n+type dhGroup struct {\n+\tg, p *big.Int\n+}\n+\n+// dhGroup14 is the group called diffie-hellman-group14-sha1 in RFC 4253 and\n+// Oakley Group 14 in RFC 3526.\n+var dhGroup14 *dhGroup\n+\n+var dhGroup14Once sync.Once\n+\n+func initDHGroup14() {\n+\tp, _ := new(big.Int).SetString(\"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF\", 16)\n+\n+\tdhGroup14 = &dhGroup{\n+\t\tg: new(big.Int).SetInt64(2),\n+\t\tp: p,\n+\t}\n+}\n+\n+// UnexpectedMessageError results when the SSH message that we received didn't\n+// match what we wanted.\n+type UnexpectedMessageError struct {\n+\texpected, got uint8\n+}\n+\n+func (u UnexpectedMessageError) String() string {\n+\treturn \"ssh: unexpected message type \" + strconv.Itoa(int(u.got)) + \" (expected \" + strconv.Itoa(int(u.expected)) + \")\"\n+}\n+\n+// ParseError results from a malformed SSH message.\n+type ParseError struct {\n+\tmsgType uint8\n+}\n+\n+func (p ParseError) String() string {\n+\treturn \"ssh: parse error in message type \" + strconv.Itoa(int(p.msgType))\n+}\n+\n+type handshakeMagics struct {\n+\tclientVersion, serverVersion []byte\n+\tclientKexInit, serverKexInit []byte\n+}\n+\n+func findCommonAlgorithm(clientAlgos []string, serverAlgos []string) (commonAlgo string, ok bool) {\n+\tfor _, clientAlgo := range clientAlgos {\n+\t\tfor _, serverAlgo := range serverAlgos {\n+\t\t\tif clientAlgo == serverAlgo {\n+\t\t\t\treturn clientAlgo, true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+func findAgreedAlgorithms(transport *transport, clientKexInit, serverKexInit *kexInitMsg) (kexAlgo, hostKeyAlgo string, ok bool) {\n+\tkexAlgo, ok = findCommonAlgorithm(clientKexInit.KexAlgos, serverKexInit.KexAlgos)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\thostKeyAlgo, ok = findCommonAlgorithm(clientKexInit.ServerHostKeyAlgos, serverKexInit.ServerHostKeyAlgos)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\ttransport.writer.cipherAlgo, ok = findCommonAlgorithm(clientKexInit.CiphersClientServer, serverKexInit.CiphersClientServer)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\ttransport.reader.cipherAlgo, ok = findCommonAlgorithm(clientKexInit.CiphersServerClient, serverKexInit.CiphersServerClient)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\ttransport.writer.macAlgo, ok = findCommonAlgorithm(clientKexInit.MACsClientServer, serverKexInit.MACsClientServer)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\ttransport.reader.macAlgo, ok = findCommonAlgorithm(clientKexInit.MACsServerClient, serverKexInit.MACsServerClient)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\ttransport.writer.compressionAlgo, ok = findCommonAlgorithm(clientKexInit.CompressionClientServer, serverKexInit.CompressionClientServer)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\ttransport.reader.compressionAlgo, ok = findCommonAlgorithm(clientKexInit.CompressionServerClient, serverKexInit.CompressionServerClient)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\n+\tok = true\n+\treturn\n+}"}, {"sha": "54a7ba9fdae3d7f97470fce250e5060fd39327bc", "filename": "libgo/go/exp/ssh/doc.go", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Package ssh implements an SSH server.\n+\n+SSH is a transport security protocol, an authentication protocol and a\n+family of application protocols. The most typical application level\n+protocol is a remote shell and this is specifically implemented.  However,\n+the multiplexed nature of SSH is exposed to users that wish to support\n+others.\n+\n+An SSH server is represented by a Server, which manages a number of\n+ServerConnections and handles authentication.\n+\n+\tvar s Server\n+\ts.PubKeyCallback = pubKeyAuth\n+\ts.PasswordCallback = passwordAuth\n+\n+\tpemBytes, err := ioutil.ReadFile(\"id_rsa\")\n+\tif err != nil {\n+\t\tpanic(\"Failed to load private key\")\n+\t}\n+\terr = s.SetRSAPrivateKey(pemBytes)\n+\tif err != nil {\n+\t\tpanic(\"Failed to parse private key\")\n+\t}\n+\n+Once a Server has been set up, connections can be attached.\n+\n+\tvar sConn ServerConnection\n+\tsConn.Server = &s\n+\terr = sConn.Handshake(conn)\n+\tif err != nil {\n+\t\tpanic(\"failed to handshake\")\n+\t}\n+\n+An SSH connection multiplexes several channels, which must be accepted themselves:\n+\n+\n+\tfor {\n+\t\tchannel, err := sConn.Accept()\n+\t\tif err != nil {\n+\t\t\tpanic(\"error from Accept\")\n+\t\t}\n+\n+\t\t...\n+\t}\n+\n+Accept reads from the connection, demultiplexes packets to their corresponding\n+channels and returns when a new channel request is seen. Some goroutine must\n+always be calling Accept; otherwise no messages will be forwarded to the\n+channels.\n+\n+Channels have a type, depending on the application level protocol intended. In\n+the case of a shell, the type is \"session\" and ServerShell may be used to\n+present a simple terminal interface.\n+\n+\tif channel.ChannelType() != \"session\" {\n+\t\tc.Reject(UnknownChannelType, \"unknown channel type\")\n+\t\treturn\n+\t}\n+\tchannel.Accept()\n+\n+\tshell := NewServerShell(channel, \"> \")\n+\tgo func() {\n+\t\tdefer channel.Close()\n+\t\tfor {\n+\t\t\tline, err := shell.ReadLine()\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tprintln(line)\n+\t\t}\n+\t\treturn\n+\t}()\n+*/\n+package ssh"}, {"sha": "1d0bc5774265350f008a2a0d9c87b333af7489c4", "filename": "libgo/go/exp/ssh/messages.go", "status": "added", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,636 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"big\"\n+\t\"bytes\"\n+\t\"io\"\n+\t\"os\"\n+\t\"reflect\"\n+)\n+\n+// These are SSH message type numbers. They are scattered around several\n+// documents but many were taken from\n+// http://www.iana.org/assignments/ssh-parameters/ssh-parameters.xml#ssh-parameters-1\n+const (\n+\tmsgDisconnect     = 1\n+\tmsgIgnore         = 2\n+\tmsgUnimplemented  = 3\n+\tmsgDebug          = 4\n+\tmsgServiceRequest = 5\n+\tmsgServiceAccept  = 6\n+\n+\tmsgKexInit = 20\n+\tmsgNewKeys = 21\n+\n+\tmsgKexDHInit  = 30\n+\tmsgKexDHReply = 31\n+\n+\tmsgUserAuthRequest  = 50\n+\tmsgUserAuthFailure  = 51\n+\tmsgUserAuthSuccess  = 52\n+\tmsgUserAuthBanner   = 53\n+\tmsgUserAuthPubKeyOk = 60\n+\n+\tmsgGlobalRequest  = 80\n+\tmsgRequestSuccess = 81\n+\tmsgRequestFailure = 82\n+\n+\tmsgChannelOpen         = 90\n+\tmsgChannelOpenConfirm  = 91\n+\tmsgChannelOpenFailure  = 92\n+\tmsgChannelWindowAdjust = 93\n+\tmsgChannelData         = 94\n+\tmsgChannelExtendedData = 95\n+\tmsgChannelEOF          = 96\n+\tmsgChannelClose        = 97\n+\tmsgChannelRequest      = 98\n+\tmsgChannelSuccess      = 99\n+\tmsgChannelFailure      = 100\n+)\n+\n+// SSH messages:\n+//\n+// These structures mirror the wire format of the corresponding SSH messages.\n+// They are marshaled using reflection with the marshal and unmarshal functions\n+// in this file. The only wrinkle is that a final member of type []byte with a\n+// ssh tag of \"rest\" receives the remainder of a packet when unmarshaling.\n+\n+// See RFC 4253, section 11.1.\n+type disconnectMsg struct {\n+\tReason   uint32\n+\tMessage  string\n+\tLanguage string\n+}\n+\n+// See RFC 4253, section 7.1.\n+type kexInitMsg struct {\n+\tCookie                  [16]byte\n+\tKexAlgos                []string\n+\tServerHostKeyAlgos      []string\n+\tCiphersClientServer     []string\n+\tCiphersServerClient     []string\n+\tMACsClientServer        []string\n+\tMACsServerClient        []string\n+\tCompressionClientServer []string\n+\tCompressionServerClient []string\n+\tLanguagesClientServer   []string\n+\tLanguagesServerClient   []string\n+\tFirstKexFollows         bool\n+\tReserved                uint32\n+}\n+\n+// See RFC 4253, section 8.\n+type kexDHInitMsg struct {\n+\tX *big.Int\n+}\n+\n+type kexDHReplyMsg struct {\n+\tHostKey   []byte\n+\tY         *big.Int\n+\tSignature []byte\n+}\n+\n+// See RFC 4253, section 10.\n+type serviceRequestMsg struct {\n+\tService string\n+}\n+\n+// See RFC 4253, section 10.\n+type serviceAcceptMsg struct {\n+\tService string\n+}\n+\n+// See RFC 4252, section 5.\n+type userAuthRequestMsg struct {\n+\tUser    string\n+\tService string\n+\tMethod  string\n+\tPayload []byte `ssh:\"rest\"`\n+}\n+\n+// See RFC 4252, section 5.1\n+type userAuthFailureMsg struct {\n+\tMethods        []string\n+\tPartialSuccess bool\n+}\n+\n+// See RFC 4254, section 5.1.\n+type channelOpenMsg struct {\n+\tChanType         string\n+\tPeersId          uint32\n+\tPeersWindow      uint32\n+\tMaxPacketSize    uint32\n+\tTypeSpecificData []byte `ssh:\"rest\"`\n+}\n+\n+// See RFC 4254, section 5.1.\n+type channelOpenConfirmMsg struct {\n+\tPeersId          uint32\n+\tMyId             uint32\n+\tMyWindow         uint32\n+\tMaxPacketSize    uint32\n+\tTypeSpecificData []byte `ssh:\"rest\"`\n+}\n+\n+// See RFC 4254, section 5.1.\n+type channelOpenFailureMsg struct {\n+\tPeersId  uint32\n+\tReason   uint32\n+\tMessage  string\n+\tLanguage string\n+}\n+\n+// See RFC 4254, section 5.2.\n+type channelData struct {\n+\tPeersId uint32\n+\tPayload []byte `ssh:\"rest\"`\n+}\n+\n+// See RFC 4254, section 5.2.\n+type channelExtendedData struct {\n+\tPeersId  uint32\n+\tDatatype uint32\n+\tData     string\n+}\n+\n+type channelRequestMsg struct {\n+\tPeersId             uint32\n+\tRequest             string\n+\tWantReply           bool\n+\tRequestSpecificData []byte `ssh:\"rest\"`\n+}\n+\n+// See RFC 4254, section 5.4.\n+type channelRequestSuccessMsg struct {\n+\tPeersId uint32\n+}\n+\n+// See RFC 4254, section 5.4.\n+type channelRequestFailureMsg struct {\n+\tPeersId uint32\n+}\n+\n+// See RFC 4254, section 5.3\n+type channelCloseMsg struct {\n+\tPeersId uint32\n+}\n+\n+// See RFC 4254, section 5.3\n+type channelEOFMsg struct {\n+\tPeersId uint32\n+}\n+\n+// See RFC 4254, section 4\n+type globalRequestMsg struct {\n+\tType      string\n+\tWantReply bool\n+}\n+\n+// See RFC 4254, section 5.2\n+type windowAdjustMsg struct {\n+\tPeersId         uint32\n+\tAdditionalBytes uint32\n+}\n+\n+// See RFC 4252, section 7\n+type userAuthPubKeyOkMsg struct {\n+\tAlgo   string\n+\tPubKey string\n+}\n+\n+// unmarshal parses the SSH wire data in packet into out using reflection.\n+// expectedType is the expected SSH message type. It either returns nil on\n+// success, or a ParseError or UnexpectedMessageError on error.\n+func unmarshal(out interface{}, packet []byte, expectedType uint8) os.Error {\n+\tif len(packet) == 0 {\n+\t\treturn ParseError{expectedType}\n+\t}\n+\tif packet[0] != expectedType {\n+\t\treturn UnexpectedMessageError{expectedType, packet[0]}\n+\t}\n+\tpacket = packet[1:]\n+\n+\tv := reflect.ValueOf(out).Elem()\n+\tstructType := v.Type()\n+\tvar ok bool\n+\tfor i := 0; i < v.NumField(); i++ {\n+\t\tfield := v.Field(i)\n+\t\tt := field.Type()\n+\t\tswitch t.Kind() {\n+\t\tcase reflect.Bool:\n+\t\t\tif len(packet) < 1 {\n+\t\t\t\treturn ParseError{expectedType}\n+\t\t\t}\n+\t\t\tfield.SetBool(packet[0] != 0)\n+\t\t\tpacket = packet[1:]\n+\t\tcase reflect.Array:\n+\t\t\tif t.Elem().Kind() != reflect.Uint8 {\n+\t\t\t\tpanic(\"array of non-uint8\")\n+\t\t\t}\n+\t\t\tif len(packet) < t.Len() {\n+\t\t\t\treturn ParseError{expectedType}\n+\t\t\t}\n+\t\t\tfor j := 0; j < t.Len(); j++ {\n+\t\t\t\tfield.Index(j).Set(reflect.ValueOf(packet[j]))\n+\t\t\t}\n+\t\t\tpacket = packet[t.Len():]\n+\t\tcase reflect.Uint32:\n+\t\t\tvar u32 uint32\n+\t\t\tif u32, packet, ok = parseUint32(packet); !ok {\n+\t\t\t\treturn ParseError{expectedType}\n+\t\t\t}\n+\t\t\tfield.SetUint(uint64(u32))\n+\t\tcase reflect.String:\n+\t\t\tvar s []byte\n+\t\t\tif s, packet, ok = parseString(packet); !ok {\n+\t\t\t\treturn ParseError{expectedType}\n+\t\t\t}\n+\t\t\tfield.SetString(string(s))\n+\t\tcase reflect.Slice:\n+\t\t\tswitch t.Elem().Kind() {\n+\t\t\tcase reflect.Uint8:\n+\t\t\t\tif structType.Field(i).Tag.Get(\"ssh\") == \"rest\" {\n+\t\t\t\t\tfield.Set(reflect.ValueOf(packet))\n+\t\t\t\t\tpacket = nil\n+\t\t\t\t} else {\n+\t\t\t\t\tvar s []byte\n+\t\t\t\t\tif s, packet, ok = parseString(packet); !ok {\n+\t\t\t\t\t\treturn ParseError{expectedType}\n+\t\t\t\t\t}\n+\t\t\t\t\tfield.Set(reflect.ValueOf(s))\n+\t\t\t\t}\n+\t\t\tcase reflect.String:\n+\t\t\t\tvar nl []string\n+\t\t\t\tif nl, packet, ok = parseNameList(packet); !ok {\n+\t\t\t\t\treturn ParseError{expectedType}\n+\t\t\t\t}\n+\t\t\t\tfield.Set(reflect.ValueOf(nl))\n+\t\t\tdefault:\n+\t\t\t\tpanic(\"slice of unknown type\")\n+\t\t\t}\n+\t\tcase reflect.Ptr:\n+\t\t\tif t == bigIntType {\n+\t\t\t\tvar n *big.Int\n+\t\t\t\tif n, packet, ok = parseInt(packet); !ok {\n+\t\t\t\t\treturn ParseError{expectedType}\n+\t\t\t\t}\n+\t\t\t\tfield.Set(reflect.ValueOf(n))\n+\t\t\t} else {\n+\t\t\t\tpanic(\"pointer to unknown type\")\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tpanic(\"unknown type\")\n+\t\t}\n+\t}\n+\n+\tif len(packet) != 0 {\n+\t\treturn ParseError{expectedType}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// marshal serializes the message in msg, using the given message type.\n+func marshal(msgType uint8, msg interface{}) []byte {\n+\tvar out []byte\n+\tout = append(out, msgType)\n+\n+\tv := reflect.ValueOf(msg)\n+\tstructType := v.Type()\n+\tfor i := 0; i < v.NumField(); i++ {\n+\t\tfield := v.Field(i)\n+\t\tt := field.Type()\n+\t\tswitch t.Kind() {\n+\t\tcase reflect.Bool:\n+\t\t\tvar v uint8\n+\t\t\tif field.Bool() {\n+\t\t\t\tv = 1\n+\t\t\t}\n+\t\t\tout = append(out, v)\n+\t\tcase reflect.Array:\n+\t\t\tif t.Elem().Kind() != reflect.Uint8 {\n+\t\t\t\tpanic(\"array of non-uint8\")\n+\t\t\t}\n+\t\t\tfor j := 0; j < t.Len(); j++ {\n+\t\t\t\tout = append(out, byte(field.Index(j).Uint()))\n+\t\t\t}\n+\t\tcase reflect.Uint32:\n+\t\t\tu32 := uint32(field.Uint())\n+\t\t\tout = append(out, byte(u32>>24))\n+\t\t\tout = append(out, byte(u32>>16))\n+\t\t\tout = append(out, byte(u32>>8))\n+\t\t\tout = append(out, byte(u32))\n+\t\tcase reflect.String:\n+\t\t\ts := field.String()\n+\t\t\tout = append(out, byte(len(s)>>24))\n+\t\t\tout = append(out, byte(len(s)>>16))\n+\t\t\tout = append(out, byte(len(s)>>8))\n+\t\t\tout = append(out, byte(len(s)))\n+\t\t\tout = append(out, s...)\n+\t\tcase reflect.Slice:\n+\t\t\tswitch t.Elem().Kind() {\n+\t\t\tcase reflect.Uint8:\n+\t\t\t\tlength := field.Len()\n+\t\t\t\tif structType.Field(i).Tag.Get(\"ssh\") != \"rest\" {\n+\t\t\t\t\tout = append(out, byte(length>>24))\n+\t\t\t\t\tout = append(out, byte(length>>16))\n+\t\t\t\t\tout = append(out, byte(length>>8))\n+\t\t\t\t\tout = append(out, byte(length))\n+\t\t\t\t}\n+\t\t\t\tfor j := 0; j < length; j++ {\n+\t\t\t\t\tout = append(out, byte(field.Index(j).Uint()))\n+\t\t\t\t}\n+\t\t\tcase reflect.String:\n+\t\t\t\tvar length int\n+\t\t\t\tfor j := 0; j < field.Len(); j++ {\n+\t\t\t\t\tif j != 0 {\n+\t\t\t\t\t\tlength++ /* comma */\n+\t\t\t\t\t}\n+\t\t\t\t\tlength += len(field.Index(j).String())\n+\t\t\t\t}\n+\n+\t\t\t\tout = append(out, byte(length>>24))\n+\t\t\t\tout = append(out, byte(length>>16))\n+\t\t\t\tout = append(out, byte(length>>8))\n+\t\t\t\tout = append(out, byte(length))\n+\t\t\t\tfor j := 0; j < field.Len(); j++ {\n+\t\t\t\t\tif j != 0 {\n+\t\t\t\t\t\tout = append(out, ',')\n+\t\t\t\t\t}\n+\t\t\t\t\tout = append(out, field.Index(j).String()...)\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tpanic(\"slice of unknown type\")\n+\t\t\t}\n+\t\tcase reflect.Ptr:\n+\t\t\tif t == bigIntType {\n+\t\t\t\tvar n *big.Int\n+\t\t\t\tnValue := reflect.ValueOf(&n)\n+\t\t\t\tnValue.Elem().Set(field)\n+\t\t\t\tneeded := intLength(n)\n+\t\t\t\toldLength := len(out)\n+\n+\t\t\t\tif cap(out)-len(out) < needed {\n+\t\t\t\t\tnewOut := make([]byte, len(out), 2*(len(out)+needed))\n+\t\t\t\t\tcopy(newOut, out)\n+\t\t\t\t\tout = newOut\n+\t\t\t\t}\n+\t\t\t\tout = out[:oldLength+needed]\n+\t\t\t\tmarshalInt(out[oldLength:], n)\n+\t\t\t} else {\n+\t\t\t\tpanic(\"pointer to unknown type\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn out\n+}\n+\n+var bigOne = big.NewInt(1)\n+\n+func parseString(in []byte) (out, rest []byte, ok bool) {\n+\tif len(in) < 4 {\n+\t\treturn\n+\t}\n+\tlength := uint32(in[0])<<24 | uint32(in[1])<<16 | uint32(in[2])<<8 | uint32(in[3])\n+\tif uint32(len(in)) < 4+length {\n+\t\treturn\n+\t}\n+\tout = in[4 : 4+length]\n+\trest = in[4+length:]\n+\tok = true\n+\treturn\n+}\n+\n+var comma = []byte{','}\n+\n+func parseNameList(in []byte) (out []string, rest []byte, ok bool) {\n+\tcontents, rest, ok := parseString(in)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\tif len(contents) == 0 {\n+\t\treturn\n+\t}\n+\tparts := bytes.Split(contents, comma)\n+\tout = make([]string, len(parts))\n+\tfor i, part := range parts {\n+\t\tout[i] = string(part)\n+\t}\n+\treturn\n+}\n+\n+func parseInt(in []byte) (out *big.Int, rest []byte, ok bool) {\n+\tcontents, rest, ok := parseString(in)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\tout = new(big.Int)\n+\n+\tif len(contents) > 0 && contents[0]&0x80 == 0x80 {\n+\t\t// This is a negative number\n+\t\tnotBytes := make([]byte, len(contents))\n+\t\tfor i := range notBytes {\n+\t\t\tnotBytes[i] = ^contents[i]\n+\t\t}\n+\t\tout.SetBytes(notBytes)\n+\t\tout.Add(out, bigOne)\n+\t\tout.Neg(out)\n+\t} else {\n+\t\t// Positive number\n+\t\tout.SetBytes(contents)\n+\t}\n+\tok = true\n+\treturn\n+}\n+\n+func parseUint32(in []byte) (out uint32, rest []byte, ok bool) {\n+\tif len(in) < 4 {\n+\t\treturn\n+\t}\n+\tout = uint32(in[0])<<24 | uint32(in[1])<<16 | uint32(in[2])<<8 | uint32(in[3])\n+\trest = in[4:]\n+\tok = true\n+\treturn\n+}\n+\n+const maxPacketSize = 36000\n+\n+func nameListLength(namelist []string) int {\n+\tlength := 4 /* uint32 length prefix */\n+\tfor i, name := range namelist {\n+\t\tif i != 0 {\n+\t\t\tlength++ /* comma */\n+\t\t}\n+\t\tlength += len(name)\n+\t}\n+\treturn length\n+}\n+\n+func intLength(n *big.Int) int {\n+\tlength := 4 /* length bytes */\n+\tif n.Sign() < 0 {\n+\t\tnMinus1 := new(big.Int).Neg(n)\n+\t\tnMinus1.Sub(nMinus1, bigOne)\n+\t\tbitLen := nMinus1.BitLen()\n+\t\tif bitLen%8 == 0 {\n+\t\t\t// The number will need 0xff padding\n+\t\t\tlength++\n+\t\t}\n+\t\tlength += (bitLen + 7) / 8\n+\t} else if n.Sign() == 0 {\n+\t\t// A zero is the zero length string\n+\t} else {\n+\t\tbitLen := n.BitLen()\n+\t\tif bitLen%8 == 0 {\n+\t\t\t// The number will need 0x00 padding\n+\t\t\tlength++\n+\t\t}\n+\t\tlength += (bitLen + 7) / 8\n+\t}\n+\n+\treturn length\n+}\n+\n+func marshalInt(to []byte, n *big.Int) []byte {\n+\tlengthBytes := to\n+\tto = to[4:]\n+\tlength := 0\n+\n+\tif n.Sign() < 0 {\n+\t\t// A negative number has to be converted to two's-complement\n+\t\t// form. So we'll subtract 1 and invert. If the\n+\t\t// most-significant-bit isn't set then we'll need to pad the\n+\t\t// beginning with 0xff in order to keep the number negative.\n+\t\tnMinus1 := new(big.Int).Neg(n)\n+\t\tnMinus1.Sub(nMinus1, bigOne)\n+\t\tbytes := nMinus1.Bytes()\n+\t\tfor i := range bytes {\n+\t\t\tbytes[i] ^= 0xff\n+\t\t}\n+\t\tif len(bytes) == 0 || bytes[0]&0x80 == 0 {\n+\t\t\tto[0] = 0xff\n+\t\t\tto = to[1:]\n+\t\t\tlength++\n+\t\t}\n+\t\tnBytes := copy(to, bytes)\n+\t\tto = to[nBytes:]\n+\t\tlength += nBytes\n+\t} else if n.Sign() == 0 {\n+\t\t// A zero is the zero length string\n+\t} else {\n+\t\tbytes := n.Bytes()\n+\t\tif len(bytes) > 0 && bytes[0]&0x80 != 0 {\n+\t\t\t// We'll have to pad this with a 0x00 in order to\n+\t\t\t// stop it looking like a negative number.\n+\t\t\tto[0] = 0\n+\t\t\tto = to[1:]\n+\t\t\tlength++\n+\t\t}\n+\t\tnBytes := copy(to, bytes)\n+\t\tto = to[nBytes:]\n+\t\tlength += nBytes\n+\t}\n+\n+\tlengthBytes[0] = byte(length >> 24)\n+\tlengthBytes[1] = byte(length >> 16)\n+\tlengthBytes[2] = byte(length >> 8)\n+\tlengthBytes[3] = byte(length)\n+\treturn to\n+}\n+\n+func writeInt(w io.Writer, n *big.Int) {\n+\tlength := intLength(n)\n+\tbuf := make([]byte, length)\n+\tmarshalInt(buf, n)\n+\tw.Write(buf)\n+}\n+\n+func writeString(w io.Writer, s []byte) {\n+\tvar lengthBytes [4]byte\n+\tlengthBytes[0] = byte(len(s) >> 24)\n+\tlengthBytes[1] = byte(len(s) >> 16)\n+\tlengthBytes[2] = byte(len(s) >> 8)\n+\tlengthBytes[3] = byte(len(s))\n+\tw.Write(lengthBytes[:])\n+\tw.Write(s)\n+}\n+\n+func stringLength(s []byte) int {\n+\treturn 4 + len(s)\n+}\n+\n+func marshalString(to []byte, s []byte) []byte {\n+\tto[0] = byte(len(s) >> 24)\n+\tto[1] = byte(len(s) >> 16)\n+\tto[2] = byte(len(s) >> 8)\n+\tto[3] = byte(len(s))\n+\tto = to[4:]\n+\tcopy(to, s)\n+\treturn to[len(s):]\n+}\n+\n+var bigIntType = reflect.TypeOf((*big.Int)(nil))\n+\n+// Decode a packet into it's corresponding message.\n+func decode(packet []byte) interface{} {\n+\tvar msg interface{}\n+\tswitch packet[0] {\n+\tcase msgDisconnect:\n+\t\tmsg = new(disconnectMsg)\n+\tcase msgServiceRequest:\n+\t\tmsg = new(serviceRequestMsg)\n+\tcase msgServiceAccept:\n+\t\tmsg = new(serviceAcceptMsg)\n+\tcase msgKexInit:\n+\t\tmsg = new(kexInitMsg)\n+\tcase msgKexDHInit:\n+\t\tmsg = new(kexDHInitMsg)\n+\tcase msgKexDHReply:\n+\t\tmsg = new(kexDHReplyMsg)\n+\tcase msgUserAuthRequest:\n+\t\tmsg = new(userAuthRequestMsg)\n+\tcase msgUserAuthFailure:\n+\t\tmsg = new(userAuthFailureMsg)\n+\tcase msgUserAuthPubKeyOk:\n+\t\tmsg = new(userAuthPubKeyOkMsg)\n+\tcase msgGlobalRequest:\n+\t\tmsg = new(globalRequestMsg)\n+\tcase msgRequestSuccess:\n+\t\tmsg = new(channelRequestSuccessMsg)\n+\tcase msgRequestFailure:\n+\t\tmsg = new(channelRequestFailureMsg)\n+\tcase msgChannelOpen:\n+\t\tmsg = new(channelOpenMsg)\n+\tcase msgChannelOpenConfirm:\n+\t\tmsg = new(channelOpenConfirmMsg)\n+\tcase msgChannelOpenFailure:\n+\t\tmsg = new(channelOpenFailureMsg)\n+\tcase msgChannelWindowAdjust:\n+\t\tmsg = new(windowAdjustMsg)\n+\tcase msgChannelData:\n+\t\tmsg = new(channelData)\n+\tcase msgChannelExtendedData:\n+\t\tmsg = new(channelExtendedData)\n+\tcase msgChannelEOF:\n+\t\tmsg = new(channelEOFMsg)\n+\tcase msgChannelClose:\n+\t\tmsg = new(channelCloseMsg)\n+\tcase msgChannelRequest:\n+\t\tmsg = new(channelRequestMsg)\n+\tcase msgChannelSuccess:\n+\t\tmsg = new(channelRequestSuccessMsg)\n+\tcase msgChannelFailure:\n+\t\tmsg = new(channelRequestFailureMsg)\n+\tdefault:\n+\t\treturn UnexpectedMessageError{0, packet[0]}\n+\t}\n+\tif err := unmarshal(msg, packet, packet[0]); err != nil {\n+\t\treturn err\n+\t}\n+\treturn msg\n+}"}, {"sha": "629f3d3b145acf183e31044c0b486541dde6d89d", "filename": "libgo/go/exp/ssh/messages_test.go", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fmessages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fmessages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"big\"\n+\t\"rand\"\n+\t\"reflect\"\n+\t\"testing\"\n+\t\"testing/quick\"\n+)\n+\n+var intLengthTests = []struct {\n+\tval, length int\n+}{\n+\t{0, 4 + 0},\n+\t{1, 4 + 1},\n+\t{127, 4 + 1},\n+\t{128, 4 + 2},\n+\t{-1, 4 + 1},\n+}\n+\n+func TestIntLength(t *testing.T) {\n+\tfor _, test := range intLengthTests {\n+\t\tv := new(big.Int).SetInt64(int64(test.val))\n+\t\tlength := intLength(v)\n+\t\tif length != test.length {\n+\t\t\tt.Errorf(\"For %d, got length %d but expected %d\", test.val, length, test.length)\n+\t\t}\n+\t}\n+}\n+\n+var messageTypes = []interface{}{\n+\t&kexInitMsg{},\n+\t&kexDHInitMsg{},\n+\t&serviceRequestMsg{},\n+\t&serviceAcceptMsg{},\n+\t&userAuthRequestMsg{},\n+\t&channelOpenMsg{},\n+\t&channelOpenConfirmMsg{},\n+\t&channelRequestMsg{},\n+\t&channelRequestSuccessMsg{},\n+}\n+\n+func TestMarshalUnmarshal(t *testing.T) {\n+\trand := rand.New(rand.NewSource(0))\n+\tfor i, iface := range messageTypes {\n+\t\tty := reflect.ValueOf(iface).Type()\n+\n+\t\tn := 100\n+\t\tif testing.Short() {\n+\t\t\tn = 5\n+\t\t}\n+\t\tfor j := 0; j < n; j++ {\n+\t\t\tv, ok := quick.Value(ty, rand)\n+\t\t\tif !ok {\n+\t\t\t\tt.Errorf(\"#%d: failed to create value\", i)\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tm1 := v.Elem().Interface()\n+\t\t\tm2 := iface\n+\n+\t\t\tmarshaled := marshal(msgIgnore, m1)\n+\t\t\tif err := unmarshal(m2, marshaled, msgIgnore); err != nil {\n+\t\t\t\tt.Errorf(\"#%d failed to unmarshal %#v: %s\", i, m1, err)\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tif !reflect.DeepEqual(v.Interface(), m2) {\n+\t\t\t\tt.Errorf(\"#%d\\ngot: %#v\\nwant:%#v\\n%x\", i, m2, m1, marshaled)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func randomBytes(out []byte, rand *rand.Rand) {\n+\tfor i := 0; i < len(out); i++ {\n+\t\tout[i] = byte(rand.Int31())\n+\t}\n+}\n+\n+func randomNameList(rand *rand.Rand) []string {\n+\tret := make([]string, rand.Int31()&15)\n+\tfor i := range ret {\n+\t\ts := make([]byte, 1+(rand.Int31()&15))\n+\t\tfor j := range s {\n+\t\t\ts[j] = 'a' + uint8(rand.Int31()&15)\n+\t\t}\n+\t\tret[i] = string(s)\n+\t}\n+\treturn ret\n+}\n+\n+func randomInt(rand *rand.Rand) *big.Int {\n+\treturn new(big.Int).SetInt64(int64(int32(rand.Uint32())))\n+}\n+\n+func (*kexInitMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n+\tki := &kexInitMsg{}\n+\trandomBytes(ki.Cookie[:], rand)\n+\tki.KexAlgos = randomNameList(rand)\n+\tki.ServerHostKeyAlgos = randomNameList(rand)\n+\tki.CiphersClientServer = randomNameList(rand)\n+\tki.CiphersServerClient = randomNameList(rand)\n+\tki.MACsClientServer = randomNameList(rand)\n+\tki.MACsServerClient = randomNameList(rand)\n+\tki.CompressionClientServer = randomNameList(rand)\n+\tki.CompressionServerClient = randomNameList(rand)\n+\tki.LanguagesClientServer = randomNameList(rand)\n+\tki.LanguagesServerClient = randomNameList(rand)\n+\tif rand.Int31()&1 == 1 {\n+\t\tki.FirstKexFollows = true\n+\t}\n+\treturn reflect.ValueOf(ki)\n+}\n+\n+func (*kexDHInitMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n+\tdhi := &kexDHInitMsg{}\n+\tdhi.X = randomInt(rand)\n+\treturn reflect.ValueOf(dhi)\n+}"}, {"sha": "410cafc44c29ef95a3f7825e98aacb35f5b7d613", "filename": "libgo/go/exp/ssh/server.go", "status": "added", "additions": 645, "deletions": 0, "changes": 645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,645 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"big\"\n+\t\"bytes\"\n+\t\"crypto\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t_ \"crypto/sha1\"\n+\t\"crypto/x509\"\n+\t\"encoding/pem\"\n+\t\"net\"\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+// Server represents an SSH server. A Server may have several ServerConnections.\n+type Server struct {\n+\trsa           *rsa.PrivateKey\n+\trsaSerialized []byte\n+\n+\t// NoClientAuth is true if clients are allowed to connect without\n+\t// authenticating.\n+\tNoClientAuth bool\n+\n+\t// PasswordCallback, if non-nil, is called when a user attempts to\n+\t// authenticate using a password. It may be called concurrently from\n+\t// several goroutines.\n+\tPasswordCallback func(user, password string) bool\n+\n+\t// PubKeyCallback, if non-nil, is called when a client attempts public\n+\t// key authentication. It must return true iff the given public key is\n+\t// valid for the given user.\n+\tPubKeyCallback func(user, algo string, pubkey []byte) bool\n+}\n+\n+// SetRSAPrivateKey sets the private key for a Server. A Server must have a\n+// private key configured in order to accept connections. The private key must\n+// be in the form of a PEM encoded, PKCS#1, RSA private key. The file \"id_rsa\"\n+// typically contains such a key.\n+func (s *Server) SetRSAPrivateKey(pemBytes []byte) os.Error {\n+\tblock, _ := pem.Decode(pemBytes)\n+\tif block == nil {\n+\t\treturn os.NewError(\"ssh: no key found\")\n+\t}\n+\tvar err os.Error\n+\ts.rsa, err = x509.ParsePKCS1PrivateKey(block.Bytes)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\ts.rsaSerialized = marshalRSA(s.rsa)\n+\treturn nil\n+}\n+\n+// marshalRSA serializes an RSA private key according to RFC 4256, section 6.6.\n+func marshalRSA(priv *rsa.PrivateKey) []byte {\n+\te := new(big.Int).SetInt64(int64(priv.E))\n+\tlength := stringLength([]byte(hostAlgoRSA))\n+\tlength += intLength(e)\n+\tlength += intLength(priv.N)\n+\n+\tret := make([]byte, length)\n+\tr := marshalString(ret, []byte(hostAlgoRSA))\n+\tr = marshalInt(r, e)\n+\tr = marshalInt(r, priv.N)\n+\n+\treturn ret\n+}\n+\n+// parseRSA parses an RSA key according to RFC 4256, section 6.6.\n+func parseRSA(in []byte) (pubKey *rsa.PublicKey, ok bool) {\n+\talgo, in, ok := parseString(in)\n+\tif !ok || string(algo) != hostAlgoRSA {\n+\t\treturn nil, false\n+\t}\n+\tbigE, in, ok := parseInt(in)\n+\tif !ok || bigE.BitLen() > 24 {\n+\t\treturn nil, false\n+\t}\n+\te := bigE.Int64()\n+\tif e < 3 || e&1 == 0 {\n+\t\treturn nil, false\n+\t}\n+\tN, in, ok := parseInt(in)\n+\tif !ok || len(in) > 0 {\n+\t\treturn nil, false\n+\t}\n+\treturn &rsa.PublicKey{\n+\t\tN: N,\n+\t\tE: int(e),\n+\t}, true\n+}\n+\n+func parseRSASig(in []byte) (sig []byte, ok bool) {\n+\talgo, in, ok := parseString(in)\n+\tif !ok || string(algo) != hostAlgoRSA {\n+\t\treturn nil, false\n+\t}\n+\tsig, in, ok = parseString(in)\n+\tif len(in) > 0 {\n+\t\tok = false\n+\t}\n+\treturn\n+}\n+\n+// cachedPubKey contains the results of querying whether a public key is\n+// acceptable for a user. The cache only applies to a single ServerConnection.\n+type cachedPubKey struct {\n+\tuser, algo string\n+\tpubKey     []byte\n+\tresult     bool\n+}\n+\n+const maxCachedPubKeys = 16\n+\n+// ServerConnection represents an incomming connection to a Server.\n+type ServerConnection struct {\n+\tServer *Server\n+\n+\t*transport\n+\n+\tchannels   map[uint32]*channel\n+\tnextChanId uint32\n+\n+\t// lock protects err and also allows Channels to serialise their writes\n+\t// to out.\n+\tlock sync.RWMutex\n+\terr  os.Error\n+\n+\t// cachedPubKeys contains the cache results of tests for public keys.\n+\t// Since SSH clients will query whether a public key is acceptable\n+\t// before attempting to authenticate with it, we end up with duplicate\n+\t// queries for public key validity.\n+\tcachedPubKeys []cachedPubKey\n+}\n+\n+// kexDH performs Diffie-Hellman key agreement on a ServerConnection. The\n+// returned values are given the same names as in RFC 4253, section 8.\n+func (s *ServerConnection) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handshakeMagics, hostKeyAlgo string) (H, K []byte, err os.Error) {\n+\tpacket, err := s.readPacket()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar kexDHInit kexDHInitMsg\n+\tif err = unmarshal(&kexDHInit, packet, msgKexDHInit); err != nil {\n+\t\treturn\n+\t}\n+\n+\tif kexDHInit.X.Sign() == 0 || kexDHInit.X.Cmp(group.p) >= 0 {\n+\t\treturn nil, nil, os.NewError(\"client DH parameter out of bounds\")\n+\t}\n+\n+\ty, err := rand.Int(rand.Reader, group.p)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tY := new(big.Int).Exp(group.g, y, group.p)\n+\tkInt := new(big.Int).Exp(kexDHInit.X, y, group.p)\n+\n+\tvar serializedHostKey []byte\n+\tswitch hostKeyAlgo {\n+\tcase hostAlgoRSA:\n+\t\tserializedHostKey = s.Server.rsaSerialized\n+\tdefault:\n+\t\treturn nil, nil, os.NewError(\"internal error\")\n+\t}\n+\n+\th := hashFunc.New()\n+\twriteString(h, magics.clientVersion)\n+\twriteString(h, magics.serverVersion)\n+\twriteString(h, magics.clientKexInit)\n+\twriteString(h, magics.serverKexInit)\n+\twriteString(h, serializedHostKey)\n+\twriteInt(h, kexDHInit.X)\n+\twriteInt(h, Y)\n+\tK = make([]byte, intLength(kInt))\n+\tmarshalInt(K, kInt)\n+\th.Write(K)\n+\n+\tH = h.Sum()\n+\n+\th.Reset()\n+\th.Write(H)\n+\thh := h.Sum()\n+\n+\tvar sig []byte\n+\tswitch hostKeyAlgo {\n+\tcase hostAlgoRSA:\n+\t\tsig, err = rsa.SignPKCS1v15(rand.Reader, s.Server.rsa, hashFunc, hh)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\tdefault:\n+\t\treturn nil, nil, os.NewError(\"internal error\")\n+\t}\n+\n+\tserializedSig := serializeRSASignature(sig)\n+\n+\tkexDHReply := kexDHReplyMsg{\n+\t\tHostKey:   serializedHostKey,\n+\t\tY:         Y,\n+\t\tSignature: serializedSig,\n+\t}\n+\tpacket = marshal(msgKexDHReply, kexDHReply)\n+\n+\terr = s.writePacket(packet)\n+\treturn\n+}\n+\n+func serializeRSASignature(sig []byte) []byte {\n+\tlength := stringLength([]byte(hostAlgoRSA))\n+\tlength += stringLength(sig)\n+\n+\tret := make([]byte, length)\n+\tr := marshalString(ret, []byte(hostAlgoRSA))\n+\tr = marshalString(r, sig)\n+\n+\treturn ret\n+}\n+\n+// serverVersion is the fixed identification string that Server will use.\n+var serverVersion = []byte(\"SSH-2.0-Go\\r\\n\")\n+\n+// buildDataSignedForAuth returns the data that is signed in order to prove\n+// posession of a private key. See RFC 4252, section 7.\n+func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubKey []byte) []byte {\n+\tuser := []byte(req.User)\n+\tservice := []byte(req.Service)\n+\tmethod := []byte(req.Method)\n+\n+\tlength := stringLength(sessionId)\n+\tlength += 1\n+\tlength += stringLength(user)\n+\tlength += stringLength(service)\n+\tlength += stringLength(method)\n+\tlength += 1\n+\tlength += stringLength(algo)\n+\tlength += stringLength(pubKey)\n+\n+\tret := make([]byte, length)\n+\tr := marshalString(ret, sessionId)\n+\tr[0] = msgUserAuthRequest\n+\tr = r[1:]\n+\tr = marshalString(r, user)\n+\tr = marshalString(r, service)\n+\tr = marshalString(r, method)\n+\tr[0] = 1\n+\tr = r[1:]\n+\tr = marshalString(r, algo)\n+\tr = marshalString(r, pubKey)\n+\treturn ret\n+}\n+\n+// Handshake performs an SSH transport and client authentication on the given ServerConnection.\n+func (s *ServerConnection) Handshake(conn net.Conn) os.Error {\n+\tvar magics handshakeMagics\n+\ts.transport = newTransport(conn, rand.Reader)\n+\n+\tif _, err := conn.Write(serverVersion); err != nil {\n+\t\treturn err\n+\t}\n+\tmagics.serverVersion = serverVersion[:len(serverVersion)-2]\n+\n+\tversion, ok := readVersion(s.transport)\n+\tif !ok {\n+\t\treturn os.NewError(\"failed to read version string from client\")\n+\t}\n+\tmagics.clientVersion = version\n+\n+\tserverKexInit := kexInitMsg{\n+\t\tKexAlgos:                supportedKexAlgos,\n+\t\tServerHostKeyAlgos:      supportedHostKeyAlgos,\n+\t\tCiphersClientServer:     supportedCiphers,\n+\t\tCiphersServerClient:     supportedCiphers,\n+\t\tMACsClientServer:        supportedMACs,\n+\t\tMACsServerClient:        supportedMACs,\n+\t\tCompressionClientServer: supportedCompressions,\n+\t\tCompressionServerClient: supportedCompressions,\n+\t}\n+\tkexInitPacket := marshal(msgKexInit, serverKexInit)\n+\tmagics.serverKexInit = kexInitPacket\n+\n+\tif err := s.writePacket(kexInitPacket); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tpacket, err := s.readPacket()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tmagics.clientKexInit = packet\n+\n+\tvar clientKexInit kexInitMsg\n+\tif err = unmarshal(&clientKexInit, packet, msgKexInit); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tkexAlgo, hostKeyAlgo, ok := findAgreedAlgorithms(s.transport, &clientKexInit, &serverKexInit)\n+\tif !ok {\n+\t\treturn os.NewError(\"ssh: no common algorithms\")\n+\t}\n+\n+\tif clientKexInit.FirstKexFollows && kexAlgo != clientKexInit.KexAlgos[0] {\n+\t\t// The client sent a Kex message for the wrong algorithm,\n+\t\t// which we have to ignore.\n+\t\t_, err := s.readPacket()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tvar H, K []byte\n+\tvar hashFunc crypto.Hash\n+\tswitch kexAlgo {\n+\tcase kexAlgoDH14SHA1:\n+\t\thashFunc = crypto.SHA1\n+\t\tdhGroup14Once.Do(initDHGroup14)\n+\t\tH, K, err = s.kexDH(dhGroup14, hashFunc, &magics, hostKeyAlgo)\n+\tdefault:\n+\t\terr = os.NewError(\"ssh: internal error\")\n+\t}\n+\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tpacket = []byte{msgNewKeys}\n+\tif err = s.writePacket(packet); err != nil {\n+\t\treturn err\n+\t}\n+\tif err = s.transport.writer.setupKeys(serverKeys, K, H, H, hashFunc); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif packet, err = s.readPacket(); err != nil {\n+\t\treturn err\n+\t}\n+\tif packet[0] != msgNewKeys {\n+\t\treturn UnexpectedMessageError{msgNewKeys, packet[0]}\n+\t}\n+\n+\ts.transport.reader.setupKeys(clientKeys, K, H, H, hashFunc)\n+\n+\tpacket, err = s.readPacket()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar serviceRequest serviceRequestMsg\n+\tif err = unmarshal(&serviceRequest, packet, msgServiceRequest); err != nil {\n+\t\treturn err\n+\t}\n+\tif serviceRequest.Service != serviceUserAuth {\n+\t\treturn os.NewError(\"ssh: requested service '\" + serviceRequest.Service + \"' before authenticating\")\n+\t}\n+\n+\tserviceAccept := serviceAcceptMsg{\n+\t\tService: serviceUserAuth,\n+\t}\n+\tpacket = marshal(msgServiceAccept, serviceAccept)\n+\tif err = s.writePacket(packet); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err = s.authenticate(H); err != nil {\n+\t\treturn err\n+\t}\n+\n+\ts.channels = make(map[uint32]*channel)\n+\treturn nil\n+}\n+\n+func isAcceptableAlgo(algo string) bool {\n+\treturn algo == hostAlgoRSA\n+}\n+\n+// testPubKey returns true if the given public key is acceptable for the user.\n+func (s *ServerConnection) testPubKey(user, algo string, pubKey []byte) bool {\n+\tif s.Server.PubKeyCallback == nil || !isAcceptableAlgo(algo) {\n+\t\treturn false\n+\t}\n+\n+\tfor _, c := range s.cachedPubKeys {\n+\t\tif c.user == user && c.algo == algo && bytes.Equal(c.pubKey, pubKey) {\n+\t\t\treturn c.result\n+\t\t}\n+\t}\n+\n+\tresult := s.Server.PubKeyCallback(user, algo, pubKey)\n+\tif len(s.cachedPubKeys) < maxCachedPubKeys {\n+\t\tc := cachedPubKey{\n+\t\t\tuser:   user,\n+\t\t\talgo:   algo,\n+\t\t\tpubKey: make([]byte, len(pubKey)),\n+\t\t\tresult: result,\n+\t\t}\n+\t\tcopy(c.pubKey, pubKey)\n+\t\ts.cachedPubKeys = append(s.cachedPubKeys, c)\n+\t}\n+\n+\treturn result\n+}\n+\n+func (s *ServerConnection) authenticate(H []byte) os.Error {\n+\tvar userAuthReq userAuthRequestMsg\n+\tvar err os.Error\n+\tvar packet []byte\n+\n+userAuthLoop:\n+\tfor {\n+\t\tif packet, err = s.readPacket(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err = unmarshal(&userAuthReq, packet, msgUserAuthRequest); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tif userAuthReq.Service != serviceSSH {\n+\t\t\treturn os.NewError(\"ssh: client attempted to negotiate for unknown service: \" + userAuthReq.Service)\n+\t\t}\n+\n+\t\tswitch userAuthReq.Method {\n+\t\tcase \"none\":\n+\t\t\tif s.Server.NoClientAuth {\n+\t\t\t\tbreak userAuthLoop\n+\t\t\t}\n+\t\tcase \"password\":\n+\t\t\tif s.Server.PasswordCallback == nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tpayload := userAuthReq.Payload\n+\t\t\tif len(payload) < 1 || payload[0] != 0 {\n+\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t}\n+\t\t\tpayload = payload[1:]\n+\t\t\tpassword, payload, ok := parseString(payload)\n+\t\t\tif !ok || len(payload) > 0 {\n+\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t}\n+\n+\t\t\tif s.Server.PasswordCallback(userAuthReq.User, string(password)) {\n+\t\t\t\tbreak userAuthLoop\n+\t\t\t}\n+\t\tcase \"publickey\":\n+\t\t\tif s.Server.PubKeyCallback == nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tpayload := userAuthReq.Payload\n+\t\t\tif len(payload) < 1 {\n+\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t}\n+\t\t\tisQuery := payload[0] == 0\n+\t\t\tpayload = payload[1:]\n+\t\t\talgoBytes, payload, ok := parseString(payload)\n+\t\t\tif !ok {\n+\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t}\n+\t\t\talgo := string(algoBytes)\n+\n+\t\t\tpubKey, payload, ok := parseString(payload)\n+\t\t\tif !ok {\n+\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t}\n+\t\t\tif isQuery {\n+\t\t\t\t// The client can query if the given public key\n+\t\t\t\t// would be ok.\n+\t\t\t\tif len(payload) > 0 {\n+\t\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t\t}\n+\t\t\t\tif s.testPubKey(userAuthReq.User, algo, pubKey) {\n+\t\t\t\t\tokMsg := userAuthPubKeyOkMsg{\n+\t\t\t\t\t\tAlgo:   algo,\n+\t\t\t\t\t\tPubKey: string(pubKey),\n+\t\t\t\t\t}\n+\t\t\t\t\tif err = s.writePacket(marshal(msgUserAuthPubKeyOk, okMsg)); err != nil {\n+\t\t\t\t\t\treturn err\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue userAuthLoop\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tsig, payload, ok := parseString(payload)\n+\t\t\t\tif !ok || len(payload) > 0 {\n+\t\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t\t}\n+\t\t\t\tif !isAcceptableAlgo(algo) {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\trsaSig, ok := parseRSASig(sig)\n+\t\t\t\tif !ok {\n+\t\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t\t}\n+\t\t\t\tsignedData := buildDataSignedForAuth(H, userAuthReq, algoBytes, pubKey)\n+\t\t\t\tswitch algo {\n+\t\t\t\tcase hostAlgoRSA:\n+\t\t\t\t\thashFunc := crypto.SHA1\n+\t\t\t\t\th := hashFunc.New()\n+\t\t\t\t\th.Write(signedData)\n+\t\t\t\t\tdigest := h.Sum()\n+\t\t\t\t\trsaKey, ok := parseRSA(pubKey)\n+\t\t\t\t\tif !ok {\n+\t\t\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t\t\t}\n+\t\t\t\t\tif rsa.VerifyPKCS1v15(rsaKey, hashFunc, digest, rsaSig) != nil {\n+\t\t\t\t\t\treturn ParseError{msgUserAuthRequest}\n+\t\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\treturn os.NewError(\"ssh: isAcceptableAlgo incorrect\")\n+\t\t\t\t}\n+\t\t\t\tif s.testPubKey(userAuthReq.User, algo, pubKey) {\n+\t\t\t\t\tbreak userAuthLoop\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tvar failureMsg userAuthFailureMsg\n+\t\tif s.Server.PasswordCallback != nil {\n+\t\t\tfailureMsg.Methods = append(failureMsg.Methods, \"password\")\n+\t\t}\n+\t\tif s.Server.PubKeyCallback != nil {\n+\t\t\tfailureMsg.Methods = append(failureMsg.Methods, \"publickey\")\n+\t\t}\n+\n+\t\tif len(failureMsg.Methods) == 0 {\n+\t\t\treturn os.NewError(\"ssh: no authentication methods configured but NoClientAuth is also false\")\n+\t\t}\n+\n+\t\tif err = s.writePacket(marshal(msgUserAuthFailure, failureMsg)); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tpacket = []byte{msgUserAuthSuccess}\n+\tif err = s.writePacket(packet); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil\n+}\n+\n+const defaultWindowSize = 32768\n+\n+// Accept reads and processes messages on a ServerConnection. It must be called\n+// in order to demultiplex messages to any resulting Channels.\n+func (s *ServerConnection) Accept() (Channel, os.Error) {\n+\tif s.err != nil {\n+\t\treturn nil, s.err\n+\t}\n+\n+\tfor {\n+\t\tpacket, err := s.readPacket()\n+\t\tif err != nil {\n+\n+\t\t\ts.lock.Lock()\n+\t\t\ts.err = err\n+\t\t\ts.lock.Unlock()\n+\n+\t\t\tfor _, c := range s.channels {\n+\t\t\t\tc.dead = true\n+\t\t\t\tc.handleData(nil)\n+\t\t\t}\n+\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tswitch msg := decode(packet).(type) {\n+\t\tcase *channelOpenMsg:\n+\t\t\tc := new(channel)\n+\t\t\tc.chanType = msg.ChanType\n+\t\t\tc.theirId = msg.PeersId\n+\t\t\tc.theirWindow = msg.PeersWindow\n+\t\t\tc.maxPacketSize = msg.MaxPacketSize\n+\t\t\tc.extraData = msg.TypeSpecificData\n+\t\t\tc.myWindow = defaultWindowSize\n+\t\t\tc.serverConn = s\n+\t\t\tc.cond = sync.NewCond(&c.lock)\n+\t\t\tc.pendingData = make([]byte, c.myWindow)\n+\n+\t\t\ts.lock.Lock()\n+\t\t\tc.myId = s.nextChanId\n+\t\t\ts.nextChanId++\n+\t\t\ts.channels[c.myId] = c\n+\t\t\ts.lock.Unlock()\n+\t\t\treturn c, nil\n+\n+\t\tcase *channelRequestMsg:\n+\t\t\ts.lock.Lock()\n+\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tc.handlePacket(msg)\n+\t\t\ts.lock.Unlock()\n+\n+\t\tcase *channelData:\n+\t\t\ts.lock.Lock()\n+\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tc.handleData(msg.Payload)\n+\t\t\ts.lock.Unlock()\n+\n+\t\tcase *channelEOFMsg:\n+\t\t\ts.lock.Lock()\n+\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tc.handlePacket(msg)\n+\t\t\ts.lock.Unlock()\n+\n+\t\tcase *channelCloseMsg:\n+\t\t\ts.lock.Lock()\n+\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\tif !ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tc.handlePacket(msg)\n+\t\t\ts.lock.Unlock()\n+\n+\t\tcase *globalRequestMsg:\n+\t\t\tif msg.WantReply {\n+\t\t\t\tif err := s.writePacket([]byte{msgRequestFailure}); err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\tcase UnexpectedMessageError:\n+\t\t\treturn nil, msg\n+\t\tcase *disconnectMsg:\n+\t\t\treturn nil, os.EOF\n+\t\tdefault:\n+\t\t\t// Unknown message. Ignore.\n+\t\t}\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "0e9967a90911c13255488239d1e9e55e3790efa6", "filename": "libgo/go/exp/ssh/server_shell.go", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,400 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"os\"\n+)\n+\n+// ServerShell contains the state for running a VT100 terminal that is capable\n+// of reading lines of input.\n+type ServerShell struct {\n+\tc      Channel\n+\tprompt string\n+\n+\t// line is the current line being entered.\n+\tline []byte\n+\t// pos is the logical position of the cursor in line\n+\tpos int\n+\n+\t// cursorX contains the current X value of the cursor where the left\n+\t// edge is 0. cursorY contains the row number where the first row of\n+\t// the current line is 0.\n+\tcursorX, cursorY int\n+\t// maxLine is the greatest value of cursorY so far.\n+\tmaxLine int\n+\n+\ttermWidth, termHeight int\n+\n+\t// outBuf contains the terminal data to be sent.\n+\toutBuf []byte\n+\t// remainder contains the remainder of any partial key sequences after\n+\t// a read. It aliases into inBuf.\n+\tremainder []byte\n+\tinBuf     [256]byte\n+}\n+\n+// NewServerShell runs a VT100 terminal on the given channel. prompt is a\n+// string that is written at the start of each input line. For example: \"> \".\n+func NewServerShell(c Channel, prompt string) *ServerShell {\n+\treturn &ServerShell{\n+\t\tc:          c,\n+\t\tprompt:     prompt,\n+\t\ttermWidth:  80,\n+\t\ttermHeight: 24,\n+\t}\n+}\n+\n+const (\n+\tkeyCtrlD     = 4\n+\tkeyEnter     = '\\r'\n+\tkeyEscape    = 27\n+\tkeyBackspace = 127\n+\tkeyUnknown   = 256 + iota\n+\tkeyUp\n+\tkeyDown\n+\tkeyLeft\n+\tkeyRight\n+\tkeyAltLeft\n+\tkeyAltRight\n+)\n+\n+// bytesToKey tries to parse a key sequence from b. If successful, it returns\n+// the key and the remainder of the input. Otherwise it returns -1.\n+func bytesToKey(b []byte) (int, []byte) {\n+\tif len(b) == 0 {\n+\t\treturn -1, nil\n+\t}\n+\n+\tif b[0] != keyEscape {\n+\t\treturn int(b[0]), b[1:]\n+\t}\n+\n+\tif len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {\n+\t\tswitch b[2] {\n+\t\tcase 'A':\n+\t\t\treturn keyUp, b[3:]\n+\t\tcase 'B':\n+\t\t\treturn keyDown, b[3:]\n+\t\tcase 'C':\n+\t\t\treturn keyRight, b[3:]\n+\t\tcase 'D':\n+\t\t\treturn keyLeft, b[3:]\n+\t\t}\n+\t}\n+\n+\tif len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {\n+\t\tswitch b[5] {\n+\t\tcase 'C':\n+\t\t\treturn keyAltRight, b[6:]\n+\t\tcase 'D':\n+\t\t\treturn keyAltLeft, b[6:]\n+\t\t}\n+\t}\n+\n+\t// If we get here then we have a key that we don't recognise, or a\n+\t// partial sequence. It's not clear how one should find the end of a\n+\t// sequence without knowing them all, but it seems that [a-zA-Z] only\n+\t// appears at the end of a sequence.\n+\tfor i, c := range b[0:] {\n+\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n+\t\t\treturn keyUnknown, b[i+1:]\n+\t\t}\n+\t}\n+\n+\treturn -1, b\n+}\n+\n+// queue appends data to the end of ss.outBuf\n+func (ss *ServerShell) queue(data []byte) {\n+\tif len(ss.outBuf)+len(data) > cap(ss.outBuf) {\n+\t\tnewOutBuf := make([]byte, len(ss.outBuf), 2*(len(ss.outBuf)+len(data)))\n+\t\tcopy(newOutBuf, ss.outBuf)\n+\t\tss.outBuf = newOutBuf\n+\t}\n+\n+\toldLen := len(ss.outBuf)\n+\tss.outBuf = ss.outBuf[:len(ss.outBuf)+len(data)]\n+\tcopy(ss.outBuf[oldLen:], data)\n+}\n+\n+var eraseUnderCursor = []byte{' ', keyEscape, '[', 'D'}\n+\n+func isPrintable(key int) bool {\n+\treturn key >= 32 && key < 127\n+}\n+\n+// moveCursorToPos appends data to ss.outBuf which will move the cursor to the\n+// given, logical position in the text.\n+func (ss *ServerShell) moveCursorToPos(pos int) {\n+\tx := len(ss.prompt) + pos\n+\ty := x / ss.termWidth\n+\tx = x % ss.termWidth\n+\n+\tup := 0\n+\tif y < ss.cursorY {\n+\t\tup = ss.cursorY - y\n+\t}\n+\n+\tdown := 0\n+\tif y > ss.cursorY {\n+\t\tdown = y - ss.cursorY\n+\t}\n+\n+\tleft := 0\n+\tif x < ss.cursorX {\n+\t\tleft = ss.cursorX - x\n+\t}\n+\n+\tright := 0\n+\tif x > ss.cursorX {\n+\t\tright = x - ss.cursorX\n+\t}\n+\n+\tmovement := make([]byte, 3*(up+down+left+right))\n+\tm := movement\n+\tfor i := 0; i < up; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'A'\n+\t\tm = m[3:]\n+\t}\n+\tfor i := 0; i < down; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'B'\n+\t\tm = m[3:]\n+\t}\n+\tfor i := 0; i < left; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'D'\n+\t\tm = m[3:]\n+\t}\n+\tfor i := 0; i < right; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'C'\n+\t\tm = m[3:]\n+\t}\n+\n+\tss.cursorX = x\n+\tss.cursorY = y\n+\tss.queue(movement)\n+}\n+\n+const maxLineLength = 4096\n+\n+// handleKey processes the given key and, optionally, returns a line of text\n+// that the user has entered.\n+func (ss *ServerShell) handleKey(key int) (line string, ok bool) {\n+\tswitch key {\n+\tcase keyBackspace:\n+\t\tif ss.pos == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tss.pos--\n+\n+\t\tcopy(ss.line[ss.pos:], ss.line[1+ss.pos:])\n+\t\tss.line = ss.line[:len(ss.line)-1]\n+\t\tss.writeLine(ss.line[ss.pos:])\n+\t\tss.moveCursorToPos(ss.pos)\n+\t\tss.queue(eraseUnderCursor)\n+\tcase keyAltLeft:\n+\t\t// move left by a word.\n+\t\tif ss.pos == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tss.pos--\n+\t\tfor ss.pos > 0 {\n+\t\t\tif ss.line[ss.pos] != ' ' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tss.pos--\n+\t\t}\n+\t\tfor ss.pos > 0 {\n+\t\t\tif ss.line[ss.pos] == ' ' {\n+\t\t\t\tss.pos++\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tss.pos--\n+\t\t}\n+\t\tss.moveCursorToPos(ss.pos)\n+\tcase keyAltRight:\n+\t\t// move right by a word.\n+\t\tfor ss.pos < len(ss.line) {\n+\t\t\tif ss.line[ss.pos] == ' ' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tss.pos++\n+\t\t}\n+\t\tfor ss.pos < len(ss.line) {\n+\t\t\tif ss.line[ss.pos] != ' ' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tss.pos++\n+\t\t}\n+\t\tss.moveCursorToPos(ss.pos)\n+\tcase keyLeft:\n+\t\tif ss.pos == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tss.pos--\n+\t\tss.moveCursorToPos(ss.pos)\n+\tcase keyRight:\n+\t\tif ss.pos == len(ss.line) {\n+\t\t\treturn\n+\t\t}\n+\t\tss.pos++\n+\t\tss.moveCursorToPos(ss.pos)\n+\tcase keyEnter:\n+\t\tss.moveCursorToPos(len(ss.line))\n+\t\tss.queue([]byte(\"\\r\\n\"))\n+\t\tline = string(ss.line)\n+\t\tok = true\n+\t\tss.line = ss.line[:0]\n+\t\tss.pos = 0\n+\t\tss.cursorX = 0\n+\t\tss.cursorY = 0\n+\t\tss.maxLine = 0\n+\tdefault:\n+\t\tif !isPrintable(key) {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(ss.line) == maxLineLength {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(ss.line) == cap(ss.line) {\n+\t\t\tnewLine := make([]byte, len(ss.line), 2*(1+len(ss.line)))\n+\t\t\tcopy(newLine, ss.line)\n+\t\t\tss.line = newLine\n+\t\t}\n+\t\tss.line = ss.line[:len(ss.line)+1]\n+\t\tcopy(ss.line[ss.pos+1:], ss.line[ss.pos:])\n+\t\tss.line[ss.pos] = byte(key)\n+\t\tss.writeLine(ss.line[ss.pos:])\n+\t\tss.pos++\n+\t\tss.moveCursorToPos(ss.pos)\n+\t}\n+\treturn\n+}\n+\n+func (ss *ServerShell) writeLine(line []byte) {\n+\tfor len(line) != 0 {\n+\t\tif ss.cursorX == ss.termWidth {\n+\t\t\tss.queue([]byte(\"\\r\\n\"))\n+\t\t\tss.cursorX = 0\n+\t\t\tss.cursorY++\n+\t\t\tif ss.cursorY > ss.maxLine {\n+\t\t\t\tss.maxLine = ss.cursorY\n+\t\t\t}\n+\t\t}\n+\n+\t\tremainingOnLine := ss.termWidth - ss.cursorX\n+\t\ttodo := len(line)\n+\t\tif todo > remainingOnLine {\n+\t\t\ttodo = remainingOnLine\n+\t\t}\n+\t\tss.queue(line[:todo])\n+\t\tss.cursorX += todo\n+\t\tline = line[todo:]\n+\t}\n+}\n+\n+// parsePtyRequest parses the payload of the pty-req message and extracts the\n+// dimensions of the terminal. See RFC 4254, section 6.2.\n+func parsePtyRequest(s []byte) (width, height int, ok bool) {\n+\t_, s, ok = parseString(s)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\twidth32, s, ok := parseUint32(s)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\theight32, _, ok := parseUint32(s)\n+\twidth = int(width32)\n+\theight = int(height32)\n+\tif width < 1 {\n+\t\tok = false\n+\t}\n+\tif height < 1 {\n+\t\tok = false\n+\t}\n+\treturn\n+}\n+\n+func (ss *ServerShell) Write(buf []byte) (n int, err os.Error) {\n+\treturn ss.c.Write(buf)\n+}\n+\n+// ReadLine returns a line of input from the terminal.\n+func (ss *ServerShell) ReadLine() (line string, err os.Error) {\n+\tss.writeLine([]byte(ss.prompt))\n+\tss.c.Write(ss.outBuf)\n+\tss.outBuf = ss.outBuf[:0]\n+\n+\tfor {\n+\t\t// ss.remainder is a slice at the beginning of ss.inBuf\n+\t\t// containing a partial key sequence\n+\t\treadBuf := ss.inBuf[len(ss.remainder):]\n+\t\tvar n int\n+\t\tn, err = ss.c.Read(readBuf)\n+\t\tif err == nil {\n+\t\t\tss.remainder = ss.inBuf[:n+len(ss.remainder)]\n+\t\t\trest := ss.remainder\n+\t\t\tlineOk := false\n+\t\t\tfor !lineOk {\n+\t\t\t\tvar key int\n+\t\t\t\tkey, rest = bytesToKey(rest)\n+\t\t\t\tif key < 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif key == keyCtrlD {\n+\t\t\t\t\treturn \"\", os.EOF\n+\t\t\t\t}\n+\t\t\t\tline, lineOk = ss.handleKey(key)\n+\t\t\t}\n+\t\t\tif len(rest) > 0 {\n+\t\t\t\tn := copy(ss.inBuf[:], rest)\n+\t\t\t\tss.remainder = ss.inBuf[:n]\n+\t\t\t} else {\n+\t\t\t\tss.remainder = nil\n+\t\t\t}\n+\t\t\tss.c.Write(ss.outBuf)\n+\t\t\tss.outBuf = ss.outBuf[:0]\n+\t\t\tif lineOk {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif req, ok := err.(ChannelRequest); ok {\n+\t\t\tok := false\n+\t\t\tswitch req.Request {\n+\t\t\tcase \"pty-req\":\n+\t\t\t\tss.termWidth, ss.termHeight, ok = parsePtyRequest(req.Payload)\n+\t\t\t\tif !ok {\n+\t\t\t\t\tss.termWidth = 80\n+\t\t\t\t\tss.termHeight = 24\n+\t\t\t\t}\n+\t\t\tcase \"shell\":\n+\t\t\t\tok = true\n+\t\t\t\tif len(req.Payload) > 0 {\n+\t\t\t\t\t// We don't accept any commands, only the default shell.\n+\t\t\t\t\tok = false\n+\t\t\t\t}\n+\t\t\tcase \"env\":\n+\t\t\t\tok = true\n+\t\t\t}\n+\t\t\tif req.WantReply {\n+\t\t\t\tss.c.AckRequest(ok)\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "622cf7cfada59f2162394df72805de6097cb6027", "filename": "libgo/go/exp/ssh/server_shell_test.go", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"testing\"\n+\t\"os\"\n+)\n+\n+type MockChannel struct {\n+\ttoSend       []byte\n+\tbytesPerRead int\n+\treceived     []byte\n+}\n+\n+func (c *MockChannel) Accept() os.Error {\n+\treturn nil\n+}\n+\n+func (c *MockChannel) Reject(RejectionReason, string) os.Error {\n+\treturn nil\n+}\n+\n+func (c *MockChannel) Read(data []byte) (n int, err os.Error) {\n+\tn = len(data)\n+\tif n == 0 {\n+\t\treturn\n+\t}\n+\tif n > len(c.toSend) {\n+\t\tn = len(c.toSend)\n+\t}\n+\tif n == 0 {\n+\t\treturn 0, os.EOF\n+\t}\n+\tif c.bytesPerRead > 0 && n > c.bytesPerRead {\n+\t\tn = c.bytesPerRead\n+\t}\n+\tcopy(data, c.toSend[:n])\n+\tc.toSend = c.toSend[n:]\n+\treturn\n+}\n+\n+func (c *MockChannel) Write(data []byte) (n int, err os.Error) {\n+\tc.received = append(c.received, data...)\n+\treturn len(data), nil\n+}\n+\n+func (c *MockChannel) Close() os.Error {\n+\treturn nil\n+}\n+\n+func (c *MockChannel) AckRequest(ok bool) os.Error {\n+\treturn nil\n+}\n+\n+func (c *MockChannel) ChannelType() string {\n+\treturn \"\"\n+}\n+\n+func (c *MockChannel) ExtraData() []byte {\n+\treturn nil\n+}\n+\n+func TestClose(t *testing.T) {\n+\tc := &MockChannel{}\n+\tss := NewServerShell(c, \"> \")\n+\tline, err := ss.ReadLine()\n+\tif line != \"\" {\n+\t\tt.Errorf(\"Expected empty line but got: %s\", line)\n+\t}\n+\tif err != os.EOF {\n+\t\tt.Errorf(\"Error should have been EOF but got: %s\", err)\n+\t}\n+}\n+\n+var keyPressTests = []struct {\n+\tin   string\n+\tline string\n+\terr  os.Error\n+}{\n+\t{\n+\t\t\"\",\n+\t\t\"\",\n+\t\tos.EOF,\n+\t},\n+\t{\n+\t\t\"\\r\",\n+\t\t\"\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"foo\\r\",\n+\t\t\"foo\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"a\\x1b[Cb\\r\", // right\n+\t\t\"ab\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"a\\x1b[Db\\r\", // left\n+\t\t\"ba\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"a\\177b\\r\", // backspace\n+\t\t\"b\",\n+\t\tnil,\n+\t},\n+}\n+\n+func TestKeyPresses(t *testing.T) {\n+\tfor i, test := range keyPressTests {\n+\t\tfor j := 0; j < len(test.in); j++ {\n+\t\t\tc := &MockChannel{\n+\t\t\t\ttoSend:       []byte(test.in),\n+\t\t\t\tbytesPerRead: j,\n+\t\t\t}\n+\t\t\tss := NewServerShell(c, \"> \")\n+\t\t\tline, err := ss.ReadLine()\n+\t\t\tif line != test.line {\n+\t\t\t\tt.Errorf(\"Line resulting from test %d (%d bytes per read) was '%s', expected '%s'\", i, j, line, test.line)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif err != test.err {\n+\t\t\t\tt.Errorf(\"Error resulting from test %d (%d bytes per read) was '%v', expected '%v'\", i, j, err, test.err)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "5994004d86656ba854a8e8c010bd36575751a983", "filename": "libgo/go/exp/ssh/transport.go", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,369 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"bufio\"\n+\t\"crypto\"\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/hmac\"\n+\t\"crypto/subtle\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"net\"\n+\t\"os\"\n+\t\"sync\"\n+)\n+\n+const (\n+\tpaddingMultiple = 16 // TODO(dfc) does this need to be configurable?\n+)\n+\n+// filteredConn reduces the set of methods exposed when embeddeding\n+// a net.Conn inside ssh.transport.\n+// TODO(dfc) suggestions for a better name will be warmly received.\n+type filteredConn interface {\n+\t// Close closes the connection.\n+\tClose() os.Error\n+\n+\t// LocalAddr returns the local network address.\n+\tLocalAddr() net.Addr\n+\n+\t// RemoteAddr returns the remote network address.\n+\tRemoteAddr() net.Addr\n+}\n+\n+// Types implementing packetWriter provide the ability to send packets to\n+// an SSH peer.\n+type packetWriter interface {\n+\t// Encrypt and send a packet of data to the remote peer.\n+\twritePacket(packet []byte) os.Error\n+}\n+\n+// transport represents the SSH connection to the remote peer.\n+type transport struct {\n+\treader\n+\twriter\n+\n+\tfilteredConn\n+}\n+\n+// reader represents the incoming connection state.\n+type reader struct {\n+\tio.Reader\n+\tcommon\n+}\n+\n+// writer represnts the outgoing connection state.\n+type writer struct {\n+\t*sync.Mutex // protects writer.Writer from concurrent writes\n+\t*bufio.Writer\n+\tpaddingMultiple int\n+\trand            io.Reader\n+\tcommon\n+}\n+\n+// common represents the cipher state needed to process messages in a single\n+// direction.\n+type common struct {\n+\tseqNum uint32\n+\tmac    hash.Hash\n+\tcipher cipher.Stream\n+\n+\tcipherAlgo      string\n+\tmacAlgo         string\n+\tcompressionAlgo string\n+}\n+\n+// Read and decrypt a single packet from the remote peer.\n+func (r *reader) readOnePacket() ([]byte, os.Error) {\n+\tvar lengthBytes = make([]byte, 5)\n+\tvar macSize uint32\n+\n+\tif _, err := io.ReadFull(r, lengthBytes); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif r.cipher != nil {\n+\t\tr.cipher.XORKeyStream(lengthBytes, lengthBytes)\n+\t}\n+\n+\tif r.mac != nil {\n+\t\tr.mac.Reset()\n+\t\tseqNumBytes := []byte{\n+\t\t\tbyte(r.seqNum >> 24),\n+\t\t\tbyte(r.seqNum >> 16),\n+\t\t\tbyte(r.seqNum >> 8),\n+\t\t\tbyte(r.seqNum),\n+\t\t}\n+\t\tr.mac.Write(seqNumBytes)\n+\t\tr.mac.Write(lengthBytes)\n+\t\tmacSize = uint32(r.mac.Size())\n+\t}\n+\n+\tlength := uint32(lengthBytes[0])<<24 | uint32(lengthBytes[1])<<16 | uint32(lengthBytes[2])<<8 | uint32(lengthBytes[3])\n+\tpaddingLength := uint32(lengthBytes[4])\n+\n+\tif length <= paddingLength+1 {\n+\t\treturn nil, os.NewError(\"invalid packet length\")\n+\t}\n+\tif length > maxPacketSize {\n+\t\treturn nil, os.NewError(\"packet too large\")\n+\t}\n+\n+\tpacket := make([]byte, length-1+macSize)\n+\tif _, err := io.ReadFull(r, packet); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tmac := packet[length-1:]\n+\tif r.cipher != nil {\n+\t\tr.cipher.XORKeyStream(packet, packet[:length-1])\n+\t}\n+\n+\tif r.mac != nil {\n+\t\tr.mac.Write(packet[:length-1])\n+\t\tif subtle.ConstantTimeCompare(r.mac.Sum(), mac) != 1 {\n+\t\t\treturn nil, os.NewError(\"ssh: MAC failure\")\n+\t\t}\n+\t}\n+\n+\tr.seqNum++\n+\treturn packet[:length-paddingLength-1], nil\n+}\n+\n+// Read and decrypt next packet discarding debug and noop messages.\n+func (t *transport) readPacket() ([]byte, os.Error) {\n+\tfor {\n+\t\tpacket, err := t.readOnePacket()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif packet[0] != msgIgnore && packet[0] != msgDebug {\n+\t\t\treturn packet, nil\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+// Encrypt and send a packet of data to the remote peer.\n+func (w *writer) writePacket(packet []byte) os.Error {\n+\tw.Mutex.Lock()\n+\tdefer w.Mutex.Unlock()\n+\n+\tpaddingLength := paddingMultiple - (5+len(packet))%paddingMultiple\n+\tif paddingLength < 4 {\n+\t\tpaddingLength += paddingMultiple\n+\t}\n+\n+\tlength := len(packet) + 1 + paddingLength\n+\tlengthBytes := []byte{\n+\t\tbyte(length >> 24),\n+\t\tbyte(length >> 16),\n+\t\tbyte(length >> 8),\n+\t\tbyte(length),\n+\t\tbyte(paddingLength),\n+\t}\n+\tpadding := make([]byte, paddingLength)\n+\t_, err := io.ReadFull(w.rand, padding)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif w.mac != nil {\n+\t\tw.mac.Reset()\n+\t\tseqNumBytes := []byte{\n+\t\t\tbyte(w.seqNum >> 24),\n+\t\t\tbyte(w.seqNum >> 16),\n+\t\t\tbyte(w.seqNum >> 8),\n+\t\t\tbyte(w.seqNum),\n+\t\t}\n+\t\tw.mac.Write(seqNumBytes)\n+\t\tw.mac.Write(lengthBytes)\n+\t\tw.mac.Write(packet)\n+\t\tw.mac.Write(padding)\n+\t}\n+\n+\t// TODO(dfc) lengthBytes, packet and padding should be\n+\t// subslices of a single buffer\n+\tif w.cipher != nil {\n+\t\tw.cipher.XORKeyStream(lengthBytes, lengthBytes)\n+\t\tw.cipher.XORKeyStream(packet, packet)\n+\t\tw.cipher.XORKeyStream(padding, padding)\n+\t}\n+\n+\tif _, err := w.Write(lengthBytes); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := w.Write(packet); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := w.Write(padding); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif w.mac != nil {\n+\t\tif _, err := w.Write(w.mac.Sum()); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tif err := w.Flush(); err != nil {\n+\t\treturn err\n+\t}\n+\tw.seqNum++\n+\treturn err\n+}\n+\n+// Send a message to the remote peer\n+func (t *transport) sendMessage(typ uint8, msg interface{}) os.Error {\n+\tpacket := marshal(typ, msg)\n+\treturn t.writePacket(packet)\n+}\n+\n+func newTransport(conn net.Conn, rand io.Reader) *transport {\n+\treturn &transport{\n+\t\treader: reader{\n+\t\t\tReader: bufio.NewReader(conn),\n+\t\t},\n+\t\twriter: writer{\n+\t\t\tWriter: bufio.NewWriter(conn),\n+\t\t\trand:   rand,\n+\t\t\tMutex:  new(sync.Mutex),\n+\t\t},\n+\t\tfilteredConn: conn,\n+\t}\n+}\n+\n+type direction struct {\n+\tivTag     []byte\n+\tkeyTag    []byte\n+\tmacKeyTag []byte\n+}\n+\n+// TODO(dfc) can this be made a constant ?\n+var (\n+\tserverKeys = direction{[]byte{'B'}, []byte{'D'}, []byte{'F'}}\n+\tclientKeys = direction{[]byte{'A'}, []byte{'C'}, []byte{'E'}}\n+)\n+\n+// setupKeys sets the cipher and MAC keys from K, H and sessionId, as\n+// described in RFC 4253, section 6.4. direction should either be serverKeys\n+// (to setup server->client keys) or clientKeys (for client->server keys).\n+func (c *common) setupKeys(d direction, K, H, sessionId []byte, hashFunc crypto.Hash) os.Error {\n+\th := hashFunc.New()\n+\n+\tblockSize := 16\n+\tkeySize := 16\n+\tmacKeySize := 20\n+\n+\tiv := make([]byte, blockSize)\n+\tkey := make([]byte, keySize)\n+\tmacKey := make([]byte, macKeySize)\n+\tgenerateKeyMaterial(iv, d.ivTag, K, H, sessionId, h)\n+\tgenerateKeyMaterial(key, d.keyTag, K, H, sessionId, h)\n+\tgenerateKeyMaterial(macKey, d.macKeyTag, K, H, sessionId, h)\n+\n+\tc.mac = truncatingMAC{12, hmac.NewSHA1(macKey)}\n+\taes, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tc.cipher = cipher.NewCTR(aes, iv)\n+\treturn nil\n+}\n+\n+// generateKeyMaterial fills out with key material generated from tag, K, H\n+// and sessionId, as specified in RFC 4253, section 7.2.\n+func generateKeyMaterial(out, tag []byte, K, H, sessionId []byte, h hash.Hash) {\n+\tvar digestsSoFar []byte\n+\n+\tfor len(out) > 0 {\n+\t\th.Reset()\n+\t\th.Write(K)\n+\t\th.Write(H)\n+\n+\t\tif len(digestsSoFar) == 0 {\n+\t\t\th.Write(tag)\n+\t\t\th.Write(sessionId)\n+\t\t} else {\n+\t\t\th.Write(digestsSoFar)\n+\t\t}\n+\n+\t\tdigest := h.Sum()\n+\t\tn := copy(out, digest)\n+\t\tout = out[n:]\n+\t\tif len(out) > 0 {\n+\t\t\tdigestsSoFar = append(digestsSoFar, digest...)\n+\t\t}\n+\t}\n+}\n+\n+// truncatingMAC wraps around a hash.Hash and truncates the output digest to\n+// a given size.\n+type truncatingMAC struct {\n+\tlength int\n+\thmac   hash.Hash\n+}\n+\n+func (t truncatingMAC) Write(data []byte) (int, os.Error) {\n+\treturn t.hmac.Write(data)\n+}\n+\n+func (t truncatingMAC) Sum() []byte {\n+\tdigest := t.hmac.Sum()\n+\treturn digest[:t.length]\n+}\n+\n+func (t truncatingMAC) Reset() {\n+\tt.hmac.Reset()\n+}\n+\n+func (t truncatingMAC) Size() int {\n+\treturn t.length\n+}\n+\n+// maxVersionStringBytes is the maximum number of bytes that we'll accept as a\n+// version string. In the event that the client is talking a different protocol\n+// we need to set a limit otherwise we will keep using more and more memory\n+// while searching for the end of the version handshake.\n+const maxVersionStringBytes = 1024\n+\n+// Read version string as specified by RFC 4253, section 4.2.\n+func readVersion(r io.Reader) (versionString []byte, ok bool) {\n+\tversionString = make([]byte, 0, 64)\n+\tseenCR := false\n+\n+\tvar buf [1]byte\n+forEachByte:\n+\tfor len(versionString) < maxVersionStringBytes {\n+\t\t_, err := io.ReadFull(r, buf[:])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tb := buf[0]\n+\n+\t\tif !seenCR {\n+\t\t\tif b == '\\r' {\n+\t\t\t\tseenCR = true\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif b == '\\n' {\n+\t\t\t\tok = true\n+\t\t\t\tbreak forEachByte\n+\t\t\t} else {\n+\t\t\t\tseenCR = false\n+\t\t\t}\n+\t\t}\n+\t\tversionString = append(versionString, b)\n+\t}\n+\n+\tif ok {\n+\t\t// We need to remove the CR from versionString\n+\t\tversionString = versionString[:len(versionString)-1]\n+\t}\n+\n+\treturn\n+}"}, {"sha": "9a610a7803c30b834718967b42a6b08c6dfce326", "filename": "libgo/go/exp/ssh/transport_test.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+func TestReadVersion(t *testing.T) {\n+\tbuf := []byte(serverVersion)\n+\tresult, ok := readVersion(bufio.NewReader(bytes.NewBuffer(buf)))\n+\tif !ok {\n+\t\tt.Error(\"readVersion didn't read version correctly\")\n+\t}\n+\tif !bytes.Equal(buf[:len(buf)-2], result) {\n+\t\tt.Error(\"version read did not match expected\")\n+\t}\n+}\n+\n+func TestReadVersionTooLong(t *testing.T) {\n+\tbuf := make([]byte, maxVersionStringBytes+1)\n+\tif _, ok := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); ok {\n+\t\tt.Errorf(\"readVersion consumed %d bytes without error\", len(buf))\n+\t}\n+}\n+\n+func TestReadVersionWithoutCRLF(t *testing.T) {\n+\tbuf := []byte(serverVersion)\n+\tbuf = buf[:len(buf)-1]\n+\tif _, ok := readVersion(bufio.NewReader(bytes.NewBuffer(buf))); ok {\n+\t\tt.Error(\"readVersion did not notice \\\\n was missing\")\n+\t}\n+}"}, {"sha": "6a36c7b7181104a5feccc8f1a5f9db2e9dd20530", "filename": "libgo/go/exp/template/html/attr.go", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fattr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fattr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fattr.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,175 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"strings\"\n+)\n+\n+// attrTypeMap[n] describes the value of the given attribute.\n+// If an attribute affects (or can mask) the encoding or interpretation of\n+// other content, or affects the contents, idempotency, or credentials of a\n+// network message, then the value in this map is contentTypeUnsafe.\n+// This map is derived from HTML5, specifically\n+// http://www.w3.org/TR/html5/Overview.html#attributes-1\n+// as well as \"%URI\"-typed attributes from\n+// http://www.w3.org/TR/html4/index/attributes.html\n+var attrTypeMap = map[string]contentType{\n+\t\"accept\":          contentTypePlain,\n+\t\"accept-charset\":  contentTypeUnsafe,\n+\t\"action\":          contentTypeURL,\n+\t\"alt\":             contentTypePlain,\n+\t\"archive\":         contentTypeURL,\n+\t\"async\":           contentTypeUnsafe,\n+\t\"autocomplete\":    contentTypePlain,\n+\t\"autofocus\":       contentTypePlain,\n+\t\"autoplay\":        contentTypePlain,\n+\t\"background\":      contentTypeURL,\n+\t\"border\":          contentTypePlain,\n+\t\"checked\":         contentTypePlain,\n+\t\"cite\":            contentTypeURL,\n+\t\"challenge\":       contentTypeUnsafe,\n+\t\"charset\":         contentTypeUnsafe,\n+\t\"class\":           contentTypePlain,\n+\t\"classid\":         contentTypeURL,\n+\t\"codebase\":        contentTypeURL,\n+\t\"cols\":            contentTypePlain,\n+\t\"colspan\":         contentTypePlain,\n+\t\"content\":         contentTypeUnsafe,\n+\t\"contenteditable\": contentTypePlain,\n+\t\"contextmenu\":     contentTypePlain,\n+\t\"controls\":        contentTypePlain,\n+\t\"coords\":          contentTypePlain,\n+\t\"crossorigin\":     contentTypeUnsafe,\n+\t\"data\":            contentTypeURL,\n+\t\"datetime\":        contentTypePlain,\n+\t\"default\":         contentTypePlain,\n+\t\"defer\":           contentTypeUnsafe,\n+\t\"dir\":             contentTypePlain,\n+\t\"dirname\":         contentTypePlain,\n+\t\"disabled\":        contentTypePlain,\n+\t\"draggable\":       contentTypePlain,\n+\t\"dropzone\":        contentTypePlain,\n+\t\"enctype\":         contentTypeUnsafe,\n+\t\"for\":             contentTypePlain,\n+\t\"form\":            contentTypeUnsafe,\n+\t\"formaction\":      contentTypeURL,\n+\t\"formenctype\":     contentTypeUnsafe,\n+\t\"formmethod\":      contentTypeUnsafe,\n+\t\"formnovalidate\":  contentTypeUnsafe,\n+\t\"formtarget\":      contentTypePlain,\n+\t\"headers\":         contentTypePlain,\n+\t\"height\":          contentTypePlain,\n+\t\"hidden\":          contentTypePlain,\n+\t\"high\":            contentTypePlain,\n+\t\"href\":            contentTypeURL,\n+\t\"hreflang\":        contentTypePlain,\n+\t\"http-equiv\":      contentTypeUnsafe,\n+\t\"icon\":            contentTypeURL,\n+\t\"id\":              contentTypePlain,\n+\t\"ismap\":           contentTypePlain,\n+\t\"keytype\":         contentTypeUnsafe,\n+\t\"kind\":            contentTypePlain,\n+\t\"label\":           contentTypePlain,\n+\t\"lang\":            contentTypePlain,\n+\t\"language\":        contentTypeUnsafe,\n+\t\"list\":            contentTypePlain,\n+\t\"longdesc\":        contentTypeURL,\n+\t\"loop\":            contentTypePlain,\n+\t\"low\":             contentTypePlain,\n+\t\"manifest\":        contentTypeURL,\n+\t\"max\":             contentTypePlain,\n+\t\"maxlength\":       contentTypePlain,\n+\t\"media\":           contentTypePlain,\n+\t\"mediagroup\":      contentTypePlain,\n+\t\"method\":          contentTypeUnsafe,\n+\t\"min\":             contentTypePlain,\n+\t\"multiple\":        contentTypePlain,\n+\t\"name\":            contentTypePlain,\n+\t\"novalidate\":      contentTypeUnsafe,\n+\t// Skip handler names from\n+\t// http://www.w3.org/TR/html5/Overview.html#event-handlers-on-elements-document-objects-and-window-objects\n+\t// since we have special handling in attrType.\n+\t\"open\":        contentTypePlain,\n+\t\"optimum\":     contentTypePlain,\n+\t\"pattern\":     contentTypeUnsafe,\n+\t\"placeholder\": contentTypePlain,\n+\t\"poster\":      contentTypeURL,\n+\t\"profile\":     contentTypeURL,\n+\t\"preload\":     contentTypePlain,\n+\t\"pubdate\":     contentTypePlain,\n+\t\"radiogroup\":  contentTypePlain,\n+\t\"readonly\":    contentTypePlain,\n+\t\"rel\":         contentTypeUnsafe,\n+\t\"required\":    contentTypePlain,\n+\t\"reversed\":    contentTypePlain,\n+\t\"rows\":        contentTypePlain,\n+\t\"rowspan\":     contentTypePlain,\n+\t\"sandbox\":     contentTypeUnsafe,\n+\t\"spellcheck\":  contentTypePlain,\n+\t\"scope\":       contentTypePlain,\n+\t\"scoped\":      contentTypePlain,\n+\t\"seamless\":    contentTypePlain,\n+\t\"selected\":    contentTypePlain,\n+\t\"shape\":       contentTypePlain,\n+\t\"size\":        contentTypePlain,\n+\t\"sizes\":       contentTypePlain,\n+\t\"span\":        contentTypePlain,\n+\t\"src\":         contentTypeURL,\n+\t\"srcdoc\":      contentTypeHTML,\n+\t\"srclang\":     contentTypePlain,\n+\t\"start\":       contentTypePlain,\n+\t\"step\":        contentTypePlain,\n+\t\"style\":       contentTypeCSS,\n+\t\"tabindex\":    contentTypePlain,\n+\t\"target\":      contentTypePlain,\n+\t\"title\":       contentTypePlain,\n+\t\"type\":        contentTypeUnsafe,\n+\t\"usemap\":      contentTypeURL,\n+\t\"value\":       contentTypeUnsafe,\n+\t\"width\":       contentTypePlain,\n+\t\"wrap\":        contentTypePlain,\n+\t\"xmlns\":       contentTypeURL,\n+}\n+\n+// attrType returns a conservative (upper-bound on authority) guess at the\n+// type of the named attribute.\n+func attrType(name string) contentType {\n+\tname = strings.ToLower(name)\n+\tif strings.HasPrefix(name, \"data-\") {\n+\t\t// Strip data- so that custom attribute heuristics below are\n+\t\t// widely applied.\n+\t\t// Treat data-action as URL below.\n+\t\tname = name[5:]\n+\t} else if colon := strings.IndexRune(name, ':'); colon != -1 {\n+\t\tif name[:colon] == \"xmlns\" {\n+\t\t\treturn contentTypeURL\n+\t\t}\n+\t\t// Treat svg:href and xlink:href as href below.\n+\t\tname = name[colon+1:]\n+\t}\n+\tif t, ok := attrTypeMap[name]; ok {\n+\t\treturn t\n+\t}\n+\t// Treat partial event handler names as script.\n+\tif strings.HasPrefix(name, \"on\") {\n+\t\treturn contentTypeJS\n+\t}\n+\n+\t// Heuristics to prevent \"javascript:...\" injection in custom\n+\t// data attributes and custom attributes like g:tweetUrl.\n+\t// http://www.w3.org/TR/html5/elements.html#embedding-custom-non-visible-data-with-the-data-attributes:\n+\t// \"Custom data attributes are intended to store custom data\n+\t//  private to the page or application, for which there are no\n+\t//  more appropriate attributes or elements.\"\n+\t// Developers seem to store URL content in data URLs that start\n+\t// or end with \"URI\" or \"URL\".\n+\tif strings.Contains(name, \"src\") ||\n+\t\tstrings.Contains(name, \"uri\") ||\n+\t\tstrings.Contains(name, \"url\") {\n+\t\treturn contentTypeURL\n+\t}\n+\treturn contentTypePlain\n+}"}, {"sha": "803a64de12fdc6e55927beffda13cdfad64f4749", "filename": "libgo/go/exp/template/html/clone.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fclone.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fclone.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fclone.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"template/parse\"\n+)\n+\n+// clone clones a template Node.\n+func clone(n parse.Node) parse.Node {\n+\tswitch t := n.(type) {\n+\tcase *parse.ActionNode:\n+\t\treturn cloneAction(t)\n+\tcase *parse.IfNode:\n+\t\tb := new(parse.IfNode)\n+\t\tcopyBranch(&b.BranchNode, &t.BranchNode)\n+\t\treturn b\n+\tcase *parse.ListNode:\n+\t\treturn cloneList(t)\n+\tcase *parse.RangeNode:\n+\t\tb := new(parse.RangeNode)\n+\t\tcopyBranch(&b.BranchNode, &t.BranchNode)\n+\t\treturn b\n+\tcase *parse.TemplateNode:\n+\t\treturn cloneTemplate(t)\n+\tcase *parse.TextNode:\n+\t\treturn cloneText(t)\n+\tcase *parse.WithNode:\n+\t\tb := new(parse.WithNode)\n+\t\tcopyBranch(&b.BranchNode, &t.BranchNode)\n+\t\treturn b\n+\t}\n+\tpanic(\"cloning \" + n.String() + \" is unimplemented\")\n+}\n+\n+// cloneAction returns a deep clone of n.\n+func cloneAction(n *parse.ActionNode) *parse.ActionNode {\n+\t// We use keyless fields because they won't compile if a field is added.\n+\treturn &parse.ActionNode{n.NodeType, n.Line, clonePipe(n.Pipe)}\n+}\n+\n+// cloneList returns a deep clone of n.\n+func cloneList(n *parse.ListNode) *parse.ListNode {\n+\tif n == nil {\n+\t\treturn nil\n+\t}\n+\t// We use keyless fields because they won't compile if a field is added.\n+\tc := parse.ListNode{n.NodeType, make([]parse.Node, len(n.Nodes))}\n+\tfor i, child := range n.Nodes {\n+\t\tc.Nodes[i] = clone(child)\n+\t}\n+\treturn &c\n+}\n+\n+// clonePipe returns a shallow clone of n.\n+// The escaper does not modify pipe descendants in place so there's no need to\n+// clone deeply.\n+func clonePipe(n *parse.PipeNode) *parse.PipeNode {\n+\tif n == nil {\n+\t\treturn nil\n+\t}\n+\t// We use keyless fields because they won't compile if a field is added.\n+\treturn &parse.PipeNode{n.NodeType, n.Line, n.Decl, n.Cmds}\n+}\n+\n+// cloneTemplate returns a deep clone of n.\n+func cloneTemplate(n *parse.TemplateNode) *parse.TemplateNode {\n+\t// We use keyless fields because they won't compile if a field is added.\n+\treturn &parse.TemplateNode{n.NodeType, n.Line, n.Name, clonePipe(n.Pipe)}\n+}\n+\n+// cloneText clones the given node sharing its []byte.\n+func cloneText(n *parse.TextNode) *parse.TextNode {\n+\t// We use keyless fields because they won't compile if a field is added.\n+\treturn &parse.TextNode{n.NodeType, n.Text}\n+}\n+\n+// copyBranch clones src into dst.\n+func copyBranch(dst, src *parse.BranchNode) {\n+\t// We use keyless fields because they won't compile if a field is added.\n+\t*dst = parse.BranchNode{\n+\t\tsrc.NodeType,\n+\t\tsrc.Line,\n+\t\tclonePipe(src.Pipe),\n+\t\tcloneList(src.List),\n+\t\tcloneList(src.ElseList),\n+\t}\n+}"}, {"sha": "d91542529b925e6f62f9dcf7e61916130f4e3770", "filename": "libgo/go/exp/template/html/clone_test.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fclone_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fclone_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fclone_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"bytes\"\n+\t\"template\"\n+\t\"template/parse\"\n+\t\"testing\"\n+)\n+\n+func TestClone(t *testing.T) {\n+\ttests := []struct {\n+\t\tinput, want, wantClone string\n+\t}{\n+\t\t{\n+\t\t\t`Hello, {{if true}}{{\"<World>\"}}{{end}}!`,\n+\t\t\t\"Hello, <World>!\",\n+\t\t\t\"Hello, &lt;World&gt;!\",\n+\t\t},\n+\t\t{\n+\t\t\t`Hello, {{if false}}{{.X}}{{else}}{{\"<World>\"}}{{end}}!`,\n+\t\t\t\"Hello, <World>!\",\n+\t\t\t\"Hello, &lt;World&gt;!\",\n+\t\t},\n+\t\t{\n+\t\t\t`Hello, {{with \"<World>\"}}{{.}}{{end}}!`,\n+\t\t\t\"Hello, <World>!\",\n+\t\t\t\"Hello, &lt;World&gt;!\",\n+\t\t},\n+\t\t{\n+\t\t\t`{{range .}}<p>{{.}}</p>{{end}}`,\n+\t\t\t\"<p>foo</p><p><bar></p><p>baz</p>\",\n+\t\t\t\"<p>foo</p><p>&lt;bar&gt;</p><p>baz</p>\",\n+\t\t},\n+\t\t{\n+\t\t\t`Hello, {{\"<World>\" | html}}!`,\n+\t\t\t\"Hello, &lt;World&gt;!\",\n+\t\t\t\"Hello, &lt;World&gt;!\",\n+\t\t},\n+\t\t{\n+\t\t\t`Hello{{if 1}}, World{{else}}{{template \"d\"}}{{end}}!`,\n+\t\t\t\"Hello, World!\",\n+\t\t\t\"Hello, World!\",\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\ts := template.Must(template.New(\"s\").Parse(test.input))\n+\t\td := template.New(\"d\")\n+\t\td.Tree = &parse.Tree{Name: d.Name(), Root: cloneList(s.Root)}\n+\n+\t\tif want, got := s.Root.String(), d.Root.String(); want != got {\n+\t\t\tt.Errorf(\"want %q, got %q\", want, got)\n+\t\t}\n+\n+\t\td, err := Escape(d)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%q: failed to escape: %s\", test.input, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif want, got := \"s\", s.Name(); want != got {\n+\t\t\tt.Errorf(\"want %q, got %q\", want, got)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif want, got := \"d\", d.Name(); want != got {\n+\t\t\tt.Errorf(\"want %q, got %q\", want, got)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tdata := []string{\"foo\", \"<bar>\", \"baz\"}\n+\n+\t\t// Make sure escaping d did not affect s.\n+\t\tvar b bytes.Buffer\n+\t\ts.Execute(&b, data)\n+\t\tif got := b.String(); got != test.want {\n+\t\t\tt.Errorf(\"%q: want %q, got %q\", test.input, test.want, got)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tb.Reset()\n+\t\td.Execute(&b, data)\n+\t\tif got := b.String(); got != test.wantClone {\n+\t\t\tt.Errorf(\"%q: want %q, got %q\", test.input, test.wantClone, got)\n+\t\t}\n+\t}\n+}"}, {"sha": "dcaff8c15c638adc08ba8c29f2aae6e551a4d645", "filename": "libgo/go/exp/template/html/content.go", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontent.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+// Strings of content from a trusted source.\n+type (\n+\t// CSS encapsulates known safe content that matches any of:\n+\t// (1) The CSS3 stylesheet production, such as `p { color: purple }`.\n+\t// (2) The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n+\t// (3) CSS3 declaration productions, such as `color: red; margin: 2px`.\n+\t// (4) The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\n+\t// See http://www.w3.org/TR/css3-syntax/#style\n+\tCSS string\n+\n+\t// HTML encapsulates a known safe HTML document fragment.\n+\t// It should not be used for HTML from a third-party, or HTML with\n+\t// unclosed tags or comments. The outputs of a sound HTML sanitizer\n+\t// and a template escaped by this package are fine for use with HTML.\n+\tHTML string\n+\n+\t// HTMLAttr encapsulates an HTML attribute from a trusted source,\n+\t// for example: ` dir=\"ltr\"`.\n+\tHTMLAttr string\n+\n+\t// JS encapsulates a known safe EcmaScript5 Expression, or example,\n+\t// `(x + y * z())`. \n+\t// Template authors are responsible for ensuring that typed expressions\n+\t// do not break the intended precedence and that there is no\n+\t// statement/expression ambiguity as when passing an expression like\n+\t// \"{ foo: bar() }\\n['foo']()\", which is both a valid Expression and a\n+\t// valid Program with a very different meaning.\n+\tJS string\n+\n+\t// JSStr encapsulates a sequence of characters meant to be embedded\n+\t// between quotes in a JavaScript expression.\n+\t// The string must match a series of StringCharacters:\n+\t// StringCharacter :: SourceCharacter but not `\\` or LineTerminator\n+\t//                  | EscapeSequence\n+\t// Note that LineContinuations are not allowed.\n+\t// JSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not.\n+\tJSStr string\n+\n+\t// URL encapsulates a known safe URL as defined in RFC 3896.\n+\t// A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()`\n+\t// from a trusted source should go in the page, but by default dynamic\n+\t// `javascript:` URLs are filtered out since they are a frequently\n+\t// exploited injection vector.\n+\tURL string\n+)\n+\n+type contentType uint8\n+\n+const (\n+\tcontentTypePlain contentType = iota\n+\tcontentTypeCSS\n+\tcontentTypeHTML\n+\tcontentTypeHTMLAttr\n+\tcontentTypeJS\n+\tcontentTypeJSStr\n+\tcontentTypeURL\n+\t// contentTypeUnsafe is used in attr.go for values that affect how\n+\t// embedded content and network messages are formed, vetted,\n+\t// or interpreted; or which credentials network messages carry.\n+\tcontentTypeUnsafe\n+)\n+\n+// stringify converts its arguments to a string and the type of the content.\n+func stringify(args ...interface{}) (string, contentType) {\n+\tif len(args) == 1 {\n+\t\tswitch s := args[0].(type) {\n+\t\tcase string:\n+\t\t\treturn s, contentTypePlain\n+\t\tcase CSS:\n+\t\t\treturn string(s), contentTypeCSS\n+\t\tcase HTML:\n+\t\t\treturn string(s), contentTypeHTML\n+\t\tcase HTMLAttr:\n+\t\t\treturn string(s), contentTypeHTMLAttr\n+\t\tcase JS:\n+\t\t\treturn string(s), contentTypeJS\n+\t\tcase JSStr:\n+\t\t\treturn string(s), contentTypeJSStr\n+\t\tcase URL:\n+\t\t\treturn string(s), contentTypeURL\n+\t\t}\n+\t}\n+\treturn fmt.Sprint(args...), contentTypePlain\n+}"}, {"sha": "033dee1747c992d0807c17b8078d83762bea545c", "filename": "libgo/go/exp/template/html/content_test.go", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontent_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontent_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontent_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,222 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"bytes\"\n+\t\"strings\"\n+\t\"template\"\n+\t\"testing\"\n+)\n+\n+func TestTypedContent(t *testing.T) {\n+\tdata := []interface{}{\n+\t\t`<b> \"foo%\" O'Reilly &bar;`,\n+\t\tCSS(`a[href =~ \"//example.com\"]#foo`),\n+\t\tHTML(`Hello, <b>World</b> &amp;tc!`),\n+\t\tHTMLAttr(` dir=\"ltr\"`),\n+\t\tJS(`c && alert(\"Hello, World!\");`),\n+\t\tJSStr(`Hello, World & O'Reilly\\x21`),\n+\t\tURL(`greeting=H%69&addressee=(World)`),\n+\t}\n+\n+\t// For each content sensitive escaper, see how it does on\n+\t// each of the typed strings above.\n+\ttests := []struct {\n+\t\t// A template containing a single {{.}}.\n+\t\tinput string\n+\t\twant  []string\n+\t}{\n+\t\t{\n+\t\t\t`<style>{{.}} { color: blue }</style>`,\n+\t\t\t[]string{\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t// Allowed but not escaped.\n+\t\t\t\t`a[href =~ \"//example.com\"]#foo`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<div style=\"{{.}}\">`,\n+\t\t\t[]string{\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t// Allowed and HTML escaped.\n+\t\t\t\t`a[href =~ &#34;//example.com&#34;]#foo`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`{{.}}`,\n+\t\t\t[]string{\n+\t\t\t\t`&lt;b&gt; &#34;foo%&#34; O&#39;Reilly &amp;bar;`,\n+\t\t\t\t`a[href =~ &#34;//example.com&#34;]#foo`,\n+\t\t\t\t// Not escaped.\n+\t\t\t\t`Hello, <b>World</b> &amp;tc!`,\n+\t\t\t\t` dir=&#34;ltr&#34;`,\n+\t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n+\t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n+\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<a{{.}}>`,\n+\t\t\t[]string{\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t// Allowed and HTML escaped.\n+\t\t\t\t` dir=\"ltr\"`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t\t`ZgotmplZ`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<a title={{.}}>`,\n+\t\t\t[]string{\n+\t\t\t\t`&lt;b&gt;&#32;&#34;foo%&#34;&#32;O&#39;Reilly&#32;&amp;bar;`,\n+\t\t\t\t`a[href&#32;&#61;~&#32;&#34;//example.com&#34;]#foo`,\n+\t\t\t\t// Tags stripped, spaces escaped, entity not re-escaped.\n+\t\t\t\t`Hello,&#32;World&#32;&amp;tc!`,\n+\t\t\t\t`&#32;dir&#61;&#34;ltr&#34;`,\n+\t\t\t\t`c&#32;&amp;&amp;&#32;alert(&#34;Hello,&#32;World!&#34;);`,\n+\t\t\t\t`Hello,&#32;World&#32;&amp;&#32;O&#39;Reilly\\x21`,\n+\t\t\t\t`greeting&#61;H%69&amp;addressee&#61;(World)`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<a title='{{.}}'>`,\n+\t\t\t[]string{\n+\t\t\t\t`&lt;b&gt; &#34;foo%&#34; O&#39;Reilly &amp;bar;`,\n+\t\t\t\t`a[href =~ &#34;//example.com&#34;]#foo`,\n+\t\t\t\t// Tags stripped, entity not re-escaped.\n+\t\t\t\t`Hello, World &amp;tc!`,\n+\t\t\t\t` dir=&#34;ltr&#34;`,\n+\t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n+\t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n+\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<textarea>{{.}}</textarea>`,\n+\t\t\t[]string{\n+\t\t\t\t`&lt;b&gt; &#34;foo%&#34; O&#39;Reilly &amp;bar;`,\n+\t\t\t\t`a[href =~ &#34;//example.com&#34;]#foo`,\n+\t\t\t\t// Angle brackets escaped to prevent injection of close tags, entity not re-escaped.\n+\t\t\t\t`Hello, &lt;b&gt;World&lt;/b&gt; &amp;tc!`,\n+\t\t\t\t` dir=&#34;ltr&#34;`,\n+\t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n+\t\t\t\t`Hello, World &amp; O&#39;Reilly\\x21`,\n+\t\t\t\t`greeting=H%69&amp;addressee=(World)`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<script>alert({{.}})</script>`,\n+\t\t\t[]string{\n+\t\t\t\t`\"\\u003cb\\u003e \\\"foo%\\\" O'Reilly &bar;\"`,\n+\t\t\t\t`\"a[href =~ \\\"//example.com\\\"]#foo\"`,\n+\t\t\t\t`\"Hello, \\u003cb\\u003eWorld\\u003c/b\\u003e &amp;tc!\"`,\n+\t\t\t\t`\" dir=\\\"ltr\\\"\"`,\n+\t\t\t\t// Not escaped.\n+\t\t\t\t`c && alert(\"Hello, World!\");`,\n+\t\t\t\t// Escape sequence not over-escaped.\n+\t\t\t\t`\"Hello, World & O'Reilly\\x21\"`,\n+\t\t\t\t`\"greeting=H%69&addressee=(World)\"`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<button onclick=\"alert({{.}})\">`,\n+\t\t\t[]string{\n+\t\t\t\t`&#34;\\u003cb\\u003e \\&#34;foo%\\&#34; O&#39;Reilly &amp;bar;&#34;`,\n+\t\t\t\t`&#34;a[href =~ \\&#34;//example.com\\&#34;]#foo&#34;`,\n+\t\t\t\t`&#34;Hello, \\u003cb\\u003eWorld\\u003c/b\\u003e &amp;amp;tc!&#34;`,\n+\t\t\t\t`&#34; dir=\\&#34;ltr\\&#34;&#34;`,\n+\t\t\t\t// Not JS escaped but HTML escaped.\n+\t\t\t\t`c &amp;&amp; alert(&#34;Hello, World!&#34;);`,\n+\t\t\t\t// Escape sequence not over-escaped.\n+\t\t\t\t`&#34;Hello, World &amp; O&#39;Reilly\\x21&#34;`,\n+\t\t\t\t`&#34;greeting=H%69&amp;addressee=(World)&#34;`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<script>alert(\"{{.}}\")</script>`,\n+\t\t\t[]string{\n+\t\t\t\t`\\x3cb\\x3e \\x22foo%\\x22 O\\x27Reilly \\x26bar;`,\n+\t\t\t\t`a[href =~ \\x22\\/\\/example.com\\x22]#foo`,\n+\t\t\t\t`Hello, \\x3cb\\x3eWorld\\x3c\\/b\\x3e \\x26amp;tc!`,\n+\t\t\t\t` dir=\\x22ltr\\x22`,\n+\t\t\t\t`c \\x26\\x26 alert(\\x22Hello, World!\\x22);`,\n+\t\t\t\t// Escape sequence not over-escaped.\n+\t\t\t\t`Hello, World \\x26 O\\x27Reilly\\x21`,\n+\t\t\t\t`greeting=H%69\\x26addressee=(World)`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<button onclick='alert(\"{{.}}\")'>`,\n+\t\t\t[]string{\n+\t\t\t\t`\\x3cb\\x3e \\x22foo%\\x22 O\\x27Reilly \\x26bar;`,\n+\t\t\t\t`a[href =~ \\x22\\/\\/example.com\\x22]#foo`,\n+\t\t\t\t`Hello, \\x3cb\\x3eWorld\\x3c\\/b\\x3e \\x26amp;tc!`,\n+\t\t\t\t` dir=\\x22ltr\\x22`,\n+\t\t\t\t`c \\x26\\x26 alert(\\x22Hello, World!\\x22);`,\n+\t\t\t\t// Escape sequence not over-escaped.\n+\t\t\t\t`Hello, World \\x26 O\\x27Reilly\\x21`,\n+\t\t\t\t`greeting=H%69\\x26addressee=(World)`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<a href=\"?q={{.}}\">`,\n+\t\t\t[]string{\n+\t\t\t\t`%3cb%3e%20%22foo%25%22%20O%27Reilly%20%26bar%3b`,\n+\t\t\t\t`a%5bhref%20%3d~%20%22%2f%2fexample.com%22%5d%23foo`,\n+\t\t\t\t`Hello%2c%20%3cb%3eWorld%3c%2fb%3e%20%26amp%3btc%21`,\n+\t\t\t\t`%20dir%3d%22ltr%22`,\n+\t\t\t\t`c%20%26%26%20alert%28%22Hello%2c%20World%21%22%29%3b`,\n+\t\t\t\t`Hello%2c%20World%20%26%20O%27Reilly%5cx21`,\n+\t\t\t\t// Quotes and parens are escaped but %69 is not over-escaped. HTML escaping is done.\n+\t\t\t\t`greeting=H%69&amp;addressee=%28World%29`,\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\t`<style>body { background: url('?img={{.}}') }</style>`,\n+\t\t\t[]string{\n+\t\t\t\t`%3cb%3e%20%22foo%25%22%20O%27Reilly%20%26bar%3b`,\n+\t\t\t\t`a%5bhref%20%3d~%20%22%2f%2fexample.com%22%5d%23foo`,\n+\t\t\t\t`Hello%2c%20%3cb%3eWorld%3c%2fb%3e%20%26amp%3btc%21`,\n+\t\t\t\t`%20dir%3d%22ltr%22`,\n+\t\t\t\t`c%20%26%26%20alert%28%22Hello%2c%20World%21%22%29%3b`,\n+\t\t\t\t`Hello%2c%20World%20%26%20O%27Reilly%5cx21`,\n+\t\t\t\t// Quotes and parens are escaped but %69 is not over-escaped. HTML escaping is not done.\n+\t\t\t\t`greeting=H%69&addressee=%28World%29`,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tfor _, test := range tests {\n+\t\ttmpl := template.Must(Escape(template.Must(template.New(\"x\").Parse(test.input))))\n+\t\tpre := strings.Index(test.input, \"{{.}}\")\n+\t\tpost := len(test.input) - (pre + 5)\n+\t\tvar b bytes.Buffer\n+\t\tfor i, x := range data {\n+\t\t\tb.Reset()\n+\t\t\tif err := tmpl.Execute(&b, x); err != nil {\n+\t\t\t\tt.Errorf(\"%q with %v: %s\", test.input, x, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif want, got := test.want[i], b.String()[pre:b.Len()-post]; want != got {\n+\t\t\t\tt.Errorf(\"%q with %v:\\nwant\\n\\t%q,\\ngot\\n\\t%q\\n\", test.input, x, want, got)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "c44df4debc1023e05e8e1b38f7253eb6dcdd7d53", "filename": "libgo/go/exp/template/html/context.go", "status": "modified", "additions": 263, "deletions": 22, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcontext.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -16,56 +16,176 @@ import (\n // http://www.w3.org/TR/html5/the-end.html#parsing-html-fragments\n // where the context element is null.\n type context struct {\n-\tstate state\n-\tdelim delim\n+\tstate   state\n+\tdelim   delim\n+\turlPart urlPart\n+\tjsCtx   jsCtx\n+\tattr    attr\n+\telement element\n+\terr     *Error\n }\n \n func (c context) String() string {\n-\treturn fmt.Sprintf(\"context{state: %s, delim: %s\", c.state, c.delim)\n+\treturn fmt.Sprintf(\"{%v %v %v %v %v %v %v}\", c.state, c.delim, c.urlPart, c.jsCtx, c.attr, c.element, c.err)\n }\n \n-// eq is true if the two contexts are identical field-wise.\n+// eq returns whether two contexts are equal.\n func (c context) eq(d context) bool {\n-\treturn c.state == d.state && c.delim == d.delim\n+\treturn c.state == d.state &&\n+\t\tc.delim == d.delim &&\n+\t\tc.urlPart == d.urlPart &&\n+\t\tc.jsCtx == d.jsCtx &&\n+\t\tc.attr == d.attr &&\n+\t\tc.element == d.element &&\n+\t\tc.err == d.err\n+}\n+\n+// mangle produces an identifier that includes a suffix that distinguishes it\n+// from template names mangled with different contexts.\n+func (c context) mangle(templateName string) string {\n+\t// The mangled name for the default context is the input templateName.\n+\tif c.state == stateText {\n+\t\treturn templateName\n+\t}\n+\ts := templateName + \"$htmltemplate_\" + c.state.String()\n+\tif c.delim != 0 {\n+\t\ts += \"_\" + c.delim.String()\n+\t}\n+\tif c.urlPart != 0 {\n+\t\ts += \"_\" + c.urlPart.String()\n+\t}\n+\tif c.jsCtx != 0 {\n+\t\ts += \"_\" + c.jsCtx.String()\n+\t}\n+\tif c.attr != 0 {\n+\t\ts += \"_\" + c.attr.String()\n+\t}\n+\tif c.element != 0 {\n+\t\ts += \"_\" + c.element.String()\n+\t}\n+\treturn s\n }\n \n // state describes a high-level HTML parser state.\n //\n-// It bounds the top of the element stack, and by extension the HTML\n-// insertion mode, but also contains state that does not correspond to\n-// anything in the HTML5 parsing algorithm because a single token \n-// production in the HTML grammar may contain embedded actions in a template.\n-// For instance, the quoted HTML attribute produced by\n+// It bounds the top of the element stack, and by extension the HTML insertion\n+// mode, but also contains state that does not correspond to anything in the\n+// HTML5 parsing algorithm because a single token production in the HTML\n+// grammar may contain embedded actions in a template. For instance, the quoted\n+// HTML attribute produced by\n //     <div title=\"Hello {{.World}}\">\n // is a single token in HTML's grammar but in a template spans several nodes.\n type state uint8\n \n const (\n-\t// statePCDATA is parsed character data.  An HTML parser is in\n+\t// stateText is parsed character data. An HTML parser is in\n \t// this state when its parse position is outside an HTML tag,\n \t// directive, comment, and special element body.\n-\tstatePCDATA state = iota\n+\tstateText state = iota\n \t// stateTag occurs before an HTML attribute or the end of a tag.\n \tstateTag\n-\t// stateURI occurs inside an HTML attribute whose content is a URI.\n-\tstateURI\n+\t// stateAttrName occurs inside an attribute name.\n+\t// It occurs between the ^'s in ` ^name^ = value`.\n+\tstateAttrName\n+\t// stateAfterName occurs after an attr name has ended but before any\n+\t// equals sign. It occurs between the ^'s in ` name^ ^= value`.\n+\tstateAfterName\n+\t// stateBeforeValue occurs after the equals sign but before the value.\n+\t// It occurs between the ^'s in ` name =^ ^value`.\n+\tstateBeforeValue\n+\t// stateHTMLCmt occurs inside an <!-- HTML comment -->.\n+\tstateHTMLCmt\n+\t// stateRCDATA occurs inside an RCDATA element (<textarea> or <title>)\n+\t// as described at http://dev.w3.org/html5/spec/syntax.html#elements-0\n+\tstateRCDATA\n+\t// stateAttr occurs inside an HTML attribute whose content is text.\n+\tstateAttr\n+\t// stateURL occurs inside an HTML attribute whose content is a URL.\n+\tstateURL\n+\t// stateJS occurs inside an event handler or script element.\n+\tstateJS\n+\t// stateJSDqStr occurs inside a JavaScript double quoted string.\n+\tstateJSDqStr\n+\t// stateJSSqStr occurs inside a JavaScript single quoted string.\n+\tstateJSSqStr\n+\t// stateJSRegexp occurs inside a JavaScript regexp literal.\n+\tstateJSRegexp\n+\t// stateJSBlockCmt occurs inside a JavaScript /* block comment */.\n+\tstateJSBlockCmt\n+\t// stateJSLineCmt occurs inside a JavaScript // line comment.\n+\tstateJSLineCmt\n+\t// stateCSS occurs inside a <style> element or style attribute.\n+\tstateCSS\n+\t// stateCSSDqStr occurs inside a CSS double quoted string.\n+\tstateCSSDqStr\n+\t// stateCSSSqStr occurs inside a CSS single quoted string.\n+\tstateCSSSqStr\n+\t// stateCSSDqURL occurs inside a CSS double quoted url(\"...\").\n+\tstateCSSDqURL\n+\t// stateCSSSqURL occurs inside a CSS single quoted url('...').\n+\tstateCSSSqURL\n+\t// stateCSSURL occurs inside a CSS unquoted url(...).\n+\tstateCSSURL\n+\t// stateCSSBlockCmt occurs inside a CSS /* block comment */.\n+\tstateCSSBlockCmt\n+\t// stateCSSLineCmt occurs inside a CSS // line comment.\n+\tstateCSSLineCmt\n \t// stateError is an infectious error state outside any valid\n \t// HTML/CSS/JS construct.\n \tstateError\n )\n \n var stateNames = [...]string{\n-\tstatePCDATA: \"statePCDATA\",\n-\tstateTag:    \"stateTag\",\n-\tstateURI:    \"stateURI\",\n-\tstateError:  \"stateError\",\n+\tstateText:        \"stateText\",\n+\tstateTag:         \"stateTag\",\n+\tstateAttrName:    \"stateAttrName\",\n+\tstateAfterName:   \"stateAfterName\",\n+\tstateBeforeValue: \"stateBeforeValue\",\n+\tstateHTMLCmt:     \"stateHTMLCmt\",\n+\tstateRCDATA:      \"stateRCDATA\",\n+\tstateAttr:        \"stateAttr\",\n+\tstateURL:         \"stateURL\",\n+\tstateJS:          \"stateJS\",\n+\tstateJSDqStr:     \"stateJSDqStr\",\n+\tstateJSSqStr:     \"stateJSSqStr\",\n+\tstateJSRegexp:    \"stateJSRegexp\",\n+\tstateJSBlockCmt:  \"stateJSBlockCmt\",\n+\tstateJSLineCmt:   \"stateJSLineCmt\",\n+\tstateCSS:         \"stateCSS\",\n+\tstateCSSDqStr:    \"stateCSSDqStr\",\n+\tstateCSSSqStr:    \"stateCSSSqStr\",\n+\tstateCSSDqURL:    \"stateCSSDqURL\",\n+\tstateCSSSqURL:    \"stateCSSSqURL\",\n+\tstateCSSURL:      \"stateCSSURL\",\n+\tstateCSSBlockCmt: \"stateCSSBlockCmt\",\n+\tstateCSSLineCmt:  \"stateCSSLineCmt\",\n+\tstateError:       \"stateError\",\n }\n \n func (s state) String() string {\n-\tif uint(s) < uint(len(stateNames)) {\n+\tif int(s) < len(stateNames) {\n \t\treturn stateNames[s]\n \t}\n-\treturn fmt.Sprintf(\"illegal state %d\", uint(s))\n+\treturn fmt.Sprintf(\"illegal state %d\", int(s))\n+}\n+\n+// isComment is true for any state that contains content meant for template\n+// authors & maintainers, not for end-users or machines.\n+func isComment(s state) bool {\n+\tswitch s {\n+\tcase stateHTMLCmt, stateJSBlockCmt, stateJSLineCmt, stateCSSBlockCmt, stateCSSLineCmt:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// isInTag return whether s occurs solely inside an HTML tag.\n+func isInTag(s state) bool {\n+\tswitch s {\n+\tcase stateTag, stateAttrName, stateAfterName, stateBeforeValue, stateAttr:\n+\t\treturn true\n+\t}\n+\treturn false\n }\n \n // delim is the delimiter that will end the current HTML attribute.\n@@ -91,8 +211,129 @@ var delimNames = [...]string{\n }\n \n func (d delim) String() string {\n-\tif uint(d) < uint(len(delimNames)) {\n+\tif int(d) < len(delimNames) {\n \t\treturn delimNames[d]\n \t}\n-\treturn fmt.Sprintf(\"illegal delim %d\", uint(d))\n+\treturn fmt.Sprintf(\"illegal delim %d\", int(d))\n+}\n+\n+// urlPart identifies a part in an RFC 3986 hierarchical URL to allow different\n+// encoding strategies.\n+type urlPart uint8\n+\n+const (\n+\t// urlPartNone occurs when not in a URL, or possibly at the start:\n+\t// ^ in \"^http://auth/path?k=v#frag\".\n+\turlPartNone urlPart = iota\n+\t// urlPartPreQuery occurs in the scheme, authority, or path; between the\n+\t// ^s in \"h^ttp://auth/path^?k=v#frag\".\n+\turlPartPreQuery\n+\t// urlPartQueryOrFrag occurs in the query portion between the ^s in\n+\t// \"http://auth/path?^k=v#frag^\".\n+\turlPartQueryOrFrag\n+\t// urlPartUnknown occurs due to joining of contexts both before and\n+\t// after the query separator.\n+\turlPartUnknown\n+)\n+\n+var urlPartNames = [...]string{\n+\turlPartNone:        \"urlPartNone\",\n+\turlPartPreQuery:    \"urlPartPreQuery\",\n+\turlPartQueryOrFrag: \"urlPartQueryOrFrag\",\n+\turlPartUnknown:     \"urlPartUnknown\",\n+}\n+\n+func (u urlPart) String() string {\n+\tif int(u) < len(urlPartNames) {\n+\t\treturn urlPartNames[u]\n+\t}\n+\treturn fmt.Sprintf(\"illegal urlPart %d\", int(u))\n+}\n+\n+// jsCtx determines whether a '/' starts a regular expression literal or a\n+// division operator.\n+type jsCtx uint8\n+\n+const (\n+\t// jsCtxRegexp occurs where a '/' would start a regexp literal.\n+\tjsCtxRegexp jsCtx = iota\n+\t// jsCtxDivOp occurs where a '/' would start a division operator.\n+\tjsCtxDivOp\n+\t// jsCtxUnknown occurs where a '/' is ambiguous due to context joining.\n+\tjsCtxUnknown\n+)\n+\n+func (c jsCtx) String() string {\n+\tswitch c {\n+\tcase jsCtxRegexp:\n+\t\treturn \"jsCtxRegexp\"\n+\tcase jsCtxDivOp:\n+\t\treturn \"jsCtxDivOp\"\n+\tcase jsCtxUnknown:\n+\t\treturn \"jsCtxUnknown\"\n+\t}\n+\treturn fmt.Sprintf(\"illegal jsCtx %d\", int(c))\n+}\n+\n+// element identifies the HTML element when inside a start tag or special body.\n+// Certain HTML element (for example <script> and <style>) have bodies that are\n+// treated differently from stateText so the element type is necessary to\n+// transition into the correct context at the end of a tag and to identify the\n+// end delimiter for the body.\n+type element uint8\n+\n+const (\n+\t// elementNone occurs outside a special tag or special element body.\n+\telementNone element = iota\n+\t// elementScript corresponds to the raw text <script> element.\n+\telementScript\n+\t// elementStyle corresponds to the raw text <style> element.\n+\telementStyle\n+\t// elementTextarea corresponds to the RCDATA <textarea> element.\n+\telementTextarea\n+\t// elementTitle corresponds to the RCDATA <title> element.\n+\telementTitle\n+)\n+\n+var elementNames = [...]string{\n+\telementNone:     \"elementNone\",\n+\telementScript:   \"elementScript\",\n+\telementStyle:    \"elementStyle\",\n+\telementTextarea: \"elementTextarea\",\n+\telementTitle:    \"elementTitle\",\n+}\n+\n+func (e element) String() string {\n+\tif int(e) < len(elementNames) {\n+\t\treturn elementNames[e]\n+\t}\n+\treturn fmt.Sprintf(\"illegal element %d\", int(e))\n+}\n+\n+// attr identifies the most recent HTML attribute when inside a start tag.\n+type attr uint8\n+\n+const (\n+\t// attrNone corresponds to a normal attribute or no attribute.\n+\tattrNone attr = iota\n+\t// attrScript corresponds to an event handler attribute.\n+\tattrScript\n+\t// attrStyle corresponds to the style attribute whose value is CSS.\n+\tattrStyle\n+\t// attrURL corresponds to an attribute whose value is a URL.\n+\tattrURL\n+)\n+\n+var attrNames = [...]string{\n+\tattrNone:   \"attrNone\",\n+\tattrScript: \"attrScript\",\n+\tattrStyle:  \"attrStyle\",\n+\tattrURL:    \"attrURL\",\n+}\n+\n+func (a attr) String() string {\n+\tif int(a) < len(attrNames) {\n+\t\treturn attrNames[a]\n+\t}\n+\treturn fmt.Sprintf(\"illegal attr %d\", int(a))\n }"}, {"sha": "c22ec6df0d07aa6fdf5b6d5a0a74257a47d8cc2e", "filename": "libgo/go/exp/template/html/css.go", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"unicode\"\n+\t\"utf8\"\n+)\n+\n+// endsWithCSSKeyword returns whether b ends with an ident that\n+// case-insensitively matches the lower-case kw.\n+func endsWithCSSKeyword(b []byte, kw string) bool {\n+\ti := len(b) - len(kw)\n+\tif i < 0 {\n+\t\t// Too short.\n+\t\treturn false\n+\t}\n+\tif i != 0 {\n+\t\tr, _ := utf8.DecodeLastRune(b[:i])\n+\t\tif isCSSNmchar(r) {\n+\t\t\t// Too long.\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\t// Many CSS keywords, such as \"!important\" can have characters encoded,\n+\t// but the URI production does not allow that according to\n+\t// http://www.w3.org/TR/css3-syntax/#TOK-URI\n+\t// This does not attempt to recognize encoded keywords. For example,\n+\t// given \"\\75\\72\\6c\" and \"url\" this return false.\n+\treturn string(bytes.ToLower(b[i:])) == kw\n+}\n+\n+// isCSSNmchar returns whether rune is allowed anywhere in a CSS identifier.\n+func isCSSNmchar(rune int) bool {\n+\t// Based on the CSS3 nmchar production but ignores multi-rune escape\n+\t// sequences.\n+\t// http://www.w3.org/TR/css3-syntax/#SUBTOK-nmchar\n+\treturn 'a' <= rune && rune <= 'z' ||\n+\t\t'A' <= rune && rune <= 'Z' ||\n+\t\t'0' <= rune && rune <= '9' ||\n+\t\t'-' == rune ||\n+\t\t'_' == rune ||\n+\t\t// Non-ASCII cases below.\n+\t\t0x80 <= rune && rune <= 0xd7ff ||\n+\t\t0xe000 <= rune && rune <= 0xfffd ||\n+\t\t0x10000 <= rune && rune <= 0x10ffff\n+}\n+\n+// decodeCSS decodes CSS3 escapes given a sequence of stringchars.\n+// If there is no change, it returns the input, otherwise it returns a slice\n+// backed by a new array.\n+// http://www.w3.org/TR/css3-syntax/#SUBTOK-stringchar defines stringchar.\n+func decodeCSS(s []byte) []byte {\n+\ti := bytes.IndexByte(s, '\\\\')\n+\tif i == -1 {\n+\t\treturn s\n+\t}\n+\t// The UTF-8 sequence for a codepoint is never longer than 1 + the\n+\t// number hex digits need to represent that codepoint, so len(s) is an\n+\t// upper bound on the output length.\n+\tb := make([]byte, 0, len(s))\n+\tfor len(s) != 0 {\n+\t\ti := bytes.IndexByte(s, '\\\\')\n+\t\tif i == -1 {\n+\t\t\ti = len(s)\n+\t\t}\n+\t\tb, s = append(b, s[:i]...), s[i:]\n+\t\tif len(s) < 2 {\n+\t\t\tbreak\n+\t\t}\n+\t\t// http://www.w3.org/TR/css3-syntax/#SUBTOK-escape\n+\t\t// escape ::= unicode | '\\' [#x20-#x7E#x80-#xD7FF#xE000-#xFFFD#x10000-#x10FFFF]\n+\t\tif isHex(s[1]) {\n+\t\t\t// http://www.w3.org/TR/css3-syntax/#SUBTOK-unicode\n+\t\t\t//   unicode ::= '\\' [0-9a-fA-F]{1,6} wc?\n+\t\t\tj := 2\n+\t\t\tfor j < len(s) && j < 7 && isHex(s[j]) {\n+\t\t\t\tj++\n+\t\t\t}\n+\t\t\trune := hexDecode(s[1:j])\n+\t\t\tif rune > unicode.MaxRune {\n+\t\t\t\trune, j = rune/16, j-1\n+\t\t\t}\n+\t\t\tn := utf8.EncodeRune(b[len(b):cap(b)], rune)\n+\t\t\t// The optional space at the end allows a hex\n+\t\t\t// sequence to be followed by a literal hex.\n+\t\t\t// string(decodeCSS([]byte(`\\A B`))) == \"\\nB\"\n+\t\t\tb, s = b[:len(b)+n], skipCSSSpace(s[j:])\n+\t\t} else {\n+\t\t\t// `\\\\` decodes to `\\` and `\\\"` to `\"`.\n+\t\t\t_, n := utf8.DecodeRune(s[1:])\n+\t\t\tb, s = append(b, s[1:1+n]...), s[1+n:]\n+\t\t}\n+\t}\n+\treturn b\n+}\n+\n+// isHex returns whether the given character is a hex digit.\n+func isHex(c byte) bool {\n+\treturn '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F'\n+}\n+\n+// hexDecode decodes a short hex digit sequence: \"10\" -> 16.\n+func hexDecode(s []byte) int {\n+\tn := 0\n+\tfor _, c := range s {\n+\t\tn <<= 4\n+\t\tswitch {\n+\t\tcase '0' <= c && c <= '9':\n+\t\t\tn |= int(c - '0')\n+\t\tcase 'a' <= c && c <= 'f':\n+\t\t\tn |= int(c-'a') + 10\n+\t\tcase 'A' <= c && c <= 'F':\n+\t\t\tn |= int(c-'A') + 10\n+\t\tdefault:\n+\t\t\tpanic(fmt.Sprintf(\"Bad hex digit in %q\", s))\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n+// skipCSSSpace returns a suffix of c, skipping over a single space.\n+func skipCSSSpace(c []byte) []byte {\n+\tif len(c) == 0 {\n+\t\treturn c\n+\t}\n+\t// wc ::= #x9 | #xA | #xC | #xD | #x20\n+\tswitch c[0] {\n+\tcase '\\t', '\\n', '\\f', ' ':\n+\t\treturn c[1:]\n+\tcase '\\r':\n+\t\t// This differs from CSS3's wc production because it contains a\n+\t\t// probable spec error whereby wc contains all the single byte\n+\t\t// sequences in nl (newline) but not CRLF.\n+\t\tif len(c) >= 2 && c[1] == '\\n' {\n+\t\t\treturn c[2:]\n+\t\t}\n+\t\treturn c[1:]\n+\t}\n+\treturn c\n+}\n+\n+// isCSSSpace returns whether b is a CSS space char as defined in wc.\n+func isCSSSpace(b byte) bool {\n+\tswitch b {\n+\tcase '\\t', '\\n', '\\f', '\\r', ' ':\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+// cssEscaper escapes HTML and CSS special characters using \\<hex>+ escapes.\n+func cssEscaper(args ...interface{}) string {\n+\ts, _ := stringify(args...)\n+\tvar b bytes.Buffer\n+\twritten := 0\n+\tfor i, r := range s {\n+\t\tvar repl string\n+\t\tswitch r {\n+\t\tcase 0:\n+\t\t\trepl = `\\0`\n+\t\tcase '\\t':\n+\t\t\trepl = `\\9`\n+\t\tcase '\\n':\n+\t\t\trepl = `\\a`\n+\t\tcase '\\f':\n+\t\t\trepl = `\\c`\n+\t\tcase '\\r':\n+\t\t\trepl = `\\d`\n+\t\t// Encode HTML specials as hex so the output can be embedded\n+\t\t// in HTML attributes without further encoding.\n+\t\tcase '\"':\n+\t\t\trepl = `\\22`\n+\t\tcase '&':\n+\t\t\trepl = `\\26`\n+\t\tcase '\\'':\n+\t\t\trepl = `\\27`\n+\t\tcase '(':\n+\t\t\trepl = `\\28`\n+\t\tcase ')':\n+\t\t\trepl = `\\29`\n+\t\tcase '+':\n+\t\t\trepl = `\\2b`\n+\t\tcase '/':\n+\t\t\trepl = `\\2f`\n+\t\tcase ':':\n+\t\t\trepl = `\\3a`\n+\t\tcase ';':\n+\t\t\trepl = `\\3b`\n+\t\tcase '<':\n+\t\t\trepl = `\\3c`\n+\t\tcase '>':\n+\t\t\trepl = `\\3e`\n+\t\tcase '\\\\':\n+\t\t\trepl = `\\\\`\n+\t\tcase '{':\n+\t\t\trepl = `\\7b`\n+\t\tcase '}':\n+\t\t\trepl = `\\7d`\n+\t\tdefault:\n+\t\t\tcontinue\n+\t\t}\n+\t\tb.WriteString(s[written:i])\n+\t\tb.WriteString(repl)\n+\t\twritten = i + utf8.RuneLen(r)\n+\t\tif repl != `\\\\` && (written == len(s) || isHex(s[written]) || isCSSSpace(s[written])) {\n+\t\t\tb.WriteByte(' ')\n+\t\t}\n+\t}\n+\tif written == 0 {\n+\t\treturn s\n+\t}\n+\tb.WriteString(s[written:])\n+\treturn b.String()\n+}\n+\n+var expressionBytes = []byte(\"expression\")\n+var mozBindingBytes = []byte(\"mozbinding\")\n+\n+// cssValueFilter allows innocuous CSS values in the output including CSS\n+// quantities (10px or 25%), ID or class literals (#foo, .bar), keyword values\n+// (inherit, blue), and colors (#888).\n+// It filters out unsafe values, such as those that affect token boundaries,\n+// and anything that might execute scripts.\n+func cssValueFilter(args ...interface{}) string {\n+\ts, t := stringify(args...)\n+\tif t == contentTypeCSS {\n+\t\treturn s\n+\t}\n+\tb, id := decodeCSS([]byte(s)), make([]byte, 0, 64)\n+\n+\t// CSS3 error handling is specified as honoring string boundaries per\n+\t// http://www.w3.org/TR/css3-syntax/#error-handling :\n+\t//     Malformed declarations. User agents must handle unexpected\n+\t//     tokens encountered while parsing a declaration by reading until\n+\t//     the end of the declaration, while observing the rules for\n+\t//     matching pairs of (), [], {}, \"\", and '', and correctly handling\n+\t//     escapes. For example, a malformed declaration may be missing a\n+\t//     property, colon (:) or value.\n+\t// So we need to make sure that values do not have mismatched bracket\n+\t// or quote characters to prevent the browser from restarting parsing\n+\t// inside a string that might embed JavaScript source.\n+\tfor i, c := range b {\n+\t\tswitch c {\n+\t\tcase 0, '\"', '\\'', '(', ')', '/', ';', '@', '[', '\\\\', ']', '`', '{', '}':\n+\t\t\treturn filterFailsafe\n+\t\tcase '-':\n+\t\t\t// Disallow <!-- or -->.\n+\t\t\t// -- should not appear in valid identifiers.\n+\t\t\tif i != 0 && '-' == b[i-1] {\n+\t\t\t\treturn filterFailsafe\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tif c < 0x80 && isCSSNmchar(int(c)) {\n+\t\t\t\tid = append(id, c)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tid = bytes.ToLower(id)\n+\tif bytes.Index(id, expressionBytes) != -1 || bytes.Index(id, mozBindingBytes) != -1 {\n+\t\treturn filterFailsafe\n+\t}\n+\treturn string(b)\n+}"}, {"sha": "5f633e89442afa955a409ff054b559a1872d730c", "filename": "libgo/go/exp/template/html/css_test.go", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestEndsWithCSSKeyword(t *testing.T) {\n+\ttests := []struct {\n+\t\tcss, kw string\n+\t\twant    bool\n+\t}{\n+\t\t{\"\", \"url\", false},\n+\t\t{\"url\", \"url\", true},\n+\t\t{\"URL\", \"url\", true},\n+\t\t{\"Url\", \"url\", true},\n+\t\t{\"url\", \"important\", false},\n+\t\t{\"important\", \"important\", true},\n+\t\t{\"image-url\", \"url\", false},\n+\t\t{\"imageurl\", \"url\", false},\n+\t\t{\"image url\", \"url\", true},\n+\t}\n+\tfor _, test := range tests {\n+\t\tgot := endsWithCSSKeyword([]byte(test.css), test.kw)\n+\t\tif got != test.want {\n+\t\t\tt.Errorf(\"want %t but got %t for css=%v, kw=%v\", test.want, got, test.css, test.kw)\n+\t\t}\n+\t}\n+}\n+\n+func TestIsCSSNmchar(t *testing.T) {\n+\ttests := []struct {\n+\t\trune int\n+\t\twant bool\n+\t}{\n+\t\t{0, false},\n+\t\t{'0', true},\n+\t\t{'9', true},\n+\t\t{'A', true},\n+\t\t{'Z', true},\n+\t\t{'a', true},\n+\t\t{'z', true},\n+\t\t{'_', true},\n+\t\t{'-', true},\n+\t\t{':', false},\n+\t\t{';', false},\n+\t\t{' ', false},\n+\t\t{0x7f, false},\n+\t\t{0x80, true},\n+\t\t{0x1234, true},\n+\t\t{0xd800, false},\n+\t\t{0xdc00, false},\n+\t\t{0xfffe, false},\n+\t\t{0x10000, true},\n+\t\t{0x110000, false},\n+\t}\n+\tfor _, test := range tests {\n+\t\tgot := isCSSNmchar(test.rune)\n+\t\tif got != test.want {\n+\t\t\tt.Errorf(\"%q: want %t but got %t\", string(test.rune), test.want, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestDecodeCSS(t *testing.T) {\n+\ttests := []struct {\n+\t\tcss, want string\n+\t}{\n+\t\t{``, ``},\n+\t\t{`foo`, `foo`},\n+\t\t{`foo\\`, `foo`},\n+\t\t{`foo\\\\`, `foo\\`},\n+\t\t{`\\`, ``},\n+\t\t{`\\A`, \"\\n\"},\n+\t\t{`\\a`, \"\\n\"},\n+\t\t{`\\0a`, \"\\n\"},\n+\t\t{`\\00000a`, \"\\n\"},\n+\t\t{`\\000000a`, \"\\u0000a\"},\n+\t\t{`\\1234 5`, \"\\u1234\" + \"5\"},\n+\t\t{`\\1234\\20 5`, \"\\u1234\" + \" 5\"},\n+\t\t{`\\1234\\A 5`, \"\\u1234\" + \"\\n5\"},\n+\t\t{\"\\\\1234\\t5\", \"\\u1234\" + \"5\"},\n+\t\t{\"\\\\1234\\n5\", \"\\u1234\" + \"5\"},\n+\t\t{\"\\\\1234\\r\\n5\", \"\\u1234\" + \"5\"},\n+\t\t{`\\12345`, \"\\U00012345\"},\n+\t\t{`\\\\`, `\\`},\n+\t\t{`\\\\ `, `\\ `},\n+\t\t{`\\\"`, `\"`},\n+\t\t{`\\'`, `'`},\n+\t\t{`\\.`, `.`},\n+\t\t{`\\. .`, `. .`},\n+\t\t{\n+\t\t\t`The \\3c i\\3equick\\3c/i\\3e,\\d\\A\\3cspan style=\\27 color:brown\\27\\3e brown\\3c/span\\3e  fox jumps\\2028over the \\3c canine class=\\22lazy\\22 \\3e dog\\3c/canine\\3e`,\n+\t\t\t\"The <i>quick</i>,\\r\\n<span style='color:brown'>brown</span> fox jumps\\u2028over the <canine class=\\\"lazy\\\">dog</canine>\",\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tgot1 := string(decodeCSS([]byte(test.css)))\n+\t\tif got1 != test.want {\n+\t\t\tt.Errorf(\"%q: want\\n\\t%q\\nbut got\\n\\t%q\", test.css, test.want, got1)\n+\t\t}\n+\t\trecoded := cssEscaper(got1)\n+\t\tif got2 := string(decodeCSS([]byte(recoded))); got2 != test.want {\n+\t\t\tt.Errorf(\"%q: escape & decode not dual for %q\", test.css, recoded)\n+\t\t}\n+\t}\n+}\n+\n+func TestHexDecode(t *testing.T) {\n+\tfor i := 0; i < 0x200000; i += 101 /* coprime with 16 */ {\n+\t\ts := strconv.Itob(i, 16)\n+\t\tif got := hexDecode([]byte(s)); got != i {\n+\t\t\tt.Errorf(\"%s: want %d but got %d\", s, i, got)\n+\t\t}\n+\t\ts = strings.ToUpper(s)\n+\t\tif got := hexDecode([]byte(s)); got != i {\n+\t\t\tt.Errorf(\"%s: want %d but got %d\", s, i, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestSkipCSSSpace(t *testing.T) {\n+\ttests := []struct {\n+\t\tcss, want string\n+\t}{\n+\t\t{\"\", \"\"},\n+\t\t{\"foo\", \"foo\"},\n+\t\t{\"\\n\", \"\"},\n+\t\t{\"\\r\\n\", \"\"},\n+\t\t{\"\\r\", \"\"},\n+\t\t{\"\\t\", \"\"},\n+\t\t{\" \", \"\"},\n+\t\t{\"\\f\", \"\"},\n+\t\t{\" foo\", \"foo\"},\n+\t\t{\"  foo\", \" foo\"},\n+\t\t{`\\20`, `\\20`},\n+\t}\n+\tfor _, test := range tests {\n+\t\tgot := string(skipCSSSpace([]byte(test.css)))\n+\t\tif got != test.want {\n+\t\t\tt.Errorf(\"%q: want %q but got %q\", test.css, test.want, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestCSSEscaper(t *testing.T) {\n+\tinput := (\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\" +\n+\t\t\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\" +\n+\t\t` !\"#$%&'()*+,-./` +\n+\t\t`0123456789:;<=>?` +\n+\t\t`@ABCDEFGHIJKLMNO` +\n+\t\t`PQRSTUVWXYZ[\\]^_` +\n+\t\t\"`abcdefghijklmno\" +\n+\t\t\"pqrstuvwxyz{|}~\\x7f\" +\n+\t\t\"\\u00A0\\u0100\\u2028\\u2029\\ufeff\\U0001D11E\")\n+\n+\twant := (\"\\\\0\\x01\\x02\\x03\\x04\\x05\\x06\\x07\" +\n+\t\t\"\\x08\\\\9 \\\\a\\x0b\\\\c \\\\d\\x0E\\x0F\" +\n+\t\t\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\" +\n+\t\t\"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\" +\n+\t\t` !\\22#$%\\26\\27\\28\\29*\\2b,-.\\2f ` +\n+\t\t`0123456789\\3a\\3b\\3c=\\3e?` +\n+\t\t`@ABCDEFGHIJKLMNO` +\n+\t\t`PQRSTUVWXYZ[\\\\]^_` +\n+\t\t\"`abcdefghijklmno\" +\n+\t\t`pqrstuvwxyz\\7b|\\7d~` + \"\\u007f\" +\n+\t\t\"\\u00A0\\u0100\\u2028\\u2029\\ufeff\\U0001D11E\")\n+\n+\tgot := cssEscaper(input)\n+\tif got != want {\n+\t\tt.Errorf(\"encode: want\\n\\t%q\\nbut got\\n\\t%q\", want, got)\n+\t}\n+\n+\tgot = string(decodeCSS([]byte(got)))\n+\tif input != got {\n+\t\tt.Errorf(\"decode: want\\n\\t%q\\nbut got\\n\\t%q\", input, got)\n+\t}\n+}\n+\n+func TestCSSValueFilter(t *testing.T) {\n+\ttests := []struct {\n+\t\tcss, want string\n+\t}{\n+\t\t{\"\", \"\"},\n+\t\t{\"foo\", \"foo\"},\n+\t\t{\"0\", \"0\"},\n+\t\t{\"0px\", \"0px\"},\n+\t\t{\"-5px\", \"-5px\"},\n+\t\t{\"1.25in\", \"1.25in\"},\n+\t\t{\"+.33em\", \"+.33em\"},\n+\t\t{\"100%\", \"100%\"},\n+\t\t{\"12.5%\", \"12.5%\"},\n+\t\t{\".foo\", \".foo\"},\n+\t\t{\"#bar\", \"#bar\"},\n+\t\t{\"corner-radius\", \"corner-radius\"},\n+\t\t{\"-moz-corner-radius\", \"-moz-corner-radius\"},\n+\t\t{\"#000\", \"#000\"},\n+\t\t{\"#48f\", \"#48f\"},\n+\t\t{\"#123456\", \"#123456\"},\n+\t\t{\"U+00-FF, U+980-9FF\", \"U+00-FF, U+980-9FF\"},\n+\t\t{\"color: red\", \"color: red\"},\n+\t\t{\"<!--\", \"ZgotmplZ\"},\n+\t\t{\"-->\", \"ZgotmplZ\"},\n+\t\t{\"<![CDATA[\", \"ZgotmplZ\"},\n+\t\t{\"]]>\", \"ZgotmplZ\"},\n+\t\t{\"</style\", \"ZgotmplZ\"},\n+\t\t{`\"`, \"ZgotmplZ\"},\n+\t\t{`'`, \"ZgotmplZ\"},\n+\t\t{\"`\", \"ZgotmplZ\"},\n+\t\t{\"\\x00\", \"ZgotmplZ\"},\n+\t\t{\"/* foo */\", \"ZgotmplZ\"},\n+\t\t{\"//\", \"ZgotmplZ\"},\n+\t\t{\"[href=~\", \"ZgotmplZ\"},\n+\t\t{\"expression(alert(1337))\", \"ZgotmplZ\"},\n+\t\t{\"-expression(alert(1337))\", \"ZgotmplZ\"},\n+\t\t{\"expression\", \"ZgotmplZ\"},\n+\t\t{\"Expression\", \"ZgotmplZ\"},\n+\t\t{\"EXPRESSION\", \"ZgotmplZ\"},\n+\t\t{\"-moz-binding\", \"ZgotmplZ\"},\n+\t\t{\"-expr\\x00ession(alert(1337))\", \"ZgotmplZ\"},\n+\t\t{`-expr\\0ession(alert(1337))`, \"ZgotmplZ\"},\n+\t\t{`-express\\69on(alert(1337))`, \"ZgotmplZ\"},\n+\t\t{`-express\\69 on(alert(1337))`, \"ZgotmplZ\"},\n+\t\t{`-exp\\72 ession(alert(1337))`, \"ZgotmplZ\"},\n+\t\t{`-exp\\52 ession(alert(1337))`, \"ZgotmplZ\"},\n+\t\t{`-exp\\000052 ession(alert(1337))`, \"ZgotmplZ\"},\n+\t\t{`-expre\\0000073sion`, \"-expre\\x073sion\"},\n+\t\t{`@import url evil.css`, \"ZgotmplZ\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\tgot := cssValueFilter(test.css)\n+\t\tif got != test.want {\n+\t\t\tt.Errorf(\"%q: want %q but got %q\", test.css, test.want, got)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkCSSEscaper(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tcssEscaper(\"The <i>quick</i>,\\r\\n<span style='color:brown'>brown</span> fox jumps\\u2028over the <canine class=\\\"lazy\\\">dog</canine>\")\n+\t}\n+}\n+\n+func BenchmarkCSSEscaperNoSpecials(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tcssEscaper(\"The quick, brown fox jumps over the lazy dog.\")\n+\t}\n+}\n+\n+func BenchmarkDecodeCSS(b *testing.B) {\n+\ts := []byte(`The \\3c i\\3equick\\3c/i\\3e,\\d\\A\\3cspan style=\\27 color:brown\\27\\3e brown\\3c/span\\3e fox jumps\\2028over the \\3c canine class=\\22lazy\\22 \\3edog\\3c/canine\\3e`)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdecodeCSS(s)\n+\t}\n+}\n+\n+func BenchmarkDecodeCSSNoSpecials(b *testing.B) {\n+\ts := []byte(\"The quick, brown fox jumps over the lazy dog.\")\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdecodeCSS(s)\n+\t}\n+}\n+\n+func BenchmarkCSSValueFilter(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tcssValueFilter(`  e\\78preS\\0Sio/**/n(alert(1337))`)\n+\t}\n+}\n+\n+func BenchmarkCSSValueFilterOk(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tcssValueFilter(`Times New Roman`)\n+\t}\n+}"}, {"sha": "a9b78ca5157962afd881924f2d6d9499eb94a03f", "filename": "libgo/go/exp/template/html/doc.go", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fdoc.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+Package html is a specialization of package template that automates the\n+construction of HTML output that is safe against code injection.\n+\n+\n+Introduction\n+\n+To use this package, invoke the standard template package to parse a template\n+set, and then use this package\u2019s EscapeSet function to secure the set.\n+The arguments to EscapeSet are the template set and the names of all templates\n+that will be passed to Execute.\n+\n+    set, err := new(template.Set).Parse(...)\n+    set, err = EscapeSet(set, \"templateName0\", ...)\n+\n+If successful, set will now be injection-safe. Otherwise, the returned set will\n+be nil and an error, described below, will explain the problem.\n+\n+The template names do not need to include helper templates but should include\n+all names x used thus:\n+\n+    set.Execute(out, x, ...)\n+\n+EscapeSet modifies the named templates in place to treat data values as plain\n+text safe for embedding in an HTML document. The escaping is contextual, so\n+actions can appear within JavaScript, CSS, and URI contexts without introducing'hazards.\n+\n+The security model used by this package assumes that template authors are\n+trusted, while Execute's data parameter is not. More details are provided below.\n+\n+Example\n+\n+    tmpls, err := new(template.Set).Parse(`{{define \"t'}}Hello, {{.}}!{{end}}`)\n+\n+when used by itself\n+\n+    tmpls.Execute(out, \"t\", \"<script>alert('you have been pwned')</script>\")\n+\n+produces\n+\n+    Hello, <script>alert('you have been pwned')</script>!\n+\n+but after securing with EscapeSet like this,\n+\n+    tmpls, err := EscapeSet(tmpls, \"t\")\n+    tmpls.Execute(out, \"t\", ...)\n+\n+produces the safe, escaped HTML output\n+\n+    Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!\n+\n+\n+Contexts\n+\n+EscapeSet understands HTML, CSS, JavaScript, and URIs. It adds sanitizing\n+functions to each simple action pipeline, so given the excerpt\n+\n+  <a href=\"/search?q={{.}}\">{{.}}</a>\n+\n+EscapeSet will rewrite each {{.}} to add escaping functions where necessary,\n+in this case,\n+\n+  <a href=\"/search?q={{. | urlquery}}\">{{. | html}}</a>\n+\n+\n+Errors\n+\n+See the documentation of ErrorCode for details.\n+\n+\n+A fuller picture\n+\n+The rest of this package comment may be skipped on first reading; it includes\n+details necessary to understand escaping contexts and error messages. Most users\n+will not need to understand these details.\n+\n+\n+Contexts\n+\n+Assuming {{.}} is `O'Reilly: How are <i>you</i>?`, the table below shows\n+how {{.}} appears when used in the context to the left.\n+\n+Context                          {{.}} After\n+{{.}}                            O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?\n+<a title='{{.}}'>                O&#39;Reilly: How are you?\n+<a href=\"/{{.}}\">                O&#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n+<a href=\"?q={{.}}\">              O&#39;Reilly%3a%20How%20are%3ci%3e...%3f\n+<a onx='f(\"{{.}}\")'>             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n+<a onx='f({{.}})'>               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n+<a onx='pattern = /{{.}}/;'>     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n+\n+If used in an unsafe context, then the value might be filtered out:\n+\n+Context                          {{.}} After\n+<a href=\"{{.}}\">                 #ZgotmplZ\n+\n+since \"O'Reilly:\" is not an allowed protocol like \"http:\".\n+\n+\n+If {{.}} is the innocuous word, `left`, then it can appear more widely,\n+\n+Context                              {{.}} After\n+{{.}}                                left\n+<a title='{{.}}'>                    left\n+<a href='{{.}}'>                     left\n+<a href='/{{.}}'>                    left\n+<a href='?dir={{.}}'>                left\n+<a style=\"border-{{.}}: 4px\">        left\n+<a style=\"align: {{.}}\">             left\n+<a style=\"background: '{{.}}'>       left\n+<a style=\"background: url('{{.}}')>  left\n+<style>p.{{.}} {color:red}</style>   left\n+\n+Non-string values can be used in JavaScript contexts.\n+If {{.}} is\n+\n+  []struct{A,B string}{ \"foo\", \"bar\" }\n+\n+in the escaped template\n+\n+  <script>var pair = {{.}};</script>\n+\n+then the template output is\n+\n+  <script>var pair = {\"A\": \"foo\", \"B\": \"bar\"};</script>\n+\n+See package json to understand how non-string content is marshalled for\n+embedding in JavaScript contexts.\n+\n+\n+Typed Strings\n+\n+By default, EscapeSet assumes all pipelines produce a plain text string. It\n+adds escaping pipeline stages necessary to correctly and safely embed that\n+plain text string in the appropriate context.\n+\n+When a data value is not plain text, you can make sure it is not over-escaped\n+by marking it with its type.\n+\n+Types HTML, JS, URL, and others from content.go can carry safe content that is\n+exempted from escaping.\n+\n+The template\n+\n+  Hello, {{.}}!\n+\n+can be invoked with\n+\n+  tmpl.Execute(out, HTML(`<b>World</b>`))\n+\n+to produce\n+\n+  Hello, <b>World</b>!\n+\n+instead of the\n+\n+  Hello, &lt;b&gt;World&lt;b&gt;!\n+\n+that would have been produced if {{.}} was a regular string.\n+\n+\n+Security Model\n+\n+http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition defines \"safe\" as used by this package.\n+\n+This package assumes that template authors are trusted, that Execute's data\n+parameter is not, and seeks to preserve the properties below in the face\n+of untrusted data:\n+\n+Structure Preservation Property\n+\"... when a template author writes an HTML tag in a safe templating language,\n+the browser will interpret the corresponding portion of the output as a tag\n+regardless of the values of untrusted data, and similarly for other structures\n+such as attribute boundaries and JS and CSS string boundaries.\"\n+\n+Code Effect Property\n+\"... only code specified by the template author should run as a result of\n+injecting the template output into a page and all code specified by the\n+template author should run as a result of the same.\"\n+\n+Least Surprise Property\n+\"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript;\n+who knows that EscapeSet is applied should be able to look at a {{.}}\n+and correctly infer what sanitization happens.\"\n+*/\n+package html"}, {"sha": "5515bfe68dd2b5859b3cb0517a1691a385e19d35", "filename": "libgo/go/exp/template/html/error.go", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ferror.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "patch": "@@ -0,0 +1,213 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package html\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+// Error describes a problem encountered during template Escaping.\n+type Error struct {\n+\t// ErrorCode describes the kind of error.\n+\tErrorCode ErrorCode\n+\t// Name is the name of the template in which the error was encountered.\n+\tName string\n+\t// Line is the line number of the error in the template source or 0.\n+\tLine int\n+\t// Description is a human-readable description of the problem.\n+\tDescription string\n+}\n+\n+// ErrorCode is a code for a kind of error.\n+type ErrorCode int\n+\n+// We define codes for each error that manifests while escaping templates, but\n+// escaped templates may also fail at runtime.\n+//\n+// Output: \"ZgotmplZ\"\n+// Example:\n+//   <img src=\"{{.X}}\">\n+//   where {{.X}} evaluates to `javascript:...`\n+// Discussion:\n+//   \"ZgotmplZ\" is a special value that indicates that unsafe content reached a\n+//   CSS or URL context at runtime. The output of the example will be\n+//     <img src=\"#ZgotmplZ\">\n+//   If the data comes from a trusted source, use content types to exempt it\n+//   from filtering: URL(`javascript:...`).\n+const (\n+\t// OK indicates the lack of an error.\n+\tOK ErrorCode = iota\n+\n+\t// ErrAmbigContext: \"... appears in an ambiguous URL context\"\n+\t// Example:\n+\t//   <a href=\"\n+\t//      {{if .C}}\n+\t//        /path/\n+\t//      {{else}}\n+\t//        /search?q=\n+\t//      {{end}}\n+\t//      {{.X}}\n+\t//   \">\n+\t// Discussion:\n+\t//   {{.X}} is in an ambiguous URL context since, depending on {{.C}},\n+\t//  it may be either a URL suffix or a query parameter.\n+\t//   Moving {{.X}} into the condition removes the ambiguity:\n+\t//   <a href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\">\n+\tErrAmbigContext\n+\n+\t// ErrBadHTML: \"expected space, attr name, or end of tag, but got ...\",\n+\t//   \"... in unquoted attr\", \"... in attribute name\"\n+\t// Example:\n+\t//   <a href = /search?q=foo>\n+\t//   <href=foo>\n+\t//   <form na<e=...>\n+\t//   <option selected<\n+\t// Discussion:\n+\t//   This is often due to a typo in an HTML element, but some runes\n+\t//   are banned in tag names, attribute names, and unquoted attribute\n+\t//   values because they can tickle parser ambiguities.\n+\t//   Quoting all attributes is the best policy.\n+\tErrBadHTML\n+\n+\t// ErrBranchEnd: \"{{if}} branches end in different contexts\"\n+\t// Example:\n+\t//   {{if .C}}<a href=\"{{end}}{{.X}}\n+\t// Discussion:\n+\t//   EscapeSet statically examines each possible path when it encounters\n+\t//   a {{if}}, {{range}}, or {{with}} to escape any following pipelines.\n+\t//   The example is ambiguous since {{.X}} might be an HTML text node,\n+\t//   or a URL prefix in an HTML attribute. EscapeSet needs to understand\n+\t//   the context of {{.X}} to escape it, but that depends on the\n+\t//   run-time value of {{.C}}.\n+\t//\n+\t//   The problem is usually something like missing quotes or angle\n+\t//   brackets, or can be avoided by refactoring to put the two contexts\n+\t//   into different branches of an if, range or with. If the problem\n+\t//   is in a {{range}} over a collection that should never be empty,\n+\t//   adding a dummy {{else}} can help.\n+\tErrBranchEnd\n+\n+\t// ErrEndContext: \"... ends in a non-text context: ...\"\n+\t// Examples:\n+\t//   <div\n+\t//   <div title=\"no close quote>\n+\t//   <script>f()\n+\t// Discussion:\n+\t//   EscapeSet assumes the ouput is a DocumentFragment of HTML.\n+\t//   Templates that end without closing tags will trigger this error.\n+\t//   Templates that produce incomplete Fragments should not be named\n+\t//   in the call to EscapeSet.\n+\t//\n+\t// If you have a helper template in your set that is not meant to\n+\t// produce a document fragment, then do not pass its name to\n+\t// EscapeSet(set, ...names).\n+\t//\n+\t//   {{define \"main\"}} <script>{{template \"helper\"}}</script> {{end}}\n+\t//   {{define \"helper\"}} document.write(' <div title=\" ') {{end}}\n+\t// \n+\t// \"helper\" does not produce a valid document fragment, though it does\n+\t// produce a valid JavaScript Program.\n+\tErrEndContext\n+\n+\t// ErrNoNames: \"must specify names of top level templates\"\n+\t// \n+\t//   EscapeSet does not assume that all templates in a set produce HTML.\n+\t//   Some may be helpers that produce snippets of other languages.\n+\t//   Passing in no template names is most likely an error,\n+\t//   so EscapeSet(set) will panic.\n+\t//   If you call EscapeSet with a slice of names, guard it with len:\n+\t// \n+\t//     if len(names) != 0 {\n+\t//       set, err := EscapeSet(set, ...names)\n+\t//     }\n+\tErrNoNames\n+\n+\t// ErrNoSuchTemplate: \"no such template ...\"\n+\t// Examples:\n+\t//   {{define \"main\"}}<div {{template \"attrs\"}}>{{end}}\n+\t//   {{define \"attrs\"}}href=\"{{.URL}}\"{{end}}\n+\t// Discussion:\n+\t//   EscapeSet looks through template calls to compute the context.\n+\t//   Here the {{.URL}} in \"attrs\" must be treated as a URL when called\n+\t//   from \"main\", but if \"attrs\" is not in set when\n+\t//   EscapeSet(&set, \"main\") is called, this error will arise.\n+\tErrNoSuchTemplate\n+\n+\t// ErrOutputContext: \"cannot compute output context for template ...\"\n+\t// Examples:\n+\t//   {{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}}\n+\t// Discussion:\n+\t//   A recursive template does not end in the same context in which it\n+\t//   starts, and a reliable output context cannot be computed.\n+\t//   Look for typos in the named template.\n+\t//   If the template should not be called in the named start context,\n+\t//   look for calls to that template in unexpected contexts.\n+\t//   Maybe refactor recursive templates to not be recursive.\n+\tErrOutputContext\n+\n+\t// ErrPartialCharset: \"unfinished JS regexp charset in ...\"\n+\t// Example:\n+\t//     <script>var pattern = /foo[{{.Chars}}]/</script>\n+\t// Discussion:\n+\t//   EscapeSet does not support interpolation into regular expression\n+\t//   literal character sets.\n+\tErrPartialCharset\n+\n+\t// ErrPartialEscape: \"unfinished escape sequence in ...\"\n+\t// Example:\n+\t//   <script>alert(\"\\{{.X}}\")</script>\n+\t// Discussion:\n+\t//   EscapeSet does not support actions following a backslash.\n+\t//   This is usually an error and there are better solutions; for\n+\t//   our example\n+\t//     <script>alert(\"{{.X}}\")</script>\n+\t//   should work, and if {{.X}} is a partial escape sequence such as\n+\t//   \"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`)\n+\tErrPartialEscape\n+\n+\t// ErrRangeLoopReentry: \"on range loop re-entry: ...\"\n+\t// Example:\n+\t//   {{range .}}<p class={{.}}{{end}}\n+\t// Discussion:\n+\t//   If an iteration through a range would cause it to end in a\n+\t//   different context than an earlier pass, there is no single context.\n+\t//   In the example, the <p> tag is missing a '>'.\n+\t//   EscapeSet cannot tell whether {{.}} is meant to be an HTML class or\n+\t//   the content of a broken <p> element and complains because the\n+\t//   second iteration would produce something like\n+\t// \n+\t//     <p class=foo<p class=bar\n+\tErrRangeLoopReentry\n+\n+\t// ErrSlashAmbig: '/' could start a division or regexp.\n+\t// Example:\n+\t//   <script>\n+\t//     {{if .C}}var x = 1{{end}}\n+\t//     /-{{.N}}/i.test(x) ? doThis : doThat();\n+\t//   </script>\n+\t// Discussion:\n+\t//   The example above could produce `var x = 1/-2/i.test(s)...`\n+\t//   in which the first '/' is a mathematical division operator or it\n+\t//   could produce `/-2/i.test(s)` in which the first '/' starts a\n+\t//   regexp literal.\n+\t//   Look for missing semicolons inside branches, and maybe add\n+\t//   parentheses to make it clear which interpretation you intend.\n+\tErrSlashAmbig\n+)\n+\n+func (e *Error) String() string {\n+\tif e.Line != 0 {\n+\t\treturn fmt.Sprintf(\"exp/template/html:%s:%d: %s\", e.Name, e.Line, e.Description)\n+\t} else if e.Name != \"\" {\n+\t\treturn fmt.Sprintf(\"exp/template/html:%s: %s\", e.Name, e.Description)\n+\t}\n+\treturn \"exp/template/html: \" + e.Description\n+}\n+\n+// errorf creates an error given a format string f and args.\n+// The template Name still needs to be supplied.\n+func errorf(k ErrorCode, line int, f string, args ...interface{}) *Error {\n+\treturn &Error{k, \"\", line, fmt.Sprintf(f, args...)}\n+}"}, {"sha": "74abccecddf332fa8db7e49c90bc360d18d4f846", "filename": "libgo/go/exp/template/html/escape.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a4ea7596cd1175d9f6f679dbcd77d766da34d74d", "filename": "libgo/go/exp/template/html/escape_test.go", "status": "modified", "additions": 1591, "deletions": 43, "changes": 1634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "91bb1b17049f3fa3482e1688e548d62a3cb6fd5e", "filename": "libgo/go/exp/template/html/html.go", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e178d0f27e5f678764da08f8a5745f41de6b0682", "filename": "libgo/go/exp/template/html/html_test.go", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "98c2ac5f27f3e98baff35590db64fc702c6d48d3", "filename": "libgo/go/exp/template/html/js.go", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e7764054a35be6b62f105fc8600d0a6336e965eb", "filename": "libgo/go/exp/template/html/js_test.go", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "49a14511745bd99599a07e9411c6cdc4d4fcbd8f", "filename": "libgo/go/exp/template/html/transition.go", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ftransition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ftransition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Ftransition.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "5b19df084049e6667e8b585c2250473728099eeb", "filename": "libgo/go/exp/template/html/url.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Furl.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "b84623151c7e408b5df85af43aa767fecf948852", "filename": "libgo/go/exp/template/html/url_test.go", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Furl_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e3f584774e3b06e9b4a674ae169721f8fd692984", "filename": "libgo/go/exp/terminal/shell.go", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2bbe4a4f8f9810ffed369d5d02de0f9fe0807f0a", "filename": "libgo/go/exp/terminal/shell_test.go", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fterminal%2Fshell_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fterminal%2Fshell_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fshell_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "aacd90905f5f156163294157abef8e96e3f5bd10", "filename": "libgo/go/exp/terminal/terminal.go", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "87e3e93da73a0ef79334020405e92386f147e584", "filename": "libgo/go/exp/types/check.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/check.go"}, {"sha": "034acd00de5a30bd7488499a9de5abe0bca57b68", "filename": "libgo/go/exp/types/check_test.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/check_test.go"}, {"sha": "1ef95d9f952ef955f68d2e53cdd9815af2e01259", "filename": "libgo/go/exp/types/const.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fconst.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/const.go"}, {"sha": "383520320f41417bfaec5f3f4493be9e5bf655bb", "filename": "libgo/go/exp/types/exportdata.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/exportdata.go"}, {"sha": "fe90f91080771f3f7b4a027a92bb7b59ee25d356", "filename": "libgo/go/exp/types/gcimporter.go", "status": "renamed", "additions": 72, "deletions": 48, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/gcimporter.go"}, {"sha": "ec87f5d514b3535b497b1b171bae7ca862c0329d", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/gcimporter_test.go"}, {"sha": "ed63bf9adec099c13e6cfaea10a8fe9b564b916e", "filename": "libgo/go/exp/types/testdata/exports.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Fexports.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/testdata/exports.go"}, {"sha": "3aa896892e3dce97919ca6c57faf444202a070ad", "filename": "libgo/go/exp/types/types.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftypes.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/types.go"}, {"sha": "80db127829585f982b5f5e22433e0d1aac071ab6", "filename": "libgo/go/exp/types/universe.go", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/go/types/universe.go"}, {"sha": "c5dfe99ad71967e4d774491f6bd6cd2da3a47e3a", "filename": "libgo/go/exp/winfsnotify/winfsnotify.go", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "edf2165c0ec699d5ca3934606338a7aa19585f68", "filename": "libgo/go/exp/winfsnotify/winfsnotify_test.go", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a2f16f282b164d42a58284c7c266dc83347d030d", "filename": "libgo/go/exp/wingui/gui.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "32015287c92c95e1fe5bc929d1b693e08031cd21", "filename": "libgo/go/exp/wingui/winapi.go", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "38e93eea717a7e07926656e1e5169329760aa163", "filename": "libgo/go/exp/wingui/zwinapi.go", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f13f7a45cd34fe60538159014ee597ae34165c6c", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f13531669c1914dcd9ae9027c042ac01e4b76df2", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "c993e57a40a29bd2d75c820da2cbc93bffa32492", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "030ad6187fafbd3d90c3c8b743ecd774bdde1745", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "7721e724115998472f859186982d35569c0a040b", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 86, "deletions": 74, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d7d4b4b6b6d6e3dfc5620f8cf6050151846406ae", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 122, "deletions": 175, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "68a4180c90698223bc90ea70ca7eb452f070fa27", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 55, "deletions": 14, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "3ee10ab3484448eb8d21c69e22852e7a7de9bce7", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 461, "deletions": 70, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "03ebb9893aafb6c0f7a6a4ede5b1b35e0ae90c45", "filename": "libgo/go/go/build/pkgtest/pkgtest.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "26b483fa0bac3bc934851004d80e5e2246462e17", "filename": "libgo/go/go/build/pkgtest/sqrt_386_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_386_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_386_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_386_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "26b483fa0bac3bc934851004d80e5e2246462e17", "filename": "libgo/go/go/build/pkgtest/sqrt_amd64_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_amd64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_amd64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_amd64_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "26b483fa0bac3bc934851004d80e5e2246462e17", "filename": "libgo/go/go/build/pkgtest/sqrt_arm_test.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_arm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_arm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_arm_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "95fb625525cef0f9975972f63f907fc983c186b0", "filename": "libgo/go/go/build/pkgtest/sqrt_test.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fsqrt_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "77e903d96ca745fdf7ad7c9056c36ad29f98bf00", "filename": "libgo/go/go/build/pkgtest/xsqrt_test.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fxsqrt_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d27630d758d94c09b0200d7a59c61fa03dc1378d", "filename": "libgo/go/go/build/syslist_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "7fdf0bcff6637eede8a87ff7a3b05b2d6eb12fdb", "filename": "libgo/go/go/doc/example.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "be82b2f801abaf99d1860dc966cff9ee11cc525b", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "9705dcff250468d18d99fdea08e922fa909c63ee", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "364530634aaeb21763155d63cdede2bdcd902893", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "bfabd749abb7e70b1117c6d5e88f009fa2d909e9", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a644aa383ab9df1006d188709af31d12c6b74ba8", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "bfa2568c21fd29ea3f8ea5697f4591be112d01f0", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 87, "deletions": 24, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "1d69c57b517466994fde21dc225b58261239147b", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "589ec68a67843f9f61b759de521aa65fb2bec520", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "0c2cbe6dc02f4288f37cdee873aaf3dc75497c8d", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "8cf3dcd25a272a032f5dcad8969e2940ddfa7be8", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "5fb47f7cbb214278e3ad7097dcf0b3b18f788db0", "filename": "libgo/go/go/token/serialize.go", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "24e419abf6d1f6d74ba018e8415e323305065d39", "filename": "libgo/go/go/token/serialize_test.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d73d1a45048db1621ec715086a1bf05c5dea713e", "filename": "libgo/go/go/typechecker/scope.go", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "4e317f214645e164302640660f2d4c57583ae753", "filename": "libgo/go/go/typechecker/testdata/test0.src", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest0.src?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "b5531fb9f5b62fa0d1074851df232a620dc2e117", "filename": "libgo/go/go/typechecker/testdata/test1.src", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest1.src?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "2e1a9fa8f5b26dd9891de0a509b7845da93870bc", "filename": "libgo/go/go/typechecker/testdata/test3.src", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest3.src?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "94d3558f9cdb21b10ed81ea3ea6b7aa78b4d76e3", "filename": "libgo/go/go/typechecker/testdata/test4.src", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest4.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest4.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest4.src?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "1b88eb54b85de2e7f1a65e3c7d3b5545f595c481", "filename": "libgo/go/go/typechecker/type.go", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "24480165bde55b028e72f66ef2ed9f82747dc9f8", "filename": "libgo/go/go/typechecker/typechecker.go", "status": "removed", "additions": 0, "deletions": 468, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "4bad4499a47009a9323f2ccf80adf1b0fad0e810", "filename": "libgo/go/go/typechecker/typechecker_test.go", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "81c14a05e57e0ffc5425d870606d4180b4b311fd", "filename": "libgo/go/go/typechecker/universe.go", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "84a1abe27013251a6826f8ca0524486bc9453601", "filename": "libgo/go/go/types/testdata/test0.src", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ftest0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ftest0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ftest0.src?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "2bcbf82a3093c8b85ad00a0cb019ef8b9adf3772", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f480087836ef5d908f6f49cc1639ea720bf1b2a7", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "5efcea8bc16f6a1965323597d15ea4a502067343", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "05ebef195932775e2e99962ef38cc09d05fe4900", "filename": "libgo/go/gob/doc.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdoc.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "6bb5458809876ec3687318e1a5c9eaecf80075a7", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "878d082c948cd00d07b29585b44c536ba3ce0c60", "filename": "libgo/go/gob/encoder.go", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a774438d38854c054f7fef46e6397e079f93b8a7", "filename": "libgo/go/gob/encoder_test.go", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "01addbe2359f6a269f97874b73ff80c1e9157f05", "filename": "libgo/go/gob/gobencdec_test.go", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fgobencdec_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "870101e20ca65c4905fcf8ef2058271acbf93ce5", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e9edc474da51373728a0396d9fd13b414e9569d6", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "582437f7673aa3fab11a37dd908ee66bc1f62778", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "564580c78b250974115e5f557822a5a761481ac9", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e1ec66ff1acb91bb3ae3f701a946d0dc2b882b8d", "filename": "libgo/go/html/render.go", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d166a3b87362db5152ddd70981daa0fccc355868", "filename": "libgo/go/html/render_test.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Frender_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Frender_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2826f95f17f4edc111f8b32ca59f3e7cc6d4f61a", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 436, "deletions": 271, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "310cd97d670893268211c23b96c43996833d45de", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 258, "deletions": 27, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "bf14c04a843b0d3865525d34736c8ad66bd3caf6", "filename": "libgo/go/http/cgi/child.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "ec53ab851baaeeab8bc871baad2bc31e02eb8dba", "filename": "libgo/go/http/cgi/child_test.go", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "9ea4c9d8bf2ededd9393d1ad4372100b13678e05", "filename": "libgo/go/http/cgi/host.go", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "6c0f1a09747304dbd44bc33b5014d7252fadc529", "filename": "libgo/go/http/cgi/host_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "eff9ae288ea4917844091c35df4d02140ae611d3", "filename": "libgo/go/http/chunked.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fchunked.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "3fa4a056ad85ced2c628a46bab1e0a67ef8040f8", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "0ad6cd7c2f3246bbca36347c606c269e30c6a230", "filename": "libgo/go/http/client_test.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "69350143248540db7f7622754aa65dbafdb922be", "filename": "libgo/go/http/cookie.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "5de6aab611fd330f24d02d7a000b0c14e6e52f8f", "filename": "libgo/go/http/cookie_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f78df57710400c1981ebf9bd1708353c3c764e42", "filename": "libgo/go/http/dump.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fdump.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "61dd3fbdc435e47b1d70c8ed41e7dc3d2a15c2d8", "filename": "libgo/go/http/fcgi/child.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Fchild.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "5c8e46bd75a6b4da1d9ae2c32fe0a0aba9b48842", "filename": "libgo/go/http/fcgi/fcgi_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffcgi%2Ffcgi_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "78f3aa2d69dd12fab8a13c7b8b63a028ba7ebb51", "filename": "libgo/go/http/filetransport.go", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffiletransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffiletransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffiletransport.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2634243f7234e039342bad15eea4d9387ba0629c", "filename": "libgo/go/http/filetransport_test.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffiletransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffiletransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffiletransport_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "6d716654a239d1032234ff873506a1ef184dd441", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "aaaa92a2ef7b1f6479e5ad99e1235eb854ab9202", "filename": "libgo/go/http/header.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fheader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "43a48ebbd1ced49e2aaba95caf7942226c56539f", "filename": "libgo/go/http/httptest/server.go", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f73e6c63c567caf53c8b043a91a22163e93f4fb3", "filename": "libgo/go/http/persist.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpersist.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "6d9042aceb629d671d0404b3e8d9dfb7f977e0a9", "filename": "libgo/go/http/readrequest_test.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freadrequest_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "02317e0c41944317e9e0c8afbbe9547dab8d2410", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 148, "deletions": 28, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "175d6f170b831ee3ac7ff51660dfe7c949b46c34", "filename": "libgo/go/http/request_test.go", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "194f6dd213cf2157af66d76e58ca668e5693c25b", "filename": "libgo/go/http/requestwrite_test.go", "status": "modified", "additions": 167, "deletions": 67, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "56c65b53c7a0330f0d11aee4c5046cc14075ccc5", "filename": "libgo/go/http/response.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "86494bf4ae9bd80aad89c0f024bcb5d6458933d5", "filename": "libgo/go/http/response_test.go", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2ff66d5ce55f0d0c6c93b6fe612165049f3b9436", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 229, "deletions": 34, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "9792c60e7b6279a75ebd013b16e71c3bc7f9d414", "filename": "libgo/go/http/server.go", "status": "modified", "additions": 114, "deletions": 108, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserver.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "868a1143fd91ce4a975638de0e3648524afb22bf", "filename": "libgo/go/http/transfer.go", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransfer.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "0914af7e5cfe31d16a3dd30341ec8a79db85fd24", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f3162b9ede43f47fb6bb4a45d17f78deb5bb9af4", "filename": "libgo/go/http/transport_test.go", "status": "modified", "additions": 22, "deletions": 44, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "1ae7d8350150b24f54f9c09ae5e8c5814dbe9a94", "filename": "libgo/go/http/transport_windows.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransport_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fhttp%2Ftransport_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_windows.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "134de5be9915ee82fc4f5d7656ee0b1500fd44d8", "filename": "libgo/go/image/bmp/reader.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "501a882f02ee39915d9fb1a37c4ac7b66da62eb1", "filename": "libgo/go/image/color.go", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fimage%2Fcolor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c39d66d4f0607177b1cf8995dda56a667e07b3/libgo%2Fgo%2Fimage%2Fcolor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor.go?ref=e0c39d66d4f0607177b1cf8995dda56a667e07b3"}, {"sha": "4a0fae5a789f2555390d3fdc8559578aedca0521", "filename": "libgo/go/image/color/color.go", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fcolor%2Fcolor.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "b348c1d1114c34fe32e96eb995c977a7c4bd4e46", "filename": "libgo/go/image/decode_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2be91185af2e384c0a048216cc6a2de97faf0dd2", "filename": "libgo/go/image/draw/bench_test.go", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "65381f72f658e756d7ca0f46b33b67816417b53c", "filename": "libgo/go/image/draw/clip_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fclip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fclip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fclip_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "af02639ccd561793b9109feceeb93d0ccb819598", "filename": "libgo/go/image/draw/draw.go", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "663ab67a1904337c133d23f6c6904d8a81161156", "filename": "libgo/go/image/draw/draw_test.go", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a5a4265e47f0c223ff96bcb845d0e3c1b11837a3", "filename": "libgo/go/image/gif/reader.go", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a0dd930c7c05c28f5badcf776d511cef216a8a0a", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 107, "deletions": 124, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2b3f1493fb872aaba10270bda39f15180876bca6", "filename": "libgo/go/image/image_test.go", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fimage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fimage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "450355efae555ebdb734659af459990fecc0ba04", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "0378252d2fb47766da9b49f78c0682be4817e3da", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "a7ad51d53714922825a255a5065ec9785bb3ee44", "filename": "libgo/go/image/names.go", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fnames.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fnames.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fnames.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "66f1916a6f35acec31e2d58cf849459d721a5956", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 169, "deletions": 178, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "48d06130e3788091746a04df30d20a88bb1f7bc0", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e5be4086cb2f218e53a3296144d4f3f891e80012", "filename": "libgo/go/image/png/testdata/invalid-crc32.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-crc32.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-crc32.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-crc32.png?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "9137270d9c3a4b2d2590e6aa658c33e86510aa98", "filename": "libgo/go/image/png/testdata/invalid-noend.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-noend.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-noend.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-noend.png?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d0748cf654156df837b1042f514492e30cd2fa67", "filename": "libgo/go/image/png/testdata/invalid-trunc.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-trunc.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-trunc.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-trunc.png?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "c6d051caee0ac07a873d0e0ff7c078fd2235b266", "filename": "libgo/go/image/png/testdata/invalid-zlib.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-zlib.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-zlib.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Finvalid-zlib.png?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "b6103c6d0e56842f75c77ba2e4f5ee42075b8f88", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e517173c3e16faef343e5393cd6f2c006cc52b8d", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "e89aa6d7ac33a225f4ef6f6c9bfb94bff25b991b", "filename": "libgo/go/image/tiff/compress.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "c452f5d54ccf2f514c3c4ff2222ce8606692b729", "filename": "libgo/go/image/tiff/reader.go", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "86b7dc3761939b7c7e13f66946ed016465cea446", "filename": "libgo/go/image/tiff/reader_test.go", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "137a0c3ef1f669b7c51a5d437160e6784675e68c", "filename": "libgo/go/image/tiff/testdata/bw-deflate.tiff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-deflate.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-deflate.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-deflate.tiff?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d59fa4aeed32c855d74bec465904dd7474243fd0", "filename": "libgo/go/image/tiff/testdata/bw-packbits.tiff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-packbits.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-packbits.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-packbits.tiff?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "8390f11357f9c3b38464b17a08d4cdd111b7d5ce", "filename": "libgo/go/image/tiff/testdata/bw-uncompressed.tiff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-uncompressed.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-uncompressed.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-uncompressed.tiff?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "fad147107b25464111b7b34d7728e99f84fe522a", "filename": "libgo/go/image/tiff/testdata/video-001-uncompressed.tiff", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fvideo-001-uncompressed.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fvideo-001-uncompressed.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fvideo-001-uncompressed.tiff?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "84a35a3fb5eb94848a13c9654362f4e11c261070", "filename": "libgo/go/image/ycbcr/ycbcr.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fycbcr%2Fycbcr.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "c69be43c2ac8a76db759e381605e229d5bc18eb7", "filename": "libgo/go/index/suffixarray/qsufsort.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "174460cab8607f01677186b62df21dac84d87fa4", "filename": "libgo/go/index/suffixarray/suffixarray.go", "status": "modified", "additions": 129, "deletions": 2, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f6b2f00fb7d8eb53d0a7920dbe50a3b8600ec0f3", "filename": "libgo/go/index/suffixarray/suffixarray_test.go", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "55206348e42cddb25b8febe5f9ea4c9842264849", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f1b23e9461bbe1d7d3c56ddb2910a1b6567c6c22", "filename": "libgo/go/io/io_test.go", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fio%2Fio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fio%2Fio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "dd50d96869eb0a2da0661861ce01db96be6ecb00", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "31b15a400dfc3623bd363615853b68dcd928e38d", "filename": "libgo/go/json/decode.go", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2c7cbc4a290e28f7e2f60d2022fa8945a072cba4", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "46abe4360ed6c59d12baf8df4507ba16abd132e0", "filename": "libgo/go/json/encode.go", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "f85bb6216a276051f299570ae954a0ac90c62a78", "filename": "libgo/go/json/encode_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "2a7530373081c94332db7b320fab4a2bf82e5197", "filename": "libgo/go/json/indent.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Findent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Findent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Findent.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "4d73eac8aaaedd6ed21cb310f664588a3c3e61df", "filename": "libgo/go/json/scanner_test.go", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "ce5a7e6d65625ea52b0d5c340833eb30e83d5372", "filename": "libgo/go/json/stream_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fstream_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "5653647b8cce0fc7d25d2fccd05929c881d48e37", "filename": "libgo/go/mail/message_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmail%2Fmessage_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmail%2Fmessage_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmail%2Fmessage_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "eb3e4c72b32914654d17981b24a4bac4de5ca901", "filename": "libgo/go/math/abs.go", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fabs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fabs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fabs.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/math/fabs.go"}, {"sha": "6be9305ac509222980004165f6c1928ca1e8cc7e", "filename": "libgo/go/math/abs_decl.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fabs_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fabs_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fabs_decl.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "94ddea2bfcbbd7128e7c11d8f2b0dfcefdf56496", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "1cf60ce7df29c49e7a1c9cb21563917255faf12a", "filename": "libgo/go/math/bits.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fbits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fbits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbits.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559"}, {"sha": "d2eb52f3bf1d331c7f916aafb38fa7cc12968bd5", "filename": "libgo/go/math/dim.go", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fdim.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f412571f8768df2d3239e72392dfeabbad1559/libgo%2Fgo%2Fmath%2Fdim.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fdim.go?ref=d8f412571f8768df2d3239e72392dfeabbad1559", "previous_filename": "libgo/go/math/fdim.go"}]}