{"sha": "2bbf216f5ecb8c1fed98a09778541778fca672d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiZjIxNmY1ZWNiOGMxZmVkOThhMDk3Nzg1NDE3NzhmY2E2NzJkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-03T15:48:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-03T15:48:39Z"}, "message": "(expand_builtin_return_addr): Break out functionality from expand_builtin.\n\n(expand_builtin): Call expand_builtin_return_addr.\n\nFrom-SVN: r10418", "tree": {"sha": "b46b12b97c4c18fac5c7d836d290f833b287ffee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b46b12b97c4c18fac5c7d836d290f833b287ffee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bbf216f5ecb8c1fed98a09778541778fca672d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbf216f5ecb8c1fed98a09778541778fca672d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bbf216f5ecb8c1fed98a09778541778fca672d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bbf216f5ecb8c1fed98a09778541778fca672d7/comments", "author": null, "committer": null, "parents": [{"sha": "cbbb4649a507b31847142cce680b5a2f6bd5f638", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbbb4649a507b31847142cce680b5a2f6bd5f638", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbbb4649a507b31847142cce680b5a2f6bd5f638"}], "stats": {"total": 98, "additions": 57, "deletions": 41}, "files": [{"sha": "d09e6fae418e4fdc683aa27327161959bd6c4e0b", "filename": "gcc/expr.c", "status": "modified", "additions": 57, "deletions": 41, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bbf216f5ecb8c1fed98a09778541778fca672d7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bbf216f5ecb8c1fed98a09778541778fca672d7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2bbf216f5ecb8c1fed98a09778541778fca672d7", "patch": "@@ -7131,6 +7131,57 @@ c_strlen (src)\n      calculation is needed.  */\n   return size_int (strlen (ptr + offset));\n }\n+\n+rtx\n+expand_builtin_return_addr (fndecl_code, count, tem)\n+     enum built_in_function fndecl_code;\n+     rtx tem;\n+     int count;\n+{\n+  int i;\n+\n+  /* Some machines need special handling before we can access\n+     arbitrary frames.  For example, on the sparc, we must first flush\n+     all register windows to the stack.  */\n+#ifdef SETUP_FRAME_ADDRESSES\n+  SETUP_FRAME_ADDRESSES ();\n+#endif\n+\n+  /* On the sparc, the return address is not in the frame, it is in a\n+     register.  There is no way to access it off of the current frame\n+     pointer, but it can be accessed off the previous frame pointer by\n+     reading the value from the register window save area.  */\n+#ifdef RETURN_ADDR_IN_PREVIOUS_FRAME\n+  if (fndecl_code == BUILT_IN_RETURN_ADDRESS)\n+    count--;\n+#endif\n+\n+  /* Scan back COUNT frames to the specified frame.  */\n+  for (i = 0; i < count; i++)\n+    {\n+      /* Assume the dynamic chain pointer is in the word that the\n+\t frame address points to, unless otherwise specified.  */\n+#ifdef DYNAMIC_CHAIN_ADDRESS\n+      tem = DYNAMIC_CHAIN_ADDRESS (tem);\n+#endif\n+      tem = memory_address (Pmode, tem);\n+      tem = copy_to_reg (gen_rtx (MEM, Pmode, tem));\n+    }\n+\n+  /* For __builtin_frame_address, return what we've got.  */\n+  if (fndecl_code == BUILT_IN_FRAME_ADDRESS)\n+    return tem;\n+\n+  /* For __builtin_return_address, Get the return address from that\n+     frame.  */\n+#ifdef RETURN_ADDR_RTX\n+  tem = RETURN_ADDR_RTX (count, tem);\n+#else\n+  tem = memory_address (Pmode,\n+\t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n+  tem = gen_rtx (MEM, Pmode, tem);\n+#endif\n+}\n \f\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -7572,52 +7623,17 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t}\n       else\n \t{\n-\t  int count = TREE_INT_CST_LOW (TREE_VALUE (arglist)); \n-\t  rtx tem = frame_pointer_rtx;\n-\t  int i;\n-\n-\t  /* Some machines need special handling before we can access arbitrary\n-\t     frames.  For example, on the sparc, we must first flush all\n-\t     register windows to the stack.  */\n-#ifdef SETUP_FRAME_ADDRESSES\n-\t  SETUP_FRAME_ADDRESSES ();\n-#endif\n-\n-\t  /* On the sparc, the return address is not in the frame, it is\n-\t     in a register.  There is no way to access it off of the current\n-\t     frame pointer, but it can be accessed off the previous frame\n-\t     pointer by reading the value from the register window save\n-\t     area.  */\n-#ifdef RETURN_ADDR_IN_PREVIOUS_FRAME\n-\t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_RETURN_ADDRESS)\n-\t    count--;\n-#endif\n-\n-\t  /* Scan back COUNT frames to the specified frame.  */\n-\t  for (i = 0; i < count; i++)\n-\t    {\n-\t      /* Assume the dynamic chain pointer is in the word that\n-\t\t the frame address points to, unless otherwise specified.  */\n-#ifdef DYNAMIC_CHAIN_ADDRESS\n-\t      tem = DYNAMIC_CHAIN_ADDRESS (tem);\n-#endif\n-\t      tem = memory_address (Pmode, tem);\n-\t      tem = copy_to_reg (gen_rtx (MEM, Pmode, tem));\n-\t    }\n+\t  rtx tem = expand_builtin_return_addr (DECL_FUNCTION_CODE (fndecl),\n+\t\t\t\t\t\tTREE_INT_CST_LOW (TREE_VALUE (arglist)),\n+\t\t\t\t\t\thard_frame_pointer_rtx);\n \n \t  /* For __builtin_frame_address, return what we've got.  */\n \t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n \t    return tem;\n \n-\t  /* For __builtin_return_address,\n-\t     Get the return address from that frame.  */\n-#ifdef RETURN_ADDR_RTX\n-\t  return RETURN_ADDR_RTX (count, tem);\n-#else\n-\t  tem = memory_address (Pmode,\n-\t\t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n-\t  return copy_to_reg (gen_rtx (MEM, Pmode, tem));\n-#endif\n+\t  if (GET_CODE (tem) != REG)\n+\t    tem = copy_to_reg (tem);\n+\t  return tem;\n \t}\n \n     case BUILT_IN_ALLOCA:"}]}