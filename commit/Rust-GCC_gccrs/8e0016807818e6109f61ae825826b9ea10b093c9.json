{"sha": "8e0016807818e6109f61ae825826b9ea10b093c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUwMDE2ODA3ODE4ZTYxMDlmNjFhZTgyNTgyNmI5ZWExMGIwOTNjOQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2009-04-29T17:36:21Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-04-29T17:36:21Z"}, "message": "re PR middle-end/39927 (build breakage for cris-elf building libstdc++-v3)\n\n        PR middle-end/39927\n        PR bootstrap/39929\n        * tree-outof-ssa.c (emit_partition_copy): New function.\n        (insert_partition_copy_on_edge, insert_rtx_to_part_on_edge,\n        insert_part_to_rtx_on_edge): Perform the partition base var\n        copy using emit_partition_copy.\n        (insert_value_copy_on_edge): Convert constants to the right mode.\n        (insert_rtx_to_part_on_edge): Add UNSIGNEDSRCP parameter.\n        (elim_create): Pass the sign of the src to insert_rtx_to_part_on_edge.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\n\nFrom-SVN: r146982", "tree": {"sha": "33196b5468666455d2b648d6908acb8afa60da98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33196b5468666455d2b648d6908acb8afa60da98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e0016807818e6109f61ae825826b9ea10b093c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e0016807818e6109f61ae825826b9ea10b093c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e0016807818e6109f61ae825826b9ea10b093c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e0016807818e6109f61ae825826b9ea10b093c9/comments", "author": null, "committer": null, "parents": [{"sha": "4e5d521bb552991496445f0303ef84a95f67ba41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e5d521bb552991496445f0303ef84a95f67ba41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e5d521bb552991496445f0303ef84a95f67ba41"}], "stats": {"total": 72, "additions": 53, "deletions": 19}, "files": [{"sha": "47978bf9ad6255a8ca041126707f81a31cdb1efb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e0016807818e6109f61ae825826b9ea10b093c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e0016807818e6109f61ae825826b9ea10b093c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e0016807818e6109f61ae825826b9ea10b093c9", "patch": "@@ -1,3 +1,16 @@\n+2009-04-29  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\t    Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/39927\n+\tPR bootstrap/39929\n+\t* tree-outof-ssa.c (emit_partition_copy): New function.\n+\t(insert_partition_copy_on_edge, insert_rtx_to_part_on_edge,\n+\tinsert_part_to_rtx_on_edge): Perform the partition base var\n+\tcopy using emit_partition_copy.\n+\t(insert_value_copy_on_edge): Convert constants to the right mode.\n+\t(insert_rtx_to_part_on_edge): Add UNSIGNEDSRCP parameter.\n+\t(elim_create): Pass the sign of the src to insert_rtx_to_part_on_edge.\n+\n 2009-04-29  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (bfin_optimize_loop): If we need a scratch reg,"}, {"sha": "50d3089340a3c1922e0d021ad0ea4af6823c1849", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e0016807818e6109f61ae825826b9ea10b093c9/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e0016807818e6109f61ae825826b9ea10b093c9/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=8e0016807818e6109f61ae825826b9ea10b093c9", "patch": "@@ -128,6 +128,25 @@ set_location_for_edge (edge e)\n     }\n }\n \n+/* Emit insns to copy SRC into DEST converting SRC if necessary.  */\n+\n+static inline rtx\n+emit_partition_copy (rtx dest, rtx src, int unsignedsrcp)\n+{\n+  rtx seq;\n+\n+  start_sequence ();\n+\n+  if (GET_MODE (src) != VOIDmode && GET_MODE (src) != GET_MODE (dest))\n+    src = convert_to_mode (GET_MODE (dest), src, unsignedsrcp);\n+  emit_move_insn (dest, src);\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  return seq;\n+}\n+\n /* Insert a copy instruction from partition SRC to DEST onto edge E.  */\n \n static void\n@@ -149,12 +168,10 @@ insert_partition_copy_on_edge (edge e, int dest, int src)\n \n   set_location_for_edge (e);\n \n-  /* Partition copy between same base variables only, so it's the same mode,\n-     hence we can use emit_move_insn.  */\n-  start_sequence ();\n-  emit_move_insn (SA.partition_to_pseudo[dest], SA.partition_to_pseudo[src]);\n-  seq = get_insns ();\n-  end_sequence ();\n+  seq = emit_partition_copy (SA.partition_to_pseudo[dest],\n+\t\t\t     SA.partition_to_pseudo[src],\n+\t\t\t     TYPE_UNSIGNED (TREE_TYPE (\n+\t\t\t       partition_to_var (SA.map, src))));\n \n   insert_insn_on_edge (seq, e);\n }\n@@ -186,6 +203,10 @@ insert_value_copy_on_edge (edge e, int dest, tree src)\n   x = expand_expr (src, SA.partition_to_pseudo[dest], mode, EXPAND_NORMAL);\n   if (GET_MODE (x) != VOIDmode && GET_MODE (x) != mode)\n     x = convert_to_mode (mode, x, TYPE_UNSIGNED (TREE_TYPE (src)));\n+  if (CONSTANT_P (x) && GET_MODE (x) == VOIDmode\n+      && mode != TYPE_MODE (TREE_TYPE (src)))\n+    x = convert_modes (mode, TYPE_MODE (TREE_TYPE (src)),\n+\t\t\t  x, TYPE_UNSIGNED (TREE_TYPE (src)));\n   if (x != SA.partition_to_pseudo[dest])\n     emit_move_insn (SA.partition_to_pseudo[dest], x);\n   seq = get_insns ();\n@@ -198,7 +219,7 @@ insert_value_copy_on_edge (edge e, int dest, tree src)\n    onto edge E.  */\n \n static void\n-insert_rtx_to_part_on_edge (edge e, int dest, rtx src)\n+insert_rtx_to_part_on_edge (edge e, int dest, rtx src, int unsignedsrcp)\n {\n   rtx seq;\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -214,11 +235,9 @@ insert_rtx_to_part_on_edge (edge e, int dest, rtx src)\n   gcc_assert (SA.partition_to_pseudo[dest]);\n   set_location_for_edge (e);\n \n-  start_sequence ();\n-  gcc_assert (GET_MODE (src) == GET_MODE (SA.partition_to_pseudo[dest]));\n-  emit_move_insn (SA.partition_to_pseudo[dest], src);\n-  seq = get_insns ();\n-  end_sequence ();\n+  seq = emit_partition_copy (SA.partition_to_pseudo[dest],\n+\t\t\t     src,\n+\t\t\t     unsignedsrcp);\n \n   insert_insn_on_edge (seq, e);\n }\n@@ -243,11 +262,10 @@ insert_part_to_rtx_on_edge (edge e, rtx dest, int src)\n   gcc_assert (SA.partition_to_pseudo[src]);\n   set_location_for_edge (e);\n \n-  start_sequence ();\n-  gcc_assert (GET_MODE (dest) == GET_MODE (SA.partition_to_pseudo[src]));\n-  emit_move_insn (dest, SA.partition_to_pseudo[src]);\n-  seq = get_insns ();\n-  end_sequence ();\n+  seq = emit_partition_copy (dest,\n+\t\t\t     SA.partition_to_pseudo[src],\n+\t\t\t     TYPE_UNSIGNED (TREE_TYPE (\n+\t\t\t       partition_to_var (SA.map, src))));\n \n   insert_insn_on_edge (seq, e);\n }\n@@ -522,14 +540,17 @@ elim_create (elim_graph g, int T)\n \n   if (elim_unvisited_predecessor (g, T))\n     {\n-      rtx U = get_temp_reg (partition_to_var (g->map, T));\n+      tree var = partition_to_var (g->map, T);\n+      rtx U = get_temp_reg (var);\n+      int unsignedsrcp = TYPE_UNSIGNED (TREE_TYPE (var));\n+\n       insert_part_to_rtx_on_edge (g->e, U, T);\n       FOR_EACH_ELIM_GRAPH_PRED (g, T, P, \n \t{\n \t  if (!TEST_BIT (g->visited, P))\n \t    {\n \t      elim_backward (g, P);\n-\t      insert_rtx_to_part_on_edge (g->e, P, U);\n+\t      insert_rtx_to_part_on_edge (g->e, P, U, unsignedsrcp);\n \t    }\n \t});\n     }"}]}