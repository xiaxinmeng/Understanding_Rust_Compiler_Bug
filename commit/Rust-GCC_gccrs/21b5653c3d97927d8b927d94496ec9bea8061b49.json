{"sha": "21b5653c3d97927d8b927d94496ec9bea8061b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFiNTY1M2MzZDk3OTI3ZDhiOTI3ZDk0NDk2ZWM5YmVhODA2MWI0OQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-08-18T22:23:57Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-08-18T22:23:57Z"}, "message": "arm.c (arm_size_rtx_costs): New function.\n\n* arm.c (arm_size_rtx_costs): New function.\n(arm_override_options): Use it if optimizing for space.\n\nFrom-SVN: r86211", "tree": {"sha": "bd96d359a55306becfc9b9e862820566b99ff830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd96d359a55306becfc9b9e862820566b99ff830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21b5653c3d97927d8b927d94496ec9bea8061b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b5653c3d97927d8b927d94496ec9bea8061b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b5653c3d97927d8b927d94496ec9bea8061b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b5653c3d97927d8b927d94496ec9bea8061b49/comments", "author": null, "committer": null, "parents": [{"sha": "542a8afa8a40e0714720ce168046a3880a44d311", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542a8afa8a40e0714720ce168046a3880a44d311", "html_url": "https://github.com/Rust-GCC/gccrs/commit/542a8afa8a40e0714720ce168046a3880a44d311"}], "stats": {"total": 234, "additions": 232, "deletions": 2}, "files": [{"sha": "d781d3e966a2e372aa2a766c584bedb78f93c403", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b5653c3d97927d8b927d94496ec9bea8061b49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b5653c3d97927d8b927d94496ec9bea8061b49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21b5653c3d97927d8b927d94496ec9bea8061b49", "patch": "@@ -1,3 +1,8 @@\n+2004-08-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_size_rtx_costs): New function.\n+\t(arm_override_options): Use it if optimizing for space.\n+\n 2004-08-18  Richard Henderson  <rth@redhat.com>\n \n \t* emit-rtl.c (gen_const_mem): New."}, {"sha": "bcb3c533f7231a64ee415b3b5eb7b8a7337208ba", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 227, "deletions": 2, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b5653c3d97927d8b927d94496ec9bea8061b49/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b5653c3d97927d8b927d94496ec9bea8061b49/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=21b5653c3d97927d8b927d94496ec9bea8061b49", "patch": "@@ -127,6 +127,7 @@ static void arm_internal_label (FILE *, const char *, unsigned long);\n static void arm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t tree);\n static int arm_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n+static bool arm_size_rtx_costs (rtx, int, int, int *);\n static bool arm_slowmul_rtx_costs (rtx, int, int, int *);\n static bool arm_fastmul_rtx_costs (rtx, int, int, int *);\n static bool arm_xscale_rtx_costs (rtx, int, int, int *);\n@@ -870,7 +871,10 @@ arm_override_options (void)\n     abort ();\n   \n   tune_flags = all_cores[(int)arm_tune].flags;\n-  targetm.rtx_costs = all_cores[(int)arm_tune].rtx_costs;\n+  if (optimize_size)\n+    targetm.rtx_costs = arm_size_rtx_costs;\n+  else\n+    targetm.rtx_costs = all_cores[(int)arm_tune].rtx_costs;\n \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n@@ -3938,6 +3942,227 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n     }\n }\n \n+/* RTX costs when optimizing for size.  */\n+static bool\n+arm_size_rtx_costs (rtx x, int code, int outer_code, int *total)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (TARGET_THUMB)\n+    {\n+      /* XXX TBD.  For now, use the standard costs.  */\n+      *total = thumb_rtx_costs (x, code, outer_code);\n+      return true;\n+    }\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      /* A memory access costs 1 insn if the mode is small, or the address is \n+\t a single register, otherwise it costs one insn per word.  */\n+      if (REG_P (XEXP (x, 0)))\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      /* Needs a libcall, so it costs about this.  */\n+      *total = COSTS_N_INSNS (2);\n+      return false;\n+\n+    case ROTATE:\n+      if (mode == SImode && GET_CODE (XEXP (x, 1)) == REG)\n+\t{\n+\t  *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), code);\n+\t  return true;\n+\t}\n+      /* Fall through */\n+    case ROTATERT:\n+    case ASHIFT:\n+    case LSHIFTRT:\n+    case ASHIFTRT:\n+      if (mode == DImode && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  *total = COSTS_N_INSNS (3) + rtx_cost (XEXP (x, 0), code);\n+\t  return true;\n+\t}\n+      else if (mode == SImode)\n+\t{\n+\t  *total = COSTS_N_INSNS (1) + rtx_cost (XEXP (x, 0), code);\n+\t  /* Slightly disparage register shifts, but not by much.  */\n+\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t    *total += 1 + rtx_cost (XEXP (x, 1), code);\n+\t  return true;\n+\t}\n+\n+      /* Needs a libcall.  */\n+      *total = COSTS_N_INSNS (2);\n+      return false;\n+\n+    case MINUS:\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n+\n+      if (mode == SImode)\n+\t{\n+\t  enum rtx_code subcode0 = GET_CODE (XEXP (x, 0));\n+\t  enum rtx_code subcode1 = GET_CODE (XEXP (x, 1));\n+\n+\t  if (subcode0 == ROTATE || subcode0 == ROTATERT || subcode0 == ASHIFT\n+\t      || subcode0 == LSHIFTRT || subcode0 == ASHIFTRT\n+\t      || subcode1 == ROTATE || subcode1 == ROTATERT\n+\t      || subcode1 == ASHIFT || subcode1 == LSHIFTRT\n+\t      || subcode1 == ASHIFTRT)\n+\t    {\n+\t      /* It's just the cost of the two operands.  */\n+\t      *total = 0;\n+\t      return false;\n+\t    }\n+\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n+\n+      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n+      return false;\n+\n+    case PLUS: \n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return false;\n+\t}\n+\n+      /* Fall through */\n+    case AND: case XOR: case IOR:\n+      if (mode == SImode)\n+\t{\n+\t  enum rtx_code subcode = GET_CODE (XEXP (x, 0));\n+\n+\t  if (subcode == ROTATE || subcode == ROTATERT || subcode == ASHIFT\n+\t      || subcode == LSHIFTRT || subcode == ASHIFTRT\n+\t      || (code == AND && subcode == NOT))\n+\t    {\n+\t      /* It's just the cost of the two operands.  */\n+\t      *total = 0;\n+\t      return false;\n+\t    }\n+\t}\n+\n+      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n+      return false;\n+\n+    case MULT:\n+      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n+      return false;\n+\n+    case NEG:\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t*total = COSTS_N_INSNS (1);\n+      /* Fall through */\n+    case NOT:\n+      *total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n+\n+      return false;\n+\n+    case IF_THEN_ELSE:\n+      *total = 0;\n+      return false;\n+\n+    case COMPARE:\n+      if (cc_register (XEXP (x, 0), VOIDmode))\n+\t* total = 0;\n+      else\n+\t*total = COSTS_N_INSNS (1);\n+      return false;\n+\n+    case ABS:\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t*total = COSTS_N_INSNS (1);\n+      else\n+\t*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));\n+      return false;\n+\n+    case SIGN_EXTEND:\n+      *total = 0;\n+      if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) < 4)\n+\t{\n+\t  if (!(arm_arch4 && MEM_P (XEXP (x, 0))))\n+\t    *total += COSTS_N_INSNS (arm_arch6 ? 1 : 2);\n+\t}\n+      if (mode == DImode)\n+\t*total += COSTS_N_INSNS (1);\n+      return false;\n+\n+    case ZERO_EXTEND:\n+      *total = 0;\n+      if (!(arm_arch4 && MEM_P (XEXP (x, 0))))\n+\t{\n+\t  switch (GET_MODE (XEXP (x, 0)))\n+\t    {\n+\t    case QImode:\n+\t      *total += COSTS_N_INSNS (1);\n+\t      break;\n+\n+\t    case HImode:\n+\t      *total += COSTS_N_INSNS (arm_arch6 ? 1 : 2);\n+\t      \n+\t    case SImode:\n+\t      break;\n+\n+\t    default:\n+\t      *total += COSTS_N_INSNS (2);\n+\t    }\n+\t}\n+\n+      if (mode == DImode)\n+\t*total += COSTS_N_INSNS (1);\n+\n+      return false;\n+\n+    case CONST_INT:\t\t\t\t\t\t\n+      if (const_ok_for_arm (INTVAL (x)))\t\t\t\n+\t*total = COSTS_N_INSNS (outer_code == SET ? 1 : 0);\n+      else if (const_ok_for_arm (~INTVAL (x)))\n+\t*total = COSTS_N_INSNS (outer_code == AND ? 0 : 1);\n+      else if (const_ok_for_arm (-INTVAL (x)))\n+\t{\n+\t  if (outer_code == COMPARE || outer_code == PLUS\n+\t      || outer_code == MINUS)\n+\t    *total = 0;\n+\t  else\n+\t    *total = COSTS_N_INSNS (1);\n+\t}\n+      else\n+\t*total = COSTS_N_INSNS (2);\n+      return true;\n+      \n+    case CONST: \t\t\t\t\t\t\t\n+    case LABEL_REF:\t\t\t\t\t\t\n+    case SYMBOL_REF:\t\t\t\t\t\t\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+      \n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    default:\n+      if (mode != VOIDmode)\n+\t*total = COSTS_N_INSNS (ARM_NUM_REGS (mode));\n+      else\n+\t*total = COSTS_N_INSNS (4); /* How knows?  */\n+      return false;\n+    }\n+}\n+\n /* RTX costs for cores with a slow MUL implementation.  */\n \n static bool\n@@ -11581,7 +11806,7 @@ arm_final_prescan_insn (rtx insn)\n }\n \n /* Returns true if REGNO is a valid register\n-   for holding a quantity of tyoe MODE.  */\n+   for holding a quantity of type MODE.  */\n int\n arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {"}]}