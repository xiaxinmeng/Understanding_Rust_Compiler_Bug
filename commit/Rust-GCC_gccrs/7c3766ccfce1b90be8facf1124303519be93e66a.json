{"sha": "7c3766ccfce1b90be8facf1124303519be93e66a", "node_id": "C_kwDOANBUbNoAKDdjMzc2NmNjZmNlMWI5MGJlOGZhY2YxMTI0MzAzNTE5YmU5M2U2NmE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-08-10T10:03:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-10T10:03:11Z"}, "message": "Merge #1454\n\n1454: intrinsics: Refactor compilation of intrinsics r=CohenArthur a=CohenArthur\n\nThis commit adds helpers around caching, compiling and using intrinsic\r\nfunctions before extending them with instructions specific to the\r\nintrinsic. We can refactor them further, but this is already a bit\r\neasier to deal with when writing new intrinsics\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "c2d64937915cbe773d50ec2cf485379ec8d7fb9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2d64937915cbe773d50ec2cf485379ec8d7fb9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c3766ccfce1b90be8facf1124303519be93e66a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi84JfCRBK7hj4Ov3rIwAAcDoIAKRwGhky1o3T9Za/Z+DKn4XV\n/AO4O2yMWcsvq9HyBmx3VEDhbTcsCZnhtqCxiHr/ERoxY6ANMhxILppsyqqHKZTd\nAVlBNfiscUgRemUOuc8qbZMwqebtHdmgUZeIYwx+J274PcNhi3i6wD7tvkFQ3i93\nsjj3OWN1ncjSsqJOlA1ZNqG0uQVqovDos7gU1rKdiKuBhHi3iN31ZurAHHt3W9to\nPBGPBUKhj+s1zjpVDUYc7wOyBRusxiwyLz5BspXRMXrz2h+BoEYVObetGU19vUVC\n3/AoXDhnquWYeJ/UAyVToFZeG2pdpICOWibo1eWgn1JZINAfR8n+Xfcou81r/Mw=\n=A9PT\n-----END PGP SIGNATURE-----\n", "payload": "tree c2d64937915cbe773d50ec2cf485379ec8d7fb9a\nparent 349b0f8ed4564fff88fc28bab0733657f2621780\nparent fc8d5dfe93e80e6d5033dc44ed3eb8220764d8f9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1660125791 +0000\ncommitter GitHub <noreply@github.com> 1660125791 +0000\n\nMerge #1454\n\n1454: intrinsics: Refactor compilation of intrinsics r=CohenArthur a=CohenArthur\n\nThis commit adds helpers around caching, compiling and using intrinsic\r\nfunctions before extending them with instructions specific to the\r\nintrinsic. We can refactor them further, but this is already a bit\r\neasier to deal with when writing new intrinsics\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3766ccfce1b90be8facf1124303519be93e66a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3766ccfce1b90be8facf1124303519be93e66a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3766ccfce1b90be8facf1124303519be93e66a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "349b0f8ed4564fff88fc28bab0733657f2621780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/349b0f8ed4564fff88fc28bab0733657f2621780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/349b0f8ed4564fff88fc28bab0733657f2621780"}, {"sha": "fc8d5dfe93e80e6d5033dc44ed3eb8220764d8f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8d5dfe93e80e6d5033dc44ed3eb8220764d8f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc8d5dfe93e80e6d5033dc44ed3eb8220764d8f9"}], "stats": {"total": 428, "additions": 151, "deletions": 277}, "files": [{"sha": "a68ccc56a13d2ab6eb8d2eb8509a88010c5aef22", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 129, "deletions": 277, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3766ccfce1b90be8facf1124303519be93e66a/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3766ccfce1b90be8facf1124303519be93e66a/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=7c3766ccfce1b90be8facf1124303519be93e66a", "patch": "@@ -30,31 +30,32 @@ namespace Rust {\n namespace Compile {\n \n static tree\n-offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+offset_handler (Context *ctx, TyTy::FnType *fntype);\n static tree\n-sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+sizeof_handler (Context *ctx, TyTy::FnType *fntype);\n static tree\n-transmute_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n+transmute_handler (Context *ctx, TyTy::FnType *fntype);\n static tree\n-rotate_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype, tree_code op);\n+rotate_handler (Context *ctx, TyTy::FnType *fntype, tree_code op);\n+\n static inline tree\n-rotate_left_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype)\n+rotate_left_handler (Context *ctx, TyTy::FnType *fntype)\n {\n-  return rotate_intrinsic_handler (ctx, fntype, LROTATE_EXPR);\n+  return rotate_handler (ctx, fntype, LROTATE_EXPR);\n }\n static inline tree\n-rotate_right_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype)\n+rotate_right_handler (Context *ctx, TyTy::FnType *fntype)\n {\n-  return rotate_intrinsic_handler (ctx, fntype, RROTATE_EXPR);\n+  return rotate_handler (ctx, fntype, RROTATE_EXPR);\n }\n \n static const std::map<std::string,\n-\t\t      std::function<tree (Context *, TyTy::BaseType *)>>\n-  generic_intrinsics = {{\"offset\", &offset_intrinsic_handler},\n-\t\t\t{\"size_of\", &sizeof_intrinsic_handler},\n-\t\t\t{\"transmute\", &transmute_intrinsic_handler},\n-\t\t\t{\"rotate_left\", &rotate_left_intrinsic_handler},\n-\t\t\t{\"rotate_right\", &rotate_right_intrinsic_handler}};\n+\t\t      std::function<tree (Context *, TyTy::FnType *)>>\n+  generic_intrinsics = {{\"offset\", &offset_handler},\n+\t\t\t{\"size_of\", &sizeof_handler},\n+\t\t\t{\"transmute\", &transmute_handler},\n+\t\t\t{\"rotate_left\", &rotate_left_handler},\n+\t\t\t{\"rotate_right\", &rotate_right_handler}};\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n@@ -80,44 +81,70 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   return error_mark_node;\n }\n \n-static tree\n-offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n+/**\n+ * Items can be forward compiled which means we may not need to invoke this\n+ * code. We might also have already compiled this generic function as well.\n+ */\n+static bool\n+check_for_cached_intrinsic (Context *ctx, TyTy::FnType *fntype, tree *lookup)\n {\n-  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n-\n-  // items can be forward compiled which means we may not need to invoke this\n-  // code. We might also have already compiled this generic function as well.\n-  tree lookup = NULL_TREE;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), lookup,\n \t\t\t\t fntype->get_id (), fntype))\n     {\n-      // has this been added to the list then it must be finished\n-      if (ctx->function_completed (lookup))\n+      // Has this been added to the list? Then it must be finished\n+      if (ctx->function_completed (*lookup))\n \t{\n \t  tree dummy = NULL_TREE;\n \t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t    {\n-\t      ctx->insert_function_decl (fntype, lookup);\n-\t    }\n-\t  return lookup;\n+\t    ctx->insert_function_decl (fntype, *lookup);\n+\t  return true;\n \t}\n     }\n \n+  return false;\n+}\n+\n+/**\n+ * Maybe override the Hir Lookups for the substituions in this context\n+ */\n+static void\n+maybe_override_ctx (TyTy::FnType *fntype)\n+{\n   if (fntype->has_subsititions_defined ())\n-    {\n-      // override the Hir Lookups for the substituions in this context\n-      fntype->override_context ();\n-    }\n+    fntype->override_context ();\n+}\n \n-  // offset intrinsic has two params dst pointer and offset isize\n-  if (fntype->get_params ().size () != 2)\n+/**\n+ * Compile and setup a function's parameters\n+ */\n+static void\n+compile_fn_params (Context *ctx, TyTy::FnType *fntype, tree fndecl,\n+\t\t   std::vector<Bvariable *> *compiled_param_variables,\n+\t\t   std::vector<tree_node *> *compiled_param_types = nullptr)\n+{\n+  for (auto &parm : fntype->get_params ())\n     {\n-      rust_error_at (fntype->get_ident ().locus,\n-\t\t     \"invalid number of parameters for offset intrinsic\");\n-      return error_mark_node;\n+      auto &referenced_param = parm.first;\n+      auto &param_tyty = parm.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param->get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      compiled_param_variables->push_back (compiled_param_var);\n+      if (compiled_param_types)\n+\tcompiled_param_types->push_back (compiled_param_type);\n     }\n+}\n+\n+static tree\n+compile_intrinsic_function (Context *ctx, TyTy::FnType *fntype)\n+{\n+  maybe_override_ctx (fntype);\n+\n+  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n \n   tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n   std::string ir_symbol_name\n@@ -128,41 +155,57 @@ offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n   tree fndecl\n     = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n \t\t\t\t     flags, fntype->get_ident ().locus);\n+\n   TREE_PUBLIC (fndecl) = 0;\n   TREE_READONLY (fndecl) = 1;\n   DECL_ARTIFICIAL (fndecl) = 1;\n   DECL_EXTERNAL (fndecl) = 0;\n   DECL_DECLARED_INLINE_P (fndecl) = 1;\n \n-  // setup the params\n-  std::vector<Bvariable *> param_vars;\n-  for (auto &parm : fntype->get_params ())\n-    {\n-      auto &referenced_param = parm.first;\n-      auto &param_tyty = parm.second;\n-      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+  return fndecl;\n+}\n \n-      Location param_locus = referenced_param->get_locus ();\n-      Bvariable *compiled_param_var\n-\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n-\t\t\t\t   compiled_param_type, param_locus);\n+static void\n+enter_intrinsic_block (Context *ctx, tree fndecl)\n+{\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = Location ();\n+  Location end_location = Location ();\n \n-      param_vars.push_back (compiled_param_var);\n-    }\n+  auto block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t\t   start_location, end_location);\n+\n+  ctx->push_block (block);\n+}\n+\n+static void\n+finalize_intrinsic_block (Context *ctx, tree fndecl)\n+{\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+  ctx->push_function (fndecl);\n+}\n+\n+static tree\n+offset_handler (Context *ctx, TyTy::FnType *fntype)\n+{\n+  // offset intrinsic has two params dst pointer and offset isize\n+  rust_assert (fntype->get_params ().size () == 2);\n+\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n+\n+  std::vector<Bvariable *> param_vars;\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n \n   auto &dst_param = param_vars.at (0);\n   auto &size_param = param_vars.at (1);\n   rust_assert (param_vars.size () == 2);\n   if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n     return error_mark_node;\n \n-  tree enclosing_scope = NULL_TREE;\n-  Location start_location = Location ();\n-  Location end_location = Location ();\n-\n-  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t\t\tstart_location, end_location);\n-  ctx->push_block (code_block);\n+  enter_intrinsic_block (ctx, fndecl);\n \n   // BUILTIN offset FN BODY BEGIN\n   tree dst = ctx->get_backend ()->var_expression (dst_param, Location ());\n@@ -175,53 +218,22 @@ offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n   ctx->add_statement (return_statement);\n   // BUILTIN offset FN BODY END\n \n-  tree bind_tree = ctx->pop_block ();\n-\n-  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  DECL_SAVED_TREE (fndecl) = bind_tree;\n-  ctx->push_function (fndecl);\n+  finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;\n }\n \n static tree\n-sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n+sizeof_handler (Context *ctx, TyTy::FnType *fntype)\n {\n-  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+  // size_of has _zero_ parameters its parameter is the generic one\n+  rust_assert (fntype->get_params ().size () == 0);\n \n-  // items can be forward compiled which means we may not need to invoke this\n-  // code. We might also have already compiled this generic function as well.\n   tree lookup = NULL_TREE;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t fntype->get_id (), fntype))\n-    {\n-      // has this been added to the list then it must be finished\n-      if (ctx->function_completed (lookup))\n-\t{\n-\t  tree dummy = NULL_TREE;\n-\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t    {\n-\t      ctx->insert_function_decl (fntype, lookup);\n-\t    }\n-\t  return lookup;\n-\t}\n-    }\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n \n-  if (fntype->has_subsititions_defined ())\n-    {\n-      // override the Hir Lookups for the substituions in this context\n-      fntype->override_context ();\n-    }\n-\n-  // size_of has _zero_ parameters its parameter is the generic one\n-  if (fntype->get_params ().size () != 0)\n-    {\n-      rust_error_at (fntype->get_ident ().locus,\n-\t\t     \"invalid number of parameters for size of intrinsic\");\n-      return error_mark_node;\n-    }\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n \n   // get the template parameter type tree fn size_of<T>();\n   rust_assert (fntype->get_num_substitutions () == 1);\n@@ -231,29 +243,7 @@ sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n   tree template_parameter_type\n     = TyTyResolveCompile::compile (ctx, resolved_tyty);\n \n-  // build the intrinsic function\n-  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-  std::string ir_symbol_name\n-    = canonical_path.get () + fntype->subst_as_string ();\n-  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n-\n-  unsigned int flags = 0;\n-  tree fndecl\n-    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n-\t\t\t\t     flags, fntype->get_ident ().locus);\n-  TREE_PUBLIC (fndecl) = 0;\n-  TREE_READONLY (fndecl) = 1;\n-  DECL_ARTIFICIAL (fndecl) = 1;\n-  DECL_EXTERNAL (fndecl) = 0;\n-  DECL_DECLARED_INLINE_P (fndecl) = 1;\n-\n-  tree enclosing_scope = NULL_TREE;\n-  Location start_location = Location ();\n-  Location end_location = Location ();\n-\n-  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t\t\tstart_location, end_location);\n-  ctx->push_block (code_block);\n+  enter_intrinsic_block (ctx, fndecl);\n \n   // BUILTIN size_of FN BODY BEGIN\n   tree size_expr = TYPE_SIZE_UNIT (template_parameter_type);\n@@ -262,89 +252,27 @@ sizeof_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n   ctx->add_statement (return_statement);\n   // BUILTIN size_of FN BODY END\n \n-  tree bind_tree = ctx->pop_block ();\n-\n-  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  DECL_SAVED_TREE (fndecl) = bind_tree;\n-  ctx->push_function (fndecl);\n+  finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;\n }\n \n static tree\n-transmute_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n+transmute_handler (Context *ctx, TyTy::FnType *fntype)\n {\n-  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n+  // transmute intrinsic has one parameter\n+  rust_assert (fntype->get_params ().size () == 1);\n \n-  // items can be forward compiled which means we may not need to invoke this\n-  // code. We might also have already compiled this generic function as well.\n   tree lookup = NULL_TREE;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t fntype->get_id (), fntype))\n-    {\n-      // has this been added to the list then it must be finished\n-      if (ctx->function_completed (lookup))\n-\t{\n-\t  tree dummy = NULL_TREE;\n-\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t    {\n-\t      ctx->insert_function_decl (fntype, lookup);\n-\t    }\n-\t  return lookup;\n-\t}\n-    }\n-\n-  if (fntype->has_subsititions_defined ())\n-    {\n-      // override the Hir Lookups for the substituions in this context\n-      fntype->override_context ();\n-    }\n-\n-  // transmute intrinsic has one parameter\n-  if (fntype->get_params ().size () != 1)\n-    {\n-      rust_error_at (fntype->get_ident ().locus,\n-\t\t     \"invalid number of parameters for transmute intrinsic\");\n-      return error_mark_node;\n-    }\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n \n-  // build the intrinsic function\n-  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-  std::string ir_symbol_name\n-    = canonical_path.get () + fntype->subst_as_string ();\n-  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n \n-  unsigned int flags = 0;\n-  tree fndecl\n-    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n-\t\t\t\t     flags, fntype->get_ident ().locus);\n-  TREE_PUBLIC (fndecl) = 0;\n-  TREE_READONLY (fndecl) = 1;\n-  DECL_ARTIFICIAL (fndecl) = 1;\n-  DECL_EXTERNAL (fndecl) = 0;\n-  DECL_DECLARED_INLINE_P (fndecl) = 1;\n-\n-  // setup the params\n   std::vector<Bvariable *> param_vars;\n   std::vector<tree_node *> compiled_types;\n-  for (auto &parm : fntype->get_params ())\n-    {\n-      auto &referenced_param = parm.first;\n-      auto &param_tyty = parm.second;\n-      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars, &compiled_types);\n \n-      Location param_locus = referenced_param->get_locus ();\n-      Bvariable *compiled_param_var\n-\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n-\t\t\t\t   compiled_param_type, param_locus);\n-\n-      param_vars.push_back (compiled_param_var);\n-      compiled_types.push_back (compiled_param_type);\n-    }\n-\n-  rust_assert (param_vars.size () == 1);\n   if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n     return error_mark_node;\n \n@@ -381,13 +309,7 @@ transmute_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n \t\t   (unsigned long) target_size);\n     }\n \n-  tree enclosing_scope = NULL_TREE;\n-  Location start_location = Location ();\n-  Location end_location = Location ();\n-\n-  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t\t\tstart_location, end_location);\n-  ctx->push_block (code_block);\n+  enter_intrinsic_block (ctx, fndecl);\n \n   // BUILTIN transmute FN BODY BEGIN\n   tree result_type_tree = TREE_TYPE (DECL_RESULT (fndecl));\n@@ -424,100 +346,34 @@ transmute_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty)\n   ctx->add_statement (return_statement);\n   // BUILTIN transmute FN BODY END\n \n-  tree bind_tree = ctx->pop_block ();\n-\n-  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  DECL_SAVED_TREE (fndecl) = bind_tree;\n-  ctx->push_function (fndecl);\n+  finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;\n }\n \n static tree\n-rotate_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty,\n-\t\t\t  tree_code op)\n+rotate_handler (Context *ctx, TyTy::FnType *fntype, tree_code op)\n {\n-  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-  const Resolver::CanonicalPath &canonical_path = fntype->get_ident ().path;\n-\n-  // items can be forward compiled which means we may not need to invoke this\n-  // code. We might also have already compiled this generic function as well.\n-  tree lookup = NULL_TREE;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t fntype->get_id (), fntype))\n-    {\n-      // has this been added to the list then it must be finished\n-      if (ctx->function_completed (lookup))\n-\t{\n-\t  tree dummy = NULL_TREE;\n-\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t    {\n-\t      ctx->insert_function_decl (fntype, lookup);\n-\t    }\n-\t  return lookup;\n-\t}\n-    }\n-\n-  if (fntype->has_subsititions_defined ())\n-    {\n-      // override the Hir Lookups for the substitutions in this context\n-      fntype->override_context ();\n-    }\n-\n   // rotate intrinsic has two parameter\n-  if (fntype->get_params ().size () != 2)\n-    {\n-      rust_error_at (fntype->get_ident ().locus,\n-\t\t     \"invalid number of parameters for rotate intrinsic\");\n-      return error_mark_node;\n-    }\n+  rust_assert (fntype->get_params ().size () == 2);\n \n-  // build the intrinsic function\n-  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-  std::string ir_symbol_name\n-    = canonical_path.get () + fntype->subst_as_string ();\n-  std::string asm_name = ctx->mangle_item (fntype, canonical_path);\n+  tree lookup = NULL_TREE;\n+  if (check_for_cached_intrinsic (ctx, fntype, &lookup))\n+    return lookup;\n \n-  unsigned int flags = 0;\n-  tree fndecl\n-    = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name, asm_name,\n-\t\t\t\t     flags, fntype->get_ident ().locus);\n-  TREE_PUBLIC (fndecl) = 0;\n-  TREE_READONLY (fndecl) = 1;\n-  DECL_ARTIFICIAL (fndecl) = 1;\n-  DECL_EXTERNAL (fndecl) = 0;\n-  DECL_DECLARED_INLINE_P (fndecl) = 1;\n+  auto fndecl = compile_intrinsic_function (ctx, fntype);\n \n   // setup the params\n   std::vector<Bvariable *> param_vars;\n-  for (auto &parm : fntype->get_params ())\n-    {\n-      auto &referenced_param = parm.first;\n-      auto &param_tyty = parm.second;\n-      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n-\n-      Location param_locus = referenced_param->get_locus ();\n-      Bvariable *compiled_param_var\n-\t= CompileFnParam::compile (ctx, fndecl, referenced_param,\n-\t\t\t\t   compiled_param_type, param_locus);\n-\n-      param_vars.push_back (compiled_param_var);\n-    }\n+  compile_fn_params (ctx, fntype, fndecl, &param_vars);\n \n   auto &x_param = param_vars.at (0);\n   auto &y_param = param_vars.at (1);\n   rust_assert (param_vars.size () == 2);\n   if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n     return error_mark_node;\n \n-  tree enclosing_scope = NULL_TREE;\n-  Location start_location = Location ();\n-  Location end_location = Location ();\n-\n-  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t\t\tstart_location, end_location);\n-  ctx->push_block (code_block);\n+  enter_intrinsic_block (ctx, fndecl);\n \n   // BUILTIN rotate FN BODY BEGIN\n   tree x = ctx->get_backend ()->var_expression (x_param, Location ());\n@@ -530,11 +386,7 @@ rotate_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype_tyty,\n   ctx->add_statement (return_statement);\n   // BUILTIN rotate FN BODY END\n \n-  tree bind_tree = ctx->pop_block ();\n-\n-  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  DECL_SAVED_TREE (fndecl) = bind_tree;\n-  ctx->push_function (fndecl);\n+  finalize_intrinsic_block (ctx, fndecl);\n \n   return fndecl;\n }"}, {"sha": "6b2339f38f3de0fced051f48336e954ada849753", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3766ccfce1b90be8facf1124303519be93e66a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3766ccfce1b90be8facf1124303519be93e66a/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-2.rs?ref=7c3766ccfce1b90be8facf1124303519be93e66a", "patch": "@@ -0,0 +1,22 @@\n+// { dg-additional-options -fdump-tree-original }\n+\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    pub fn size_of<T>() -> usize;\n+}\n+\n+fn main() -> i32 {\n+    unsafe fn foo() -> usize {\n+        let f: f32;\n+\n+        let s_f32 = size_of::<f32>();\n+        let s_f64 = size_of::<f64>();\n+        let s_f32_again = size_of::<f32>();\n+\n+        s_f32 + s_f64 + s_f32_again\n+    }\n+\n+    // useless code, just used for function compilation caching\n+    unsafe { foo() as i32 }\n+}"}]}