{"sha": "a01dda3c23b836754814fab1cab949a1bbc641e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxZGRhM2MyM2I4MzY3NTQ4MTRmYWIxY2FiOTQ5YTFiYmM2NDFlOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-17T04:06:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-20T20:44:35Z"}, "message": "compiler, libgo: change mangling scheme\n\nOverhaul the mangling scheme to avoid ambiguities if the package path\ncontains a dot. Instead of using dot both to separate components and\nto mangle characters, use dot only to separate components and use\nunderscore to mangle characters.\n\nFor golang/go#41862\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/271726", "tree": {"sha": "826310b88323c0f636baf89393557fde6a56fdeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/826310b88323c0f636baf89393557fde6a56fdeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a01dda3c23b836754814fab1cab949a1bbc641e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01dda3c23b836754814fab1cab949a1bbc641e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a01dda3c23b836754814fab1cab949a1bbc641e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a01dda3c23b836754814fab1cab949a1bbc641e8/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90bf60c3c24c6c99ebbecf9d08a6d0d916d73721"}], "stats": {"total": 2271, "additions": 1327, "deletions": 944}, "files": [{"sha": "9545a59873855363f54e75653ee0b1949114434e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1,4 +1,4 @@\n-c948c2d770122932a05b62f653efa2c51f72d3ae\n+b483d0e0a289ba5fcdbd0388cbc75393367ca870\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "eca0bf1fad2dcd40b234bd06e61219f2eb06f1bd", "filename": "gcc/go/gofrontend/ast-dump.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fast-dump.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -226,7 +226,11 @@ Ast_dump_context::dump_type(const Type* t)\n     // FIXME: write a type pretty printer instead of\n     // using mangled names.\n     if (this->gogo_ != NULL)\n-      this->ostream() << \"(\" << t->mangled_name(this->gogo_) <<  \")\";\n+      {\n+\tBackend_name bname;\n+\tt->backend_name(this->gogo_, &bname);\n+\tthis->ostream() << \"(\" << bname.name() << \")\";\n+      }\n }\n \n // Dump a textual representation of a block to the"}, {"sha": "e99c680f709fcfaba032f935736e7310ddfd5a64", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -461,7 +461,7 @@ should_export(Named_object* no)\n     return false;\n \n   // We don't export various special functions.\n-  if (Gogo::is_special_name(no->name()))\n+  if (Gogo::special_name_pos(no->name()) != std::string::npos)\n     return false;\n \n   // Methods are exported with the type, not here.\n@@ -524,7 +524,11 @@ struct Sort_types\n     if (t1->classification() != t2->classification())\n       return t1->classification() < t2->classification();\n     Gogo* gogo = go_get_gogo();\n-    return gogo->type_descriptor_name(t1, NULL).compare(gogo->type_descriptor_name(t2, NULL)) < 0;\n+    Backend_name b1;\n+    gogo->type_descriptor_backend_name(t1, NULL, &b1);\n+    Backend_name b2;\n+    gogo->type_descriptor_backend_name(t2, NULL, &b2);\n+    return b1.name() < b2.name();\n   }\n };\n "}, {"sha": "6bc93488939dbf4b70d0fd30f0ce3cef9c7e6bdb", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1596,7 +1596,8 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n     return context->backend()->var_expression(this->dvar_, loc);\n \n   Gogo* gogo = context->gogo();\n-  std::string var_name(gogo->function_descriptor_name(no));\n+  Backend_name bname;\n+  gogo->function_descriptor_backend_name(no, &bname);\n   bool is_descriptor = false;\n   if (no->is_function_declaration()\n       && !no->func_declaration_value()->asm_name().empty()\n@@ -1616,10 +1617,11 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n   Btype* btype = this->type()->get_backend(gogo);\n \n   Bvariable* bvar;\n-  std::string asm_name(go_selectively_encode_id(var_name));\n   if (no->package() != NULL || is_descriptor)\n-    bvar = context->backend()->immutable_struct_reference(var_name, asm_name,\n-                                                          btype, loc);\n+    bvar =\n+      context->backend()->immutable_struct_reference(bname.name(),\n+\t\t\t\t\t\t     bname.optional_asm_name(),\n+\t\t\t\t\t\t     btype, loc);\n   else\n     {\n       Location bloc = Linemap::predeclared_location();\n@@ -1644,7 +1646,8 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n       if (no->is_function() && no->func_value()->is_referenced_by_inline())\n \tis_hidden = false;\n \n-      bvar = context->backend()->immutable_struct(var_name, asm_name,\n+      bvar = context->backend()->immutable_struct(bname.name(),\n+\t\t\t\t\t\t  bname.optional_asm_name(),\n                                                   is_hidden, false,\n \t\t\t\t\t\t  btype, bloc);\n       Expression_list* vals = new Expression_list();\n@@ -1654,8 +1657,9 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n       Translate_context bcontext(gogo, NULL, NULL, NULL);\n       bcontext.set_is_const();\n       Bexpression* binit = init->get_backend(&bcontext);\n-      context->backend()->immutable_struct_set_init(bvar, var_name, is_hidden,\n-\t\t\t\t\t\t    false, btype, bloc, binit);\n+      context->backend()->immutable_struct_set_init(bvar, bname.name(),\n+\t\t\t\t\t\t    is_hidden, false, btype,\n+\t\t\t\t\t\t    bloc, binit);\n     }\n \n   this->dvar_ = bvar;\n@@ -5190,11 +5194,9 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      copy_to_heap = (context->function() != NULL\n                               || context->is_const());\n \t    }\n-\t  std::string asm_name(go_selectively_encode_id(var_name));\n \t  Bvariable* implicit =\n-              gogo->backend()->implicit_variable(var_name, asm_name,\n-                                                 btype, true, copy_to_heap,\n-                                                 false, 0);\n+              gogo->backend()->implicit_variable(var_name, \"\", btype, true,\n+\t\t\t\t\t\t copy_to_heap, false, 0);\n \t  gogo->backend()->implicit_variable_set_init(implicit, var_name, btype,\n \t\t\t\t\t\t      true, copy_to_heap, false,\n \t\t\t\t\t\t      bexpr);\n@@ -5219,20 +5221,18 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t       && this->expr_->is_static_initializer())\n         {\n \t  std::string var_name(gogo->initializer_name());\n-\t  std::string asm_name(go_selectively_encode_id(var_name));\n           Bvariable* decl =\n-              gogo->backend()->immutable_struct(var_name, asm_name,\n-                                                true, false, btype, loc);\n+              gogo->backend()->immutable_struct(var_name, \"\", true, false,\n+\t\t\t\t\t\tbtype, loc);\n           gogo->backend()->immutable_struct_set_init(decl, var_name, true,\n \t\t\t\t\t\t     false, btype, loc, bexpr);\n           bexpr = gogo->backend()->var_expression(decl, loc);\n         }\n       else if (this->expr_->is_constant())\n         {\n           std::string var_name(gogo->initializer_name());\n-          std::string asm_name(go_selectively_encode_id(var_name));\n           Bvariable* decl =\n-              gogo->backend()->implicit_variable(var_name, asm_name, btype,\n+              gogo->backend()->implicit_variable(var_name, \"\", btype,\n                                                  true, true, false, 0);\n           gogo->backend()->implicit_variable_set_init(decl, var_name, btype,\n                                                       true, true, false,\n@@ -18251,9 +18251,8 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n     {\n       // The interface conversion table is defined elsewhere.\n       Btype* btype = this->type()->get_backend(gogo);\n-      std::string asm_name(go_selectively_encode_id(mangled_name));\n       this->bvar_ =\n-          gogo->backend()->immutable_struct_reference(mangled_name, asm_name,\n+          gogo->backend()->immutable_struct_reference(mangled_name, \"\",\n                                                       btype, loc);\n       return gogo->backend()->var_expression(this->bvar_, this->location());\n     }\n@@ -18323,8 +18322,7 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   Bexpression* ctor =\n       gogo->backend()->constructor_expression(btype, ctor_bexprs, loc);\n \n-  std::string asm_name(go_selectively_encode_id(mangled_name));\n-  this->bvar_ = gogo->backend()->immutable_struct(mangled_name, asm_name, false,\n+  this->bvar_ = gogo->backend()->immutable_struct(mangled_name, \"\", false,\n \t\t\t\t\t\t  !is_public, btype, loc);\n   gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, false,\n                                              !is_public, btype, loc, ctor);"}, {"sha": "7ab65f513b394642c7448f6e21ff91719b1474fc", "filename": "gcc/go/gofrontend/go-encode-id.cc", "status": "modified", "additions": 189, "deletions": 100, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -12,8 +12,8 @@\n #include \"go-encode-id.h\"\n #include \"lex.h\"\n \n-// Return whether the character c is OK to use in the assembler.  We\n-// only permit ASCII alphanumeric characters, underscore, and dot.\n+// Return whether the character c can appear in a name that we are\n+// encoding.  We only permit ASCII alphanumeric characters.\n \n static bool\n char_needs_encoding(char c)\n@@ -32,7 +32,6 @@ char_needs_encoding(char c)\n     case 'y': case 'z':\n     case '0': case '1': case '2': case '3': case '4':\n     case '5': case '6': case '7': case '8': case '9':\n-    case '_': case '.':\n       return false;\n     default:\n       return true;\n@@ -53,6 +52,52 @@ go_id_needs_encoding(const std::string& str)\n   return false;\n }\n \n+// Map from characters to the underscore encoding for them.\n+\n+class Special_char_code\n+{\n+ public:\n+  Special_char_code();\n+\n+  // Return the simple underscore encoding for C, or 0 if none.\n+  char\n+  code_for(unsigned int c) const\n+  {\n+    if (c <= 127)\n+      return this->codes_[c];\n+    return 0;\n+  }\n+\n+ private:\n+  // Encodings for characters.\n+  char codes_[128];\n+};\n+\n+// Construct the underscore encoding map.\n+\n+Special_char_code::Special_char_code()\n+{\n+  memset(this->codes_, 0, sizeof this->codes_);\n+  this->codes_['_'] = '_';\n+  this->codes_['.'] = '0';\n+  this->codes_['/'] = '1';\n+  this->codes_['*'] = '2';\n+  this->codes_[','] = '3';\n+  this->codes_['{'] = '4';\n+  this->codes_['}'] = '5';\n+  this->codes_['['] = '6';\n+  this->codes_[']'] = '7';\n+  this->codes_['('] = '8';\n+  this->codes_[')'] = '9';\n+  this->codes_['\"'] = 'a';\n+  this->codes_[' '] = 'b';\n+  this->codes_[';'] = 'c';\n+}\n+\n+// The singleton Special_char_code.\n+\n+static const Special_char_code special_char_code;\n+\n // Pull the next UTF-8 character out of P and store it in *PC.  Return\n // the number of bytes read.\n \n@@ -82,10 +127,9 @@ fetch_utf8_char(const char* p, unsigned int* pc)\n   return len;\n }\n \n-// Encode an identifier using assembler-friendly characters. The encoding is\n-// described in detail near the end of the long comment at the start of\n-// names.cc. Short version: translate all non-ASCII-alphanumeric characters into\n-// ..uXXXX or ..UXXXXXXXX, translate ASCII non-alphanumerics into \".zXX\".\n+// Encode an identifier using assembler-friendly characters.  The\n+// encoding is described in detail near the end of the long comment at\n+// the start of names.cc.\n \n std::string\n go_encode_id(const std::string &id)\n@@ -96,50 +140,57 @@ go_encode_id(const std::string &id)\n       return id;\n     }\n \n-  // The encoding is only unambiguous if the input string does not\n-  // contain ..z, ..u or ..U.\n-  go_assert(id.find(\"..z\") == std::string::npos);\n-  go_assert(id.find(\"..u\") == std::string::npos);\n-  go_assert(id.find(\"..U\") == std::string::npos);\n-\n   std::string ret;\n   const char* p = id.c_str();\n   const char* pend = p + id.length();\n \n-  // A leading \".0\" is a space introduced before a mangled type name\n-  // that starts with a 'u' or 'U', to avoid confusion with the\n-  // mangling used here.  We don't need a leading \".0\", and we don't\n-  // want symbols that start with '.', so remove it.\n-  if (p[0] == '.' && p[1] == '0')\n-    p += 2;\n+  // We encode a leading digit, to ensure that no identifier starts\n+  // with a digit.\n+  if (pend > p && p[0] >= '0' && p[0] <= '9')\n+    {\n+      char buf[8];\n+      snprintf(buf, sizeof buf, \"_x%02x\", p[0]);\n+      ret.append(buf);\n+      ++p;\n+    }\n \n   while (p < pend)\n     {\n       unsigned int c;\n       size_t len = fetch_utf8_char(p, &c);\n-      if (len == 1 && !char_needs_encoding(c))\n+      if (len == 1)\n \t{\n-\t  ret += c;\n+\t  if (!char_needs_encoding(c))\n+\t    ret.push_back(c);\n+\t  else\n+\t    {\n+\t      char code = special_char_code.code_for(c);\n+\t      if (code != 0)\n+\t\t{\n+\t\t  ret.push_back('_');\n+\t\t  ret.push_back(code);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  char buf[8];\n+\t\t  snprintf(buf, sizeof buf, \"_x%02x\", c);\n+\t\t  ret.append(buf);\n+\t\t}\n+\t    }\n \t}\n       else\n \t{\n \t  char buf[16];\n-          if (len == 1)\n-            snprintf(buf, sizeof buf, \"..z%02x\", c);\n-\t  else if (c < 0x10000)\n-\t    snprintf(buf, sizeof buf, \"..u%04x\", c);\n+\t  if (c < 0x10000)\n+\t    snprintf(buf, sizeof buf, \"_u%04x\", c);\n \t  else\n-\t    snprintf(buf, sizeof buf, \"..U%08x\", c);\n-\n-\t  // We don't want a symbol to start with '.', so add a prefix\n-\t  // if needed.\n-\t  if (ret.empty())\n-\t    ret += '_';\n-\n-\t  ret += buf;\n+\t    snprintf(buf, sizeof buf, \"_U%08x\", c);\n+\t  ret.append(buf);\n \t}\n+\n       p += len;\n     }\n+\n   return ret;\n }\n \n@@ -170,64 +221,116 @@ go_decode_id(const std::string &encoded)\n   const char* pend = p + encoded.length();\n   const Location loc = Linemap::predeclared_location();\n \n-  // Special case for initial \"_\", in case it was introduced\n-  // as a way to prevent encoded symbol starting with \".\".\n-  if (*p == '_' && (strncmp(p+1, \"..u\", 3) == 0 || strncmp(p+1, \"..U\", 3) == 0))\n-    p++;\n-\n   while (p < pend)\n     {\n-      if (strncmp(p, \"..z\", 3) == 0)\n-        {\n-          const char* digits = p+3;\n-          if (strlen(digits) < 2)\n-            return \"\";\n-          unsigned rune = hex_digits_to_unicode_codepoint(digits, 2);\n-          Lex::append_char(rune, true, &ret, loc);\n-          p += 5;\n-        }\n-      else if (strncmp(p, \"..u\", 3) == 0)\n-        {\n-          const char* digits = p+3;\n-          if (strlen(digits) < 4)\n-            return \"\";\n-          unsigned rune = hex_digits_to_unicode_codepoint(digits, 4);\n-          Lex::append_char(rune, true, &ret, loc);\n-          p += 7;\n-        }\n-      else if (strncmp(p, \"..U\", 3) == 0)\n-        {\n-          const char* digits = p+3;\n-          if (strlen(digits) < 8)\n-            return \"\";\n-          unsigned rune = hex_digits_to_unicode_codepoint(digits, 8);\n-          Lex::append_char(rune, true, &ret, loc);\n-          p += 11;\n-        }\n-      else\n-        {\n-          ret += *p;\n-          p += 1;\n-        }\n+      if (*p != '_' || p + 1 == pend)\n+\t{\n+\t  ret.push_back(*p);\n+\t  p++;\n+\t  continue;\n+\t}\n+\n+      switch (p[1])\n+\t{\n+\tcase '_':\n+\t  ret.push_back('_');\n+\t  p += 2;\n+\t  break;\n+\tcase '0':\n+\t  ret.push_back('.');\n+\t  p += 2;\n+\t  break;\n+\tcase '1':\n+\t  ret.push_back('/');\n+\t  p += 2;\n+\t  break;\n+\tcase '2':\n+\t  ret.push_back('*');\n+\t  p += 2;\n+\t  break;\n+\tcase '3':\n+\t  ret.push_back(',');\n+\t  p += 2;\n+\t  break;\n+\tcase '4':\n+\t  ret.push_back('{');\n+\t  p += 2;\n+\t  break;\n+\tcase '5':\n+\t  ret.push_back('}');\n+\t  p += 2;\n+\t  break;\n+\tcase '6':\n+\t  ret.push_back('[');\n+\t  p += 2;\n+\t  break;\n+\tcase '7':\n+\t  ret.push_back(']');\n+\t  p += 2;\n+\t  break;\n+\tcase '8':\n+\t  ret.push_back('(');\n+\t  p += 2;\n+\t  break;\n+\tcase '9':\n+\t  ret.push_back(')');\n+\t  p += 2;\n+\t  break;\n+\tcase 'a':\n+\t  ret.push_back('\"');\n+\t  p += 2;\n+\t  break;\n+\tcase 'b':\n+\t  ret.push_back(' ');\n+\t  p += 2;\n+\t  break;\n+\tcase 'c':\n+\t  ret.push_back(';');\n+\t  p += 2;\n+\t  break;\n+        case 'x':\n+\t  {\n+\t    const char* digits = p + 2;\n+\t    if (strlen(digits) < 2)\n+\t      return \"\";\n+\t    unsigned int rune = hex_digits_to_unicode_codepoint(digits, 2);\n+\t    Lex::append_char(rune, true, &ret, loc);\n+\t    p += 4;\n+\t  }\n+\t  break;\n+\tcase 'u':\n+\t  {\n+\t    const char* digits = p + 2;\n+\t    if (strlen(digits) < 4)\n+\t      return \"\";\n+\t    unsigned int rune = hex_digits_to_unicode_codepoint(digits, 4);\n+\t    Lex::append_char(rune, true, &ret, loc);\n+\t    p += 6;\n+\t  }\n+\t  break;\n+\tcase 'U':\n+\t  {\n+\t    const char* digits = p + 2;\n+\t    if (strlen(digits) < 8)\n+\t      return \"\";\n+\t    unsigned int rune = hex_digits_to_unicode_codepoint(digits, 8);\n+\t    Lex::append_char(rune, true, &ret, loc);\n+\t    p += 10;\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  return \"\";\n+\t}\n     }\n \n   return ret;\n }\n \n-std::string\n-go_selectively_encode_id(const std::string &id)\n-{\n-  if (go_id_needs_encoding(id))\n-    return go_encode_id(id);\n-  return std::string();\n-}\n-\n // Encode a struct field tag.  This is only used when we need to\n // create a type descriptor for an anonymous struct type with field\n-// tags.  This mangling is applied before go_encode_id.  We skip\n-// alphanumerics and underscore, replace every other single byte\n-// character with .xNN, and leave larger UTF-8 characters for\n-// go_encode_id.\n+// tags.  Underscore encoding will be applied to the returned string.\n+// The tag will appear between curly braces, so that is all we have to\n+// avoid.\n \n std::string\n go_mangle_struct_tag(const std::string& tag)\n@@ -241,28 +344,14 @@ go_mangle_struct_tag(const std::string& tag)\n       size_t len = fetch_utf8_char(p, &c);\n       if (len > 1)\n \tret.append(p, len);\n-      else if (!char_needs_encoding(c) && c != '.')\n-\tret += c;\n+      else if (c != '{' && c != '}' && c != '\\\\')\n+\tret.push_back(c);\n       else\n \t{\n-\t  char buf[16];\n-\t  snprintf(buf, sizeof buf, \".x%02x\", c);\n-\t  ret += buf;\n+\t  ret.push_back('\\\\');\n+\t  ret.push_back(c);\n \t}\n       p += len;\n     }\n   return ret;\n }\n-\n-// Encode a package path.\n-\n-std::string\n-go_mangle_pkgpath(const std::string& pkgpath)\n-{\n-  std::string s = pkgpath;\n-  for (size_t i = s.find('.');\n-       i != std::string::npos;\n-       i = s.find('.', i + 1))\n-    s.replace(i, 1, \".x2e\"); // 0x2e is the ASCII encoding for '.'\n-  return s;\n-}"}, {"sha": "cbafd5447d6f33d543e589d52bb6b1820a8cd39d", "filename": "gcc/go/gofrontend/go-encode-id.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -25,21 +25,8 @@ go_encode_id(const std::string &id);\n extern std::string\n go_decode_id(const std::string &id);\n \n-// Returns the empty string if the specified name needs encoding,\n-// otherwise invokes go_encode_id on the name and returns the result.\n-extern std::string\n-go_selectively_encode_id(const std::string &id);\n-\n // Encodes a struct tag that appears in a type literal encoding.\n extern std::string\n go_mangle_struct_tag(const std::string& tag);\n \n-// Encode a package path.  A package path can contain any arbitrary\n-// character, including '.'.  go_encode_id expects that any '.' will\n-// be inserted by name mangling in a controlled manner.  So first\n-// translate any '.' using the same .x encoding as used by\n-// go_mangle_struct_tag.\n-extern std::string\n-go_mangle_pkgpath(const std::string& pkgpath);\n-\n #endif // !defined(GO_ENCODE_ID_H)"}, {"sha": "93a4a5773a20e019c8737e75630793b064cd9a93", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 114, "deletions": 138, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -299,7 +299,7 @@ void\n Gogo::set_pkgpath(const std::string& arg)\n {\n   go_assert(!this->pkgpath_set_);\n-  this->pkgpath_ = go_mangle_pkgpath(arg);\n+  this->pkgpath_ = arg;\n   this->pkgpath_set_ = true;\n   this->pkgpath_from_option_ = true;\n }\n@@ -324,32 +324,6 @@ Gogo::set_prefix(const std::string& arg)\n   this->prefix_from_option_ = true;\n }\n \n-// Given a name which may or may not have been hidden, append the\n-// appropriate version of the name to the result string. Take care\n-// to avoid creating a sequence that will be rejected by go_encode_id\n-// (avoid ..u, ..U, ..z).\n-void\n-Gogo::append_possibly_hidden_name(std::string *result, const std::string& name)\n-{\n-  // FIXME: This adds in pkgpath twice for hidden symbols, which is\n-  // less than ideal.\n-  if (!Gogo::is_hidden_name(name))\n-    (*result) += name;\n-  else\n-    {\n-      std::string n = \".\";\n-      std::string pkgpath = Gogo::hidden_name_pkgpath(name);\n-      char lastR = result->at(result->length() - 1);\n-      char firstP = pkgpath.at(0);\n-      if (lastR == '.' && (firstP == 'u' || firstP == 'U' || firstP == 'z'))\n-        n = \"_.\";\n-      n.append(pkgpath);\n-      n.append(1, '.');\n-      n.append(Gogo::unpack_hidden_name(name));\n-      (*result) += n;\n-    }\n-}\n-\n // Munge name for use in an error message.\n \n std::string\n@@ -397,8 +371,7 @@ Gogo::set_package_name(const std::string& package_name,\n \t{\n \t  if (!this->prefix_from_option_)\n \t    this->prefix_ = \"go\";\n-\t  this->pkgpath_ = (go_mangle_pkgpath(this->prefix_) + '.'\n-\t\t\t    + package_name);\n+\t  this->pkgpath_ = this->prefix_ + '.' + package_name;\n \t  this->pkgpath_symbol_ = (Gogo::pkgpath_for_symbol(this->prefix_) + '.'\n \t\t\t\t   + Gogo::pkgpath_for_symbol(package_name));\n \t}\n@@ -997,9 +970,9 @@ Gogo::register_type_descriptors(std::vector<Bstatement*>& init_stmts,\n        it != this->imported_init_fns_.end();\n        ++it)\n     {\n-      std::string pkgpath =\n-        this->pkgpath_from_init_fn_name((*it)->init_name());\n-      list_names.push_back(this->type_descriptor_list_symbol(pkgpath));\n+      std::string pkgpath_symbol =\n+        this->pkgpath_symbol_from_init_fn_name((*it)->init_name());\n+      list_names.push_back(this->type_descriptor_list_symbol(pkgpath_symbol));\n     }\n   // Add the main package itself.\n   list_names.push_back(this->type_descriptor_list_symbol(\"main\"));\n@@ -2746,16 +2719,15 @@ Gogo::clear_file_scope()\n // parse tree is lowered.\n \n void\n-Gogo::queue_hash_function(Type* type, int64_t size,\n-\t\t\t  const std::string& hash_name,\n+Gogo::queue_hash_function(Type* type, int64_t size, Backend_name* bname,\n \t\t\t  Function_type* hash_fntype)\n {\n   go_assert(!this->specific_type_functions_are_written_);\n   go_assert(!this->in_global_scope());\n   Specific_type_function::Specific_type_function_kind kind =\n     Specific_type_function::SPECIFIC_HASH;\n   Specific_type_function* tsf = new Specific_type_function(type, NULL, size,\n-\t\t\t\t\t\t\t   kind, hash_name,\n+\t\t\t\t\t\t\t   kind, bname,\n \t\t\t\t\t\t\t   hash_fntype);\n   this->specific_type_functions_.push_back(tsf);\n }\n@@ -2766,15 +2738,14 @@ Gogo::queue_hash_function(Type* type, int64_t size,\n \n void\n Gogo::queue_equal_function(Type* type, Named_type* name, int64_t size,\n-\t\t\t   const std::string& equal_name,\n-\t\t\t   Function_type* equal_fntype)\n+\t\t\t   Backend_name* bname, Function_type* equal_fntype)\n {\n   go_assert(!this->specific_type_functions_are_written_);\n   go_assert(!this->in_global_scope());\n   Specific_type_function::Specific_type_function_kind kind =\n     Specific_type_function::SPECIFIC_EQUAL;\n   Specific_type_function* tsf = new Specific_type_function(type, name, size,\n-\t\t\t\t\t\t\t   kind, equal_name,\n+\t\t\t\t\t\t\t   kind, bname,\n \t\t\t\t\t\t\t   equal_fntype);\n   this->specific_type_functions_.push_back(tsf);\n }\n@@ -2872,11 +2843,11 @@ Gogo::write_specific_type_functions()\n       Specific_type_function* tsf = this->specific_type_functions_.back();\n       this->specific_type_functions_.pop_back();\n       if (tsf->kind == Specific_type_function::SPECIFIC_HASH)\n-\ttsf->type->write_hash_function(this, tsf->size, tsf->fnname,\n+\ttsf->type->write_hash_function(this, tsf->size, &tsf->bname,\n \t\t\t\t       tsf->fntype);\n       else\n \ttsf->type->write_equal_function(this, tsf->name, tsf->size,\n-\t\t\t\t\ttsf->fnname, tsf->fntype);\n+\t\t\t\t\t&tsf->bname, tsf->fntype);\n       delete tsf;\n     }\n   this->specific_type_functions_are_written_ = true;\n@@ -6218,6 +6189,56 @@ Function::import_func(Import* imp, std::string* pname,\n   return true;\n }\n \n+// Get the backend name.\n+\n+void\n+Function::backend_name(Gogo* gogo, Named_object* no, Backend_name *bname)\n+{\n+  if (!this->asm_name_.empty())\n+    bname->set_asm_name(this->asm_name_);\n+  else if (no->package() == NULL && no->name() == gogo->get_init_fn_name())\n+    {\n+      // These names appear in the export data and are used\n+      // directly in the assembler code.  If we change this here\n+      // we need to change Gogo::init_imports.\n+      bname->set_asm_name(no->name());\n+    }\n+  else if (this->enclosing_ != NULL)\n+    {\n+      // Rewrite the nested name to use the enclosing function name.\n+      // We don't do this earlier because we just store simple names\n+      // in a Named_object, not Backend_names.\n+\n+      // The name was set by nested_function_name, which always\n+      // appends ..funcNNN.  We want that to be our suffix.\n+      size_t pos = no->name().find(\"..func\");\n+      go_assert(pos != std::string::npos);\n+\n+      Named_object* enclosing = this->enclosing_;\n+      while (true)\n+\t{\n+\t  Named_object* parent = enclosing->func_value()->enclosing();\n+\t  if (parent == NULL)\n+\t    break;\n+\t  enclosing = parent;\n+\t}\n+\n+      Type* rtype = NULL;\n+      if (enclosing->func_value()->type()->is_method())\n+\trtype = enclosing->func_value()->type()->receiver()->type();\n+      gogo->function_backend_name(enclosing->name(), enclosing->package(),\n+\t\t\t\t  rtype, bname);\n+      bname->append_suffix(no->name().substr(pos));\n+    }\n+  else\n+    {\n+      Type* rtype = NULL;\n+      if (this->type_->is_method())\n+\trtype = this->type_->receiver()->type();\n+      gogo->function_backend_name(no->name(), no->package(), rtype, bname);\n+    }\n+}\n+\n // Get the backend representation.\n \n Bfunction*\n@@ -6226,7 +6247,6 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n   if (this->fndecl_ == NULL)\n     {\n       unsigned int flags = 0;\n-      bool is_init_fn = false;\n       if (no->package() != NULL)\n \t{\n \t  // Functions defined in other packages must be visible.\n@@ -6238,10 +6258,7 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n                && !this->type_->is_method())\n \t;\n       else if (no->name() == gogo->get_init_fn_name())\n-\t{\n-\t  flags |= Backend::function_is_visible;\n-\t  is_init_fn = true;\n-\t}\n+\tflags |= Backend::function_is_visible;\n       else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n                && gogo->is_main_package())\n \tflags |= Backend::function_is_visible;\n@@ -6255,29 +6272,13 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n \t    flags |= Backend::function_is_visible;\n         }\n \n-      Type* rtype = NULL;\n-      if (this->type_->is_method())\n-\trtype = this->type_->receiver()->type();\n-\n-      std::string asm_name;\n       if (!this->asm_name_.empty())\n \t{\n-\t  asm_name = this->asm_name_;\n-\n \t  // If an assembler name is explicitly specified, there must\n \t  // be some reason to refer to the symbol from a different\n \t  // object file.\n \t  flags |= Backend::function_is_visible;\n \t}\n-      else if (is_init_fn)\n-\t{\n-\t  // These names appear in the export data and are used\n-\t  // directly in the assembler code.  If we change this here\n-\t  // we need to change Gogo::init_imports.\n-\t  asm_name = no->name();\n-\t}\n-      else\n-\tasm_name = gogo->function_asm_name(no->name(), no->package(), rtype);\n \n       // If an inline body refers to this function, then it\n       // needs to be visible in the symbol table.\n@@ -6337,13 +6338,36 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n \tflags |= Backend::function_only_inline;\n \n       Btype* functype = this->type_->get_backend_fntype(gogo);\n-      this->fndecl_ =\n-          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n-\t\t\t\t    flags, this->location());\n+\n+      Backend_name bname;\n+      this->backend_name(gogo, no, &bname);\n+\n+      this->fndecl_ = gogo->backend()->function(functype,\n+\t\t\t\t\t\tbname.name(),\n+\t\t\t\t\t\tbname.optional_asm_name(),\n+\t\t\t\t\t\tflags,\n+\t\t\t\t\t\tthis->location());\n     }\n   return this->fndecl_;\n }\n \n+// Get the backend name.\n+\n+void\n+Function_declaration::backend_name(Gogo* gogo, Named_object* no,\n+\t\t\t\t   Backend_name* bname)\n+{\n+  if (!this->asm_name_.empty())\n+    bname->set_asm_name(this->asm_name_);\n+  else\n+    {\n+      Type* rtype = NULL;\n+      if (this->fntype_->is_method())\n+\trtype = this->fntype_->receiver()->type();\n+      gogo->function_backend_name(no->name(), no->package(), rtype, bname);\n+    }\n+}\n+\n // Get the backend representation.\n \n Bfunction*\n@@ -6375,21 +6399,16 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n \t    flags |= Backend::function_does_not_return;\n \t}\n \n-      std::string asm_name;\n-      if (this->asm_name_.empty())\n-\t{\n-\t  Type* rtype = NULL;\n-\t  if (this->fntype_->is_method())\n-\t    rtype = this->fntype_->receiver()->type();\n-\t  asm_name = gogo->function_asm_name(no->name(), no->package(), rtype);\n-\t}\n-      else if (go_id_needs_encoding(no->get_id(gogo)))\n-        asm_name = go_encode_id(no->get_id(gogo));\n-\n       Btype* functype = this->fntype_->get_backend_fntype(gogo);\n-      this->fndecl_ =\n-          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n-\t\t\t\t    flags, this->location());\n+\n+      Backend_name bname;\n+      this->backend_name(gogo, no, &bname);\n+\n+      this->fndecl_ = gogo->backend()->function(functype,\n+\t\t\t\t\t\tbname.name(),\n+\t\t\t\t\t\tbname.optional_asm_name(),\n+\t\t\t\t\t\tflags,\n+\t\t\t\t\t\tthis->location());\n     }\n \n   return this->fndecl_;\n@@ -7993,27 +8012,21 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t      type = Type::make_pointer_type(type);\n \t    }\n \n-\t  const std::string n = Gogo::unpack_hidden_name(name);\n \t  Btype* btype = type->get_backend(gogo);\n \n \t  Bvariable* bvar;\n \t  if (Map_type::is_zero_value(this))\n \t    bvar = Map_type::backend_zero_value(gogo);\n \t  else if (this->is_global_)\n \t    {\n-\t      std::string var_name(package != NULL\n-\t\t\t\t   ? package->package_name()\n-\t\t\t\t   : gogo->package_name());\n-\t      var_name.push_back('.');\n-\t      var_name.append(n);\n-\n-              std::string asm_name(gogo->global_var_asm_name(name, package));\n+\t      Backend_name bname;\n+\t      gogo->global_var_backend_name(name, package, &bname);\n \n \t      bool is_hidden = Gogo::is_hidden_name(name);\n \t      // Hack to export runtime.writeBarrier.  FIXME.\n \t      // This is because go:linkname doesn't work on variables.\n \t      if (gogo->compiling_runtime()\n-\t\t  && var_name == \"runtime.writeBarrier\")\n+\t\t  && bname.name() == \"runtime.writeBarrier\")\n \t\tis_hidden = false;\n \n \t      // If an inline body refers to this variable, then it\n@@ -8028,8 +8041,12 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t      if (package != NULL)\n \t\tis_hidden = false;\n \n-\t      bvar = backend->global_variable(var_name,\n-\t\t\t\t\t      asm_name,\n+\t      // For some reason asm_name can't be the empty string\n+\t      // for global_variable, so we call asm_name rather than\n+\t      // optional_asm_name here.  FIXME.\n+\n+\t      bvar = backend->global_variable(bname.name(),\n+\t\t\t\t\t      bname.asm_name(),\n \t\t\t\t\t      btype,\n \t\t\t\t\t      package != NULL,\n \t\t\t\t\t      is_hidden,\n@@ -8043,6 +8060,7 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t    }\n \t  else\n \t    {\n+\t      const std::string n = Gogo::unpack_hidden_name(name);\n \t      Bfunction* bfunction = function->func_value()->get_decl();\n \t      bool is_address_taken = (this->is_non_escaping_address_taken_\n \t\t\t\t       && !this->is_in_heap());\n@@ -8216,7 +8234,13 @@ Named_constant::get_backend(Gogo* gogo, Named_object* const_no)\n       if (type != NULL && type->is_numeric_type())\n \t{\n \t  Btype* btype = type->get_backend(gogo);\n-\t  std::string name = const_no->get_id(gogo);\n+\t  std::string name;\n+\t  if (const_no->package() == NULL)\n+\t    name = gogo->pkgpath();\n+\t  else\n+\t    name = const_no->package()->pkgpath();\n+\t  name.push_back('.');\n+\t  name.append(Gogo::unpack_hidden_name(const_no->name()));\n \t  const_decl =\n \t    gogo->backend()->named_constant_expression(btype, name,\n \t\t\t\t\t\t       const_decl, loc);\n@@ -8637,54 +8661,6 @@ Named_object::get_backend_variable(Gogo* gogo, Named_object* function)\n     go_unreachable();\n }\n \n-// Return the external identifier for this object.\n-\n-std::string\n-Named_object::get_id(Gogo* gogo)\n-{\n-  go_assert(!this->is_variable()\n-\t    && !this->is_result_variable()\n-\t    && !this->is_type());\n-  std::string decl_name;\n-  if (this->is_function_declaration()\n-      && !this->func_declaration_value()->asm_name().empty())\n-    decl_name = this->func_declaration_value()->asm_name();\n-  else\n-    {\n-      std::string package_name;\n-      if (this->package_ == NULL)\n-\tpackage_name = gogo->package_name();\n-      else\n-\tpackage_name = this->package_->package_name();\n-\n-      // Note that this will be misleading if this is an unexported\n-      // method generated for an embedded imported type.  In that case\n-      // the unexported method should have the package name of the\n-      // package from which it is imported, but we are going to give\n-      // it our package name.  Fixing this would require knowing the\n-      // package name, but we only know the package path.  It might be\n-      // better to use package paths here anyhow.  This doesn't affect\n-      // the assembler code, because we always set that name in\n-      // Function::get_or_make_decl anyhow.  FIXME.\n-\n-      decl_name = package_name + '.' + Gogo::unpack_hidden_name(this->name_);\n-\n-      Function_type* fntype;\n-      if (this->is_function())\n-\tfntype = this->func_value()->type();\n-      else if (this->is_function_declaration())\n-\tfntype = this->func_declaration_value()->type();\n-      else\n-\tfntype = NULL;\n-      if (fntype != NULL && fntype->is_method())\n-\t{\n-\t  decl_name.push_back('.');\n-\t  decl_name.append(fntype->receiver()->type()->mangled_name(gogo));\n-\t}\n-    }\n-  return decl_name;\n-}\n-\n void\n debug_go_named_object(Named_object* no)\n {"}, {"sha": "f22d47656db04977b81f6a13ae31f607bd0bac4c", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 138, "deletions": 35, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -57,6 +57,101 @@ class Node;\n // This file declares the basic classes used to hold the internal\n // representation of Go which is built by the parser.\n \n+// The name of some backend object.  Backend objects have a\n+// user-visible name and an assembler name.  The user visible name\n+// might include arbitrary Unicode characters.  The assembler name\n+// will not.\n+\n+class Backend_name\n+{\n+ public:\n+  Backend_name()\n+    : prefix_(NULL), components_(), count_(0), suffix_(),\n+      is_asm_name_(false)\n+  {}\n+\n+  // Set the prefix.  Prefixes are always constant strings.\n+  void\n+  set_prefix(const char* p)\n+  {\n+    go_assert(this->prefix_ == NULL && !this->is_asm_name_);\n+    this->prefix_ = p;\n+  }\n+\n+  // Set the suffix.\n+  void\n+  set_suffix(const std::string& s)\n+  {\n+    go_assert(this->suffix_.empty() && !this->is_asm_name_);\n+    this->suffix_ = s;\n+  }\n+\n+  // Append to the suffix.\n+  void\n+  append_suffix(const std::string& s)\n+  {\n+    if (this->is_asm_name_)\n+      this->components_[0].append(s);\n+    else\n+      this->suffix_.append(s);\n+  }\n+\n+  // Add a component.\n+  void\n+  add(const std::string& c)\n+  {\n+    go_assert(this->count_ < Backend_name::max_components\n+\t      && !this->is_asm_name_);\n+    this->components_[this->count_] = c;\n+    ++this->count_;\n+  }\n+\n+  // Set an assembler name specified by the user.  This overrides both\n+  // the user-visible name and the assembler name.  No further\n+  // encoding is applied.\n+  void\n+  set_asm_name(const std::string& n)\n+  {\n+    go_assert(this->prefix_ == NULL\n+\t      && this->count_ == 0\n+\t      && this->suffix_.empty()\n+\t      && !this->is_asm_name_);\n+    this->components_[0] = n;\n+    this->is_asm_name_ = true;\n+  }\n+\n+  // Get the user visible name.\n+  std::string\n+  name() const;\n+\n+  // Get the assembler name.  This may be the same as the user visible\n+  // name.\n+  std::string\n+  asm_name() const;\n+\n+  // Get an optional assembler name: if it would be the same as the\n+  // user visible name, this returns the empty string.\n+  std::string\n+  optional_asm_name() const;\n+\n+ private:\n+  // The maximum number of components.\n+  static const int max_components = 4;\n+\n+  // An optional prefix that does not require encoding.\n+  const char *prefix_;\n+  // Up to four components.  The name will include these components\n+  // separated by dots.  Each component will be underscore-encoded\n+  // (see the long comment near the top of names.cc).\n+  std::string components_[Backend_name::max_components];\n+  // Number of components.\n+  int count_;\n+  // An optional suffix that does not require encoding.\n+  std::string suffix_;\n+  // True if components_[0] is an assembler name specified by the user.\n+  bool is_asm_name_;\n+};\n+\n // An initialization function for an imported package.  This is a\n // magic function which initializes variables and runs the \"init\"\n // function.\n@@ -613,16 +708,15 @@ class Gogo\n   // is used when a type-specific hash function is needed when not at\n   // top level.\n   void\n-  queue_hash_function(Type* type, int64_t size, const std::string& hash_name,\n+  queue_hash_function(Type* type, int64_t size, Backend_name*,\n \t\t      Function_type* hash_fntype);\n \n   // Queue up a type-specific equal function to be written out.  This\n   // is used when a type-specific equal function is needed when not at\n   // top level.\n   void\n   queue_equal_function(Type* type, Named_type* name, int64_t size,\n-\t\t       const std::string& equal_name,\n-\t\t       Function_type* equal_fntype);\n+\t\t       Backend_name*, Function_type* equal_fntype);\n \n   // Write out queued specific type functions.\n   void\n@@ -869,31 +963,32 @@ class Gogo\n   Expression*\n   allocate_memory(Type *type, Location);\n \n-  // Return the assembler name to use for an exported function, a\n-  // method, or a function/method declaration.\n-  std::string\n-  function_asm_name(const std::string& go_name, const Package*,\n-\t\t    const Type* receiver);\n+  // Get the backend name to use for an exported function, a method,\n+  // or a function/method declaration.\n+  void\n+  function_backend_name(const std::string& go_name, const Package*,\n+\t\t\tconst Type* receiver, Backend_name*);\n \n   // Return the name to use for a function descriptor.\n-  std::string\n-  function_descriptor_name(Named_object*);\n+  void\n+  function_descriptor_backend_name(Named_object*, Backend_name*);\n \n   // Return the name to use for a generated stub method.\n   std::string\n   stub_method_name(const Package*, const std::string& method_name);\n \n-  // Return the name of the hash function for TYPE.\n-  std::string\n-  hash_function_name(const Type*);\n+  // Get the backend name of the hash function for TYPE.\n+  void\n+  hash_function_name(const Type*, Backend_name*);\n \n-  // Return the name of the equal function for TYPE.\n-  std::string\n-  equal_function_name(const Type*, const Named_type*);\n+  // Get the backend name of the equal function for TYPE.\n+  void\n+  equal_function_name(const Type*, const Named_type*, Backend_name*);\n \n-  // Return the assembler name to use for a global variable.\n-  std::string\n-  global_var_asm_name(const std::string& go_name, const Package*);\n+  // Get the backend name to use for a global variable.\n+  void\n+  global_var_backend_name(const std::string& go_name, const Package*,\n+\t\t\t  Backend_name*);\n \n   // Return a name to use for an error case.  This should only be used\n   // after reporting an error, and is used to avoid useless knockon\n@@ -961,13 +1056,14 @@ class Gogo\n   // Return the package path symbol from an init function name, which\n   // can be a real init function or a dummy one.\n   std::string\n-  pkgpath_from_init_fn_name(std::string);\n+  pkgpath_symbol_from_init_fn_name(std::string);\n \n-  // Return the name for a type descriptor symbol.\n-  std::string\n-  type_descriptor_name(const Type*, Named_type*);\n+  // Get the backend name for a type descriptor symbol.\n+  void\n+  type_descriptor_backend_name(const Type*, Named_type*, Backend_name*);\n \n   // Return the name of the type descriptor list symbol of a package.\n+  // The argument is an encoded pkgpath, as with pkgpath_symbol.\n   std::string\n   type_descriptor_list_symbol(const std::string&);\n \n@@ -987,11 +1083,11 @@ class Gogo\n   std::string\n   interface_method_table_name(Interface_type*, Type*, bool is_pointer);\n \n-  // Return whether NAME is a special name that can not be passed to\n-  // unpack_hidden_name.  This is needed because various special names\n-  // use \"..SUFFIX\", but unpack_hidden_name just looks for '.'.\n-  static bool\n-  is_special_name(const std::string& name);\n+  // If NAME is a special name used as a Go identifier, return the\n+  // position within the string where the special part of the name\n+  // occurs.\n+  static size_t\n+  special_name_pos(const std::string& name);\n \n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n@@ -1056,6 +1152,9 @@ class Gogo\n   Named_object*\n   write_barrier_variable();\n \n+  static bool\n+  is_digits(const std::string&);\n+\n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;\n \n@@ -1079,15 +1178,15 @@ class Gogo\n     Named_type* name;\n     int64_t size;\n     Specific_type_function_kind kind;\n-    std::string fnname;\n+    Backend_name bname;\n     Function_type* fntype;\n \n     Specific_type_function(Type* atype, Named_type* aname, int64_t asize,\n \t\t\t   Specific_type_function_kind akind,\n-\t\t\t   const std::string& afnname,\n+\t\t\t   Backend_name* abname,\n \t\t\t   Function_type* afntype)\n       : type(atype), name(aname), size(asize), kind(akind),\n-\tfnname(afnname), fntype(afntype)\n+\tbname(*abname), fntype(afntype)\n     { }\n   };\n \n@@ -1631,6 +1730,10 @@ class Function\n   Bstatement*\n   return_value(Gogo*, Named_object*, Location) const;\n \n+  // Get the backend name of this function.\n+  void\n+  backend_name(Gogo*, Named_object*, Backend_name*);\n+\n   // Get an expression for the variable holding the defer stack.\n   Expression*\n   defer_stack(Location);\n@@ -1872,6 +1975,10 @@ class Function_declaration\n   void\n   build_backend_descriptor(Gogo*);\n \n+  // Get the backend name of this function declaration.\n+  void\n+  backend_name(Gogo*, Named_object*, Backend_name*);\n+\n   // Export a function declaration.\n   void\n   export_func(Export* exp, const Named_object* no) const\n@@ -2863,10 +2970,6 @@ class Named_object\n   Bvariable*\n   get_backend_variable(Gogo*, Named_object* function);\n \n-  // Return the external identifier for this object.\n-  std::string\n-  get_id(Gogo*);\n-\n   // Get the backend representation of this object.\n   void\n   get_backend(Gogo*, std::vector<Bexpression*>&, std::vector<Btype*>&,"}, {"sha": "0097417cff0003edc6352784259efeb67c55ce3e", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 433, "deletions": 326, "changes": 759, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -15,53 +15,68 @@\n // assembly code.  This is not used for names that appear only in the\n // debug info.\n \n-// Our external names contain only ASCII alphanumeric characters,\n+// Our external names may contain only ASCII alphanumeric characters,\n // underscore, and dot.  (According to the GCC sources, dot is not\n // permitted in assembler symbols on VxWorks and MMIX.  We will not\n-// support those systems.)  Go names can not contain dot, so we rely\n-// on using dot to encode Unicode characters, and to separate Go\n-// symbols by package, and so forth.  We assume that none of the\n-// non-Go symbols in the final link will contain a dot, so we don't\n-// worry about conflicts.\n+// support those systems.)  Go identifiers cannot contain dot, but Go\n+// package paths can.  Both Go identifiers and package paths can, of\n+// course, contain all sorts of Unicode characters.\n+//\n+// The gc compiler uses names like \"pkg.F\", and it seems convenient to\n+// emulate that.  Therefore, we will use dot to separate different\n+// components of names.\n+//\n+// Since package paths can contain dot, to avoid ambiguity we must\n+// encode package paths such that they do not contain any dot.  The\n+// natural way to do this is to encode forbidden characters, including\n+// dot, using a notation based on underscore.  We will, of course,\n+// have to encode underscore itself.\n+//\n+// Since we will be using an underscore encoding for the package path,\n+// it seems reasonable to use the same encoding for Go identifiers.\n+// This has the disadvantage that encoded Go identifiers will appear\n+// to be valid Go identifiers with funny spellings, but it seems like\n+// the best available approach.\n+//\n+// Therefore, in the following discussion we may assume that none of\n+// the names under discussion contain a dot.  All of the names we\n+// generate for Go identifiers (that don't use //export or\n+// //go:linkname) will contain at least one dot, as discussed below.\n+// We assume that none of the non-Go symbols in the final link will\n+// contain a dot, so we don't worry about conflicts.\n //\n // We first describe the basic symbol names, used to represent Go\n-// functions and variables.  These never start with a dot, never end\n-// with a dot, never contain two consecutive dots, and never contain a\n-// dot followed by a digit.\n+// functions and variables.\n //\n // The external name for a normal Go symbol NAME, a function or\n // variable, is simply \"PKGPATH.NAME\".  Note that NAME is not the\n // packed form used for the \"hidden\" name internally in the compiler;\n-// it is the name that appears in the source code.  PKGPATH is the\n-// -fgo-pkgpath option as adjusted by Gogo::pkgpath_for_symbol. Note\n-// that PKGPATH can not contain a dot and neither can NAME.  Also,\n-// NAME may not begin with a digit.  NAME may require further encoding\n-// for non-ASCII characters as described below, but until that\n-// encoding these symbols contain exactly one dot, and they do not\n-// start with a dot.\n+// it is the name that appears in the source code.  Both PKGPATH and\n+// NAME will be encoded as described below.  The encoding process\n+// ensures that neither encoded string can contain a dot, and neither\n+// will start with a digit (NAME is a Go identifier that can't contain\n+// a dot or start with a digit anyhow).  The encoding process means\n+// that these external names contain exactly one dot and do not start\n+// with a dot.\n //\n // The external name for a method NAME for a named type TYPE is\n-// \"PKGPATH.TYPE.NAME\".  Unlike the gc compiler, the external name\n-// does not indicate whether this is a pointer method or a value\n-// method; a named type can not have both a pointer and value method\n-// with the same name, so there is no ambiguity.  PKGPATH is the\n-// package path of the package in which TYPE is defined.  Here none of\n-// PKGPATH, TYPE, or NAME can be empty or contain a dot, and neither\n-// TYPE nor NAME may begin with a digit.  Before encoding these names\n-// contain exactly two dots, not consecutive, and they do not start\n-// with a dot.\n+// \"PKGPATH.TYPE.NAME\".  Both NAME and TYPE are simple Go identifiers.\n+// Unlike the gc compiler, the external name does not indicate whether\n+// this is a pointer method or a value method; a named type can not\n+// have both a pointer and value method with the same name, so there\n+// is no ambiguity.  PKGPATH is the package path of the package in\n+// which TYPE is defined.  PKGPATH, TYPE, and NAME are encoded, and\n+// cannot be empty or contain a dot or start with a digit.  These\n+// external names contain exactly two dots, not consecutive, and they\n+// do not start with a dot.\n //\n // It's uncommon, but the use of type literals with embedded fields\n // can cause us to have methods on unnamed types.  The external names\n-// for these are also PKGPATH.TYPE.NAME, where TYPE is an\n+// for these are also PKGPATH.TYPELIT.NAME, where TYPELIT is an\n // approximately readable version of the type literal, described\n-// below.  As the type literal encoding always contains multiple dots,\n-// these names always contain more than two dots.  Although the type\n-// literal encoding contains dots, neither PKGPATH nor NAME can\n-// contain a dot, and neither TYPE nor NAME can begin with a digit.\n-// The effect is that PKGPATH is always the portion of the name before\n-// the first dot and NAME is always the portion after the last dot.\n-// There is no ambiguity as long as encoded type literals are\n+// below.  A TYPELIT will always contain characters that cannot appear\n+// in a Go identifier, so TYPELIT can never be confused with a TYPE\n+// name.  There is no ambiguity as long as encoded type literals are\n // unambiguous.\n //\n // Also uncommon is an external name that must refer to a named type\n@@ -91,46 +106,51 @@\n // the function with an added suffix \"..f\".\n //\n // A thunk for a go or defer statement is treated as a function whose\n-// name is \".thunkNN\" where NN is a sequence of digits (these\n-// functions are never globally visible).  Thus the final name of a\n-// thunk will be PKGPATH..thunkNN.\n+// name is \".thunkNN\", unencoded, where NN is a sequence of digits\n+// (these functions are never globally visible).  Thus the final name\n+// of a thunk will be PKGPATH..thunkNN (PKGPATH is encoded).\n //\n-// An init function is treated as a function whose name is \".initNN\"\n-// where NN is a sequence of digits (these functions are never\n-// globally visible).  Thus the final name of an init function will be\n-// PKGPATH..initNN.\n+// An init function is treated as a function whose name is \".initNN\",\n+// unencoded, where NN is a sequence of digits (these functions are\n+// never globally visible).  Thus the final name of an init function\n+// will be PKGPATH..initNN (PKGPATH is encoded).\n //\n // A nested function is given the name of outermost enclosing function\n-// or method with an added suffix \"..funcNN\" where NN is a sequence of\n-// digits.  Note that the function descriptor of a nested function, if\n-// needed, will end with \"..funcNN..f\".\n+// or method with an added suffix \"..funcNN\", unencoded, where NN is a\n+// sequence of digits.  Note that the function descriptor of a nested\n+// function, if needed, will end with \"..funcNN..f\".\n //\n // A recover thunk is the same as the name of the function with an\n // added suffix \"..r\".\n //\n-// The name of a type descriptor for a named type is PKGPATH.TYPE..d.\n+// The name of a type descriptor for a named type is\n+// PKGPATH.TYPENAME..d (PKGPATH and TYPENAME are encoded).\n //\n-// The name of a type descriptor for an unnamed type is type..TYPE.\n-// That is, the string \"type..\" followed by the type literal encoding.\n+// The name of a type descriptor for a pointer to a named type is\n+// PKGPATH.TYPENAME..p (PKGPATH and TYPENAME are encoded).\n+//\n+// The name of a type descriptor for an unnamed type is type..TYPELIT.\n+// That is, the string \"type..\" followed by the encoded type literal.\n // These names are common symbols, in the linker's sense of the word\n // common: in the final executable there is only one instance of the\n-// type descriptor for a given unnamed type.  The type literal\n-// encoding can never start with a digit or with 'u' or 'U'.\n+// type descriptor for a given unnamed type.\n //\n-// The name of the GC symbol for a named type is PKGPATH.TYPE..g.\n+// The name of the GC symbol for a named type is PKGPATH.TYPE..g\n+// (PKGPATH and TYPE are encoded).\n //\n-// The name of the GC symbol for an unnamed type is typeg..TYPE.\n+// The name of the GC symbol for an unnamed type is type..TYPELIT..g.\n // These are common symbols.\n //\n // The name of a ptrmask symbol is gcbits..B32 where B32 is an\n-// encoding of the ptrmask bits using only ASCII letters without 'u'\n-// or 'U'.  These are common symbols.\n+// encoding of the ptrmask bits using only ASCII letters.  These are\n+// common symbols.\n //\n // An interface method table for assigning the non-interface type TYPE\n // to the interface type ITYPE is named imt..ITYPE..TYPE.  If ITYPE or\n-// TYPE is a named type, they are written as PKGPATH.TYPE.  Otherwise\n-// they are written as a type literal.  An interface method table for\n-// a pointer method set uses pimt instead of imt.\n+// TYPE is a named type, they are written as PKGPATH.TYPE (where both\n+// PKGPATH and TYPE are encoded).  Otherwise they are written as a\n+// type literal.  An interface method table for a pointer method set\n+// uses pimt instead of imt.\n //\n // The names of composite literal initializers, including the GC root\n // variable, are not referenced.  They must not conflict with any C\n@@ -147,7 +167,7 @@\n // PKGPATH..import.  If a package doesn't need an init function, it\n // will have a dummy one, named ~PKGPATH.\n //\n-// In each pacakge there is a list of all the type descriptors defined\n+// In each package there is a list of all the type descriptors defined\n // in this package.  The name of the list is PKGPATH..types.\n //\n // In the main package it gathers all the type descriptor lists in a\n@@ -161,109 +181,109 @@\n // The type literal encoding is not quite valid Go, as some aspects of\n // compiler generated types can not be represented.  For example,\n // incomparable struct types have an extra field \"{x}\".  Struct tags\n-// are quoted inside curly braces, rather than introduce an encoding\n-// for quotes.  Struct tags can contain any character, so any single\n-// byte Unicode character that is not alphanumeric or underscore is\n-// replaced with .xNN where NN is the hex encoding.\n+// can contain any character, which will be underscore encoded as\n+// usual.  In the unusual case of a curly brace or a backslash in a\n+// struct tag, the brace or backslash will be backslash quoted, before\n+// underscore encoding.\n+//\n+// The underscore encoding is, naturally, an underscore followed by\n+// other characters.  As there are various characters that commonly\n+// appear in type literals and in package paths, we have a set of\n+// short encodings.  Then we have general encodings for other\n+// characters.\n //\n-// There is a simple encoding for glue characters in type literals:\n-//   .0 - ' '\n-//   .1 - '*'\n-//   .2 - ';'\n-//   .3 - ','\n-//   .4 - '{'\n-//   .5 - '}'\n-//   .6 - '['\n-//   .7 - ']'\n-//   .8 - '('\n-//   .9 - ')'\n-// This is unambiguous as, although the type literal can contain a dot\n-// as shown above, those dots are always followed by a name and names\n-// can not begin with a digit.  A dot is always followed by a name or\n-// a digit, and a type literal can neither start nor end with a dot,\n-// so this never introduces consecutive dots.\n+//   __ - '_'\n+//   _0 - '.'\n+//   _1 - '/'\n+//   _2 - '*'\n+//   _3 - ','\n+//   _4 - '{'\n+//   _5 - '}'\n+//   _6 - '['\n+//   _7 - ']'\n+//   _8 - '('\n+//   _9 - ')'\n+//   _a - '\"'\n+//   _b - ' '\n+//   _c - ';'\n //\n-// Struct tags can contain any character, so they need special\n-// treatment.  Alphanumerics, underscores, and Unicode characters that\n-// require more than a single byte are left alone (Unicode characters\n-// will be encoded later, as described below).  Other single bytes\n-// characters are replace with .xNN where NN is the hex encoding.\n+// Other non-alphanumeric ASCII characters are encoded as _xNN, where\n+// NN is the hex value for the character.  If an encoded name would\n+// otherwise start with a digit, this encoding is also used for the\n+// leading digit.\n //\n-// Since Go identifiers can contain Unicode characters, we must encode\n-// them into ASCII.  We do this last, after the name is generated as\n-// described above and after type literals are encoded.  To make the\n-// encoding unambiguous, we introduce it with two consecutive dots.\n-// This is followed by the letter u and four hex digits or the letter\n-// U and eight digits, just as in the language only using ..u and ..U\n-// instead of \\u and \\U.  The compiler also produces identifiers that\n-// are qualified by package path, which means that there may also be ASCII\n-// characters that are not assembler-friendly (ex: '=', '/'). The encoding\n-// scheme translates such characters into the \"..zNN\" where NN is the\n-// hex value for the character. Since before this encoding names can never\n-// contain consecutive dots followed by 'z', 'u' or 'U', and after this\n-// encoding \"..z\", \"..u\" and \"..U\" are followed by a known number of\n-// characters, this is unambiguous.\n+// Non-ASCII Unicode characters are encoded as _u and four hex digits\n+// or _U and eight digits, just as in the language only using _u and\n+// _U instead of \\u and \\U.\n //\n // Demangling these names is straightforward:\n-//  - replace ..zXX with an ASCII character\n-//  - replace ..uXXXX with a unicode character\n-//  - replace ..UXXXXXXXX with a unicode character\n-//  - replace .D, where D is a digit, with the character from the above\n+//  - replace _xXX with an ASCII character\n+//  - replace _uXXXX with a unicode character\n+//  - replace _UXXXXXXXX with a unicode character\n+//  - replace _C per the table above\n // That will get you as close as possible to a readable name.\n \n-// Return the assembler name to use for an exported function, a\n-// method, or a function/method declaration.  This is not called if\n-// the function has been given an explicit name via a magic //extern\n-// or //go:linkname comment.  GO_NAME is the name that appears in the\n-// Go code.  PACKAGE is the package where the function is defined, and\n-// is NULL for the package being compiled.  For a method, RTYPE is\n+// Set BNAME to the name to use for an exported function, a method, or\n+// a function/method declaration.  GO_NAME is the name that appears in\n+// the Go code.  PACKAGE is the package where the function is defined,\n+// and is NULL for the package being compiled.  For a method, RTYPE is\n // the method's receiver type; for a function, RTYPE is NULL.\n \n-std::string\n-Gogo::function_asm_name(const std::string& go_name, const Package* package,\n-\t\t\tconst Type* rtype)\n+void\n+Gogo::function_backend_name(const std::string& go_name,\n+\t\t\t    const Package* package, const Type* rtype,\n+\t\t\t    Backend_name* bname)\n {\n-  std::string ret;\n   if (rtype != NULL)\n-    ret = rtype->deref()->mangled_name(this);\n+    rtype->deref()->backend_name(this, bname);\n   else if (package == NULL)\n-    ret = this->pkgpath();\n+    bname->add(this->pkgpath());\n   else\n-    ret = package->pkgpath();\n-  ret.push_back('.');\n-  // Check for special names that will break if we use\n-  // Gogo::unpack_hidden_name.\n-  if (Gogo::is_special_name(go_name))\n-    ret.append(go_name);\n+    bname->add(package->pkgpath());\n+\n+  size_t pos = Gogo::special_name_pos(go_name);\n+  if (pos == std::string::npos)\n+    bname->add(Gogo::unpack_hidden_name(go_name));\n   else\n-    ret.append(Gogo::unpack_hidden_name(go_name));\n-  return go_encode_id(ret);\n+    {\n+      if (pos > 0)\n+\tbname->add(go_name.substr(0, pos));\n+      bname->set_suffix(go_name.substr(pos));\n+    }\n }\n \n-// Return the name to use for a function descriptor.  These symbols\n-// are globally visible.\n+// Set BNAME to the name to use for a function descriptor.  These\n+// symbols are globally visible.\n \n-std::string\n-Gogo::function_descriptor_name(Named_object* no)\n+void\n+Gogo::function_descriptor_backend_name(Named_object* no,\n+\t\t\t\t       Backend_name* bname)\n {\n-  if (no->is_function() && !no->func_value()->asm_name().empty())\n-    return no->func_value()->asm_name() + \"..f\";\n-  else if (no->is_function_declaration()\n-\t   && !no->func_declaration_value()->asm_name().empty())\n-    return no->func_declaration_value()->asm_name() + \"..f\";\n-  std::string ret = this->function_asm_name(no->name(), no->package(), NULL);\n-  ret.append(\"..f\");\n-  return ret;\n+  if (no->is_function())\n+    no->func_value()->backend_name(this, no, bname);\n+  else if (no->is_function_declaration())\n+    no->func_declaration_value()->backend_name(this, no, bname);\n+  else\n+    go_unreachable();\n+  bname->append_suffix(\"..f\");\n }\n \n-// Return the name to use for a generated stub method.  MNAME is the\n-// method name.  PACKAGE is the package where the type that needs this\n-// stub method is defined.  These functions are globally visible.\n-// Note that this is the function name that corresponds to the name\n-// used for the method in Go source code, if this stub method were\n-// written in Go.  The assembler name will be generated by\n-// Gogo::function_asm_name, and because this is a method that name\n-// will include the receiver type.\n+// Return the name to use for a generated stub method.  A stub method\n+// is used as the method table entry for a promoted method of an\n+// embedded type.  MNAME is the method name.  PACKAGE is the package\n+// where the type that needs this stub method is defined.  These\n+// functions are globally visible.\n+//\n+// This returns a name that acts like a Go identifier, as though the\n+// stub method were written in Go as an explicitly defined method that\n+// simply calls the promoted method.  The name we return here will\n+// eventually be passed to function_backend_name, which will return a\n+// name that includes the receiver type.\n+//\n+// We construct a unique method name and append \"..stub\".\n+// function_backend_name will look for the \"..stub\" and turn that into\n+// an unencoded suffix.  The rest of the name will be encoded as\n+// usual.\n \n std::string\n Gogo::stub_method_name(const Package* package, const std::string& mname)\n@@ -279,56 +299,70 @@ Gogo::stub_method_name(const Package* package, const std::string& mname)\n     return Gogo::unpack_hidden_name(mname) + \"..stub\";\n \n   // We are creating a stub method for an unexported method of an\n-  // imported embedded type.  We need to disambiguate the method name.\n-  std::string ret = mpkgpath;\n+  // imported embedded type.  A single type can have multiple promoted\n+  // methods with the same unexported name, if it embeds types from\n+  // different packages.  We need to disambiguate the method name.\n+  // This produces an unambiguous name because even though MPKGPATH\n+  // can be anything, we know that MNAME does not contain a dot.  The\n+  // dot we return here, between MPKGPATH and MNAME, will wind up\n+  // being underscore encoded.\n+  std::string ret(mpkgpath);\n   ret.push_back('.');\n   ret.append(Gogo::unpack_hidden_name(mname));\n   ret.append(\"..stub\");\n   return ret;\n }\n \n-// Return the name of the hash function for TYPE.\n+// Set BNAME to the name of the hash function for TYPE.\n \n-std::string\n-Gogo::hash_function_name(const Type* type)\n+void\n+Gogo::hash_function_name(const Type* type, Backend_name* bname)\n {\n-  std::string tname = type->mangled_name(this);\n-  return tname + \"..hash\";\n+  if (type->named_type() != NULL)\n+    type->backend_name(this, bname);\n+  else\n+    {\n+      bname->add(this->pkgpath());\n+      type->backend_name(this, bname);\n+    }\n+  bname->set_suffix(\"..hash\");\n }\n \n-// Return the name of the equal function for TYPE.  If NAME is not\n-// NULL it is the name of the type.\n+// Set BNAME to the name of the equal function for TYPE.  If NAME is\n+// not NULL it is the name of the type.\n \n-std::string\n-Gogo::equal_function_name(const Type* type, const Named_type* name)\n+void\n+Gogo::equal_function_name(const Type* type, const Named_type* name,\n+\t\t\t  Backend_name* bname)\n {\n-  const Type* rtype = type;\n   if (name != NULL)\n-    rtype = name;\n-  std::string tname = rtype->mangled_name(this);\n-  return tname + \"..eq\";\n+    name->backend_name(this, bname);\n+  else\n+    {\n+      bname->add(this->pkgpath());\n+      type->backend_name(this, bname);\n+    }\n+  bname->set_suffix(\"..eq\");\n }\n \n-// Return the assembler name to use for a global variable.  GO_NAME is\n-// the name that appears in the Go code.  PACKAGE is the package where\n-// the variable is defined, and is NULL for the package being\n-// compiled.\n+// Set BNAME to the name to use for a global variable.  GO_NAME is the\n+// name that appears in the Go code.  PACKAGE is the package where the\n+// variable is defined, and is NULL for the package being compiled.\n \n-std::string\n-Gogo::global_var_asm_name(const std::string& go_name, const Package* package)\n+void\n+Gogo::global_var_backend_name(const std::string& go_name,\n+\t\t\t      const Package* package,\n+\t\t\t      Backend_name* bname)\n {\n-  std::string ret;\n   if (package == NULL)\n-    ret = this->pkgpath();\n+    bname->add(this->pkgpath());\n   else\n-    ret = package->pkgpath();\n-  ret.append(1, '.');\n-  ret.append(Gogo::unpack_hidden_name(go_name));\n-  return go_encode_id(ret);\n+    bname->add(package->pkgpath());\n+  bname->add(Gogo::unpack_hidden_name(go_name));\n }\n \n // Return an erroneous name that indicates that an error has already\n-// been reported.\n+// been reported.  This name will act like a Go identifier.\n \n std::string\n Gogo::erroneous_name()\n@@ -349,7 +383,10 @@ Gogo::is_erroneous_name(const std::string& name)\n   return name.compare(0, 10, \".erroneous\") == 0;\n }\n \n-// Return a name for a thunk object.\n+// Return a name for a thunk object.  This name will act like a Go\n+// identifier.  The name returned here will eventually be passed to\n+// function_backend_name, which will pull off the ..thunk as an\n+// unencoded suffix.\n \n std::string\n Gogo::thunk_name()\n@@ -358,7 +395,12 @@ Gogo::thunk_name()\n   char thunk_name[50];\n   snprintf(thunk_name, sizeof thunk_name, \"..thunk%d\", thunk_count);\n   ++thunk_count;\n-  std::string ret = this->pkgpath();\n+  // We don't want to return a name that starts with a dot, as that\n+  // will confuse Gogo::is_hidden_name.  And we don't want to change\n+  // ..thunk, which fits our general theme and is used by code like\n+  // runtime.Callers.  But the prefix doesn't matter, as the actual\n+  // name will include the package path.\n+  std::string ret = \"go\";\n   return ret + thunk_name;\n }\n \n@@ -368,13 +410,10 @@ bool\n Gogo::is_thunk(const Named_object* no)\n {\n   const std::string& name(no->name());\n-  size_t i = name.find(\"..thunk\");\n+  size_t i = name.rfind(\"..thunk\");\n   if (i == std::string::npos)\n     return false;\n-  for (i += 7; i < name.size(); ++i)\n-    if (name[i] < '0' || name[i] > '9')\n-      return false;\n-  return true;\n+  return Gogo::is_digits(name.substr(i + 7));\n }\n \n // Return the name to use for an init function.  There can be multiple\n@@ -387,11 +426,12 @@ Gogo::init_function_name()\n   char buf[30];\n   snprintf(buf, sizeof buf, \"..init%d\", init_count);\n   ++init_count;\n-  std::string ret = this->pkgpath();\n-  return ret + buf;\n+  return this->pkgpath() + buf;\n }\n \n-// Return the name to use for a nested function.\n+// Return the name to use for a nested function.  This name acts like\n+// a Go identifier.  This name will be rewritten by\n+// Function::backend_name.\n \n std::string\n Gogo::nested_function_name(Named_object* enclosing)\n@@ -420,7 +460,9 @@ Gogo::nested_function_name(Named_object* enclosing)\n \tenclosing->func_value()->type()->receiver();\n       if (rcvr != NULL)\n \t{\n-\t  prefix = rcvr->type()->mangled_name(this);\n+\t  Backend_name bname;\n+\t  rcvr->type()->backend_name(this, &bname);\n+\t  prefix = bname.name();\n \t  prefix.push_back('.');\n \t}\n       prefix.append(Gogo::unpack_hidden_name(enclosing->name()));\n@@ -460,18 +502,21 @@ Gogo::redefined_function_name()\n }\n \n // Return the name to use for a recover thunk for the function NAME.\n-// If the function is a method, RTYPE is the receiver type.\n+// If the function is a method, RTYPE is the receiver type.  This is a\n+// name that acts like a Go identifier.\n \n std::string\n Gogo::recover_thunk_name(const std::string& name, const Type* rtype)\n {\n   std::string ret;\n   if (rtype != NULL)\n     {\n-      ret = rtype->mangled_name(this);\n+      Backend_name bname;\n+      rtype->backend_name(this, &bname);\n+      ret = bname.name();\n       ret.append(1, '.');\n     }\n-  if (Gogo::is_special_name(name))\n+  if (Gogo::special_name_pos(name) != std::string::npos)\n     ret.append(name);\n   else\n     ret.append(Gogo::unpack_hidden_name(name));\n@@ -504,16 +549,18 @@ Gogo::initializer_name()\n   return buf;\n }\n \n-// Return the name of the variable used to represent the zero value of\n-// a map.  This is a globally visible common symbol.\n+// Return the assembler name of the variable used to represent the\n+// zero value of a map.  This is a globally visible common symbol.\n \n std::string\n Gogo::map_zero_value_name()\n {\n   return \"go..zerovalue\";\n }\n \n-// Return the name to use for the import control function.\n+// Return the name to use for the import control function.  This name\n+// is handled specially by Function::backend_name.  It is not encoded\n+// further.\n \n const std::string&\n Gogo::get_init_fn_name()\n@@ -550,7 +597,7 @@ Gogo::dummy_init_fn_name()\n // can be a real init function or a dummy one.\n \n std::string\n-Gogo::pkgpath_from_init_fn_name(std::string name)\n+Gogo::pkgpath_symbol_from_init_fn_name(std::string name)\n {\n   go_assert(!name.empty());\n   if (name[0] == '~')\n@@ -561,60 +608,38 @@ Gogo::pkgpath_from_init_fn_name(std::string name)\n   go_unreachable();\n }\n \n-// Return a mangled name for a type.  These names appear in symbol\n-// names in the assembler file for things like type descriptors and\n-// methods.\n+// Set BNAME to a name for a type to use in a symbol.  Return a name\n+// for a type to use in a symbol.  These names appear in symbol names\n+// in the assembler file for things like type descriptors and methods.\n \n-std::string\n-Type::mangled_name(Gogo* gogo) const\n+void\n+Type::backend_name(Gogo* gogo, Backend_name* bname) const\n {\n-  std::string ret;\n-\n-  // The do_mangled_name virtual function will set RET to the mangled\n-  // name before glue character mapping.\n-  this->do_mangled_name(gogo, &ret);\n-\n-  // Type descriptor names and interface method table names use a \"..\"\n-  // before the mangled name of a type, so to avoid ambiguity the\n-  // mangled name must not start with 'u' or 'U' or a digit.\n-  go_assert((ret[0] < '0' || ret[0] > '9') && ret[0] != ' ');\n-  if (ret[0] == 'u' || ret[0] == 'U')\n-    ret = \" \" + ret;\n-\n-  // Map glue characters as described above.\n-\n-  // The mapping is only unambiguous if there is no .DIGIT in the\n-  // string, so check that.\n-  for (size_t i = ret.find('.');\n-       i != std::string::npos;\n-       i = ret.find('.', i + 1))\n+  // Special case top level named types to get nicer name encodings\n+  // for this common case.\n+  const Named_type* nt = this->unalias()->named_type();\n+  if (nt != NULL && !nt->is_builtin())\n     {\n-      if (i + 1 < ret.size())\n+      unsigned int index;\n+      if (nt->in_function(&index) == NULL)\n \t{\n-\t  char c = ret[i + 1];\n-\t  go_assert(c < '0' || c > '9');\n+\t  const Named_object* no = nt->named_object();\n+\t  if (no->package() == NULL)\n+\t    bname->add(gogo->pkgpath());\n+\t  else\n+\t    bname->add(no->package()->pkgpath());\n+\t  bname->add(Gogo::unpack_hidden_name(no->name()));\n+\t  return;\n \t}\n     }\n \n-  // The order of these characters is the replacement code.\n-  const char * const replace = \" *;,{}[]()\";\n+  std::string name;\n \n-  const size_t rlen = strlen(replace);\n-  char buf[2];\n-  buf[0] = '.';\n-  for (size_t ri = 0; ri < rlen; ++ri)\n-    {\n-      buf[1] = '0' + ri;\n-      while (true)\n-\t{\n-\t  size_t i = ret.find(replace[ri]);\n-\t  if (i == std::string::npos)\n-\t    break;\n-\t  ret.replace(i, 1, buf, 2);\n-\t}\n-    }\n+  // The do_symbol_name virtual function will set RET to the mangled\n+  // name before encoding.\n+  this->do_mangled_name(gogo, &name);\n \n-  return ret;\n+  bname->add(name);\n }\n \n // The mangled name is implemented as a method on each instance of\n@@ -701,12 +726,7 @@ Function_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \t  else\n \t    ret->push_back(',');\n \t  if (this->is_varargs_ && p + 1 == params->end())\n-\t    {\n-\t      // We can't use \"...\" here because the mangled name\n-\t      // might start with 'u' or 'U', which would be ambiguous\n-\t      // with the encoding of Unicode characters.\n-\t      ret->append(\",,,\");\n-\t    }\n+\t    ret->append(\"...\");\n \t  this->append_mangled_name(p->type(), gogo, ret);\n \t}\n     }\n@@ -776,15 +796,15 @@ Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \t  if (p->is_anonymous()\n \t      && p->type()->named_type() != NULL\n \t      && p->type()->named_type()->is_alias())\n-\t    p->type()->named_type()->append_mangled_type_name(gogo, true, ret);\n+\t    p->type()->named_type()->append_symbol_type_name(gogo, true, ret);\n \t  else\n \t    this->append_mangled_name(p->type(), gogo, ret);\n \n \t  if (p->has_tag())\n \t    {\n \t      // Use curly braces around a struct tag, since they are\n-\t      // unambiguous here and we have no encoding for\n-\t      // quotation marks.\n+\t      // unambiguous here and struct tags rarely contain curly\n+\t      // braces.\n \t      ret->push_back('{');\n \t      ret->append(go_mangle_struct_tag(p->tag()));\n \t      ret->push_back('}');\n@@ -837,10 +857,10 @@ void\n Channel_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n   if (!this->may_send_)\n-    ret->append(\"{}\");\n+    ret->append(\"<-\");\n   ret->append(\"chan\");\n   if (!this->may_receive_)\n-    ret->append(\"{}\");\n+    ret->append(\"<-\");\n   ret->push_back(' ');\n   this->append_mangled_name(this->element_type_, gogo, ret);\n }\n@@ -883,7 +903,7 @@ Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n void\n Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n {\n-  this->append_mangled_type_name(gogo, false, ret);\n+  this->append_symbol_type_name(gogo, false, ret);\n }\n \n void\n@@ -903,13 +923,13 @@ Forward_declaration_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n     }\n }\n \n-// Append the mangled name for a named type to RET.  For an alias we\n+// Append the symbol name for a named type to RET.  For an alias we\n // normally use the real name, but if USE_ALIAS is true we use the\n // alias name itself.\n \n void\n-Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n-\t\t\t\t     std::string* ret) const\n+Named_type::append_symbol_type_name(Gogo* gogo, bool use_alias,\n+\t\t\t\t    std::string* ret) const\n {\n   if (this->is_error_)\n     return;\n@@ -933,7 +953,11 @@ Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n \t  const Typed_identifier* rcvr =\n \t    this->in_function_->func_value()->type()->receiver();\n \t  if (rcvr != NULL)\n-\t    ret->append(rcvr->type()->deref()->mangled_name(gogo));\n+\t    {\n+\t      Backend_name bname;\n+\t      rcvr->type()->deref()->backend_name(gogo, &bname);\n+\t      ret->append(bname.name());\n+\t    }\n \t  else if (this->in_function_->package() == NULL)\n \t    ret->append(gogo->pkgpath());\n \t  else\n@@ -956,23 +980,46 @@ Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n   if (this->in_function_ != NULL && this->in_function_index_ > 0)\n     {\n       char buf[30];\n-      snprintf(buf, sizeof buf, \"..i%u\", this->in_function_index_);\n+      snprintf(buf, sizeof buf, \".i%u\", this->in_function_index_);\n       ret->append(buf);\n     }\n }\n \n-// Return the name for the type descriptor symbol for TYPE.  This can\n-// be a global, common, or local symbol, depending.  NT is not NULL if\n-// it is the name to use.\n+// Given a name which may or may not have been hidden, append the\n+// appropriate version of the name to the result string.\n \n-std::string\n-Gogo::type_descriptor_name(const Type* type, Named_type* nt)\n+void\n+Gogo::append_possibly_hidden_name(std::string *result, const std::string& name)\n+{\n+  if (!Gogo::is_hidden_name(name))\n+    *result += name;\n+  else\n+    *result += name.substr(1);\n+}\n+\n+// Set BNAME to the name for the type descriptor symbol for TYPE.\n+// This can be a global, common, or local symbol, depending.  NT is\n+// not NULL if it is the name to use.\n+\n+void\n+Gogo::type_descriptor_backend_name(const Type* type, Named_type* nt,\n+\t\t\t\t   Backend_name* bname)\n {\n   // The type descriptor symbol for the unsafe.Pointer type is defined\n   // in libgo/runtime/go-unsafe-pointer.c, so just use a reference to\n   // that symbol for all unsafe pointer types.\n   if (type->is_unsafe_pointer_type())\n-    return \"unsafe.Pointer..d\";\n+    {\n+      bname->set_asm_name(\"unsafe.Pointer..d\");\n+      return;\n+    }\n+\n+  bool is_pointer = false;\n+  if (nt == NULL && type->points_to() != NULL)\n+    {\n+      nt = type->points_to()->named_type();\n+      is_pointer = true;\n+    }\n \n   if (nt == NULL)\n     {\n@@ -981,123 +1028,183 @@ Gogo::type_descriptor_name(const Type* type, Named_type* nt)\n       // using a named type, like \"int\".\n       go_assert(!type->is_basic_type());\n \n-      return \"type..\" + type->mangled_name(this);\n+      type->backend_name(this, bname);\n+      bname->set_prefix(\"type..\");\n     }\n-\n-  std::string ret;\n-  Named_object* no = nt->named_object();\n-  unsigned int index;\n-  const Named_object* in_function = nt->in_function(&index);\n-  if (nt->is_builtin())\n-    go_assert(in_function == NULL);\n   else\n     {\n-      if (in_function != NULL)\n-\t{\n-\t  const Typed_identifier* rcvr =\n-\t    in_function->func_value()->type()->receiver();\n-\t  if (rcvr != NULL)\n-\t    ret.append(rcvr->type()->deref()->mangled_name(this));\n-\t  else if (in_function->package() == NULL)\n-\t    ret.append(this->pkgpath());\n-\t  else\n-\t    ret.append(in_function->package()->pkgpath());\n-\t  ret.push_back('.');\n-\t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n-\t  ret.push_back('.');\n-\t}\n-\n-      if (no->package() == NULL)\n-\tret.append(this->pkgpath());\n-      else\n-\tret.append(no->package()->pkgpath());\n-      ret.push_back('.');\n+      nt->backend_name(this, bname);\n+      bname->set_suffix(is_pointer ? \"..p\" : \"..d\");\n     }\n-\n-  Gogo::append_possibly_hidden_name(&ret, no->name());\n-\n-  if (in_function != NULL && index > 0)\n-    {\n-      char buf[30];\n-      snprintf(buf, sizeof buf, \"..i%u\", index);\n-      ret.append(buf);\n-    }\n-\n-  ret.append(\"..d\");\n-\n-  return ret;\n }\n \n // Return the name of the type descriptor list symbol of a package.\n+// This is passed directly to the backend without further encoding.\n \n std::string\n-Gogo::type_descriptor_list_symbol(const std::string& pkgpath)\n+Gogo::type_descriptor_list_symbol(const std::string& pkgpath_symbol)\n {\n-  return pkgpath + \"..types\";\n+  return pkgpath_symbol + \"..types\";\n }\n \n // Return the name of the list of all type descriptor lists.  This is\n-// only used in the main package.\n+// only used in the main package.  This is passed directly to the\n+// backend without further encoding.\n \n std::string\n Gogo::typelists_symbol()\n {\n   return \"go..typelists\";\n }\n \n-// Return the name for the GC symbol for a type.  This is used to\n-// initialize the gcdata field of a type descriptor.  This is a local\n-// name never referenced outside of this assembly file.  (Note that\n-// some type descriptors will initialize the gcdata field with a name\n-// generated by ptrmask_symbol_name rather than this method.)\n+// Return the assembler name for the GC symbol for a type.  This is\n+// used to initialize the gcdata field of a type descriptor.  This is\n+// a local name never referenced outside of this assembly file.  (Note\n+// that some type descriptors will initialize the gcdata field with a\n+// name generated by ptrmask_symbol_name rather than this method.)\n+// This is passed directly to the backend without further encoding.\n \n std::string\n Gogo::gc_symbol_name(Type* type)\n {\n-  return this->type_descriptor_name(type, type->named_type()) + \"..g\";\n+  Backend_name bname;\n+  this->type_descriptor_backend_name(type, type->named_type(), &bname);\n+  bname.append_suffix(\"..g\");\n+  return bname.asm_name();\n }\n \n-// Return the name for a ptrmask variable.  PTRMASK_SYM_NAME is a\n-// base32 string encoding the ptrmask (as returned by Ptrmask::symname\n-// in types.cc).  This name is used to intialize the gcdata field of a\n-// type descriptor.  These names are globally visible.  (Note that\n-// some type descriptors will initialize the gcdata field with a name\n-// generated by gc_symbol_name rather than this method.)\n+// Return the assembler name for a ptrmask variable.  PTRMASK_SYM_NAME\n+// is a base32 string encoding the ptrmask (as returned by\n+// Ptrmask::symname in types.cc).  This name is used to intialize the\n+// gcdata field of a type descriptor.  These names are globally\n+// visible.  (Note that some type descriptors will initialize the\n+// gcdata field with a name generated by gc_symbol_name rather than\n+// this method.)  This is passed directly to the backend without\n+// further encoding.\n \n std::string\n Gogo::ptrmask_symbol_name(const std::string& ptrmask_sym_name)\n {\n   return \"gcbits..\" + ptrmask_sym_name;\n }\n \n-// Return the name to use for an interface method table used for the\n-// ordinary type TYPE converted to the interface type ITYPE.\n+// Return the assembler name to use for an interface method table used\n+// for the ordinary type TYPE converted to the interface type ITYPE.\n // IS_POINTER is true if this is for the method set for a pointer\n-// receiver.\n+// receiver.  This is passed directly to the backend without further\n+// encoding.\n \n std::string\n Gogo::interface_method_table_name(Interface_type* itype, Type* type,\n \t\t\t\t  bool is_pointer)\n {\n+  Backend_name iname;\n+  itype->backend_name(this, &iname);\n+  Backend_name tname;\n+  type->backend_name(this, &tname);\n   return ((is_pointer ? \"pimt..\" : \"imt..\")\n-\t  + itype->mangled_name(this)\n+\t  + iname.asm_name()\n \t  + \"..\"\n-\t  + type->mangled_name(this));\n+\t  + tname.asm_name());\n }\n \n-// Return whether NAME is a special name that can not be passed to\n-// unpack_hidden_name.  This is needed because various special names\n-// use \"..SUFFIX\", but unpack_hidden_name just looks for '.'.\n+// If NAME is a special name with a \"..\" suffix, return the position\n+// of that suffix.  This is needed because various special names use\n+// \"..SUFFIX\", but unpack_hidden_name just looks for '.', and because\n+// we don't want to encode the suffix.\n+\n+size_t\n+Gogo::special_name_pos(const std::string& name)\n+{\n+  size_t pos = name.rfind(\"..\");\n+  if (pos == std::string::npos)\n+    return pos;\n+  std::string suffix(name.substr(pos));\n+  if (suffix == \"..hash\"\n+      || suffix == \"..eq\"\n+      || suffix == \"..stub\"\n+      || suffix == \"..d\"\n+      || suffix == \"..f\"\n+      || suffix == \"..r\"\n+      || suffix == \"..import\")\n+    return pos;\n+  if ((suffix.compare(2, 4, \"func\") == 0\n+       || suffix.compare(2, 4, \"init\") == 0)\n+      && Gogo::is_digits(suffix.substr(6)))\n+    return pos;\n+  if (suffix.compare(2, 5, \"thunk\") == 0\n+      && Gogo::is_digits(suffix.substr(7)))\n+    return pos;\n+  return std::string::npos;\n+}\n+\n+// Return whether the string is non-empty and contains only digits.\n \n bool\n-Gogo::is_special_name(const std::string& name)\n+Gogo::is_digits(const std::string& s)\n+{\n+  if (s.empty())\n+    return false;\n+  for (size_t i = 0; i < s.size(); ++i)\n+    if (s[i] < '0' || s[i] > '9')\n+      return false;\n+  return true;\n+}\n+\n+// Class Backend_name.\n+\n+// Get the user visible name.\n+\n+std::string\n+Backend_name::name() const\n+{\n+  if (this->is_asm_name_)\n+    return this->components_[0];\n+  std::string ret;\n+  if (this->prefix_ != NULL)\n+    ret.append(this->prefix_);\n+  for (int i = 0; i < this->count_; i++)\n+    {\n+      if (i > 0)\n+\tret.push_back('.');\n+      ret.append(this->components_[i]);\n+    }\n+  if (!this->suffix_.empty())\n+    ret.append(this->suffix_);\n+  return ret;\n+}\n+\n+// Get the assembler name.\n+\n+std::string\n+Backend_name::asm_name() const\n+{\n+  if (this->is_asm_name_)\n+    return this->components_[0];\n+  std::string ret;\n+  if (this->prefix_ != NULL)\n+    ret.append(this->prefix_);\n+  for (int i = 0; i < this->count_; i++)\n+    {\n+      if (i > 0)\n+\tret.push_back('.');\n+      ret.append(go_encode_id(this->components_[i]));\n+    }\n+  if (!this->suffix_.empty())\n+    ret.append(this->suffix_);\n+  return ret;\n+}\n+\n+// Get the assembler name, or the empty string if it is the same as\n+// the user visible name.\n+\n+std::string\n+Backend_name::optional_asm_name() const\n {\n-  return (name.find(\"..hash\") != std::string::npos\n-\t  || name.find(\"..eq\") != std::string::npos\n-\t  || name.find(\"..stub\") != std::string::npos\n-\t  || name.find(\"..func\") != std::string::npos\n-\t  || name.find(\"..r\") != std::string::npos\n-\t  || name.find(\"..init\") != std::string::npos\n-\t  || name.find(\"..thunk\") != std::string::npos\n-\t  || name.find(\"..import\") != std::string::npos);\n+  if (this->is_asm_name_)\n+    return \"\";\n+  for (int i = 0; i < this->count_; i++)\n+    if (go_id_needs_encoding(this->components_[i]))\n+      return this->asm_name();\n+  return \"\";\n }"}, {"sha": "b608766cdaf88236e81df5fc99a72eca239a5204", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -83,7 +83,7 @@ DEF_GO_RUNTIME(MAKEMAP64, \"runtime.makemap64\", P3(TYPE, INT64, POINTER),\n \t\tR1(MAP))\n \n // Make a map with no hint, or a small constant hint.\n-DEF_GO_RUNTIME(MAKEMAP_SMALL, \"runtime.makemap_small\", P0(), R1(MAP))\n+DEF_GO_RUNTIME(MAKEMAP_SMALL, \"runtime.makemap__small\", P0(), R1(MAP))\n \n // Build a map from a composite literal.\n DEF_GO_RUNTIME(CONSTRUCT_MAP, \"__go_construct_map\",\n@@ -95,19 +95,19 @@ DEF_GO_RUNTIME(MAPACCESS1, \"runtime.mapaccess1\", P3(TYPE, MAP, POINTER),\n \t       R1(POINTER))\n \n // Look up a uint32 key in a map.\n-DEF_GO_RUNTIME(MAPACCESS1_FAST32, \"runtime.mapaccess1_fast32\",\n+DEF_GO_RUNTIME(MAPACCESS1_FAST32, \"runtime.mapaccess1__fast32\",\n                P3(TYPE, MAP, UINT32), R1(POINTER))\n \n // Look up a uint64 key in a map.\n-DEF_GO_RUNTIME(MAPACCESS1_FAST64, \"runtime.mapaccess1_fast64\",\n+DEF_GO_RUNTIME(MAPACCESS1_FAST64, \"runtime.mapaccess1__fast64\",\n                P3(TYPE, MAP, UINT64), R1(POINTER))\n \n // Look up a string key in a map.\n-DEF_GO_RUNTIME(MAPACCESS1_FASTSTR, \"runtime.mapaccess1_faststr\",\n+DEF_GO_RUNTIME(MAPACCESS1_FASTSTR, \"runtime.mapaccess1__faststr\",\n                P3(TYPE, MAP, STRING), R1(POINTER))\n \n // Look up a key in a map when the value is large.\n-DEF_GO_RUNTIME(MAPACCESS1_FAT, \"runtime.mapaccess1_fat\",\n+DEF_GO_RUNTIME(MAPACCESS1_FAT, \"runtime.mapaccess1__fat\",\n \t       P4(TYPE, MAP, POINTER, POINTER), R1(POINTER))\n \n // Look up a key in a map returning the value and whether it is\n@@ -117,61 +117,61 @@ DEF_GO_RUNTIME(MAPACCESS2, \"runtime.mapaccess2\", P3(TYPE, MAP, POINTER),\n \n // Look up a uint32 key in a map returning the value and whether\n // it is present.\n-DEF_GO_RUNTIME(MAPACCESS2_FAST32, \"runtime.mapaccess2_fast32\",\n+DEF_GO_RUNTIME(MAPACCESS2_FAST32, \"runtime.mapaccess2__fast32\",\n                P3(TYPE, MAP, UINT32), R2(POINTER, BOOL))\n \n // Look up a uint64 key in a map returning the value and whether\n // it is present.\n-DEF_GO_RUNTIME(MAPACCESS2_FAST64, \"runtime.mapaccess2_fast64\",\n+DEF_GO_RUNTIME(MAPACCESS2_FAST64, \"runtime.mapaccess2__fast64\",\n                P3(TYPE, MAP, UINT64), R2(POINTER, BOOL))\n \n // Look up a string key in a map returning the value and whether\n // it is present.\n-DEF_GO_RUNTIME(MAPACCESS2_FASTSTR, \"runtime.mapaccess2_faststr\",\n+DEF_GO_RUNTIME(MAPACCESS2_FASTSTR, \"runtime.mapaccess2__faststr\",\n                P3(TYPE, MAP, STRING), R2(POINTER, BOOL))\n \n // Look up a key in a map, returning the value and whether it is\n // present, when the value is large.\n-DEF_GO_RUNTIME(MAPACCESS2_FAT, \"runtime.mapaccess2_fat\",\n+DEF_GO_RUNTIME(MAPACCESS2_FAT, \"runtime.mapaccess2__fat\",\n \t       P4(TYPE, MAP, POINTER, POINTER), R2(POINTER, BOOL))\n \n // Assignment to a key in a map.\n DEF_GO_RUNTIME(MAPASSIGN, \"runtime.mapassign\", P3(TYPE, MAP, POINTER),\n \t       R1(POINTER))\n \n // Assignment to a uint32 key in a map.\n-DEF_GO_RUNTIME(MAPASSIGN_FAST32, \"runtime.mapassign_fast32\",\n+DEF_GO_RUNTIME(MAPASSIGN_FAST32, \"runtime.mapassign__fast32\",\n                P3(TYPE, MAP, UINT32), R1(POINTER))\n \n // Assignment to a uint64 key in a map.\n-DEF_GO_RUNTIME(MAPASSIGN_FAST64, \"runtime.mapassign_fast64\",\n+DEF_GO_RUNTIME(MAPASSIGN_FAST64, \"runtime.mapassign__fast64\",\n                P3(TYPE, MAP, UINT64), R1(POINTER))\n \n // Assignment to a 32-bit pointer key in a map.\n-DEF_GO_RUNTIME(MAPASSIGN_FAST32PTR, \"runtime.mapassign_fast32ptr\",\n+DEF_GO_RUNTIME(MAPASSIGN_FAST32PTR, \"runtime.mapassign__fast32ptr\",\n                P3(TYPE, MAP, POINTER), R1(POINTER))\n \n // Assignment to a 64-bit pointer key in a map.\n-DEF_GO_RUNTIME(MAPASSIGN_FAST64PTR, \"runtime.mapassign_fast64ptr\",\n+DEF_GO_RUNTIME(MAPASSIGN_FAST64PTR, \"runtime.mapassign__fast64ptr\",\n                P3(TYPE, MAP, POINTER), R1(POINTER))\n \n // Assignment to a string key in a map.\n-DEF_GO_RUNTIME(MAPASSIGN_FASTSTR, \"runtime.mapassign_faststr\",\n+DEF_GO_RUNTIME(MAPASSIGN_FASTSTR, \"runtime.mapassign__faststr\",\n                P3(TYPE, MAP, STRING), R1(POINTER))\n \n // Delete a key from a map.\n DEF_GO_RUNTIME(MAPDELETE, \"runtime.mapdelete\", P3(TYPE, MAP, POINTER), R0())\n \n // Delete a uint32 key from a map.\n-DEF_GO_RUNTIME(MAPDELETE_FAST32, \"runtime.mapdelete_fast32\",\n+DEF_GO_RUNTIME(MAPDELETE_FAST32, \"runtime.mapdelete__fast32\",\n                P3(TYPE, MAP, UINT32), R0())\n \n // Delete a uint64 key from a map.\n-DEF_GO_RUNTIME(MAPDELETE_FAST64, \"runtime.mapdelete_fast64\",\n+DEF_GO_RUNTIME(MAPDELETE_FAST64, \"runtime.mapdelete__fast64\",\n                P3(TYPE, MAP, UINT64), R0())\n \n // Delete a string key from a map.\n-DEF_GO_RUNTIME(MAPDELETE_FASTSTR, \"runtime.mapdelete_faststr\",\n+DEF_GO_RUNTIME(MAPDELETE_FASTSTR, \"runtime.mapdelete__faststr\",\n                P3(TYPE, MAP, STRING), R0())\n \n // Begin a range over a map."}, {"sha": "c4570b41a71bd7707b947d5a5d272c9446cf6858", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1342,19 +1342,21 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \n       Type* td_type = Type::make_type_descriptor_type();\n       Btype* td_btype = td_type->get_backend(gogo);\n-      std::string name = gogo->type_descriptor_name(this, nt);\n-      std::string asm_name(go_selectively_encode_id(name));\n+      Backend_name bname;\n+      gogo->type_descriptor_backend_name(this, nt, &bname);\n       this->type_descriptor_var_ =\n-\t  gogo->backend()->immutable_struct_reference(name, asm_name,\n-\t\t\t\t\t\t      td_btype,\n-\t\t\t\t\t\t      bloc);\n+\tgogo->backend()->immutable_struct_reference(bname.name(),\n+\t\t\t\t\t\t    bname.optional_asm_name(),\n+\t\t\t\t\t\t    td_btype,\n+\t\t\t\t\t\t    bloc);\n \n       if (phash != NULL)\n \t*phash = this->type_descriptor_var_;\n       return;\n     }\n \n-  std::string var_name = gogo->type_descriptor_name(this, nt);\n+  Backend_name bname;\n+  gogo->type_descriptor_backend_name(this, nt, &bname);\n \n   // Build the contents of the type descriptor.\n   Expression* initializer = this->do_type_descriptor(gogo, NULL);\n@@ -1366,11 +1368,11 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   const Package* dummy;\n   if (this->type_descriptor_defined_elsewhere(nt, &dummy))\n     {\n-      std::string asm_name(go_selectively_encode_id(var_name));\n       this->type_descriptor_var_ =\n-\t  gogo->backend()->immutable_struct_reference(var_name, asm_name,\n-\t\t\t\t\t\t      initializer_btype,\n-\t\t\t\t\t\t      loc);\n+\tgogo->backend()->immutable_struct_reference(bname.name(),\n+\t\t\t\t\t\t    bname.optional_asm_name(),\n+\t\t\t\t\t\t    initializer_btype,\n+\t\t\t\t\t\t    loc);\n       if (phash != NULL)\n \t*phash = this->type_descriptor_var_;\n       return;\n@@ -1399,10 +1401,10 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   // ensure that type_descriptor_pointer will work if called while\n   // converting INITIALIZER.\n \n-  std::string asm_name(go_selectively_encode_id(var_name));\n   this->type_descriptor_var_ =\n-      gogo->backend()->immutable_struct(var_name, asm_name, false, is_common,\n-\t\t\t\t      initializer_btype, loc);\n+    gogo->backend()->immutable_struct(bname.name(), bname.optional_asm_name(),\n+\t\t\t\t      false, is_common, initializer_btype,\n+\t\t\t\t      loc);\n   if (phash != NULL)\n     *phash = this->type_descriptor_var_;\n \n@@ -1411,7 +1413,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   Bexpression* binitializer = initializer->get_backend(&context);\n \n   gogo->backend()->immutable_struct_set_init(this->type_descriptor_var_,\n-\t\t\t\t\t     var_name, false, is_common,\n+\t\t\t\t\t     bname.name(), false, is_common,\n \t\t\t\t\t     initializer_btype, loc,\n \t\t\t\t\t     binitializer);\n \n@@ -1924,28 +1926,28 @@ Type::build_hash_function(Gogo* gogo, int64_t size, Function_type* hash_fntype)\n       return ins.first->second;\n     }\n \n-  std::string hash_name = gogo->hash_function_name(type);\n+  Backend_name bname;\n+  gogo->hash_function_name(type, &bname);\n \n   Location bloc = Linemap::predeclared_location();\n \n-  Named_object* hash_fn = gogo->declare_package_function(hash_name,\n+  Named_object* hash_fn = gogo->declare_package_function(bname.name(),\n \t\t\t\t\t\t\t hash_fntype, bloc);\n \n   ins.first->second = hash_fn;\n \n   if (gogo->in_global_scope())\n-    type->write_hash_function(gogo, size, hash_name, hash_fntype);\n+    type->write_hash_function(gogo, size, &bname, hash_fntype);\n   else\n-    gogo->queue_hash_function(type, size, hash_name, hash_fntype);\n+    gogo->queue_hash_function(type, size, &bname, hash_fntype);\n \n   return hash_fn;\n }\n \n // Write the hash function for a type that needs it written specially.\n \n void\n-Type::write_hash_function(Gogo* gogo, int64_t size,\n-\t\t\t  const std::string& hash_name,\n+Type::write_hash_function(Gogo* gogo, int64_t size, const Backend_name* bname,\n \t\t\t  Function_type* hash_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n@@ -1958,8 +1960,9 @@ Type::write_hash_function(Gogo* gogo, int64_t size,\n \n   go_assert(this->is_comparable());\n \n-  Named_object* hash_fn = gogo->start_function(hash_name, hash_fntype, false,\n-\t\t\t\t\t       bloc);\n+  Named_object* hash_fn = gogo->start_function(bname->name(), hash_fntype,\n+\t\t\t\t\t       false, bloc);\n+  hash_fn->func_value()->set_asm_name(bname->asm_name());\n   hash_fn->func_value()->set_is_type_specific_function();\n   gogo->start_block(bloc);\n \n@@ -2245,7 +2248,8 @@ Type::build_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n       return ins.first->second;\n     }\n \n-  std::string equal_name = gogo->equal_function_name(this, name);\n+  Backend_name bname;\n+  gogo->equal_function_name(this, name, &bname);\n \n   Location bloc = Linemap::predeclared_location();\n \n@@ -2255,19 +2259,21 @@ Type::build_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n \n   Named_object* equal_fn;\n   if (is_defined_elsewhere)\n-    equal_fn = Named_object::make_function_declaration(equal_name, package,\n+    equal_fn = Named_object::make_function_declaration(bname.name(), package,\n \t\t\t\t\t\t       equal_fntype, bloc);\n   else\n-    equal_fn = gogo->declare_package_function(equal_name, equal_fntype, bloc);\n+    equal_fn = gogo->declare_package_function(bname.name(), equal_fntype, bloc);\n \n   ins.first->second = equal_fn;\n \n-  if (!is_defined_elsewhere)\n+  if (is_defined_elsewhere)\n+    equal_fn->func_declaration_value()->set_asm_name(bname.asm_name());\n+  else\n     {\n       if (gogo->in_global_scope())\n-\tthis->write_equal_function(gogo, name, size, equal_name, equal_fntype);\n+\tthis->write_equal_function(gogo, name, size, &bname, equal_fntype);\n       else\n-\tgogo->queue_equal_function(this, name, size, equal_name, equal_fntype);\n+\tgogo->queue_equal_function(this, name, size, &bname, equal_fntype);\n     }\n \n   return equal_fn;\n@@ -2278,7 +2284,7 @@ Type::build_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n \n void\n Type::write_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n-\t\t\t   const std::string& equal_name,\n+\t\t\t   const Backend_name* bname,\n \t\t\t   Function_type* equal_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n@@ -2291,8 +2297,9 @@ Type::write_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n \n   go_assert(this->is_comparable());\n \n-  Named_object* equal_fn = gogo->start_function(equal_name, equal_fntype,\n+  Named_object* equal_fn = gogo->start_function(bname->name(), equal_fntype,\n \t\t\t\t\t\tfalse, bloc);\n+  equal_fn->func_value()->set_asm_name(bname->asm_name());\n   equal_fn->func_value()->set_is_type_specific_function();\n   gogo->start_block(bloc);\n \n@@ -2671,9 +2678,8 @@ Type::make_gc_symbol_var(Gogo* gogo)\n   const Package* dummy;\n   if (this->type_descriptor_defined_elsewhere(nt, &dummy))\n     {\n-      std::string asm_name(go_selectively_encode_id(sym_name));\n       this->gc_symbol_var_ =\n-          gogo->backend()->implicit_variable_reference(sym_name, asm_name,\n+          gogo->backend()->implicit_variable_reference(sym_name, \"\",\n                                                        sym_btype);\n       if (phash != NULL)\n \t*phash = this->gc_symbol_var_;\n@@ -2699,10 +2705,9 @@ Type::make_gc_symbol_var(Gogo* gogo)\n   // Since we are building the GC symbol in this package, we must create the\n   // variable before converting the initializer to its backend representation\n   // because the initializer may refer to the GC symbol for this type.\n-  std::string asm_name(go_selectively_encode_id(sym_name));\n   this->gc_symbol_var_ =\n-      gogo->backend()->implicit_variable(sym_name, asm_name,\n-\t\t\t\t\t sym_btype, false, true, is_common, 0);\n+      gogo->backend()->implicit_variable(sym_name, \"\", sym_btype, false, true,\n+\t\t\t\t\t is_common, 0);\n   if (phash != NULL)\n     *phash = this->gc_symbol_var_;\n \n@@ -2876,14 +2881,17 @@ Ptrmask::set_from(Gogo* gogo, Type* type, int64_t ptrsize, int64_t offset)\n     }\n }\n \n-// Return a symbol name for this ptrmask. This is used to coalesce identical\n-// ptrmasks, which are common. The symbol name must use only characters that are\n-// valid in symbols. It's nice if it's short. For smaller ptrmasks, we convert\n-// it to a string that uses only 32 characters, avoiding digits and u and U. For\n-// longer pointer masks, apply the same process to the SHA1 digest of the bits,\n-// so as to avoid pathologically long symbol names (see related Go issues #32083\n-// and #11583 for more on this). To avoid collisions between the two encoding\n-// schemes, use a prefix (\"X\") for the SHA form to disambiguate.\n+// Return a symbol name for this ptrmask. This is used to coalesce\n+// identical ptrmasks, which are common.  The symbol name must use\n+// only characters that are valid in symbols.  It's nice if it's\n+// short.  For smaller ptrmasks, we convert it to a string that uses\n+// only 32 characters.  For longer pointer masks, apply the same\n+// process to the SHA1 digest of the bits, so as to avoid\n+// pathologically long symbol names (see related Go issues #32083 and\n+// #11583 for more on this).  To avoid collisions between the two\n+// encoding schemes, use a prefix (\"X\") for the SHA form to\n+// disambiguate.\n+\n std::string\n Ptrmask::symname() const\n {\n@@ -2911,7 +2919,7 @@ Ptrmask::symname() const\n       bits = &shabits;\n     }\n \n-  const char chars[33] = \"abcdefghijklmnopqrstvwxyzABCDEFG\";\n+  const char chars[33] = \"abcdefghijklmnopqrstuvwxyzABCDEF\";\n   go_assert(chars[32] == '\\0');\n   std::string ret(prefix);\n   unsigned int b = 0;\n@@ -2995,9 +3003,8 @@ Type::gc_ptrmask_var(Gogo* gogo, int64_t ptrsize, int64_t ptrdata)\n   context.set_is_const();\n   Bexpression* bval = val->get_backend(&context);\n \n-  std::string asm_name(go_selectively_encode_id(sym_name));\n   Btype *btype = val->type()->get_backend(gogo);\n-  Bvariable* ret = gogo->backend()->implicit_variable(sym_name, asm_name,\n+  Bvariable* ret = gogo->backend()->implicit_variable(sym_name, \"\",\n \t\t\t\t\t\t      btype, false, true,\n \t\t\t\t\t\t      true, 0);\n   gogo->backend()->implicit_variable_set_init(ret, sym_name, btype, false,\n@@ -8092,11 +8099,9 @@ Map_type::backend_zero_value(Gogo* gogo)\n   Btype* barray_type = gogo->backend()->array_type(buint8_type, blength);\n \n   std::string zname = Map_type::zero_value->name();\n-  std::string asm_name(go_selectively_encode_id(zname));\n   Bvariable* zvar =\n-      gogo->backend()->implicit_variable(zname, asm_name,\n-                                         barray_type, false, false, true,\n-\t\t\t\t\t Map_type::zero_value_align);\n+      gogo->backend()->implicit_variable(zname, \"\", barray_type, false, false,\n+\t\t\t\t\t true, Map_type::zero_value_align);\n   gogo->backend()->implicit_variable_set_init(zvar, zname, barray_type,\n \t\t\t\t\t      false, false, true, NULL);\n   return zvar;"}, {"sha": "5965d5a3fdeccf734b4998a81c07db6a582d3d72", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -49,6 +49,7 @@ class Function;\n class Translate_context;\n class Export;\n class Import;\n+class Backend_name;\n class Btype;\n class Bexpression;\n class Bvariable;\n@@ -1008,11 +1009,11 @@ class Type\n   std::string\n   reflection(Gogo*) const;\n \n-  // Return a mangled name for the type.  This is a name which can be\n-  // used in assembler code.  Identical types should have the same\n-  // manged name.\n-  std::string\n-  mangled_name(Gogo*) const;\n+  // Add the backend name for the type to BNAME.  This will add one or\n+  // two name components.  Identical types should have the same\n+  // backend name.\n+  void\n+  backend_name(Gogo*, Backend_name* bname) const;\n \n   // If the size of the type can be determined, set *PSIZE to the size\n   // in bytes and return true.  Otherwise, return false.  This queries\n@@ -1066,12 +1067,11 @@ class Type\n   // Write the equal function for a type.\n   void\n   write_equal_function(Gogo*, Named_type*, int64_t size,\n-\t\t       const std::string& equal_name,\n-\t\t       Function_type* equal_fntype);\n+\t\t       const Backend_name*, Function_type* equal_fntype);\n \n   // Write the hash function for a type.\n   void\n-  write_hash_function(Gogo*, int64_t size, const std::string& hash_name,\n+  write_hash_function(Gogo*, int64_t size, const Backend_name*,\n \t\t      Function_type* hash_fntype);\n \n   // Return the alignment required by the memequalN function.\n@@ -3557,10 +3557,10 @@ class Named_type : public Type\n   void\n   append_reflection_type_name(Gogo*, bool use_alias, std::string*) const;\n \n-  // Append the mangled type name as for Type::append_mangled_name,\n+  // Append the symbol type name as for Type::append_mangled_name,\n   // but if USE_ALIAS use the alias name rather than the alias target.\n   void\n-  append_mangled_type_name(Gogo*, bool use_alias, std::string*) const;\n+  append_symbol_type_name(Gogo*, bool use_alias, std::string*) const;\n \n   // Import a named type.\n   static void"}, {"sha": "1d7d007f88ed622fe60436dfdf1a459d73b209c9", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -2551,7 +2551,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=17:0:0\n+libtool_VERSION=18:0:0\n \n \n # Default to --enable-multilib"}, {"sha": "5013f4142a6c17d64ffca15217dad6587e8bfe1d", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=17:0:0\n+libtool_VERSION=18:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)"}, {"sha": "05441398d7abd1202abf817265172b5f64e8c80f", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -191,7 +191,7 @@ func (p *Package) writeDefs() {\n \t\t\tpanic(fmt.Errorf(\"invalid var kind %q\", n.Kind))\n \t\t}\n \t\tif *gccgo {\n-\t\t\tfmt.Fprintf(fc, `extern void *%s __asm__(\"%s.%s\");`, n.Mangle, gccgoSymbolPrefix, n.Mangle)\n+\t\t\tfmt.Fprintf(fc, `extern void *%s __asm__(\"%s.%s\");`, n.Mangle, gccgoSymbolPrefix, gccgoToSymbol(n.Mangle))\n \t\t\tfmt.Fprintf(&gccgoInit, \"\\t%s = &%s;\\n\", n.Mangle, n.C)\n \t\t\tfmt.Fprintf(fc, \"\\n\")\n \t\t}\n@@ -1168,7 +1168,7 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\t// will not be able to link against it from the C\n \t\t// code.\n \t\tgoName := \"Cgoexp_\" + exp.ExpName\n-\t\tfmt.Fprintf(fgcc, `extern %s %s %s __asm__(\"%s.%s\");`, cRet, goName, cParams, gccgoSymbolPrefix, goName)\n+\t\tfmt.Fprintf(fgcc, `extern %s %s %s __asm__(\"%s.%s\");`, cRet, goName, cParams, gccgoSymbolPrefix, gccgoToSymbol(goName))\n \t\tfmt.Fprint(fgcc, \"\\n\")\n \n \t\tfmt.Fprint(fgcc, \"\\nCGO_NO_SANITIZE_THREAD\\n\")\n@@ -1202,7 +1202,7 @@ func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \t\tfmt.Fprint(fgcc, \"}\\n\")\n \n \t\t// Dummy declaration for _cgo_main.c\n-\t\tfmt.Fprintf(fm, `char %s[1] __asm__(\"%s.%s\");`, goName, gccgoSymbolPrefix, goName)\n+\t\tfmt.Fprintf(fm, `char %s[1] __asm__(\"%s.%s\");`, goName, gccgoSymbolPrefix, gccgoToSymbol(goName))\n \t\tfmt.Fprint(fm, \"\\n\")\n \n \t\t// For gccgo we use a wrapper function in Go, in order\n@@ -1286,9 +1286,8 @@ func (p *Package) writeExportHeader(fgcch io.Writer) {\n \tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n }\n \n-// gccgoPkgpathToSymbol converts a package path to a mangled packagepath\n-// symbol.\n-func gccgoPkgpathToSymbol(ppath string) string {\n+// gccgoToSymbol converts a name to a mangled symbol for gccgo.\n+func gccgoToSymbol(ppath string) string {\n \tif gccgoMangler == nil {\n \t\tvar err error\n \t\tcmd := os.Getenv(\"GCCGO\")\n@@ -1313,12 +1312,12 @@ func (p *Package) gccgoSymbolPrefix() string {\n \t}\n \n \tif *gccgopkgpath != \"\" {\n-\t\treturn gccgoPkgpathToSymbol(*gccgopkgpath)\n+\t\treturn gccgoToSymbol(*gccgopkgpath)\n \t}\n \tif *gccgoprefix == \"\" && p.PackageName == \"main\" {\n \t\treturn \"main\"\n \t}\n-\tprefix := gccgoPkgpathToSymbol(*gccgoprefix)\n+\tprefix := gccgoToSymbol(*gccgoprefix)\n \tif prefix == \"\" {\n \t\tprefix = \"go\"\n \t}\n@@ -1710,8 +1709,12 @@ void _cgoPREFIX_Cfunc__Cmalloc(void *v) {\n `\n \n func (p *Package) cPrologGccgo() string {\n-\treturn strings.Replace(strings.Replace(cPrologGccgo, \"PREFIX\", cPrefix, -1),\n-\t\t\"GCCGOSYMBOLPREF\", p.gccgoSymbolPrefix(), -1)\n+\tr := strings.NewReplacer(\n+\t\t\"PREFIX\", cPrefix,\n+\t\t\"GCCGOSYMBOLPREF\", p.gccgoSymbolPrefix(),\n+\t\t\"_cgoCheckPointer\", gccgoToSymbol(\"_cgoCheckPointer\"),\n+\t\t\"_cgoCheckResult\", gccgoToSymbol(\"_cgoCheckResult\"))\n+\treturn r.Replace(cPrologGccgo)\n }\n \n const cPrologGccgo = `"}, {"sha": "40a040a81af6acb54eb272d7bf388b8f79289d99", "filename": "libgo/go/cmd/internal/pkgpath/pkgpath.go", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -50,9 +50,12 @@ func ToSymbolFunc(cmd, tmpdir string) (func(string) string, error) {\n \t\treturn nil, err\n \t}\n \n-\t// New mangling: expect go.l..u00e4ufer.Run\n-\t// Old mangling: expect go.l__ufer.Run\n-\tif bytes.Contains(buf, []byte(\"go.l..u00e4ufer.Run\")) {\n+\t// Original mangling: go.l__ufer.Run\n+\t// Mangling v2: go.l..u00e4ufer.Run\n+\t// Mangling v3: go_0l_u00e4ufer.Run\n+\tif bytes.Contains(buf, []byte(\"go_0l_u00e4ufer.Run\")) {\n+\t\treturn toSymbolV3, nil\n+\t} else if bytes.Contains(buf, []byte(\"go.l..u00e4ufer.Run\")) {\n \t\treturn toSymbolV2, nil\n \t} else if bytes.Contains(buf, []byte(\"go.l__ufer.Run\")) {\n \t\treturn toSymbolV1, nil\n@@ -82,7 +85,7 @@ func toSymbolV1(ppath string) string {\n \treturn strings.Map(clean, ppath)\n }\n \n-// toSymbolV2 converts a package path using the newer mangling scheme.\n+// toSymbolV2 converts a package path using the second mangling scheme.\n func toSymbolV2(ppath string) string {\n \t// This has to build at boostrap time, so it has to build\n \t// with Go 1.4, so we don't use strings.Builder.\n@@ -112,3 +115,60 @@ func toSymbolV2(ppath string) string {\n \t}\n \treturn string(bsl)\n }\n+\n+// v3UnderscoreCodes maps from a character that supports an underscore\n+// encoding to the underscore encoding character.\n+var v3UnderscoreCodes = map[byte]byte{\n+\t'_': '_',\n+\t'.': '0',\n+\t'/': '1',\n+\t'*': '2',\n+\t',': '3',\n+\t'{': '4',\n+\t'}': '5',\n+\t'[': '6',\n+\t']': '7',\n+\t'(': '8',\n+\t')': '9',\n+\t'\"': 'a',\n+\t' ': 'b',\n+\t';': 'c',\n+}\n+\n+// toSymbolV3 converts a package path using the third mangling scheme.\n+func toSymbolV3(ppath string) string {\n+\t// This has to build at boostrap time, so it has to build\n+\t// with Go 1.4, so we don't use strings.Builder.\n+\tbsl := make([]byte, 0, len(ppath))\n+\tchanged := false\n+\tfor _, c := range ppath {\n+\t\tif ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z') || ('0' <= c && c <= '9') {\n+\t\t\tbsl = append(bsl, byte(c))\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif c < 0x80 {\n+\t\t\tif u, ok := v3UnderscoreCodes[byte(c)]; ok {\n+\t\t\t\tbsl = append(bsl, '_', u)\n+\t\t\t\tchanged = true\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tvar enc string\n+\t\tswitch {\n+\t\tcase c < 0x80:\n+\t\t\tenc = fmt.Sprintf(\"_x%02x\", c)\n+\t\tcase c < 0x10000:\n+\t\t\tenc = fmt.Sprintf(\"_u%04x\", c)\n+\t\tdefault:\n+\t\t\tenc = fmt.Sprintf(\"_U%08x\", c)\n+\t\t}\n+\t\tbsl = append(bsl, enc...)\n+\t\tchanged = true\n+\t}\n+\tif !changed {\n+\t\treturn ppath\n+\t}\n+\treturn string(bsl)\n+}"}, {"sha": "232e803a6014df6270b24a3b782d0c60ff8209e2", "filename": "libgo/go/cmd/internal/pkgpath/pkgpath_test.go", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath_test.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -24,6 +24,9 @@ func init() {\n \tcase \"v2\":\n \t\tos.Stdout.WriteString(`.string\t\"go.l..u00e4ufer.Run\"`)\n \t\tos.Exit(0)\n+\tcase \"v3\":\n+\t\tos.Stdout.WriteString(`.string\t\"go_0l_u00e4ufer.Run\"`)\n+\t\tos.Exit(0)\n \tcase \"error\":\n \t\tos.Stdout.WriteString(`unknown string`)\n \t\tos.Exit(0)\n@@ -45,6 +48,10 @@ func TestToSymbolFunc(t *testing.T) {\n \t\t\tenv:     \"v2\",\n \t\t\tmangled: \"p..u00e4..u4e16..U0001f703\",\n \t\t},\n+\t\t{\n+\t\t\tenv:     \"v3\",\n+\t\t\tmangled: \"p_u00e4_u4e16_U0001f703\",\n+\t\t},\n \t\t{\n \t\t\tenv:  \"error\",\n \t\t\tfail: true,\n@@ -75,32 +82,37 @@ func TestToSymbolFunc(t *testing.T) {\n }\n \n var symbolTests = []struct {\n-\tinput, v1, v2 string\n+\tinput, v1, v2, v3 string\n }{\n \t{\n \t\t\"\",\n \t\t\"\",\n \t\t\"\",\n+\t\t\"\",\n \t},\n \t{\n \t\t\"bytes\",\n \t\t\"bytes\",\n \t\t\"bytes\",\n+\t\t\"bytes\",\n \t},\n \t{\n \t\t\"net/http\",\n \t\t\"net_http\",\n \t\t\"net..z2fhttp\",\n+\t\t\"net_1http\",\n \t},\n \t{\n \t\t\"golang.org/x/net/http\",\n \t\t\"golang_org_x_net_http\",\n \t\t\"golang.x2eorg..z2fx..z2fnet..z2fhttp\",\n+\t\t\"golang_0org_1x_1net_1http\",\n \t},\n \t{\n \t\t\"p\u00e4\u4e16.\ud83d\udf03\",\n \t\t\"p____\",\n \t\t\"p..u00e4..u4e16.x2e..U0001f703\",\n+\t\t\"p_u00e4_u4e16_0_U0001f703\",\n \t},\n }\n \n@@ -119,3 +131,11 @@ func TestV2(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestV3(t *testing.T) {\n+\tfor _, test := range symbolTests {\n+\t\tif got, want := toSymbolV3(test.input), test.v3; got != want {\n+\t\t\tt.Errorf(\"toSymbolV3(%q) = %q, want %q\", test.input, got, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "3a2ca9aba81d34df17e3f903f7a177a3c7c345e1", "filename": "libgo/go/go/internal/srcimporter/srcimporter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -262,5 +262,5 @@ func (p *Importer) joinPath(elem ...string) string {\n \treturn filepath.Join(elem...)\n }\n \n-//go:linkname setUsesCgo go/types.srcimporter_setUsesCgo\n+//go:linkname setUsesCgo go_1types.srcimporter__setUsesCgo\n func setUsesCgo(conf *types.Config)"}, {"sha": "6c08340b38ff90111ebe2c78466d57ff810776fc", "filename": "libgo/go/internal/bytealg/bytealg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Finternal%2Fbytealg%2Fbytealg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Finternal%2Fbytealg%2Fbytealg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fbytealg%2Fbytealg.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -38,7 +38,7 @@ static const void *goMemmem(const void *in, size_t inl, const void *s, size_t sl\n #endif\n \n intgo Compare(struct __go_open_array, struct __go_open_array)\n-  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.Compare\")\n+  __asm__(GOSYM_PREFIX \"internal_1bytealg.Compare\")\n   __attribute__((no_split_stack));\n \n intgo Compare(struct __go_open_array a, struct __go_open_array b)\n@@ -69,7 +69,7 @@ intgo Compare(struct __go_open_array a, struct __go_open_array b)\n }\n \n intgo IndexByte(struct __go_open_array, byte)\n-  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.IndexByte\")\n+  __asm__(GOSYM_PREFIX \"internal_1bytealg.IndexByte\")\n   __attribute__((no_split_stack));\n \n intgo IndexByte(struct __go_open_array b, byte c)\n@@ -85,7 +85,7 @@ intgo IndexByte(struct __go_open_array b, byte c)\n \n \n intgo IndexByteString(String, byte)\n-  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.IndexByteString\")\n+  __asm__(GOSYM_PREFIX \"internal_1bytealg.IndexByteString\")\n   __attribute__((no_split_stack));\n \n intgo IndexByteString(String s, byte c)\n@@ -100,7 +100,7 @@ intgo IndexByteString(String s, byte c)\n }\n \n intgo Index(struct __go_open_array, struct __go_open_array)\n-  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.Index\")\n+  __asm__(GOSYM_PREFIX \"internal_1bytealg.Index\")\n   __attribute__((no_split_stack));\n \n intgo Index(struct __go_open_array a, struct __go_open_array b)\n@@ -115,7 +115,7 @@ intgo Index(struct __go_open_array a, struct __go_open_array b)\n }\n \n intgo IndexString(String, String)\n-  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.IndexString\")\n+  __asm__(GOSYM_PREFIX \"internal_1bytealg.IndexString\")\n   __attribute__((no_split_stack));\n \n intgo IndexString(String a, String b)"}, {"sha": "da26f4d7407ad162c49f5fff617d8dbe21b748cc", "filename": "libgo/go/internal/cpu/cpu_gccgo.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Finternal%2Fcpu%2Fcpu_gccgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Finternal%2Fcpu%2Fcpu_gccgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fcpu%2Fcpu_gccgo.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -21,7 +21,7 @@ struct cpuid_ret {\n };\n \n struct cpuid_ret cpuid(uint32_t, uint32_t)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.cpuid\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.cpuid\")\n   __attribute__((no_split_stack));\n \n struct cpuid_ret cpuid(uint32_t eaxArg, uint32_t ecxArg) {\n@@ -45,7 +45,7 @@ struct xgetbv_ret {\n };\n \n struct xgetbv_ret xgetbv(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.xgetbv\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.xgetbv\")\n   __attribute__((no_split_stack));\n \n #pragma GCC push_options\n@@ -82,7 +82,7 @@ struct queryResult {\n };\n \n struct facilityList stfle(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.stfle\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.stfle\")\n   __attribute__((no_split_stack));\n \n struct facilityList stfle(void) {\n@@ -96,7 +96,7 @@ struct facilityList stfle(void) {\n }\n \n struct queryResult kmQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.kmQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.kmQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult kmQuery() {\n@@ -110,7 +110,7 @@ struct queryResult kmQuery() {\n }\n \n struct queryResult kmcQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.kmcQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.kmcQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult kmcQuery() {\n@@ -125,7 +125,7 @@ struct queryResult kmcQuery() {\n }\n \n struct queryResult kmctrQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.kmctrQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.kmctrQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult kmctrQuery() {\n@@ -140,7 +140,7 @@ struct queryResult kmctrQuery() {\n }\n \n struct queryResult kmaQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.kmaQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.kmaQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult kmaQuery() {\n@@ -155,7 +155,7 @@ struct queryResult kmaQuery() {\n }\n \n struct queryResult kimdQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.kimdQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.kimdQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult kimdQuery() {\n@@ -170,7 +170,7 @@ struct queryResult kimdQuery() {\n }\n \n struct queryResult klmdQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.klmdQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.klmdQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult klmdQuery() {\n@@ -185,7 +185,7 @@ struct queryResult klmdQuery() {\n }\n \n struct queryResult kdsaQuery(void)\n-  __asm__(GOSYM_PREFIX \"internal..z2fcpu.kdsaQuery\")\n+  __asm__(GOSYM_PREFIX \"internal_1cpu.kdsaQuery\")\n   __attribute__((no_split_stack));\n \n struct queryResult kdsaQuery() {"}, {"sha": "329df404efd0876a91b4d5e6f7061467bf65c167", "filename": "libgo/go/log/syslog/syslog_c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_c.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -12,7 +12,7 @@\n    can't represent a C varargs function in Go.  */\n \n void syslog_c(intgo, const char*)\n-  __asm__ (GOSYM_PREFIX \"log..z2fsyslog.syslog_c\");\n+  __asm__ (GOSYM_PREFIX \"log_1syslog.syslog_c\");\n \n void\n syslog_c (intgo priority, const char *msg)"}, {"sha": "029591394b49513f7738ed4c3a926950d0fe6784", "filename": "libgo/go/runtime/atomic_pointer.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -39,10 +39,10 @@ func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n // We cannot just call the runtime routines, because the race detector expects\n // to be able to intercept the sync/atomic forms but not the runtime forms.\n \n-//go:linkname sync_atomic_StoreUintptr sync..z2fatomic.StoreUintptr\n+//go:linkname sync_atomic_StoreUintptr sync_1atomic.StoreUintptr\n func sync_atomic_StoreUintptr(ptr *uintptr, new uintptr)\n \n-//go:linkname sync_atomic_StorePointer sync..z2fatomic.StorePointer\n+//go:linkname sync_atomic_StorePointer sync_1atomic.StorePointer\n //go:nosplit\n func sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer) {\n \tif writeBarrier.enabled {\n@@ -51,10 +51,10 @@ func sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer) {\n \tsync_atomic_StoreUintptr((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n }\n \n-//go:linkname sync_atomic_SwapUintptr sync..z2fatomic.SwapUintptr\n+//go:linkname sync_atomic_SwapUintptr sync_1atomic.SwapUintptr\n func sync_atomic_SwapUintptr(ptr *uintptr, new uintptr) uintptr\n \n-//go:linkname sync_atomic_SwapPointer sync..z2fatomic.SwapPointer\n+//go:linkname sync_atomic_SwapPointer sync_1atomic.SwapPointer\n //go:nosplit\n func sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer {\n \tif writeBarrier.enabled {\n@@ -64,10 +64,10 @@ func sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Poi\n \treturn old\n }\n \n-//go:linkname sync_atomic_CompareAndSwapUintptr sync..z2fatomic.CompareAndSwapUintptr\n+//go:linkname sync_atomic_CompareAndSwapUintptr sync_1atomic.CompareAndSwapUintptr\n func sync_atomic_CompareAndSwapUintptr(ptr *uintptr, old, new uintptr) bool\n \n-//go:linkname sync_atomic_CompareAndSwapPointer sync..z2fatomic.CompareAndSwapPointer\n+//go:linkname sync_atomic_CompareAndSwapPointer sync_1atomic.CompareAndSwapPointer\n //go:nosplit\n func sync_atomic_CompareAndSwapPointer(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n \tif writeBarrier.enabled {"}, {"sha": "8e104f14140ca8eaea102b915904f51c2c8df8a9", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -774,7 +774,7 @@ func reflect_chanlen(c *hchan) int {\n \treturn int(c.qcount)\n }\n \n-//go:linkname reflectlite_chanlen internal..z2freflectlite.chanlen\n+//go:linkname reflectlite_chanlen internal_1reflectlite.chanlen\n func reflectlite_chanlen(c *hchan) int {\n \tif c == nil {\n \t\treturn 0"}, {"sha": "43f0a6705f5d6603549a0e58c310681830b87037", "filename": "libgo/go/runtime/cpuprof.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcpuprof.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -189,7 +189,7 @@ func CPUProfile() []byte {\n \tpanic(\"CPUProfile no longer available\")\n }\n \n-//go:linkname runtime_pprof_runtime_cyclesPerSecond runtime..z2fpprof.runtime_cyclesPerSecond\n+//go:linkname runtime_pprof_runtime_cyclesPerSecond runtime_1pprof.runtime__cyclesPerSecond\n func runtime_pprof_runtime_cyclesPerSecond() int64 {\n \treturn tickspersecond()\n }\n@@ -200,7 +200,7 @@ func runtime_pprof_runtime_cyclesPerSecond() int64 {\n // on has been returned, readProfile returns eof=true.\n // The caller must save the returned data and tags before calling readProfile again.\n //\n-//go:linkname runtime_pprof_readProfile runtime..z2fpprof.readProfile\n+//go:linkname runtime_pprof_readProfile runtime_1pprof.readProfile\n func runtime_pprof_readProfile() ([]uint64, []unsafe.Pointer, bool) {\n \tlock(&cpuprof.lock)\n \tlog := cpuprof.log"}, {"sha": "ff76580ee659e471d74ffa63b3527510d39ee7d8", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -66,7 +66,7 @@ func NumGoroutine() int {\n // added.\n func Fieldtrack(map[string]bool)\n \n-//go:linkname debug_modinfo runtime..z2fdebug.modinfo\n+//go:linkname debug_modinfo runtime_1debug.modinfo\n func debug_modinfo() string {\n \treturn modinfo\n }"}, {"sha": "816d93c6ef0164591337887a07cd6c0ce1371759", "filename": "libgo/go/runtime/heapdump.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fheapdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fheapdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fheapdump.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -16,7 +16,7 @@ import (\n \t\"unsafe\"\n )\n \n-//go:linkname runtime_debug_WriteHeapDump runtime..z2fdebug.WriteHeapDump\n+//go:linkname runtime_debug_WriteHeapDump runtime_1debug.WriteHeapDump\n func runtime_debug_WriteHeapDump(fd uintptr) {\n \tstopTheWorld(\"write heap dump\")\n "}, {"sha": "f9df1e0d79a6fb0e1adb83d0a94a7436d0855aef", "filename": "libgo/go/runtime/iface.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fiface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fiface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fiface.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -505,7 +505,7 @@ func reflect_ifaceE2I(inter *interfacetype, e eface, dst *iface) {\n \tdst.data = e.data\n }\n \n-//go:linkname reflectlite_ifaceE2I internal..z2freflectlite.ifaceE2I\n+//go:linkname reflectlite_ifaceE2I internal_1reflectlite.ifaceE2I\n func reflectlite_ifaceE2I(inter *interfacetype, e eface, dst *iface) {\n \tt := e._type\n \tif t == nil {"}, {"sha": "9fed1a8bff1f2bec10b92ff5580db6bfc8a66b72", "filename": "libgo/go/runtime/internal/atomic/atomic.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -7,7 +7,7 @@\n #include \"runtime.h\"\n \n uint32_t Load (uint32_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Load\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Load\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -17,7 +17,7 @@ Load (uint32_t *ptr)\n }\n \n void *Loadp (void *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loadp\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Loadp\")\n   __attribute__ ((no_split_stack));\n \n void *\n@@ -27,7 +27,7 @@ Loadp (void *ptr)\n }\n \n uint8_t Load8 (uint8_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Load8\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Load8\")\n   __attribute__ ((no_split_stack));\n \n uint8_t\n@@ -37,7 +37,7 @@ Load8 (uint8_t *ptr)\n }\n \n uint64_t Load64 (uint64_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Load64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Load64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -49,7 +49,7 @@ Load64 (uint64_t *ptr)\n }\n \n uint32_t LoadAcq (uint32_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.LoadAcq\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.LoadAcq\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -59,7 +59,7 @@ LoadAcq (uint32_t *ptr)\n }\n \n uintptr_t Loaduintptr (uintptr_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loaduintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Loaduintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -69,7 +69,7 @@ Loaduintptr (uintptr_t *ptr)\n }\n \n uintgo Loaduint (uintgo *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loaduint\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Loaduint\")\n   __attribute__ ((no_split_stack));\n \n uintgo\n@@ -79,7 +79,7 @@ Loaduint (uintgo *ptr)\n }\n \n int64_t Loadint64 (int64_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loadint64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Loadint64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -91,7 +91,7 @@ Loadint64 (int64_t *ptr)\n }\n \n uint32_t Xadd (uint32_t *ptr, int32_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xadd\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xadd\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -101,7 +101,7 @@ Xadd (uint32_t *ptr, int32_t delta)\n }\n \n uint64_t Xadd64 (uint64_t *ptr, int64_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xadd64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xadd64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -113,7 +113,7 @@ Xadd64 (uint64_t *ptr, int64_t delta)\n }\n \n uintptr_t Xadduintptr (uintptr_t *ptr, uintptr_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xadduintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xadduintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -123,7 +123,7 @@ Xadduintptr (uintptr_t *ptr, uintptr_t delta)\n }\n \n int64_t Xaddint64 (int64_t *ptr, int64_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xaddint64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xaddint64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -135,7 +135,7 @@ Xaddint64 (int64_t *ptr, int64_t delta)\n }\n \n uint32_t Xchg (uint32_t *ptr, uint32_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xchg\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xchg\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -145,7 +145,7 @@ Xchg (uint32_t *ptr, uint32_t new)\n }\n \n uint64_t Xchg64 (uint64_t *ptr, uint64_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xchg64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xchg64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -157,7 +157,7 @@ Xchg64 (uint64_t *ptr, uint64_t new)\n }\n \n uintptr_t Xchguintptr (uintptr_t *ptr, uintptr_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xchguintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Xchguintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -167,7 +167,7 @@ Xchguintptr (uintptr_t *ptr, uintptr_t new)\n }\n \n void And8 (uint8_t *ptr, uint8_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.And8\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.And8\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -177,7 +177,7 @@ And8 (uint8_t *ptr, uint8_t val)\n }\n \n void Or8 (uint8_t *ptr, uint8_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Or8\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Or8\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -187,7 +187,7 @@ Or8 (uint8_t *ptr, uint8_t val)\n }\n \n _Bool Cas (uint32_t *ptr, uint32_t old, uint32_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Cas\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Cas\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -197,7 +197,7 @@ Cas (uint32_t *ptr, uint32_t old, uint32_t new)\n }\n \n _Bool Cas64 (uint64_t *ptr, uint64_t old, uint64_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Cas64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Cas64\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -209,7 +209,7 @@ Cas64 (uint64_t *ptr, uint64_t old, uint64_t new)\n }\n \n _Bool CasRel (uint32_t *ptr, uint32_t old, uint32_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.CasRel\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.CasRel\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -219,7 +219,7 @@ CasRel (uint32_t *ptr, uint32_t old, uint32_t new)\n }\n \n _Bool Casp1 (void **ptr, void *old, void *new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Casp1\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Casp1\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -229,7 +229,7 @@ Casp1 (void **ptr, void *old, void *new)\n }\n \n _Bool Casuintptr (uintptr_t *ptr, uintptr_t old, uintptr_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Casuintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Casuintptr\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -239,7 +239,7 @@ Casuintptr (uintptr_t *ptr, uintptr_t old, uintptr_t new)\n }\n \n void Store (uint32_t *ptr, uint32_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Store\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Store\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -249,7 +249,7 @@ Store (uint32_t *ptr, uint32_t val)\n }\n \n void Store8 (uint8_t *ptr, uint8_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Store8\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Store8\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -259,7 +259,7 @@ Store8 (uint8_t *ptr, uint8_t val)\n }\n \n void Store64 (uint64_t *ptr, uint64_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Store64\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Store64\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -271,7 +271,7 @@ Store64 (uint64_t *ptr, uint64_t val)\n }\n \n void StoreRel (uint32_t *ptr, uint32_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.StoreRel\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.StoreRel\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -281,7 +281,7 @@ StoreRel (uint32_t *ptr, uint32_t val)\n }\n \n void Storeuintptr (uintptr_t *ptr, uintptr_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Storeuintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.Storeuintptr\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -291,7 +291,7 @@ Storeuintptr (uintptr_t *ptr, uintptr_t val)\n }\n \n void StorepNoWB (void *ptr, void *val)\n-  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.StorepNoWB\")\n+  __asm__ (GOSYM_PREFIX \"runtime_1internal_1atomic.StorepNoWB\")\n   __attribute__ ((no_split_stack));\n \n void"}, {"sha": "feb043ac2e9600078ec00f32c541f532dca8f92b", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1220,12 +1220,12 @@ func newobject(typ *_type) unsafe.Pointer {\n \treturn mallocgc(typ.size, typ, true)\n }\n \n-//go:linkname reflect_unsafe_New reflect.unsafe_New\n+//go:linkname reflect_unsafe_New reflect.unsafe__New\n func reflect_unsafe_New(typ *_type) unsafe.Pointer {\n \treturn mallocgc(typ.size, typ, true)\n }\n \n-//go:linkname reflectlite_unsafe_New internal..z2freflectlite.unsafe_New\n+//go:linkname reflectlite_unsafe_New internal_1reflectlite.unsafe__New\n func reflectlite_unsafe_New(typ *_type) unsafe.Pointer {\n \treturn mallocgc(typ.size, typ, true)\n }\n@@ -1242,7 +1242,7 @@ func newarray(typ *_type, n int) unsafe.Pointer {\n \treturn mallocgc(mem, typ, true)\n }\n \n-//go:linkname reflect_unsafe_NewArray reflect.unsafe_NewArray\n+//go:linkname reflect_unsafe_NewArray reflect.unsafe__NewArray\n func reflect_unsafe_NewArray(typ *_type, n int) unsafe.Pointer {\n \treturn newarray(typ, n)\n }"}, {"sha": "1155fee861c8176475e40dea7d6c5d7d24e58f1b", "filename": "libgo/go/runtime/map.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1417,7 +1417,7 @@ func reflect_maplen(h *hmap) int {\n \treturn h.count\n }\n \n-//go:linkname reflectlite_maplen internal..z2freflectlite.maplen\n+//go:linkname reflectlite_maplen internal_1reflectlite.maplen\n func reflectlite_maplen(h *hmap) int {\n \tif h == nil {\n \t\treturn 0"}, {"sha": "3bd8b34429d2bfe8cca84f625f2705baaa554c28", "filename": "libgo/go/runtime/mbarrier.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmbarrier.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbarrier.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -192,7 +192,7 @@ func reflect_typedmemmove(typ *_type, dst, src unsafe.Pointer) {\n \ttypedmemmove(typ, dst, src)\n }\n \n-//go:linkname reflectlite_typedmemmove internal..z2freflectlite.typedmemmove\n+//go:linkname reflectlite_typedmemmove internal_1reflectlite.typedmemmove\n func reflectlite_typedmemmove(typ *_type, dst, src unsafe.Pointer) {\n \treflect_typedmemmove(typ, dst, src)\n }"}, {"sha": "72479c2391687b94e6e2882adaf0d8ed606cfc74", "filename": "libgo/go/runtime/mgc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -223,7 +223,7 @@ func gcenable() {\n \tmemstats.enablegc = true // now that runtime is initialized, GC is okay\n }\n \n-//go:linkname setGCPercent runtime..z2fdebug.setGCPercent\n+//go:linkname setGCPercent runtime_1debug.setGCPercent\n func setGCPercent(in int32) (out int32) {\n \t// Run on the system stack since we grab the heap lock.\n \tsystemstack(func() {\n@@ -2238,7 +2238,7 @@ func gcResetMarkState() {\n \n var poolcleanup func()\n \n-//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup\n+//go:linkname sync_runtime_registerPoolCleanup sync.runtime__registerPoolCleanup\n func sync_runtime_registerPoolCleanup(f func()) {\n \tpoolcleanup = f\n }"}, {"sha": "755efd19772fd427fd9463c21d706f03a692befd", "filename": "libgo/go/runtime/mheap.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmheap.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1502,7 +1502,7 @@ func (h *mheap) scavengeAll() {\n \t}\n }\n \n-//go:linkname runtime_debug_freeOSMemory runtime..z2fdebug.freeOSMemory\n+//go:linkname runtime_debug_freeOSMemory runtime_1debug.freeOSMemory\n func runtime_debug_freeOSMemory() {\n \tGC()\n \tsystemstack(func() { mheap_.scavengeAll() })"}, {"sha": "afacf8fa70f50f388cee156e421e86b239e94c53", "filename": "libgo/go/runtime/mprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmprof.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -942,7 +942,7 @@ func ThreadCreateProfile(p []StackRecord) (n int, ok bool) {\n \treturn\n }\n \n-//go:linkname runtime_goroutineProfileWithLabels runtime..z2fpprof.runtime_goroutineProfileWithLabels\n+//go:linkname runtime_goroutineProfileWithLabels runtime_1pprof.runtime__goroutineProfileWithLabels\n func runtime_goroutineProfileWithLabels(p []StackRecord, labels []unsafe.Pointer) (n int, ok bool) {\n \treturn goroutineProfileWithLabels(p, labels)\n }"}, {"sha": "85a0861b8cd658c94ca80b2e7685634a4b2e9c22", "filename": "libgo/go/runtime/mstats.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmstats.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fmstats.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmstats.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -468,7 +468,7 @@ func readmemstats_m(stats *MemStats) {\n \tstats.StackSys += stats.StackInuse\n }\n \n-//go:linkname readGCStats runtime..z2fdebug.readGCStats\n+//go:linkname readGCStats runtime_1debug.readGCStats\n func readGCStats(pauses *[]uint64) {\n \tsystemstack(func() {\n \t\treadGCStats_m(pauses)"}, {"sha": "38ff5a4ccb314d60c3589059ccf584b4b8d92ecb", "filename": "libgo/go/runtime/net_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fnet_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fnet_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnet_plan9.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -8,12 +8,12 @@ import (\n \t_ \"unsafe\"\n )\n \n-//go:linkname runtime_ignoreHangup internal..z2fpoll.runtime_ignoreHangup\n+//go:linkname runtime_ignoreHangup internal_1poll.runtime__ignoreHangup\n func runtime_ignoreHangup() {\n \tgetg().m.ignoreHangup = true\n }\n \n-//go:linkname runtime_unignoreHangup internal..z2fpoll.runtime_unignoreHangup\n+//go:linkname runtime_unignoreHangup internal_1poll.runtime__unignoreHangup\n func runtime_unignoreHangup(sig string) {\n \tgetg().m.ignoreHangup = false\n }"}, {"sha": "da00b57c276ee1ed89f68a7985af1263e3f1e467", "filename": "libgo/go/runtime/netpoll.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -113,7 +113,7 @@ var (\n \tnetpollWaiters uint32\n )\n \n-//go:linkname poll_runtime_pollServerInit internal..z2fpoll.runtime_pollServerInit\n+//go:linkname poll_runtime_pollServerInit internal_1poll.runtime__pollServerInit\n func poll_runtime_pollServerInit() {\n \tnetpollGenericInit()\n }\n@@ -134,15 +134,15 @@ func netpollinited() bool {\n \treturn atomic.Load(&netpollInited) != 0\n }\n \n-//go:linkname poll_runtime_isPollServerDescriptor internal..z2fpoll.runtime_isPollServerDescriptor\n+//go:linkname poll_runtime_isPollServerDescriptor internal_1poll.runtime__isPollServerDescriptor\n \n // poll_runtime_isPollServerDescriptor reports whether fd is a\n // descriptor being used by netpoll.\n func poll_runtime_isPollServerDescriptor(fd uintptr) bool {\n \treturn netpollIsPollDescriptor(fd)\n }\n \n-//go:linkname poll_runtime_pollOpen internal..z2fpoll.runtime_pollOpen\n+//go:linkname poll_runtime_pollOpen internal_1poll.runtime__pollOpen\n func poll_runtime_pollOpen(fd uintptr) (uintptr, int) {\n \tpd := pollcache.alloc()\n \tlock(&pd.lock)\n@@ -169,7 +169,7 @@ func poll_runtime_pollOpen(fd uintptr) (uintptr, int) {\n \treturn uintptr(unsafe.Pointer(pd)), int(errno)\n }\n \n-//go:linkname poll_runtime_pollClose internal..z2fpoll.runtime_pollClose\n+//go:linkname poll_runtime_pollClose internal_1poll.runtime__pollClose\n func poll_runtime_pollClose(ctx uintptr) {\n \tpd := (*pollDesc)(unsafe.Pointer(ctx))\n \tif !pd.closing {\n@@ -195,7 +195,7 @@ func (c *pollCache) free(pd *pollDesc) {\n // poll_runtime_pollReset, which is internal/poll.runtime_pollReset,\n // prepares a descriptor for polling in mode, which is 'r' or 'w'.\n // This returns an error code; the codes are defined above.\n-//go:linkname poll_runtime_pollReset internal..z2fpoll.runtime_pollReset\n+//go:linkname poll_runtime_pollReset internal_1poll.runtime__pollReset\n func poll_runtime_pollReset(ctx uintptr, mode int) int {\n \tpd := (*pollDesc)(unsafe.Pointer(ctx))\n \terrcode := netpollcheckerr(pd, int32(mode))\n@@ -214,7 +214,7 @@ func poll_runtime_pollReset(ctx uintptr, mode int) int {\n // waits for a descriptor to be ready for reading or writing,\n // according to mode, which is 'r' or 'w'.\n // This returns an error code; the codes are defined above.\n-//go:linkname poll_runtime_pollWait internal..z2fpoll.runtime_pollWait\n+//go:linkname poll_runtime_pollWait internal_1poll.runtime__pollWait\n func poll_runtime_pollWait(ctx uintptr, mode int) int {\n \tpd := (*pollDesc)(unsafe.Pointer(ctx))\n \terrcode := netpollcheckerr(pd, int32(mode))\n@@ -237,7 +237,7 @@ func poll_runtime_pollWait(ctx uintptr, mode int) int {\n \treturn pollNoError\n }\n \n-//go:linkname poll_runtime_pollWaitCanceled internal..z2fpoll.runtime_pollWaitCanceled\n+//go:linkname poll_runtime_pollWaitCanceled internal_1poll.runtime__pollWaitCanceled\n func poll_runtime_pollWaitCanceled(ctx uintptr, mode int) {\n \tpd := (*pollDesc)(unsafe.Pointer(ctx))\n \t// This function is used only on windows after a failed attempt to cancel\n@@ -246,7 +246,7 @@ func poll_runtime_pollWaitCanceled(ctx uintptr, mode int) {\n \t}\n }\n \n-//go:linkname poll_runtime_pollSetDeadline internal..z2fpoll.runtime_pollSetDeadline\n+//go:linkname poll_runtime_pollSetDeadline internal_1poll.runtime__pollSetDeadline\n func poll_runtime_pollSetDeadline(ctx uintptr, d int64, mode int) {\n \tpd := (*pollDesc)(unsafe.Pointer(ctx))\n \tlock(&pd.lock)\n@@ -330,7 +330,7 @@ func poll_runtime_pollSetDeadline(ctx uintptr, d int64, mode int) {\n \t}\n }\n \n-//go:linkname poll_runtime_pollUnblock internal..z2fpoll.runtime_pollUnblock\n+//go:linkname poll_runtime_pollUnblock internal_1poll.runtime__pollUnblock\n func poll_runtime_pollUnblock(ctx uintptr) {\n \tpd := (*pollDesc)(unsafe.Pointer(ctx))\n \tlock(&pd.lock)"}, {"sha": "83bf572dd6cbb79331e0d607a866053eebccb440", "filename": "libgo/go/runtime/pprof/mprof_test.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -91,35 +91,35 @@ func TestMemoryProfiler(t *testing.T) {\n \t\tstk    []string\n \t\tlegacy string\n \t}{{\n-\t\tstk: []string{\"pprof.allocatePersistent1K\", \"runtime/pprof.TestMemoryProfiler\"},\n+\t\tstk: []string{\"runtime/pprof.allocatePersistent1K\", \"runtime/pprof.TestMemoryProfiler\"},\n \t\tlegacy: fmt.Sprintf(`%v: %v \\[%v: %v\\] @ 0x[0-9,a-f x]+\n-#\t0x[0-9,a-f]+\tpprof\\.allocatePersistent1K\\+0x[0-9,a-f]+\t.*/mprof_test\\.go:47\n+#\t0x[0-9,a-f]+\truntime/pprof\\.allocatePersistent1K\\+0x[0-9,a-f]+\t.*/mprof_test\\.go:47\n #\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test\\.go:82\n `, 32*memoryProfilerRun, 1024*memoryProfilerRun, 32*memoryProfilerRun, 1024*memoryProfilerRun),\n \t}, {\n-\t\tstk: []string{\"pprof.allocateTransient1M\", \"runtime/pprof.TestMemoryProfiler\"},\n+\t\tstk: []string{\"runtime/pprof.allocateTransient1M\", \"runtime/pprof.TestMemoryProfiler\"},\n \t\tlegacy: fmt.Sprintf(`(0|%v): (0|%v) \\[%v: %v\\] @ 0x[0-9,a-f x]+\n-#\t0x[0-9,a-f]+\tpprof\\.allocateTransient1M\\+0x[0-9,a-f]+\t.*/mprof_test.go:24\n+#\t0x[0-9,a-f]+\truntime/pprof\\.allocateTransient1M\\+0x[0-9,a-f]+\t.*/mprof_test.go:24\n #\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:79\n `, (1<<10)*memoryProfilerRun, (1<<20)*memoryProfilerRun, (1<<10)*memoryProfilerRun, (1<<20)*memoryProfilerRun),\n \t}, {\n-\t\tstk: []string{\"pprof.allocateTransient2M\", \"runtime/pprof.TestMemoryProfiler\"},\n+\t\tstk: []string{\"runtime/pprof.allocateTransient2M\", \"runtime/pprof.TestMemoryProfiler\"},\n \t\t// This should start with \"0: 0\" but gccgo's imprecise\n \t\t// GC means that sometimes the value is not collected.\n \t\tlegacy: fmt.Sprintf(`(0|%v): (0|%v) \\[%v: %v\\] @ 0x[0-9,a-f x]+\n-#\t0x[0-9,a-f]+\tpprof\\.allocateTransient2M\\+0x[0-9,a-f]+\t.*/mprof_test.go:30\n+#\t0x[0-9,a-f]+\truntime/pprof\\.allocateTransient2M\\+0x[0-9,a-f]+\t.*/mprof_test.go:30\n #\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:80\n `, memoryProfilerRun, (2<<20)*memoryProfilerRun, memoryProfilerRun, (2<<20)*memoryProfilerRun),\n \t}, {\n-\t\tstk: []string{\"pprof.allocateTransient2MInline\", \"runtime/pprof.TestMemoryProfiler\"},\n+\t\tstk: []string{\"runtime/pprof.allocateTransient2MInline\", \"runtime/pprof.TestMemoryProfiler\"},\n \t\tlegacy: fmt.Sprintf(`(0|%v): (0|%v) \\[%v: %v\\] @ 0x[0-9,a-f x]+\n-#\t0x[0-9,a-f]+\tpprof\\.allocateTransient2MInline\\+0x[0-9,a-f]+\t.*/mprof_test.go:34\n+#\t0x[0-9,a-f]+\truntime/pprof\\.allocateTransient2MInline\\+0x[0-9,a-f]+\t.*/mprof_test.go:34\n #\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:81\n `, memoryProfilerRun, (4<<20)*memoryProfilerRun, memoryProfilerRun, (4<<20)*memoryProfilerRun),\n \t}, {\n-\t\tstk: []string{\"pprof.allocateReflectTransient\"},\n+\t\tstk: []string{\"runtime/pprof.allocateReflectTransient\"},\n \t\tlegacy: fmt.Sprintf(`(0|%v): (0|%v) \\[%v: %v\\] @( 0x[0-9,a-f]+)+\n-#\t0x[0-9,a-f]+\tpprof\\.allocateReflectTransient\\+0x[0-9,a-f]+\t.*/mprof_test.go:55\n+#\t0x[0-9,a-f]+\truntime/pprof\\.allocateReflectTransient\\+0x[0-9,a-f]+\t.*/mprof_test.go:55\n `, memoryProfilerRun, (3<<20)*memoryProfilerRun, memoryProfilerRun, (3<<20)*memoryProfilerRun),\n \t}}\n "}, {"sha": "7adf891afff153d871c5bbbd90f037c42e2a7f67", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -958,8 +958,8 @@ func TestMutexProfile(t *testing.T) {\n \n \t\tstks := stacks(p)\n \t\tfor _, want := range [][]string{\n-\t\t\t// {\"sync.(*Mutex).Unlock\", \"pprof.blockMutex.func1\"},\n-\t\t\t{\"sync.Mutex.Unlock\", \"pprof.blockMutex..func1\"},\n+\t\t\t// {\"sync.(*Mutex).Unlock\", \"runtime/pprof.blockMutex.func1\"},\n+\t\t\t{\"sync.Mutex.Unlock\", \"runtime/pprof.blockMutex..func1\"},\n \t\t} {\n \t\t\tif !containsStack(stks, want) {\n \t\t\t\tt.Errorf(\"No matching stack entry for %+v\", want)"}, {"sha": "8452076dc7d25ecbd9630aa8f458375cf6a1be1a", "filename": "libgo/go/runtime/preempt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fpreempt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fpreempt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpreempt.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -360,7 +360,7 @@ func isAsyncSafePoint(gp *g, pc uintptr) (bool, uintptr) {\n \t}\n \tname := f.Name()\n \tif hasPrefix(name, \"runtime.\") ||\n-\t\thasPrefix(name, \"runtime..z2finternal..z2f\") ||\n+\t\thasPrefix(name, \"runtime_1internal_1\") ||\n \t\thasPrefix(name, \"reflect.\") {\n \t\t// For now we never async preempt the runtime or\n \t\t// anything closely tied to the runtime. Known issues"}, {"sha": "6c720503c44471e28a79cacf49dde149fe971818", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -263,7 +263,7 @@ func main(unsafe.Pointer) {\n }\n \n // os_beforeExit is called from os.Exit(0).\n-//go:linkname os_beforeExit os.runtime_beforeExit\n+//go:linkname os_beforeExit os.runtime__beforeExit\n func os_beforeExit() {\n \tif raceenabled {\n \t\tracefini()\n@@ -3305,7 +3305,7 @@ func beforefork() {\n }\n \n // Called from syscall package before fork.\n-//go:linkname syscall_runtime_BeforeFork syscall.runtime_BeforeFork\n+//go:linkname syscall_runtime_BeforeFork syscall.runtime__BeforeFork\n //go:nosplit\n func syscall_runtime_BeforeFork() {\n \tsystemstack(beforefork)\n@@ -3320,7 +3320,7 @@ func afterfork() {\n }\n \n // Called from syscall package after fork in parent.\n-//go:linkname syscall_runtime_AfterFork syscall.runtime_AfterFork\n+//go:linkname syscall_runtime_AfterFork syscall.runtime__AfterFork\n //go:nosplit\n func syscall_runtime_AfterFork() {\n \tsystemstack(afterfork)\n@@ -3338,7 +3338,7 @@ var inForkedChild bool\n // temporarily sharing address space with the parent process, this must\n // not change any global variables or calling into C code that may do so.\n //\n-//go:linkname syscall_runtime_AfterForkInChild syscall.runtime_AfterForkInChild\n+//go:linkname syscall_runtime_AfterForkInChild syscall.runtime__AfterForkInChild\n //go:nosplit\n //go:nowritebarrierrec\n func syscall_runtime_AfterForkInChild() {\n@@ -3363,7 +3363,7 @@ func syscall_runtime_AfterForkInChild() {\n var pendingPreemptSignals uint32\n \n // Called from syscall package before Exec.\n-//go:linkname syscall_runtime_BeforeExec syscall.runtime_BeforeExec\n+//go:linkname syscall_runtime_BeforeExec syscall.runtime__BeforeExec\n func syscall_runtime_BeforeExec() {\n \t// Prevent thread creation during exec.\n \texecLock.lock()\n@@ -3378,7 +3378,7 @@ func syscall_runtime_BeforeExec() {\n }\n \n // Called from syscall package after Exec.\n-//go:linkname syscall_runtime_AfterExec syscall.runtime_AfterExec\n+//go:linkname syscall_runtime_AfterExec syscall.runtime__AfterExec\n func syscall_runtime_AfterExec() {\n \texecLock.unlock()\n }\n@@ -5165,7 +5165,7 @@ func (l *gList) pop() *g {\n \treturn gp\n }\n \n-//go:linkname setMaxThreads runtime..z2fdebug.setMaxThreads\n+//go:linkname setMaxThreads runtime_1debug.setMaxThreads\n func setMaxThreads(in int) (out int) {\n \tlock(&sched.lock)\n \tout = int(sched.maxmcount)\n@@ -5199,32 +5199,32 @@ func procUnpin() {\n \t_g_.m.locks--\n }\n \n-//go:linkname sync_runtime_procPin sync.runtime_procPin\n+//go:linkname sync_runtime_procPin sync.runtime__procPin\n //go:nosplit\n func sync_runtime_procPin() int {\n \treturn procPin()\n }\n \n-//go:linkname sync_runtime_procUnpin sync.runtime_procUnpin\n+//go:linkname sync_runtime_procUnpin sync.runtime__procUnpin\n //go:nosplit\n func sync_runtime_procUnpin() {\n \tprocUnpin()\n }\n \n-//go:linkname sync_atomic_runtime_procPin sync..z2fatomic.runtime_procPin\n+//go:linkname sync_atomic_runtime_procPin sync_1atomic.runtime__procPin\n //go:nosplit\n func sync_atomic_runtime_procPin() int {\n \treturn procPin()\n }\n \n-//go:linkname sync_atomic_runtime_procUnpin sync..z2fatomic.runtime_procUnpin\n+//go:linkname sync_atomic_runtime_procUnpin sync_1atomic.runtime__procUnpin\n //go:nosplit\n func sync_atomic_runtime_procUnpin() {\n \tprocUnpin()\n }\n \n // Active spinning for sync.Mutex.\n-//go:linkname sync_runtime_canSpin sync.runtime_canSpin\n+//go:linkname sync_runtime_canSpin sync.runtime__canSpin\n //go:nosplit\n func sync_runtime_canSpin(i int) bool {\n \t// sync.Mutex is cooperative, so we are conservative with spinning.\n@@ -5241,7 +5241,7 @@ func sync_runtime_canSpin(i int) bool {\n \treturn true\n }\n \n-//go:linkname sync_runtime_doSpin sync.runtime_doSpin\n+//go:linkname sync_runtime_doSpin sync.runtime__doSpin\n //go:nosplit\n func sync_runtime_doSpin() {\n \tprocyield(active_spin_cnt)"}, {"sha": "1e1f3bfab134f1cddaf50db815c04b1e4a1c83bb", "filename": "libgo/go/runtime/proflabel.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fproflabel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fproflabel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproflabel.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -8,7 +8,7 @@ import \"unsafe\"\n \n var labelSync uintptr\n \n-//go:linkname runtime_setProfLabel runtime..z2fpprof.runtime_setProfLabel\n+//go:linkname runtime_setProfLabel runtime_1pprof.runtime__setProfLabel\n func runtime_setProfLabel(labels unsafe.Pointer) {\n \t// Introduce race edge for read-back via profile.\n \t// This would more properly use &getg().labels as the sync address,\n@@ -34,7 +34,7 @@ func runtime_setProfLabel(labels unsafe.Pointer) {\n \tgetg().labels = labels\n }\n \n-//go:linkname runtime_getProfLabel runtime..z2fpprof.runtime_getProfLabel\n+//go:linkname runtime_getProfLabel runtime_1pprof.runtime__getProfLabel\n func runtime_getProfLabel() unsafe.Pointer {\n \treturn getg().labels\n }"}, {"sha": "9c43ce569070fa17ad94483bd9a77e66275de853", "filename": "libgo/go/runtime/rdebug.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Frdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Frdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Frdebug.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -11,14 +11,14 @@ import _ \"unsafe\" // for go:linkname\n // maxstacksize.\n var maxstacksize uintptr = 1 << 20 // enough until runtime.main sets it for real\n \n-//go:linkname setMaxStack runtime..z2fdebug.setMaxStack\n+//go:linkname setMaxStack runtime_1debug.setMaxStack\n func setMaxStack(in int) (out int) {\n \tout = int(maxstacksize)\n \tmaxstacksize = uintptr(in)\n \treturn out\n }\n \n-//go:linkname setPanicOnFault runtime..z2fdebug.setPanicOnFault\n+//go:linkname setPanicOnFault runtime_1debug.setPanicOnFault\n func setPanicOnFault(new bool) (old bool) {\n \t_g_ := getg()\n \told = _g_.paniconfault"}, {"sha": "5af28aec97488be1762b4415456bb5d4a48e9a06", "filename": "libgo/go/runtime/runtime.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -51,13 +51,13 @@ func tickspersecond() int64 {\n var envs []string\n var argslice []string\n \n-//go:linkname syscall_runtime_envs syscall.runtime_envs\n+//go:linkname syscall_runtime_envs syscall.runtime__envs\n func syscall_runtime_envs() []string { return append([]string{}, envs...) }\n \n //go:linkname syscall_Getpagesize syscall.Getpagesize\n func syscall_Getpagesize() int { return int(physPageSize) }\n \n-//go:linkname os_runtime_args os.runtime_args\n+//go:linkname os_runtime_args os.runtime__args\n func os_runtime_args() []string { return append([]string{}, argslice...) }\n \n //go:linkname syscall_Exit syscall.Exit"}, {"sha": "39969d19a7e41df225e45359bc0d1763d4609adb", "filename": "libgo/go/runtime/runtime1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fruntime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fruntime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime1.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -398,7 +398,7 @@ func parsedebugvars() {\n \ttraceback_env = traceback_cache\n }\n \n-//go:linkname setTraceback runtime..z2fdebug.SetTraceback\n+//go:linkname setTraceback runtime_1debug.SetTraceback\n func setTraceback(level string) {\n \tvar t uint32\n \tswitch level {"}, {"sha": "9a288806fa560a009db0d723b9156814859ff456", "filename": "libgo/go/runtime/sema.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fsema.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fsema.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsema.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -51,27 +51,27 @@ var semtable [semTabSize]struct {\n \tpad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot{})]byte\n }\n \n-//go:linkname sync_runtime_Semacquire sync.runtime_Semacquire\n+//go:linkname sync_runtime_Semacquire sync.runtime__Semacquire\n func sync_runtime_Semacquire(addr *uint32) {\n \tsemacquire1(addr, false, semaBlockProfile, 0)\n }\n \n-//go:linkname poll_runtime_Semacquire internal..z2fpoll.runtime_Semacquire\n+//go:linkname poll_runtime_Semacquire internal_1poll.runtime__Semacquire\n func poll_runtime_Semacquire(addr *uint32) {\n \tsemacquire1(addr, false, semaBlockProfile, 0)\n }\n \n-//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease\n+//go:linkname sync_runtime_Semrelease sync.runtime__Semrelease\n func sync_runtime_Semrelease(addr *uint32, handoff bool, skipframes int) {\n \tsemrelease1(addr, handoff, skipframes)\n }\n \n-//go:linkname sync_runtime_SemacquireMutex sync.runtime_SemacquireMutex\n+//go:linkname sync_runtime_SemacquireMutex sync.runtime__SemacquireMutex\n func sync_runtime_SemacquireMutex(addr *uint32, lifo bool, skipframes int) {\n \tsemacquire1(addr, lifo, semaBlockProfile|semaMutexProfile, skipframes)\n }\n \n-//go:linkname poll_runtime_Semrelease internal..z2fpoll.runtime_Semrelease\n+//go:linkname poll_runtime_Semrelease internal_1poll.runtime__Semrelease\n func poll_runtime_Semrelease(addr *uint32) {\n \tsemrelease(addr)\n }\n@@ -475,7 +475,7 @@ func less(a, b uint32) bool {\n // notifyListAdd adds the caller to a notify list such that it can receive\n // notifications. The caller must eventually call notifyListWait to wait for\n // such a notification, passing the returned ticket number.\n-//go:linkname notifyListAdd sync.runtime_notifyListAdd\n+//go:linkname notifyListAdd sync.runtime__notifyListAdd\n func notifyListAdd(l *notifyList) uint32 {\n \t// This may be called concurrently, for example, when called from\n \t// sync.Cond.Wait while holding a RWMutex in read mode.\n@@ -484,7 +484,7 @@ func notifyListAdd(l *notifyList) uint32 {\n \n // notifyListWait waits for a notification. If one has been sent since\n // notifyListAdd was called, it returns immediately. Otherwise, it blocks.\n-//go:linkname notifyListWait sync.runtime_notifyListWait\n+//go:linkname notifyListWait sync.runtime__notifyListWait\n func notifyListWait(l *notifyList, t uint32) {\n \tlockWithRank(&l.lock, lockRankNotifyList)\n \n@@ -518,7 +518,7 @@ func notifyListWait(l *notifyList, t uint32) {\n }\n \n // notifyListNotifyAll notifies all entries in the list.\n-//go:linkname notifyListNotifyAll sync.runtime_notifyListNotifyAll\n+//go:linkname notifyListNotifyAll sync.runtime__notifyListNotifyAll\n func notifyListNotifyAll(l *notifyList) {\n \t// Fast-path: if there are no new waiters since the last notification\n \t// we don't need to acquire the lock.\n@@ -550,7 +550,7 @@ func notifyListNotifyAll(l *notifyList) {\n }\n \n // notifyListNotifyOne notifies one entry in the list.\n-//go:linkname notifyListNotifyOne sync.runtime_notifyListNotifyOne\n+//go:linkname notifyListNotifyOne sync.runtime__notifyListNotifyOne\n func notifyListNotifyOne(l *notifyList) {\n \t// Fast-path: if there are no new waiters since the last notification\n \t// we don't need to acquire the lock at all.\n@@ -603,15 +603,15 @@ func notifyListNotifyOne(l *notifyList) {\n \tunlock(&l.lock)\n }\n \n-//go:linkname notifyListCheck sync.runtime_notifyListCheck\n+//go:linkname notifyListCheck sync.runtime__notifyListCheck\n func notifyListCheck(sz uintptr) {\n \tif sz != unsafe.Sizeof(notifyList{}) {\n \t\tprint(\"runtime: bad notifyList size - sync=\", sz, \" runtime=\", unsafe.Sizeof(notifyList{}), \"\\n\")\n \t\tthrow(\"bad notifyList size\")\n \t}\n }\n \n-//go:linkname sync_nanotime sync.runtime_nanotime\n+//go:linkname sync_nanotime sync.runtime__nanotime\n func sync_nanotime() int64 {\n \treturn nanotime()\n }"}, {"sha": "ed024e1281329a0fe244ebc5da65e3fbf9365cda", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -121,7 +121,7 @@ Send:\n \n // Called to receive the next queued signal.\n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_recv os..z2fsignal.signal_recv\n+//go:linkname signal_recv os_1signal.signal__recv\n func signal_recv() uint32 {\n \tfor {\n \t\t// Serve any signals from local copy.\n@@ -169,7 +169,7 @@ func signal_recv() uint32 {\n // the signal(s) in question, and here we are just waiting to make sure\n // that all the signals have been delivered to the user channels\n // by the os/signal package.\n-//go:linkname signalWaitUntilIdle os..z2fsignal.signalWaitUntilIdle\n+//go:linkname signalWaitUntilIdle os_1signal.signalWaitUntilIdle\n func signalWaitUntilIdle() {\n \t// Although the signals we care about have been removed from\n \t// sig.wanted, it is possible that another thread has received\n@@ -189,7 +189,7 @@ func signalWaitUntilIdle() {\n }\n \n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_enable os..z2fsignal.signal_enable\n+//go:linkname signal_enable os_1signal.signal__enable\n func signal_enable(s uint32) {\n \tif !sig.inuse {\n \t\t// This is the first call to signal_enable. Initialize.\n@@ -217,7 +217,7 @@ func signal_enable(s uint32) {\n }\n \n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_disable os..z2fsignal.signal_disable\n+//go:linkname signal_disable os_1signal.signal__disable\n func signal_disable(s uint32) {\n \tif s >= uint32(len(sig.wanted)*32) {\n \t\treturn\n@@ -230,7 +230,7 @@ func signal_disable(s uint32) {\n }\n \n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_ignore os..z2fsignal.signal_ignore\n+//go:linkname signal_ignore os_1signal.signal__ignore\n func signal_ignore(s uint32) {\n \tif s >= uint32(len(sig.wanted)*32) {\n \t\treturn\n@@ -257,7 +257,7 @@ func sigInitIgnored(s uint32) {\n }\n \n // Checked by signal handlers.\n-//go:linkname signal_ignored os..z2fsignal.signal_ignored\n+//go:linkname signal_ignored os_1signal.signal__ignored\n func signal_ignored(s uint32) bool {\n \ti := atomic.Load(&sig.ignored[s/32])\n \treturn i&(1<<(s&31)) != 0"}, {"sha": "22a2b13977dc5c5dfb09597a314a29e199996fc0", "filename": "libgo/go/runtime/symtab.go", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsymtab.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -5,6 +5,7 @@\n package runtime\n \n import (\n+\t\"internal/bytealg\"\n \t_ \"unsafe\" // for go:linkname\n )\n \n@@ -119,7 +120,7 @@ func pcInlineCallers(pc uintptr, locbuf *location, max int32) int32\n // runtime_expandFinalInlineFrame expands the final pc in stk to include all\n // \"callers\" if pc is inline.\n //\n-//go:linkname runtime_expandFinalInlineFrame runtime..z2fpprof.runtime_expandFinalInlineFrame\n+//go:linkname runtime_expandFinalInlineFrame runtime_1pprof.runtime__expandFinalInlineFrame\n func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr {\n \tif len(stk) == 0 {\n \t\treturn stk\n@@ -210,42 +211,62 @@ func hexDigitsToRune(digits []byte, ndig int) rune {\n \treturn rune(result)\n }\n \n-// Perform an in-place decoding on the input byte slice. This looks\n-// for \"..z<hex 2 >\", \"..u<hex x 4>\" and \"..U<hex x 8>\" and overwrites\n-// with the encoded bytes corresponding to the unicode in question.\n-// Return value is the number of bytes taken by the result.\n-\n+// decodeIdentifier performs an in-place decoding on the input byte slice.\n+// This undoes the compiler underscore mangling.\n+// Returns the number of bytes used by the result.\n func decodeIdentifier(bsl []byte) int {\n+\tunderscoreCodes := map[byte]byte{\n+\t\t'_': '_',\n+\t\t'0': '.',\n+\t\t'1': '/',\n+\t\t'2': '*',\n+\t\t'3': ',',\n+\t\t'4': '{',\n+\t\t'5': '}',\n+\t\t'6': '[',\n+\t\t'7': ']',\n+\t\t'8': '(',\n+\t\t'9': ')',\n+\t\t'a': '\"',\n+\t\t'b': ' ',\n+\t\t'c': ';',\n+\t}\n+\n \tj := 0\n \tfor i := 0; i < len(bsl); i++ {\n \t\tb := bsl[i]\n+\t\tif b != '_' || i+1 >= len(bsl) {\n+\t\t\tbsl[j] = b\n+\t\t\tj++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif d, ok := underscoreCodes[bsl[i+1]]; ok {\n+\t\t\ti++\n+\t\t\tbsl[j] = d\n+\t\t\tj++\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\trlen := 0\n+\t\tswitch bsl[i+1] {\n+\t\tcase 'x':\n+\t\t\trlen = 2\n+\t\tcase 'u':\n+\t\t\trlen = 4\n+\t\tcase 'U':\n+\t\t\trlen = 8\n+\t\t}\n \n-\t\tif i+1 < len(bsl) && bsl[i] == '.' && bsl[i+1] == '.' {\n-\t\t\tif i+4 < len(bsl) && bsl[i+2] == 'z' {\n-\t\t\t\tdigits := bsl[i+3:]\n-\t\t\t\tr := hexDigitsToRune(digits, 2)\n-\t\t\t\tnc := encoderune(bsl[j:], r)\n-\t\t\t\tj += nc\n-\t\t\t\ti += 4\n-\t\t\t\tcontinue\n-\t\t\t} else if i+6 < len(bsl) && bsl[i+2] == 'u' {\n-\t\t\t\tdigits := bsl[i+3:]\n-\t\t\t\tr := hexDigitsToRune(digits, 4)\n-\t\t\t\tnc := encoderune(bsl[j:], r)\n-\t\t\t\tj += nc\n-\t\t\t\ti += 6\n-\t\t\t\tcontinue\n-\t\t\t} else if i+10 < len(bsl) && bsl[i+2] == 'U' {\n-\t\t\t\tdigits := bsl[i+3:]\n-\t\t\t\tr := hexDigitsToRune(digits, 8)\n-\t\t\t\tnc := encoderune(bsl[j:], r)\n-\t\t\t\tj += nc\n-\t\t\t\ti += 10\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\tif rlen > 0 && i+1+rlen < len(bsl) {\n+\t\t\tr := hexDigitsToRune(bsl[i+2:], rlen)\n+\t\t\tnc := encoderune(bsl[j:], r)\n+\t\t\tj += nc\n+\t\t\ti += rlen + 1\n+\t\t} else {\n+\t\t\tbsl[j] = b\n+\t\t\tj++\n \t\t}\n-\t\tbsl[j] = b\n-\t\tj += 1\n \t}\n \treturn j\n }\n@@ -254,6 +275,11 @@ func decodeIdentifier(bsl []byte) int {\n // as used in the compiler.\n \n func demangleSymbol(s string) string {\n+\tif bytealg.IndexByteString(s, '.') < 0 {\n+\t\t// A symbol with no '.' is not a Go symbol.\n+\t\treturn s\n+\t}\n+\n \tbsl := []byte(s)\n \tnchars := decodeIdentifier(bsl)\n \tbsl = bsl[:nchars]"}, {"sha": "b05f30a928a362f30aba8b5ae3f23f58ed092f44", "filename": "libgo/go/runtime/trace.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Ftrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Ftrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -1152,7 +1152,7 @@ func traceNextGC() {\n // To access runtime functions from runtime/trace.\n // See runtime/trace/annotation.go\n \n-//go:linkname trace_userTaskCreate runtime..z2ftrace.userTaskCreate\n+//go:linkname trace_userTaskCreate runtime_1trace.userTaskCreate\n func trace_userTaskCreate(id, parentID uint64, taskType string) {\n \tif !trace.enabled {\n \t\treturn\n@@ -1170,12 +1170,12 @@ func trace_userTaskCreate(id, parentID uint64, taskType string) {\n \ttraceReleaseBuffer(pid)\n }\n \n-//go:linkname trace_userTaskEnd runtime..z2ftrace.userTaskEnd\n+//go:linkname trace_userTaskEnd runtime_1trace.userTaskEnd\n func trace_userTaskEnd(id uint64) {\n \ttraceEvent(traceEvUserTaskEnd, 2, id)\n }\n \n-//go:linkname trace_userRegion runtime..z2ftrace.userRegion\n+//go:linkname trace_userRegion runtime_1trace.userRegion\n func trace_userRegion(id, mode uint64, name string) {\n \tif !trace.enabled {\n \t\treturn\n@@ -1192,7 +1192,7 @@ func trace_userRegion(id, mode uint64, name string) {\n \ttraceReleaseBuffer(pid)\n }\n \n-//go:linkname trace_userLog runtime..z2ftrace.userLog\n+//go:linkname trace_userLog runtime_1trace.userLog\n func trace_userLog(id uint64, category, message string) {\n \tif !trace.enabled {\n \t\treturn"}, {"sha": "ebdbefcb24dd7829ffbaa186607ad6a7b82e0532", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -184,10 +184,10 @@ func showfuncinfo(name string, firstFrame bool) bool {\n // isExportedRuntime reports whether name is an exported runtime function.\n // It is only for runtime functions, so ASCII A-Z is fine. Here also check\n // for mangled functions from runtime/<...>, which will be prefixed with\n-// \"runtime..z2f\".\n+// \"runtime_1\".\n func isExportedRuntime(name string) bool {\n \tconst n = len(\"runtime.\")\n-\tif hasPrefix(name, \"runtime..z2f\") {\n+\tif hasPrefix(name, \"runtime_1\") {\n \t\treturn true\n \t}\n \treturn len(name) > n && name[:n] == \"runtime.\" && 'A' <= name[n] && name[n] <= 'Z'"}, {"sha": "71d51aaef473ac20955cade8e565a6e6b514bd7f", "filename": "libgo/go/sync/atomic/atomic.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -9,7 +9,7 @@\n #include \"runtime.h\"\n \n int32_t SwapInt32 (int32_t *, int32_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.SwapInt32\")\n   __attribute__ ((no_split_stack));\n \n int32_t\n@@ -19,7 +19,7 @@ SwapInt32 (int32_t *addr, int32_t new)\n }\n \n int64_t SwapInt64 (int64_t *, int64_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.SwapInt64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -31,7 +31,7 @@ SwapInt64 (int64_t *addr, int64_t new)\n }\n \n uint32_t SwapUint32 (uint32_t *, uint32_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.SwapUint32\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -41,7 +41,7 @@ SwapUint32 (uint32_t *addr, uint32_t new)\n }\n \n uint64_t SwapUint64 (uint64_t *, uint64_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.SwapUint64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -53,7 +53,7 @@ SwapUint64 (uint64_t *addr, uint64_t new)\n }\n \n uintptr_t SwapUintptr (uintptr_t *, uintptr_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.SwapUintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -63,7 +63,7 @@ SwapUintptr (uintptr_t *addr, uintptr_t new)\n }\n \n _Bool CompareAndSwapInt32 (int32_t *, int32_t, int32_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.CompareAndSwapInt32\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -74,7 +74,7 @@ CompareAndSwapInt32 (int32_t *val, int32_t old, int32_t new)\n }\n \n _Bool CompareAndSwapInt64 (int64_t *, int64_t, int64_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.CompareAndSwapInt64\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -87,7 +87,7 @@ CompareAndSwapInt64 (int64_t *val, int64_t old, int64_t new)\n }\n \n _Bool CompareAndSwapUint32 (uint32_t *, uint32_t, uint32_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.CompareAndSwapUint32\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -98,7 +98,7 @@ CompareAndSwapUint32 (uint32_t *val, uint32_t old, uint32_t new)\n }\n \n _Bool CompareAndSwapUint64 (uint64_t *, uint64_t, uint64_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.CompareAndSwapUint64\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -111,7 +111,7 @@ CompareAndSwapUint64 (uint64_t *val, uint64_t old, uint64_t new)\n }\n \n _Bool CompareAndSwapUintptr (uintptr_t *, uintptr_t, uintptr_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.CompareAndSwapUintptr\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -122,7 +122,7 @@ CompareAndSwapUintptr (uintptr_t *val, uintptr_t old, uintptr_t new)\n }\n \n int32_t AddInt32 (int32_t *, int32_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.AddInt32\")\n   __attribute__ ((no_split_stack));\n \n int32_t\n@@ -132,7 +132,7 @@ AddInt32 (int32_t *val, int32_t delta)\n }\n \n uint32_t AddUint32 (uint32_t *, uint32_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.AddUint32\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -142,7 +142,7 @@ AddUint32 (uint32_t *val, uint32_t delta)\n }\n \n int64_t AddInt64 (int64_t *, int64_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.AddInt64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -154,7 +154,7 @@ AddInt64 (int64_t *val, int64_t delta)\n }\n \n uint64_t AddUint64 (uint64_t *, uint64_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.AddUint64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -166,7 +166,7 @@ AddUint64 (uint64_t *val, uint64_t delta)\n }\n \n uintptr_t AddUintptr (uintptr_t *, uintptr_t)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.AddUintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -176,7 +176,7 @@ AddUintptr (uintptr_t *val, uintptr_t delta)\n }\n \n int32_t LoadInt32 (int32_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.LoadInt32\")\n   __attribute__ ((no_split_stack));\n \n int32_t\n@@ -186,7 +186,7 @@ LoadInt32 (int32_t *addr)\n }\n \n int64_t LoadInt64 (int64_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.LoadInt64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -198,7 +198,7 @@ LoadInt64 (int64_t *addr)\n }\n \n uint32_t LoadUint32 (uint32_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.LoadUint32\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -208,7 +208,7 @@ LoadUint32 (uint32_t *addr)\n }\n \n uint64_t LoadUint64 (uint64_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.LoadUint64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -220,7 +220,7 @@ LoadUint64 (uint64_t *addr)\n }\n \n uintptr_t LoadUintptr (uintptr_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.LoadUintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -230,7 +230,7 @@ LoadUintptr (uintptr_t *addr)\n }\n \n void *LoadPointer (void **addr)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadPointer\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.LoadPointer\")\n   __attribute__ ((no_split_stack));\n \n void *\n@@ -240,7 +240,7 @@ LoadPointer (void **addr)\n }\n \n void StoreInt32 (int32_t *addr, int32_t val)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.StoreInt32\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -250,7 +250,7 @@ StoreInt32 (int32_t *addr, int32_t val)\n }\n \n void StoreInt64 (int64_t *addr, int64_t val)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.StoreInt64\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -262,7 +262,7 @@ StoreInt64 (int64_t *addr, int64_t val)\n }\n \n void StoreUint32 (uint32_t *addr, uint32_t val)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.StoreUint32\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -272,7 +272,7 @@ StoreUint32 (uint32_t *addr, uint32_t val)\n }\n \n void StoreUint64 (uint64_t *addr, uint64_t val)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.StoreUint64\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -284,7 +284,7 @@ StoreUint64 (uint64_t *addr, uint64_t val)\n }\n \n void StoreUintptr (uintptr_t *addr, uintptr_t val)\n-  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync_1atomic.StoreUintptr\")\n   __attribute__ ((no_split_stack));\n \n void"}, {"sha": "1ec5f87870cd64f7f605fe5bcef3f4d8d23efb49", "filename": "libgo/runtime/go-ffi.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-ffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-ffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -16,36 +16,36 @@\n    the libffi type values.  */\n \n ffi_type *go_ffi_type_pointer(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_pointer(void) __asm__ (\"runtime.ffi_type_pointer\");\n+ffi_type *go_ffi_type_pointer(void) __asm__ (\"runtime.ffi__type__pointer\");\n ffi_type *go_ffi_type_sint8(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_sint8(void) __asm__ (\"runtime.ffi_type_sint8\");\n+ffi_type *go_ffi_type_sint8(void) __asm__ (\"runtime.ffi__type__sint8\");\n ffi_type *go_ffi_type_sint16(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_sint16(void) __asm__ (\"runtime.ffi_type_sint16\");\n+ffi_type *go_ffi_type_sint16(void) __asm__ (\"runtime.ffi__type__sint16\");\n ffi_type *go_ffi_type_sint32(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_sint32(void) __asm__ (\"runtime.ffi_type_sint32\");\n+ffi_type *go_ffi_type_sint32(void) __asm__ (\"runtime.ffi__type__sint32\");\n ffi_type *go_ffi_type_sint64(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_sint64(void) __asm__ (\"runtime.ffi_type_sint64\");\n+ffi_type *go_ffi_type_sint64(void) __asm__ (\"runtime.ffi__type__sint64\");\n ffi_type *go_ffi_type_uint8(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_uint8(void) __asm__ (\"runtime.ffi_type_uint8\");\n+ffi_type *go_ffi_type_uint8(void) __asm__ (\"runtime.ffi__type__uint8\");\n ffi_type *go_ffi_type_uint16(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_uint16(void) __asm__ (\"runtime.ffi_type_uint16\");\n+ffi_type *go_ffi_type_uint16(void) __asm__ (\"runtime.ffi__type__uint16\");\n ffi_type *go_ffi_type_uint32(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_uint32(void) __asm__ (\"runtime.ffi_type_uint32\");\n+ffi_type *go_ffi_type_uint32(void) __asm__ (\"runtime.ffi__type__uint32\");\n ffi_type *go_ffi_type_uint64(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_uint64(void) __asm__ (\"runtime.ffi_type_uint64\");\n+ffi_type *go_ffi_type_uint64(void) __asm__ (\"runtime.ffi__type__uint64\");\n ffi_type *go_ffi_type_float(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_float(void) __asm__ (\"runtime.ffi_type_float\");\n+ffi_type *go_ffi_type_float(void) __asm__ (\"runtime.ffi__type__float\");\n ffi_type *go_ffi_type_double(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_double(void) __asm__ (\"runtime.ffi_type_double\");\n+ffi_type *go_ffi_type_double(void) __asm__ (\"runtime.ffi__type__double\");\n ffi_type *go_ffi_type_complex_float(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_complex_float(void) __asm__ (\"runtime.ffi_type_complex_float\");\n+ffi_type *go_ffi_type_complex_float(void) __asm__ (\"runtime.ffi__type__complex__float\");\n ffi_type *go_ffi_type_complex_double(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_complex_double(void) __asm__ (\"runtime.ffi_type_complex_double\");\n+ffi_type *go_ffi_type_complex_double(void) __asm__ (\"runtime.ffi__type__complex__double\");\n ffi_type *go_ffi_type_void(void) __attribute__ ((no_split_stack));\n-ffi_type *go_ffi_type_void(void) __asm__ (\"runtime.ffi_type_void\");\n+ffi_type *go_ffi_type_void(void) __asm__ (\"runtime.ffi__type__void\");\n \n _Bool go_ffi_supports_complex(void) __attribute__ ((no_split_stack));\n-_Bool go_ffi_supports_complex(void) __asm__ (\"runtime.ffi_supports_complex\");\n+_Bool go_ffi_supports_complex(void) __asm__ (\"runtime.ffi__supports__complex\");\n \n ffi_type *\n go_ffi_type_pointer(void)"}, {"sha": "08987def8af8d25cc7aacb1bdb7ff4d974047586", "filename": "libgo/runtime/go-setenv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-setenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-setenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-setenv.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -13,7 +13,7 @@\n \n /* Set the C environment from Go.  This is called by syscall.Setenv.  */\n \n-void setenv_c (String, String) __asm__ (GOSYM_PREFIX \"syscall.setenv_c\");\n+void setenv_c (String, String) __asm__ (GOSYM_PREFIX \"syscall.setenv__c\");\n \n void\n setenv_c (String k, String v)"}, {"sha": "e24bfb25d1e256e02d0c8c1c6d738c3a20928fa1", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -72,7 +72,7 @@ const struct _type unsafe_Pointer =\n    it to be defined elsewhere.  */\n \n extern const struct ptrtype pointer_unsafe_Pointer\n-  __asm__ (GOSYM_PREFIX \"type...1unsafe.Pointer\");\n+  __asm__ (GOSYM_PREFIX \"unsafe.Pointer..p\");\n \n /* The reflection string.  */\n #define PREFLECTION \"*unsafe.Pointer\"\n@@ -83,7 +83,7 @@ static const String preflection_string =\n };\n \n extern const byte pointer_unsafe_Pointer_gc[]\n-  __asm__ (GOSYM_PREFIX \"type...1unsafe.Pointer..g\");\n+  __asm__ (GOSYM_PREFIX \"unsafe.Pointer..p..g\");\n \n const byte pointer_unsafe_Pointer_gc[] = { 1 };\n "}, {"sha": "4b5058a220fb14751f0015c65fb0a2d51f91a2e3", "filename": "libgo/runtime/go-unsetenv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-unsetenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fgo-unsetenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsetenv.c?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -14,7 +14,7 @@\n /* Unset an environment variable from Go.  This is called by\n    syscall.Unsetenv.  */\n \n-void unsetenv_c (String) __asm__ (GOSYM_PREFIX \"syscall.unsetenv_c\");\n+void unsetenv_c (String) __asm__ (GOSYM_PREFIX \"syscall.unsetenv__c\");\n \n void\n unsetenv_c (String k)"}, {"sha": "3a65d44f349ac5c188e38a6576dd54bd1de4dbd2", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -440,7 +440,7 @@ void\truntime_freedefer(Defer*);\n \n extern void _cgo_wait_runtime_init_done (void);\n extern void _cgo_notify_runtime_init_done (void)\n-  __asm__ (GOSYM_PREFIX \"runtime._cgo_notify_runtime_init_done\");\n+  __asm__ (GOSYM_PREFIX \"runtime.__cgo__notify__runtime__init__done\");\n extern _Bool runtime_iscgo;\n extern uintptr __go_end __attribute__ ((weak));\n extern void *getitab(const struct _type *, const struct _type *, _Bool)"}, {"sha": "8c3c5ca1b32375fc3f7a9e6a5d5044be8722be78", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a01dda3c23b836754814fab1cab949a1bbc641e8/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=a01dda3c23b836754814fab1cab949a1bbc641e8", "patch": "@@ -496,15 +496,16 @@ testname() {\n localname() {\n \t# The package main has been renamed to __main__ when imported.\n \t# Adjust its uses.\n-\techo $1 | sed 's/^main\\./__main__./'\n+\t# Also demangle underscores.\n+\techo $1 | sed 's/^main\\./__main__./' | sed 's/__/_/'\n }\n \n # Takes a list of tests derived from 'nm' output (whose symbols are mangled)\n # and emits a demangled list of tests, using only the terminal package.\n # Example:\n #\n #    Original symbol:   foo/bar/leaf.Mumble\n-#    Mangled symbol:    foo..z2fbar..z2fleaf.Mumble\n+#    Mangled symbol:    foo_1fbar_1leaf.Mumble\n #    Returned:          leaf.Mumble\n #\n symtogo() {\n@@ -522,7 +523,7 @@ symtogo() {\n     if expr \"$tp\" : '^type\\.\\.' >/dev/null 2>&1; then\n       continue\n     fi\n-    s=$(echo \"$tp\" | sed -e 's/\\.\\.z2f/%/g' | sed -e 's/.*%//')\n+    s=$(echo \"$tp\" | sed -e 's/_1/%/g' | sed -e 's/.*%//')\n     # Screen out methods (X.Y.Z).\n     if ! expr \"$s\" : '^[^.]*\\.[^.]*$' >/dev/null 2>&1; then\n       continue"}]}