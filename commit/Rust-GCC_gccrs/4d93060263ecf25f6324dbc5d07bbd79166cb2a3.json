{"sha": "4d93060263ecf25f6324dbc5d07bbd79166cb2a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ5MzA2MDI2M2VjZjI1ZjYzMjRkYmM1ZDA3YmJkNzkxNjZjYjJhMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-09T14:51:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-09T14:51:57Z"}, "message": "Improve ivopts handling of forced scales\n\nThis patch improves the ivopts address cost calculation for modes\nin which an index must be scaled rather than unscaled.  Previously\nwe would only try the scaled form if the unscaled form was valid.\n\nMany of the SVE tests rely on this when matching scaled indices.\n\n2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-ssa-loop-ivopts.c (get_address_cost): Try using a\n\tscaled index even if the unscaled address was invalid.\n\tDon't increase the complexity of using a scale in that case.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254585", "tree": {"sha": "292c271ccc5d5f5031741141dc65eab9a1766ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/292c271ccc5d5f5031741141dc65eab9a1766ff5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d93060263ecf25f6324dbc5d07bbd79166cb2a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d93060263ecf25f6324dbc5d07bbd79166cb2a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d93060263ecf25f6324dbc5d07bbd79166cb2a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d93060263ecf25f6324dbc5d07bbd79166cb2a3/comments", "author": null, "committer": null, "parents": [{"sha": "1eae67f812a0b7b6b7132d0375e662bc6200d68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eae67f812a0b7b6b7132d0375e662bc6200d68a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eae67f812a0b7b6b7132d0375e662bc6200d68a"}], "stats": {"total": 25, "additions": 21, "deletions": 4}, "files": [{"sha": "eb0e6c2d51d95fb33ac8f51dc0e72979324875d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d93060263ecf25f6324dbc5d07bbd79166cb2a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d93060263ecf25f6324dbc5d07bbd79166cb2a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d93060263ecf25f6324dbc5d07bbd79166cb2a3", "patch": "@@ -1,3 +1,11 @@\n+2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (get_address_cost): Try using a\n+\tscaled index even if the unscaled address was invalid.\n+\tDon't increase the complexity of using a scale in that case.\n+\n 2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "65794b2b777e8d660d062df1fda2bec73cc7b895", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d93060263ecf25f6324dbc5d07bbd79166cb2a3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d93060263ecf25f6324dbc5d07bbd79166cb2a3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=4d93060263ecf25f6324dbc5d07bbd79166cb2a3", "patch": "@@ -4331,18 +4331,25 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n   machine_mode addr_mode = TYPE_MODE (type);\n   machine_mode mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n   addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n+  /* Only true if ratio != 1.  */\n+  bool ok_with_ratio_p = false;\n+  bool ok_without_ratio_p = false;\n \n   if (!aff_combination_const_p (aff_inv))\n     {\n       parts.index = integer_one_node;\n       /* Addressing mode \"base + index\".  */\n-      if (valid_mem_ref_p (mem_mode, as, &parts))\n+      ok_without_ratio_p = valid_mem_ref_p (mem_mode, as, &parts);\n+      if (ratio != 1)\n \t{\n \t  parts.step = wide_int_to_tree (type, ratio);\n \t  /* Addressing mode \"base + index << scale\".  */\n-\t  if (ratio != 1 && !valid_mem_ref_p (mem_mode, as, &parts))\n+\t  ok_with_ratio_p = valid_mem_ref_p (mem_mode, as, &parts);\n+\t  if (!ok_with_ratio_p)\n \t    parts.step = NULL_TREE;\n-\n+\t}\n+      if (ok_with_ratio_p || ok_without_ratio_p)\n+\t{\n \t  if (aff_inv->offset != 0)\n \t    {\n \t      parts.offset = wide_int_to_tree (sizetype, aff_inv->offset);\n@@ -4440,7 +4447,9 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n \n   if (parts.symbol != NULL_TREE)\n     cost.complexity += 1;\n-  if (parts.step != NULL_TREE && !integer_onep (parts.step))\n+  /* Don't increase the complexity of adding a scaled index if it's\n+     the only kind of index that the target allows.  */\n+  if (parts.step != NULL_TREE && ok_without_ratio_p)\n     cost.complexity += 1;\n   if (parts.base != NULL_TREE && parts.index != NULL_TREE)\n     cost.complexity += 1;"}]}