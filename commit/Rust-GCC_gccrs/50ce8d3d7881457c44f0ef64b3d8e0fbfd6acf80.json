{"sha": "50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBjZThkM2Q3ODgxNDU3YzQ0ZjBlZjY0YjNkOGUwZmJmZDZhY2Y4MA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2008-12-12T17:10:16Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-12-12T17:10:16Z"}, "message": "cstdatomic: Update to N2798.\n\n2008-12-11  Benjamin Kosnik  <bkoz@redhat.com>\n\t    Richard Henderson  <rth@redhat.com>\n\n\t* include/c_global/cstdatomic: Update to N2798.\n\t(atomic): Remove explicit constructors as per DR 845.\n\t* include/bits/atomic_0.h: New. Switchable implementation.\n\t* include/bits/atomic_2.h: New. Lock-free implementation.\n\t* include/c_compatibility/stdatomic.h: Use foward headers.\n\t* include/bits/atomicfwd_cxx.h: New.\n\t* include/bits/atomicfwd_c.h: New.\n\t* src/atomic.cc: Adjust.\n\t* acinclude.m4 (GLIBCXX_CHECK_STANDARD_LAYOUT): Remove,\n\tunconditionally use default/deleted syntax.\n\t(GLIBCXX_ENABLE_ATOMIC_BUILTINS): Check for 2, 8.\n\t* include/Makefile.am (bits_headers): Add atomicfwd_c.h,\n\tatomicfwd_cxx.h, atomic_0.h, atomic_2.h.\n\t* include/Makefile.in: Regenerate.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.\n\t* config/abi/pre/gnu.ver: Adjust exports.\n\n\t* testsuite/27_io/ios_base/types/fmtflags/bitmask_operators.cc: Adjust.\n\t* testsuite/27_io/ios_base/types/openmode/bitmask_operators.cc: Same.\n\t* testsuite/27_io/ios_base/types/iostate/bitmask_operators.cc: Same.\n\t* testsuite/29_atomics/atomic_address/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_address/cons/explicit_value.cc: Move to..\n\t* testsuite/29_atomics/atomic_address/cons/single_value.cc: ...this.\n\t* testsuite/29_atomics/atomic_address/cons/copy_neg.cc\n\t* testsuite/29_atomics/atomic_integral/cons/single_value.cc: New.\n\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: New.\n\t* testsuite/29_atomics/atomic_integral/cons/copy_neg.cc: New.\n\t* testsuite/29_atomics/atomic_integral/cons/default.cc: New.\n\t* testsuite/29_atomics/atomic_integral/cons/direct_list.cc: New.\n\t* testsuite/29_atomics/atomic_integral/cons/copy_list.cc: New.\n\t* testsuite/29_atomics/atomic_integral/requirements/\n\tstandard_layout.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/\n\tintegral_assignment.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/increment_neg.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/decrement_neg.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/increment.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/decrement.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/bitwise.cc: New.\n\t* testsuite/29_atomics/atomic_integral/operators/\n\tintegral_conversion.cc: New.\n\t* testsuite/29_atomics/atomic_flag/cons/assign_neg.cc: Adjust.\n\t* testsuite/29_atomics/atomic_flag/cons/copy_neg.cc: Same.\n\t* testsuite/29_atomics/atomic_flag/requirements/\n\tstandard_layout.cc: Same.\n\t* testsuite/29_atomics/atomic_flag/\n\tatomic_global_fence_compatibility.cc: Kill.\n\t* testsuite/29_atomics/headers/cstdatomic/types_std_c++0x.cc: Adjust.\n\t* testsuite/29_atomics/headers/cstdatomic/functions_std_c++0x.cc: Same.\n\t* testsuite/29_atomics/headers/cstdatomic/macros.cc: Same.\n\t* testsuite/29_atomics/headers/stdatomic.h/macros.c: Same.\n\t* testsuite/29_atomics/headers/stdatomic.h/types.c: Same.\n\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Same.\n\t* testsuite/29_atomics/atomic/cons/explicit_value.cc: Move to...\n\t* testsuite/29_atomics/atomic/cons/single_value.cc: ...this.\n\t* testsuite/29_atomics/atomic/cons/copy_neg.cc\n\t* testsuite/29_atomics/atomic/cons/direct_list.cc: New.\n\t* testsuite/29_atomics/atomic/cons/copy_list.cc: New.\n\t* testsuite/29_atomics/atomic/requirements/standard_layout.cc: New.\n\t* testsuite/29_atomics/atomic/requirements/base_classes.cc: New.\n\t* testsuite/29_atomics/atomic/operators/integral_assignment.cc: New.\n\t* testsuite/29_atomics/atomic/operators/integral_conversion.cc: New.\n\t* testsuite/util/testsuite_hooks.h (bitmask_operators): Move...\n\t* testsuite/util/testsuite_common_types.h: ...here.\n\t(atomic_integrals_no_bool): New.\n\t(atomic_integrals): New.\n\t(has_increment_operators, has_decrement_operators)\n\t(direct_list_initializable, single_value_constructible)\n\t(standard_layout, has_bitwise_operators, integral_convertable)\n\t(integral_assignable): Add.\n\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r142714", "tree": {"sha": "d3d243c9a6e2c75d6b11938be2803f572daeddf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d243c9a6e2c75d6b11938be2803f572daeddf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/comments", "author": null, "committer": null, "parents": [{"sha": "0f2dc4ccd7682ddb4f12a19e4554a797c405da4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2dc4ccd7682ddb4f12a19e4554a797c405da4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2dc4ccd7682ddb4f12a19e4554a797c405da4f"}], "stats": {"total": 7792, "additions": 3391, "deletions": 4401}, "files": [{"sha": "36149efdf27d8ab11e17b3db718de57c48b79930", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -1,3 +1,79 @@\n+2008-12-11  Benjamin Kosnik  <bkoz@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* include/c_global/cstdatomic: Update to N2798.\n+\t(atomic): Remove explicit constructors as per DR 845.\n+\t* include/bits/atomic_0.h: New. Switchable implementation.\n+\t* include/bits/atomic_2.h: New. Lock-free implementation.\n+\t* include/c_compatibility/stdatomic.h: Use foward headers.\n+\t* include/bits/atomicfwd_cxx.h: New.\n+\t* include/bits/atomicfwd_c.h: New.\n+\t* src/atomic.cc: Adjust.\n+\t* acinclude.m4 (GLIBCXX_CHECK_STANDARD_LAYOUT): Remove,\n+\tunconditionally use default/deleted syntax.\n+\t(GLIBCXX_ENABLE_ATOMIC_BUILTINS): Check for 2, 8.\n+\t* include/Makefile.am (bits_headers): Add atomicfwd_c.h,\n+\tatomicfwd_cxx.h, atomic_0.h, atomic_2.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* config/abi/pre/gnu.ver: Adjust exports.\n+\n+\t* testsuite/27_io/ios_base/types/fmtflags/bitmask_operators.cc: Adjust.\n+\t* testsuite/27_io/ios_base/types/openmode/bitmask_operators.cc: Same.\n+\t* testsuite/27_io/ios_base/types/iostate/bitmask_operators.cc: Same.\n+\t* testsuite/29_atomics/atomic_address/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_address/cons/explicit_value.cc: Move to..\n+\t* testsuite/29_atomics/atomic_address/cons/single_value.cc: ...this.\n+\t* testsuite/29_atomics/atomic_address/cons/copy_neg.cc\n+\t* testsuite/29_atomics/atomic_integral/cons/single_value.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/cons/assign_neg.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/cons/copy_neg.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/cons/default.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/cons/direct_list.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/cons/copy_list.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/requirements/\n+\tstandard_layout.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/\n+\tintegral_assignment.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/increment_neg.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/decrement_neg.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/increment.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/decrement.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/bitwise.cc: New.\n+\t* testsuite/29_atomics/atomic_integral/operators/\n+\tintegral_conversion.cc: New.\n+\t* testsuite/29_atomics/atomic_flag/cons/assign_neg.cc: Adjust.\n+\t* testsuite/29_atomics/atomic_flag/cons/copy_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic_flag/requirements/\n+\tstandard_layout.cc: Same.\n+\t* testsuite/29_atomics/atomic_flag/\n+\tatomic_global_fence_compatibility.cc: Kill.\n+\t* testsuite/29_atomics/headers/cstdatomic/types_std_c++0x.cc: Adjust.\n+\t* testsuite/29_atomics/headers/cstdatomic/functions_std_c++0x.cc: Same.\n+\t* testsuite/29_atomics/headers/cstdatomic/macros.cc: Same.\n+\t* testsuite/29_atomics/headers/stdatomic.h/macros.c: Same.\n+\t* testsuite/29_atomics/headers/stdatomic.h/types.c: Same.\n+\t* testsuite/29_atomics/atomic/cons/assign_neg.cc: Same.\n+\t* testsuite/29_atomics/atomic/cons/explicit_value.cc: Move to...\n+\t* testsuite/29_atomics/atomic/cons/single_value.cc: ...this.\n+\t* testsuite/29_atomics/atomic/cons/copy_neg.cc\n+\t* testsuite/29_atomics/atomic/cons/direct_list.cc: New.\n+\t* testsuite/29_atomics/atomic/cons/copy_list.cc: New.\n+\t* testsuite/29_atomics/atomic/requirements/standard_layout.cc: New.\n+\t* testsuite/29_atomics/atomic/requirements/base_classes.cc: New.\n+\t* testsuite/29_atomics/atomic/operators/integral_assignment.cc: New.\n+\t* testsuite/29_atomics/atomic/operators/integral_conversion.cc: New.\n+\t* testsuite/util/testsuite_hooks.h (bitmask_operators): Move...\n+\t* testsuite/util/testsuite_common_types.h: ...here.\n+\t(atomic_integrals_no_bool): New.\n+\t(atomic_integrals): New.\n+\t(has_increment_operators, has_decrement_operators)\n+\t(direct_list_initializable, single_value_constructible)\n+\t(standard_layout, has_bitwise_operators, integral_convertable)\n+\t(integral_assignable): Add.\n+\n 2008-12-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/37582"}, {"sha": "a1356bd7b06cb33dfdd122b114cdd4ec100e28f8", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 70, "deletions": 42, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -1676,41 +1676,6 @@ m4_popdef([SYSERR])dnl\n m4_popdef([n_syserr])dnl\n ])\n \n-dnl\n-dnl Check whether C++200x's standard layout types are supported. \n-dnl\n-AC_DEFUN([GLIBCXX_CHECK_STANDARD_LAYOUT], [\n-\n-  AC_MSG_CHECKING([for ISO C++200x standard layout type support])\n-  AC_CACHE_VAL(ac_standard_layout, [\n-  AC_LANG_SAVE\n-  AC_LANG_CPLUSPLUS\n-  ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n-  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n-  CXXFLAGS='-std=gnu++0x'\n-\n-  AC_TRY_COMPILE([struct b\n-                  {\n-  \t\t    bool t;\n-\n-\t\t    // Need standard layout relaxation from POD\n-\t\t    private:\t    \n-  \t\t    b& operator=(const b&);\n-  \t\t    b(const b&);\n-\t\t    };],\n-\t\t [b tst1 = { false };],\n-\t\t [ac_standard_layout=yes], [ac_standard_layout=no])\n-\n-  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n-  AC_LANG_RESTORE\n-  ])\n-  AC_MSG_RESULT($ac_standard_layout)\n-  if test x\"$ac_standard_layout\" = x\"yes\"; then\n-    AC_DEFINE(_GLIBCXX_USE_STANDARD_LAYOUT, 1,\n-              [Define if standard layout types are supported in C++200x.])\n-  fi\n-])\n-\n dnl\n dnl Check for what type of C headers to use.\n dnl\n@@ -2456,7 +2421,9 @@ dnl see: CHECK_SYNC_FETCH_AND_ADD\n dnl\n dnl Defines:\n dnl  _GLIBCXX_ATOMIC_BUILTINS_1 \n+dnl  _GLIBCXX_ATOMIC_BUILTINS_2\n dnl  _GLIBCXX_ATOMIC_BUILTINS_4\n+dnl  _GLIBCXX_ATOMIC_BUILTINS_8\n dnl\n AC_DEFUN([GLIBCXX_ENABLE_ATOMIC_BUILTINS], [\n   AC_LANG_SAVE\n@@ -2472,6 +2439,66 @@ AC_DEFUN([GLIBCXX_ENABLE_ATOMIC_BUILTINS], [\n     cat > conftest.$ac_ext << EOF\n [#]line __oline__ \"configure\"\n int main()\n+{\n+  typedef bool atomic_type;\n+  atomic_type c1;\n+  atomic_type c2;\n+  const atomic_type c3(0);\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n+}\n+EOF\n+\n+    AC_MSG_CHECKING([for atomic builtins for bool])\n+    if AC_TRY_EVAL(ac_compile); then\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinsb=no\n+      else\n+      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_1, 1,\n+      [Define if builtin atomic operations for bool are supported on this host.])\n+        enable_atomic_builtinsb=yes\n+      fi\n+    fi\n+    AC_MSG_RESULT($enable_atomic_builtinsb)\n+    rm -f conftest*\n+\n+    cat > conftest.$ac_ext << EOF\n+[#]line __oline__ \"configure\"\n+int main()\n+{\n+  typedef short atomic_type;\n+  atomic_type c1;\n+  atomic_type c2;\n+  const atomic_type c3(0);\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n+}\n+EOF\n+\n+    AC_MSG_CHECKING([for atomic builtins for short])\n+    if AC_TRY_EVAL(ac_compile); then\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinss=no\n+      else\n+      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_2, 1,\n+      [Define if builtin atomic operations for short are supported on this host.])\n+        enable_atomic_builtinss=yes\n+      fi\n+    fi\n+    AC_MSG_RESULT($enable_atomic_builtinss)\n+    rm -f conftest*\n+\n+    cat > conftest.$ac_ext << EOF\n+[#]line __oline__ \"configure\"\n+int main()\n {\n   // NB: _Atomic_word not necessarily int. \n   typedef int atomic_type;\n@@ -2504,7 +2531,7 @@ EOF\n [#]line __oline__ \"configure\"\n int main()\n {\n-  typedef bool atomic_type;\n+  typedef long long atomic_type;\n   atomic_type c1;\n   atomic_type c2;\n   const atomic_type c3(0);\n@@ -2517,19 +2544,20 @@ int main()\n }\n EOF\n \n-    AC_MSG_CHECKING([for atomic builtins for bool])\n+    AC_MSG_CHECKING([for atomic builtins for long long])\n     if AC_TRY_EVAL(ac_compile); then\n       if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n-        enable_atomic_builtinsb=no\n+        enable_atomic_builtinsll=no\n       else\n-      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_1, 1,\n-      [Define if builtin atomic operations for bool are supported on this host.])\n-        enable_atomic_builtinsb=yes\n+      AC_DEFINE(_GLIBCXX_ATOMIC_BUILTINS_8, 1,\n+      [Define if builtin atomic operations for long long are supported on this host.])\n+        enable_atomic_builtinsll=yes\n       fi\n     fi\n-    AC_MSG_RESULT($enable_atomic_builtinsb)\n+    AC_MSG_RESULT($enable_atomic_builtinsll)\n     rm -f conftest*\n \n+\n   CXXFLAGS=\"$old_CXXFLAGS\"\n   AC_LANG_RESTORE\n "}, {"sha": "55edd8c20b47d95dec4623b8ac6a601d911cf5ba", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -692,9 +692,17 @@\n /* Define if builtin atomic operations for bool are supported on this host. */\n #undef _GLIBCXX_ATOMIC_BUILTINS_1\n \n+/* Define if builtin atomic operations for short are supported on this host.\n+   */\n+#undef _GLIBCXX_ATOMIC_BUILTINS_2\n+\n /* Define if builtin atomic operations for int are supported on this host. */\n #undef _GLIBCXX_ATOMIC_BUILTINS_4\n \n+/* Define if builtin atomic operations for long long are supported on this\n+   host. */\n+#undef _GLIBCXX_ATOMIC_BUILTINS_8\n+\n /* Define to use concept checking code from the boost libraries. */\n #undef _GLIBCXX_CONCEPT_CHECKS\n \n@@ -804,9 +812,6 @@\n    of TR1 (Chapter 5.1). */\n #undef _GLIBCXX_USE_RANDOM_TR1\n \n-/* Define if standard layout types are supported in C++200x. */\n-#undef _GLIBCXX_USE_STANDARD_LAYOUT\n-\n /* Define if code specialized for wchar_t should be used. */\n #undef _GLIBCXX_USE_WCHAR_T\n "}, {"sha": "477604a095510100d61261650baca73565b8559c", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -866,13 +866,11 @@ GLIBCXX_3.4.11 {\n     # atomic\n     __atomic_flag_for_address;\n     __atomic_flag_wait_explicit;\n-    atomic_flag_clear;\n     atomic_flag_clear_explicit;\n-    atomic_flag_fence;\n-    atomic_flag_test_and_set;\n     atomic_flag_test_and_set_explicit;\n-    atomic_global_fence_compatibility;\n-    \n+    _ZNVSt9__atomic011atomic_flag12test_and_setESt12memory_order;\n+    _ZNVSt9__atomic011atomic_flag5clearESt12memory_order;\n+\n     # mutex\n     _ZSt10adopt_lock;\n     _ZSt10defer_lock;"}, {"sha": "a90c29dae6619bf6410c6f5bb9abd26efee1304c", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 89, "deletions": 103, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -14711,6 +14711,84 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n     cat > conftest.$ac_ext << EOF\n #line 14712 \"configure\"\n int main()\n+{\n+  typedef bool atomic_type;\n+  atomic_type c1;\n+  atomic_type c2;\n+  const atomic_type c3(0);\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n+}\n+EOF\n+\n+    echo \"$as_me:$LINENO: checking for atomic builtins for bool\" >&5\n+echo $ECHO_N \"checking for atomic builtins for bool... $ECHO_C\" >&6\n+    if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; then\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinsb=no\n+      else\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define _GLIBCXX_ATOMIC_BUILTINS_1 1\n+_ACEOF\n+\n+        enable_atomic_builtinsb=yes\n+      fi\n+    fi\n+    echo \"$as_me:$LINENO: result: $enable_atomic_builtinsb\" >&5\n+echo \"${ECHO_T}$enable_atomic_builtinsb\" >&6\n+    rm -f conftest*\n+\n+    cat > conftest.$ac_ext << EOF\n+#line 14751 \"configure\"\n+int main()\n+{\n+  typedef short atomic_type;\n+  atomic_type c1;\n+  atomic_type c2;\n+  const atomic_type c3(0);\n+  __sync_fetch_and_add(&c1, c2);\n+  __sync_val_compare_and_swap(&c1, c3, c2);\n+  __sync_lock_test_and_set(&c1, c3);\n+  __sync_lock_release(&c1);\n+  __sync_synchronize();\n+  return 0;\n+}\n+EOF\n+\n+    echo \"$as_me:$LINENO: checking for atomic builtins for short\" >&5\n+echo $ECHO_N \"checking for atomic builtins for short... $ECHO_C\" >&6\n+    if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; then\n+      if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n+        enable_atomic_builtinss=no\n+      else\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define _GLIBCXX_ATOMIC_BUILTINS_2 1\n+_ACEOF\n+\n+        enable_atomic_builtinss=yes\n+      fi\n+    fi\n+    echo \"$as_me:$LINENO: result: $enable_atomic_builtinss\" >&5\n+echo \"${ECHO_T}$enable_atomic_builtinss\" >&6\n+    rm -f conftest*\n+\n+    cat > conftest.$ac_ext << EOF\n+#line 14790 \"configure\"\n+int main()\n {\n   // NB: _Atomic_word not necessarily int.\n   typedef int atomic_type;\n@@ -14749,10 +14827,10 @@ echo \"${ECHO_T}$enable_atomic_builtinsi\" >&6\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 14752 \"configure\"\n+#line 14830 \"configure\"\n int main()\n {\n-  typedef bool atomic_type;\n+  typedef long long atomic_type;\n   atomic_type c1;\n   atomic_type c2;\n   const atomic_type c3(0);\n@@ -14765,28 +14843,29 @@ int main()\n }\n EOF\n \n-    echo \"$as_me:$LINENO: checking for atomic builtins for bool\" >&5\n-echo $ECHO_N \"checking for atomic builtins for bool... $ECHO_C\" >&6\n+    echo \"$as_me:$LINENO: checking for atomic builtins for long long\" >&5\n+echo $ECHO_N \"checking for atomic builtins for long long... $ECHO_C\" >&6\n     if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); }; then\n       if grep __sync_ conftest.s >/dev/null 2>&1 ; then\n-        enable_atomic_builtinsb=no\n+        enable_atomic_builtinsll=no\n       else\n \n cat >>confdefs.h <<\\_ACEOF\n-#define _GLIBCXX_ATOMIC_BUILTINS_1 1\n+#define _GLIBCXX_ATOMIC_BUILTINS_8 1\n _ACEOF\n \n-        enable_atomic_builtinsb=yes\n+        enable_atomic_builtinsll=yes\n       fi\n     fi\n-    echo \"$as_me:$LINENO: result: $enable_atomic_builtinsb\" >&5\n-echo \"${ECHO_T}$enable_atomic_builtinsb\" >&6\n+    echo \"$as_me:$LINENO: result: $enable_atomic_builtinsll\" >&5\n+echo \"${ECHO_T}$enable_atomic_builtinsll\" >&6\n     rm -f conftest*\n \n+\n   CXXFLAGS=\"$old_CXXFLAGS\"\n   ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n@@ -14939,100 +15018,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n \n \n \n-\n-\n-  echo \"$as_me:$LINENO: checking for ISO C++200x standard layout type support\" >&5\n-echo $ECHO_N \"checking for ISO C++200x standard layout type support... $ECHO_C\" >&6\n-  if test \"${ac_standard_layout+set}\" = set; then\n-  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n-else\n-\n-\n-\n-  ac_ext=cc\n-ac_cpp='$CXXCPP $CPPFLAGS'\n-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n-\n-  ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n-  ac_save_CXXFLAGS=\"$CXXFLAGS\"\n-  CXXFLAGS='-std=gnu++0x'\n-\n-  cat >conftest.$ac_ext <<_ACEOF\n-/* confdefs.h.  */\n-_ACEOF\n-cat confdefs.h >>conftest.$ac_ext\n-cat >>conftest.$ac_ext <<_ACEOF\n-/* end confdefs.h.  */\n-struct b\n-                  {\n-  \t\t    bool t;\n-\n-\t\t    // Need standard layout relaxation from POD\n-\t\t    private:\n-  \t\t    b& operator=(const b&);\n-  \t\t    b(const b&);\n-\t\t    };\n-int\n-main ()\n-{\n-b tst1 = { false };\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-rm -f conftest.$ac_objext\n-if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n-  (eval $ac_compile) 2>conftest.er1\n-  ac_status=$?\n-  grep -v '^ *+' conftest.er1 >conftest.err\n-  rm -f conftest.er1\n-  cat conftest.err >&5\n-  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n-  (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_cxx_werror_flag\"\n-\t\t\t || test ! -s conftest.err'\n-  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n-  (eval $ac_try) 2>&5\n-  ac_status=$?\n-  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n-  (exit $ac_status); }; } &&\n-\t { ac_try='test -s conftest.$ac_objext'\n-  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n-  (eval $ac_try) 2>&5\n-  ac_status=$?\n-  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n-  (exit $ac_status); }; }; then\n-  ac_standard_layout=yes\n-else\n-  echo \"$as_me: failed program was:\" >&5\n-sed 's/^/| /' conftest.$ac_ext >&5\n-\n-ac_standard_layout=no\n-fi\n-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n-\n-  CXXFLAGS=\"$ac_save_CXXFLAGS\"\n-  ac_ext=c\n-ac_cpp='$CPP $CPPFLAGS'\n-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n-ac_compiler_gnu=$ac_cv_c_compiler_gnu\n-\n-\n-fi\n-\n-  echo \"$as_me:$LINENO: result: $ac_standard_layout\" >&5\n-echo \"${ECHO_T}$ac_standard_layout\" >&6\n-  if test x\"$ac_standard_layout\" = x\"yes\"; then\n-\n-cat >>confdefs.h <<\\_ACEOF\n-#define _GLIBCXX_USE_STANDARD_LAYOUT 1\n-_ACEOF\n-\n-  fi\n-\n+GLIBCXX_CHECK_STANDARD_LAYOUT\n \n # Enable all the variable C++ runtime options that don't require linking.\n "}, {"sha": "5205e704d92e10a86ab0bf07f2258a31a4eefc24", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -78,6 +78,10 @@ bits_builddir = ./bits\n bits_headers = \\\n         ${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/allocator.h \\\n+\t${bits_srcdir}/atomicfwd_c.h \\\n+\t${bits_srcdir}/atomicfwd_cxx.h \\\n+\t${bits_srcdir}/atomic_0.h \\\n+\t${bits_srcdir}/atomic_2.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "c36ce6698f3447bd62f076007ca71a8fa2c6ae81", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -344,6 +344,10 @@ bits_builddir = ./bits\n bits_headers = \\\n         ${bits_srcdir}/algorithmfwd.h \\\n \t${bits_srcdir}/allocator.h \\\n+\t${bits_srcdir}/atomicfwd_c.h \\\n+\t${bits_srcdir}/atomicfwd_cxx.h \\\n+\t${bits_srcdir}/atomic_0.h \\\n+\t${bits_srcdir}/atomic_2.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\"}, {"sha": "cd00b4a76d17cb90421ac6c9204e0494174330c8", "filename": "libstdc++-v3/include/bits/atomic_0.h", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_0.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,471 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2008\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file bits/atomic_0.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _GLIBCXX_ATOMIC_0_H\n+#define _GLIBCXX_ATOMIC_0_H 1\n+\n+#pragma GCC system_header\n+\n+// _GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+  // 0 == __atomic0 == Never lock-free\n+namespace __atomic0\n+{\n+  struct atomic_flag;\n+\n+  // Implementation specific defines.\n+#define _ATOMIC_LOAD_(__a, __x)\t\t\t\t\t\t   \\\n+  ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \\\n+    volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);     \\\n+    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n+    __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t   \\\n+    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n+    __r; })\n+\n+#define _ATOMIC_STORE_(__a, __m, __x)\t\t\t\t\t   \\\n+  ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \\\n+    __typeof__(__m) __v = (__m);\t\t\t       \t\t   \\\n+    volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);     \\\n+    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n+    *__p = __v;\t\t\t\t\t\t\t\t   \\\n+    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n+    __v; })\n+\n+#define _ATOMIC_MODIFY_(__a, __o, __m, __x)\t\t\t\t   \\\n+  ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \\\n+    __typeof__(__m) __v = (__m);\t\t\t       \t\t   \\\n+    volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);     \\\n+    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n+    __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t   \\\n+    *__p __o __v;\t\t\t\t\t       \t\t   \\\n+    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n+    __r; })\n+\n+#define _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)\t\t\t\t   \\\n+  ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t   \\\n+    __typeof__(__e) __q = (__e);\t\t\t       \t\t   \\\n+    __typeof__(__m) __v = (__m);\t\t\t       \t\t   \\\n+    bool __r;\t\t\t\t\t\t       \t\t   \\\n+    volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);     \\\n+    __atomic_flag_wait_explicit(__g, __x);\t\t\t\t   \\\n+    __typeof__ _ATOMIC_MEMBER_ __t__ = *__p;\t\t       \t\t   \\\n+    if (__t__ == *__q) { *__p = __v; __r = true; }\t\t\t   \\\n+    else { *__q = __t__; __r = false; }\t\t       \t\t\t   \\\n+    atomic_flag_clear_explicit(__g, __x);\t\t       \t\t   \\\n+    __r; })\n+\n+  /// atomic_flag\n+  struct atomic_flag : private __atomic_flag_base\n+  {\n+    atomic_flag() = default;\n+    ~atomic_flag() = default;\n+    atomic_flag(const atomic_flag&) = delete;\n+    atomic_flag& operator=(const atomic_flag&) = delete;\n+\n+    atomic_flag(bool __i) { _M_i = __i; } // XXX deleted copy ctor != agg\n+\n+    bool\n+    test_and_set(memory_order __m = memory_order_seq_cst) volatile;\n+\n+    void\n+    clear(memory_order __m = memory_order_seq_cst) volatile;\n+  };\n+\n+  /// 29.4.2, address types\n+  struct atomic_address\n+  {\n+  private:\n+    void* _M_i;\n+\n+  public:\n+    atomic_address() = default;\n+    ~atomic_address() = default;\n+    atomic_address(const atomic_address&) = delete;\n+    atomic_address& operator=(const atomic_address&) = delete;\n+\n+    atomic_address(void* __v) { _M_i = __v; }\n+\n+    bool\n+    is_lock_free() const volatile\n+    { return false; }\n+\n+    void\n+    store(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      // XXX\n+      //if (__m != memory_order_acquire && __m != memory_order_acq_rel\n+      // && __m != memory_order_consume)\n+      _ATOMIC_STORE_(this, __v, __m);\n+    }\n+\n+    void*\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    {\n+      // XXX\n+      //if (__m != memory_order_release && __m != memory_order_acq_rel)\n+      return _ATOMIC_LOAD_(this, __m);\n+    }\n+\n+    void*\n+    exchange(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    { return _ATOMIC_MODIFY_(this, =, __v, __m); }\n+\n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    {\n+      bool __ret = false;\n+      if (__m2 != memory_order_release && __m2 != memory_order_acq_rel\n+\t  && __m2 <= __m1)\n+\t__ret = _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+      return __ret;\n+    }\n+\n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    {\n+      bool __ret = false;\n+      if (__m2 != memory_order_release && __m2 != memory_order_acq_rel\n+\t  && __m2 <= __m1)\n+\t__ret = _ATOMIC_CMPEXCHNG_(this, &__v1, __v2, __m1);\n+      return __ret;\n+    }\n+\n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    void*\n+    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      void* volatile* __p = &(_M_i);\n+      volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);\n+      __atomic_flag_wait_explicit(__g, __m);\n+      void* __r = *__p;\n+      *__p = (void*)((char*)(*__p) + __d);\n+      atomic_flag_clear_explicit(__g, __m);\n+      return __r;\n+    }\n+\n+    void*\n+    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      void* volatile* __p = &(_M_i);\n+      volatile __atomic_flag_base* __g = __atomic_flag_for_address(__p);\n+      __atomic_flag_wait_explicit(__g, __m);\n+      void* __r = *__p;\n+      *__p = (void*)((char*)(*__p) - __d);\n+      atomic_flag_clear_explicit(__g, __m);\n+      return __r;\n+    }\n+\n+    operator void*() const volatile\n+    { return load(); }\n+\n+    void*\n+    operator=(void* __v) // XXX volatile\n+    {\n+      store(__v);\n+      return __v;\n+    }\n+\n+    void*\n+    operator+=(ptrdiff_t __d) volatile\n+    { return fetch_add(__d) + __d; }\n+\n+    void*\n+    operator-=(ptrdiff_t __d) volatile\n+    { return fetch_sub(__d) - __d; }\n+  };\n+\n+\n+  // 29.3.1 atomic integral types\n+  // For each of the integral types, define atomic_[integral type] struct\n+  //\n+  // atomic_bool     bool\n+  // atomic_char     char\n+  // atomic_schar    signed char\n+  // atomic_uchar    unsigned char\n+  // atomic_short    short\n+  // atomic_ushort   unsigned short\n+  // atomic_int      int\n+  // atomic_uint     unsigned int\n+  // atomic_long     long\n+  // atomic_ulong    unsigned long\n+  // atomic_llong    long long\n+  // atomic_ullong   unsigned long long\n+  // atomic_char16_t char16_t\n+  // atomic_char32_t char32_t\n+  // atomic_wchar_t  wchar_t\n+\n+  // Base type.\n+  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or 8 bytes,\n+  // since that is what GCC built-in functions for atomic memory access work on.\n+  template<typename _ITp>\n+    struct __atomic_base\n+    {\n+    private:\n+      typedef _ITp \t__integral_type;\n+\n+      __integral_type \t_M_i;\n+\n+    public:\n+      __atomic_base() = default;\n+      ~__atomic_base() = default;\n+      __atomic_base(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) = delete;\n+\n+      // Requires __integral_type convertible to _M_base._M_i.\n+      __atomic_base(__integral_type __i) { _M_i = __i; }\n+\n+      operator __integral_type() const volatile\n+      { return load(); }\n+\n+      __integral_type\n+      operator=(__integral_type __i) // XXX volatile\n+      {\n+\tstore(__i);\n+\treturn __i;\n+      }\n+\n+      __integral_type\n+      operator++(int) volatile\n+      { return fetch_add(1); }\n+\n+      __integral_type\n+      operator--(int) volatile\n+      { return fetch_sub(1); }\n+\n+      __integral_type\n+      operator++() volatile\n+      { return fetch_add(1) + 1; }\n+\n+      __integral_type\n+      operator--() volatile\n+      { return fetch_sub(1) - 1; }\n+\n+      __integral_type\n+      operator+=(__integral_type __i) volatile\n+      { return fetch_add(__i) + __i; }\n+\n+      __integral_type\n+      operator-=(__integral_type __i) volatile\n+      { return fetch_sub(__i) - __i; }\n+\n+      __integral_type\n+      operator&=(__integral_type __i) volatile\n+      { return fetch_and(__i) & __i; }\n+\n+      __integral_type\n+      operator|=(__integral_type __i) volatile\n+      { return fetch_or(__i) | __i; }\n+\n+      __integral_type\n+      operator^=(__integral_type __i) volatile\n+      { return fetch_xor(__i) ^ __i; }\n+\n+      bool\n+      is_lock_free() const volatile\n+      { return false; }\n+\n+      void\n+      store(__integral_type __i,\n+\t    memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\t// XXX\n+\t//if (__m != memory_order_acquire && __m != memory_order_acq_rel\n+\t//  && __m != memory_order_consume)\n+\t_ATOMIC_STORE_(this, __i, __m);\n+      }\n+\n+      __integral_type\n+      load(memory_order __m = memory_order_seq_cst) const volatile\n+      {\n+\t// if (__m != memory_order_release && __m != memory_order_acq_rel)\n+\treturn _ATOMIC_LOAD_(this, __m);\n+      }\n+\n+      __integral_type\n+      exchange(__integral_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, =, __i, __m); }\n+\n+      bool\n+      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+\t\t\t    memory_order __m1, memory_order __m2) volatile\n+      {\n+\tbool __ret = false;\n+\tif (__m2 != memory_order_release && __m2 != memory_order_acq_rel\n+\t    && __m2 <= __m1)\n+\t  __ret = _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n+\treturn __ret;\n+      }\n+\n+      bool\n+      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_weak(__i1, __i2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+\t\t\t      memory_order __m1, memory_order __m2) volatile\n+      {\n+\tbool __ret = false;\n+\tif (__m2 != memory_order_release && __m2 != memory_order_acq_rel\n+\t    && __m2 <= __m1)\n+\t  __ret = _ATOMIC_CMPEXCHNG_(this, &__i1, __i2, __m1);\n+\treturn __ret;\n+      }\n+\n+      bool\n+      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+\t\t\t      memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_strong(__i1, __i2, __m,\n+\t\t\t\t       __calculate_memory_order(__m));\n+      }\n+\n+      __integral_type\n+      fetch_add(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, +=, __i, __m); }\n+\n+      __integral_type\n+      fetch_sub(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, -=, __i, __m); }\n+\n+      __integral_type\n+      fetch_and(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, &=, __i, __m); }\n+\n+      __integral_type\n+      fetch_or(__integral_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, |=, __i, __m); }\n+\n+      __integral_type\n+      fetch_xor(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return _ATOMIC_MODIFY_(this, ^=, __i, __m); }\n+    };\n+\n+\n+  /// atomic_bool\n+  // NB: No operators or fetch-operations for this type.\n+  struct atomic_bool\n+  {\n+  private:\n+    __atomic_base<bool>\t_M_base;\n+\n+  public:\n+    atomic_bool() = default;\n+    ~atomic_bool() = default;\n+    atomic_bool(const atomic_bool&) = delete;\n+    atomic_bool& operator=(const atomic_bool&) = delete;\n+\n+    atomic_bool(bool __i) : _M_base(__i) { }\n+\n+    bool\n+    operator=(bool __i) // XXX volatile\n+    { return _M_base.operator=(__i); }\n+\n+    operator bool() const volatile\n+    { return _M_base.load(); }\n+\n+    bool\n+    is_lock_free() const volatile\n+    { return _M_base.is_lock_free(); }\n+\n+    void\n+    store(bool __i, memory_order __m = memory_order_seq_cst) volatile\n+    { _M_base.store(__i, __m); }\n+\n+    bool\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    { return _M_base.load(__m); }\n+\n+    bool\n+    exchange(bool __i, memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.exchange(__i, __m); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n+  };\n+\n+#undef _ATOMIC_LOAD_\n+#undef _ATOMIC_STORE_\n+#undef _ATOMIC_MODIFY_\n+#undef _ATOMIC_CMPEXCHNG_\n+} // namespace __atomic0\n+\n+// _GLIBCXX_END_NAMESPACE\n+\n+#endif"}, {"sha": "48eda413cde22e161fb7b4ef3b18a6d4be120805", "filename": "libstdc++-v3/include/bits/atomic_2.h", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_2.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,456 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2008\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file bits/atomic_2.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _GLIBCXX_ATOMIC_2_H\n+#define _GLIBCXX_ATOMIC_2_H 1\n+\n+#pragma GCC system_header\n+\n+#include <cassert> // XXX static_assert vs. constant-expression PR38502\n+\n+// _GLIBCXX_BEGIN_NAMESPACE(std)\n+\n+// 2 == __atomic2 == Always lock-free\n+// Assumed:\n+// _GLIBCXX_ATOMIC_BUILTINS_1\n+// _GLIBCXX_ATOMIC_BUILTINS_2\n+// _GLIBCXX_ATOMIC_BUILTINS_4\n+// _GLIBCXX_ATOMIC_BUILTINS_8\n+namespace __atomic2\n+{\n+  /// atomic_flag\n+  struct atomic_flag : private __atomic_flag_base\n+  {\n+    atomic_flag() = default;\n+    ~atomic_flag() = default;\n+    atomic_flag(const atomic_flag&) = delete;\n+    atomic_flag& operator=(const atomic_flag&) = delete;\n+\n+    atomic_flag(bool __i) { _M_i = __i; } // XXX deleted copy ctor != agg\n+\n+    bool\n+    test_and_set(memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      // Redundant synchronize if built-in for lock is a full barrier.\n+      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n+\t__sync_synchronize();\n+      return __sync_lock_test_and_set(&_M_i, 1);\n+    }\n+\n+    void\n+    clear(memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      __sync_lock_release(&_M_i);\n+      if (__m != memory_order_acquire && __m != memory_order_acq_rel)\n+\t__sync_synchronize();\n+    }\n+  };\n+\n+\n+  /// 29.4.2, address types\n+  struct atomic_address\n+  {\n+  private:\n+    void* _M_i;\n+\n+  public:\n+    atomic_address() = default;\n+    ~atomic_address() = default;\n+    atomic_address(const atomic_address&) = delete;\n+    atomic_address& operator=(const atomic_address&) = delete;\n+\n+    atomic_address(void* __v) { _M_i = __v; }\n+\n+    bool\n+    is_lock_free() const volatile\n+    { return true; }\n+\n+    void\n+    store(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      assert(__m == memory_order_acquire);\n+      assert(__m == memory_order_acq_rel);\n+      assert(__m == memory_order_consume);\n+\n+      if (__m == memory_order_relaxed)\n+\t_M_i = __v;\n+      else\n+\t{\n+\t  // write_mem_barrier();\n+\t  _M_i = __v;\n+\t  if (__m = memory_order_seq_cst)\n+\t    __sync_synchronize();\n+\t}\n+    }\n+\n+    void*\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    {\n+      assert(__m == memory_order_release);\n+      assert(__m == memory_order_acq_rel);\n+\n+      __sync_synchronize();\n+      void* __ret = _M_i;\n+      __sync_synchronize();\n+      return __ret;\n+    }\n+\n+    void*\n+    exchange(void* __v, memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      // XXX built-in assumes memory_order_acquire.\n+      return __sync_lock_test_and_set(&_M_i, __v);\n+    }\n+\n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    { return compare_exchange_strong(__v1, __v2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_weak(__v1, __v2, __m,\n+\t\t\t\t   __calculate_memory_order(__m));\n+    }\n+\n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    {\n+      assert(__m2 == memory_order_release);\n+      assert(__m2 == memory_order_acq_rel);\n+      assert(__m2 <= __m1);\n+\n+      void* __v1o = __v1;\n+      void* __v1n = __sync_val_compare_and_swap(&_M_i, __v1o, __v2);\n+\n+      // Assume extra stores (of same value) allowed in true case.\n+      __v1 = __v1n;\n+      return __v1o == __v1n;\n+    }\n+\n+    bool\n+    compare_exchange_strong(void*& __v1, void* __v2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    {\n+      return compare_exchange_strong(__v1, __v2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+    }\n+\n+    void*\n+    fetch_add(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    { return __sync_fetch_and_add(&_M_i, __d); }\n+\n+    void*\n+    fetch_sub(ptrdiff_t __d, memory_order __m = memory_order_seq_cst) volatile\n+    { return __sync_fetch_and_sub(&_M_i, __d); }\n+\n+    operator void*() const volatile\n+    { return load(); }\n+\n+    void*\n+    operator=(void* __v) // XXX volatile\n+    {\n+      store(__v);\n+      return __v;\n+    }\n+\n+    void*\n+    operator+=(ptrdiff_t __d) volatile\n+    { return __sync_add_and_fetch(&_M_i, __d); }\n+\n+    void*\n+    operator-=(ptrdiff_t __d) volatile\n+    { return __sync_sub_and_fetch(&_M_i, __d); }\n+  };\n+\n+  // 29.3.1 atomic integral types\n+  // For each of the integral types, define atomic_[integral type] struct\n+  //\n+  // atomic_bool     bool\n+  // atomic_char     char\n+  // atomic_schar    signed char\n+  // atomic_uchar    unsigned char\n+  // atomic_short    short\n+  // atomic_ushort   unsigned short\n+  // atomic_int      int\n+  // atomic_uint     unsigned int\n+  // atomic_long     long\n+  // atomic_ulong    unsigned long\n+  // atomic_llong    long long\n+  // atomic_ullong   unsigned long long\n+  // atomic_char16_t char16_t\n+  // atomic_char32_t char32_t\n+  // atomic_wchar_t  wchar_t\n+\n+  // Base type.\n+  // NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or 8 bytes,\n+  // since that is what GCC built-in functions for atomic memory access work on.\n+  template<typename _ITp>\n+    struct __atomic_base\n+    {\n+    private:\n+      typedef _ITp \t__integral_type;\n+\n+      __integral_type \t_M_i;\n+\n+    public:\n+      __atomic_base() = default;\n+      ~__atomic_base() = default;\n+      __atomic_base(const __atomic_base&) = delete;\n+      __atomic_base& operator=(const __atomic_base&) = delete;\n+\n+      // Requires __integral_type convertible to _M_base._M_i.\n+      __atomic_base(__integral_type __i) { _M_i = __i; }\n+\n+      operator __integral_type() const volatile\n+      { return load(); }\n+\n+      __integral_type\n+      operator=(__integral_type __i) // XXX volatile\n+      {\n+\tstore(__i);\n+\treturn __i;\n+      }\n+\n+      __integral_type\n+      operator++(int) volatile\n+      { return fetch_add(1); }\n+\n+      __integral_type\n+      operator--(int) volatile\n+      { return fetch_sub(1); }\n+\n+      __integral_type\n+      operator++() volatile\n+      { return __sync_add_and_fetch(&_M_i, 1); }\n+\n+      __integral_type\n+      operator--() volatile\n+      { return __sync_sub_and_fetch(&_M_i, 1); }\n+\n+      __integral_type\n+      operator+=(__integral_type __i) volatile\n+      { return __sync_add_and_fetch(&_M_i, __i); }\n+\n+      __integral_type\n+      operator-=(__integral_type __i) volatile\n+      { return __sync_sub_and_fetch(&_M_i, __i); }\n+\n+      __integral_type\n+      operator&=(__integral_type __i) volatile\n+      { return __sync_and_and_fetch(&_M_i, __i); }\n+\n+      __integral_type\n+      operator|=(__integral_type __i) volatile\n+      { return __sync_or_and_fetch(&_M_i, __i); }\n+\n+      __integral_type\n+      operator^=(__integral_type __i) volatile\n+      { return __sync_xor_and_fetch(&_M_i, __i); }\n+\n+      bool\n+      is_lock_free() const volatile\n+      { return true; }\n+\n+      void\n+      store(__integral_type __i,\n+\t    memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\tassert(__m == memory_order_acquire);\n+\tassert(__m == memory_order_acq_rel);\n+\tassert(__m == memory_order_consume);\n+\n+\tif (__m == memory_order_relaxed)\n+\t  _M_i = __i;\n+\telse\n+\t  {\n+\t    // write_mem_barrier();\n+\t    _M_i = __i;\n+\t    if (__m = memory_order_seq_cst)\n+\t      __sync_synchronize();\n+\t  }\n+      }\n+\n+      __integral_type\n+      load(memory_order __m = memory_order_seq_cst) const volatile\n+      {\n+\tassert(__m == memory_order_release);\n+\tassert(__m == memory_order_acq_rel);\n+\n+\t__sync_synchronize();\n+\t__integral_type __ret = _M_i;\n+\t__sync_synchronize();\n+\treturn __ret;\n+      }\n+\n+      __integral_type\n+      exchange(__integral_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\t// XXX built-in assumes memory_order_acquire.\n+\treturn __sync_lock_test_and_set(&_M_i, __i);\n+      }\n+\n+      bool\n+      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+\t\t\t    memory_order __m1, memory_order __m2) volatile\n+      { return compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+\n+      bool\n+      compare_exchange_weak(__integral_type& __i1, __integral_type __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_weak(__i1, __i2, __m,\n+\t\t\t\t     __calculate_memory_order(__m));\n+      }\n+\n+      bool\n+      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+\t\t\t      memory_order __m1, memory_order __m2) volatile\n+      {\n+\tassert(__m2 == memory_order_release);\n+\tassert(__m2 == memory_order_acq_rel);\n+\tassert(__m2 <= __m1);\n+\n+\t__integral_type __i1o = __i1;\n+\t__integral_type __i1n = __sync_val_compare_and_swap(&_M_i, __i1o, __i2);\n+\n+\t// Assume extra stores (of same value) allowed in true case.\n+\t__i1 = __i1n;\n+\treturn __i1o == __i1n;\n+      }\n+\n+      bool\n+      compare_exchange_strong(__integral_type& __i1, __integral_type __i2,\n+\t\t\t      memory_order __m = memory_order_seq_cst) volatile\n+      {\n+\treturn compare_exchange_strong(__i1, __i2, __m,\n+\t\t\t\t       __calculate_memory_order(__m));\n+      }\n+\n+      __integral_type\n+      fetch_add(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_add(&_M_i, __i); }\n+\n+      __integral_type\n+      fetch_sub(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_sub(&_M_i, __i); }\n+\n+      __integral_type\n+      fetch_and(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_and(&_M_i, __i); }\n+\n+      __integral_type\n+      fetch_or(__integral_type __i,\n+\t       memory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_or(&_M_i, __i); }\n+\n+      __integral_type\n+      fetch_xor(__integral_type __i,\n+\t\tmemory_order __m = memory_order_seq_cst) volatile\n+      { return __sync_fetch_and_xor(&_M_i, __i); }\n+    };\n+\n+\n+  /// atomic_bool\n+  // NB: No operators or fetch-operations for this type.\n+  struct atomic_bool\n+  {\n+  private:\n+    __atomic_base<bool>\t_M_base;\n+\n+  public:\n+    atomic_bool() = default;\n+    ~atomic_bool() = default;\n+    atomic_bool(const atomic_bool&) = delete;\n+    atomic_bool& operator=(const atomic_bool&) = delete;\n+\n+    atomic_bool(bool __i) : _M_base(__i) { }\n+\n+    bool\n+    operator=(bool __i) // XXX volatile\n+    { return _M_base.operator=(__i); }\n+\n+    operator bool() const volatile\n+    { return _M_base.load(); }\n+\n+    bool\n+    is_lock_free() const volatile\n+    { return _M_base.is_lock_free(); }\n+\n+    void\n+    store(bool __i, memory_order __m = memory_order_seq_cst) volatile\n+    { _M_base.store(__i, __m); }\n+\n+    bool\n+    load(memory_order __m = memory_order_seq_cst) const volatile\n+    { return _M_base.load(__m); }\n+\n+    bool\n+    exchange(bool __i, memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.exchange(__i, __m); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t  memory_order __m2) volatile\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m1, __m2); }\n+\n+    bool\n+    compare_exchange_weak(bool& __i1, bool __i2,\n+\t\t\t  memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.compare_exchange_weak(__i1, __i2, __m); }\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2, memory_order __m1,\n+\t\t\t    memory_order __m2) volatile\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m1, __m2); }\n+\n+\n+    bool\n+    compare_exchange_strong(bool& __i1, bool __i2,\n+\t\t\t    memory_order __m = memory_order_seq_cst) volatile\n+    { return _M_base.compare_exchange_strong(__i1, __i2, __m); }\n+  };\n+} // namespace __atomic2\n+\n+// _GLIBCXX_END_NAMESPACE\n+\n+#endif"}, {"sha": "41f2dfebe9a3d2492be2ad71312a77bf05a0d073", "filename": "libstdc++-v3/include/bits/atomicfwd_c.h", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_c.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,179 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2008\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file bits/atomicfwd_c.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+// \"C\" only bits.\n+\n+#define _ATOMIC_MEMBER_ ((__a)->_M_i)\n+\n+  // POD base classes for atomic intgral types.\n+  struct __atomic_bool_base\n+  {\n+    bool _M_i;\n+  };\n+\n+  struct __atomic_char_base\n+  {\n+    char _M_i;\n+  };\n+\n+  struct __atomic_schar_base\n+  {\n+    signed char _M_i;\n+  };\n+\n+  struct __atomic_uchar_base\n+  {\n+    unsigned char _M_i;\n+  };\n+\n+  struct __atomic_short_base\n+  {\n+    short _M_i;\n+  };\n+\n+  struct __atomic_ushort_base\n+  {\n+    unsigned short _M_i;\n+  };\n+\n+  struct __atomic_int_base\n+  {\n+    int _M_i;\n+  };\n+\n+  struct __atomic_uint_base\n+  {\n+    unsigned int _M_i;\n+  };\n+\n+  struct __atomic_long_base\n+  {\n+    long _M_i;\n+  };\n+\n+  struct __atomic_ulong_base\n+  {\n+    unsigned long _M_i;\n+  };\n+\n+  struct __atomic_llong_base\n+  {\n+    long long _M_i;\n+  };\n+\n+  struct __atomic_ullong_base\n+  {\n+    unsigned long long\t_M_i;\n+  };\n+\n+  struct __atomic_wchar_t_base\n+  {\n+    wchar_t _M_i;\n+  };\n+\n+  typedef struct __atomic_flag_base \t\tatomic_flag;\n+  typedef struct __atomic_address_base \t\tatomic_address;\n+  typedef struct __atomic_bool_base\t\tatomic_bool;\n+  typedef struct __atomic_char_base \t\tatomic_char;\n+  typedef struct __atomic_schar_base \t\tatomic_schar;\n+  typedef struct __atomic_uchar_base \t\tatomic_uchar;\n+  typedef struct __atomic_short_base \t\tatomic_short;\n+  typedef struct __atomic_ushort_base \t\tatomic_ushort;\n+  typedef struct __atomic_int_base \t\tatomic_int;\n+  typedef struct __atomic_uint_base \t\tatomic_uint;\n+  typedef struct __atomic_long_base \t\tatomic_long;\n+  typedef struct __atomic_ulong_base \t\tatomic_ulong;\n+  typedef struct __atomic_llong_base \t\tatomic_llong;\n+  typedef struct __atomic_ullong_base \t\tatomic_ullong;\n+  typedef struct __atomic_wchar_t_base \t\tatomic_wchar_t;\n+  typedef struct __atomic_short_base \t\tatomic_char16_t;\n+  typedef struct __atomic_int_base \t\tatomic_char32_t;\n+\n+#define atomic_is_lock_free(__a)\t\t\t\t\t\\\n+  false\n+\n+#define atomic_load_explicit(__a, __x)\t\t\t\t\t\\\n+  _ATOMIC_LOAD_(__a, __x)\n+\n+#define atomic_load(__a)\t\t\t\t\t\t\\\n+  atomic_load_explicit(__a, memory_order_seq_cst)\n+\n+#define atomic_store_explicit(__a, __m, __x)\t\t\t\t\\\n+  _ATOMIC_STORE_(__a, __m, __x)\n+\n+#define atomic_store(__a, __m)\t\t\t\t\t\t\\\n+  atomic_store_explicit(__a, __m, memory_order_seq_cst)\n+\n+#define atomic_exchange_explicit(__a, __m, __x)\t\t\t\t\\\n+  _ATOMIC_MODIFY_(__a, =, __m, __x)\n+\n+#define atomic_exchange(__a, __m)\t\t\t\t\t\\\n+  atomic_exchange_explicit(__a, __m, memory_order_seq_cst)\n+\n+#define atomic_compare_exchange_explicit(__a, __e, __m, __x, __y)\t\\\n+  _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)\n+\n+#define atomic_compare_exchange(__a, __e, __m)\t\t\t\t\\\n+  _ATOMIC_CMPEXCHNG_(__a, __e, __m, memory_order_seq_cst)\n+\n+#define atomic_fetch_add_explicit(__a, __m, __x)\t\t\t\\\n+  _ATOMIC_MODIFY_(__a, +=, __m, __x)\n+\n+#define atomic_fetch_add(__a, __m)\t\t\t\t\t\\\n+  atomic_fetch_add_explicit(__a, __m, memory_order_seq_cst)\n+\n+#define atomic_fetch_sub_explicit(__a, __m, __x)\t\t\t\\\n+  _ATOMIC_MODIFY_(__a, -=, __m, __x)\n+\n+#define atomic_fetch_sub(__a, __m)\t\t\t\t\t\\\n+  atomic_fetch_sub_explicit(__a, __m, memory_order_seq_cst)\n+\n+#define atomic_fetch_and_explicit(__a, __m, __x)\t\t\t\\\n+  _ATOMIC_MODIFY_(__a, &=, __m, __x)\n+\n+#define atomic_fetch_and(__a, __m)\t\t\t\t\t\\\n+  atomic_fetch_and_explicit(__a, __m, memory_order_seq_cst)\n+\n+#define atomic_fetch_or_explicit(__a, __m, __x) \t\t\t\\\n+  _ATOMIC_MODIFY_(__a, |=, __m, __x)\n+\n+#define atomic_fetch_or(__a, __m)\t\t\t\t\t\\\n+  atomic_fetch_or_explicit(__a, __m, memory_order_seq_cst)\n+\n+#define atomic_fetch_xor_explicit(__a, __m, __x)\t\t\t\\\n+  _ATOMIC_MODIFY_(__a, ^=, __m, __x)\n+\n+#define atomic_fetch_xor(__a, __m)\t\t\t\t\t\\\n+  atomic_fetch_xor_explicit(__a, __m, memory_order_seq_cst)"}, {"sha": "06429316adbe633f464f251160fb8aa0c14e1762", "filename": "libstdc++-v3/include/bits/atomicfwd_cxx.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicfwd_cxx.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,114 @@\n+// -*- C++ -*- header.\n+\n+// Copyright (C) 2008\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+// Boston, MA 02110-1301, USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file bits/atomicfwd_cxx.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+// \"C++\" only bits.\n+\n+#define _ATOMIC_MEMBER_ _M_i\n+\n+_GLIBCXX_END_EXTERN_C\n+\n+  namespace __atomic0\n+  {\n+    template<typename _IntTp>\n+      struct __atomic_base;\n+\n+    struct atomic_flag;\n+    struct atomic_address;\n+    struct atomic_bool;\n+  } \n+\n+  namespace __atomic2\n+  {\n+    template<typename _IntTp>\n+      struct __atomic_base;\n+\n+    struct atomic_flag;\n+    struct atomic_address;\n+    struct atomic_bool;\n+  } \n+\n+  namespace __atomic1\n+  {\n+    using __atomic2::atomic_flag;\n+    using __atomic2::atomic_bool;\n+    using __atomic0::atomic_address;\n+    using __atomic0::__atomic_base;\n+  } \n+\n+  /// atomic_char\n+  typedef __atomic_base<char>  \t       \t\tatomic_char;\n+\n+  /// atomic_schar\n+  typedef __atomic_base<signed char>         \tatomic_schar;\n+\n+  /// atomic_uchar\n+  typedef __atomic_base<unsigned char>  \tatomic_uchar;\n+\n+  /// atomic_short\n+  typedef __atomic_base<short>  \t\tatomic_short;\n+\n+  /// atomic_ushort\n+  typedef __atomic_base<unsigned short>  \tatomic_ushort;\n+\n+  /// atomic_int\n+  typedef __atomic_base<int>  \t       \t\tatomic_int;\n+\n+  /// atomic_uint\n+  typedef __atomic_base<unsigned int>        \tatomic_uint;\n+\n+  /// atomic_long\n+  typedef __atomic_base<long>  \t       \t\tatomic_long;\n+\n+  /// atomic_ulong\n+  typedef __atomic_base<unsigned long>  \tatomic_ulong;\n+\n+  /// atomic_llong\n+  typedef __atomic_base<long long>  \t\tatomic_llong;\n+\n+  /// atomic_ullong\n+  typedef __atomic_base<unsigned long long> \tatomic_ullong;\n+\n+  /// atomic_wchar_t\n+  typedef __atomic_base<wchar_t>  \t\tatomic_wchar_t;\n+\n+  /// atomic_char16_t\n+  typedef __atomic_base<char16_t>  \t\tatomic_char16_t;\n+\n+  /// atomic_char32_t\n+  typedef __atomic_base<char32_t>  \t\tatomic_char32_t;\n+\n+  template<typename _Tp>\n+    struct atomic;\n+_GLIBCXX_BEGIN_EXTERN_C"}, {"sha": "be66600f0859f8855fc1e53e369d980e9703f172", "filename": "libstdc++-v3/include/c_compatibility/stdatomic.h", "status": "modified", "additions": 44, "deletions": 217, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_compatibility%2Fstdatomic.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -45,201 +45,46 @@ _GLIBCXX_BEGIN_EXTERN_C\n   typedef enum memory_order \n     {\n       memory_order_relaxed, \n+      memory_order_consume, \n       memory_order_acquire, \n       memory_order_release,\n       memory_order_acq_rel, \n       memory_order_seq_cst\n     } memory_order;\n \n-\n   // Base for atomic_flag.\n-  struct __atomic_flag_base\n-  {\n-    bool _M_b;\n-  };\n-\n-  // Base for atomic_address\n-  struct __atomic_address_base\n-  {\n-    void* _M_i;\n-  };\n-\n-  // POD base classes for atomic intgral types.\n-  struct __atomic_bool_base\n+  typedef struct __atomic_flag_base\n   {\n     bool _M_i;\n-  };\n-\n-  struct __atomic_char_base\n-  {\n-    char _M_i;\n-  };\n-\n-  struct __atomic_schar_base\n-  {\n-    signed char _M_i;\n-  };\n-\n-  struct __atomic_uchar_base\n-  {\n-    unsigned char _M_i;\n-  };\n-\n-  struct __atomic_short_base\n-  {\n-    short _M_i;\n-  };\n-\n-  struct __atomic_ushort_base\n-  {\n-    unsigned short _M_i;\n-  };\n-\n-  struct __atomic_int_base\n-  {\n-    int _M_i;\n-  };\n-\n-  struct __atomic_uint_base\n-  {\n-    unsigned int _M_i;\n-  };\n+  } __atomic_flag_base;\n \n-  struct __atomic_long_base\n-  {\n-    long _M_i;\n-  };\n+#define ATOMIC_FLAG_INIT { false } \n \n-  struct __atomic_ulong_base\n-  {\n-    unsigned long _M_i;\n-  };\n-\n-  struct __atomic_llong_base\n-  {\n-    long long _M_i;\n-  };\n-\n-  struct __atomic_ullong_base\n-  {\n-    unsigned long long _M_i;\n-  };\n+  /// 29.2 Lock-free Property\n+#if defined(_GLIBCXX_ATOMIC_BUILTINS_1) && defined(_GLIBCXX_ATOMIC_BUILTINS_2) \\\n+  && defined(_GLIBCXX_ATOMIC_BUILTINS_4) && defined(_GLIBCXX_ATOMIC_BUILTINS_8)\n+# define _GLIBCXX_ATOMIC_PROPERTY 2\n+# define _GLIBCXX_ATOMIC_NAMESPACE __atomic2\n+#elif defined(_GLIBCXX_ATOMIC_BUILTINS_1)\n+# define _GLIBCXX_ATOMIC_PROPERTY 1\n+# define _GLIBCXX_ATOMIC_NAMESPACE __atomic1\n+#else\n+# define _GLIBCXX_ATOMIC_PROPERTY 0\n+# define _GLIBCXX_ATOMIC_NAMESPACE __atomic0\n+#endif\n \n-  struct __atomic_wchar_t_base\n-  {\n-    wchar_t _M_i;\n-  };\n+#define ATOMIC_INTEGRAL_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n+#define ATOMIC_ADDRESS_LOCK_FREE _GLIBCXX_ATOMIC_PROPERTY\n \n   // Switch atomic integral base types based on C or C++.  In\n   // addition, for \"C\" only provide type-generic macros for atomic\n   // operations. (As C++ accomplishes the same thing with sets of\n   // overloaded functions.\n #ifdef __cplusplus\n-\n-#define ATOMIC_FLAG_INIT { { false } }\n-#define _ATOMIC_MEMBER_ ((__a)->_M_base._M_i)\n-\n-extern \"C++\"\n-{\n-  struct atomic_flag;\n-  struct atomic_address;\n-  struct atomic_bool;\n-  struct atomic_char;\n-  struct atomic_schar;\n-  struct atomic_uchar;\n-  struct atomic_short;\n-  struct atomic_ushort;\n-  struct atomic_int;\n-  struct atomic_uint;\n-  struct atomic_long;\n-  struct atomic_ulong;\n-  struct atomic_llong;\n-  struct atomic_ullong;\n-  struct atomic_wchar_t;\n-  template<typename _Tp>\n-    struct atomic;\n-}\n+  inline namespace _GLIBCXX_ATOMIC_NAMESPACE { }\n+# include <bits/atomicfwd_cxx.h>\n #else\n-\n-#define ATOMIC_FLAG_INIT { false }\n-#define _ATOMIC_MEMBER_ ((__a)->_M_i)\n-\n-  typedef struct __atomic_flag_base \tatomic_flag;\n-  typedef struct __atomic_address_base \tatomic_address;\n-  typedef struct __atomic_bool_base\tatomic_bool;\n-  typedef struct __atomic_char_base \tatomic_char;\n-  typedef struct __atomic_schar_base \tatomic_schar;\n-  typedef struct __atomic_uchar_base \tatomic_uchar;\n-  typedef struct __atomic_short_base \tatomic_short;\n-  typedef struct __atomic_ushort_base \tatomic_ushort;\n-  typedef struct __atomic_int_base \tatomic_int;\n-  typedef struct __atomic_uint_base \tatomic_uint;\n-  typedef struct __atomic_long_base \tatomic_long;\n-  typedef struct __atomic_ulong_base \tatomic_ulong;\n-  typedef struct __atomic_llong_base \tatomic_llong;\n-  typedef struct __atomic_ullong_base \tatomic_ullong;\n-  typedef struct __atomic_wchar_t_base \tatomic_wchar_t;\n-\n-#define atomic_is_lock_free(__a)\t\t\t\t\\\n-  false\n-\n-#define atomic_load(__a)\t\t\t\t\t\\\n-  _ATOMIC_LOAD_(__a, memory_order_seq_cst)\n-\n-#define atomic_load_explicit(__a, __x)\t\t\t\t\\\n-  _ATOMIC_LOAD_(__a, __x)\n-\n-#define atomic_store(__a, __m)\t\t\t\t\t\\\n-  _ATOMIC_STORE_(__a, __m, memory_order_seq_cst)\n-\n-#define atomic_store_explicit(__a, __m, __x)\t\t\t\\\n-  _ATOMIC_STORE_(__a, __m, __x)\n-\n-#define atomic_swap(__a, __m)\t\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, =, __m, memory_order_seq_cst)\n-\n-#define atomic_swap_explicit(__a, __m, __x)\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, =, __m, __x)\n-\n-#define atomic_compare_swap(__a, __e, __m)\t\t\t\\\n-  _ATOMIC_CMPSWP_(__a, __e, __m, memory_order_seq_cst)\n-\n-#define atomic_compare_swap_explicit(__a, __e, __m, __x, __y)\t\\\n-  _ATOMIC_CMPSWP_(__a, __e, __m, __x)\n-\n-#define atomic_fence(__a, __x)\t\t\t\t\t\\\n-  ({ _ATOMIC_FENCE_(__a, __x); })\n-\n-#define atomic_fetch_add_explicit(__a, __m, __x)\t\t\\\n-  _ATOMIC_MODIFY_(__a, +=, __m, __x)\n-\n-#define atomic_fetch_add(__a, __m)\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, +=, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_sub_explicit(__a, __m, __x)\t\t\\\n-  _ATOMIC_MODIFY_(__a, -=, __m, __x)\n-\n-#define atomic_fetch_sub(__a, __m)\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, -=, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_and_explicit(__a, __m, __x)\t\t\\\n-  _ATOMIC_MODIFY_(__a, &=, __m, __x)\n-\n-#define atomic_fetch_and(__a, __m)\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, &=, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_or_explicit(__a, __m, __x) \t\t\\\n-  _ATOMIC_MODIFY_(__a, |=, __m, __x)\n-\n-#define atomic_fetch_or(__a, __m)\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, |=, __m, memory_order_seq_cst)\n-\n-#define atomic_fetch_xor_explicit(__a, __m, __x)\t\t\\\n-  _ATOMIC_MODIFY_(__a, ^=, __m, __x)\n-\n-#define atomic_fetch_xor(__a, __m)\t\t\t\t\\\n-  _ATOMIC_MODIFY_(__a, ^=, __m, memory_order_seq_cst)\n-\n+# include <bits/atomicfwd_c.h>\n #endif\n   \n   // Typedefs for other atomic integral types.\n@@ -272,42 +117,31 @@ extern \"C++\"\n \n   typedef atomic_long \t\tatomic_ptrdiff_t;\n \n-  typedef atomic_int_least16_t\tatomic_char16_t;\n-  typedef atomic_int_least32_t\tatomic_char32_t;\n+  // Accessor functions for base atomic_flag type.\n+  bool \n+  atomic_flag_test_and_set_explicit(volatile __atomic_flag_base*, memory_order);\n \n-  // Accessor functions for atomic_flag.\n-  extern bool \n-  atomic_flag_test_and_set(volatile atomic_flag*);\n+  inline bool \n+  atomic_flag_test_and_set(volatile __atomic_flag_base* __a)\n+  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }\n   \n-  extern bool \n-  atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order);\n-  \n-  extern void \n-  atomic_flag_clear(volatile atomic_flag*);\n-  \n-  extern void \n-  atomic_flag_clear_explicit(volatile atomic_flag*, memory_order);\n-  \n-  extern void \n-  atomic_flag_fence(const volatile atomic_flag*, memory_order);\n-  \n-  extern void \n-  __atomic_flag_wait_explicit(volatile atomic_flag*, memory_order);\n+  void \n+  atomic_flag_clear_explicit(volatile __atomic_flag_base*, memory_order);\n+\n+  inline void \n+  atomic_flag_clear(volatile __atomic_flag_base* __a)\n+  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }\n+\n+  void \n+  __atomic_flag_wait_explicit(volatile __atomic_flag_base*, memory_order);\n   \n-  extern volatile atomic_flag* \n+  volatile __atomic_flag_base* \n   __atomic_flag_for_address(const volatile void* __z) __attribute__((const));\n-   \n-  // External object.\n-  extern const atomic_flag atomic_global_fence_compatibility;\n-  \n-  /// 29.2 Lock-free Property\n-#define ATOMIC_INTEGRAL_LOCK_FREE 0\n-#define ATOMIC_ADDRESS_LOCK_FREE 0\n \n   // Implementation specific defines.\n #define _ATOMIC_LOAD_(__a, __x)\t\t\t\t\t\t\\\n   ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\\\n-    volatile atomic_flag* __g = __atomic_flag_for_address(__p); \t\\\n+     volatile atomic_flag* __g = __atomic_flag_for_address(__p); \t\\\n     __atomic_flag_wait_explicit(__g, __x);\t\t\t\t\\\n     __typeof__ _ATOMIC_MEMBER_ __r = *__p;\t\t\t\t\\\n     atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n@@ -332,7 +166,7 @@ extern \"C++\"\n     atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n     __r; })\n \n-#define _ATOMIC_CMPSWP_(__a, __e, __m, __x)\t\t\t\t\\\n+#define _ATOMIC_CMPEXCHNG_(__a, __e, __m, __x)\t\t\t\t\\\n   ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\\\n     __typeof__(__e) __q = (__e);\t\t\t       \t\t\\\n     __typeof__(__m) __v = (__m);\t\t\t       \t\t\\\n@@ -345,26 +179,19 @@ extern \"C++\"\n     atomic_flag_clear_explicit(__g, __x);\t\t       \t\t\\\n     __r; })\n \n-#define _ATOMIC_FENCE_(__a, __x)\t\t\t       \t\t\\\n-  ({ volatile __typeof__ _ATOMIC_MEMBER_* __p = &_ATOMIC_MEMBER_;\t\\\n-    volatile atomic_flag* __g = __atomic_flag_for_address(__p); \t\\\n-    atomic_flag_fence(__g, __x);\t\t\t       \t\t\\\n-  })\n-\n _GLIBCXX_END_EXTERN_C\n _GLIBCXX_END_NAMESPACE\n \n-#ifdef __cplusplus\n-// Inject into global namespace iff C++.\n+// Inject into global namespace. XXX\n+#if defined(__cplusplus) && !defined(_GLIBCXX_STDATOMIC)\n using std::memory_order;\n using std::memory_order_relaxed;\n+using std::memory_order_consume;\n using std::memory_order_acquire;\n using std::memory_order_release;\n using std::memory_order_acq_rel;\n using std::memory_order_seq_cst;\n-\n using std::atomic_flag;\n-\n using std::atomic_bool;\n using std::atomic_char;\n using std::atomic_schar;\n@@ -378,10 +205,10 @@ using std::atomic_ulong;\n using std::atomic_llong;\n using std::atomic_ullong;\n using std::atomic_wchar_t;\n-\n+using std::atomic_char16_t;\n+using std::atomic_char32_t;\n using std::atomic_address;\n using std::atomic;\n-\n #endif\n \n #endif"}, {"sha": "82d699b8e8109d82f29e4e1845155694c12f3edd", "filename": "libstdc++-v3/include/c_global/cstdatomic", "status": "modified", "additions": 621, "deletions": 3875, "changes": 4496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcstdatomic?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80"}, {"sha": "e2fe68f09bc44b99e483f249b00ed4aa66b173f1", "filename": "libstdc++-v3/src/atomic.cc", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fatomic.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -30,12 +30,17 @@\n \n #include \"gstdint.h\"\n #include <cstdatomic>\n+#include <mutex>\n \n #define LOGSIZE 4\n \n namespace\n {\n-  atomic_flag volatile __atomic_flag_anon_table__[ 1 << LOGSIZE ] =\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+  std::mutex atomic_mutex;\n+#endif\n+\n+  std::__atomic_flag_base volatile flag_table[ 1 << LOGSIZE ] =\n     {\n       ATOMIC_FLAG_INIT, ATOMIC_FLAG_INIT, ATOMIC_FLAG_INIT, ATOMIC_FLAG_INIT,\n       ATOMIC_FLAG_INIT, ATOMIC_FLAG_INIT, ATOMIC_FLAG_INIT, ATOMIC_FLAG_INIT,\n@@ -46,73 +51,66 @@ namespace\n \n namespace std\n {\n-  extern \"C\" {\n-\n-  const atomic_flag atomic_global_fence_compatibility = ATOMIC_FLAG_INIT;\n-\n-  bool \n-  atomic_flag_test_and_set_explicit(volatile atomic_flag* __a, \n-\t\t\t\t    memory_order __x\n-\t\t\t\t    __attribute__ ((__unused__)))\n+  namespace __atomic0\n   {\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS_1\n-    if (__x >= memory_order_acq_rel)\n-      __sync_synchronize();\n-    return __sync_lock_test_and_set(&(__a->_M_base._M_b), 1);\n-#else\n-    bool result = __a->_M_base._M_b;\n-     __a->_M_base._M_b = true;\n-    return result;\n+    bool\n+    atomic_flag::test_and_set(memory_order) volatile\n+    {\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+      lock_guard<mutex> __lock(atomic_mutex);\n #endif\n-  }\n+      bool result = _M_i;\n+      _M_i = true;\n+      return result;\n+    }\n \n-  bool \n-  atomic_flag_test_and_set(volatile atomic_flag* __a)\n-  { return atomic_flag_test_and_set_explicit(__a, memory_order_seq_cst); }\n-  \n-  void \n-  atomic_flag_clear_explicit(volatile atomic_flag* __a,\n-\t\t\t     memory_order __x __attribute__ ((__unused__)))\n-  {\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS_1\n-    __sync_lock_release(&(__a->_M_base._M_b));\n-    if (__x >= memory_order_acq_rel)\n-      __sync_synchronize();\n-#else\n-     __a->_M_base._M_b = false;\n+    void\n+    atomic_flag::clear(memory_order) volatile\n+    {\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+      lock_guard<mutex> __lock(atomic_mutex);\n #endif\n-  } \n+      _M_i = false;\n+    }\n+  }\n \n-  void \n-  atomic_flag_clear(volatile atomic_flag* __a)\n-  { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }\n-  \n-  void \n-  atomic_flag_fence(const volatile atomic_flag*, memory_order)\n+  extern \"C\"\n   {\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS_1\n-    __sync_synchronize(); \n-#endif\n-  } \n+    bool\n+    atomic_flag_test_and_set_explicit(volatile __atomic_flag_base* __a,\n+\t\t\t\t      memory_order __m)\n+    {\n+      volatile atomic_flag d(__a->_M_i);\n+      return d.test_and_set(__m);\n+    }\n \n-  void \n-  __atomic_flag_wait_explicit(volatile atomic_flag* __a, memory_order __x)\n-  { \n-    while (atomic_flag_test_and_set_explicit(__a, __x))\n-      { }; \n-  }\n+    void\n+    atomic_flag_clear_explicit(volatile __atomic_flag_base* __a,\n+\t\t\t       memory_order __m)\n+    {\n+      volatile atomic_flag d(__a->_M_i);\n+      return d.clear(__m);\n+    }\n \n-  volatile atomic_flag* \n-  __atomic_flag_for_address(const volatile void* __z)\n-  {\n-    uintptr_t __u = reinterpret_cast<uintptr_t>(__z);\n-    __u += (__u >> 2) + (__u << 4);\n-    __u += (__u >> 7) + (__u << 5);\n-    __u += (__u >> 17) + (__u << 13);\n-    if (sizeof(uintptr_t) > 4) __u += (__u >> 31);\n-    __u &= ~((~uintptr_t(0)) << LOGSIZE);\n-    return __atomic_flag_anon_table__ + __u;\n-  }\n+    void\n+    __atomic_flag_wait_explicit(volatile __atomic_flag_base* __a,\n+\t\t\t\tmemory_order __x)\n+    {\n+      while (atomic_flag_test_and_set_explicit(__a, __x))\n+\t{ };\n+    }\n \n+    volatile __atomic_flag_base*\n+    __atomic_flag_for_address(const volatile void* __z)\n+    {\n+      uintptr_t __u = reinterpret_cast<uintptr_t>(__z);\n+      __u += (__u >> 2) + (__u << 4);\n+      __u += (__u >> 7) + (__u << 5);\n+      __u += (__u >> 17) + (__u << 13);\n+      if (sizeof(uintptr_t) > 4)\n+\t__u += (__u >> 31);\n+      __u &= ~((~uintptr_t(0)) << LOGSIZE);\n+      return flag_table + __u;\n+    }\n   } // extern \"C\"\n } // namespace std"}, {"sha": "4644f32920232b157fb09d391c055ab3b0fcbfdb", "filename": "libstdc++-v3/testsuite/27_io/ios_base/types/fmtflags/bitmask_operators.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Ffmtflags%2Fbitmask_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Ffmtflags%2Fbitmask_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Ffmtflags%2Fbitmask_operators.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // -*- C++ -*-\n  \n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2008 Free Software Foundation, Inc.\n  \n // This library is free software; you can redistribute it and/or\n // modify it under the terms of the GNU General Public License as\n@@ -31,7 +31,7 @@\n // Benjamin Kosnik  <bkoz@redhat.com>\n \n #include <ios>\n-#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n \n int main()\n {"}, {"sha": "348261f083011b8d9d139922fb70b33856f0cb85", "filename": "libstdc++-v3/testsuite/27_io/ios_base/types/iostate/bitmask_operators.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fiostate%2Fbitmask_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fiostate%2Fbitmask_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fiostate%2Fbitmask_operators.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // -*- C++ -*-\n  \n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2008 Free Software Foundation, Inc.\n  \n // This library is free software; you can redistribute it and/or\n // modify it under the terms of the GNU General Public License as\n@@ -31,7 +31,7 @@\n // Benjamin Kosnik  <bkoz@redhat.com>\n \n #include <ios>\n-#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n \n int main()\n {"}, {"sha": "bd71de62adcd38aedd5c9ce803799e5d3df3c20a", "filename": "libstdc++-v3/testsuite/27_io/ios_base/types/openmode/bitmask_operators.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fopenmode%2Fbitmask_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fopenmode%2Fbitmask_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_base%2Ftypes%2Fopenmode%2Fbitmask_operators.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // -*- C++ -*-\n  \n-// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2008 Free Software Foundation, Inc.\n  \n // This library is free software; you can redistribute it and/or\n // modify it under the terms of the GNU General Public License as\n@@ -31,7 +31,7 @@\n // Benjamin Kosnik  <bkoz@redhat.com>\n \n #include <ios>\n-#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n \n int main()\n {"}, {"sha": "834d68c33f9c4d05f3618e07598001961d449a56", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/assign_neg.cc", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fassign_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -38,18 +38,20 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"within this context\" \"\" { target *-*-* } 310 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1750 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1782 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 1799 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1816 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1832 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1848 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1864 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1880 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1896 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1913 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1929 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1945 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1961 }\n+// { dg-error \"used here\" \"\" { target *-*-* } 510 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 257 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 275 } \n+// { dg-error \"deleted function\" \"\" { target *-*-* } 293 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 311 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 329 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 347 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 365 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 383 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 401 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 419 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 437 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 455 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 473 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 491 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 239 }\n // { dg-excess-errors \"In member function\" }"}, {"sha": "c7ad3b73fb43764ebe3667e4cc8482ff803e78aa", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/copy_list.cc", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_list.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -32,7 +32,7 @@\n \n int main()\n {\n-  __gnu_test::explicit_value_constructible test;\n+  __gnu_test::copy_list_initializable test;\n   __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl(), \n \t\t\t\t       __gnu_test::integral_types::type());\n   return 0;", "previous_filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/explicit_value.cc"}, {"sha": "94022289152193830c44804012a5d86985ff4be2", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/copy_neg.cc", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fcopy_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -38,18 +38,20 @@ int main()\n   return 0;\n }\n \n-// { dg-error \"within this context\" \"\" { target *-*-* } 349 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 1749 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1781 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1798 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1814 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1831 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1847 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1863 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1879 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1895 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1912 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1928 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1944 }\n-// { dg-error \"is private\" \"\" { target *-*-* } 1960 }\n+// { dg-error \"used here\" \"\" { target *-*-* } 549 } \n+// { dg-error \"deleted function\" \"\" { target *-*-* } 238 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 256 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 274 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 292 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 310 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 328 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 346 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 364 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 382 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 400 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 418 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 436 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 454 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 472 }\n+// { dg-error \"deleted function\" \"\" { target *-*-* } 490 }\n // { dg-excess-errors \"In member function\" }"}, {"sha": "a9ef8a91867a3a1fe2e415db7798b6d072c60cbe", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/direct_list.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fdirect_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fdirect_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fdirect_list.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::direct_list_initializable test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "79e5e4b83821f678a8e2a4e1e6b277d0f8f23a50", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/cons/single_value.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fsingle_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fsingle_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fcons%2Fsingle_value.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::single_value_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "3fcc15c99d799744ac9b2d2af5fe75d4c0a388aa", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/operators/integral_assignment.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fintegral_assignment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fintegral_assignment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fintegral_assignment.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::integral_assignable test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "5586d2ecbe6bbca2938bb4e257e2aca1deeab769", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/operators/integral_conversion.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fintegral_conversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fintegral_conversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fintegral_conversion.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::integral_convertable test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "44dc4fe89737a336f94aaea36c9e590d58f1ecfa", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/requirements/base_classes.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fbase_classes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fbase_classes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fbase_classes.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+void test01()\n+{\n+  // Check for required base class.\n+  __gnu_test::has_required_base_class test;\n+  __gnu_cxx::typelist::apply_generator(test, \n+\t\t\t\t       __gnu_test::atomic_integrals::type(), \n+                                       __gnu_test::atomics_tl());\n+}"}, {"sha": "e51e8e4454f9666448bf985540b949812b5702dd", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/requirements/standard_layout.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fstandard_layout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fstandard_layout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Fstandard_layout.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// 2008-10-22 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+void test01()\n+{\n+  // Check for standard layout requirements\n+  __gnu_test::standard_layout test;\n+  __gnu_cxx::typelist::apply_generator(test, __gnu_test::atomics_tl());\n+}"}, {"sha": "3d7986ac190a38354bf02f088bdf9e4c218c7342", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_address/cons/assign_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fassign_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -38,5 +38,5 @@ void test01()\n   test_type t2;\n   t1 = t2;\n }\n-// { dg-error \"within this context\" \"\" { target *-*-* } 39 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 167 } \n+// { dg-error \"used here\" \"\" { target *-*-* } 39 } \n+// { dg-excess-errors \"deleted function\" } "}, {"sha": "fe0155f0e2cb3ed2a0a0eee878285869a147620b", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_address/cons/copy_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fcopy_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -37,5 +37,5 @@ void test01()\n   test_type t1;\n   test_type t2(t1);\n }\n-// { dg-error \"within this context\" \"\" { target *-*-* } 38 } \n-// { dg-error \"is private\" \"\" { target *-*-* } 166 } \n+// { dg-error \"used here\" \"\" { target *-*-* } 38 } \n+// { dg-excess-errors \"deleted function\" } "}, {"sha": "bdae37bf8fed6ab1e622970d0b666f802853d2fc", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_address/cons/single_value.cc", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fsingle_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fsingle_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_address%2Fcons%2Fsingle_value.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -31,7 +31,7 @@\n \n int main()\n {\n-  // Explicit value constructor.\n+  // Single value constructor.\n   void* v = NULL;\n   std::atomic_address a(v);\n   return 0;", "previous_filename": "libstdc++-v3/testsuite/29_atomics/atomic_address/cons/explicit_value.cc"}, {"sha": "21616bb7af1aeefdce2b378dc4f655c964415a21", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/assign_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2Fassign_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -38,5 +38,5 @@ void test01()\n   test_type t2;\n   t1 = t2;\n }\n-// { dg-error \"within this context\" \"\" { xfail *-*-* } 39 } \n-// { dg-error \"is private\" \"\" { xfail *-*-* } 89 } \n+// { dg-error \"used here\" \"\" { target *-*-* } 39 } \n+// { dg-excess-errors \"deleted function\" } "}, {"sha": "4dcd0500f90da665bf8c4ac066cde1b7c612aa6e", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/cons/copy_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Fcons%2Fcopy_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -37,5 +37,5 @@ void test01()\n   test_type t1;\n   test_type t2(t1);\n }\n-// { dg-error \"within this context\" \"\" { xfail *-*-* } 38 } \n-// { dg-error \"is private\" \"\" { xfail *-*-* } 88 } \n+// { dg-error \"used here\" \"\" { target *-*-* } 38 } \n+// { dg-excess-errors \"deleted function\" } "}, {"sha": "c7489014334054b447b99469be6cedff781f4c7e", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/requirements/standard_layout.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Frequirements%2Fstandard_layout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Frequirements%2Fstandard_layout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_flag%2Frequirements%2Fstandard_layout.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -36,6 +36,10 @@ int main()\n   bool test __attribute__((unused)) = true;\n \n   typedef std::atomic_flag test_type;\n+  \n+  // libstdc++/37907\n+  // VERIFY( std::is_standard_layout<test_type>::value );\n+\n   VERIFY( std::has_trivial_default_constructor<test_type>::value );\n   VERIFY( std::has_trivial_destructor<test_type>::value );\n "}, {"sha": "724714ed819cecab5bf540602988d856fad238cb", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/assign_neg.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fassign_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::assignable test;\n+  __gnu_cxx::typelist::apply_generator(test, \n+\t\t\t\t       __gnu_test::atomic_integrals::type());\n+  return 0;\n+}\n+\n+// { dg-error \"used here\" \"\" { target *-*-* } 510 }\n+// { dg-excess-errors \"deleted function\" } \n+// { dg-excess-errors \"deleted function\" } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 38 } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 517 } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 173 } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 404 }\n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 175 }  \n+// { dg-excess-errors \"In member function\" }"}, {"sha": "b5bc8d0c07852e06b403d1b54b6b6d04d21a041e", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/copy_list.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_list.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::copy_list_initializable test;\n+  __gnu_cxx::typelist::apply_generator(test,\n+\t\t\t\t       __gnu_test::atomic_integrals::type(),\n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "f03ceced11b869cfe51fc46083f6f150c09ff7aa", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/copy_neg.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fcopy_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::copy_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test, \n+\t\t\t\t       __gnu_test::atomic_integrals::type());\n+  return 0;\n+}\n+\n+// { dg-error \"used here\" \"\" { target *-*-* } 549 }\n+// { dg-excess-errors \"deleted function\" } \n+// { dg-excess-errors \"deleted function\" } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 38 } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 555 } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 173 } \n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 404 }\n+// { dg-error \"instantiated from\" \"\" { target *-*-* } 175 }  \n+// { dg-excess-errors \"In member function\" }"}, {"sha": "3894fd4c343f47192c36284d5b35191fbf5bc381", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/default.cc", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fdefault.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -28,12 +28,12 @@\n // the GNU General Public License.\n \n #include <cstdatomic>\n+#include <testsuite_common_types.h>\n \n int main()\n {\n-  using namespace std;\n-  atomic_flag_fence(&atomic_global_fence_compatibility, memory_order_acquire);\n-  atomic_global_fence_compatibility.fence(memory_order_release);\n-\n+  __gnu_test::default_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test,\n+\t\t\t\t       __gnu_test::atomic_integrals::type());\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/29_atomics/atomic_flag/atomic_global_fence_compatibility.cc"}, {"sha": "ac53f318f35ac90a0141dd8b3faaaa98857ca94f", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/direct_list.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fdirect_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fdirect_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fdirect_list.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::direct_list_initializable test;\n+  __gnu_cxx::typelist::apply_generator(test, \n+\t\t\t\t       __gnu_test::atomic_integrals::type(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "6572de7cf68a5e5d2998a45274a247772de9b133", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/cons/single_value.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fsingle_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fsingle_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fcons%2Fsingle_value.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::single_value_constructible test;\n+  __gnu_cxx::typelist::apply_generator(test, \n+\t\t\t\t       __gnu_test::atomic_integrals::type(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "649c34000bf209ef3f5d3f2270b110f35bbad6e3", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/bitwise.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// -*- C++ -*-\n+ \n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+ \n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+ \n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+ \n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::has_bitwise_operators test;\n+  using __gnu_test::atomic_integrals_no_bool;\n+  __gnu_cxx::typelist::apply_generator(test, atomic_integrals_no_bool::type());\n+};"}, {"sha": "0d36bbcd77af62994f16a6cbb9eed15f384918d2", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/bitwise_neg.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fbitwise_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// -*- C++ -*-\n+ \n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+ \n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+ \n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+ \n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::bitwise_assignment_operators<std::atomic_bool>();\n+  return 0;\n+}\n+\n+// { dg-error \"operator\" \"\" { target *-*-* } 413 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 414 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 415 }\n+// { dg-excess-errors \"In file included from\" }"}, {"sha": "f487b6553af94135a7d4542a1a5fe6a8aeee1618", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/decrement.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// -*- C++ -*-\n+ \n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+ \n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+ \n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+ \n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::has_decrement_operators test;\n+  using __gnu_test::atomic_integrals_no_bool;\n+  __gnu_cxx::typelist::apply_generator(test, atomic_integrals_no_bool::type());\n+};"}, {"sha": "9480af5a23621acab14cd3e66dd0fccc80490aa5", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/decrement_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fdecrement_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// -*- C++ -*-\n+ \n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+ \n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+ \n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+ \n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::has_decrement_operators test;\n+  test.operator()<std::atomic_bool>();\n+  return 0;\n+}\n+\n+// { dg-error \"operator\" \"\" { target *-*-* } 384 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 385 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 386 }\n+// { dg-excess-errors \"In file included from\" }"}, {"sha": "608ddefbb4c44b6db6bd18712bca92b7212fff14", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/increment.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// -*- C++ -*-\n+ \n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+ \n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+ \n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+ \n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::has_increment_operators test;\n+  using __gnu_test::atomic_integrals_no_bool;\n+  __gnu_cxx::typelist::apply_generator(test, atomic_integrals_no_bool::type());\n+};"}, {"sha": "fc2f76b35e060e1f571dd002f13eeb384fe0a77f", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/increment_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fincrement_neg.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// -*- C++ -*-\n+ \n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+ \n+// This library is free software; you can redistribute it and/or\n+// modify it under the terms of the GNU General Public License as\n+// published by the Free Software Foundation; either version 2, or (at\n+// your option) any later version.\n+ \n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+ \n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+// MA 02110-1301, USA.\n+ \n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+ \n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::has_increment_operators test;\n+  test.operator()<std::atomic_bool>();\n+  return 0;\n+}\n+\n+// { dg-error \"operator\" \"\" { target *-*-* } 362 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 363 }\n+// { dg-error \"operator\" \"\" { target *-*-* } 364 }\n+// { dg-excess-errors \"In file included from\" }"}, {"sha": "4e8a42383b842f03e16d5d83c857f961805c2de4", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/integral_assignment.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fintegral_assignment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fintegral_assignment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fintegral_assignment.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::integral_assignable test;\n+  __gnu_cxx::typelist::apply_generator(test,\n+\t\t\t\t       __gnu_test::atomic_integrals::type(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "527dc77691da76640d3a3b4e1057db5de208c148", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/operators/integral_conversion.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fintegral_conversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fintegral_conversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Foperators%2Fintegral_conversion.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,41 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdatomic>\n+#include <testsuite_hooks.h>\n+#include <testsuite_common_types.h>\n+\n+int main()\n+{\n+  __gnu_test::integral_convertable test;\n+  __gnu_cxx::typelist::apply_generator(test,\n+\t\t\t\t       __gnu_test::atomic_integrals::type(), \n+\t\t\t\t       __gnu_test::integral_types::type());\n+  return 0;\n+}"}, {"sha": "1b6836fb54c845eaffce73cb6d8a9e504b46cd93", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/requirements/standard_layout.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Frequirements%2Fstandard_layout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Frequirements%2Fstandard_layout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Frequirements%2Fstandard_layout.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+// 2008-10-22 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <cstdatomic>\n+#include <testsuite_common_types.h>\n+\n+void test01()\n+{\n+  // Check for standard layout requirements\n+  __gnu_test::standard_layout test;\n+  __gnu_cxx::typelist::apply_generator(test, \n+\t\t\t\t       __gnu_test::atomic_integrals::type());\n+}"}, {"sha": "c7ea8bc74f8b3e0171ab326002a800d032b194f4", "filename": "libstdc++-v3/testsuite/29_atomics/headers/cstdatomic/functions_std_c++0x.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Ffunctions_std_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Ffunctions_std_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Ffunctions_std_c%2B%2B0x.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -27,21 +27,21 @@ namespace gnu\n   using std::atomic_flag_test_and_set_explicit;\n   using std::atomic_flag_clear;\n   using std::atomic_flag_clear_explicit;\n-  using std::atomic_flag_fence;\n \n-  using std::atomic_global_fence_compatibility;\n+  using std::kill_dependency;\n \n   // Sloppy testing for integral types (en masse).\n   using std::atomic_is_lock_free;\n   using std::atomic_store;\n   using std::atomic_store_explicit;\n   using std::atomic_load;\n   using std::atomic_load_explicit;\n-  using std::atomic_swap;\n-  using std::atomic_swap_explicit;\n-  using std::atomic_compare_swap;\n-  using std::atomic_compare_swap_explicit;\n-  using std::atomic_fence;\n+  using std::atomic_exchange;\n+  using std::atomic_exchange_explicit;\n+  using std::atomic_compare_exchange_weak;\n+  using std::atomic_compare_exchange_strong;\n+  using std::atomic_compare_exchange_weak_explicit;\n+  using std::atomic_compare_exchange_strong_explicit;\n \n   using std::atomic_fetch_add;\n   using std::atomic_fetch_add_explicit;"}, {"sha": "d285a7e276719a3f182af98dd19a342c59eb24fb", "filename": "libstdc++-v3/testsuite/29_atomics/headers/cstdatomic/macros.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Fmacros.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Fmacros.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Fmacros.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -24,11 +24,20 @@\n namespace gnu\n {\n #ifndef ATOMIC_INTEGRAL_LOCK_FREE\n-    #error \"ATOMIC_INTEGRAL_LOCK_FREE_must_be_a_macro\"\n+# error \"ATOMIC_INTEGRAL_LOCK_FREE must be a macro\"\n+#else\n+# if ATOMIC_INTEGRAL_LOCK_FREE != 0 \\\n+    && ATOMIC_INTEGRAL_LOCK_FREE != 1 && ATOMIC_INTEGRAL_LOCK_FREE != 2\n+# error \"ATOMIC_INTEGRAL_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n #endif\n \n #ifndef ATOMIC_ADDRESS_LOCK_FREE\n-    #error \"ATOMIC_ADDRESS_LOCK_FREE_must_be_a_macro\"\n+# error \"ATOMIC_ADDRESS_LOCK_FREE must be a macro\"\n+# if ATOMIC_INTEGRAL_LOCK_FREE != 0 \\\n+    && ATOMIC_INTEGRAL_LOCK_FREE != 1 && ATOMIC_INTEGRAL_LOCK_FREE != 2\n+# error \"ATOMIC_INTEGRAL_LOCK_FREE must be 0, 1, or 2\"\n+# endif\n #endif\n \n #ifndef ATOMIC_FLAG_INIT"}, {"sha": "182c2d91866b20756cef8e86f1e6c63dd18ec326", "filename": "libstdc++-v3/testsuite/29_atomics/headers/cstdatomic/types_std_c++0x.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Ftypes_std_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Ftypes_std_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fcstdatomic%2Ftypes_std_c%2B%2B0x.cc?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -25,6 +25,7 @@ void test01()\n {\n   using std::memory_order;\n   using std::memory_order_relaxed;\n+  using std::memory_order_consume;\n   using std::memory_order_acquire;\n   using std::memory_order_release;\n   using std::memory_order_acq_rel;\n@@ -75,7 +76,4 @@ void test01()\n   using std::atomic_uintmax_t;\n \n   using std::atomic_address;\n-\n-  const std::atomic_flag* p __attribute__((unused))\n-    = &std::atomic_global_fence_compatibility;\n }"}, {"sha": "1e65e940dc9c0c0856749450aa60371ee084de0a", "filename": "libstdc++-v3/testsuite/29_atomics/headers/stdatomic.h/macros.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Fmacros.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Fmacros.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Fmacros.c?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -55,24 +55,20 @@ int main()\n     #error \"atomic_store_must_be_a_macro\"\n #endif\n \n-#ifndef atomic_swap_explicit\n-    #error \"atomic_swap_explicit_must_be_a_macro\"\n+#ifndef atomic_exchange_explicit\n+    #error \"atomic_exchange_explicit_must_be_a_macro\"\n #endif\n \n-#ifndef atomic_swap\n-    #error \"atomic_swap_must_be_a_macro\"\n+#ifndef atomic_exchange\n+    #error \"atomic_exchange_must_be_a_macro\"\n #endif\n \n-#ifndef atomic_compare_swap\n-    #error \"atomic_compare_swap_must_be_a_macro\"\n+#ifndef atomic_compare_exchange\n+    #error \"atomic_compare_exchange_must_be_a_macro\"\n #endif\n \n-#ifndef atomic_compare_swap_explicit\n-    #error \"atomic_compare_swap_explicit_must_be_a_macro\"\n-#endif\n-\n-#ifndef atomic_fence\n-    #error \"atomic_fence_must_be_a_macro\"\n+#ifndef atomic_compare_exchange_explicit\n+    #error \"atomic_compare_exchange_explicit_must_be_a_macro\"\n #endif\n \n #ifndef atomic_fetch_add_explicit"}, {"sha": "478fdd8283aa5dfeb716399edd41bf5b45cd0a82", "filename": "libstdc++-v3/testsuite/29_atomics/headers/stdatomic.h/types.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fstdatomic.h%2Ftypes.c?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -75,7 +75,4 @@ void test01()\n   typedef atomic_uintmax_t t_45;\n \n   typedef atomic_address t_46;\n-\n-  const atomic_flag* p __attribute__((unused))\n-    = &atomic_global_fence_compatibility;\n }"}, {"sha": "6dc0dfa7ebff0751423479e2834f38adfd8bed03", "filename": "libstdc++-v3/testsuite/util/testsuite_common_types.h", "status": "modified", "additions": 301, "deletions": 4, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_common_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_common_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_common_types.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -54,6 +54,7 @@\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdatomic>\n+#include <type_traits>\n #endif\n \n namespace __gnu_test\n@@ -279,14 +280,63 @@ namespace __gnu_test\n     typedef long long \t\ta11;\n     typedef unsigned long long \ta12;\n     typedef wchar_t \t\ta13;\n-    // typedef char16_t \t\ta14;\n-    // typedef char16_t \t\ta15;\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+    typedef char16_t \t\ta14;\n+    typedef char32_t \t\ta15;\n \n+    typedef node<_GLIBCXX_TYPELIST_CHAIN15(a1, a2, a3, a4, a5, a6, a7, a8, a9, \n+\t\t\t\t\t   a10, a11, a12, a13, a14, a15)> type;\n+#else\n     typedef node<_GLIBCXX_TYPELIST_CHAIN13(a1, a2, a3, a4, a5, a6, a7, a8, a9, \n \t\t\t\t\t   a10, a11, a12, a13)> type;\n+#endif\n   };\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  struct atomic_integrals_no_bool\n+  {\n+    typedef std::atomic_char        \ta2;\n+    typedef std::atomic_schar \t\ta3;\n+    typedef std::atomic_uchar \t\ta4;\n+    typedef std::atomic_short       \ta5;\n+    typedef std::atomic_ushort \t\ta6;\n+    typedef std::atomic_int \t\ta7;\n+    typedef std::atomic_uint \t\ta8;\n+    typedef std::atomic_long        \ta9;\n+    typedef std::atomic_ulong \t\ta10;\n+    typedef std::atomic_llong       \ta11;\n+    typedef std::atomic_ullong \t\ta12;\n+    typedef std::atomic_wchar_t     \ta13;\n+    typedef std::atomic_char16_t    \ta14;\n+    typedef std::atomic_char32_t    \ta15;\n+    \n+    typedef node<_GLIBCXX_TYPELIST_CHAIN14(a2, a3, a4, a5, a6, a7, a8, a9, \n+\t\t\t\t\t   a10, a11, a12, a13, a14, a15)> type;\n+  };\n+\n+  struct atomic_integrals\n+  {\n+    typedef std::atomic_bool        \ta1;\n+    typedef std::atomic_char        \ta2;\n+    typedef std::atomic_schar \t\ta3;\n+    typedef std::atomic_uchar \t\ta4;\n+    typedef std::atomic_short       \ta5;\n+    typedef std::atomic_ushort \t\ta6;\n+    typedef std::atomic_int \t\ta7;\n+    typedef std::atomic_uint \t\ta8;\n+    typedef std::atomic_long        \ta9;\n+    typedef std::atomic_ulong \t\ta10;\n+    typedef std::atomic_llong       \ta11;\n+    typedef std::atomic_ullong \t\ta12;\n+    typedef std::atomic_wchar_t     \ta13;\n+    typedef std::atomic_char16_t    \ta14;\n+    typedef std::atomic_char32_t    \ta15;\n+    \n+    typedef node<_GLIBCXX_TYPELIST_CHAIN15(a1, a2, a3, a4, a5, a6, a7, a8, a9, \n+\t\t\t\t\t   a10, a11, a12, a13, a14, a15)> type;\n+  };\n+\n+\n   template<typename Tp>\n     struct atomics\n     {\n@@ -297,6 +347,156 @@ namespace __gnu_test\n   typedef transform<integral_types::type, atomics>::type atomics_tl;\n #endif\n \n+\n+  struct has_increment_operators\n+  {\n+    template<typename _Tp>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    _Tp a; \n+\t    ++a; // prefix\n+\t    a++; // postfix\n+\t    a += a;\n+\t  }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n+  struct has_decrement_operators\n+  {\n+    template<typename _Tp>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    _Tp a; \n+\t    --a; // prefix\n+\t    a--; // postfix\n+\t    a -= a;\n+\t  }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n+  template<typename _Tp>\n+    void\n+    bitwise_operators()\n+    {\n+      _Tp a; \n+      _Tp b;\n+      a | b;\n+      a & b;\n+      a ^ b;\n+      ~b;\n+    }\n+\n+  template<typename _Tp>\n+    void\n+    bitwise_assignment_operators()\n+    {\n+      _Tp a; \n+      _Tp b;\n+      a |= b; // set\n+      a &= ~b; // clear\n+      a ^= b;\n+    }\n+\n+  // 17.3.2.1.2 - Bitmask types [lib.bitmask.types]\n+  // bitmask_operators\n+  template<typename _BitmTp>\n+    void\n+    bitmask_operators()\n+    {\n+      bitwise_operators<_BitmTp>();\n+      bitwise_assignment_operators<_BitmTp>();\n+    }\n+\n+  struct has_bitwise_operators\n+  {\n+    template<typename _Tp>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    bitwise_assignment_operators<_Tp>();\n+\t  }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n+  // Generator to test standard layout\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  struct standard_layout\n+  {\n+    template<typename _Tp>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    // libstdc++/37907\n+\t    // typedef std::is_standard_layout<_Tp> standard_layout_p;\n+\t    // static_assert(standard_layout_p::value, \"not standard_layout\");\n+\t    \n+\t    typedef std::has_trivial_default_constructor<_Tp> ctor_p;\n+\t    static_assert(ctor_p::value, \"default ctor not trivial\");\n+\n+\t    typedef std::has_trivial_destructor<_Tp> dtor_p;\n+\t    static_assert(dtor_p::value, \"dtor not trivial\");\n+\t  }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+#endif\n+\n+  // Generator to test base class\n+  struct has_required_base_class\n+  {\n+    template<typename _TBase, typename _TDerived>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    const _TDerived& obj = __a;\n+\t    const _TBase* base __attribute__((unused)) = &obj;\n+\t  }\n+\t  \n+\t  _TDerived __a;\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n   // Generator to test assignment operator.\n   struct assignable\n   {\n@@ -356,8 +556,8 @@ namespace __gnu_test\n       }\n   };\n \n-  // Generator to test explicit value constructor.\n-  struct explicit_value_constructible\n+  // Generator to test direct initialization, single value constructor.\n+  struct single_value_constructible\n   {\n     template<typename _Ttype, typename _Tvalue>\n       void \n@@ -376,5 +576,102 @@ namespace __gnu_test\n       }\n   };\n \n+  // Generator to test direct list initialization\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  struct direct_list_initializable\n+  {\n+    template<typename _Ttype, typename _Tvalue>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    _Ttype __v1 { }; // default ctor\n+\t    _Ttype __v2 { __a };  // single-argument ctor\n+\t  }\n+\t  \n+\t  _Tvalue __a;\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+#endif\n+\n+  // Generator to test copy list initialization, aggregate initialization\n+  struct copy_list_initializable\n+  {\n+    template<typename _Ttype, typename _Tvalue>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { _Ttype __v = {__a}; }\n+\t  \n+\t  _Tvalue __a;\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n+  // Generator to test integral conversion operator\n+  struct integral_convertable\n+  {\n+    template<typename _Ttype, typename _Tvalue>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    _Tvalue __v0(0);\n+\t    _Tvalue __v1(1);\n+\t    _Ttype __a(__v1);\n+\t    __v0 = __a;\n+\n+\t    bool test __attribute__((unused)) = true;\n+\t    VERIFY( __v1 == __v0 );\n+\t  }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n+\n+  // Generator to test integral assignment operator \n+  struct integral_assignable\n+  {\n+    template<typename _Ttype, typename _Tvalue>\n+      void \n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  {\n+\t    _Tvalue __v0(0);\n+\t    _Tvalue __v1(1);\n+\t    _Ttype __a(__v0);\n+\t    __a = __v1;\n+\t    _Tvalue __vr = __a;\n+\n+\t    bool test __attribute__((unused)) = true;\n+\t    VERIFY( __v1 == __vr );\n+\t  }\n+\t};\n+\n+\tvoid (_Concept::*__x)() __attribute__((unused))\n+\t  = &_Concept::__constraint;\n+      }\n+  };\n } // namespace __gnu_test\n #endif"}, {"sha": "0f870f84cd197afd9e86e204cd78f54f150dac12", "filename": "libstdc++-v3/testsuite/util/testsuite_hooks.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_hooks.h?ref=50ce8d3d7881457c44f0ef64b3d8e0fbfd6acf80", "patch": "@@ -1,7 +1,7 @@\n // -*- C++ -*-\n // Utility subroutines for the C++ library testsuite. \n //\n-// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -100,22 +100,6 @@ namespace __gnu_test\n   void\n   verify_demangle(const char* mangled, const char* wanted);\n \n-  // 17.3.2.1.2 - Bitmask types [lib.bitmask.types]\n-  // bitmask_operators\n-  template<typename bitmask_type>\n-    void\n-    bitmask_operators(bitmask_type a = bitmask_type(),\n-\t\t      bitmask_type b = bitmask_type())\n-    {\n-      a | b;\n-      a & b;\n-      a ^ b;\n-      ~b;\n-      a |= b; // set\n-      a &= ~b; // clear\n-      a ^= b;\n-    }\n-\n   // Simple callback structure for variable numbers of tests (all with\n   // same signature).  Assume all unit tests are of the signature\n   // void test01(); "}]}