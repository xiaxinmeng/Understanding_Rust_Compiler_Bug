{"sha": "472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcyYzdmYmQwOTc5MTI5MzEzZTQ5YzJmYjczZmY1YjM2ZDRiMWQ1Nw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-03-27T22:36:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-03-27T22:36:33Z"}, "message": "re PR tree-optimization/39120 (Missed escape constraints for call results)\n\n2009-03-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/39120\n\t* tree-ssa-structalias.c (handle_rhs_call): Fill out return\n\tconstraints.\n\t(handle_lhs_call): Process return constraints.  Add escape\n\tconstraints if necessary.\n\t(handle_const_call): Fill out return constraints.  Make nested\n\tcase more precise.  Avoid consttmp if possible.\n\t(handle_pure_call): Fill out return constraints.  Avoid\n\tcallused if possible.\n\t(find_func_aliases): Simplify call handling.\n\n\t* gcc.c-torture/execute/pr39120.c: New testcase.\n\n2009-03-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/39120\n\t* tree-ssa-structalias.c (do_sd_constraint): Do not use CALLUSED\n\tas a representative.\n\t(solve_graph): Do propagate CALLUSED.\n\t(handle_pure_call): Use a scalar constraint from CALLUSED for\n\tthe return value.\n\t(find_what_p_points_to): CALLUSED shall not appear in poins-to\n\tsolutions.\n\n\t* gcc.dg/torture/pta-callused-1.c: New testcase.\n\nFrom-SVN: r145137", "tree": {"sha": "6d9ebbc1d407783c84648954b0a8422eb2e7ad5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d9ebbc1d407783c84648954b0a8422eb2e7ad5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9223014f991d207719b03fca8d8433edc58f27a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9223014f991d207719b03fca8d8433edc58f27a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9223014f991d207719b03fca8d8433edc58f27a"}], "stats": {"total": 271, "additions": 170, "deletions": 101}, "files": [{"sha": "7fd95bcdda1bcfe8b9c50b720eb36dcbf70575d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "patch": "@@ -1,3 +1,27 @@\n+2009-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39120\n+\t* tree-ssa-structalias.c (handle_rhs_call): Fill out return\n+\tconstraints.\n+\t(handle_lhs_call): Process return constraints.  Add escape\n+\tconstraints if necessary.\n+\t(handle_const_call): Fill out return constraints.  Make nested\n+\tcase more precise.  Avoid consttmp if possible.\n+\t(handle_pure_call): Fill out return constraints.  Avoid\n+\tcallused if possible.\n+\t(find_func_aliases): Simplify call handling.\n+\n+2009-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39120\n+\t* tree-ssa-structalias.c (do_sd_constraint): Do not use CALLUSED\n+\tas a representative.\n+\t(solve_graph): Do propagate CALLUSED.\n+\t(handle_pure_call): Use a scalar constraint from CALLUSED for\n+\tthe return value.\n+\t(find_what_p_points_to): CALLUSED shall not appear in poins-to\n+\tsolutions.\n+\n 2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c/39323"}, {"sha": "5fea6b9c9f4c06a2b07f50ca0e7fac4d0d848e62", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "patch": "@@ -1,3 +1,13 @@\n+2009-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39120\n+\t* gcc.c-torture/execute/pr39120.c: New testcase.\n+\n+2009-03-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39120\n+\t* gcc.dg/torture/pta-callused-1.c: New testcase.\n+\n 2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c/39323"}, {"sha": "8859848007ba03e222f7bfe2cd634b45254908be", "filename": "gcc/testsuite/gcc.c-torture/execute/pr39120.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr39120.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr39120.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr39120.c?ref=472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "patch": "@@ -0,0 +1,18 @@\n+struct X { int *p; } x;\n+\n+struct X __attribute__((noinline))\n+foo(int *p) { struct X x; x.p = p; return x; }\n+\n+void __attribute((noinline))\n+bar() { *x.p = 1; }\n+\n+extern void abort (void);\n+int main()\n+{\n+  int i = 0;\n+  x = foo(&i);\n+  bar();\n+  if (i != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "dfe994b7a84aa588a3b95ae1ca2e06cbc41f1d86", "filename": "gcc/testsuite/gcc.dg/torture/pta-callused-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-callused-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-callused-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpta-callused-1.c?ref=472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fdump-tree-alias\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+volatile int i;\n+int ** __attribute__((noinline,pure)) foo(int **p) { i; return p; }\n+int bar(void)\n+{\n+  int i = 0, j = 1;\n+  int *p, **q;\n+  p = &i;\n+  q = foo(&p);\n+  *q = &j;\n+  return *p;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  if (bar() != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"p.._., name memory tag: NMT..., is dereferenced, points-to vars: { i j }\" \"alias\" } } */\n+/* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "32e25a2455ee3edaecebac06448f748dd5795dc3", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 93, "deletions": 101, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/472c7fbd0979129313e49c2fb73ff5b36d4b1d57/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=472c7fbd0979129313e49c2fb73ff5b36d4b1d57", "patch": "@@ -1592,12 +1592,9 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  if (get_varinfo (t)->is_special_var)\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t  /* Merging the solution from ESCAPED needlessly increases\n-\t     the set.  Use ESCAPED as representative instead.\n-\t     Same for CALLUSED.  */\n+\t     the set.  Use ESCAPED as representative instead.  */\n \t  else if (get_varinfo (t)->id == find (escaped_id))\n \t    flag |= bitmap_set_bit (sol, escaped_id);\n-\t  else if (get_varinfo (t)->id == find (callused_id))\n-\t    flag |= bitmap_set_bit (sol, callused_id);\n \t  else if (add_graph_edge (graph, lhs, t))\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \t}\n@@ -2516,9 +2513,8 @@ solve_graph (constraint_graph_t graph)\n \t      solution_empty = bitmap_empty_p (solution);\n \n \t      if (!solution_empty\n-\t\t  /* Do not propagate the ESCAPED/CALLUSED solutions.  */\n-\t\t  && i != find (escaped_id)\n-\t\t  && i != find (callused_id))\n+\t\t  /* Do not propagate the ESCAPED solutions.  */\n+\t\t  && i != find (escaped_id))\n \t\t{\n \t\t  bitmap_iterator bi;\n \n@@ -3488,8 +3484,9 @@ make_escape_constraint (tree op)\n    RHS.  */\n \n static void\n-handle_rhs_call (gimple stmt)\n+handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n {\n+  struct constraint_expr rhsc;\n   unsigned i;\n \n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n@@ -3505,24 +3502,30 @@ handle_rhs_call (gimple stmt)\n   /* The static chain escapes as well.  */\n   if (gimple_call_chain (stmt))\n     make_escape_constraint (gimple_call_chain (stmt));\n+\n+  /* Regular functions return escaped addresses.  */\n+  rhsc.var = escaped_id;\n+  rhsc.offset = 0;\n+  rhsc.type = ADDRESSOF;\n+  VEC_safe_push (ce_s, heap, *results, &rhsc);\n }\n \n /* For non-IPA mode, generate constraints necessary for a call\n    that returns a pointer and assigns it to LHS.  This simply makes\n    the LHS point to global and escaped variables.  */\n \n static void\n-handle_lhs_call (tree lhs, int flags)\n+handle_lhs_call (tree lhs, int flags, VEC(ce_s, heap) *rhsc)\n {\n   VEC(ce_s, heap) *lhsc = NULL;\n-  struct constraint_expr rhsc;\n   unsigned int j;\n   struct constraint_expr *lhsp;\n \n   get_constraint_for (lhs, &lhsc);\n \n   if (flags & ECF_MALLOC)\n     {\n+      struct constraint_expr rhsc;\n       tree heapvar = heapvar_lookup (lhs);\n       varinfo_t vi;\n \n@@ -3546,59 +3549,54 @@ handle_lhs_call (tree lhs, int flags)\n       vi->size = ~0;\n       rhsc.type = ADDRESSOF;\n       rhsc.offset = 0;\n+      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\tprocess_constraint (new_constraint (*lhsp, rhsc));\n     }\n-  else\n+  else if (VEC_length (ce_s, rhsc) > 0)\n     {\n-      rhsc.var = escaped_id;\n-      rhsc.offset = 0;\n-      rhsc.type = ADDRESSOF;\n+      struct constraint_expr *lhsp, *rhsp;\n+      unsigned int i, j;\n+      /* If the store is to a global decl make sure to\n+\t add proper escape constraints.  */\n+      lhs = get_base_address (lhs);\n+      if (lhs\n+\t  && DECL_P (lhs)\n+\t  && is_global_var (lhs))\n+\t{\n+\t  struct constraint_expr tmpc;\n+\t  tmpc.var = escaped_id;\n+\t  tmpc.offset = 0;\n+\t  tmpc.type = SCALAR;\n+\t  VEC_safe_push (ce_s, heap, lhsc, &tmpc);\n+\t}\n+      for (i = 0; VEC_iterate (ce_s, lhsc, i, lhsp); ++i)\n+\tfor (j = 0; VEC_iterate (ce_s, rhsc, j, rhsp); ++j)\n+\t  process_constraint (new_constraint (*lhsp, *rhsp));\n     }\n-  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-    process_constraint (new_constraint (*lhsp, rhsc));\n   VEC_free (ce_s, heap, lhsc);\n }\n \n /* For non-IPA mode, generate constraints necessary for a call of a\n    const function that returns a pointer in the statement STMT.  */\n \n static void\n-handle_const_call (gimple stmt)\n+handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n {\n-  tree lhs = gimple_call_lhs (stmt);\n-  VEC(ce_s, heap) *lhsc = NULL;\n-  struct constraint_expr rhsc;\n-  unsigned int j, k;\n-  struct constraint_expr *lhsp;\n-  tree tmpvar;\n-  struct constraint_expr tmpc;\n+  struct constraint_expr rhsc, tmpc;\n+  tree tmpvar = NULL_TREE;\n+  unsigned int k;\n \n-  get_constraint_for (lhs, &lhsc);\n-\n-  /* If this is a nested function then it can return anything.  */\n+  /* Treat nested const functions the same as pure functions as far\n+     as the static chain is concerned.  */\n   if (gimple_call_chain (stmt))\n     {\n-      rhsc.var = anything_id;\n+      make_constraint_to (callused_id, gimple_call_chain (stmt));\n+      rhsc.var = callused_id;\n       rhsc.offset = 0;\n-      rhsc.type = ADDRESSOF;\n-      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\tprocess_constraint (new_constraint (*lhsp, rhsc));\n-      VEC_free (ce_s, heap, lhsc);\n-      return;\n+      rhsc.type = SCALAR;\n+      VEC_safe_push (ce_s, heap, *results, &rhsc);\n     }\n \n-  /* We always use a temporary here, otherwise we end up with a quadratic\n-     amount of constraints for\n-       large_struct = const_call (large_struct);\n-     in field-sensitive PTA.  */\n-  tmpvar = create_tmp_var_raw (ptr_type_node, \"consttmp\");\n-  tmpc = get_constraint_exp_for_temp (tmpvar);\n-\n-  /* May return addresses of globals.  */\n-  rhsc.var = nonlocal_id;\n-  rhsc.offset = 0;\n-  rhsc.type = ADDRESSOF;\n-  process_constraint (new_constraint (tmpc, rhsc));\n-\n   /* May return arguments.  */\n   for (k = 0; k < gimple_call_num_args (stmt); ++k)\n     {\n@@ -3610,75 +3608,73 @@ handle_const_call (gimple stmt)\n \t  struct constraint_expr *argp;\n \t  int i;\n \n+\t  /* We always use a temporary here, otherwise we end up with\n+\t     a quadratic amount of constraints for\n+\t       large_struct = const_call (large_struct);\n+\t     with field-sensitive PTA.  */\n+\t  if (tmpvar == NULL_TREE)\n+\t    {\n+\t      tmpvar = create_tmp_var_raw (ptr_type_node, \"consttmp\");\n+\t      tmpc = get_constraint_exp_for_temp (tmpvar);\n+\t    }\n+\n \t  get_constraint_for (arg, &argc);\n \t  for (i = 0; VEC_iterate (ce_s, argc, i, argp); i++)\n \t    process_constraint (new_constraint (tmpc, *argp));\n \t  VEC_free (ce_s, heap, argc);\n \t}\n     }\n+  if (tmpvar != NULL_TREE)\n+    VEC_safe_push (ce_s, heap, *results, &tmpc);\n \n-  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-    process_constraint (new_constraint (*lhsp, tmpc));\n-\n-  VEC_free (ce_s, heap, lhsc);\n+  /* May return addresses of globals.  */\n+  rhsc.var = nonlocal_id;\n+  rhsc.offset = 0;\n+  rhsc.type = ADDRESSOF;\n+  VEC_safe_push (ce_s, heap, *results, &rhsc);\n }\n \n /* For non-IPA mode, generate constraints necessary for a call to a\n    pure function in statement STMT.  */\n \n static void\n-handle_pure_call (gimple stmt)\n+handle_pure_call (gimple stmt, VEC(ce_s, heap) **results)\n {\n+  struct constraint_expr rhsc;\n   unsigned i;\n+  bool need_callused = false;\n \n   /* Memory reached from pointer arguments is call-used.  */\n   for (i = 0; i < gimple_call_num_args (stmt); ++i)\n     {\n       tree arg = gimple_call_arg (stmt, i);\n \n       if (could_have_pointers (arg))\n-\tmake_constraint_to (callused_id, arg);\n+\t{\n+\t  make_constraint_to (callused_id, arg);\n+\t  need_callused = true;\n+\t}\n     }\n \n   /* The static chain is used as well.  */\n   if (gimple_call_chain (stmt))\n-    make_constraint_to (callused_id, gimple_call_chain (stmt));\n-\n-  /* If the call returns a pointer it may point to reachable memory\n-     from the arguments.  Not so for malloc functions though.  */\n-  if (gimple_call_lhs (stmt)\n-      && could_have_pointers (gimple_call_lhs (stmt))\n-      && !(gimple_call_flags (stmt) & ECF_MALLOC))\n     {\n-      tree lhs = gimple_call_lhs (stmt);\n-      VEC(ce_s, heap) *lhsc = NULL;\n-      struct constraint_expr rhsc;\n-      struct constraint_expr *lhsp;\n-      unsigned j;\n-\n-      get_constraint_for (lhs, &lhsc);\n-\n-      /* If this is a nested function then it can return anything.  */\n-      if (gimple_call_chain (stmt))\n-\t{\n-\t  rhsc.var = anything_id;\n-\t  rhsc.offset = 0;\n-\t  rhsc.type = ADDRESSOF;\n-\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\t    process_constraint (new_constraint (*lhsp, rhsc));\n-\t  VEC_free (ce_s, heap, lhsc);\n-\t  return;\n-\t}\n+      make_constraint_to (callused_id, gimple_call_chain (stmt));\n+      need_callused = true;\n+    }\n \n-      /* Else just add the call-used memory here.  Escaped variables\n-         and globals will be dealt with in handle_lhs_call.  */\n+  /* Pure functions may return callused and escaped memory.  */\n+  if (need_callused)\n+    {\n       rhsc.var = callused_id;\n       rhsc.offset = 0;\n-      rhsc.type = ADDRESSOF;\n-      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\tprocess_constraint (new_constraint (*lhsp, rhsc));\n-      VEC_free (ce_s, heap, lhsc);\n+      rhsc.type = SCALAR;\n+      VEC_safe_push (ce_s, heap, *results, &rhsc);\n     }\n+  rhsc.var = escaped_id;\n+  rhsc.offset = 0;\n+  rhsc.type = ADDRESSOF;\n+  VEC_safe_push (ce_s, heap, *results, &rhsc);\n }\n \n /* Walk statement T setting up aliasing constraints according to the\n@@ -3743,33 +3739,28 @@ find_func_aliases (gimple origt)\n     {\n       if (!in_ipa_mode)\n \t{\n+\t  VEC(ce_s, heap) *rhsc = NULL;\n \t  int flags = gimple_call_flags (t);\n \n \t  /* Const functions can return their arguments and addresses\n \t     of global memory but not of escaped memory.  */\n-\t  if (flags & ECF_CONST)\n+\t  if (flags & (ECF_CONST|ECF_NOVOPS))\n \t    {\n \t      if (gimple_call_lhs (t)\n \t\t  && could_have_pointers (gimple_call_lhs (t)))\n-\t\thandle_const_call (t);\n+\t\thandle_const_call (t, &rhsc);\n \t    }\n \t  /* Pure functions can return addresses in and of memory\n \t     reachable from their arguments, but they are not an escape\n \t     point for reachable memory of their arguments.  */\n-\t  else if (flags & ECF_PURE)\n-\t    {\n-\t      handle_pure_call (t);\n-\t      if (gimple_call_lhs (t)\n-\t\t  && could_have_pointers (gimple_call_lhs (t)))\n-\t\thandle_lhs_call (gimple_call_lhs (t), flags);\n-\t    }\n+\t  else if (flags & (ECF_PURE|ECF_LOOPING_CONST_OR_PURE))\n+\t    handle_pure_call (t, &rhsc);\n \t  else\n-\t    {\n-\t      handle_rhs_call (t);\n-\t      if (gimple_call_lhs (t)\n-\t\t  && could_have_pointers (gimple_call_lhs (t)))\n-\t\thandle_lhs_call (gimple_call_lhs (t), flags);\n-\t    }\n+\t    handle_rhs_call (t, &rhsc);\n+\t  if (gimple_call_lhs (t)\n+\t      && could_have_pointers (gimple_call_lhs (t)))\n+\t    handle_lhs_call (gimple_call_lhs (t), flags, rhsc);\n+\t  VEC_free (ce_s, heap, rhsc);\n \t}\n       else\n \t{\n@@ -4925,9 +4916,10 @@ find_what_p_points_to (tree p)\n \t\t    pi->pt_null = 1;\n \t\t  else if (vi->id == anything_id\n \t\t\t   || vi->id == nonlocal_id\n-\t\t\t   || vi->id == escaped_id\n-\t\t\t   || vi->id == callused_id)\n+\t\t\t   || vi->id == escaped_id)\n \t\t    was_pt_anything = 1;\n+\t\t  else if (vi->id == callused_id)\n+\t\t    gcc_unreachable ();\n \t\t  else if (vi->id == readonly_id)\n \t\t    was_pt_anything = 1;\n \t\t  else if (vi->id == integer_id)"}]}