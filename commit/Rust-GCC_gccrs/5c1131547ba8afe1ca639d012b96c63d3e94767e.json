{"sha": "5c1131547ba8afe1ca639d012b96c63d3e94767e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMxMTMxNTQ3YmE4YWZlMWNhNjM5ZDAxMmI5NmM2M2QzZTk0NzY3ZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-05-21T23:47:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-05-21T23:47:29Z"}, "message": "decl.c (cxx_maybe_build_cleanup): Handle __attribute__((cleanup)).\n\n\t* decl.c (cxx_maybe_build_cleanup): Handle\n\t__attribute__((cleanup)).\n\t* g++.dg/ext/cleanup-1.C: New test.\n\t* g++.dg/ext/cleanup-2.C: Likewise.\n\t* g++.dg/ext/cleanup-3.C: Likewise.\n\t* g++.dg/ext/cleanup-4.C: Likewise.\n\t* g++.dg/ext/cleanup-5.C: Likewise.\n\t* g++.dg/ext/cleanup-6.C: Likewise.\n\t* g++.dg/ext/cleanup-8.C: Likewise.\n\t* g++.dg/ext/cleanup-9.C: Likewise.\n\t* g++.dg/ext/cleanup-10.C: Likewise.\n\t* g++.dg/ext/cleanup-11.C: Likewise.\n\t* g++.dg/ext/cleanup-dtor.C: Likewise.\n\nFrom-SVN: r124930", "tree": {"sha": "53be7e6a464964a2a2ab76a9407d12f76ef6def8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53be7e6a464964a2a2ab76a9407d12f76ef6def8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c1131547ba8afe1ca639d012b96c63d3e94767e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1131547ba8afe1ca639d012b96c63d3e94767e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c1131547ba8afe1ca639d012b96c63d3e94767e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1131547ba8afe1ca639d012b96c63d3e94767e/comments", "author": null, "committer": null, "parents": [{"sha": "0b4cafec04e60b7a06ee01ddc752c516ddb250c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4cafec04e60b7a06ee01ddc752c516ddb250c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4cafec04e60b7a06ee01ddc752c516ddb250c7"}], "stats": {"total": 758, "additions": 747, "deletions": 11}, "files": [{"sha": "e6b4f45db671f2f35013c6893a94c258196b39ad", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -1,3 +1,8 @@\n+2007-05-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (cxx_maybe_build_cleanup): Handle\n+\t__attribute__((cleanup)).\n+\n 2007-05-19  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \t* cvt.c (cp_convert_and_check): Don't check warnings if the"}, {"sha": "c76568a16f34379c4a83457d431a48328c32d006", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -11636,39 +11636,80 @@ complete_vars (tree type)\n   complete_type_check_abstract (type);\n }\n \n-/* If DECL is of a type which needs a cleanup, build that cleanup\n-   here.  */\n+/* If DECL is of a type which needs a cleanup, build and return an\n+   expression to perform that cleanup here.  Return NULL_TREE if no\n+   cleanup need be done.  */\n \n tree\n cxx_maybe_build_cleanup (tree decl)\n {\n-  tree type = TREE_TYPE (decl);\n+  tree type;\n+  tree attr;\n+  tree cleanup;\n+\n+  /* Assume no cleanup is required.  */\n+  cleanup = NULL_TREE;\n \n-  if (type != error_mark_node && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+  if (error_operand_p (decl))\n+    return cleanup;\n+\n+  /* Handle \"__attribute__((cleanup))\".  We run the cleanup function\n+     before the destructor since the destructor is what actually\n+     terminates the lifetime of the object.  */\n+  attr = lookup_attribute (\"cleanup\", DECL_ATTRIBUTES (decl));\n+  if (attr)\n+    {\n+      tree id;\n+      tree fn;\n+      tree arg;\n+\n+      /* Get the name specified by the user for the cleanup function.  */\n+      id = TREE_VALUE (TREE_VALUE (attr));\n+      /* Look up the name to find the cleanup function to call.  It is\n+\t important to use lookup_name here because that is what is\n+\t used in c-common.c:handle_cleanup_attribute when performing\n+\t initial checks on the attribute.  Note that those checks\n+\t include ensuring that the function found is not an overloaded\n+\t function, or an object with an overloaded call operator,\n+\t etc.; we can rely on the fact that the functionfound is an\n+\t ordinary FUNCTION_DECL.  */\n+      fn = lookup_name (id);\n+      arg = build_address (decl);\n+      mark_used (decl);\n+      cleanup = build_function_call (fn, build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t  arg));\n+    }\n+  /* Handle ordinary C++ destructors.  */\n+  type = TREE_TYPE (decl);\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n     {\n       int flags = LOOKUP_NORMAL|LOOKUP_DESTRUCTOR;\n-      tree rval;\n       bool has_vbases = (TREE_CODE (type) == RECORD_TYPE\n \t\t\t && CLASSTYPE_VBASECLASSES (type));\n+      tree addr;\n+      tree call;\n \n       if (TREE_CODE (type) == ARRAY_TYPE)\n-\trval = decl;\n+\taddr = decl;\n       else\n \t{\n \t  cxx_mark_addressable (decl);\n-\t  rval = build_unary_op (ADDR_EXPR, decl, 0);\n+\t  addr = build_unary_op (ADDR_EXPR, decl, 0);\n \t}\n \n       /* Optimize for space over speed here.  */\n       if (!has_vbases || flag_expensive_optimizations)\n \tflags |= LOOKUP_NONVIRTUAL;\n \n-      rval = build_delete (TREE_TYPE (rval), rval,\n+      call = build_delete (TREE_TYPE (addr), addr,\n \t\t\t   sfk_complete_destructor, flags, 0);\n-\n-      return rval;\n+      if (cleanup)\n+\tcleanup = build_compound_expr (cleanup, call);\n+      else\n+\tcleanup = call;\n     }\n-  return NULL_TREE;\n+\n+  return cleanup;\n }\n \f\n /* When a stmt has been parsed, this function is called.  */"}, {"sha": "c37b3439b8a7754fd06e4eed35b7fe20b0e1be76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -1,3 +1,17 @@\n+2007-05-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/ext/cleanup-1.C: New test.\n+\t* g++.dg/ext/cleanup-2.C: Likewise.\n+\t* g++.dg/ext/cleanup-3.C: Likewise.\n+\t* g++.dg/ext/cleanup-4.C: Likewise.\n+\t* g++.dg/ext/cleanup-5.C: Likewise.\n+\t* g++.dg/ext/cleanup-6.C: Likewise.\n+\t* g++.dg/ext/cleanup-8.C: Likewise.\n+\t* g++.dg/ext/cleanup-9.C: Likewise.\n+\t* g++.dg/ext/cleanup-10.C: Likewise.\n+\t* g++.dg/ext/cleanup-11.C: Likewise.\n+\t* g++.dg/ext/cleanup-dtor.C: Likewise.\n+\n 2007-05-21  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR middle-end/31995"}, {"sha": "383c64eb79fe5f4101feae430601ad45e662e440", "filename": "gcc/testsuite/g++.dg/ext/cleanup-1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-1.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wall\" } */\n+/* Validate expected warnings and errors.  */\n+\n+#define U\t__attribute__((unused))\n+#define C(x)\t__attribute__((cleanup(x)))\n+\n+static int f1(void *x U) { return 0; }\n+static void f2() { } /* { dg-error \"too many arguments\" } */\n+static void f3(void) { } /* { dg-error \"too many arguments\" } */\n+static void f4(void *x U) { }\n+static void f5(int *x U) { }\n+static void f6(double *x U) { }\n+static void f7(const int *x U) { }\n+static void f8(const int *x U, int y U) { } /* { dg-error \"too few arguments\" } */\n+static void f9(int x U) { }\n+\n+void test(void)\n+{\n+  int o1 C(f1);\n+  int o2 C(f2);         /* { dg-error \"at this point\" } */\n+  int o3 C(f3);\t\t/* { dg-error \"at this point\" } */\n+  int o4 C(f4);\n+  int o5 C(f5);\n+  int o6 C(f6);\t\t/* { dg-error \"cannot convert\" } */\n+  int o7 C(f7);\n+  int o8 C(f8);\t\t/* { dg-error \"at this point\" } */\n+  int o9 C(f9);\t\t/* { dg-error \"conversion\" } */\n+  int o10 U C(undef);\t/* { dg-error \"not a function\" } */\n+  int o11 U C(o1);\t/* { dg-error \"not a function\" } */\n+  int o12 U C(\"f1\");\t/* { dg-error \"not an identifier\" } */\n+  static int o13 U C(f1); /* { dg-warning \"attribute ignored\" } */\n+}\n+\n+int o14 C(f1);\t\t/* { dg-warning \"attribute ignored\" } */\n+void t15(int o U C(f1)) {} /* { dg-warning \"attribute ignored\" } */"}, {"sha": "c0c6971a3899d8330998edbedc3a0e404901016f", "filename": "gcc/testsuite/g++.dg/ext/cleanup-10.C", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-10.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do run { target hppa*-*-hpux* *-*-linux* powerpc*-*-darwin* } } */\n+/* { dg-options \"-fexceptions -fnon-call-exceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through signal frames\n+   on alternate stack.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <unistd.h>\n+#include <string.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc \n+    = (struct _Unwind_Exception *) malloc (sizeof (*exc));\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig, siginfo_t *info, void *ctx)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  stack_t ss;\n+  struct sigaction s;\n+\n+  ss.ss_size = 4 * sysconf (_SC_PAGESIZE);\n+  if (ss.ss_size < SIGSTKSZ)\n+    ss.ss_size = SIGSTKSZ;\n+  ss.ss_sp = malloc (ss.ss_size);\n+  if (ss.ss_sp == NULL)\n+    exit (1);\n+  ss.ss_flags = 0;\n+  if (sigaltstack (&ss, NULL) < 0)\n+    exit (1);\n+\n+  sigemptyset (&s.sa_mask);\n+  s.sa_sigaction = fn4;\n+  s.sa_flags = SA_RESETHAND | SA_ONSTACK;\n+  sigaction (SIGSEGV, &s, NULL);\n+  sigaction (SIGBUS, &s, NULL);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "06c65693c195815fbe12d50710f81f9fadf7d3e1", "filename": "gcc/testsuite/g++.dg/ext/cleanup-11.C", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-11.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do run { target hppa*-*-hpux* *-*-linux* powerpc*-*-darwin* } } */\n+/* { dg-options \"-fexceptions -fnon-call-exceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through realtime signal\n+   frames on alternate stack.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <unistd.h>\n+#include <string.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc \n+    = (struct _Unwind_Exception*) malloc (sizeof (*exc));\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig, siginfo_t *info, void *ctx)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  stack_t ss;\n+  struct sigaction s;\n+\n+  ss.ss_size = 4 * sysconf (_SC_PAGESIZE);\n+  if (ss.ss_size < SIGSTKSZ)\n+    ss.ss_size = SIGSTKSZ;\n+  ss.ss_sp = malloc (ss.ss_size);\n+  if (ss.ss_sp == NULL)\n+    exit (1);\n+  ss.ss_flags = 0;\n+  if (sigaltstack (&ss, NULL) < 0)\n+    exit (1);\n+\n+  sigemptyset (&s.sa_mask);\n+  s.sa_sigaction = fn4;\n+  s.sa_flags = SA_RESETHAND | SA_ONSTACK | SA_SIGINFO;\n+  sigaction (SIGSEGV, &s, NULL);\n+  sigaction (SIGBUS, &s, NULL);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "d9033b4542452bb90e21624b0919c4a90c09a7fa", "filename": "gcc/testsuite/g++.dg/ext/cleanup-2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-2.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify that cleanup works in the most basic of ways.  */\n+\n+extern \"C\" void exit(int);\n+extern \"C\" void abort(void);\n+\n+static void handler(void *p __attribute__((unused)))\n+{\n+  exit (0);\n+}\n+\n+static void doit(void)\n+{\n+  int x __attribute__((cleanup (handler)));\n+}\n+\n+int main()\n+{\n+  doit ();\n+  abort ();\n+}"}, {"sha": "5367c496e7ead9e8140dfd54256e15aa3a0510aa", "filename": "gcc/testsuite/g++.dg/ext/cleanup-3.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-3.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify that the cleanup handler receives the proper contents\n+   of the variable.  */\n+\n+extern \"C\" void exit(int);\n+extern \"C\" void abort(void);\n+\n+static int expected;\n+\n+static void\n+handler(int *p)\n+{\n+  if (*p != expected)\n+    abort ();\n+}\n+\n+static void __attribute__((noinline))\n+bar(void)\n+{\n+}\n+\n+static void doit(int x, int y)\n+{\n+  int r __attribute__((cleanup (handler)));\n+  if (x < y)\n+    {\n+      r = 0;\n+      return;\n+    }\n+\n+  bar();\n+  r = x + y;\n+}\n+\n+int main()\n+{\n+  expected = 0;\n+  doit (1, 2);\n+\n+  expected = 3;\n+  doit (2, 1);\n+\n+  return 0;\n+}"}, {"sha": "ae9a6e40f8bfbaebcf076dd3d1f0835f15da4371", "filename": "gcc/testsuite/g++.dg/ext/cleanup-4.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-4.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* Verify cleanup execution on non-trivial exit from a block.  */\n+\n+extern \"C\" void exit(int);\n+extern \"C\" void abort(void);\n+\n+static int counter;\n+\n+static void\n+handler(int *p)\n+{\n+  counter += *p;\n+}\n+\n+static void __attribute__((noinline))\n+bar(void)\n+{\n+}\n+\n+static void doit(int n, int n2)\n+{\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    {\n+      int dummy __attribute__((cleanup (handler))) = i;\n+      if (i == n2)\n+\tbreak;\n+      bar();\n+    }\n+}\n+\n+int main()\n+{\n+  doit (10, 6);\n+  if (counter != 0 + 1 + 2 + 3 + 4 + 5 + 6)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "db4c2bbc8cc7adf097fb7abff0bf43bd04876565", "filename": "gcc/testsuite/g++.dg/ext/cleanup-5.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-5.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,54 @@\n+/* HP-UX libunwind.so doesn't provide _UA_END_OF_STACK */\n+/* { dg-do run } */\n+/* { dg-options \"-fexceptions\" } */\n+/* { dg-skip-if \"\" { \"ia64-*-hpux11.*\" }  { \"*\" } { \"\" } } */\n+/* Verify that cleanups work with exception handling.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc \n+    = (struct _Unwind_Exception *) malloc (sizeof (*exc));\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  exit (0);\n+}\n+\n+static void doit ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  force_unwind ();\n+}\n+\n+int main()\n+{ \n+  doit ();\n+  abort ();\n+}"}, {"sha": "4e3d53893afc7d39f1335039f293f099e53c8023", "filename": "gcc/testsuite/g++.dg/ext/cleanup-6.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-6.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* Verify that a cleanup marked \"inline\" gets inlined.  */\n+\n+static inline void xyzzy(void *p __attribute__((unused)))\n+{\n+}\n+\n+void doit(void)\n+{\n+  int x __attribute__((cleanup (xyzzy)));\n+}\n+\n+/* { dg-final { scan-assembler-not \"xyzzy\" } } */"}, {"sha": "ece12e8125c94d6f8b9b8e15d5178cce8b057487", "filename": "gcc/testsuite/g++.dg/ext/cleanup-8.C", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-8.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,100 @@\n+/* { dg-do run { target hppa*-*-hpux* *-*-linux* powerpc*-*-darwin* } } */\n+/* { dg-options \"-fexceptions -fnon-call-exceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through signal\n+   frames.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <string.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc \n+    = (struct _Unwind_Exception *) malloc (sizeof (*exc));\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  signal (SIGSEGV, fn4);\n+  signal (SIGBUS, fn4);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "59a973505ae32bd140e994d906ec40d55def4167", "filename": "gcc/testsuite/g++.dg/ext/cleanup-9.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-9.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do run { target hppa*-*-hpux* *-*-linux* powerpc*-*-darwin* } } */\n+/* { dg-options \"-fexceptions -fnon-call-exceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through realtime\n+   signal frames.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <string.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc \n+    = (struct _Unwind_Exception *) malloc (sizeof (*exc));\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig, siginfo_t *info, void *ctx)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  struct sigaction s;\n+  sigemptyset (&s.sa_mask);\n+  s.sa_sigaction = fn4;\n+  s.sa_flags = SA_RESETHAND | SA_SIGINFO;\n+  sigaction (SIGSEGV, &s, NULL);\n+  sigaction (SIGBUS, &s, NULL);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "58da646704ba0d221484d662709348ac9e277be3", "filename": "gcc/testsuite/g++.dg/ext/cleanup-dtor.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-dtor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c1131547ba8afe1ca639d012b96c63d3e94767e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-dtor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fcleanup-dtor.C?ref=5c1131547ba8afe1ca639d012b96c63d3e94767e", "patch": "@@ -0,0 +1,28 @@\n+// Check that destructors are run after cleanup functions.\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+int i;\n+\n+struct S {\n+  ~S() {\n+    if (i != 1)\n+      abort ();\n+    i = 2;\n+  }\n+};\n+\n+void f(void *) {\n+  if (i != 0)\n+    abort ();\n+  i = 1;\n+}\n+\n+int main () {\n+  {\n+    S s __attribute__((cleanup (f)));\n+  }\n+  if (i != 2)\n+    abort ();\n+}"}]}