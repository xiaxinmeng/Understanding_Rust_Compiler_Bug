{"sha": "c0258754e4161f2603043d7dd17c397ce2a56d41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyNTg3NTRlNDE2MWYyNjAzMDQzZDdkZDE3YzM5N2NlMmE1NmQ0MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2012-10-23T20:33:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2012-10-23T20:33:49Z"}, "message": "re PR tree-optimization/54985 (dom optimization erroneous remove conditional goto.)\n\n        PR tree-optimization/54985\n        * tree-ssa-threadedge.c (cond_arg_set_in_bb): New function\n        * extracted\n        from thread_across_edge.\n        (thread_across_edge): Use it in all cases where we might thread\n        across a back edge.\n\n        * gcc.c-torture/execute/pr54985.c: New test.\n\nFrom-SVN: r192745", "tree": {"sha": "51b0fc7c3eb6fb713379ff7a3369def5e9535c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51b0fc7c3eb6fb713379ff7a3369def5e9535c04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0258754e4161f2603043d7dd17c397ce2a56d41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0258754e4161f2603043d7dd17c397ce2a56d41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0258754e4161f2603043d7dd17c397ce2a56d41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0258754e4161f2603043d7dd17c397ce2a56d41/comments", "author": null, "committer": null, "parents": [{"sha": "44b94bdb07afe93c07763c89e8b8ed025fbbd200", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b94bdb07afe93c07763c89e8b8ed025fbbd200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b94bdb07afe93c07763c89e8b8ed025fbbd200"}], "stats": {"total": 120, "additions": 101, "deletions": 19}, "files": [{"sha": "f75665e484ce89263e1bd03a246e8cf4761c8fe5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0258754e4161f2603043d7dd17c397ce2a56d41", "patch": "@@ -1,3 +1,11 @@\n+2012-10-23  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/54985\n+\t* tree-ssa-threadedge.c (cond_arg_set_in_bb): New function extracted\n+\tfrom thread_across_edge.\n+\t(thread_across_edge): Use it in all cases where we might thread\n+\tacross a back edge.\n+\n 2012-10-23  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra-constraints.c (update_ebb_live_info): Process empty blocks."}, {"sha": "b9bee3f32e490ab53af60ba9166725620ffe3269", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c0258754e4161f2603043d7dd17c397ce2a56d41", "patch": "@@ -1,3 +1,7 @@\n+2012-10-23  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.c-torture/execute/pr54985.c: New test.\n+\n 2012-10-23  Paul Koning  <ni1d@arrl.net>\n \n \tPR debug/54508"}, {"sha": "678c9f47ae735c86678113cef6bc51f67c295e52", "filename": "gcc/testsuite/gcc.c-torture/execute/pr54985.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr54985.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr54985.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr54985.c?ref=c0258754e4161f2603043d7dd17c397ce2a56d41", "patch": "@@ -0,0 +1,36 @@\n+\n+typedef struct st {\n+    int a;\n+} ST;\n+\n+int __attribute__((noinline,noclone))\n+foo(ST *s, int c)\n+{\n+  int first = 1;\n+  int count = c;\n+  ST *item = s;\n+  int a = s->a;\n+  int x;\n+\n+  while (count--)\n+    {\n+      x = item->a;\n+      if (first)\n+        first = 0;\n+      else if (x >= a)\n+        return 1;\n+      a = x;\n+      item++;\n+    }\n+  return 0;\n+}\n+\n+extern void abort (void);\n+\n+int main ()\n+{\n+  ST _1[2] = {{2}, {1}};\n+  if (foo(_1, 2) != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "1ffacae7cb09754fdaacfaf16d9a904602ac5cef", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0258754e4161f2603043d7dd17c397ce2a56d41/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c0258754e4161f2603043d7dd17c397ce2a56d41", "patch": "@@ -572,6 +572,44 @@ simplify_control_stmt_condition (edge e,\n   return cached_lhs;\n }\n \n+/* Return TRUE if the statement at the end of e->dest depends on\n+   the output of any statement in BB.   Otherwise return FALSE.\n+\n+   This is used when we are threading a backedge and need to ensure\n+   that temporary equivalences from BB do not affect the condition\n+   in e->dest.  */\n+\n+static bool\n+cond_arg_set_in_bb (edge e, basic_block bb, int n)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  gimple last = gsi_stmt (gsi_last_bb (e->dest));\n+\n+  /* E->dest does not have to end with a control transferring\n+     instruction.  This can occurr when we try to extend a jump\n+     threading opportunity deeper into the CFG.  In that case\n+     it is safe for this check to return false.  */\n+  if (!last)\n+    return false;\n+\n+  if (gimple_code (last) != GIMPLE_COND\n+      && gimple_code (last) != GIMPLE_GOTO\n+      && gimple_code (last) != GIMPLE_SWITCH)\n+    return false;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, last, iter, SSA_OP_USE | SSA_OP_VUSE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+\n+      if (TREE_CODE (use) == SSA_NAME\n+\t  && gimple_code (SSA_NAME_DEF_STMT (use)) != GIMPLE_PHI\n+\t  && gimple_bb (SSA_NAME_DEF_STMT (use)) == bb)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* TAKEN_EDGE represents the an edge taken as a result of jump threading.\n    See if we can thread around TAKEN_EDGE->dest as well.  If so, return\n    the edge out of TAKEN_EDGE->dest that we can statically compute will be\n@@ -705,19 +743,8 @@ thread_across_edge (gimple dummy_cond,\n      safe to thread this edge.  */\n   if (e->flags & EDGE_DFS_BACK)\n     {\n-      ssa_op_iter iter;\n-      use_operand_p use_p;\n-      gimple last = gsi_stmt (gsi_last_bb (e->dest));\n-\n-      FOR_EACH_SSA_USE_OPERAND (use_p, last, iter, SSA_OP_USE | SSA_OP_VUSE)\n-\t{\n-\t  tree use = USE_FROM_PTR (use_p);\n-\n-          if (TREE_CODE (use) == SSA_NAME\n-\t      && gimple_code (SSA_NAME_DEF_STMT (use)) != GIMPLE_PHI\n-\t      && gimple_bb (SSA_NAME_DEF_STMT (use)) == e->dest)\n-\t    goto fail;\n-\t}\n+      if (cond_arg_set_in_bb (e, e->dest, 1))\n+\tgoto fail;\n     }\n \n   stmt_count = 0;\n@@ -758,7 +785,9 @@ thread_across_edge (gimple dummy_cond,\n \t     address.  If DEST is not null, then see if we can thread\n \t     through it as well, this helps capture secondary effects\n \t     of threading without having to re-run DOM or VRP.  */\n-\t  if (dest)\n+\t  if (dest\n+\t      && ((e->flags & EDGE_DFS_BACK) == 0\n+\t\t  || ! cond_arg_set_in_bb (taken_edge, e->dest, 2)))\n \t    {\n \t      /* We don't want to thread back to a block we have already\n  \t\t visited.  This may be overly conservative.  */\n@@ -816,11 +845,16 @@ thread_across_edge (gimple dummy_cond,\n \te3 = taken_edge;\n \tdo\n \t  {\n-\t    e2 = thread_around_empty_block (e3,\n-\t\t\t\t            dummy_cond,\n-\t\t\t\t            handle_dominating_asserts,\n-\t\t\t\t            simplify,\n-\t\t\t\t            visited);\n+\t    if ((e->flags & EDGE_DFS_BACK) == 0\n+\t\t|| ! cond_arg_set_in_bb (e3, e->dest, 3))\n+\t      e2 = thread_around_empty_block (e3,\n+\t\t\t\t\t      dummy_cond,\n+\t\t\t\t\t      handle_dominating_asserts,\n+\t\t\t\t\t      simplify,\n+\t\t\t\t\t      visited);\n+\t    else\n+\t      e2 = NULL;\n+\n \t    if (e2)\n \t      {\n \t        e3 = e2;"}]}