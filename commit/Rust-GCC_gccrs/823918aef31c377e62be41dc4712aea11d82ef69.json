{"sha": "823918aef31c377e62be41dc4712aea11d82ef69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzOTE4YWVmMzFjMzc3ZTYyYmU0MWRjNDcxMmFlYTExZDgyZWY2OQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-04-07T08:35:23Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-04-07T08:35:23Z"}, "message": "re PR target/43920 (Choosing conditional execution over conditional branches for code size in some cases.)\n\n2011-04-07  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/43920\n\t* cfgcleanup.c (walk_to_nondebug_insn): New function.\n\t(flow_find_cross_jump): Use walk_to_nondebug_insn.  Recalculate bb1 and\n\tbb2.\n\t(try_crossjump_to_edge): Handle case that newpos1 or newpos2 is not src1\n\tor src2.  Redirect edges to the last basic block.  Update frequency and\n\tcount on multiple basic blocks in case of fallthru.\n\nFrom-SVN: r172091", "tree": {"sha": "0d6feadff61e87b1d3b25cad1e195ea520028364", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d6feadff61e87b1d3b25cad1e195ea520028364"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/823918aef31c377e62be41dc4712aea11d82ef69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823918aef31c377e62be41dc4712aea11d82ef69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/823918aef31c377e62be41dc4712aea11d82ef69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823918aef31c377e62be41dc4712aea11d82ef69/comments", "author": null, "committer": null, "parents": [{"sha": "472c95f5af0a86d073d305c2328acac19dd784bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/472c95f5af0a86d073d305c2328acac19dd784bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/472c95f5af0a86d073d305c2328acac19dd784bc"}], "stats": {"total": 126, "additions": 108, "deletions": 18}, "files": [{"sha": "8594a76907644bf3a7c8d42914122e12f5429e76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823918aef31c377e62be41dc4712aea11d82ef69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823918aef31c377e62be41dc4712aea11d82ef69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=823918aef31c377e62be41dc4712aea11d82ef69", "patch": "@@ -1,3 +1,13 @@\n+2011-04-07  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/43920\n+\t* cfgcleanup.c (walk_to_nondebug_insn): New function.\n+\t(flow_find_cross_jump): Use walk_to_nondebug_insn.  Recalculate bb1 and\n+\tbb2.\n+\t(try_crossjump_to_edge): Handle case that newpos1 or newpos2 is not src1\n+\tor src2.  Redirect edges to the last basic block.  Update frequency and\n+\tcount on multiple basic blocks in case of fallthru.\n+\n 2011-04-07  Tom de Vries  <tom@codesourcery.com>\n \n \tPR target/43920"}, {"sha": "27af12f6437d8c49b0a1909a14ce3f61356e315c", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 98, "deletions": 18, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823918aef31c377e62be41dc4712aea11d82ef69/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823918aef31c377e62be41dc4712aea11d82ef69/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=823918aef31c377e62be41dc4712aea11d82ef69", "patch": "@@ -1174,6 +1174,43 @@ merge_notes (rtx i1, rtx i2)\n     }\n }\n \n+ /* Walks from I1 in BB1 backward till the next non-debug insn, and returns the\n+    resulting insn in I1, and the corresponding bb in BB1.  At the head of a\n+    bb, if there is a predecessor bb that reaches this bb via fallthru, and\n+    FOLLOW_FALLTHRU, walks further in the predecessor bb and registers this in\n+    DID_FALLTHRU.  Otherwise, stops at the head of the bb.  */\n+\n+static void\n+walk_to_nondebug_insn (rtx *i1, basic_block *bb1, bool follow_fallthru,\n+                       bool *did_fallthru)\n+{\n+  edge fallthru;\n+\n+  *did_fallthru = false;\n+\n+  /* Ignore notes.  */\n+  while (!NONDEBUG_INSN_P (*i1))\n+    {\n+      if (*i1 != BB_HEAD (*bb1))\n+        {\n+          *i1 = PREV_INSN (*i1);\n+          continue;\n+        }\n+\n+      if (!follow_fallthru)\n+        return;\n+\n+      fallthru = find_fallthru_edge ((*bb1)->preds);\n+      if (!fallthru || fallthru->src == ENTRY_BLOCK_PTR_FOR_FUNCTION (cfun)\n+          || !single_succ_p (fallthru->src))\n+        return;\n+\n+      *bb1 = fallthru->src;\n+      *i1 = BB_END (*bb1);\n+      *did_fallthru = true;\n+     }\n+}\n+\n /* Look through the insns at the end of BB1 and BB2 and find the longest\n    sequence that are either equivalent, or allow forward or backward\n    replacement.  Store the first insns for that sequence in *F1 and *F2 and\n@@ -1194,6 +1231,7 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n   int ninsns = 0;\n   rtx p1;\n   enum replace_direction dir, last_dir, afterlast_dir;\n+  bool follow_fallthru, did_fallthru;\n \n   if (dir_p)\n     dir = *dir_p;\n@@ -1227,12 +1265,31 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n \n   while (true)\n     {\n-      /* Ignore notes.  */\n-      while (!NONDEBUG_INSN_P (i1) && i1 != BB_HEAD (bb1))\n-\ti1 = PREV_INSN (i1);\n-\n-      while (!NONDEBUG_INSN_P (i2) && i2 != BB_HEAD (bb2))\n-\ti2 = PREV_INSN (i2);\n+      /* In the following example, we can replace all jumps to C by jumps to A.\n+\n+         This removes 4 duplicate insns.\n+         [bb A] insn1            [bb C] insn1\n+                insn2                   insn2\n+         [bb B] insn3                   insn3\n+                insn4                   insn4\n+                jump_insn               jump_insn\n+\n+         We could also replace all jumps to A by jumps to C, but that leaves B\n+         alive, and removes only 2 duplicate insns.  In a subsequent crossjump\n+         step, all jumps to B would be replaced with jumps to the middle of C,\n+         achieving the same result with more effort.\n+         So we allow only the first possibility, which means that we don't allow\n+         fallthru in the block that's being replaced.  */\n+\n+      follow_fallthru = dir_p && dir != dir_forward;\n+      walk_to_nondebug_insn (&i1, &bb1, follow_fallthru, &did_fallthru);\n+      if (did_fallthru)\n+        dir = dir_backward;\n+\n+      follow_fallthru = dir_p && dir != dir_backward;\n+      walk_to_nondebug_insn (&i2, &bb2, follow_fallthru, &did_fallthru);\n+      if (did_fallthru)\n+        dir = dir_forward;\n \n       if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n \tbreak;\n@@ -1273,12 +1330,14 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n      Two, it keeps line number notes as matched as may be.  */\n   if (ninsns)\n     {\n+      bb1 = BLOCK_FOR_INSN (last1);\n       while (last1 != BB_HEAD (bb1) && !NONDEBUG_INSN_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n       if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n \tlast1 = PREV_INSN (last1);\n \n+      bb2 = BLOCK_FOR_INSN (last2);\n       while (last2 != BB_HEAD (bb2) && !NONDEBUG_INSN_P (PREV_INSN (last2)))\n \tlast2 = PREV_INSN (last2);\n \n@@ -1710,6 +1769,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   int nmatch;\n   basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to, redirect_from, to_remove;\n+  basic_block osrc1, osrc2, redirect_edges_to, tmp;\n   enum replace_direction dir;\n   rtx newpos1, newpos2;\n   edge s;\n@@ -1769,6 +1829,13 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   dir = dir_forward;\n   nmatch = flow_find_cross_jump (src1, src2, &newpos1, &newpos2, &dir);\n \n+  osrc1 = src1;\n+  osrc2 = src2;\n+  if (newpos1 != NULL_RTX)\n+    src1 = BLOCK_FOR_INSN (newpos1);\n+  if (newpos2 != NULL_RTX)\n+    src2 = BLOCK_FOR_INSN (newpos2);\n+\n   /* Don't proceed with the crossjump unless we found a sufficient number\n      of matching instructions or the 'from' block was totally matched\n      (such that its predecessors will hopefully be redirected and the\n@@ -1791,8 +1858,8 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n       rtx label1, label2;\n       rtx table1, table2;\n \n-      if (tablejump_p (BB_END (src1), &label1, &table1)\n-\t  && tablejump_p (BB_END (src2), &label2, &table2)\n+      if (tablejump_p (BB_END (osrc1), &label1, &table1)\n+\t  && tablejump_p (BB_END (osrc2), &label2, &table2)\n \t  && label1 != label2)\n \t{\n \t  replace_label_data rr;\n@@ -1807,7 +1874,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \t      /* Do not replace the label in SRC1->END because when deleting\n \t\t a block whose end is a tablejump, the tablejump referenced\n \t\t from the instruction is deleted too.  */\n-\t      if (insn != BB_END (src1))\n+\t      if (insn != BB_END (osrc1))\n \t\tfor_each_rtx (&insn, replace_label, &rr);\n \t    }\n \t}\n@@ -1848,8 +1915,13 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   /* We may have some registers visible through the block.  */\n   df_set_bb_dirty (redirect_to);\n \n+  if (osrc2 == src2)\n+    redirect_edges_to = redirect_to;\n+  else\n+    redirect_edges_to = osrc2;\n+\n   /* Recompute the frequencies and counts of outgoing edges.  */\n-  FOR_EACH_EDGE (s, ei, redirect_to->succs)\n+  FOR_EACH_EDGE (s, ei, redirect_edges_to->succs)\n     {\n       edge s2;\n       edge_iterator ei;\n@@ -1892,24 +1964,32 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \t    s2->dest->count = 0;\n \t}\n \n-      if (!redirect_to->frequency && !src1->frequency)\n+      if (!redirect_edges_to->frequency && !src1->frequency)\n \ts->probability = (s->probability + s2->probability) / 2;\n       else\n \ts->probability\n-\t  = ((s->probability * redirect_to->frequency +\n+\t  = ((s->probability * redirect_edges_to->frequency +\n \t      s2->probability * src1->frequency)\n-\t     / (redirect_to->frequency + src1->frequency));\n+\t     / (redirect_edges_to->frequency + src1->frequency));\n     }\n \n   /* Adjust count and frequency for the block.  An earlier jump\n      threading pass may have left the profile in an inconsistent\n      state (see update_bb_profile_for_threading) so we must be\n      prepared for overflows.  */\n-  redirect_to->count += src1->count;\n-  redirect_to->frequency += src1->frequency;\n-  if (redirect_to->frequency > BB_FREQ_MAX)\n-    redirect_to->frequency = BB_FREQ_MAX;\n-  update_br_prob_note (redirect_to);\n+  tmp = redirect_to;\n+  do\n+    {\n+      tmp->count += src1->count;\n+      tmp->frequency += src1->frequency;\n+      if (tmp->frequency > BB_FREQ_MAX)\n+        tmp->frequency = BB_FREQ_MAX;\n+      if (tmp == redirect_edges_to)\n+        break;\n+      tmp = find_fallthru_edge (tmp->succs)->dest;\n+    }\n+  while (true);\n+  update_br_prob_note (redirect_edges_to);\n \n   /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n "}]}