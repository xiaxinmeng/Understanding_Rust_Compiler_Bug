{"sha": "9839edf18db53d249327cd6cc128112684d13dfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgzOWVkZjE4ZGI1M2QyNDkzMjdjZDZjYzEyODExMjY4NGQxM2RmZA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2004-06-11T22:46:13Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2004-06-11T22:46:13Z"}, "message": "pa.c (legitimize_pic_address): Use UNSPEC_DLTIND14R to identify unspec used for loading address from DLT.\n\n\t* pa.c (legitimize_pic_address): Use UNSPEC_DLTIND14R to identify\n\tunspec used for loading address from DLT.\n\t* pa.md: Define constants for the uses of UNSPEC and UNSPEC_VOLATILE.\n\tChange all users of UNSPEC and UNSPEC_VOLATILE to use new constants.\n\tDon't use short code sequence when loading the address of a nonlocal\n\tlabel.\n\t(nonlocal_goto): New expander.\n\t(indirect_goto): New jump pattern for nonlocal gotos.\n\t(short_jump): Remove extra whitespace.\n\t(builtin_longjmp): Clobber memory and hard frame pointer.  Restore\n\tframe pointer via virtual_stack_vars_rtx when we have a nonlocal goto\n\tpattern.\n\nFrom-SVN: r83003", "tree": {"sha": "61765660ea4d945b17b61247dbb88c2dbe551fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61765660ea4d945b17b61247dbb88c2dbe551fa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9839edf18db53d249327cd6cc128112684d13dfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839edf18db53d249327cd6cc128112684d13dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9839edf18db53d249327cd6cc128112684d13dfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839edf18db53d249327cd6cc128112684d13dfd/comments", "author": null, "committer": null, "parents": [{"sha": "41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41c64ac01272bd3fca0486e618bd1d1ea14a76bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41c64ac01272bd3fca0486e618bd1d1ea14a76bd"}], "stats": {"total": 134, "additions": 122, "deletions": 12}, "files": [{"sha": "0a29cd904e6c8649b8fc25221e23866f38e38f45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839edf18db53d249327cd6cc128112684d13dfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839edf18db53d249327cd6cc128112684d13dfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9839edf18db53d249327cd6cc128112684d13dfd", "patch": "@@ -1,3 +1,18 @@\n+2004-06-11  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa.c (legitimize_pic_address): Use UNSPEC_DLTIND14R to identify\n+\tunspec used for loading address from DLT.\n+\t* pa.md: Define constants for the uses of UNSPEC and UNSPEC_VOLATILE.\n+\tChange all users of UNSPEC and UNSPEC_VOLATILE to use new constants.\n+\tDon't use short code sequence when loading the address of a nonlocal\n+\tlabel.\n+\t(nonlocal_goto): New expander.\n+\t(indirect_goto): New jump pattern for nonlocal gotos.\n+\t(short_jump): Remove extra whitespace.\n+\t(builtin_longjmp): Clobber memory and hard frame pointer.  Restore\n+\tframe pointer via virtual_stack_vars_rtx when we have a nonlocal goto\n+\tpattern.\n+\n 2004-06-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* expmed.c (synth_mult): Add an additional MODE argument for the"}, {"sha": "54030a23832786cb16198f3a6328b192cb206194", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839edf18db53d249327cd6cc128112684d13dfd/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839edf18db53d249327cd6cc128112684d13dfd/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=9839edf18db53d249327cd6cc128112684d13dfd", "patch": "@@ -904,7 +904,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t       gen_rtx_LO_SUM (Pmode, tmp_reg,\n \t\t\t\t       gen_rtx_UNSPEC (Pmode,\n \t\t\t\t\t\t       gen_rtvec (1, orig),\n-\t\t\t\t\t\t       0)));\n+\t\t\t\t\t\t       UNSPEC_DLTIND14R)));\n \n       current_function_uses_pic_offset_table = 1;\n       MEM_NOTRAP_P (pic_ref) = 1;"}, {"sha": "23e5d5130783c3607f0befe3a821242e4ef9f409", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 106, "deletions": 11, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839edf18db53d249327cd6cc128112684d13dfd/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839edf18db53d249327cd6cc128112684d13dfd/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=9839edf18db53d249327cd6cc128112684d13dfd", "patch": "@@ -26,6 +26,25 @@\n \n ;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n+;; Uses of UNSPEC in this file:\n+\n+(define_constants\n+  [(UNSPEC_CFFC\t\t0)\t; canonicalize_funcptr_for_compare\n+   (UNSPEC_GOTO\t\t1)\t; indirect_goto\n+   (UNSPEC_DLTIND14R\t2)\t; \n+  ])\n+\n+;; UNSPEC_VOLATILE:\n+\n+(define_constants\n+  [(UNSPECV_BLOCKAGE\t0)\t; blockage\n+   (UNSPECV_DCACHE\t1)\t; dcacheflush\n+   (UNSPECV_ICACHE\t2)\t; icacheflush\n+   (UNSPECV_OPC\t\t3)\t; outline_prologue_call\n+   (UNSPECV_OEC\t\t4)\t; outline_epilogue_call\n+   (UNSPECV_LONGJMP\t5)\t; builtin_longjmp\n+  ])\n+\n ;; Insn type.  Used to default other attribute values.\n \n ;; type \"unary\" insns have one input operand (1) and one output operand (0)\n@@ -2632,6 +2651,7 @@\n   /* If we're trying to load the address of a label that happens to be\n      close, then we can use a shorter sequence.  */\n   if (GET_CODE (operands[1]) == LABEL_REF\n+      && !LABEL_REF_NONLOCAL_P (operands[1])\n       && INSN_ADDRESSES_SET_P ()\n       && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))\n \t        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)\n@@ -2666,6 +2686,7 @@\n   /* If we're trying to load the address of a label that happens to be\n      close, then we can use a shorter sequence.  */\n   if (GET_CODE (operands[1]) == LABEL_REF\n+      && !LABEL_REF_NONLOCAL_P (operands[1])\n       && INSN_ADDRESSES_SET_P ()\n       && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))\n \t        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)\n@@ -6787,7 +6808,7 @@\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 2)] 0)]\n+  [(unspec_volatile [(const_int 2)] UNSPECV_BLOCKAGE)]\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n@@ -6828,6 +6849,62 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n+;;; An indirect jump can be optimized to a direct jump.  GAS for the\n+;;; SOM target doesn't allow branching to a label inside a function.\n+;;; We also don't correctly compute branch distances for labels\n+;;; outside the current function.  Thus, we use an indirect jump can't\n+;;; be optimized to a direct jump for all targets.  We assume that\n+;;; the branch target is in the same space (i.e., nested function\n+;;; jumping to a label in an outer function in the same translation\n+;;; unit).\n+(define_expand \"nonlocal_goto\"\n+  [(use (match_operand 0 \"general_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))\n+   (use (match_operand 2 \"general_operand\" \"\"))\n+   (use (match_operand 3 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  rtx lab = operands[1];\n+  rtx stack = operands[2];\n+  rtx fp = operands[3];\n+\n+  lab = copy_to_reg (lab);\n+\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t      gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t   gen_rtx_SCRATCH (VOIDmode))));\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t      gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t   hard_frame_pointer_rtx)));\n+\n+  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved\n+     instead of the hard_frame_pointer_rtx in the save area.  As a\n+     result, an extra instruction is needed to adjust for the offset\n+     of the virtual stack variables and the frame pointer.  */\n+  if (GET_CODE (fp) != REG)\n+    fp = force_reg (Pmode, fp);\n+  emit_move_insn (virtual_stack_vars_rtx, fp);\n+\n+  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+\n+  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\n+  /* Nonlocal goto jumps are only used between functions in the same\n+     translation unit.  Thus, we can avoid the extra overhead of an\n+     interspace jump.  */\n+  emit_jump_insn (gen_indirect_goto (lab));\n+  emit_barrier ();\n+  DONE;\n+})\n+\n+(define_insn \"indirect_goto\"\n+  [(unspec [(match_operand 0 \"register_operand\" \"=r\")] UNSPEC_GOTO)]\n+  \"GET_MODE (operands[0]) == word_mode\"\n+  \"bv%* %%r0(%0)\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4\")])\n+\n ;;; This jump is used in branch tables where the insn length is fixed.\n ;;; The length of this insn is adjusted if the delay slot is not filled.\n (define_insn \"short_jump\"\n@@ -8248,7 +8325,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   [(set (pc) (match_operand 0 \"pmode_register_operand\" \"a\"))\n   (clobber (reg:SI 2))]\n   \"!TARGET_64BIT\"\n-  \"ldsid (%%sr0,%0),%%r2\\; mtsp %%r2,%%sr0\\; be%* 0(%%sr0,%0)\"\n+  \"ldsid (%%sr0,%0),%%r2\\;mtsp %%r2,%%sr0\\;be%* 0(%%sr0,%0)\"\n    [(set_attr \"type\" \"branch\")\n     (set_attr \"length\" \"12\")])\n \n@@ -8261,7 +8338,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n     (set_attr \"length\" \"4\")])\n \n (define_expand \"builtin_longjmp\"\n-  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] 3)]\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] UNSPECV_LONGJMP)]\n   \"\"\n   \"\n {\n@@ -8273,8 +8350,26 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t\t\t   (POINTER_SIZE * 2) / BITS_PER_UNIT));\n   rtx pv = gen_rtx_REG (Pmode, 1);\n \n+  emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t      gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t   gen_rtx_SCRATCH (VOIDmode))));\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t      gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t   hard_frame_pointer_rtx)));\n+\n+  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved\n+     instead of the hard_frame_pointer_rtx in the save area.  We need\n+     to adjust for the offset between these two values when we have\n+     a nonlocal_goto pattern.  When we don't have a nonlocal_goto\n+     pattern, the receiver performs the adjustment.  */\n+#ifdef HAVE_nonlocal_goto\n+  if (HAVE_nonlocal_goto)\n+    emit_move_insn (virtual_stack_vars_rtx, force_reg (Pmode, fp));\n+  else\n+#endif\n+    emit_move_insn (hard_frame_pointer_rtx, fp);\n+\n   /* This bit is the same as expand_builtin_longjmp.  */\n-  emit_move_insn (hard_frame_pointer_rtx, fp);\n   emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n   emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n@@ -8959,7 +9054,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; Operands 3 and 4 (icacheflush) are clobbered scratch registers.\n (define_insn \"dcacheflush\"\n   [(const_int 1)\n-   (unspec_volatile [(mem:BLK (scratch))] 0)\n+   (unspec_volatile [(mem:BLK (scratch))] UNSPECV_DCACHE)\n    (use (match_operand 0 \"pmode_register_operand\" \"r\"))\n    (use (match_operand 1 \"pmode_register_operand\" \"r\"))\n    (use (match_operand 2 \"pmode_register_operand\" \"r\"))\n@@ -8977,7 +9072,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n (define_insn \"icacheflush\"\n   [(const_int 2)\n-   (unspec_volatile [(mem:BLK (scratch))] 0)\n+   (unspec_volatile [(mem:BLK (scratch))] UNSPECV_ICACHE)\n    (use (match_operand 0 \"pmode_register_operand\" \"r\"))\n    (use (match_operand 1 \"pmode_register_operand\" \"r\"))\n    (use (match_operand 2 \"pmode_register_operand\" \"r\"))\n@@ -8997,7 +9092,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n ;; An out-of-line prologue.\n (define_insn \"outline_prologue_call\"\n-  [(unspec_volatile [(const_int 0)] 0)\n+  [(unspec_volatile [(const_int 0)] UNSPECV_OPC)\n    (clobber (reg:SI 31))\n    (clobber (reg:SI 22))\n    (clobber (reg:SI 21))\n@@ -9047,7 +9142,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n ;; An out-of-line epilogue.\n (define_insn \"outline_epilogue_call\"\n-  [(unspec_volatile [(const_int 1)] 0)\n+  [(unspec_volatile [(const_int 1)] UNSPECV_OEC)\n    (use (reg:SI 29))\n    (use (reg:SI 28))\n    (clobber (reg:SI 31))\n@@ -9106,7 +9201,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; reliably compared to another function pointer.  */\n (define_expand \"canonicalize_funcptr_for_compare\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"register_operand\" \"\"))\n-   (parallel [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] 0))\n+   (parallel [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] UNSPEC_CFFC))\n \t      (clobber (match_dup 2))\n \t      (clobber (reg:SI 26))\n \t      (clobber (reg:SI 22))\n@@ -9136,8 +9231,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n     }\n }\")\n \n-(define_insn \"\"\n-  [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] 0))\n+(define_insn \"*$$sh_func_adrs\"\n+  [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] UNSPEC_CFFC))\n    (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n    (clobber (reg:SI 26))\n    (clobber (reg:SI 22))"}]}