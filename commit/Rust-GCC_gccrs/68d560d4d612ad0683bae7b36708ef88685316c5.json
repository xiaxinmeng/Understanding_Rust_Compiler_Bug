{"sha": "68d560d4d612ad0683bae7b36708ef88685316c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhkNTYwZDRkNjEyYWQwNjgzYmFlN2IzNjcwOGVmODg2ODUzMTZjNQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-06-25T10:42:21Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-06-25T10:42:21Z"}, "message": "arm.c (arm_arch4t): New variable.\n\n* arm.c (arm_arch4t): New variable.\n(arm_override_options): Initialize it.  If compiling for armv5 or\nhigher clear TARGET_INTERWORK.\n(output_call): Abort if called for armv5.  Use BX if it's available.\n(output_call_mem): Use BLX if available and ensure that all armv5\ncode is interworking safe.\n(output_return_instruction): Always use BX in preference to MOV if\nit's available.\n(arm_output_epilogue): Likewise.\n(arm_final_prescan_insn): Never conditionally call a subroutine\non armv5.\n* arm.h (arm_arch4t): Declare.\n* arm.md (call_reg_armv5, call_value_reg_armv5): New.\n(call_reg_arm, call_value_reg_arm): Renamed from call_reg and\ncall_value_reg respectively.\n(call_reg_thumb_v5, call_value_reg_thumb_v5): New.\n(call_reg_thumb, call_value_reg_thumb): Renamed from call_indirect\nand call_value_indirect respectively.\n\nFrom-SVN: r83647", "tree": {"sha": "7fbbce5dce641445636037d4f40a6ff09f75b128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fbbce5dce641445636037d4f40a6ff09f75b128"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68d560d4d612ad0683bae7b36708ef88685316c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d560d4d612ad0683bae7b36708ef88685316c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68d560d4d612ad0683bae7b36708ef88685316c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68d560d4d612ad0683bae7b36708ef88685316c5/comments", "author": null, "committer": null, "parents": [{"sha": "576df3214c16163b65f82064f035fd375d0c02aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576df3214c16163b65f82064f035fd375d0c02aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576df3214c16163b65f82064f035fd375d0c02aa"}], "stats": {"total": 166, "additions": 133, "deletions": 33}, "files": [{"sha": "343d785ed6b5d00712c2eb3e1b3f9b1730babc3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68d560d4d612ad0683bae7b36708ef88685316c5", "patch": "@@ -1,3 +1,24 @@\n+2004-06-25  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_arch4t): New variable.\n+\t(arm_override_options): Initialize it.  If compiling for armv5 or\n+\thigher clear TARGET_INTERWORK.\n+\t(output_call): Abort if called for armv5.  Use BX if it's available.\n+\t(output_call_mem): Use BLX if available and ensure that all armv5\n+\tcode is interworking safe.\n+\t(output_return_instruction): Always use BX in preference to MOV if\n+\tit's available.\n+\t(arm_output_epilogue): Likewise.\n+\t(arm_final_prescan_insn): Never conditionally call a subroutine\n+\ton armv5.\n+\t* arm.h (arm_arch4t): Declare.\n+\t* arm.md (call_reg_armv5, call_value_reg_armv5): New.\n+\t(call_reg_arm, call_value_reg_arm): Renamed from call_reg and \n+\tcall_value_reg respectively.\n+\t(call_reg_thumb_v5, call_value_reg_thumb_v5): New.\n+\t(call_reg_thumb, call_value_reg_thumb): Renamed from call_indirect\n+\tand call_value_indirect respectively.\n+\n 2004-06-25  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (reg_or_const_float_1_operand): Reimplement"}, {"sha": "e1b5be2e9a295d361cd68fec7cf6922014b74f01", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=68d560d4d612ad0683bae7b36708ef88685316c5", "patch": "@@ -366,6 +366,9 @@ int arm_arch3m = 0;\n /* Nonzero if this chip supports the ARM Architecture 4 extensions.  */\n int arm_arch4 = 0;\n \n+/* Nonzero if this chip supports the ARM Architecture 4t extensions.  */\n+int arm_arch4t = 0;\n+\n /* Nonzero if this chip supports the ARM Architecture 5 extensions.  */\n int arm_arch5 = 0;\n \n@@ -802,6 +805,7 @@ arm_override_options (void)\n   /* Initialize boolean versions of the flags, for use in the arm.md file.  */\n   arm_arch3m = (insn_flags & FL_ARCH3M) != 0;\n   arm_arch4 = (insn_flags & FL_ARCH4) != 0;\n+  arm_arch4t = arm_arch4 & ((insn_flags & FL_THUMB) != 0);\n   arm_arch5 = (insn_flags & FL_ARCH5) != 0;\n   arm_arch5e = (insn_flags & FL_ARCH5E) != 0;\n   arm_arch6 = (insn_flags & FL_ARCH6) != 0;\n@@ -816,6 +820,11 @@ arm_override_options (void)\n   arm_tune_xscale = (tune_flags & FL_XSCALE) != 0;\n   arm_arch_iwmmxt = (insn_flags & FL_IWMMXT) != 0;\n \n+  /* V5 code we generate is completely interworking capable, so we turn off\n+     TARGET_INTERWORK here to avoid many tests later on.  */\n+  if (arm_arch5)\n+    target_flags &= ~ARM_FLAG_INTERWORK;\n+\n   if (target_abi_name)\n     {\n       for (i = 0; i < ARRAY_SIZE (arm_all_abis); i++)\n@@ -8000,8 +8009,10 @@ vfp_emit_fstmx (int base_reg, int count)\n const char *\n output_call (rtx *operands)\n {\n-  /* Handle calls to lr using ip (which may be clobbered in subr anyway).  */\n+  if (arm_arch5)\n+    abort ();\t\t/* Patterns should call blx <reg> directly.  */\n \n+  /* Handle calls to lr using ip (which may be clobbered in subr anyway).  */\n   if (REGNO (operands[0]) == LR_REGNUM)\n     {\n       operands[0] = gen_rtx_REG (SImode, IP_REGNUM);\n@@ -8010,7 +8021,7 @@ output_call (rtx *operands)\n   \n   output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n   \n-  if (TARGET_INTERWORK)\n+  if (TARGET_INTERWORK || arm_arch4t)\n     output_asm_insn (\"bx%?\\t%0\", operands);\n   else\n     output_asm_insn (\"mov%?\\t%|pc, %0\", operands);\n@@ -8022,7 +8033,7 @@ output_call (rtx *operands)\n const char *\n output_call_mem (rtx *operands)\n {\n-  if (TARGET_INTERWORK)\n+  if (TARGET_INTERWORK && !arm_arch5)\n     {\n       output_asm_insn (\"ldr%?\\t%|ip, %0\", operands);\n       output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n@@ -8034,8 +8045,16 @@ output_call_mem (rtx *operands)\n \t first instruction.  It's safe to use IP as the target of the\n \t load since the call will kill it anyway.  */\n       output_asm_insn (\"ldr%?\\t%|ip, %0\", operands);\n-      output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n-      output_asm_insn (\"mov%?\\t%|pc, %|ip\", operands);\n+      if (arm_arch5)\n+\toutput_asm_insn (\"blx%?%|ip\", operands);\n+      else\n+\t{\n+\t  output_asm_insn (\"mov%?\\t%|lr, %|pc\", operands);\n+\t  if (arm_arch4t)\n+\t    output_asm_insn (\"bx%?\\t%|ip\", operands);\n+\t  else\n+\t    output_asm_insn (\"mov%?\\t%|pc, %|ip\", operands);\n+\t}\n     }\n   else\n     {\n@@ -9261,9 +9280,8 @@ output_return_instruction (rtx operand, int really_return, int reverse)\n \t  break;\n \n \tdefault:\n-\t  /* ARMv5 implementations always provide BX, so interworking\n-\t     is the default.  */\n-\t  if ((insn_flags & FL_ARCH5) != 0)\n+\t  /* Use bx if it's available.  */\n+\t  if (arm_arch5 || arm_arch4t)\n \t    sprintf (instr, \"bx%s\\t%%|lr\", conditional);\t    \n \t  else\n \t    sprintf (instr, \"mov%s\\t%%|pc, %%|lr\", conditional);\n@@ -9729,7 +9747,10 @@ arm_output_epilogue (rtx sibling)\n       break;\n \n     default:\n-      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n+      if (arm_arch5 || arm_arch4t)\n+\tasm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n+      else\n+\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n       break;\n     }\n \n@@ -11234,6 +11255,16 @@ arm_final_prescan_insn (rtx insn)\n \t      break;\n \n \t    case CALL_INSN:\n+\t      /* The AAPCS says that conditional calls should not be\n+\t\t used since they make interworking inefficient (the\n+\t\t linker can't transform BL<cond> into BLX).  That's\n+\t\t only a problem if the machine has BLX.  */\n+\t      if (arm_arch5)\n+\t\t{\n+\t\t  fail = TRUE;\n+\t\t  break;\n+\t\t}\n+\n \t      /* Succeed if the following insn is the target label, or\n \t\t if the following two insns are a barrier and the\n \t\t target label.  */"}, {"sha": "d6d07e6721940f2007deab36cf33caca320db503", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=68d560d4d612ad0683bae7b36708ef88685316c5", "patch": "@@ -490,6 +490,9 @@ extern int arm_arch3m;\n /* Nonzero if this chip supports the ARM Architecture 4 extensions.  */\n extern int arm_arch4;\n \n+/* Nonzero if this chip supports the ARM Architecture 4T extensions.  */\n+extern int arm_arch4t;\n+\n /* Nonzero if this chip supports the ARM Architecture 5 extensions.  */\n extern int arm_arch5;\n "}, {"sha": "4b94f6e90f33aecac8259be06298f9333262a1e8", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68d560d4d612ad0683bae7b36708ef88685316c5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=68d560d4d612ad0683bae7b36708ef88685316c5", "patch": "@@ -7377,12 +7377,22 @@\n   }\"\n )\n \n-(define_insn \"*call_reg\"\n+(define_insn \"*call_reg_armv5\"\n   [(call (mem:SI (match_operand:SI 0 \"s_register_operand\" \"r\"))\n          (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && arm_arch5\"\n+  \"blx%?\\\\t%0\"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_reg_arm\"\n+  [(call (mem:SI (match_operand:SI 0 \"s_register_operand\" \"r\"))\n+         (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_ARM && !arm_arch5\"\n   \"*\n   return output_call (operands);\n   \"\n@@ -7404,35 +7414,29 @@\n    (set_attr \"type\" \"call\")]\n )\n \n-(define_insn \"*call_indirect\"\n+(define_insn \"*call_reg_thumb_v5\"\n   [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB\"\n-  \"*\n-  {\n-    if (TARGET_CALLER_INTERWORKING)\n-      return \\\"bl\\\\t%__interwork_call_via_%0\\\";\n-    else\n-      return \\\"bl\\\\t%__call_via_%0\\\";\n-  }\"\n-  [(set_attr \"type\" \"call\")]\n+  \"TARGET_THUMB && arm_arch5\"\n+  \"blx\\\\t%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"call\")]\n )\n \n-(define_insn \"*call_value_indirect\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand 3 \"\" \"\"))\n+(define_insn \"*call_reg_thumb\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"l*r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_THUMB\"\n+  \"TARGET_THUMB && !arm_arch5\"\n   \"*\n   {\n     if (TARGET_CALLER_INTERWORKING)\n-      return \\\"bl\\\\t%__interwork_call_via_%1\\\";\n+      return \\\"bl\\\\t%__interwork_call_via_%0\\\";\n     else\n-      return \\\"bl\\\\t%__call_via_%1\\\";\n+      return \\\"bl\\\\t%__call_via_%0\\\";\n   }\"\n   [(set_attr \"type\" \"call\")]\n )\n@@ -7459,13 +7463,24 @@\n   }\"\n )\n \n-(define_insn \"*call_value_reg\"\n+(define_insn \"*call_value_reg_armv5\"\n   [(set (match_operand 0 \"\" \"\")\n         (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && arm_arch5\"\n+  \"blx%?\\\\t%1\"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_value_reg_arm\"\n+  [(set (match_operand 0 \"\" \"\")\n+        (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_ARM && !arm_arch5\"\n   \"*\n   return output_call (&operands[1]);\n   \"\n@@ -7487,6 +7502,35 @@\n    (set_attr \"type\" \"call\")]\n )\n \n+(define_insn \"*call_value_reg_thumb_v5\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB && arm_arch5\"\n+  \"blx\\\\t%1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"call\")]\n+)\n+\n+(define_insn \"*call_value_reg_thumb\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"l*r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (clobber (reg:SI LR_REGNUM))]\n+  \"TARGET_THUMB && !arm_arch5\"\n+  \"*\n+  {\n+    if (TARGET_CALLER_INTERWORKING)\n+      return \\\"bl\\\\t%__interwork_call_via_%1\\\";\n+    else\n+      return \\\"bl\\\\t%__call_via_%1\\\";\n+  }\"\n+  [(set_attr \"type\" \"call\")]\n+)\n+\n ;; Allow calls to SYMBOL_REFs specially as they are not valid general addresses\n ;; The 'a' causes the operand to be treated as an address, i.e. no '#' output.\n \n@@ -7786,6 +7830,7 @@\n   \"\"\n )\n \n+;; NB Never uses BX.\n (define_insn \"*arm_indirect_jump\"\n   [(set (pc)\n \t(match_operand:SI 0 \"s_register_operand\" \"r\"))]\n@@ -7794,8 +7839,6 @@\n   [(set_attr \"predicable\" \"yes\")]\n )\n \n-;; Although not supported by the define_expand above,\n-;; cse/combine may generate this form.\n (define_insn \"*load_indirect_jump\"\n   [(set (pc)\n \t(match_operand:SI 0 \"memory_operand\" \"m\"))]\n@@ -7807,6 +7850,7 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n+;; NB Never uses BX.\n (define_insn \"*thumb_indirect_jump\"\n   [(set (pc)\n \t(match_operand:SI 0 \"register_operand\" \"l*r\"))]\n@@ -10099,6 +10143,7 @@\n   \"\n )\n \n+;; NB never uses BX.\n (define_insn \"*thumb_tablejump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"l*r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]"}]}