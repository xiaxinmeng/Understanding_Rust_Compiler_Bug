{"sha": "2925cad2151842daa387950e62d989090e47c91d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkyNWNhZDIxNTE4NDJkYWEzODc5NTBlNjJkOTg5MDkwZTQ3YzkxZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-10-03T15:08:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-03T15:08:21Z"}, "message": "params.def (PARAM_INLINE_HEURISTICS_HINT_PERCENT, [...]): New.\n\n\n\t* params.def (PARAM_INLINE_HEURISTICS_HINT_PERCENT,\n\tPARAM_INLINE_HEURISTICS_HINT_PERCENT_O2): New.\n\t* doc/invoke.texi (inline-heuristics-hint-percent,\n\tinline-heuristics-hint-percent-O2): Document.\n\t* tree-inline.c (inline_insns_single, inline_insns_auto): Add new\n\thint attribute.\n\t(can_inline_edge_by_limits_p): Use it.\n\nFrom-SVN: r276516", "tree": {"sha": "56cbd7caf486ca7dff683542ddbc56465b543189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56cbd7caf486ca7dff683542ddbc56465b543189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2925cad2151842daa387950e62d989090e47c91d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2925cad2151842daa387950e62d989090e47c91d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2925cad2151842daa387950e62d989090e47c91d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2925cad2151842daa387950e62d989090e47c91d/comments", "author": null, "committer": null, "parents": [{"sha": "ebf8247e7b8d944e75ebcb406a992b24425fc712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf8247e7b8d944e75ebcb406a992b24425fc712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf8247e7b8d944e75ebcb406a992b24425fc712"}], "stats": {"total": 131, "additions": 90, "deletions": 41}, "files": [{"sha": "ff52beb4869367675d32139ff411a620dcdd3e5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2925cad2151842daa387950e62d989090e47c91d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2925cad2151842daa387950e62d989090e47c91d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2925cad2151842daa387950e62d989090e47c91d", "patch": "@@ -1,3 +1,13 @@\n+2019-10-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* params.def (PARAM_INLINE_HEURISTICS_HINT_PERCENT,\n+\tPARAM_INLINE_HEURISTICS_HINT_PERCENT_O2): New.\n+\t* doc/invoke.texi (inline-heuristics-hint-percent,\n+\tinline-heuristics-hint-percent-O2): Document.\n+\t* tree-inline.c (inline_insns_single, inline_insns_auto): Add new\n+\thint attribute.\n+\t(can_inline_edge_by_limits_p): Use it.\n+\n 2019-10-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/arm/arm.c (arm_print_value): Use real_to_decimal"}, {"sha": "ac20e3a1446282f8c3955edd99c01f8c72cebc44", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2925cad2151842daa387950e62d989090e47c91d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2925cad2151842daa387950e62d989090e47c91d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2925cad2151842daa387950e62d989090e47c91d", "patch": "@@ -11215,6 +11215,18 @@ function prologue and epilogue.\n Extra time accounted by inliner for function overhead such as time needed to\n execute function prologue and epilogue\n \n+@item inline-heuristics-hint-percent\n+@item inline-heuristics-hint-percent-O2\n+The scale (in percents) applied to @option{inline-insns-single},\n+@option{inline-insns-single-O2}, @option{inline-insns-auto},\n+@option{inline-insns-auto-O2} when inline heuristics hints that inlining is\n+very profitable (will enable later optimizations).\n+\n+For functions compiled with optimization levels\n+@option{-O3} and @option{-Ofast} parameter\n+@option{inline-heuristics-hint-percent} is applied. In other cases\n+@option{inline-heuristics-hint-percent-O2} is applied.\n+\n @item uninlined-thunk-insns\n @item uninlined-thunk-time\n Same as @option{--param uninlined-function-insns} and"}, {"sha": "725e6750aac90d1ac0d7114b6184fc86bca33cc7", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 58, "deletions": 41, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2925cad2151842daa387950e62d989090e47c91d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2925cad2151842daa387950e62d989090e47c91d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2925cad2151842daa387950e62d989090e47c91d", "patch": "@@ -390,26 +390,48 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   return inlinable;\n }\n \n-/* Return inlining_insns_single limit for function N */\n+/* Return inlining_insns_single limit for function N. If HINT is true\n+   scale up the bound.  */\n \n static int\n-inline_insns_single (cgraph_node *n)\n+inline_insns_single (cgraph_node *n, bool hint)\n {\n   if (opt_for_fn (n->decl, optimize >= 3))\n-    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE);\n+    {\n+      if (hint)\n+\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE)\n+\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT) / 100;\n+      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE);\n+    }\n   else\n-    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE_O2);\n+    {\n+      if (hint)\n+\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE_O2)\n+\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT_O2) / 100;\n+      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE_O2);\n+    }\n }\n \n-/* Return inlining_insns_auto limit for function N */\n+/* Return inlining_insns_auto limit for function N. If HINT is true\n+   scale up the bound.   */\n \n static int\n-inline_insns_auto (cgraph_node *n)\n+inline_insns_auto (cgraph_node *n, bool hint)\n {\n   if (opt_for_fn (n->decl, optimize >= 3))\n-    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO);\n+    {\n+      if (hint)\n+\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO)\n+\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT) / 100;\n+      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO);\n+    }\n   else\n-    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO_O2);\n+    {\n+      if (hint)\n+\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO_O2)\n+\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT_O2) / 100;\n+      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO_O2);\n+    }\n }\n \n /* Decide if we can inline the edge and possibly update\n@@ -554,8 +576,8 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t  int growth = estimate_edge_growth (e);\n \t  if (growth > PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SIZE)\n \t      && (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t\t  && growth >= MAX (inline_insns_single (caller),\n-\t\t\t\t    inline_insns_auto (caller))))\n+\t\t  && growth >= MAX (inline_insns_single (caller, false),\n+\t\t\t\t    inline_insns_auto (caller, false))))\n \t    {\n \t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t      inlinable = false;\n@@ -801,15 +823,12 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       want_inline = false;\n     }\n   /* Do fast and conservative check if the function can be good\n-     inline candidate.  At the moment we allow inline hints to\n-     promote non-inline functions to inline and we increase\n-     MAX_INLINE_INSNS_SINGLE 16-fold for inline functions.  */\n+     inline candidate.  */\n   else if ((!DECL_DECLARED_INLINE_P (callee->decl)\n \t   && (!e->count.ipa ().initialized_p () || !e->maybe_hot_p ()))\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n-\t      > MAX (inline_insns_single (e->caller),\n-\t\t     inline_insns_auto (e->caller)))\n+\t      > inline_insns_auto (e->caller, true))\n     {\n       if (opt_for_fn (e->caller->decl, optimize) >= 3)\n         e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -821,7 +840,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t    || e->count.ipa ().nonzero_p ())\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n-\t      > 16 * inline_insns_single (e->caller))\n+\t      > inline_insns_single (e->caller, true))\n     {\n       if (opt_for_fn (e->caller->decl, optimize) >= 3)\n \te->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n@@ -837,20 +856,22 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n     {\n       int growth = estimate_edge_growth (e);\n       ipa_hints hints = estimate_edge_hints (e);\n-      int big_speedup = -1; /* compute this lazily */\n+      bool apply_hints = (hints & (INLINE_HINT_indirect_call\n+\t\t\t\t   | INLINE_HINT_known_hot\n+\t\t\t\t   | INLINE_HINT_loop_iterations\n+\t\t\t\t   | INLINE_HINT_loop_stride));\n \n       if (growth <= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SIZE))\n \t;\n       /* Apply MAX_INLINE_INSNS_SINGLE limit.  Do not do so when\n-\t hints suggests that inlining given function is very profitable.  */\n+\t hints suggests that inlining given function is very profitable.\n+\t Avoid computation of big_speedup_p when not necessary to change\n+\t outcome of decision.  */\n       else if (DECL_DECLARED_INLINE_P (callee->decl)\n-\t       && growth >= inline_insns_single (e->caller)\n-\t       && (growth >= inline_insns_single (e->caller) * 16\n-\t\t   || (!(hints & (INLINE_HINT_indirect_call\n-\t\t\t\t  | INLINE_HINT_known_hot\n-\t\t\t\t  | INLINE_HINT_loop_iterations\n-\t\t\t\t  | INLINE_HINT_loop_stride))\n-\t\t       && !(big_speedup = big_speedup_p (e)))))\n+\t       && growth >= inline_insns_single (e->caller, apply_hints)\n+\t       && (apply_hints\n+\t\t   || growth >= inline_insns_single (e->caller, true)\n+\t\t   || !big_speedup_p (e)))\n \t{\n \t  if (opt_for_fn (e->caller->decl, optimize) >= 3)\n             e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n@@ -863,28 +884,23 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && growth >= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SMALL))\n \t{\n \t  /* growth_likely_positive is expensive, always test it last.  */\n-          if (growth >= inline_insns_single (e->caller)\n+          if (growth >= inline_insns_single (e->caller, false)\n \t      || growth_likely_positive (callee, growth))\n \t    {\n               e->inline_failed = CIF_NOT_DECLARED_INLINED;\n \t      want_inline = false;\n  \t    }\n \t}\n-      /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline\n-\t Upgrade it to MAX_INLINE_INSNS_SINGLE when hints suggests that\n-\t inlining given function is very profitable.  */\n+      /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline.\n+\t Bypass the limit when speedup seems big.  */\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t       && !(hints & INLINE_HINT_known_hot)\n-\t       && growth >= ((hints & (INLINE_HINT_indirect_call\n-\t\t\t\t       | INLINE_HINT_loop_iterations\n-\t\t\t\t       | INLINE_HINT_loop_stride))\n-\t\t\t     ? MAX (inline_insns_auto (e->caller),\n-\t\t\t\t    inline_insns_single (e->caller))\n-\t\t\t     : inline_insns_auto (e->caller))\n-\t       && !(big_speedup == -1 ? big_speedup_p (e) : big_speedup))\n+\t       && growth >= inline_insns_auto (e->caller, apply_hints)\n+\t       && (apply_hints\n+\t\t   || growth >= inline_insns_auto (e->caller, true)\n+\t\t   || !big_speedup_p (e)))\n \t{\n \t  /* growth_likely_positive is expensive, always test it last.  */\n-          if (growth >= inline_insns_single (e->caller)\n+          if (growth >= inline_insns_single (e->caller, false)\n \t      || growth_likely_positive (callee, growth))\n \t    {\n \t      if (opt_for_fn (e->caller->decl, optimize) >= 3)\n@@ -896,7 +912,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t}\n       /* If call is cold, do not inline when function body would grow. */\n       else if (!e->maybe_hot_p ()\n-\t       && (growth >= inline_insns_single (e->caller)\n+\t       && (growth >= inline_insns_single (e->caller, false)\n \t\t   || growth_likely_positive (callee, growth)))\n \t{\n           e->inline_failed = CIF_UNLIKELY_CALL;\n@@ -1200,12 +1216,13 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t  int caller_growth = caller_info->growth;\n \n \t  /* Only apply the penalty when caller looks like inline candidate,\n-\t     and it is not called once and.  */\n+\t     and it is not called once.  */\n \t  if (!caller_info->single_caller && overall_growth < caller_growth\n \t      && caller_info->inlinable\n \t      && caller_info->size\n \t\t < (DECL_DECLARED_INLINE_P (caller->decl)\n-\t\t    ? inline_insns_single (caller) : inline_insns_auto (caller)))\n+\t\t    ? inline_insns_single (caller, false)\n+\t\t    : inline_insns_auto (caller, false)))\n \t    {\n \t      if (dump)\n \t\tfprintf (dump_file,"}, {"sha": "4cb48d9ab5baa889392172442823717f9eda7b1c", "filename": "gcc/params.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2925cad2151842daa387950e62d989090e47c91d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2925cad2151842daa387950e62d989090e47c91d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=2925cad2151842daa387950e62d989090e47c91d", "patch": "@@ -102,6 +102,16 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SMALL,\n \t  \"The maximum number of instructions when automatically inlining small functions.\",\n \t  0, 0, 0)\n \n+DEFPARAM (PARAM_INLINE_HEURISTICS_HINT_PERCENT,\n+\t  \"inline-heuristics-hint-percent\",\n+\t  \"The scale (in percents) applied to inline-insns-single and auto limits when heuristics hints that inlining is very profitable with -O3 and -Ofast.\",\n+\t  1600, 100, 1000000)\n+\n+DEFPARAM (PARAM_INLINE_HEURISTICS_HINT_PERCENT_O2,\n+\t  \"inline-heuristics-hint-percent-O2\",\n+\t  \"The scale (in percents) applied to inline-insns-single and auto limits when heuristics hints that inlining is very profitable.\",\n+\t  200, 100, 1000000)\n+\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SIZE,\n \t  \"max-inline-insns-size\",\n \t  \"The maximum number of instructions when inlining for size.\","}]}