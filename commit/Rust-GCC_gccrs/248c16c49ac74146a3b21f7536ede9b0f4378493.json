{"sha": "248c16c49ac74146a3b21f7536ede9b0f4378493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4YzE2YzQ5YWM3NDE0NmEzYjIxZjc1MzZlZGU5YjBmNDM3ODQ5Mw==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2015-10-01T06:35:57Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2015-10-01T06:35:57Z"}, "message": "bb-reorder: Add the \"simple\" algorithm\n\n\n2015-10-01  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* bb-reorder.c: Add intro comment.\n\t(reorder_basic_blocks_software_trace_cache): Print a header to\n\tthe dump file.\n\t(edge_order): New function.\n\t(reorder_basic_blocks_simple): New function.\n\t(reorder_basic_blocks): Choose between the STC and the simple\n\talgorithms (always choose the former).\n\nFrom-SVN: r228317", "tree": {"sha": "001468cbda8d71f9917826959d383040d64cb40c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/001468cbda8d71f9917826959d383040d64cb40c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/248c16c49ac74146a3b21f7536ede9b0f4378493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248c16c49ac74146a3b21f7536ede9b0f4378493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/248c16c49ac74146a3b21f7536ede9b0f4378493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248c16c49ac74146a3b21f7536ede9b0f4378493/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "af71fa391d8bdfd5c3156a03afa42f0363a495a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af71fa391d8bdfd5c3156a03afa42f0363a495a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af71fa391d8bdfd5c3156a03afa42f0363a495a7"}], "stats": {"total": 185, "additions": 184, "deletions": 1}, "files": [{"sha": "92fcb0febe578066b22e4bda28e20bac2b5f42cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248c16c49ac74146a3b21f7536ede9b0f4378493/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248c16c49ac74146a3b21f7536ede9b0f4378493/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=248c16c49ac74146a3b21f7536ede9b0f4378493", "patch": "@@ -1,3 +1,13 @@\n+2015-10-01  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* bb-reorder.c: Add intro comment.\n+\t(reorder_basic_blocks_software_trace_cache): Print a header to\n+\tthe dump file.\n+\t(edge_order): New function.\n+\t(reorder_basic_blocks_simple): New function.\n+\t(reorder_basic_blocks): Choose between the STC and the simple\n+\talgorithms (always choose the former).\n+\n 2015-10-01  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* bb-reorder.c (reorder_basic_blocks_software_trace_cache): New"}, {"sha": "4d07b2e136966f54262d04c99856529477cad223", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 174, "deletions": 1, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/248c16c49ac74146a3b21f7536ede9b0f4378493/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/248c16c49ac74146a3b21f7536ede9b0f4378493/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=248c16c49ac74146a3b21f7536ede9b0f4378493", "patch": "@@ -17,6 +17,18 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* This file contains the \"reorder blocks\" pass, which changes the control\n+   flow of a function to encounter fewer branches; the \"partition blocks\"\n+   pass, which divides the basic blocks into \"hot\" and \"cold\" partitions,\n+   which are kept separate; and the \"duplicate computed gotos\" pass, which\n+   duplicates blocks ending in an indirect jump.\n+\n+   There are two algorithms for \"reorder blocks\": the \"simple\" algorithm,\n+   which just rearranges blocks, trying to minimize the number of executed\n+   unconditional branches; and the \"software trace cache\" algorithm, which\n+   also copies code, and in general tries a lot harder to have long linear\n+   pieces of machine code executed.  This algorithm is described next.  */\n+\n /* This (greedy) algorithm constructs traces in several rounds.\n    The construction starts from \"seeds\".  The seed for the first round\n    is the entry point of the function.  When there are more than one seed,\n@@ -2231,6 +2243,9 @@ update_crossing_jump_flags (void)\n static void\n reorder_basic_blocks_software_trace_cache (void)\n {\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nReordering with the STC algorithm.\\n\\n\");\n+\n   int n_traces;\n   int i;\n   struct trace *traces;\n@@ -2261,6 +2276,161 @@ reorder_basic_blocks_software_trace_cache (void)\n   FREE (bbd);\n }\n \n+/* Return true if edge E1 is more desirable as a fallthrough edge than\n+   edge E2 is.  */\n+\n+static bool\n+edge_order (edge e1, edge e2)\n+{\n+  return EDGE_FREQUENCY (e1) > EDGE_FREQUENCY (e2);\n+}\n+\n+/* Reorder basic blocks using the \"simple\" algorithm.  This tries to\n+   maximize the dynamic number of branches that are fallthrough, without\n+   copying instructions.  The algorithm is greedy, looking at the most\n+   frequently executed branch first.  */\n+\n+static void\n+reorder_basic_blocks_simple (void)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nReordering with the \\\"simple\\\" algorithm.\\n\\n\");\n+\n+  edge *edges = new edge[2 * n_basic_blocks_for_fn (cfun)];\n+\n+  /* First, collect all edges that can be optimized by reordering blocks:\n+     simple jumps and conditional jumps, as well as the function entry edge.  */\n+\n+  int n = 0;\n+  edges[n++] = EDGE_SUCC (ENTRY_BLOCK_PTR_FOR_FN (cfun), 0);\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *end = BB_END (bb);\n+\n+      if (computed_jump_p (end) || tablejump_p (end, NULL, NULL))\n+\tcontinue;\n+\n+      /* We cannot optimize asm goto.  */\n+      if (JUMP_P (end) && extract_asm_operands (end))\n+\tcontinue;\n+\n+      if (any_condjump_p (end))\n+\t{\n+\t  edges[n++] = EDGE_SUCC (bb, 0);\n+\t  edges[n++] = EDGE_SUCC (bb, 1);\n+\t}\n+      else if (single_succ_p (bb))\n+\tedges[n++] = EDGE_SUCC (bb, 0);\n+    }\n+\n+  /* Sort the edges, the most desirable first.  */\n+\n+  std::stable_sort (edges, edges + n, edge_order);\n+\n+  /* Now decide which of those edges to make fallthrough edges.  We set\n+     BB_VISITED if a block already has a fallthrough successor assigned\n+     to it.  We make ->AUX of an endpoint point to the opposite endpoint\n+     of a sequence of blocks that fall through, and ->AUX will be NULL\n+     for a block that is in such a sequence but not an endpoint anymore.\n+\n+     To start with, everything points to itself, nothing is assigned yet.  */\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bb->aux = bb;\n+\n+  EXIT_BLOCK_PTR_FOR_FN (cfun)->aux = 0;\n+\n+  /* Now for all edges, the most desirable first, see if that edge can\n+     connect two sequences.  If it can, update AUX and BB_VISITED; if it\n+     cannot, zero out the edge in the table.  */\n+\n+  for (int j = 0; j < n; j++)\n+    {\n+      edge e = edges[j];\n+\n+      basic_block tail_a = e->src;\n+      basic_block head_b = e->dest;\n+      basic_block head_a = (basic_block) tail_a->aux;\n+      basic_block tail_b = (basic_block) head_b->aux;\n+\n+      /* An edge cannot connect two sequences if:\n+\t - it crosses partitions;\n+\t - its src is not a current endpoint;\n+\t - its dest is not a current endpoint;\n+\t - or, it would create a loop.  */\n+\n+      if (e->flags & EDGE_CROSSING\n+\t  || tail_a->flags & BB_VISITED\n+\t  || !tail_b\n+\t  || (!(head_b->flags & BB_VISITED) && head_b != tail_b)\n+\t  || tail_a == tail_b)\n+\t{\n+\t  edges[j] = 0;\n+\t  continue;\n+\t}\n+\n+      tail_a->aux = 0;\n+      head_b->aux = 0;\n+      head_a->aux = tail_b;\n+      tail_b->aux = head_a;\n+      tail_a->flags |= BB_VISITED;\n+    }\n+\n+  /* Put the pieces together, in the same order that the start blocks of\n+     the sequences already had.  The hot/cold partitioning gives a little\n+     complication: as a first pass only do this for blocks in the same\n+     partition as the start block, and (if there is anything left to do)\n+     in a second pass handle the other partition.  */\n+\n+  basic_block last_tail = (basic_block) ENTRY_BLOCK_PTR_FOR_FN (cfun)->aux;\n+\n+  int current_partition = BB_PARTITION (last_tail);\n+  bool need_another_pass = true;\n+\n+  for (int pass = 0; pass < 2 && need_another_pass; pass++)\n+    {\n+      need_another_pass = false;\n+\n+      FOR_EACH_BB_FN (bb, cfun)\n+\tif ((bb->flags & BB_VISITED && bb->aux) || bb->aux == bb)\n+\t  {\n+\t    if (BB_PARTITION (bb) != current_partition)\n+\t      {\n+\t\tneed_another_pass = true;\n+\t\tcontinue;\n+\t      }\n+\n+\t    last_tail->aux = bb;\n+\t    last_tail = (basic_block) bb->aux;\n+\t  }\n+\n+      current_partition ^= BB_HOT_PARTITION | BB_COLD_PARTITION;\n+    }\n+\n+  last_tail->aux = 0;\n+\n+  /* Finally, link all the chosen fallthrough edges.  */\n+\n+  for (int j = 0; j < n; j++)\n+    if (edges[j])\n+      edges[j]->src->aux = edges[j]->dest;\n+\n+  delete[] edges;\n+\n+  /* If the entry edge no longer falls through we have to make a new\n+     block so it can do so again.  */\n+\n+  edge e = EDGE_SUCC (ENTRY_BLOCK_PTR_FOR_FN (cfun), 0);\n+  if (e->dest != ENTRY_BLOCK_PTR_FOR_FN (cfun)->aux)\n+    {\n+      force_nonfallthru (e);\n+      e->src->aux = ENTRY_BLOCK_PTR_FOR_FN (cfun)->aux;\n+      BB_COPY_PARTITION (e->src, e->dest);\n+    }\n+}\n+\n /* Reorder basic blocks.  The main entry point to this file.  */\n \n static void\n@@ -2274,7 +2444,10 @@ reorder_basic_blocks (void)\n   set_edge_can_fallthru_flag ();\n   mark_dfs_back_edges ();\n \n-  reorder_basic_blocks_software_trace_cache ();\n+  if (1)\n+    reorder_basic_blocks_software_trace_cache ();\n+  else\n+    reorder_basic_blocks_simple ();\n \n   relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n "}]}