{"sha": "e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdiYWViMzk2ZDMxM2VmMTQxZjk3MmNkZWRjMTliMTJlZjFiOWNmZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-06-06T07:37:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-06-06T07:37:14Z"}, "message": "re PR tree-optimization/80928 (SLP vectorization does not handle induction in outer loop vectorization)\n\n2017-06-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/80928\n\t* tree-vect-loop.c (vect_update_vf_for_slp): Amend dumps.\n\t(vect_analyze_loop_operations): Properly guard analysis for\n\tpure SLP case.\n\t(vect_transform_loop): Likewise.\n\t(vect_analyze_loop_2): Also reset SLP type on PHIs.\n\t(vect_model_induction_cost): Do not cost for pure SLP.\n\t(vectorizable_induction): Pass in SLP node, implement SLP vectorization\n\tof induction in inner loop vectorization.\n\t* tree-vect-slp.c (vect_create_new_slp_node): Handle PHIs.\n\t(vect_get_and_check_slp_defs): Handle vect_induction_def.\n\t(vect_build_slp_tree): Likewise.  Handle PHIs as terminating the\n\trecursion.\n\t(vect_analyze_slp_cost_1): Cost induction.\n\t(vect_detect_hybrid_slp_stmts): Handle PHIs.\n\t(vect_get_slp_vect_defs): Likewise.\n\t* tree-vect-stmts.c (vect_analyze_stmt): Handle induction.\n\t(vect_transform_stmt): Handle SLP reductions.\n\t* tree-vectorizer.h (vectorizable_induction): Adjust.\n\n\t* gcc.dg/vect/pr80928.c: New testcase.\n\t* gcc.dg/vect/slp-13-big-array.c: Remove XFAILs.\n\t* gcc.dg/vect/slp-13.c: Likewise.\n\t* gcc.dg/vect/slp-perm-9.c: Prevent vectorization of check loop.\n\nFrom-SVN: r248909", "tree": {"sha": "bcb9603549d0ee4ff166d61a0be4175d7142c721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcb9603549d0ee4ff166d61a0be4175d7142c721"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09a04a5e5e254b283b2ac765f75414ad5064e787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a04a5e5e254b283b2ac765f75414ad5064e787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a04a5e5e254b283b2ac765f75414ad5064e787"}], "stats": {"total": 354, "additions": 316, "deletions": 38}, "files": [{"sha": "4a729fe4c7592a58fa3119cdb86840ec1872dbd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -1,3 +1,25 @@\n+2017-06-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/80928\n+\t* tree-vect-loop.c (vect_update_vf_for_slp): Amend dumps.\n+\t(vect_analyze_loop_operations): Properly guard analysis for\n+\tpure SLP case.\n+\t(vect_transform_loop): Likewise.\n+\t(vect_analyze_loop_2): Also reset SLP type on PHIs.\n+\t(vect_model_induction_cost): Do not cost for pure SLP.\n+\t(vectorizable_induction): Pass in SLP node, implement SLP vectorization\n+\tof induction in inner loop vectorization.\n+\t* tree-vect-slp.c (vect_create_new_slp_node): Handle PHIs.\n+\t(vect_get_and_check_slp_defs): Handle vect_induction_def.\n+\t(vect_build_slp_tree): Likewise.  Handle PHIs as terminating the\n+\trecursion.\n+\t(vect_analyze_slp_cost_1): Cost induction.\n+\t(vect_detect_hybrid_slp_stmts): Handle PHIs.\n+\t(vect_get_slp_vect_defs): Likewise.\n+\t* tree-vect-stmts.c (vect_analyze_stmt): Handle induction.\n+\t(vect_transform_stmt): Handle SLP reductions.\n+\t* tree-vectorizer.h (vectorizable_induction): Adjust.\n+\n 2017-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (make_resolver_func): Update"}, {"sha": "35d36c49798b256827c58e1c1e894144b9e23283", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -1,3 +1,11 @@\n+2017-06-06  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/80928\n+\t* gcc.dg/vect/pr80928.c: New testcase.\n+\t* gcc.dg/vect/slp-13-big-array.c: Remove XFAILs.\n+\t* gcc.dg/vect/slp-13.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-9.c: Prevent vectorization of check loop.\n+\n 2017-06-05  David Malcolm  <dmalcolm@redhat.com>\n \n \t* g++.dg/plugin/comment_plugin.c: New test plugin."}, {"sha": "e6c1f1ab5a7f4ca7eac98cf91fccffbff2dcfc7a", "filename": "gcc/testsuite/gcc.dg/vect/pr80928.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80928.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80928.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr80928.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int a[1020];\n+\n+void __attribute__((noinline))\n+foo ()\n+{\n+  for (int i = 0; i < 1020; i += 5)\n+    {\n+      a[i] = i;\n+      a[i+1] = i;\n+      a[i+2] = i;\n+      a[i+3] = i;\n+      a[i+4] = i;\n+    }\n+}\n+\n+int main ()\n+{\n+  check_vect ();\n+\n+  foo ();\n+\n+  /* check results */\n+  for (int i = 0; i < 1020; ++i)\n+    if (a[i] != ((i + 4) / 5) * 5)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* Make sure we are not triggering hybrid SLP due to the IV update.  */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "635ca47cd2e8af12724b336b7723b4c8de7abe47", "filename": "gcc/testsuite/gcc.dg/vect/slp-13-big-array.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13-big-array.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -22,7 +22,7 @@ main1 ()\n \tabort ();\n     }\n \n-  /* Induction is not SLPable yet.  */\n+  /* Induction is SLPable.  */\n   for (i = 0; i < N; i++)\n     {\n       out[i*8] = in[i*8] + i;\n@@ -49,8 +49,7 @@ main1 ()\n \tabort ();\n     }\n \n-  /* Induction is not SLPable yet and strided group size must be a power of 2\n-     to get vectorized.  */\n+  /* Induction is SLPable.  */\n   for (i = 0; i < N/2; i++)\n     {\n       out2[i*12] = in2[i*12] + i;\n@@ -134,7 +133,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail *-*-* }  } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n-\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" } } */"}, {"sha": "084858db8cbc7a89cfbc505adc81ae2e2cb8a0db", "filename": "gcc/testsuite/gcc.dg/vect/slp-13.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-13.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -14,7 +14,7 @@ main1 ()\n   unsigned int in2[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n   unsigned int out2[N*8];\n \n-  /* Induction is not SLPable yet.  */\n+  /* Induction is SLPable.  */\n   for (i = 0; i < N; i++)\n     {\n       out[i*8] = in[i*8] + i;\n@@ -41,8 +41,7 @@ main1 ()\n \tabort ();\n     }\n \n-  /* Induction is not SLPable yet and strided group size must be a power of 2 \n-     to get vectorized.  */\n+  /* Induction is SLPable.  */\n   for (i = 0; i < N/2; i++)\n     {\n       out2[i*12] = in2[i*12] + i;\n@@ -126,7 +125,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" { xfail *-*-* }  } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" } } */\n-  \n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" } } */"}, {"sha": "4d9c11dcc476a8023b3eaac2ae76cc01bd0db182", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-9.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -42,6 +42,7 @@ int main (int argc, const char* argv[])\n       check_results[3*i] = 9 * i + 6;\n       check_results[3*i+1] = 9 * i + 15;\n       check_results[3*i+2] = 9 * i + 4;\n+      __asm__ volatile (\"\" : : : \"memory\");\n     }\n \n   foo (input, output);"}, {"sha": "f81eb6f3f20e5c70b2d243adaab1cce95b038fea", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 172, "deletions": 13, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -1649,11 +1649,19 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n     }\n \n   if (only_slp_in_loop)\n-    vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"Loop contains only SLP stmts\\n\");\n+      vectorization_factor = LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo);\n+    }\n   else\n-    vectorization_factor\n-      = least_common_multiple (vectorization_factor,\n-\t\t\t       LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"Loop contains SLP and non-SLP stmts\\n\");\n+      vectorization_factor\n+\t= least_common_multiple (vectorization_factor,\n+\t\t\t\t LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n+    }\n \n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n   if (dump_enabled_p ())\n@@ -1765,8 +1773,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n           if (STMT_VINFO_RELEVANT_P (stmt_info))\n             {\n               need_to_vectorize = true;\n-              if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n-                ok = vectorizable_induction (phi, NULL, NULL);\n+              if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n+\t\t  && ! PURE_SLP_STMT (stmt_info))\n+                ok = vectorizable_induction (phi, NULL, NULL, NULL);\n             }\n \n \t  if (ok && STMT_VINFO_LIVE_P (stmt_info))\n@@ -2275,6 +2284,12 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n     {\n       basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];\n+      for (gimple_stmt_iterator si = gsi_start_phis (bb);\n+\t   !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (gsi_stmt (si));\n+\t  STMT_SLP_TYPE (stmt_info) = loop_vect;\n+\t}\n       for (gimple_stmt_iterator si = gsi_start_bb (bb);\n \t   !gsi_end_p (si); gsi_next (&si))\n \t{\n@@ -3797,6 +3812,9 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n   void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n   unsigned inside_cost, prologue_cost;\n \n+  if (PURE_SLP_STMT (stmt_info))\n+    return;\n+\n   /* loop cost for vec_loop.  */\n   inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n \t\t\t       stmt_info, 0, vect_body);\n@@ -6086,7 +6104,7 @@ vect_min_worthwhile_factor (enum tree_code code)\n bool\n vectorizable_induction (gimple *phi,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\tgimple **vec_stmt)\n+\t\t\tgimple **vec_stmt, slp_tree slp_node)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -6125,14 +6143,13 @@ vectorizable_induction (gimple *phi,\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n     return false;\n \n-  /* FORNOW: SLP not supported.  */\n-  if (STMT_SLP_TYPE (stmt_info))\n-    return false;\n-\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  ncopies = vf / nunits;\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = vf / nunits;\n   gcc_assert (ncopies >= 1);\n \n   /* FORNOW. These restrictions should be relaxed.  */\n@@ -6234,6 +6251,147 @@ vectorizable_induction (gimple *phi,\n   /* Find the first insertion point in the BB.  */\n   si = gsi_after_labels (bb);\n \n+  /* For SLP induction we have to generate several IVs as for example\n+     with group size 3 we need [i, i, i, i + S] [i + S, i + S, i + 2*S, i + 2*S]\n+     [i + 2*S, i + 3*S, i + 3*S, i + 3*S].  The step is the same uniform\n+     [VF*S, VF*S, VF*S, VF*S] for all.  */\n+  if (slp_node)\n+    {\n+      /* Convert the init to the desired type.  */\n+      stmts = NULL;\n+      init_expr = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n+      if (stmts)\n+\t{\n+\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n+\n+      /* Generate [VF*S, VF*S, ... ].  */\n+      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n+\t{\n+\t  expr = build_int_cst (integer_type_node, vf);\n+\t  expr = fold_convert (TREE_TYPE (step_expr), expr);\n+\t}\n+      else\n+\texpr = build_int_cst (TREE_TYPE (step_expr), vf);\n+      new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t      expr, step_expr);\n+      if (! CONSTANT_CLASS_P (new_name))\n+\tnew_name = vect_init_vector (phi, new_name,\n+\t\t\t\t     TREE_TYPE (step_expr), NULL);\n+      new_vec = build_vector_from_val (vectype, new_name);\n+      vec_step = vect_init_vector (phi, new_vec, vectype, NULL);\n+\n+      /* Now generate the IVs.  */\n+      unsigned group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      unsigned nvects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      unsigned elts = nunits * nvects;\n+      unsigned nivs = least_common_multiple (group_size, nunits) / nunits;\n+      gcc_assert (elts % group_size == 0);\n+      tree elt = init_expr;\n+      unsigned ivn;\n+      for (ivn = 0; ivn < nivs; ++ivn)\n+\t{\n+\t  tree *elts = XALLOCAVEC (tree, nunits);\n+\t  bool constant_p = true;\n+\t  for (unsigned eltn = 0; eltn < nunits; ++eltn)\n+\t    {\n+\t      if (ivn*nunits + eltn >= group_size\n+\t\t  && (ivn*nunits + eltn) % group_size == 0)\n+\t\t{\n+\t\t  stmts = NULL;\n+\t\t  elt = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (elt),\n+\t\t\t\t      elt, step_expr);\n+\t\t  if (stmts)\n+\t\t    {\n+\t\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t\t      gcc_assert (!new_bb);\n+\t\t    }\n+\t\t}\n+\t      if (! CONSTANT_CLASS_P (elt))\n+\t\tconstant_p = false;\n+\t      elts[eltn] = elt;\n+\t    }\n+\t  if (constant_p)\n+\t    new_vec = build_vector (vectype, elts);\n+\t  else\n+\t    {\n+\t      vec<constructor_elt, va_gc> *v;\n+\t      vec_alloc (v, nunits);\n+\t      for (i = 0; i < nunits; ++i)\n+\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n+\t      new_vec = build_constructor (vectype, v);\n+\t    }\n+\t  vec_init = vect_init_vector (phi, new_vec, vectype, NULL);\n+\n+\t  /* Create the induction-phi that defines the induction-operand.  */\n+\t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n+\t  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n+\t  set_vinfo_for_stmt (induction_phi,\n+\t\t\t      new_stmt_vec_info (induction_phi, loop_vinfo));\n+\t  induc_def = PHI_RESULT (induction_phi);\n+\n+\t  /* Create the iv update inside the loop  */\n+\t  vec_def = make_ssa_name (vec_dest);\n+\t  new_stmt = gimple_build_assign (vec_def, PLUS_EXPR, induc_def, vec_step);\n+\t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+\t  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo));\n+\n+\t  /* Set the arguments of the phi node:  */\n+\t  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n+\t  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n+\t\t       UNKNOWN_LOCATION);\n+\n+\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (induction_phi);\n+\t}\n+\n+      /* Re-use IVs when we can.  */\n+      if (ivn < nvects)\n+\t{\n+\t  unsigned vfp\n+\t    = least_common_multiple (group_size, nunits) / group_size;\n+\t  /* Generate [VF'*S, VF'*S, ... ].  */\n+\t  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n+\t    {\n+\t      expr = build_int_cst (integer_type_node, vfp);\n+\t      expr = fold_convert (TREE_TYPE (step_expr), expr);\n+\t    }\n+\t  else\n+\t    expr = build_int_cst (TREE_TYPE (step_expr), vfp);\n+\t  new_name = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t\t  expr, step_expr);\n+\t  if (! CONSTANT_CLASS_P (new_name))\n+\t    new_name = vect_init_vector (phi, new_name,\n+\t\t\t\t\t TREE_TYPE (step_expr), NULL);\n+\t  new_vec = build_vector_from_val (vectype, new_name);\n+\t  vec_step = vect_init_vector (phi, new_vec, vectype, NULL);\n+\t  for (; ivn < nvects; ++ivn)\n+\t    {\n+\t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs];\n+\t      tree def;\n+\t      if (gimple_code (iv) == GIMPLE_PHI)\n+\t\tdef = gimple_phi_result (iv);\n+\t      else\n+\t\tdef = gimple_assign_lhs (iv);\n+\t      new_stmt = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t\t      PLUS_EXPR,\n+\t\t\t\t\t      def, vec_step);\n+\t      if (gimple_code (iv) == GIMPLE_PHI)\n+\t\tgsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n+\t      else\n+\t\t{\n+\t\t  gimple_stmt_iterator tgsi = gsi_for_stmt (iv);\n+\t\t  gsi_insert_after (&tgsi, new_stmt, GSI_CONTINUE_LINKING);\n+\t\t}\n+\t      set_vinfo_for_stmt (new_stmt,\n+\t\t\t\t  new_stmt_vec_info (new_stmt, loop_vinfo));\n+\t      SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t    }\n+\t}\n+\n+      return true;\n+    }\n+\n   /* Create the vector that holds the initial_value of the induction.  */\n   if (nested_in_vect_loop)\n     {\n@@ -6841,7 +6999,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      && dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n \n-\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n+\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def\n+\t      && ! PURE_SLP_STMT (stmt_info))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location, \"transform phi.\\n\");"}, {"sha": "0800a3f6b23759b93e9a3a5be95ee6472b39752a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -100,6 +100,8 @@ vect_create_new_slp_node (vec<gimple *> scalar_stmts)\n       if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n \tnops++;\n     }\n+  else if (gimple_code (stmt) == GIMPLE_PHI)\n+    nops = 0;\n   else\n     return NULL;\n \n@@ -401,9 +403,10 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t{\n \tcase vect_constant_def:\n \tcase vect_external_def:\n-        case vect_reduction_def:\n+\tcase vect_reduction_def:\n \t  break;\n \n+\tcase vect_induction_def:\n \tcase vect_internal_def:\n \t  oprnd_info->def_stmts.quick_push (def_stmt);\n \t  break;\n@@ -935,9 +938,23 @@ vect_build_slp_tree (vec_info *vinfo,\n       if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n \tnops++;\n     }\n+  else if (gimple_code (stmt) == GIMPLE_PHI)\n+    nops = 0;\n   else\n     return NULL;\n \n+  /* If the SLP node is a PHI (induction), terminate the recursion.  */\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    {\n+      FOR_EACH_VEC_ELT (stmts, i, stmt)\n+\tif (stmt != stmts[0])\n+\t  /* Induction from different IVs is not supported.  */\n+\t  return NULL;\n+      node = vect_create_new_slp_node (stmts);\n+      return node;\n+    }\n+\n+\n   bool two_operators = false;\n   unsigned char *swap = XALLOCAVEC (unsigned char, group_size);\n   if (!vect_build_slp_tree_1 (vinfo, swap,\n@@ -987,7 +1004,8 @@ vect_build_slp_tree (vec_info *vinfo,\n       unsigned old_tree_size = this_tree_size;\n       unsigned int j;\n \n-      if (oprnd_info->first_dt != vect_internal_def)\n+      if (oprnd_info->first_dt != vect_internal_def\n+\t  && oprnd_info->first_dt != vect_induction_def)\n         continue;\n \n       if (++this_tree_size > max_tree_size)\n@@ -1611,6 +1629,28 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t  return;\n \t}\n     }\n+  else if (STMT_VINFO_TYPE (stmt_info) == induc_vec_info_type)\n+    {\n+      /* ncopies_for_cost is the number of IVs we generate.  */\n+      record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n+\t\t\tstmt_info, 0, vect_body);\n+\n+      /* Prologue cost for the initial values and step vector.  */\n+      record_stmt_cost (prologue_cost_vec, ncopies_for_cost,\n+\t\t\tCONSTANT_CLASS_P\n+\t\t\t  (STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED\n+\t\t\t     (stmt_info))\n+\t\t\t? vector_load : vec_construct,\n+\t\t\tstmt_info, 0, vect_prologue);\n+      record_stmt_cost (prologue_cost_vec, 1,\n+\t\t\tCONSTANT_CLASS_P\n+\t\t\t  (STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info))\n+\t\t\t? vector_load : vec_construct,\n+\t\t\tstmt_info, 0, vect_prologue);\n+      \n+      /* ???  No easy way to get at the actual number of vector stmts\n+         to be geneated and thus the derived IVs.  */\n+    }\n   else\n     {\n       record_stmt_cost (body_cost_vec, ncopies_for_cost, vector_stmt,\n@@ -2169,8 +2209,13 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n       if (! STMT_VINFO_IN_PATTERN_P (stmt_vinfo)\n \t  && STMT_VINFO_RELATED_STMT (stmt_vinfo))\n \tstmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n-      if (TREE_CODE (gimple_op (stmt, 0)) == SSA_NAME)\n-\tFOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, gimple_op (stmt, 0))\n+      tree def;\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tdef = gimple_phi_result (stmt);\n+      else\n+\tdef = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n+      if (def)\n+\tFOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n \t  {\n \t    if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n \t      continue;\n@@ -3277,7 +3322,10 @@ vect_get_slp_vect_defs (slp_tree slp_node, vec<tree> *vec_oprnds)\n   FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt)\n     {\n       gcc_assert (vec_def_stmt);\n-      vec_oprnd = gimple_get_lhs (vec_def_stmt);\n+      if (gimple_code (vec_def_stmt) == GIMPLE_PHI)\n+\tvec_oprnd = gimple_phi_result (vec_def_stmt);\n+      else\n+\tvec_oprnd = gimple_get_lhs (vec_def_stmt);\n       vec_oprnds->quick_push (vec_oprnd);\n     }\n }\n@@ -3331,8 +3379,13 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \t      gimple *first_def = SLP_TREE_SCALAR_STMTS (child)[0];\n \t      gimple *related\n \t\t= STMT_VINFO_RELATED_STMT (vinfo_for_stmt (first_def));\n+\t      tree first_def_op;\n \n-\t      if (operand_equal_p (oprnd, gimple_get_lhs (first_def), 0)\n+\t      if (gimple_code (first_def) == GIMPLE_PHI)\n+\t\tfirst_def_op = gimple_phi_result (first_def);\n+\t      else\n+\t\tfirst_def_op = gimple_get_lhs (first_def);\n+\t      if (operand_equal_p (oprnd, first_def_op, 0)\n \t\t  || (related\n \t\t      && operand_equal_p (oprnd, gimple_get_lhs (related), 0)))\n \t\t{\n@@ -3372,9 +3425,9 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n         /* The defs are already vectorized.  */\n \tvect_get_slp_vect_defs (child, &vec_defs);\n       else\n-        /* Build vectors from scalar defs.  */\n+\t/* Build vectors from scalar defs.  */\n \tvect_get_constant_vectors (oprnd, slp_node, &vec_defs, i,\n-                                   number_of_vects, reduc_index);\n+\t\t\t\t   number_of_vects, reduc_index);\n \n       vec_oprnds->quick_push (vec_defs);\n "}, {"sha": "d1d97cb662e53d6becf4db53140e6d269d4d62a9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -8520,6 +8520,9 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n          break;\n \n       case vect_induction_def:\n+\tgcc_assert (!bb_vinfo);\n+\tbreak;\n+\n       case vect_constant_def:\n       case vect_external_def:\n       case vect_unknown_def_type:\n@@ -8598,6 +8601,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n \t  || vectorizable_call (stmt, NULL, NULL, node)\n \t  || vectorizable_store (stmt, NULL, NULL, node)\n \t  || vectorizable_reduction (stmt, NULL, NULL, node)\n+\t  || vectorizable_induction (stmt, NULL, NULL, node)\n \t  || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node)\n \t  || vectorizable_comparison (stmt, NULL, NULL, NULL, node));\n   else\n@@ -8681,8 +8685,7 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n       break;\n \n     case induc_vec_info_type:\n-      gcc_assert (!slp_node);\n-      done = vectorizable_induction (stmt, gsi, &vec_stmt);\n+      done = vectorizable_induction (stmt, gsi, &vec_stmt, slp_node);\n       gcc_assert (done);\n       break;\n "}, {"sha": "3dacb1aee47e22f52ee108fb1ad4c9600572cc29", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7baeb396d313ef141f972cdedc19b12ef1b9cfe/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e7baeb396d313ef141f972cdedc19b12ef1b9cfe", "patch": "@@ -1159,7 +1159,8 @@ extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, int, gimple **);\n extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, slp_tree);\n-extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *, gimple **);\n+extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *,\n+\t\t\t\t    gimple **, slp_tree);\n extern tree get_initial_def_for_reduction (gimple *, tree, tree *);\n extern int vect_min_worthwhile_factor (enum tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,"}]}