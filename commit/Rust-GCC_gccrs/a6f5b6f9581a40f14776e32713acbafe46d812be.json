{"sha": "a6f5b6f9581a40f14776e32713acbafe46d812be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZmNWI2Zjk1ODFhNDBmMTQ3NzZlMzI3MTNhY2JhZmU0NmQ4MTJiZQ==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@redhat.com", "date": "2001-04-20T09:43:52Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2001-04-20T09:43:52Z"}, "message": "natSystem.cc (getSystemTimeZone): Adjust for DST.\n\n\t* java/lang/natSystem.cc (getSystemTimeZone): Adjust for DST.\n\t* java/text/SimpleDateFormat.java\n\t(indexInArray): Removed private method.\n\t(processYear): Removed private method.\n\t(parseLenient): Removed private method.\n\t(parseLeadingZeros): Removed private method.\n\t(parseStrict): Removed private method.\n\t(expect): Added new private method.\n\t(parse): Reverted to pre-Classpath merge version with minor fixes.\n\t* java/util/natGregorianCalendar.cc (computeTime): Handle strict\n\tcalendars.\n\nFrom-SVN: r41456", "tree": {"sha": "b80312c6827358f9739e8862d310f71e085817bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b80312c6827358f9739e8862d310f71e085817bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6f5b6f9581a40f14776e32713acbafe46d812be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f5b6f9581a40f14776e32713acbafe46d812be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f5b6f9581a40f14776e32713acbafe46d812be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f5b6f9581a40f14776e32713acbafe46d812be/comments", "author": null, "committer": null, "parents": [{"sha": "7471a1f03c040550e7295c80df4deac080d49ffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7471a1f03c040550e7295c80df4deac080d49ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7471a1f03c040550e7295c80df4deac080d49ffa"}], "stats": {"total": 923, "additions": 265, "deletions": 658}, "files": [{"sha": "c119849dca070217a6bc2de37b1a6f2df8a1eac5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a6f5b6f9581a40f14776e32713acbafe46d812be", "patch": "@@ -1,3 +1,17 @@\n+2001-04-20  Warren Levy  <warrenl@redhat.com>\n+\n+\t* java/lang/natSystem.cc (getSystemTimeZone): Adjust for DST.\n+\t* java/text/SimpleDateFormat.java\n+\t(indexInArray): Removed private method.\n+\t(processYear): Removed private method.\n+\t(parseLenient): Removed private method.\n+\t(parseLeadingZeros): Removed private method.\n+\t(parseStrict): Removed private method.\n+\t(expect): Added new private method.\n+\t(parse): Reverted to pre-Classpath merge version with minor fixes.\n+\t* java/util/natGregorianCalendar.cc (computeTime): Handle strict\n+\tcalendars.\n+\n 2001-04-12  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/io/File.java (normalizePath): New private method. "}, {"sha": "57e135c7db51b8d27b0ff9d572700a8c36e769a7", "filename": "libjava/java/lang/natSystem.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2Fjava%2Flang%2FnatSystem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2Fjava%2Flang%2FnatSystem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatSystem.cc?ref=a6f5b6f9581a40f14776e32713acbafe46d812be", "patch": "@@ -249,9 +249,11 @@ java::lang::System::getSystemTimeZone (void)\n \n   mktime(tim = localtime(&current_time));\n #ifdef STRUCT_TM_HAS_GMTOFF\n-  tzoffset = -(tim->tm_gmtoff);\t// tm_gmtoff is secs EAST of UTC.\n+  // tm_gmtoff is secs EAST of UTC.\n+  tzoffset = -(tim->tm_gmtoff) + tim->tm_isdst * 3600L;\n #elif HAVE_TIMEZONE\n-  tzoffset = timezone;\t\t// timezone is secs WEST of UTC.\n+  // timezone is secs WEST of UTC.\n+  tzoffset = timezone;\t\n #else\n   // FIXME: there must be another global if neither tm_gmtoff nor timezone\n   // is available, esp. if tzname is valid."}, {"sha": "527fcc87ada636bc50b576d2c84a14e14e0e161b", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 203, "deletions": 654, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=a6f5b6f9581a40f14776e32713acbafe46d812be", "patch": "@@ -482,679 +482,228 @@ private void withLeadingZeros(int value, int length, StringBuffer buffer) {\n     buffer.append(valStr);\n   }\n \n-  private int indexInArray(String dateStr, int index, String[] values) {\n-    int l1 = dateStr.length()-index;\n-    int l2;\n-\n-    for (int i=0; i < values.length; i++) {\n-      if (values[i] == null)\n-        continue;\n-\n-      l2 = values[i].length();\n-      //System.err.println(values[i] + \" \" + dateStr.substring(index,index+l2));\n-      if ((l1 >= l2) && (dateStr.substring(index,index+l2).equals(values[i])))\n-\treturn i;\n-    }\n-    return -1;\n-  }\n-\n-  /*\n-   * Get the actual year value, converting two digit years if necessary.\n-   */\n-  private int processYear(int val)\n+  private final boolean expect (String source, ParsePosition pos, char ch)\n   {\n-    if (val > 100)\n-      return val;\n-\n-    Date d = get2DigitYearStart();\n-    Calendar c = Calendar.getInstance();\n-    c.setTime(d);\n-    int y = c.get(YEAR_FIELD);\n-\n-    return ((y / 100) * 100) + val;\n-  }\n-\n-  /*\n-   * Ok, we ignore the format string and just try to parse what we can\n-   * out of the string.  We need, month, day, year at a minimum. The real\n-   * killer is stuff like XX/XX/XX.  How do we interpret that?  Is is the\n-   * US style MM/DD/YY or the European style DD/MM/YY. Or is it YYYY/MM/DD?\n-   * I'm an American, so I guess you know which one I'm choosing....\n-   */\n-  private Date parseLenient(String dateStr, ParsePosition pos)\n-  {\n-    int month = -1;\n-    int day = -1;\n-    int year = -1;\n-    int era = -1;\n-    int hour = -1;\n-    int hour24 = -1;\n-    int minute = -1;\n-    int second = -1;\n-    int millis = -1;\n-    int ampm = -1;\n-    int last = -1;\n-    TimeZone tz = null;\n-    char lastsep = ' ';\n-    char nextchar = ' ';\n-\n-    Calendar cal = (Calendar)calendar.clone();\n-    cal.clear();\n-    cal.setTime(new Date(0));\n-\n-    int index = pos.getIndex();\n-    String buf = dateStr.substring(index, dateStr.length());\n-\n-    top:\n-    for(;;)\n-      {\n-\n-        // Are we at the end of the string?  If so, make sure we have\n-        // enough data and return. // FIXME: Also detect sufficient data\n-        // and return by setting buf to \"\" on an unparsible string.\n-        if (buf.equals(\"\"))\n-          {\n-            pos.setIndex(index);\n-\n-            // This is the minimum we need\n-            if ((month == -1) || (day == -1) || (year == -1))\n-              {\n-                pos.setErrorIndex(index);\n-                return null;\n-              }\n-\n-             if (tz != null)\n-               cal.setTimeZone(tz);\n-\n-             cal.set(Calendar.YEAR, year);\n-             cal.set(Calendar.MONTH, month - 1);\n-             cal.set(Calendar.DATE, day);           \n-\n-             if (ampm == 0)\n-               cal.set(Calendar.AM_PM, Calendar.AM);\n-             else if (ampm == 1)\n-               cal.set(Calendar.AM_PM, Calendar.PM);\n-\n-             // If am/pm not set, we assume 24 hour day\n-             if (hour != -1)\n-               {\n-                 if (ampm == -1)\n-                   cal.set(Calendar.HOUR_OF_DAY, hour);\n-                 else\n-                   {\n-                     if (ampm == 0)\n-                       {\n-                         if (hour == 12)\n-                           hour = 0;\n-                       }\n-                     else\n-                       {\n-                         if (hour != 12)\n-                           hour += 12;\n-                       }\n-    \n-                     cal.set(Calendar.HOUR_OF_DAY, hour);\n-                   }\n-               }\n-\n-             if (minute != -1)\n-               cal.set(Calendar.MINUTE, minute);\n-\n-             if (second != -1)\n-               cal.set(Calendar.SECOND, second);\n-\n-             if (millis != -1)\n-               cal.set(Calendar.MILLISECOND, millis);\n-\n-             if (era == 0)\n-               cal.set(Calendar.ERA, GregorianCalendar.BC);\n-             else if (era == 1)\n-               cal.set(Calendar.ERA, GregorianCalendar.AD);\n-\n-             return cal.getTime();\n-          }\n-\n-        // Skip over whitespace and expected punctuation\n-        char c = buf.charAt(0);\n-        boolean comma_found = false;\n-        while(Character.isWhitespace(c) || (c == ':') || \n-              (c == ',') || (c == '.') || (c == '/'))\n-          {\n-            lastsep = c;\n-            if (c == ',') // This is a total and utter crock\n-              comma_found = true;\n-            buf = buf.substring(1);\n-            if (buf.equals(\"\"))\n-              continue;\n-            c = buf.charAt(0);\n-          }\n-\n-        if (comma_found == true)\n-          lastsep = ',';\n-\n-        // Is it a month name?\n-        for (int i = 0; i < formatData.months.length; i++)\n-          if ((formatData.months[i] != null) \n-              && buf.startsWith(formatData.months[i]))\n-            {\n-              month = i + 1;\n-              buf = buf.substring(formatData.months[i].length());\n-              index += formatData.months[i].length();\n-              last = MONTH_FIELD;\n-              continue top;\n-            }\n-\n-        // Is it a short month name?\n-        for (int i = 0; i < formatData.shortMonths.length; i++)\n-          if ((formatData.shortMonths[i] != null) \n-              && buf.startsWith(formatData.shortMonths[i]))\n-            {\n-              month = i + 1;\n-              buf = buf.substring(formatData.shortMonths[i].length());\n-              index += formatData.shortMonths[i].length();\n-              last = MONTH_FIELD;\n-              continue top;\n-            }\n-\n-        // Is it a weekday name?\n-        for (int i = 0; i < formatData.weekdays.length; i++)\n-          if ((formatData.weekdays[i] != null)\n-              && buf.startsWith(formatData.weekdays[i]))\n-            {\n-              buf = buf.substring(formatData.weekdays[i].length());\n-              index += formatData.weekdays[i].length();\n-              last = DAY_OF_WEEK_FIELD;\n-              continue top;\n-            }\n-\n-        // Is it a short weekday name?\n-        for (int i = 0; i < formatData.shortWeekdays.length; i++)\n-          if ((formatData.shortWeekdays[i] != null)\n-              && buf.startsWith(formatData.shortWeekdays[i]))\n-            {\n-              buf = buf.substring(formatData.shortWeekdays[i].length());\n-              index += formatData.shortWeekdays[i].length();\n-              last = DAY_OF_WEEK_FIELD;\n-              continue top;\n-            }\n-\n-        // Is this an am/pm string?\n-        for (int i = 0; i < formatData.ampms.length; i++) {\n-          if ((formatData.ampms[i] != null)\n-              && buf.toLowerCase().startsWith(formatData.ampms[i].toLowerCase()))\n-            {\n-              ampm = i;\n-              buf = buf.substring(formatData.ampms[i].length());\n-              index += formatData.ampms[i].length();\n-              last = AM_PM_FIELD;\n-              continue top;\n-            }\n-        }\n-\n-        // See if we have a number\n-        c = buf.charAt(0);\n-        String nbrstr = \"\";\n-        while (Character.isDigit(c))\n-          {\n-            nbrstr = nbrstr + c;\n-            buf = buf.substring(1);\n-            if (buf.equals(\"\"))\n-              break;\n-            c = buf.charAt(0);\n-          }\n-\n-        // If we didn't get a number, try for a timezone, otherwise set buf\n-        // to \"\" and loop to see if we are done.\n-        if (nbrstr.equals(\"\"))\n-          {\n-            // Ok, try for a timezone name\n-            while(!Character.isWhitespace(c) && (c != ',') && (c != '.') &&\n-                  (c != ':') && (c != '/'))\n-              {\n-                nbrstr = nbrstr + c;\n-                buf = buf.substring(1);\n-                if (buf.equals(\"\"))\n-                  break;\n-                c = buf.charAt(0);\n-              }\n-            TimeZone tmptz = TimeZone.getTimeZone(nbrstr);\n-             \n-            // We get GMT on failure, so be sure we asked for it.\n-            if (tmptz.getID().equals(\"GMT\"))\n-              {\n-                if (!nbrstr.equals(\"GMT\"))\n-                  {\n-                    buf = \"\";\n-                    continue top;\n-                  }\n-              }\n-\n-            tz = tmptz;\n-            last = TIMEZONE_FIELD;\n-            index += nbrstr.length();\n-            continue top;\n-          }\n-\n-        // Convert to integer\n-        int val = 0;\n-        try\n-          {\n-            val = Integer.parseInt(nbrstr);\n-          }\n-        catch(Exception e)\n-          {\n-            return null; // Shouldn't happen\n-          }\n-\n-        if (!buf.equals(\"\"))\n-          nextchar = buf.charAt(0);\n-        else\n-          nextchar = ' ';\n-\n-        // Figure out which value to assign to\n-        // I make bad US assumptions about MM/DD/YYYY\n-        if (last == DAY_OF_WEEK_FIELD)\n-          {\n-            day = val;\n-            last = DATE_FIELD;\n-          }\n-        else if ((last == MONTH_FIELD) && (day != -1))\n-          {\n-            year = processYear(val);\n-            last = YEAR_FIELD;\n-          }\n-        else if (last == MONTH_FIELD)\n-          {\n-            day = val;\n-            last = DATE_FIELD;\n-          }\n-        else if (last == -1)\n-          {\n-            // Assume month\n-            if ((val < 13) && (val > 0))\n-              {\n-                month = val;\n-                last = MONTH_FIELD;\n-              }\n-            // Assume year. This only works for two digit years that aren't\n-            // between 01 and 12\n-            else\n-              {\n-                year = processYear(val);\n-                last = YEAR_FIELD;\n-              } \n-          }\n-        else if ((last == YEAR_FIELD) && ((nextchar == '/') ||\n-                 (nextchar == '.')))\n-          {\n-            month = val;\n-            last = MONTH_FIELD;\n-          }\n-        else if (last == YEAR_FIELD)\n-          {\n-            hour = val;\n-            last = HOUR0_FIELD;\n-          }\n-        else if ((last == DATE_FIELD) && ((nextchar == '/') ||\n-                 (nextchar == '.') || buf.equals(\"\")))\n-          {\n-            year = processYear(val);\n-            last = YEAR_FIELD;\n-          }\n-        else if ((last == DATE_FIELD) && ((lastsep == '/') ||\n-                 (lastsep == '.') || (lastsep == ',')))\n-          {\n-            year = processYear(val);\n-            last = YEAR_FIELD;\n-          }\n-        else if (last == DATE_FIELD)\n-          {\n-            hour = val;\n-            last = HOUR0_FIELD;\n-          }\n-        else if (last == HOUR0_FIELD)\n-          {\n-            minute = val;\n-            last = MINUTE_FIELD;\n-          }\n-        else if (last == MINUTE_FIELD)\n-          {\n-            second = val;\n-            last = SECOND_FIELD;\n-          }\n-        else if (lastsep == '.') \n-          {\n-            ; // This is milliseconds or something.  Ignore it\n-            last = WEEK_OF_YEAR_FIELD; // Just a random value\n-          }\n-        else // It is year. I have spoken!\n-          {\n-            year = processYear(val);\n-            last = YEAR_FIELD;\n-          }\n-      }\n-  }\n-\n-  private int parseLeadingZeros(String dateStr, ParsePosition pos,\n-                                FieldSizePair p)\n-  {\n-    int value;\n-    int index = pos.getIndex();\n-    String buf = null;\n-\n-    if (p.size == 1)\n-      {\n-        char c = dateStr.charAt(index+1);\n-        if ((dateStr.charAt(index) == '1') && \n-             Character.isDigit(dateStr.charAt(index+1)))\n-          buf = dateStr.substring(index, index+2);\n-        else\n-          buf = dateStr.substring(index, index+1);\n-        pos.setIndex(index + buf.length());\n-      }\n-    else if (p.size == 2)\n-      {\n-        buf = dateStr.substring(index, index+2);\n-        pos.setIndex(index+2);\n-      }\n-    else if (p.size == 3)\n-      {\n-        buf = dateStr.substring(index, index+3);\n-        pos.setIndex(index+3);\n-      }\n+    int x = pos.getIndex();\n+    boolean r = x < source.length() && source.charAt(x) == ch;\n+    if (r)\n+      pos.setIndex(x + 1);\n     else\n-      {\n-        buf = dateStr.substring(index, index+4);\n-        pos.setIndex(index+4);\n-      }\n-    try\n-      {\n-        value = Integer.parseInt(buf);\n-      }\n-    catch(NumberFormatException nfe)\n-      {\n-        pos.setIndex(index);\n-        pos.setErrorIndex(index);\n-        return -1;\n-      } \n-\n-    return value;\n+      pos.setErrorIndex(x);\n+    return r;\n   }\n \n-  /*\n-   * Note that this method doesn't properly protect against\n-   * StringIndexOutOfBoundsException.  FIXME\n+  /**\n+   * This method parses the specified string into a date.\n+   * \n+   * @param dateStr The date string to parse.\n+   * @param pos The input and output parse position\n+   *\n+   * @return The parsed date, or <code>null</code> if the string cannot be\n+   * parsed.\n    */\n-  private Date parseStrict(String dateStr, ParsePosition pos)\n+  public Date parse (String dateStr, ParsePosition pos)\n   {\n-    // start looking at position pos.index\n-    Enumeration e = tokens.elements();\n-    Calendar theCalendar = (Calendar) calendar.clone();\n-    theCalendar.clear();\n-    theCalendar.setTime(new Date(0));\n-\n-    int value, index, hour = -1;\n-    String buf;\n-    while (pos.getIndex() < dateStr.length()) {\n-      Object o = e.nextElement();\n-      if (o instanceof FieldSizePair) {\n-\tFieldSizePair p = (FieldSizePair) o;\n-\tswitch (p.field) {\n+    int fmt_index = 0;\n+    int fmt_max = pattern.length();\n \n-\tcase ERA_FIELD:\n-\t  value = indexInArray(dateStr,pos.getIndex(),formatData.eras);\n-\t  if (value == -1) {\n-\t    pos.setErrorIndex(pos.getIndex());\n-\t    return null;\n+    calendar.clear();\n+    int quote_start = -1;\n+    for (; fmt_index < fmt_max; ++fmt_index)\n+      {\n+\tchar ch = pattern.charAt(fmt_index);\n+\tif (ch == '\\'')\n+\t  {\n+\t    int index = pos.getIndex();\n+\t    if (fmt_index < fmt_max - 1\n+\t\t&& pattern.charAt(fmt_index + 1) == '\\'')\n+\t      {\n+\t\tif (! expect (dateStr, pos, ch))\n+\t\t  return null;\n+\t\t++fmt_index;\n+\t      }\n+\t    else\n+\t      quote_start = quote_start < 0 ? fmt_index : -1;\n+\t    continue;\n \t  }\n-\t  pos.setIndex(pos.getIndex() + formatData.eras[value].length());\n-\t  theCalendar.set(Calendar.ERA,value);\n-\t  break;\n \n-\tcase YEAR_FIELD:\n-          String y;\n-\t  if (p.size < 4)\n-            y = dateStr.substring(pos.getIndex(), pos.getIndex() + 2);\n-          else\n-            y = dateStr.substring(pos.getIndex(), pos.getIndex() + 4);\n-            \n-          int year;\n-          try\n-            {\n-              year = Integer.parseInt(y);\n-            }\n-          catch(NumberFormatException nfe)\n-            {\n-              pos.setErrorIndex(pos.getIndex());\n-              return null;\n-            }\n-\n-\t  if (p.size < 4)\n-            year += get2DigitYearStart().getYear();\n-\n-          theCalendar.set(Calendar.YEAR, year);\n-\t  if (p.size < 4)\n-            pos.setIndex(pos.getIndex()+2);\n-          else\n-            pos.setIndex(pos.getIndex()+4);\n-\t  break;\n-\n-\tcase MONTH_FIELD:\n-          if (p.size > 2)\n-            {\n-              index = pos.getIndex();\n-\n-\t      value = indexInArray(dateStr,pos.getIndex(),\n-                 (p.size == 3) ? formatData.shortMonths : formatData.months);\n-\t      if (value == -1) \n-                {\n-\t          pos.setErrorIndex(pos.getIndex());\n-\t          return null;\n-\t        }\n-              if (p.size == 3)\n-                pos.setIndex(index + formatData.shortMonths[value].length());\n-              else\n-                pos.setIndex(index + formatData.months[value].length());\n-              theCalendar.set(Calendar.MONTH, value);\n-              break;\n-            }\n-\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-\n-          theCalendar.set(Calendar.MONTH, value);\n-          break;\n-\n-\tcase DATE_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-\n-          theCalendar.set(Calendar.DATE, value);\n-\t  break;\n-\n-\tcase HOUR_OF_DAY1_FIELD:\n-\tcase HOUR_OF_DAY0_FIELD:\n-          index = pos.getIndex();\n-          buf = dateStr.substring(index, index+2);\n-          try\n-            {\n-              value = Integer.parseInt(buf);\n-            }\n-          catch(NumberFormatException nfe)\n-            {\n-              return null;\n-            }\n-          if (p.field == HOUR_OF_DAY0_FIELD)\n-           // theCalendar.set(Calendar.HOUR_OF_DAY, value);\n-            hour = value + 1;\n-          else\n-           // theCalendar.set(Calendar.HOUR_OF_DAY, value-1);\n-            hour = value;\n-          pos.setIndex(index+2);\n-\n-\t  break;\n-\n-\tcase MINUTE_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-\n-          theCalendar.set(Calendar.MINUTE, value);\n-\t  break;\n-\n-\tcase SECOND_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-\n-          theCalendar.set(Calendar.SECOND, value);\n-\t  break;\n-\n-\tcase MILLISECOND_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-         \n-          theCalendar.set(Calendar.MILLISECOND, value);\n-\t  break;\n-\n-\tcase DAY_OF_WEEK_FIELD:\n-\t  value = indexInArray(dateStr,pos.getIndex(),(p.size < 4) ? formatData.shortWeekdays : formatData.weekdays);\n-\t  if (value == -1) {\n-\t    pos.setErrorIndex(pos.getIndex());\n-\t    return null;\n+\tif (quote_start != -1\n+\t    || ((ch < 'a' || ch > 'z')\n+\t\t&& (ch < 'A' || ch > 'Z')))\n+\t  {\n+\t    if (! expect (dateStr, pos, ch))\n+\t      return null;\n+\t    continue;\n \t  }\n-\t  pos.setIndex(pos.getIndex() + ((p.size < 4) ? formatData.shortWeekdays[value].length()\n-\t    : formatData.weekdays[value].length()));\n-\t  // Note: Calendar.set(Calendar.DAY_OF_WEEK,value) does not work\n-\t  // as implemented in jdk1.1.5 (possibly DAY_OF_WEEK is meant to\n-\t  // be read-only). Instead, calculate number of days offset.\n-\t  theCalendar.add(Calendar.DATE,value \n-\t\t\t  - theCalendar.get(Calendar.DAY_OF_WEEK));\n-\t  // in JDK, this seems to clear the hours, so we'll do the same.\n-\t  theCalendar.set(Calendar.HOUR_OF_DAY,0);\n-\t  break;\n-\n-\tcase DAY_OF_YEAR_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-         \n-\t  theCalendar.set(Calendar.DAY_OF_YEAR, value);\n-\t  break;\n-\n-        // Just parse and ignore\n-\tcase DAY_OF_WEEK_IN_MONTH_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-         \n-\t  break;\n-\n-        // Just parse and ignore\n-\tcase WEEK_OF_YEAR_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-         \n-\t  break;\n-\n-        // Just parse and ignore\n-\tcase WEEK_OF_MONTH_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-\n-\t  break;\n \n-\tcase AM_PM_FIELD:\n-\t  value = indexInArray(dateStr,pos.getIndex(),formatData.ampms);\n-\t  if (value == -1) {\n+\t// We've arrived at a potential pattern character in the\n+\t// pattern.\n+\tint first = fmt_index;\n+\twhile (++fmt_index < fmt_max && pattern.charAt(fmt_index) == ch)\n+\t  ;\n+\tint count = fmt_index - first;\n+\t--fmt_index;\n+\n+\t// We can handle most fields automatically: most either are\n+\t// numeric or are looked up in a string vector.  In some cases\n+\t// we need an offset.  When numeric, `offset' is added to the\n+\t// resulting value.  When doing a string lookup, offset is the\n+\t// initial index into the string array.\n+\tint calendar_field;\n+\tboolean is_numeric = true;\n+\tString[] match = null;\n+\tint offset = 0;\n+\tint zone_number = 0;\n+\tswitch (ch)\n+\t  {\n+\t  case 'd':\n+\t    calendar_field = Calendar.DATE;\n+\t    break;\n+\t  case 'D':\n+\t    calendar_field = Calendar.DAY_OF_YEAR;\n+\t    break;\n+\t  case 'F':\n+\t    calendar_field = Calendar.DAY_OF_WEEK_IN_MONTH;\n+\t    break;\n+\t  case 'E':\n+\t    is_numeric = false;\n+\t    offset = 1;\n+\t    calendar_field = Calendar.DAY_OF_WEEK;\n+\t    match = (count <= 3\n+\t\t     ? formatData.getShortWeekdays()\n+\t\t     : formatData.getWeekdays());\n+\t    break;\n+\t  case 'w':\n+\t    calendar_field = Calendar.WEEK_OF_YEAR;\n+\t    break;\n+\t  case 'W':\n+\t    calendar_field = Calendar.WEEK_OF_MONTH;\n+\t    break;\n+\t  case 'M':\n+\t    calendar_field = Calendar.MONTH;\n+\t    if (count <= 2)\n+\t      offset = -1;\n+\t    else\n+\t      {\n+\t\tis_numeric = false;\n+\t\tmatch = (count <= 3\n+\t\t\t ? formatData.getShortMonths()\n+\t\t\t : formatData.getMonths());\n+\t      }\n+\t    break;\n+\t  case 'y':\n+\t    calendar_field = Calendar.YEAR;\n+\t    if (count <= 2)\n+\t      offset = 1900;\n+\t    break;\n+\t  case 'K':\n+\t    calendar_field = Calendar.HOUR;\n+\t    break;\n+\t  case 'h':\n+\t    calendar_field = Calendar.HOUR;\n+\t    break;\n+\t  case 'H':\n+\t    calendar_field = Calendar.HOUR_OF_DAY;\n+\t    break;\n+\t  case 'k':\n+\t    calendar_field = Calendar.HOUR_OF_DAY;\n+\t    break;\n+\t  case 'm':\n+\t    calendar_field = Calendar.MINUTE;\n+\t    break;\n+\t  case 's':\n+\t    calendar_field = Calendar.SECOND;\n+\t    break;\n+\t  case 'S':\n+\t    calendar_field = Calendar.MILLISECOND;\n+\t    break;\n+\t  case 'a':\n+\t    is_numeric = false;\n+\t    calendar_field = Calendar.AM_PM;\n+\t    match = formatData.getAmPmStrings();\n+\t    break;\n+\t  case 'z':\n+\t    // We need a special case for the timezone, because it\n+\t    // uses a different data structure than the other cases.\n+\t    is_numeric = false;\n+\t    calendar_field = Calendar.DST_OFFSET;\n+\t    String[][] zoneStrings = formatData.getZoneStrings();\n+\t    int zoneCount = zoneStrings.length;\n+\t    int index = pos.getIndex();\n+\t    boolean found_zone = false;\n+\t    for (int j = 0;  j < zoneCount;  j++)\n+\t      {\n+\t\tString[] strings = zoneStrings[j];\n+\t\tint k;\n+\t\tfor (k = 1; k < strings.length; ++k)\n+\t\t  {\n+\t\t    if (dateStr.startsWith(strings[k], index))\n+\t\t      break;\n+\t\t  }\n+\t\tif (k != strings.length)\n+\t\t  {\n+\t\t    if (k > 2)\n+\t\t      ;\t\t// FIXME: dst.\n+\t\t    zone_number = 0; // FIXME: dst.\n+\t\t    // FIXME: raw offset to SimpleTimeZone const.\n+\t\t    calendar.setTimeZone(new SimpleTimeZone (1, strings[0]));\n+\t\t    pos.setIndex(index + strings[k].length());\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    if (! found_zone)\n+\t      {\n+\t\tpos.setErrorIndex(pos.getIndex());\n+\t\treturn null;\n+\t      }\n+\t    break;\n+\t  default:\n \t    pos.setErrorIndex(pos.getIndex());\n \t    return null;\n \t  }\n-\t  pos.setIndex(pos.getIndex() + formatData.ampms[value].length());\n-\t  theCalendar.set(Calendar.AM_PM,value);\n-\t  break;\n-\n-\tcase HOUR1_FIELD:\n-\tcase HOUR0_FIELD:\n-          value = parseLeadingZeros(dateStr, pos, p);\n-          if (value == -1)\n-            return null;\n-          if (p.field == HOUR1_FIELD)\n-            theCalendar.set(Calendar.HOUR, value);\n-          if (p.field == HOUR0_FIELD)\n-            theCalendar.set(Calendar.HOUR, value+1);\n-\t  break;\n \n-\t  /*\n-\tcase TIMEZONE_FIELD:\n-\t  // TODO: FIXME: XXX\n-\t  break;\n-\t  */\n+\t// Compute the value we should assign to the field.\n+\tint value;\n+\tif (is_numeric)\n+\t  {\n+\t    numberFormat.setMinimumIntegerDigits(count);\n+\t    Number n = numberFormat.parse(dateStr, pos);\n+\t    if (pos == null || ! (n instanceof Long))\n+\t      return null;\n+\t    value = n.intValue() + offset;\n+\t  }\n+\telse if (match != null)\n+\t  {\n+\t    int index = pos.getIndex();\n+\t    int i;\n+\t    for (i = offset; i < match.length; ++i)\n+\t      {\n+\t\tif (dateStr.startsWith(match[i], index))\n+\t\t  break;\n+\t      }\n+\t    if (i == match.length)\n+\t      {\n+\t\tpos.setErrorIndex(index);\n+\t\treturn null;\n+\t      }\n+\t    pos.setIndex(index + match[i].length());\n+\t    value = i;\n+\t  }\n+\telse\n+\t  value = zone_number;\n \n-\tdefault:\n-\t  throw new IllegalArgumentException(\"Illegal pattern character: \" +\n-             p.field);\n-\t} // end switch\n-      } else if (o instanceof String) {\n-\tString ostr = (String) o;\n-\tif (dateStr.substring(pos.getIndex(),pos.getIndex()+ostr.length()).equals(ostr)) {\n-\t  pos.setIndex(pos.getIndex() + ostr.length());\n-\t} else {\n-\t  pos.setErrorIndex(pos.getIndex());\n-\t  return null;\n-\t}\n-      } else if (o instanceof Character) {\n-\tCharacter ochar = (Character) o;\n-\tif (dateStr.charAt(pos.getIndex()) == ochar.charValue()) {\n-\t  pos.setIndex(pos.getIndex() + 1);\n-\t} else {\n-\t  pos.setErrorIndex(pos.getIndex());\n-\t  return null;\n-\t}\n+\t// Assign the value and move on.\n+\tcalendar.set(calendar_field, value);\n       }\n-    }\n \n-    if (hour != -1)\n+    try\n       {\n-        if (theCalendar.get(Calendar.AM_PM) == Calendar.PM)\n-          {\n-            if (hour == 12)\n-              theCalendar.set(Calendar.HOUR_OF_DAY, 12);\n-            else\n-              theCalendar.set(Calendar.HOUR_OF_DAY, hour + 12);\n-          }\n-        else\n-          {\n-            if (hour == 12)\n-              theCalendar.set(Calendar.HOUR_OF_DAY, 0);\n-            else\n-              theCalendar.set(Calendar.HOUR_OF_DAY, hour);\n-          }\n+        return calendar.getTime();\n+      }\n+    catch (IllegalArgumentException x)\n+      {\n+        pos.setErrorIndex(pos.getIndex());\n+\treturn null;\n       }\n-\n-    return theCalendar.getTime();\n-  }\n-\n-  /**\n-   * This method parses the specified string into a date.\n-   * \n-   * @param dateStr The date string to parse.\n-   * @param pos The input and output parse position\n-   *\n-   * @return The parsed date, or <code>null</code> if the string cannot be\n-   * parsed.\n-   */\n-  public Date parse(String dateStr, ParsePosition pos) {\n-    if (isLenient())\n-       return parseLenient(dateStr, pos);\n-    else\n-       return parseStrict(dateStr, pos);\n-\n   }\n }\n-"}, {"sha": "34b49969b457d70a01c8c2bf4189c3dd71c86181", "filename": "libjava/java/util/natGregorianCalendar.cc", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2Fjava%2Futil%2FnatGregorianCalendar.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6f5b6f9581a40f14776e32713acbafe46d812be/libjava%2Fjava%2Futil%2FnatGregorianCalendar.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatGregorianCalendar.cc?ref=a6f5b6f9581a40f14776e32713acbafe46d812be", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -15,6 +15,7 @@ details.  */\n #include <gcj/cni.h>\n #include <java/util/TimeZone.h>\n #include <java/util/GregorianCalendar.h>\n+#include <java/lang/IllegalArgumentException.h>\n #include <time.h>\n \n void\n@@ -27,11 +28,52 @@ java::util::GregorianCalendar::computeTime ()\n   tim.tm_mday = elements(fields)[DATE];\n   tim.tm_mon = elements(fields)[MONTH];\n   tim.tm_year = elements(fields)[YEAR] - 1900;\n-  tim.tm_isdst = 0;  // FIXME\n+  tim.tm_isdst = 0;\n #ifndef ECOS\n   // FIXME: None of the standard C library access to the ECOS calendar\n   // is yet available.\n   time_t t = mktime (&tim);\n+\n+  if (!isLenient ())\n+    {\n+      // mktime will correct for any time leniencies (e.g. 31-Apr becomes\n+      // 1-May).\n+      // Daylight savings time is a special case since times in hour 23\n+      // will compute to hour 0 of the next day.\n+      if (tim.tm_isdst == 0 || elements(fields)[HOUR_OF_DAY] != 23)\n+        {\n+\t  if (tim.tm_sec != elements(fields)[SECOND] ||\n+\t      tim.tm_min != elements(fields)[MINUTE] ||\n+\t      tim.tm_hour != elements(fields)[HOUR_OF_DAY] +\n+\t      \t\t     (tim.tm_isdst > 0 ? 1 : 0) ||\n+\t      tim.tm_mday != elements(fields)[DATE] ||\n+\t      tim.tm_mon != elements(fields)[MONTH] ||\n+\t      tim.tm_year != elements(fields)[YEAR] - 1900)\n+\t    throw new java::lang::IllegalArgumentException ();\n+        }\n+      else\n+        {\n+\t  // The easiest thing to do is to temporarily shift the clock\n+\t  // back from the 23th hour so mktime doesn't cause the extra\n+\t  // hour for DST to roll the date to the next day.\n+\t  struct tm tmp_tim;\n+\t  tmp_tim.tm_sec = elements(fields)[SECOND];\n+\t  tmp_tim.tm_min = elements(fields)[MINUTE];\n+\t  tmp_tim.tm_hour = elements(fields)[HOUR_OF_DAY] - 1;\n+\t  tmp_tim.tm_mday = elements(fields)[DATE];\n+\t  tmp_tim.tm_mon = elements(fields)[MONTH];\n+\t  tmp_tim.tm_year = elements(fields)[YEAR] - 1900;\n+\t  tmp_tim.tm_isdst = 0;\n+\t  mktime (&tmp_tim);\n+\t  if (tmp_tim.tm_sec != elements(fields)[SECOND] ||\n+\t      tmp_tim.tm_min != elements(fields)[MINUTE] ||\n+\t      tmp_tim.tm_hour != elements(fields)[HOUR_OF_DAY] ||\n+\t      tmp_tim.tm_mday != elements(fields)[DATE] ||\n+\t      tmp_tim.tm_mon != elements(fields)[MONTH] ||\n+\t      tmp_tim.tm_year != elements(fields)[YEAR] - 1900)\n+\t    throw new java::lang::IllegalArgumentException ();\n+\t}\n+    }\n #else\n   time_t t = 0;\n #endif"}]}