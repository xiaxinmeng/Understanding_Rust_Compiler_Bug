{"sha": "78d8c16ca93453666755e70c5931bffda080d12c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhkOGMxNmNhOTM0NTM2NjY3NTVlNzBjNTkzMWJmZmRhMDgwZDEyYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-08-23T20:00:27Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-08-23T20:00:27Z"}, "message": "constraints.md (Yp): New register constraint.\n\n\t* config/i386/constraints.md (Yp): New register constraint.\n\t* config/i386/i386.md (*addhi_1): Merge with *addhi_1_lea using\n\tYp register constraint.\n\t(*addqi_1): Merge with *addqi_1_lea using Yp register constraint.\n\t(*ashlhi3_1): Merge with *ashlhi3_1_lea using Yp register constraint.\n\t(*ashlqi3_1): Merge with *ashlqi3_1_lea using Yp register constraint.\n\nFrom-SVN: r178011", "tree": {"sha": "d3422bf129765a288fac370d658c4e0d5964cc77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3422bf129765a288fac370d658c4e0d5964cc77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78d8c16ca93453666755e70c5931bffda080d12c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d8c16ca93453666755e70c5931bffda080d12c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d8c16ca93453666755e70c5931bffda080d12c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d8c16ca93453666755e70c5931bffda080d12c/comments", "author": null, "committer": null, "parents": [{"sha": "2ddfea8a33905ade165e6aa833dd0adea93e1480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ddfea8a33905ade165e6aa833dd0adea93e1480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ddfea8a33905ade165e6aa833dd0adea93e1480"}], "stats": {"total": 255, "additions": 40, "deletions": 215}, "files": [{"sha": "8b8ba626270ebec12f6f0c19a50e41f077b5e5ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d8c16ca93453666755e70c5931bffda080d12c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d8c16ca93453666755e70c5931bffda080d12c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78d8c16ca93453666755e70c5931bffda080d12c", "patch": "@@ -1,3 +1,12 @@\n+2011-08-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/constraints.md (Yp): New register constraint.\n+\t* config/i386/i386.md (*addhi_1): Merge with *addhi_1_lea using\n+\tYp register constraint.\n+\t(*addqi_1): Merge with *addqi_1_lea using Yp register constraint.\n+\t(*ashlhi3_1): Merge with *ashlhi3_1_lea using Yp register constraint.\n+\t(*ashlqi3_1): Merge with *ashlqi3_1_lea using Yp register constraint.\n+\n 2011-08-23  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/i386/sse.md (<s>mul<mode>3_highpart): Update.\n@@ -18,21 +27,17 @@\n \t(imm_disp): Ditto.\n \t(isa): Add bmi2.\n \t(enabled): Handle bmi2.\n-\t(w): New mode attribute.\n \t(*mul<mode><dwi>3): Split from *<u>mul<mode><dwi>3.\n \t(*umul<mode><dwi>3): Ditto.  Add imulx BMI2 alternative.\n \t(*bmi2_umulditi3_1): New insn pattern.\n \t(*bmi2_umulsidi3_1): Ditto.\n-\t(*umul<mode><dwi>3 splitter): New splitter to avoid flags\n-\tdependency.\n+\t(*umul<mode><dwi>3 splitter): New splitter to avoid flags dependency.\n \t(*bmi2_ashl<mode>3_1): New insn pattern.\n \t(*ashl<mode>3_1): Add ishiftx BMI2 alternative.\n-\t(*ashl<mode>3_1 splitter): New splitter to avoid flags\n-\tdependency.\n+\t(*ashl<mode>3_1 splitter): New splitter to avoid flags dependency.\n \t(*bmi2_ashlsi3_1_zext): New insn pattern.\n \t(*ashlsi3_1_zext): Add ishiftx BMI2 alternative.\n-\t(*ashlsi3_1_zext splitter): New splitter to avoid flags\n-\tdependency.\n+\t(*ashlsi3_1_zext splitter): New splitter to avoid flags dependency.\n \t(*bmi2_<shiftrt_insn><mode>3_1): New insn pattern.\n \t(*<shiftrt_insn><mode>3_1): Add ishiftx BMI2 alternative.\n \t(*<shiftrt_insn><mode>3_1 splitter): New splitter to avoid\n@@ -43,19 +48,16 @@\n \tflags dependency.\n \t(*bmi2_rorx<mode>3_1): New insn pattern.\n \t(*<rotate_insn><mode>3_1): Add rotatex BMI2 alternative.\n-\t(*rotate<mode>3_1 splitter): New splitter to avoid flags\n-\tdependency.\n+\t(*rotate<mode>3_1 splitter): New splitter to avoid flags dependency.\n \t(*rotatert<mode>3_1 splitter): Ditto.\n \t(*bmi2_rorxsi3_1_zext): New insn pattern.\n \t(*<rotate_insn>si3_1_zext): Add rotatex BMI2 alternative.\n-\t(*rotatesi3_1_zext splitter): New splitter to avoid flags\n-\tdependency.\n+\t(*rotatesi3_1_zext splitter): New splitter to avoid flags dependency.\n \t(*rotatertsi3_1_zext splitter): Ditto.\n \n 2011-08-23  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n-\t* common/config/i386/i386-common.c (OPTION_MASK_ISA_BMI2_SET):\n-\tNew.\n+\t* common/config/i386/i386-common.c (OPTION_MASK_ISA_BMI2_SET): New.\n \t(OPTION_MASK_ISA_BMI2_UNSET): Likewise.\n \t(ix86_handle_option): Handle OPT_mbmi2 case.\n \t* config.gcc (i[34567]86-*-*): Add bmi2intrin.h.\n@@ -93,8 +95,7 @@\n \n \tPR middle-end/50161\n \t* simplify-rtx.c (simplify_const_unary_operation): If\n-\top is CONST_INT, don't look at op_mode, but use instead\n-\tmode.\n+\top is CONST_INT, don't look at op_mode, but use instead mode.\n \t* optabs.c (add_equal_note): For FFS, CLZ, CTZ,\n \tCLRSB, POPCOUNT, PARITY and BSWAP use operand mode for\n \toperation and TRUNCATE/ZERO_EXTEND if needed.\n@@ -144,8 +145,7 @@\n \n \t* tree-data-ref.c (dr_analyze_indices): Add comments, handle\n \tREALPART_EXPR and IMAGPART_EXPR similar to ARRAY_REFs.\n-\t(create_data_ref): Also dump access functions for the created\n-\tdata-ref.\n+\t(create_data_ref): Also dump access functions for the created data-ref.\n \n 2011-08-22  Uros Bizjak  <ubizjak@gmail.com>\n \t    Kirill Yukhin  <kirill.yukhin@intel.com>"}, {"sha": "09ee66efaf4f9f9220c1cd7c2200ac265b96d11d", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d8c16ca93453666755e70c5931bffda080d12c/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d8c16ca93453666755e70c5931bffda080d12c/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=78d8c16ca93453666755e70c5931bffda080d12c", "patch": "@@ -88,8 +88,11 @@\n ;; We use the Y prefix to denote any number of conditional register sets:\n ;;  z\tFirst SSE register.\n ;;  2\tSSE2 enabled\n+;;  3\tSSE3 enabled\n+;;  4\tSSE4_1 enabled\n ;;  i\tSSE2 inter-unit moves enabled\n ;;  m\tMMX inter-unit moves enabled\n+;;  p\tInteger register when TARGET_PARTIAL_REG_STALL is disabled\n ;;  d\tInteger register when integer DFmode moves are enabled\n ;;  x\tInteger register when integer XFmode moves are enabled\n \n@@ -113,6 +116,10 @@\n  \"TARGET_MMX && TARGET_INTER_UNIT_MOVES ? MMX_REGS : NO_REGS\"\n  \"@internal Any MMX register, when inter-unit moves are enabled.\")\n \n+(define_register_constraint \"Yp\"\n+ \"TARGET_PARTIAL_REG_STALL ? NO_REGS : GENERAL_REGS\"\n+ \"@internal Any integer register when TARGET_PARTIAL_REG_STALL is disabled.\")\n+\n (define_register_constraint \"Yd\"\n  \"(TARGET_64BIT\n    || (TARGET_INTEGER_DFMODE_MOVES && optimize_function_for_speed_p (cfun)))"}, {"sha": "e739d83f4d617879b079177f130467f2e6fb6443", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 198, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d8c16ca93453666755e70c5931bffda080d12c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d8c16ca93453666755e70c5931bffda080d12c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=78d8c16ca93453666755e70c5931bffda080d12c", "patch": "@@ -5650,49 +5650,11 @@\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*addhi_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rn,rm\")))\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r,r,Yp\")\n+\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,r,Yp\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"rn,rm,0,ln\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (PLUS, HImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_INCDEC:\n-      if (operands[2] == const1_rtx)\n-\treturn \"inc{w}\\t%0\";\n-      else\n-        {\n-\t  gcc_assert (operands[2] == constm1_rtx);\n-\t  return \"dec{w}\\t%0\";\n-\t}\n-\n-    default:\n-      if (x86_maybe_negate_const_int (&operands[2], HImode))\n-\treturn \"sub{w}\\t{%2, %0|%0, %2}\";\n-\n-      return \"add{w}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (if_then_else (match_operand:HI 2 \"incdec_operand\" \"\")\n-\t(const_string \"incdec\")\n-\t(const_string \"alu\")))\n-   (set (attr \"length_immediate\")\n-      (if_then_else\n-\t(and (eq_attr \"type\" \"alu\") (match_operand 2 \"const128_operand\" \"\"))\n-\t(const_string \"1\")\n-\t(const_string \"*\")))\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*addhi_1_lea\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n-\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0,r,r\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmn,rn,0,ln\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (PLUS, HImode, operands)\"\n+  \"ix86_binary_operator_ok (PLUS, HImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -5739,62 +5701,15 @@\n \t(const_string \"*\")))\n    (set_attr \"mode\" \"HI,HI,HI,SI\")])\n \n-;; %%% Potential partial reg stall on alternative 2.  What to do?\n-(define_insn \"*addqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,r\")\n-\t(plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"qn,qmn,rn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (PLUS, QImode, operands)\"\n-{\n-  int widen = (which_alternative == 2);\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_INCDEC:\n-      if (operands[2] == const1_rtx)\n-\treturn widen ? \"inc{l}\\t%k0\" : \"inc{b}\\t%0\";\n-      else\n-\t{\n-\t  gcc_assert (operands[2] == constm1_rtx);\n-\t  return widen ? \"dec{l}\\t%k0\" : \"dec{b}\\t%0\";\n-\t}\n-\n-    default:\n-      if (x86_maybe_negate_const_int (&operands[2], QImode))\n-\t{\n-\t  if (widen)\n-\t    return \"sub{l}\\t{%2, %k0|%k0, %2}\";\n-\t  else\n-\t    return \"sub{b}\\t{%2, %0|%0, %2}\";\n-\t}\n-      if (widen)\n-        return \"add{l}\\t{%k2, %k0|%k0, %k2}\";\n-      else\n-        return \"add{b}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (if_then_else (match_operand:QI 2 \"incdec_operand\" \"\")\n-\t(const_string \"incdec\")\n-\t(const_string \"alu\")))\n-   (set (attr \"length_immediate\")\n-      (if_then_else\n-\t(and (eq_attr \"type\" \"alu\") (match_operand 2 \"const128_operand\" \"\"))\n-\t(const_string \"1\")\n-\t(const_string \"*\")))\n-   (set_attr \"mode\" \"QI,QI,SI\")])\n-\n ;; %%% Potential partial reg stall on alternatives 3 and 4.  What to do?\n-(define_insn \"*addqi_1_lea\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,qm,q,r,r,r\")\n-\t(plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,q,0,r,r\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"qmn,qn,0,rn,0,ln\")))\n+(define_insn \"*addqi_1\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q,q,r,r,Yp\")\n+\t(plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,q,0,r,Yp\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"qn,qm,0,rn,0,ln\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (PLUS, QImode, operands)\"\n+  \"ix86_binary_operator_ok (PLUS, QImode, operands)\"\n {\n-  int widen = (which_alternative == 3 || which_alternative == 4);\n+  bool widen = (which_alternative == 3 || which_alternative == 4);\n \n   switch (get_attr_type (insn))\n     {\n@@ -5851,7 +5766,7 @@\n (define_insn \"*addqi_1_slp\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n \t(plus:QI (match_dup 0)\n-\t\t (match_operand:QI 1 \"general_operand\" \"qn,qnm\")))\n+\t\t (match_operand:QI 1 \"general_operand\" \"qn,qm\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n@@ -9294,53 +9209,11 @@\n   \"operands[2] = gen_lowpart (SImode, operands[2]);\")\n \n (define_insn \"*ashlhi3_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{w}\\t%0, %0\";\n-\n-    default:\n-      if (operands[2] == const1_rtx\n-\t  && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{w}\\t%0\";\n-      else\n-\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*ashlhi3_1_lea\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,Yp\")\n \t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,l\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,M\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n+  \"ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -9380,68 +9253,13 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"HI,SI\")])\n \n+;; %%% Potential partial reg stall on alternative 1.  What to do?\n (define_insn \"*ashlqi3_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r\")\n-\t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      if (REG_P (operands[1]) && !ANY_QI_REG_P (operands[1]))\n-        return \"add{l}\\t%k0, %k0\";\n-      else\n-        return \"add{b}\\t%0, %0\";\n-\n-    default:\n-      if (operands[2] == const1_rtx\n-\t  && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_SI)\n-\t    return \"sal{l}\\t%k0\";\n-\t  else\n-\t    return \"sal{b}\\t%0\";\n-\t}\n-      else\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_SI)\n-\t    return \"sal{l}\\t{%2, %k0|%k0, %2}\";\n-\t  else\n-\t    return \"sal{b}\\t{%2, %0|%0, %2}\";\n-\t}\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"QI,SI\")])\n-\n-;; %%% Potential partial reg stall on alternative 2.  What to do?\n-(define_insn \"*ashlqi3_1_lea\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r,r\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r,Yp\")\n \t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0,l\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI,M\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n+  \"ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {"}]}