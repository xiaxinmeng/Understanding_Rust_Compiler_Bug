{"sha": "0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk2NGJlMDcxM2Y2YzlhOWU2YTJhMGEzZWZlODY5Yjc1NzBkYzljZQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-01-05T19:16:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-04T09:17:32Z"}, "message": "[Ada] Clean up ??? marks\n\ngcc/ada/\n\n\t* binde.adb: No need for ??? marks in Binde, because it is\n\tsuperseded by Bindo.\n\t* bindo-writers.adb (Write_Unit_Closure): Verified that -Ra\n\tworks.\n\t* exp_ch4.adb, sinfo.ads (Expand_N_Type_Conversion): Rules for\n\tconversions passed to gigi are documented in sinfo.ads.\n\t(Expand_N_Unchecked_Type_Conversion): Comment is a duplicate of\n\tone in sinfo.ads.\n\t(Expand_N_In): Robert already added sufficient comments years\n\tafter the ??? comment was inserted.\n\t(Expand_Membership_Minimize_Eliminate_Overflow): I don't see any\n\treason why Stand should export Long_Long_Integer'Base -- it\n\tdoesn't export any other base types.\n\t(Size_In_Storage_Elements): We are doing an allocator, so we\n\tdon't care about sizes in bits.\n\t(Expand_N_Allocator): PolyORB isn't going to be significantly\n\timproved, so we're not going to mess with remote access to\n\tclass-wide types.\n\t(Optimize_Return_Stmt): It's not important to optimize return\n\tstatements in predicate functions -- there are many\n\tmore-important optimizations we could do. Keep part of the\n\tcomment without \"???\", to clarify why the \"and then ...\".\n\t(User_Defined_Primitive_Equality_Op): The optimization doesn't\n\tseem important enough.\n\t(Expand_N_Unchecked_Type_Conversion): Refactor to use\n\tExpand_N_Unchecked_Expression.\n\t(Make_Array_Comparison_Op): This seems like a case of \"it it's\n\tnot broken, don't fix it\". Too much risk of causing bugs.\n\t* debug_a.adb: Remove ??? comments asking why Current_Error_Node\n\tis maintained unconditionally, and add a comment explaining why.\n\t* errout.adb: These kinds of minor bugs do indeed exist, but\n\twe're never going to get around to fixing them \"properly\", so we\n\tneed this code for robustness.\n\t* gnatchop.adb (Read_File): Document when read can fail.\n\t* gnatdll.adb (Parse_Command_Line): Nobody is complaining about\n\tthese arbitrary limits, so no need to use Table. Increase the\n\tlimits just in case.  It is clear from the names what they are\n\tlimits on.\n\t* gnatlink.adb: Add needed comments.\n\t(Delete): An existing comment makes clear it's intentional, and\n\tit's been like that since 1996.\n\t(Process_Args): Improve comments.\n\t(Search_Library_Path): Refactoring to avoid deep nesting.\n\t* inline.adb (Build_Body_To_Inline): Probably won't get around\n\tto doing that optimization.\n\t(Is_Unit_Subprogram): No, this should not be moved to Sem_Aux,\n\tbecause it is too specialized to this context.\n\t(Do_Reset): No comment is needed here; it's clear from the\n\tcomment on Reset_Dispatching_Calls. Do_Reset is an artificial\n\tsubprogram; if we had proper iterators, it would just be an if\n\tstatement in the loop.\n\t(Rewrite_Function_Call): Probably won't get around to doing that\n\toptimization.\n\t* layout.adb (Layout_Type): The gigi comment doesn't need to be\n\ta ??? comment, and it's been that way since 2000.  The\n\tlimitation to scalars will likely never be investigated, and\n\tit's been that way since 2009.\n\t* lib.adb (Check_Same_Extended_Unit): This doesn't look like\n\tsomething that needs fixing; it looks like a permanent\n\tworkaround.\n\t* lib-load.adb (Change_Main_Unit_To_Spec): It is good enough in\n\tpractice.\n\t(Load_Unit): Nobody will ever get around to investigating the\n\tobscure PMES oddity, and the optimization is not worth the\n\ttrouble.\n\t* live.adb: It's not worth documenting this. It is used only\n\twith a debug switch. Nobody who has done significant work on it\n\tis still around, so it would require substantial investigation.\n\t* mdll.ads: I see no reason for USE.\n\t* namet.ads: Routines are obsolete, but they're not going\n\tanywhere anytime soon (too much work, and surprisingly delicate\n\tbecause of dependences on global variables).\n\t* osint.ads: Minor.\n\t* osint.adb: Improve comments.\n\t(Full_Lib_File_Name): Use Smart_Find_File.", "tree": {"sha": "8228d4ef814957d9ba4ec518088a091d8bdf4629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8228d4ef814957d9ba4ec518088a091d8bdf4629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86a9605014f424c556032c2c1586cbfbc4b72131", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a9605014f424c556032c2c1586cbfbc4b72131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a9605014f424c556032c2c1586cbfbc4b72131"}], "stats": {"total": 772, "additions": 357, "deletions": 415}, "files": [{"sha": "3df78bf0ceedf612314ec068579641153bf3195a", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -2327,7 +2327,7 @@ package body Binde is\n       --  subsumed by their parent units, but we need to list them for other\n       --  tools. For now they are listed after other files, rather than right\n       --  after their parent, since there is no easy link between the\n-      --  elaboration table and the ALIs table ??? As subunits may appear\n+      --  elaboration table and the ALIs table. As subunits may appear\n       --  repeatedly in the list, if the parent unit appears in the context of\n       --  several units in the closure, duplicates are suppressed.\n \n@@ -2811,7 +2811,7 @@ package body Binde is\n                        or else Withs.Table (W).Elab_All_Desirable\n                      then\n                         if SCC (U) = SCC (Withed_Unit) then\n-                           Elab_Cycle_Found := True; -- ???\n+                           Elab_Cycle_Found := True;\n \n                            --  We could probably give better error messages\n                            --  than Elab_Old here, but for now, to avoid\n@@ -2873,10 +2873,10 @@ package body Binde is\n             end if;\n \n             --  If there are no nodes with predecessors, then either we are\n-            --  done, as indicated by Num_Left being set to zero, or we have\n-            --  a circularity. In the latter case, diagnose the circularity,\n-            --  removing it from the graph and continue.\n-            --  ????But Diagnose_Elaboration_Problem always raises an\n+            --  done, as indicated by Num_Left being set to zero, or we have a\n+            --  circularity. In the latter case, diagnose the circularity,\n+            --  removing it from the graph and\n+            --  continue. Diagnose_Elaboration_Problem always raises an\n             --  exception, so the loop never goes around more than once.\n \n             Get_No_Pred : while No_Pred = No_Unit_Id loop\n@@ -3086,11 +3086,11 @@ package body Binde is\n          Outer : loop\n \n             --  If there are no nodes with predecessors, then either we are\n-            --  done, as indicated by Num_Left being set to zero, or we have\n-            --  a circularity. In the latter case, diagnose the circularity,\n+            --  done, as indicated by Num_Left being set to zero, or we have a\n+            --  circularity. In the latter case, diagnose the circularity,\n             --  removing it from the graph and continue.\n-            --  ????But Diagnose_Elaboration_Problem always raises an\n-            --  exception, so the loop never goes around more than once.\n+            --  Diagnose_Elaboration_Problem always raises an exception, so the\n+            --  loop never goes around more than once.\n \n             Get_No_Pred : while No_Pred = No_Unit_Id loop\n                exit Outer when Num_Left < 1;"}, {"sha": "b124a42228390576bab4382c64c754da861f1569", "filename": "gcc/ada/bindo-writers.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fbindo-writers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fbindo-writers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -1689,8 +1689,8 @@ package body Bindo.Writers is\n          if Contains (Set, Source) then\n             return;\n \n-         --  Nothing to do for internal source files unless switch -Ra (???) is\n-         --  in effect.\n+         --  Nothing to do for internal source files unless switch -Ra is in\n+         --  effect.\n \n          elsif Is_Internal_File_Name (Source)\n            and then not List_Closure_All"}, {"sha": "c92cbd4a2e205b4ef5bdae4d9ca234be8d61f519", "filename": "gcc/ada/debug_a.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fdebug_a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fdebug_a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug_a.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -46,6 +46,12 @@ package body Debug_A is\n    --  recursion levels, we just don't reset the right value on exit, which\n    --  is not crucial, since this is only for debugging.\n \n+   --  Note that Current_Error_Node must be maintained unconditionally (not\n+   --  only when Debug_Flag_A is True), because we want to print a correct sloc\n+   --  in bug boxes. Also, Current_Error_Node is not just used for printing bug\n+   --  boxes. For example, an incorrect Current_Error_Node can cause some code\n+   --  in Rtsfind to malfunction.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -75,8 +81,6 @@ package body Debug_A is\n \n       --  Now push the new element\n \n-      --  Why is this done unconditionally???\n-\n       Debug_A_Depth := Debug_A_Depth + 1;\n \n       if Debug_A_Depth <= Max_Node_Ids then\n@@ -103,8 +107,6 @@ package body Debug_A is\n       --  We look down the stack to find something with a decent Sloc. (If\n       --  we find nothing, just leave it unchanged which is not so terrible)\n \n-      --  This seems nasty overhead for the normal case ???\n-\n       for J in reverse 1 .. Integer'Min (Max_Node_Ids, Debug_A_Depth) loop\n          if Sloc (Node_Ids (J)) > No_Location then\n             Current_Error_Node := Node_Ids (J);"}, {"sha": "855723add81f65a461e0a2b82e96a602cdcbc32d", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -1825,10 +1825,6 @@ package body Errout is\n       F := First_Node (N);\n       S := Sloc (F);\n \n-      --  ??? Protect against inconsistency in locations, by returning S\n-      --  immediately if not in the expected range, rather than failing with\n-      --  a Constraint_Error when accessing Source_Text(SI)(S)\n-\n       if S not in SF .. SL then\n          return S;\n       end if;\n@@ -1944,10 +1940,6 @@ package body Errout is\n       F := Last_Node (N);\n       S := Sloc (F);\n \n-      --  ??? Protect against inconsistency in locations, by returning S\n-      --  immediately if not in the expected range, rather than failing with\n-      --  a Constraint_Error when accessing Source_Text(SI)(S)\n-\n       if S not in SF .. SL then\n          return S;\n       end if;"}, {"sha": "5b0ba1967300b661a00b0f9b0cfbb9cca429fbc7", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 14, "deletions": 52, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -3030,10 +3030,8 @@ package body Exp_Ch4 is\n       --  check when creating the upper bound. This is needed to avoid junk\n       --  overflow checks in the common case of String types.\n \n-      --  ??? Disabled for now\n-\n-      --  elsif Istyp = Standard_Positive then\n-      --     Artyp := Standard_Unsigned;\n+      elsif Istyp = Standard_Positive then\n+         Artyp := Standard_Unsigned;\n \n       --  For modular types, we use a 32-bit modular type for types whose size\n       --  is in the range 1-31 bits. For 32-bit unsigned types, we use the\n@@ -3793,7 +3791,7 @@ package body Exp_Ch4 is\n       --  Bounds in Minimize calls, not used currently\n \n       LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n-      --  Entity for Long_Long_Integer'Base (Standard should export this???)\n+      --  Entity for Long_Long_Integer'Base\n \n    begin\n       Minimize_Eliminate_Overflows (Lop, Lo, Hi, Top_Level => False);\n@@ -4489,10 +4487,6 @@ package body Exp_Ch4 is\n          --  are too large, and which in the absence of a check results in\n          --  undetected chaos ???\n \n-         --  Note in particular that this is a pessimistic estimate in the\n-         --  case of packed array types, where an array element might occupy\n-         --  just a fraction of a storage element???\n-\n          declare\n             Idx : Node_Id := First_Index (E);\n             Len : Node_Id;\n@@ -4614,9 +4608,10 @@ package body Exp_Ch4 is\n       end if;\n \n       --  RM E.2.2(17). We enforce that the expected type of an allocator\n-      --  shall not be a remote access-to-class-wide-limited-private type\n-\n-      --  Why is this being done at expansion time, seems clearly wrong ???\n+      --  shall not be a remote access-to-class-wide-limited-private type.\n+      --  We probably shouldn't be doing this legality check during expansion,\n+      --  but this is only an issue for Annex E users, and is unlikely to be a\n+      --  problem in practice.\n \n       Validate_Remote_Access_To_Class_Wide_Type (N);\n \n@@ -5558,10 +5553,8 @@ package body Exp_Ch4 is\n       if Is_Copy_Type (Typ) then\n          Target_Typ := Typ;\n \n-         --  ??? Do not perform the optimization when the return statement is\n-         --  within a predicate function, as this causes spurious errors. Could\n-         --  this be a possible mismatch in handling this case somewhere else\n-         --  in semantic analysis?\n+         --  Do not perform the optimization when the return statement is\n+         --  within a predicate function, as this causes spurious errors.\n \n          Optimize_Return_Stmt :=\n            Nkind (Par) = N_Simple_Return_Statement and then not In_Predicate;\n@@ -6345,13 +6338,11 @@ package body Exp_Ch4 is\n             --  perspective.\n \n             if Comes_From_Source (Obj_Ref) then\n-\n-               --  Recover the actual object reference. There may be more cases\n-               --  to consider???\n-\n                loop\n                   if Nkind (Obj_Ref) in\n-                       N_Type_Conversion | N_Unchecked_Type_Conversion\n+                       N_Type_Conversion |\n+                       N_Unchecked_Type_Conversion |\n+                       N_Qualified_Expression\n                   then\n                      Obj_Ref := Expression (Obj_Ref);\n                   else\n@@ -6496,8 +6487,6 @@ package body Exp_Ch4 is\n          begin\n             --  If test is explicit x'First .. x'Last, replace by valid check\n \n-            --  Could use some individual comments for this complex test ???\n-\n             if Is_Scalar_Type (Ltyp)\n \n               --  And left operand is X'First where X matches left operand\n@@ -8105,10 +8094,6 @@ package body Exp_Ch4 is\n          Enclosing_Scope : constant Node_Id := Scope (Typ);\n          E : Entity_Id;\n       begin\n-         --  Prune this search by somehow not looking at decls that precede\n-         --  the declaration of the first view of Typ (which might be a partial\n-         --  view)???\n-\n          for Private_Entities in Boolean loop\n             if Private_Entities then\n                if Ekind (Enclosing_Scope) /= E_Package then\n@@ -12702,17 +12687,7 @@ package body Exp_Ch4 is\n \n       --  At this stage, either the conversion node has been transformed into\n       --  some other equivalent expression, or left as a conversion that can be\n-      --  handled by Gigi, in the following cases:\n-\n-      --    Conversions with no change of representation or type\n-\n-      --    Numeric conversions involving integer, floating- and fixed-point\n-      --    values. Fixed-point values are allowed only if Conversion_OK is\n-      --    set, i.e. if the fixed-point values are to be treated as integers.\n-\n-      --  No other conversions should be passed to Gigi\n-\n-      --  Check: are these rules stated in sinfo??? if so, why restate here???\n+      --  handled by Gigi.\n \n       --  The only remaining step is to generate a range check if we still have\n       --  a type conversion at this stage and Do_Range_Check is set. Note that\n@@ -12831,14 +12806,7 @@ package body Exp_Ch4 is\n       --  an Assignment_OK indication which must be propagated to the operand.\n \n       if Operand_Type = Target_Type then\n-\n-         --  Code duplicates Expand_N_Unchecked_Expression above, factor???\n-\n-         if Assignment_OK (N) then\n-            Set_Assignment_OK (Operand);\n-         end if;\n-\n-         Rewrite (N, Relocate_Node (Operand));\n+         Expand_N_Unchecked_Expression (N);\n          return;\n       end if;\n \n@@ -12869,9 +12837,6 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  Otherwise force evaluation unless Assignment_OK flag is set (this\n-      --  flag indicates ??? More comments needed here)\n-\n       if Assignment_OK (N) then\n          null;\n       else\n@@ -13805,9 +13770,6 @@ package body Exp_Ch4 is\n    --  do not need to generate an actual or formal generic part, just the\n    --  instantiated function itself.\n \n-   --  Perhaps we could have the actual generic available in the run-time,\n-   --  obtained by rtsfind, and actually expand a real instantiation ???\n-\n    function Make_Array_Comparison_Op\n      (Typ : Entity_Id;\n       Nod : Node_Id) return Node_Id"}, {"sha": "8f3048c93a23af0c526175a4b50e55b568b165ff", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -995,9 +995,8 @@ procedure Gnatchop is\n \n       Buffer (Read_Ptr) := EOF;\n \n-      --  Comment needed for the following ???\n-      --  Under what circumstances can the test fail ???\n-      --  What is copy doing in that case???\n+      --  The following test can fail if there was an I/O error, in which case\n+      --  Success will be set to False.\n \n       if Read_Ptr = Length then\n          Contents := Buffer;"}, {"sha": "ce90cc22fb8e4c6fe7bad931e2a8e929b8abfe9c", "filename": "gcc/ada/gnatdll.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fgnatdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fgnatdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatdll.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -172,11 +172,8 @@ procedure Gnatdll is\n       --  Add the files listed in List_Filename (one by line) to the list\n       --  of file to handle\n \n-      Max_Files   : constant := 5_000;\n-      Max_Options : constant :=   100;\n-      --  These are arbitrary limits, a better way will be to use linked list.\n-      --  No, a better choice would be to use tables ???\n-      --  Limits on what???\n+      Max_Files   : constant := 50_000;\n+      Max_Options : constant :=  1_000;\n \n       Ofiles : Argument_List (1 .. Max_Files);\n       O      : Positive := Ofiles'First;"}, {"sha": "52e714a4e70b7b8a558616ac5504a480d40e1634", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 298, "deletions": 297, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -69,7 +69,7 @@ procedure Gnatlink is\n      Table_Initial        => 20,\n      Table_Increment      => 100,\n      Table_Name           => \"Gnatlink.Gcc_Linker_Options\");\n-   --  Comments needed ???\n+   --  Options to be passed to the gcc linker\n \n    package Libpath is new Table.Table (\n      Table_Component_Type => Character,\n@@ -78,7 +78,7 @@ procedure Gnatlink is\n      Table_Initial        => 4096,\n      Table_Increment      => 100,\n      Table_Name           => \"Gnatlink.Libpath\");\n-   --  Comments needed ???\n+   --  Library search path\n \n    package Linker_Options is new Table.Table (\n      Table_Component_Type => String_Access,\n@@ -87,7 +87,7 @@ procedure Gnatlink is\n      Table_Initial        => 20,\n      Table_Increment      => 100,\n      Table_Name           => \"Gnatlink.Linker_Options\");\n-   --  Comments needed ???\n+   --  Options to be passed to gnatlink\n \n    package Linker_Objects is new Table.Table (\n      Table_Component_Type => String_Access,\n@@ -204,12 +204,45 @@ procedure Gnatlink is\n    --  Indicates wether libgcc should be statically linked (use 'T') or\n    --  dynamically linked (use 'H') by default.\n \n+   Link_Max : Integer;\n+   pragma Import (C, Link_Max, \"__gnat_link_max\");\n+   --  Maximum number of bytes on the command line supported by the OS\n+   --  linker. Passed this limit the response file mechanism must be used\n+   --  if supported.\n+\n+   Run_Path_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n+   pragma Import (C, Run_Path_Option_Ptr, \"__gnat_run_path_option\");\n+   --  Pointer to string representing the native linker option which\n+   --  specifies the path where the dynamic loader should find shared\n+   --  libraries. Equal to null string if this system doesn't support it.\n+\n+   Libgcc_Subdir_Ptr : Interfaces.C.Strings.chars_ptr;\n+   pragma Import (C, Libgcc_Subdir_Ptr, \"__gnat_default_libgcc_subdir\");\n+   --  Pointer to string indicating the installation subdirectory where\n+   --  a default shared libgcc might be found.\n+\n+   Object_Library_Ext_Ptr : Interfaces.C.Strings.chars_ptr;\n+   pragma Import\n+     (C, Object_Library_Ext_Ptr, \"__gnat_object_library_extension\");\n+   --  Pointer to string specifying the default extension for\n+   --  object libraries, e.g. Unix uses \".a\".\n+\n+   Separate_Run_Path_Options : Boolean;\n+   for Separate_Run_Path_Options'Size use Character'Size;\n+   pragma Import\n+     (C, Separate_Run_Path_Options, \"__gnat_separate_run_path_options\");\n+   --  Whether separate rpath options should be emitted for each directory\n+\n+   function Get_Maximum_File_Name_Length return Integer;\n+   pragma Import (C, Get_Maximum_File_Name_Length,\n+                     \"__gnat_get_maximum_file_name_length\");\n+\n    function Base_Name (File_Name : String) return String;\n    --  Return just the file name part without the extension (if present)\n \n    procedure Check_Existing_Executable (File_Name : String);\n    --  Delete any existing executable to avoid accidentally updating the target\n-   --  of a symbolic link, but produce a Fatail_Error if File_Name matches any\n+   --  of a symbolic link, but produce a Fatal_Error if File_Name matches any\n    --  of the source file names. This avoids overwriting of extensionless\n    --  source files by accident on systems where executables do not have\n    --  extensions.\n@@ -229,6 +262,19 @@ procedure Gnatlink is\n    procedure Process_Binder_File (Name : String);\n    --  Reads the binder file and extracts linker arguments\n \n+   function Index (S, Pattern : String) return Natural;\n+   --  Return the last occurrence of Pattern in S, or 0 if none\n+\n+   procedure Search_Library_Path\n+     (Next_Line   : String;\n+      Nfirst      : Integer;\n+      Nlast       : Integer;\n+      Last        : Integer;\n+      GNAT_Static : Boolean;\n+      GNAT_Shared : Boolean);\n+   --  Given a Gnat standard library, search the library path to find the\n+   --  library location. Parameters are documented in Process_Binder_File.\n+\n    procedure Usage;\n    --  Display usage\n \n@@ -307,7 +353,6 @@ procedure Gnatlink is\n       pragma Unreferenced (Status);\n    begin\n       Status := unlink (Name'Address);\n-      --  Is it really right to ignore an error here ???\n    end Delete;\n \n    ---------------\n@@ -332,6 +377,23 @@ procedure Gnatlink is\n       Exit_Program (E_Fatal);\n    end Exit_With_Error;\n \n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index (S, Pattern : String) return Natural is\n+      Len : constant Natural := Pattern'Length;\n+\n+   begin\n+      for J in reverse S'First .. S'Last - Len + 1 loop\n+         if Pattern = S (J .. J + Len - 1) then\n+            return J;\n+         end if;\n+      end loop;\n+\n+      return 0;\n+   end Index;\n+\n    ------------------\n    -- Process_Args --\n    ------------------\n@@ -362,21 +424,19 @@ procedure Gnatlink is\n             Arg : constant String := Argument (Next_Arg);\n \n          begin\n-            --  Case of argument which is a switch\n-\n-            --  We definitely need section by section comments here ???\n+            --  This argument must not be parsed, just add it to the list of\n+            --  linker's options.\n \n             if Skip_Next then\n \n-               --  This argument must not be parsed, just add it to the\n-               --  list of linker's options.\n-\n                Skip_Next := False;\n \n                Linker_Options.Increment_Last;\n                Linker_Options.Table (Linker_Options.Last) :=\n                  new String'(Arg);\n \n+            --  Case of argument which is a switch\n+\n             elsif Arg'Length /= 0 and then Arg (1) = '-' then\n                if Arg'Length > 4 and then Arg (2 .. 5) = \"gnat\" then\n                   Exit_With_Error\n@@ -689,12 +749,6 @@ procedure Gnatlink is\n       Link_Bytes : Integer := 0;\n       --  Projected number of bytes for the linker command line\n \n-      Link_Max : Integer;\n-      pragma Import (C, Link_Max, \"__gnat_link_max\");\n-      --  Maximum number of bytes on the command line supported by the OS\n-      --  linker. Passed this limit the response file mechanism must be used\n-      --  if supported.\n-\n       Next_Line : String (1 .. 1000);\n       --  Current line value\n \n@@ -752,36 +806,10 @@ procedure Gnatlink is\n       RB_Nlast     : Integer;             -- Slice last index\n       RB_Nfirst    : Integer;             -- Slice first index\n \n-      Run_Path_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n-      pragma Import (C, Run_Path_Option_Ptr, \"__gnat_run_path_option\");\n-      --  Pointer to string representing the native linker option which\n-      --  specifies the path where the dynamic loader should find shared\n-      --  libraries. Equal to null string if this system doesn't support it.\n-\n-      Libgcc_Subdir_Ptr : Interfaces.C.Strings.chars_ptr;\n-      pragma Import (C, Libgcc_Subdir_Ptr, \"__gnat_default_libgcc_subdir\");\n-      --  Pointer to string indicating the installation subdirectory where\n-      --  a default shared libgcc might be found.\n-\n-      Object_Library_Ext_Ptr : Interfaces.C.Strings.chars_ptr;\n-      pragma Import\n-        (C, Object_Library_Ext_Ptr, \"__gnat_object_library_extension\");\n-      --  Pointer to string specifying the default extension for\n-      --  object libraries, e.g. Unix uses \".a\".\n-\n-      Separate_Run_Path_Options : Boolean;\n-      for Separate_Run_Path_Options'Size use Character'Size;\n-      pragma Import\n-        (C, Separate_Run_Path_Options, \"__gnat_separate_run_path_options\");\n-      --  Whether separate rpath options should be emitted for each directory\n-\n       procedure Get_Next_Line;\n       --  Read the next line from the binder file without the line\n       --  terminator.\n \n-      function Index (S, Pattern : String) return Natural;\n-      --  Return the last occurrence of Pattern in S, or 0 if none\n-\n       procedure Store_File_Context;\n       --  Store current file context, Fd position and current line data.\n       --  The file context is stored into the rollback data above (RB_*).\n@@ -823,23 +851,6 @@ procedure Gnatlink is\n          Nlast := Nlast - 1;\n       end Get_Next_Line;\n \n-      -----------\n-      -- Index --\n-      -----------\n-\n-      function Index (S, Pattern : String) return Natural is\n-         Len : constant Natural := Pattern'Length;\n-\n-      begin\n-         for J in reverse S'First .. S'Last - Len + 1 loop\n-            if Pattern = S (J .. J + Len - 1) then\n-               return J;\n-            end if;\n-         end loop;\n-\n-         return 0;\n-      end Index;\n-\n       ---------------------------\n       -- Rollback_File_Context --\n       ---------------------------\n@@ -1003,7 +1014,7 @@ procedure Gnatlink is\n          Create_Temp_File (Tname_FD, Tname);\n \n          --  ??? File descriptor should be checked to not be Invalid_FD.\n-         --  ??? Status of Write and Close operations should be checked, and\n+         --  Status of Write and Close operations should be checked, and\n          --  failure should occur if a status is wrong.\n \n          for J in Objs_Begin .. Objs_End loop\n@@ -1115,268 +1126,262 @@ procedure Gnatlink is\n                      Last := Nlast;\n                   end if;\n \n-                  --  Given a Gnat standard library, search the library path to\n-                  --  find the library location.\n+                  Search_Library_Path\n+                    (Next_Line   => Next_Line,\n+                     Nfirst      => Nfirst,\n+                     Nlast       => Nlast,\n+                     Last        => Last,\n+                     GNAT_Static => GNAT_Static,\n+                     GNAT_Shared => GNAT_Shared);\n \n-                  --  Shouldn't we abstract a proc here, we are getting awfully\n-                  --  heavily nested ???\n+               else\n+                  Linker_Options.Increment_Last;\n+                  Linker_Options.Table (Linker_Options.Last) :=\n+                    new String'(Next_Line (Nfirst .. Nlast));\n+               end if;\n+            end if;\n \n-                  declare\n-                     File_Path : String_Access;\n+            Xlinker_Was_Previous := Next_Line (Nfirst .. Nlast) = \"-Xlinker\";\n+\n+            Get_Next_Line;\n+            exit when Next_Line (Nfirst .. Nlast) = End_Info;\n+\n+            Next_Line (Nfirst .. Nlast - 8) := Next_Line (Nfirst + 8 .. Nlast);\n+            Nlast := Nlast - 8;\n+         end loop;\n+      end if;\n+\n+      --  If -shared was specified, invoke gcc with -shared-libgcc\n+\n+      if GNAT_Shared then\n+         Linker_Options.Increment_Last;\n+         Linker_Options.Table (Linker_Options.Last) := Shared_Libgcc;\n+      end if;\n \n-                     Object_Lib_Extension : constant String :=\n-                       Value (Object_Library_Ext_Ptr);\n+      Status := fclose (Fd);\n+   end Process_Binder_File;\n+\n+   -------------------------\n+   -- Search_Library_Path --\n+   -------------------------\n+\n+   procedure Search_Library_Path\n+     (Next_Line   : String;\n+      Nfirst      : Integer;\n+      Nlast       : Integer;\n+      Last        : Integer;\n+      GNAT_Static : Boolean;\n+      GNAT_Shared : Boolean)\n+   is\n+      File_Path : String_Access;\n \n-                     File_Name : constant String := \"lib\" &\n-                       Next_Line (Nfirst + 2 .. Last) & Object_Lib_Extension;\n+      Object_Lib_Extension : constant String :=\n+        Value (Object_Library_Ext_Ptr);\n \n-                     Run_Path_Opt : constant String :=\n-                       Value (Run_Path_Option_Ptr);\n+      File_Name : constant String := \"lib\" &\n+        Next_Line (Nfirst + 2 .. Last) & Object_Lib_Extension;\n \n-                     GCC_Index          : Natural;\n-                     Run_Path_Opt_Index : Natural := 0;\n+      Run_Path_Opt : constant String :=\n+        Value (Run_Path_Option_Ptr);\n+\n+      GCC_Index          : Natural;\n+      Run_Path_Opt_Index : Natural := 0;\n+\n+   begin\n+      File_Path :=\n+        Locate_Regular_File (File_Name,\n+          String (Libpath.Table (1 .. Libpath.Last)));\n+\n+      if File_Path /= null then\n+         if GNAT_Static then\n+\n+            --  If static gnatlib found, explicitly specify to overcome\n+            --  possible linker default usage of shared version.\n+\n+            Linker_Options.Increment_Last;\n+\n+            Linker_Options.Table (Linker_Options.Last) :=\n+              new String'(File_Path.all);\n+\n+         elsif GNAT_Shared then\n+            if Opt.Run_Path_Option then\n+\n+               --  If shared gnatlib desired, add appropriate system specific\n+               --  switch so that it can be located at runtime.\n+\n+               if Run_Path_Opt'Length /= 0 then\n+\n+                  --  Output the system specific linker command that allows the\n+                  --  image activator to find the shared library at\n+                  --  runtime. Also add path to find libgcc_s.so, if relevant.\n+\n+                  declare\n+                     Path : String (1 .. File_Path'Length + 15);\n+\n+                     Path_Last : constant Natural := File_Path'Length;\n \n                   begin\n-                     File_Path :=\n-                       Locate_Regular_File (File_Name,\n-                         String (Libpath.Table (1 .. Libpath.Last)));\n+                     Path (1 .. File_Path'Length) := File_Path.all;\n \n-                     if File_Path /= null then\n-                        if GNAT_Static then\n+                  --  To find the location of the shared version of libgcc, we\n+                  --  look for \"gcc-lib\" in the path of the library. However,\n+                  --  this subdirectory is no longer present in recent versions\n+                  --  of GCC. So, we look for the last subdirectory \"lib\" in\n+                  --  the path.\n \n-                           --  If static gnatlib found, explicitly specify to\n-                           --  overcome possible linker default usage of shared\n-                           --  version.\n+                     GCC_Index := Index (Path (1 .. Path_Last), \"gcc-lib\");\n \n-                           Linker_Options.Increment_Last;\n+                     if GCC_Index /= 0 then\n \n-                           Linker_Options.Table (Linker_Options.Last) :=\n-                             new String'(File_Path.all);\n-\n-                        elsif GNAT_Shared then\n-                           if Opt.Run_Path_Option then\n-\n-                              --  If shared gnatlib desired, add appropriate\n-                              --  system specific switch so that it can be\n-                              --  located at runtime.\n-\n-                              if Run_Path_Opt'Length /= 0 then\n-\n-                                 --  Output the system specific linker command\n-                                 --  that allows the image activator to find\n-                                 --  the shared library at runtime. Also add\n-                                 --  path to find libgcc_s.so, if relevant.\n-\n-                                 declare\n-                                    Path : String (1 .. File_Path'Length + 15);\n-\n-                                    Path_Last : constant Natural :=\n-                                                  File_Path'Length;\n-\n-                                 begin\n-                                    Path (1 .. File_Path'Length) :=\n-                                      File_Path.all;\n-\n-                                 --  To find the location of the shared version\n-                                 --  of libgcc, we look for \"gcc-lib\" in the\n-                                 --  path of the library. However, this\n-                                 --  subdirectory is no longer present in\n-                                 --  recent versions of GCC. So, we look for\n-                                 --  the last subdirectory \"lib\" in the path.\n-\n-                                    GCC_Index :=\n-                                      Index (Path (1 .. Path_Last), \"gcc-lib\");\n-\n-                                    if GCC_Index /= 0 then\n-\n-                                       --  The shared version of libgcc is\n-                                       --  located in the parent directory.\n-\n-                                       GCC_Index := GCC_Index - 1;\n-\n-                                    else\n-                                       GCC_Index :=\n-                                         Index\n-                                           (Path (1 .. Path_Last),\n-                                            \"/lib/\");\n-\n-                                       if GCC_Index = 0 then\n-                                          GCC_Index :=\n-                                            Index (Path (1 .. Path_Last),\n-                                                   Directory_Separator & \"lib\"\n-                                                   & Directory_Separator);\n-                                       end if;\n-\n-                                       --  If we have found a \"lib\" subdir in\n-                                       --  the path to libgnat, the possible\n-                                       --  shared libgcc of interest by default\n-                                       --  is in libgcc_subdir at the same\n-                                       --  level.\n-\n-                                       if GCC_Index /= 0 then\n-                                          declare\n-                                             Subdir : constant String :=\n-                                               Value (Libgcc_Subdir_Ptr);\n-                                          begin\n-                                             Path\n-                                               (GCC_Index + 1 ..\n-                                                GCC_Index + Subdir'Length) :=\n-                                               Subdir;\n-                                             GCC_Index :=\n-                                               GCC_Index + Subdir'Length;\n-                                          end;\n-                                       end if;\n-                                    end if;\n-\n-                                 --  Look for an eventual run_path_option in\n-                                 --  the linker switches.\n-\n-                                    if Separate_Run_Path_Options then\n-                                       Linker_Options.Increment_Last;\n-                                       Linker_Options.Table\n-                                         (Linker_Options.Last) :=\n-                                           new String'\n-                                             (Run_Path_Opt\n-                                              & File_Path\n-                                                (1 .. File_Path'Length\n-                                                 - File_Name'Length));\n-\n-                                       if GCC_Index /= 0 then\n-                                          Linker_Options.Increment_Last;\n-                                          Linker_Options.Table\n-                                            (Linker_Options.Last) :=\n-                                            new String'\n-                                              (Run_Path_Opt\n-                                               & Path (1 .. GCC_Index));\n-                                       end if;\n-\n-                                    else\n-                                       for J in reverse\n-                                         1 .. Linker_Options.Last\n-                                       loop\n-                                          if Linker_Options.Table (J) /= null\n-                                            and then\n-                                              Linker_Options.Table (J)'Length\n-                                                        > Run_Path_Opt'Length\n-                                            and then\n-                                              Linker_Options.Table (J)\n-                                                (1 .. Run_Path_Opt'Length) =\n-                                                                 Run_Path_Opt\n-                                          then\n-                                             --  We have found an already\n-                                             --  specified run_path_option:\n-                                             --  we will add to this\n-                                             --  switch, because only one\n-                                             --  run_path_option should be\n-                                             --  specified.\n-\n-                                             Run_Path_Opt_Index := J;\n-                                             exit;\n-                                          end if;\n-                                       end loop;\n-\n-                                       --  If there is no run_path_option, we\n-                                       --  need to add one.\n-\n-                                       if Run_Path_Opt_Index = 0 then\n-                                          Linker_Options.Increment_Last;\n-                                       end if;\n-\n-                                       if GCC_Index = 0 then\n-                                          if Run_Path_Opt_Index = 0 then\n-                                             Linker_Options.Table\n-                                               (Linker_Options.Last) :=\n-                                                 new String'\n-                                                   (Run_Path_Opt\n-                                                    & File_Path\n-                                                      (1 .. File_Path'Length\n-                                                       - File_Name'Length));\n-\n-                                          else\n-                                             Linker_Options.Table\n-                                               (Run_Path_Opt_Index) :=\n-                                                 new String'\n-                                                   (Linker_Options.Table\n-                                                     (Run_Path_Opt_Index).all\n-                                                    & Path_Separator\n-                                                    & File_Path\n-                                                      (1 .. File_Path'Length\n-                                                       - File_Name'Length));\n-                                          end if;\n-\n-                                       else\n-                                          if Run_Path_Opt_Index = 0 then\n-                                             Linker_Options.Table\n-                                               (Linker_Options.Last) :=\n-                                                 new String'\n-                                                   (Run_Path_Opt\n-                                                    & File_Path\n-                                                      (1 .. File_Path'Length\n-                                                       - File_Name'Length)\n-                                                    & Path_Separator\n-                                                    & Path (1 .. GCC_Index));\n-\n-                                          else\n-                                             Linker_Options.Table\n-                                               (Run_Path_Opt_Index) :=\n-                                                 new String'\n-                                                   (Linker_Options.Table\n-                                                     (Run_Path_Opt_Index).all\n-                                                    & Path_Separator\n-                                                    & File_Path\n-                                                      (1 .. File_Path'Length\n-                                                       - File_Name'Length)\n-                                                    & Path_Separator\n-                                                    & Path (1 .. GCC_Index));\n-                                          end if;\n-                                       end if;\n-                                    end if;\n-                                 end;\n-                              end if;\n-                           end if;\n+                        --  The shared version of libgcc is located in the\n+                        --  parent directory.\n \n-                           --  Then we add the appropriate -l switch\n+                        GCC_Index := GCC_Index - 1;\n \n+                     else\n+                        GCC_Index := Index (Path (1 .. Path_Last), \"/lib/\");\n+\n+                        if GCC_Index = 0 then\n+                           GCC_Index :=\n+                             Index (Path (1 .. Path_Last),\n+                                    Directory_Separator & \"lib\"\n+                                    & Directory_Separator);\n+                        end if;\n+\n+                        --  If we have found a \"lib\" subdir in the path to\n+                        --  libgnat, the possible shared libgcc of interest by\n+                        --  default is in libgcc_subdir at the same level.\n+\n+                        if GCC_Index /= 0 then\n+                           declare\n+                              Subdir : constant String :=\n+                                Value (Libgcc_Subdir_Ptr);\n+\n+                           begin\n+                              Path (GCC_Index + 1 .. GCC_Index + Subdir'Length)\n+                                := Subdir;\n+                              GCC_Index := GCC_Index + Subdir'Length;\n+                           end;\n+                        end if;\n+                     end if;\n+\n+                  --  Look for an eventual run_path_option in\n+                  --  the linker switches.\n+\n+                     if Separate_Run_Path_Options then\n+                        Linker_Options.Increment_Last;\n+                        Linker_Options.Table\n+                          (Linker_Options.Last) :=\n+                            new String'\n+                              (Run_Path_Opt\n+                               & File_Path\n+                                 (1 .. File_Path'Length\n+                                  - File_Name'Length));\n+\n+                        if GCC_Index /= 0 then\n                            Linker_Options.Increment_Last;\n                            Linker_Options.Table (Linker_Options.Last) :=\n-                             new String'(Next_Line (Nfirst .. Nlast));\n+                             new String'\n+                               (Run_Path_Opt\n+                                & Path (1 .. GCC_Index));\n                         end if;\n \n                      else\n-                        --  If gnatlib library not found, then add it anyway in\n-                        --  case some other mechanism may find it.\n+                        for J in reverse 1 .. Linker_Options.Last loop\n+                           if Linker_Options.Table (J) /= null\n+                             and then\n+                               Linker_Options.Table (J)'Length\n+                                         > Run_Path_Opt'Length\n+                             and then\n+                               Linker_Options.Table (J)\n+                                 (1 .. Run_Path_Opt'Length) =\n+                                                  Run_Path_Opt\n+                           then\n+                              --  We have found an already specified\n+                              --  run_path_option: we will add to this switch,\n+                              --  because only one run_path_option should be\n+                              --  specified.\n \n-                        Linker_Options.Increment_Last;\n-                        Linker_Options.Table (Linker_Options.Last) :=\n-                          new String'(Next_Line (Nfirst .. Nlast));\n+                              Run_Path_Opt_Index := J;\n+                              exit;\n+                           end if;\n+                        end loop;\n+\n+                        --  If there is no run_path_option, we need to add one.\n+\n+                        if Run_Path_Opt_Index = 0 then\n+                           Linker_Options.Increment_Last;\n+                        end if;\n+\n+                        if GCC_Index = 0 then\n+                           if Run_Path_Opt_Index = 0 then\n+                              Linker_Options.Table\n+                                (Linker_Options.Last) :=\n+                                  new String'\n+                                    (Run_Path_Opt\n+                                     & File_Path\n+                                       (1 .. File_Path'Length\n+                                        - File_Name'Length));\n+\n+                           else\n+                              Linker_Options.Table\n+                                (Run_Path_Opt_Index) :=\n+                                  new String'\n+                                    (Linker_Options.Table\n+                                      (Run_Path_Opt_Index).all\n+                                     & Path_Separator\n+                                     & File_Path\n+                                       (1 .. File_Path'Length\n+                                        - File_Name'Length));\n+                           end if;\n+\n+                        else\n+                           if Run_Path_Opt_Index = 0 then\n+                              Linker_Options.Table\n+                                (Linker_Options.Last) :=\n+                                  new String'\n+                                    (Run_Path_Opt\n+                                     & File_Path\n+                                       (1 .. File_Path'Length\n+                                        - File_Name'Length)\n+                                     & Path_Separator\n+                                     & Path (1 .. GCC_Index));\n+\n+                           else\n+                              Linker_Options.Table\n+                                (Run_Path_Opt_Index) :=\n+                                  new String'\n+                                    (Linker_Options.Table\n+                                      (Run_Path_Opt_Index).all\n+                                     & Path_Separator\n+                                     & File_Path\n+                                       (1 .. File_Path'Length\n+                                        - File_Name'Length)\n+                                     & Path_Separator\n+                                     & Path (1 .. GCC_Index));\n+                           end if;\n+                        end if;\n                      end if;\n                   end;\n-               else\n-                  Linker_Options.Increment_Last;\n-                  Linker_Options.Table (Linker_Options.Last) :=\n-                    new String'(Next_Line (Nfirst .. Nlast));\n                end if;\n             end if;\n \n-            Xlinker_Was_Previous := Next_Line (Nfirst .. Nlast) = \"-Xlinker\";\n-\n-            Get_Next_Line;\n-            exit when Next_Line (Nfirst .. Nlast) = End_Info;\n+            --  Then we add the appropriate -l switch\n \n-            Next_Line (Nfirst .. Nlast - 8) := Next_Line (Nfirst + 8 .. Nlast);\n-            Nlast := Nlast - 8;\n-         end loop;\n-      end if;\n+            Linker_Options.Increment_Last;\n+            Linker_Options.Table (Linker_Options.Last) :=\n+              new String'(Next_Line (Nfirst .. Nlast));\n+         end if;\n \n-      --  If -shared was specified, invoke gcc with -shared-libgcc\n+      else\n+         --  If gnatlib library not found, then add it anyway in\n+         --  case some other mechanism may find it.\n \n-      if GNAT_Shared then\n          Linker_Options.Increment_Last;\n-         Linker_Options.Table (Linker_Options.Last) := Shared_Libgcc;\n+         Linker_Options.Table (Linker_Options.Last) :=\n+           new String'(Next_Line (Nfirst .. Nlast));\n       end if;\n-\n-      Status := fclose (Fd);\n-   end Process_Binder_File;\n+   end Search_Library_Path;\n \n    -----------\n    -- Usage --\n@@ -1748,10 +1753,6 @@ begin\n       Fname     : constant String  := Base_Name (Ali_File_Name.all);\n       Fname_Len : Integer := Fname'Length;\n \n-      function Get_Maximum_File_Name_Length return Integer;\n-      pragma Import (C, Get_Maximum_File_Name_Length,\n-                        \"__gnat_get_maximum_file_name_length\");\n-\n       Maximum_File_Name_Length : constant Integer :=\n                                    Get_Maximum_File_Name_Length;\n "}, {"sha": "91a8bf24bc488691fcd0db045549773c93493def", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -1451,7 +1451,7 @@ package body Inline is\n            --  Skip inlining if the function returns an unconstrained type\n            --  using an extended return statement, since this part of the\n            --  new inlining model is not yet supported by the current\n-           --  implementation. ???\n+           --  implementation.\n \n            or else (Returns_Unconstrained_Type (Spec_Id)\n                      and then Has_Extended_Return)\n@@ -1531,7 +1531,6 @@ package body Inline is\n \n       function Is_Unit_Subprogram (Id : Entity_Id) return Boolean;\n       --  Return True if subprogram Id defines a compilation unit\n-      --  Shouldn't this be in Sem_Aux???\n \n       function In_Package_Spec (Id : Entity_Id) return Boolean;\n       --  Return True if subprogram Id is defined in the package specification,\n@@ -2161,10 +2160,7 @@ package body Inline is\n                Body_To_Inline :=\n                  Copy_Generic_Node (N, Empty, Instantiating => True);\n             else\n-               --  ??? Shouldn't this use New_Copy_Tree? What about global\n-               --  references captured in the body to inline?\n-\n-               Body_To_Inline := Copy_Separate_Tree (N);\n+               Body_To_Inline := New_Copy_Tree (N);\n             end if;\n \n             --  Remove aspects/pragmas that have no meaning in an inlined body\n@@ -3554,7 +3550,6 @@ package body Inline is\n       procedure Reset_Dispatching_Calls (N : Node_Id) is\n \n          function Do_Reset (N : Node_Id) return Traverse_Result;\n-         --  Comment required ???\n \n          --------------\n          -- Do_Reset --\n@@ -3620,7 +3615,6 @@ package body Inline is\n \n          --  If the context is an assignment, and the left-hand side is free of\n          --  side-effects, the replacement is also safe.\n-         --  Can this be generalized further???\n \n          elsif Nkind (Parent (N)) = N_Assignment_Statement\n            and then"}, {"sha": "42f29d7bb7d219fd2ac3f2b49405f76717517ae2", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -235,8 +235,8 @@ package body Layout is\n       Desig_Type : Entity_Id;\n \n    begin\n-      --  For string literal types, for now, kill the size always, this is\n-      --  because gigi does not like or need the size to be set ???\n+      --  For string literal types, kill the size always, because gigi does not\n+      --  like or need the size to be set.\n \n       if Ekind (E) = E_String_Literal_Subtype then\n          Set_Esize (E, Uint_0);\n@@ -448,7 +448,7 @@ package body Layout is\n \n             begin\n                --  For some reason, access types can cause trouble, So let's\n-               --  just do this for scalar types ???\n+               --  just do this for scalar types.\n \n                if Present (CT)\n                  and then Is_Scalar_Type (CT)"}, {"sha": "f561b6db0bc279c0cb018e75e7592f83fd3e3069", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -85,7 +85,7 @@ package body Lib.Load is\n \n       --  Note: for the following we should really generalize and consult the\n       --  file name pattern data, but for now we just deal with the common\n-      --  naming cases, which is probably good enough in practice ???\n+      --  naming cases, which is good enough in practice.\n \n       --  Change .adb to .ads\n \n@@ -424,7 +424,7 @@ package body Lib.Load is\n       --  it is part of the main extended source, otherwise reset them.\n \n       --  Note: it's a bit odd but PMES is False for subunits, which is why\n-      --  we have the OR here. Should be investigated some time???\n+      --  we have the OR here.\n \n       if PMES or Subunit then\n          Restore_Config_Cunit_Boolean_Restrictions;\n@@ -478,7 +478,7 @@ package body Lib.Load is\n             --  installing the context. The implicit with is on this entity,\n             --  not on the package it renames. This is somewhat redundant given\n             --  the with_clause just created, but it simplifies subsequent\n-            --  expansion of the current with_clause. Optimizable ???\n+            --  expansion of the current with_clause.\n \n             if Nkind (Error_Node) = N_With_Clause\n               and then Nkind (Name (Error_Node)) = N_Selected_Component"}, {"sha": "1aeedad839573ad2b41d52dbcb667f1b776e8c63", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -509,8 +509,8 @@ package body Lib is\n \n          if Counter > Max_Iterations then\n \n-            --  ??? Not quite right, but return a value to be able to generate\n-            --  SCIL files and hope for the best.\n+            --  In CodePeer_Mode, return a value to be able to generate SCIL\n+            --  files and hope for the best.\n \n             if CodePeer_Mode then\n                return No;"}, {"sha": "91ea7bbe8e547707a3aecb32923f139957d26012", "filename": "gcc/ada/live.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flive.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Flive.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -82,9 +82,6 @@ package body Live is\n    function Spec_Of (N : Node_Id) return Entity_Id;\n    --  Given a subprogram body N, return defining identifier of its declaration\n \n-   --  ??? the body of this package contains no comments at all, this\n-   --  should be fixed.\n-\n    -------------\n    -- Body_Of --\n    -------------"}, {"sha": "a134ae4e5705d22c6dae2081544fb31a6d55a135", "filename": "gcc/ada/mdll.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fmdll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fmdll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll.ads?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -27,7 +27,6 @@\n --  to build Windows DLL\n \n with GNAT.OS_Lib;\n---  Should have USE here ???\n \n package MDLL is\n "}, {"sha": "00987ad2fcf3777569df6977599a4a729958176a", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -442,7 +442,7 @@ package Namet is\n    --  The following routines operate on Global_Name_Buffer. New code should\n    --  use the routines above, and declare Bounded_Strings as local\n    --  variables. Existing code can be improved incrementally by removing calls\n-   --  to the following. ???If we eliminate all of these, we can remove\n+   --  to the following. If we eliminate all of these, we can remove\n    --  Global_Name_Buffer. But be sure to look at namet.h first.\n \n    --  To see what these do, look at the bodies. They are all trivially defined"}, {"sha": "ea52a7aa19f6b1abe1ae4c5bbbade69d3f9d476d", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -49,10 +49,11 @@ package body Osint is\n    use type CRTL.size_t;\n \n    Running_Program : Program_Type := Unspecified;\n-   --  comment required here ???\n+   --  Set by Set_Program to indicate which of Compiler, Binder, etc is\n+   --  running.\n \n    Program_Set : Boolean := False;\n-   --  comment required here ???\n+   --  True if Set_Program has been called; used to detect duplicate calls.\n \n    Std_Prefix : String_Ptr;\n    --  Standard prefix, computed dynamically the first time Relocate_Path\n@@ -151,9 +152,9 @@ package body Osint is\n    function To_Path_String_Access\n      (Path_Addr : Address;\n       Path_Len  : CRTL.size_t) return String_Access;\n-   --  Converts a C String to an Ada String. Are we doing this to avoid withing\n-   --  Interfaces.C.Strings ???\n-   --  Caller must free result.\n+   --  Converts a C String to an Ada String. We don't use a more general\n+   --  purpose facility, because we are dealing with low-level types like\n+   --  Address. Caller must free result.\n \n    function Include_Dir_Default_Prefix return String_Access;\n    --  Same as exported version, except returns a String_Access\n@@ -1348,11 +1349,8 @@ package body Osint is\n       Lib_File : out File_Name_Type;\n       Attr     : out File_Attributes)\n    is\n-      A : aliased File_Attributes;\n    begin\n-      --  ??? seems we could use Smart_Find_File here\n-      Find_File (N, Library, Lib_File, A'Access);\n-      Attr := A;\n+      Smart_Find_File (N, Library, Lib_File, Attr);\n    end Full_Lib_File_Name;\n \n    ------------------------\n@@ -1891,7 +1889,7 @@ package body Osint is\n                Name_Len := Full_Name'Length - 1;\n                Name_Buffer (1 .. Name_Len) :=\n                  Full_Name (1 .. Full_Name'Last - 1);\n-               Found := Name_Find;  --  ??? Was Name_Enter, no obvious reason\n+               Found := Name_Find;\n             end if;\n          end if;\n       end;"}, {"sha": "8dfa7c2062b3d73e2b4dda28ecd54d6be9ceefb2", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -29,11 +29,11 @@\n with Namet; use Namet;\n with Types; use Types;\n \n-with System;                  use System;\n+with System; use System;\n \n pragma Warnings (Off);\n --  This package is used also by gnatcoll\n-with System.OS_Lib;           use System.OS_Lib;\n+with System.OS_Lib; use System.OS_Lib;\n pragma Warnings (On);\n \n with System.Storage_Elements;"}, {"sha": "d952b3c2c219f737322bb4bd9a4fa2b9fb8ad2ee", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=0964be0713f6c9a9e6a2a0a3efe869b7570dc9ce", "patch": "@@ -4732,7 +4732,8 @@ package Sinfo is\n       --  Conversions from floating-point to integer are only handled in\n       --  the case where Float_Truncate flag set. Other conversions from\n       --  floating-point to integer (involving rounding) and all conversions\n-      --  involving fixed-point types are handled by the expander.\n+      --  involving fixed-point types are handled by the expander, unless the\n+      --  Conversion_OK flag is set.\n \n       --  Sprint syntax if Float_Truncate set: X^(Y)\n       --  Sprint syntax if Conversion_OK set X?(Y)"}]}