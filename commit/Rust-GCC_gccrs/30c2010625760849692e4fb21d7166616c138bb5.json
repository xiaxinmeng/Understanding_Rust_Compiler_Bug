{"sha": "30c2010625760849692e4fb21d7166616c138bb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBjMjAxMDYyNTc2MDg0OTY5MmU0ZmIyMWQ3MTY2NjE2YzEzOGJiNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-05T14:57:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-05T14:57:42Z"}, "message": "[multiple changes]\n\n2004-04-05  Vincent Celier  <celier@gnat.com>\n\n\t* adaint.h, adaint.c: Add function __gnat_named_file_length\n\n\t* impunit.adb: Add Ada.Directories to the list\n\n\t* Makefile.in: Add VMS and Windows versions of\n\tAda.Directories.Validity package body.\n\n\t* Makefile.rtl: Add a-direct and a-dirval\n\n\t* mlib-tgt.ads: Minor comment update.\n\n\t* a-dirval.ads, a-dirval.adb, 5vdirval.adb, 5wdirval.adb,\n\ta-direct.ads, a-direct.adb: New files.\n\n2004-04-05  Vincent Celier  <celier@gnat.com>\n\n\tPR ada/13620\n\t* make.adb (Scan_Make_Arg): Pass any -fxxx switches to gnatlink, not\n\tjust to the compiler.\n\n2004-04-05  Robert Dewar  <dewar@gnat.com>\n\n\t* a-except.adb (Exception_Name_Simple): Make sure lower bound of\n\treturned string is 1.\n\n\t* ali-util.adb: Use proper specific form for Warnings (Off, entity)\n\n\t* eval_fat.ads: Minor reformatting\n\n\t* g-curexc.ads: Document that lower bound of returned string values\n\tis always one.\n\n\t* gnatlink.adb: Add ??? comment for previous change\n\t(need to document why this is VMS specific)\n\n\t* s-stoele.ads: Minor reformatting\n\n\t* tbuild.ads: Minor reformatting throughout (new function specs)\n\n\t* par-ch10.adb (P_Context_Clause): Handle comma instead of semicolon\n\tafter WITH.\n\n\t* scng.adb: Minor reformatting\n\n2004-04-05  Geert Bosch  <bosch@gnat.com>\n\n\t* eval_fat.adb (Machine): Remove unnecessary suppression of warning.\n\t(Leading_Part): Still perform truncation to machine number if the\n\tspecified radix_digits is greater or equal to machine_mantissa.\n\n2004-04-05  Javier Miranda  <miranda@gnat.com>\n\n\t* par-ch3.adb: Complete documentation of previous change\n\tCorrect wrong syntax documentation of the OBJECT_DECLARATION rule\n\t(aliased must appear before constant).\n\n\t* par-ch4.adb: Complete documentation of previous change.\n\n\t* par-ch6.adb: Complete documentation of previous change.\n\n\t* sinfo.ads: Fix typo in commment.\n\n2004-04-05  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch3.adb (Inherit_Components): If derived type is private and has\n\tstored discriminants, use its discriminants to constrain parent type,\n\tas is done for non-private derived record types.\n\n\t* sem_ch4.adb (Remove_Abstract_Operations): New subprogram to implement\n\tAda 2005 AI-310: an abstract non-dispatching operation is not a\n\tcandidate interpretation in an overloaded call.\n\n\t* tbuild.adb (Unchecked_Convert_To): Preserve conversion node if\n\texpression is Null and target type is not an access type (e.g. a\n\tnon-private address type).\n\n2004-04-05  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* exp_ch6.adb (Rewrite_Function_Call): When rewriting an assignment\n\tstatement whose right-hand side is an inlined call, save a copy of the\n\toriginal assignment subtree to preserve enough consistency for\n\tAnalyze_Assignment to proceed.\n\n\t* sem_ch5.adb (Analyze_Assignment): Remove a costly copy of the\n\tcomplete assignment subtree which is now unnecessary, as the expansion\n\tof inlined call has been improved to preserve a consistent assignment\n\ttree.  Note_Possible_Modification must be called only\n\tafter checks have been applied, or else unnecessary checks will\n\tbe generated.\n\n\t* sem_util.adb (Note_Possible_Modification): Reorganise the handling\n\tof explicit dereferences that do not Come_From_Source:\n\t - be selective on cases where we must go back to the dereferenced\n\t   pointer (an assignment to an implicit dereference must not be\n\t   recorded as modifying the pointer);\n\t - do not rely on Original_Node being present (Analyze_Assignment\n\t   calls Note_Possible_Modification on a copied tree).\n\n\t* sem_warn.adb (Check_References): When an unset reference to a pointer\n\tthat is never assigned is encountered, prefer '<pointer> may be null'\n\twarning over '<pointer> is never assigned a value'.\n\n2004-04-05  Ramon Fernandez  <fernandez@gnat.com>\n\n\t* tracebak.c: Change STOP_FRAME in ppc vxworks to be compliant with\n\tthe ABI.\n\n2004-04-05  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* 5gmastop.adb (Pop_Frame): Comment out the pragma Linker_Option for\n\tlibexc. We currently don't reference anything in this library and\n\tlinking it in triggers linker warnings we don't want to see.\n\n\t* init.c: Update comments.\n\nFrom-SVN: r80431", "tree": {"sha": "2d91f19f11f8b38d7d3f5b5cf90649006ce6ddb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d91f19f11f8b38d7d3f5b5cf90649006ce6ddb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30c2010625760849692e4fb21d7166616c138bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c2010625760849692e4fb21d7166616c138bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30c2010625760849692e4fb21d7166616c138bb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30c2010625760849692e4fb21d7166616c138bb5/comments", "author": null, "committer": null, "parents": [{"sha": "4f976745b7f4deeed63381e21990fd2a2c2e2103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f976745b7f4deeed63381e21990fd2a2c2e2103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f976745b7f4deeed63381e21990fd2a2c2e2103"}], "stats": {"total": 2650, "additions": 2369, "deletions": 281}, "files": [{"sha": "74b1818f7528ad4493b5d73fa20a3c8aba5d75b8", "filename": "gcc/ada/5gmastop.adb", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2F5gmastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2F5gmastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gmastop.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -292,15 +292,6 @@ package body System.Machine_State_Operations is\n \n       procedure Exc_Unwind (Scp : Sigcontext_Ptr; Fde : Long_Integer := 0);\n       pragma Import (C, Exc_Unwind, \"exc_unwind\");\n-      pragma Linker_Options (\"-lexc\");\n-\n-   begin\n-      --  exc_unwind is apparently not thread-safe under IRIX, so protect it\n-      --  against race conditions within the GNAT run time.\n-      --  ??? Note that we might want to use a fine grained lock here since\n-      --  Lock_Task is used in many other places.\n-\n-      Lock_Task.all;\n \n       --  ??? Calling exc_unwind in the current setup does not work and\n       --  triggers the emission of system warning messages. Why it does\n@@ -312,7 +303,19 @@ package body System.Machine_State_Operations is\n       --  occurred and failed.\n \n       --  ??? Until this is fixed, we shall document that the backtrace\n-      --  computation facility does not work.\n+      --  computation facility does not work, and we inhibit the pragma below\n+      --  because we arrange for the call not to be emitted and the linker\n+      --  complains when a library is linked in but resolves nothing.\n+\n+      --  pragma Linker_Options (\"-lexc\");\n+\n+   begin\n+      --  exc_unwind is apparently not thread-safe under IRIX, so protect it\n+      --  against race conditions within the GNAT run time.\n+      --  ??? Note that we might want to use a fine grained lock here since\n+      --  Lock_Task is used in many other places.\n+\n+      Lock_Task.all;\n \n       if False then\n          Exc_Unwind (Scp);"}, {"sha": "76cae74aa34032648700b144db861e6be3f72207", "filename": "gcc/ada/5vdirval.adb", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2F5vdirval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2F5vdirval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vdirval.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -0,0 +1,175 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . D I R E C T O R I E S . V A L I D I T Y              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                              (VMS Version)                               --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the OpenVMS version of this package\n+\n+package body Ada.Directories.Validity is\n+\n+   Max_Number_Of_Characters : constant := 39;\n+   Max_Path_Length          : constant := 1_024;\n+\n+   Invalid_Character : constant array (Character) of Boolean :=\n+                         ('a' .. 'z' => False,\n+                          'A' .. 'Z' => False,\n+                          '_' | '$' | '-' | '.' => False,\n+                          others => True);\n+\n+   ------------------------\n+   -- Is_Valid_Path_Name --\n+   ------------------------\n+\n+   function Is_Valid_Path_Name (Name : String) return Boolean is\n+      First     : Positive := Name'First;\n+      Last      : Positive;\n+      Dot_Found : Boolean := False;\n+\n+   begin\n+      --  A valid path (directory) name cannot be empty, and cannot contain\n+      --  more than 1024 characters. Directories can be \".\", \"..\" or be simple\n+      --  name without extensions.\n+\n+      if Name'Length = 0 or else Name'Length > Max_Path_Length then\n+         return False;\n+\n+      else\n+         loop\n+            --  Look for the start of the next directory or file name\n+\n+            while First <= Name'Last and then Name (First) = '/' loop\n+               First := First + 1;\n+            end loop;\n+\n+            --  If all directories/file names are OK, return True\n+\n+            exit when First > Name'Last;\n+\n+            Last := First;\n+            Dot_Found := False;\n+\n+            --  Look for the end of the directory/file name\n+\n+            while Last < Name'Last loop\n+               exit when Name (Last + 1) = '/';\n+               Last := Last + 1;\n+\n+               if Name (Last) = '.' then\n+                  Dot_Found := True;\n+               end if;\n+            end loop;\n+\n+            --  If name include a dot, it can only be \".\", \"..\" or a the last\n+            --  file name.\n+\n+            if Dot_Found then\n+               if Name (First .. Last) /= \".\" and then\n+                  Name (First .. Last) /= \"..\"\n+               then\n+                  return Last = Name'Last\n+                    and then Is_Valid_Simple_Name (Name (First .. Last));\n+\n+               end if;\n+\n+            --  Check if the directory/file name is valid\n+\n+            elsif not Is_Valid_Simple_Name (Name (First .. Last)) then\n+                  return False;\n+            end if;\n+\n+            --  Move to the next name\n+\n+            First := Last + 1;\n+         end loop;\n+      end if;\n+\n+      --  If Name follows the rules, then it is valid\n+\n+      return True;\n+   end Is_Valid_Path_Name;\n+\n+   --------------------------\n+   -- Is_Valid_Simple_Name --\n+   --------------------------\n+\n+   function Is_Valid_Simple_Name (Name : String) return Boolean is\n+      In_Extension         : Boolean := False;\n+      Number_Of_Characters : Natural := 0;\n+\n+   begin\n+      --  A file name cannot be empty, and cannot have more than 39 characters\n+      --  before or after a single '.'.\n+\n+      if Name'Length = 0 then\n+         return False;\n+\n+      else\n+         --  Check each character for validity\n+\n+         for J in Name'Range loop\n+            if Invalid_Character (Name (J)) then\n+               return False;\n+\n+            elsif Name (J) = '.' then\n+\n+               --  Name cannot contain several dots\n+\n+               if In_Extension then\n+                  return False;\n+\n+               else\n+                  --  Reset the number of characters to count the characters\n+                  --  of the extension.\n+\n+                  In_Extension := True;\n+                  Number_Of_Characters := 0;\n+               end if;\n+\n+            else\n+               --  Check that the number of character is not too large\n+\n+               Number_Of_Characters := Number_Of_Characters + 1;\n+\n+               if Number_Of_Characters > Max_Number_Of_Characters then\n+                  return False;\n+               end if;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If the rules are followed, then it is valid\n+\n+      return True;\n+   end Is_Valid_Simple_Name;\n+\n+end Ada.Directories.Validity;\n+"}, {"sha": "4607fb1779137b44160d5e94a38dda69a1f6f8bc", "filename": "gcc/ada/5wdirval.adb", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2F5wdirval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2F5wdirval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wdirval.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -0,0 +1,142 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . D I R E C T O R I E S . V A L I D I T Y              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                            (Windows Version)                             --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Windows version of this package\n+\n+with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;\n+\n+package body Ada.Directories.Validity is\n+\n+   Invalid_Character : constant array (Character) of Boolean :=\n+                         (NUL .. US             => True,\n+                          '/' | ':' | '*' | '?' => True,\n+                          '\"' | '<' | '>' | '|' => True,\n+                          DEL .. NBSP           => True,\n+                          others                => False);\n+\n+   ------------------------\n+   -- Is_Valid_Path_Name --\n+   ------------------------\n+\n+   function Is_Valid_Path_Name (Name : String) return Boolean is\n+      Start : Positive := Name'First;\n+      Last  : Natural;\n+   begin\n+      --  A path name cannot be empty, cannot contain more than 256 characters,\n+      --  cannot contain invalid characters and each directory/file name need\n+      --  to be valid.\n+\n+      if Name'Length = 0 or else Name'Length > 256 then\n+         return False;\n+\n+      else\n+         --  A drive letter may be specified at the beginning\n+\n+         if Name'Length >= 2\n+           and then  Name (Start + 1) = ':'\n+           and then\n+            (Name (Start) in 'A' .. 'Z' or else\n+             Name (Start) in 'a' .. 'z')\n+         then\n+            Start := Start + 2;\n+         end if;\n+\n+         loop\n+            --  Look for the start of the next directory or file name\n+\n+            while Start <= Name'Last and then Name (Start) = '\\' loop\n+               Start := Start + 1;\n+            end loop;\n+\n+            --  If all directories/file names are OK, return True\n+\n+            exit when Start > Name'Last;\n+\n+            Last := Start;\n+\n+            --  Look for the end of the directory/file name\n+\n+            while Last < Name'Last loop\n+               exit when Name (Last + 1) = '\\';\n+               Last := Last + 1;\n+            end loop;\n+\n+            --  Check if the directory/file name is valid\n+\n+            if not Is_Valid_Simple_Name (Name (Start .. Last)) then\n+                  return False;\n+            end if;\n+\n+            --  Move to the next name\n+\n+            Start := Last + 1;\n+         end loop;\n+      end if;\n+\n+      --  If Name follows the rules, it is valid\n+\n+      return True;\n+   end Is_Valid_Path_Name;\n+\n+   --------------------------\n+   -- Is_Valid_Simple_Name --\n+   --------------------------\n+\n+   function Is_Valid_Simple_Name (Name : String) return Boolean is\n+      Only_Spaces : Boolean := True;\n+   begin\n+      --  A file name cannot be empty, cannot contain more than 256 characters,\n+      --  and cannot contain invalid characters, including '\\'\n+\n+      if Name'Length = 0 or else Name'Length > 256 then\n+         return False;\n+\n+      else\n+         for J in Name'Range loop\n+            if Invalid_Character (Name (J)) or else Name (J) = '\\' then\n+               return False;\n+\n+            elsif Name (J) /= ' ' then\n+               Only_Spaces := False;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If Name follows the rules, it is valid\n+\n+      return not Only_Spaces;\n+   end Is_Valid_Simple_Name;\n+\n+end Ada.Directories.Validity;\n+"}, {"sha": "2cd3dd6126fff8e52b55602916e28509d714d630", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -1,3 +1,120 @@\n+2004-04-05  Vincent Celier  <celier@gnat.com>\n+\n+\t* adaint.h, adaint.c: Add function __gnat_named_file_length\n+\n+\t* impunit.adb: Add Ada.Directories to the list\n+\n+\t* Makefile.in: Add VMS and Windows versions of\n+\tAda.Directories.Validity package body.\n+\n+\t* Makefile.rtl: Add a-direct and a-dirval\n+\n+\t* mlib-tgt.ads: Minor comment update.\n+\n+\t* a-dirval.ads, a-dirval.adb, 5vdirval.adb, 5wdirval.adb,\n+\ta-direct.ads, a-direct.adb: New files.\n+\n+2004-04-05  Vincent Celier  <celier@gnat.com>\n+\n+\tPR ada/13620\n+\t* make.adb (Scan_Make_Arg): Pass any -fxxx switches to gnatlink, not\n+\tjust to the compiler.\n+\n+2004-04-05  Robert Dewar  <dewar@gnat.com>\n+\n+\t* a-except.adb (Exception_Name_Simple): Make sure lower bound of\n+\treturned string is 1.\n+\n+\t* ali-util.adb: Use proper specific form for Warnings (Off, entity)\n+\n+\t* eval_fat.ads: Minor reformatting\n+\n+\t* g-curexc.ads: Document that lower bound of returned string values\n+\tis always one.\n+\n+\t* gnatlink.adb: Add ??? comment for previous change\n+\t(need to document why this is VMS specific)\n+\n+\t* s-stoele.ads: Minor reformatting\n+\n+\t* tbuild.ads: Minor reformatting throughout (new function specs)\n+\n+\t* par-ch10.adb (P_Context_Clause): Handle comma instead of semicolon\n+\tafter WITH.\n+\n+\t* scng.adb: Minor reformatting\n+\n+2004-04-05  Geert Bosch  <bosch@gnat.com>\n+\n+\t* eval_fat.adb (Machine): Remove unnecessary suppression of warning.\n+\t(Leading_Part): Still perform truncation to machine number if the\n+\tspecified radix_digits is greater or equal to machine_mantissa.\n+\n+2004-04-05  Javier Miranda  <miranda@gnat.com>\n+\n+\t* par-ch3.adb: Complete documentation of previous change\n+\tCorrect wrong syntax documentation of the OBJECT_DECLARATION rule\n+\t(aliased must appear before constant).\n+\n+\t* par-ch4.adb: Complete documentation of previous change.\n+\n+\t* par-ch6.adb: Complete documentation of previous change.\n+\n+\t* sinfo.ads: Fix typo in commment.\n+\n+2004-04-05  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch3.adb (Inherit_Components): If derived type is private and has\n+\tstored discriminants, use its discriminants to constrain parent type,\n+\tas is done for non-private derived record types.\n+\n+\t* sem_ch4.adb (Remove_Abstract_Operations): New subprogram to implement\n+\tAda 2005 AI-310: an abstract non-dispatching operation is not a\n+\tcandidate interpretation in an overloaded call.\n+\n+\t* tbuild.adb (Unchecked_Convert_To): Preserve conversion node if\n+\texpression is Null and target type is not an access type (e.g. a\n+\tnon-private address type).\n+\n+2004-04-05  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* exp_ch6.adb (Rewrite_Function_Call): When rewriting an assignment\n+\tstatement whose right-hand side is an inlined call, save a copy of the\n+\toriginal assignment subtree to preserve enough consistency for\n+\tAnalyze_Assignment to proceed.\n+\n+\t* sem_ch5.adb (Analyze_Assignment): Remove a costly copy of the\n+\tcomplete assignment subtree which is now unnecessary, as the expansion\n+\tof inlined call has been improved to preserve a consistent assignment\n+\ttree.  Note_Possible_Modification must be called only\n+\tafter checks have been applied, or else unnecessary checks will\n+\tbe generated.\n+\n+\t* sem_util.adb (Note_Possible_Modification): Reorganise the handling\n+\tof explicit dereferences that do not Come_From_Source:\n+\t - be selective on cases where we must go back to the dereferenced\n+\t   pointer (an assignment to an implicit dereference must not be\n+\t   recorded as modifying the pointer);\n+\t - do not rely on Original_Node being present (Analyze_Assignment\n+\t   calls Note_Possible_Modification on a copied tree).\n+\n+\t* sem_warn.adb (Check_References): When an unset reference to a pointer\n+\tthat is never assigned is encountered, prefer '<pointer> may be null'\n+\twarning over '<pointer> is never assigned a value'.\n+\n+2004-04-05  Ramon Fernandez  <fernandez@gnat.com>\n+\n+\t* tracebak.c: Change STOP_FRAME in ppc vxworks to be compliant with\n+\tthe ABI.\n+\n+2004-04-05  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* 5gmastop.adb (Pop_Frame): Comment out the pragma Linker_Option for\n+\tlibexc. We currently don't reference anything in this library and\n+\tlinking it in triggers linker warnings we don't want to see.\n+\n+\t* init.c: Update comments.\n+\n 2004-04-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (gnat_to_gnu_entity): Use TYPE_READONLY."}, {"sha": "072c9e8f7d627edd4426c03ba906d4bd4153c6eb", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -1178,6 +1178,7 @@ endif\n   a-caldel.adb<4vcaldel.adb \\\n   a-calend.adb<4vcalend.adb \\\n   a-calend.ads<4vcalend.ads \\\n+  a-dirval.adb<5vdirval.adb \\\n   a-excpol.adb<4wexcpol.adb \\\n   a-intnam.ads<4vintnam.ads \\\n   a-numaux.ads<4vnumaux.ads \\\n@@ -1227,6 +1228,7 @@ endif\n ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-calend.adb<4wcalend.adb \\\n+  a-dirval.adb<5wdirval.adb \\\n   a-excpol.adb<4wexcpol.adb \\\n   a-intnam.ads<4wintnam.ads \\\n   a-numaux.adb<86numaux.adb \\"}, {"sha": "3fe48f3016cd703ae36221cdb34410780574d09d", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -85,7 +85,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cwila9$(objext) \\\n   a-decima$(objext) \\\n   a-diocst$(objext) \\\n+  a-direct$(objext) \\\n   a-direio$(objext) \\\n+  a-dirval$(objext) \\\n   a-einuoc$(objext) \\\n   a-elchha$(objext) \\\n   a-except$(objext) \\"}, {"sha": "74757fe80778d7164ec2e8b38d768948f09b3187", "filename": "gcc/ada/a-direct.adb", "status": "added", "additions": 926, "deletions": 0, "changes": 926, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -0,0 +1,926 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      A D A . D I R E C T O R I E S                       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Directories.Validity; use Ada.Directories.Validity;\n+with Ada.Strings.Unbounded;    use Ada.Strings.Unbounded;\n+with Ada.Unchecked_Deallocation;\n+\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.OS_Lib;               use GNAT.OS_Lib;\n+with GNAT.Regexp;               use GNAT.Regexp;\n+\n+with System;\n+\n+package body Ada.Directories is\n+\n+   type Search_Data is record\n+      Is_Valid : Boolean := False;\n+      Name     : Ada.Strings.Unbounded.Unbounded_String;\n+      Pattern  : Regexp;\n+      Filter   : Filter_Type;\n+      Dir      : Dir_Type;\n+      Entry_Fetched : Boolean := False;\n+      Dir_Entry     : Directory_Entry_Type;\n+   end record;\n+\n+   Empty_String : constant String := (1 .. 0 => ASCII.NUL);\n+\n+   procedure Free is new Ada.Unchecked_Deallocation (Search_Data, Search_Ptr);\n+\n+   function File_Exists (Name : String) return Boolean;\n+   --  Returns True if the named file exists.\n+\n+   procedure Fetch_Next_Entry (Search : Search_Type);\n+   --  Get the next entry in a directory, setting Entry_Fetched if successful\n+   --  or resetting Is_Valid if not.\n+\n+   ---------------\n+   -- Base_Name --\n+   ---------------\n+\n+   function Base_Name (Name : String) return String is\n+      Simple : constant String := Simple_Name (Name);\n+      --  Simple'First is guaranteed to be 1\n+\n+   begin\n+      --  Look for the last dot in the file name and return the part of the\n+      --  file name preceding this last dot. If the first dot is the first\n+      --  character of the file name, the base name is the empty string.\n+\n+      for Pos in reverse Simple'Range loop\n+         if Simple (Pos) = '.' then\n+            return Simple (1 .. Pos - 1);\n+         end if;\n+      end loop;\n+\n+      --  If there is no dot, return the complete file name\n+\n+      return Simple;\n+   end Base_Name;\n+\n+   -------------\n+   -- Compose --\n+   -------------\n+\n+   function Compose\n+     (Containing_Directory : String := \"\";\n+      Name                 : String;\n+      Extension            : String := \"\") return String\n+   is\n+      Result : String (1 ..\n+                         Containing_Directory'Length +\n+                         Name'Length + Extension'Length + 2);\n+      Last   : Natural;\n+\n+   begin\n+      --  First, deal with the invalid cases\n+\n+      if not Is_Valid_Path_Name (Containing_Directory) then\n+         raise Name_Error;\n+\n+      elsif\n+        Extension'Length = 0 and then (not Is_Valid_Simple_Name (Name))\n+      then\n+         raise Name_Error;\n+\n+      elsif Extension'Length /= 0 and then\n+        (not Is_Valid_Simple_Name (Name & '.' & Extension))\n+      then\n+         raise Name_Error;\n+\n+         --  This is not an invalid case. Build the path name.\n+\n+      else\n+         Last := Containing_Directory'Length;\n+         Result (1 .. Last) := Containing_Directory;\n+\n+         --  Add a directory separator if needed\n+\n+         if Result (Last) /= Dir_Separator then\n+            Last := Last + 1;\n+            Result (Last) := Dir_Separator;\n+         end if;\n+\n+         --  Add the file name\n+\n+         Result (Last + 1 .. Last + Name'Length) := Name;\n+         Last := Last + Name'Length;\n+\n+         --  If extension was specified, add dot followed by this extension\n+\n+         if Extension'Length /= 0 then\n+            Last := Last + 1;\n+            Result (Last) := '.';\n+            Result (Last + 1 .. Last + Extension'Length) := Extension;\n+            Last := Last + Extension'Length;\n+         end if;\n+\n+         return Result (1 .. Last);\n+      end if;\n+   end Compose;\n+\n+   --------------------------\n+   -- Containing_Directory --\n+   --------------------------\n+\n+   function Containing_Directory (Name : String) return String is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error;\n+\n+      else\n+         --  Get the directory name using GNAT.Directory_Operations.Dir_Name\n+\n+         declare\n+            Value : constant String := Dir_Name (Path => Name);\n+            Result : String (1 .. Value'Length);\n+            Last : Natural := Result'Last;\n+\n+         begin\n+            Result := Value;\n+\n+            --  Remove any trailing directory separator, except as the first\n+            --  character.\n+\n+            while Last > 1 and then Result (Last) = Dir_Separator loop\n+               Last := Last - 1;\n+            end loop;\n+\n+            --  Special case of current directory, identified by \".\"\n+\n+            if Last = 1 and then Result (1) = '.' then\n+               return Get_Current_Dir;\n+\n+            else\n+               return Result (1 .. Last);\n+            end if;\n+         end;\n+      end if;\n+   end Containing_Directory;\n+\n+   ---------------\n+   -- Copy_File --\n+   ---------------\n+\n+   procedure Copy_File\n+     (Source_Name   : String;\n+      Target_Name   : String;\n+      Form          : String := \"\")\n+   is\n+      pragma Unreferenced (Form);\n+      Success : Boolean;\n+\n+   begin\n+      --  First, the invalid cases\n+\n+      if (not Is_Valid_Path_Name (Source_Name)) or else\n+        (not Is_Valid_Path_Name (Target_Name)) or else\n+        (not Is_Regular_File (Source_Name))\n+      then\n+         raise Name_Error;\n+\n+      elsif Is_Directory (Target_Name) then\n+         raise Use_Error;\n+\n+      else\n+         --  The implementation uses GNAT.OS_Lib.Copy_File, with parameters\n+         --  suitable for all platforms.\n+\n+         Copy_File\n+           (Source_Name, Target_Name, Success, Overwrite, None);\n+\n+         if not Success then\n+            raise Use_Error;\n+         end if;\n+      end if;\n+   end Copy_File;\n+\n+   ----------------------\n+   -- Create_Directory --\n+   ----------------------\n+\n+   procedure Create_Directory\n+     (New_Directory : String;\n+      Form          : String := \"\")\n+   is\n+      pragma Unreferenced (Form);\n+\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (New_Directory) then\n+         raise Name_Error;\n+\n+      else\n+         --  The implementation uses GNAT.Directory_Operations.Make_Dir\n+\n+         begin\n+            Make_Dir (Dir_Name => New_Directory);\n+\n+         exception\n+            when Directory_Error =>\n+               raise Use_Error;\n+         end;\n+      end if;\n+   end Create_Directory;\n+\n+   -----------------\n+   -- Create_Path --\n+   -----------------\n+\n+   procedure Create_Path\n+     (New_Directory : String;\n+      Form          : String := \"\")\n+   is\n+      pragma Unreferenced (Form);\n+\n+      New_Dir : String (1 .. New_Directory'Length + 1);\n+      Last    : Positive := 1;\n+\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (New_Directory) then\n+         raise Name_Error;\n+\n+      else\n+         --  Build New_Dir with a directory separator at the end, so that the\n+         --  complete path will be found in the loop below.\n+\n+         New_Dir (1 .. New_Directory'Length) := New_Directory;\n+         New_Dir (New_Dir'Last) := Directory_Separator;\n+\n+         --  Create, if necessary, each directory in the path\n+\n+         for J in 2 .. New_Dir'Last loop\n+\n+            --  Look for the end of an intermediate directory\n+\n+            if New_Dir (J) /= Dir_Separator then\n+               Last := J;\n+\n+            --  We have found a new intermediate directory each time we find\n+            --  a first directory separator.\n+\n+            elsif New_Dir (J - 1) /= Dir_Separator then\n+\n+               --  No need to create the directory if it already exists\n+\n+               if Is_Directory (New_Dir (1 .. Last)) then\n+                  null;\n+\n+               --  It is an error if a file with such a name already exists\n+\n+               elsif Is_Regular_File (New_Dir (1 .. Last)) then\n+                  raise Use_Error;\n+\n+               else\n+                  --  The implementation uses\n+                  --  GNAT.Directory_Operations.Make_Dir.\n+\n+                  begin\n+                     Make_Dir (Dir_Name => New_Dir (1 .. Last));\n+\n+                  exception\n+                     when Directory_Error =>\n+                        raise Use_Error;\n+                  end;\n+               end if;\n+            end if;\n+         end loop;\n+      end if;\n+   end Create_Path;\n+\n+   -----------------------\n+   -- Current_Directory --\n+   -----------------------\n+\n+   function Current_Directory return String is\n+   begin\n+      --  The implementation uses GNAT.Directory_Operations.Get_Current_Dir\n+\n+      return Get_Current_Dir;\n+   end Current_Directory;\n+\n+   ----------------------\n+   -- Delete_Directory --\n+   ----------------------\n+\n+   procedure Delete_Directory (Directory : String) is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Directory) then\n+         raise Name_Error;\n+\n+      else\n+         --  The implementation uses GNAT.Directory_Operations.Remove_Dir\n+\n+         begin\n+            Remove_Dir (Dir_Name => Directory, Recursive => False);\n+\n+         exception\n+            when Directory_Error =>\n+               raise Use_Error;\n+         end;\n+      end if;\n+   end Delete_Directory;\n+\n+   -----------------\n+   -- Delete_File --\n+   -----------------\n+\n+   procedure Delete_File (Name : String) is\n+      Success : Boolean;\n+\n+   begin\n+      --  First, the invalid cases\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error;\n+\n+      elsif not Is_Regular_File (Name) then\n+         raise Name_Error;\n+\n+      else\n+         --  The implementation uses GNAT.OS_Lib.Delete_File\n+\n+         Delete_File (Name, Success);\n+\n+         if not Success then\n+            raise Use_Error;\n+         end if;\n+      end if;\n+   end Delete_File;\n+\n+   -----------------\n+   -- Delete_Tree --\n+   -----------------\n+\n+   procedure Delete_Tree (Directory : String) is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Directory) then\n+         raise Name_Error;\n+\n+      else\n+         --  The implementation uses GNAT.Directory_Operations.Remove_Dir\n+\n+         begin\n+            Remove_Dir (Directory, Recursive => True);\n+\n+         exception\n+            when Directory_Error =>\n+               raise Use_Error;\n+         end;\n+      end if;\n+   end Delete_Tree;\n+\n+   ------------\n+   -- Exists --\n+   ------------\n+\n+   function Exists (Name : String) return Boolean is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error;\n+\n+      else\n+         --  The implementation is in File_Exists\n+\n+         return File_Exists (Name);\n+      end if;\n+   end Exists;\n+\n+   ---------------\n+   -- Extension --\n+   ---------------\n+\n+   function Extension (Name : String) return String is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error;\n+\n+      else\n+         --  Look fir the first dot that is not followed by a directory\n+         --  separator.\n+\n+         for Pos in reverse Name'Range loop\n+\n+            --  If a directory separator is found before a dot, there is no\n+            --  extension.\n+\n+            if Name (Pos) = Dir_Separator then\n+               return Empty_String;\n+\n+            elsif Name (Pos) = '.' then\n+\n+               --  We found a dot, build the return value with lower bound 1\n+\n+               declare\n+                  Result : String (1 .. Name'Last - Pos);\n+               begin\n+                  Result := Name (Pos + 1 .. Name'Last);\n+                  return Result;\n+               end;\n+            end if;\n+         end loop;\n+\n+         --  No dot were found, there is no extension\n+\n+         return Empty_String;\n+      end if;\n+   end Extension;\n+\n+   ----------------------\n+   -- Fetch_Next_Entry --\n+   ----------------------\n+\n+   procedure Fetch_Next_Entry (Search : Search_Type) is\n+      Name : String (1 .. 255);\n+      Last : Natural;\n+      Kind : File_Kind;\n+\n+   begin\n+      --  Search.Value.Is_Valid is always True when Fetch_Next_Entry is called\n+\n+      loop\n+         Read (Search.Value.Dir, Name, Last);\n+\n+         --  If no matching entry is found, set Is_Valid to False\n+\n+         if Last = 0 then\n+            Search.Value.Is_Valid := False;\n+            exit;\n+         end if;\n+\n+         --  Check if the entry matches the pattern\n+\n+         if Match (Name (1 .. Last), Search.Value.Pattern) then\n+            declare\n+               Full_Name : constant String :=\n+                             Compose\n+                               (To_String\n+                                  (Search.Value.Name), Name (1 .. Last));\n+               Found : Boolean := False;\n+\n+            begin\n+               if File_Exists (Full_Name) then\n+\n+                  --  Now check if the file kind matches the filter\n+\n+                  if Is_Regular_File (Full_Name) then\n+                     if Search.Value.Filter (Ordinary_File) then\n+                        Kind := Ordinary_File;\n+                        Found := True;\n+                     end if;\n+\n+                  elsif Is_Directory (Full_Name) then\n+                     if Search.Value.Filter (Directory) then\n+                        Kind := Directory;\n+                        Found := True;\n+                     end if;\n+\n+                  elsif Search.Value.Filter (Special_File) then\n+                     Kind := Special_File;\n+                     Found := True;\n+                  end if;\n+\n+                  --  If it does, update Search and return\n+\n+                  if Found then\n+                     Search.Value.Entry_Fetched := True;\n+                     Search.Value.Dir_Entry :=\n+                       (Is_Valid => True,\n+                        Simple   => To_Unbounded_String (Name (1 .. Last)),\n+                        Full     => To_Unbounded_String (Full_Name),\n+                        Kind     => Kind);\n+                     exit;\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end loop;\n+   end Fetch_Next_Entry;\n+\n+   -----------------\n+   -- File_Exists --\n+   -----------------\n+\n+   function File_Exists (Name : String) return Boolean is\n+      function C_File_Exists (A : System.Address) return Integer;\n+      pragma Import (C, C_File_Exists, \"__gnat_file_exists\");\n+\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+   begin\n+      C_Name (1 .. Name'Length) := Name;\n+      C_Name (C_Name'Last) := ASCII.NUL;\n+\n+      return C_File_Exists (C_Name (1)'Address) = 1;\n+   end File_Exists;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Search : in out Search_Type) is\n+   begin\n+      if Search.Value /= null then\n+\n+         --  Close the directory, if one is open\n+\n+         if Is_Open (Search.Value.Dir) then\n+            Close (Search.Value.Dir);\n+         end if;\n+\n+         Free (Search.Value);\n+      end if;\n+   end Finalize;\n+\n+   ---------------\n+   -- Full_Name --\n+   ---------------\n+\n+   function Full_Name (Name : String) return String is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error;\n+\n+      else\n+         --  Build the return value with lower bound 1.\n+         --  Use GNAT.OS_Lib.Normalize_Pathname.\n+\n+         declare\n+            Value : constant String := Normalize_Pathname (Name);\n+            Result : String (1 .. Value'Length);\n+         begin\n+            Result := Value;\n+            return Result;\n+         end;\n+      end if;\n+   end Full_Name;\n+\n+   function Full_Name (Directory_Entry : Directory_Entry_Type) return String is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Directory_Entry.Is_Valid then\n+         raise Status_Error;\n+\n+      else\n+         --  The value to return has already been computed\n+\n+         return To_String (Directory_Entry.Full);\n+      end if;\n+   end Full_Name;\n+\n+   --------------------\n+   -- Get_Next_Entry --\n+   --------------------\n+\n+   procedure Get_Next_Entry\n+     (Search          : in out Search_Type;\n+      Directory_Entry : out Directory_Entry_Type)\n+   is\n+   begin\n+      --  First, the invalid case\n+\n+      if Search.Value = null or else not Search.Value.Is_Valid then\n+         raise Status_Error;\n+      end if;\n+\n+      --  Fetch the next entry, if needed\n+\n+      if not Search.Value.Entry_Fetched then\n+         Fetch_Next_Entry (Search);\n+      end if;\n+\n+      --  It is an error if no valid entry is found\n+\n+      if not Search.Value.Is_Valid then\n+         raise Status_Error;\n+\n+      else\n+         --  Reset Entry_Fatched and return the entry\n+\n+         Search.Value.Entry_Fetched := False;\n+         Directory_Entry := Search.Value.Dir_Entry;\n+      end if;\n+   end Get_Next_Entry;\n+\n+   ----------\n+   -- Kind --\n+   ----------\n+\n+   function Kind (Name : String) return File_Kind is\n+   begin\n+      --  First, the invalid case\n+\n+      if not File_Exists (Name) then\n+         raise Name_Error;\n+\n+      elsif Is_Regular_File (Name) then\n+         return Ordinary_File;\n+\n+      elsif Is_Directory (Name) then\n+         return Directory;\n+\n+      else\n+         return Special_File;\n+      end if;\n+   end Kind;\n+\n+   function Kind (Directory_Entry : Directory_Entry_Type) return File_Kind is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Directory_Entry.Is_Valid then\n+         raise Status_Error;\n+\n+      else\n+         --  The value to return has already be computed\n+\n+         return Directory_Entry.Kind;\n+      end if;\n+   end Kind;\n+\n+   -----------------------\n+   -- Modification_Time --\n+   -----------------------\n+\n+   function Modification_Time (Name : String) return Ada.Calendar.Time is\n+      Date   : OS_Time;\n+      Year   : Year_Type;\n+      Month  : Month_Type;\n+      Day    : Day_Type;\n+      Hour   : Hour_Type;\n+      Minute : Minute_Type;\n+      Second : Second_Type;\n+\n+   begin\n+      --  First, the invalid cases\n+\n+\n+      if not (Is_Regular_File (Name) or else Is_Directory (Name)) then\n+         raise Name_Error;\n+\n+      else\n+         Date := File_Time_Stamp (Name);\n+         --  ???? We need to be able to convert OS_Time to Ada.Calendar.Time\n+         --  For now, use the component of the OS_Time to create the\n+         --  Calendar.Time value.\n+\n+         GM_Split (Date, Year, Month, Day, Hour, Minute, Second);\n+\n+         return Ada.Calendar.Time_Of\n+           (Year, Month, Day, Duration (Second + 60 * (Minute + 60 * Hour)));\n+      end if;\n+   end Modification_Time;\n+\n+   function Modification_Time\n+     (Directory_Entry : Directory_Entry_Type) return Ada.Calendar.Time\n+   is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Directory_Entry.Is_Valid then\n+         raise Status_Error;\n+\n+      else\n+         --  The value to return has already be computed\n+\n+         return Modification_Time (To_String (Directory_Entry.Full));\n+      end if;\n+   end Modification_Time;\n+\n+   ------------------\n+   -- More_Entries --\n+   ------------------\n+\n+   function More_Entries (Search : Search_Type) return Boolean is\n+   begin\n+      if Search.Value = null then\n+         return False;\n+\n+      elsif Search.Value.Is_Valid then\n+\n+         --  Fetch the next entry, if needed\n+\n+         if not Search.Value.Entry_Fetched then\n+            Fetch_Next_Entry (Search);\n+         end if;\n+      end if;\n+\n+      return Search.Value.Is_Valid;\n+   end More_Entries;\n+\n+   ------------\n+   -- Rename --\n+   ------------\n+\n+   procedure Rename (Old_Name, New_Name : String) is\n+      Success : Boolean;\n+\n+   begin\n+      --  First, the invalid cases\n+\n+      if not Is_Valid_Path_Name (Old_Name)\n+        or else not Is_Valid_Path_Name (New_Name)\n+        or else (not Is_Regular_File (Old_Name)\n+                   and then not Is_Directory (Old_Name))\n+      then\n+         raise Name_Error;\n+\n+      elsif Is_Regular_File (New_Name) or Is_Directory (New_Name) then\n+         raise Use_Error;\n+\n+      else\n+         --  The implemewntation uses GNAT.OS_Lib.Rename_File\n+\n+         Rename_File (Old_Name, New_Name, Success);\n+\n+         if not Success then\n+            raise Use_Error;\n+         end if;\n+      end if;\n+   end Rename;\n+\n+   -------------------\n+   -- Set_Directory --\n+   -------------------\n+\n+   procedure Set_Directory (Directory : String) is\n+   begin\n+      --  The implementation uses GNAT.Directory_Operations.Change_Dir\n+\n+      Change_Dir (Dir_Name => Directory);\n+\n+   exception\n+      when Directory_Error =>\n+         raise Name_Error;\n+   end Set_Directory;\n+\n+   -----------------\n+   -- Simple_Name --\n+   -----------------\n+\n+   function Simple_Name (Name : String) return String is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Valid_Path_Name (Name) then\n+         raise Name_Error;\n+\n+      else\n+         --  Build the value to return with lower bound 1.\n+         --  The implementation uses GNAT.Directory_Operations.Base_Name.\n+\n+         declare\n+            Value : constant String :=\n+                       GNAT.Directory_Operations.Base_Name (Name);\n+            Result : String (1 .. Value'Length);\n+         begin\n+            Result := Value;\n+            return Result;\n+         end;\n+      end if;\n+   end Simple_Name;\n+\n+   function Simple_Name\n+     (Directory_Entry : Directory_Entry_Type) return String\n+   is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Directory_Entry.Is_Valid then\n+         raise Status_Error;\n+\n+      else\n+         --  The value to return has already be computed\n+\n+         return To_String (Directory_Entry.Simple);\n+      end if;\n+   end Simple_Name;\n+\n+   ----------\n+   -- Size --\n+   ----------\n+\n+   function Size (Name : String) return File_Size is\n+      C_Name : String (1 .. Name'Length + 1);\n+\n+      function C_Size (Name : System.Address) return File_Size;\n+      pragma Import (C, C_Size, \"__gnat_named_file_length\");\n+\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Regular_File (Name) then\n+         raise Name_Error;\n+\n+      else\n+         C_Name (1 .. Name'Length) := Name;\n+         C_Name (C_Name'Last) := ASCII.NUL;\n+         return C_Size (C_Name'Address);\n+      end if;\n+   end Size;\n+\n+   function Size (Directory_Entry : Directory_Entry_Type) return File_Size is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Directory_Entry.Is_Valid then\n+         raise Status_Error;\n+\n+      else\n+         --  The value to return has already be computed\n+\n+         return Size (To_String (Directory_Entry.Full));\n+      end if;\n+   end Size;\n+\n+   ------------------\n+   -- Start_Search --\n+   ------------------\n+\n+   procedure Start_Search\n+     (Search    : in out Search_Type;\n+      Directory : String;\n+      Pattern   : String;\n+      Filter    : Filter_Type := (others => True))\n+   is\n+   begin\n+      --  First, the invalid case\n+\n+      if not Is_Directory (Directory) then\n+         raise Name_Error;\n+      end if;\n+\n+      --  If needed, finalize Search\n+\n+      Finalize (Search);\n+\n+      --  Allocate the default data\n+\n+      Search.Value := new Search_Data;\n+\n+      begin\n+         --  Check the pattern\n+\n+         Search.Value.Pattern := Compile (Pattern, Glob => True);\n+\n+      exception\n+         when Error_In_Regexp =>\n+            raise Name_Error;\n+      end;\n+\n+      --  Initialize some Search components\n+\n+      Search.Value.Filter := Filter;\n+      Search.Value.Name := To_Unbounded_String (Full_Name (Directory));\n+      Open (Search.Value.Dir, Directory);\n+      Search.Value.Is_Valid := True;\n+   end Start_Search;\n+\n+end Ada.Directories;\n+"}, {"sha": "b5ed79b3beedb877aeb4cc29b8d3957620669211", "filename": "gcc/ada/a-direct.ads", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-direct.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-direct.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -0,0 +1,415 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      A D A . D I R E C T O R I E S                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- This specification is derived for use with GNAT from AI-00248,  which is --\n+-- expected to be a part of a future expected revised Ada Reference Manual. --\n+-- The copyright notice above, and the license provisions that follow apply --\n+-- solely to the  contents of the part following the private keyword.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Ada0Y: Implementation of Ada.Directories (AI95-00248). Note that this\n+--  unit is available without -gnatX. That seems reasonable, since you only\n+--  get it if you explicitly ask for it.\n+\n+--  External files may be classified as directories, special files, or ordinary\n+--  files. A directory is an external file that is a container for files on\n+--  the target system. A special file is an external file that cannot be\n+--  created or read by a predefined Ada Input-Output package. External files\n+--  that are not special files or directories are called ordinary files.\n+\n+--  A file name is a string identifying an external file. Similarly, a\n+--  directory name is a string identifying a directory. The interpretation of\n+--  file names and directory names is implementation-defined.\n+\n+--  The full name of an external file is a full specification of the name of\n+--  the file. If the external environment allows alternative specifications of\n+--  the name (for example, abbreviations), the full name should not use such\n+--  alternatives. A full name typically will include the names of all of\n+--  directories that contain the item. The simple name of an external file is\n+--  the name of the item, not including any containing directory names. Unless\n+--  otherwise specified, a file name or directory name parameter to a\n+--  predefined Ada input-output subprogram can be a full name, a simple name,\n+--  or any other form of name supported by the implementation.\n+\n+--  The default directory is the directory that is used if a directory or\n+--  file name is not a full name (that is, when the name does not fully\n+--  identify all of the containing directories).\n+\n+--  A directory entry is a single item in a directory, identifying a single\n+--  external file (including directories and special files).\n+\n+--  For each function that returns a string, the lower bound of the returned\n+--  value is 1.\n+\n+with Ada.Calendar;\n+with Ada.Finalization;\n+with Ada.IO_Exceptions;\n+with Ada.Strings.Unbounded;\n+\n+package Ada.Directories is\n+\n+   -----------------------------------\n+   -- Directory and File Operations --\n+   -----------------------------------\n+\n+   function Current_Directory return String;\n+   --  Returns the full directory name for the current default directory. The\n+   --  name returned shall be suitable for a future call to Set_Directory.\n+   --  The exception Use_Error is propagated if a default directory is not\n+   --  supported by the external environment.\n+\n+   procedure Set_Directory (Directory : String);\n+   --  Sets the current default directory. The exception Name_Error is\n+   --  propagated if the string given as Directory does not identify an\n+   --  existing directory. The exception Use_Error is propagated if the\n+   --  external environment does not support making Directory (in the absence\n+   --  of Name_Error) a default directory.\n+\n+   procedure Create_Directory\n+     (New_Directory : String;\n+      Form          : String := \"\");\n+   --  Creates a directory with name New_Directory. The Form parameter can be\n+   --  used to give system-dependent characteristics of the directory; the\n+   --  interpretation of the Form parameter is implementation-defined. A null\n+   --  string for Form specifies the use of the default options of the\n+   --  implementation of the new directory. The exception Name_Error is\n+   --  propagated if the string given as New_Directory does not allow the\n+   --  identification of a directory. The exception Use_Error is propagated if\n+   --  the external environment does not support the creation of a directory\n+   --  with the given name (in the absence of Name_Error) and form.\n+\n+   procedure Delete_Directory (Directory : String);\n+   --  Deletes an existing empty directory with name Directory. The exception\n+   --  Name_Error is propagated if the string given as Directory does not\n+   --  identify an existing directory. The exception Use_Error is propagated\n+   --  if the external environment does not support the deletion of the\n+   --  directory (or some portion of its contents) with the given name (in the\n+   --  absence of Name_Error).\n+\n+   procedure Create_Path\n+     (New_Directory : String;\n+      Form          : String := \"\");\n+   --  Creates zero or more directories with name New_Directory. Each\n+   --  non-existent directory named by New_Directory is created. For example,\n+   --  on a typical Unix system, Create_Path (\"/usr/me/my\"); would create\n+   --  directory \"me\" in directory \"usr\", then create directory \"my\" in\n+   --  directory \"me\". The Form can be used to give system-dependent\n+   --  characteristics of the directory; the interpretation of the Form\n+   --  parameter is implementation-defined. A null string for Form specifies\n+   --  the use of the default options of the implementation of the new\n+   --  directory. The exception Name_Error is propagated if the string given\n+   --  as New_Directory does not allow the identification of any directory.\n+   --  The exception Use_Error is propagated if the external environment does\n+   --  not support the creation of any directories with the given name (in the\n+   --  absence of Name_Error) and form.\n+\n+   procedure Delete_Tree (Directory : String);\n+   --  Deletes an existing directory with name Directory. The directory and\n+   --  all of its contents (possibly including other directories) are deleted.\n+   --  The exception Name_Error is propagated if the string given as Directory\n+   --  does not identify an existing directory. The exception Use_Error is\n+   --  propagatedi f the external environment does not support the deletion of\n+   --  the directory or some portion of its contents with the given name (in\n+   --  the absence of Name_Error). If Use_Error is propagated, it is\n+   --  unspecified if a portion of the contents of the directory are deleted.\n+\n+   procedure Delete_File (Name : String);\n+   --  Deletes an existing ordinary or special file with Name. The exception\n+   --  Name_Error is propagated if the string given as Name does not identify\n+   --  an existing ordinary or special external file. The exception Use_Error\n+   --  is propagated if the external environment does not support the deletion\n+   --  of the file with the given name (in the absence of Name_Error).\n+\n+   procedure Rename (Old_Name, New_Name : String);\n+   --  Renames an existing external file (including directories) with Old_Name\n+   --  to New_Name. The exception Name_Error is propagated if the string given\n+   --  as Old_Name does not identify an existing external file. The exception\n+   --  Use_Error is propagated if the external environment does not support the\n+   --  renaming of the file with the given name (in the absence of Name_Error).\n+   --  In particular, Use_Error is propagated if a file or directory already\n+   --  exists with New_Name.\n+\n+   procedure Copy_File\n+     (Source_Name   : String;\n+      Target_Name   : String;\n+      Form          : String := \"\");\n+   --  Copies the contents of the existing external file with Source_Name\n+   --  to Target_Name. The resulting external file is a duplicate of the source\n+   --  external file. The Form can be used to give system-dependent\n+   --  characteristics of the resulting external file; the interpretation of\n+   --  the Form parameter is implementation-defined. Exception Name_Error is\n+   --  propagated if the string given as Source_Name does not identify an\n+   --  existing external ordinary or special file or if the string given as\n+   --  Target_Name does not allow the identification of an external file.\n+   --  The exception Use_Error is propagated if the external environment does\n+   --  not support the creating of the file with the name given by Target_Name\n+   --  and form given by Form, or copying of the file with the name given by\n+   --  Source_Name (in the absence of Name_Error).\n+\n+\n+   --  File and directory name operations:\n+\n+   function Full_Name (Name : String) return String;\n+   --  Returns the full name corresponding to the file name specified by Name.\n+   --  The exception Name_Error is propagated if the string given as Name does\n+   --  not allow the identification of an external file (including directories\n+   --  and special files).\n+\n+   function Simple_Name (Name : String) return String;\n+   --  Returns the simple name portion of the file name specified by Name. The\n+   --  exception Name_Error is propagated if the string given as Name does not\n+   --  allow the identification of an external file (including directories and\n+   --  special files).\n+\n+   function Containing_Directory (Name : String) return String;\n+   --  Returns the name of the containing directory of the external file\n+   --  (including directories) identified by Name. If more than one directory\n+   --  can contain Name, the directory name returned is implementation-defined.\n+   --  The exception Name_Error is propagated if the string given as Name does\n+   --  not allow the identification of an external file. The exception\n+   --  Use_Error is propagated if the external file does not have a containing\n+   --  directory.\n+\n+   function Extension (Name : String) return String;\n+   --  Returns the extension name corresponding to Name. The extension name is\n+   --  a portion of a simple name (not including any separator characters),\n+   --  typically used to identify the file class. If the external environment\n+   --  does not have extension names, then the null string is returned.\n+   --  The exception Name_Error is propagated if the string given as Name does\n+   --  not allow the identification of an external file.\n+\n+   function Base_Name (Name : String) return String;\n+   --  Returns the base name corresponding to Name. The base name is the\n+   --  remainder of a simple name after removing any extension and extension\n+   --  separators. The exception Name_Error is propagated if the string given\n+   --  as Name does not allow the identification of an external file\n+   --  (including directories and special files).\n+\n+   function Compose\n+     (Containing_Directory : String := \"\";\n+      Name                 : String;\n+      Extension            : String := \"\") return String;\n+   --  Returns the name of the external file with the specified\n+   --  Containing_Directory, Name, and Extension. If Extension is the null\n+   --  string, then Name is interpreted as a simple name; otherwise Name is\n+   --  interpreted as a base name. The exception Name_Error is propagated if\n+   --  the string given as Containing_Directory is not null and does not allow\n+   --  the identification of a directory, or if the string given as Extension\n+   --  is not null and is not a possible extension, or if the string given as\n+   --  Name is not a possible simple name (if Extension is null) or base name\n+   --  (if Extension is non-null).\n+\n+\n+   --  File and directory queries:\n+\n+   type File_Kind is (Directory, Ordinary_File, Special_File);\n+   --  The type File_Kind represents the kind of file represented by an\n+   --  external file or directory.\n+\n+   type File_Size is range 0 .. Long_Long_Integer'Last;\n+   --  The type File_Size represents the size of an external file.\n+\n+   function Exists (Name : String) return Boolean;\n+   --  Returns True if external file represented by Name exists, and False\n+   --  otherwise. The exception Name_Error is propagated if the string given as\n+   --  Name does not allow the identification of an external file (including\n+   --  directories and special files).\n+\n+   function Kind (Name : String) return File_Kind;\n+   --  Returns the kind of external file represented by Name. The exception\n+   --  Name_Error is propagated if the string given as Name does not allow the\n+   --  identification of an existing external file.\n+\n+   function Size (Name : String) return File_Size;\n+   --  Returns the size of the external file represented by Name. The size of\n+   --  an external file is the number of stream elements contained in the file.\n+   --  If the external file is discontiguous (not all elements exist), the\n+   --  result is implementation-defined. If the external file is not an\n+   --  ordinary file, the result is implementation-defined. The exception\n+   --  Name_Error is propagated if the string given as Name does not allow the\n+   --  identification of an existing external file. The exception\n+   --  Constraint_Error is propagated if the file size is not a value of type\n+   --  File_Size.\n+\n+   function Modification_Time (Name : String) return Ada.Calendar.Time;\n+   --  Returns the time that the external file represented by Name was most\n+   --  recently modified. If the external file is not an ordinary file, the\n+   --  result is implementation-defined. The exception Name_Error is propagated\n+   --  if the string given as Name does not allow the identification of an\n+   --  existing external file. The exception Use_Error is propagated if the\n+   --  external environment does not support the reading the modification time\n+   --  of the file with the name given by Name (in the absence of Name_Error).\n+\n+   -------------------------\n+   -- Directory Searching --\n+   -------------------------\n+\n+   type Directory_Entry_Type is limited private;\n+   --  The type Directory_Entry_Type represents a single item in a directory.\n+   --  These items can only be created by the Get_Next_Entry procedure in this\n+   --  package. Information about the item can be obtained from the functions\n+   --  declared in this package. A default initialized object of this type is\n+   --  invalid; objects returned from Get_Next_Entry are valid.\n+\n+   type Filter_Type is array (File_Kind) of Boolean;\n+   --  The type Filter_Type specifies which directory entries are provided from\n+   --  a search operation. If the Directory component is True, directory\n+   --  entries representing directories are provided. If the Ordinary_File\n+   --  component is True, directory entries representing ordinary files are\n+   --  provided. If the Special_File component is True, directory entries\n+   --  representing special files are provided.\n+\n+   type Search_Type is limited private;\n+   --  The type Search_Type contains the state of a directory search. A\n+   --  default-initialized Search_Type object has no entries available\n+   --  (More_Entries returns False).\n+\n+   procedure Start_Search\n+     (Search    : in out Search_Type;\n+      Directory : String;\n+      Pattern   : String;\n+      Filter    : Filter_Type := (others => True));\n+   --  Starts a search in the directory entry in the directory named by\n+   --  Directory for entries matching Pattern. Pattern represents a file name\n+   --  matching pattern. If Pattern is null, all items in the directory are\n+   --  matched; otherwise, the interpretation of Pattern is\n+   --  implementation-defined. Only items which match Filter will be returned.\n+   --  After a successful call on Start_Search, the object Search may have\n+   --  entries available, but it may have no entries available if no files or\n+   --  directories match Pattern and Filter. The exception Name_Error is\n+   --  propagated if the string given by Directory does not identify an\n+   --  existing directory, or if Pattern does not allow the identification of\n+   --  any possible external file or directory. The exception Use_Error is\n+   --  propagated if the external environment does not support the searching\n+   --  of the directory with the given name (in the absence of Name_Error).\n+\n+   procedure End_Search (Search : in out Search_Type);\n+   --  Ends the search represented by Search. After a successful call on\n+   --  End_Search, the object Search will have no entries available.\n+\n+   function More_Entries (Search : Search_Type) return Boolean;\n+   --  Returns True if more entries are available to be returned by a call\n+   --  to Get_Next_Entry for the specified search object, and False otherwise.\n+\n+   procedure Get_Next_Entry\n+     (Search          : in out Search_Type;\n+      Directory_Entry : out Directory_Entry_Type);\n+   --  Returns the next Directory_Entry for the search described by Search that\n+   --  matches the pattern and filter. If no further matches are available,\n+   --  Status_Error is raised. It is implementation-defined as to whether the\n+   --  results returned by this routine are altered if the contents of the\n+   --  directory are altered while the Search object is valid (for example, by\n+   --  another program). The exception Use_Error is propagated if the external\n+   --  environment does not support continued searching of the directory\n+   --  represented by Search.\n+\n+   -------------------------------------\n+   -- Operations on Directory Entries --\n+   -------------------------------------\n+\n+   function Simple_Name (Directory_Entry : Directory_Entry_Type) return String;\n+   --  Returns the simple external name of the external file (including\n+   --  directories) represented by Directory_Entry. The format of the name\n+   --  returned is implementation-defined. The exception Status_Error is\n+   --  propagated if Directory_Entry is invalid.\n+\n+   function Full_Name (Directory_Entry : Directory_Entry_Type) return String;\n+   --  Returns the full external name of the external file (including\n+   --  directories) represented by Directory_Entry. The format of the name\n+   --  returned is implementation-defined. The exception Status_Error is\n+   --  propagated if Directory_Entry is invalid.\n+\n+   function Kind (Directory_Entry : Directory_Entry_Type) return File_Kind;\n+   --  Returns the kind of external file represented by Directory_Entry. The\n+   --  exception Status_Error is propagated if Directory_Entry is invalid.\n+\n+   function Size (Directory_Entry : Directory_Entry_Type) return File_Size;\n+   --  Returns the size of the external file represented by Directory_Entry.\n+   --  The size of an external file is the number of stream elements contained\n+   --  in the file. If the external file is discontiguous (not all elements\n+   --  exist), the result is implementation-defined. If the external file\n+   --  represented by Directory_Entry is not an ordinary file, the result is\n+   --  implementation-defined. The exception Status_Error is propagated if\n+   --  Directory_Entry is invalid. The exception Constraint_Error is propagated\n+   --  if the file size is not a value of type File_Size.\n+\n+   function Modification_Time\n+     (Directory_Entry : Directory_Entry_Type) return Ada.Calendar.Time;\n+   --  Returns the time that the external file represented by Directory_Entry\n+   --  was most recently modified. If the external file represented by\n+   --  Directory_Entry is not an ordinary file, the result is\n+   --  implementation-defined. The exception Status_Error is propagated if\n+   --  Directory_Entry is invalid. The exception Use_Error is propagated if\n+   --  the external environment does not support the reading the modification\n+   --  time of the file represented by Directory_Entry.\n+\n+   ----------------\n+   -- Exceptions --\n+   ----------------\n+\n+   Status_Error : exception renames Ada.IO_Exceptions.Status_Error;\n+   Name_Error   : exception renames Ada.IO_Exceptions.Name_Error;\n+   Use_Error    : exception renames Ada.IO_Exceptions.Use_Error;\n+   Device_Error : exception renames Ada.IO_Exceptions.Device_Error;\n+\n+private\n+   type Directory_Entry_Type is record\n+      Is_Valid : Boolean := False;\n+      Simple   : Ada.Strings.Unbounded.Unbounded_String;\n+      Full     : Ada.Strings.Unbounded.Unbounded_String;\n+      Kind     : File_Kind;\n+   end record;\n+\n+   --  The type Search_Data is defined in the body, so that the spec does not\n+   --  depend on packages of the GNAT hierarchy.\n+\n+   type Search_Data;\n+   type Search_Ptr is access Search_Data;\n+\n+   --  Search_Type need to be a controlled type, because it includes component\n+   --  of type Dir_Type (in GNAT.Directory_Operations) that need to be closed\n+   --  (if opened) during finalization.\n+   --  The component need to be an access value, because Search_Data is not\n+   --  fully defined in the spec.\n+\n+   type Search_Type is new Ada.Finalization.Controlled with record\n+      Value : Search_Ptr;\n+   end record;\n+\n+   procedure Finalize (Search : in out Search_Type);\n+   --  Close the directory, if opened, and deallocate Value.\n+\n+   procedure End_Search (Search : in out Search_Type) renames Finalize;\n+\n+end Ada.Directories;\n+\n+"}, {"sha": "f0740d2c0e0994f003e5cef062f9b548237b675c", "filename": "gcc/ada/a-dirval.adb", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-dirval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-dirval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -0,0 +1,90 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . D I R E C T O R I E S . V A L I D I T Y              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                             (POSIX Version)                              --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the POSIX version of this package\n+\n+package body Ada.Directories.Validity is\n+\n+   ------------------------\n+   -- Is_Valid_Path_Name --\n+   ------------------------\n+\n+   function Is_Valid_Path_Name   (Name : String) return Boolean is\n+   begin\n+      --  A path name cannot be empty and cannot contain any NUL character\n+\n+      if Name'Length = 0 then\n+         return False;\n+\n+      else\n+         for J in Name'Range loop\n+            if Name (J) = ASCII.NUL then\n+               return False;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If Name does not contain any NUL character, it is valid\n+\n+      return True;\n+   end Is_Valid_Path_Name;\n+\n+   --------------------------\n+   -- Is_Valid_Simple_Name --\n+   --------------------------\n+\n+   function Is_Valid_Simple_Name (Name : String) return Boolean is\n+   begin\n+      --  A file name cannot be empty and cannot contain a slash ('/') or\n+      --  the NUL character.\n+\n+      if Name'Length = 0 then\n+         return False;\n+\n+      else\n+         for J in Name'Range loop\n+            if Name (J) = '/' or else Name (J) = ASCII.NUL then\n+               return False;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If Name does not contain any slash or NUL, it is valid\n+\n+      return True;\n+   end Is_Valid_Simple_Name;\n+\n+end Ada.Directories.Validity;\n+\n+"}, {"sha": "23d681cdbfdfa840ee1d297e6966a76c692ad979", "filename": "gcc/ada/a-dirval.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-dirval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-dirval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . D I R E C T O R I E S . V A L I D I T Y              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004 Free Software Foundation, Inc.               --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This private child package is used in the body of Ada.Directories.\n+--  It has several bodies, for different platforms.\n+\n+private package Ada.Directories.Validity is\n+\n+   function Is_Valid_Simple_Name (Name : String) return Boolean;\n+   --  Returns True if Name is a valid file name\n+\n+   function Is_Valid_Path_Name (Name : String) return Boolean;\n+   --  Returns True if Name is a valid path name\n+\n+end Ada.Directories.Validity;\n+\n+"}, {"sha": "8e9e98c342d300303d7855bc2afe4fa91bb1932c", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -703,7 +703,13 @@ package body Ada.Exceptions is\n          P := P - 1;\n       end loop;\n \n-      return Name (P .. Name'Length);\n+      --  Return result making sure lower bound is 1\n+\n+      declare\n+         subtype Rname is String (1 .. Name'Length - P + 1);\n+      begin\n+         return Rname (Name (P .. Name'Length));\n+      end;\n    end Exception_Name_Simple;\n \n    --------------------"}, {"sha": "4c1430dd235f4b4ee9a8939112643e981a9911c4", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -720,6 +720,21 @@ __gnat_file_length (int fd)\n   return (statbuf.st_size);\n }\n \n+/* Return the number of bytes in the specified named file.  */\n+\n+long\n+__gnat_named_file_length (char *name)\n+{\n+  int ret;\n+  struct stat statbuf;\n+\n+  ret = __gnat_stat (name, &statbuf);\n+  if (ret || !S_ISREG (statbuf.st_mode))\n+    return 0;\n+\n+  return (statbuf.st_size);\n+}\n+\n /* Create a temporary filename and put it in string pointed to by\n    TMP_FILENAME.  */\n "}, {"sha": "def011c678b04a7289dc387ae38a04d69b570724", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -66,6 +66,7 @@ extern int    __gnat_open_create                   (char *, int);\n extern int    __gnat_create_output_file            (char *);\n extern int    __gnat_open_append                   (char *, int);\n extern long   __gnat_file_length                   (int);\n+extern long   __gnat_named_file_length             (char *);\n extern void   __gnat_tmp_name\t\t\t   (char *);\n extern char  *__gnat_readdir                       (DIR *, char *);\n extern int    __gnat_readdir_is_thread_safe        (void);"}, {"sha": "1358ed07c113ea601e6989086e71a0ca39209403", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -86,26 +86,23 @@ package body ALI.Util is\n       return Checksum1 = Checksum2 and then Checksum1 /= Checksum_Error;\n    end Checksums_Match;\n \n-   pragma Warnings (Off);\n-   --  To avoid warnings on non referenced parameters of the error procedures\n-\n    ---------------\n    -- Error_Msg --\n    ---------------\n \n    procedure Error_Msg (Msg : String; Flag_Location : Source_Ptr) is\n+      pragma Warnings (Off, Msg);\n+      pragma Warnings (Off, Flag_Location);\n    begin\n       null;\n    end Error_Msg;\n \n-   pragma Warnings (Off);\n-   --  To avoid warnings on non referenced parameters of the error procedures\n-\n    -----------------\n    -- Error_Msg_S --\n    -----------------\n \n    procedure Error_Msg_S (Msg : String) is\n+      pragma Warnings (Off, Msg);\n    begin\n       null;\n    end Error_Msg_S;\n@@ -115,6 +112,7 @@ package body ALI.Util is\n    ------------------\n \n    procedure Error_Msg_SC (Msg : String) is\n+      pragma Warnings (Off, Msg);\n    begin\n       null;\n    end Error_Msg_SC;\n@@ -124,12 +122,11 @@ package body ALI.Util is\n    ------------------\n \n    procedure Error_Msg_SP (Msg : String) is\n+      pragma Warnings (Off, Msg);\n    begin\n       null;\n    end Error_Msg_SP;\n \n-   pragma Warnings (On);\n-\n    -----------------------\n    -- Get_File_Checksum --\n    -----------------------"}, {"sha": "2a5357cb3117232875c04320f0a811ec478187a0", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -62,11 +62,11 @@ package body Eval_Fat is\n    --  The result is rounded to a nearest machine number.\n \n    procedure Decompose_Int\n-     (RT               : R;\n-      X                : in T;\n-      Fraction         : out UI;\n-      Exponent         : out UI;\n-      Mode             : Rounding_Mode);\n+     (RT       : R;\n+      X        : in T;\n+      Fraction : out UI;\n+      Exponent : out UI;\n+      Mode     : Rounding_Mode);\n    --  This is similar to Decompose, except that the Fraction value returned\n    --  is an integer representing the value Fraction * Scale, where Scale is\n    --  the value (Radix ** Machine_Mantissa (RT)). The value is obtained by\n@@ -129,7 +129,6 @@ package body Eval_Fat is\n    function Compose (RT : R; Fraction : T; Exponent : UI) return T is\n       Arg_Frac : T;\n       Arg_Exp  : UI;\n-\n    begin\n       if UR_Is_Zero (Fraction) then\n          return Fraction;\n@@ -190,18 +189,17 @@ package body Eval_Fat is\n    -- Decompose_Int --\n    -------------------\n \n-   --  This procedure should be modified with care, as there\n-   --  are many non-obvious details that may cause problems\n-   --  that are hard to detect. The cases of positive and\n-   --  negative zeroes are also special and should be\n-   --  verified separately.\n+   --  This procedure should be modified with care, as there are many\n+   --  non-obvious details that may cause problems that are hard to\n+   --  detect. The cases of positive and negative zeroes are also\n+   --  special and should be verified separately.\n \n    procedure Decompose_Int\n-     (RT               : R;\n-      X                : in T;\n-      Fraction         : out UI;\n-      Exponent         : out UI;\n-      Mode             : Rounding_Mode)\n+     (RT       : R;\n+      X        : in T;\n+      Fraction : out UI;\n+      Exponent : out UI;\n+      Mode     : Rounding_Mode)\n    is\n       Base : Int := Rbase (X);\n       N    : UI  := abs Numerator (X);\n@@ -466,7 +464,6 @@ package body Eval_Fat is\n    function Exponent (RT : R; X : T) return UI is\n       X_Frac : UI;\n       X_Exp  : UI;\n-\n    begin\n       if UR_Is_Zero (X) then\n          return Uint_0;\n@@ -502,7 +499,6 @@ package body Eval_Fat is\n    function Fraction (RT : R; X : T) return T is\n       X_Frac : T;\n       X_Exp  : UI;\n-\n    begin\n       if UR_Is_Zero (X) then\n          return X;\n@@ -517,19 +513,13 @@ package body Eval_Fat is\n    ------------------\n \n    function Leading_Part (RT : R; X : T; Radix_Digits : UI) return T is\n-      L    : UI;\n-      Y, Z : T;\n-\n+      RD : constant UI := UI_Min (Radix_Digits, Machine_Mantissa (RT));\n+      L  : UI;\n+      Y  : T;\n    begin\n-      if Radix_Digits >= Machine_Mantissa (RT) then\n-         return X;\n-\n-      else\n-         L := Exponent (RT, X) - Radix_Digits;\n-         Y := Truncation (RT, Scaling (RT, X, -L));\n-         Z := Scaling (RT, Y, L);\n-         return Z;\n-      end if;\n+      L := Exponent (RT, X) - RD;\n+      Y := UR_From_Uint (UR_Trunc (Scaling (RT, X, -L)));\n+      return Scaling (RT, Y, L);\n    end Leading_Part;\n \n    -------------\n@@ -540,11 +530,8 @@ package body Eval_Fat is\n      (RT    : R;\n       X     : T;\n       Mode  : Rounding_Mode;\n-      Enode : Node_Id)\n-      return  T\n+      Enode : Node_Id) return T\n    is\n-      pragma Warnings (Off, Enode); -- not yet referenced\n-\n       X_Frac : T;\n       X_Exp  : UI;\n       Emin   : constant UI := UI_From_Int (Machine_Emin (RT));\n@@ -726,7 +713,6 @@ package body Eval_Fat is\n    function Model (RT : R; X : T) return T is\n       X_Frac : T;\n       X_Exp  : UI;\n-\n    begin\n       Decompose (RT, X, X_Frac, X_Exp);\n       return Compose (RT, X_Frac, X_Exp);"}, {"sha": "451326dd523b0eeaa4153a4d5d91f3dcfddeb687", "filename": "gcc/ada/eval_fat.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Feval_fat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Feval_fat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -98,7 +98,6 @@ package Eval_Fat is\n      (RT    : R;\n       X     : T;\n       Mode  : Rounding_Mode;\n-      Enode : Node_Id)\n-      return  T;\n+      Enode : Node_Id) return T;\n \n end Eval_Fat;"}, {"sha": "a405d6bece5985d85c41559bb5814702e58d5916", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -2457,7 +2457,19 @@ package body Exp_Ch6 is\n \n             --  Replace assignment with the block\n \n-            Rewrite (Parent (N), Blk);\n+            declare\n+               Original_Assignment : constant Node_Id := Parent (N);\n+               Saved_Assignment    : constant Node_Id :=\n+                                       Relocate_Node (Original_Assignment);\n+               pragma Warnings (Off, Saved_Assignment);\n+               --  Preserve the original assignment node to keep the\n+               --  complete assignment subtree consistent enough for\n+               --  Analyze_Assignment to proceed. We do not use the\n+               --  saved value, the point was just to do the relocation.\n+\n+            begin\n+               Rewrite (Original_Assignment, Blk);\n+            end;\n \n          elsif Nkind (Parent (N)) = N_Object_Declaration then\n             Set_Expression (Parent (N), Empty);\n@@ -2471,7 +2483,6 @@ package body Exp_Ch6 is\n \n       procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id) is\n          HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n-\n       begin\n          if Is_Empty_List (Declarations (Blk)) then\n             Insert_List_After (N, Statements (HSS));"}, {"sha": "87017c71df20c594c469c562ee60f439bc960396", "filename": "gcc/ada/g-curexc.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fg-curexc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fg-curexc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-curexc.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---         Copyright (C) 1996-2000 Ada Core Technologies, Inc.              --\n+--         Copyright (C) 1996-2004 Ada Core Technologies, Inc.              --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,6 +50,8 @@ pragma Pure (Current_Exception);\n    -- Subprograms --\n    -----------------\n \n+   --  Note: the lower bound of returnd String values is always one.\n+\n    function Exception_Information return String;\n    --  Returns the result of calling Ada.Exceptions.Exception_Information\n    --  with an argument that is the Exception_Occurrence corresponding to"}, {"sha": "529207946009f90059cf1e7aa10a383250e7c6d5", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -988,6 +988,9 @@ procedure Gnatlink is\n             --  Add binder options only if not already set on the command\n             --  line. This rule is a way to control the linker options order.\n \n+            --  The following test needs comments, why is it VMS specific.\n+            --  The above comment looks out of date ???\n+\n             elsif not (Hostparm.OpenVMS\n                          and then\n                        Is_Option_Present (Next_Line (Nfirst .. Nlast)))"}, {"sha": "b69886cca9016fef21d761b6aaf92b239b27910a", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -53,6 +53,7 @@ package body Impunit is\n      \"a-chlat1\",    -- Ada.Characters.Latin_1\n      \"a-comlin\",    -- Ada.Command_Line\n      \"a-decima\",    -- Ada.Decimal\n+     \"a-direct\",    -- Ada.Directories\n      \"a-direio\",    -- Ada.Direct_IO\n      \"a-dynpri\",    -- Ada.Dynamic_Priorities\n      \"a-except\",    -- Ada.Exceptions"}, {"sha": "50e0feb085a3e9cf7c71b3d42e58fa6d484d25b9", "filename": "gcc/ada/init.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -1777,6 +1777,41 @@ __gnat_initialize (void)\n {\n   __gnat_init_float ();\n \n+  /* On targets where we might be using the ZCX scheme, we need to register\n+     the frame tables.\n+\n+     For application \"modules\", the crtstuff objects linked in (crtbegin/endS)\n+     are tailored to provide this service a-la C++ constructor fashion,\n+     typically triggered by the dynamic loader. This is achieved by way of a\n+     special variable declaration in the crt object, the name of which has\n+     been deduced by analyzing the output of the \"munching\" step documented\n+     for C++.  The de-registration call is handled symetrically, a-la C++\n+     destructor fashion and typically triggered by the dynamic unloader. With\n+     this scheme, a mixed Ada/C++ application has to be linked and loaded as\n+     separate modules for each language, which is not unreasonable anyway.\n+\n+     For applications statically linked with the kernel, the module scheme\n+     above would lead to duplicated symbols because the VxWorks kernel build\n+     \"munches\" by default. To prevent those conflicts, we link against\n+     crtbegin/end objects that don't include the special variable and directly\n+     call the appropriate function here. We'll never unload that, so there is\n+     no de-registration to worry about.\n+\n+     We can differentiate between the two cases by looking at the\n+     __module_has_ctors value provided by each class of crt objects. As of\n+     today, selecting the crt set intended for applications to be statically\n+     linked with the kernel is triggered by adding \"-static\" to the gcc *link*\n+     command line options.  */\n+\n+#if 0\n+ {\n+   extern const int __module_has_ctors;\n+   extern void __do_global_ctors ();\n+\n+   if (! __module_has_ctors)\n+     __do_global_ctors ();\n+ }\n+#endif\n }\n \n /********************************/"}, {"sha": "3587599796258c49c2bd2abba6ced2c9238808c7", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6778,14 +6778,19 @@ package body Make is\n          elsif Argv (2) = 'L' then\n             Add_Switch (Argv, Linker, And_Save => And_Save);\n \n-         --  For -gxxxxx,-pg,-mxxx: give the switch to both the compiler and\n-         --  the linker (except for -gnatxxx which is only for the compiler)\n+         --  For -gxxxxx, -pg, -mxxx, -fxxx: give the switch to both the\n+         --  compiler and the linker (except for -gnatxxx which is only for\n+         --  the compiler). Some of the -mxxx (for example -m64) and -fxxx\n+         --  (for example -ftest-coverage for gcov) need to be used when\n+         --  compiling the binder generated files, and using all these gcc\n+         --  switches for the binder generated files should not be a problem.\n \n          elsif\n            (Argv (2) = 'g' and then (Argv'Last < 5\n                                        or else Argv (2 .. 5) /= \"gnat\"))\n              or else Argv (2 .. Argv'Last) = \"pg\"\n              or else (Argv (2) = 'm' and then Argv'Last > 2)\n+             or else (Argv (2) = 'f' and then Argv'Last > 2)\n          then\n             Add_Switch (Argv, Compiler, And_Save => And_Save);\n             Add_Switch (Argv, Linker, And_Save => And_Save);"}, {"sha": "a6458956cdc9c30965e79f017586ba179f5c1c0e", "filename": "gcc/ada/mlib-tgt.ads", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---              Copyright (C) 2001-2003, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2004, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -86,7 +86,8 @@ package MLib.Tgt is\n \n    function DLL_Ext return String;\n    --  System dependent dynamic library extension, without leading dot.\n-   --  On Unix, returns \"so\", on Windows, returns \"dll\".\n+   --  On Windows, returns \"dll\". On Unix, usually returns \"so\", but not\n+   --  always, e.g. on HP-UX the extension for shared libraries is \"sl\".\n \n    function PIC_Option return String;\n    --  Position independent code option\n@@ -119,22 +120,25 @@ package MLib.Tgt is\n       Lib_Version  : String  := \"\";\n       Relocatable  : Boolean := False;\n       Auto_Init    : Boolean := False);\n-   --  Build a dynamic/relocatable library.\n+   --  Build a dynamic/relocatable library\n+   --\n+   --  Ofiles is the list of all object files in the library\n+   --\n+   --  Foreign is the list of non Ada object files (also included in Ofiles)\n+   --\n+   --  Afiles is the list of ALI files for the Ada object files\n    --\n-   --  Ofiles is the list of all object files in the library.\n-   --  Foreign is the list of non Ada object files (also included in Ofiles).\n-   --  Afiles is the list of ALI files for the Ada object files.\n    --  Options is a list of options to be passed to the tool (gcc or other)\n    --  that effectively builds the dynamic library.\n    --\n    --  Interfaces is the list of ALI files for the interfaces of a SAL.\n    --  It is empty if the library is not a SAL.\n    --\n    --  Lib_Filename is the name of the library, without any prefix or\n-   --  extension. For example, on Unix, if Lib_Filename is \"toto\", the name of\n-   --  the library file will be \"libtoto.so\".\n+   --  extension. For example, on Unix, if Lib_Filename is \"toto\", the\n+   --  name of the library file will be \"libtoto.so\".\n    --\n-   --  Lib_Dir is the directory path where the library will be located.\n+   --  Lib_Dir is the directory path where the library will be located\n    --\n    --  Lib_Address is the base address of the library for a non relocatable\n    --  library, given as an hexadecimal string."}, {"sha": "d45e727e97ce95b7c8a1fe7c24e345b5d4d48902", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -669,6 +669,7 @@ package body Ch10 is\n \n             declare\n                Save_Style_Check : constant Boolean := Style_Check;\n+\n             begin\n                Style_Check := False;\n \n@@ -691,7 +692,6 @@ package body Ch10 is\n                   Error_Msg_SC\n                     (\"end of file expected, \" &\n                      \"file can have only one compilation unit\");\n-\n                else\n                   Error_Msg_SC (\"end of file expected\");\n                end if;\n@@ -833,7 +833,7 @@ package body Ch10 is\n \n             if Token /= Tok_With then\n \n-               --  Keyword is beginning of private child unit.\n+               --  Keyword is beginning of private child unit\n \n                Restore_Scan_State (Scan_State); -- to PRIVATE\n                return Item_List;\n@@ -901,8 +901,25 @@ package body Ch10 is\n                   Set_Limited_Present (With_Node, Has_Limited);\n                   Set_Private_Present (With_Node, Has_Private);\n                   First_Flag := False;\n+\n+                  --  All done if no comma\n+\n                   exit when Token /= Tok_Comma;\n+\n+                  --  If comma is followed by compilation unit token\n+                  --  or by USE, or PRAGMA, then it should have been a\n+                  --  semicolon after all\n+\n+                  Save_Scan_State (Scan_State);\n                   Scan; -- past comma\n+\n+                  if Token in Token_Class_Cunit\n+                    or else Token = Tok_Use\n+                    or else Token = Tok_Pragma\n+                  then\n+                     Restore_Scan_State (Scan_State);\n+                     exit;\n+                  end if;\n                end loop;\n \n                Set_Last_Name (With_Node, True);"}, {"sha": "c109d3f2387efda44a7d47a478e65fb4bee60d86", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -721,7 +721,7 @@ package body Ch3 is\n    --------------------------------\n \n    --  SUBTYPE_DECLARATION ::=\n-   --    subtype DEFINING_IDENTIFIER is SUBTYPE_INDICATION;\n+   --    subtype DEFINING_IDENTIFIER is [NULL_EXCLUSION] SUBTYPE_INDICATION;\n \n    --  The caller has checked that the initial token is SUBTYPE\n \n@@ -1017,9 +1017,9 @@ package body Ch3 is\n    --  This routine scans out a declaration starting with an identifier:\n \n    --  OBJECT_DECLARATION ::=\n-   --    DEFINING_IDENTIFIER_LIST : [constant] [aliased]\n-   --      SUBTYPE_INDICATION [:= EXPRESSION];\n-   --  | DEFINING_IDENTIFIER_LIST : [constant] [aliased]\n+   --    DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n+   --      [NULL_EXCLUSION] SUBTYPE_INDICATION [:= EXPRESSION];\n+   --  | DEFINING_IDENTIFIER_LIST : [aliased] [constant]\n    --      ARRAY_TYPE_DEFINITION [:= EXPRESSION];\n \n    --  NUMBER_DECLARATION ::=\n@@ -1519,7 +1519,8 @@ package body Ch3 is\n    -------------------------------------------------------------------------\n \n    --  DERIVED_TYPE_DEFINITION ::=\n-   --    [abstract] new parent_SUBTYPE_INDICATION [RECORD_EXTENSION_PART]\n+   --    [abstract] new [NULL_EXCLUSION] parent_SUBTYPE_INDICATION\n+   --    [RECORD_EXTENSION_PART]\n \n    --  PRIVATE_EXTENSION_DECLARATION ::=\n    --     type DEFINING_IDENTIFIER [DISCRIMINANT_PART] is\n@@ -2116,7 +2117,7 @@ package body Ch3 is\n    --    DISCRETE_SUBTYPE_INDICATION | RANGE\n \n    --  COMPONENT_DEFINITION ::=\n-   --    [aliased] SUBTYPE_INDICATION | ACCESS_DEFINITION\n+   --    [aliased] [NULL_EXCLUSION] SUBTYPE_INDICATION | ACCESS_DEFINITION\n \n    --  The caller has checked that the initial token is ARRAY\n \n@@ -2385,7 +2386,7 @@ package body Ch3 is\n    --    (DISCRIMINANT_SPECIFICATION {; DISCRIMINANT_SPECIFICATION})\n \n    --  DISCRIMINANT_SPECIFICATION ::=\n-   --    DEFINING_IDENTIFIER_LIST : SUBTYPE_MARK\n+   --    DEFINING_IDENTIFIER_LIST : [NULL_EXCLUSION] SUBTYPE_MARK\n    --      [:= DEFAULT_EXPRESSION]\n    --  | DEFINING_IDENTIFIER_LIST : ACCESS_DEFINITION\n    --      [:= DEFAULT_EXPRESSION]\n@@ -2866,7 +2867,7 @@ package body Ch3 is\n    --      [:= DEFAULT_EXPRESSION];\n \n    --  COMPONENT_DEFINITION ::=\n-   --    [aliased] SUBTYPE_INDICATION | ACCESS_DEFINITION\n+   --    [aliased] [NULL_EXCLUSION] SUBTYPE_INDICATION | ACCESS_DEFINITION\n \n    --  Error recovery: cannot raise Error_Resync, if an error occurs,\n    --  the scan is positioned past the following semicolon.\n@@ -3217,13 +3218,14 @@ package body Ch3 is\n    --  | ACCESS_TO_SUBPROGRAM_DEFINITION\n \n    --  ACCESS_TO_OBJECT_DEFINITION ::=\n-   --    access [GENERAL_ACCESS_MODIFIER] SUBTYPE_INDICATION\n+   --    [NULL_EXCLUSION] access [GENERAL_ACCESS_MODIFIER] SUBTYPE_INDICATION\n \n    --  GENERAL_ACCESS_MODIFIER ::= all | constant\n \n    --  ACCESS_TO_SUBPROGRAM_DEFINITION\n-   --    access [protected] procedure PARAMETER_PROFILE\n-   --  | access [protected] function PARAMETER_AND_RESULT_PROFILE\n+   --    [NULL_EXCLUSION] access [protected] procedure PARAMETER_PROFILE\n+   --  | [NULL_EXCLUSION] access [protected] function\n+   --    PARAMETER_AND_RESULT_PROFILE\n \n    --  PARAMETER_PROFILE ::= [FORMAL_PART]\n \n@@ -3362,7 +3364,8 @@ package body Ch3 is\n    -- 3.10  Access Definition --\n    -----------------------------\n \n-   --  ACCESS_DEFINITION ::= access SUBTYPE_MARK\n+   --  ACCESS_DEFINITION ::=\n+   --    [NULL_EXCLUSION] access [GENERAL_ACCESS_MODIFIER] SUBTYPE_MARK\n \n    --  The caller has checked that the initial token is ACCESS\n \n@@ -3375,7 +3378,7 @@ package body Ch3 is\n       Def_Node := New_Node (N_Access_Definition, Token_Ptr);\n       Scan; -- past ACCESS\n \n-      --  Ada 0Y (AI-231): ACCESS [general_access_modifier] subtype_mark\n+      --  Ada 0Y (AI-231)\n \n       if Extensions_Allowed then\n          if Token = Tok_All then"}, {"sha": "1e8e23f1e10b24cbace702d23c9ae7bd1247b723", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -2308,7 +2308,6 @@ package body Ch4 is\n \n    function  P_Qualified_Expression (Subtype_Mark : Node_Id) return Node_Id is\n       Qual_Node : Node_Id;\n-\n    begin\n       Qual_Node := New_Node (N_Qualified_Expression, Prev_Token_Ptr);\n       Set_Subtype_Mark (Qual_Node, Check_Subtype_Mark (Subtype_Mark));\n@@ -2321,7 +2320,7 @@ package body Ch4 is\n    --------------------\n \n    --  ALLOCATOR ::=\n-   --   new SUBTYPE_INDICATION | new QUALIFIED_EXPRESSION\n+   --    new [NULL_EXCLUSION] SUBTYPE_INDICATION | new QUALIFIED_EXPRESSION\n \n    --  The caller has checked that the initial token is NEW\n "}, {"sha": "3d7e2708c84b35b209b68b854cf13f9c74d664fd", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -839,7 +839,7 @@ package body Ch6 is\n    --  FORMAL_PART ::= (PARAMETER_SPECIFICATION {; PARAMETER_SPECIFICATION})\n \n    --  PARAMETER_SPECIFICATION ::=\n-   --    DEFINING_IDENTIFIER_LIST : MODE SUBTYPE_MARK\n+   --    DEFINING_IDENTIFIER_LIST : MODE [NULL_EXCLUSION] SUBTYPE_MARK\n    --      [:= DEFAULT_EXPRESSION]\n    --  | DEFINING_IDENTIFIER_LIST : ACCESS_DEFINITION\n    --      [:= DEFAULT_EXPRESSION]"}, {"sha": "535813852b09518d2e1da3f3998123390dabf3fe", "filename": "gcc/ada/s-stoele.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fs-stoele.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fs-stoele.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stoele.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -91,8 +91,7 @@ pragma Pure (Storage_Elements);\n \n    function \"mod\"\n      (Left  : Address;\n-      Right : Storage_Offset)\n-      return  Storage_Offset;\n+      Right : Storage_Offset) return  Storage_Offset;\n    pragma Convention (Intrinsic, \"mod\");\n    pragma Inline_Always (\"mod\");\n    pragma Pure_Function (\"mod\");"}, {"sha": "93e340f54ac6aa1120285aa2887be4d124443df0", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -459,10 +459,10 @@ package body Scng is\n                C := Source (Scan_Ptr);\n \n                if C = '_' then\n-                  --  We do not want to accumulate the '_' in the checksum,\n-                  --  so that 1_234 is equivalent to 1234, and does not\n-                  --  trigger compilation in \"minimal recompilation\"\n-                  --  (gnatmake -m).\n+\n+                  --  We do not accumulate the '_' in the checksum, so that\n+                  --  1_234 is equivalent to 1234, and does not trigger\n+                  --  compilation for \"minimal recompilation\" (gnatmake -m).\n \n                   loop\n                      Scan_Ptr := Scan_Ptr + 1;"}, {"sha": "cf0ba5e66789a8030ffdf5f512f61fc565848dc8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -4026,6 +4026,7 @@ package body Sem_Ch3 is\n \n             Set_First_Entity (Derived_Type, First_Entity (Der_Base));\n             Set_Last_Entity  (Derived_Type, Last_Entity  (Der_Base));\n+            Set_Stored_Constraint (Full_Der, Stored_Constraint (Derived_Type));\n \n          else\n             --  If this is a completion, the derived type stays private\n@@ -4343,14 +4344,14 @@ package body Sem_Ch3 is\n    --  discriminants in R and T1 through T4.\n \n    --   Type      Discrim     Stored Discrim  Comment\n-   --    R      (D1, D2, D3)   (D1, D2, D3)   Gider discrims are implicit in R\n-   --    T1     (D1, D2, D3)   (D1, D2, D3)   Gider discrims are implicit in T1\n-   --    T2     (X1, X2)       (D1, D2, D3)   Gider discrims are EXPLICIT in T2\n-   --    T3     (X1, X2)       (D1, D2, D3)   Gider discrims are EXPLICIT in T3\n-   --    T4     (Y)            (D1, D2, D3)   Gider discrims are EXPLICIT in T4\n-\n-   --  Field Corresponding_Discriminant (abbreviated CD below) allows to find\n-   --  the corresponding discriminant in the parent type, while\n+   --    R      (D1, D2, D3)   (D1, D2, D3)   Girder discrims implicit in R\n+   --    T1     (D1, D2, D3)   (D1, D2, D3)   Girder discrims implicit in T1\n+   --    T2     (X1, X2)       (D1, D2, D3)   Girder discrims EXPLICIT in T2\n+   --    T3     (X1, X2)       (D1, D2, D3)   Girder discrims EXPLICIT in T3\n+   --    T4     (Y)            (D1, D2, D3)   Girder discrims EXPLICIT in T4\n+\n+   --  Field Corresponding_Discriminant (abbreviated CD below) allows us to\n+   --  find the corresponding discriminant in the parent type, while\n    --  Original_Record_Component (abbreviated ORC below), the actual physical\n    --  component that is renamed. Finally the field Is_Completely_Hidden\n    --  (abbreviated ICH below) is set for all explicit stored discriminants\n@@ -5309,7 +5310,7 @@ package body Sem_Ch3 is\n             Set_Discriminant_Constraint\n               (Derived_Type, Save_Discr_Constr);\n             Set_Stored_Constraint\n-              (Derived_Type, Expand_To_Stored_Constraint (Parent_Base, Discs));\n+              (Derived_Type, Expand_To_Stored_Constraint (Parent_Type, Discs));\n             Replace_Components (Derived_Type, New_Decl);\n          end if;\n \n@@ -10472,11 +10473,18 @@ package body Sem_Ch3 is\n       --  This is achieved by appending Derived_Base discriminants into\n       --  Discs, which has the side effect of returning a non empty Discs\n       --  list to the caller of Inherit_Components, which is what we want.\n+      --  This must be done for private derived types if there are explicit\n+      --  stored discriminants, to ensure that we can retrieve the values of\n+      --  the constraints provided in the ancestors.\n \n       if Inherit_Discr\n         and then Is_Empty_Elmt_List (Discs)\n-        and then (not Is_Private_Type (Derived_Base)\n-                   or Is_Generic_Type (Derived_Base))\n+        and then Present (First_Discriminant (Derived_Base))\n+        and then\n+          (not Is_Private_Type (Derived_Base)\n+           or else Is_Completely_Hidden\n+             (First_Stored_Discriminant (Derived_Base))\n+           or else Is_Generic_Type (Derived_Base))\n       then\n          D := First_Discriminant (Derived_Base);\n          while Present (D) loop"}, {"sha": "1ac9b4491fd1d6e83d7f07badc34a30cc0abf0a9", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -209,6 +209,10 @@ package body Sem_Ch4 is\n    --  for the type is not directly visible. The routine uses this type to emit\n    --  a more informative message.\n \n+   procedure Remove_Abstract_Operations (N : Node_Id);\n+   --  Ada 2005: implementation of AI-310. An abstract non-dispatching\n+   --  operation is not a candidate interpretation.\n+\n    function Try_Indexed_Call\n      (N   : Node_Id;\n       Nam : Entity_Id;\n@@ -852,6 +856,8 @@ package body Sem_Ch4 is\n             Generate_Reference (Entity (Nam), Nam);\n \n             Set_Etype (Nam, Etype (Entity (Nam)));\n+         else\n+            Remove_Abstract_Operations (N);\n          end if;\n \n          End_Interp_List;\n@@ -4125,6 +4131,8 @@ package body Sem_Ch4 is\n \n    procedure Operator_Check (N : Node_Id) is\n    begin\n+      Remove_Abstract_Operations (N);\n+\n       --  Test for case of no interpretation found for operator\n \n       if Etype (N) = Any_Type then\n@@ -4317,6 +4325,71 @@ package body Sem_Ch4 is\n       end if;\n    end Operator_Check;\n \n+   --------------------------------\n+   -- Remove_Abstract_Operations --\n+   --------------------------------\n+\n+   procedure Remove_Abstract_Operations (N : Node_Id) is\n+      I               : Interp_Index;\n+      It              : Interp;\n+      Has_Abstract_Op : Boolean := False;\n+\n+      --  AI-310: If overloaded, remove abstract non-dispatching\n+      --  operations.\n+\n+   begin\n+      if Extensions_Allowed\n+        and then Is_Overloaded (N)\n+      then\n+         Get_First_Interp (N, I, It);\n+         while Present (It.Nam) loop\n+            if not Is_Type (It.Nam)\n+              and then Is_Abstract (It.Nam)\n+              and then not Is_Dispatching_Operation (It.Nam)\n+            then\n+               Has_Abstract_Op := True;\n+               Remove_Interp (I);\n+               exit;\n+            end if;\n+\n+            Get_Next_Interp (I, It);\n+         end loop;\n+\n+         --  Remove corresponding predefined operator, which is\n+         --  always added to the overload set, unless it is a universal\n+         --  operation.\n+\n+         if Nkind (N) in N_Op\n+           and then Has_Abstract_Op\n+         then\n+            if Nkind (N) in N_Unary_Op\n+              and then\n+                Present (Universal_Interpretation (Etype (Right_Opnd (N))))\n+            then\n+               return;\n+\n+            elsif Nkind (N) in N_Binary_Op\n+              and then\n+                Present (Universal_Interpretation (Etype (Right_Opnd (N))))\n+              and then\n+                Present (Universal_Interpretation (Etype (Left_Opnd (N))))\n+            then\n+               return;\n+\n+            else\n+               Get_First_Interp (N, I, It);\n+               while Present (It.Nam) loop\n+                  if Scope (It.Nam) = Standard_Standard then\n+                     Remove_Interp (I);\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end if;\n+         end if;\n+      end if;\n+   end Remove_Abstract_Operations;\n+\n    -----------------------\n    -- Try_Indirect_Call --\n    -----------------------"}, {"sha": "c43aee8cf0a2297d39637633bc6a61b68265ccd2", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -339,6 +339,7 @@ package body Sem_Ch5 is\n       Set_Assignment_Type (Lhs, T1);\n \n       Resolve (Rhs, T1);\n+      Check_Unset_Reference (Rhs);\n \n       --  Remaining steps are skipped if Rhs was syntactically in error\n \n@@ -347,7 +348,6 @@ package body Sem_Ch5 is\n       end if;\n \n       T2 := Etype (Rhs);\n-      Check_Unset_Reference (Rhs);\n \n       if Covers (T1, T2) then\n          null;\n@@ -430,10 +430,16 @@ package body Sem_Ch5 is\n          Apply_Length_Check (Rhs, Etype (Lhs));\n \n       else\n-         --  Discriminant checks are applied in the course of expansion.\n+         --  Discriminant checks are applied in the course of expansion\n+\n          null;\n       end if;\n \n+      --  Note: modifications of the Lhs may only be recorded after\n+      --  checks have been applied.\n+\n+      Note_Possible_Modification (Lhs);\n+\n       --  ??? a real accessibility check is needed when ???\n \n       --  Post warning for useless assignment\n@@ -462,8 +468,6 @@ package body Sem_Ch5 is\n            (\"?useless assignment of & to itself\", N, Entity (Lhs));\n       end if;\n \n-      Note_Possible_Modification (Lhs);\n-\n       --  Check for non-allowed composite assignment\n \n       if not Support_Composite_Assign_On_Target"}, {"sha": "578c9340f94fe988108d22d51d8008bea81a76d9", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 54, "deletions": 22, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -4979,6 +4979,9 @@ package body Sem_Util is\n    --------------------------------\n \n    procedure Note_Possible_Modification (N : Node_Id) is\n+      Modification_Comes_From_Source : constant Boolean :=\n+                                         Comes_From_Source (Parent (N));\n+\n       Ent : Entity_Id;\n       Exp : Node_Id;\n \n@@ -4993,7 +4996,9 @@ package body Sem_Util is\n       procedure Set_Ref (E : Entity_Id; N : Node_Id) is\n       begin\n          if Is_Object (E) then\n-            if Comes_From_Source (N) then\n+            if Comes_From_Source (N)\n+              or else Modification_Comes_From_Source\n+            then\n                Set_Never_Set_In_Source (E, False);\n             end if;\n \n@@ -5015,19 +5020,60 @@ package body Sem_Util is\n \n       Exp := N;\n       loop\n-         --  Test for node rewritten as dereference (e.g. accept parameter)\n+         Ent := Empty;\n+\n+         if Is_Entity_Name (Exp) then\n+            Ent := Entity (Exp);\n+\n+         elsif Nkind (Exp) = N_Explicit_Dereference then\n+            declare\n+               P : constant Node_Id := Prefix (Exp);\n+\n+            begin\n+               if Nkind (P) = N_Selected_Component\n+                 and then Present (\n+                   Entry_Formal (Entity (Selector_Name (P))))\n+               then\n+                  --  Case of a reference to an entry formal\n+\n+                  Ent := Entry_Formal (Entity (Selector_Name (P)));\n+\n+               elsif Nkind (P) = N_Identifier\n+                 and then Nkind (Parent (Entity (P))) = N_Object_Declaration\n+                 and then Present (Expression (Parent (Entity (P))))\n+                 and then Nkind (Expression (Parent (Entity (P))))\n+                   = N_Reference\n+               then\n+                  --  Case of a reference to a value on which\n+                  --  side effects have been removed.\n+\n+                  Exp := Prefix (Expression (Parent (Entity (P))));\n+\n+               else\n+                  return;\n+\n+               end if;\n+            end;\n+\n+         elsif     Nkind (Exp) = N_Type_Conversion\n+           or else Nkind (Exp) = N_Unchecked_Type_Conversion\n+         then\n+            Exp := Expression (Exp);\n \n-         if Nkind (Exp) = N_Explicit_Dereference\n-           and then not Comes_From_Source (Exp)\n+         elsif     Nkind (Exp) = N_Slice\n+           or else Nkind (Exp) = N_Indexed_Component\n+           or else Nkind (Exp) = N_Selected_Component\n          then\n-            Exp := Original_Node (Exp);\n+            Exp := Prefix (Exp);\n+\n+         else\n+            return;\n+\n          end if;\n \n          --  Now look for entity being referenced\n \n-         if Is_Entity_Name (Exp) then\n-            Ent := Entity (Exp);\n-\n+         if Present (Ent) then\n             if (Ekind (Ent) = E_Variable or else Ekind (Ent) = E_Constant)\n               and then Present (Renamed_Object (Ent))\n             then\n@@ -5046,20 +5092,6 @@ package body Sem_Util is\n                Kill_Checks (Ent);\n                return;\n             end if;\n-\n-         elsif     Nkind (Exp) = N_Type_Conversion\n-           or else Nkind (Exp) = N_Unchecked_Type_Conversion\n-         then\n-            Exp := Expression (Exp);\n-\n-         elsif     Nkind (Exp) = N_Slice\n-           or else Nkind (Exp) = N_Indexed_Component\n-           or else Nkind (Exp) = N_Selected_Component\n-         then\n-            Exp := Prefix (Exp);\n-\n-         else\n-            return;\n          end if;\n       end loop;\n    end Note_Possible_Modification;"}, {"sha": "187fc9bf3895ea9587d9104fc49a77bff4f64bb8", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 71, "deletions": 65, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -351,7 +351,7 @@ package body Sem_Warn is\n       E1 := First_Entity (E);\n       while Present (E1) loop\n \n-         --  We only look at source entities with warning flag off\n+         --  We only look at source entities with warning flag on\n \n          if Comes_From_Source (E1) and then not Warnings_Off (E1) then\n \n@@ -367,6 +367,14 @@ package body Sem_Warn is\n                --  do not consider the implicit initialization of an access\n                --  type to be the assignment of a value for this purpose.\n \n+               if Ekind (E1) = E_Out_Parameter\n+                 and then Present (Spec_Entity (E1))\n+               then\n+                  UR := Unset_Reference (Spec_Entity (E1));\n+               else\n+                  UR := Unset_Reference (E1);\n+               end if;\n+\n                --  If the entity is an out parameter of the current subprogram\n                --  body, check the warning status of the parameter in the spec.\n \n@@ -376,6 +384,23 @@ package body Sem_Warn is\n                then\n                   null;\n \n+               elsif Warn_On_No_Value_Assigned\n+                 and then Present (UR)\n+                 and then Is_Access_Type (Etype (E1))\n+               then\n+\n+                  --  For access types, the only time we made a UR\n+                  --  entry was for a dereference, and so we post\n+                  --  the appropriate warning here (note that the\n+                  --  dereference may not be explicit in the source,\n+                  --  for example in the case of a dispatching call\n+                  --  with an anonymous access controlling formal, or\n+                  --  of an assignment of a pointer involving a\n+                  --  discriminant check on the designated object).\n+\n+                  Error_Msg_NE (\"& may be null?\", UR, E1);\n+                  goto Continue;\n+\n                elsif Never_Set_In_Source (E1)\n                  and then not Generic_Package_Spec_Entity (E1)\n                then\n@@ -435,86 +460,67 @@ package body Sem_Warn is\n                --  types from this check, since access types do always have\n                --  a null value, and that seems legitimate in this case.\n \n-               if Ekind (E1) = E_Out_Parameter\n-                 and then Present (Spec_Entity (E1))\n-               then\n-                  UR := Unset_Reference (Spec_Entity (E1));\n-               else\n-                  UR := Unset_Reference (E1);\n-               end if;\n-\n                if Warn_On_No_Value_Assigned and then Present (UR) then\n \n-                  --  For access types, the only time we made a UR entry\n-                  --  was for a dereference, and so we post the appropriate\n-                  --  warning here. The issue is not that the value is not\n-                  --  initialized here, but that it is null.\n-\n-                  if Is_Access_Type (Etype (E1)) then\n-                     Error_Msg_NE (\"& may be null?\", UR, E1);\n-                     goto Continue;\n-\n                   --  For other than access type, go back to original node\n                   --  to deal with case where original unset reference\n                   --  has been rewritten during expansion.\n \n-                  else\n-                     UR := Original_Node (UR);\n+                  UR := Original_Node (UR);\n \n-                     --  In some cases, the original node may be a type\n-                     --  conversion or qualification, and in this case\n-                     --  we want the object entity inside.\n+                  --  In some cases, the original node may be a type\n+                  --  conversion or qualification, and in this case\n+                  --  we want the object entity inside.\n \n-                     while Nkind (UR) = N_Type_Conversion\n-                       or else Nkind (UR) = N_Qualified_Expression\n-                     loop\n-                        UR := Expression (UR);\n-                     end loop;\n+                  while Nkind (UR) = N_Type_Conversion\n+                    or else Nkind (UR) = N_Qualified_Expression\n+                  loop\n+                     UR := Expression (UR);\n+                  end loop;\n \n-                     --  Here we issue the warning, all checks completed\n-                     --  If the unset reference is prefix of a selected\n-                     --  component that comes from source, mention the\n-                     --  component as well. If the selected component comes\n-                     --  from expansion, all we know is that the entity is\n-                     --  not fully initialized at the point of the reference.\n-                     --  Locate an unintialized component to get a better\n-                     --  error message.\n+                  --  Here we issue the warning, all checks completed\n+                  --  If the unset reference is prefix of a selected\n+                  --  component that comes from source, mention the\n+                  --  component as well. If the selected component comes\n+                  --  from expansion, all we know is that the entity is\n+                  --  not fully initialized at the point of the reference.\n+                  --  Locate an unintialized component to get a better\n+                  --  error message.\n \n-                     if Nkind (Parent (UR)) = N_Selected_Component then\n-                        Error_Msg_Node_2 := Selector_Name (Parent (UR));\n+                  if Nkind (Parent (UR)) = N_Selected_Component then\n+                     Error_Msg_Node_2 := Selector_Name (Parent (UR));\n \n-                        if not Comes_From_Source (Parent (UR)) then\n-                           declare\n-                              Comp : Entity_Id;\n+                     if not Comes_From_Source (Parent (UR)) then\n+                        declare\n+                           Comp : Entity_Id;\n \n-                           begin\n-                              Comp := First_Entity (Etype (E1));\n-                              while Present (Comp) loop\n-                                 if Ekind (Comp) = E_Component\n-                                   and then Nkind (Parent (Comp)) =\n-                                     N_Component_Declaration\n-                                   and then No (Expression (Parent (Comp)))\n-                                 then\n-                                    Error_Msg_Node_2 := Comp;\n-                                    exit;\n-                                 end if;\n-\n-                                 Next_Entity (Comp);\n-                              end loop;\n-                           end;\n-                        end if;\n+                        begin\n+                           Comp := First_Entity (Etype (E1));\n+                           while Present (Comp) loop\n+                              if Ekind (Comp) = E_Component\n+                                and then Nkind (Parent (Comp)) =\n+                                  N_Component_Declaration\n+                                and then No (Expression (Parent (Comp)))\n+                              then\n+                                 Error_Msg_Node_2 := Comp;\n+                                 exit;\n+                              end if;\n \n-                        Error_Msg_N\n-                          (\"`&.&` may be referenced before it has a value?\",\n-                           UR);\n-                     else\n-                        Error_Msg_N\n-                          (\"& may be referenced before it has a value?\",\n-                           UR);\n+                              Next_Entity (Comp);\n+                           end loop;\n+                        end;\n                      end if;\n \n-                     goto Continue;\n+                     Error_Msg_N\n+                       (\"`&.&` may be referenced before it has a value?\",\n+                        UR);\n+                  else\n+                     Error_Msg_N\n+                       (\"& may be referenced before it has a value?\",\n+                        UR);\n                   end if;\n+\n+                  goto Continue;\n                end if;\n             end if;\n "}, {"sha": "5ee8fb388279195f1d0d326eb704411f464179f0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -4242,7 +4242,7 @@ package Sinfo is\n \n       --  PRIVATE_TYPE_DECLARATION ::=\n       --    type DEFINING_IDENTIFIER [DISCRIMINANT_PART]\n-      --      is [[abstract] tagged] [limited] private;\n+      --      is [abstract] tagged] [limited] private;\n \n       --  Note: TAGGED is not permitted in Ada 83 mode\n "}, {"sha": "60242a5e8c2ca2c57b09244b8d4ef1921b1bb3c0", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -113,7 +113,6 @@ package body Tbuild is\n \n    procedure Discard_List (L : List_Id) is\n       pragma Warnings (Off, L);\n-\n    begin\n       null;\n    end Discard_List;\n@@ -124,7 +123,6 @@ package body Tbuild is\n \n    procedure Discard_Node (N : Node_Or_Entity_Id) is\n       pragma Warnings (Off, N);\n-\n    begin\n       null;\n    end Discard_Node;\n@@ -157,10 +155,9 @@ package body Tbuild is\n    --------------------\n \n    function Make_DT_Access\n-     (Loc  : Source_Ptr;\n-      Rec  : Node_Id;\n-      Typ  : Entity_Id)\n-      return Node_Id\n+     (Loc : Source_Ptr;\n+      Rec : Node_Id;\n+      Typ : Entity_Id) return Node_Id\n    is\n       Full_Type : Entity_Id := Typ;\n \n@@ -183,10 +180,9 @@ package body Tbuild is\n    -----------------------\n \n    function Make_DT_Component\n-     (Loc  : Source_Ptr;\n-      Typ  : Entity_Id;\n-      I    : Positive)\n-      return Node_Id\n+     (Loc : Source_Ptr;\n+      Typ : Entity_Id;\n+      I   : Positive) return Node_Id\n    is\n       X : Node_Id;\n       Full_Type : Entity_Id := Typ;\n@@ -215,8 +211,7 @@ package body Tbuild is\n       Condition       : Node_Id;\n       Then_Statements : List_Id;\n       Elsif_Parts     : List_Id := No_List;\n-      Else_Statements : List_Id := No_List)\n-      return            Node_Id\n+      Else_Statements : List_Id := No_List) return Node_Id\n    is\n    begin\n       Check_Restriction (No_Implicit_Conditionals, Node);\n@@ -234,8 +229,7 @@ package body Tbuild is\n    function Make_Implicit_Label_Declaration\n      (Loc                 : Source_Ptr;\n       Defining_Identifier : Node_Id;\n-      Label_Construct     : Node_Id)\n-      return                Node_Id\n+      Label_Construct     : Node_Id) return Node_Id\n    is\n       N : constant Node_Id :=\n             Make_Implicit_Label_Declaration (Loc, Defining_Identifier);\n@@ -255,8 +249,7 @@ package body Tbuild is\n       Identifier             : Node_Id := Empty;\n       Iteration_Scheme       : Node_Id := Empty;\n       Has_Created_Identifier : Boolean := False;\n-      End_Label              : Node_Id := Empty)\n-      return                   Node_Id\n+      End_Label              : Node_Id := Empty) return Node_Id\n    is\n    begin\n       Check_Restriction (No_Implicit_Loops, Node);\n@@ -281,8 +274,7 @@ package body Tbuild is\n \n    function Make_Integer_Literal\n      (Loc    : Source_Ptr;\n-      Intval : Int)\n-      return   Node_Id\n+      Intval : Int) return Node_Id\n    is\n    begin\n       return Make_Integer_Literal (Loc, UI_From_Int (Intval));\n@@ -295,8 +287,7 @@ package body Tbuild is\n    function Make_Raise_Constraint_Error\n      (Sloc      : Source_Ptr;\n       Condition : Node_Id := Empty;\n-      Reason    : RT_Exception_Code)\n-      return      Node_Id\n+      Reason    : RT_Exception_Code) return Node_Id\n    is\n    begin\n       pragma Assert (Reason in RT_CE_Exceptions);\n@@ -314,8 +305,7 @@ package body Tbuild is\n    function Make_Raise_Program_Error\n      (Sloc      : Source_Ptr;\n       Condition : Node_Id := Empty;\n-      Reason    : RT_Exception_Code)\n-      return      Node_Id\n+      Reason    : RT_Exception_Code) return Node_Id\n    is\n    begin\n       pragma Assert (Reason in RT_PE_Exceptions);\n@@ -333,8 +323,7 @@ package body Tbuild is\n    function Make_Raise_Storage_Error\n      (Sloc      : Source_Ptr;\n       Condition : Node_Id := Empty;\n-      Reason    : RT_Exception_Code)\n-      return      Node_Id\n+      Reason    : RT_Exception_Code) return Node_Id\n    is\n    begin\n       pragma Assert (Reason in RT_SE_Exceptions);\n@@ -360,8 +349,7 @@ package body Tbuild is\n    function Make_Unsuppress_Block\n      (Loc   : Source_Ptr;\n       Check : Name_Id;\n-      Stmts : List_Id)\n-      return  Node_Id\n+      Stmts : List_Id) return Node_Id\n    is\n    begin\n       return\n@@ -403,8 +391,7 @@ package body Tbuild is\n      (Related_Id   : Name_Id;\n       Suffix       : Character := ' ';\n       Suffix_Index : Int       := 0;\n-      Prefix       : Character := ' ')\n-      return         Name_Id\n+      Prefix       : Character := ' ') return Name_Id\n    is\n    begin\n       Get_Name_String (Related_Id);\n@@ -441,8 +428,7 @@ package body Tbuild is\n      (Related_Id   : Name_Id;\n       Suffix       : String;\n       Suffix_Index : Int       := 0;\n-      Prefix       : Character := ' ')\n-      return         Name_Id\n+      Prefix       : Character := ' ') return Name_Id\n    is\n    begin\n       Get_Name_String (Related_Id);\n@@ -476,8 +462,7 @@ package body Tbuild is\n \n    function New_External_Name\n      (Suffix       : Character;\n-      Suffix_Index : Nat)\n-      return         Name_Id\n+      Suffix_Index : Nat) return Name_Id\n    is\n    begin\n       Name_Buffer (1) := Suffix;\n@@ -505,8 +490,7 @@ package body Tbuild is\n \n    function New_Occurrence_Of\n      (Def_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id\n+      Loc    : Source_Ptr) return Node_Id\n    is\n       Occurrence : Node_Id;\n \n@@ -530,8 +514,7 @@ package body Tbuild is\n \n    function New_Reference_To\n      (Def_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id\n+      Loc    : Source_Ptr) return Node_Id\n    is\n       Occurrence : Node_Id;\n \n@@ -548,8 +531,7 @@ package body Tbuild is\n \n    function New_Suffixed_Name\n      (Related_Id : Name_Id;\n-      Suffix     : String)\n-      return       Name_Id\n+      Suffix     : String) return Name_Id\n    is\n    begin\n       Get_Name_String (Related_Id);\n@@ -566,7 +548,6 @@ package body Tbuild is\n \n    function OK_Convert_To (Typ : Entity_Id; Expr : Node_Id) return Node_Id is\n       Result : Node_Id;\n-\n    begin\n       Result :=\n         Make_Type_Conversion (Sloc (Expr),\n@@ -583,8 +564,7 @@ package body Tbuild is\n \n    function Unchecked_Convert_To\n      (Typ  : Entity_Id;\n-      Expr : Node_Id)\n-      return Node_Id\n+      Expr : Node_Id) return Node_Id\n    is\n       Loc    : constant Source_Ptr := Sloc (Expr);\n       Result : Node_Id;\n@@ -607,8 +587,9 @@ package body Tbuild is\n       then\n          Result := Relocate_Node (Expr);\n \n-      elsif Nkind (Expr) = N_Null then\n-\n+      elsif Nkind (Expr) = N_Null\n+        and then Is_Access_Type (Typ)\n+      then\n          --  No need for a conversion\n \n          Result := Relocate_Node (Expr);"}, {"sha": "7aac7295600f288c5cf4c8359d39c3ca32c3cb0d", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,8 +63,7 @@ package Tbuild is\n    function Make_Byte_Aligned_Attribute_Reference\n      (Sloc           : Source_Ptr;\n       Prefix         : Node_Id;\n-      Attribute_Name : Name_Id)\n-      return           Node_Id;\n+      Attribute_Name : Name_Id) return Node_Id;\n    pragma Inline (Make_Byte_Aligned_Attribute_Reference);\n    --  Like the standard Make_Attribute_Reference but the special flag\n    --  Must_Be_Byte_Aligned is set in the attribute reference node. The\n@@ -73,8 +72,7 @@ package Tbuild is\n    function Make_DT_Component\n      (Loc  : Source_Ptr;\n       Typ  : Entity_Id;\n-      I    : Positive)\n-      return Node_Id;\n+      I    : Positive) return Node_Id;\n    --  Gives a reference to the Ith component of the Dispatch Table of\n    --  a given Tagged Type.\n    --\n@@ -95,8 +93,7 @@ package Tbuild is\n       Condition       : Node_Id;\n       Then_Statements : List_Id;\n       Elsif_Parts     : List_Id := No_List;\n-      Else_Statements : List_Id := No_List)\n-      return            Node_Id;\n+      Else_Statements : List_Id := No_List) return Node_Id;\n    pragma Inline (Make_Implicit_If_Statement);\n    --  This function makes an N_If_Statement node whose fields are filled\n    --  in with the indicated values (see Sinfo), and whose Sloc field is\n@@ -108,8 +105,7 @@ package Tbuild is\n    function Make_Implicit_Label_Declaration\n      (Loc                 : Source_Ptr;\n       Defining_Identifier : Node_Id;\n-      Label_Construct     : Node_Id)\n-      return                Node_Id;\n+      Label_Construct     : Node_Id) return Node_Id;\n    --  Used to contruct an implicit label declaration node, including setting\n    --  the proper Label_Construct field (since Label_Construct is a semantic\n    --  field, the normal call to Make_Implicit_Label_Declaration does not\n@@ -121,8 +117,7 @@ package Tbuild is\n       Identifier             : Node_Id := Empty;\n       Iteration_Scheme       : Node_Id := Empty;\n       Has_Created_Identifier : Boolean := False;\n-      End_Label              : Node_Id := Empty)\n-      return                   Node_Id;\n+      End_Label              : Node_Id := Empty) return Node_Id;\n    --  This function makes an N_Loop_Statement node whose fields are filled\n    --  in with the indicated values (see Sinfo), and whose Sloc field is\n    --  is set to Sloc (Node). The effect is identical to calling function\n@@ -133,43 +128,38 @@ package Tbuild is\n \n    function Make_Integer_Literal\n      (Loc    : Source_Ptr;\n-      Intval : Int)\n-      return   Node_Id;\n+      Intval : Int) return Node_Id;\n    pragma Inline (Make_Integer_Literal);\n    --  A convenient form of Make_Integer_Literal taking Int instead of Uint\n \n    function Make_Raise_Constraint_Error\n      (Sloc      : Source_Ptr;\n       Condition : Node_Id := Empty;\n-      Reason    : RT_Exception_Code)\n-      return      Node_Id;\n+      Reason    : RT_Exception_Code) return Node_Id;\n    pragma Inline (Make_Raise_Constraint_Error);\n    --  A convenient form of Make_Raise_Constraint_Error where the Reason\n    --  is given simply as an enumeration value, rather than a Uint code.\n \n    function Make_Raise_Program_Error\n      (Sloc      : Source_Ptr;\n       Condition : Node_Id := Empty;\n-      Reason    : RT_Exception_Code)\n-      return      Node_Id;\n+      Reason    : RT_Exception_Code) return Node_Id;\n    pragma Inline (Make_Raise_Program_Error);\n    --  A convenient form of Make_Raise_Program_Error where the Reason\n    --  is given simply as an enumeration value, rather than a Uint code.\n \n    function Make_Raise_Storage_Error\n      (Sloc      : Source_Ptr;\n       Condition : Node_Id := Empty;\n-      Reason    : RT_Exception_Code)\n-      return      Node_Id;\n+      Reason    : RT_Exception_Code) return Node_Id;\n    pragma Inline (Make_Raise_Storage_Error);\n    --  A convenient form of Make_Raise_Storage_Error where the Reason\n    --  is given simply as an enumeration value, rather than a Uint code.\n \n    function Make_Unsuppress_Block\n      (Loc   : Source_Ptr;\n       Check : Name_Id;\n-      Stmts : List_Id)\n-      return  Node_Id;\n+      Stmts : List_Id) return Node_Id;\n    --  Build a block with a pragma Suppress on 'Check'. Stmts is the\n    --  statements list that needs protection against the check\n \n@@ -182,14 +172,12 @@ package Tbuild is\n      (Related_Id   : Name_Id;\n       Suffix       : Character := ' ';\n       Suffix_Index : Int       := 0;\n-      Prefix       : Character := ' ')\n-      return         Name_Id;\n+      Prefix       : Character := ' ') return Name_Id;\n    function New_External_Name\n      (Related_Id   : Name_Id;\n       Suffix       : String;\n       Suffix_Index : Int       := 0;\n-      Prefix       : Character := ' ')\n-      return         Name_Id;\n+      Prefix       : Character := ' ') return Name_Id;\n    --  Builds a new entry in the names table of the form:\n    --\n    --    [Prefix  &] Related_Id [& Suffix] [& Suffix_Index]\n@@ -217,8 +205,7 @@ package Tbuild is\n \n    function New_External_Name\n      (Suffix       : Character;\n-      Suffix_Index : Nat)\n-      return         Name_Id;\n+      Suffix_Index : Nat) return Name_Id;\n    --  Builds a new entry in the names table of the form\n    --    Suffix & Suffix_Index'Image\n    --  where Suffix is a single upper case letter other than O,Q,U,W,X and is\n@@ -249,8 +236,7 @@ package Tbuild is\n \n    function New_Occurrence_Of\n      (Def_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id;\n+      Loc    : Source_Ptr) return Node_Id;\n    --  New_Occurrence_Of creates an N_Identifier node which is an\n    --  occurrence of the defining identifier which is passed as its\n    --  argument. The Entity and Etype of the result are set from\n@@ -260,16 +246,14 @@ package Tbuild is\n \n    function New_Reference_To\n      (Def_Id : Entity_Id;\n-      Loc    : Source_Ptr)\n-      return   Node_Id;\n+      Loc    : Source_Ptr) return Node_Id;\n    --  This is like New_Occurrence_Of, but it does not set the Etype field.\n    --  It is used from the expander, where Etype fields are generally not set,\n    --  since they are set when the expanded tree is reanalyzed.\n \n    function New_Suffixed_Name\n      (Related_Id : Name_Id;\n-      Suffix     : String)\n-      return       Name_Id;\n+      Suffix     : String) return Name_Id;\n    --  This function is used to create special suffixed names used by the\n    --  debugger. Suffix is a string of upper case letters, used to construct\n    --  the required name. For instance, the special type used to record the\n@@ -282,8 +266,7 @@ package Tbuild is\n \n    function Unchecked_Convert_To\n      (Typ  : Entity_Id;\n-      Expr : Node_Id)\n-      return Node_Id;\n+      Expr : Node_Id) return Node_Id;\n    --  Like Convert_To, but if a conversion is actually needed, constructs\n    --  an N_Unchecked_Type_Conversion node to do the required conversion.\n "}, {"sha": "991550ad54013e4236d483687b3fc68025bde791", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30c2010625760849692e4fb21d7166616c138bb5/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=30c2010625760849692e4fb21d7166616c138bb5", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *           Copyright (C) 2000-2003 Ada Core Technologies, Inc.            *\n+ *           Copyright (C) 2000-2004 Ada Core Technologies, Inc.            *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -230,7 +230,7 @@ struct layout\n \n #define FRAME_OFFSET 0\n #define PC_ADJUST -4\n-#define STOP_FRAME(CURRENT, TOP_STACK) ((CURRENT)->return_address == 0)\n+#define STOP_FRAME(CURRENT, TOP_STACK) ((CURRENT)->next == 0)\n \n #define BASE_SKIP 1\n \n@@ -322,7 +322,6 @@ extern unsigned int _image_base__;\n # define CURRENT_STACK_FRAME  ({ char __csf; &__csf; })\n #endif\n \n-\n #ifndef VALID_STACK_FRAME\n #define VALID_STACK_FRAME(ptr) 1\n #endif"}]}