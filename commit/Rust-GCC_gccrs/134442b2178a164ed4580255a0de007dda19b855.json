{"sha": "134442b2178a164ed4580255a0de007dda19b855", "node_id": "C_kwDOANBUbNoAKDEzNDQ0MmIyMTc4YTE2NGVkNDU4MDI1NWEwZGUwMDdkZGExOWI4NTU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-03T10:21:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-03T10:21:00Z"}, "message": "c++: Support &typeid(x) == &typeid(y) and typeid(x) == typeid(y) in constant evaluation [PR103600]\n\nIf the tinfo vars are emitted in the current TU, they are emitted at the end\nof the compilation, and for some types they are exported from\nlibstdc++/libsupc++ and not emitted in the current TU at all.\n\nThe following patch allows constant folding of comparisons of typeid\naddresses and makes it possible to implement P1328R1 - making type_info\noperator== constexpr (Jonathan has a patch for that).\n\nAs mentioned in the PR, the varpool/middle-end code is trying to be\nconservative with address comparisons of different vars if those vars\ndon't bind locally, because of possible aliases in other TUs etc.\nand so while match.pd folds &typeid(int) == &typeid(int) because\nit is equality comparison with the same operands, for different typeids\nit doesn't fold it.\n\nOn Wed, Dec 08, 2021 at 08:53:03AM -0500, Jason Merrill wrote:\n> Would it make sense to assume that DECL_ARTIFICIAL variables can't be\n> aliases?  If not, could we have some way of marking a variable as\n> non-aliasing, perhaps an attribute?\n\nI think DECL_ARTIFICIAL vars generally can overlap.\n\nThe following patch adds a GCC internal attribute \"non overlapping\"\nand uses it in symtab_node::equal_address_to.\nNot sure what plans has Honza in that area and whether it would be useful\nto make the attribute public and let users assert that some variable will\nnever overlap with other variables, won't have aliases etc.\n\n> During constant evaluation, the operator== could compare the type_info\n> address instead of the __name address, reducing this to the previous\n> problem.\n\nAh, indeed, good idea.  FYI, clang++ seems to constant fold\n&typeid(x) != &typeid(y) already, so Jonathan could use it even for\nclang++ in the constexpr operator==.  But it folds even\nextern int &a, &b;\nconstexpr bool c = &a != &b;\nregardless of whether some other TU has\nint a;\nint b __attribute__((alias (a));\nor not.\n\n2022-01-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/103600\ngcc/\n\t* symtab.c (symtab_node::equal_address_to): Return 0 if one of\n\tVAR_DECLs has \"non overlapping\" attribute and rs1 != rs2.\ngcc/c-family/\n\t* c-attribs.c (handle_non_overlapping_attribute): New function.\n\t(c_common_attribute_table): Add \"non overlapping\" attribute.\ngcc/cp/\n\t* rtti.c (get_tinfo_decl_direct): Add \"non overlapping\" attribute\n\tto DECL_TINFO_P VAR_DECLs.\ngcc/testsuite/\n\t* g++.dg/cpp0x/constexpr-typeid2.C: New test.", "tree": {"sha": "6f048a33ed9afc59b39ffea97635723568cd5747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f048a33ed9afc59b39ffea97635723568cd5747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/134442b2178a164ed4580255a0de007dda19b855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134442b2178a164ed4580255a0de007dda19b855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/134442b2178a164ed4580255a0de007dda19b855", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134442b2178a164ed4580255a0de007dda19b855/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd83fd98a7e769ac7ded28377984f68238812a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd83fd98a7e769ac7ded28377984f68238812a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd83fd98a7e769ac7ded28377984f68238812a26"}], "stats": {"total": 43, "additions": 43, "deletions": 0}, "files": [{"sha": "dbb892e0ec6dbd6cc3335a70b3374697da0256b6", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134442b2178a164ed4580255a0de007dda19b855/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134442b2178a164ed4580255a0de007dda19b855/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=134442b2178a164ed4580255a0de007dda19b855", "patch": "@@ -159,6 +159,7 @@ static tree handle_omp_declare_variant_attribute (tree *, tree, tree, int,\n static tree handle_simd_attribute (tree *, tree, tree, int, bool *);\n static tree handle_omp_declare_target_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n+static tree handle_non_overlapping_attribute (tree *, tree, tree, int, bool *);\n static tree handle_designated_init_attribute (tree *, tree, tree, int, bool *);\n static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n \t\t\t\t\t\t       int, bool *);\n@@ -512,6 +513,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_omp_declare_target_attribute, NULL },\n   { \"omp declare target block\", 0, 0, true, false, false, false,\n \t\t\t      handle_omp_declare_target_attribute, NULL },\n+  { \"non overlapping\",\t      0, 0, true, false, false, false,\n+\t\t\t      handle_non_overlapping_attribute, NULL },\n   { \"alloc_align\",\t      1, 1, false, true, true, false,\n \t\t\t      handle_alloc_align_attribute,\n \t                      attr_alloc_exclusions },\n@@ -3765,6 +3768,15 @@ handle_omp_declare_target_attribute (tree *, tree, tree, int, bool *)\n   return NULL_TREE;\n }\n \n+/* Handle an \"non overlapping\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_non_overlapping_attribute (tree *, tree, tree, int, bool *)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"returns_twice\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "a4dedc31f0ab632181bbf86cd6e4223eebf2a697", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134442b2178a164ed4580255a0de007dda19b855/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134442b2178a164ed4580255a0de007dda19b855/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=134442b2178a164ed4580255a0de007dda19b855", "patch": "@@ -475,6 +475,15 @@ get_tinfo_decl_direct (tree type, tree name, int pseudo_ix)\n       DECL_IGNORED_P (d) = 1;\n       TREE_READONLY (d) = 1;\n       TREE_STATIC (d) = 1;\n+      /* Tell equal_address_to that different tinfo decls never\n+\t overlap.  */\n+      if (vec_safe_is_empty (unemitted_tinfo_decls))\n+\tDECL_ATTRIBUTES (d)\n+\t  = build_tree_list (get_identifier (\"non overlapping\"),\n+\t\t\t     NULL_TREE);\n+      else\n+\tDECL_ATTRIBUTES (d)\n+\t  = DECL_ATTRIBUTES ((*unemitted_tinfo_decls)[0]);\n \n       /* Mark the variable as undefined -- but remember that we can\n \t define it later if we need to do so.  */"}, {"sha": "f9e4571d396c628b00b21685ae6fd1a79d391fcc", "filename": "gcc/symtab.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134442b2178a164ed4580255a0de007dda19b855/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134442b2178a164ed4580255a0de007dda19b855/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=134442b2178a164ed4580255a0de007dda19b855", "patch": "@@ -2276,6 +2276,14 @@ symtab_node::equal_address_to (symtab_node *s2, bool memory_accessed)\n       return 0;\n     }\n \n+  /* If the FE tells us at least one of the decls will never be aliased nor\n+     overlapping with other vars in some other way, return 0.  */\n+  if (VAR_P (decl)\n+      && rs1 != rs2\n+      && (lookup_attribute (\"non overlapping\", DECL_ATTRIBUTES (decl))\n+\t  || lookup_attribute (\"non overlapping\", DECL_ATTRIBUTES (s2->decl))))\n+    return 0;\n+\n   /* TODO: Alias oracle basically assume that addresses of global variables\n      are different unless they are declared as alias of one to another while\n      the code folding comparisons doesn't."}, {"sha": "78c6b8e9a2ce9be18f3cd44c1650e225e567a9b7", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-typeid2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/134442b2178a164ed4580255a0de007dda19b855/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-typeid2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/134442b2178a164ed4580255a0de007dda19b855/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-typeid2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-typeid2.C?ref=134442b2178a164ed4580255a0de007dda19b855", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/103600\n+// { dg-do compile { target c++11 } }\n+\n+#include <typeinfo>\n+\n+struct S { int i; };\n+namespace {\n+  struct T { int i; };\n+};\n+constexpr bool a = &typeid (int) == &typeid (int);\n+constexpr bool b = &typeid (int) == &typeid (long);\n+constexpr bool c = &typeid (double) != &typeid (int);\n+constexpr bool d = &typeid (S) != &typeid (T);\n+static_assert (a && !b && c && d, \"\");"}]}