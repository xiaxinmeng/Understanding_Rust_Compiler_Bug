{"sha": "55eb4dab2793417e583d02c2ceaa20955442818b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlYjRkYWIyNzkzNDE3ZTU4M2QwMmMyY2VhYTIwOTU1NDQyODE4Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-01-29T18:21:39Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-01-29T18:21:39Z"}, "message": "tree-ssa-alias.c (same_type_for_tbaa): Return -1 if the types have the same alias set and their sizes different...\n\n\t* tree-ssa-alias.c (same_type_for_tbaa): Return -1 if the types have\n\tthe same alias set and their sizes different constantness.\n\t(aliasing_component_refs_p): Revert 2009-10-24 change.\n\nFrom-SVN: r156362", "tree": {"sha": "5344e048d3cfa8a76a87a8e11dda42f08b02b060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5344e048d3cfa8a76a87a8e11dda42f08b02b060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55eb4dab2793417e583d02c2ceaa20955442818b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55eb4dab2793417e583d02c2ceaa20955442818b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55eb4dab2793417e583d02c2ceaa20955442818b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55eb4dab2793417e583d02c2ceaa20955442818b/comments", "author": null, "committer": null, "parents": [{"sha": "dd70c860773c034379db9eb117ad69234111e796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd70c860773c034379db9eb117ad69234111e796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd70c860773c034379db9eb117ad69234111e796"}], "stats": {"total": 33, "additions": 19, "deletions": 14}, "files": [{"sha": "670344d0149c150f24101fa9bbdfd3b2f342567b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eb4dab2793417e583d02c2ceaa20955442818b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eb4dab2793417e583d02c2ceaa20955442818b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55eb4dab2793417e583d02c2ceaa20955442818b", "patch": "@@ -1,3 +1,9 @@\n+2010-01-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-ssa-alias.c (same_type_for_tbaa): Return -1 if the types have\n+\tthe same alias set and their sizes different constantness.\n+\t(aliasing_component_refs_p): Revert 2009-10-24 change.\n+\n 2010-01-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/sparc/sparc.c (sparc_elf_asm_named_section): Declare decl"}, {"sha": "6ace7e326808d7e5ddaabd8a87bc113cbccb3fa8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55eb4dab2793417e583d02c2ceaa20955442818b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55eb4dab2793417e583d02c2ceaa20955442818b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=55eb4dab2793417e583d02c2ceaa20955442818b", "patch": "@@ -537,13 +537,22 @@ same_type_for_tbaa (tree type1, tree type2)\n   if (TYPE_CANONICAL (type1) == TYPE_CANONICAL (type2))\n     return 1;\n \n-  /* ???  Array types are not properly unified in all cases as we have\n+  /* ??? Array types are not properly unified in all cases as we have\n      spurious changes in the index types for example.  Removing this\n      causes all sorts of problems with the Fortran frontend.  */\n   if (TREE_CODE (type1) == ARRAY_TYPE\n       && TREE_CODE (type2) == ARRAY_TYPE)\n     return -1;\n \n+  /* In Ada, an lvalue of unconstrained type can be used to access an object\n+     of one of its constrained subtypes, for example when a function with an\n+     unconstrained parameter passed by reference is called on a constrained\n+     object and inlined.  In this case, the types have the same alias set.  */\n+  if (TYPE_SIZE (type1) && TYPE_SIZE (type2)\n+      && TREE_CONSTANT (TYPE_SIZE (type1)) != TREE_CONSTANT (TYPE_SIZE (type2))\n+      && get_alias_set (type1) == get_alias_set (type2))\n+    return -1;\n+\n   /* The types are known to be not equal.  */\n   return 0;\n }\n@@ -600,19 +609,9 @@ aliasing_component_refs_p (tree ref1, tree type1,\n       offset1 -= offadj;\n       return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n     }\n-\n-  /* We haven't found any common base to apply offset-based disambiguation.\n-     There are two cases:\n-       1. The base access types have the same alias set.  This can happen\n-\t  in Ada when a function with an unconstrained parameter passed by\n-\t  reference is called on a constrained object and inlined: the types\n-\t  have the same alias set but aren't equivalent.  The references may\n-\t  alias in this case.\n-       2. The base access types don't have the same alias set, i.e. one set\n-\t  is a subset of the other.  We have proved that B1 is not in the\n-\t  access path B2.path and that B2 is not in the access path B1.path\n-\t  so the references may not alias.  */\n-  return get_alias_set (type1) == get_alias_set (type2);\n+  /* If we have two type access paths B1.path1 and B2.path2 they may\n+     only alias if either B1 is in B2.path2 or B2 is in B1.path1.  */\n+  return false;\n }\n \n /* Return true if two memory references based on the variables BASE1"}]}