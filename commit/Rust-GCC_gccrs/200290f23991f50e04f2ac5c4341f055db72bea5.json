{"sha": "200290f23991f50e04f2ac5c4341f055db72bea5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwMjkwZjIzOTkxZjUwZTA0ZjJhYzVjNDM0MWYwNTVkYjcyYmVhNQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-27T05:23:08Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-27T05:23:08Z"}, "message": "In gcc/: 2010-10-27 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * c-parser.c (c_parser_objc_at_property_declaration): Recognize\n        RID_ASSIGN, RID_COPY, RID_RETAIN, RID_READWRITE and RID_NONATOMIC.\n        Do not use objc_set_property_attr, but use local variables\n        instead.  Detect repeated usage of setter, getter and ivar\n        attributes.  Improved error processing when a setter name does not\n        end in ':'.  Do not check for CPP_CLOSE_PAREN after we determined\n        that the token is a keyword.  Updated call to\n        objc_add_property_declaration.\n\nIn gcc/cp/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * parser.c (cp_parser_objc_at_property_declaration): Recognize\n        RID_ASSIGN, RID_COPY, RID_RETAIN, RID_READWRITE and RID_NONATOMIC.\n        Do not use objc_set_property_attr, but use local variables\n        instead.  Detect repeated usage of setter, getter and ivar\n        attributes.  Improved error processing when a setter name does not\n        end in ':'.  Do not check for CPP_CLOSE_PAREN after we determined\n        that the token is a keyword.  Updated call to\n        objc_add_property_declaration.\n\nIn gcc/c-family/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * c-common.h (enum rid): Added RID_READWRITE, RID_ASSIGN,\n        RID_RETAIN, RID_COPY and RID_NONATOMIC.  Updated RID_FIRST_PATTR\n        and RID_LAST_PATTR.\n        (objc_add_property_declaration): Added additional arguments.\n        (objc_property_attribute_kind): Removed.\n        (objc_set_property_attr): Removed.\n        * c-common.c (c_common_reswords): Added readwrite, assign, retain,\n        copy and nonatomic.\n        * stub-objc.c (objc_add_property_declaration): Added additional\n        arguments.\n        (objc_set_property_attr): Removed.\n        \nIn gcc/objc/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (objc_add_property_declaration): Added arguments to\n        pass the various property attributes that were parsed with the\n        property declaration.  Process arguments to determine the final\n        property attributes and produce error messages as appropriate.\n        Added temporary code to keep the compiler silent about variables\n        set but not used - for new attributes that are only checked but\n        have no effect yet.\n        (property_readonly): Removed.\n        (property_setter): Removed.\n        (property_getter): Removed.\n        (property_ivar): Removed.\n        (property_copies): Removed.     \n        (objc_set_property_attr): Removed.\n        * objc-act.h (enum property_assign_semantics): New.\n        \nIn gcc/testsuite/:\n2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * obj-c.dg/property/at-property-4.m: New.\n        * obj-c++.dg/property/at-property-4.mm: New.\n        * obj-c++.dg/property/property-neg-5.m: Updated testcase for\n        updates in warning.\n        * obj-c++.dg/property/property-neg-5.mm: Updated testcase for\n        updates in warning.\n\nFrom-SVN: r165997", "tree": {"sha": "ba6ae21d33b46a8fb8b884194c9eb79ecdd38f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba6ae21d33b46a8fb8b884194c9eb79ecdd38f48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200290f23991f50e04f2ac5c4341f055db72bea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200290f23991f50e04f2ac5c4341f055db72bea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200290f23991f50e04f2ac5c4341f055db72bea5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200290f23991f50e04f2ac5c4341f055db72bea5/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f614132bc795c4773957e0d7fec7ee9dfd127274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f614132bc795c4773957e0d7fec7ee9dfd127274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f614132bc795c4773957e0d7fec7ee9dfd127274"}], "stats": {"total": 611, "additions": 437, "deletions": 174}, "files": [{"sha": "460cef3c325a84ce19f9c0fc0e22980888aadbd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -1,3 +1,14 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-parser.c (c_parser_objc_at_property_declaration): Recognize\n+\tRID_ASSIGN, RID_COPY, RID_RETAIN, RID_READWRITE and RID_NONATOMIC.\n+\tDo not use objc_set_property_attr, but use local variables\n+\tinstead.  Detect repeated usage of setter, getter and ivar\n+\tattributes.  Improved error processing when a setter name does not\n+\tend in ':'.  Do not check for CPP_CLOSE_PAREN after we determined\n+\tthat the token is a keyword.  Updated call to\n+\tobjc_add_property_declaration.\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-parser.c (c_parser_objc_at_property): Renamed to"}, {"sha": "4f30512870bc8e0d436c4babad04373e820edd0b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -1,3 +1,17 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* c-common.h (enum rid): Added RID_READWRITE, RID_ASSIGN,\n+\tRID_RETAIN, RID_COPY and RID_NONATOMIC.  Updated RID_FIRST_PATTR\n+\tand RID_LAST_PATTR.\n+\t(objc_add_property_declaration): Added additional arguments.\n+\t(objc_property_attribute_kind): Removed.\n+\t(objc_set_property_attr): Removed.\n+\t* c-common.c (c_common_reswords): Added readwrite, assign, retain,\n+\tcopy and nonatomic.\n+\t* stub-objc.c (objc_add_property_declaration): Added additional\n+\targuments.\n+\t(objc_set_property_attr): Removed.\n+\t\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c-common.h (objc_add_property_variable): Renamed to"}, {"sha": "a847be27ccdc4fc6e5c8c82a5442ea7b47426e9d", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -556,10 +556,16 @@ const struct c_common_resword c_common_reswords[] =\n   { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC },\n   { \"out\",\t\tRID_OUT,\t\tD_OBJC },\n   /* These are recognized inside a property attribute list */\n-  { \"readonly\",\t\tRID_READONLY,\t\tD_OBJC }, \n-  { \"copies\",\t\tRID_COPIES,\t\tD_OBJC },\n+  { \"assign\",\t        RID_ASSIGN,\t\tD_OBJC }, \n+  { \"copy\",\t        RID_COPY,\t\tD_OBJC }, \n   { \"getter\",\t\tRID_GETTER,\t\tD_OBJC }, \n+  { \"nonatomic\",\tRID_NONATOMIC,\t\tD_OBJC }, \n+  { \"readonly\",\t\tRID_READONLY,\t\tD_OBJC }, \n+  { \"readwrite\",\tRID_READWRITE,\t\tD_OBJC }, \n+  { \"retain\",\t        RID_RETAIN,\t\tD_OBJC }, \n   { \"setter\",\t\tRID_SETTER,\t\tD_OBJC }, \n+  /* The following two will be removed once @synthesize is fully implemented.  */\n+  { \"copies\",\t\tRID_COPIES,\t\tD_OBJC },\n   { \"ivar\",\t\tRID_IVAR,\t\tD_OBJC }, \n };\n "}, {"sha": "aa877d43583f95cea6e5139c557411eb0c771555", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -82,7 +82,13 @@ enum rid\n \n   /* ObjC (\"PATTR\" reserved words - they do not appear after a '@' \n      and are keywords only as property attributes)  */\n-  RID_READONLY, RID_COPIES, RID_GETTER, RID_SETTER, RID_IVAR,\n+  RID_GETTER, RID_SETTER,\n+  RID_READONLY, RID_READWRITE,\n+  RID_ASSIGN, RID_RETAIN, RID_COPY,\n+  /* RID_IVAR and RID_COPIES will be removed once @synthesize is\n+     completed.  */\n+  RID_COPIES, RID_IVAR,\n+  RID_NONATOMIC,\n \n   /* C (reserved and imaginary types not implemented, so any use is a\n      syntax error) */\n@@ -187,8 +193,8 @@ enum rid\n   RID_LAST_AT = RID_AT_IMPLEMENTATION,\n   RID_FIRST_PQ = RID_IN,\n   RID_LAST_PQ = RID_ONEWAY,\n-  RID_FIRST_PATTR = RID_READONLY,\n-  RID_LAST_PATTR = RID_IVAR\n+  RID_FIRST_PATTR = RID_GETTER,\n+  RID_LAST_PATTR = RID_NONATOMIC\n };\n \n #define OBJC_IS_AT_KEYWORD(rid) \\\n@@ -431,16 +437,6 @@ extern c_language_kind c_language;\n #define c_dialect_cxx()\t\t((c_language & clk_cxx) != 0)\n #define c_dialect_objc()\t((c_language & clk_objc) != 0)\n \n-/* ObjC Property Attribute types.  */\n-typedef enum objc_property_attribute_kind {\n-  OBJC_PATTR_INIT\t= 0,\n-  OBJC_PATTR_READONLY\t= 1,\n-  OBJC_PATTR_GETTER\t= 2,\n-  OBJC_PATTR_SETTER\t= 3,\n-  OBJC_PATTR_IVAR\t= 4,\n-  OBJC_PATTR_COPIES\t= 5\n-} objc_property_attribute_kind;\n-\n /* ObjC ivar visibility types.  */\n typedef enum objc_ivar_visibility_kind {\n   OBJC_IVAR_VIS_PROTECTED = 0,\n@@ -1040,10 +1036,10 @@ extern tree objc_generate_static_init_call (tree);\n extern tree objc_generate_write_barrier (tree, enum tree_code, tree);\n extern void objc_set_method_opt (bool);\n extern void objc_finish_foreach_loop (location_t, tree, tree, tree, tree, tree);\n-extern void objc_set_property_attr \n-  (location_t, objc_property_attribute_kind, tree);\n extern bool  objc_method_decl (enum tree_code);\n-extern void objc_add_property_declaration (location_t, tree);\n+extern void objc_add_property_declaration (location_t, tree, bool, bool, bool, \n+\t\t\t\t\t   bool, bool, bool, tree, tree,\n+\t\t\t\t\t   bool, tree);\n extern tree objc_build_getter_call (tree, tree);\n extern tree objc_build_setter_call (tree, tree);\n extern void objc_add_synthesize_declaration (location_t, tree);"}, {"sha": "d4a4e58785a5972a984d4c2e6636a3b479b4f33f", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -324,14 +324,18 @@ objc_get_class_ivars (tree ARG_UNUSED (name))\n }\n \n void\n-objc_set_property_attr (location_t ARG_UNUSED (loc),\n-\t\t\tobjc_property_attribute_kind ARG_UNUSED (code),\n-\t\t\ttree ARG_UNUSED (identifier))\n-{\n-}\n-\n-void\n-objc_add_property_declaration (location_t ARG_UNUSED (loc), tree ARG_UNUSED (prop))\n+objc_add_property_declaration (location_t ARG_UNUSED (location), \n+\t\t\t       tree ARG_UNUSED (decl),\n+\t\t\t       bool ARG_UNUSED (parsed_property_readonly),\n+\t\t\t       bool ARG_UNUSED (parsed_property_readwrite),\n+\t\t\t       bool ARG_UNUSED (parsed_property_assign),\n+\t\t\t       bool ARG_UNUSED (parsed_property_retain),\n+\t\t\t       bool ARG_UNUSED (parsed_property_copy),\n+\t\t\t       bool ARG_UNUSED (parsed_property_nonatomic),\n+\t\t\t       tree ARG_UNUSED (parsed_property_getter_ident),\n+\t\t\t       tree ARG_UNUSED (parsed_property_setter_ident),\n+\t\t\t       bool ARG_UNUSED (parsed_property_copies),\n+\t\t\t       tree ARG_UNUSED (parsed_property_ivar_ident))\n {\n }\n "}, {"sha": "932ab31e649b883fd37737c2ee1fbf303601f6b0", "filename": "gcc/c-parser.c", "status": "modified", "additions": 65, "deletions": 41, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -7603,24 +7603,42 @@ c_parser_objc_diagnose_bad_element_prefix (c_parser *parser,\n     @property int a, b, c;\n \n   PS: This function is identical to cp_parser_objc_at_propery_declaration\n-  for C++.  Keep them in sync.\n-\n-  WORK IN PROGRESS: At the moment, the list of attributes that are\n-  parsed is different from the above list.  It will be updated to use\n-  the above list at the same time as @synthesize is implemented.  */\n+  for C++.  Keep them in sync.  */\n static void\n c_parser_objc_at_property_declaration (c_parser *parser)\n {\n+  /* The following variables hold the attributes of the properties as\n+     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n+     seen.  When we see an attribute, we set them to 'true' (if they\n+     are boolean properties) or to the identifier (if they have an\n+     argument, ie, for getter and setter).  Note that here we only\n+     parse the list of attributes, check the syntax and accumulate the\n+     attributes that we find.  objc_add_property_declaration() will\n+     then process the information.  */\n+  bool property_assign = false;\n+  bool property_copy = false;\n+  tree property_getter_ident = NULL_TREE;\n+  bool property_nonatomic = false;\n+  bool property_readonly = false;\n+  bool property_readwrite = false;\n+  bool property_retain = false;\n+  tree property_setter_ident = NULL_TREE;\n+  /* The following two will be removed once @synthesize is\n+     implemented.  */\n+  bool property_copies = false;\n+  tree property_ivar_ident = NULL_TREE;\n+\n+  /* 'properties' is the list of properties that we read.  Usually a\n+     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n+     are three).  */\n   tree properties;\n   location_t loc;\n+\n   loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_AT_PROPERTY));\n \n   c_parser_consume_token (parser);  /* Eat '@property'.  */\n \n-  /* Initialize attributes to an empty list.  */\n-  objc_set_property_attr (loc, OBJC_PATTR_INIT, NULL_TREE);\n-\n   /* Parse the optional attribute list...  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n@@ -7648,18 +7666,20 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \t      break;\n \t    }\n \t  keyword = token->keyword;\n+\t  c_parser_consume_token (parser);\n \t  switch (keyword)\n \t    {\n-\t      tree ident;\n-\t      objc_property_attribute_kind pkind;\n-\t    case RID_READONLY:\n-\t      c_parser_consume_token (parser);\n-\t      objc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n-\t      break;\n+\t    case RID_ASSIGN:    property_assign = true;    break;\n+\t    case RID_COPIES:    property_copies = true;    break;\n+\t    case RID_COPY:      property_copy = true;      break;\n+\t    case RID_NONATOMIC: property_nonatomic = true; break;\n+\t    case RID_READONLY:  property_readonly = true;  break;\n+\t    case RID_READWRITE: property_readwrite = true; break;\n+\t    case RID_RETAIN:    property_retain = true;    break;\n+\n \t    case RID_GETTER:\n \t    case RID_SETTER:\n \t    case RID_IVAR:\n-\t      c_parser_consume_token (parser);\n \t      if (c_parser_next_token_is_not (parser, CPP_EQ))\n \t\t{\n \t\t  c_parser_error (parser,\n@@ -7674,39 +7694,37 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \t\t  syntax_error = true;\n \t\t  break;\n \t\t}\n-\t      ident = c_parser_peek_token (parser)->value;\n-\t      c_parser_consume_token (parser);\n \t      if (keyword == RID_SETTER)\n \t\t{\n-\t\t  pkind = OBJC_PATTR_SETTER;\n-\t\t  /* Eat the identifier, and look for the following : */\n-\t\t  if (c_parser_next_token_is_not (parser, CPP_COLON))\n-\t\t    {\n-\t\t      c_parser_error (parser,\n-\t\t\t\t      \"setter name must be followed by %<:%>\");\n-\t\t      syntax_error = true;\n-\t\t      break;\n-\t\t    }\n+\t\t  if (property_setter_ident != NULL_TREE)\n+\t\t    c_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_setter_ident = c_parser_peek_token (parser)->value;\n \t\t  c_parser_consume_token (parser);\n+\t\t  if (c_parser_next_token_is_not (parser, CPP_COLON))\n+\t\t    c_parser_error (parser, \"setter name must terminate with %<:%>\");\n+\t\t  else\n+\t\t    c_parser_consume_token (parser);\n \t\t}\n \t      else if (keyword == RID_GETTER)\n-\t\tpkind = OBJC_PATTR_GETTER;\n-\t      else\n-\t\tpkind = OBJC_PATTR_IVAR;\n-\t      objc_set_property_attr (loc, pkind, ident);\n-\t      break;\n-\t    case RID_COPIES:\n-\t      c_parser_consume_token (parser);\n-\t      objc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n-\t      break;\n-\t    default:\n-\t      if (token->type == CPP_CLOSE_PAREN)\n-\t\tc_parser_error (parser, \"expected identifier\");\n-\t      else\n \t\t{\n+\t\t  if (property_getter_ident != NULL_TREE)\n+\t\t    c_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_getter_ident = c_parser_peek_token (parser)->value;\n+\t\t  c_parser_consume_token (parser);\n+\t\t}\n+\t      else /* RID_IVAR, this case will go away.  */\n+\t\t{\n+\t\t  if (property_ivar_ident != NULL_TREE)\n+\t\t    c_parser_error (parser, \"the %<ivar%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_ivar_ident = c_parser_peek_token (parser)->value;\n \t\t  c_parser_consume_token (parser);\n-\t\t  c_parser_error (parser, \"unknown property attribute\");\n \t\t}\n+\t      break;\n+\t    default:\n+\t      c_parser_error (parser, \"unknown property attribute\");\n \t      syntax_error = true;\n \t      break;\n \t    }\n@@ -7741,7 +7759,13 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n       properties = nreverse (properties);\n       \n       for (; properties; properties = TREE_CHAIN (properties))\n-\tobjc_add_property_declaration (loc, copy_node (properties));\n+\tobjc_add_property_declaration (loc, copy_node (properties),\n+\t\t\t\t       property_readonly, property_readwrite,\n+\t\t\t\t       property_assign, property_retain,\n+\t\t\t\t       property_copy, property_nonatomic,\n+\t\t\t\t       property_getter_ident, property_setter_ident,\n+\t\t\t\t       /* The following two will be removed.  */\n+\t\t\t\t       property_copies, property_ivar_ident);\n     }\n \n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");"}, {"sha": "3a7e754b062ce87cd7030c6703aec81629dfcb9c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -1,3 +1,14 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* parser.c (cp_parser_objc_at_property_declaration): Recognize\n+\tRID_ASSIGN, RID_COPY, RID_RETAIN, RID_READWRITE and RID_NONATOMIC.\n+\tDo not use objc_set_property_attr, but use local variables\n+\tinstead.  Detect repeated usage of setter, getter and ivar\n+\tattributes.  Improved error processing when a setter name does not\n+\tend in ':'.  Do not check for CPP_CLOSE_PAREN after we determined\n+\tthat the token is a keyword.  Updated call to\n+\tobjc_add_property_declaration.\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* parser.c (cp_parser_objc_property_decl): Renamed to"}, {"sha": "d0bd6bb5e0bc2d086993b71686f0a5e03dc8a889", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 65, "deletions": 41, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -22648,23 +22648,41 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n     @property int a, b, c;\n \n    PS: This function is identical to\n-   c_parser_objc_at_property_declaration for C.  Keep them in sync.\n-\n-   WORK IN PROGRESS: At the moment, the list of attributes that are\n-   parsed is different from the above list.  It will be updated to use\n-   the above list at the same time as @synthesize is implemented.  */\n+   c_parser_objc_at_property_declaration for C.  Keep them in sync.  */\n static void \n cp_parser_objc_at_property_declaration (cp_parser *parser)\n {\n+  /* The following variables hold the attributes of the properties as\n+     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n+     seen.  When we see an attribute, we set them to 'true' (if they\n+     are boolean properties) or to the identifier (if they have an\n+     argument, ie, for getter and setter).  Note that here we only\n+     parse the list of attributes, check the syntax and accumulate the\n+     attributes that we find.  objc_add_property_declaration() will\n+     then process the information.  */\n+  bool property_assign = false;\n+  bool property_copy = false;\n+  tree property_getter_ident = NULL_TREE;\n+  bool property_nonatomic = false;\n+  bool property_readonly = false;\n+  bool property_readwrite = false;\n+  bool property_retain = false;\n+  tree property_setter_ident = NULL_TREE;\n+  /* The following two will be removed once @synthesize is\n+     implemented.  */\n+  bool property_copies = false;\n+  tree property_ivar_ident = NULL_TREE;\n+\n+  /* 'properties' is the list of properties that we read.  Usually a\n+     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n+     are three).  */\n   tree properties;\n   location_t loc;\n+\n   loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n \n-  /* Initialize attributes to an empty list.  */\n-  objc_set_property_attr (loc, OBJC_PATTR_INIT, NULL_TREE);\n-\n   /* Parse the optional attribute list...  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n@@ -22683,18 +22701,20 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \t      break;\n \t    }\n \t  keyword = C_RID_CODE (token->u.value);\n+\t  cp_lexer_consume_token (parser->lexer);\n \t  switch (keyword)\n \t    {\n-\t      tree ident;\n-\t      objc_property_attribute_kind pkind;\n-\t    case RID_READONLY:\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      objc_set_property_attr (loc, OBJC_PATTR_READONLY, NULL_TREE);\n-\t      break;\n+\t    case RID_ASSIGN:    property_assign = true;    break;\n+\t    case RID_COPIES:    property_copies = true;    break;\n+\t    case RID_COPY:      property_copy = true;      break;\n+\t    case RID_NONATOMIC: property_nonatomic = true; break;\n+\t    case RID_READONLY:  property_readonly = true;  break;\n+\t    case RID_READWRITE: property_readwrite = true; break;\n+\t    case RID_RETAIN:    property_retain = true;    break;\n+\n \t    case RID_GETTER:\n \t    case RID_SETTER:\n \t    case RID_IVAR:\n-\t      cp_lexer_consume_token (parser->lexer);\n \t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n \t\t{\n \t\t  cp_parser_error (parser,\n@@ -22709,39 +22729,37 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \t\t  syntax_error = true;\n \t\t  break;\n \t\t}\n-\t      ident = cp_lexer_peek_token (parser->lexer)->u.value;\n-\t      cp_lexer_consume_token (parser->lexer);\n \t      if (keyword == RID_SETTER)\n \t\t{\n-\t\t  pkind = OBJC_PATTR_SETTER;\n-\t\t  /* Eat the identifier, and look for the following : */\n-\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\t\t    {\n-\t\t      cp_parser_error (parser,\n-\t\t\t\t      \"setter name must be followed by %<:%>\");\n-\t\t      syntax_error = true;\n-\t\t      break;\n-\t\t    }\n+\t\t  if (property_setter_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_setter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n \t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t\t    cp_parser_error (parser, \"setter name must terminate with %<:%>\");\n+\t\t  else\n+\t\t    cp_lexer_consume_token (parser->lexer);\n \t\t}\n \t      else if (keyword == RID_GETTER)\n-\t\tpkind = OBJC_PATTR_GETTER;\n-\t      else\n-\t\tpkind = OBJC_PATTR_IVAR;\n-\t      objc_set_property_attr (loc, pkind, ident);\n-\t      break;\n-\t    case RID_COPIES:\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      objc_set_property_attr (loc, OBJC_PATTR_COPIES, NULL_TREE);\n-\t      break;\n-\t    default:\n-\t      if (token->type == CPP_CLOSE_PAREN)\n-\t\tcp_parser_error (parser, \"expected identifier\");\n-\t      else\n \t\t{\n+\t\t  if (property_getter_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_getter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n \t\t  cp_lexer_consume_token (parser->lexer);\n-\t\t  cp_parser_error (parser, \"unknown property attribute\");\n \t\t}\n+\t      else /* RID_IVAR, this case will go away.  */\n+\t\t{\n+\t\t  if (property_ivar_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<ivar%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_ivar_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      cp_parser_error (parser, \"unknown property attribute\");\n \t      syntax_error = true;\n \t      break;\n \t    }\n@@ -22785,7 +22803,13 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n       properties = nreverse (properties);\n       \n       for (; properties; properties = TREE_CHAIN (properties))\n-\tobjc_add_property_declaration (loc, copy_node (properties));\n+\tobjc_add_property_declaration (loc, copy_node (properties),\n+\t\t\t\t       property_readonly, property_readwrite,\n+\t\t\t\t       property_assign, property_retain,\n+\t\t\t\t       property_copy, property_nonatomic,\n+\t\t\t\t       property_getter_ident, property_setter_ident,\n+\t\t\t\t       /* The following two will be removed.  */\n+\t\t\t\t       property_copies, property_ivar_ident);\n     }\n   \n   cp_parser_consume_semicolon_at_end_of_statement (parser);"}, {"sha": "aa5876489a52298ae1952349c7861c43b4a1a5cd", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -1,3 +1,20 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (objc_add_property_declaration): Added arguments to\n+\tpass the various property attributes that were parsed with the\n+\tproperty declaration.  Process arguments to determine the final\n+\tproperty attributes and produce error messages as appropriate.\n+\tAdded temporary code to keep the compiler silent about variables\n+\tset but not used - for new attributes that are only checked but\n+\thave no effect yet.\n+\t(property_readonly): Removed.\n+\t(property_setter): Removed.\n+\t(property_getter): Removed.\n+\t(property_ivar): Removed.\n+\t(property_copies): Removed.\t\n+\t(objc_set_property_attr): Removed.\n+\t* objc-act.h (enum property_assign_semantics): New.\n+\t\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_add_property_variable): Renamed to"}, {"sha": "674b77e68947e49d97e9cfa63c55514e1e3634d5", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 123, "deletions": 64, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -406,11 +406,6 @@ static int method_slot = 0;\n    required.  */\n static bool objc_method_optional_flag = false;\n \n-static bool property_readonly;\n-static tree property_getter;\n-static tree property_setter;\n-static tree property_ivar;\n-static bool property_copies;\n static bool in_objc_property_setter_name_context = false;\n \n static int objc_collecting_ivars = 0;\n@@ -815,68 +810,93 @@ objc_set_method_opt (bool optional)\n     }\n }\n \n-/* This routine gathers property attribute information from the attribute\n-   portion of a property declaration. */\n-\n+/* This routine is called by the parser when a\n+   @property... declaration is found.  'decl' is the declaration of\n+   the property (type/identifier), and the other arguments represent\n+   property attributes that may have been specified in the Objective-C\n+   declaration.  'parsed_property_readonly' is 'true' if the attribute\n+   'readonly' was specified, and 'false' if not; similarly for the\n+   other bool parameters.  'parsed_property_getter_ident' is NULL_TREE\n+   if the attribute 'getter' was not specified, and is the identifier\n+   corresponding to the specified getter if it was; similarly for\n+   'parsed_property_setter_ident'.  */\n void\n-objc_set_property_attr (location_t loc, objc_property_attribute_kind attr,\n-\t\t\ttree ident)\n+objc_add_property_declaration (location_t location, tree decl,\n+\t\t\t       bool parsed_property_readonly, bool parsed_property_readwrite,\n+\t\t\t       bool parsed_property_assign, bool parsed_property_retain,\n+\t\t\t       bool parsed_property_copy, bool parsed_property_nonatomic,\n+\t\t\t       tree parsed_property_getter_ident, tree parsed_property_setter_ident,\n+\t\t\t       /* The following two will be removed.  */\n+\t\t\t       bool parsed_property_copies, tree parsed_property_ivar_ident)\n {\n-  static char string[BUFSIZE];\n-  switch (attr)\n+  tree property_decl;\n+  tree x;\n+  tree interface = NULL_TREE;\n+  /* 'property_readonly' is the final readonly/rewrite attribute of\n+     the property declaration after all things have been\n+     considered.  */\n+  bool property_readonly = false;\n+  enum objc_property_assign_semantics property_assign_semantics = OBJC_PROPERTY_ASSIGN;\n+  /* The following will be removed once @synthesize is implemented.  */\n+  bool property_copies = false;\n+\n+  if (parsed_property_readonly && parsed_property_readwrite)\n+    {\n+      error_at (location, \"%<readonly%> attribute conflicts with %<readwrite%> attribute\");\n+      /* In case of conflicting attributes (here and below), after\n+\t producing an error, we pick one of the attributes and keep\n+\t going.  */\n+      property_readonly = false;\n+    }\n+  else\n     {\n-    case OBJC_PATTR_INIT: /* init */\n-\tproperty_readonly = property_copies = false;\n-\tproperty_setter = property_getter = property_ivar = NULL_TREE;\n-\tbreak;\n-    case OBJC_PATTR_READONLY: /* readonly */\n+      if (parsed_property_readonly)\n \tproperty_readonly = true;\n-\tbreak;\n-    case OBJC_PATTR_GETTER: /* getter = ident */\n-\tif (property_getter != NULL_TREE)\n-\t  error_at (loc, \"the %<getter%> attribute may only be specified once\");\n-        property_getter = ident;\n-\tbreak;\n-    case OBJC_PATTR_SETTER: /* setter = ident */\n-\tif (property_setter != NULL_TREE)\n-\t  error_at (loc, \"the %<setter%> attribute may only be specified once\");\n-\t/* setters always have a trailing ':' in their name. In fact, this is the\n-\t   only syntax that parser recognizes for a setter name. Must add a trailing\n-\t   ':' here so name matches that of the declaration of user instance method\n-\t   for the setter. */\n-\tsprintf (string, \"%s:\", IDENTIFIER_POINTER (ident));\n-\tproperty_setter = get_identifier (string);;\n-\tbreak;\n-    case OBJC_PATTR_IVAR: /* ivar = ident */\n-\tif (property_ivar != NULL_TREE)\n-\t  error_at (loc, \"the %<ivar%> attribute may only be specified once\");\n-\telse if (objc_interface_context) \n-\t  {\n-\t    warning_at (loc, 0, \"the %<ivar%> attribute is ignored in an @interface\");\n-\t    property_ivar = NULL_TREE;\n-\t  }\n-\telse\n-\t  property_ivar = ident;\n-\tbreak;\n-    case OBJC_PATTR_COPIES: /* copies */\n-\tproperty_copies = true;\n-\tbreak;\n-    default:\n-\tbreak;\n+  \n+      if (parsed_property_readwrite)\n+\tproperty_readonly = false;\n     }\n-}\n \n-/* This routine builds a 'property_decl' tree node and adds it to the list\n-   of such properties in the current class. It also checks for duplicates.\n-*/\n+  if (parsed_property_readonly && parsed_property_setter_ident)\n+    {\n+      /* Maybe this should be an error ? */\n+      warning_at (location, 0, \"%<readonly%> attribute conflicts with %<setter%> attribute\");\n+      parsed_property_readonly = false;\n+    }\n \n-void\n-objc_add_property_declaration (location_t location, tree decl)\n-{\n-  tree property_decl;\n-  tree x;\n-  tree interface = NULL_TREE;\n+  if (parsed_property_assign && parsed_property_retain)\n+    {\n+      error_at (location, \"%<assign%> attribute conflicts with %<retain%> attribute\");\n+      property_assign_semantics = OBJC_PROPERTY_RETAIN;\n+    }\n+  else if (parsed_property_assign && parsed_property_copy)\n+    {\n+      error_at (location, \"%<assign%> attribute conflicts with %<copy%> attribute\");\n+      property_assign_semantics = OBJC_PROPERTY_COPY;\n+    }\n+  else if (parsed_property_retain && parsed_property_copy)\n+    {\n+      error_at (location, \"%<retain%> attribute conflicts with %<copy%> attribute\");\n+      property_assign_semantics = OBJC_PROPERTY_COPY;\n+    }\n+  else\n+    {\n+      if (parsed_property_assign)\n+\tproperty_assign_semantics = OBJC_PROPERTY_ASSIGN;\n+\n+      if (parsed_property_retain)\n+\tproperty_assign_semantics = OBJC_PROPERTY_RETAIN;\n+\n+      if (parsed_property_copy)\n+\tproperty_assign_semantics = OBJC_PROPERTY_COPY;\n+    }\n \n+  /* This will be removed when @synthesize is implemented.  */\n+  if (parsed_property_copies)\n+    property_copies = true;\n+\n+  /* This case will be removed when @synthesize is implemented; then\n+     @property will only be allowed in an @interface context.  */\n   if (objc_implementation_context)\n     {\n       interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n@@ -896,26 +916,62 @@ objc_add_property_declaration (location_t location, tree decl)\n \t    }\n         }\n     }\n+  else if (objc_interface_context) \n+    {\n+      /* This will be removed when ivar is removed.  */\n+      if (parsed_property_ivar_ident)\n+\t{\n+\t  warning_at (location, 0, \"the %<ivar%> attribute is ignored in an @interface\");\n+\t  parsed_property_ivar_ident = NULL_TREE;\n+\t}\n+    }\n   else if (!objc_interface_context)\n     {\n       error_at (location, \"property declaration not in @interface or @implementation context\");\n       return;\n     }\n \n+  if (parsed_property_setter_ident)\n+    {\n+      /* The setter should be terminated by ':', but the parser only\n+\t passes us an identifier without ':'.  So, we need to add ':'\n+\t at the end.  */\n+      const char *parsed_setter = IDENTIFIER_POINTER (parsed_property_setter_ident);\n+      size_t length = strlen (parsed_setter);\n+      char *final_setter = (char *)alloca (length + 2);\n+\n+      sprintf (final_setter, \"%s:\", parsed_setter);\n+      parsed_property_setter_ident = get_identifier (final_setter);\n+    }\n+\n   property_decl = make_node (PROPERTY_DECL);\n   TREE_TYPE (property_decl) = TREE_TYPE (decl);\n \n   PROPERTY_NAME (property_decl) = DECL_NAME (decl);\n-  PROPERTY_GETTER_NAME (property_decl) = property_getter;\n-  PROPERTY_SETTER_NAME (property_decl) = property_setter;\n-  PROPERTY_IVAR_NAME (property_decl) = property_ivar;\n+  PROPERTY_GETTER_NAME (property_decl) = parsed_property_getter_ident;\n+  PROPERTY_SETTER_NAME (property_decl) = parsed_property_setter_ident;\n+  PROPERTY_IVAR_NAME (property_decl) = parsed_property_ivar_ident;\n   PROPERTY_READONLY (property_decl) = property_readonly \n \t\t\t\t\t? boolean_true_node \n \t\t\t\t\t: boolean_false_node;\n   PROPERTY_COPIES (property_decl) = property_copies \n \t\t\t\t\t? boolean_true_node \n \t\t\t\t\t: boolean_false_node;\n \n+  /* TODO: The following is temporary code that will be removed when\n+     property_assign_semantics and property_nonatomic are\n+     implemented.  */\n+  if (objc_implementation_context && objc_interface_context)\n+    {\n+      /* This branch is impossible but the compiler can't know it.  Do\n+\t something with property_assign_semantics and\n+\t parsed_property_nonatomic (not implemented yet) to convince\n+\t the compiler we're using them and prevent it from generating\n+\t warnings and breaking bootstrap.  */\n+      PROPERTY_COPIES (property_decl) = property_assign_semantics ? boolean_true_node : boolean_false_node;\n+      PROPERTY_READONLY (property_decl) = parsed_property_nonatomic ? boolean_true_node : boolean_false_node;\n+    }\n+\n   if (objc_interface_context)\n     {\n       /* Doing the property in interface declaration. */\n@@ -938,6 +994,8 @@ objc_add_property_declaration (location_t location, tree decl)\n     }\n   else\n     {\n+      /* This case will go away once @syhtensize is implemented.  */\n+\n       /* Doing the property in implementation context. */\n       /* If property is not declared in the interface issue error. */\n       for (x = CLASS_PROPERTY_DECL (interface); x; x = TREE_CHAIN (x))\n@@ -964,7 +1022,8 @@ objc_add_property_declaration (location_t location, tree decl)\n       if (PROPERTY_READONLY (property_decl) == boolean_true_node &&\n \t  PROPERTY_SETTER_NAME (property_decl))\n \t{\n-\t  warning_at (location, 0, \"a %<readonly%> property cannot have a setter (ignored)\");\n+\t  /* This error is already reported up there.  */\n+\t  /* warning_at (location, 0, \"a %<readonly%> property cannot have a setter (ignored)\"); */\n \t  PROPERTY_SETTER_NAME (property_decl) = NULL_TREE;\n \t}\n       /* Add the property to the list of properties for current implementation. */\n@@ -1039,7 +1098,7 @@ lookup_property (tree interface_type, tree property)\n   return inter;\n }\n \n-/* This routine recognizes a dot-notation for a propery reference and generates a call to\n+/* This routine recognizes a dot-notation for a property reference and generates a call to\n    the getter function for this property. In all other cases, it returns a NULL_TREE.\n */\n "}, {"sha": "2456c1090097f01876a247c47565f4a7be86ff99", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -61,6 +61,12 @@ tree objc_eh_personality (void);\n #define PROPERTY_READONLY(DECL) ((DECL)->decl_minimal.context)\n #define PROPERTY_COPIES(DECL) ((DECL)->decl_common.size_unit)\n \n+enum objc_property_assign_semantics {\n+  OBJC_PROPERTY_ASSIGN = 1,\n+  OBJC_PROPERTY_RETAIN = 2,\n+  OBJC_PROPERTY_COPY = 3\n+};\n+\n /* CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,\n    PROTOCOL_INTERFACE_TYPE */"}, {"sha": "09a9f6b3335e56a4da0216e2c4048f75b182fab2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -1,3 +1,12 @@\n+2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* obj-c.dg/property/at-property-4.m: New.\n+\t* obj-c++.dg/property/at-property-4.mm: New.\n+\t* obj-c++.dg/property/property-neg-5.m: Updated testcase for\n+\tupdates in warning.\n+\t* obj-c++.dg/property/property-neg-5.mm: Updated testcase for\n+\tupdates in warning.\n+\t\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/property/at-property-1.m: New.\t"}, {"sha": "05223a3fa223bb5e06ea608b5ffab02ba92894e1", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-4.mm", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-4.mm?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+- (id) myGetter;\n+- (id) myGetterB;\n+- (void) mySetter: (id)property;\n+- (void) mySetterB: (id)property;\n+\n+/* Test that all the new property attributes can be parsed.  */\n+@property (assign)    id property_a;\n+@property (copy)      id property_b;\n+@property (nonatomic) id property_c;\n+@property (readonly)  id property_d;\n+@property (readwrite) id property_e;\n+@property (retain)    id property_f;\n+@property (release)   id property_g;      /* { dg-error \"unknown property attribute\" } */\n+\n+/* The following will be enabled when @synthesized is implemented.  */\n+/* @property (getter=myGetter)   id property_h; */\n+/* @property (setter=mySetter:)  id property_i; */\n+\n+/* Now test various problems.  */\n+\n+@property (readonly, readwrite) int a;    /* { dg-error \".readonly. attribute conflicts with .readwrite. attribute\" } */\n+/* The following will be enabled when @synthesized is implemented.  */\n+/* @property (readonly, setter=setA:) int b; */ /* dg-warning \".readonly. attribute conflicts with .setter. attribute\" */\n+\n+@property (assign, retain) id c;          /* { dg-error \".assign. attribute conflicts with .retain. attribute\" } */\n+@property (assign, copy) id d;            /* { dg-error \".assign. attribute conflicts with .copy. attribute\" } */\n+@property (copy, retain) id e;            /* { dg-error \".retain. attribute conflicts with .copy. attribute\" } */\n+\n+/* The following will be enabled when @synthesized is implemented.  */\n+/* @property (setter=mySetter:,setter=mySetterB:)  id f; */ /* dg-error \".setter. attribute may only be specified once\" */\n+/* @property (getter=myGetter:,getter=myGetterB:)  id f; */ /* dg-error \".getter. attribute may only be specified once\" */\n+\n+@end"}, {"sha": "7a9090ad056559408a0a12ba1af04c3ada9f3117", "filename": "gcc/testsuite/obj-c++.dg/property/property-neg-5.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fproperty-neg-5.mm?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -2,6 +2,6 @@\n /* { dg-do compile } */\n \n @interface Foo\n-@property ( readonly, getter = HELLO, setter = THERE : ) int value;\n+@property ( readonly, getter = HELLO, setter = THERE : ) int value; /* { dg-warning \".readonly. attribute conflicts with .setter. attribute\" } */\n @end\t/* { dg-warning \"getter = \\\\'HELLO\\\\' may not be specified in an interface\" } */ \n \t/* { dg-warning \"setter = \\\\'THERE\\\\:\\\\' may not be specified in an interface\" \"\" { target *-*-* } 6 } */"}, {"sha": "05223a3fa223bb5e06ea608b5ffab02ba92894e1", "filename": "gcc/testsuite/objc.dg/property/at-property-4.m", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-4.m?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+- (id) myGetter;\n+- (id) myGetterB;\n+- (void) mySetter: (id)property;\n+- (void) mySetterB: (id)property;\n+\n+/* Test that all the new property attributes can be parsed.  */\n+@property (assign)    id property_a;\n+@property (copy)      id property_b;\n+@property (nonatomic) id property_c;\n+@property (readonly)  id property_d;\n+@property (readwrite) id property_e;\n+@property (retain)    id property_f;\n+@property (release)   id property_g;      /* { dg-error \"unknown property attribute\" } */\n+\n+/* The following will be enabled when @synthesized is implemented.  */\n+/* @property (getter=myGetter)   id property_h; */\n+/* @property (setter=mySetter:)  id property_i; */\n+\n+/* Now test various problems.  */\n+\n+@property (readonly, readwrite) int a;    /* { dg-error \".readonly. attribute conflicts with .readwrite. attribute\" } */\n+/* The following will be enabled when @synthesized is implemented.  */\n+/* @property (readonly, setter=setA:) int b; */ /* dg-warning \".readonly. attribute conflicts with .setter. attribute\" */\n+\n+@property (assign, retain) id c;          /* { dg-error \".assign. attribute conflicts with .retain. attribute\" } */\n+@property (assign, copy) id d;            /* { dg-error \".assign. attribute conflicts with .copy. attribute\" } */\n+@property (copy, retain) id e;            /* { dg-error \".retain. attribute conflicts with .copy. attribute\" } */\n+\n+/* The following will be enabled when @synthesized is implemented.  */\n+/* @property (setter=mySetter:,setter=mySetterB:)  id f; */ /* dg-error \".setter. attribute may only be specified once\" */\n+/* @property (getter=myGetter:,getter=myGetterB:)  id f; */ /* dg-error \".getter. attribute may only be specified once\" */\n+\n+@end"}, {"sha": "7a9090ad056559408a0a12ba1af04c3ada9f3117", "filename": "gcc/testsuite/objc.dg/property/property-neg-5.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200290f23991f50e04f2ac5c4341f055db72bea5/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fproperty-neg-5.m?ref=200290f23991f50e04f2ac5c4341f055db72bea5", "patch": "@@ -2,6 +2,6 @@\n /* { dg-do compile } */\n \n @interface Foo\n-@property ( readonly, getter = HELLO, setter = THERE : ) int value;\n+@property ( readonly, getter = HELLO, setter = THERE : ) int value; /* { dg-warning \".readonly. attribute conflicts with .setter. attribute\" } */\n @end\t/* { dg-warning \"getter = \\\\'HELLO\\\\' may not be specified in an interface\" } */ \n \t/* { dg-warning \"setter = \\\\'THERE\\\\:\\\\' may not be specified in an interface\" \"\" { target *-*-* } 6 } */"}]}