{"sha": "cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JlM2I4ZDQ5ZDA3Y2Y1ZWVlNjJjMzk2M2I4NDNmM2VhOTMxYjAzZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-05-27T20:42:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:19Z"}, "message": "[Ada] Small cleanup throughout Exp_Ch4\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_Array_Comparison): Reformat.\n\t(Expand_Concatenate): Use standard size values directly and use\n\tStandard_Long_Long_Unsigned instead of RE_Long_Long_Unsigned.\n\t(Expand_Modular_Op): Use Standard_Long_Long_Integer in case the\n\tmodulus is larger than Integer.\n\t(Expand_N_Op_Expon): Use standard size value directly.\n\t(Narrow_Large_Operation): Use Uint instead of Nat for sizes and\n\tuse a local variable for the size of the type.\n\t(Get_Size_For_Range): Return Uint instead of Nat.\n\t(Is_OK_For_Range): Take Uint instead of Nat.", "tree": {"sha": "fcd88e4ba1c4b91a9f174b86d926a17125e6c137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcd88e4ba1c4b91a9f174b86d926a17125e6c137"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e91f87c3e7b76af8a73b52498f76aa3aea50b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e91f87c3e7b76af8a73b52498f76aa3aea50b69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e91f87c3e7b76af8a73b52498f76aa3aea50b69"}], "stats": {"total": 65, "additions": 32, "deletions": 33}, "files": [{"sha": "e3af266f5516e62b3903f8ed8b05c90da21c8198", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "patch": "@@ -1378,9 +1378,7 @@ package body Exp_Ch4 is\n       --  except that we avoid this for targets for which are not addressable\n       --  by bytes.\n \n-      if not Is_Bit_Packed_Array (Typ1)\n-        and then Byte_Addressable\n-      then\n+      if not Is_Bit_Packed_Array (Typ1) and then Byte_Addressable then\n          --  The call we generate is:\n \n          --  Compare_Array_xn[_Unaligned]\n@@ -3008,23 +3006,23 @@ package body Exp_Ch4 is\n \n       --  For modular types, we use a 32-bit modular type for types whose size\n       --  is in the range 1-31 bits. For 32-bit unsigned types, we use the\n-      --  identity type, and for larger unsigned types we use 64-bits.\n+      --  identity type, and for larger unsigned types we use a 64-bit type.\n \n       elsif Is_Modular_Integer_Type (Ityp) then\n-         if RM_Size (Ityp) < RM_Size (Standard_Unsigned) then\n+         if RM_Size (Ityp) < Standard_Integer_Size then\n             Artyp := Standard_Unsigned;\n-         elsif RM_Size (Ityp) = RM_Size (Standard_Unsigned) then\n+         elsif RM_Size (Ityp) = Standard_Integer_Size then\n             Artyp := Ityp;\n          else\n-            Artyp := RTE (RE_Long_Long_Unsigned);\n+            Artyp := Standard_Long_Long_Unsigned;\n          end if;\n \n       --  Similar treatment for signed types\n \n       else\n-         if RM_Size (Ityp) < RM_Size (Standard_Integer) then\n+         if RM_Size (Ityp) < Standard_Integer_Size then\n             Artyp := Standard_Integer;\n-         elsif RM_Size (Ityp) = RM_Size (Standard_Integer) then\n+         elsif RM_Size (Ityp) = Standard_Integer_Size then\n             Artyp := Ityp;\n          else\n             Artyp := Standard_Long_Long_Integer;\n@@ -4167,7 +4165,7 @@ package body Exp_Ch4 is\n             --  errors on large legal literals of the type.\n \n             if Modulus (Etype (N)) > UI_From_Int (Int (Integer'Last)) then\n-               Target_Type := Standard_Long_Integer;\n+               Target_Type := Standard_Long_Long_Integer;\n             else\n                Target_Type := Standard_Integer;\n             end if;\n@@ -8747,7 +8745,7 @@ package body Exp_Ch4 is\n         --  We only handle cases where the right type is a integer\n \n         and then Is_Integer_Type (Root_Type (Exptyp))\n-        and then Esize (Root_Type (Exptyp)) <= Esize (Standard_Integer)\n+        and then Esize (Root_Type (Exptyp)) <= Standard_Integer_Size\n \n         --  This transformation is not applicable for a modular type with a\n         --  nonbinary modulus because we do not handle modular reduction in\n@@ -11394,7 +11392,7 @@ package body Exp_Ch4 is\n          --  integer type large enough to hold the result.\n \n          if Is_Fixed_Point_Type (Etype (Expr)) then\n-            if Esize (Base_Type (Etype (Expr))) > Esize (Standard_Integer) then\n+            if Esize (Base_Type (Etype (Expr))) > Standard_Integer_Size then\n                Ityp := Standard_Long_Long_Integer;\n             else\n                Ityp := Standard_Integer;\n@@ -13910,25 +13908,26 @@ package body Exp_Ch4 is\n       Compar : constant Boolean   := Kind in N_Op_Compare or else In_Rng;\n       R      : constant Node_Id   := Right_Opnd (N);\n       Typ    : constant Entity_Id := Etype (R);\n+      Tsiz   : constant Uint      := RM_Size (Typ);\n \n-      function Get_Size_For_Range (Lo, Hi : Uint) return Nat;\n+      function Get_Size_For_Range (Lo, Hi : Uint) return Uint;\n       --  Return the size of a small signed integer type covering Lo .. Hi.\n       --  The important thing is to return a size lower than that of Typ.\n \n       ------------------------\n       -- Get_Size_For_Range --\n       ------------------------\n \n-      function Get_Size_For_Range (Lo, Hi : Uint) return Nat is\n+      function Get_Size_For_Range (Lo, Hi : Uint) return Uint is\n \n-         function Is_OK_For_Range (Siz : Nat) return Boolean;\n+         function Is_OK_For_Range (Siz : Uint) return Boolean;\n          --  Return True if a signed integer with given size can cover Lo .. Hi\n \n          --------------------------\n          -- Is_OK_For_Range --\n          --------------------------\n \n-         function Is_OK_For_Range (Siz : Nat) return Boolean is\n+         function Is_OK_For_Range (Siz : Uint) return Boolean is\n             B : constant Uint := Uint_2 ** (Siz - 1);\n \n          begin\n@@ -13940,21 +13939,21 @@ package body Exp_Ch4 is\n       begin\n          --  This is (almost always) the size of Integer\n \n-         if Is_OK_For_Range (32) then\n-            return 32;\n+         if Is_OK_For_Range (Uint_32) then\n+            return Uint_32;\n \n          --  If the size of Typ is 64 then check 63\n \n-         elsif RM_Size (Typ) = 64 and then Is_OK_For_Range (63) then\n-            return 63;\n+         elsif Tsiz = Uint_64 and then Is_OK_For_Range (Uint_63) then\n+            return Uint_63;\n \n          --  This is (almost always) the size of Long_Long_Integer\n \n-         elsif Is_OK_For_Range (64) then\n-            return 64;\n+         elsif Is_OK_For_Range (Uint_64) then\n+            return Uint_64;\n \n          else\n-            return 128;\n+            return Uint_128;\n          end if;\n       end Get_Size_For_Range;\n \n@@ -13963,9 +13962,9 @@ package body Exp_Ch4 is\n       L          : Node_Id;\n       Llo, Lhi   : Uint;\n       Rlo, Rhi   : Uint;\n-      Lsiz, Rsiz : Nat;\n+      Lsiz, Rsiz : Uint;\n       Nlo, Nhi   : Uint;\n-      Nsiz       : Nat;\n+      Nsiz       : Uint;\n       Ntyp       : Entity_Id;\n       Nop        : Node_Id;\n       OK         : Boolean;\n@@ -14022,7 +14021,7 @@ package body Exp_Ch4 is\n       if Binary then\n          Lsiz := Get_Size_For_Range (Llo, Lhi);\n       else\n-         Lsiz := 0;\n+         Lsiz := Uint_0;\n       end if;\n \n       Rsiz := Get_Size_For_Range (Rlo, Rhi);\n@@ -14032,7 +14031,7 @@ package body Exp_Ch4 is\n       if Compar then\n          --  The type must be able to accommodate the operands\n \n-         Nsiz := Nat'Max (Lsiz, Rsiz);\n+         Nsiz := UI_Max (Lsiz, Rsiz);\n \n       else\n          --  The type must be able to accommodate the operand(s) and result.\n@@ -14050,15 +14049,15 @@ package body Exp_Ch4 is\n          --  here, we cannot be sure that the operation does not overflow.\n \n          Nsiz := Get_Size_For_Range (Nlo, Nhi);\n-         Nsiz := Nat'Max (Nsiz, Lsiz);\n-         Nsiz := Nat'Max (Nsiz, Rsiz);\n+         Nsiz := UI_Max (Nsiz, Lsiz);\n+         Nsiz := UI_Max (Nsiz, Rsiz);\n       end if;\n \n       --  If the size is not lower than the size of the original type, then\n       --  there is no point in changing the type, except in the case where\n       --  we can remove a conversion to the original type from an operand.\n \n-      if Nsiz >= RM_Size (Typ)\n+      if Nsiz >= Tsiz\n         and then not (Binary\n                        and then Nkind (L) = N_Type_Conversion\n                        and then Entity (Subtype_Mark (L)) = Typ)\n@@ -14072,10 +14071,10 @@ package body Exp_Ch4 is\n       --  type instead of the first subtype because operations are done in\n       --  the base type, so this avoids the need for useless conversions.\n \n-      if Nsiz <= RM_Size (Standard_Integer) then\n+      if Nsiz <= Standard_Integer_Size then\n          Ntyp := Etype (Standard_Integer);\n \n-      elsif Nsiz <= RM_Size (Standard_Long_Long_Integer) then\n+      elsif Nsiz <= Standard_Long_Long_Integer_Size then\n          Ntyp := Etype (Standard_Long_Long_Integer);\n \n       else\n@@ -14112,7 +14111,7 @@ package body Exp_Ch4 is\n          --  Analyze it with the narrower type and checks suppressed, but only\n          --  when we are sure that the operation does not overflow, see above.\n \n-         if Nsiz < RM_Size (Typ) then\n+         if Nsiz < Tsiz then\n             Analyze_And_Resolve (N, Ntyp, Suppress => Overflow_Check);\n          else\n             Analyze_And_Resolve (N, Ntyp);"}]}