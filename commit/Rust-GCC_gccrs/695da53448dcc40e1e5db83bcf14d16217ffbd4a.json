{"sha": "695da53448dcc40e1e5db83bcf14d16217ffbd4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk1ZGE1MzQ0OGRjYzQwZTFlNWRiODNiY2YxNGQxNjIxN2ZmYmQ0YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:57:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:57:25Z"}, "message": "Give the target more control over ARRAY_TYPE modes\n\nSo far we've used integer modes for LD[234] and ST[234] arrays.\nThat doesn't scale well to SVE, since the sizes aren't fixed at\ncompile time (and even if they were, we wouldn't want integers\nto be so wide).\n\nThis patch lets the target use double-, triple- and quadruple-length\nvectors instead.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (array_mode): New target hook.\n\t* doc/tm.texi.in (TARGET_ARRAY_MODE): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* hooks.h (hook_optmode_mode_uhwi_none): Declare.\n\t* hooks.c (hook_optmode_mode_uhwi_none): New function.\n\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Use\n\ttargetm.array_mode.\n\t* stor-layout.c (mode_for_array): Likewise.  Support polynomial\n\ttype sizes.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256617", "tree": {"sha": "653ae8366d4a3351466cfc904a7623b71b73a233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/653ae8366d4a3351466cfc904a7623b71b73a233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/695da53448dcc40e1e5db83bcf14d16217ffbd4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695da53448dcc40e1e5db83bcf14d16217ffbd4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695da53448dcc40e1e5db83bcf14d16217ffbd4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695da53448dcc40e1e5db83bcf14d16217ffbd4a/comments", "author": null, "committer": null, "parents": [{"sha": "779fed5fdb6098e67213a82dfd27f5b326a75e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779fed5fdb6098e67213a82dfd27f5b326a75e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779fed5fdb6098e67213a82dfd27f5b326a75e88"}], "stats": {"total": 99, "additions": 81, "deletions": 18}, "files": [{"sha": "ed20d31774b1f28ec02172efbd54ce7c9e21ef98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -1,3 +1,17 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (array_mode): New target hook.\n+\t* doc/tm.texi.in (TARGET_ARRAY_MODE): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* hooks.h (hook_optmode_mode_uhwi_none): Declare.\n+\t* hooks.c (hook_optmode_mode_uhwi_none): New function.\n+\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Use\n+\ttargetm.array_mode.\n+\t* stor-layout.c (mode_for_array): Likewise.  Support polynomial\n+\ttype sizes.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "25b0a1b21230058ed2d41a1dce1308f439a8ece4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -4250,6 +4250,20 @@ insns involving vector mode @var{mode}.  At the very least, it\n must have move patterns for this mode.\n @end deftypefn\n \n+@deftypefn {Target Hook} opt_machine_mode TARGET_ARRAY_MODE (machine_mode @var{mode}, unsigned HOST_WIDE_INT @var{nelems})\n+Return the mode that GCC should use for an array that has\n+@var{nelems} elements, with each element having mode @var{mode}.\n+Return no mode if the target has no special requirements.  In the\n+latter case, GCC looks for an integer mode of the appropriate size\n+if available and uses BLKmode otherwise.  Usually the search for the\n+integer mode is limited to @code{MAX_FIXED_MODE_SIZE}, but the\n+@code{TARGET_ARRAY_MODE_SUPPORTED_P} hook allows a larger mode to be\n+used in specific cases.\n+\n+The main use of this hook is to specify that an array of vectors should\n+also have a vector mode.  The default implementation returns no mode.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_ARRAY_MODE_SUPPORTED_P (machine_mode @var{mode}, unsigned HOST_WIDE_INT @var{nelems})\n Return true if GCC should try to use a scalar mode to store an array\n of @var{nelems} elements, given that each element has mode @var{mode}."}, {"sha": "b0ac8b2fd8fbebf2c20b5ee4f052f0638000ce46", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -3329,6 +3329,8 @@ stack.\n \n @hook TARGET_VECTOR_MODE_SUPPORTED_P\n \n+@hook TARGET_ARRAY_MODE\n+\n @hook TARGET_ARRAY_MODE_SUPPORTED_P\n \n @hook TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P"}, {"sha": "61719606a36db15a91215f14e35ca0585fffab42", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -525,3 +525,11 @@ hook_bool_mode_reg_class_t_reg_class_t_false (machine_mode, reg_class_t,\n   return false;\n }\n \n+/* Generic hook that takes a mode and an unsigned HOST_WIDE_INT and\n+   returns no mode.  */\n+\n+opt_machine_mode\n+hook_optmode_mode_uhwi_none (machine_mode, unsigned HOST_WIDE_INT)\n+{\n+  return opt_machine_mode ();\n+}"}, {"sha": "8caedd429a6964bdf23b7fc0f939a430c4031a1c", "filename": "gcc/hooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -124,4 +124,7 @@ extern const char *hook_constcharptr_const_rtx_insn_null (const rtx_insn *);\n extern const char *hook_constcharptr_const_tree_const_tree_null (const_tree, const_tree);\n extern const char *hook_constcharptr_int_const_tree_null (int, const_tree);\n extern const char *hook_constcharptr_int_const_tree_const_tree_null (int, const_tree, const_tree);\n+\n+extern opt_machine_mode hook_optmode_mode_uhwi_none (machine_mode,\n+\t\t\t\t\t\t     unsigned HOST_WIDE_INT);\n #endif"}, {"sha": "0f65e166411dab479291b0ad4ab431516d0271a1", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -546,7 +546,8 @@ static machine_mode\n mode_for_array (tree elem_type, tree size)\n {\n   tree elem_size;\n-  unsigned HOST_WIDE_INT int_size, int_elem_size;\n+  poly_uint64 int_size, int_elem_size;\n+  unsigned HOST_WIDE_INT num_elems;\n   bool limit_p;\n \n   /* One-element arrays get the component type's mode.  */\n@@ -555,14 +556,16 @@ mode_for_array (tree elem_type, tree size)\n     return TYPE_MODE (elem_type);\n \n   limit_p = true;\n-  if (tree_fits_uhwi_p (size) && tree_fits_uhwi_p (elem_size))\n+  if (poly_int_tree_p (size, &int_size)\n+      && poly_int_tree_p (elem_size, &int_elem_size)\n+      && maybe_ne (int_elem_size, 0U)\n+      && constant_multiple_p (int_size, int_elem_size, &num_elems))\n     {\n-      int_size = tree_to_uhwi (size);\n-      int_elem_size = tree_to_uhwi (elem_size);\n-      if (int_elem_size > 0\n-\t  && int_size % int_elem_size == 0\n-\t  && targetm.array_mode_supported_p (TYPE_MODE (elem_type),\n-\t\t\t\t\t     int_size / int_elem_size))\n+      machine_mode elem_mode = TYPE_MODE (elem_type);\n+      machine_mode mode;\n+      if (targetm.array_mode (elem_mode, num_elems).exists (&mode))\n+\treturn mode;\n+      if (targetm.array_mode_supported_p (elem_mode, num_elems))\n \tlimit_p = false;\n     }\n   return mode_for_size_tree (size, MODE_INT, limit_p).else_blk ();"}, {"sha": "783ac99980910047c90a70d715a2283cd2be4ef3", "filename": "gcc/target.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -3426,6 +3426,22 @@ the vector element type.\",\n  HOST_WIDE_INT, (const_tree type),\n  default_vector_alignment)\n \n+DEFHOOK\n+(array_mode,\n+ \"Return the mode that GCC should use for an array that has\\n\\\n+@var{nelems} elements, with each element having mode @var{mode}.\\n\\\n+Return no mode if the target has no special requirements.  In the\\n\\\n+latter case, GCC looks for an integer mode of the appropriate size\\n\\\n+if available and uses BLKmode otherwise.  Usually the search for the\\n\\\n+integer mode is limited to @code{MAX_FIXED_MODE_SIZE}, but the\\n\\\n+@code{TARGET_ARRAY_MODE_SUPPORTED_P} hook allows a larger mode to be\\n\\\n+used in specific cases.\\n\\\n+\\n\\\n+The main use of this hook is to specify that an array of vectors should\\n\\\n+also have a vector mode.  The default implementation returns no mode.\",\n+ opt_machine_mode, (machine_mode mode, unsigned HOST_WIDE_INT nelems),\n+ hook_optmode_mode_uhwi_none)\n+\n /* True if we should try to use a scalar mode to represent an array,\n    overriding the usual MAX_FIXED_MODE limit.  */\n DEFHOOK"}, {"sha": "759c1e30edffaad705392d744ac0a926f0f95aa4", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/695da53448dcc40e1e5db83bcf14d16217ffbd4a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=695da53448dcc40e1e5db83bcf14d16217ffbd4a", "patch": "@@ -61,20 +61,23 @@ static bool\n vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n \t\t\t      tree vectype, unsigned HOST_WIDE_INT count)\n {\n-  machine_mode mode;\n-  scalar_int_mode array_mode;\n+  machine_mode mode, array_mode;\n   bool limit_p;\n \n   mode = TYPE_MODE (vectype);\n-  limit_p = !targetm.array_mode_supported_p (mode, count);\n-  if (!int_mode_for_size (count * GET_MODE_BITSIZE (mode),\n-\t\t\t  limit_p).exists (&array_mode))\n+  if (!targetm.array_mode (mode, count).exists (&array_mode))\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\\n\",\n-                         GET_MODE_NAME (mode), count);\n-      return false;\n+      poly_uint64 bits = count * GET_MODE_BITSIZE (mode);\n+      limit_p = !targetm.array_mode_supported_p (mode, count);\n+      if (!int_mode_for_size (bits, limit_p).exists (&array_mode))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"no array mode for %s[\"\n+\t\t\t     HOST_WIDE_INT_PRINT_DEC \"]\\n\",\n+\t\t\t     GET_MODE_NAME (mode), count);\n+\t  return false;\n+\t}\n     }\n \n   if (convert_optab_handler (optab, array_mode, mode) == CODE_FOR_nothing)"}]}