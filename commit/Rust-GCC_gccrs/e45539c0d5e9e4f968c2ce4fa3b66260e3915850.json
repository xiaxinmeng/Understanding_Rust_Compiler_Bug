{"sha": "e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ1NTM5YzBkNWU5ZTRmOTY4YzJjZTRmYTNiNjYyNjBlMzkxNTg1MA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-03T17:13:54Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-03T17:13:54Z"}, "message": "pa.md (parallel_addb, [...]): New patterns.\n\n        * pa.md (parallel_addb, parallel_movb): New patterns.\n        (fmpyadd, fmpysub): New patterns.\n\nFrom-SVN: r12384", "tree": {"sha": "805d41eb972104a46f9560544c3ca6dfb7a2222f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/805d41eb972104a46f9560544c3ca6dfb7a2222f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45539c0d5e9e4f968c2ce4fa3b66260e3915850/comments", "author": null, "committer": null, "parents": [{"sha": "d85ab9665cf1e89fcb2e6e89580edeb45b74e8cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d85ab9665cf1e89fcb2e6e89580edeb45b74e8cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d85ab9665cf1e89fcb2e6e89580edeb45b74e8cd"}], "stats": {"total": 138, "additions": 138, "deletions": 0}, "files": [{"sha": "58d72d3fc65f5b4c717afa2c237dd6ce995193da", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45539c0d5e9e4f968c2ce4fa3b66260e3915850/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45539c0d5e9e4f968c2ce4fa3b66260e3915850/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "patch": "@@ -4965,6 +4965,144 @@\n \t  (const_int 8)\n \t  (const_int 12)))))])\n \n+;; The next several patterns (parallel_addb, parallel_movb, fmpyadd and\n+;; fmpysub aren't currently used by the FSF sources, but will be soon.\n+;;\n+;; They're in the FSF tree for documentation and to make Cygnus<->FSF\n+;; merging easier.\n+(define_insn \"\"\n+  [(set (pc) (label_ref (match_operand 3 \"\" \"\" )))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"ireg_or_int5_operand\" \"rL\")))]\n+  \"reload_completed && operands[0] == operands[1] || operands[0] == operands[2]\"\n+  \"*\n+{\n+  return output_parallel_addb (operands, get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\" \"parallel_branch\")\n+   (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 3) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n+   (set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(match_operand:SF 1 \"ireg_or_int5_operand\" \"rL\"))]\n+  \"reload_completed\"\n+  \"*\n+{\n+  return output_parallel_movb (operands, get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\" \"parallel_branch\")\n+   (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"ireg_or_int5_operand\" \"rL\"))]\n+  \"reload_completed\"\n+  \"*\n+{\n+  return output_parallel_movb (operands, get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\" \"parallel_branch\")\n+   (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n+   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"ireg_or_int5_operand\" \"rL\"))]\n+  \"reload_completed\"\n+  \"*\n+{\n+  return output_parallel_movb (operands, get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\" \"parallel_branch\")\n+   (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+(define_insn \"\"\n+  [(set (pc) (label_ref (match_operand 2 \"\" \"\" )))\n+   (set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"ireg_or_int5_operand\" \"rL\"))]\n+  \"reload_completed\"\n+  \"*\n+{\n+  return output_parallel_movb (operands, get_attr_length (insn));\n+}\"\n+  [(set_attr \"type\" \"parallel_branch\")\n+   (set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 2) (plus (pc) (const_int 8))))\n+\t\t      (const_int 8184))\n+           (const_int 4)\n+\t   (const_int 8)))])\n+\n+;; These insns will replace fmpyadd and fmpysub peepholes when the\n+;; independent insn combination code is installed at the FSF.  Until\n+;; then these patterns aren't used by the FSF compiler and are only\n+;; here for documentation purposes.\n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=f\")\n+\t(mult (match_operand 1 \"register_operand\" \"f\")\n+\t      (match_operand 2 \"register_operand\" \"f\")))\n+   (set (match_operand 3 \"register_operand\" \"+f\")\n+\t(plus (match_operand 4 \"register_operand\" \"f\")\n+\t      (match_operand 5 \"register_operand\" \"f\")))]\n+  \"TARGET_SNAKE && ! TARGET_SOFT_FLOAT\n+   && reload_completed && fmpyaddoperands (operands)\"\n+  \"*\n+{\n+  if (GET_MODE (operands[0]) == DFmode)\n+    {\n+      if (rtx_equal_p (operands[3], operands[5]))\n+\treturn \\\"fmpyadd,dbl %1,%2,%0,%4,%3\\\";\n+      else\n+\treturn \\\"fmpyadd,dbl %1,%2,%0,%5,%3\\\";\n+    }\n+  else\n+    {\n+      if (rtx_equal_p (operands[3], operands[5]))\n+\treturn \\\"fmpyadd,sgl %1,%2,%0,%4,%3\\\";\n+      else\n+\treturn \\\"fmpyadd,sgl %1,%2,%0,%5,%3\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=f\")\n+\t(mult (match_operand 1 \"register_operand\" \"f\")\n+\t      (match_operand 2 \"register_operand\" \"f\")))\n+   (set (match_operand 3 \"register_operand\" \"+f\")\n+\t(minus (match_operand 4 \"register_operand\" \"f\")\n+\t       (match_operand 5 \"register_operand\" \"f\")))]\n+  \"TARGET_SNAKE && ! TARGET_SOFT_FLOAT\n+   && reload_completed && fmpysuboperands (operands)\"\n+  \"*\n+{\n+  if (GET_MODE (operands[0]) == DFmode)\n+    return \\\"fmpysub,dbl %1,%2,%0,%5,%3\\\";\n+  else\n+    return \\\"fmpysub,sgl %1,%2,%0,%5,%3\\\";\n+}\"\n+  [(set_attr \"type\" \"fpalu\")\n+   (set_attr \"length\" \"4\")])\n+\n ;; The next four peepholes take advantage of the new 5 operand\n ;; fmpy{add,sub} instructions available on 1.1 CPUS.  Basically\n ;; fmpyadd performs a multiply and add/sub of independent operands"}]}