{"sha": "7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M3NGIwMTBkNzJhNGJiMWZiNmUyNjQ3Yzc1YTg4Yjg2NWUxMzdiMg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1998-06-18T20:17:26Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-06-18T20:17:26Z"}, "message": "Fix stack overflow found by glibc compile with max optimizations.\n\n\t* sched.c (schedule_insns): Use xmalloc not alloca for max_uid\n\tindexed arrays.  Call free at the end of the function for them.\n\t* haifa-sched.c (schedule_insns): Likewise.\n\nFrom-SVN: r20563", "tree": {"sha": "93fbc1459e6675b3c705a7f66d20d7194d504e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93fbc1459e6675b3c705a7f66d20d7194d504e4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/comments", "author": null, "committer": null, "parents": [{"sha": "243e7835fb7d2015eee565f70b17c2fdb238cdab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243e7835fb7d2015eee565f70b17c2fdb238cdab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243e7835fb7d2015eee565f70b17c2fdb238cdab"}], "stats": {"total": 95, "additions": 70, "deletions": 25}, "files": [{"sha": "9b7d7e477f69f95b6da2f40caa632b1fc17c8523", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "patch": "@@ -1,3 +1,9 @@\n+Thu Jun 18 20:11:00 1998  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* sched.c (schedule_insns): Use xmalloc not alloca for max_uid\n+\tindexed arrays.  Call free at the end of the function for them.\n+\t* haifa-sched.c (schedule_insns): Likewise.\n+\n Thu Jun 18 18:16:01 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* dwarf2out.c (size_of_string): Do count backslashes."}, {"sha": "a4c63a3ae16b65395048696d418f96309fb1d618", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "patch": "@@ -8447,17 +8447,17 @@ schedule_insns (dump_file)\n \n   max_uid = (get_max_uid () + 1);\n \n-  cant_move = (char *) alloca (max_uid * sizeof (char));\n+  cant_move = (char *) xmalloc (max_uid * sizeof (char));\n   bzero ((char *) cant_move, max_uid * sizeof (char));\n \n-  fed_by_spec_load = (char *) alloca (max_uid * sizeof (char));\n+  fed_by_spec_load = (char *) xmalloc (max_uid * sizeof (char));\n   bzero ((char *) fed_by_spec_load, max_uid * sizeof (char));\n \n-  is_load_insn = (char *) alloca (max_uid * sizeof (char));\n+  is_load_insn = (char *) xmalloc (max_uid * sizeof (char));\n   bzero ((char *) is_load_insn, max_uid * sizeof (char));\n \n-  insn_orig_block = (int *) alloca (max_uid * sizeof (int));\n-  insn_luid = (int *) alloca (max_uid * sizeof (int));\n+  insn_orig_block = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_luid = (int *) xmalloc (max_uid * sizeof (int));\n \n   luid = 0;\n   for (b = 0; b < n_basic_blocks; b++)\n@@ -8577,18 +8577,22 @@ schedule_insns (dump_file)\n     }\n \n   /* Allocate data for this pass.  See comments, above,\n-     for what these vectors do.  */\n-  insn_priority = (int *) alloca (max_uid * sizeof (int));\n-  insn_reg_weight = (int *) alloca (max_uid * sizeof (int));\n-  insn_tick = (int *) alloca (max_uid * sizeof (int));\n-  insn_costs = (short *) alloca (max_uid * sizeof (short));\n-  insn_units = (short *) alloca (max_uid * sizeof (short));\n-  insn_blockage = (unsigned int *) alloca (max_uid * sizeof (unsigned int));\n-  insn_ref_count = (int *) alloca (max_uid * sizeof (int));\n+     for what these vectors do.\n+\n+     We use xmalloc instead of alloca, because max_uid can be very large\n+     when there is a lot of function inlining.  If we used alloca, we could\n+     exceed stack limits on some hosts for some inputs.  */\n+  insn_priority = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_reg_weight = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_tick = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_costs = (short *) xmalloc (max_uid * sizeof (short));\n+  insn_units = (short *) xmalloc (max_uid * sizeof (short));\n+  insn_blockage = (unsigned int *) xmalloc (max_uid * sizeof (unsigned int));\n+  insn_ref_count = (int *) xmalloc (max_uid * sizeof (int));\n \n   /* Allocate for forward dependencies */\n-  insn_dep_count = (int *) alloca (max_uid * sizeof (int));\n-  insn_depend = (rtx *) alloca (max_uid * sizeof (rtx));\n+  insn_dep_count = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_depend = (rtx *) xmalloc (max_uid * sizeof (rtx));\n \n   if (reload_completed == 0)\n     {\n@@ -8616,7 +8620,7 @@ schedule_insns (dump_file)\n     {\n       rtx line;\n \n-      line_note = (rtx *) alloca (max_uid * sizeof (rtx));\n+      line_note = (rtx *) xmalloc (max_uid * sizeof (rtx));\n       bzero ((char *) line_note, max_uid * sizeof (rtx));\n       line_note_head = (rtx *) alloca (n_basic_blocks * sizeof (rtx));\n       bzero ((char *) line_note_head, n_basic_blocks * sizeof (rtx));\n@@ -8703,6 +8707,26 @@ schedule_insns (dump_file)\n       fprintf (dump, \"\\n\\n\");\n     }\n \n+  free (cant_move);\n+  free (fed_by_spec_load);\n+  free (is_load_insn);\n+  free (insn_orig_block);\n+  free (insn_luid);\n+\n+  free (insn_priority);\n+  free (insn_reg_weight);\n+  free (insn_tick);\n+  free (insn_costs);\n+  free (insn_units);\n+  free (insn_blockage);\n+  free (insn_ref_count);\n+\n+  free (insn_dep_count);\n+  free (insn_depend);\n+\n+  if (write_symbols != NO_DEBUG)\n+    free (line_note);\n+\n   if (bb_live_regs)\n     FREE_REG_SET (bb_live_regs);\n "}, {"sha": "5b540285676ae99ec8c988b87ea7178e669f3cd3", "filename": "gcc/sched.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c74b010d72a4bb1fb6e2647c75a88b865e137b2/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=7c74b010d72a4bb1fb6e2647c75a88b865e137b2", "patch": "@@ -4293,14 +4293,18 @@ schedule_insns (dump_file)\n      remember how far we can cut back the stack on exit.  */\n \n   /* Allocate data for this pass.  See comments, above,\n-     for what these vectors do.  */\n-  insn_luid = (int *) alloca (max_uid * sizeof (int));\n-  insn_priority = (int *) alloca (max_uid * sizeof (int));\n-  insn_tick = (int *) alloca (max_uid * sizeof (int));\n-  insn_costs = (short *) alloca (max_uid * sizeof (short));\n-  insn_units = (short *) alloca (max_uid * sizeof (short));\n-  insn_blockage = (unsigned int *) alloca (max_uid * sizeof (unsigned int));\n-  insn_ref_count = (int *) alloca (max_uid * sizeof (int));\n+     for what these vectors do.\n+\n+     We use xmalloc instead of alloca, because max_uid can be very large\n+     when there is a lot of function inlining.  If we used alloca, we could\n+     exceed stack limits on some hosts for some inputs.  */\n+  insn_luid = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_priority = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_tick = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_costs = (short *) xmalloc (max_uid * sizeof (short));\n+  insn_units = (short *) xmalloc (max_uid * sizeof (short));\n+  insn_blockage = (unsigned int *) xmalloc (max_uid * sizeof (unsigned int));\n+  insn_ref_count = (int *) xmalloc (max_uid * sizeof (int));\n \n   if (reload_completed == 0)\n     {\n@@ -4324,7 +4328,7 @@ schedule_insns (dump_file)\n     {\n       rtx line;\n \n-      line_note = (rtx *) alloca (max_uid * sizeof (rtx));\n+      line_note = (rtx *) xmalloc (max_uid * sizeof (rtx));\n       bzero ((char *) line_note, max_uid * sizeof (rtx));\n       line_note_head = (rtx *) alloca (n_basic_blocks * sizeof (rtx));\n       bzero ((char *) line_note_head, n_basic_blocks * sizeof (rtx));\n@@ -4561,6 +4565,17 @@ schedule_insns (dump_file)\n \t  }\n     }\n \n+  free (insn_luid);\n+  free (insn_priority);\n+  free (insn_tick);\n+  free (insn_costs);\n+  free (insn_units);\n+  free (insn_blockage);\n+  free (insn_ref_count);\n+\n+  if (write_symbols != NO_DEBUG)\n+    free (line_note);\n+\n   if (reload_completed == 0)\n     {\n       FREE_REG_SET (bb_dead_regs);"}]}