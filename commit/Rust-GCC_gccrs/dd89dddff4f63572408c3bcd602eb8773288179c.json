{"sha": "dd89dddff4f63572408c3bcd602eb8773288179c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ4OWRkZGZmNGY2MzU3MjQwOGMzYmNkNjAyZWI4NzczMjg4MTc5Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T09:34:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T09:34:30Z"}, "message": "[multiple changes]\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* einfo.adb (Designated_Type): Use Is_Incomplete_Type to handle\n\tproperly incomplete subtypes that may be created by explicit or\n\timplicit declarations.\n\t(Is_Base_Type): Take E_Incomplete_Subtype into account.\n\t(Subtype_Kind): Ditto.\n\t* sem_ch3.adb (Build_Discriminated_Subtype): Set properly the\n\tEkind of a subtype of a discriminated incomplete type.\n\t(Fixup_Bad_Constraint): Use Subtype_Kind in all cases, including\n\tincomplete types, to preserve error reporting.\n\t(Process_Incomplete_Dependents): Do not create a subtype\n\tdeclaration for an incomplete subtype that is created internally.\n\t* sem_ch7.adb (Analyze_Package_Specification): Handle properly\n\tincomplete subtypes that do not require a completion, either\n\tbecause they are limited views, of they are generic actuals.\n\n2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Insert_Valid_Check): Remove the\n\tsuspicious manipulation of the Do_Range_Check flag as ths is\n\tno linger needed. Suppress validity check when analysing the\n\tvalidation variable.\n\n2017-09-06  Philippe Gil  <gil@adacore.com>\n\n\t* g-debpoo.adb: adapt GNAT.Debug_Pools to allow safe thread\n\tGNATCOLL.Memory\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* sem_elim.adb: Minor comment fix.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Is_Object_Reference): A function call is an\n\tobject reference, and thus attribute references for attributes\n\tthat are functions (such as Pred and Succ) as well as predefined\n\toperators are legal in contexts that require an object, such as\n\tthe prefix of attribute Img and the Ada2020 version of 'Image.\n\nFrom-SVN: r251759", "tree": {"sha": "081c331a23be4c245d4cc36c7f97c0f64be94ee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/081c331a23be4c245d4cc36c7f97c0f64be94ee7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd89dddff4f63572408c3bcd602eb8773288179c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd89dddff4f63572408c3bcd602eb8773288179c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd89dddff4f63572408c3bcd602eb8773288179c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd89dddff4f63572408c3bcd602eb8773288179c/comments", "author": null, "committer": null, "parents": [{"sha": "3e720c9601e26585c386c983084fdc2926902936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e720c9601e26585c386c983084fdc2926902936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e720c9601e26585c386c983084fdc2926902936"}], "stats": {"total": 609, "additions": 384, "deletions": 225}, "files": [{"sha": "af389109ff7b610a7c19adaa48778e0bb499e108", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -1,3 +1,44 @@\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* einfo.adb (Designated_Type): Use Is_Incomplete_Type to handle\n+\tproperly incomplete subtypes that may be created by explicit or\n+\timplicit declarations.\n+\t(Is_Base_Type): Take E_Incomplete_Subtype into account.\n+\t(Subtype_Kind): Ditto.\n+\t* sem_ch3.adb (Build_Discriminated_Subtype): Set properly the\n+\tEkind of a subtype of a discriminated incomplete type.\n+\t(Fixup_Bad_Constraint): Use Subtype_Kind in all cases, including\n+\tincomplete types, to preserve error reporting.\n+\t(Process_Incomplete_Dependents): Do not create a subtype\n+\tdeclaration for an incomplete subtype that is created internally.\n+\t* sem_ch7.adb (Analyze_Package_Specification): Handle properly\n+\tincomplete subtypes that do not require a completion, either\n+\tbecause they are limited views, of they are generic actuals.\n+\n+2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Insert_Valid_Check): Remove the\n+\tsuspicious manipulation of the Do_Range_Check flag as ths is\n+\tno linger needed. Suppress validity check when analysing the\n+\tvalidation variable.\n+\n+2017-09-06  Philippe Gil  <gil@adacore.com>\n+\n+\t* g-debpoo.adb: adapt GNAT.Debug_Pools to allow safe thread\n+\tGNATCOLL.Memory\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elim.adb: Minor comment fix.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Is_Object_Reference): A function call is an\n+\tobject reference, and thus attribute references for attributes\n+\tthat are functions (such as Pred and Succ) as well as predefined\n+\toperators are legal in contexts that require an object, such as\n+\tthe prefix of attribute Img and the Ada2020 version of 'Image.\n+\n 2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb, einfo.adb, sem_attr.adb, exp_ch4.adb, gnatls.adb,"}, {"sha": "5751885132258dfdda6722a440cf7000b768aaa8", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -7333,21 +7333,12 @@ package body Checks is\n          return;\n       end if;\n \n-      --  We are about to insert the validity check for Exp. We save and\n-      --  reset the Do_Range_Check flag over this validity check, and then\n-      --  put it back for the final original reference (Exp may be rewritten).\n-\n       declare\n-         DRC : constant Boolean := Do_Range_Check (Exp);\n-\n          CE     : Node_Id;\n-         Obj    : Node_Id;\n          PV     : Node_Id;\n          Var_Id : Entity_Id;\n \n       begin\n-         Set_Do_Range_Check (Exp, False);\n-\n          --  If the expression denotes an assignable object, capture its value\n          --  in a variable and replace the original expression by the variable.\n          --  This approach has several effects:\n@@ -7386,15 +7377,16 @@ package body Checks is\n          --         Object := Var;         --  update Object\n \n          if Is_Variable (Exp) then\n-            Obj    := New_Copy_Tree (Exp);\n             Var_Id := Make_Temporary (Loc, 'T', Exp);\n \n             Insert_Action (Exp,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Var_Id,\n                 Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-                Expression          => Relocate_Node (Exp)));\n-            Set_Validated_Object (Var_Id, Obj);\n+                Expression          => New_Copy_Tree (Exp)),\n+              Suppress => Validity_Check);\n+\n+            Set_Validated_Object (Var_Id, New_Copy_Tree (Exp));\n \n             Rewrite (Exp, New_Occurrence_Of (Var_Id, Loc));\n             PV := New_Occurrence_Of (Var_Id, Loc);\n@@ -7474,20 +7466,6 @@ package body Checks is\n                end if;\n             end;\n          end if;\n-\n-         --  Put back the Do_Range_Check flag on the resulting (possibly\n-         --  rewritten) expression.\n-\n-         --  Note: it might be thought that a validity check is not required\n-         --  when a range check is present, but that's not the case, because\n-         --  the back end is allowed to assume for the range check that the\n-         --  operand is within its declared range (an assumption that validity\n-         --  checking is all about NOT assuming).\n-\n-         --  Note: no need to worry about Possible_Local_Raise here, it will\n-         --  already have been called if original node has Do_Range_Check set.\n-\n-         Set_Do_Range_Check (Exp, DRC);\n       end;\n    end Insert_Valid_Check;\n "}, {"sha": "f89e9704caf2bc055cd885be1d1e1ac672314ded", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -7151,13 +7151,13 @@ package body Einfo is\n    begin\n       Desig_Type := Directly_Designated_Type (Id);\n \n-      if Ekind (Desig_Type) = E_Incomplete_Type\n+      if Is_Incomplete_Type (Desig_Type)\n         and then Present (Full_View (Desig_Type))\n       then\n          return Full_View (Desig_Type);\n \n       elsif Is_Class_Wide_Type (Desig_Type)\n-        and then Ekind (Etype (Desig_Type)) = E_Incomplete_Type\n+        and then Is_Incomplete_Type (Etype (Desig_Type))\n         and then Present (Full_View (Etype (Desig_Type)))\n         and then Present (Class_Wide_Type (Full_View (Etype (Desig_Type))))\n       then\n@@ -7364,11 +7364,11 @@ package body Einfo is\n \n    function Get_Full_View (T : Entity_Id) return Entity_Id is\n    begin\n-      if Ekind (T) = E_Incomplete_Type and then Present (Full_View (T)) then\n+      if Is_Incomplete_Type (T) and then Present (Full_View (T)) then\n          return Full_View (T);\n \n       elsif Is_Class_Wide_Type (T)\n-        and then Ekind (Root_Type (T)) = E_Incomplete_Type\n+        and then Is_Incomplete_Type (Root_Type (T))\n         and then Present (Full_View (Root_Type (T)))\n       then\n          return Class_Wide_Type (Full_View (Root_Type (T)));\n@@ -7800,7 +7800,7 @@ package body Einfo is\n \n    Entity_Is_Base_Type : constant array (Entity_Kind) of Boolean :=\n      (E_Enumeration_Subtype          |\n-      E_Incomplete_Type              |\n+      E_Incomplete_Subtype           |\n       E_Signed_Integer_Subtype       |\n       E_Modular_Integer_Subtype      |\n       E_Floating_Point_Subtype       |\n@@ -9174,6 +9174,9 @@ package body Einfo is\n          when Enumeration_Kind =>\n             Kind := E_Enumeration_Subtype;\n \n+         when E_Incomplete_Type =>\n+            Kind := E_Incomplete_Subtype;\n+\n          when Float_Kind =>\n             Kind := E_Floating_Point_Subtype;\n "}, {"sha": "42acdbdbed748c358863d536137864631d80ffd1", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 305, "deletions": 174, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -41,6 +41,7 @@ with GNAT.Debug_Utilities; use GNAT.Debug_Utilities;\n with GNAT.HTable;\n with GNAT.Traceback; use GNAT.Traceback;\n \n+with Ada.Finalization;\n with Ada.Unchecked_Conversion;\n \n package body GNAT.Debug_Pools is\n@@ -386,6 +387,36 @@ package body GNAT.Debug_Pools is\n    function PC_For (TB_Entry : STBE.Traceback_Entry) return System.Address\n      renames STBE.PC_For;\n \n+   type Scope_Lock is\n+     new Ada.Finalization.Limited_Controlled with null record;\n+   --  to handle Lock_Task/Unlock_Task calls\n+\n+   overriding procedure Initialize (This : in out Scope_Lock);\n+   --  lock task on initialization\n+\n+   overriding procedure Finalize   (This : in out Scope_Lock);\n+   --  unlock task on finalization\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (This : in out Scope_Lock) is\n+      pragma Unreferenced (This);\n+   begin\n+      Lock_Task.all;\n+   end Initialize;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (This : in out Scope_Lock) is\n+      pragma Unreferenced (This);\n+   begin\n+      Unlock_Task.all;\n+   end Finalize;\n+\n    -----------\n    -- Align --\n    -----------\n@@ -906,14 +937,15 @@ package body GNAT.Debug_Pools is\n \n       Reset_Disable_At_Exit : Boolean := False;\n \n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n+\n    begin\n       <<Allocate_Label>>\n-      Lock_Task.all;\n \n       if Disable then\n          Storage_Address :=\n            System.CRTL.malloc (System.CRTL.size_t (Size_In_Storage_Elements));\n-         Unlock_Task.all;\n          return;\n       end if;\n \n@@ -1055,14 +1087,11 @@ package body GNAT.Debug_Pools is\n \n       Disable := False;\n \n-      Unlock_Task.all;\n-\n    exception\n       when others =>\n          if Reset_Disable_At_Exit then\n             Disable := False;\n          end if;\n-         Unlock_Task.all;\n          raise;\n    end Allocate;\n \n@@ -1345,10 +1374,12 @@ package body GNAT.Debug_Pools is\n          end loop;\n       end Reset_Marks;\n \n-   --  Start of processing for Free_Physically\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n+\n+      --  Start of processing for Free_Physically\n \n    begin\n-      Lock_Task.all;\n \n       if Pool.Advanced_Scanning then\n \n@@ -1371,12 +1402,6 @@ package body GNAT.Debug_Pools is\n          Free_Blocks (Ignore_Marks => True);\n       end if;\n \n-      Unlock_Task.all;\n-\n-   exception\n-      when others =>\n-         Unlock_Task.all;\n-         raise;\n    end Free_Physically;\n \n    --------------\n@@ -1387,8 +1412,11 @@ package body GNAT.Debug_Pools is\n      (Storage_Address          : Address;\n       Size_In_Storage_Elements : out Storage_Count;\n       Valid                    : out Boolean) is\n+\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n+\n    begin\n-      Lock_Task.all;\n \n       Valid := Is_Valid (Storage_Address);\n \n@@ -1408,13 +1436,6 @@ package body GNAT.Debug_Pools is\n          Valid := False;\n       end if;\n \n-      Unlock_Task.all;\n-\n-   exception\n-      when others =>\n-         Unlock_Task.all;\n-         raise;\n-\n    end Get_Size;\n \n    ---------------------\n@@ -1444,21 +1465,136 @@ package body GNAT.Debug_Pools is\n    is\n       pragma Unreferenced (Alignment);\n \n-      Unlock_Task_Required : Boolean := False;\n       Header   : constant Allocation_Header_Access :=\n         Header_Of (Storage_Address);\n       Valid    : Boolean;\n       Previous : System.Address;\n+      Header_Block_Size_Was_Less_Than_0 : Boolean := True;\n \n    begin\n       <<Deallocate_Label>>\n-      Lock_Task.all;\n-      Unlock_Task_Required := True;\n-      Valid := Is_Valid (Storage_Address);\n+\n+      declare\n+         Lock : Scope_Lock;\n+         pragma Unreferenced (Lock);\n+      begin\n+         Valid := Is_Valid (Storage_Address);\n+\n+         if Valid and then not (Header.Block_Size < 0) then\n+            Header_Block_Size_Was_Less_Than_0 := False;\n+\n+            --  Some sort of codegen problem or heap corruption caused the\n+            --  Size_In_Storage_Elements to be wrongly computed.\n+            --  The code below is all based on the assumption that Header.all\n+            --  is not corrupted, such that the error is non-fatal.\n+\n+            if Header.Block_Size /= Size_In_Storage_Elements and then\n+              Size_In_Storage_Elements /= Storage_Count'Last\n+            then\n+               Put_Line (Output_File (Pool),\n+                         \"error: Deallocate size \"\n+                         & Storage_Count'Image (Size_In_Storage_Elements)\n+                         & \" does not match allocate size \"\n+                         & Storage_Count'Image (Header.Block_Size));\n+            end if;\n+\n+            if Pool.Low_Level_Traces then\n+               Put (Output_File (Pool),\n+                    \"info: Deallocated\"\n+                    & Storage_Count'Image (Header.Block_Size)\n+                    & \" bytes at \");\n+               Print_Address (Output_File (Pool), Storage_Address);\n+               Put (Output_File (Pool),\n+                    \" (physically\"\n+                    & Storage_Count'Image\n+                      (Header.Block_Size + Extra_Allocation)\n+                    & \" bytes at \");\n+               Print_Address (Output_File (Pool), Header.Allocation_Address);\n+               Put (Output_File (Pool), \"), at \");\n+\n+               Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n+                         Deallocate_Label'Address,\n+                         Code_Address_For_Deallocate_End);\n+               Print_Traceback (Output_File (Pool),\n+                                \"   Memory was allocated at \",\n+                                Header.Alloc_Traceback);\n+            end if;\n+\n+            --  Remove this block from the list of used blocks\n+\n+            Previous :=\n+              To_Address (Header.Dealloc_Traceback);\n+\n+            if Previous = System.Null_Address then\n+               Pool.First_Used_Block := Header_Of (Pool.First_Used_Block).Next;\n+\n+               if Pool.First_Used_Block /= System.Null_Address then\n+                  Header_Of (Pool.First_Used_Block).Dealloc_Traceback :=\n+                    To_Traceback (null);\n+               end if;\n+\n+            else\n+               Header_Of (Previous).Next := Header.Next;\n+\n+               if Header.Next /= System.Null_Address then\n+                  Header_Of\n+                    (Header.Next).Dealloc_Traceback := To_Address (Previous);\n+               end if;\n+            end if;\n+\n+            --  Update the Alloc_Traceback Frees/Total_Frees members\n+            --  (if present)\n+\n+            if Header.Alloc_Traceback /= null then\n+               Header.Alloc_Traceback.Frees :=\n+                 Header.Alloc_Traceback.Frees + 1;\n+               Header.Alloc_Traceback.Total_Frees :=\n+                 Header.Alloc_Traceback.Total_Frees +\n+                   Byte_Count (Header.Block_Size);\n+            end if;\n+\n+            Pool.Free_Count := Pool.Free_Count + 1;\n+\n+            --  Update the header\n+\n+            Header.all :=\n+              (Allocation_Address => Header.Allocation_Address,\n+               Alloc_Traceback    => Header.Alloc_Traceback,\n+               Dealloc_Traceback  => To_Traceback\n+                 (Find_Or_Create_Traceback\n+                      (Pool, Dealloc,\n+                       Header.Block_Size,\n+                       Deallocate_Label'Address,\n+                       Code_Address_For_Deallocate_End)),\n+               Next               => System.Null_Address,\n+               Block_Size         => -Header.Block_Size);\n+\n+            if Pool.Reset_Content_On_Free then\n+               Set_Dead_Beef (Storage_Address, -Header.Block_Size);\n+            end if;\n+\n+            Pool.Logically_Deallocated :=\n+              Pool.Logically_Deallocated + Byte_Count (-Header.Block_Size);\n+\n+            --  Link this free block with the others (at the end of the list,\n+            --  so that we can start releasing the older blocks first later on)\n+\n+            if Pool.First_Free_Block = System.Null_Address then\n+               Pool.First_Free_Block := Storage_Address;\n+               Pool.Last_Free_Block := Storage_Address;\n+\n+            else\n+               Header_Of (Pool.Last_Free_Block).Next := Storage_Address;\n+               Pool.Last_Free_Block := Storage_Address;\n+            end if;\n+\n+            --  Do not physically release the memory here, but in Alloc.\n+            --  See comment there for details.\n+         end if;\n+\n+      end;\n \n       if not Valid then\n-         Unlock_Task_Required := False;\n-         Unlock_Task.all;\n \n          if Storage_Address = System.Null_Address then\n             if Pool.Raise_Exceptions and then\n@@ -1493,9 +1629,8 @@ package body GNAT.Debug_Pools is\n                       Code_Address_For_Deallocate_End);\n          end if;\n \n-      elsif Header.Block_Size < 0 then\n-         Unlock_Task_Required := False;\n-         Unlock_Task.all;\n+      elsif Header_Block_Size_Was_Less_Than_0 then\n+\n          if Pool.Raise_Exceptions then\n             raise Freeing_Deallocated_Storage;\n          else\n@@ -1511,121 +1646,8 @@ package body GNAT.Debug_Pools is\n                              Header.Alloc_Traceback);\n          end if;\n \n-      else\n-         --  Some sort of codegen problem or heap corruption caused the\n-         --  Size_In_Storage_Elements to be wrongly computed.\n-         --  The code below is all based on the assumption that Header.all\n-         --  is not corrupted, such that the error is non-fatal.\n-\n-         if Header.Block_Size /= Size_In_Storage_Elements and then\n-           Size_In_Storage_Elements /= Storage_Count'Last\n-         then\n-            Put_Line (Output_File (Pool),\n-                      \"error: Deallocate size \"\n-                        & Storage_Count'Image (Size_In_Storage_Elements)\n-                        & \" does not match allocate size \"\n-                        & Storage_Count'Image (Header.Block_Size));\n-         end if;\n-\n-         if Pool.Low_Level_Traces then\n-            Put (Output_File (Pool),\n-                 \"info: Deallocated\"\n-                 & Storage_Count'Image (Header.Block_Size)\n-                 & \" bytes at \");\n-            Print_Address (Output_File (Pool), Storage_Address);\n-            Put (Output_File (Pool),\n-                 \" (physically\"\n-                 & Storage_Count'Image (Header.Block_Size + Extra_Allocation)\n-                 & \" bytes at \");\n-            Print_Address (Output_File (Pool), Header.Allocation_Address);\n-            Put (Output_File (Pool), \"), at \");\n-\n-            Put_Line (Output_File (Pool), Pool.Stack_Trace_Depth, null,\n-                      Deallocate_Label'Address,\n-                      Code_Address_For_Deallocate_End);\n-            Print_Traceback (Output_File (Pool), \"   Memory was allocated at \",\n-                             Header.Alloc_Traceback);\n-         end if;\n-\n-         --  Remove this block from the list of used blocks\n-\n-         Previous :=\n-           To_Address (Header.Dealloc_Traceback);\n-\n-         if Previous = System.Null_Address then\n-            Pool.First_Used_Block := Header_Of (Pool.First_Used_Block).Next;\n-\n-            if Pool.First_Used_Block /= System.Null_Address then\n-               Header_Of (Pool.First_Used_Block).Dealloc_Traceback :=\n-                 To_Traceback (null);\n-            end if;\n-\n-         else\n-            Header_Of (Previous).Next := Header.Next;\n-\n-            if Header.Next /= System.Null_Address then\n-               Header_Of\n-                 (Header.Next).Dealloc_Traceback := To_Address (Previous);\n-            end if;\n-         end if;\n-\n-         --  Update the Alloc_Traceback Frees/Total_Frees members (if present)\n-\n-         if Header.Alloc_Traceback /= null then\n-            Header.Alloc_Traceback.Frees := Header.Alloc_Traceback.Frees + 1;\n-            Header.Alloc_Traceback.Total_Frees :=\n-              Header.Alloc_Traceback.Total_Frees +\n-                Byte_Count (Header.Block_Size);\n-         end if;\n-\n-         Pool.Free_Count := Pool.Free_Count + 1;\n-\n-         --  Update the header\n-\n-         Header.all :=\n-           (Allocation_Address => Header.Allocation_Address,\n-            Alloc_Traceback    => Header.Alloc_Traceback,\n-            Dealloc_Traceback  => To_Traceback\n-                                    (Find_Or_Create_Traceback\n-                                       (Pool, Dealloc,\n-                                        Header.Block_Size,\n-                                        Deallocate_Label'Address,\n-                                        Code_Address_For_Deallocate_End)),\n-            Next               => System.Null_Address,\n-            Block_Size         => -Header.Block_Size);\n-\n-         if Pool.Reset_Content_On_Free then\n-            Set_Dead_Beef (Storage_Address, -Header.Block_Size);\n-         end if;\n-\n-         Pool.Logically_Deallocated :=\n-           Pool.Logically_Deallocated + Byte_Count (-Header.Block_Size);\n-\n-         --  Link this free block with the others (at the end of the list, so\n-         --  that we can start releasing the older blocks first later on).\n-\n-         if Pool.First_Free_Block = System.Null_Address then\n-            Pool.First_Free_Block := Storage_Address;\n-            Pool.Last_Free_Block := Storage_Address;\n-\n-         else\n-            Header_Of (Pool.Last_Free_Block).Next := Storage_Address;\n-            Pool.Last_Free_Block := Storage_Address;\n-         end if;\n-\n-         --  Do not physically release the memory here, but in Alloc.\n-         --  See comment there for details.\n-\n-         Unlock_Task_Required := False;\n-         Unlock_Task.all;\n       end if;\n \n-   exception\n-      when others =>\n-         if Unlock_Task_Required then\n-            Unlock_Task.all;\n-         end if;\n-         raise;\n    end Deallocate;\n \n    --------------------\n@@ -1904,9 +1926,6 @@ package body GNAT.Debug_Pools is\n       Size   : Positive;\n       Report : Report_Type := All_Reports) is\n \n-      Total_Freed : constant Byte_Count :=\n-        Pool.Logically_Deallocated + Pool.Physically_Deallocated;\n-\n       procedure Do_Report (Sort : Report_Type);\n       --  Do a specific type of report\n \n@@ -1919,6 +1938,15 @@ package body GNAT.Debug_Pools is\n            (others => null);\n          --  Sorted array for the biggest memory users\n \n+         Allocated_In_Pool : Byte_Count;\n+         --  safe thread Pool.Allocated\n+\n+         Elem_Safe : Traceback_Htable_Elem;\n+         --  safe thread current elem.all;\n+\n+         Max_M_Safe : Traceback_Htable_Elem;\n+         --  safe thread Max(M).all\n+\n       begin\n          Put_Line (\"\");\n \n@@ -1940,52 +1968,83 @@ package body GNAT.Debug_Pools is\n                Put_Line (\"Results include total bytes and chunks allocated,\");\n                Put_Line (\"even if no longer allocated - Deallocations are\"\n                          & \" ignored\");\n-               Grand_Total := Float (Pool.Allocated);\n+\n+               declare\n+                  Lock : Scope_Lock;\n+                  pragma Unreferenced (Lock);\n+               begin\n+                  Allocated_In_Pool := Pool.Allocated;\n+               end;\n+\n+               Grand_Total := Float (Allocated_In_Pool);\n \n             when Marked_Blocks =>\n                Put_Line (\"Special blocks marked by Mark_Traceback\");\n                Grand_Total := 0.0;\n          end case;\n \n-         Elem := Backtrace_Htable.Get_First;\n+         declare\n+            Lock : Scope_Lock;\n+            pragma Unreferenced (Lock);\n+         begin\n+            Elem := Backtrace_Htable.Get_First;\n+         end;\n+\n          while Elem /= null loop\n+\n+            declare\n+               Lock : Scope_Lock;\n+               pragma Unreferenced (Lock);\n+            begin\n+               Elem_Safe := Elem.all;\n+            end;\n+\n             --  Handle only alloc elememts\n-            if Elem.Kind = Alloc then\n+            if Elem_Safe.Kind = Alloc then\n                --  Ignore small blocks (depending on the sorting criteria) to\n                --  gain speed.\n \n                if (Sort = Memory_Usage\n-                   and then Elem.Total - Elem.Total_Frees >= 1_000)\n+                   and then Elem_Safe.Total - Elem_Safe.Total_Frees >= 1_000)\n                  or else (Sort = Allocations_Count\n-                          and then Elem.Count - Elem.Frees >= 1)\n-                 or else (Sort = Sort_Total_Allocs and then Elem.Count > 1)\n+                          and then Elem_Safe.Count - Elem_Safe.Frees >= 1)\n+                 or else (Sort = Sort_Total_Allocs\n+                          and then Elem_Safe.Count > 1)\n                  or else (Sort = Marked_Blocks\n-                          and then Elem.Total = 0)\n+                          and then Elem_Safe.Total = 0)\n                then\n                   if Sort = Marked_Blocks then\n-                     Grand_Total := Grand_Total + Float (Elem.Count);\n+                     Grand_Total := Grand_Total + Float (Elem_Safe.Count);\n                   end if;\n \n                   for M in Max'Range loop\n                      Bigger := Max (M) = null;\n                      if not Bigger then\n+\n+                        declare\n+                           Lock : Scope_Lock;\n+                           pragma Unreferenced (Lock);\n+                        begin\n+                           Max_M_Safe := Max (M).all;\n+                        end;\n+\n                         case Sort is\n                            when All_Reports\n                               | Memory_Usage\n                            =>\n                               Bigger :=\n-                                Max (M).Total - Max (M).Total_Frees\n-                                  < Elem.Total - Elem.Total_Frees;\n+                                Max_M_Safe.Total - Max_M_Safe.Total_Frees\n+                                  < Elem_Safe.Total - Elem_Safe.Total_Frees;\n \n                            when Allocations_Count =>\n                               Bigger :=\n-                                Max (M).Count - Max (M).Frees\n-                                  < Elem.Count - Elem.Frees;\n+                                Max_M_Safe.Count - Max_M_Safe.Frees\n+                                  < Elem_Safe.Count - Elem_Safe.Frees;\n \n                            when Marked_Blocks\n                               | Sort_Total_Allocs\n                            =>\n-                              Bigger := Max (M).Count < Elem.Count;\n+                              Bigger := Max_M_Safe.Count < Elem_Safe.Count;\n                         end case;\n                      end if;\n \n@@ -1998,7 +2057,13 @@ package body GNAT.Debug_Pools is\n                end if;\n             end if;\n \n-            Elem := Backtrace_Htable.Get_Next;\n+            declare\n+               Lock : Scope_Lock;\n+               pragma Unreferenced (Lock);\n+            begin\n+               Elem := Backtrace_Htable.Get_Next;\n+            end;\n+\n          end loop;\n \n          if Grand_Total = 0.0 then\n@@ -2012,37 +2077,56 @@ package body GNAT.Debug_Pools is\n                Total : Byte_Count;\n                P : Percent;\n             begin\n+\n+               declare\n+                  Lock : Scope_Lock;\n+                  pragma Unreferenced (Lock);\n+               begin\n+                  Max_M_Safe := Max (M).all;\n+               end;\n+\n                case Sort is\n                   when All_Reports\n                      | Allocations_Count\n                      | Memory_Usage\n                   =>\n-                     Total := Max (M).Total - Max (M).Total_Frees;\n+                     Total := Max_M_Safe.Total - Max_M_Safe.Total_Frees;\n \n                   when Sort_Total_Allocs =>\n-                     Total := Max (M).Total;\n+                     Total := Max_M_Safe.Total;\n \n                   when Marked_Blocks =>\n-                     Total := Byte_Count (Max (M).Count);\n+                     Total := Byte_Count (Max_M_Safe.Count);\n                end case;\n \n-               P := Percent (100.0 * Float (Total) / Grand_Total);\n+               declare\n+                  Normalized_Total : constant Float := Float (Total);\n+                  --  In multi tasking configuration, memory deallocations\n+                  --  during Do_Report processing can lead to Total >\n+                  --  Grand_Total. As Percent requires Total <= Grand_Total\n+               begin\n+                  if Normalized_Total > Grand_Total then\n+                     P := 100.0;\n+                  else\n+                     P := Percent (100.0 * Normalized_Total / Grand_Total);\n+                  end if;\n+               end;\n \n                case Sort is\n                   when Memory_Usage | Allocations_Count | All_Reports =>\n                      declare\n                         Count : constant Natural :=\n-                          Max (M).Count - Max (M).Frees;\n+                          Max_M_Safe.Count - Max_M_Safe.Frees;\n                      begin\n                         Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n                              & Count'Img & \" chunks at\");\n                      end;\n                   when Sort_Total_Allocs =>\n                      Put (P'Img & \"%:\" & Total'Img & \" bytes in\"\n-                          & Max (M).Count'Img & \" chunks at\");\n+                          & Max_M_Safe.Count'Img & \" chunks at\");\n                   when Marked_Blocks =>\n                      Put (P'Img & \"%:\"\n-                          & Max (M).Count'Img & \" chunks /\"\n+                          & Max_M_Safe.Count'Img & \" chunks /\"\n                           & Integer (Grand_Total)'Img & \" at\");\n                end case;\n             end;\n@@ -2055,20 +2139,57 @@ package body GNAT.Debug_Pools is\n          end loop;\n       end Do_Report;\n \n+      --  Local variables\n+\n+      Total_Freed : Byte_Count;\n+      --  safe thread pool logically & physically deallocated\n+\n+      Traceback_Elements_Allocated : Byte_Count;\n+      --  safe thread Traceback_Count\n+\n+      Validity_Elements_Allocated : Byte_Count;\n+      --  safe thread Validity_Count\n+\n+      Ada_Allocs_Bytes : Byte_Count;\n+      --  safe thread pool Allocated\n+\n+      Ada_Allocs_Chunks : Byte_Count;\n+      --  safe thread pool Alloc_Count\n+\n+      Ada_Free_Chunks : Byte_Count;\n+      --  safe thread pool Free_Count\n+\n+   --  Start of processing for Dump\n+\n    begin\n-      Put_Line (\"Traceback elements allocated: \" & Traceback_Count'Img);\n-      Put_Line (\"Validity elements allocated: \" & Validity_Count'Img);\n+      declare\n+         Lock : Scope_Lock;\n+         pragma Unreferenced (Lock);\n+      begin\n+         Total_Freed :=\n+           Pool.Logically_Deallocated + Pool.Physically_Deallocated;\n+         Traceback_Elements_Allocated := Traceback_Count;\n+         Validity_Elements_Allocated := Validity_Count;\n+         Ada_Allocs_Bytes := Pool.Allocated;\n+         Ada_Allocs_Chunks := Pool.Alloc_Count;\n+         Ada_Free_Chunks := Pool.Free_Count;\n+      end;\n+\n+      Put_Line\n+        (\"Traceback elements allocated: \" & Traceback_Elements_Allocated'Img);\n+      Put_Line\n+        (\"Validity elements allocated: \" & Validity_Elements_Allocated'Img);\n       Put_Line (\"\");\n \n-      Put_Line (\"Ada Allocs:\" & Pool.Allocated'Img\n-                & \" bytes in\" & Pool.Alloc_Count'Img & \" chunks\");\n+      Put_Line (\"Ada Allocs:\" & Ada_Allocs_Bytes'Img\n+                & \" bytes in\" & Ada_Allocs_Chunks'Img & \" chunks\");\n       Put_Line (\"Ada Free:\" & Total_Freed'Img & \" bytes in\" &\n-                  Pool.Free_Count'Img\n+                  Ada_Free_Chunks'Img\n                 & \" chunks\");\n       Put_Line (\"Ada Current watermark: \"\n                 & Byte_Count'Image (Pool.Current_Water_Mark)\n-                & \" in\" & Byte_Count'Image (Pool.Alloc_Count -\n-                    Pool.Free_Count) & \" chunks\");\n+                & \" in\" & Byte_Count'Image (Ada_Allocs_Chunks -\n+                    Ada_Free_Chunks) & \" chunks\");\n       Put_Line (\"Ada High watermark: \" & Pool.High_Water_Mark'Img);\n \n       case Report is\n@@ -2109,6 +2230,8 @@ package body GNAT.Debug_Pools is\n \n    procedure Reset is\n       Elem : Traceback_Htable_Elem_Ptr;\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n    begin\n       Elem := Backtrace_Htable.Get_First;\n       while Elem /= null loop\n@@ -2136,6 +2259,8 @@ package body GNAT.Debug_Pools is\n \n    function High_Water_Mark\n      (Pool : Debug_Pool) return Byte_Count is\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n    begin\n       return Pool.High_Water;\n    end High_Water_Mark;\n@@ -2146,6 +2271,8 @@ package body GNAT.Debug_Pools is\n \n    function Current_Water_Mark\n      (Pool : Debug_Pool) return Byte_Count is\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n    begin\n       return Pool.Allocated - Pool.Logically_Deallocated -\n         Pool.Physically_Deallocated;\n@@ -2157,6 +2284,8 @@ package body GNAT.Debug_Pools is\n \n    procedure System_Memory_Debug_Pool\n      (Has_Unhandled_Memory : Boolean := True) is\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n    begin\n       System_Memory_Debug_Pool_Enabled := True;\n       Allow_Unhandled_Memory := Has_Unhandled_Memory;\n@@ -2177,6 +2306,8 @@ package body GNAT.Debug_Pools is\n       Errors_To_Stdout               : Boolean := Default_Errors_To_Stdout;\n       Low_Level_Traces               : Boolean := Default_Low_Level_Traces)\n    is\n+      Lock : Scope_Lock;\n+      pragma Unreferenced (Lock);\n    begin\n       Pool.Stack_Trace_Depth              := Stack_Trace_Depth;\n       Pool.Maximum_Logically_Freed_Memory := Maximum_Logically_Freed_Memory;"}, {"sha": "6fbcea27ce23d5fcd0b8d2413329ade7c7940a27", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -10094,7 +10094,11 @@ package body Sem_Ch3 is\n          --  elaboration, because only the access type is needed in the\n          --  initialization procedure.\n \n-         Set_Ekind (Def_Id, Ekind (T));\n+         if Ekind (T) = E_Incomplete_Type then\n+            Set_Ekind (Def_Id, E_Incomplete_Subtype);\n+         else\n+            Set_Ekind (Def_Id, Ekind (T));\n+         end if;\n \n          if For_Access and then Within_Init_Proc then\n             null;\n@@ -13629,15 +13633,9 @@ package body Sem_Ch3 is\n \n       procedure Fixup_Bad_Constraint is\n       begin\n-         --  Set a reasonable Ekind for the entity. For an incomplete type,\n-         --  we can't do much, but for other types, we can set the proper\n-         --  corresponding subtype kind.\n+         --  Set a reasonable Ekind for the entity, including incomplete types.\n \n-         if Ekind (T) = E_Incomplete_Type then\n-            Set_Ekind (Def_Id, Ekind (T));\n-         else\n-            Set_Ekind (Def_Id, Subtype_Kind (Ekind (T)));\n-         end if;\n+         Set_Ekind (Def_Id, Subtype_Kind (Ekind (T)));\n \n          --  Set Etype to the known type, to reduce chances of cascaded errors\n \n@@ -20802,7 +20800,9 @@ package body Sem_Ch3 is\n          --  Ada 2005 (AI-412): Transform a regular incomplete subtype into a\n          --  corresponding subtype of the full view.\n \n-         elsif Ekind (Priv_Dep) = E_Incomplete_Subtype then\n+         elsif Ekind (Priv_Dep) = E_Incomplete_Subtype\n+            and then Comes_From_Source (Priv_Dep)\n+         then\n             Set_Subtype_Indication\n               (Parent (Priv_Dep), New_Occurrence_Of (Full_T, Sloc (Priv_Dep)));\n             Set_Etype (Priv_Dep, Full_T);"}, {"sha": "d5e0f4b9f26c1826d5d26df56e95f358f15a815b", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -1441,11 +1441,14 @@ package body Sem_Ch7 is\n \n          --  Check on incomplete types\n \n-         --  AI05-0213: A formal incomplete type has no completion\n+         --  AI05-0213: A formal incomplete type has no completion,\n+         --  and neither does the corresponding subtype in an instance.\n \n-         if Ekind (E) = E_Incomplete_Type\n+         if Is_Incomplete_Type (E)\n            and then No (Full_View (E))\n            and then not Is_Generic_Type (E)\n+           and then not From_Limited_With (E)\n+           and then not Is_Generic_Actual_Type (E)\n          then\n             Error_Msg_N (\"no declaration in visible part for incomplete}\", E);\n          end if;"}, {"sha": "cc0f43c9dd7302dee224fb6f4bcab501cdb4b400", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -194,7 +194,7 @@ package body Sem_Elim is\n    -- Tables --\n    ------------\n \n-   --  The following table records the data for each pragmas, using the\n+   --  The following table records the data for each pragma, using the\n    --  entity name as the hash key for retrieval. Entries in this table\n    --  are set by Process_Eliminate_Pragma and read by Check_Eliminated.\n "}, {"sha": "d9babcd8b3b6ec4cb771ffc61b3a205435dfa092", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd89dddff4f63572408c3bcd602eb8773288179c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=dd89dddff4f63572408c3bcd602eb8773288179c", "patch": "@@ -14153,18 +14153,21 @@ package body Sem_Util is\n             --  In Ada 95, a function call is a constant object; a procedure\n             --  call is not.\n \n-            when N_Function_Call =>\n+            --  Note that predefined operators are functions as well, and so\n+            --  are attributes that are (can be renamed as) functions.\n+\n+            when N_Function_Call | N_Binary_Op | N_Unary_Op =>\n                return Etype (N) /= Standard_Void_Type;\n \n-            --  Attributes 'Input, 'Loop_Entry, 'Old, and 'Result produce\n-            --  objects.\n+            --  Attributes references 'Loop_Entry, 'Old, and 'Result yield\n+            --  objects, even though they are not functions.\n \n             when N_Attribute_Reference =>\n                return\n-                 Nam_In (Attribute_Name (N), Name_Input,\n-                                             Name_Loop_Entry,\n+                 Nam_In (Attribute_Name (N), Name_Loop_Entry,\n                                              Name_Old,\n-                                             Name_Result);\n+                                             Name_Result)\n+                  or else Is_Function_Attribute_Name (Attribute_Name (N));\n \n             when N_Selected_Component =>\n                return"}]}