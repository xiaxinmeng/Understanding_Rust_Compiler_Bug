{"sha": "c7bfed18df8a3f85eb8acd15f860c3e828cd61d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiZmVkMThkZjhhM2Y4NWViOGFjZDE1Zjg2MGMzZTgyOGNkNjFkMA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-23T15:19:55Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-23T15:19:55Z"}, "message": "re PR d/90079 (SEGV in _aaKeys, _aaValues on 32-bit SPARC)\n\n\tPR d/90079\nlibphobos: Fix SEGV in _aaKeys, _aaValues on 32-bit SPARC\n\nMerges upstream druntime b43203a1\n\nReviewed-on: https://github.com/dlang/druntime/pull/2572\n\nFrom-SVN: r270514", "tree": {"sha": "530bfe75c261e022cf4646b630e721ab464f31d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/530bfe75c261e022cf4646b630e721ab464f31d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0/comments", "author": null, "committer": null, "parents": [{"sha": "d86bc962aef6df2bba3026bea6954e32456cc780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86bc962aef6df2bba3026bea6954e32456cc780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d86bc962aef6df2bba3026bea6954e32456cc780"}], "stats": {"total": 126, "additions": 95, "deletions": 31}, "files": [{"sha": "27dfc5fc1d9d14f14bfcdd528c74c1cbd792e925", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=c7bfed18df8a3f85eb8acd15f860c3e828cd61d0", "patch": "@@ -1,4 +1,4 @@\n-109f0f2e11aaaddd2b158117928e10c3c4688870\n+b43203a134fb5e259ffc1711cc061c6e869b56f6\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "d7588dccbedf1ae4e871de02db0ec34cc3ef41c7", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 94, "deletions": 30, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7bfed18df8a3f85eb8acd15f860c3e828cd61d0/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=c7bfed18df8a3f85eb8acd15f860c3e828cd61d0", "patch": "@@ -661,12 +661,12 @@ class TypeInfo_AssociativeArray : TypeInfo\n \n     override bool equals(in void* p1, in void* p2) @trusted const\n     {\n-        return !!_aaEqual(this, *cast(const void**) p1, *cast(const void**) p2);\n+        return !!_aaEqual(this, *cast(const AA*) p1, *cast(const AA*) p2);\n     }\n \n     override hash_t getHash(scope const void* p) nothrow @trusted const\n     {\n-        return _aaGetHash(cast(void*)p, this);\n+        return _aaGetHash(cast(AA*)p, this);\n     }\n \n     // BUG: need to add the rest of the functions\n@@ -1862,30 +1862,31 @@ extern (C)\n {\n     // from druntime/src/rt/aaA.d\n \n-    // size_t _aaLen(in void* p) pure nothrow @nogc;\n-    private void* _aaGetY(void** paa, const TypeInfo_AssociativeArray ti, in size_t valuesize, in void* pkey) pure nothrow;\n-    private void* _aaGetX(void** paa, const TypeInfo_AssociativeArray ti, in size_t valuesize, in void* pkey, out bool found) pure nothrow;\n-    // inout(void)* _aaGetRvalueX(inout void* p, in TypeInfo keyti, in size_t valuesize, in void* pkey);\n-    inout(void)[] _aaValues(inout void* p, in size_t keysize, in size_t valuesize, const TypeInfo tiValArray) pure nothrow;\n-    inout(void)[] _aaKeys(inout void* p, in size_t keysize, const TypeInfo tiKeyArray) pure nothrow;\n-    void* _aaRehash(void** pp, in TypeInfo keyti) pure nothrow;\n-    void _aaClear(void* p) pure nothrow;\n+    private struct AA { void* impl; }\n+    // size_t _aaLen(in AA aa) pure nothrow @nogc;\n+    private void* _aaGetY(AA* paa, const TypeInfo_AssociativeArray ti, in size_t valsz, in void* pkey) pure nothrow;\n+    private void* _aaGetX(AA* paa, const TypeInfo_AssociativeArray ti, in size_t valsz, in void* pkey, out bool found) pure nothrow;\n+    // inout(void)* _aaGetRvalueX(inout AA aa, in TypeInfo keyti, in size_t valsz, in void* pkey);\n+    inout(void[]) _aaValues(inout AA aa, in size_t keysz, in size_t valsz, const TypeInfo tiValueArray) pure nothrow;\n+    inout(void[]) _aaKeys(inout AA aa, in size_t keysz, const TypeInfo tiKeyArray) pure nothrow;\n+    void* _aaRehash(AA* paa, in TypeInfo keyti) pure nothrow;\n+    void _aaClear(AA aa) pure nothrow;\n \n     // alias _dg_t = extern(D) int delegate(void*);\n-    // int _aaApply(void* aa, size_t keysize, _dg_t dg);\n+    // int _aaApply(AA aa, size_t keysize, _dg_t dg);\n \n     // alias _dg2_t = extern(D) int delegate(void*, void*);\n-    // int _aaApply2(void* aa, size_t keysize, _dg2_t dg);\n+    // int _aaApply2(AA aa, size_t keysize, _dg2_t dg);\n \n-    private struct AARange { void* impl; size_t idx; }\n-    AARange _aaRange(void* aa) pure nothrow @nogc @safe;\n+    private struct AARange { AA impl; size_t idx; }\n+    AARange _aaRange(AA aa) pure nothrow @nogc @safe;\n     bool _aaRangeEmpty(AARange r) pure nothrow @nogc @safe;\n     void* _aaRangeFrontKey(AARange r) pure nothrow @nogc @safe;\n     void* _aaRangeFrontValue(AARange r) pure nothrow @nogc @safe;\n     void _aaRangePopFront(ref AARange r) pure nothrow @nogc @safe;\n \n-    int _aaEqual(in TypeInfo tiRaw, in void* e1, in void* e2);\n-    hash_t _aaGetHash(in void* aa, in TypeInfo tiRaw) nothrow;\n+    int _aaEqual(in TypeInfo tiRaw, in AA aa1, in AA aa2);\n+    hash_t _aaGetHash(in AA* aa, in TypeInfo tiRaw) nothrow;\n \n     /*\n         _d_assocarrayliteralTX marked as pure, because aaLiteral can be called from pure code.\n@@ -1910,13 +1911,13 @@ alias AssociativeArray(Key, Value) = Value[Key];\n  */\n void clear(T : Value[Key], Value, Key)(T aa)\n {\n-    _aaClear(*cast(void **) &aa);\n+    _aaClear(*cast(AA *) &aa);\n }\n \n /* ditto */\n void clear(T : Value[Key], Value, Key)(T* aa)\n {\n-    _aaClear(*cast(void **) aa);\n+    _aaClear(*cast(AA *) aa);\n }\n \n /***********************************\n@@ -1929,28 +1930,28 @@ void clear(T : Value[Key], Value, Key)(T* aa)\n  */\n T rehash(T : Value[Key], Value, Key)(T aa)\n {\n-    _aaRehash(cast(void**)&aa, typeid(Value[Key]));\n+    _aaRehash(cast(AA*)&aa, typeid(Value[Key]));\n     return aa;\n }\n \n /* ditto */\n T rehash(T : Value[Key], Value, Key)(T* aa)\n {\n-    _aaRehash(cast(void**)aa, typeid(Value[Key]));\n+    _aaRehash(cast(AA*)aa, typeid(Value[Key]));\n     return *aa;\n }\n \n /* ditto */\n T rehash(T : shared Value[Key], Value, Key)(T aa)\n {\n-    _aaRehash(cast(void**)&aa, typeid(Value[Key]));\n+    _aaRehash(cast(AA*)&aa, typeid(Value[Key]));\n     return aa;\n }\n \n /* ditto */\n T rehash(T : shared Value[Key], Value, Key)(T* aa)\n {\n-    _aaRehash(cast(void**)aa, typeid(Value[Key]));\n+    _aaRehash(cast(AA*)aa, typeid(Value[Key]));\n     return *aa;\n }\n \n@@ -1977,7 +1978,7 @@ V[K] dup(T : V[K], K, V)(T aa)\n     {\n         import core.stdc.string : memcpy;\n \n-        void* pv = _aaGetY(cast(void**)&result, typeid(V[K]), V.sizeof, &k);\n+        void* pv = _aaGetY(cast(AA*)&result, typeid(V[K]), V.sizeof, &k);\n         memcpy(pv, &v, V.sizeof);\n         return *cast(V*)pv;\n     }\n@@ -2010,7 +2011,7 @@ private AARange _aaToRange(T: V[K], K, V)(ref T aa) pure nothrow @nogc @safe\n         alias realAA = aa;\n     else\n         const(V[K]) realAA = aa;\n-    return _aaRange(() @trusted { return cast(void*)realAA; } ());\n+    return _aaRange(() @trusted { return *cast(AA*)&realAA; } ());\n }\n \n /***********************************\n@@ -2146,7 +2147,12 @@ auto byKeyValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n  */\n Key[] keys(T : Value[Key], Value, Key)(T aa) @property\n {\n-    auto a = cast(void[])_aaKeys(cast(inout(void)*)aa, Key.sizeof, typeid(Key[]));\n+    // ensure we are dealing with a genuine AA.\n+    static if (is(const(Value[Key]) == const(T)))\n+        alias realAA = aa;\n+    else\n+        const(Value[Key]) realAA = aa;\n+    auto a = cast(void[])_aaKeys(*cast(inout(AA)*)&realAA, Key.sizeof, typeid(Key[]));\n     auto res = *cast(Key[]*)&a;\n     _doPostblit(res);\n     return res;\n@@ -2158,6 +2164,19 @@ Key[] keys(T : Value[Key], Value, Key)(T *aa) @property\n     return (*aa).keys;\n }\n \n+@system unittest\n+{\n+    static struct S\n+    {\n+        string str;\n+        void[][string] dict;\n+        alias dict this;\n+    }\n+\n+    auto s = S(\"a\");\n+    assert(s.keys.length == 0);\n+}\n+\n /***********************************\n  * Returns a dynamic array, the elements of which are the values in the\n  * associative array.\n@@ -2168,7 +2187,12 @@ Key[] keys(T : Value[Key], Value, Key)(T *aa) @property\n  */\n Value[] values(T : Value[Key], Value, Key)(T aa) @property\n {\n-    auto a = cast(void[])_aaValues(cast(inout(void)*)aa, Key.sizeof, Value.sizeof, typeid(Value[]));\n+    // ensure we are dealing with a genuine AA.\n+    static if (is(const(Value[Key]) == const(T)))\n+        alias realAA = aa;\n+    else\n+        const(Value[Key]) realAA = aa;\n+    auto a = cast(void[])_aaValues(*cast(inout(AA)*)&realAA, Key.sizeof, Value.sizeof, typeid(Value[]));\n     auto res = *cast(Value[]*)&a;\n     _doPostblit(res);\n     return res;\n@@ -2180,6 +2204,19 @@ Value[] values(T : Value[Key], Value, Key)(T *aa) @property\n     return (*aa).values;\n }\n \n+@system unittest\n+{\n+    static struct S\n+    {\n+        string str;\n+        void[][string] dict;\n+        alias dict this;\n+    }\n+\n+    auto s = S(\"a\");\n+    assert(s.values.length == 0);\n+}\n+\n /***********************************\n  * Looks up key; if it exists returns corresponding value else evaluates and\n  * returns defaultValue.\n@@ -2220,12 +2257,12 @@ ref V require(K, V)(ref V[K] aa, K key, lazy V value = V.init)\n     {\n         auto p = () @trusted\n         {\n-            return cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n+            return cast(V*) _aaGetX(cast(AA*) &aa, typeid(V[K]), V.sizeof, &key, found);\n         } ();\n     }\n     else\n     {\n-        auto p = cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n+        auto p = cast(V*) _aaGetX(cast(AA*) &aa, typeid(V[K]), V.sizeof, &key, found);\n     }\n     return found ? *p : (*p = value);\n }\n@@ -2276,12 +2313,12 @@ if (isCreateOperation!(C, V) && isUpdateOperation!(U, V))\n     {\n         auto p = () @trusted\n         {\n-            return cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n+            return cast(V*) _aaGetX(cast(AA*) &aa, typeid(V[K]), V.sizeof, &key, found);\n         } ();\n     }\n     else\n     {\n-        auto p = cast(V*) _aaGetX(cast(void**) &aa, typeid(V[K]), V.sizeof, &key, found);\n+        auto p = cast(V*) _aaGetX(cast(AA*) &aa, typeid(V[K]), V.sizeof, &key, found);\n     }\n     if (!found)\n         *p = create();\n@@ -3879,3 +3916,30 @@ unittest\n     scope arr = [S(&p)];\n     auto a = arr.dup; // dup does escape\n }\n+\n+// compiler frontend lowers dynamic array comparison to this\n+bool __ArrayEq(T1, T2)(T1[] a, T2[] b)\n+{\n+    if (a.length != b.length)\n+        return false;\n+    foreach (size_t i; 0 .. a.length)\n+    {\n+        if (a[i] != b[i])\n+            return false;\n+    }\n+    return true;\n+}\n+\n+// compiler frontend lowers struct array postblitting to this\n+void __ArrayPostblit(T)(T[] a)\n+{\n+    foreach (ref T e; a)\n+        e.__xpostblit();\n+}\n+\n+// compiler frontend lowers dynamic array deconstruction to this\n+void __ArrayDtor(T)(T[] a)\n+{\n+    foreach_reverse (ref T e; a)\n+        e.__xdtor();\n+}"}]}