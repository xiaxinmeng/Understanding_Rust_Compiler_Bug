{"sha": "1e49b79aef9b30e35c1af20d7f2979f419b57c00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0OWI3OWFlZjliMzBlMzVjMWFmMjBkN2YyOTc5ZjQxOWI1N2MwMA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-01-17T11:30:35Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-01-17T11:30:35Z"}, "message": "[arm] Convert gcc.target/arm/stl-cond.c into an RTL test\n\nThis is an awkward testsuite failure. The original bug was that we were failing to put out\nthe conditional code in the conditional form of the STL instruction (oops!).\nSo we wanted to output STLNE, but instead output STL.\nThe testacase relies on if-conversion to conditionalise the insn for STL.\nHowever, ever since r251643 the expansion of a non-relaxed atomic store\nalways includes a compiler barrier. That blocks if-conversion in all cases.\n\nSo there's no easy way to get to a conditional STL instruction from a C program.\nBut we do want to test for the original bug fix that if the RTL insn for STL is conditionalised\nit should output the conditional code.\n\nThe solution in this patch is to convert the test into an RTL test with the COND_EXEC form\nof the STL insn and scan the assembly output there.\nThis seems to work fine, and gives us an opportunity to create a gcc.dg/rtl/arm directory\nin the RTL tests.\n\nThis now makes the gcc.target/arm/stl-cond.c disappear (as the test is deleted) and\nthe new test in gcc.dg/rtl/arm/stl-cond.c passes.\n\n     * gcc.dg/rtl/arm/stl-cond.c: New test.\n     * gcc.target/arm/stl-cond.c: Delete.\n\nFrom-SVN: r256785", "tree": {"sha": "014051113eb71e16341ddf38087965e72767dacf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/014051113eb71e16341ddf38087965e72767dacf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e49b79aef9b30e35c1af20d7f2979f419b57c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e49b79aef9b30e35c1af20d7f2979f419b57c00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e49b79aef9b30e35c1af20d7f2979f419b57c00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e49b79aef9b30e35c1af20d7f2979f419b57c00/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d83fae9d62cf039af090b078abb4af36e4c71193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83fae9d62cf039af090b078abb4af36e4c71193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83fae9d62cf039af090b078abb4af36e4c71193"}], "stats": {"total": 85, "additions": 66, "deletions": 19}, "files": [{"sha": "be4bece36636075392dd47daca1a9afa5d015631", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e49b79aef9b30e35c1af20d7f2979f419b57c00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e49b79aef9b30e35c1af20d7f2979f419b57c00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e49b79aef9b30e35c1af20d7f2979f419b57c00", "patch": "@@ -1,3 +1,8 @@\n+2018-01-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gcc.dg/rtl/arm/stl-cond.c: New test.\n+\t* gcc.target/arm/stl-cond.c: Delete.\n+\n 2018-01-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/pr40887.c: Add armv5te effective target checks and"}, {"sha": "e2bc610e1faf4012d06764d78d7853d2237c7b01", "filename": "gcc/testsuite/gcc.dg/rtl/arm/stl-cond.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e49b79aef9b30e35c1af20d7f2979f419b57c00/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Farm%2Fstl-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e49b79aef9b30e35c1af20d7f2979f419b57c00/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Farm%2Fstl-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Farm%2Fstl-cond.c?ref=1e49b79aef9b30e35c1af20d7f2979f419b57c00", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile { target arm-*-* } } */\n+/* { dg-require-effective-target arm_arm_ok } */\n+/* { dg-require-effective-target arm_arch_v8a_ok } */\n+/* { dg-options \"-O2 -marm\" } */\n+/* { dg-add-options arm_arch_v8a } */\n+\n+/* We want to test that the STL instruction gets the conditional\n+   suffix when under a COND_EXEC.  However, COND_EXEC is very hard to\n+   generate from C code because the atomic_store expansion adds a compiler\n+   barrier before the insn, preventing if-conversion.  So test the output\n+   here with a hand-crafted COND_EXEC wrapped around an STL.  */\n+\n+void __RTL (startwith (\"final\")) foo (int *a, int b)\n+{\n+(function \"foo\"\n+  (param \"a\"\n+    (DECL_RTL (reg/v:SI r0))\n+    (DECL_RTL_INCOMING (reg:SI r0))\n+  )\n+  (param \"b\"\n+    (DECL_RTL (reg/v:SI r1))\n+    (DECL_RTL_INCOMING (reg:SI r1))\n+  )\n+  (insn-chain\n+    (block 2\n+\t(edge-from entry (flags \"FALLTHRU\"))\n+\t(cnote 5 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+\n+  (insn:TI 7 (parallel [\n+\t(set (reg:CC cc)\n+\t     (compare:CC (reg:SI r1)\n+\t\t\t (const_int 0)))\n+\t(set (reg/v:SI r1)\n+\t     (reg:SI r1 ))\n+        ])  ;; {*movsi_compare0}\n+     (nil))\n+\n+  ;; A conditional atomic store-release: STLNE for Armv8-A.\n+  (insn 10 (cond_exec (ne (reg:CC cc)\n+\t   (const_int 0))\n+\t(set (mem/v:SI (reg/v/f:SI r0) [-1  S4 A32])\n+\t\t(unspec_volatile:SI [\n+\t\t(reg/v:SI r1)\n+\t\t(const_int 3)\n+\t\t] VUNSPEC_STL))) ;; {*p atomic_storesi}\n+\t(expr_list:REG_DEAD (reg:CC cc)\n+\t(expr_list:REG_DEAD (reg/v:SI r1)\n+\t(expr_list:REG_DEAD (reg/v/f:SI r0)\n+\t\t(nil)))))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function\n+}\n+\n+/* { dg-final { scan-assembler \"stlne\" } } */"}, {"sha": "de14bb580b82eaf8ca0a3e6e11f842c4baf5c756", "filename": "gcc/testsuite/gcc.target/arm/stl-cond.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d83fae9d62cf039af090b078abb4af36e4c71193/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstl-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d83fae9d62cf039af090b078abb4af36e4c71193/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstl-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstl-cond.c?ref=d83fae9d62cf039af090b078abb4af36e4c71193", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-require-effective-target arm_arm_ok } */ \n-/* { dg-require-effective-target arm_arch_v8a_ok } */\n-/* { dg-options \"-O2 -marm\" } */\n-/* { dg-add-options arm_arch_v8a } */\n-\n-struct backtrace_state\n-{\n-  int threaded;\n-  int lock_alloc;\n-};\n-\n-void foo (struct backtrace_state *state)\n-{\n-  if (state->threaded)\n-    __sync_lock_release (&state->lock_alloc);\n-}\n-\n-/* { dg-final { scan-assembler \"stlne\" } } */"}]}