{"sha": "0982edd371d5429d24615442e96e76ba6bc4faa9", "node_id": "C_kwDOANBUbNoAKDA5ODJlZGQzNzFkNTQyOWQyNDYxNTQ0MmU5NmU3NmJhNmJjNGZhYTk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:39:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:39:51Z"}, "message": "Implement __builtin_issignaling\n\nThe following patch implements a new builtin, __builtin_issignaling,\nwhich can be used to implement the ISO/IEC TS 18661-1  issignaling\nmacro.\n\nIt is implemented as type-generic function, so there is just one\nbuiltin, not many with various suffixes.\nThis patch doesn't address PR56831 nor PR58416, but I think compared to\nusing glibc issignaling macro could make some cases better (as\nthe builtin is expanded always inline and for SFmode/DFmode just\nreinterprets a memory or pseudo register as SImode/DImode, so could\navoid some raising of exception + turning sNaN into qNaN before the\nbuiltin can analyze it).\n\nFor floading point modes that do not have NaNs it will return 0,\notherwise I've tried to implement this for all the other supported\nreal formats.\nIt handles both the MIPS/PA floats where a sNaN has the mantissa\nMSB set and the rest where a sNaN has it cleared, with the exception\nof format which are known never to be in the MIPS/PA form.\nThe MIPS/PA floats are handled using a test like\n(x & mask) == mask,\nthe other usually as\n((x ^ bit) & mask) > val\nwhere bit, mask and val are some constants.\nIBM double double is done by doing DFmode test on the most significant\nhalf, and Intel/Motorola extended (12 or 16 bytes) and IEEE quad are\nhandled by extracting 32-bit/16-bit words or 64-bit parts from the\nvalue and testing those.\nOn x86, XFmode is handled by a special optab so that even pseudo numbers\nare considered signaling, like in glibc and like the i386 specific testcase\ntests.\n\n2022-08-26  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* builtins.def (BUILT_IN_ISSIGNALING): New built-in.\n\t* builtins.cc (expand_builtin_issignaling): New function.\n\t(expand_builtin_signbit): Don't overwrite target.\n\t(expand_builtin): Handle BUILT_IN_ISSIGNALING.\n\t(fold_builtin_classify): Likewise.\n\t(fold_builtin_1): Likewise.\n\t* optabs.def (issignaling_optab): New.\n\t* fold-const-call.cc (fold_const_call_ss): Handle\n\tBUILT_IN_ISSIGNALING.\n\t* config/i386/i386.md (issignalingxf2): New expander.\n\t* doc/extend.texi (__builtin_issignaling): Document.\n\t(__builtin_isinf, __builtin_isnan): Clarify behavior with\n\t-ffinite-math-only.\n\t* doc/md.texi (issignaling<mode>2): Likewise.\ngcc/c-family/\n\t* c-common.cc (check_builtin_function_arguments): Handle\n\tBUILT_IN_ISSIGNALING.\ngcc/c/\n\t* c-typeck.cc (convert_arguments): Handle BUILT_IN_ISSIGNALING.\ngcc/fortran/\n\t* f95-lang.cc (gfc_init_builtin_functions): Initialize\n\tBUILT_IN_ISSIGNALING.\ngcc/testsuite/\n\t* gcc.dg/torture/builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/builtin-issignaling-2.c: New test.\n\t* gcc.dg/torture/float16-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/float32-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/float32x-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/float64-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/float64x-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/float128-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/float128x-builtin-issignaling-1.c: New test.\n\t* gcc.target/i386/builtin-issignaling-1.c: New test.", "tree": {"sha": "67abe3deb6d101e0f7d0eb15075b2fee1057a1b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67abe3deb6d101e0f7d0eb15075b2fee1057a1b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0982edd371d5429d24615442e96e76ba6bc4faa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0982edd371d5429d24615442e96e76ba6bc4faa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0982edd371d5429d24615442e96e76ba6bc4faa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0982edd371d5429d24615442e96e76ba6bc4faa9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "530dc5aaaeb67c223fd0e3986d635408dcea4343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/530dc5aaaeb67c223fd0e3986d635408dcea4343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/530dc5aaaeb67c223fd0e3986d635408dcea4343"}], "stats": {"total": 778, "additions": 775, "deletions": 3}, "files": [{"sha": "f1f7c0ce33724532f78887158ab2a1075ccb6873", "filename": "gcc/builtins.cc", "status": "modified", "additions": 318, "deletions": 3, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -123,6 +123,7 @@ static rtx expand_builtin_fegetround (tree, rtx, machine_mode);\n static rtx expand_builtin_feclear_feraise_except (tree, rtx, machine_mode,\n \t\t\t\t\t\t  optab);\n static rtx expand_builtin_cexpi (tree, rtx);\n+static rtx expand_builtin_issignaling (tree, rtx);\n static rtx expand_builtin_int_roundingfn (tree, rtx);\n static rtx expand_builtin_int_roundingfn_2 (tree, rtx);\n static rtx expand_builtin_next_arg (void);\n@@ -2747,6 +2748,300 @@ build_call_nofold_loc (location_t loc, tree fndecl, int n, ...)\n   return fn;\n }\n \n+/* Expand the __builtin_issignaling builtin.  This needs to handle\n+   all floating point formats that do support NaNs (for those that\n+   don't it just sets target to 0).  */\n+\n+static rtx\n+expand_builtin_issignaling (tree exp, rtx target)\n+{\n+  if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tree arg = CALL_EXPR_ARG (exp, 0);\n+  scalar_float_mode fmode = SCALAR_FLOAT_TYPE_MODE (TREE_TYPE (arg));\n+  const struct real_format *fmt = REAL_MODE_FORMAT (fmode);\n+\n+  /* Expand the argument yielding a RTX expression. */\n+  rtx temp = expand_normal (arg);\n+\n+  /* If mode doesn't support NaN, always return 0.\n+     Don't use !HONOR_SNANS (fmode) here, so there is some possibility of\n+     __builtin_issignaling working without -fsignaling-nans.  Especially\n+     when -fno-signaling-nans is the default.\n+     On the other side, MODE_HAS_NANS (fmode) is unnecessary, with\n+     -ffinite-math-only even __builtin_isnan or __builtin_fpclassify\n+     fold to 0 or non-NaN/Inf classification.  */\n+  if (!HONOR_NANS (fmode))\n+    {\n+      emit_move_insn (target, const0_rtx);\n+      return target;\n+    }\n+\n+  /* Check if the back end provides an insn that handles issignaling for the\n+     argument's mode. */\n+  enum insn_code icode = optab_handler (issignaling_optab, fmode);\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      rtx_insn *last = get_last_insn ();\n+      rtx this_target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+      if (maybe_emit_unop_insn (icode, this_target, temp, UNKNOWN))\n+\treturn this_target;\n+      delete_insns_since (last);\n+    }\n+\n+  if (DECIMAL_FLOAT_MODE_P (fmode))\n+    {\n+      scalar_int_mode imode;\n+      rtx hi;\n+      switch (fmt->ieee_bits)\n+\t{\n+\tcase 32:\n+\tcase 64:\n+\t  imode = int_mode_for_mode (fmode).require ();\n+\t  temp = gen_lowpart (imode, temp);\n+\t  break;\n+\tcase 128:\n+\t  imode = int_mode_for_size (64, 1).require ();\n+\t  hi = NULL_RTX;\n+\t  /* For decimal128, TImode support isn't always there and even when\n+\t     it is, working on the DImode high part is usually better.  */\n+\t  if (!MEM_P (temp))\n+\t    {\n+\t      if (rtx t = simplify_gen_subreg (imode, temp, fmode,\n+\t\t\t\t\t       subreg_highpart_offset (imode,\n+\t\t\t\t\t\t\t\t       fmode)))\n+\t\thi = t;\n+\t      else\n+\t\t{\n+\t\t  scalar_int_mode imode2;\n+\t\t  if (int_mode_for_mode (fmode).exists (&imode2))\n+\t\t    {\n+\t\t      rtx temp2 = gen_lowpart (imode2, temp);\n+\t\t      poly_uint64 off = subreg_highpart_offset (imode, imode2);\n+\t\t      if (rtx t = simplify_gen_subreg (imode, temp2,\n+\t\t\t\t\t\t       imode2, off))\n+\t\t\thi = t;\n+\t\t    }\n+\t\t}\n+\t      if (!hi)\n+\t\t{\n+\t\t  rtx mem = assign_stack_temp (fmode, GET_MODE_SIZE (fmode));\n+\t\t  emit_move_insn (mem, temp);\n+\t\t  temp = mem;\n+\t\t}\n+\t    }\n+\t  if (!hi)\n+\t    {\n+\t      poly_int64 offset\n+\t\t= subreg_highpart_offset (imode, GET_MODE (temp));\n+\t      hi = adjust_address (temp, imode, offset);\n+\t    }\n+\t  temp = hi;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      /* In all of decimal{32,64,128}, there is MSB sign bit and sNaN\n+\t have 6 bits below it all set.  */\n+      rtx val\n+\t= GEN_INT (HOST_WIDE_INT_C (0x3f) << (GET_MODE_BITSIZE (imode) - 7));\n+      temp = expand_binop (imode, and_optab, temp, val,\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      temp = emit_store_flag_force (target, EQ, temp, val, imode, 1, 1);\n+      return temp;\n+    }\n+\n+  /* Only PDP11 has these defined differently but doesn't support NaNs.  */\n+  gcc_assert (FLOAT_WORDS_BIG_ENDIAN == WORDS_BIG_ENDIAN);\n+  gcc_assert (fmt->signbit_ro > 0 && fmt->b == 2);\n+  gcc_assert (MODE_COMPOSITE_P (fmode)\n+\t      || (fmt->pnan == fmt->p\n+\t\t  && fmt->signbit_ro == fmt->signbit_rw));\n+\n+  switch (fmt->p)\n+    {\n+    case 106: /* IBM double double  */\n+      /* For IBM double double, recurse on the most significant double.  */\n+      gcc_assert (MODE_COMPOSITE_P (fmode));\n+      temp = convert_modes (DFmode, fmode, temp, 0);\n+      fmode = DFmode;\n+      fmt = REAL_MODE_FORMAT (DFmode);\n+      /* FALLTHRU */\n+    case 8: /* bfloat */\n+    case 11: /* IEEE half */\n+    case 24: /* IEEE single */\n+    case 53: /* IEEE double or Intel extended with rounding to double */\n+      if (fmt->p == 53 && fmt->signbit_ro == 79)\n+\tgoto extended;\n+      {\n+\tscalar_int_mode imode = int_mode_for_mode (fmode).require ();\n+\ttemp = gen_lowpart (imode, temp);\n+\trtx val = GEN_INT ((HOST_WIDE_INT_M1U << (fmt->p - 2))\n+\t\t\t   & ~(HOST_WIDE_INT_M1U << fmt->signbit_ro));\n+\tif (fmt->qnan_msb_set)\n+\t  {\n+\t    rtx mask = GEN_INT (~(HOST_WIDE_INT_M1U << fmt->signbit_ro));\n+\t    rtx bit = GEN_INT (HOST_WIDE_INT_1U << (fmt->p - 2));\n+\t    /* For non-MIPS/PA IEEE single/double/half or bfloat, expand to:\n+\t       ((temp ^ bit) & mask) > val.  */\n+\t    temp = expand_binop (imode, xor_optab, temp, bit,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = expand_binop (imode, and_optab, temp, mask,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = emit_store_flag_force (target, GTU, temp, val, imode,\n+\t\t\t\t\t  1, 1);\n+\t  }\n+\telse\n+\t  {\n+\t    /* For MIPS/PA IEEE single/double, expand to:\n+\t       (temp & val) == val.  */\n+\t    temp = expand_binop (imode, and_optab, temp, val,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = emit_store_flag_force (target, EQ, temp, val, imode,\n+\t\t\t\t\t  1, 1);\n+\t  }\n+      }\n+      break;\n+    case 113: /* IEEE quad */\n+      {\n+\trtx hi = NULL_RTX, lo = NULL_RTX;\n+\tscalar_int_mode imode = int_mode_for_size (64, 1).require ();\n+\t/* For IEEE quad, TImode support isn't always there and even when\n+\t   it is, working on DImode parts is usually better.  */\n+\tif (!MEM_P (temp))\n+\t  {\n+\t    hi = simplify_gen_subreg (imode, temp, fmode,\n+\t\t\t\t      subreg_highpart_offset (imode, fmode));\n+\t    lo = simplify_gen_subreg (imode, temp, fmode,\n+\t\t\t\t      subreg_lowpart_offset (imode, fmode));\n+\t    if (!hi || !lo)\n+\t      {\n+\t\tscalar_int_mode imode2;\n+\t\tif (int_mode_for_mode (fmode).exists (&imode2))\n+\t\t  {\n+\t\t    rtx temp2 = gen_lowpart (imode2, temp);\n+\t\t    hi = simplify_gen_subreg (imode, temp2, imode2,\n+\t\t\t\t\t      subreg_highpart_offset (imode,\n+\t\t\t\t\t\t\t\t      imode2));\n+\t\t    lo = simplify_gen_subreg (imode, temp2, imode2,\n+\t\t\t\t\t      subreg_lowpart_offset (imode,\n+\t\t\t\t\t\t\t\t     imode2));\n+\t\t  }\n+\t      }\n+\t    if (!hi || !lo)\n+\t      {\n+\t\trtx mem = assign_stack_temp (fmode, GET_MODE_SIZE (fmode));\n+\t\temit_move_insn (mem, temp);\n+\t\ttemp = mem;\n+\t      }\n+\t  }\n+\tif (!hi || !lo)\n+\t  {\n+\t    poly_int64 offset\n+\t      = subreg_highpart_offset (imode, GET_MODE (temp));\n+\t    hi = adjust_address (temp, imode, offset);\n+\t    offset = subreg_lowpart_offset (imode, GET_MODE (temp));\n+\t    lo = adjust_address (temp, imode, offset);\n+\t  }\n+\trtx val = GEN_INT ((HOST_WIDE_INT_M1U << (fmt->p - 2 - 64))\n+\t\t\t   & ~(HOST_WIDE_INT_M1U << (fmt->signbit_ro - 64)));\n+\tif (fmt->qnan_msb_set)\n+\t  {\n+\t    rtx mask = GEN_INT (~(HOST_WIDE_INT_M1U << (fmt->signbit_ro\n+\t\t\t\t\t\t\t- 64)));\n+\t    rtx bit = GEN_INT (HOST_WIDE_INT_1U << (fmt->p - 2 - 64));\n+\t    /* For non-MIPS/PA IEEE quad, expand to:\n+\t       (((hi ^ bit) | ((lo | -lo) >> 63)) & mask) > val.  */\n+\t    rtx nlo = expand_unop (imode, neg_optab, lo, NULL_RTX, 0);\n+\t    lo = expand_binop (imode, ior_optab, lo, nlo,\n+\t\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    lo = expand_shift (RSHIFT_EXPR, imode, lo, 63, NULL_RTX, 1);\n+\t    temp = expand_binop (imode, xor_optab, hi, bit,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = expand_binop (imode, ior_optab, temp, lo,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = expand_binop (imode, and_optab, temp, mask,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = emit_store_flag_force (target, GTU, temp, val, imode,\n+\t\t\t\t\t  1, 1);\n+\t  }\n+\telse\n+\t  {\n+\t    /* For MIPS/PA IEEE quad, expand to:\n+\t       (hi & val) == val.  */\n+\t    temp = expand_binop (imode, and_optab, hi, val,\n+\t\t\t\t NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t    temp = emit_store_flag_force (target, EQ, temp, val, imode,\n+\t\t\t\t\t  1, 1);\n+\t  }\n+      }\n+      break;\n+    case 64: /* Intel or Motorola extended */\n+    extended:\n+      {\n+\trtx ex, hi, lo;\n+\tscalar_int_mode imode = int_mode_for_size (32, 1).require ();\n+\tscalar_int_mode iemode = int_mode_for_size (16, 1).require ();\n+\tif (!MEM_P (temp))\n+\t  {\n+\t    rtx mem = assign_stack_temp (fmode, GET_MODE_SIZE (fmode));\n+\t    emit_move_insn (mem, temp);\n+\t    temp = mem;\n+\t  }\n+\tif (fmt->signbit_ro == 95)\n+\t  {\n+\t    /* Motorola, always big endian, with 16-bit gap in between\n+\t       16-bit sign+exponent and 64-bit mantissa.  */\n+\t    ex = adjust_address (temp, iemode, 0);\n+\t    hi = adjust_address (temp, imode, 4);\n+\t    lo = adjust_address (temp, imode, 8);\n+\t  }\n+\telse if (!WORDS_BIG_ENDIAN)\n+\t  {\n+\t    /* Intel little endian, 64-bit mantissa followed by 16-bit\n+\t       sign+exponent and then either 16 or 48 bits of gap.  */\n+\t    ex = adjust_address (temp, iemode, 8);\n+\t    hi = adjust_address (temp, imode, 4);\n+\t    lo = adjust_address (temp, imode, 0);\n+\t  }\n+\telse\n+\t  {\n+\t    /* Big endian Itanium.  */\n+\t    ex = adjust_address (temp, iemode, 0);\n+\t    hi = adjust_address (temp, imode, 2);\n+\t    lo = adjust_address (temp, imode, 6);\n+\t  }\n+\trtx val = GEN_INT (HOST_WIDE_INT_M1U << 30);\n+\tgcc_assert (fmt->qnan_msb_set);\n+\trtx mask = GEN_INT (0x7fff);\n+\trtx bit = GEN_INT (HOST_WIDE_INT_1U << 30);\n+\t/* For Intel/Motorola extended format, expand to:\n+\t   (ex & mask) == mask && ((hi ^ bit) | ((lo | -lo) >> 31)) > val.  */\n+\trtx nlo = expand_unop (imode, neg_optab, lo, NULL_RTX, 0);\n+\tlo = expand_binop (imode, ior_optab, lo, nlo,\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\tlo = expand_shift (RSHIFT_EXPR, imode, lo, 31, NULL_RTX, 1);\n+\ttemp = expand_binop (imode, xor_optab, hi, bit,\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\ttemp = expand_binop (imode, ior_optab, temp, lo,\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\ttemp = emit_store_flag_force (target, GTU, temp, val, imode, 1, 1);\n+\tex = expand_binop (iemode, and_optab, ex, mask,\n+\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\tex = emit_store_flag_force (gen_reg_rtx (GET_MODE (temp)), EQ,\n+\t\t\t\t    ex, mask, iemode, 1, 1);\n+\ttemp = expand_binop (GET_MODE (temp), and_optab, temp, ex,\n+\t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+      }\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return temp;\n+}\n+\n /* Expand a call to one of the builtin rounding functions gcc defines\n    as an extension (lfloor and lceil).  As these are gcc extensions we\n    do not need to worry about setting errno to EDOM.\n@@ -5508,9 +5803,9 @@ expand_builtin_signbit (tree exp, rtx target)\n   if (icode != CODE_FOR_nothing)\n     {\n       rtx_insn *last = get_last_insn ();\n-      target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-      if (maybe_emit_unop_insn (icode, target, temp, UNKNOWN))\n-\treturn target;\n+      rtx this_target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+      if (maybe_emit_unop_insn (icode, this_target, temp, UNKNOWN))\n+\treturn this_target;\n       delete_insns_since (last);\n     }\n \n@@ -7120,6 +7415,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_ISSIGNALING:\n+      target = expand_builtin_issignaling (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     CASE_FLT_FN (BUILT_IN_ICEIL):\n     CASE_FLT_FN (BUILT_IN_LCEIL):\n     CASE_FLT_FN (BUILT_IN_LLCEIL):\n@@ -8963,6 +9264,17 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n       arg = builtin_save_expr (arg);\n       return fold_build2_loc (loc, UNORDERED_EXPR, type, arg, arg);\n \n+    case BUILT_IN_ISSIGNALING:\n+      /* Folding to true for REAL_CST is done in fold_const_call_ss.\n+\t Don't use tree_expr_signaling_nan_p (arg) -> integer_one_node\n+\t and !tree_expr_maybe_signaling_nan_p (arg) -> integer_zero_node\n+\t here, so there is some possibility of __builtin_issignaling working\n+\t without -fsignaling-nans.  Especially when -fno-signaling-nans is\n+\t the default.  */\n+      if (!tree_expr_maybe_nan_p (arg))\n+\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n+      return NULL_TREE;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -9399,6 +9711,9 @@ fold_builtin_1 (location_t loc, tree expr, tree fndecl, tree arg0)\n     case BUILT_IN_ISNAND128:\n       return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISNAN);\n \n+    case BUILT_IN_ISSIGNALING:\n+      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISSIGNALING);\n+\n     case BUILT_IN_FREE:\n       if (integer_zerop (arg0))\n \treturn build_empty_stmt (loc);"}, {"sha": "f02363168509cd5d9d6e2c55ea4f47ae0ee979dc", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -908,6 +908,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_ISLESS, \"isless\", BT_FN_INT_VAR, ATTR_CONST_NOT\n DEF_GCC_BUILTIN        (BUILT_IN_ISLESSEQUAL, \"islessequal\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n DEF_GCC_BUILTIN        (BUILT_IN_ISLESSGREATER, \"islessgreater\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n DEF_GCC_BUILTIN        (BUILT_IN_ISUNORDERED, \"isunordered\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n+DEF_GCC_BUILTIN        (BUILT_IN_ISSIGNALING, \"issignaling\", BT_FN_INT_VAR, ATTR_CONST_NOTHROW_TYPEGENERIC_LEAF)\n DEF_LIB_BUILTIN        (BUILT_IN_LABS, \"labs\", BT_FN_LONG_LONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_LLABS, \"llabs\", BT_FN_LONGLONG_LONGLONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_LONGJMP, \"longjmp\", BT_FN_VOID_PTR_INT, ATTR_NORETURN_NOTHROW_LIST)"}, {"sha": "71fe7305369b091d30009f8ee82823b1971ec57e", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -6308,6 +6308,7 @@ check_builtin_function_arguments (location_t loc, vec<location_t> arg_loc,\n     case BUILT_IN_ISINF_SIGN:\n     case BUILT_IN_ISNAN:\n     case BUILT_IN_ISNORMAL:\n+    case BUILT_IN_ISSIGNALING:\n     case BUILT_IN_SIGNBIT:\n       if (builtin_function_validate_nargs (loc, fndecl, nargs, 1))\n \t{"}, {"sha": "ee891ee33c24623f0b136d9813394524800fe493", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -3553,6 +3553,7 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t  case BUILT_IN_ISINF_SIGN:\n \t  case BUILT_IN_ISNAN:\n \t  case BUILT_IN_ISNORMAL:\n+\t  case BUILT_IN_ISSIGNALING:\n \t  case BUILT_IN_FPCLASSIFY:\n \t    type_generic_remove_excess_precision = true;\n \t    break;"}, {"sha": "a4a18cf89f51275f3f5d93142254977961805653", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -24732,6 +24732,58 @@\n   DONE;\n })\n \n+;; Defined because the generic expand_builtin_issignaling for XFmode\n+;; only tests for sNaNs, but i387 treats also pseudo numbers as always\n+;; signaling.\n+(define_expand \"issignalingxf2\"\n+  [(match_operand:SI 0 \"register_operand\")\n+   (match_operand:XF 1 \"general_operand\")]\n+  \"\"\n+{\n+  rtx temp = operands[1];\n+  if (!MEM_P (temp))\n+    {\n+      rtx mem = assign_stack_temp (XFmode, GET_MODE_SIZE (XFmode));\n+      emit_move_insn (mem, temp);\n+      temp = mem;\n+    }\n+  rtx ex = adjust_address (temp, HImode, 8);\n+  rtx hi = adjust_address (temp, SImode, 4);\n+  rtx lo = adjust_address (temp, SImode, 0);\n+  rtx val = GEN_INT (HOST_WIDE_INT_M1U << 30);\n+  rtx mask = GEN_INT (0x7fff);\n+  rtx bit = GEN_INT (HOST_WIDE_INT_1U << 30);\n+  /* Expand to:\n+     ((ex & mask) && (int) hi >= 0)\n+     || ((ex & mask) == mask && ((hi ^ bit) | ((lo | -lo) >> 31)) > val).  */\n+  rtx nlo = expand_unop (SImode, neg_optab, lo, NULL_RTX, 0);\n+  lo = expand_binop (SImode, ior_optab, lo, nlo,\n+\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  lo = expand_shift (RSHIFT_EXPR, SImode, lo, 31, NULL_RTX, 1);\n+  temp = expand_binop (SImode, xor_optab, hi, bit,\n+\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  temp = expand_binop (SImode, ior_optab, temp, lo,\n+\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  temp = emit_store_flag_force (gen_reg_rtx (SImode), GTU, temp, val,\n+\t\t\t\tSImode, 1, 1);\n+  ex = expand_binop (HImode, and_optab, ex, mask,\n+\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  rtx temp2 = emit_store_flag_force (gen_reg_rtx (SImode), NE,\n+\t\t\t\t     ex, const0_rtx, SImode, 1, 1);\n+  ex = emit_store_flag_force (gen_reg_rtx (SImode), EQ,\n+\t\t\t      ex, mask, HImode, 1, 1);\n+  temp = expand_binop (SImode, and_optab, temp, ex,\n+\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  rtx temp3 = emit_store_flag_force (gen_reg_rtx (SImode), GE,\n+\t\t\t\t     hi, const0_rtx, SImode, 0, 1);\n+  temp2 = expand_binop (SImode, and_optab, temp2, temp3,\n+\t\t\tNULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  temp = expand_binop (SImode, ior_optab, temp, temp2,\n+\t\t       NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+  emit_move_insn (operands[0], temp);\n+  DONE;\n+})\n+\n (include \"mmx.md\")\n (include \"sse.md\")\n (include \"sync.md\")"}, {"sha": "0fedab96610b313d9eb010c35bf9f6e52d76e0e1", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -13003,6 +13003,7 @@ is called and the @var{flag} argument passed to it.\n @findex __builtin_isless\n @findex __builtin_islessequal\n @findex __builtin_islessgreater\n+@findex __builtin_issignaling\n @findex __builtin_isunordered\n @findex __builtin_object_size\n @findex __builtin_powi\n@@ -13558,6 +13559,8 @@ In the same fashion, GCC provides @code{fpclassify}, @code{isfinite},\n @code{isinf_sign}, @code{isnormal} and @code{signbit} built-ins used with\n @code{__builtin_} prefixed.  The @code{isinf} and @code{isnan}\n built-in functions appear both with and without the @code{__builtin_} prefix.\n+With @code{-ffinite-math-only} option the @code{isinf} and @code{isnan}\n+built-in functions will always return 0.\n \n GCC provides built-in versions of the ISO C99 floating-point rounding and\n exceptions handling functions @code{fegetround}, @code{feclearexcept} and\n@@ -14491,6 +14494,20 @@ Similar to @code{__builtin_nans}, except the return type is\n @code{_Float@var{n}x}.\n @end deftypefn\n \n+@deftypefn {Built-in Function} int __builtin_issignaling (...)\n+Return non-zero if the argument is a signaling NaN and zero otherwise.\n+Note while the parameter list is an\n+ellipsis, this function only accepts exactly one floating-point\n+argument.  GCC treats this parameter as type-generic, which means it\n+does not do default promotion from float to double.\n+This built-in function can work even without the non-default\n+@code{-fsignaling-nans} option, although if a signaling NaN is computed,\n+stored or passed as argument to some function other than this built-in\n+in the current translation unit, it is safer to use @code{-fsignaling-nans}.\n+With @code{-ffinite-math-only} option this built-in function will always\n+return 0.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} int __builtin_ffs (int x)\n Returns one plus the index of the least significant 1-bit of @var{x}, or\n if @var{x} is zero, returns zero."}, {"sha": "34825549ed4e315b07d36dc3d63bae0cc0a3932d", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -6150,6 +6150,10 @@ floating-point mode.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{issignaling@var{m}2} instruction pattern\n+@item @samp{issignaling@var{m}2}\n+Set operand 0 to 1 if operand 1 is a signaling NaN and to 0 otherwise.\n+\n @cindex @code{cadd90@var{m}3} instruction pattern\n @item @samp{cadd90@var{m}3}\n Perform vector add and subtract on even/odd number pairs.  The operation being"}, {"sha": "c18256825af3a09cabdf8af50b2cf9f8953c46f5", "filename": "gcc/fold-const-call.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ffold-const-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ffold-const-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.cc?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -952,6 +952,10 @@ fold_const_call_ss (wide_int *result, combined_fn fn,\n       *result = wi::shwi (real_isfinite (arg) ? 1 : 0, precision);\n       return true;\n \n+    case CFN_BUILT_IN_ISSIGNALING:\n+      *result = wi::shwi (real_issignaling_nan (arg) ? 1 : 0, precision);\n+      return true;\n+\n     CASE_CFN_ISINF:\n     case CFN_BUILT_IN_ISINFD32:\n     case CFN_BUILT_IN_ISINFD64:"}, {"sha": "a7149f418b6a864ee538aa7b8fc0e76409ee5904", "filename": "gcc/fortran/f95-lang.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ffortran%2Ff95-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ffortran%2Ff95-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.cc?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -1013,6 +1013,8 @@ gfc_init_builtin_functions (void)\n \t\t      \"__builtin_isnan\", ATTR_CONST_NOTHROW_LEAF_LIST);\n   gfc_define_builtin (\"__builtin_isnormal\", ftype, BUILT_IN_ISNORMAL,\n \t\t      \"__builtin_isnormal\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  gfc_define_builtin (\"__builtin_issignaling\", ftype, BUILT_IN_ISSIGNALING,\n+\t\t      \"__builtin_issignaling\", ATTR_CONST_NOTHROW_LEAF_LIST);\n   gfc_define_builtin (\"__builtin_signbit\", ftype, BUILT_IN_SIGNBIT,\n \t\t      \"__builtin_signbit\", ATTR_CONST_NOTHROW_LEAF_LIST);\n "}, {"sha": "a6db2342bed6baf13ecbd84112c8432c6972e6fe", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -313,6 +313,7 @@ OPTAB_D (fmod_optab, \"fmod$a3\")\n OPTAB_D (hypot_optab, \"hypot$a3\")\n OPTAB_D (ilogb_optab, \"ilogb$a2\")\n OPTAB_D (isinf_optab, \"isinf$a2\")\n+OPTAB_D (issignaling_optab, \"issignaling$a2\")\n OPTAB_D (ldexp_optab, \"ldexp$a3\")\n OPTAB_D (log10_optab, \"log10$a2\")\n OPTAB_D (log1p_optab, \"log1p$a2\")"}, {"sha": "fddca6cdd2111b7a356cd7bcc5420bbe7e565c1f", "filename": "gcc/testsuite/gcc.dg/torture/builtin-issignaling-1.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,130 @@\n+/* { dg-do run } */\n+/* { dg-add-options ieee } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#ifndef EXT\n+int\n+f1 (void)\n+{\n+  return __builtin_issignaling (__builtin_nansf (\"\"));\n+}\n+\n+int\n+f2 (void)\n+{\n+  return __builtin_issignaling (__builtin_nan (\"\"));\n+}\n+\n+int\n+f3 (void)\n+{\n+  return __builtin_issignaling (0.0L);\n+}\n+\n+int\n+f4 (float x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+\n+int\n+f5 (double x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+\n+int\n+f6 (long double x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+#else\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+\n+#if EXT\n+# define TYPE CONCAT3 (_Float, WIDTH, x)\n+# define CST(C) CONCAT4 (C, f, WIDTH, x)\n+# define FN(F) CONCAT4 (F, f, WIDTH, x)\n+#else\n+# define TYPE CONCAT (_Float, WIDTH)\n+# define CST(C) CONCAT3 (C, f, WIDTH)\n+# define FN(F) CONCAT3 (F, f, WIDTH)\n+#endif\n+\n+int\n+f1 (void)\n+{\n+  return __builtin_issignaling (FN (__builtin_nans) (\"\"));\n+}\n+\n+int\n+f2 (void)\n+{\n+  return __builtin_issignaling (FN (__builtin_nan) (\"\"));\n+}\n+\n+int\n+f3 (void)\n+{\n+  return __builtin_issignaling (CST (0.0));\n+}\n+\n+int\n+f4 (TYPE x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+#endif\n+\n+#ifndef EXT\n+float x;\n+double y;\n+long double z;\n+#else\n+TYPE w;\n+#endif\n+\n+int\n+main ()\n+{\n+  if (!f1 () || f2 () || f3 ())\n+    __builtin_abort ();\n+  asm volatile (\"\" : : : \"memory\");\n+#ifndef EXT\n+  if (f4 (x) || !f4 (__builtin_nansf (\"0x123\")) || f4 (42.0f) || f4 (__builtin_nanf (\"0x234\"))\n+      || f4 (__builtin_inff ()) || f4 (-__builtin_inff ()) || f4 (-42.0f) || f4 (-0.0f) || f4 (0.0f))\n+    __builtin_abort ();\n+  x = __builtin_nansf (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f4 (x))\n+    __builtin_abort ();\n+  if (f5 (y) || !f5 (__builtin_nans (\"0x123\")) || f5 (42.0) || f5 (__builtin_nan (\"0x234\"))\n+      || f5 (__builtin_inf ()) || f5 (-__builtin_inf ()) || f5 (-42.0) || f5 (-0.0) || f5 (0.0))\n+    __builtin_abort ();\n+  y = __builtin_nans (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f5 (y))\n+    __builtin_abort ();\n+  if (f6 (z) || !f6 (__builtin_nansl (\"0x123\")) || f6 (42.0L) || f6 (__builtin_nanl (\"0x234\"))\n+      || f6 (__builtin_infl ()) || f6 (-__builtin_infl ()) || f6 (-42.0L) || f6 (-0.0L) || f6 (0.0L))\n+    __builtin_abort ();\n+  z = __builtin_nansl (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f6 (z))\n+    __builtin_abort ();\n+#else\n+  if (f4 (w) || !f4 (FN (__builtin_nans) (\"0x123\")) || f4 (CST (42.0)) || f4 (FN (__builtin_nan) (\"0x234\"))\n+      || f4 (FN (__builtin_inf) ()) || f4 (-FN (__builtin_inf) ()) || f4 (CST (-42.0)) || f4 (CST (-0.0)) || f4 (CST (0.0)))\n+    __builtin_abort ();\n+  w = FN (__builtin_nans) (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f4 (w))\n+    __builtin_abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "4209a219e1d8faf2d97c97e500be470731930fc9", "filename": "gcc/testsuite/gcc.dg/torture/builtin-issignaling-2.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-2.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target dfp } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+\n+int\n+f1 (void)\n+{\n+  return __builtin_issignaling (__builtin_nansd32 (\"\"));\n+}\n+\n+int\n+f2 (void)\n+{\n+  return __builtin_issignaling (__builtin_nand64 (\"\"));\n+}\n+\n+int\n+f3 (void)\n+{\n+  return __builtin_issignaling (0.0DD);\n+}\n+\n+int\n+f4 (_Decimal32 x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+\n+int\n+f5 (_Decimal64 x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+\n+int\n+f6 (_Decimal128 x)\n+{\n+  return __builtin_issignaling (x);\n+}\n+\n+_Decimal32 x;\n+_Decimal64 y;\n+_Decimal128 z;\n+\n+int\n+main ()\n+{\n+  if (!f1 () || f2 () || f3 ())\n+    __builtin_abort ();\n+  asm volatile (\"\" : : : \"memory\");\n+  if (f4 (x) || !f4 (__builtin_nansd32 (\"0x123\")) || f4 (42.0DF) || f4 (__builtin_nand32 (\"0x234\"))\n+      || f4 (__builtin_infd32 ()) || f4 (-__builtin_infd32 ()) || f4 (-42.0DF) || f4 (-0.0DF) || f4 (0.0DF))\n+    __builtin_abort ();\n+  x = __builtin_nansd32 (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f4 (x))\n+    __builtin_abort ();\n+  if (f5 (y) || !f5 (__builtin_nansd64 (\"0x123\")) || f5 (42.0DD) || f5 (__builtin_nand64 (\"0x234\"))\n+      || f5 (__builtin_infd64 ()) || f5 (-__builtin_infd64 ()) || f5 (-42.0DD) || f5 (-0.0DD) || f5 (0.0DD))\n+    __builtin_abort ();\n+  y = __builtin_nansd64 (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f5 (y))\n+    __builtin_abort ();\n+  if (f6 (z) || !f6 (__builtin_nansd128 (\"0x123\")) || f6 (42.0DL) || f6 (__builtin_nand128 (\"0x234\"))\n+      || f6 (__builtin_infd128 ()) || f6 (-__builtin_infd128 ()) || f6 (-42.0DL) || f6 (-0.0DL) || f6 (0.0DL))\n+    __builtin_abort ();\n+  z = __builtin_nansd128 (\"\");\n+  asm volatile (\"\" : : : \"memory\");\n+  if (!f6 (z))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "3299ffd566621355d7396bb49a387b3b00ef072f", "filename": "gcc/testsuite/gcc.dg/torture/float128-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float128 __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float128_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 128\n+#define EXT 0\n+#include \"builtin-issignaling-1.c\""}, {"sha": "af0b25af8a5fa8bdc8a6356b81e01f96c49a14e1", "filename": "gcc/testsuite/gcc.dg/torture/float128x-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat128x-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float128x __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float128x } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float128x_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 128\n+#define EXT 1\n+#include \"builtin-issignaling-1.c\""}, {"sha": "a0747e4240b4dc132d46a6582fcca84b33252a86", "filename": "gcc/testsuite/gcc.dg/torture/float16-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat16-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float16 __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float16 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float16_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 16\n+#define EXT 0\n+#include \"builtin-issignaling-1.c\""}, {"sha": "38e56c2c00cc950ec5684a04810197ca4233df79", "filename": "gcc/testsuite/gcc.dg/torture/float32-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float32 __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float32_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 32\n+#define EXT 0\n+#include \"builtin-issignaling-1.c\""}, {"sha": "88eefdbc1d69046971028d74949f3f96c2bb8ee2", "filename": "gcc/testsuite/gcc.dg/torture/float32x-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat32x-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float32x __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float32x } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float32x_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 32\n+#define EXT 1\n+#include \"builtin-issignaling-1.c\""}, {"sha": "07d755b37be5505666a6bf59cd59af1c4f9d9753", "filename": "gcc/testsuite/gcc.dg/torture/float64-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float64 __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float64_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 64\n+#define EXT 0\n+#include \"builtin-issignaling-1.c\""}, {"sha": "fe6420aaa95b77614a9636464c7a44bb2e5e5f0e", "filename": "gcc/testsuite/gcc.dg/torture/float64x-builtin-issignaling-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloat64x-builtin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,13 @@\n+/* Test _Float64x __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options float64x } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target float64x_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define WIDTH 64\n+#define EXT 1\n+#include \"builtin-issignaling-1.c\""}, {"sha": "8f170c475a174beb1a4bced62d00a4ff36c7a01d", "filename": "gcc/testsuite/gcc.target/i386/builtin-issignaling-1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin-issignaling-1.c?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fsignaling-nans\" } */\n+\n+#if __LDBL_MANT_DIG__ == 64\n+union U { struct { unsigned long long m; unsigned short e; } p; long double l; };\n+union U zero = { { 0, 0 } };\n+union U mzero = { { 0, 0x8000 } };\n+union U denorm = { { 42, 0 } };\n+union U mdenorm = { { 42, 0x8000 } };\n+union U pseudodenorm = { { 0x8000000000000000ULL, 0 } };\n+union U mpseudodenorm = { { 0x8000000000000000ULL, 0x8000 } };\n+union U pseudodenorm1 = { { 0x8000000000000042ULL, 0 } };\n+union U mpseudodenorm1 = { { 0x8000000000000042ULL, 0x8000 } };\n+union U pseudoinf = { { 0, 0x7fff } };\n+union U mpseudoinf = { { 0, 0xffff } };\n+union U pseudonan = { { 42, 0x7fff } };\n+union U mpseudonan = { { 42, 0xffff } };\n+union U pseudonan1 = { { 0x4000000000000000ULL, 0x7fff } };\n+union U mpseudonan1 = { { 0x4000000000000000ULL, 0xffff } };\n+union U pseudonan2 = { { 0x4000000000000042ULL, 0x7fff } };\n+union U mpseudonan2 = { { 0x4000000000000042ULL, 0xffff } };\n+union U inf = { { 0x8000000000000000ULL, 0x7fff } };\n+union U minf = { { 0x8000000000000000ULL, 0xffff } };\n+union U snan = { { 0x8000000000000042ULL, 0x7fff } };\n+union U msnan = { { 0x8000000000000042ULL, 0xffff } };\n+union U indefinite = { { 0xc000000000000000ULL, 0x7fff } };\n+union U mindefinite = { { 0xc000000000000000ULL, 0xffff } };\n+union U qnan = { { 0xc000000000000042ULL, 0x7fff } };\n+union U mqnan = { { 0xc000000000000042ULL, 0xffff } };\n+union U unnormal = { { 0, 0x42 } };\n+union U munnormal = { { 0, 0x8042 } };\n+union U unnormal1 = { { 42, 0x42 } };\n+union U munnormal1 = { { 42, 0x8042 } };\n+union U normal = { { 0x8000000000000000ULL, 0x42 } };\n+union U mnormal = { { 0x8000000000000000ULL, 0x8042 } };\n+union U normal1 = { { 0x8000000000000042ULL, 0x42 } };\n+union U mnormal1 = { { 0x8000000000000042ULL, 0x8042 } };\n+#endif\n+\n+int\n+main ()\n+{\n+#if __LDBL_MANT_DIG__ == 64\n+  asm volatile (\"\" : : : \"memory\");\n+  if (__builtin_issignaling (zero.l)\n+      || __builtin_issignaling (mzero.l)\n+      || __builtin_issignaling (denorm.l)\n+      || __builtin_issignaling (mdenorm.l)\n+      || __builtin_issignaling (pseudodenorm.l)\n+      || __builtin_issignaling (mpseudodenorm.l)\n+      || __builtin_issignaling (pseudodenorm1.l)\n+      || __builtin_issignaling (mpseudodenorm1.l)\n+      || !__builtin_issignaling (pseudoinf.l)\n+      || !__builtin_issignaling (mpseudoinf.l)\n+      || !__builtin_issignaling (pseudonan.l)\n+      || !__builtin_issignaling (mpseudonan.l)\n+      || !__builtin_issignaling (pseudonan1.l)\n+      || !__builtin_issignaling (mpseudonan1.l)\n+      || !__builtin_issignaling (pseudonan2.l)\n+      || !__builtin_issignaling (mpseudonan2.l)\n+      || __builtin_issignaling (inf.l)\n+      || __builtin_issignaling (minf.l)\n+      || !__builtin_issignaling (snan.l)\n+      || !__builtin_issignaling (msnan.l)\n+      || __builtin_issignaling (indefinite.l)\n+      || __builtin_issignaling (mindefinite.l)\n+      || __builtin_issignaling (qnan.l)\n+      || __builtin_issignaling (mqnan.l)\n+      || !__builtin_issignaling (unnormal.l)\n+      || !__builtin_issignaling (munnormal.l)\n+      || !__builtin_issignaling (unnormal1.l)\n+      || !__builtin_issignaling (munnormal1.l)\n+      || __builtin_issignaling (normal.l)\n+      || __builtin_issignaling (mnormal.l)\n+      || __builtin_issignaling (normal1.l)\n+      || __builtin_issignaling (mnormal1.l))\n+    __builtin_abort ();\n+#endif\n+  return 0;\n+}"}]}