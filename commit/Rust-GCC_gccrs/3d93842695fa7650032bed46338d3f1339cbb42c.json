{"sha": "3d93842695fa7650032bed46338d3f1339cbb42c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q5Mzg0MjY5NWZhNzY1MDAzMmJlZDQ2MzM4ZDNmMTMzOWNiYjQyYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-07T07:02:02Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-07T07:02:02Z"}, "message": "call.c (merge_conversion_sequences): New function.\n\n\t* call.c (merge_conversion_sequences): New function.\n\t(build_conv): Set ICS_USER_FLAG for USER_CONVs.\n\t(convert_class_to_reference): Correct handling of second\n\tstandard conversion sequence in a user-defined conversion\n\tsequence.\n\t(build_user_type_conversion_1): Use merge_conversion_sequences.\n\t* cp-tree.def: Add comments for CONV nodes.\n\n\t* g++.dg/init/ref3.C: New test.\n\nFrom-SVN: r63930", "tree": {"sha": "9fb76bbd4262b032899b2cd77f6653508a644d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fb76bbd4262b032899b2cd77f6653508a644d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d93842695fa7650032bed46338d3f1339cbb42c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d93842695fa7650032bed46338d3f1339cbb42c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d93842695fa7650032bed46338d3f1339cbb42c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d93842695fa7650032bed46338d3f1339cbb42c/comments", "author": null, "committer": null, "parents": [{"sha": "ea67bef4705c2012dfe5c35ff15cb0ebc78ea2da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea67bef4705c2012dfe5c35ff15cb0ebc78ea2da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea67bef4705c2012dfe5c35ff15cb0ebc78ea2da"}], "stats": {"total": 146, "additions": 112, "deletions": 34}, "files": [{"sha": "668c6e7135ea71c73fe7c77141e02e5016dc1e25", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3d93842695fa7650032bed46338d3f1339cbb42c", "patch": "@@ -1,3 +1,13 @@\n+2003-03-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (merge_conversion_sequences): New function.\n+\t(build_conv): Set ICS_USER_FLAG for USER_CONVs.\n+\t(convert_class_to_reference): Correct handling of second\n+\tstandard conversion sequence in a user-defined conversion\n+\tsequence.\n+\t(build_user_type_conversion_1): Use merge_conversion_sequences.\n+\t* cp-tree.def: Add comments for CONV nodes.\n+\n 2003-03-07  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* error.c (init_error): Use C90 prototype style."}, {"sha": "15dbbe1d2b4322bcb92c0881d1ff35c2266becef", "filename": "gcc/cp/call.c", "status": "modified", "additions": 77, "deletions": 24, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3d93842695fa7650032bed46338d3f1339cbb42c", "patch": "@@ -1,6 +1,6 @@\n /* Functions related to invoking methods and overloaded functions.\n-   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) and\n    modified by Brendan Kehoe (brendan@cygnus.com).\n \n@@ -106,6 +106,7 @@ static tree call_builtin_trap (void);\n static tree prep_operand (tree);\n static void add_candidates (tree, tree, tree, tree,\n \t\t\t    int, struct z_candidate **);\n+static tree merge_conversion_sequences (tree, tree);\n \n tree\n build_vfield_ref (tree datum, tree type)\n@@ -560,7 +561,12 @@ struct z_candidate GTY(()) {\n   tree fn;\n   /* The arguments to use when calling this function.  */\n   tree args;\n+  /* The implicit conversion sequences for each of the arguments to\n+     FN.  */\n   tree convs;\n+  /* If FN is a user-defined conversion, the standard conversion\n+     sequence from the type returned by FN to the desired destination\n+     type.  */\n   tree second_conv;\n   int viable;\n   /* If FN is a member function, the binfo indicating the path used to\n@@ -667,7 +673,7 @@ build_conv (enum tree_code code, tree type, tree from)\n       break;\n     }\n   ICS_STD_RANK (t) = rank;\n-  ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n+  ICS_USER_FLAG (t) = (code == USER_CONV || ICS_USER_FLAG (from));\n   ICS_BAD_FLAG (t) = ICS_BAD_FLAG (from);\n   return t;\n }\n@@ -1034,15 +1040,15 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t\t\t\t\t   LOOKUP_NORMAL);\n \t  \n \t  if (cand)\n-\t    {\n-\t      conv = build1 (IDENTITY_CONV, s, expr);\n-\t      conv = build_conv (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n-\t\t\t\t conv);\n-\t      TREE_OPERAND (conv, 1) = build_zc_wrapper (cand);\n-\t      ICS_USER_FLAG (conv) = 1;\n-\t      cand->second_conv\n-\t\t= direct_reference_binding (reference_type, conv);\n-\t    }\n+\t    /* Build a standard conversion sequence indicating the\n+\t       binding from the reference type returned by the\n+\t       function to the desired REFERENCE_TYPE.  */\n+\t    cand->second_conv\n+\t      = (direct_reference_binding \n+\t\t (reference_type, \n+\t\t  build1 (IDENTITY_CONV, \n+\t\t\t  TREE_TYPE (TREE_TYPE (TREE_TYPE (cand->fn))),\n+\t\t\t  NULL_TREE)));\n \t}\n       conversions = TREE_CHAIN (conversions);\n     }\n@@ -1063,11 +1069,21 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t\t\t  build_this (expr),\n \t\t\t  TREE_CHAIN (cand->args));\n \n-  conv = cand->second_conv;\n+  /* Build a user-defined conversion sequence representing the\n+     conversion.  */\n+  conv = build_conv (USER_CONV,\n+\t\t     TREE_TYPE (TREE_TYPE (cand->fn)),\n+\t\t     build1 (IDENTITY_CONV, TREE_TYPE (expr), expr));\n+  TREE_OPERAND (conv, 1) = build_zc_wrapper (cand);\n+\n+  /* Merge it with the standard conversion sequence from the\n+     conversion function's return type to the desired type.  */\n+  cand->second_conv = merge_conversion_sequences (conv, cand->second_conv);\n+\n   if (cand->viable == -1)\n     ICS_BAD_FLAG (conv) = 1;\n   \n-  return conv;\n+  return cand->second_conv;\n }\n \n /* A reference of the indicated TYPE is being bound directly to the\n@@ -1077,7 +1093,13 @@ convert_class_to_reference (tree t, tree s, tree expr)\n static tree\n direct_reference_binding (tree type, tree conv)\n {\n-  tree t = TREE_TYPE (type);\n+  tree t;\n+\n+  my_friendly_assert (TREE_CODE (type) == REFERENCE_TYPE, 20030306);\n+  my_friendly_assert (TREE_CODE (TREE_TYPE (conv)) != REFERENCE_TYPE,\n+\t\t      20030306);\n+\n+  t = TREE_TYPE (type);\n \n   /* [over.ics.rank] \n      \n@@ -2428,6 +2450,35 @@ print_z_candidates (struct z_candidate *candidates)\n     }\n }\n \n+/* USER_SEQ is a user-defined conversion sequence, beginning with a\n+   USER_CONV.  STD_SEQ is the standard conversion sequence applied to\n+   the result of the conversion function to convert it to the final\n+   desired type.  Merge the the two sequences into a single sequence,\n+   and return the merged sequence.  */\n+\n+static tree\n+merge_conversion_sequences (tree user_seq, tree std_seq)\n+{\n+  tree *t;\n+\n+  my_friendly_assert (TREE_CODE (user_seq) == USER_CONV,\n+\t\t      20030306);\n+\n+  /* Find the end of the second conversion sequence.  */\n+  t = &(std_seq); \n+  while (TREE_CODE (*t) != IDENTITY_CONV)\n+    t = &TREE_OPERAND (*t, 0);\n+\n+  /* Replace the identity conversion with the user conversion\n+     sequence.  */\n+  *t = user_seq;\n+\n+  /* The entire sequence is a user-conversion sequence.  */\n+  ICS_USER_FLAG (std_seq) = 1;\n+\n+  return std_seq;\n+}\n+\n /* Returns the best overload candidate to perform the requested\n    conversion.  This function is used for three the overloading situations\n    described in [over.match.copy], [over.match.conv], and [over.match.ref].\n@@ -2439,7 +2490,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n {\n   struct z_candidate *candidates, *cand;\n   tree fromtype = TREE_TYPE (expr);\n-  tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n+  tree ctors = NULL_TREE, convs = NULL_TREE;\n   tree args = NULL_TREE;\n \n   /* We represent conversion within a hierarchy using RVALUE_CONV and\n@@ -2583,18 +2634,20 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       return cand;\n     }\n \n-  for (p = &(cand->second_conv); TREE_CODE (*p) != IDENTITY_CONV; )\n-    p = &(TREE_OPERAND (*p, 0));\n-\n-  *p = build\n+  /* Build the user conversion sequence.  */\n+  convs = build_conv\n     (USER_CONV,\n      (DECL_CONSTRUCTOR_P (cand->fn)\n       ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n-     expr, build_zc_wrapper (cand));\n-  \n-  ICS_USER_FLAG (cand->second_conv) = ICS_USER_FLAG (*p) = 1;\n+     build1 (IDENTITY_CONV, TREE_TYPE (expr), expr));\n+  TREE_OPERAND (convs, 1) = build_zc_wrapper (cand);\n+\n+  /* Combine it with the second conversion sequence.  */\n+  cand->second_conv = merge_conversion_sequences (convs,\n+\t\t\t\t\t\t  cand->second_conv);\n+\n   if (cand->viable == -1)\n-    ICS_BAD_FLAG (cand->second_conv) = ICS_BAD_FLAG (*p) = 1;\n+    ICS_BAD_FLAG (cand->second_conv) = 1;\n \n   return cand;\n }"}, {"sha": "86103c41eef186ee073dbad5c048ed831bec7862", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=3d93842695fa7650032bed46338d3f1339cbb42c", "patch": "@@ -1,8 +1,8 @@\n /* This file contains the definitions and documentation for the\n    additional tree codes used in the GNU C++ compiler (see tree.def\n    for the standard codes).\n-   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1990, 1993, 1997, 1998, 2003, \n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -270,7 +270,13 @@ DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", 'e', 1)\n \n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n-/* And some codes for expressing conversions for overload resolution.  */\n+/* The following codes are used to represent implicit conversion\n+   sequences, in the sense of [over.best.ics].  The conversion\n+   sequences are connected through their first operands, with the\n+   first conversion to be performed at the end of the chain.\n+\n+   The innermost conversion (i.e, the one at the end of the chain) is\n+   always an IDENTITY_CONV, corresponding to the identity conversion.  */\n \n DEFTREECODE (IDENTITY_CONV, \"identity_conv\", 'e', 1)\n DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", 'e', 1)"}, {"sha": "eab85f700504396abefad8e154592a5bd166f746", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=3d93842695fa7650032bed46338d3f1339cbb42c", "patch": "@@ -378,13 +378,8 @@ get_tinfo_decl (tree type)\n static tree\n get_tinfo_ptr (tree type)\n {\n-  tree exp = get_tinfo_decl (type);\n-  \n-   /* Convert to type_info type.  */\n-  exp = build_unary_op (ADDR_EXPR, exp, 0);\n-  exp = ocp_convert (type_info_ptr_type, exp, CONV_REINTERPRET, 0);\n-\n-  return exp;\n+  return build_nop (type_info_ptr_type, \n+\t\t    build_address (get_tinfo_decl (type)));\n }\n \n /* Return the type_info object for TYPE.  */"}, {"sha": "36715896476025c8e23fa777db3025ba15fdc1cc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d93842695fa7650032bed46338d3f1339cbb42c", "patch": "@@ -1,5 +1,7 @@\n 2003-03-06  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* g++.dg/init/ref3.C: New test.\n+\n \tPR c++/9965\n \t* g++.dg/init/ref2.C: New test.\n \t"}, {"sha": "776f2d0c5d225478d6fd36e4111a29b2f4cdaeb2", "filename": "gcc/testsuite/g++.dg/init/ref3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d93842695fa7650032bed46338d3f1339cbb42c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref3.C?ref=3d93842695fa7650032bed46338d3f1339cbb42c", "patch": "@@ -0,0 +1,12 @@\n+struct Base { };\n+struct Derived : public Base { };\n+struct Choose {\n+  operator Base&();\n+  operator Derived&();\n+};\n+\n+void f()\n+{\n+  Choose c;\n+  Base& ref = c;\n+}"}]}