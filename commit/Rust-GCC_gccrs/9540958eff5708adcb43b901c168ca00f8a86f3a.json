{"sha": "9540958eff5708adcb43b901c168ca00f8a86f3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU0MDk1OGVmZjU3MDhhZGNiNDNiOTAxYzE2OGNhMDBmOGE4NmYzYQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-10-20T22:11:40Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-10-20T22:11:40Z"}, "message": "re PR libstdc++/10081 (basic_ios::_M_cache_locale leaves NULL members in the face of unknown locales)\n\n\n2003-10-20  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/10081\n\t* testsuite_hooks.h: Add pod_type, ctype and numpunct specializations.\n\t* testsuite_hooks.cc: Same.\n\t* 22_locale/numpunct/members/pod/1.cc: Edit.\n\t* 22_locale/numpunct/members/pod/2.cc: Same.\n\t* 27_io/basic_istream/sentry/char/3983-fstream.cc: Move ...\n\t* 27_io/basic_istream/sentry/char/3983-sstream.cc: Move ...\n\t* 27_io/basic_istream/extractors_arithmetic/pod/3983-1.cc: Here.\n\t* 27_io/basic_istream/extractors_character/pod/3983-2.cc: Here.\n\t* 27_io/basic_istream/extractors_other/pod/3983-3.cc: Here.\n\t* 27_io/basic_ostream/sentry/char/3983-fstream.cc: Remove.\n\t* 27_io/basic_ostream/sentry/char/3983-sstream.cc: Remove.\n\t* 27_io/basic_istream/sentry/pod/1.cc: New.\n\t* 27_io/basic_ostream/sentry/pod/1.cc: New.\n\t* 21_strings/basic_string/inserters_extractors/pod/10081-in.cc: New.\n\t* 21_strings/basic_string/inserters_extractors/pod/10081-out.cc: New.\n\nFrom-SVN: r72728", "tree": {"sha": "abc2a8445881711de975f687d0dc599d65f7e072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abc2a8445881711de975f687d0dc599d65f7e072"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9540958eff5708adcb43b901c168ca00f8a86f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9540958eff5708adcb43b901c168ca00f8a86f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9540958eff5708adcb43b901c168ca00f8a86f3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9540958eff5708adcb43b901c168ca00f8a86f3a/comments", "author": null, "committer": null, "parents": [{"sha": "ac054e28e69292ed10814619d7c822042b318d0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac054e28e69292ed10814619d7c822042b318d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac054e28e69292ed10814619d7c822042b318d0a"}], "stats": {"total": 1913, "additions": 974, "deletions": 939}, "files": [{"sha": "1493a4deef06def331c583929bbb52526157d4f5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -1,3 +1,22 @@\n+2003-10-20  Benjamin Kosnik  <bkoz@redhat.com>\n+ \n+\tPR libstdc++/10081\n+\t* testsuite_hooks.h: Add pod_type, ctype and numpunct specializations.\n+\t* testsuite_hooks.cc: Same.\n+\t* 22_locale/numpunct/members/pod/1.cc: Edit.\n+\t* 22_locale/numpunct/members/pod/2.cc: Same.\n+\t* 27_io/basic_istream/sentry/char/3983-fstream.cc: Move ...\n+\t* 27_io/basic_istream/sentry/char/3983-sstream.cc: Move ...\n+\t* 27_io/basic_istream/extractors_arithmetic/pod/3983-1.cc: Here.\n+\t* 27_io/basic_istream/extractors_character/pod/3983-2.cc: Here.\n+\t* 27_io/basic_istream/extractors_other/pod/3983-3.cc: Here.\n+\t* 27_io/basic_ostream/sentry/char/3983-fstream.cc: Remove.\n+\t* 27_io/basic_ostream/sentry/char/3983-sstream.cc: Remove.\n+\t* 27_io/basic_istream/sentry/pod/1.cc: New.\n+\t* 27_io/basic_ostream/sentry/pod/1.cc: New.\n+\t* 21_strings/basic_string/inserters_extractors/pod/10081-in.cc: New.\n+\t* 21_strings/basic_string/inserters_extractors/pod/10081-out.cc: New.\n+\n 2003-10-20  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* config/cpu/mips/atomicity.h (__atomic_add): Use _ABIO32 instead"}, {"sha": "05190295f4b097265b8edffd4471c389efeaa1b6", "filename": "libstdc++-v3/include/ext/pod_char_traits.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpod_char_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpod_char_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpod_char_traits.h?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -68,9 +68,12 @@ namespace std\n       // NB: This type should be bigger than char_type, so as to\n       // properly hold EOF values in addition to the full range of\n       // char_type values.\n+      // Also, assumes \n+      // int_type(value_type) is valid.\n+      // int_type(-1) is possible.\n       typedef typename char_type::int_type\tint_type;\n       typedef typename char_type::state_type\tstate_type;\n-      typedef streampos \t\t\tpos_type;\n+      typedef fpos<state_type>\t\t\tpos_type;\n       typedef streamoff \t\t\toff_type;\n       \n       static void "}, {"sha": "fcfcf74be36d3bb4798967712aa9c04ecb58da34", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/pod/10081-in.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Finserters_extractors%2Fpod%2F10081-in.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Finserters_extractors%2Fpod%2F10081-in.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Finserters_extractors%2Fpod%2F10081-in.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,90 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.6.1.1.2 class basic_istream::sentry\n+\n+#include <string>\n+#include <istream>\n+#include <sstream>\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  typedef basic_string<pod_type> \tstring_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_istream<pod_type> \tistream_type;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  string_type str;\n+  stringbuf_type strbuf01;\n+  istream_type stream(&strbuf01);\n+\n+  try\n+    {\n+      stream >> str;\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Ok, throws bad_cast because locale has no ctype facet.\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  const std::locale loc(std::locale::classic(), new std::ctype<pod_type>);\n+  stream.imbue(loc);\n+  try\n+    {\n+      stream >> str;\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "908d9b30d117a37769a617d141bc10ba5a4fb478", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/inserters_extractors/pod/10081-out.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Finserters_extractors%2Fpod%2F10081-out.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Finserters_extractors%2Fpod%2F10081-out.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Finserters_extractors%2Fpod%2F10081-out.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,90 @@\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.6.1.1.2 class basic_istream::sentry\n+\n+#include <string>\n+#include <ostream>\n+#include <sstream>\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  typedef basic_string<pod_type> \tstring_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_ostream<pod_type> \tostream_type;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  string_type str;\n+  stringbuf_type strbuf01;\n+  ostream_type stream(&strbuf01);\n+\n+  try\n+    {\n+      stream << str;\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Ok, throws bad_cast because locale has no ctype facet.\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  const std::locale loc(std::locale::classic(), new std::ctype<pod_type>);\n+  stream.imbue(loc);\n+  try\n+    {\n+      stream << str;\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7ceda98d5467fdfa640323b64197109e3c24a4e2", "filename": "libstdc++-v3/testsuite/22_locale/numpunct/members/pod/1.cc", "status": "modified", "additions": 15, "deletions": 70, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct%2Fmembers%2Fpod%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct%2Fmembers%2Fpod%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct%2Fmembers%2Fpod%2F1.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -25,103 +25,48 @@\n #include <ext/pod_char_traits.h>\n #include <testsuite_hooks.h>\n \n-typedef unsigned short\t\t\t\t\tvalue_type;\n-typedef unsigned int\t\t\t\t\tint_type;\n-typedef __gnu_cxx::character<value_type, int_type>\tpodchar_type;\n-\n-// Member specializations for the existing facet classes.\n-// NB: This isn't especially portable. Perhaps a better way would be\n-// to just specialize all of numpunct and ctype.\n-namespace std\n-{\n-  template<>\n-    void\n-    numpunct<podchar_type>::_M_initialize_numpunct(__c_locale)\n-    {\n-      if (!_M_data)\n-\t_M_data = new __numpunct_cache<podchar_type>;\n-\n-      _M_data->_M_grouping = \"\";\n-      _M_data->_M_use_grouping = false;\n-\n-      _M_data->_M_decimal_point.value =  value_type('.');\n-      _M_data->_M_thousands_sep.value = value_type(',');\n-      \n-      for (size_t i = 0; i < __num_base::_S_oend; ++i)\n-\t{\n-\t  value_type v = __num_base::_S_atoms_out[i];\n-\t  _M_data->_M_atoms_out[i].value = v;\n-\t}\n-      _M_data->_M_atoms_out[__num_base::_S_oend] = podchar_type();\n-      \n-      for (size_t i = 0; i < __num_base::_S_iend; ++i)\n-\t_M_data->_M_atoms_in[i].value = value_type(__num_base::_S_atoms_in[i]);\n-      _M_data->_M_atoms_in[__num_base::_S_iend] = podchar_type();\n-\n-      // \"true\"\n-      podchar_type* __truename = new podchar_type[4 + 1];\n-      __truename[0].value = value_type('t');\n-      __truename[1].value = value_type('r');\n-      __truename[2].value = value_type('u');\n-      __truename[3].value = value_type('e');\n-      __truename[4] = podchar_type();\n-      _M_data->_M_truename = __truename;\n-\n-      // \"false\"\n-      podchar_type* __falsename = new podchar_type[5 + 1];\n-      __falsename[0].value = value_type('f');\n-      __falsename[1].value = value_type('a');\n-      __falsename[2].value = value_type('l');\n-      __falsename[3].value = value_type('s');\n-      __falsename[4].value = value_type('e');\n-      __falsename[5] = podchar_type();\n-      _M_data->_M_falsename = __falsename;\n-    }\n-\n-  template<>\n-    numpunct<podchar_type>::~numpunct()\n-    { delete _M_data; }\n-}\n \n // Check for numpunct and ctype dependencies. Make sure that numpunct\n // can be created without ctype.\n void test01()\n {\n   using namespace std;\n-  typedef numpunct<podchar_type>::string_type \tstring_type;\n-  typedef basic_stringbuf<podchar_type> \tstringbuf_type;\n-  typedef basic_ostream<podchar_type> \t\tostream_type;\n+  using __gnu_test::pod_type;\n+  using __gnu_test::value_type;\n+  typedef numpunct<pod_type>::string_type \tstring_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_ostream<pod_type> \t\tostream_type;\n   \n   bool test __attribute__((unused)) = true;\n \n   // Pre-cache sanity check.\n-  const locale \tloc(locale::classic(), new numpunct<podchar_type>);\n-  const numpunct<podchar_type>& np = use_facet<numpunct<podchar_type> >(loc);\n+  const locale \tloc(locale::classic(), new numpunct<pod_type>);\n+  const numpunct<pod_type>& np = use_facet<numpunct<pod_type> >(loc);\n \n-  podchar_type dp = np.decimal_point();\n-  podchar_type ts = np.thousands_sep();\n+  pod_type dp = np.decimal_point();\n+  pod_type ts = np.thousands_sep();\n   string g = np.grouping();\n   string_type strue = np.truename();\n   string_type sfalse = np.falsename();\n \n-  podchar_type basedp = { value_type('.') };\n-  podchar_type basets = { value_type(',') };\n+  pod_type basedp = { value_type('.') };\n+  pod_type basets = { value_type(',') };\n \n-  string_type basetrue(4, podchar_type());\n+  string_type basetrue(4, pod_type());\n   basetrue[0].value = value_type('t');\n   basetrue[1].value = value_type('r');\n   basetrue[2].value = value_type('u');\n   basetrue[3].value = value_type('e');\n \n-  string_type basefalse(5, podchar_type());\n+  string_type basefalse(5, pod_type());\n   basefalse[0].value = value_type('f');\n   basefalse[1].value = value_type('a');\n   basefalse[2].value = value_type('l');\n   basefalse[3].value = value_type('s');\n   basefalse[4].value = value_type('e');\n \n-  VERIFY( char_traits<podchar_type>::eq(dp, basedp) );\n-  VERIFY( char_traits<podchar_type>::eq(ts, basets) );\n+  VERIFY( char_traits<pod_type>::eq(dp, basedp) );\n+  VERIFY( char_traits<pod_type>::eq(ts, basets) );\n   VERIFY( g == \"\" );\n   VERIFY( strue == basetrue );\n   VERIFY( sfalse == basefalse );"}, {"sha": "bb970369ee34f1fabb6b6f75d8b6252e90aa3fb4", "filename": "libstdc++-v3/testsuite/22_locale/numpunct/members/pod/2.cc", "status": "modified", "additions": 7, "deletions": 157, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct%2Fmembers%2Fpod%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct%2Fmembers%2Fpod%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct%2Fmembers%2Fpod%2F2.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -25,165 +25,15 @@\n #include <ext/pod_char_traits.h>\n #include <testsuite_hooks.h>\n \n-typedef unsigned short\t\t\t\t\tvalue_type;\n-typedef unsigned int\t\t\t\t\tint_type;\n-typedef __gnu_cxx::character<value_type, int_type>\tpodchar_type;\n-\n-// Member specializations for the existing facet classes.\n-// NB: This isn't especially portable. Perhaps a better way would be\n-// to just specialize all of numpunct and ctype.\n-namespace std\n-{\n-  template<>\n-    bool \n-    ctype<podchar_type>::\n-    do_is(mask, char_type) const { return true; }\n-\n-  template<>\n-    const podchar_type*\n-    ctype<podchar_type>::\n-    do_is(const char_type* __lo, const char_type*, mask*) const\n-    { return __lo; }\n-\n-  template<>\n-    const podchar_type*\n-    ctype<podchar_type>::\n-    do_scan_is(mask, const char_type* __lo, const char_type*) const\n-    { return __lo; }\n-\n-  template<>\n-    const podchar_type*\n-    ctype<podchar_type>::\n-    do_scan_not(mask, const char_type* __lo, const char_type*) const\n-    { return __lo; }\n-\n-  template<>\n-    podchar_type \n-    ctype<podchar_type>::\n-    do_toupper(char_type __c) const\n-    { return __c; }\n-\n-  template<>\n-    const podchar_type*\n-    ctype<podchar_type>::\n-    do_toupper(char_type*, const char_type* __hi) const\n-    { return __hi; }\n-\n-  template<>\n-    podchar_type \n-    ctype<podchar_type>::\n-    do_tolower(char_type __c) const\n-    { return __c; }\n-\n-  template<>\n-    const podchar_type*\n-    ctype<podchar_type>::\n-    do_tolower(char_type*, const char_type* __hi) const\n-    { return __hi; }\n-\n-  template<>\n-    podchar_type\n-    ctype<podchar_type>::\n-    do_widen(char __c) const\n-    { \n-      char_type ret = { value_type(__c) };\n-      return ret;\n-    }\n-\n-  template<>\n-    const char*\n-    ctype<podchar_type>::\n-    do_widen(const char* __lo, const char* __hi, char_type* __dest) const\n-    {\n-      while (__lo < __hi)\n-\t{\n-\t  *__dest = this->do_widen(*__lo);\n-\t  ++__lo;\n-\t  ++__dest;\n-\t}\n-      return __hi;\n-    }\n-\n-  template<>\n-    char\n-    ctype<podchar_type>::\n-    do_narrow(char_type __wc, char) const\n-    { return static_cast<char>(__wc.value); }\n-\n-  template<>\n-    const podchar_type*\n-    ctype<podchar_type>::\n-    do_narrow(const podchar_type* __lo, const podchar_type* __hi, \n-\t      char, char* __dest) const\n-    {\n-      while (__lo < __hi)\n-\t{\n-\t  *__dest = this->do_narrow(*__lo, char());\n-\t  ++__lo;\n-\t  ++__dest;\n-\t}\n-      return __hi;\n-    }\n-\n-  template<>\n-    ctype<podchar_type>::~ctype() { }\n-\n-  template<>\n-    void\n-    numpunct<podchar_type>::_M_initialize_numpunct(__c_locale)\n-    {\n-      if (!_M_data)\n-\t_M_data = new __numpunct_cache<podchar_type>;\n-\n-      _M_data->_M_grouping = \"\";\n-      _M_data->_M_use_grouping = false;\n-\n-      _M_data->_M_decimal_point.value =  value_type('.');\n-      _M_data->_M_thousands_sep.value = value_type(',');\n-      \n-      for (size_t i = 0; i < __num_base::_S_oend; ++i)\n-\t{\n-\t  value_type v = __num_base::_S_atoms_out[i];\n-\t  _M_data->_M_atoms_out[i].value = v;\n-\t}\n-      _M_data->_M_atoms_out[__num_base::_S_oend] = podchar_type();\n-      \n-      for (size_t i = 0; i < __num_base::_S_iend; ++i)\n-\t_M_data->_M_atoms_in[i].value = value_type(__num_base::_S_atoms_in[i]);\n-      _M_data->_M_atoms_in[__num_base::_S_iend] = podchar_type();\n-\n-      // \"true\"\n-      podchar_type* __truename = new podchar_type[4 + 1];\n-      __truename[0].value = value_type('t');\n-      __truename[1].value = value_type('r');\n-      __truename[2].value = value_type('u');\n-      __truename[3].value = value_type('e');\n-      __truename[4] = podchar_type();\n-      _M_data->_M_truename = __truename;\n-\n-      // \"false\"\n-      podchar_type* __falsename = new podchar_type[5 + 1];\n-      __falsename[0].value = value_type('f');\n-      __falsename[1].value = value_type('a');\n-      __falsename[2].value = value_type('l');\n-      __falsename[3].value = value_type('s');\n-      __falsename[4].value = value_type('e');\n-      __falsename[5] = podchar_type();\n-      _M_data->_M_falsename = __falsename;\n-    }\n-\n-  template<>\n-    numpunct<podchar_type>::~numpunct()\n-    { delete _M_data; }\n-}\n-\n // Check for numpunct and ctype dependencies. Make sure that numpunct\n // can be created without ctype.\n void test01()\n {\n   using namespace std;\n-  typedef numpunct<podchar_type>::string_type \tstring_type;\n-  typedef basic_ostringstream<podchar_type> \t\tostream_type;\n+  using __gnu_test::pod_type;\n+\n+  typedef numpunct<pod_type>::string_type \tstring_type;\n+  typedef basic_ostringstream<pod_type> \t\tostream_type;\n   \n   bool \t\ttest = true;\n \n@@ -208,7 +58,7 @@ void test01()\n   VERIFY( test );\n \n   // 2: fail, no ctype\n-  const locale \tloc2(loc, new num_put<podchar_type>);\n+  const locale \tloc2(loc, new num_put<pod_type>);\n   os.clear();\n   os.imbue(loc2);\n   try\n@@ -224,7 +74,7 @@ void test01()\n   VERIFY( test );\n \n   // 3: fail, no numpunct\n-  const locale \tloc3(loc, new ctype<podchar_type>);\n+  const locale \tloc3(loc, new ctype<pod_type>);\n   os.clear();\n   os.imbue(loc3);\n   try\n@@ -240,7 +90,7 @@ void test01()\n   VERIFY( test );\n \n   // 4: works.\n-  const locale \tloc4(loc3, new numpunct<podchar_type>);\n+  const locale \tloc4(loc3, new numpunct<pod_type>);\n   os.clear();\n   os.imbue(loc4);\n   try"}, {"sha": "40fc2c415267a6855223614c32bbdeedeaaac609", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/pod/3983-1.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_arithmetic%2Fpod%2F3983-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_arithmetic%2Fpod%2F3983-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_arithmetic%2Fpod%2F3983-1.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,77 @@\n+// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.4.2.1.6 class ios_base::init\n+\n+#include <sstream>\n+#include <typeinfo>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/3983\n+// Sentry uses locale info, so have to try one formatted input/output.\n+void test03()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  using __gnu_test::value_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_istream<pod_type> \tistream_type;\n+\n+  stringbuf_type strbuf01;\n+  istream_type iss(&strbuf01);\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  try \n+    { \n+      int i;\n+      iss >> i;\n+    }\n+  catch (std::bad_cast& obj)\n+    { }\n+  catch (std::exception& obj)\n+    { VERIFY( false ); }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "78b54f6ddbe656edb7502e15253f2556eb8f16c4", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/pod/3983-2.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fpod%2F3983-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fpod%2F3983-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fpod%2F3983-2.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,80 @@\n+// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.4.2.1.6 class ios_base::init\n+\n+#include <sstream>\n+#include <typeinfo>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/3983\n+// Sentry uses locale info, so have to try one formatted input/output.\n+void test03()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  using __gnu_test::value_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_istream<pod_type> \tistream_type;\n+\n+  stringbuf_type strbuf01;\n+  istream_type iss(&strbuf01);\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  // input streams\n+  pod_type arr[6] = { value_type('a'), value_type('b'), \n+\t\t      value_type('c'), value_type('d'), value_type('e') };\n+\n+  try \n+    { \n+      iss >> arr;\n+    }\n+  catch (std::bad_cast& obj)\n+    { }\n+  catch (std::exception& obj)\n+    { VERIFY( false ); }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "888abe7acf57f1e060ccf9f842ee9831b2b891e5", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/pod/3983-3.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fpod%2F3983-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fpod%2F3983-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_other%2Fpod%2F3983-3.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,76 @@\n+// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.4.2.1.6 class ios_base::init\n+\n+#include <sstream>\n+#include <typeinfo>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/3983\n+// Sentry uses locale info, so have to try one formatted input/output.\n+void test03()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  using __gnu_test::value_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_istream<pod_type> \tistream_type;\n+\n+  stringbuf_type strbuf01;\n+  istream_type iss(&strbuf01);\n+\n+  bool test __attribute__((unused)) = true;\n+  \n+  try \n+    { \n+      iss >> std::ws;\n+    }\n+  catch (std::bad_cast& obj)\n+    { }\n+  catch (std::exception& obj)\n+    { VERIFY( false ); }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main()\n+{\n+  test03();\n+  return 0;\n+}"}, {"sha": "d285bc11367105e4297cecd7141895354faa9e6f", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/3983-fstream.cc", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fchar%2F3983-fstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fchar%2F3983-fstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fchar%2F3983-fstream.cc?ref=ac054e28e69292ed10814619d7c822042b318d0a", "patch": "@@ -1,188 +0,0 @@\n-// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// 27.4.2.1.6 class ios_base::init\n-\n-#include <fstream>\n-#include <typeinfo>\n-#include <testsuite_hooks.h>\n-\n-// char_traits specialization\n-namespace std\n-{\n-  template<>\n-    struct char_traits<unsigned char>\n-    {\n-      typedef unsigned char \tchar_type;\n-      // Unsigned as wint_t in unsigned.\n-      typedef unsigned long  \tint_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n-      \n-      static void \n-      assign(char_type& __c1, const char_type& __c2)\n-      { __c1 = __c2; }\n-\n-      static bool \n-      eq(const char_type& __c1, const char_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static bool \n-      lt(const char_type& __c1, const char_type& __c2)\n-      { return __c1 < __c2; }\n-\n-      static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { \n-\tfor (size_t __i = 0; __i < __n; ++__i)\n-\t  if (!eq(__s1[__i], __s2[__i]))\n-\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n-\treturn 0; \n-      }\n-\n-      static size_t\n-      length(const char_type* __s)\n-      { \n-\tconst char_type* __p = __s; \n-\twhile (__p && *__p) \n-\t  ++__p; \n-\treturn (__p - __s); \n-      }\n-\n-      static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a)\n-      { \n-\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n-\t  if (*__p == __a) return __p;\n-\treturn 0;\n-      }\n-\n-      static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a)\n-      { \n-\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n-\t  assign(*__p, __a);\n-        return __s; \n-      }\n-\n-      static char_type \n-      to_char_type(const int_type& __c)\n-      { return char_type(); }\n-\n-      static int_type \n-      to_int_type(const char_type& __c) { return int_type(); }\n-\n-      static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static int_type \n-      eof() { return static_cast<int_type>(-1); }\n-\n-      static int_type \n-      not_eof(const int_type& __c)\n-      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n-    };\n-} // namespace std\n-\n-// libstdc++/3983\n-// Sentry uses locale info, so have to try one formatted input/output.\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  // input streams\n-  std::basic_ifstream<unsigned char> ifs_uc;\n-  unsigned char arr[6] = { 'a', 'b', 'c', 'd', 'e' };\n-  try \n-    { \n-      int i;\n-      ifs_uc >> i;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n-  \n-  try \n-    { \n-      ifs_uc >> arr;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n-  \n-  try \n-    { \n-      ifs_uc >> std::ws;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n- \n-  try \n-    { \n-      std::basic_string<unsigned char> s_uc(arr);\n-      ifs_uc >> s_uc;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n-   \n-  VERIFY( test );\n-}\n-\n-#if !__GXX_WEAK__\n-// Explicitly instantiate for systems with no COMDAT or weak support.\n-template \n-  std::basic_string<unsigned char>::size_type \n-  std::basic_string<unsigned char>::_Rep::_S_max_size;\n-\n-template \n-  unsigned char\n-  std::basic_string<unsigned char>::_Rep::_S_terminal;\n-#endif\n-\n-int main()\n-{\n-  test03();\n-  return 0;\n-}"}, {"sha": "0ae9c80777051bb057e373b598b2422d0fb29ab5", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/3983-sstream.cc", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fchar%2F3983-sstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fchar%2F3983-sstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fchar%2F3983-sstream.cc?ref=ac054e28e69292ed10814619d7c822042b318d0a", "patch": "@@ -1,189 +0,0 @@\n-// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n-\n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// 27.4.2.1.6 class ios_base::init\n-\n-#include <sstream>\n-#include <typeinfo>\n-#include <testsuite_hooks.h>\n-\n-// char_traits specialization\n-namespace std\n-{\n-  template<>\n-    struct char_traits<unsigned char>\n-    {\n-      typedef unsigned char \tchar_type;\n-      // Unsigned as wint_t in unsigned.\n-      typedef unsigned long  \tint_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n-      \n-      static void \n-      assign(char_type& __c1, const char_type& __c2)\n-      { __c1 = __c2; }\n-\n-      static bool \n-      eq(const char_type& __c1, const char_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static bool \n-      lt(const char_type& __c1, const char_type& __c2)\n-      { return __c1 < __c2; }\n-\n-      static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { \n-\tfor (size_t __i = 0; __i < __n; ++__i)\n-\t  if (!eq(__s1[__i], __s2[__i]))\n-\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n-\treturn 0; \n-      }\n-\n-      static size_t\n-      length(const char_type* __s)\n-      { \n-\tconst char_type* __p = __s; \n-\twhile (__p && *__p) \n-\t  ++__p; \n-\treturn (__p - __s); \n-      }\n-\n-      static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a)\n-      { \n-\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n-\t  if (*__p == __a) return __p;\n-\treturn 0;\n-      }\n-\n-      static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a)\n-      { \n-\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n-\t  assign(*__p, __a);\n-        return __s; \n-      }\n-\n-      static char_type \n-      to_char_type(const int_type& __c)\n-      { return char_type(); }\n-\n-      static int_type \n-      to_int_type(const char_type& __c) { return int_type(); }\n-\n-      static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static int_type \n-      eof() { return static_cast<int_type>(-1); }\n-\n-      static int_type \n-      not_eof(const int_type& __c)\n-      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n-    };\n-} // namespace std\n-\n-// libstdc++/3983\n-// Sentry uses locale info, so have to try one formatted input/output.\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  // input streams\n-  std::basic_istringstream<unsigned char> iss_uc;\n-  unsigned char arr[6] = { 'a', 'b', 'c', 'd', 'e' };\n-\n-  try \n-    { \n-      int i;\n-      iss_uc >> i;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n-  \n-  try \n-    { \n-      iss_uc >> arr;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n-  \n-  try \n-    { \n-      iss_uc >> std::ws;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n- \n-  try \n-    { \n-      std::basic_string<unsigned char> s_uc(arr);\n-      iss_uc >> s_uc;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }\n-   \n-  VERIFY( test );\n-}\n-\n-#if !__GXX_WEAK__\n-// Explicitly instantiate for systems with no COMDAT or weak support.\n-template \n-  std::basic_string<unsigned char>::size_type \n-  std::basic_string<unsigned char>::_Rep::_S_max_size;\n-\n-template \n-  unsigned char\n-  std::basic_string<unsigned char>::_Rep::_S_terminal;\n-#endif\n-\n-int main()\n-{\n-  test03();\n-  return 0;\n-}"}, {"sha": "7d89476ac0f7321404043f7b4d55cfa4502631d4", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/sentry/pod/1.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fpod%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fpod%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fsentry%2Fpod%2F1.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,172 @@\n+// 1999-10-14 bkoz\n+\n+// Copyright (C) 1999, 2001, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.6.1.1.2 class basic_istream::sentry\n+\n+#include <istream>\n+#include <sstream>\n+#include <ext/pod_char_traits.h>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  typedef basic_string<pod_type> \tstring_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_istream<pod_type> \tistream_type;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+\n+  const string_type str01;\n+  stringbuf_type strbuf01;\n+  stringbuf_type strbuf02(str01);\n+  istream_type istr01(&strbuf01);\n+  istream_type istr02(&strbuf02);\n+  \n+  // test negatives\n+  try\n+    {\n+      istream_type::sentry sentry01(istr01);\t\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Ok, throws bad_cast because locale has no ctype facet.\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  try\n+    {\n+      istream_type::sentry sentry02(istr01, true);\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Ok, throws bad_cast because locale has no ctype facet.\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  // imbued.\n+  const std::locale loc(std::locale::classic(), new std::ctype<pod_type>);\n+  istr01.imbue(loc);\n+  try\n+    {\n+      istream_type::sentry sentry01(istr01);\t\n+      VERIFY( bool(sentry01) == false ); \n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  try\n+    {\n+      istream_type::sentry sentry02(istr01, true);\n+      VERIFY( bool(sentry02) == false ); \n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  // test positive \n+  try\n+    {\n+      istream_type::sentry sentry03(istr02);\t\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Ok, throws bad_cast because locale has no ctype facet.\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  try\n+    {\n+      istream_type::sentry sentry04(istr02, true);\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Ok, throws bad_cast because locale has no ctype facet.\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  // imbued.\n+  istr02.imbue(loc);\n+  try\n+    {\n+      istr02.clear();\n+      istream_type::sentry sentry03(istr02);\t\n+      // ... as eofbit set.\n+      VERIFY( bool(sentry03) == false ); \n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  try\n+    {\n+      istr02.clear();\n+      istream_type::sentry sentry04(istr02, true);\n+      VERIFY( bool(sentry04) == true ); \n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c37c0048449f80ae8faacefbb696806f2b4defb7", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/sentry/char/3983-fstream.cc", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fchar%2F3983-fstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fchar%2F3983-fstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fchar%2F3983-fstream.cc?ref=ac054e28e69292ed10814619d7c822042b318d0a", "patch": "@@ -1,158 +0,0 @@\n-// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// 27.4.2.1.6 class ios_base::init\n-\n-#include <fstream>\n-#include <typeinfo>\n-#include <testsuite_hooks.h>\n-\n-// char_traits specialization\n-namespace std\n-{\n-  template<>\n-    struct char_traits<unsigned char>\n-    {\n-      typedef unsigned char \tchar_type;\n-      // Unsigned as wint_t in unsigned.\n-      typedef unsigned long  \tint_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n-      \n-      static void \n-      assign(char_type& __c1, const char_type& __c2)\n-      { __c1 = __c2; }\n-\n-      static bool \n-      eq(const char_type& __c1, const char_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static bool \n-      lt(const char_type& __c1, const char_type& __c2)\n-      { return __c1 < __c2; }\n-\n-      static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { \n-\tfor (size_t __i = 0; __i < __n; ++__i)\n-\t  if (!eq(__s1[__i], __s2[__i]))\n-\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n-\treturn 0; \n-      }\n-\n-      static size_t\n-      length(const char_type* __s)\n-      { \n-\tconst char_type* __p = __s; \n-\twhile (__p && *__p) \n-\t  ++__p; \n-\treturn (__p - __s); \n-      }\n-\n-      static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a)\n-      { \n-\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n-\t  if (*__p == __a) return __p;\n-\treturn 0;\n-      }\n-\n-      static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a)\n-      { \n-\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n-\t  assign(*__p, __a);\n-        return __s; \n-      }\n-\n-      static char_type \n-      to_char_type(const int_type& __c)\n-      { return char_type(); }\n-\n-      static int_type \n-      to_int_type(const char_type& __c) { return int_type(); }\n-\n-      static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static int_type \n-      eof() { return static_cast<int_type>(-1); }\n-\n-      static int_type \n-      not_eof(const int_type& __c)\n-      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n-    };\n-} // namespace std\n-\n-// libstdc++/3983\n-// Sentry uses locale info, so have to try one formatted input/output.\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  // output streams\n-  std::basic_ofstream<unsigned char> ofs_uc;\n-  try \n-    { \n-      bool b = true;\n-      ofs_uc << b;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }   \n-  VERIFY( test );\n-}\n-\n-#if !__GXX_WEAK__\n-// Explicitly instantiate for systems with no COMDAT or weak support.\n-template \n-  std::basic_string<unsigned char>::size_type \n-  std::basic_string<unsigned char>::_Rep::_S_max_size;\n-\n-template \n-  unsigned char\n-  std::basic_string<unsigned char>::_Rep::_S_terminal;\n-#endif\n-\n-int main()\n-{\n-  test03();\n-  return 0;\n-}"}, {"sha": "5ace23211d16772ef6b6c87063a82cd90790939b", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/sentry/char/3983-sstream.cc", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fchar%2F3983-sstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac054e28e69292ed10814619d7c822042b318d0a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fchar%2F3983-sstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fchar%2F3983-sstream.cc?ref=ac054e28e69292ed10814619d7c822042b318d0a", "patch": "@@ -1,158 +0,0 @@\n-// 2001-06-05 Benjamin Kosnik  <bkoz@redhat.com>\n-\n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// 27.4.2.1.6 class ios_base::init\n-\n-#include <sstream>\n-#include <typeinfo>\n-#include <testsuite_hooks.h>\n-\n-// char_traits specialization\n-namespace std\n-{\n-  template<>\n-    struct char_traits<unsigned char>\n-    {\n-      typedef unsigned char \tchar_type;\n-      // Unsigned as wint_t in unsigned.\n-      typedef unsigned long  \tint_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n-      \n-      static void \n-      assign(char_type& __c1, const char_type& __c2)\n-      { __c1 = __c2; }\n-\n-      static bool \n-      eq(const char_type& __c1, const char_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static bool \n-      lt(const char_type& __c1, const char_type& __c2)\n-      { return __c1 < __c2; }\n-\n-      static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { \n-\tfor (size_t __i = 0; __i < __n; ++__i)\n-\t  if (!eq(__s1[__i], __s2[__i]))\n-\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n-\treturn 0; \n-      }\n-\n-      static size_t\n-      length(const char_type* __s)\n-      { \n-\tconst char_type* __p = __s; \n-\twhile (__p && *__p) \n-\t  ++__p; \n-\treturn (__p - __s); \n-      }\n-\n-      static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a)\n-      { \n-\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n-\t  if (*__p == __a) return __p;\n-\treturn 0;\n-      }\n-\n-      static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n-\n-      static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a)\n-      { \n-\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n-\t  assign(*__p, __a);\n-        return __s; \n-      }\n-\n-      static char_type \n-      to_char_type(const int_type& __c)\n-      { return char_type(); }\n-\n-      static int_type \n-      to_int_type(const char_type& __c) { return int_type(); }\n-\n-      static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2)\n-      { return __c1 == __c2; }\n-\n-      static int_type \n-      eof() { return static_cast<int_type>(-1); }\n-\n-      static int_type \n-      not_eof(const int_type& __c)\n-      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n-    };\n-} // namespace std\n-\n-// libstdc++/3983\n-// Sentry uses locale info, so have to try one formatted input/output.\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  // output streams\n-  std::basic_ostringstream<unsigned char> oss_uc;\n-  try \n-    { \n-      bool b = true;\n-      oss_uc << b;\n-    }\n-  catch (std::bad_cast& obj)\n-    { }\n-  catch (std::exception& obj)\n-    { test = false; }   \n-  VERIFY( test );\n-}\n-\n-#if !__GXX_WEAK__\n-// Explicitly instantiate for systems with no COMDAT or weak support.\n-template \n-  std::basic_string<unsigned char>::size_type \n-  std::basic_string<unsigned char>::_Rep::_S_max_size;\n-\n-template \n-  unsigned char\n-  std::basic_string<unsigned char>::_Rep::_S_terminal;\n-#endif\n-\n-int main()\n-{\n-  test03();\n-  return 0;\n-}"}, {"sha": "95a168240c480c65c8c7bff1f1237b5e640c4ce5", "filename": "libstdc++-v3/testsuite/27_io/basic_ostream/sentry/pod/1.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fpod%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fpod%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostream%2Fsentry%2Fpod%2F1.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -0,0 +1,128 @@\n+// 1999-10-14 bkoz\n+\n+// Copyright (C) 1999, 2001, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.6.1.1.2 class basic_istream::sentry\n+\n+#include <ostream>\n+#include <sstream>\n+#include <ext/pod_char_traits.h>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  using __gnu_test::pod_type;\n+  typedef basic_string<pod_type> \tstring_type;\n+  typedef basic_stringbuf<pod_type> \tstringbuf_type;\n+  typedef basic_ostream<pod_type> \tostream_type;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+\n+  const string_type str01;\n+  stringbuf_type* strbuf01 = NULL;\n+  stringbuf_type strbuf02(str01);\n+  ostream_type ostr01(strbuf01);\n+  ostream_type ostr02(&strbuf02);\n+  \n+  // test negatives\n+  try\n+    {\n+      ostream_type::sentry sentry01(ostr01);\t\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Not ok, throws bad_cast because locale has no ctype facet,\n+      // but none is needed for ostream::sentry.\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  // imbued.\n+  const std::locale loc(std::locale::classic(), new std::ctype<pod_type>);\n+  ostr01.imbue(loc);\n+  try\n+    {\n+      ostream_type::sentry sentry01(ostr01);\t\n+      VERIFY( bool(sentry01) == false ); \n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  // test positive \n+  try\n+    {\n+      ostream_type::sentry sentry03(ostr02);\t\n+    }\n+  catch (std::bad_cast& obj)\n+    {\n+      // Not ok, throws bad_cast because locale has no ctype facet,\n+      // but none is needed for ostream::sentry.\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  // imbued.\n+  ostr02.clear();\n+  ostr02.imbue(loc);\n+  try\n+    {\n+      ostream_type::sentry sentry03(ostr02);\t\n+      VERIFY( bool(sentry03) == true ); \n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_string<__gnu_test::pod_type>::size_type \n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_max_size;\n+\n+template \n+  __gnu_test::pod_type\n+  std::basic_string<__gnu_test::pod_type>::_Rep::_S_terminal;\n+#endif\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2f4add63f4331fd8f1cb098f9f64ee4ec7d42d87", "filename": "libstdc++-v3/testsuite/testsuite_hooks.cc", "status": "modified", "additions": 153, "deletions": 1, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -215,4 +215,156 @@ namespace __gnu_test\n   unsigned int assignment_operator::throw_on_ = 0;\n   unsigned int destructor::_M_count = 0;\n   int copy_tracker::next_id_ = 0;\n-}; // namespace __cxx_test\n+}; // namespace __gnu_test\n+\n+namespace std\n+{\n+  // Member specializations for the existing facet classes.  \n+  // NB: This isn't especially portable. Perhaps a better way would be\n+  // to just specialize all of numpunct and ctype.\n+  using __gnu_test::int_type;\n+  using __gnu_test::value_type;\n+  using __gnu_test::pod_type;\n+\n+  template<>\n+    bool \n+    ctype<pod_type>::\n+    do_is(mask, char_type) const { return true; }\n+\n+  template<>\n+    const pod_type*\n+    ctype<pod_type>::\n+    do_is(const char_type* __lo, const char_type*, mask*) const\n+    { return __lo; }\n+\n+  template<>\n+    const pod_type*\n+    ctype<pod_type>::\n+    do_scan_is(mask, const char_type* __lo, const char_type*) const\n+    { return __lo; }\n+\n+  template<>\n+    const pod_type*\n+    ctype<pod_type>::\n+    do_scan_not(mask, const char_type* __lo, const char_type*) const\n+    { return __lo; }\n+\n+  template<>\n+    pod_type \n+    ctype<pod_type>::\n+    do_toupper(char_type __c) const\n+    { return __c; }\n+\n+  template<>\n+    const pod_type*\n+    ctype<pod_type>::\n+    do_toupper(char_type*, const char_type* __hi) const\n+    { return __hi; }\n+\n+  template<>\n+    pod_type \n+    ctype<pod_type>::\n+    do_tolower(char_type __c) const\n+    { return __c; }\n+\n+  template<>\n+    const pod_type*\n+    ctype<pod_type>::\n+    do_tolower(char_type*, const char_type* __hi) const\n+    { return __hi; }\n+\n+  template<>\n+    pod_type\n+    ctype<pod_type>::\n+    do_widen(char __c) const\n+    { \n+      char_type ret = { value_type(__c) };\n+      return ret;\n+    }\n+\n+  template<>\n+    const char*\n+    ctype<pod_type>::\n+    do_widen(const char* __lo, const char* __hi, char_type* __dest) const\n+    {\n+      while (__lo < __hi)\n+\t{\n+\t  *__dest = this->do_widen(*__lo);\n+\t  ++__lo;\n+\t  ++__dest;\n+\t}\n+      return __hi;\n+    }\n+\n+  template<>\n+    char\n+    ctype<pod_type>::\n+    do_narrow(char_type __wc, char) const\n+    { return static_cast<char>(__wc.value); }\n+\n+  template<>\n+    const pod_type*\n+    ctype<pod_type>::\n+    do_narrow(const pod_type* __lo, const pod_type* __hi, \n+\t      char, char* __dest) const\n+    {\n+      while (__lo < __hi)\n+\t{\n+\t  *__dest = this->do_narrow(*__lo, char());\n+\t  ++__lo;\n+\t  ++__dest;\n+\t}\n+      return __hi;\n+    }\n+\n+  template<>\n+    ctype<pod_type>::~ctype() { }\n+\n+  template<>\n+    void\n+    numpunct<pod_type>::_M_initialize_numpunct(__c_locale)\n+    {\n+      if (!_M_data)\n+\t_M_data = new __numpunct_cache<pod_type>;\n+\n+      _M_data->_M_grouping = \"\";\n+      _M_data->_M_use_grouping = false;\n+\n+      _M_data->_M_decimal_point.value =  value_type('.');\n+      _M_data->_M_thousands_sep.value = value_type(',');\n+      \n+      for (size_t i = 0; i < __num_base::_S_oend; ++i)\n+\t{\n+\t  value_type v = __num_base::_S_atoms_out[i];\n+\t  _M_data->_M_atoms_out[i].value = v;\n+\t}\n+      _M_data->_M_atoms_out[__num_base::_S_oend] = pod_type();\n+      \n+      for (size_t i = 0; i < __num_base::_S_iend; ++i)\n+\t_M_data->_M_atoms_in[i].value = value_type(__num_base::_S_atoms_in[i]);\n+      _M_data->_M_atoms_in[__num_base::_S_iend] = pod_type();\n+\n+      // \"true\"\n+      pod_type* __truename = new pod_type[4 + 1];\n+      __truename[0].value = value_type('t');\n+      __truename[1].value = value_type('r');\n+      __truename[2].value = value_type('u');\n+      __truename[3].value = value_type('e');\n+      __truename[4] = pod_type();\n+      _M_data->_M_truename = __truename;\n+\n+      // \"false\"\n+      pod_type* __falsename = new pod_type[5 + 1];\n+      __falsename[0].value = value_type('f');\n+      __falsename[1].value = value_type('a');\n+      __falsename[2].value = value_type('l');\n+      __falsename[3].value = value_type('s');\n+      __falsename[4].value = value_type('e');\n+      __falsename[5] = pod_type();\n+      _M_data->_M_falsename = __falsename;\n+    }\n+\n+  template<>\n+    numpunct<pod_type>::~numpunct()\n+    { delete _M_data; }\n+} // namespace std"}, {"sha": "d3755c66f6e1ea461ae0d868ffb1bfa4e60a8529", "filename": "libstdc++-v3/testsuite/testsuite_hooks.h", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9540958eff5708adcb43b901c168ca00f8a86f3a/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h?ref=9540958eff5708adcb43b901c168ca00f8a86f3a", "patch": "@@ -61,13 +61,16 @@\n #include <bits/c++config.h>\n #include <bits/functexcept.h>\n #include <cstddef>\n+#include <locale>\n+#include <ext/pod_char_traits.h>\n+\n #ifdef _GLIBCXX_ASSERT\n # include <cassert>\n # define VERIFY(fn) assert(fn)\n #else\n # define VERIFY(fn) test &= (fn)\n #endif\n-#include <locale>\n+\n #ifdef _GLIBCXX_HAVE_UNISTD_H\n # include <unistd.h>\n #else\n@@ -156,6 +159,10 @@ namespace __gnu_test\n     unsigned long l2;\n   };\n \n+  typedef unsigned short\t\t\t\tvalue_type;\n+  typedef unsigned int\t\t\t\t\tint_type;\n+  typedef __gnu_cxx::character<value_type, int_type>\tpod_type;\n+\n \n   // Counting.\n   struct counter\n@@ -336,51 +343,90 @@ namespace std\n     {\n       typedef __gnu_test::pod_char\tchar_type;\n       typedef __gnu_test::pod_int  \tint_type;\n-      typedef long \t\t\tpos_type;\n-      typedef long \t\t\toff_type;\n       typedef __gnu_test::state   \tstate_type;\n+      typedef fpos<state_type> \t\tpos_type;\n+      typedef streamoff \t\toff_type;\n       \n       static void \n-      assign(char_type& __c1, const char_type& __c2);\n+      assign(char_type& c1, const char_type& c2)\n+      { c1.c = c2.c; }\n \n       static bool \n-      eq(const char_type& __c1, const char_type& __c2);\n+      eq(const char_type& c1, const char_type& c2)\n+      { return c1.c == c2.c; }\n \n       static bool \n-      lt(const char_type& __c1, const char_type& __c2);\n+      lt(const char_type& c1, const char_type& c2)\n+      { return c1.c < c2.c; }\n \n       static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n);\n+      compare(const char_type* s1, const char_type* s2, size_t n)\n+      { return memcmp(s1, s2, n); }\n \n       static size_t\n-      length(const char_type* __s);\n+      length(const char_type* s)\n+      { return strlen(reinterpret_cast<const char*>(s)); }\n \n       static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a);\n+      find(const char_type* s, size_t n, const char_type& a)\n+      { return static_cast<const char_type*>(memchr(s, a.c, n)); }\n \n       static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n);\n+      move(char_type* s1, const char_type* s2, size_t n)\n+      {\n+\tmemmove(s1, s2, n);\n+\treturn s1;\n+      }\n \n       static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n);\n+      copy(char_type* s1, const char_type* s2, size_t n)\n+      {\n+\tmemcpy(s1, s2, n);\n+\treturn s1;\n+      }\n \n       static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a);\n+      assign(char_type* s, size_t n, char_type a)\n+      {\n+\tmemset(s, a.c, n);\n+\treturn s;\n+      }\n \n       static char_type \n-      to_char_type(const int_type& __c);\n+      to_char_type(const int_type& c)\n+      {\n+\tchar_type ret;\n+\tret.c = static_cast<unsigned char>(c.i);\n+\treturn ret;\n+      }\n \n       static int_type \n-      to_int_type(const char_type& __c);\n+      to_int_type(const char_type& c)\n+      {\n+\tint_type ret;\n+\tret.i = c.c;\n+\treturn ret;\n+      }\n \n       static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2);\n+      eq_int_type(const int_type& c1, const int_type& c2)\n+      { return c1.i == c2.i; }\n \n       static int_type \n-      eof();\n+      eof()\n+      {\n+\tint_type n;\n+\tn.i = -10;\n+\treturn n;\n+      }\n \n       static int_type \n-      not_eof(const int_type& __c);\n+      not_eof(const int_type& c)\n+      {\n+\tif (eq_int_type(c, eof()))\n+\t  return int_type();\n+\treturn c;\n+      }\n     };\n } // namespace std\n "}]}