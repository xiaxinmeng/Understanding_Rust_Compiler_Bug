{"sha": "e1b7b0cb2e688fac7793af38a4d805a13e36056b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiN2IwY2IyZTY4OGZhYzc3OTNhZjM4YTRkODA1YTEzZTM2MDU2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:38:00Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:38:00Z"}, "message": "(build_opfncall): Use DECL_CHAIN, not TREE_CHAIN for results from lookup_fnfields.\n\n(build_opfncall): Use DECL_CHAIN, not TREE_CHAIN for results from\nlookup_fnfields.  Always give warning/error on bad code.\n(build_overload_int): New routine.  Break out functionality from\nbuild_overload_value so we can reuse it.\n(build_overload_value): Handle pointer to member functions as value parameters\nfor templates.\n(build_overload_identifier): Since template parameters are shared\namong all instantiations, we have to substitute in the real types in\nTREE_TYPE (parm).\n\nFrom-SVN: r10045", "tree": {"sha": "3dd7e0c44a9ce44749bd48c9f016aa17f16d70a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd7e0c44a9ce44749bd48c9f016aa17f16d70a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1b7b0cb2e688fac7793af38a4d805a13e36056b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b7b0cb2e688fac7793af38a4d805a13e36056b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b7b0cb2e688fac7793af38a4d805a13e36056b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b7b0cb2e688fac7793af38a4d805a13e36056b/comments", "author": null, "committer": null, "parents": [{"sha": "46b49f6ce93f745f05bbb4cba71e736708dc590c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b49f6ce93f745f05bbb4cba71e736708dc590c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b49f6ce93f745f05bbb4cba71e736708dc590c"}], "stats": {"total": 121, "additions": 88, "deletions": 33}, "files": [{"sha": "3fa66c3b656382aaa44679b75f75d70d24ffbb09", "filename": "gcc/cp/method.c", "status": "modified", "additions": 88, "deletions": 33, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b7b0cb2e688fac7793af38a4d805a13e36056b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b7b0cb2e688fac7793af38a4d805a13e36056b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e1b7b0cb2e688fac7793af38a4d805a13e36056b", "patch": "@@ -1,6 +1,6 @@\n /* Handle the hair of processing (but not expanding) inline functions.\n    Also manage function and variable name overloading.\n-   Copyright (C) 1987, 1989, 1992, 1993, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n    This file is part of GNU CC.\n@@ -354,6 +354,32 @@ build_overload_nested_name (decl)\n     }\n }\n \n+/* Encoding for an INTEGER_CST value. */\n+static void\n+build_overload_int (value)\n+     tree value;\n+{\n+  my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n+  if (TYPE_PRECISION (value) == 2 * HOST_BITS_PER_WIDE_INT)\n+    {\n+      if (tree_int_cst_lt (value, integer_zero_node))\n+\t{\n+\t  OB_PUTC ('m');\n+\t  value = build_int_2 (~ TREE_INT_CST_LOW (value),\n+\t\t\t       - TREE_INT_CST_HIGH (value));\n+\t}\n+      if (TREE_INT_CST_HIGH (value)\n+\t  != (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n+\t{\n+\t  /* need to print a DImode value in decimal */\n+\t  sorry (\"conversion of long long as PT parameter\");\n+\t}\n+      /* else fall through to print in smaller mode */\n+    }\n+  /* Wordsize or smaller */\n+  icat (TREE_INT_CST_LOW (value));\n+}\n+\n static void\n build_overload_value (type, value)\n      tree type, value;\n@@ -363,10 +389,17 @@ build_overload_value (type, value)\n     value = TREE_OPERAND (value, 0);\n   my_friendly_assert (TREE_CODE (type) == PARM_DECL, 242);\n   type = TREE_TYPE (type);\n+\n+  if (numeric_output_need_bar)\n+    {\n+      OB_PUTC ('_');\n+      numeric_output_need_bar = 0;\n+    }\n+\n   if (TREE_CODE (type) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n     {\n-      /* Handle a pointer to member as a template instantiation\n+      /* Handle a pointer to data member as a template instantiation\n \t parameter, boy, what fun!  */\n       type = integer_type_node;\n       if (TREE_CODE (value) != INTEGER_CST)\n@@ -376,35 +409,17 @@ build_overload_value (type, value)\n \t}\n     }\n \n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+\n   switch (TREE_CODE (type))\n     {\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n-      {\n-\tmy_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n-\tif (TYPE_PRECISION (value) == 2 * HOST_BITS_PER_WIDE_INT)\n-\t  {\n-\t    if (tree_int_cst_lt (value, integer_zero_node))\n-\t      {\n-\t\tOB_PUTC ('m');\n-\t\tvalue = build_int_2 (~ TREE_INT_CST_LOW (value),\n-\t\t\t\t     - TREE_INT_CST_HIGH (value));\n-\t      }\n-\t    if (TREE_INT_CST_HIGH (value)\n-\t\t!= (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n-\t      {\n-\t\t/* need to print a DImode value in decimal */\n-\t\tsorry (\"conversion of long long as PT parameter\");\n-\t      }\n-\t    /* else fall through to print in smaller mode */\n-\t  }\n-\t/* Wordsize or smaller */\n-\ticat (TREE_INT_CST_LOW (value));\n-\treturn;\n-      }\n     case BOOLEAN_TYPE:\n       {\n-\ticat (TREE_INT_CST_LOW (value));\n+\tbuild_overload_int (value);\n+\tnumeric_output_need_bar = 1;\n \treturn;\n       }\n #ifndef REAL_IS_NOT_DOUBLE\n@@ -451,10 +466,52 @@ build_overload_value (type, value)\n \t      }\n \t  }\n \tOB_PUTCP (digit_buffer);\n+\tnumeric_output_need_bar = 1;\n \treturn;\n       }\n #endif\n     case POINTER_TYPE:\n+      if (TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n+\t  && TREE_CODE (value) != ADDR_EXPR)\n+\t{\n+\t  if (TREE_CODE (value) == CONSTRUCTOR)\n+\t    {\n+\t      /* This is dangerous code, crack built up pointer to members. */\n+\t      tree args = CONSTRUCTOR_ELTS (value);\n+\t      tree a1 = TREE_VALUE (args);\n+\t      tree a2 = TREE_VALUE (TREE_CHAIN (args));\n+\t      tree a3 = CONSTRUCTOR_ELTS (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args))));\n+\t      a3 = TREE_VALUE (a3);\n+\t      STRIP_NOPS (a3);\n+\t      if (TREE_CODE (a1) == INTEGER_CST\n+\t\t  && TREE_CODE (a2) == INTEGER_CST)\n+\t\t{\n+\t\t  build_overload_int (a1);\n+\t\t  OB_PUTC ('_');\n+\t\t  build_overload_int (a2);\n+\t\t  OB_PUTC ('_');\n+\t\t  if (TREE_CODE (a3) == ADDR_EXPR)\n+\t\t    {\n+\t\t      a3 = TREE_OPERAND (a3, 0);\n+\t\t      if (TREE_CODE (a3) == FUNCTION_DECL)\n+\t\t\t{\n+\t\t\t  numeric_output_need_bar = 0;\n+\t\t\t  build_overload_identifier (DECL_ASSEMBLER_NAME (a3));\n+\t\t\t  return;\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (TREE_CODE (a3) == INTEGER_CST)\n+\t\t    {\n+\t\t      OB_PUTC ('i');\n+\t\t      build_overload_int (a3);\n+\t\t      numeric_output_need_bar = 1;\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  sorry (\"template instantiation with pointer to method that is too complex\");\n+\t  return;\n+\t}\n       value = TREE_OPERAND (value, 0);\n       if (TREE_CODE (value) == VAR_DECL)\n \t{\n@@ -509,10 +566,11 @@ build_overload_identifier (name)\n \t    }\n \t  else\n \t    {\n+\t      parm = tsubst (parm, &TREE_VEC_ELT (arglist, 0),\n+\t\t\t     TREE_VEC_LENGTH (arglist), NULL_TREE);\n \t      /* It's a PARM_DECL.  */\n \t      build_overload_name (TREE_TYPE (parm), 0, 0);\n \t      build_overload_value (parm, arg);\n-\t      numeric_output_need_bar = 1;\n \t    }\n \t}\n     }\n@@ -1323,7 +1381,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \n \t      /* Look for an `operator++ (int)'.  If they didn't have\n \t\t one, then we fall back to the old way of doing things.  */\n-\t      for (t = TREE_VALUE (fields1); t ; t = TREE_CHAIN (t))\n+\t      for (t = TREE_VALUE (fields1); t ; t = DECL_CHAIN (t))\n \t\t{\n \t\t  t2 = TYPE_ARG_TYPES (TREE_TYPE (t));\n \t\t  if (TREE_CHAIN (t2) != NULL_TREE\n@@ -1339,12 +1397,9 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t\t  char *op = POSTINCREMENT_EXPR ? \"++\" : \"--\";\n \n \t\t  /* There's probably a LOT of code in the world that\n-\t\t     relies upon this old behavior.  So we'll only give this\n-\t\t     warning when we've been given -pedantic.  A few\n-\t\t     releases after 2.4, we'll convert this to be a pedwarn\n-\t\t     or something else more appropriate.  */\n-\t\t  if (pedantic)\n-\t\t    warning (\"no `operator%s (int)' declared for postfix `%s'\",\n+\t\t     relies upon this old behavior.  */\n+\t\t  if (! flag_traditional)\n+\t\t    pedwarn (\"no `operator%s (int)' declared for postfix `%s', using prefix operator instead\",\n \t\t\t     op, op);\n \t\t  xarg2 = NULL_TREE;\n \t\t  binary_is_unary = 1;"}]}