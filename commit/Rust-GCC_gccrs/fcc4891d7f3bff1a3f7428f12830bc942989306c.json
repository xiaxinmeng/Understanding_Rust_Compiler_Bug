{"sha": "fcc4891d7f3bff1a3f7428f12830bc942989306c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNjNDg5MWQ3ZjNiZmYxYTNmNzQyOGYxMjgzMGJjOTQyOTg5MzA2Yw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-09-30T12:44:39Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-09-30T12:44:39Z"}, "message": "This patch fixes PR97045 - unlimited polymorphic array element selectors.\n\n2020-30-09  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/97045\n\t* trans-array.c (gfc_conv_array_ref): Make sure that the class\n\tdecl is passed to build_array_ref in the case of unlimited\n\tpolymorphic entities.\n\t* trans-expr.c (gfc_conv_derived_to_class): Ensure that array\n\trefs do not preceed the _len component. Free the _len expr.\n\t* trans-stmt.c (trans_associate_var): Reset 'need_len_assign'\n\tfor polymorphic scalars.\n\t* trans.c (gfc_build_array_ref): When the vptr size is used for\n\tspan, multiply by the _len field of unlimited polymorphic\n\tentities, when non-zero.\n\ngcc/testsuite/\n\tPR fortran/97045\n\t* gfortran.dg/select_type_50.f90 : New test.", "tree": {"sha": "b26ee228d65681be27def3adf906e19309b11f08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b26ee228d65681be27def3adf906e19309b11f08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcc4891d7f3bff1a3f7428f12830bc942989306c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcc4891d7f3bff1a3f7428f12830bc942989306c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcc4891d7f3bff1a3f7428f12830bc942989306c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcc4891d7f3bff1a3f7428f12830bc942989306c/comments", "author": null, "committer": null, "parents": [{"sha": "bae974e637421263e8854a69b83284fa6309f9a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae974e637421263e8854a69b83284fa6309f9a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae974e637421263e8854a69b83284fa6309f9a1"}], "stats": {"total": 94, "additions": 91, "deletions": 3}, "files": [{"sha": "998d4d4ed9be9cd77bbf93aafb382f77dd70d539", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fcc4891d7f3bff1a3f7428f12830bc942989306c", "patch": "@@ -3787,7 +3787,20 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n \tdecl = sym->backend_decl;\n     }\n   else if (sym->ts.type == BT_CLASS)\n-    decl = NULL_TREE;\n+    {\n+      if (UNLIMITED_POLY (sym))\n+\t{\n+\t  gfc_expr *class_expr = gfc_find_and_cut_at_last_class_ref (expr);\n+\t  gfc_init_se (&tmpse, NULL);\n+\t  gfc_conv_expr (&tmpse, class_expr);\n+\t  if (!se->class_vptr)\n+\t    se->class_vptr = gfc_class_vptr_get (tmpse.expr);\n+\t  gfc_free_expr (class_expr);\n+\t  decl = tmpse.expr;\n+\t}\n+      else\n+\tdecl = NULL_TREE;\n+    }\n \n   se->expr = build_array_ref (se->expr, offset, decl, se->class_vptr);\n }"}, {"sha": "2c31ec9bf019f9699f0482daeaa9aa7ab0ce3625", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=fcc4891d7f3bff1a3f7428f12830bc942989306c", "patch": "@@ -728,7 +728,7 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t  gfc_expr *len;\n \t  gfc_se se;\n \n-\t  len = gfc_copy_expr (e);\n+\t  len = gfc_find_and_cut_at_last_class_ref (e);\n \t  gfc_add_len_component (len);\n \t  gfc_init_se (&se, NULL);\n \t  gfc_conv_expr (&se, len);\n@@ -739,6 +739,7 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t\t\t\t    integer_zero_node));\n \t  else\n \t    tmp = se.expr;\n+\t  gfc_free_expr (len);\n \t}\n       else\n \ttmp = integer_zero_node;"}, {"sha": "adc6b8fefb56d09d4862c7f428a8f3bb10d24ff1", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fcc4891d7f3bff1a3f7428f12830bc942989306c", "patch": "@@ -2091,6 +2091,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  /* Obtain a temporary class container for the result.  */\n \t  gfc_conv_derived_to_class (&se, e, sym->ts, tmp, false, false);\n \t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n+\t  need_len_assign = false;\n \t}\n       else\n \t{"}, {"sha": "8caa625ab0e878bf0daf9fd5f62a72348c48f393", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=fcc4891d7f3bff1a3f7428f12830bc942989306c", "patch": "@@ -429,7 +429,28 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n   /* If decl or vptr are non-null, pointer arithmetic for the array reference\n      is likely. Generate the 'span' for the array reference.  */\n   if (vptr)\n-    span = gfc_vptr_size_get (vptr);\n+    {\n+      span = gfc_vptr_size_get (vptr);\n+\n+      /* Check if this is an unlimited polymorphic object carrying a character\n+\t payload. In this case, the 'len' field is non-zero.  */\n+      if (decl && GFC_CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t{\n+\t  tmp = gfc_class_len_or_zero_get (decl);\n+\t  if (!integer_zerop (tmp))\n+\t    {\n+\t      tree cond;\n+\t      tree stype = TREE_TYPE (span);\n+\t      tmp = fold_convert (stype, tmp);\n+\t      cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t      logical_type_node, tmp,\n+\t\t\t\t      build_int_cst (stype, 0));\n+\t      tmp = fold_build2 (MULT_EXPR, stype, span, tmp);\n+\t      span = fold_build3_loc (input_location, COND_EXPR, stype,\n+\t\t\t\t      cond, span, tmp);\n+\t    }\n+\t}\n+    }\n   else if (decl)\n     span = get_array_span (type, decl);\n "}, {"sha": "aea1c81fa20f5ce22bf10f2e4a1cb56918c36520", "filename": "gcc/testsuite/gfortran.dg/select_type_50.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_50.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc4891d7f3bff1a3f7428f12830bc942989306c/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_50.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_50.f90?ref=fcc4891d7f3bff1a3f7428f12830bc942989306c", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR97045. The report was for the INTEGER version. Testing\n+! revealed a further bug with the character versions.\n+!\n+! Contributed by Igor Gayday  <igor.gayday@mu.edu>\n+!\n+program test_prg\n+  implicit none\n+  integer :: i\n+  integer, allocatable :: arr(:, :)\n+  character(kind = 1, len = 2), allocatable :: chr(:, :)\n+  character(kind = 4, len = 2), allocatable :: chr4(:, :)\n+\n+  arr = reshape ([(i, i = 1, 9)], [3, 3])\n+  do i = 1, 3\n+    call write_array(arr(1:2, i), i)\n+  end do\n+\n+  chr = reshape([(char (i)//char (i+1), i = 65, 83, 2)], [3, 3])\n+  do i = 1, 3\n+    call write_array (chr(1:2, i), i)\n+  end do\n+\n+  chr4 = reshape([(char (i, kind = 4)//char (i+1, kind = 4), i = 65, 83, 2)], &\n+                 [3, 3])\n+  do i = 1, 3\n+    call write_array (chr4(1:2, i), i)\n+  end do\n+\n+contains\n+\n+  subroutine write_array(array, j)\n+    class(*), intent(in) :: array(:)\n+    integer :: i = 2\n+    integer :: j, k\n+\n+    select type (elem => array(i))\n+      type is (integer)\n+        k = 3*(j-1)+i\n+        if (elem .ne. k) stop 1\n+      type is (character(kind = 1, len = *))\n+        k = 63 + 2*(3*(j-1)+i)\n+        if (elem .ne. char (k)//char (k+1)) print *, elem, \"   \", char (k)//char (k+1)\n+      type is (character(kind = 4, len = *))\n+        k = 63 + 2*(3*(j-1)+i)\n+        if (elem .ne. char (k, kind = 4)//char (k+1, kind = 4)) stop 3\n+    end select\n+\n+  end subroutine\n+\n+end program"}]}