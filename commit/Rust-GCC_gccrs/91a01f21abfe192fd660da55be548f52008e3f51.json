{"sha": "91a01f21abfe192fd660da55be548f52008e3f51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFhMDFmMjFhYmZlMTkyZmQ2NjBkYTU1YmU1NDhmNTIwMDhlM2Y1MQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-05-06T21:11:29Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-05-06T21:11:29Z"}, "message": "re PR tree-optimization/19401 (Trivial loop not unrolled)\n\n\tPR tree-optimization/19401\n\t* tree-flow.h (tree_unroll_loops_completely): Declaration changed.\n\t* tree-ssa-loop-ivcanon.c (enum unroll_level): New.\n\t(estimated_unrolled_size): New function.\n\t(try_unroll_loop_completely, canonicalize_loop_induction_variables,\n\ttree_unroll_loops_completely): Always unroll loops if the code size\n\tdoes not increase.\n\t* tree-ssa-loop.c (tree_complete_unroll): Indicate whether all\n\tloops should be unrolled completely.\n\t(gate_tree_complete_unroll): Run complete unrolling unconditionally.\n\nFrom-SVN: r99334", "tree": {"sha": "7fbe820f0e0b444ff5d1c9867f6355dcd5f85a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fbe820f0e0b444ff5d1c9867f6355dcd5f85a91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91a01f21abfe192fd660da55be548f52008e3f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a01f21abfe192fd660da55be548f52008e3f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a01f21abfe192fd660da55be548f52008e3f51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a01f21abfe192fd660da55be548f52008e3f51/comments", "author": null, "committer": null, "parents": [{"sha": "4fbe4f91ff05cb6f4f9507fde1b63102a117e40f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbe4f91ff05cb6f4f9507fde1b63102a117e40f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbe4f91ff05cb6f4f9507fde1b63102a117e40f"}], "stats": {"total": 113, "additions": 94, "deletions": 19}, "files": [{"sha": "9a94371ef132fa32152824866fc764b7bcf493b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91a01f21abfe192fd660da55be548f52008e3f51", "patch": "@@ -1,3 +1,16 @@\n+2005-05-06  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/19401\n+\t* tree-flow.h (tree_unroll_loops_completely): Declaration changed.\n+\t* tree-ssa-loop-ivcanon.c (enum unroll_level): New.\n+\t(estimated_unrolled_size): New function.\n+\t(try_unroll_loop_completely, canonicalize_loop_induction_variables,\n+\ttree_unroll_loops_completely): Always unroll loops if the code size\n+\tdoes not increase.\n+\t* tree-ssa-loop.c (tree_complete_unroll): Indicate whether all\n+\tloops should be unrolled completely.\n+\t(gate_tree_complete_unroll): Run complete unrolling unconditionally.\n+\n 2005-05-06  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR rtl-optimization/21254"}, {"sha": "fc1456488d2cb5908843a150b08f85e8f7d6646c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=91a01f21abfe192fd660da55be548f52008e3f51", "patch": "@@ -693,7 +693,7 @@ bool empty_block_p (basic_block);\n void tree_ssa_lim (struct loops *);\n void tree_ssa_unswitch_loops (struct loops *);\n void canonicalize_induction_variables (struct loops *);\n-void tree_unroll_loops_completely (struct loops *);\n+void tree_unroll_loops_completely (struct loops *, bool);\n void tree_ssa_iv_optimize (struct loops *);\n \n bool number_of_iterations_exit (struct loop *, edge,"}, {"sha": "c4e64b2635abcd2390e88a6752b35a615a1e63f2", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=91a01f21abfe192fd660da55be548f52008e3f51", "patch": "@@ -55,6 +55,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n #include \"tree-inline.h\"\n \n+/* Specifies types of loops that may be unrolled.  */\n+\n+enum unroll_level\n+{\n+  UL_SINGLE_ITER,\t/* Only loops that exit immediatelly in the first\n+\t\t\t   iteration.  */\n+  UL_NO_GROWTH,\t\t/* Only loops whose unrolling will not cause increase\n+\t\t\t   of code size.  */\n+  UL_ALL\t\t/* All suitable loops.  */\n+};\n+\n /* Adds a canonical induction variable to LOOP iterating NITER times.  EXIT\n    is the exit edge whose condition is replaced.  */\n \n@@ -117,18 +128,43 @@ tree_num_loop_insns (struct loop *loop)\n   return size;\n }\n \n+/* Estimate number of insns of completely unrolled loop.  We assume\n+   that the size of the unrolled loop is decreased in the\n+   following way (the numbers of insns are based on what\n+   estimate_num_insns returns for appropriate statements):\n+\n+   1) exit condition gets removed (2 insns)\n+   2) increment of the control variable gets removed (2 insns)\n+   3) All remaining statements are likely to get simplified\n+      due to constant propagation.  Hard to estimate; just\n+      as a heuristics we decrease the rest by 1/3.\n+\n+   NINSNS is the number of insns in the loop before unrolling.\n+   NUNROLL is the number of times the loop is unrolled.  */\n+\n+static unsigned HOST_WIDE_INT\n+estimated_unrolled_size (unsigned HOST_WIDE_INT ninsns,\n+\t\t\t unsigned HOST_WIDE_INT nunroll)\n+{\n+  HOST_WIDE_INT unr_insns = 2 * ((HOST_WIDE_INT) ninsns - 4) / 3;\n+  if (unr_insns <= 0)\n+    unr_insns = 1;\n+  unr_insns *= (nunroll + 1);\n+\n+  return unr_insns;\n+}\n+\n /* Tries to unroll LOOP completely, i.e. NITER times.  LOOPS is the\n-   loop tree.  COMPLETELY_UNROLL is true if we should unroll the loop\n-   even if it may cause code growth.  EXIT is the exit of the loop\n-   that should be eliminated.  */\n+   loop tree.  UL determines which loops we are allowed to unroll. \n+   EXIT is the exit of the loop that should be eliminated.  */\n \n static bool\n try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n \t\t\t    struct loop *loop,\n \t\t\t    edge exit, tree niter,\n-\t\t\t    bool completely_unroll)\n+\t\t\t    enum unroll_level ul)\n {\n-  unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll;\n+  unsigned HOST_WIDE_INT n_unroll, ninsns, max_unroll, unr_insns;\n   tree old_cond, cond, dont_exit, do_exit;\n \n   if (loop->inner)\n@@ -144,14 +180,33 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n \n   if (n_unroll)\n     {\n-      if (!completely_unroll)\n+      if (ul == UL_SINGLE_ITER)\n \treturn false;\n \n       ninsns = tree_num_loop_insns (loop);\n \n       if (n_unroll * ninsns\n \t  > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS))\n \treturn false;\n+\n+      if (ul == UL_NO_GROWTH)\n+\t{\n+\t  unr_insns = estimated_unrolled_size (ninsns, n_unroll);\n+\t  \n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"  Loop size: %d\\n\", (int) ninsns);\n+\t      fprintf (dump_file, \"  Estimated size after unrolling: %d\\n\",\n+\t\t       (int) unr_insns);\n+\t    }\n+\t  \n+\t  if (unr_insns > ninsns)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Not unrolling loop %d:\\n\", loop->num);\n+\t      return false;\n+\t    }\n+\t}\n     }\n \n   if (exit->flags & EDGE_TRUE_VALUE)\n@@ -194,14 +249,14 @@ try_unroll_loop_completely (struct loops *loops ATTRIBUTE_UNUSED,\n }\n \n /* Adds a canonical induction variable to LOOP if suitable.  LOOPS is the loops\n-   tree.  CREATE_IV is true if we may create a new iv.  COMPLETELY_UNROLL is\n-   true if we should do complete unrolling even if it may cause the code\n-   growth.  If TRY_EVAL is true, we try to determine the number of iterations\n-   of a loop by direct evaluation.  Returns true if cfg is changed.  */\n+   tree.  CREATE_IV is true if we may create a new iv.  UL determines what\n+   which loops we are allowed to completely unroll.  If TRY_EVAL is true, we try\n+   to determine the number of iterations of a loop by direct evaluation. \n+   Returns true if cfg is changed.  */\n \n static bool\n canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n-\t\t\t\t       bool create_iv, bool completely_unroll,\n+\t\t\t\t       bool create_iv, enum unroll_level ul,\n \t\t\t\t       bool try_eval)\n {\n   edge exit = NULL;\n@@ -245,7 +300,7 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n       fprintf (dump_file, \" times.\\n\");\n     }\n \n-  if (try_unroll_loop_completely (loops, loop, exit, niter, completely_unroll))\n+  if (try_unroll_loop_completely (loops, loop, exit, niter, ul))\n     return true;\n \n   if (create_iv)\n@@ -270,7 +325,8 @@ canonicalize_induction_variables (struct loops *loops)\n \n       if (loop)\n \tchanged |= canonicalize_loop_induction_variables (loops, loop,\n-\t\t\t\t\t\t\t  true, false, true);\n+\t\t\t\t\t\t\t  true, UL_SINGLE_ITER,\n+\t\t\t\t\t\t\t  true);\n     }\n \n   /* Clean up the information about numbers of iterations, since brute force\n@@ -281,14 +337,17 @@ canonicalize_induction_variables (struct loops *loops)\n     cleanup_tree_cfg_loop ();\n }\n \n-/* Unroll LOOPS completely if they iterate just few times.  */\n+/* Unroll LOOPS completely if they iterate just few times.  Unless\n+   MAY_INCREASE_SIZE is true, perform the unrolling only if the\n+   size of the code does not increase.  */\n \n void\n-tree_unroll_loops_completely (struct loops *loops)\n+tree_unroll_loops_completely (struct loops *loops, bool may_increase_size)\n {\n   unsigned i;\n   struct loop *loop;\n   bool changed = false;\n+  enum unroll_level ul = may_increase_size ? UL_ALL : UL_NO_GROWTH;\n \n   for (i = 1; i < loops->num; i++)\n     {\n@@ -298,7 +357,7 @@ tree_unroll_loops_completely (struct loops *loops)\n \tcontinue;\n \n       changed |= canonicalize_loop_induction_variables (loops, loop,\n-\t\t\t\t\t\t\tfalse, true,\n+\t\t\t\t\t\t\tfalse, ul,\n \t\t\t\t\t\t\t!flag_tree_loop_ivcanon);\n     }\n "}, {"sha": "f7a96fb2aa72389abf427eeb1fedab814c3bf392", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91a01f21abfe192fd660da55be548f52008e3f51/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=91a01f21abfe192fd660da55be548f52008e3f51", "patch": "@@ -323,13 +323,16 @@ tree_complete_unroll (void)\n   if (!current_loops)\n     return;\n \n-  tree_unroll_loops_completely (current_loops);\n+  tree_unroll_loops_completely (current_loops,\n+\t\t\t\tflag_unroll_loops\n+\t\t\t\t|| flag_peel_loops\n+\t\t\t\t|| optimize >= 3);\n }\n \n static bool\n gate_tree_complete_unroll (void)\n {\n-  return flag_peel_loops || flag_unroll_loops;\n+  return true;\n }\n \n struct tree_opt_pass pass_complete_unroll ="}]}