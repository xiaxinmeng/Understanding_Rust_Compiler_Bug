{"sha": "f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzOGVhNWNiYWY4ZjJhOGNlYzAwYjc0MWU1YjIzYThkYjVjMGY4Mw==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2017-04-27T09:58:27Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2017-04-27T09:58:27Z"}, "message": "re PR middle-end/79665 (gcc's signed (x*x)/200 is slower than clang's)\n\n2017-04-26  Tamar Christina  <tamar.christina@arm.com>\n\n\tPR middle-end/79665\n\t* expr.c (expand_expr_real_2): Move TRUNC_MOD_EXPR, FLOOR_MOD_EXPR,\n\tCEIL_MOD_EXPR, ROUND_MOD_EXPR cases.\n\nFrom-SVN: r247307", "tree": {"sha": "c55de710b6a0aa1539a12b4ac1fb689467099208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c55de710b6a0aa1539a12b4ac1fb689467099208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b63d61f7d1256c255013af6ea4b0f64bdd6d7340"}], "stats": {"total": 110, "additions": 57, "deletions": 53}, "files": [{"sha": "cc202329c7f21a7de622158e0cc0e486f99919b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83", "patch": "@@ -1,3 +1,9 @@\n+2017-04-27  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR middle-end/79665\n+\t* expr.c (expand_expr_real_2): Move TRUNC_MOD_EXPR, FLOOR_MOD_EXPR,\n+\tCEIL_MOD_EXPR, ROUND_MOD_EXPR cases.\n+\n 2017-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/77728"}, {"sha": "c5c50e015ad18db9e64e50471f44f71313a04a1e", "filename": "gcc/expr.c", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f138ea5cbaf8f2a8cec00b741e5b23a8db5c0f83", "patch": "@@ -8792,54 +8792,62 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n+    case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+\n     case TRUNC_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      /* If this is a fixed-point operation, then we cannot use the code\n-\t below because \"expand_divmod\" doesn't support sat/no-sat fixed-point\n-         divisions.   */\n-      if (ALL_FIXED_POINT_MODE_P (mode))\n-\tgoto binop;\n-\n-      if (modifier == EXPAND_STACK_PARM)\n-\ttarget = 0;\n-      /* Possible optimization: compute the dividend with EXPAND_SUM\n-\t then if the divisor is constant can optimize the case\n-\t where some terms of the dividend have coeffs divisible by it.  */\n-      expand_operands (treeop0, treeop1,\n-\t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n-      if (SCALAR_INT_MODE_P (mode)\n-\t  && optimize >= 2\n-\t  && get_range_pos_neg (treeop0) == 1\n-\t  && get_range_pos_neg (treeop1) == 1)\n-\t{\n-\t  /* If both arguments are known to be positive when interpreted\n-\t     as signed, we can expand it as both signed and unsigned\n-\t     division or modulo.  Choose the cheaper sequence in that case.  */\n-\t  bool speed_p = optimize_insn_for_speed_p ();\n-\t  do_pending_stack_adjust ();\n-\t  start_sequence ();\n-\t  rtx uns_ret = expand_divmod (0, code, mode, op0, op1, target, 1);\n-\t  rtx_insn *uns_insns = get_insns ();\n-\t  end_sequence ();\n-\t  start_sequence ();\n-\t  rtx sgn_ret = expand_divmod (0, code, mode, op0, op1, target, 0);\n-\t  rtx_insn *sgn_insns = get_insns ();\n-\t  end_sequence ();\n-\t  unsigned uns_cost = seq_cost (uns_insns, speed_p);\n-\t  unsigned sgn_cost = seq_cost (sgn_insns, speed_p);\n-\t  if (uns_cost < sgn_cost || (uns_cost == sgn_cost && unsignedp))\n-\t    {\n-\t      emit_insn (uns_insns);\n-\t      return uns_ret;\n-\t    }\n-\t  emit_insn (sgn_insns);\n-\t  return sgn_ret;\n-\t}\n-      return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n-\n+     {\n+       /* If this is a fixed-point operation, then we cannot use the code\n+\t  below because \"expand_divmod\" doesn't support sat/no-sat fixed-point\n+\t  divisions.   */\n+       if (ALL_FIXED_POINT_MODE_P (mode))\n+\t goto binop;\n+\n+       if (modifier == EXPAND_STACK_PARM)\n+\t target = 0;\n+       /* Possible optimization: compute the dividend with EXPAND_SUM\n+\t  then if the divisor is constant can optimize the case\n+\t  where some terms of the dividend have coeffs divisible by it.  */\n+       expand_operands (treeop0, treeop1,\n+\t\t\tsubtarget, &op0, &op1, EXPAND_NORMAL);\n+       bool mod_p = code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR\n+\t\t    || code == CEIL_MOD_EXPR || code == ROUND_MOD_EXPR;\n+       if (SCALAR_INT_MODE_P (mode)\n+\t   && optimize >= 2\n+\t   && get_range_pos_neg (treeop0) == 1\n+\t   && get_range_pos_neg (treeop1) == 1)\n+\t {\n+\t   /* If both arguments are known to be positive when interpreted\n+\t      as signed, we can expand it as both signed and unsigned\n+\t      division or modulo.  Choose the cheaper sequence in that case.  */\n+\t   bool speed_p = optimize_insn_for_speed_p ();\n+\t   do_pending_stack_adjust ();\n+\t   start_sequence ();\n+\t   rtx uns_ret = expand_divmod (mod_p, code, mode, op0, op1, target, 1);\n+\t   rtx_insn *uns_insns = get_insns ();\n+\t   end_sequence ();\n+\t   start_sequence ();\n+\t   rtx sgn_ret = expand_divmod (mod_p, code, mode, op0, op1, target, 0);\n+\t   rtx_insn *sgn_insns = get_insns ();\n+\t   end_sequence ();\n+\t   unsigned uns_cost = seq_cost (uns_insns, speed_p);\n+\t   unsigned sgn_cost = seq_cost (sgn_insns, speed_p);\n+\t   if (uns_cost < sgn_cost || (uns_cost == sgn_cost && unsignedp))\n+\t     {\n+\t       emit_insn (uns_insns);\n+\t       return uns_ret;\n+\t     }\n+\t   emit_insn (sgn_insns);\n+\t   return sgn_ret;\n+\t }\n+       return expand_divmod (mod_p, code, mode, op0, op1, target, unsignedp);\n+     }\n     case RDIV_EXPR:\n       goto binop;\n \n@@ -8849,16 +8857,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n       gcc_assert (temp);\n       return temp;\n \n-    case TRUNC_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case CEIL_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-      if (modifier == EXPAND_STACK_PARM)\n-\ttarget = 0;\n-      expand_operands (treeop0, treeop1,\n-\t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n-      return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n-\n     case FIXED_CONVERT_EXPR:\n       op0 = expand_normal (treeop0);\n       if (target == 0 || modifier == EXPAND_STACK_PARM)"}]}