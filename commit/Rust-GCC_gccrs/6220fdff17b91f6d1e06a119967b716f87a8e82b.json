{"sha": "6220fdff17b91f6d1e06a119967b716f87a8e82b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIyMGZkZmYxN2I5MWY2ZDFlMDZhMTE5OTY3YjcxNmY4N2E4ZTgyYg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2015-01-16T13:22:00Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2015-01-16T13:22:00Z"}, "message": "libstdc++: Add POSIX variant of shared_timed_mutex.\n\n\t* include/std/shared_mutex (shared_timed_mutex): Add POSIX-based\n\timplementation.\n\nFrom-SVN: r219737", "tree": {"sha": "604f5cda24b801c16d972fab86dec7713d7a0984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/604f5cda24b801c16d972fab86dec7713d7a0984"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6220fdff17b91f6d1e06a119967b716f87a8e82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6220fdff17b91f6d1e06a119967b716f87a8e82b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6220fdff17b91f6d1e06a119967b716f87a8e82b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6220fdff17b91f6d1e06a119967b716f87a8e82b/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0399a8db1c67b92d8f46c1b71bae910a773a05e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0399a8db1c67b92d8f46c1b71bae910a773a05e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0399a8db1c67b92d8f46c1b71bae910a773a05e9"}], "stats": {"total": 188, "additions": 188, "deletions": 0}, "files": [{"sha": "98b958961551755ab594bb3da223027d6f47bc42", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6220fdff17b91f6d1e06a119967b716f87a8e82b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6220fdff17b91f6d1e06a119967b716f87a8e82b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6220fdff17b91f6d1e06a119967b716f87a8e82b", "patch": "@@ -1,3 +1,8 @@\n+2015-01-16  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* include/std/shared_mutex (shared_timed_mutex): Add POSIX-based\n+\timplementation.\n+\n 2015-01-13  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/64571"}, {"sha": "643768c6f8b27d57abac60127fcc2acc6d56ffa6", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6220fdff17b91f6d1e06a119967b716f87a8e82b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6220fdff17b91f6d1e06a119967b716f87a8e82b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=6220fdff17b91f6d1e06a119967b716f87a8e82b", "patch": "@@ -57,6 +57,188 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// shared_timed_mutex\n   class shared_timed_mutex\n   {\n+#if defined(__GTHREADS_CXX0X)\n+    typedef chrono::system_clock\t__clock_t;\n+\n+    pthread_rwlock_t\t\t\t_M_rwlock;\n+\n+  public:\n+    shared_timed_mutex()\n+    {\n+      int __ret = pthread_rwlock_init(&_M_rwlock, NULL);\n+      if (__ret == ENOMEM)\n+\tthrow bad_alloc();\n+      else if (__ret == EAGAIN)\n+\t__throw_system_error(int(errc::resource_unavailable_try_again));\n+      else if (__ret == EPERM)\n+\t__throw_system_error(int(errc::operation_not_permitted));\n+      // Errors not handled: EBUSY, EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+    }\n+\n+    ~shared_timed_mutex()\n+    {\n+      int __ret __attribute((unused)) = pthread_rwlock_destroy(&_M_rwlock);\n+      // Errors not handled: EBUSY, EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+    }\n+\n+    shared_timed_mutex(const shared_timed_mutex&) = delete;\n+    shared_timed_mutex& operator=(const shared_timed_mutex&) = delete;\n+\n+    // Exclusive ownership\n+\n+    void\n+    lock()\n+    {\n+      int __ret = pthread_rwlock_wrlock(&_M_rwlock);\n+      if (__ret == EDEADLK)\n+\t__throw_system_error(int(errc::resource_deadlock_would_occur));\n+      // Errors not handled: EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+    }\n+\n+    bool\n+    try_lock()\n+    {\n+      int __ret = pthread_rwlock_trywrlock(&_M_rwlock);\n+      if (__ret == EBUSY) return false;\n+      // Errors not handled: EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+      return true;\n+    }\n+\n+    template<typename _Rep, typename _Period>\n+      bool\n+      try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      {\n+\treturn try_lock_until(__clock_t::now() + __rel_time);\n+      }\n+\n+    template<typename _Duration>\n+      bool\n+      try_lock_until(const chrono::time_point<__clock_t, _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tint __ret = pthread_rwlock_timedwrlock(&_M_rwlock, &__ts);\n+\t// On self-deadlock, we just fail to acquire the lock.  Technically,\n+\t// the program violated the precondition.\n+\tif (__ret == ETIMEDOUT || __ret == EDEADLK)\n+\t  return false;\n+\t// Errors not handled: EINVAL\n+\t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+\treturn true;\n+      }\n+\n+    template<typename _Clock, typename _Duration>\n+      bool\n+      try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n+      {\n+\t// DR 887 - Sync unknown clock to known clock.\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __clock_t::time_point __s_entry = __clock_t::now();\n+\tconst auto __delta = __abs_time - __c_entry;\n+\tconst auto __s_atime = __s_entry + __delta;\n+\treturn try_lock_until(__s_atime);\n+      }\n+\n+    void\n+    unlock()\n+    {\n+      int __ret __attribute((unused)) = pthread_rwlock_unlock(&_M_rwlock);\n+      // Errors not handled: EPERM, EBUSY, EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+    }\n+\n+    // Shared ownership\n+\n+    void\n+    lock_shared()\n+    {\n+      int __ret = pthread_rwlock_rdlock(&_M_rwlock);\n+      if (__ret == EDEADLK)\n+\t__throw_system_error(int(errc::resource_deadlock_would_occur));\n+      if (__ret == EAGAIN)\n+\t// Maximum number of read locks has been exceeded.\n+\t__throw_system_error(int(errc::device_or_resource_busy));\n+      // Errors not handled: EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+    }\n+\n+    bool\n+    try_lock_shared()\n+    {\n+      int __ret = pthread_rwlock_tryrdlock(&_M_rwlock);\n+      // If the maximum number of read locks has been exceeded, we just fail\n+      // to acquire the lock.  Unlike for lock(), we are not allowed to throw\n+      // an exception.\n+      if (__ret == EBUSY || __ret == EAGAIN) return false;\n+      // Errors not handled: EINVAL\n+      _GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+      return true;\n+    }\n+\n+    template<typename _Rep, typename _Period>\n+      bool\n+      try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)\n+      {\n+\treturn try_lock_shared_until(__clock_t::now() + __rel_time);\n+      }\n+\n+    template<typename _Duration>\n+      bool\n+      try_lock_shared_until(const chrono::time_point<__clock_t,\n+\t\t\t    _Duration>& __atime)\n+      {\n+\tauto __s = chrono::time_point_cast<chrono::seconds>(__atime);\n+\tauto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t__gthread_time_t __ts =\n+\t  {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\tint __ret = pthread_rwlock_timedrdlock(&_M_rwlock, &__ts);\n+\t// If the maximum number of read locks has been exceeded, or we would\n+\t// deadlock, we just fail to acquire the lock.  Unlike for lock(),\n+\t// we are not allowed to throw an exception.\n+\tif (__ret == ETIMEDOUT || __ret == EAGAIN || __ret == EDEADLK)\n+\t  return false;\n+\t// Errors not handled: EINVAL\n+\t_GLIBCXX_DEBUG_ASSERT(__ret == 0);\n+\treturn true;\n+      }\n+\n+    template<typename _Clock, typename _Duration>\n+      bool\n+      try_lock_shared_until(const chrono::time_point<_Clock,\n+\t\t\t    _Duration>& __abs_time)\n+      {\n+\t// DR 887 - Sync unknown clock to known clock.\n+\tconst typename _Clock::time_point __c_entry = _Clock::now();\n+\tconst __clock_t::time_point __s_entry = __clock_t::now();\n+\tconst auto __delta = __abs_time - __c_entry;\n+\tconst auto __s_atime = __s_entry + __delta;\n+\treturn try_lock_shared_until(__s_atime);\n+      }\n+\n+    void\n+    unlock_shared()\n+    {\n+      unlock();\n+    }\n+\n+#else // defined(__GTHREADS_CXX0X)\n+\n #if _GTHREAD_USE_MUTEX_TIMEDLOCK\n     struct _Mutex : mutex, __timed_mutex_impl<_Mutex>\n     {\n@@ -252,6 +434,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_gate1.notify_one();\n \t}\n     }\n+#endif // !defined(__GTHREADS_CXX0X)\n   };\n #endif // _GLIBCXX_HAS_GTHREADS\n "}]}