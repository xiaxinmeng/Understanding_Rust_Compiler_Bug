{"sha": "6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0ZmNjOTUyMmJiNmQ2NzllZjE5NmM1ZGQzZTY0ZTZkNmYzY2FkNQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-12-21T22:08:17Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-12-21T22:08:17Z"}, "message": "* md.texi (Looping Patterns): New node.\n\nFrom-SVN: r38427", "tree": {"sha": "6c15ea64c60f6f19c0bddf23138756cdc344c96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c15ea64c60f6f19c0bddf23138756cdc344c96c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5/comments", "author": null, "committer": null, "parents": [{"sha": "a60b5209b9e0b2d30e85e6847597a0f473faa2af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a60b5209b9e0b2d30e85e6847597a0f473faa2af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a60b5209b9e0b2d30e85e6847597a0f473faa2af"}], "stats": {"total": 151, "additions": 151, "deletions": 0}, "files": [{"sha": "30f18bedf66d62b1f00b999bca58146d342ce416", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5", "patch": "@@ -1,3 +1,7 @@\n+2000-12-22  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* md.texi (Looping Patterns): New node.\n+\n 2000-12-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc.texi, cpp.texi: Update last-updated dates."}, {"sha": "27b57dc7782163292e2b7519b46e6fbef47c0375", "filename": "gcc/md.texi", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=6e4fcc9522bb6d679ef196c5dd3e64e6d6f3cad5", "patch": "@@ -32,6 +32,7 @@ See the next chapter for information on the C header file.\n * Pattern Ordering::    When the order of patterns makes a difference.\n * Dependent Patterns::  Having one pattern may make you need another.\n * Jump Patterns::       Special considerations for patterns for jump insns.\n+* Looping Patterns::    How to define patterns for special looping insns.\n * Insn Canonicalizations::Canonicalization of Instructions\n * Expander Definitions::Generating a sequence of several RTL insns\n                           for a standard operation.\n@@ -2597,6 +2598,47 @@ table it uses.  Its assembler code normally has no need to use the\n second operand, but you should incorporate it in the RTL pattern so\n that the jump optimizer will not delete the table as unreachable code.\n \n+\n+@cindex @code{decrement_and_branch_until_zero} instruction pattern\n+@item @samp{decrement_and_branch_until_zero}\n+Conditional branch instruction that decrements a register and\n+jumps if the register is non-zero.  Operand 0 is the register to\n+decrement and test; operand 1 is the label to jump to if the\n+register is non-zero.  @xref{Looping Patterns}\n+\n+This optional instruction pattern is only used by the combiner,\n+typically for loops reversed by the loop optimizer when strength\n+reduction is enabled.\n+\n+@cindex @code{doloop_end} instruction pattern\n+@item @samp{doloop_end}\n+Conditional branch instruction that decrements a register and jumps if\n+the register is non-zero.  This instruction takes five operands: Operand\n+0 is the register to decrement and test; operand 1 is the number of loop\n+iterations as a @code{const_int} or @code{const0_rtx} if this cannot be\n+determined until run-time; operand 2 is the actual or estimated maximum\n+number of iterations as a @code{const_int}; operand 3 is the number of\n+enclosed loops as a @code{const_int} (an innermost loop has a value of\n+1); operand 4 is the label to jump to if the register is non-zero.\n+@xref{Looping Patterns}\n+\n+This optional instruction pattern should be defined for machines with\n+low-overhead looping instructions as the loop optimizer will try to\n+modify suitable loops to utilize it.  If nested low-overhead looping is\n+not supported, use a @code{define_expand} (@pxref{Expander Definitions})\n+and make the pattern fail if operand 3 is not @code{const1_rtx}.\n+Similarly, if the actual or estimated maximum number of iterations is\n+too large for this instruction, make it fail.\n+\n+@cindex @code{doloop_begin} instruction pattern\n+@item @samp{doloop_begin}\n+Companion instruction to @code{doloop_end} required for machines that\n+need to perform some initialisation, such as loading special registers\n+used by a low-overhead looping instruction.  If initialisation insns do\n+not always need to be emitted, use a @code{define_expand}\n+(@pxref{Expander Definitions}) and make it fail.\n+\n+\n @cindex @code{canonicalize_funcptr_for_compare} instruction pattern\n @item @samp{canonicalize_funcptr_for_compare}\n Canonicalize the function pointer in operand 1 and store the result\n@@ -3084,6 +3126,111 @@ discussed above, we have the pattern\n The @code{SELECT_CC_MODE} macro on the Sparc returns @code{CC_NOOVmode}\n for comparisons whose argument is a @code{plus}.\n \n+@node Looping Patterns\n+@section Defining Looping Instruction Patterns\n+@cindex looping instruction patterns\n+@cindex defining looping instruction patterns\n+\n+Some machines have special jump instructions that can be utilised to\n+make loops more efficient.  A common example is the 68000 @samp{dbra}\n+instruction which performs a decrement of a register and a branch if the\n+result was greater than zero.  Other machines, in particular digital\n+signal processors (DSPs), have special block repeat instructions to\n+provide low-overhead loop support.  For example, the TI TMS320C3x/C4x\n+DSPs have a block repeat instruction that loads special registers to\n+mark the top and end of a loop and to count the number of loop\n+iterations.  This avoids the need for fetching and executing a\n+@samp{dbra}-like instruction and avoids pipeline stalls asociated with\n+the jump.\n+\n+GNU CC has three special named patterns to support low overhead looping,\n+@samp{decrement_and_branch_until_zero}, @samp{doloop_begin}, and\n+@samp{doloop_end}.  The first pattern,\n+@samp{decrement_and_branch_until_zero}, is not emitted during RTL\n+generation but may be emitted during the instruction combination phase.\n+This requires the assistance of the loop optimizer, using information\n+collected during strength reduction, to reverse a loop to count down to\n+zero.  Some targets also require the loop optimizer to add a\n+@code{REG_NONNEG} note to indicate that the iteration count is always\n+positive.  This is needed if the target performs a signed loop\n+termination test.  For example, the 68000 uses a pattern similar to the\n+following for its @code{dbra} instruction:\n+\n+@smallexample\n+@group\n+(define_insn \"decrement_and_branch_until_zero\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (ge (plus:SI (match_operand:SI 0 \"general_operand\" \"+d*am\")\n+\t\t       (const_int -1))\n+\t      (const_int 0))\n+\t  (label_ref (match_operand 1 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"...\")\n+@end group\n+@end smallexample\n+\n+Note that since the insn is both a jump insn and has an output, it must\n+deal with its own reloads, hence the `m' constraints.  Also note that\n+since this insn is generated by the instruction combination phase\n+combining two sequential insns together into an implicit parallel insn,\n+the iteration counter needs to be biased by the same amount as the\n+decrement operation, in this case -1.  Note that the following similar\n+pattern will not be matched by the combiner.\n+\n+@smallexample\n+@group\n+(define_insn \"decrement_and_branch_until_zero\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (ge (match_operand:SI 0 \"general_operand\" \"+d*am\")\n+\t      (const_int 1))\n+\t  (label_ref (match_operand 1 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"...\")\n+@end group\n+@end smallexample\n+\n+The other two special looping patterns, @samp{doloop_begin} and\n+@samp{doloop_end}, are emitted by the loop optimiser for certain\n+well-behaved loops with a finite number of loop iterations using\n+information collected during strength reduction.  \n+\n+The @samp{doloop_end} pattern describes the actual looping instruction\n+(or the implicit looping operation) and the @samp{doloop_begin} pattern\n+is an optional companion pattern that can be used for initialisation\n+needed for some low-overhead looping instructions.\n+\n+Note that some machines require the actual looping instruction to be\n+emitted at the top of the loop (e.g., the TMS320C3x/C4x DSPs).  Emitting\n+the true RTL for a looping instruction at the top of the loop can cause\n+problems with flow analysis.  So instead, a dummy @code{doloop} insn is\n+emitted at the end of the loop.  The machine dependent reorg pass checks\n+for the presence of this @code{doloop} insn and then searches back to\n+the top of the loop, where it inserts the true looping insn (provided\n+there are no instructions in the loop which would cause problems).  Any\n+additional labels can be emitted at this point.  In addition, if the\n+desired special iteration counter register was not allocated, this\n+machine dependent reorg pass could emit a traditional compare and jump\n+instruction pair.\n+\n+The essential difference between the\n+@samp{decrement_and_branch_until_zero} and the @samp{doloop_end}\n+patterns is that the loop optimizer allocates an additional pseudo\n+register for the latter as an iteration counter.  This pseudo register\n+cannot be used within the loop (i.e., general induction variables cannot\n+be derived from it), however, in many cases the loop induction variable\n+may become redundant and removed by the flow pass.\n+\n+\n @node Insn Canonicalizations\n @section Canonicalization of Instructions\n @cindex canonicalization of instructions"}]}