{"sha": "6be349364986cc95bf8e7691476c197f1ee629ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlMzQ5MzY0OTg2Y2M5NWJmOGU3NjkxNDc2YzE5N2YxZWU2MjllYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-05-20T20:40:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-05-20T20:40:23Z"}, "message": "re PR middle-end/35204 (crash by too deep recursion in DFS tree-ssa-sccvn.c:1898)\n\n2008-05-20  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/35204\n\t* tree-ssa-sccvn.c (extract_and_process_scc_for_name): New\n\thelper, split out from ...\n\t(DFS): ... here.  Make the DFS walk non-recursive.\n\nFrom-SVN: r135676", "tree": {"sha": "44d2fd2620480e5dd3b1cf39816eab963fe4c4b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44d2fd2620480e5dd3b1cf39816eab963fe4c4b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6be349364986cc95bf8e7691476c197f1ee629ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be349364986cc95bf8e7691476c197f1ee629ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be349364986cc95bf8e7691476c197f1ee629ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be349364986cc95bf8e7691476c197f1ee629ea/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4ae405a3508cd881d708465fd9fd167a7cc1c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ae405a3508cd881d708465fd9fd167a7cc1c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ae405a3508cd881d708465fd9fd167a7cc1c28"}], "stats": {"total": 162, "additions": 112, "deletions": 50}, "files": [{"sha": "cdc2b9dd0e0ee48407e0939f5291bf81e161c857", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be349364986cc95bf8e7691476c197f1ee629ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be349364986cc95bf8e7691476c197f1ee629ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6be349364986cc95bf8e7691476c197f1ee629ea", "patch": "@@ -1,3 +1,10 @@\n+2008-05-20  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/35204\n+\t* tree-ssa-sccvn.c (extract_and_process_scc_for_name): New\n+\thelper, split out from ...\n+\t(DFS): ... here.  Make the DFS walk non-recursive.\n+\n 2008-05-20  Sebastian Pop  <sebastian.pop@amd.com>\n \t    Jan Sjodin  <jan.sjodin@amd.com>\n "}, {"sha": "86777c784f0ea0f6a5f8f2ebac7aad7b19b0156f", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 105, "deletions": 50, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be349364986cc95bf8e7691476c197f1ee629ea/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be349364986cc95bf8e7691476c197f1ee629ea/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=6be349364986cc95bf8e7691476c197f1ee629ea", "patch": "@@ -1956,6 +1956,53 @@ process_scc (VEC (tree, heap) *scc)\n     }\n }\n \n+DEF_VEC_O(ssa_op_iter);\n+DEF_VEC_ALLOC_O(ssa_op_iter,heap);\n+\n+/* Pop the components of the found SCC for NAME off the SCC stack\n+   and process them.  Returns true if all went well, false if\n+   we run into resource limits.  */\n+\n+static bool\n+extract_and_process_scc_for_name (tree name)\n+{\n+  VEC (tree, heap) *scc = NULL;\n+  tree x;\n+\n+  /* Found an SCC, pop the components off the SCC stack and\n+     process them.  */\n+  do\n+    {\n+      x = VEC_pop (tree, sccstack);\n+\n+      VN_INFO (x)->on_sccstack = false;\n+      VEC_safe_push (tree, heap, scc, x);\n+    } while (x != name);\n+\n+  /* Bail out of SCCVN in case a SCC turns out to be incredibly large.  */\n+  if (VEC_length (tree, scc)\n+      > (unsigned)PARAM_VALUE (PARAM_SCCVN_MAX_SCC_SIZE))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"WARNING: Giving up with SCCVN due to \"\n+\t\t \"SCC size %u exceeding %u\\n\", VEC_length (tree, scc),\n+\t\t (unsigned)PARAM_VALUE (PARAM_SCCVN_MAX_SCC_SIZE));\n+      return false;\n+    }\n+\n+  if (VEC_length (tree, scc) > 1)\n+    sort_scc (scc);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    print_scc (dump_file, scc);\n+\n+  process_scc (scc);\n+\n+  VEC_free (tree, heap, scc);\n+\n+  return true;\n+}\n+\n /* Depth first search on NAME to discover and process SCC's in the SSA\n    graph.\n    Execution of this algorithm relies on the fact that the SCC's are\n@@ -1966,10 +2013,13 @@ process_scc (VEC (tree, heap) *scc)\n static bool\n DFS (tree name)\n {\n+  VEC(ssa_op_iter, heap) *itervec = NULL;\n+  VEC(tree, heap) *namevec = NULL;\n+  use_operand_p usep = NULL;\n+  tree defstmt, use;\n   ssa_op_iter iter;\n-  use_operand_p usep;\n-  tree defstmt;\n \n+start_over:\n   /* SCC info */\n   VN_INFO (name)->dfsnum = next_dfs_num++;\n   VN_INFO (name)->visited = true;\n@@ -1982,20 +2032,63 @@ DFS (tree name)\n   /* Recursively DFS on our operands, looking for SCC's.  */\n   if (!IS_EMPTY_STMT (defstmt))\n     {\n-      FOR_EACH_PHI_OR_STMT_USE (usep, SSA_NAME_DEF_STMT (name), iter,\n-\t\t\t\tSSA_OP_ALL_USES)\n+      /* Push a new iterator.  */\n+      if (TREE_CODE (defstmt) == PHI_NODE)\n+\tusep = op_iter_init_phiuse (&iter, defstmt, SSA_OP_ALL_USES);\n+      else\n+\tusep = op_iter_init_use (&iter, defstmt, SSA_OP_ALL_USES);\n+    }\n+  else\n+    iter.done = true;\n+\n+  while (1)\n+    {\n+      /* If we are done processing uses of a name, go up the stack\n+\t of iterators and process SCCs as we found them.  */\n+      if (op_iter_done (&iter))\n \t{\n-\t  tree use = USE_FROM_PTR (usep);\n+\t  /* See if we found an SCC.  */\n+\t  if (VN_INFO (name)->low == VN_INFO (name)->dfsnum)\n+\t    if (!extract_and_process_scc_for_name (name))\n+\t      {\n+\t\tVEC_free (tree, heap, namevec);\n+\t\tVEC_free (ssa_op_iter, heap, itervec);\n+\t\treturn false;\n+\t      }\n \n-\t  /* Since we handle phi nodes, we will sometimes get\n-\t     invariants in the use expression.  */\n-\t  if (TREE_CODE (use) != SSA_NAME)\n-\t    continue;\n+\t  /* Check if we are done.  */\n+\t  if (VEC_empty (tree, namevec))\n+\t    {\n+\t      VEC_free (tree, heap, namevec);\n+\t      VEC_free (ssa_op_iter, heap, itervec);\n+\t      return true;\n+\t    }\n+\n+\t  /* Restore the last use walker and continue walking there.  */\n+\t  use = name;\n+\t  name = VEC_pop (tree, namevec);\n+\t  memcpy (&iter, VEC_last (ssa_op_iter, itervec),\n+\t\t  sizeof (ssa_op_iter));\n+\t  VEC_pop (ssa_op_iter, itervec);\n+\t  goto continue_walking;\n+\t}\n \n+      use = USE_FROM_PTR (usep);\n+\n+      /* Since we handle phi nodes, we will sometimes get\n+\t invariants in the use expression.  */\n+      if (TREE_CODE (use) == SSA_NAME)\n+\t{\n \t  if (! (VN_INFO (use)->visited))\n \t    {\n-\t      if (!DFS (use))\n-\t\treturn false;\n+\t      /* Recurse by pushing the current use walking state on\n+\t\t the stack and starting over.  */\n+\t      VEC_safe_push(ssa_op_iter, heap, itervec, &iter);\n+\t      VEC_safe_push(tree, heap, namevec, name);\n+\t      name = use;\n+\t      goto start_over;\n+\n+continue_walking:\n \t      VN_INFO (name)->low = MIN (VN_INFO (name)->low,\n \t\t\t\t\t VN_INFO (use)->low);\n \t    }\n@@ -2006,47 +2099,9 @@ DFS (tree name)\n \t\t\t\t\t VN_INFO (name)->low);\n \t    }\n \t}\n-    }\n-\n-  /* See if we found an SCC.  */\n-  if (VN_INFO (name)->low == VN_INFO (name)->dfsnum)\n-    {\n-      VEC (tree, heap) *scc = NULL;\n-      tree x;\n-\n-      /* Found an SCC, pop the components off the SCC stack and\n-\t process them.  */\n-      do\n-\t{\n-\t  x = VEC_pop (tree, sccstack);\n-\n-\t  VN_INFO (x)->on_sccstack = false;\n-\t  VEC_safe_push (tree, heap, scc, x);\n-\t} while (x != name);\n-\n-      /* Bail out of SCCVN in case a SCC turns out to be incredibly large.  */\n-      if (VEC_length (tree, scc)\n-\t    > (unsigned)PARAM_VALUE (PARAM_SCCVN_MAX_SCC_SIZE))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"WARNING: Giving up with SCCVN due to \"\n-\t\t     \"SCC size %u exceeding %u\\n\", VEC_length (tree, scc),\n-\t\t     (unsigned)PARAM_VALUE (PARAM_SCCVN_MAX_SCC_SIZE));\n-\t  return false;\n-\t}\n \n-      if (VEC_length (tree, scc) > 1)\n-\tsort_scc (scc);\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tprint_scc (dump_file, scc);\n-\n-      process_scc (scc);\n-\n-      VEC_free (tree, heap, scc);\n+      usep = op_iter_next_use (&iter);\n     }\n-\n-  return true;\n }\n \n /* Allocate a value number table.  */"}]}