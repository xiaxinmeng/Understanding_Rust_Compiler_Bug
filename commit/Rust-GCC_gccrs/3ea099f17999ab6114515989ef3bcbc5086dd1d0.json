{"sha": "3ea099f17999ab6114515989ef3bcbc5086dd1d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhMDk5ZjE3OTk5YWI2MTE0NTE1OTg5ZWYzYmNiYzUwODZkZDFkMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-06-14T12:59:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-06-14T12:59:40Z"}, "message": "class.c (dfs_find_final_overrider): Fix logic.\n\n        * class.c (dfs_find_final_overrider): Fix logic.\n\n        * class.c (update_vtable_entry_for_fn): Uncomment optimization to use\n        virtual thunk instead of non-virtual.\n        (get_matching_virtual): Uncomment.\n\n        * pt.c (unify): Don't recurse between the POINTER_TYPE and the\n        OFFSET_TYPE.  If we're adding cv-quals, the extra ones would be on\n        PARM, not ARG.\n\nFrom-SVN: r43372", "tree": {"sha": "7c3f1904152cd04cafdddcd7ed7d7c7d5ffc763f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c3f1904152cd04cafdddcd7ed7d7c7d5ffc763f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ea099f17999ab6114515989ef3bcbc5086dd1d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea099f17999ab6114515989ef3bcbc5086dd1d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ea099f17999ab6114515989ef3bcbc5086dd1d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ea099f17999ab6114515989ef3bcbc5086dd1d0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "630d3d5a68bcb7dd898d5977580dcdca3906a119", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630d3d5a68bcb7dd898d5977580dcdca3906a119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630d3d5a68bcb7dd898d5977580dcdca3906a119"}], "stats": {"total": 97, "additions": 76, "deletions": 21}, "files": [{"sha": "deaa83f5a5b6690d2220d38095272eb0619b2441", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ea099f17999ab6114515989ef3bcbc5086dd1d0", "patch": "@@ -1,3 +1,15 @@\n+2001-06-14  Jason Merrill  <jason_merrill@redhat.com>\n+\n+\t* class.c (dfs_find_final_overrider): Fix logic.\n+\n+\t* class.c (update_vtable_entry_for_fn): Uncomment optimization to use\n+\tvirtual thunk instead of non-virtual.\n+\t(get_matching_virtual): Uncomment.\n+\n+\t* pt.c (unify): Don't recurse between the POINTER_TYPE and the\n+\tOFFSET_TYPE.  If we're adding cv-quals, the extra ones would be on\n+\tPARM, not ARG.\n+\n 2001-06-14  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (dfs_accumulate_vtbl_inits): For case 2 & 3, make sure"}, {"sha": "2ff9d14a9f13b2bd5d5f8f42761520f7a1f095d6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3ea099f17999ab6114515989ef3bcbc5086dd1d0", "patch": "@@ -2567,32 +2567,44 @@ dfs_find_final_overrider (binfo, data)\n \t      ffod->overriding_fn = method;\n \t      ffod->overriding_base = TREE_VALUE (path);\n \t    }\n-\t  /* If we found the same overrider we already have, then\n-\t     we just need to check that we're finding it in the same\n-\t     place.  */\n-\t  else if (ffod->overriding_fn == method)\n+\t  else if (ffod->overriding_fn)\n \t    {\n-\t      if (ffod->overriding_base\n-\t\t  && (!tree_int_cst_equal \n+\t      /* We had a best overrider; let's see how this compares.  */\n+\n+\t      if (ffod->overriding_fn == method\n+\t\t  && (tree_int_cst_equal \n \t\t      (BINFO_OFFSET (TREE_VALUE (path)),\n \t\t       BINFO_OFFSET (ffod->overriding_base))))\n+\t\t/* We found the same overrider we already have, and in the\n+\t\t   same place; it's still the best.  */;\n+\t      else if (strictly_overrides (ffod->overriding_fn, method))\n+\t\t/* The old function overrides this function; it's still the\n+\t\t   best.  */;\n+\t      else if (strictly_overrides (method, ffod->overriding_fn))\n+\t\t{\n+\t\t  /* The new function overrides the old; it's now the\n+\t\t     best.  */\n+\t\t  ffod->overriding_fn = method;\n+\t\t  ffod->overriding_base = TREE_VALUE (path);\n+\t\t}\n+\t      else\n \t\t{\n+\t\t  /* Ambiguous.  */\n \t\t  ffod->candidates \n \t\t    = build_tree_list (NULL_TREE,\n \t\t\t\t       ffod->overriding_fn);\n+\t\t  if (method != ffod->overriding_fn)\n+\t\t    ffod->candidates \n+\t\t      = tree_cons (NULL_TREE, method, ffod->candidates);\n \t\t  ffod->overriding_fn = NULL_TREE;\n \t\t  ffod->overriding_base = NULL_TREE;\n \t\t}\n \t    }\n-\t  /* If there was already an overrider, and it overrides this\n-\t     function, then the old overrider is still the best\n-\t     candidate.  */\n-\t  else if (ffod->overriding_fn\n-\t\t   && strictly_overrides (ffod->overriding_fn,\n-\t\t\t\t\t  method))\n-\t    ;\n \t  else\n \t    {\n+\t      /* We had a list of ambiguous overrides; let's see how this\n+\t\t new one compares.  */\n+\n \t      tree candidates;\n \t      bool incomparable = false;\n \n@@ -2692,7 +2704,6 @@ find_final_overrider (t, binfo, fn)\n   return build_tree_list (ffod.overriding_fn, ffod.overriding_base);\n }\n \n-#if 0\n /* Returns the function from the BINFO_VIRTUALS entry in T which matches\n    the signature of FUNCTION_DECL FN, or NULL_TREE if none.  In other words,\n    the function that the slot in T's primary vtable points to.  */\n@@ -2709,7 +2720,6 @@ get_matching_virtual (t, fn)\n       return BV_FN (f);\n   return NULL_TREE;\n }\n-#endif\n \n /* Update an entry in the vtable for BINFO, which is in the hierarchy\n    dominated by T.  FN has been overriden in BINFO; VIRTUALS points to the\n@@ -2784,10 +2794,6 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n       delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n \t\t\t   BINFO_OFFSET (binfo));\n \n-#if 0\n-      /* Disable this optimization pending an ABI change, or until\n-\t we can force emission of the non-virtual thunk even if we don't\n-\t use it.  */\n       if (! integer_zerop (delta))\n \t{\n \t  /* We'll need a thunk.  But if we have a (perhaps formerly)\n@@ -2810,7 +2816,6 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n \t\t}\n \t    }\n \t}\n-#endif\n     }\n \n   modify_vtable_entry (t, "}, {"sha": "d9fa17fe164a283f29a904560ce6091bada0a3ba", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3ea099f17999ab6114515989ef3bcbc5086dd1d0", "patch": "@@ -8504,7 +8504,7 @@ unify (tparms, targs, parm, arg, strict)\n     return 1;\n \n   if (!(strict & UNIFY_ALLOW_OUTER_LEVEL)\n-      && TYPE_P (arg) && !CP_TYPE_CONST_P (arg))\n+      && TYPE_P (parm) && !CP_TYPE_CONST_P (parm))\n     strict &= ~UNIFY_ALLOW_MORE_CV_QUAL;\n   strict &= ~UNIFY_ALLOW_OUTER_LEVEL;\n   strict &= ~UNIFY_ALLOW_DERIVED;\n@@ -8712,6 +8712,18 @@ unify (tparms, targs, parm, arg, strict)\n \t     level of pointers.  */\n \t  strict |= (strict_in & UNIFY_ALLOW_DERIVED);\n \n+\tif (TREE_CODE (TREE_TYPE (parm)) == OFFSET_TYPE\n+\t    && TREE_CODE (TREE_TYPE (arg)) == OFFSET_TYPE)\n+\t  {\n+\t    /* Avoid getting confused about cv-quals; don't recurse here.\n+\t       Pointers to members should really be just OFFSET_TYPE, not\n+\t       this two-level nonsense... */\n+\n+\t    parm = TREE_TYPE (parm);\n+\t    arg = TREE_TYPE (arg);\n+\t    goto offset;\n+\t  }\n+\n \treturn unify (tparms, targs, TREE_TYPE (parm), \n \t\t      TREE_TYPE (arg), strict);\n       }\n@@ -8864,6 +8876,7 @@ unify (tparms, targs, parm, arg, strict)\n \t\t\t\t    DEDUCE_EXACT, 0, -1);\n \n     case OFFSET_TYPE:\n+    offset:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, TYPE_OFFSET_BASETYPE (parm),"}, {"sha": "6466b7d76ef0016fac803317f1cf3f650139b467", "filename": "gcc/testsuite/g++.old-deja/g++.other/override2.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverride2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverride2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Foverride2.C?ref=3ea099f17999ab6114515989ef3bcbc5086dd1d0", "patch": "@@ -0,0 +1,9 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Jason Merrill 14 Jun 2001 <jason@redhat.com>\n+\n+// Test for diagnosis of missing final overrider.\n+\n+struct A { virtual void f (); };\n+struct B1: virtual A { virtual void f (); };\n+struct B2: virtual A { virtual void f (); };\n+struct C: public B1, public B2 {}; // ERROR - no final overrider"}, {"sha": "ec51d30878d1ed8e221756d6c76c16bae613e7a6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/deduct7.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdeduct7.C?ref=3ea099f17999ab6114515989ef3bcbc5086dd1d0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Jason Merrill 14 Jun 2001 <jason@redhat.com>\n+\n+// Test that deduction can add cv-quals to a pointer-to-member type.\n+\n+struct A;\n+int A::* pi;\n+\n+template <typename T> void f (const T A::*) {}\n+\n+int main ()\n+{\n+  f (pi);\n+}"}, {"sha": "afe57d1cd14789b945b788e684767dca5c20969f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/unify8.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ea099f17999ab6114515989ef3bcbc5086dd1d0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C?ref=3ea099f17999ab6114515989ef3bcbc5086dd1d0", "patch": "@@ -9,10 +9,12 @@\n \n \n template <typename T> void Foo (T const **);\n+template <typename T> void Bar (T const * const *);\n void Foo (int);       // ERROR - candidate\n void Foo (float);     // ERROR - candidate\n \n void baz (int **p1)\n {\n   Foo (p1);   // ERROR - no such function\n+  Bar (p1);   // OK\n }"}]}