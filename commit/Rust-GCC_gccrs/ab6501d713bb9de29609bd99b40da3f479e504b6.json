{"sha": "ab6501d713bb9de29609bd99b40da3f479e504b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2NTAxZDcxM2JiOWRlMjk2MDliZDk5YjQwZGEzZjQ3OWU1MDRiNg==", "commit": {"author": {"name": "Sudakshina Das", "email": "sudi.das@arm.com", "date": "2017-10-04T16:59:40Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2017-10-04T16:59:40Z"}, "message": "[PATCH][AArch64] Add BIC-imm and ORR-imm SIMD pattern\n\nThis patch adds the support for BIC (vector, immediate) and\nORR (vector, immediate) SIMD patterns to the AArch64 backend.\n\nCommitted on behalf of Sudi Das.\n\nReviewed-by: Richard Earnshaw <Richard.Earnshaw@arm.com>\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\ngcc/\n\n\t* config/aarch64/aarch64-protos.h (enum simd_immediate_check): New\n\tcheck type for aarch64_simd_valid_immediate.\n\t(aarch64_output_simd_mov_immediate): Update prototype.\n\t(aarch64_simd_valid_immediate): Update prototype.\n\t* config/aarch64/aarch64-simd.md (orr<mode>3): modified pattern to add\n\tsupport for ORR-immediate.\n\t(and<mode>3): modified pattern to add support for BIC-immediate.\n\t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): Function\n\tnow checks for valid immediate for BIC and ORR based on new enum\n\targument.\n\t(aarch64_output_simd_mov_immediate): Function now used to output\n\tBIC/ORR imm as well based on new enum argument.\n\t* config/aarch64/constraints.md (Do): New vector immediate constraint.\n\t(Db) : Likewise.\n\t* config/aarch64/predicates.md (aarch64_reg_or_orr_imm): New predicate.\n\t(aarch64_reg_or_bic_imm): Likewise.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/bic_imm_1.c: New test.\n\t* gcc.target/aarch64/orr_imm_1.c: Likewise.\n\nFrom-SVN: r253422", "tree": {"sha": "97297f308bbbc9787451edba999be6621050b15a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97297f308bbbc9787451edba999be6621050b15a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab6501d713bb9de29609bd99b40da3f479e504b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6501d713bb9de29609bd99b40da3f479e504b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab6501d713bb9de29609bd99b40da3f479e504b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6501d713bb9de29609bd99b40da3f479e504b6/comments", "author": {"login": "sudakshina-das-arm", "id": 28538945, "node_id": "MDQ6VXNlcjI4NTM4OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/28538945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudakshina-das-arm", "html_url": "https://github.com/sudakshina-das-arm", "followers_url": "https://api.github.com/users/sudakshina-das-arm/followers", "following_url": "https://api.github.com/users/sudakshina-das-arm/following{/other_user}", "gists_url": "https://api.github.com/users/sudakshina-das-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudakshina-das-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudakshina-das-arm/subscriptions", "organizations_url": "https://api.github.com/users/sudakshina-das-arm/orgs", "repos_url": "https://api.github.com/users/sudakshina-das-arm/repos", "events_url": "https://api.github.com/users/sudakshina-das-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/sudakshina-das-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b419102c126ef6fa1b80566bbe9cb299ef860432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b419102c126ef6fa1b80566bbe9cb299ef860432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b419102c126ef6fa1b80566bbe9cb299ef860432"}], "stats": {"total": 235, "additions": 177, "deletions": 58}, "files": [{"sha": "2046e349a80049ae1fd5b13960b870754e229797", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -1,3 +1,22 @@\n+2017-10-04  Sudakshina Das  <sudi.das@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (enum simd_immediate_check): New\n+\tcheck type for aarch64_simd_valid_immediate.\n+\t(aarch64_output_simd_mov_immediate): Update prototype.\n+\t(aarch64_simd_valid_immediate): Update prototype.\n+\t* config/aarch64/aarch64-simd.md (orr<mode>3): modified pattern to add\n+\tsupport for ORR-immediate.\n+\t(and<mode>3): modified pattern to add support for BIC-immediate.\n+\t* config/aarch64/aarch64.c (aarch64_simd_valid_immediate): Function\n+\tnow checks for valid immediate for BIC and ORR based on new enum\n+\targument.\n+\t(aarch64_output_simd_mov_immediate): Function now used to output\n+\tBIC/ORR imm as well based on new enum argument.\n+\t* config/aarch64/constraints.md (Do): New vector immediate constraint.\n+\t(Db) : Likewise.\n+\t* config/aarch64/predicates.md (aarch64_reg_or_orr_imm): New predicate.\n+\t(aarch64_reg_or_bic_imm): Likewise.\n+\n 2017-10-04  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/vx-builtins.md (\"vec_mergeh<mode>\")"}, {"sha": "5d7c5dfc6902b5e208bb9ebef758e0bd00b60561", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -308,6 +308,16 @@ enum aarch64_parse_opt_result\n   AARCH64_PARSE_INVALID_ARG\t\t/* Invalid arch, tune, cpu arg.  */\n };\n \n+/* Enum to distinguish which type of check is to be done in\n+   aarch64_simd_valid_immediate.  This is used as a bitmask where\n+   AARCH64_CHECK_MOV has both bits set.  Thus AARCH64_CHECK_MOV will\n+   perform all checks.  Adding new types would require changes accordingly.  */\n+enum simd_immediate_check {\n+  AARCH64_CHECK_ORR  = 1 << 0,\n+  AARCH64_CHECK_BIC  = 1 << 1,\n+  AARCH64_CHECK_MOV  = AARCH64_CHECK_ORR | AARCH64_CHECK_BIC\n+};\n+\n extern struct tune_params aarch64_tune_params;\n \n HOST_WIDE_INT aarch64_initial_elimination_offset (unsigned, unsigned);\n@@ -345,7 +355,8 @@ bool aarch64_mov_operand_p (rtx, machine_mode);\n rtx aarch64_reverse_mask (machine_mode);\n bool aarch64_offset_7bit_signed_scaled_p (machine_mode, HOST_WIDE_INT);\n char *aarch64_output_scalar_simd_mov_immediate (rtx, scalar_int_mode);\n-char *aarch64_output_simd_mov_immediate (rtx, machine_mode, unsigned);\n+char *aarch64_output_simd_mov_immediate (rtx, machine_mode, unsigned,\n+\t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);\n bool aarch64_pad_reg_upward (machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n bool aarch64_regno_ok_for_index_p (int, bool);\n@@ -356,7 +367,8 @@ bool aarch64_simd_imm_zero_p (rtx, machine_mode);\n bool aarch64_simd_scalar_immediate_valid_for_move (rtx, scalar_int_mode);\n bool aarch64_simd_shift_imm_p (rtx, machine_mode, bool);\n bool aarch64_simd_valid_immediate (rtx, machine_mode, bool,\n-\t\t\t\t   struct simd_immediate_info *);\n+\t\t\tstruct simd_immediate_info *,\n+\t\t\tenum simd_immediate_check w = AARCH64_CHECK_MOV);\n bool aarch64_split_dimode_const_store (rtx, rtx);\n bool aarch64_symbolic_address_p (rtx);\n bool aarch64_uimm12_shift (HOST_WIDE_INT);"}, {"sha": "12da8be73e83d0325879c23a86a28ad3f9c84e77", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -558,21 +558,45 @@\n   [(set_attr \"type\" \"neon_fp_abd_<stype><q>\")]\n )\n \n+;; For AND (vector, register) and BIC (vector, immediate)\n (define_insn \"and<mode>3\"\n-  [(set (match_operand:VDQ_I 0 \"register_operand\" \"=w\")\n-        (and:VDQ_I (match_operand:VDQ_I 1 \"register_operand\" \"w\")\n-\t\t (match_operand:VDQ_I 2 \"register_operand\" \"w\")))]\n+  [(set (match_operand:VDQ_I 0 \"register_operand\" \"=w,w\")\n+\t(and:VDQ_I (match_operand:VDQ_I 1 \"register_operand\" \"w,0\")\n+\t\t   (match_operand:VDQ_I 2 \"aarch64_reg_or_bic_imm\" \"w,Db\")))]\n   \"TARGET_SIMD\"\n-  \"and\\t%0.<Vbtype>, %1.<Vbtype>, %2.<Vbtype>\"\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+\treturn \"and\\t%0.<Vbtype>, %1.<Vbtype>, %2.<Vbtype>\";\n+      case 1:\n+\treturn aarch64_output_simd_mov_immediate (operands[2],\n+\t   <MODE>mode, GET_MODE_BITSIZE (<MODE>mode), AARCH64_CHECK_BIC);\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n   [(set_attr \"type\" \"neon_logic<q>\")]\n )\n \n+;; For ORR (vector, register) and ORR (vector, immediate)\n (define_insn \"ior<mode>3\"\n-  [(set (match_operand:VDQ_I 0 \"register_operand\" \"=w\")\n-        (ior:VDQ_I (match_operand:VDQ_I 1 \"register_operand\" \"w\")\n-\t\t (match_operand:VDQ_I 2 \"register_operand\" \"w\")))]\n+  [(set (match_operand:VDQ_I 0 \"register_operand\" \"=w,w\")\n+\t(ior:VDQ_I (match_operand:VDQ_I 1 \"register_operand\" \"w,0\")\n+\t\t   (match_operand:VDQ_I 2 \"aarch64_reg_or_orr_imm\" \"w,Do\")))]\n   \"TARGET_SIMD\"\n-  \"orr\\t%0.<Vbtype>, %1.<Vbtype>, %2.<Vbtype>\"\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+\treturn \"orr\\t%0.<Vbtype>, %1.<Vbtype>, %2.<Vbtype>\";\n+      case 1:\n+\treturn aarch64_output_simd_mov_immediate (operands[2],\n+\t\t<MODE>mode, GET_MODE_BITSIZE (<MODE>mode), AARCH64_CHECK_ORR);\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n   [(set_attr \"type\" \"neon_logic<q>\")]\n )\n "}, {"sha": "ee98a1f822827cec610cc28b17f199b77192785e", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 83, "deletions": 48, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -11483,7 +11483,8 @@ aarch64_vect_float_const_representable_p (rtx x)\n /* Return true for valid and false for invalid.  */\n bool\n aarch64_simd_valid_immediate (rtx op, machine_mode mode, bool inverse,\n-\t\t\t      struct simd_immediate_info *info)\n+\t\t\t      struct simd_immediate_info *info,\n+\t\t\t      enum simd_immediate_check which)\n {\n #define CHECK(STRIDE, ELSIZE, CLASS, TEST, SHIFT, NEG)\t\\\n   matches = 1;\t\t\t\t\t\t\\\n@@ -11551,54 +11552,65 @@ aarch64_simd_valid_immediate (rtx op, machine_mode mode, bool inverse,\n \n   do\n     {\n-      CHECK (4, 32, 0, bytes[i] == bytes[0] && bytes[i + 1] == 0\n-\t     && bytes[i + 2] == 0 && bytes[i + 3] == 0, 0, 0);\n+      if (which & AARCH64_CHECK_ORR)\n+\t{\n+\t  CHECK (4, 32, 0, bytes[i] == bytes[0] && bytes[i + 1] == 0\n+\t\t && bytes[i + 2] == 0 && bytes[i + 3] == 0, 0, 0);\n \n-      CHECK (4, 32, 1, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n-\t     && bytes[i + 2] == 0 && bytes[i + 3] == 0, 8, 0);\n+\t  CHECK (4, 32, 1, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n+\t\t && bytes[i + 2] == 0 && bytes[i + 3] == 0, 8, 0);\n \n-      CHECK (4, 32, 2, bytes[i] == 0 && bytes[i + 1] == 0\n-\t     && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0, 16, 0);\n+\t  CHECK (4, 32, 2, bytes[i] == 0 && bytes[i + 1] == 0\n+\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0, 16, 0);\n \n-      CHECK (4, 32, 3, bytes[i] == 0 && bytes[i + 1] == 0\n-\t     && bytes[i + 2] == 0 && bytes[i + 3] == bytes[3], 24, 0);\n+\t  CHECK (4, 32, 3, bytes[i] == 0 && bytes[i + 1] == 0\n+\t\t && bytes[i + 2] == 0 && bytes[i + 3] == bytes[3], 24, 0);\n \n-      CHECK (2, 16, 4, bytes[i] == bytes[0] && bytes[i + 1] == 0, 0, 0);\n+\t  CHECK (2, 16, 4, bytes[i] == bytes[0] && bytes[i + 1] == 0, 0, 0);\n \n-      CHECK (2, 16, 5, bytes[i] == 0 && bytes[i + 1] == bytes[1], 8, 0);\n+\t  CHECK (2, 16, 5, bytes[i] == 0 && bytes[i + 1] == bytes[1], 8, 0);\n+\t}\n \n-      CHECK (4, 32, 6, bytes[i] == bytes[0] && bytes[i + 1] == 0xff\n-\t     && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 0, 1);\n+      if (which & AARCH64_CHECK_BIC)\n+\t{\n+\t  CHECK (4, 32, 6, bytes[i] == bytes[0] && bytes[i + 1] == 0xff\n+\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 0, 1);\n \n-      CHECK (4, 32, 7, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n-\t     && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 8, 1);\n+\t  CHECK (4, 32, 7, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n+\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 8, 1);\n \n-      CHECK (4, 32, 8, bytes[i] == 0xff && bytes[i + 1] == 0xff\n-\t     && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff, 16, 1);\n+\t  CHECK (4, 32, 8, bytes[i] == 0xff && bytes[i + 1] == 0xff\n+\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff, 16, 1);\n \n-      CHECK (4, 32, 9, bytes[i] == 0xff && bytes[i + 1] == 0xff\n-\t     && bytes[i + 2] == 0xff && bytes[i + 3] == bytes[3], 24, 1);\n+\t  CHECK (4, 32, 9, bytes[i] == 0xff && bytes[i + 1] == 0xff\n+\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == bytes[3], 24, 1);\n \n-      CHECK (2, 16, 10, bytes[i] == bytes[0] && bytes[i + 1] == 0xff, 0, 1);\n+\t  CHECK (2, 16, 10, bytes[i] == bytes[0] && bytes[i + 1] == 0xff, 0, 1);\n \n-      CHECK (2, 16, 11, bytes[i] == 0xff && bytes[i + 1] == bytes[1], 8, 1);\n+\t  CHECK (2, 16, 11, bytes[i] == 0xff && bytes[i + 1] == bytes[1], 8, 1);\n+\t}\n \n-      CHECK (4, 32, 12, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n-\t     && bytes[i + 2] == 0 && bytes[i + 3] == 0, 8, 0);\n+      /* Shifting ones / 8-bit / 64-bit variants only checked\n+\t for 'ALL' (MOVI/MVNI).  */\n+      if (which == AARCH64_CHECK_MOV)\n+\t{\n+\t  CHECK (4, 32, 12, bytes[i] == 0xff && bytes[i + 1] == bytes[1]\n+\t\t && bytes[i + 2] == 0 && bytes[i + 3] == 0, 8, 0);\n \n-      CHECK (4, 32, 13, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n-\t     && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 8, 1);\n+\t  CHECK (4, 32, 13, bytes[i] == 0 && bytes[i + 1] == bytes[1]\n+\t\t && bytes[i + 2] == 0xff && bytes[i + 3] == 0xff, 8, 1);\n \n-      CHECK (4, 32, 14, bytes[i] == 0xff && bytes[i + 1] == 0xff\n-\t     && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0, 16, 0);\n+\t  CHECK (4, 32, 14, bytes[i] == 0xff && bytes[i + 1] == 0xff\n+\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0, 16, 0);\n \n-      CHECK (4, 32, 15, bytes[i] == 0 && bytes[i + 1] == 0\n-\t     && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff, 16, 1);\n+\t  CHECK (4, 32, 15, bytes[i] == 0 && bytes[i + 1] == 0\n+\t\t && bytes[i + 2] == bytes[2] && bytes[i + 3] == 0xff, 16, 1);\n \n-      CHECK (1, 8, 16, bytes[i] == bytes[0], 0, 0);\n+\t  CHECK (1, 8, 16, bytes[i] == bytes[0], 0, 0);\n \n-      CHECK (1, 64, 17, (bytes[i] == 0 || bytes[i] == 0xff)\n-\t     && bytes[i] == bytes[(i + 8) % idx], 0, 0);\n+\t  CHECK (1, 64, 17, (bytes[i] == 0 || bytes[i] == 0xff)\n+\t\t && bytes[i] == bytes[(i + 8) % idx], 0, 0);\n+\t}\n     }\n   while (0);\n \n@@ -13000,10 +13012,14 @@ aarch64_float_const_representable_p (rtx x)\n   return (exponent >= 0 && exponent <= 7);\n }\n \n+/* Returns the string with the instruction for AdvSIMD MOVI, MVNI, ORR or BIC\n+   immediate with a CONST_VECTOR of MODE and WIDTH.  WHICH selects whether to\n+   output MOVI/MVNI, ORR or BIC immediate.  */\n char*\n aarch64_output_simd_mov_immediate (rtx const_vector,\n \t\t\t\t   machine_mode mode,\n-\t\t\t\t   unsigned width)\n+\t\t\t\t   unsigned width,\n+\t\t\t\t   enum simd_immediate_check which)\n {\n   bool is_valid;\n   static char templ[40];\n@@ -13015,9 +13031,11 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n   struct simd_immediate_info info = { NULL_RTX, 0, 0, false, false };\n \n   /* This will return true to show const_vector is legal for use as either\n-     a AdvSIMD MOVI instruction (or, implicitly, MVNI) immediate.  It will\n-     also update INFO to show how the immediate should be generated.  */\n-  is_valid = aarch64_simd_valid_immediate (const_vector, mode, false, &info);\n+     a AdvSIMD MOVI instruction (or, implicitly, MVNI), ORR or BIC immediate.\n+     It will also update INFO to show how the immediate should be generated.\n+     WHICH selects whether to check for MOVI/MVNI, ORR or BIC.  */\n+  is_valid = aarch64_simd_valid_immediate (const_vector, mode, false,\n+\t\t\t\t\t   &info, which);\n   gcc_assert (is_valid);\n \n   element_char = sizetochar (info.element_width);\n@@ -13048,20 +13066,37 @@ aarch64_output_simd_mov_immediate (rtx const_vector,\n \t}\n     }\n \n-  mnemonic = info.mvn ? \"mvni\" : \"movi\";\n-  shift_op = info.msl ? \"msl\" : \"lsl\";\n-\n   gcc_assert (CONST_INT_P (info.value));\n-  if (lane_count == 1)\n-    snprintf (templ, sizeof (templ), \"%s\\t%%d0, \" HOST_WIDE_INT_PRINT_HEX,\n-\t      mnemonic, UINTVAL (info.value));\n-  else if (info.shift)\n-    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \" HOST_WIDE_INT_PRINT_HEX\n-\t      \", %s %d\", mnemonic, lane_count, element_char,\n-\t      UINTVAL (info.value), shift_op, info.shift);\n+\n+  if (which == AARCH64_CHECK_MOV)\n+    {\n+      mnemonic = info.mvn ? \"mvni\" : \"movi\";\n+      shift_op = info.msl ? \"msl\" : \"lsl\";\n+      if (lane_count == 1)\n+\tsnprintf (templ, sizeof (templ), \"%s\\t%%d0, \" HOST_WIDE_INT_PRINT_HEX,\n+\t\t  mnemonic, UINTVAL (info.value));\n+      else if (info.shift)\n+\tsnprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \"\n+\t\t  HOST_WIDE_INT_PRINT_HEX \", %s %d\", mnemonic, lane_count,\n+\t\t  element_char, UINTVAL (info.value), shift_op, info.shift);\n+      else\n+\tsnprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \"\n+\t\t  HOST_WIDE_INT_PRINT_HEX, mnemonic, lane_count,\n+\t\t  element_char, UINTVAL (info.value));\n+    }\n   else\n-    snprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, \" HOST_WIDE_INT_PRINT_HEX,\n-\t      mnemonic, lane_count, element_char, UINTVAL (info.value));\n+    {\n+      /* For AARCH64_CHECK_BIC and AARCH64_CHECK_ORR.  */\n+      mnemonic = info.mvn ? \"bic\" : \"orr\";\n+      if (info.shift)\n+\tsnprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, #\"\n+\t\t  HOST_WIDE_INT_PRINT_DEC \", %s #%d\", mnemonic, lane_count,\n+\t\t  element_char, UINTVAL (info.value), \"lsl\", info.shift);\n+      else\n+\tsnprintf (templ, sizeof (templ), \"%s\\t%%0.%d%c, #\"\n+\t\t  HOST_WIDE_INT_PRINT_DEC, mnemonic, lane_count,\n+\t\t  element_char, UINTVAL (info.value));\n+    }\n   return templ;\n }\n "}, {"sha": "77c510cea0d9da7cbce2e5d42823de6b288a153f", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -190,6 +190,20 @@\n   (and (match_code \"const_double\")\n        (match_test \"aarch64_can_const_movi_rtx_p (op, GET_MODE (op))\")))\n \n+(define_constraint \"Do\"\n+  \"@internal\n+   A constraint that matches vector of immediates for orr.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"aarch64_simd_valid_immediate (op, mode, false,\n+\t\t\t\t\t\t NULL, AARCH64_CHECK_ORR)\")))\n+\n+(define_constraint \"Db\"\n+  \"@internal\n+   A constraint that matches vector of immediates for bic.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"aarch64_simd_valid_immediate (op, mode, false,\n+\t\t\t\t\t\t NULL, AARCH64_CHECK_BIC)\")))\n+\n (define_constraint \"Dn\"\n   \"@internal\n  A constraint that matches vector of immediates.\""}, {"sha": "887a13ee4f1be504317c0857d8ad135523cbaec0", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -69,6 +69,16 @@\n \t\t (ior (match_test \"op == constm1_rtx\")\n \t\t      (match_test \"op == const1_rtx\"))))))\n \n+(define_predicate \"aarch64_reg_or_orr_imm\"\n+   (ior (match_operand 0 \"register_operand\")\n+\t(match_test \"aarch64_simd_valid_immediate (op, mode, false,\n+\t\t\t\t\t\t   NULL, AARCH64_CHECK_ORR)\")))\n+\n+(define_predicate \"aarch64_reg_or_bic_imm\"\n+   (ior (match_operand 0 \"register_operand\")\n+\t(match_test \"aarch64_simd_valid_immediate (op, mode, false,\n+\t\t\t\t\t\t   NULL, AARCH64_CHECK_BIC)\")))\n+\n (define_predicate \"aarch64_fp_compare_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (and (match_code \"const_double\")"}, {"sha": "da8358ced9e17463defa6288669328a9be500136", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6501d713bb9de29609bd99b40da3f479e504b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ab6501d713bb9de29609bd99b40da3f479e504b6", "patch": "@@ -1,3 +1,8 @@\n+2017-10-04  Sudakshina Das  <sudi.das@arm.com>\n+\n+\t* gcc.target/aarch64/bic_imm_1.c: New.\n+\t* gcc.target/aarch64/orr_imm_1.c: Likewise.\n+\n 2017-10-04  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.dg/abi/mangle41.C: Adjust diagnostics."}]}