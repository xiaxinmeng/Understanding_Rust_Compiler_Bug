{"sha": "c5e94699efa816444c0ae49ad55d0e01a48203df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlOTQ2OTllZmE4MTY0NDRjMGFlNDlhZDU1ZDBlMDFhNDgyMDNkZg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-04T18:05:38Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-05T21:09:10Z"}, "message": "d: Merge upstream dmd a5c86f5b9\n\nAdds the following new `__traits' to the D language.\n\n - isDeprecated: used to detect if a function is deprecated.\n\n - isDisabled: used to detect if a function is marked with @disable.\n\n - isFuture: used to detect if a function is marked with @__future.\n\n - isModule: used to detect if a given symbol represents a module, this\n   enhancement also adds support using `is(sym == module)'.\n\n - isPackage: used to detect if a given symbol represents a package,\n   this enhancement also adds support using `is(sym == package)'.\n\n - child: takes two arguments.  The first must be a symbol or expression\n   and the second must be a symbol, such as an alias to a member of the\n   first 'parent' argument.  The result is the second 'member' argument\n   interpreted with its 'this' context set to 'parent'.  This is the\n   inverse of `__traits(parent, member)'.\n\n - isReturnOnStack: determines if a function's return value is placed on\n   the stack, or is returned via registers.\n\n - isZeroInit: used to detect if a type's default initializer has no\n   non-zero bits.\n\n - getTargetInfo: used to query features of the target being compiled\n   for, the back-end can expand this to register any key to handle the\n   given argument, however a reliable subset exists which includes\n   \"cppRuntimeLibrary\", \"cppStd\", \"floatAbi\", and \"objectFormat\".\n\n - getLocation: returns a tuple whose entries correspond to the\n   filename, line number, and column number of where the argument was\n   declared.\n\n - hasPostblit: used to detect if a type is a struct with a postblit.\n\n - isCopyable: used to detect if a type allows copying its value.\n\n - getVisibility: an alias for the getProtection trait.\n\nReviewed-on: https://github.com/dlang/dmd/pull/12093\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd a5c86f5b9.\n\t* d-builtins.cc (d_eval_constant_expression): Handle ADDR_EXPR trees\n\tcreated by build_string_literal.\n\t* d-frontend.cc (retStyle): Remove function.\n\t* d-target.cc (d_language_target_info): New variable.\n\t(d_target_info_table): Likewise.\n\t(Target::_init): Initialize d_target_info_table.\n\t(Target::isReturnOnStack): New function.\n\t(d_add_target_info_handlers): Likewise.\n\t(d_handle_target_cpp_std): Likewise.\n\t(d_handle_target_cpp_runtime_library): Likewise.\n\t(Target::getTargetInfo): Likewise.\n\t* d-target.h (struct d_target_info_spec): New type.\n\t(d_add_target_info_handlers): Declare.", "tree": {"sha": "f527fd1748c2f034d74ca1b268d4f56fc36cf050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f527fd1748c2f034d74ca1b268d4f56fc36cf050"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5e94699efa816444c0ae49ad55d0e01a48203df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e94699efa816444c0ae49ad55d0e01a48203df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e94699efa816444c0ae49ad55d0e01a48203df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e94699efa816444c0ae49ad55d0e01a48203df/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae1ada95fee1ee4fac0dec0486076d9787988a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1ada95fee1ee4fac0dec0486076d9787988a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1ada95fee1ee4fac0dec0486076d9787988a03"}], "stats": {"total": 2317, "additions": 1886, "deletions": 431}, "files": [{"sha": "26ccd00c79a25252ae2c9668673e0d1491dade71", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -393,6 +393,20 @@ d_eval_constant_expression (const Loc &loc, tree cst)\n \n \t  return VectorExp::create (loc, e, type);\n \t}\n+      else if (code == ADDR_EXPR)\n+\t{\n+\t  /* Special handling for trees constructed by build_string_literal.\n+\t     What we receive is an `&\"string\"[0]' expression, strip off the\n+\t     outer ADDR_EXPR and ARRAY_REF to get to the underlying CST.  */\n+\t  tree pointee = TREE_OPERAND (cst, 0);\n+\n+\t  if (TREE_CODE (pointee) != ARRAY_REF\n+\t      || TREE_OPERAND (pointee, 1) != integer_zero_node\n+\t      || TREE_CODE (TREE_OPERAND (pointee, 0)) != STRING_CST)\n+\t    return NULL;\n+\n+\t  return d_eval_constant_expression (loc, TREE_OPERAND (pointee, 0));\n+\t}\n     }\n \n   return NULL;"}, {"sha": "32550ecfd64bc1b71023870f0bbfff8aa06110d2", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -139,26 +139,6 @@ Loc::equals (const Loc &loc)\n \n /* Implements back-end specific interfaces used by the frontend.  */\n \n-/* Determine return style of function - whether in registers or through a\n-   hidden pointer to the caller's stack.  */\n-\n-RET\n-retStyle (TypeFunction *tf)\n-{\n-  /* Need the backend type to determine this, but this is called from the\n-     frontend before semantic processing is finished.  An accurate value\n-     is not currently needed anyway.  */\n-  if (tf->isref)\n-    return RETregs;\n-\n-  Type *tn = tf->next->toBasetype ();\n-\n-  if (tn->ty == Tstruct || tn->ty == Tsarray)\n-    return RETstack;\n-\n-  return RETregs;\n-}\n-\n /* Determine if function FD is a builtin one that we can evaluate in CTFE.  */\n \n BUILTIN"}, {"sha": "d50fcef22e24b05a394898473ff58adb2b80f2b8", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -44,6 +44,25 @@ along with GCC; see the file COPYING3.  If not see\n \n Target target;\n \n+/* Internal key handlers for `__traits(getTargetInfo)'.  */\n+static tree d_handle_target_cpp_std (void);\n+static tree d_handle_target_cpp_runtime_library (void);\n+\n+/* In [traits/getTargetInfo], a reliable subset of getTargetInfo keys exists\n+   which are always available.  */\n+static const struct d_target_info_spec d_language_target_info[] =\n+{\n+  /* { name, handler } */\n+  { \"cppStd\", d_handle_target_cpp_std },\n+  { \"cppRuntimeLibrary\", d_handle_target_cpp_runtime_library },\n+  { \"floatAbi\", NULL },\n+  { \"objectFormat\", NULL },\n+  { NULL, NULL },\n+};\n+\n+/* Table `__traits(getTargetInfo)' keys.  */\n+static vec<d_target_info_spec> d_target_info_table;\n+\n \n /* Initialize the floating-point constants for TYPE.  */\n \n@@ -167,6 +186,10 @@ Target::_init (const Param &)\n   real_convert (&CTFloat::one.rv (), mode, &dconst1);\n   real_convert (&CTFloat::minusone.rv (), mode, &dconstm1);\n   real_convert (&CTFloat::half.rv (), mode, &dconsthalf);\n+\n+  /* Initialize target info tables, the keys required by the language are added\n+     last, so that the OS and CPU handlers can override.  */\n+  d_add_target_info_handlers (d_language_target_info);\n }\n \n /* Return GCC memory alignment size for type TYPE.  */\n@@ -413,3 +436,84 @@ Target::toArgTypes (Type *)\n   /* Not implemented, however this is not currently used anywhere.  */\n   return NULL;\n }\n+\n+/* Determine return style of function, whether in registers or through a\n+   hidden pointer to the caller's stack.  */\n+\n+bool\n+Target::isReturnOnStack (TypeFunction *tf, bool)\n+{\n+  /* Need the back-end type to determine this, but this is called from the\n+     frontend before semantic processing is finished.  An accurate value\n+     is not currently needed anyway.  */\n+  if (tf->isref)\n+    return false;\n+\n+  Type *tn = tf->next->toBasetype ();\n+\n+  return (tn->ty == Tstruct || tn->ty == Tsarray);\n+}\n+\n+/* Add all target info in HANDLERS to D_TARGET_INFO_TABLE for use by\n+   Target::getTargetInfo().  */\n+\n+void\n+d_add_target_info_handlers (const d_target_info_spec *handlers)\n+{\n+  gcc_assert (handlers != NULL);\n+\n+  if (d_target_info_table.is_empty ())\n+    d_target_info_table.create (8);\n+\n+  for (size_t i = 0; handlers[i].name != NULL; i++)\n+    d_target_info_table.safe_push (handlers[i]);\n+}\n+\n+/* Handle a call to `__traits(getTargetInfo, \"cppStd\")'.  */\n+\n+tree\n+d_handle_target_cpp_std (void)\n+{\n+  return build_integer_cst (global.params.cplusplus);\n+}\n+\n+/* Handle a call to `__traits(getTargetInfo, \"cppRuntimeLibrary\")'.  */\n+\n+tree\n+d_handle_target_cpp_runtime_library (void)\n+{\n+  /* The driver only ever optionally links to libstdc++.  */\n+  const char *libstdcxx = \"libstdc++\";\n+  return build_string_literal (strlen (libstdcxx) + 1, libstdcxx);\n+}\n+\n+/* Look up the target info KEY in the available getTargetInfo tables, and return\n+   the result as an Expression, or NULL if KEY is not found.  When the key must\n+   always exist, but is not supported, an empty string expression is returned.\n+   LOC is the location to use for the returned expression.  */\n+\n+Expression *\n+Target::getTargetInfo (const char *key, const Loc &loc)\n+{\n+  unsigned ix;\n+  d_target_info_spec *spec;\n+\n+  FOR_EACH_VEC_ELT (d_target_info_table, ix, spec)\n+    {\n+      tree result;\n+\n+      if (strcmp (key, spec->name) != 0)\n+       continue;\n+\n+      /* Get the requested information, or empty string if unhandled.  */\n+      if (spec->handler)\n+       result = (spec->handler) ();\n+      else\n+       result = build_string_literal (1, \"\");\n+\n+      gcc_assert (result);\n+      return d_eval_constant_expression (loc, result);\n+    }\n+\n+  return NULL;\n+}"}, {"sha": "56595d225bf5a0b39e5909880d8186861c591a00", "filename": "gcc/d/d-target.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fd-target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.h?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -31,4 +31,19 @@ extern struct gcc_targetdm targetdm;\n /* Used by target to add predefined version idenditiers.  */\n extern void d_add_builtin_version (const char *);\n \n+/* Structure describing a supported key for `__traits(getTargetInfo)' and a\n+   function to handle it.  */\n+struct d_target_info_spec\n+{\n+  /* The name of the key or NULL to mark the end of a table of keys.  */\n+  const char *name;\n+  /* Function to handle this key, the return value of the handler must be a CST.\n+     This pointer may be NULL if no special handling is required, for instance,\n+     the key must always be available according to the D language spec.  */\n+  tree (*handler) ();\n+};\n+\n+/* Used by target to add getTargetInfo handlers.  */\n+extern void d_add_target_info_handlers (const d_target_info_spec *);\n+\n #endif /* GCC_D_TARGET_H  */"}, {"sha": "1629b4535ee87eca6434bbb2e1591c2f630e493b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -1,4 +1,4 @@\n-2bd4fc3fed8b8cd9760e77c6b2a1905cd84d0e70\n+a5c86f5b92c4cd3afde910c89881ccaea11de554\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "a4e776697fccb3a385c82e9a7eef4a0dc4df5636", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -149,6 +149,7 @@ class Declaration : public Dsymbol\n     bool isSynchronized() { return (storage_class & STCsynchronized) != 0; }\n     bool isParameter()    { return (storage_class & STCparameter) != 0; }\n     bool isDeprecated()   { return (storage_class & STCdeprecated) != 0; }\n+    bool isDisabled()     { return (storage_class & STCdisable) != 0; }\n     bool isOverride()     { return (storage_class & STCoverride) != 0; }\n     bool isResult()       { return (storage_class & STCresult) != 0; }\n     bool isField()        { return (storage_class & STCfield) != 0; }\n@@ -669,7 +670,7 @@ class FuncDeclaration : public Declaration\n     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, const char *name, StorageClass stc=0);\n     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, Identifier *id, StorageClass stc=0);\n     void checkDmain();\n-    bool checkNrvo();\n+    bool checkNRVO();\n \n     FuncDeclaration *isFuncDeclaration() { return this; }\n "}, {"sha": "305b1331146f4e50542aadd7510d04102dbba2ce", "filename": "gcc/d/dmd/dmodule.c", "status": "modified", "additions": 152, "deletions": 137, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -34,7 +34,6 @@ Dsymbols Module::deferred2; // deferred Dsymbol's needing semantic2() run on the\n Dsymbols Module::deferred3; // deferred Dsymbol's needing semantic3() run on them\n unsigned Module::dprogress;\n \n-const char *lookForSourceFile(const char **path, const char *filename);\n StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n \n void Module::_init()\n@@ -72,7 +71,6 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do\n     sfilename = NULL;\n     importedFrom = NULL;\n     srcfile = NULL;\n-    srcfilePath = NULL;\n     docfile = NULL;\n \n     debuglevel = 0;\n@@ -109,9 +107,6 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do\n         fatal();\n     }\n     srcfile = new File(srcfilename);\n-    if (!FileName::absolute(srcfilename))\n-        srcfilePath = getcwd(NULL, 0);\n-\n     objfile = setOutfile(global.params.objname.ptr, global.params.objdir.ptr, filename, global.obj_ext.ptr);\n \n     if (doDocComment)\n@@ -215,57 +210,149 @@ static void checkModFileAlias(OutBuffer *buf, OutBuffer *dotmods,\n     dotmods->writeByte('.');\n }\n \n-Module *Module::load(Loc loc, Identifiers *packages, Identifier *ident)\n+/**\n+ * Converts a chain of identifiers to the filename of the module\n+ *\n+ * Params:\n+ *  packages = the names of the \"parent\" packages\n+ *  ident = the name of the child package or module\n+ *\n+ * Returns:\n+ *  the filename of the child package or module\n+ */\n+static const char *getFilename(Identifiers *packages, Identifier *ident)\n {\n-    //printf(\"Module::load(ident = '%s')\\n\", ident->toChars());\n-\n-    // Build module filename by turning:\n-    //  foo.bar.baz\n-    // into:\n-    //  foo\\bar\\baz\n     const char *filename = ident->toChars();\n-    if (packages && packages->length)\n-    {\n-        OutBuffer buf;\n-        OutBuffer dotmods;\n-        Array<const char *> *ms = &global.params.modFileAliasStrings;\n-        const size_t msdim = ms ? ms->length : 0;\n \n-        for (size_t i = 0; i < packages->length; i++)\n-        {\n-            Identifier *pid = (*packages)[i];\n-            const char *p = pid->toChars();\n-            buf.writestring(p);\n-            if (msdim)\n-                checkModFileAlias(&buf, &dotmods, ms, msdim, p);\n+    if (packages == NULL || packages->length == 0)\n+        return filename;\n+\n+    OutBuffer buf;\n+    OutBuffer dotmods;\n+    Array<const char *> *ms = &global.params.modFileAliasStrings;\n+    const size_t msdim = ms ? ms->length : 0;\n+\n+    for (size_t i = 0; i < packages->length; i++)\n+    {\n+        Identifier *pid = (*packages)[i];\n+        const char *p = pid->toChars();\n+        buf.writestring(p);\n+        if (msdim)\n+            checkModFileAlias(&buf, &dotmods, ms, msdim, p);\n #if _WIN32\n-            buf.writeByte('\\\\');\n+        buf.writeByte('\\\\');\n #else\n-            buf.writeByte('/');\n+        buf.writeByte('/');\n #endif\n-        }\n-        buf.writestring(filename);\n-        if (msdim)\n-            checkModFileAlias(&buf, &dotmods, ms, msdim, filename);\n-        buf.writeByte(0);\n-        filename = (char *)buf.extractData();\n     }\n+    buf.writestring(filename);\n+    if (msdim)\n+        checkModFileAlias(&buf, &dotmods, ms, msdim, filename);\n+    buf.writeByte(0);\n+    filename = (char *)buf.extractData();\n \n-    Module *m = new Module(filename, ident, 0, 0);\n-    m->loc = loc;\n+    return filename;\n+}\n+\n+/********************************************\n+ * Look for the source file if it's different from filename.\n+ * Look for .di, .d, directory, and along global.path.\n+ * Does not open the file.\n+ * Input:\n+ *      filename        as supplied by the user\n+ *      global.path\n+ * Returns:\n+ *      NULL if it's not different from filename.\n+ */\n \n-    /* Look for the source file\n+static const char *lookForSourceFile(const char *filename)\n+{\n+    /* Search along global.path for .di file, then .d file.\n      */\n-    const char *path;\n-    const char *result = lookForSourceFile(&path, filename);\n-    if (result)\n+    const char *sdi = FileName::forceExt(filename, global.hdr_ext.ptr);\n+    if (FileName::exists(sdi) == 1)\n+        return sdi;\n+\n+    const char *sd  = FileName::forceExt(filename, global.mars_ext.ptr);\n+    if (FileName::exists(sd) == 1)\n+        return sd;\n+\n+    if (FileName::exists(filename) == 2)\n     {\n-        m->srcfile = new File(result);\n-        if (path)\n-            m->srcfilePath = path;\n-        else if (!FileName::absolute(result))\n-            m->srcfilePath = getcwd(NULL, 0);\n+        /* The filename exists and it's a directory.\n+         * Therefore, the result should be: filename/package.d\n+         * iff filename/package.d is a file\n+         */\n+        const char *ni = FileName::combine(filename, \"package.di\");\n+        if (FileName::exists(ni) == 1)\n+            return ni;\n+        FileName::free(ni);\n+        const char *n = FileName::combine(filename, \"package.d\");\n+        if (FileName::exists(n) == 1)\n+            return n;\n+        FileName::free(n);\n+    }\n+\n+    if (FileName::absolute(filename))\n+        return NULL;\n+\n+    if (!global.path)\n+        return NULL;\n+\n+    for (size_t i = 0; i < global.path->length; i++)\n+    {\n+        const char *p = (*global.path)[i];\n+        const char *n = FileName::combine(p, sdi);\n+        if (FileName::exists(n) == 1)\n+        {\n+            return n;\n+        }\n+        FileName::free(n);\n+\n+        n = FileName::combine(p, sd);\n+        if (FileName::exists(n) == 1)\n+        {\n+            return n;\n+        }\n+        FileName::free(n);\n+\n+        const char *b = FileName::removeExt(filename);\n+        n = FileName::combine(p, b);\n+        FileName::free(b);\n+        if (FileName::exists(n) == 2)\n+        {\n+            const char *n2i = FileName::combine(n, \"package.di\");\n+            if (FileName::exists(n2i) == 1)\n+                return n2i;\n+            FileName::free(n2i);\n+            const char *n2 = FileName::combine(n, \"package.d\");\n+            if (FileName::exists(n2) == 1)\n+            {\n+                return n2;\n+            }\n+            FileName::free(n2);\n+        }\n+        FileName::free(n);\n     }\n+    return NULL;\n+}\n+\n+Module *Module::load(Loc loc, Identifiers *packages, Identifier *ident)\n+{\n+    //printf(\"Module::load(ident = '%s')\\n\", ident->toChars());\n+\n+    // Build module filename by turning:\n+    //  foo.bar.baz\n+    // into:\n+    //  foo\\bar\\baz\n+    const char *filename = getFilename(packages, ident);\n+    // Look for the source file\n+    const char *result = lookForSourceFile(filename);\n+    if (result)\n+        filename = result;\n+\n+    Module *m = new Module(filename, ident, 0, 0);\n+    m->loc = loc;\n \n     if (!m->read(loc))\n         return NULL;\n@@ -1158,6 +1245,27 @@ Module *Package::isPackageMod()\n     return NULL;\n }\n \n+/**\n+ * Checks for the existence of a package.d to set isPkgMod appropriately\n+ * if isPkgMod == PKGunknown\n+ */\n+void Package::resolvePKGunknown()\n+{\n+    if (isModule())\n+        return;\n+    if (isPkgMod != PKGunknown)\n+        return;\n+\n+    Identifiers packages;\n+    for (Dsymbol *s = this->parent; s; s = s->parent)\n+        packages.insert(0, s->ident);\n+\n+    if (lookForSourceFile(getFilename(&packages, ident)))\n+        Module::load(Loc(), &packages, this->ident);\n+    else\n+        isPkgMod = PKGpackage;\n+}\n+\n /**\n  * Checks if pkg is a sub-package of this\n  *\n@@ -1266,96 +1374,3 @@ Dsymbol *Package::search(const Loc &loc, Identifier *ident, int flags)\n \n     return ScopeDsymbol::search(loc, ident, flags);\n }\n-\n-/* ===========================  ===================== */\n-\n-/********************************************\n- * Look for the source file if it's different from filename.\n- * Look for .di, .d, directory, and along global.path.\n- * Does not open the file.\n- * Output:\n- *      path            the path where the file was found if it was not the current directory\n- * Input:\n- *      filename        as supplied by the user\n- *      global.path\n- * Returns:\n- *      NULL if it's not different from filename.\n- */\n-\n-const char *lookForSourceFile(const char **path, const char *filename)\n-{\n-    /* Search along global.path for .di file, then .d file.\n-     */\n-    *path = NULL;\n-\n-    const char *sdi = FileName::forceExt(filename, global.hdr_ext.ptr);\n-    if (FileName::exists(sdi) == 1)\n-        return sdi;\n-\n-    const char *sd  = FileName::forceExt(filename, global.mars_ext.ptr);\n-    if (FileName::exists(sd) == 1)\n-        return sd;\n-\n-    if (FileName::exists(filename) == 2)\n-    {\n-        /* The filename exists and it's a directory.\n-         * Therefore, the result should be: filename/package.d\n-         * iff filename/package.d is a file\n-         */\n-        const char *ni = FileName::combine(filename, \"package.di\");\n-        if (FileName::exists(ni) == 1)\n-            return ni;\n-        FileName::free(ni);\n-        const char *n = FileName::combine(filename, \"package.d\");\n-        if (FileName::exists(n) == 1)\n-            return n;\n-        FileName::free(n);\n-    }\n-\n-    if (FileName::absolute(filename))\n-        return NULL;\n-\n-    if (!global.path)\n-        return NULL;\n-\n-    for (size_t i = 0; i < global.path->length; i++)\n-    {\n-        const char *p = (*global.path)[i];\n-\n-        const char *n = FileName::combine(p, sdi);\n-        if (FileName::exists(n) == 1)\n-        {\n-            *path = p;\n-            return n;\n-        }\n-        FileName::free(n);\n-\n-        n = FileName::combine(p, sd);\n-        if (FileName::exists(n) == 1)\n-        {\n-            *path = p;\n-            return n;\n-        }\n-        FileName::free(n);\n-\n-        const char *b = FileName::removeExt(filename);\n-        n = FileName::combine(p, b);\n-        FileName::free(b);\n-        if (FileName::exists(n) == 2)\n-        {\n-            const char *n2i = FileName::combine(n, \"package.di\");\n-            if (FileName::exists(n2i) == 1)\n-                return n2i;\n-            FileName::free(n2i);\n-            const char *n2 = FileName::combine(n, \"package.d\");\n-            if (FileName::exists(n2) == 1)\n-            {\n-                *path = p;\n-                return n2;\n-            }\n-            FileName::free(n2);\n-        }\n-        FileName::free(n);\n-    }\n-    return NULL;\n-}"}, {"sha": "8829367dab4560bf17c59ca5db31c91d15d60bc9", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 115, "deletions": 3, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -23,6 +23,8 @@\n #include \"template.h\"\n #include \"tokens.h\"\n #include \"target.h\"\n+#include \"utf.h\"\n+#include \"root/ctfloat.h\"\n \n Type *getTypeInfoType(Loc loc, Type *t, Scope *sc);\n void unSpeculative(Scope *sc, RootObject *o);\n@@ -1245,6 +1247,102 @@ Dsymbol *StructDeclaration::search(const Loc &loc, Identifier *ident, int flags)\n     return ScopeDsymbol::search(loc, ident, flags);\n }\n \n+/**********************************\n+ * Determine if exp is all binary zeros.\n+ * Params:\n+ *      exp = expression to check\n+ * Returns:\n+ *      true if it's all binary 0\n+ */\n+static bool isZeroInit(Expression *exp)\n+{\n+    switch (exp->op)\n+    {\n+        case TOKint64:\n+            return exp->toInteger() == 0;\n+\n+        case TOKnull:\n+        case TOKfalse:\n+            return true;\n+\n+        case TOKstructliteral:\n+        {\n+            StructLiteralExp *sle = (StructLiteralExp *) exp;\n+            for (size_t i = 0; i < sle->sd->fields.length; i++)\n+            {\n+                VarDeclaration *field = sle->sd->fields[i];\n+                if (field->type->size(field->loc))\n+                {\n+                    Expression *e = (*sle->elements)[i];\n+                    if (e ? !isZeroInit(e)\n+                          : !field->type->isZeroInit(field->loc))\n+                        return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        case TOKarrayliteral:\n+        {\n+            ArrayLiteralExp *ale = (ArrayLiteralExp *) exp;\n+\n+            const size_t dim = ale->elements ? ale->elements->length : 0;\n+\n+            if (ale->type->toBasetype()->ty == Tarray) // if initializing a dynamic array\n+                return dim == 0;\n+\n+            for (size_t i = 0; i < dim; i++)\n+            {\n+                if (!isZeroInit(ale->getElement(i)))\n+                    return false;\n+            }\n+            /* Note that true is returned for all T[0]\n+             */\n+            return true;\n+        }\n+\n+        case TOKstring:\n+        {\n+            StringExp *se = exp->toStringExp();\n+\n+            if (se->type->toBasetype()->ty == Tarray) // if initializing a dynamic array\n+                return se->len == 0;\n+\n+            void *s = se->string;\n+            for (size_t i = 0; i < se->len; i++)\n+            {\n+                dinteger_t val;\n+                switch (se->sz)\n+                {\n+                    case 1:     val = (( utf8_t *)s)[i];    break;\n+                    case 2:     val = ((utf16_t *)s)[i];    break;\n+                    case 4:     val = ((utf32_t *)s)[i];    break;\n+                    default:    assert(0);                  break;\n+                }\n+                if (val)\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        case TOKvector:\n+        {\n+            VectorExp *ve = (VectorExp *) exp;\n+            return isZeroInit(ve->e1);\n+        }\n+\n+        case TOKfloat64:\n+        case TOKcomplex80:\n+        {\n+            return (exp->toReal() == CTFloat::zero) &&\n+                   (exp->toImaginary() == CTFloat::zero);\n+        }\n+\n+        default:\n+            return false;\n+    }\n+}\n+\n void StructDeclaration::finalizeSize()\n {\n     //printf(\"StructDeclaration::finalizeSize() %s, sizeok = %d\\n\", toChars(), sizeok);\n@@ -1301,9 +1399,23 @@ void StructDeclaration::finalizeSize()\n         VarDeclaration *vd = fields[i];\n         if (vd->_init)\n         {\n-            // Should examine init to see if it is really all 0's\n-            zeroInit = 0;\n-            break;\n+            if (vd->_init->isVoidInitializer())\n+                /* Treat as 0 for the purposes of putting the initializer\n+                 * in the BSS segment, or doing a mass set to 0\n+                 */\n+                continue;\n+\n+            // Zero size fields are zero initialized\n+            if (vd->type->size(vd->loc) == 0)\n+                continue;\n+\n+            // Examine init to see if it is all 0s.\n+            Expression *exp = vd->getConstInitializer();\n+            if (!exp || !isZeroInit(exp))\n+            {\n+                zeroInit = 0;\n+                break;\n+            }\n         }\n         else if (!vd->type->isZeroInit(loc))\n         {"}, {"sha": "1035f829e126051fdc24b165971c244b91c8fea3", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -6783,7 +6783,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n         {\n             //printf(\"type %s\\n\", ta->toChars());\n             // It might really be an Expression or an Alias\n-            ta->resolve(loc, sc, &ea, &ta, &sa);\n+            ta->resolve(loc, sc, &ea, &ta, &sa, (flags & 1) != 0);\n             if (ea) goto Lexpr;\n             if (sa) goto Ldsym;\n             if (ta == NULL)\n@@ -6914,7 +6914,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n                     //goto Ldsym;\n                 }\n             }\n-            if (ea->op == TOKdotvar)\n+            if (ea->op == TOKdotvar && !(flags & 1))\n             {\n                 // translate expression to dsymbol.\n                 sa = ((DotVarExp *)ea)->var;\n@@ -6925,7 +6925,7 @@ bool TemplateInstance::semanticTiargs(Loc loc, Scope *sc, Objects *tiargs, int f\n                 sa = ((TemplateExp *)ea)->td;\n                 goto Ldsym;\n             }\n-            if (ea->op == TOKdottd)\n+            if (ea->op == TOKdottd && !(flags & 1))\n             {\n                 // translate expression to dsymbol.\n                 sa = ((DotTemplateExp *)ea)->td;"}, {"sha": "789183201924f3d560821d6e492607265c3fdd38", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -3337,7 +3337,7 @@ ClassReferenceExp *Expression::isClassReferenceExp()\n \n \n /****************************************\n- * Resolve __FILE__, __LINE__, __MODULE__, __FUNCTION__, __PRETTY_FUNCTION__ to loc.\n+ * Resolve __FILE__, __LINE__, __MODULE__, __FUNCTION__, __PRETTY_FUNCTION__, __FILE__FULL_PATH__ to loc.\n  */\n \n Expression *Expression::resolveLoc(Loc, Scope *)\n@@ -7170,9 +7170,12 @@ FileInitExp::FileInitExp(Loc loc, TOK tok)\n Expression *FileInitExp::resolveLoc(Loc loc, Scope *sc)\n {\n     //printf(\"FileInitExp::resolve() %s\\n\", toChars());\n-    const char *s = loc.filename ? loc.filename : sc->_module->ident->toChars();\n+    const char *s;\n     if (subop == TOKfilefullpath)\n-        s = FileName::combine(sc->_module->srcfilePath, s);\n+        s = FileName::toAbsolute(loc.filename != NULL ? loc.filename : sc->_module->srcfile->name->toChars());\n+    else\n+        s = loc.filename != NULL ? loc.filename : sc->_module->ident->toChars();\n+\n     Expression *e = new StringExp(loc, const_cast<char *>(s));\n     e = semantic(e, sc);\n     e = e->castTo(sc, type);"}, {"sha": "7dfe995b711e5d33d27602877a23c8324b8a5a4f", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -119,6 +119,36 @@ static bool preFunctionParameters(Scope *sc, Expressions *exps)\n     return err;\n }\n \n+/**\n+ * Determines whether a symbol represents a module or package\n+ * (Used as a helper for is(type == module) and is(type == package))\n+ *\n+ * Params:\n+ *  sym = the symbol to be checked\n+ *\n+ * Returns:\n+ *  the symbol which `sym` represents (or `null` if it doesn't represent a `Package`)\n+ */\n+Package *resolveIsPackage(Dsymbol *sym)\n+{\n+    Package *pkg;\n+    if (Import *imp = sym->isImport())\n+    {\n+        if (imp->pkg == NULL)\n+        {\n+            error(sym->loc, \"Internal Compiler Error: unable to process forward-referenced import `%s`\",\n+                  imp->toChars());\n+            assert(0);\n+        }\n+        pkg = imp->pkg;\n+    }\n+    else\n+        pkg = sym->isPackage();\n+    if (pkg)\n+        pkg->resolvePKGunknown();\n+    return pkg;\n+}\n+\n class ExpressionSemanticVisitor : public Visitor\n {\n public:\n@@ -1920,15 +1950,34 @@ class ExpressionSemanticVisitor : public Visitor\n         }\n \n         Type *tded = NULL;\n-        Scope *sc2 = sc->copy();    // keep sc->flags\n-        sc2->tinst = NULL;\n-        sc2->minst = NULL;\n-        sc2->flags |= SCOPEfullinst;\n-        Type *t = e->targ->trySemantic(e->loc, sc2);\n-        sc2->pop();\n-        if (!t)\n-            goto Lno;                       // errors, so condition is false\n-        e->targ = t;\n+        if (e->tok2 == TOKpackage || e->tok2 == TOKmodule) // These is() expressions are special because they can work on modules, not just types.\n+        {\n+            Dsymbol *sym = e->targ->toDsymbol(sc);\n+            if (sym == NULL)\n+                goto Lno;\n+            Package *p = resolveIsPackage(sym);\n+            if (p == NULL)\n+                goto Lno;\n+            if (e->tok2 == TOKpackage && p->isModule()) // Note that isModule() will return null for package modules because they're not actually instances of Module.\n+                goto Lno;\n+            else if(e->tok2 == TOKmodule && !(p->isModule() || p->isPackageMod()))\n+                goto Lno;\n+            tded = e->targ;\n+            goto Lyes;\n+        }\n+\n+        {\n+            Scope *sc2 = sc->copy(); // keep sc->flags\n+            sc2->tinst = NULL;\n+            sc2->minst = NULL;\n+            sc2->flags |= SCOPEfullinst;\n+            Type *t = e->targ->trySemantic(e->loc, sc2);\n+            sc2->pop();\n+            if (!t) // errors, so condition is false\n+                goto Lno;\n+            e->targ = t;\n+        }\n+\n         if (e->tok2 != TOKreserved)\n         {\n             switch (e->tok2)"}, {"sha": "fe1ad1118e0e219bd029506ef193c6e8f41cc60d", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -41,7 +41,6 @@ Expression *semantic(Expression *e, Scope *sc);\n int blockExit(Statement *s, FuncDeclaration *func, bool mustNotThrow);\n TypeIdentifier *getThrowable();\n \n-RET retStyle(TypeFunction *tf);\n void MODtoBuffer(OutBuffer *buf, MOD mod);\n char *MODtoChars(MOD mod);\n bool MODimplicitConv(MOD modfrom, MOD modto);\n@@ -970,7 +969,7 @@ void FuncDeclaration::semantic(Scope *sc)\n                 {\n                     if (fdv->isFuture())\n                     {\n-                        ::deprecation(loc, \"@future base class method %s is being overridden by %s; rename the latter\",\n+                        ::deprecation(loc, \"@__future base class method %s is being overridden by %s; rename the latter\",\n                             fdv->toPrettyChars(), toPrettyChars());\n                         // Treat 'this' as an introducing function, giving it a separate hierarchy in the vtbl[]\n                         goto Lintro;\n@@ -1758,7 +1757,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 if (storage_class & STCauto)\n                     storage_class &= ~STCauto;\n             }\n-            if (retStyle(f) != RETstack || checkNrvo())\n+            if (!target.isReturnOnStack(f, needThis()) || !checkNRVO())\n                 nrvo_can = 0;\n \n             if (fbody->isErrorStatement())\n@@ -4275,19 +4274,16 @@ void FuncDeclaration::checkDmain()\n  * using NRVO is possible.\n  *\n  * Returns:\n- *      true if the result cannot be returned by hidden reference.\n+ *      `false` if the result cannot be returned by hidden reference.\n  */\n-bool FuncDeclaration::checkNrvo()\n+bool FuncDeclaration::checkNRVO()\n {\n-    if (!nrvo_can)\n-        return true;\n-\n-    if (returns == NULL)\n-        return true;\n+    if (!nrvo_can || returns == NULL)\n+        return false;\n \n     TypeFunction *tf = type->toTypeFunction();\n     if (tf->isref)\n-        return true;\n+        return false;\n \n     for (size_t i = 0; i < returns->length; i++)\n     {\n@@ -4297,24 +4293,23 @@ bool FuncDeclaration::checkNrvo()\n         {\n             VarDeclaration *v = ve->var->isVarDeclaration();\n             if (!v || v->isOut() || v->isRef())\n-                return true;\n+                return false;\n             else if (nrvo_var == NULL)\n             {\n-                if (!v->isDataseg() && !v->isParameter() && v->toParent2() == this)\n-                {\n-                    //printf(\"Setting nrvo to %s\\n\", v->toChars());\n-                    nrvo_var = v;\n-                }\n-                else\n-                    return true;\n+                // Variables in the data segment (e.g. globals, TLS or not),\n+                // parameters and closure variables cannot be NRVOed.\n+                if (v->isDataseg() || v->isParameter() || v->toParent2() != this)\n+                    return false;\n+                //printf(\"Setting nrvo to %s\\n\", v->toChars());\n+                nrvo_var = v;\n             }\n             else if (nrvo_var != v)\n-                return true;\n+                return false;\n         }\n         else //if (!exp->isLvalue())    // keep NRVO-ability\n-            return true;\n+            return false;\n     }\n-    return false;\n+    return true;\n }\n \n const char *FuncDeclaration::kind() const"}, {"sha": "502bae29c48484546c0c54dc9440edf7f94297cd", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -286,7 +286,7 @@ typedef uint64_t                d_uns64;\n // file location\n struct Loc\n {\n-    const char *filename;\n+    const char *filename; // either absolute or relative to cwd\n     unsigned linnum;\n     unsigned charnum;\n "}, {"sha": "09855a056880e6bc895390e9802a6b87f33dbcd0", "filename": "gcc/d/dmd/idgen.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fidgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fidgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fidgen.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -322,6 +322,9 @@ Msgtable msgtable[] =\n     { \"isFinalClass\", NULL },\n     { \"isTemplate\", NULL },\n     { \"isPOD\", NULL },\n+    { \"isDeprecated\", NULL },\n+    { \"isDisabled\", NULL },\n+    { \"isFuture\" , NULL },\n     { \"isNested\", NULL },\n     { \"isFloating\", NULL },\n     { \"isIntegral\", NULL },\n@@ -334,13 +337,17 @@ Msgtable msgtable[] =\n     { \"isFinalFunction\", NULL },\n     { \"isOverrideFunction\", NULL },\n     { \"isStaticFunction\", NULL },\n+    { \"isModule\", NULL },\n+    { \"isPackage\", NULL },\n     { \"isRef\", NULL },\n     { \"isOut\", NULL },\n     { \"isLazy\", NULL },\n     { \"hasMember\", NULL },\n     { \"identifier\", NULL },\n     { \"getProtection\", NULL },\n+    { \"getVisibility\", NULL },\n     { \"parent\", NULL },\n+    { \"child\", NULL },\n     { \"getMember\", NULL },\n     { \"getOverloads\", NULL },\n     { \"getVirtualFunctions\", NULL },\n@@ -360,6 +367,12 @@ Msgtable msgtable[] =\n     { \"getUnitTests\", NULL },\n     { \"getVirtualIndex\", NULL },\n     { \"getPointerBitmap\", NULL },\n+    { \"isReturnOnStack\", NULL },\n+    { \"isZeroInit\", NULL },\n+    { \"getTargetInfo\", NULL },\n+    { \"getLocation\", NULL },\n+    { \"hasPostblit\", NULL },\n+    { \"isCopyable\", NULL },\n \n     // For C++ mangling\n     { \"allocator\", NULL },"}, {"sha": "4968ec7e1b540bc6b37a30ea182f782485fbe308", "filename": "gcc/d/dmd/module.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fmodule.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fmodule.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmodule.h?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -48,6 +48,7 @@ class Package : public ScopeDsymbol\n     void accept(Visitor *v) { v->visit(this); }\n \n     Module *isPackageMod();\n+    void resolvePKGunknown();\n };\n \n class Module : public Package\n@@ -68,7 +69,6 @@ class Module : public Package\n     const char *arg;    // original argument name\n     ModuleDeclaration *md; // if !NULL, the contents of the ModuleDeclaration declaration\n     File *srcfile;      // input source file\n-    const char* srcfilePath; // the path prefix to the srcfile if it applies\n     File *objfile;      // output .obj file\n     File *hdrfile;      // 'header' file\n     File *docfile;      // output documentation file"}, {"sha": "94e2082f5b23ae40f03f956f60d8227bfb0f3ca1", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -6682,6 +6682,7 @@ Type *TypeTraits::semantic(Loc, Scope *sc)\n         exp->ident != Id::derivedMembers &&\n         exp->ident != Id::getMember &&\n         exp->ident != Id::parent &&\n+        exp->ident != Id::child &&\n         exp->ident != Id::getOverloads &&\n         exp->ident != Id::getVirtualFunctions &&\n         exp->ident != Id::getVirtualMethods &&"}, {"sha": "be861fa92f6e69a8c211e4a4e0107d133f13898b", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -5949,7 +5949,10 @@ bool Parser::isDeclaration(Token *t, int needId, TOK endtok, Token **pt)\n     }\n     if (!isDeclarator(&t, &haveId, &haveTpl, endtok, needId != 3))\n         goto Lisnot;\n-    if (needId == 1 || (needId == 0 && !haveId) || ((needId == 2 || needId == 3) && haveId))\n+    if ((needId == 0 && !haveId) ||\n+        (needId == 1) ||\n+        (needId == 2 && haveId) ||\n+        (needId == 3 && haveId))\n     {\n         if (pt)\n             *pt = t;\n@@ -6821,12 +6824,8 @@ Expression *Parser::parsePrimaryExp()\n \n         case TOKfilefullpath:\n         {\n-            const char *srcfile = mod->srcfile->name->toChars();\n-            const char *s;\n-            if (loc.filename && !FileName::equals(loc.filename, srcfile))\n-                s = loc.filename;\n-            else\n-                s = FileName::combine(mod->srcfilePath, srcfile);\n+            assert(loc.filename); // __FILE_FULL_PATH__ does not work with an invalid location\n+            const char *s = FileName::toAbsolute(loc.filename);\n             e = new StringExp(loc, const_cast<char *>(s), strlen(s), 0);\n             nextToken();\n             break;\n@@ -7039,6 +7038,8 @@ Expression *Parser::parsePrimaryExp()\n                          token.value == TOKsuper ||\n                          token.value == TOKenum ||\n                          token.value == TOKinterface ||\n+                         token.value == TOKmodule ||\n+                         token.value == TOKpackage ||\n                          token.value == TOKargTypes ||\n                          token.value == TOKparameters ||\n                          (token.value == TOKconst && peek(&token)->value == TOKrparen) ||"}, {"sha": "f0e0213e701d79f970e64b55e270cd639126f883", "filename": "gcc/d/dmd/root/filename.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -175,6 +175,20 @@ bool FileName::absolute(const char *name)\n #endif\n }\n \n+/**\n+Return the given name as an absolute path\n+\n+Params:\n+    name = path\n+    base = the absolute base to prefix name with if it is relative\n+\n+Returns: name as an absolute path relative to base\n+*/\n+const char *FileName::toAbsolute(const char *name, const char *base)\n+{\n+    return absolute(name) ? name : combine(base ? base : getcwd(NULL, 0), name);\n+}\n+\n /********************************\n  * Return filename extension (read-only).\n  * Points past '.' of extension."}, {"sha": "6ef515c644145c3ff24f3e19f25e73b89ca548b5", "filename": "gcc/d/dmd/root/filename.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.h?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -24,6 +24,7 @@ struct FileName\n     int compare(RootObject *obj);\n     static int compare(const char *name1, const char *name2);\n     static bool absolute(const char *name);\n+    static const char *toAbsolute(const char *name, const char *base = NULL);\n     static const char *ext(const char *);\n     const char *ext();\n     static const char *removeExt(const char *str);"}, {"sha": "5a2dd4d913369b8a2989492090fea0b933746101", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -22,6 +22,7 @@ class Expression;\n class FuncDeclaration;\n class Parameter;\n class Type;\n+class TypeFunction;\n class TypeTuple;\n struct OutBuffer;\n \n@@ -105,6 +106,8 @@ struct Target\n     // ABI and backend.\n     LINK systemLinkage();\n     TypeTuple *toArgTypes(Type *t);\n+    bool isReturnOnStack(TypeFunction *tf, bool needsThis);\n+    Expression *getTargetInfo(const char* name, const Loc& loc);\n };\n \n extern Target target;"}, {"sha": "658529943ea14aee5abeff40a407f5466a873ef5", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 541, "deletions": 143, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -32,11 +32,13 @@\n #include \"attrib.h\"\n #include \"parse.h\"\n #include \"root/speller.h\"\n+#include \"target.h\"\n \n typedef int (*ForeachDg)(void *ctx, size_t idx, Dsymbol *s);\n int ScopeDsymbol_foreach(Scope *sc, Dsymbols *members, ForeachDg dg, void *ctx, size_t *pn = NULL);\n void freeFieldinit(Scope *sc);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n+Package *resolveIsPackage(Dsymbol *sym);\n Expression *trySemantic(Expression *e, Scope *sc);\n Expression *semantic(Expression *e, Scope *sc);\n Expression *typeToExpression(Type *t);\n@@ -49,32 +51,69 @@ Expression *typeToExpression(Type *t);\n \n struct Ptrait\n {\n+    Dsymbol *sym;\n     Expression *e1;\n     Expressions *exps;          // collected results\n     Identifier *ident;          // which trait we're looking for\n+    bool includeTemplates;\n+    AA **funcTypeHash;\n };\n \n+/* Compute the function signature and insert it in the\n+ * hashtable, if not present. This is needed so that\n+ * traits(getOverlods, F3, \"visit\") does not count `int visit(int)`\n+ * twice in the following example:\n+ *\n+ * =============================================\n+ * interface F1 { int visit(int);}\n+ * interface F2 { int visit(int); void visit(); }\n+ * interface F3 : F2, F1 {}\n+ *==============================================\n+ */\n+static void insertInterfaceInheritedFunction(Ptrait *p, FuncDeclaration *fd, Expression *e)\n+{\n+    Identifier *signature = Identifier::idPool(fd->type->toChars());\n+    //printf(\"%s - %s\\n\", fd->toChars, signature);\n+    if (!dmd_aaGetRvalue(*p->funcTypeHash, (void *)signature))\n+    {\n+        bool* value = (bool*) dmd_aaGet(p->funcTypeHash, (void *)signature);\n+        *value = true;\n+        p->exps->push(e);\n+    }\n+}\n+\n static int fptraits(void *param, Dsymbol *s)\n {\n-    FuncDeclaration *f = s->isFuncDeclaration();\n-    if (!f)\n+    Ptrait *p = (Ptrait *)param;\n+    if (p->includeTemplates)\n+    {\n+        p->exps->push(new DsymbolExp(Loc(),s, false));\n+        return 0;\n+    }\n+    FuncDeclaration *fd = s->isFuncDeclaration();\n+    if (!fd)\n         return 0;\n \n-    Ptrait *p = (Ptrait *)param;\n-    if (p->ident == Id::getVirtualFunctions && !f->isVirtual())\n+    if (p->ident == Id::getVirtualFunctions && !fd->isVirtual())\n         return 0;\n \n-    if (p->ident == Id::getVirtualMethods && !f->isVirtualMethod())\n+    if (p->ident == Id::getVirtualMethods && !fd->isVirtualMethod())\n         return 0;\n \n     Expression *e;\n-    FuncAliasDeclaration* ad = new FuncAliasDeclaration(f->ident, f, false);\n-    ad->protection = f->protection;\n+    FuncAliasDeclaration* ad = new FuncAliasDeclaration(fd->ident, fd, false);\n+    ad->protection = fd->protection;\n     if (p->e1)\n         e = new DotVarExp(Loc(), p->e1, ad, false);\n     else\n         e = new DsymbolExp(Loc(), ad, false);\n-    p->exps->push(e);\n+     // if the parent is an interface declaration\n+     // we must check for functions with the same signature\n+     // in different inherited interfaces\n+     if (p->sym && p->sym->isInterfaceDeclaration())\n+         insertInterfaceInheritedFunction(p, fd, e);\n+     else\n+         p->exps->push(e);\n     return 0;\n }\n \n@@ -126,22 +165,111 @@ static void collectUnitTests(Dsymbols *symbols, AA *uniqueUnitTests, Expressions\n     }\n }\n \n+/***************************************************\n+ * Determine if type t is copyable.\n+ * Params:\n+ *      t = type to check\n+ * Returns:\n+ *      true if we can copy it\n+ */\n+static bool isCopyable(Type *t)\n+{\n+    //printf(\"isCopyable() %s\\n\", t->toChars());\n+    if (TypeStruct *ts = t->isTypeStruct())\n+    {\n+        if (ts->sym->postblit &&\n+            (ts->sym->postblit->storage_class & STCdisable))\n+            return false;\n+    }\n+    return true;\n+}\n+\n /************************ TraitsExp ************************************/\n \n static Expression *True(TraitsExp *e)  { return new IntegerExp(e->loc, true, Type::tbool); }\n static Expression *False(TraitsExp *e) { return new IntegerExp(e->loc, false, Type::tbool); }\n \n-bool isTypeArithmetic(Type *t)       { return t->isintegral() || t->isfloating(); }\n-bool isTypeFloating(Type *t)         { return t->isfloating(); }\n-bool isTypeIntegral(Type *t)         { return t->isintegral(); }\n-bool isTypeScalar(Type *t)           { return t->isscalar(); }\n-bool isTypeUnsigned(Type *t)         { return t->isunsigned(); }\n-bool isTypeAssociativeArray(Type *t) { return t->toBasetype()->ty == Taarray; }\n-bool isTypeStaticArray(Type *t)      { return t->toBasetype()->ty == Tsarray; }\n-bool isTypeAbstractClass(Type *t)    { return t->toBasetype()->ty == Tclass && ((TypeClass *)t->toBasetype())->sym->isAbstract(); }\n-bool isTypeFinalClass(Type *t)       { return t->toBasetype()->ty == Tclass && (((TypeClass *)t->toBasetype())->sym->storage_class & STCfinal) != 0; }\n-\n-Expression *isTypeX(TraitsExp *e, bool (*fp)(Type *t))\n+/**************************************\n+ * Convert `Expression` or `Type` to corresponding `Dsymbol`,\n+ * additionally strip off expression contexts.\n+ *\n+ * Some symbol related `__traits` ignore arguments expression contexts.\n+ * For example:\n+ *  struct S { void f() {} }\n+ *  S s;\n+ *  pragma(msg, __traits(isNested, s.f));\n+ *  // s.f is DotVarExp, but __traits(isNested) needs a FuncDeclaration.\n+ *\n+ * This is used for that common `__traits` behavior.\n+ */\n+static Dsymbol *getDsymbolWithoutExpCtx(RootObject *oarg)\n+{\n+    if (Expression *e = isExpression(oarg))\n+    {\n+        if (e->op == TOKdotvar)\n+            return ((DotVarExp *)e)->var;\n+        if (e->op == TOKdottd)\n+            return ((DotTemplateExp *)e)->td;\n+    }\n+    return getDsymbol(oarg);\n+}\n+\n+/**\n+   Gets the function type from a given AST node\n+   if the node is a function of some sort.\n+\n+ Params:\n+    o = an AST node to check for a `TypeFunction`\n+    fdp = optional pointer to a function declararion, to be set\n+      if `o` is a function declarartion.\n+\n+ Returns:\n+    a type node if `o` is a declaration of\n+        a delegate, function, function-pointer\n+      or a variable of the former.  Otherwise, `null`.\n+*/\n+static TypeFunction *toTypeFunction(RootObject *o, FuncDeclaration **fdp = NULL)\n+{\n+    Dsymbol *s = getDsymbolWithoutExpCtx(o);\n+    Type *t = isType(o);\n+    TypeFunction *tf = NULL;\n+\n+    if (s)\n+    {\n+        FuncDeclaration *fd = s->isFuncDeclaration();\n+        if (fd)\n+        {\n+            t = fd->type;\n+            if (fdp)\n+                *fdp = fd;\n+        }\n+        else if (VarDeclaration *vd = s->isVarDeclaration())\n+            t = vd->type;\n+    }\n+    if (t)\n+    {\n+        if (t->ty == Tfunction)\n+            tf = (TypeFunction *)t;\n+        else if (t->ty == Tdelegate)\n+            tf = (TypeFunction *)t->nextOf();\n+        else if (t->ty == Tpointer && t->nextOf()->ty == Tfunction)\n+            tf = (TypeFunction *)t->nextOf();\n+    }\n+\n+    return tf;\n+}\n+\n+static bool isTypeArithmetic(Type *t)       { return t->isintegral() || t->isfloating(); }\n+static bool isTypeFloating(Type *t)         { return t->isfloating(); }\n+static bool isTypeIntegral(Type *t)         { return t->isintegral(); }\n+static bool isTypeScalar(Type *t)           { return t->isscalar(); }\n+static bool isTypeUnsigned(Type *t)         { return t->isunsigned(); }\n+static bool isTypeAssociativeArray(Type *t) { return t->toBasetype()->ty == Taarray; }\n+static bool isTypeStaticArray(Type *t)      { return t->toBasetype()->ty == Tsarray; }\n+static bool isTypeAbstractClass(Type *t)    { return t->toBasetype()->ty == Tclass && ((TypeClass *)t->toBasetype())->sym->isAbstract(); }\n+static bool isTypeFinalClass(Type *t)       { return t->toBasetype()->ty == Tclass && (((TypeClass *)t->toBasetype())->sym->storage_class & STCfinal) != 0; }\n+\n+static Expression *isTypeX(TraitsExp *e, bool (*fp)(Type *t))\n {\n     if (!e->args || !e->args->length)\n         return False(e);\n@@ -154,20 +282,52 @@ Expression *isTypeX(TraitsExp *e, bool (*fp)(Type *t))\n     return True(e);\n }\n \n-bool isFuncAbstractFunction(FuncDeclaration *f) { return f->isAbstract(); }\n-bool isFuncVirtualFunction(FuncDeclaration *f) { return f->isVirtual(); }\n-bool isFuncVirtualMethod(FuncDeclaration *f) { return f->isVirtualMethod(); }\n-bool isFuncFinalFunction(FuncDeclaration *f) { return f->isFinalFunc(); }\n-bool isFuncStaticFunction(FuncDeclaration *f) { return !f->needThis() && !f->isNested(); }\n-bool isFuncOverrideFunction(FuncDeclaration *f) { return f->isOverride(); }\n+static bool isDsymDeprecated(Dsymbol *s) { return s->isDeprecated(); }\n+\n+static int fpisTemplate(void *, Dsymbol *s)\n+{\n+    if (s->isTemplateDeclaration())\n+        return 1;\n+\n+    return 0;\n+}\n+\n+bool isTemplate(Dsymbol *s)\n+{\n+    if (!s->toAlias()->isOverloadable())\n+        return false;\n+\n+    return overloadApply(s, NULL, &fpisTemplate) != 0;\n+}\n+\n+static Expression *isDsymX(TraitsExp *e, bool (*fp)(Dsymbol *s))\n+{\n+    if (!e->args || !e->args->length)\n+        return False(e);\n+    for (size_t i = 0; i < e->args->length; i++)\n+    {\n+        Dsymbol *s = getDsymbolWithoutExpCtx((*e->args)[i]);\n+        if (!s || !fp(s))\n+            return False(e);\n+    }\n+    return True(e);\n+}\n+\n+static bool isFuncDisabled(FuncDeclaration *f) { return f->isDisabled(); }\n+static bool isFuncAbstractFunction(FuncDeclaration *f) { return f->isAbstract(); }\n+static bool isFuncVirtualFunction(FuncDeclaration *f) { return f->isVirtual(); }\n+static bool isFuncVirtualMethod(FuncDeclaration *f) { return f->isVirtualMethod(); }\n+static bool isFuncFinalFunction(FuncDeclaration *f) { return f->isFinalFunc(); }\n+static bool isFuncStaticFunction(FuncDeclaration *f) { return !f->needThis() && !f->isNested(); }\n+static bool isFuncOverrideFunction(FuncDeclaration *f) { return f->isOverride(); }\n \n-Expression *isFuncX(TraitsExp *e, bool (*fp)(FuncDeclaration *f))\n+static Expression *isFuncX(TraitsExp *e, bool (*fp)(FuncDeclaration *f))\n {\n     if (!e->args || !e->args->length)\n         return False(e);\n     for (size_t i = 0; i < e->args->length; i++)\n     {\n-        Dsymbol *s = getDsymbol((*e->args)[i]);\n+        Dsymbol *s = getDsymbolWithoutExpCtx((*e->args)[i]);\n         if (!s)\n             return False(e);\n         FuncDeclaration *f = s->isFuncDeclaration();\n@@ -177,17 +337,18 @@ Expression *isFuncX(TraitsExp *e, bool (*fp)(FuncDeclaration *f))\n     return True(e);\n }\n \n-bool isDeclRef(Declaration *d) { return d->isRef(); }\n-bool isDeclOut(Declaration *d) { return d->isOut(); }\n-bool isDeclLazy(Declaration *d) { return (d->storage_class & STClazy) != 0; }\n+static bool isDeclFuture(Declaration *d) { return d->isFuture(); }\n+static bool isDeclRef(Declaration *d) { return d->isRef(); }\n+static bool isDeclOut(Declaration *d) { return d->isOut(); }\n+static bool isDeclLazy(Declaration *d) { return (d->storage_class & STClazy) != 0; }\n \n-Expression *isDeclX(TraitsExp *e, bool (*fp)(Declaration *d))\n+static Expression *isDeclX(TraitsExp *e, bool (*fp)(Declaration *d))\n {\n     if (!e->args || !e->args->length)\n         return False(e);\n     for (size_t i = 0; i < e->args->length; i++)\n     {\n-        Dsymbol *s = getDsymbol((*e->args)[i]);\n+        Dsymbol *s = getDsymbolWithoutExpCtx((*e->args)[i]);\n         if (!s)\n             return False(e);\n         Declaration *d = s->isDeclaration();\n@@ -197,6 +358,25 @@ Expression *isDeclX(TraitsExp *e, bool (*fp)(Declaration *d))\n     return True(e);\n }\n \n+static bool isPkgModule(Package *p) { return p->isModule() || p->isPackageMod(); }\n+static bool isPkgPackage(Package *p) { return p->isModule() == NULL; }\n+\n+static Expression *isPkgX(TraitsExp *e, bool (*fp)(Package *p))\n+{\n+    if (!e->args || !e->args->length)\n+        return False(e);\n+    for (size_t i = 0; i < e->args->length; i++)\n+    {\n+        Dsymbol *s = getDsymbolWithoutExpCtx((*e->args)[i]);\n+        if (!s)\n+            return False(e);\n+        Package *p = resolveIsPackage(s);\n+        if (!p || !fp(p))\n+            return False(e);\n+    }\n+    return True(e);\n+}\n+\n // callback for TypeFunction::attributesApply\n struct PushAttributes\n {\n@@ -225,6 +405,9 @@ TraitsInitializer::TraitsInitializer()\n         \"isAbstractClass\",\n         \"isArithmetic\",\n         \"isAssociativeArray\",\n+        \"isDisabled\",\n+        \"isDeprecated\",\n+        \"isFuture\",\n         \"isFinalClass\",\n         \"isPOD\",\n         \"isNested\",\n@@ -239,13 +422,18 @@ TraitsInitializer::TraitsInitializer()\n         \"isFinalFunction\",\n         \"isOverrideFunction\",\n         \"isStaticFunction\",\n+        \"isModule\",\n+        \"isPackage\",\n         \"isRef\",\n         \"isOut\",\n         \"isLazy\",\n+        \"isReturnOnStack\",\n         \"hasMember\",\n         \"identifier\",\n         \"getProtection\",\n+        \"getVisibility\",\n         \"parent\",\n+        \"child\",\n         \"getLinkage\",\n         \"getMember\",\n         \"getOverloads\",\n@@ -265,10 +453,15 @@ TraitsInitializer::TraitsInitializer()\n         \"getUnitTests\",\n         \"getVirtualIndex\",\n         \"getPointerBitmap\",\n+        \"isZeroInit\",\n+        \"getTargetInfo\",\n+        \"getLocation\",\n+        \"hasPostblit\",\n+        \"isCopyable\",\n         NULL\n     };\n \n-    traitsStringTable._init(40);\n+    traitsStringTable._init(56);\n \n     for (size_t idx = 0;; idx++)\n     {\n@@ -291,35 +484,6 @@ void *trait_search_fp(void *, const char *seed, int* cost)\n     return sv ? (void*)sv->ptrvalue : NULL;\n }\n \n-static int fpisTemplate(void *, Dsymbol *s)\n-{\n-    if (s->isTemplateDeclaration())\n-        return 1;\n-\n-    return 0;\n-}\n-\n-bool isTemplate(Dsymbol *s)\n-{\n-    if (!s->toAlias()->isOverloadable())\n-        return false;\n-\n-    return overloadApply(s, NULL, &fpisTemplate) != 0;\n-}\n-\n-Expression *isSymbolX(TraitsExp *e, bool (*fp)(Dsymbol *s))\n-{\n-    if (!e->args || !e->args->length)\n-        return False(e);\n-    for (size_t i = 0; i < e->args->length; i++)\n-    {\n-        Dsymbol *s = getDsymbol((*e->args)[i]);\n-        if (!s || !fp(s))\n-            return False(e);\n-    }\n-    return True(e);\n-}\n-\n /**\n  * get an array of size_t values that indicate possible pointer words in memory\n  *  if interpreted as the type given as argument\n@@ -491,11 +655,22 @@ static Expression *dimError(TraitsExp *e, int expected, int dim)\n \n Expression *semanticTraits(TraitsExp *e, Scope *sc)\n {\n-    if (e->ident != Id::compiles && e->ident != Id::isSame &&\n-        e->ident != Id::identifier && e->ident != Id::getProtection)\n+    if (e->ident != Id::compiles &&\n+        e->ident != Id::isSame &&\n+        e->ident != Id::identifier &&\n+        e->ident != Id::getProtection && e->ident != Id::getVisibility)\n     {\n+        // Pretend we're in a deprecated scope so that deprecation messages\n+        // aren't triggered when checking if a symbol is deprecated\n+        const StorageClass save = sc->stc;\n+        if (e->ident == Id::isDeprecated)\n+            sc->stc |= STCdeprecated;\n         if (!TemplateInstance::semanticTiargs(e->loc, sc, e->args, 1))\n+        {\n+            sc->stc = save;\n             return new ErrorExp();\n+        }\n+        sc->stc = save;\n     }\n     size_t dim = e->args ? e->args->length : 0;\n \n@@ -523,6 +698,14 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n     {\n         return isTypeX(e, &isTypeAssociativeArray);\n     }\n+    else if (e->ident == Id::isDeprecated)\n+    {\n+        return isDsymX(e, &isDsymDeprecated);\n+    }\n+    else if (e->ident == Id::isFuture)\n+    {\n+        return isDeclX(e, &isDeclFuture);\n+    }\n     else if (e->ident == Id::isStaticArray)\n     {\n         return isTypeX(e, &isTypeStaticArray);\n@@ -537,7 +720,10 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n     }\n     else if (e->ident == Id::isTemplate)\n     {\n-        return isSymbolX(e, &isTemplate);\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        return isDsymX(e, &isTemplate);\n     }\n     else if (e->ident == Id::isPOD)\n     {\n@@ -560,13 +746,50 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         }\n         return True(e);\n     }\n+    else if (e->ident == Id::hasPostblit)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        RootObject *o = (*e->args)[0];\n+        Type *t = isType(o);\n+        if (!t)\n+        {\n+            e->error(\"type expected as second argument of __traits %s instead of %s\",\n+                e->ident->toChars(), o->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        Type *tb = t->baseElemOf();\n+        if (StructDeclaration *sd = (tb->ty == Tstruct) ? ((TypeStruct *)tb)->sym : NULL)\n+        {\n+            return sd->postblit ? True(e) : False(e);\n+        }\n+        return False(e);\n+    }\n+    else if (e->ident == Id::isCopyable)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        RootObject *o = (*e->args)[0];\n+        Type *t = isType(o);\n+        if (!t)\n+        {\n+            e->error(\"type expected as second argument of __traits %s instead of %s\",\n+                e->ident->toChars(), o->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        return isCopyable(t) ? True(e) : False(e);\n+    }\n     else if (e->ident == Id::isNested)\n     {\n         if (dim != 1)\n             return dimError(e, 1, dim);\n \n         RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n+        Dsymbol *s = getDsymbolWithoutExpCtx(o);\n         if (!s)\n         {\n         }\n@@ -582,40 +805,88 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         e->error(\"aggregate or function expected instead of '%s'\", o->toChars());\n         return new ErrorExp();\n     }\n+    else if (e->ident == Id::isDisabled)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        return isFuncX(e, &isFuncDisabled);\n+    }\n     else if (e->ident == Id::isAbstractFunction)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isFuncX(e, &isFuncAbstractFunction);\n     }\n     else if (e->ident == Id::isVirtualFunction)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isFuncX(e, &isFuncVirtualFunction);\n     }\n     else if (e->ident == Id::isVirtualMethod)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isFuncX(e, &isFuncVirtualMethod);\n     }\n     else if (e->ident == Id::isFinalFunction)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isFuncX(e, &isFuncFinalFunction);\n     }\n     else if (e->ident == Id::isOverrideFunction)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isFuncX(e, &isFuncOverrideFunction);\n     }\n     else if (e->ident == Id::isStaticFunction)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isFuncX(e, &isFuncStaticFunction);\n     }\n+    else if (e->ident == Id::isModule)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        return isPkgX(e, &isPkgModule);\n+    }\n+    else if (e->ident == Id::isPackage)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        return isPkgX(e, &isPkgPackage);\n+    }\n     else if (e->ident == Id::isRef)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isDeclX(e, &isDeclRef);\n     }\n     else if (e->ident == Id::isOut)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isDeclX(e, &isDeclOut);\n     }\n     else if (e->ident == Id::isLazy)\n     {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n         return isDeclX(e, &isDeclLazy);\n     }\n     else if (e->ident == Id::identifier)\n@@ -639,7 +910,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         }\n         else\n         {\n-            Dsymbol *s = getDsymbol(o);\n+            Dsymbol *s = getDsymbolWithoutExpCtx(o);\n             if (!s || !s->ident)\n             {\n                 e->error(\"argument %s has no identifier\", o->toChars());\n@@ -651,7 +922,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         StringExp *se = new StringExp(e->loc, const_cast<char *>(id->toChars()));\n         return semantic(se, sc);\n     }\n-    else if (e->ident == Id::getProtection)\n+    else if (e->ident == Id::getProtection || e->ident == Id::getVisibility)\n     {\n         if (dim != 1)\n             return dimError(e, 1, dim);\n@@ -664,7 +935,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return new ErrorExp();\n \n         RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n+        Dsymbol *s = getDsymbolWithoutExpCtx(o);\n         if (!s)\n         {\n             if (!isError(o))\n@@ -685,7 +956,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return dimError(e, 1, dim);\n \n         RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n+        Dsymbol *s = getDsymbolWithoutExpCtx(o);\n         if (s)\n         {\n             if (FuncDeclaration *fd = s->isFuncDeclaration())   // Bugzilla 8943\n@@ -720,13 +991,51 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n         return resolve(e->loc, sc, s, false);\n     }\n+    else if (e->ident == Id::child)\n+    {\n+        if (dim != 2)\n+            return dimError(e, 2, dim);\n+\n+        Expression *ex;\n+        RootObject *op = (*e->args)[0];\n+        if (Dsymbol *symp = getDsymbol(op))\n+            ex = new DsymbolExp(e->loc, symp);\n+        else if (Expression *exp = isExpression(op))\n+            ex = exp;\n+        else\n+        {\n+            e->error(\"symbol or expression expected as first argument of __traits `child` instead of `%s`\", op->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        ex = semantic(ex, sc);\n+        RootObject *oc = (*e->args)[1];\n+        Dsymbol *symc = getDsymbol(oc);\n+        if (!symc)\n+        {\n+            e->error(\"symbol expected as second argument of __traits `child` instead of `%s`\", oc->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        if (Declaration *d = symc->isDeclaration())\n+            ex = new DotVarExp(e->loc, ex, d);\n+        else if (TemplateDeclaration *td = symc->isTemplateDeclaration())\n+            ex = new DotExp(e->loc, ex, new TemplateExp(e->loc, td));\n+        else if (ScopeDsymbol *ti = symc->isScopeDsymbol())\n+            ex = new DotExp(e->loc, ex, new ScopeExp(e->loc, ti));\n+        else\n+            assert(0);\n+\n+        ex = semantic(ex, sc);\n+        return ex;\n+    }\n     else if (e->ident == Id::hasMember ||\n              e->ident == Id::getMember ||\n              e->ident == Id::getOverloads ||\n              e->ident == Id::getVirtualMethods ||\n              e->ident == Id::getVirtualFunctions)\n     {\n-        if (dim != 2)\n+        if (dim != 2 && !(dim == 3 && e->ident == Id::getOverloads))\n             return dimError(e, 2, dim);\n \n         RootObject *o = (*e->args)[0];\n@@ -738,6 +1047,19 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         }\n         ex = ex->ctfeInterpret();\n \n+        bool includeTemplates = false;\n+        if (dim == 3 && e->ident == Id::getOverloads)\n+        {\n+            Expression *b = isExpression((*e->args)[2]);\n+            b = b->ctfeInterpret();\n+            if (!b->type->equals(Type::tbool))\n+            {\n+                e->error(\"`bool` expected as third argument of `__traits(getOverloads)`, not `%s` of type `%s`\", b->toChars(), b->type->toChars());\n+                return new ErrorExp();\n+            }\n+            includeTemplates = b->isBool(true);\n+        }\n+\n         StringExp *se = ex->toStringExp();\n         if (!se || se->len == 0)\n         {\n@@ -758,6 +1080,11 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         Dsymbol *sym = getDsymbol(o);\n         if (sym)\n         {\n+            if (e->ident == Id::hasMember)\n+            {\n+                if (sym->search(e->loc, id) != NULL)\n+                    return True(e);\n+            }\n             ex = new DsymbolExp(e->loc, sym);\n             ex = new DotIdExp(e->loc, ex, id);\n         }\n@@ -773,12 +1100,6 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n         if (e->ident == Id::hasMember)\n         {\n-            if (sym)\n-            {\n-                if (sym->search(e->loc, id))\n-                    return True(e);\n-            }\n-\n             /* Take any errors as meaning it wasn't found\n              */\n             Scope *scx = sc->push();\n@@ -814,7 +1135,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             /* Create tuple of functions of ex\n              */\n             Expressions *exps = new Expressions();\n-            FuncDeclaration *f;\n+            Dsymbol *f;\n             if (ex->op == TOKvar)\n             {\n                 VarExp *ve = (VarExp *)ex;\n@@ -830,13 +1151,43 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n                 else\n                     ex = dve->e1;\n             }\n+            else if (ex->op == TOKtemplate)\n+            {\n+                TemplateExp *te = (TemplateExp *)ex;\n+                TemplateDeclaration *td = te->td;\n+                f = td;\n+                if (td && td->funcroot)\n+                    f = td->funcroot;\n+                ex = NULL;\n+            }\n             else\n                 f = NULL;\n             Ptrait p;\n+            p.sym = sym;\n             p.exps = exps;\n             p.e1 = ex;\n             p.ident = e->ident;\n-            overloadApply(f, &p, &fptraits);\n+            p.includeTemplates = includeTemplates;\n+            AA *funcTypeHash = NULL;\n+            p.funcTypeHash = &funcTypeHash;\n+\n+            InterfaceDeclaration *ifd = NULL;\n+            if (sym)\n+                ifd = sym->isInterfaceDeclaration();\n+            // If the symbol passed as a parameter is an\n+            // interface that inherits other interfaces\n+            if (ifd && ifd->interfaces.length)\n+            {\n+                // check the overloads of each inherited interface individually\n+                for (size_t i = 0; i < ifd->interfaces.length; i++)\n+                {\n+                    BaseClass *bc = ifd->interfaces.ptr[i];\n+                    if (Dsymbol *fd = bc->sym->search(e->loc, f->ident))\n+                        overloadApply(fd, &p, &fptraits);\n+                }\n+            }\n+            else\n+                overloadApply(f, &p, &fptraits);\n \n             ex = new TupleExp(e->loc, exps);\n             ex = semantic(ex, scx);\n@@ -898,7 +1249,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return dimError(e, 1, dim);\n \n         RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n+        Dsymbol *s = getDsymbolWithoutExpCtx(o);\n         if (!s)\n         {\n             e->error(\"first argument is not a symbol\");\n@@ -917,30 +1268,14 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n     }\n     else if (e->ident == Id::getFunctionAttributes)\n     {\n-        /// extract all function attributes as a tuple (const/shared/inout/pure/nothrow/etc) except UDAs.\n+        /* extract all function attributes as a tuple (const/shared/inout/pure/nothrow/etc) except UDAs.\n+         * https://dlang.org/spec/traits.html#getFunctionAttributes\n+         */\n         if (dim != 1)\n             return dimError(e, 1, dim);\n \n-        RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n-        Type *t = isType(o);\n-        TypeFunction *tf = NULL;\n-        if (s)\n-        {\n-            if (FuncDeclaration *f = s->isFuncDeclaration())\n-                t = f->type;\n-            else if (VarDeclaration *v = s->isVarDeclaration())\n-                t = v->type;\n-        }\n-        if (t)\n-        {\n-            if (t->ty == Tfunction)\n-                tf = (TypeFunction *)t;\n-            else if (t->ty == Tdelegate)\n-                tf = (TypeFunction *)t->nextOf();\n-            else if (t->ty == Tpointer && t->nextOf()->ty == Tfunction)\n-                tf = (TypeFunction *)t->nextOf();\n-        }\n+        TypeFunction *tf = toTypeFunction((*e->args)[0]);\n+\n         if (!tf)\n         {\n             e->error(\"first argument is not a function\");\n@@ -956,6 +1291,27 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         TupleExp *tup = new TupleExp(e->loc, mods);\n         return semantic(tup, sc);\n     }\n+    else if (e->ident == Id::isReturnOnStack)\n+    {\n+        /* Extract as a boolean if function return value is on the stack\n+         * https://dlang.org/spec/traits.html#isReturnOnStack\n+         */\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        RootObject *o = (*e->args)[0];\n+        FuncDeclaration *fd = NULL;\n+        TypeFunction *tf = toTypeFunction(o, &fd);\n+\n+        if (!tf)\n+        {\n+            e->error(\"argument to `__traits(isReturnOnStack, %s)` is not a function\", o->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        bool value = target.isReturnOnStack(tf, fd && fd->needThis());\n+        return new IntegerExp(e->loc, value, Type::tbool);\n+    }\n     else if (e->ident == Id::getFunctionVariadicStyle)\n     {\n         /* Accept a symbol or a type. Returns one of the following:\n@@ -971,27 +1327,17 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         LINK link;\n         VarArg varargs;\n         RootObject *o = (*e->args)[0];\n-        Type *t = isType(o);\n-        TypeFunction *tf = NULL;\n-        if (t)\n-        {\n-            if (t->ty == Tfunction)\n-                tf = (TypeFunction *)t;\n-            else if (t->ty == Tdelegate)\n-                tf = (TypeFunction *)t->nextOf();\n-            else if (t->ty == Tpointer && t->nextOf()->ty == Tfunction)\n-                tf = (TypeFunction *)t->nextOf();\n-        }\n+        FuncDeclaration *fd = NULL;\n+        TypeFunction *tf = toTypeFunction(o, &fd);\n+\n         if (tf)\n         {\n             link = tf->linkage;\n             varargs = tf->parameterList.varargs;\n         }\n         else\n         {\n-            Dsymbol *s = getDsymbol(o);\n-            FuncDeclaration *fd = NULL;\n-            if (!s || (fd = s->isFuncDeclaration()) == NULL)\n+            if (!fd)\n             {\n                 e->error(\"argument to `__traits(getFunctionVariadicStyle, %s)` is not a function\", o->toChars());\n                 return new ErrorExp();\n@@ -1021,29 +1367,20 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         if (dim != 2)\n             return dimError(e, 2, dim);\n \n-        RootObject *o1 = (*e->args)[1];\n         RootObject *o = (*e->args)[0];\n-        Type *t = isType(o);\n-        TypeFunction *tf = NULL;\n-        if (t)\n-        {\n-            if (t->ty == Tfunction)\n-                tf = (TypeFunction *)t;\n-            else if (t->ty == Tdelegate)\n-                tf = (TypeFunction *)t->nextOf();\n-            else if (t->ty == Tpointer && t->nextOf()->ty == Tfunction)\n-                tf = (TypeFunction *)t->nextOf();\n-        }\n+        RootObject *o1 = (*e->args)[1];\n+\n+        FuncDeclaration *fd = NULL;\n+        TypeFunction *tf = toTypeFunction(o, &fd);\n+\n         ParameterList fparams;\n         if (tf)\n         {\n             fparams = tf->parameterList;\n         }\n         else\n         {\n-            Dsymbol *s = getDsymbol(o);\n-            FuncDeclaration *fd = NULL;\n-            if (!s || (fd = s->isFuncDeclaration()) == NULL)\n+            if (!fd)\n             {\n                 e->error(\"first argument to `__traits(getParameterStorageClasses, %s, %s)` is not a function\",\n                     o->toChars(), o1->toChars());\n@@ -1118,17 +1455,9 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n         LINK link;\n         RootObject *o = (*e->args)[0];\n-        Type *t = isType(o);\n-        TypeFunction *tf = NULL;\n-        if (t)\n-        {\n-            if (t->ty == Tfunction)\n-                tf = (TypeFunction *)t;\n-            else if (t->ty == Tdelegate)\n-                tf = (TypeFunction *)t->nextOf();\n-            else if (t->ty == Tpointer && t->nextOf()->ty == Tfunction)\n-                tf = (TypeFunction *)t->nextOf();\n-        }\n+\n+        TypeFunction *tf = toTypeFunction(o);\n+\n         if (tf)\n             link = tf->linkage;\n         else\n@@ -1421,7 +1750,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return dimError(e, 1, dim);\n \n         RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n+        Dsymbol *s = getDsymbolWithoutExpCtx(o);\n         if (!s)\n         {\n             e->error(\"argument %s to __traits(getUnitTests) must be a module or aggregate\",\n@@ -1455,7 +1784,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             return dimError(e, 1, dim);\n \n         RootObject *o = (*e->args)[0];\n-        Dsymbol *s = getDsymbol(o);\n+        Dsymbol *s = getDsymbolWithoutExpCtx(o);\n \n         FuncDeclaration *fd = s ? s->isFuncDeclaration() : NULL;\n         if (!fd)\n@@ -1471,6 +1800,75 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n     {\n         return pointerBitmap(e);\n     }\n+    else if (e->ident == Id::isZeroInit)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        RootObject *o = (*e->args)[0];\n+        Type *t = isType(o);\n+        if (!t)\n+        {\n+            e->error(\"type expected as second argument of __traits `%s` instead of `%s`\",\n+                e->ident->toChars(), o->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        Type *tb = t->baseElemOf();\n+        return tb->isZeroInit(e->loc) ? True(e) : False(e);\n+    }\n+    else if (e->ident == Id::getTargetInfo)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+\n+        Expression *ex = isExpression((*e->args)[0]);\n+        StringExp *se = ex ? ex->ctfeInterpret()->toStringExp() : NULL;\n+        if (!ex || !se || se->len == 0)\n+        {\n+            e->error(\"string expected as argument of __traits `%s` instead of `%s`\", e->ident->toChars(), ex->toChars());\n+            return new ErrorExp();\n+        }\n+        se = se->toUTF8(sc);\n+\n+        Expression *r = target.getTargetInfo(se->toPtr(), e->loc);\n+        if (!r)\n+        {\n+            e->error(\"`getTargetInfo` key `\\\"%s\\\"` not supported by this implementation\", se->toPtr());\n+            return new ErrorExp();\n+        }\n+        return semantic(r, sc);\n+    }\n+    else if (e->ident == Id::getLocation)\n+    {\n+        if (dim != 1)\n+            return dimError(e, 1, dim);\n+        RootObject *arg0 = (*e->args)[0];\n+        Dsymbol *s = getDsymbolWithoutExpCtx(arg0);\n+        if (!s || !s->loc.filename)\n+        {\n+            e->error(\"can only get the location of a symbol, not `%s`\", arg0->toChars());\n+            return new ErrorExp();\n+        }\n+\n+        const FuncDeclaration *fd = s->isFuncDeclaration();\n+        if (fd && fd->overnext)\n+        {\n+            e->error(\"cannot get location of an overload set, \"\n+                     \"use `__traits(getOverloads, ..., \\\"%s\\\"%s)[N]` \"\n+                     \"to get the Nth overload\",\n+                     arg0->toChars(), \"\");\n+            return new ErrorExp();\n+        }\n+\n+        Expressions *exps = new Expressions();\n+        exps->setDim(3);\n+        (*exps)[0] = new StringExp(e->loc, const_cast<char *>(s->loc.filename), strlen(s->loc.filename));\n+        (*exps)[1] = new IntegerExp(e->loc, s->loc.linnum, Type::tint32);\n+        (*exps)[2] = new IntegerExp(e->loc, s->loc.charnum, Type::tint32);\n+        TupleExp *tup = new TupleExp(e->loc, exps);\n+        return semantic(tup, sc);\n+    }\n \n     if (const char *sub = (const char *)speller(e->ident->toChars(), &trait_search_fp, NULL, idchars))\n         e->error(\"unrecognized trait '%s', did you mean '%s'?\", e->ident->toChars(), sub);"}, {"sha": "0b9ccf318765787af9699962cfeb268fefc24a69", "filename": "gcc/testsuite/gdc.test/compilable/Test16206.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FTest16206.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FTest16206.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FTest16206.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,28 @@\n+struct S {\n+    static int foo()() { return 0; }\n+    static int foo()(int n) { return 1; }\n+    static int foo(string s) { return 2; }\n+    enum foo(int[] arr) = arr.length;\n+}\n+\n+alias AliasSeq(T...) = T;\n+\n+alias allFoos = AliasSeq!(__traits(getOverloads, S, \"foo\", true));\n+\n+static assert(allFoos.length == 4);\n+\n+static assert(allFoos[0](\"\") == 2);\n+static assert(allFoos[1]() == 0);\n+static assert(allFoos[2](1) == 1);\n+alias foo3 = allFoos[3];\n+static assert(foo3!([]) == 0);\n+\n+static assert(S.foo() == 0);\n+static assert(S.foo(1) == 1);\n+static assert(S.foo(\"\") == 2);\n+static assert(S.foo!([]) == 0);\n+\n+\n+alias fooFuns = AliasSeq!(__traits(getOverloads, S, \"foo\"));\n+static assert(fooFuns.length == 1);\n+static assert(fooFuns[0](\"\") == 2);\n\\ No newline at end of file"}, {"sha": "b6e98ff011b0f26b2599c5ea1c498e14f682a5c4", "filename": "gcc/testsuite/gdc.test/compilable/imports/pkgmodule/package.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkgmodule%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkgmodule%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkgmodule%2Fpackage.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,3 @@\n+/// Used to test is(x == package) and is(x == module)\n+\n+module imports.pkgmodule;"}, {"sha": "948a87e5feeeaa360c6efc98c490a5e60dffcb10", "filename": "gcc/testsuite/gdc.test/compilable/imports/pkgmodule/plainmodule.d", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkgmodule%2Fplainmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkgmodule%2Fplainmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fpkgmodule%2Fplainmodule.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,2 @@\n+/// Used to test is(x == module)\n+module imports.pkgmodule.plainmodule;"}, {"sha": "9e9933b379bd962117b080f4b9c0f630a9dd9b7c", "filename": "gcc/testsuite/gdc.test/compilable/imports/plainpackage/plainmodule.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fplainpackage%2Fplainmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fplainpackage%2Fplainmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fplainpackage%2Fplainmodule.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,4 @@\n+/// Used to test is(x == module)\n+\n+module imports.plainpackage.plainmodule;\n+"}, {"sha": "b5423cfb636063073454ad95fe473df288ac2e86", "filename": "gcc/testsuite/gdc.test/compilable/isZeroInit.d", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FisZeroInit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FisZeroInit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FisZeroInit.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,78 @@\n+alias AliasSeq(T...) = T;\n+\n+struct Holder(T, ubyte val)\n+{\n+    T x = val;\n+}\n+\n+struct SArrayHolder(T, ubyte val)\n+{\n+    T[2] x = val;\n+}\n+\n+static foreach (T; AliasSeq!(bool, byte, short, int, long,\n+                             ubyte, ushort, uint, ulong,\n+                             char, wchar, dchar,\n+                             float, double, real))\n+{\n+    static assert(__traits(isZeroInit, T) == (T.init is T(0)));\n+    static assert(__traits(isZeroInit, T[2]) == (T.init is T(0)));\n+\n+    static assert(!__traits(isZeroInit, Holder!(T, 1)));\n+    static assert(__traits(isZeroInit, Holder!(T, 0)));\n+\n+    static assert(__traits(isZeroInit, SArrayHolder!(T, 0)));\n+    static assert(!__traits(isZeroInit, SArrayHolder!(T, 1)));\n+\n+}\n+\n+static assert(__traits(isZeroInit, void)); // For initializing arrays of element type `void`.\n+static assert(__traits(isZeroInit, void*));\n+static assert(__traits(isZeroInit, void[]));\n+static assert(__traits(isZeroInit, float[]));\n+static assert(__traits(isZeroInit, Object));\n+class C1 : Object\n+{\n+    int x = 1;\n+}\n+static assert(__traits(isZeroInit, C1)); // An Object's fields are irrelevant.\n+\n+struct S1\n+{\n+    int[] a;\n+    int b;\n+}\n+static assert(__traits(isZeroInit, S1));\n+\n+struct S2\n+{\n+    alias H = Holder!(int, 1);\n+    H h;\n+    int a;\n+}\n+static assert(!__traits(isZeroInit, S2));\n+\n+struct S3\n+{\n+    S1 h;\n+    float f = 0;\n+}\n+static assert(__traits(isZeroInit, S3));\n+\n+struct S4\n+{\n+    S2 h = S2(S2.H(0), 0);\n+    int a;\n+}\n+static assert(__traits(isZeroInit, S4));\n+\n+struct S5\n+{\n+    Object o = null;\n+}\n+static assert(__traits(isZeroInit, S5));\n+\n+version(D_SIMD):\n+import core.simd : int4;\n+static assert(__traits(isZeroInit, Holder!(int4, 0)));\n+static assert(!__traits(isZeroInit, Holder!(int4, 1)));"}, {"sha": "8bdb97de13f295a10ea560a657b4d51075b0f8ee", "filename": "gcc/testsuite/gdc.test/compilable/isreturnonstack.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fisreturnonstack.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fisreturnonstack.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fisreturnonstack.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,7 @@\n+struct S { int[10] a; }\n+int test1();\n+S test2();\n+\n+static assert(__traits(isReturnOnStack, test1) == false);\n+static assert(__traits(isReturnOnStack, test2) == true);\n+"}, {"sha": "14e178988c8f2add1f74247bebab0d919761c43b", "filename": "gcc/testsuite/gdc.test/compilable/line.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fline.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fline.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fline.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -19,12 +19,12 @@ static assert(__FILE_FULL_PATH__[$-__FILE__.length..$] == __FILE__);\n \n static assert(__LINE__ == 101);\n static assert(__FILE__ == \"newfile.d\");\n-static assert(__FILE_FULL_PATH__ == \"newfile.d\");\n+static assert(__FILE_FULL_PATH__[$ - 9 .. $] == \"newfile.d\");\n \n # line 200\n \n static assert(__LINE__ == 201);\n static assert(__FILE__ == \"newfile.d\");\n-static assert(__FILE_FULL_PATH__ == \"newfile.d\");\n+static assert(__FILE_FULL_PATH__[$ - 9 .. $] == \"newfile.d\");\n \n "}, {"sha": "f3303c0e31076eaaf9ddf36d31580d1832014997", "filename": "gcc/testsuite/gdc.test/compilable/test16002.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16002.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16002.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16002.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,24 @@\n+module test.compilable.test16002;\n+\n+import imports.plainpackage.plainmodule;\n+import imports.pkgmodule.plainmodule;\n+\n+struct MyStruct;\n+\n+alias a = imports.plainpackage;\n+alias b = imports.pkgmodule.plainmodule;\n+\n+static assert(is(imports.plainpackage == package));\n+static assert(is(a == package));\n+static assert(!is(imports.plainpackage.plainmodule == package));\n+static assert(!is(b == package));\n+static assert(is(imports.pkgmodule == package));\n+static assert(!is(MyStruct == package));\n+\n+static assert(!is(imports.plainpackage == module));\n+static assert(!is(a == module));\n+static assert(is(imports.plainpackage.plainmodule == module));\n+static assert(is(b == module));\n+// This is supposed to work even though we haven't directly imported imports.pkgmodule.\n+static assert(is(imports.pkgmodule == module));\n+static assert(!is(MyStruct == module));"}, {"sha": "3244c129aa94e6cac36600a3065a51f98dfcff8e", "filename": "gcc/testsuite/gdc.test/compilable/test17791.d", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17791.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17791.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17791.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,28 @@\n+/*\n+REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+---\n+*/\n+deprecated(\"A deprecated class\") {\n+class DepClass\n+{\n+}\n+}\n+\n+class NewClass\n+{\n+}\n+\n+void main()\n+{\n+    // test that a symbol (which is not likely to be deprecated)\n+    // is not depercated\n+    static assert(!__traits(isDeprecated, int));\n+    // check that a class marked deprecated \"isDeprecated\"\n+    static assert(__traits(isDeprecated, DepClass));\n+    // check that a class not marked deprecated is not deprecated\n+    static assert(!__traits(isDeprecated, NewClass));\n+    // Check for expressions (18617)\n+    static assert(__traits(isDeprecated, { scope foo = new DepClass; }));\n+}"}, {"sha": "4d8a5e140c4b536ae8e7993dea09137b4899892a", "filename": "gcc/testsuite/gdc.test/compilable/traits.d", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftraits.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -1,10 +1,140 @@\n // REQUIRED_ARGS:\n+// EXTRA_FILES: imports/plainpackage/plainmodule.d imports/pkgmodule/package.d imports/pkgmodule/plainmodule.d\n \n // This file is intended to contain all compilable traits-related tests in an\n // effort to keep the number of files in the `compilable` folder to a minimum.\n \n+// https://issues.dlang.org/show_bug.cgi?id=19152\n+module traits;\n+\n+class C19152\n+{\n+    int OnExecute()\n+    {\n+        auto name = __traits(getOverloads, this, \"OnExecute\").stringof;\n+        return 0;\n+    }\n+}\n+\n+static assert(is(typeof(__traits(getTargetInfo, \"cppRuntimeLibrary\")) == string));\n+version (CppRuntime_Microsoft)\n+{\n+    static assert(__traits(getTargetInfo, \"cppRuntimeLibrary\") == \"libcmt\");\n+}\n+\n+import imports.plainpackage.plainmodule;\n+import imports.pkgmodule.plainmodule;\n+\n+#line 40\n+struct MyStruct;\n+\n+alias a = imports.plainpackage;\n+alias b = imports.pkgmodule.plainmodule;\n+\n+static assert(__traits(isPackage, imports.plainpackage));\n+static assert(__traits(isPackage, a));\n+static assert(!__traits(isPackage, imports.plainpackage.plainmodule));\n+static assert(!__traits(isPackage, b));\n+static assert(__traits(isPackage, imports.pkgmodule));\n+static assert(!__traits(isPackage, MyStruct));\n+\n+static assert(!__traits(isModule, imports.plainpackage));\n+static assert(!__traits(isModule, a));\n+static assert(__traits(isModule, imports.plainpackage.plainmodule));\n+static assert(__traits(isModule, b));\n+// This is supposed to work even though we haven't directly imported imports.pkgmodule.\n+static assert(__traits(isModule, imports.pkgmodule));\n+static assert(!__traits(isModule, MyStruct));\n+\n /******************************************/\n // https://issues.dlang.org/show_bug.cgi?id=19942\n \n static assert(!__traits(compiles, { a.init; }));\n static assert(!__traits(compiles, { import m : a; a.init; }));\n+\n+version(Windows)\n+    static assert(__traits(getLocation, MyStruct)[0] == `compilable\\traits.d`);\n+else\n+    static assert(__traits(getLocation, MyStruct)[0] == \"compilable/traits.d\");\n+static assert(__traits(getLocation, MyStruct)[1] == 40);\n+static assert(__traits(getLocation, MyStruct)[2] == 1);\n+\n+int foo();\n+int foo(int);\n+\n+static assert(__traits(getLocation, __traits(getOverloads, traits, \"foo\")[1])[1] == 74);\n+\n+mixin(\"int bar;\");\n+static assert(__traits(getLocation, bar)[1] == 78);\n+\n+struct Outer\n+{\n+    struct Nested{}\n+\n+    void method() {}\n+}\n+static assert(__traits(getLocation, Outer.Nested)[1] == 83);\n+static assert(__traits(getLocation, Outer.method)[1] == 85);\n+\n+/******************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=19902\n+// Define hasElaborateCopyConstructor trait\n+// but done as two independent traits per conversation\n+// in https://github.com/dlang/dmd/pull/10265\n+\n+struct S\n+{\n+    this (ref S rhs) {}\n+}\n+\n+struct OuterS\n+{\n+    struct S\n+    {\n+        this (ref S rhs) {}\n+    }\n+\n+    S s;\n+}\n+\n+void foo(T)()\n+{\n+    struct S(U)\n+    {\n+        this (ref S rhs) {}\n+    }\n+}\n+\n+struct U(T)\n+{\n+    this (ref U rhs) {}\n+}\n+\n+struct SPostblit\n+{\n+    this(this) {}\n+}\n+\n+struct DisabledPostblit\n+{\n+    @disable this(this);\n+}\n+\n+struct NoCpCtor { }\n+class C19902 { }\n+\n+static assert(__traits(compiles, foo!int));\n+static assert(__traits(compiles, foo!S));\n+static assert(!__traits(hasPostblit, U!S));\n+static assert(__traits(hasPostblit, SPostblit));\n+\n+static assert(!__traits(hasPostblit, NoCpCtor));\n+static assert(!__traits(hasPostblit, C19902));\n+static assert(!__traits(hasPostblit, int));\n+\n+// Check that invalid use cases don't compile\n+static assert(!__traits(compiles, __traits(hasPostblit)));\n+static assert(!__traits(compiles, __traits(hasPostblit, S())));\n+\n+static assert(__traits(isCopyable, int));\n+static assert(!__traits(isCopyable, DisabledPostblit));"}, {"sha": "3c1cc56782ea72520959a0a1f2917d936ef50b88", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail16206a.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16206a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16206a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16206a.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,12 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail16206a.d(12): Error: `bool` expected as third argument of `__traits(getOverloads)`, not `\"Not a bool\"` of type `string`\n+---\n+*/\n+\n+struct S {\n+    static int foo()() { return 0; }\n+}\n+alias AliasSeq(T...) = T;\n+alias allFoos = AliasSeq!(__traits(getOverloads, S, \"foo\", \"Not a bool\"));\n\\ No newline at end of file"}, {"sha": "9b3a69c0914dec55ede232bacba99e6f209aaa7e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail16206b.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16206b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16206b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16206b.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,12 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail16206b.d(12): Error: expected 2 arguments for `hasMember` but had 3\n+---\n+*/\n+\n+struct S {\n+    static int foo()() { return 0; }\n+}\n+alias AliasSeq(T...) = T;\n+alias allFoos = AliasSeq!(__traits(hasMember, S, \"foo\", true));\n\\ No newline at end of file"}, {"sha": "a352984742f88faa087a34ff3eeef807a1a3779a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail_isZeroInit.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_isZeroInit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_isZeroInit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail_isZeroInit.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,12 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail_isZeroInit.d(11): Error: type expected as second argument of __traits `isZeroInit` instead of `a`\n+---\n+*/\n+void test()\n+{\n+    int a = 3;\n+    // Providing a specific variable rather than a type isn't allowed.\n+    enum bool az = __traits(isZeroInit, a);\n+}"}, {"sha": "1dde6991baab91910649d5f246a341bad03f1892", "filename": "gcc/testsuite/gdc.test/fail_compilation/isreturnonstack.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fisreturnonstack.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fisreturnonstack.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fisreturnonstack.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,12 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/isreturnonstack.d(11): Error: argument to `__traits(isReturnOnStack, int)` is not a function\n+fail_compilation/isreturnonstack.d(12): Error: expected 1 arguments for `isReturnOnStack` but had 2\n+---\n+*/\n+\n+int test() { return 0; }\n+\n+enum b = __traits(isReturnOnStack, int);\n+enum c = __traits(isReturnOnStack, test, int);"}, {"sha": "80ae40b6b88b0a9d838a1a40af7bc9465c3261cc", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16002.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16002.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16002.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16002.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,15 @@\n+/*\n+REQUIRED_ARGS:\n+PERMUTE_ARGS:\n+TEST_OUTPUT:\n+---\n+fail_compilation/test16002.d(100): Error: undefined identifier `imports.nonexistent`\n+fail_compilation/test16002.d(101): Error: undefined identifier `imports.nonexistent`\n+---\n+*/\n+\n+module test.fail_compilation.test16002;\n+\n+#line 100\n+enum A = is(imports.nonexistent == package);\n+enum B = is(imports.nonexistent == module);"}, {"sha": "e421419ae2d03a1dfecc761f0f372b523eef4eac", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17096.d", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17096.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17096.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17096.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,50 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test17096.d(28): Error: expected 1 arguments for `isPOD` but had 2\n+fail_compilation/test17096.d(29): Error: expected 1 arguments for `isNested` but had 2\n+fail_compilation/test17096.d(30): Error: expected 1 arguments for `isVirtualFunction` but had 2\n+fail_compilation/test17096.d(31): Error: expected 1 arguments for `isVirtualMethod` but had 2\n+fail_compilation/test17096.d(32): Error: expected 1 arguments for `isAbstractFunction` but had 2\n+fail_compilation/test17096.d(33): Error: expected 1 arguments for `isFinalFunction` but had 2\n+fail_compilation/test17096.d(34): Error: expected 1 arguments for `isOverrideFunction` but had 2\n+fail_compilation/test17096.d(35): Error: expected 1 arguments for `isStaticFunction` but had 2\n+fail_compilation/test17096.d(36): Error: expected 1 arguments for `isRef` but had 2\n+fail_compilation/test17096.d(37): Error: expected 1 arguments for `isOut` but had 2\n+fail_compilation/test17096.d(38): Error: expected 1 arguments for `isLazy` but had 2\n+fail_compilation/test17096.d(39): Error: expected 1 arguments for `identifier` but had 2\n+fail_compilation/test17096.d(40): Error: expected 1 arguments for `getProtection` but had 2\n+fail_compilation/test17096.d(41): Error: expected 1 arguments for `parent` but had 2\n+fail_compilation/test17096.d(42): Error: expected 1 arguments for `classInstanceSize` but had 2\n+fail_compilation/test17096.d(43): Error: expected 1 arguments for `allMembers` but had 2\n+fail_compilation/test17096.d(44): Error: expected 1 arguments for `derivedMembers` but had 2\n+fail_compilation/test17096.d(45): Error: expected 1 arguments for `getAliasThis` but had 2\n+fail_compilation/test17096.d(46): Error: expected 1 arguments for `getAttributes` but had 2\n+fail_compilation/test17096.d(47): Error: expected 1 arguments for `getFunctionAttributes` but had 2\n+fail_compilation/test17096.d(48): Error: expected 1 arguments for `getUnitTests` but had 2\n+fail_compilation/test17096.d(49): Error: expected 1 arguments for `getVirtualIndex` but had 2\n+fail_compilation/test17096.d(50): Error: a single type expected for trait pointerBitmap\n+---\n+*/\n+enum b03 = __traits(isPOD, 1, 2);\n+enum b04 = __traits(isNested, 1, 2);\n+enum b05 = __traits(isVirtualFunction, 1, 2);\n+enum b06 = __traits(isVirtualMethod, 1, 2);\n+enum b07 = __traits(isAbstractFunction, 1, 2);\n+enum b08 = __traits(isFinalFunction, 1, 2);\n+enum b09 = __traits(isOverrideFunction, 1, 2);\n+enum b10 = __traits(isStaticFunction, 1, 2);\n+enum b11 = __traits(isRef, 1, 2);\n+enum b12 = __traits(isOut, 1, 2);\n+enum b13 = __traits(isLazy, 1, 2);\n+enum b14 = __traits(identifier, 1, 2);\n+enum b15 = __traits(getProtection, 1, 2);\n+enum b16 = __traits(parent, 1, 2);\n+enum b17 = __traits(classInstanceSize, 1, 2);\n+enum b18 = __traits(allMembers, 1, 2);\n+enum b19 = __traits(derivedMembers, 1, 2);\n+enum b20 = __traits(getAliasThis, 1, 2);\n+enum b21 = __traits(getAttributes, 1, 2);\n+enum b22 = __traits(getFunctionAttributes, 1, 2);\n+enum b23 = __traits(getUnitTests, 1, 2);\n+enum b24 = __traits(getVirtualIndex, 1, 2);\n+enum b25 = __traits(getPointerBitmap, 1, 2);"}, {"sha": "8d5d480174e085a7db9ff14c07a34a39ee79bd33", "filename": "gcc/testsuite/gdc.test/fail_compilation/trait_loc_err.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftrait_loc_err.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftrait_loc_err.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftrait_loc_err.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,15 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/trait_loc_err.d(13): Error: can only get the location of a symbol, not `trait_loc_err`\n+fail_compilation/trait_loc_err.d(14): Error: can only get the location of a symbol, not `std`\n+---\n+*/\n+module trait_loc_err;\n+import std.stdio;\n+\n+void main()\n+{\n+    __traits(getLocation, __traits(parent, main));\n+    __traits(getLocation, __traits(parent, std.stdio));\n+}"}, {"sha": "313e57da4c9ee9222a1b1fc654f7fda72af9437e", "filename": "gcc/testsuite/gdc.test/fail_compilation/trait_loc_ov_err.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftrait_loc_ov_err.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftrait_loc_ov_err.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftrait_loc_ov_err.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,40 @@\n+module trait_loc_ov_err;\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/trait_loc_ov_err.d(24): Error: cannot get location of an overload set, use `__traits(getOverloads, ..., \"ov1\")[N]` to get the Nth overload\n+fail_compilation/trait_loc_ov_err.d(25): Error: cannot get location of an overload set, use `__traits(getOverloads, ..., \"ov2\")[N]` to get the Nth overload\n+---\n+*/\n+\n+void ov1(){}\n+void ov1(int){}\n+\n+void ov21(){}\n+void ov22(int){}\n+alias ov2 = ov21;\n+alias ov2 = ov22;\n+\n+template OvT(T, U){}\n+template OvT(T){}\n+\n+auto func(T)(T t) {}\n+auto func(T,U)(T t,U u) {}\n+\n+enum e1 = __traits(getLocation, ov1);\n+enum e2 = __traits(getLocation, ov2);\n+\n+enum e3 = __traits(getLocation, OvT);\n+enum e4 = __traits(getLocation, func);\n+\n+enum e5 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"ov1\")[0]);\n+enum e6 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"ov1\")[1]);\n+\n+enum e7 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"ov2\")[0]);\n+enum e8 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"ov2\")[1]);\n+\n+enum e9  = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"OvT\", true)[1]);\n+enum e10 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"OvT\", true)[0]);\n+\n+enum e11 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"func\", true)[0]);\n+enum e12 = __traits(getLocation, __traits(getOverloads, trait_loc_ov_err, \"func\", true)[1]);"}, {"sha": "bee29ed1d76a0d602578f1e4b5430b45f6d4b6fd", "filename": "gcc/testsuite/gdc.test/fail_compilation/traits.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,27 @@\n+/************************************************************/\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits.d(100): Error: `getTargetInfo` key `\"not_a_target_info\"` not supported by this implementation\n+fail_compilation/traits.d(101): Error: string expected as argument of __traits `getTargetInfo` instead of `100`\n+fail_compilation/traits.d(102): Error: expected 1 arguments for `getTargetInfo` but had 2\n+fail_compilation/traits.d(103): Error: expected 1 arguments for `getTargetInfo` but had 0\n+fail_compilation/traits.d(200): Error: undefined identifier `imports.nonexistent`\n+fail_compilation/traits.d(201): Error: undefined identifier `imports.nonexistent`\n+fail_compilation/traits.d(202): Error: expected 1 arguments for `isPackage` but had 0\n+fail_compilation/traits.d(203): Error: expected 1 arguments for `isModule` but had 0\n+---\n+*/\n+\n+#line 100\n+enum A1 = __traits(getTargetInfo, \"not_a_target_info\");\n+enum B1 = __traits(getTargetInfo, 100);\n+enum C1 = __traits(getTargetInfo, \"cppRuntimeLibrary\", \"bits\");\n+enum D1 = __traits(getTargetInfo);\n+\n+#line 200\n+enum A2 = __traits(isPackage, imports.nonexistent);\n+enum B2 = __traits(isModule, imports.nonexistent);\n+enum C2 = __traits(isPackage);\n+enum D2 = __traits(isModule);"}, {"sha": "7a0b75e0c9c46fa6bc8e9434ea00aeef0f9dc26f", "filename": "gcc/testsuite/gdc.test/fail_compilation/traits_child.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_child.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_child.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_child.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,17 @@\n+/************************************************************/\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_child.d(100): Error: expected 2 arguments for `child` but had 1\n+fail_compilation/traits_child.d(101): Error: symbol or expression expected as first argument of __traits \n+child` instead of `long`\n+fail_compilation/traits_child.d(102): Error: symbol expected as second argument of __traits `child` inste\n+d of `3`\n+---\n+*/\n+\n+#line 100\n+enum a = __traits(child, long);\n+enum b = __traits(child, long, 3);\n+enum c = __traits(child, \"hi\", 3);"}, {"sha": "8916cfd2a90e335253746d3657d5f43736524f79", "filename": "gcc/testsuite/gdc.test/runnable/imports/test18322import.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftest18322import.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftest18322import.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftest18322import.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,14 @@\n+module test18322import;\n+void fun(string templateFileFullPath = __FILE_FULL_PATH__,\n+    string templateFile = __FILE__)(string expectedFilename, string fileFullPath = __FILE_FULL_PATH__)\n+{\n+    // make sure it is an absolute path\n+    version(Windows)\n+        assert(fileFullPath[1..3] == \":\\\\\");\n+    else\n+        assert(fileFullPath[0] == '/');\n+\n+    assert(templateFileFullPath == fileFullPath);\n+    assert(fileFullPath[$ - expectedFilename.length .. $] == expectedFilename);\n+    assert(fileFullPath[$ - templateFile.length .. $] == templateFile);\n+}"}, {"sha": "93753baf27b5020a63a7d2e87bfca24902ecdc23", "filename": "gcc/testsuite/gdc.test/runnable/test17373.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17373.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17373.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17373.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,20 @@\n+interface Foo { void visit (int); }\n+interface Bar { void visit(double); }\n+interface FooBar : Foo, Bar {}\n+static assert(__traits(getOverloads, FooBar, \"visit\").length == 2);\n+\n+interface Fbar { void visit(char); void visit(double); }\n+interface Triple : Foo, Bar, Fbar {}\n+static assert(__traits(getOverloads, Triple, \"visit\").length == 3);\n+\n+interface InheritanceMadness : FooBar, Triple {}\n+static assert(__traits(getOverloads, Triple, \"visit\").length == 3);\n+\n+interface Simple\n+{\n+    int square(int);\n+    real square(real);\n+}\n+static assert(__traits(getOverloads, Simple, \"square\").length == 2);\n+\n+void main() {}"}, {"sha": "77b5a52bb28a6ff8e81805b2d6c80a147f31eaea", "filename": "gcc/testsuite/gdc.test/runnable/test17878.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17878.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17878.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest17878.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,19 @@\n+@__future int foo()\n+{\n+    return 0;\n+}\n+\n+int bar()\n+{\n+    return 1;\n+}\n+\n+@__future int c;\n+\n+\n+void main()\n+{\n+    static assert(__traits(isFuture, foo));\n+    static assert(!__traits(isFuture, bar));\n+    static assert(__traits(isFuture, c));\n+}"}, {"sha": "97e2e976440ed9075bc375ce6918938eebd2569c", "filename": "gcc/testsuite/gdc.test/runnable/test18322.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18322.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18322.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18322.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,21 @@\n+/*\n+REQUIRED_ARGS: -Irunnable/imports\n+COMPILED_IMPORTS: imports/test18322import.d\n+PERMUTE_ARGS:\n+*/\n+import test18322import;\n+void main(){\n+    version(Windows)\n+        auto sep = \"\\\\\";\n+    else\n+        auto sep = \"/\";\n+\n+    auto filename = \"runnable\" ~ sep ~ \"test18322.d\";\n+\n+    fun(filename);\n+    mixin(`fun(filename ~ \"-mixin-16\");`);\n+\n+    #line 100 \"poundlinefile.d\"\n+    fun(\"poundlinefile.d\");\n+    mixin(`fun(\"poundlinefile.d-mixin-101\");`);\n+}"}, {"sha": "3cdfe83afa0a86f42e8465bb7715e29fbbc55bc7", "filename": "gcc/testsuite/gdc.test/runnable/traits.d", "status": "modified", "additions": 102, "deletions": 78, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -12,6 +12,7 @@ class AC2 { abstract void foo(); }\n class AC3 : AC2 { }\n final class FC { void foo() { } }\n enum E { EMEM }\n+struct D1 { @disable void true_(); void false_(){} }\n \n /********************************************************/\n \n@@ -623,7 +624,7 @@ struct Test24\n     private void test24(int, int){}\n }\n \n-static assert(__traits(getProtection, __traits(getOverloads, Test24, \"test24\")[1]) == \"private\");\n+static assert(__traits(getVisibility, __traits(getOverloads, Test24, \"test24\")[1]) == \"private\");\n \n /********************************************************/\n // 1369\n@@ -878,7 +879,7 @@ protected struct TestProt3 {}\n public    struct TestProt4 {}\n export    struct TestProt5 {}\n \n-void getProtection()\n+void getVisibility()\n {\n     class Test\n     {\n@@ -891,52 +892,52 @@ void getProtection()\n     Test t;\n \n     // TOKvar and VarDeclaration\n-    static assert(__traits(getProtection, Test.va) == \"private\");\n-    static assert(__traits(getProtection, Test.vb) == \"package\");\n-    static assert(__traits(getProtection, Test.vc) == \"protected\");\n-    static assert(__traits(getProtection, Test.vd) == \"public\");\n-    static assert(__traits(getProtection, Test.ve) == \"export\");\n+    static assert(__traits(getVisibility, Test.va) == \"private\");\n+    static assert(__traits(getVisibility, Test.vb) == \"package\");\n+    static assert(__traits(getVisibility, Test.vc) == \"protected\");\n+    static assert(__traits(getVisibility, Test.vd) == \"public\");\n+    static assert(__traits(getVisibility, Test.ve) == \"export\");\n \n     // TOKdotvar and VarDeclaration\n-    static assert(__traits(getProtection, t.va) == \"private\");\n-    static assert(__traits(getProtection, t.vb) == \"package\");\n-    static assert(__traits(getProtection, t.vc) == \"protected\");\n-    static assert(__traits(getProtection, t.vd) == \"public\");\n-    static assert(__traits(getProtection, t.ve) == \"export\");\n+    static assert(__traits(getVisibility, t.va) == \"private\");\n+    static assert(__traits(getVisibility, t.vb) == \"package\");\n+    static assert(__traits(getVisibility, t.vc) == \"protected\");\n+    static assert(__traits(getVisibility, t.vd) == \"public\");\n+    static assert(__traits(getVisibility, t.ve) == \"export\");\n \n     // TOKvar and FuncDeclaration\n-    static assert(__traits(getProtection, Test.fa) == \"private\");\n-    static assert(__traits(getProtection, Test.fb) == \"package\");\n-    static assert(__traits(getProtection, Test.fc) == \"protected\");\n-    static assert(__traits(getProtection, Test.fd) == \"public\");\n-    static assert(__traits(getProtection, Test.fe) == \"export\");\n+    static assert(__traits(getVisibility, Test.fa) == \"private\");\n+    static assert(__traits(getVisibility, Test.fb) == \"package\");\n+    static assert(__traits(getVisibility, Test.fc) == \"protected\");\n+    static assert(__traits(getVisibility, Test.fd) == \"public\");\n+    static assert(__traits(getVisibility, Test.fe) == \"export\");\n \n     // TOKdotvar and FuncDeclaration\n-    static assert(__traits(getProtection, t.fa) == \"private\");\n-    static assert(__traits(getProtection, t.fb) == \"package\");\n-    static assert(__traits(getProtection, t.fc) == \"protected\");\n-    static assert(__traits(getProtection, t.fd) == \"public\");\n-    static assert(__traits(getProtection, t.fe) == \"export\");\n+    static assert(__traits(getVisibility, t.fa) == \"private\");\n+    static assert(__traits(getVisibility, t.fb) == \"package\");\n+    static assert(__traits(getVisibility, t.fc) == \"protected\");\n+    static assert(__traits(getVisibility, t.fd) == \"public\");\n+    static assert(__traits(getVisibility, t.fe) == \"export\");\n \n     // TOKtype\n-    static assert(__traits(getProtection, TestProt1) == \"private\");\n-    static assert(__traits(getProtection, TestProt2) == \"package\");\n-    static assert(__traits(getProtection, TestProt3) == \"protected\");\n-    static assert(__traits(getProtection, TestProt4) == \"public\");\n-    static assert(__traits(getProtection, TestProt5) == \"export\");\n+    static assert(__traits(getVisibility, TestProt1) == \"private\");\n+    static assert(__traits(getVisibility, TestProt2) == \"package\");\n+    static assert(__traits(getVisibility, TestProt3) == \"protected\");\n+    static assert(__traits(getVisibility, TestProt4) == \"public\");\n+    static assert(__traits(getVisibility, TestProt5) == \"export\");\n \n     // This specific pattern is important to ensure it always works\n     // through reflection, however that becomes implemented\n-    static assert(__traits(getProtection, __traits(getMember, t, \"va\")) == \"private\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"vb\")) == \"package\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"vc\")) == \"protected\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"vd\")) == \"public\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"ve\")) == \"export\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"fa\")) == \"private\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"fb\")) == \"package\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"fc\")) == \"protected\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"fd\")) == \"public\");\n-    static assert(__traits(getProtection, __traits(getMember, t, \"fe\")) == \"export\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"va\")) == \"private\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"vb\")) == \"package\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"vc\")) == \"protected\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"vd\")) == \"public\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"ve\")) == \"export\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"fa\")) == \"private\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"fb\")) == \"package\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"fc\")) == \"protected\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"fd\")) == \"public\");\n+    static assert(__traits(getVisibility, __traits(getMember, t, \"fe\")) == \"export\");\n }\n \n /********************************************************/\n@@ -947,47 +948,47 @@ void test9546()\n     import imports.a9546 : S;\n \n     S s;\n-    static assert(__traits(getProtection, s.privA) == \"private\");\n-    static assert(__traits(getProtection, s.protA) == \"protected\");\n-    static assert(__traits(getProtection, s.packA) == \"package\");\n-    static assert(__traits(getProtection, S.privA) == \"private\");\n-    static assert(__traits(getProtection, S.protA) == \"protected\");\n-    static assert(__traits(getProtection, S.packA) == \"package\");\n-\n-    static assert(__traits(getProtection, mixin(\"s.privA\")) == \"private\");\n-    static assert(__traits(getProtection, mixin(\"s.protA\")) == \"protected\");\n-    static assert(__traits(getProtection, mixin(\"s.packA\")) == \"package\");\n-    static assert(__traits(getProtection, mixin(\"S.privA\")) == \"private\");\n-    static assert(__traits(getProtection, mixin(\"S.protA\")) == \"protected\");\n-    static assert(__traits(getProtection, mixin(\"S.packA\")) == \"package\");\n-\n-    static assert(__traits(getProtection, __traits(getMember, s, \"privA\")) == \"private\");\n-    static assert(__traits(getProtection, __traits(getMember, s, \"protA\")) == \"protected\");\n-    static assert(__traits(getProtection, __traits(getMember, s, \"packA\")) == \"package\");\n-    static assert(__traits(getProtection, __traits(getMember, S, \"privA\")) == \"private\");\n-    static assert(__traits(getProtection, __traits(getMember, S, \"protA\")) == \"protected\");\n-    static assert(__traits(getProtection, __traits(getMember, S, \"packA\")) == \"package\");\n-\n-    static assert(__traits(getProtection, s.privF) == \"private\");\n-    static assert(__traits(getProtection, s.protF) == \"protected\");\n-    static assert(__traits(getProtection, s.packF) == \"package\");\n-    static assert(__traits(getProtection, S.privF) == \"private\");\n-    static assert(__traits(getProtection, S.protF) == \"protected\");\n-    static assert(__traits(getProtection, S.packF) == \"package\");\n-\n-    static assert(__traits(getProtection, mixin(\"s.privF\")) == \"private\");\n-    static assert(__traits(getProtection, mixin(\"s.protF\")) == \"protected\");\n-    static assert(__traits(getProtection, mixin(\"s.packF\")) == \"package\");\n-    static assert(__traits(getProtection, mixin(\"S.privF\")) == \"private\");\n-    static assert(__traits(getProtection, mixin(\"S.protF\")) == \"protected\");\n-    static assert(__traits(getProtection, mixin(\"S.packF\")) == \"package\");\n-\n-    static assert(__traits(getProtection, __traits(getMember, s, \"privF\")) == \"private\");\n-    static assert(__traits(getProtection, __traits(getMember, s, \"protF\")) == \"protected\");\n-    static assert(__traits(getProtection, __traits(getMember, s, \"packF\")) == \"package\");\n-    static assert(__traits(getProtection, __traits(getMember, S, \"privF\")) == \"private\");\n-    static assert(__traits(getProtection, __traits(getMember, S, \"protF\")) == \"protected\");\n-    static assert(__traits(getProtection, __traits(getMember, S, \"packF\")) == \"package\");\n+    static assert(__traits(getVisibility, s.privA) == \"private\");\n+    static assert(__traits(getVisibility, s.protA) == \"protected\");\n+    static assert(__traits(getVisibility, s.packA) == \"package\");\n+    static assert(__traits(getVisibility, S.privA) == \"private\");\n+    static assert(__traits(getVisibility, S.protA) == \"protected\");\n+    static assert(__traits(getVisibility, S.packA) == \"package\");\n+\n+    static assert(__traits(getVisibility, mixin(\"s.privA\")) == \"private\");\n+    static assert(__traits(getVisibility, mixin(\"s.protA\")) == \"protected\");\n+    static assert(__traits(getVisibility, mixin(\"s.packA\")) == \"package\");\n+    static assert(__traits(getVisibility, mixin(\"S.privA\")) == \"private\");\n+    static assert(__traits(getVisibility, mixin(\"S.protA\")) == \"protected\");\n+    static assert(__traits(getVisibility, mixin(\"S.packA\")) == \"package\");\n+\n+    static assert(__traits(getVisibility, __traits(getMember, s, \"privA\")) == \"private\");\n+    static assert(__traits(getVisibility, __traits(getMember, s, \"protA\")) == \"protected\");\n+    static assert(__traits(getVisibility, __traits(getMember, s, \"packA\")) == \"package\");\n+    static assert(__traits(getVisibility, __traits(getMember, S, \"privA\")) == \"private\");\n+    static assert(__traits(getVisibility, __traits(getMember, S, \"protA\")) == \"protected\");\n+    static assert(__traits(getVisibility, __traits(getMember, S, \"packA\")) == \"package\");\n+\n+    static assert(__traits(getVisibility, s.privF) == \"private\");\n+    static assert(__traits(getVisibility, s.protF) == \"protected\");\n+    static assert(__traits(getVisibility, s.packF) == \"package\");\n+    static assert(__traits(getVisibility, S.privF) == \"private\");\n+    static assert(__traits(getVisibility, S.protF) == \"protected\");\n+    static assert(__traits(getVisibility, S.packF) == \"package\");\n+\n+    static assert(__traits(getVisibility, mixin(\"s.privF\")) == \"private\");\n+    static assert(__traits(getVisibility, mixin(\"s.protF\")) == \"protected\");\n+    static assert(__traits(getVisibility, mixin(\"s.packF\")) == \"package\");\n+    static assert(__traits(getVisibility, mixin(\"S.privF\")) == \"private\");\n+    static assert(__traits(getVisibility, mixin(\"S.protF\")) == \"protected\");\n+    static assert(__traits(getVisibility, mixin(\"S.packF\")) == \"package\");\n+\n+    static assert(__traits(getVisibility, __traits(getMember, s, \"privF\")) == \"private\");\n+    static assert(__traits(getVisibility, __traits(getMember, s, \"protF\")) == \"protected\");\n+    static assert(__traits(getVisibility, __traits(getMember, s, \"packF\")) == \"package\");\n+    static assert(__traits(getVisibility, __traits(getMember, S, \"privF\")) == \"private\");\n+    static assert(__traits(getVisibility, __traits(getMember, S, \"protF\")) == \"protected\");\n+    static assert(__traits(getVisibility, __traits(getMember, S, \"packF\")) == \"package\");\n }\n \n /********************************************************/\n@@ -1547,6 +1548,19 @@ void async(ARGS...)(ARGS)\n \n alias test17495 = async!(int, int);\n \n+/********************************************************/\n+// 15094\n+\n+void test15094()\n+{\n+    static struct Foo { int i; }\n+    static struct Bar { Foo foo; }\n+\n+    Bar bar;\n+    auto n = __traits(getMember, bar.foo, \"i\");\n+    assert(n == bar.foo.i);\n+}\n+\n /********************************************************/\n // https://issues.dlang.org/show_bug.cgi?id=10100\n \n@@ -1564,6 +1578,15 @@ static assert(\n \n /********************************************************/\n \n+void testIsDisabled()\n+{\n+    static assert(__traits(isDisabled, D1.true_));\n+    static assert(!__traits(isDisabled, D1.false_));\n+    static assert(!__traits(isDisabled, D1));\n+}\n+\n+/********************************************************/\n+\n int main()\n {\n     test1();\n@@ -1603,6 +1626,7 @@ int main()\n     test_getFunctionAttributes();\n     test_isOverrideFunction();\n     test12237();\n+    test15094();\n \n     writeln(\"Success\");\n     return 0;"}, {"sha": "056b8f120ac24e5db58aba95092cdab9da961e34", "filename": "gcc/testsuite/gdc.test/runnable/traits_child.d", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_child.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5e94699efa816444c0ae49ad55d0e01a48203df/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_child.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_child.d?ref=c5e94699efa816444c0ae49ad55d0e01a48203df", "patch": "@@ -0,0 +1,122 @@\n+struct A\n+{\n+    ulong i;\n+    void foo(ulong a)\n+    {\n+        i = a;\n+    }\n+\n+    void foo(string s)\n+    {\n+        i = s.length;\n+    }\n+\n+    void bar(T)(T a)\n+    {\n+        i = a;\n+    }\n+\n+    void bar(T : string)(T s)\n+    {\n+        i = s.length;\n+    }\n+}\n+\n+alias ai = A.i;\n+alias afoo = A.foo;\n+alias abar = A.bar;\n+alias abar_ulong = A.bar!ulong;\n+alias abar_string = A.bar!string;\n+\n+struct B\n+{\n+    A a;\n+}\n+\n+alias ba = B.a;\n+\n+template T(alias x)\n+{\n+    void set(int n)\n+    {\n+        x = n;\n+    }\n+}\n+\n+mixin template M(alias x)\n+{\n+    void set(int n)\n+    {\n+        x = n;\n+    }\n+}\n+\n+struct C\n+{\n+    int i;\n+    alias t = T!i;\n+    mixin M!i m;\n+}\n+\n+alias ct = C.t;\n+alias ctset = C.t.set;\n+alias cm = C.m;\n+alias cmset = C.m.set;\n+\n+\n+// adapted from http://thecybershadow.net/d/dconf2017/#/21\n+struct S { string a, b, c; }\n+\n+static string printField(alias field)()\n+{\n+    S s = { a: \"aa\", b: \"bb\", c: \"cc\" };\n+    return __traits(child, s, field);\n+}\n+\n+void main()\n+{\n+    auto f = printField!(S.b)();\n+    assert(f == \"bb\");\n+\n+    A a;\n+    __traits(child, a, ai) = 3;\n+    assert(a.i == 3);\n+    assert(__traits(child, a, ai) == 3);\n+    __traits(child, a, afoo)(2);\n+    assert(a.i == 2);\n+    __traits(child, a, afoo)(\"hello\");\n+    assert(a.i == 5);\n+    __traits(child, a, abar)(6);\n+    assert(a.i == 6);\n+    __traits(child, a, abar_ulong)(7);\n+    assert(a.i == 7);\n+    __traits(child, a, abar_string)(\"hi\");\n+    assert(a.i == 2);\n+\n+    __traits(child, a, A.i) = 7;\n+    assert(a.i == 7);\n+    __traits(child, a, A.bar)(3);\n+    assert(a.i == 3);\n+    __traits(child, a, A.bar!ulong)(4);\n+    assert(a.i == 4);\n+    __traits(child, a, __traits(getMember, A, \"i\")) = 5;\n+    assert(a.i == 5);\n+    __traits(child, a, __traits(getOverloads, A, \"bar\", true)[1])(\"hi!\");\n+    assert(a.i == 3);\n+\n+    B b;\n+    __traits(child, b.a, ai) = 2;\n+    assert(b.a.i == 2);\n+    __traits(child, __traits(child, b, ba), ai) = 3;\n+    assert(b.a.i == 3);\n+\n+    C c;\n+    __traits(child, c, ct).set(3);\n+    assert(c.i == 3);\n+    __traits(child, c, ctset)(4);\n+    assert(c.i == 4);\n+    __traits(child, c, cm).set(5);\n+    assert(c.i == 5);\n+    __traits(child, c, cmset)(6);\n+    assert(c.i == 6);\n+}"}]}