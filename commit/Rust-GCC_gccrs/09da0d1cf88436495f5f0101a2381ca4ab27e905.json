{"sha": "09da0d1cf88436495f5f0101a2381ca4ab27e905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlkYTBkMWNmODg0MzY0OTVmNWYwMTAxYTIzODFjYTRhYjI3ZTkwNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-23T18:32:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-23T18:32:58Z"}, "message": "Initial revision\n\nFrom-SVN: r232", "tree": {"sha": "276207935a05b61cca3c82f7cdcb40b65fef6590", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/276207935a05b61cca3c82f7cdcb40b65fef6590"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09da0d1cf88436495f5f0101a2381ca4ab27e905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09da0d1cf88436495f5f0101a2381ca4ab27e905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09da0d1cf88436495f5f0101a2381ca4ab27e905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09da0d1cf88436495f5f0101a2381ca4ab27e905/comments", "author": null, "committer": null, "parents": [{"sha": "f8684ec8a50f4d823bdaf78e5a024c50269e55a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8684ec8a50f4d823bdaf78e5a024c50269e55a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8684ec8a50f4d823bdaf78e5a024c50269e55a1"}], "stats": {"total": 322, "additions": 322, "deletions": 0}, "files": [{"sha": "7726da12d7d219cd1d3ac47773feda83153e9bf5", "filename": "gcc/config/svr3.h", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09da0d1cf88436495f5f0101a2381ca4ab27e905/gcc%2Fconfig%2Fsvr3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09da0d1cf88436495f5f0101a2381ca4ab27e905/gcc%2Fconfig%2Fsvr3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr3.h?ref=09da0d1cf88436495f5f0101a2381ca4ab27e905", "patch": "@@ -0,0 +1,322 @@\n+/* svr3.h  --  operating system specific defines to be used when\n+   targeting GCC for some generic System V Release 3 system.\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+   To use this file, make up a file with a name like:\n+\n+\t?????svr3.h\n+\n+   where ????? is replaced by the name of the basic hardware that you\n+   are targeting for.  Then, in the file ?????svr3.h, put something\n+   like:\n+\n+\t#include \"?????.h\"\n+\t#include \"svr3.h\"\n+\n+   followed by any really system-specific defines (or overrides of\n+   defines) which you find that you need.  For example, CPP_PREDEFINES\n+   is defined here with only the defined -Dunix and -DSVR3.  You should\n+   probably override that in your target-specific ?????svr3.h file\n+   with a set of defines that includes these, but also contains an\n+   appropriate define for the type of hardware that you are targeting.\n+*/\n+\n+/* Define a symbol so that libgcc* can know what sort of operating\n+   environment and assembler syntax we are targeting for.  */\n+#define SVR3_target\n+\n+/* Cpp, assembler, linker, library, and startfile spec's.  */\n+\n+/* You should redefine CPP_PREDEFINES in any file which includes this one.\n+   The definition should be appropriate for the type of target system\n+   involved, and it should include any -A (assertion) options which are\n+   appropriate for the given target system.  */\n+\n+#undef CPP_PREDEFINES\n+\n+/* Output at beginning of assembler file.  */\n+/* The .file command should always begin the output.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+  do { output_file_directive ((FILE), main_input_filename);\t\\\n+       if (optimize) ASM_FILE_START_1 (FILE);\t\t\t\\\n+     } while (0)\n+\n+/* By default, do nothing: a few machines support .optim, but not most.  */\n+#undef ASM_FILE_START_1\n+#define ASM_FILE_START_1(FILE)\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+/* We don't use ROUNDED because the standard compiler doesn't,\n+   and the linker gives error messages if a common symbol\n+   has more than one length value.  */\n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (SIZE)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+/* Note that using bss_section here caused errors\n+   in building shared libraries on system V.3.  */\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    int align = exact_log2 (ROUNDED);\t\t\t\\\n+    if (align > 2) align = 2;\t\t\t\t\\\n+    data_section ();\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN ((FILE), align == -1 ? 2 : align);\t\\\n+    ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n+    fprintf ((FILE), \"\\t.set .,.+%u\\n\", (ROUNDED));\t\\\n+  } while (0)\n+\n+#if 0 /* For now, let's leave these machine-specific.  */\n+/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n+\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}}\"\n+\n+#define LIB_SPEC \"%{p:-L/usr/lib/libp}%{pg:-L/usr/lib/libp} -lc crtn.o%s\"\n+\n+/* Special flags for the linker.  I don't know what they do.  */\n+\n+#define LINK_SPEC \"%{T*} %{z:-lm}\"\n+#endif\n+\n+/* Allow #sccs in preprocessor.  */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+/* Use periods rather than dollar signs in special g++ assembler names.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* System V Release 3 uses COFF debugging info.  */\n+\n+#define SDB_DEBUGGING_INFO\n+\n+/* We don't want to output DBX debugging information.  */\n+\n+#undef DBX_DEBUGGING_INFO\n+\n+/* Define the actual types of some ANSI-mandated types.  These\n+   definitions should work for most SVR3 systems.  */\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+/* Assembler pseudos to introduce constants of various size.  These\n+   definitions hsould work for most svr3 systems.  */\n+\n+#undef ASM_BYTE_OP\n+#define ASM_BYTE_OP \"\\t.byte\"\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.\n+\n+   For System V Release 3 the convention is to prepend a leading\n+   underscore onto user-level symbol names.  */\n+\n+#undef ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME) fprintf (FILE, \"_%s\", NAME)\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.\n+   However, use of the const section is turned off by default\n+   unless the specific tm.h file turns it on by defining\n+   USE_CONST_SECTION as 1.  */\n+\n+/* The support for constructors and destructors depends on two\n+   machine-specific macros that the individual tm.h file has to define:\n+\n+   CTORS_SECTION_ASM_OP should be defined to concatenate\n+   the macro INIT_SECTION_ASM_OP, a newline, and a push instruction\n+   to push a word containing 0 (or some equivalent of that).\n+\n+   ASM_OUTPUT_CONSTRUCTOR should be defined\n+   to push the address of the constructor.  */\n+\n+#define USE_CONST_SECTION\t0\n+\n+#define INIT_SECTION_ASM_OP     \"\\t.section\\t.init\"\n+#define FINI_SECTION_ASM_OP     \".section .fini,\\\"x\\\"\"\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata, \\\"x\\\"\"\n+\n+#define DTORS_SECTION_ASM_OP    FINI_SECTION_ASM_OP\n+/* CTORS_SECTION_ASM_OP is machine-dependent\n+   because it pushes on the stack.  */\n+\n+#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  func_ptr *__CTOR_LIST__ = __builtin_alloca (0), *p;\t\t\t\\\n+  for (p = __CTOR_LIST__; *p; )\t\t\t\t\t\t\\\n+    (*p++) ();\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Add extra sections .init and .fini, in addition to .bss from att386.h. */\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_bss, in_init, in_fini\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\\\n+  BSS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  INIT_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  FINI_SECTION_FUNCTION\n+\n+#define INIT_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+init_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_init)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", INIT_SECTION_ASM_OP);\t\\\n+      in_section = in_init;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define FINI_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+fini_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_fini)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", FINI_SECTION_ASM_OP);\t\\\n+      in_section = in_fini;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void text_section();\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#if 0\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+#endif\n+\n+/* This is machine-dependent\n+   because it needs to push something on the stack.  */\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fini_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"%s\\t \", ASM_LONG);\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL,RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((0 && RELOC)\t/* should be (flag_pic && RELOC) */\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+\n+#define SELECT_RTX_SECTION(MODE,RTX) const_section()"}]}