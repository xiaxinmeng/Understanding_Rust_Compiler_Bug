{"sha": "6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ2NzlhN2Q5ZDhkYmY5YmMyYzY3Y2MwYmU3NDdhZjJhOTU1NzMxNA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-21T10:02:02Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-04-21T10:02:02Z"}, "message": "libphobos: Merge upstream druntime 4b2674b3\n\nAdds version (BacktraceExternal) for using libexecinfo instead of\ninternal implementation on FreeBSD, NetBSD, and DragonFly.\n\nReviewed-on: https://github.com/dlang/druntime/pull/2560\n\nFrom-SVN: r270482", "tree": {"sha": "8d227445beafa88f89bded3527ff4476c68fb962", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d227445beafa88f89bded3527ff4476c68fb962"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/comments", "author": null, "committer": null, "parents": [{"sha": "42d3fe9afb0a107c2a7956e0feb4b20ff41cc611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42d3fe9afb0a107c2a7956e0feb4b20ff41cc611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42d3fe9afb0a107c2a7956e0feb4b20ff41cc611"}], "stats": {"total": 621, "additions": 331, "deletions": 290}, "files": [{"sha": "405be921eb30145848eba0a90886c77baec9d150", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "patch": "@@ -1,4 +1,4 @@\n-70b9fea60246e63d936ad6826b1b48b6e0f1de8f\n+4b2674b36b1f6aac75db2a5aa38d67d4be55a987\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "1fd54407aa533a42abbf2390a80657cfa13fa0d6", "filename": "libphobos/libdruntime/core/runtime.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fruntime.d?ref=6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "patch": "@@ -519,9 +519,8 @@ extern (C) bool runModuleUnitTests()\n         {\n             static enum MAXFRAMES = 128;\n             void*[MAXFRAMES]  callstack;\n-            int               numframes;\n \n-            numframes = backtrace( callstack.ptr, MAXFRAMES );\n+            auto numframes = backtrace( callstack.ptr, MAXFRAMES );\n             backtrace_symbols_fd( callstack.ptr, numframes, 2 );\n         }\n "}, {"sha": "9f91a0be6caa756f9128c520718d4a4ae4a86b3e", "filename": "libphobos/libdruntime/core/sys/dragonflybsd/execinfo.d", "status": "modified", "additions": 111, "deletions": 97, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fexecinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fexecinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fexecinfo.d?ref=6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "patch": "@@ -9,125 +9,139 @@\n module core.sys.dragonflybsd.execinfo;\n \n version (DragonFlyBSD):\n+extern (C):\n+nothrow:\n \n-extern (C) nothrow @system:\n+version (GNU)\n+    version = BacktraceExternal;\n \n-import core.sys.dragonflybsd.dlfcn;\n-\n-// Use extern (D) so that these functions don't collide with libexecinfo.\n-\n-extern (D) int backtrace(void** buffer, int size)\n+version (BacktraceExternal)\n {\n-    import core.thread : thread_stackBottom;\n-\n-    void** p, pend=cast(void**)thread_stackBottom();\n-    version (D_InlineAsm_X86)\n-        asm nothrow @trusted { mov p[EBP], EBP; }\n-    else version (D_InlineAsm_X86_64)\n-        asm nothrow @trusted { mov p[RBP], RBP; }\n-    else\n-        static assert(false, \"Architecture not supported.\");\n-\n-    int i;\n-    for (; i < size && p < pend; ++i)\n-    {\n-        buffer[i] = *(p + 1);\n-        auto pnext = cast(void**)*p;\n-        if (pnext <= p) break;\n-        p = pnext;\n-    }\n-    return i;\n+    size_t backtrace(void**, size_t);\n+    char** backtrace_symbols(const(void*)*, size_t);\n+    void backtrace_symbols_fd(const(void*)*, size_t, int);\n+    char** backtrace_symbols_fmt(const(void*)*, size_t, const char*);\n+    int backtrace_symbols_fd_fmt(const(void*)*, size_t, int, const char*);\n }\n+else\n+{\n+    import core.sys.dragonflybsd.dlfcn;\n \n+    // Use extern (D) so that these functions don't collide with libexecinfo.\n \n-extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n-{\n-    static void* realloc(void* p, size_t len) nothrow\n+    extern (D) int backtrace(void** buffer, int size)\n     {\n-        static import cstdlib=core.stdc.stdlib;\n-        auto res = cstdlib.realloc(p, len);\n-        if (res is null) cstdlib.free(p);\n-        return res;\n+        import core.thread : thread_stackBottom;\n+\n+        void** p, pend=cast(void**)thread_stackBottom();\n+        version (D_InlineAsm_X86)\n+            asm nothrow @trusted { mov p[EBP], EBP; }\n+        else version (D_InlineAsm_X86_64)\n+            asm nothrow @trusted { mov p[RBP], RBP; }\n+        else\n+            static assert(false, \"Architecture not supported.\");\n+\n+        int i;\n+        for (; i < size && p < pend; ++i)\n+        {\n+            buffer[i] = *(p + 1);\n+            auto pnext = cast(void**)*p;\n+            if (pnext <= p) break;\n+            p = pnext;\n+        }\n+        return i;\n     }\n \n-    if (size <= 0) return null;\n-\n-    size_t pos = size * (char*).sizeof;\n-    char** p = cast(char**)realloc(null, pos);\n-    if (p is null) return null;\n \n-    Dl_info info;\n-    foreach (i, addr; buffer[0 .. size])\n+    extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n     {\n-        if (dladdr(addr, &info) == 0)\n-            (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-        fixupDLInfo(addr, info);\n-\n-        immutable len = formatStackFrame(null, 0, addr, info);\n-        assert(len > 0);\n-\n-        p = cast(char**)realloc(p, pos + len);\n+        static void* realloc(void* p, size_t len) nothrow\n+        {\n+            static import cstdlib=core.stdc.stdlib;\n+            auto res = cstdlib.realloc(p, len);\n+            if (res is null) cstdlib.free(p);\n+            return res;\n+        }\n+\n+        if (size <= 0) return null;\n+\n+        size_t pos = size * (char*).sizeof;\n+        char** p = cast(char**)realloc(null, pos);\n         if (p is null) return null;\n \n-        formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n-\n-        p[i] = cast(char*)pos;\n-        pos += len;\n+        Dl_info info;\n+        foreach (i, addr; buffer[0 .. size])\n+        {\n+            if (dladdr(addr, &info) == 0)\n+                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n+            fixupDLInfo(addr, info);\n+\n+            immutable len = formatStackFrame(null, 0, addr, info);\n+            assert(len > 0);\n+\n+            p = cast(char**)realloc(p, pos + len);\n+            if (p is null) return null;\n+\n+            formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n+\n+            p[i] = cast(char*)pos;\n+            pos += len;\n+        }\n+        foreach (i; 0 .. size)\n+        {\n+            pos = cast(size_t)p[i];\n+            p[i] = cast(char*)p + pos;\n+        }\n+        return p;\n     }\n-    foreach (i; 0 .. size)\n+\n+\n+    extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n     {\n-        pos = cast(size_t)p[i];\n-        p[i] = cast(char*)p + pos;\n+        import core.sys.posix.unistd : write;\n+        import core.stdc.stdlib : alloca;\n+\n+        if (size <= 0) return;\n+\n+        Dl_info info;\n+        foreach (i, addr; buffer[0 .. size])\n+        {\n+            if (dladdr(addr, &info) == 0)\n+                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n+            fixupDLInfo(addr, info);\n+\n+            enum maxAlloca = 1024;\n+            enum min = (size_t a, size_t b) => a <= b ? a : b;\n+            immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n+            assert(len > 0);\n+\n+            auto p = cast(char*)alloca(len);\n+            if (p is null) return;\n+\n+            formatStackFrame(p, len, addr, info) >= len || assert(0);\n+            p[len - 1] = '\\n';\n+            write(fd, p, len);\n+        }\n     }\n-    return p;\n-}\n \n \n-extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n-{\n-    import core.sys.posix.unistd : write;\n-    import core.stdc.stdlib : alloca;\n+    private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n+    {\n+        if (info.dli_fname is null) info.dli_fname = \"???\";\n+        if (info.dli_fbase is null) info.dli_fbase = null;\n+        if (info.dli_sname is null) info.dli_sname = \"???\";\n+        if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n+    }\n \n-    if (size <= 0) return;\n \n-    Dl_info info;\n-    foreach (i, addr; buffer[0 .. size])\n+    private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n     {\n-        if (dladdr(addr, &info) == 0)\n-            (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-        fixupDLInfo(addr, info);\n+        import core.stdc.stdio : snprintf;\n \n-        enum maxAlloca = 1024;\n-        enum min = (size_t a, size_t b) => a <= b ? a : b;\n-        immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n+        immutable off = addr - info.dli_saddr;\n+        immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n+                                 addr, info.dli_sname, off, info.dli_fname);\n         assert(len > 0);\n-\n-        auto p = cast(char*)alloca(len);\n-        if (p is null) return;\n-\n-        formatStackFrame(p, len, addr, info) >= len || assert(0);\n-        p[len - 1] = '\\n';\n-        write(fd, p, len);\n+        return cast(size_t)len + 1; // + '\\0'\n     }\n }\n-\n-\n-private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n-{\n-    if (info.dli_fname is null) info.dli_fname = \"???\";\n-    if (info.dli_fbase is null) info.dli_fbase = null;\n-    if (info.dli_sname is null) info.dli_sname = \"???\";\n-    if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n-}\n-\n-\n-private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n-{\n-    import core.stdc.stdio : snprintf;\n-\n-    immutable off = addr - info.dli_saddr;\n-    immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n-                             addr, info.dli_sname, off, info.dli_fname);\n-    assert(len > 0);\n-    return cast(size_t)len + 1; // + '\\0'\n-}"}, {"sha": "cbdf70219dcfccce8316830ba66b71da039275dc", "filename": "libphobos/libdruntime/core/sys/freebsd/execinfo.d", "status": "modified", "additions": 109, "deletions": 95, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fexecinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fexecinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fexecinfo.d?ref=6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "patch": "@@ -12,122 +12,136 @@ version (FreeBSD):\n extern (C):\n nothrow:\n \n-import core.sys.freebsd.dlfcn;\n+version (GNU)\n+    version = BacktraceExternal;\n \n-// Use extern (D) so that these functions don't collide with libexecinfo.\n-\n-extern (D) int backtrace(void** buffer, int size)\n+version (BacktraceExternal)\n {\n-    import core.thread : thread_stackBottom;\n-\n-    void** p, pend=cast(void**)thread_stackBottom();\n-    version (D_InlineAsm_X86)\n-        asm nothrow @trusted { mov p[EBP], EBP; }\n-    else version (D_InlineAsm_X86_64)\n-        asm nothrow @trusted { mov p[RBP], RBP; }\n-    else\n-        static assert(false, \"Architecture not supported.\");\n-\n-    int i;\n-    for (; i < size && p < pend; ++i)\n-    {\n-        buffer[i] = *(p + 1);\n-        auto pnext = cast(void**)*p;\n-        if (pnext <= p) break;\n-        p = pnext;\n-    }\n-    return i;\n+    size_t backtrace(void**, size_t);\n+    char** backtrace_symbols(const(void*)*, size_t);\n+    void backtrace_symbols_fd(const(void*)*, size_t, int);\n+    char** backtrace_symbols_fmt(const(void*)*, size_t, const char*);\n+    int backtrace_symbols_fd_fmt(const(void*)*, size_t, int, const char*);\n }\n+else\n+{\n+    import core.sys.freebsd.dlfcn;\n \n+    // Use extern (D) so that these functions don't collide with libexecinfo.\n \n-extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n-{\n-    static void* realloc(void* p, size_t len) nothrow\n+    extern (D) int backtrace(void** buffer, int size)\n     {\n-        static import cstdlib=core.stdc.stdlib;\n-        auto res = cstdlib.realloc(p, len);\n-        if (res is null) cstdlib.free(p);\n-        return res;\n+        import core.thread : thread_stackBottom;\n+\n+        void** p, pend=cast(void**)thread_stackBottom();\n+        version (D_InlineAsm_X86)\n+            asm nothrow @trusted { mov p[EBP], EBP; }\n+        else version (D_InlineAsm_X86_64)\n+            asm nothrow @trusted { mov p[RBP], RBP; }\n+        else\n+            static assert(false, \"Architecture not supported.\");\n+\n+        int i;\n+        for (; i < size && p < pend; ++i)\n+        {\n+            buffer[i] = *(p + 1);\n+            auto pnext = cast(void**)*p;\n+            if (pnext <= p) break;\n+            p = pnext;\n+        }\n+        return i;\n     }\n \n-    if (size <= 0) return null;\n-\n-    size_t pos = size * (char*).sizeof;\n-    char** p = cast(char**)realloc(null, pos);\n-    if (p is null) return null;\n \n-    Dl_info info;\n-    foreach (i, addr; buffer[0 .. size])\n+    extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n     {\n-        if (dladdr(addr, &info) == 0)\n-            (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-        fixupDLInfo(addr, info);\n-\n-        immutable len = formatStackFrame(null, 0, addr, info);\n-        assert(len > 0);\n-\n-        p = cast(char**)realloc(p, pos + len);\n+        static void* realloc(void* p, size_t len) nothrow\n+        {\n+            static import cstdlib=core.stdc.stdlib;\n+            auto res = cstdlib.realloc(p, len);\n+            if (res is null) cstdlib.free(p);\n+            return res;\n+        }\n+\n+        if (size <= 0) return null;\n+\n+        size_t pos = size * (char*).sizeof;\n+        char** p = cast(char**)realloc(null, pos);\n         if (p is null) return null;\n \n-        formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n-\n-        p[i] = cast(char*)pos;\n-        pos += len;\n+        Dl_info info;\n+        foreach (i, addr; buffer[0 .. size])\n+        {\n+            if (dladdr(addr, &info) == 0)\n+                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n+            fixupDLInfo(addr, info);\n+\n+            immutable len = formatStackFrame(null, 0, addr, info);\n+            assert(len > 0);\n+\n+            p = cast(char**)realloc(p, pos + len);\n+            if (p is null) return null;\n+\n+            formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n+\n+            p[i] = cast(char*)pos;\n+            pos += len;\n+        }\n+        foreach (i; 0 .. size)\n+        {\n+            pos = cast(size_t)p[i];\n+            p[i] = cast(char*)p + pos;\n+        }\n+        return p;\n     }\n-    foreach (i; 0 .. size)\n+\n+\n+    extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n     {\n-        pos = cast(size_t)p[i];\n-        p[i] = cast(char*)p + pos;\n+        import core.sys.posix.unistd : write;\n+        import core.stdc.stdlib : alloca;\n+\n+        if (size <= 0) return;\n+\n+        Dl_info info;\n+        foreach (i, addr; buffer[0 .. size])\n+        {\n+            if (dladdr(addr, &info) == 0)\n+                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n+            fixupDLInfo(addr, info);\n+\n+            enum maxAlloca = 1024;\n+            enum min = (size_t a, size_t b) => a <= b ? a : b;\n+            immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n+            assert(len > 0);\n+\n+            auto p = cast(char*)alloca(len);\n+            if (p is null) return;\n+\n+            formatStackFrame(p, len, addr, info) >= len || assert(0);\n+            p[len - 1] = '\\n';\n+            write(fd, p, len);\n+        }\n     }\n-    return p;\n-}\n \n \n-extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n-{\n-    import core.sys.posix.unistd : write;\n-    import core.stdc.stdlib : alloca;\n+    private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n+    {\n+        if (info.dli_fname is null) info.dli_fname = \"???\";\n+        if (info.dli_fbase is null) info.dli_fbase = null;\n+        if (info.dli_sname is null) info.dli_sname = \"???\";\n+        if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n+    }\n \n-    if (size <= 0) return;\n \n-    Dl_info info;\n-    foreach (i, addr; buffer[0 .. size])\n+    private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n     {\n-        if (dladdr(addr, &info) == 0)\n-            (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-        fixupDLInfo(addr, info);\n+        import core.stdc.stdio : snprintf;\n \n-        enum maxAlloca = 1024;\n-        enum min = (size_t a, size_t b) => a <= b ? a : b;\n-        immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n+        immutable off = addr - info.dli_saddr;\n+        immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n+                                 addr, info.dli_sname, off, info.dli_fname);\n         assert(len > 0);\n-\n-        auto p = cast(char*)alloca(len);\n-        if (p is null) return;\n-\n-        formatStackFrame(p, len, addr, info) >= len || assert(0);\n-        p[len - 1] = '\\n';\n-        write(fd, p, len);\n+        return cast(size_t)len + 1; // + '\\0'\n     }\n }\n-\n-\n-private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n-{\n-    if (info.dli_fname is null) info.dli_fname = \"???\";\n-    if (info.dli_fbase is null) info.dli_fbase = null;\n-    if (info.dli_sname is null) info.dli_sname = \"???\";\n-    if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n-}\n-\n-\n-private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n-{\n-    import core.stdc.stdio : snprintf;\n-\n-    immutable off = addr - info.dli_saddr;\n-    immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n-                             addr, info.dli_sname, off, info.dli_fname);\n-    assert(len > 0);\n-    return cast(size_t)len + 1; // + '\\0'\n-}"}, {"sha": "97b2a45d365629597151bdf8b47b533f7beaacbc", "filename": "libphobos/libdruntime/core/sys/netbsd/execinfo.d", "status": "modified", "additions": 109, "deletions": 95, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fexecinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d679a7d9d8dbf9bc2c67cc0be747af2a9557314/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fexecinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fexecinfo.d?ref=6d679a7d9d8dbf9bc2c67cc0be747af2a9557314", "patch": "@@ -12,122 +12,136 @@ version (NetBSD):\n extern (C):\n nothrow:\n \n-import core.sys.netbsd.dlfcn;\n+version (GNU)\n+    version = BacktraceExternal;\n \n-// Use extern (D) so that these functions don't collide with libexecinfo.\n-\n-extern (D) int backtrace(void** buffer, int size)\n+version (BacktraceExternal)\n {\n-    import core.thread : thread_stackBottom;\n-\n-    void** p, pend=cast(void**)thread_stackBottom();\n-    version (D_InlineAsm_X86)\n-        asm nothrow @trusted { mov p[EBP], EBP; }\n-    else version (D_InlineAsm_X86_64)\n-        asm nothrow @trusted { mov p[RBP], RBP; }\n-    else\n-        static assert(false, \"Architecture not supported.\");\n-\n-    int i;\n-    for (; i < size && p < pend; ++i)\n-    {\n-        buffer[i] = *(p + 1);\n-        auto pnext = cast(void**)*p;\n-        if (pnext <= p) break;\n-        p = pnext;\n-    }\n-    return i;\n+    size_t backtrace(void**, size_t);\n+    char** backtrace_symbols(const(void*)*, size_t);\n+    void backtrace_symbols_fd(const(void*)*, size_t, int);\n+    char** backtrace_symbols_fmt(const(void*)*, size_t, const char*);\n+    int backtrace_symbols_fd_fmt(const(void*)*, size_t, int, const char*);\n }\n+else\n+{\n+    import core.sys.netbsd.dlfcn;\n \n+    // Use extern (D) so that these functions don't collide with libexecinfo.\n \n-extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n-{\n-    static void* realloc(void* p, size_t len) nothrow\n+    extern (D) int backtrace(void** buffer, int size)\n     {\n-        static import cstdlib=core.stdc.stdlib;\n-        auto res = cstdlib.realloc(p, len);\n-        if (res is null) cstdlib.free(p);\n-        return res;\n+        import core.thread : thread_stackBottom;\n+\n+        void** p, pend=cast(void**)thread_stackBottom();\n+        version (D_InlineAsm_X86)\n+            asm nothrow @trusted { mov p[EBP], EBP; }\n+        else version (D_InlineAsm_X86_64)\n+            asm nothrow @trusted { mov p[RBP], RBP; }\n+        else\n+            static assert(false, \"Architecture not supported.\");\n+\n+        int i;\n+        for (; i < size && p < pend; ++i)\n+        {\n+            buffer[i] = *(p + 1);\n+            auto pnext = cast(void**)*p;\n+            if (pnext <= p) break;\n+            p = pnext;\n+        }\n+        return i;\n     }\n \n-    if (size <= 0) return null;\n-\n-    size_t pos = size * (char*).sizeof;\n-    char** p = cast(char**)realloc(null, pos);\n-    if (p is null) return null;\n \n-    Dl_info info;\n-    foreach (i, addr; buffer[0 .. size])\n+    extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n     {\n-        if (dladdr(addr, &info) == 0)\n-            (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-        fixupDLInfo(addr, info);\n-\n-        immutable len = formatStackFrame(null, 0, addr, info);\n-        assert(len > 0);\n-\n-        p = cast(char**)realloc(p, pos + len);\n+        static void* realloc(void* p, size_t len) nothrow\n+        {\n+            static import cstdlib=core.stdc.stdlib;\n+            auto res = cstdlib.realloc(p, len);\n+            if (res is null) cstdlib.free(p);\n+            return res;\n+        }\n+\n+        if (size <= 0) return null;\n+\n+        size_t pos = size * (char*).sizeof;\n+        char** p = cast(char**)realloc(null, pos);\n         if (p is null) return null;\n \n-        formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n-\n-        p[i] = cast(char*)pos;\n-        pos += len;\n+        Dl_info info;\n+        foreach (i, addr; buffer[0 .. size])\n+        {\n+            if (dladdr(addr, &info) == 0)\n+                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n+            fixupDLInfo(addr, info);\n+\n+            immutable len = formatStackFrame(null, 0, addr, info);\n+            assert(len > 0);\n+\n+            p = cast(char**)realloc(p, pos + len);\n+            if (p is null) return null;\n+\n+            formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n+\n+            p[i] = cast(char*)pos;\n+            pos += len;\n+        }\n+        foreach (i; 0 .. size)\n+        {\n+            pos = cast(size_t)p[i];\n+            p[i] = cast(char*)p + pos;\n+        }\n+        return p;\n     }\n-    foreach (i; 0 .. size)\n+\n+\n+    extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n     {\n-        pos = cast(size_t)p[i];\n-        p[i] = cast(char*)p + pos;\n+        import core.sys.posix.unistd : write;\n+        import core.stdc.stdlib : alloca;\n+\n+        if (size <= 0) return;\n+\n+        Dl_info info;\n+        foreach (i, addr; buffer[0 .. size])\n+        {\n+            if (dladdr(addr, &info) == 0)\n+                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n+            fixupDLInfo(addr, info);\n+\n+            enum maxAlloca = 1024;\n+            enum min = (size_t a, size_t b) => a <= b ? a : b;\n+            immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n+            assert(len > 0);\n+\n+            auto p = cast(char*)alloca(len);\n+            if (p is null) return;\n+\n+            formatStackFrame(p, len, addr, info) >= len || assert(0);\n+            p[len - 1] = '\\n';\n+            write(fd, p, len);\n+        }\n     }\n-    return p;\n-}\n \n \n-extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n-{\n-    import core.sys.posix.unistd : write;\n-    import core.stdc.stdlib : alloca;\n+    private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n+    {\n+        if (info.dli_fname is null) info.dli_fname = \"???\";\n+        if (info.dli_fbase is null) info.dli_fbase = null;\n+        if (info.dli_sname is null) info.dli_sname = \"???\";\n+        if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n+    }\n \n-    if (size <= 0) return;\n \n-    Dl_info info;\n-    foreach (i, addr; buffer[0 .. size])\n+    private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n     {\n-        if (dladdr(addr, &info) == 0)\n-            (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-        fixupDLInfo(addr, info);\n+        import core.stdc.stdio : snprintf;\n \n-        enum maxAlloca = 1024;\n-        enum min = (size_t a, size_t b) => a <= b ? a : b;\n-        immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n+        immutable off = addr - info.dli_saddr;\n+        immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n+                                 addr, info.dli_sname, off, info.dli_fname);\n         assert(len > 0);\n-\n-        auto p = cast(char*)alloca(len);\n-        if (p is null) return;\n-\n-        formatStackFrame(p, len, addr, info) >= len || assert(0);\n-        p[len - 1] = '\\n';\n-        write(fd, p, len);\n+        return cast(size_t)len + 1; // + '\\0'\n     }\n }\n-\n-\n-private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n-{\n-    if (info.dli_fname is null) info.dli_fname = \"???\";\n-    if (info.dli_fbase is null) info.dli_fbase = null;\n-    if (info.dli_sname is null) info.dli_sname = \"???\";\n-    if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n-}\n-\n-\n-private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n-{\n-    import core.stdc.stdio : snprintf;\n-\n-    immutable off = addr - info.dli_saddr;\n-    immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n-                             addr, info.dli_sname, off, info.dli_fname);\n-    assert(len > 0);\n-    return cast(size_t)len + 1; // + '\\0'\n-}"}]}