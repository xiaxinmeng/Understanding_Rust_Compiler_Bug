{"sha": "17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdhZDViNWVjMjZkOWM2ZDdlZGM4NGM4OWQ2OTkzMTU1MmQxMzhmZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-18T07:46:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-18T07:46:33Z"}, "message": "tree.h (struct tree_decl): Add gimple_formal_temp.\n\n        * tree.h (struct tree_decl): Add gimple_formal_temp.\n        (DECL_GIMPLE_FORMAL_TEMP_P): New.\n        * gimplify.c (pop_gimplify_context): Clear it.\n        (lookup_tmp_var): Set it, if is_formal.\n        (gimplify_init_constructor): Use rhs_predicate_for for COMPLEX.\n        Use is_gimple_val for VECTOR.  Simplify return value.\n        (gimplify_save_expr): Use and set DECL_GIMPLE_FORMAL_TEMP_P.\n        (gimplify_expr): Likewise.\n        * tree-gimple.c (is_gimple_formal_tmp_rhs): Rename from\n        is_gimple_tmp_rhs for clarity.  Update all callers.\n        (is_gimple_reg_rhs): Simplify logic.\n        (is_gimple_formal_tmp_var): Rename from is_gimple_tmp_var for\n        clarity; use DECL_GIMPLE_FORMAL_TEMP_P.\n        (is_gimple_formal_tmp_reg): Similarly.\n        * tree-gimple.h: Update decls.\n        * tree-ssa-copyrename.c (copy_rename_partition_coalesce): Use\n        DECL_IGNORED_P, not DECL_ARTIFICIAL.  Tidy formatting.\n        * tree-ssa-live.c (var_union, type_var_init): Likewise.\njava/\n        * java-gimplify.c (java_gimplify_expr): Move '2' handling into\n        default case.  Treat '<' similarly.  Update for\n        is_gimple_formal_tmp_var name change.\ntestsuite/\n        * gcc.dg/20040206-1.c: XFAIL.\n\nFrom-SVN: r86176", "tree": {"sha": "699c6e9907b0c33f5cd057a408e8a232bd118ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/699c6e9907b0c33f5cd057a408e8a232bd118ec9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/comments", "author": null, "committer": null, "parents": [{"sha": "5b0eba617b824ab3442bee5fc4f7c7d40d112aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0eba617b824ab3442bee5fc4f7c7d40d112aa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0eba617b824ab3442bee5fc4f7c7d40d112aa6"}], "stats": {"total": 255, "additions": 148, "deletions": 107}, "files": [{"sha": "0fb256244c959d55a3638dd2de964d90d86e26bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -1,3 +1,24 @@\n+2004-08-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree.h (struct tree_decl): Add gimple_formal_temp.\n+\t(DECL_GIMPLE_FORMAL_TEMP_P): New.\n+\t* gimplify.c (pop_gimplify_context): Clear it.\n+\t(lookup_tmp_var): Set it, if is_formal.\n+\t(gimplify_init_constructor): Use rhs_predicate_for for COMPLEX.\n+\tUse is_gimple_val for VECTOR.  Simplify return value.\n+\t(gimplify_save_expr): Use and set DECL_GIMPLE_FORMAL_TEMP_P.\n+\t(gimplify_expr): Likewise.\n+\t* tree-gimple.c (is_gimple_formal_tmp_rhs): Rename from\n+\tis_gimple_tmp_rhs for clarity.  Update all callers.\n+\t(is_gimple_reg_rhs): Simplify logic.\n+\t(is_gimple_formal_tmp_var): Rename from is_gimple_tmp_var for\n+\tclarity; use DECL_GIMPLE_FORMAL_TEMP_P.\n+\t(is_gimple_formal_tmp_reg): Similarly.\n+\t* tree-gimple.h: Update decls.\n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Use\n+\tDECL_IGNORED_P, not DECL_ARTIFICIAL.  Tidy formatting.\n+\t* tree-ssa-live.c (var_union, type_var_init): Likewise.\n+\n 2004-08-18  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* c4x.c (legitimize_operands): Remove calls to"}, {"sha": "21328e6049188ecf825524fb55d6af089365b823", "filename": "gcc/gimplify.c", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -128,9 +128,14 @@ push_gimplify_context (void)\n void\n pop_gimplify_context (tree body)\n {\n+  tree t;\n+\n   if (!gimplify_ctxp || gimplify_ctxp->current_bind_expr)\n     abort ();\n \n+  for (t = gimplify_ctxp->temps; t ; t = TREE_CHAIN (t))\n+    DECL_GIMPLE_FORMAL_TEMP_P (t) = 0;\n+\n   if (body)\n     declare_tmp_vars (gimplify_ctxp->temps, body);\n   else\n@@ -402,8 +407,10 @@ create_tmp_from_val (tree val)\n static tree\n lookup_tmp_var (tree val, bool is_formal)\n {\n+  tree ret;\n+\n   if (!is_formal || TREE_SIDE_EFFECTS (val))\n-    return create_tmp_from_val (val);\n+    ret = create_tmp_from_val (val);\n   else\n     {\n       elt_t elt, *elt_p;\n@@ -415,15 +422,20 @@ lookup_tmp_var (tree val, bool is_formal)\n \t{\n \t  elt_p = xmalloc (sizeof (*elt_p));\n \t  elt_p->val = val;\n-\t  elt_p->temp = create_tmp_from_val (val);\n-\t  TREE_READONLY (elt_p->temp) = 1;\n+\t  elt_p->temp = ret = create_tmp_from_val (val);\n \t  *slot = (void *) elt_p;\n \t}\n       else\n-\telt_p = (elt_t *) *slot;\n-\n-      return elt_p->temp;\n+\t{\n+\t  elt_p = (elt_t *) *slot;\n+          ret = elt_p->temp;\n+\t}\n     }\n+\n+  if (is_formal)\n+    DECL_GIMPLE_FORMAL_TEMP_P (ret) = 1;\n+\n+  return ret;\n }\n \n /* Returns a formal temporary variable initialized with VAL.  PRE_P is as\n@@ -444,7 +456,7 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n   tree t, mod;\n   char class;\n \n-  gimplify_expr (&val, pre_p, post_p, is_gimple_tmp_rhs, fb_rvalue);\n+  gimplify_expr (&val, pre_p, post_p, is_gimple_formal_tmp_rhs, fb_rvalue);\n \n   t = lookup_tmp_var (val, is_formal);\n \n@@ -1571,7 +1583,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t\t{\n \t          TREE_OPERAND (t, 2) = low;\n \t\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,\n-\t\t\t\t\tis_gimple_tmp_reg, fb_rvalue);\n+\t\t\t\t\tis_gimple_formal_tmp_reg, fb_rvalue);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n \t    }\n@@ -1590,7 +1602,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t\t{\n \t          TREE_OPERAND (t, 3) = elmt_size;\n \t\t  tret = gimplify_expr (&TREE_OPERAND (t, 3), pre_p, post_p,\n-\t\t\t\t\tis_gimple_tmp_reg, fb_rvalue);\n+\t\t\t\t\tis_gimple_formal_tmp_reg, fb_rvalue);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n \t    }\n@@ -1612,7 +1624,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t\t{\n \t          TREE_OPERAND (t, 2) = offset;\n \t\t  tret = gimplify_expr (&TREE_OPERAND (t, 2), pre_p, post_p,\n-\t\t\t\t\tis_gimple_tmp_reg, fb_rvalue);\n+\t\t\t\t\tis_gimple_formal_tmp_reg, fb_rvalue);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n \t    }\n@@ -1643,7 +1655,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n \t  if (!is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n \t    {\n \t      tret = gimplify_expr (&TREE_OPERAND (t, 1), pre_p, post_p,\n-\t\t\t\t    is_gimple_tmp_reg, fb_rvalue);\n+\t\t\t\t    is_gimple_formal_tmp_reg, fb_rvalue);\n \t      ret = MIN (ret, tret);\n \t    }\n \t}\n@@ -2744,7 +2756,8 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    ctor = build (COMPLEX_EXPR, type, r, i);\n \t    TREE_OPERAND (*expr_p, 1) = ctor;\n \t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p,\n-\t\t\t\t is_gimple_tmp_rhs, fb_rvalue);\n+\t\t\t\t rhs_predicate_for (TREE_OPERAND (*expr_p, 0)),\n+\t\t\t\t fb_rvalue);\n \t  }\n       }\n       break;\n@@ -2761,7 +2774,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    {\n \t      enum gimplify_status tret;\n \t      tret = gimplify_expr (&TREE_VALUE (elt_list), pre_p, post_p,\n-\t\t\t\t    is_gimple_constructor_elt, fb_rvalue);\n+\t\t\t\t    is_gimple_val, fb_rvalue);\n \t      if (tret == GS_ERROR)\n \t\tret = GS_ERROR;\n \t    }\n@@ -2932,19 +2945,14 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n \t}\n     }\n \n-  /* If the destination is already simple, nothing else needed.  */\n-  if (is_gimple_tmp_var (*to_p) || !want_value)\n-    ret = GS_ALL_DONE;\n-  else\n-    ret = GS_OK;\n-\n   if (want_value)\n     {\n       append_to_statement_list (*expr_p, pre_p);\n       *expr_p = *to_p;\n+      return GS_OK;\n     }\n \n-  return ret;\n+  return GS_ALL_DONE;\n }\n \n /*  Gimplify a comparison between two variable-sized objects.  Do this\n@@ -3090,7 +3098,7 @@ gimplify_save_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n   /* If the operand is already a GIMPLE temporary, just re-write the\n      SAVE_EXPR node.  */\n-  if (is_gimple_tmp_var (val))\n+  if (TREE_CODE (val) == VAR_DECL && DECL_GIMPLE_FORMAL_TEMP_P (val))\n     *expr_p = val;\n   /* The operand may be a void-valued expression such as SAVE_EXPRs\n      generated by the Java frontend for class initialization.  It is\n@@ -3103,8 +3111,11 @@ gimplify_save_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       *expr_p = NULL;\n     }\n   else\n-    *expr_p = TREE_OPERAND (*expr_p, 0)\n-      = get_initialized_tmp_var (val, pre_p, post_p);\n+    {\n+      val = get_initialized_tmp_var (val, pre_p, post_p);\n+      DECL_GIMPLE_FORMAL_TEMP_P (val) = 1;\n+      *expr_p = TREE_OPERAND (*expr_p, 0) = val;\n+    }\n \n   return ret;\n }\n@@ -4095,7 +4106,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       gimplify_expr (&tmp, pre_p, post_p, is_gimple_reg, fb_rvalue);\n       *expr_p = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (tmp)), tmp);\n     }\n-  else if ((fallback & fb_rvalue) && is_gimple_tmp_rhs (*expr_p))\n+  else if ((fallback & fb_rvalue) && is_gimple_formal_tmp_rhs (*expr_p))\n     {\n #if defined ENABLE_CHECKING\n       if (VOID_TYPE_P (TREE_TYPE (*expr_p)))\n@@ -4112,6 +4123,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t*expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p);\n       else\n \t*expr_p = get_formal_tmp_var (*expr_p, pre_p);\n+      DECL_GIMPLE_FORMAL_TEMP_P (*expr_p) = 1;\n     }\n   else if (fallback & fb_mayfail)\n     {"}, {"sha": "8aeeba5fa5c64308cdacd3c91702dac5ebaf2891", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -1,3 +1,9 @@\n+2004-08-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* java-gimplify.c (java_gimplify_expr): Move '2' handling into\n+\tdefault case.  Treat '<' similarly.  Update for\n+\tis_gimple_formal_tmp_var name change.\n+\n 2004-08-17  Andrew Haley  <aph@redhat.com>\n \n \t* lang.c (lang_printable_name): Obey verbose flag."}, {"sha": "ea1b3f0bd6545b8a6ece2e147d331d4aa08ae9fc", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -60,28 +60,9 @@ int\n java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n \t\t    tree *post_p ATTRIBUTE_UNUSED)\n {\n-  char code_class = TREE_CODE_CLASS(TREE_CODE (*expr_p));\n-\n-  /* Java insists on strict left-to-right evaluation of expressions.\n-     A problem may arise if a variable used in the LHS of a binary\n-     operation is altered by an assignment to that value in the RHS\n-     before we've performed the operation.  So, we always copy every\n-     LHS to a temporary variable.  \n-\n-     FIXME: Are there any other cases where we should do this?\n-     Parameter lists, maybe?  Or perhaps that's unnecessary because\n-     the front end already generates SAVE_EXPRs.  */\n-  if (code_class == '2')\n-    {\n-      tree lhs = TREE_OPERAND (*expr_p, 0);\n-      enum gimplify_status stat \n-\t= gimplify_expr (&lhs, pre_p, post_p, is_gimple_tmp_var, fb_rvalue);\n-      if (stat == GS_ERROR)\n-\treturn stat;\n-      TREE_OPERAND (*expr_p, 0) = lhs;\n-    }\n+  enum tree_code code = TREE_CODE (*expr_p);\n \n-  switch (TREE_CODE (*expr_p))\n+  switch (code)\n     {\n     case BLOCK:\n       *expr_p = java_gimplify_block (*expr_p);\n@@ -150,6 +131,25 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n       abort ();\n \n     default:\n+      /* Java insists on strict left-to-right evaluation of expressions.\n+\t A problem may arise if a variable used in the LHS of a binary\n+\t operation is altered by an assignment to that value in the RHS\n+\t before we've performed the operation.  So, we always copy every\n+\t LHS to a temporary variable.  \n+\n+\t FIXME: Are there any other cases where we should do this?\n+\t Parameter lists, maybe?  Or perhaps that's unnecessary because\n+\t the front end already generates SAVE_EXPRs.  */\n+\n+      if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n+\t{\n+\t  enum gimplify_status stat \n+\t    = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t     is_gimple_formal_tmp_var, fb_rvalue);\n+\t  if (stat == GS_ERROR)\n+\t    return stat;\n+\t}\n+\n       return GS_UNHANDLED;\n     }\n "}, {"sha": "78cd8dfecebe890cbafad91f9f02d987298443ac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -1,3 +1,7 @@\n+2004-08-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/20040206-1.c: XFAIL.\n+\n 2004-08-17  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16246"}, {"sha": "3f25126e33599f9c3b4a4bda27d717f02ee34996", "filename": "gcc/testsuite/gcc.dg/20040206-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftestsuite%2Fgcc.dg%2F20040206-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftestsuite%2Fgcc.dg%2F20040206-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20040206-1.c?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -8,4 +8,4 @@\n     returning non-void\" is PR 13000. */\n \n static int foo (int a __attribute__((unused)) ) { }  /* { dg-warning \"return\" \"\" { xfail *-*-* } } */\n-int main (void) { return foo (0); } \n+int main (void) { return foo (0); } /* { dg-bogus \"uninitialized\" \"\" { xfail *-*-* } } */"}, {"sha": "cabe5469eba14289a35082fe644a1d6bac4cd750", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -195,7 +195,7 @@ static inline bool is_gimple_id (tree);\n /* Return true if T is a GIMPLE RHS for an assignment to a temporary.  */\n \n bool\n-is_gimple_tmp_rhs (tree t)\n+is_gimple_formal_tmp_rhs (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n \n@@ -235,28 +235,27 @@ is_gimple_tmp_rhs (tree t)\n   return is_gimple_lvalue (t) || is_gimple_val (t);\n }\n \n-/* Returns true iff T is a valid RHS for an assignment to a renamed user\n-   variable.  */\n+/* Returns true iff T is a valid RHS for an assignment to a renamed\n+   user -- or front-end generated artificial -- variable.  */\n \n bool\n is_gimple_reg_rhs (tree t)\n {\n-  /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto and\n-     the LHS is a user variable, then we need to introduce a temporary.\n-     ie temp = RHS; LHS = temp.\n+  /* If the RHS of the MODIFY_EXPR may throw or make a nonlocal goto\n+     and the LHS is a user variable, then we need to introduce a formal\n+     temporary.  This way the optimizers can determine that the user\n+     variable is only modified if evaluation of the RHS does not throw.\n+\n+     Don't force a temp of a non-renamable type; the copy could be\n+     arbitrarily expensive.  Instead we will generate a V_MAY_DEF for\n+     the assignment.  */\n \n-     This way the optimizers can determine that the user variable is\n-     only modified if evaluation of the RHS does not throw.  */\n   if (is_gimple_reg_type (TREE_TYPE (t))\n-      && TREE_SIDE_EFFECTS (t)\n-      && (TREE_CODE (t) == CALL_EXPR\n-\t  || (flag_non_call_exceptions && tree_could_trap_p (t))))\n-    return is_gimple_val (t);\n-  else\n-    /* Don't force a temp of a non-renamable type; the copy could be\n-       arbitrarily expensive.  Instead we will generate a V_MAY_DEF for\n-       the assignment.  */\n-    return is_gimple_tmp_rhs (t);\n+      && ((TREE_CODE (t) == CALL_EXPR && TREE_SIDE_EFFECTS (t))\n+\t  || tree_could_throw_p (t)))\n+    return false;\n+\n+  return is_gimple_formal_tmp_rhs (t);\n }\n \n /* Returns true iff T is a valid RHS for an assignment to an un-renamed\n@@ -270,16 +269,16 @@ is_gimple_mem_rhs (tree t)\n   if (is_gimple_reg_type (TREE_TYPE (t)))\n     return is_gimple_val (t);\n   else\n-    return is_gimple_tmp_rhs (t);\n+    return is_gimple_formal_tmp_rhs (t);\n }\n \n /* Returns the appropriate RHS predicate for this LHS.  */\n \n gimple_predicate\n rhs_predicate_for (tree lhs)\n {\n-  if (is_gimple_tmp_var (lhs))\n-    return is_gimple_tmp_rhs;\n+  if (is_gimple_formal_tmp_var (lhs))\n+    return is_gimple_formal_tmp_rhs;\n   else if (is_gimple_reg (lhs))\n     return is_gimple_reg_rhs;\n   else\n@@ -444,28 +443,26 @@ is_gimple_reg (tree t)\n \t  && ! needs_to_live_in_memory (t));\n }\n \n-/* Returns true if T is a GIMPLE temporary variable, false otherwise.  */\n+/* Returns true if T is a GIMPLE formal temporary variable.  */\n \n bool\n-is_gimple_tmp_var (tree t)\n+is_gimple_formal_tmp_var (tree t)\n {\n-  /* FIXME this could trigger for other local artificials, too.  */\n-  return (TREE_CODE (t) == VAR_DECL && DECL_ARTIFICIAL (t)\n-\t  && !TREE_STATIC (t) && !DECL_EXTERNAL (t));\n+  return TREE_CODE (t) == VAR_DECL && DECL_GIMPLE_FORMAL_TEMP_P (t);\n }\n \n-/* Returns true if T is a GIMPLE temporary register variable.  */\n+/* Returns true if T is a GIMPLE formal temporary register variable.  */\n \n bool\n-is_gimple_tmp_reg (tree t)\n+is_gimple_formal_tmp_reg (tree t)\n {\n   /* The intent of this is to get hold of a value that won't change.\n      An SSA_NAME qualifies no matter if its of a user variable or not.  */\n   if (TREE_CODE (t) == SSA_NAME)\n     return true;\n \n   /* We don't know the lifetime characteristics of user variables.  */\n-  if (TREE_CODE (t) != VAR_DECL || !DECL_ARTIFICIAL (t))\n+  if (!is_gimple_formal_tmp_var (t))\n     return false;\n \n   /* Finally, it must be capable of being placed in a register.  */"}, {"sha": "9acfc4214b6cdedb7586060a8df12bde3f17328e", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -48,9 +48,9 @@ extern bool is_gimple_reg_type (tree);\n /* Returns true iff T is a scalar register variable.  */\n extern bool is_gimple_reg (tree);\n /* Returns true if T is a GIMPLE temporary variable, false otherwise.  */\n-extern bool is_gimple_tmp_var (tree);\n+extern bool is_gimple_formal_tmp_var (tree);\n /* Returns true if T is a GIMPLE temporary register variable.  */\n-extern bool is_gimple_tmp_reg (tree);\n+extern bool is_gimple_formal_tmp_reg (tree);\n /* Returns true iff T is any sort of variable.  */\n extern bool is_gimple_variable (tree);\n /* Returns true iff T is a variable or an INDIRECT_REF (of a variable).  */\n@@ -67,7 +67,7 @@ extern bool is_gimple_val (tree);\n /* Returns true iff T is a valid rhs for a MODIFY_EXPR where the LHS is a\n    GIMPLE temporary, a renamed user variable, or something else,\n    respectively.  */\n-extern bool is_gimple_tmp_rhs (tree);\n+extern bool is_gimple_formal_tmp_rhs (tree);\n extern bool is_gimple_reg_rhs (tree);\n extern bool is_gimple_mem_rhs (tree);\n /* Returns the appropriate one of the above three predicates for the LHS"}, {"sha": "a05935f574299be4e4a57447fe3aff73b8c61e46", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -118,7 +118,7 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n   int p1, p2, p3;\n   tree root1, root2;\n   var_ann_t ann1, ann2, ann3;\n-  bool gimp1, gimp2;\n+  bool ign1, ign2;\n \n #ifdef ENABLE_CHECKING\n   if (TREE_CODE (var1) != SSA_NAME || TREE_CODE (var2) != SSA_NAME)\n@@ -195,27 +195,25 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n       return;\n     }\n \n-  gimp1 = (TREE_CODE (root1) == VAR_DECL && DECL_ARTIFICIAL (root1));\n-  gimp2 = (TREE_CODE (root2) == VAR_DECL && DECL_ARTIFICIAL (root2));\n+  ign1 = TREE_CODE (root1) == VAR_DECL && DECL_IGNORED_P (root1);\n+  ign2 = TREE_CODE (root2) == VAR_DECL && DECL_IGNORED_P (root2);\n \n   /* Never attempt to coalesce 2 user variables unless one is an inline \n      variable.  */\n-  if (!gimp1 && !gimp2)\n+  if (!ign1 && !ign2)\n     {\n       if (DECL_FROM_INLINE (root2))\n-        gimp2 = true;\n-      else\n-        if (DECL_FROM_INLINE (root1))\n-\t  gimp1 = true;\n-\telse \n-\t  {\n-\t    if (debug)\n-\t      fprintf (debug, \" : 2 different USER vars. No coalesce.\\n\");\n-\t    return;\n-\t  }\n+        ign2 = true;\n+      else if (DECL_FROM_INLINE (root1))\n+\tign1 = true;\n+      else \n+\t{\n+\t  if (debug)\n+\t    fprintf (debug, \" : 2 different USER vars. No coalesce.\\n\");\n+\t  return;\n+\t}\n     }\n \n-    \n   /* Don't coalesce if there are two different memory tags.  */\n   if (ann1->type_mem_tag && ann2->type_mem_tag\n       && ann1->type_mem_tag != ann2->type_mem_tag)\n@@ -237,16 +235,15 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \t}\n       else\n         {\n-\t  gimp2 = true;\n-\t  gimp1 = false;\n+\t  ign2 = true;\n+\t  ign1 = false;\n \t}\n     }\n-  else\n-    if (default_def (root2))\n-      {\n-\tgimp1 = true;\n-\tgimp2 = false;\n-      }\n+  else if (default_def (root2))\n+    {\n+      ign1 = true;\n+      ign2 = false;\n+    }\n \n   /* Don't coalesce if the two variables aren't type compatible.  */\n   if (!lang_hooks.types_compatible_p (TREE_TYPE (root1), TREE_TYPE (root2)))\n@@ -261,11 +258,10 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \n   /* Set the root variable of the partition to the better choice, if there is \n      one.  */\n-  if (!gimp2)\n+  if (!ign2)\n     replace_ssa_name_symbol (partition_to_var (map, p3), root2);\n-  else\n-    if (!gimp1)\n-      replace_ssa_name_symbol (partition_to_var (map, p3), root1);\n+  else if (!ign1)\n+    replace_ssa_name_symbol (partition_to_var (map, p3), root1);\n \n   /* Update the various flag widgitry of the current base representative.  */\n   ann3 = var_ann (SSA_NAME_VAR (partition_to_var (map, p3)));"}, {"sha": "6833c6f1eda91dda46c6f9e763aac314af7683af", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -135,8 +135,7 @@ var_union (var_map map, tree var1, tree var2)\n \n       /* If there is no root_var set, or its not a user variable, set the\n \t root_var to this one.  */\n-      if (!root_var\n-          || (TREE_CODE (root_var) == VAR_DECL && DECL_ARTIFICIAL (root_var)))\n+      if (!root_var || (DECL_P (root_var) && DECL_IGNORED_P (root_var)))\n         {\n \t  other_var = root_var;\n \t  root_var = var2;\n@@ -1040,7 +1039,7 @@ type_var_init (var_map map)\n       \t  || TREE_CODE (t) == PARM_DECL \n \t  || (DECL_P (t)\n \t      && (DECL_REGISTER (t)\n-\t\t  || !DECL_ARTIFICIAL (t)\n+\t\t  || !DECL_IGNORED_P (t)\n \t\t  || DECL_RTL_SET_P (t))))\n         continue;\n "}, {"sha": "b60c7b40784ab22361417762e662e9d6760542cd", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad5b5ec26d9c6d7edc84c89d69931552d138ff/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=17ad5b5ec26d9c6d7edc84c89d69931552d138ff", "patch": "@@ -2177,6 +2177,11 @@ struct tree_binfo GTY (())\n #define DECL_PRESERVE_P(DECL) \\\n   DECL_CHECK (DECL)->decl.preserve_flag\n \n+/* Internal to the gimplifier.  Indicates that the value is a formal\n+   temporary controlled by the gimplifier.  */\n+#define DECL_GIMPLE_FORMAL_TEMP_P(DECL) \\\n+  DECL_CHECK (DECL)->decl.gimple_formal_temp\n+\n /* Enumerate visibility settings.  */\n #ifndef SYMBOL_VISIBILITY_DEFINED\n #define SYMBOL_VISIBILITY_DEFINED\n@@ -2245,6 +2250,7 @@ struct tree_decl GTY(())\n \n   unsigned possibly_inlined : 1;\n   unsigned preserve_flag: 1;\n+  unsigned gimple_formal_temp : 1;\n   /* 13 unused bits.  */\n \n   union tree_decl_u1 {"}]}