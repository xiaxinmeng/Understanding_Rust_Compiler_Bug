{"sha": "c7d6dca22e2f15c986335937740e5d3b2a1eeae8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdkNmRjYTIyZTJmMTVjOTg2MzM1OTM3NzQwZTVkM2IyYTFlZWFlOA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-24T21:13:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-24T21:13:11Z"}, "message": "(is_tagged_type):  New function added.\n\n(member_attribute):  Use it.\n(type_ok_for_scope):  Rewritten to eliminate serious bugs.\n(output_type):  Call `output_pending_types_for_scope' at the end of\nstruct/union types (which are themselves scopes in C++).\n\nFrom-SVN: r1681", "tree": {"sha": "0fc7f0c926d2c12694ef049973509fd675415a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fc7f0c926d2c12694ef049973509fd675415a3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7d6dca22e2f15c986335937740e5d3b2a1eeae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7d6dca22e2f15c986335937740e5d3b2a1eeae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7d6dca22e2f15c986335937740e5d3b2a1eeae8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7d6dca22e2f15c986335937740e5d3b2a1eeae8/comments", "author": null, "committer": null, "parents": [{"sha": "0eb0686e8f5ff7bfbd040f2567a30f4510dd39ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb0686e8f5ff7bfbd040f2567a30f4510dd39ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb0686e8f5ff7bfbd040f2567a30f4510dd39ed"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "c9d57259ee883484ce1d8c3e8f8ca9dc295edd8c", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7d6dca22e2f15c986335937740e5d3b2a1eeae8/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7d6dca22e2f15c986335937740e5d3b2a1eeae8/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=c7d6dca22e2f15c986335937740e5d3b2a1eeae8", "patch": "@@ -742,6 +742,17 @@ is_pseudo_reg (rtl)\n \t      && (REGNO (XEXP (rtl, 0)) >= FIRST_PSEUDO_REGISTER)));\n }\n \n+/* Return non-zero if the given type node represents a tagged type.  */\n+\n+inline int\n+is_tagged_type (type)\n+     register tree type;\n+{\n+  register enum tree_code code = TREE_CODE (type);\n+\n+  return (code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE);\n+}\n+\n static char *\n dwarf_tag_name (tag)\n      register unsigned tag;\n@@ -2501,9 +2512,7 @@ member_attribute (context)\n \n   /* Generate this attribute only for members in C++.  */\n \n-  if (context != NULL\n-      && (TREE_CODE (context) == RECORD_TYPE\n-\t  || TREE_CODE (context) == UNION_TYPE))\n+  if (context != NULL && is_tagged_type (context))\n     {\n       ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_member);\n       sprintf (label, TYPE_NAME_FMT, TYPE_UID (context));\n@@ -3637,21 +3646,10 @@ pend_type (type)\n \n /* Return non-zero if it is legitimate to output DIEs to represent a\n    given type while we are generating the list of child DIEs for some\n-   DIE associated with a given scope.\n+   DIE (e.g. a function or lexical block DIE) associated with a given scope.\n \n-   This function returns non-zero if *either* of the following two conditions\n-   is satisfied:\n-\n-\t o\tthe type actually belongs to the given scope (as evidenced\n-\t\tby its TYPE_CONTEXT value), or\n-\n-\t o\tthe type is anonymous, and the `scope' in question is *not*\n-\t\ta RECORD_TYPE or UNION_TYPE.\n-\n-   In theory, we should be able to generate DIEs for anonymous types\n-   *anywhere* (since the scope of an anonymous type is irrelevant)\n-   however svr4 SDB doesn't want to see other type DIEs within the\n-   lists of child DIEs for a TAG_structure_type or TAG_union_type DIE.\n+   See the comments within the function for a description of when it is\n+   considered legitimate to output DIEs for various kinds of types.\n \n    Note that TYPE_CONTEXT(type) may be NULL (to indicate global scope)\n    or it may point to a BLOCK node (for types local to a block), or to a\n@@ -3673,28 +3671,38 @@ pend_type (type)\n    It order to delay the production of DIEs representing types of formal\n    parameters, callers of this function supply `fake_containing_scope' as\n    the `scope' parameter to this function.  Given that fake_containing_scope\n-   is *not* the containing scope for *any* other type, the desired effect\n-   is achieved, i.e. output of DIEs representing types is temporarily\n-   suspended, and any type DIEs which would have been output otherwise\n-   are instead placed onto the pending_types_list.  Later on, we can force\n-   these (temporarily pended) types to be output simply by calling\n+   is a tagged type which is *not* the containing scope for *any* other type,\n+   the desired effect is achieved, i.e. output of DIEs representing types\n+   is temporarily suspended, and any type DIEs which would have otherwise\n+   been output are instead placed onto the pending_types_list.  Later on,\n+   we force these (temporarily pended) types to be output simply by calling\n    `output_pending_types_for_scope' with an actual argument equal to the\n    true scope of the types we temporarily pended.\n */\n \n-static int\n+inline int\n type_ok_for_scope (type, scope)\n     register tree type;\n     register tree scope;\n {\n-  return (TYPE_CONTEXT (type) == scope\n-\t  || (TYPE_NAME (type) == NULL\n-\t      && TREE_CODE (scope) != RECORD_TYPE\n-\t      && TREE_CODE (scope) != UNION_TYPE));\n+  /* Tagged types (i.e. struct, union, and enum types) must always be\n+     output only in the scopes where they actually belong (or else the\n+     scoping of their own tag names and the scoping of their member\n+     names will be incorrect).  Non-tagged-types on the other hand can\n+     generally be output anywhere, except that svr4 SDB really doesn't\n+     want to see them nested within struct or union types, so here we\n+     say it is always OK to immediately output any such a (non-tagged)\n+     type, so long as we are not within such a context.  Note that the\n+     only kinds of non-tagged types which we will be dealing with here\n+     (for C and C++ anyway) will be array types and function types.  */\n+\n+  return is_tagged_type (type)\n+\t ? (TYPE_CONTEXT (type) == scope)\n+\t : (scope == NULL_TREE || ! is_tagged_type (scope));\n }\n \n /* Output any pending types (from the pending_types list) which we can output\n-   now (given the limitations of the scope that we are working on now).\n+   now (taking into account the scope that we are working on now).\n \n    For each type output, remove the given type from the pending_types_list\n    *before* we try to output it.\n@@ -3954,6 +3962,12 @@ output_type (type, containing_scope)\n \t\t}\n \t    }\n \n+\t    /* RECORD_TYPEs and UNION_TYPEs are themselves scopes (at least\n+\t       in C++) so we must now output any nested pending types which\n+\t       are local just to this RECORD_TYPE or UNION_TYPE.  */\n+\n+\t    output_pending_types_for_scope (type);\n+\n \t    end_sibling_chain ();\t/* Terminate member chain.  */\n \t  }\n "}]}