{"sha": "1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwYmY1ZTExYmFkZGViM2IxMmUwMmQ4NWI1ZTI1MDRjZTE1MWFiZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-03T19:05:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-03T19:05:31Z"}, "message": "cgraph.c (symbol_table::create_edge): Set inline_failed.\n\n\n\t* cgraph.c (symbol_table::create_edge): Set inline_failed.\n\t(cgraph_edge::make_direct): Likewise.\n\t(cgraph_edge::dump_edge_flags): Dump call_stmt_cannot_inline_p.\n\t* cgraphclones.c (duplicate_thunk_for_node): Set inline_failed.\n\t* cif-code.def (CIF_LTO_MISMATCHED_DECLARATIONS): New code\n\t(CIF_THUNK): New code.\n\t* ipa-inline-analysis.c (initialize_inline_failed): Preserve\n\tCIF_FINAL_ERROR codes; do not deal with call_stmt_cannot_inline_p.\n\t(compute_inline_parameters): Set inline_failed for thunks.\n\t(inline_analyze_function): Cleanup.\n\t* ipa-inline.c (can_inline_edge_p): Do not deal with\n\tcall_stmt_cannot_inline_p.\n\t(can_early_inline_edge_p): Likewise.\n\t(early_inliner): Initialize inline_failed.\n\t* lto-cgraph.c (lto_output_edge): Sanity check inline_failed.\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Initialize inline_failed.\n\nFrom-SVN: r235839", "tree": {"sha": "fa1518ec23a4f9f2df062d54c970f14311ba7cbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa1518ec23a4f9f2df062d54c970f14311ba7cbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/comments", "author": null, "committer": null, "parents": [{"sha": "8b38916ad4fe0b878b12c9a42d6983ac09440485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b38916ad4fe0b878b12c9a42d6983ac09440485", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b38916ad4fe0b878b12c9a42d6983ac09440485"}], "stats": {"total": 101, "additions": 71, "deletions": 30}, "files": [{"sha": "12a292c17deb91933491dde1efa18d3f637c7093", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -1,3 +1,21 @@\n+2016-05-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (symbol_table::create_edge): Set inline_failed.\n+\t(cgraph_edge::make_direct): Likewise.\n+\t(cgraph_edge::dump_edge_flags): Dump call_stmt_cannot_inline_p.\n+\t* cgraphclones.c (duplicate_thunk_for_node): Set inline_failed.\n+\t* cif-code.def (CIF_LTO_MISMATCHED_DECLARATIONS): New code\n+\t(CIF_THUNK): New code.\n+\t* ipa-inline-analysis.c (initialize_inline_failed): Preserve\n+\tCIF_FINAL_ERROR codes; do not deal with call_stmt_cannot_inline_p.\n+\t(compute_inline_parameters): Set inline_failed for thunks.\n+\t(inline_analyze_function): Cleanup.\n+\t* ipa-inline.c (can_inline_edge_p): Do not deal with\n+\tcall_stmt_cannot_inline_p.\n+\t(can_early_inline_edge_p): Likewise.\n+\t(early_inliner): Initialize inline_failed.\n+\t* lto-cgraph.c (lto_output_edge): Sanity check inline_failed.\n+\n 2016-05-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/predicates.md (x87nonimm_ssenomem_operand): Rename"}, {"sha": "782cb520eacf25ba547b06ece696d09e70c08f52", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -859,9 +859,15 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n       && callee && callee->decl\n       && !gimple_check_call_matching_types (call_stmt, callee->decl,\n \t\t\t\t\t    false))\n-    edge->call_stmt_cannot_inline_p = true;\n+    {\n+      edge->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+      edge->call_stmt_cannot_inline_p = true;\n+    }\n   else\n-    edge->call_stmt_cannot_inline_p = false;\n+    {\n+      edge->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n+      edge->call_stmt_cannot_inline_p = false;\n+    }\n \n   edge->indirect_info = NULL;\n   edge->indirect_inlining_edge = 0;\n@@ -1240,10 +1246,12 @@ cgraph_edge::make_direct (cgraph_node *callee)\n   /* Insert to callers list of the new callee.  */\n   edge->set_callee (callee);\n \n-  if (call_stmt)\n-    call_stmt_cannot_inline_p\n-      = !gimple_check_call_matching_types (call_stmt, callee->decl,\n-\t\t\t\t\t   false);\n+  if (call_stmt\n+      && !gimple_check_call_matching_types (call_stmt, callee->decl, false))\n+    {\n+      call_stmt_cannot_inline_p = true;\n+      inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+    }\n \n   /* We need to re-determine the inlining status of the edge.  */\n   initialize_inline_failed (edge);\n@@ -1996,6 +2004,8 @@ cgraph_edge::dump_edge_flags (FILE *f)\n     fprintf (f, \"(speculative) \");\n   if (!inline_failed)\n     fprintf (f, \"(inlined) \");\n+  if (call_stmt_cannot_inline_p)\n+    fprintf (f, \"(call_stmt_cannot_inline_p) \");\n   if (indirect_inlining_edge)\n     fprintf (f, \"(indirect_inlining) \");\n   if (count)"}, {"sha": "10f2d3417f47e41528d50f8bc65bee5afc2d9c58", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -338,6 +338,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   cgraph_edge *e = new_thunk->create_edge (node, NULL, 0,\n \t\t\t\t\t\t  CGRAPH_FREQ_BASE);\n   e->call_stmt_cannot_inline_p = true;\n+  e->inline_failed = CIF_THUNK;\n   symtab->call_edge_duplication_hooks (thunk->callees, e);\n   symtab->call_cgraph_duplication_hooks (thunk, new_thunk);\n   return new_thunk;"}, {"sha": "f112e962aadfedd8fbe23b89582247a6758d56a6", "filename": "gcc/cif-code.def", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -92,8 +92,12 @@ DEFCIFCODE(MISMATCHED_ARGUMENTS, CIF_FINAL_ERROR,\n \t   N_(\"mismatched arguments\"))\n \n /* Caller and callee disagree on the arguments.  */\n-DEFCIFCODE(THUNK, CIF_FINAL_ERROR,\n-\t   N_(\"thunk call\"))\n+DEFCIFCODE(LTO_MISMATCHED_DECLARATIONS, CIF_FINAL_ERROR,\n+\t   N_(\"mismatched declarations during linktime optimization\"))\n+\n+/* Caller is thunk.  */\n+DEFCIFCODE(THUNK, CIF_FINAL_ERROR,                                             \n+          N_(\"thunk call\"))                                                    \n \n /* Call was originally indirect.  */\n DEFCIFCODE(ORIGINALLY_INDIRECT_CALL, CIF_FINAL_NORMAL,"}, {"sha": "47b5b96ace4db0121323c2b8bad78728f2d7d233", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -1490,19 +1490,23 @@ initialize_inline_failed (struct cgraph_edge *e)\n {\n   struct cgraph_node *callee = e->callee;\n \n-  if (e->indirect_unknown_callee)\n+  if (e->inline_failed && e->inline_failed != CIF_BODY_NOT_AVAILABLE\n+      && cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+    ;\n+  else if (e->indirect_unknown_callee)\n     e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n   else if (!callee->definition)\n     e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n   else if (callee->local.redefined_extern_inline)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n-  else if (e->call_stmt_cannot_inline_p)\n-    e->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n   else if (cfun && fn_contains_cilk_spawn_p (cfun))\n     /* We can't inline if the function is spawing a function.  */\n-    e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n+    e->inline_failed = CIF_CILK_SPAWN;\n   else\n     e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n+  gcc_checking_assert (!e->call_stmt_cannot_inline_p\n+\t\t       || cgraph_inline_failed_type (e->inline_failed)\n+\t\t\t    == CIF_FINAL_ERROR);\n }\n \n /* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n@@ -2925,7 +2929,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n       struct predicate t = true_predicate ();\n \n       info->inlinable = 0;\n-      node->callees->call_stmt_cannot_inline_p = true;\n+      node->callees->inline_failed = CIF_THUNK;\n       node->local.can_change_signature = false;\n       es->call_stmt_time = 1;\n       es->call_stmt_size = 1;\n@@ -4107,17 +4111,9 @@ inline_analyze_function (struct cgraph_node *node)\n     {\n       struct cgraph_edge *e;\n       for (e = node->callees; e; e = e->next_callee)\n-\t{\n-\t  if (e->inline_failed == CIF_FUNCTION_NOT_CONSIDERED)\n-\t    e->inline_failed = CIF_FUNCTION_NOT_OPTIMIZED;\n-\t  e->call_stmt_cannot_inline_p = true;\n-\t}\n+\te->inline_failed = CIF_FUNCTION_NOT_OPTIMIZED;\n       for (e = node->indirect_calls; e; e = e->next_callee)\n-\t{\n-\t  if (e->inline_failed == CIF_FUNCTION_NOT_CONSIDERED)\n-\t    e->inline_failed = CIF_FUNCTION_NOT_OPTIMIZED;\n-\t  e->call_stmt_cannot_inline_p = true;\n-\t}\n+\te->inline_failed = CIF_FUNCTION_NOT_OPTIMIZED;\n     }\n \n   pop_cfun ();"}, {"sha": "a5c5c9b382bac6dad8806d990e7316bba7f7a42a", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -335,12 +335,10 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_OVERWRITABLE;\n       inlinable = false;\n     }\n+  /* All edges with call_stmt_cannot_inline_p should have inline_failed\n+     initialized to one of FINAL_ERROR reasons.  */\n   else if (e->call_stmt_cannot_inline_p)\n-    {\n-      if (e->inline_failed != CIF_FUNCTION_NOT_OPTIMIZED)\n-        e->inline_failed = e->caller->thunk.thunk_p ? CIF_THUNK : CIF_MISMATCHED_ARGUMENTS;\n-      inlinable = false;\n-    }\n+    gcc_unreachable ();\n   /* Don't inline if the functions have different EH personalities.  */\n   else if (DECL_FUNCTION_PERSONALITY (caller->decl)\n \t   && DECL_FUNCTION_PERSONALITY (callee->decl)\n@@ -529,6 +527,8 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n   /* Early inliner might get called at WPA stage when IPA pass adds new\n      function.  In this case we can not really do any of early inlining\n      because function bodies are missing.  */\n+  if (cgraph_inline_failed_type (e->inline_failed) == CIF_FINAL_ERROR)\n+    return false;\n   if (!gimple_has_body_p (callee->decl))\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n@@ -2741,7 +2741,10 @@ early_inliner (function *fun)\n \t      if (edge->callee->decl\n \t\t  && !gimple_check_call_matching_types (\n \t\t      edge->call_stmt, edge->callee->decl, false))\n-\t\tedge->call_stmt_cannot_inline_p = true;\n+\t\t{\n+ \t\t  edge->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+\t\t  edge->call_stmt_cannot_inline_p = true;\n+\t\t}\n \t    }\n \t  if (iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS) - 1)\n \t    inline_update_overall_summary (node);"}, {"sha": "14302138efa050a69bb9d1250715cd6947fb9ffe", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -268,6 +268,8 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp_pack_value (&bp, edge->indirect_inlining_edge, 1);\n   bp_pack_value (&bp, edge->speculative, 1);\n   bp_pack_value (&bp, edge->call_stmt_cannot_inline_p, 1);\n+  gcc_assert (!edge->call_stmt_cannot_inline_p\n+\t      || edge->inline_failed != CIF_BODY_NOT_AVAILABLE);\n   bp_pack_value (&bp, edge->can_throw_external, 1);\n   bp_pack_value (&bp, edge->in_polymorphic_cdtor, 1);\n   if (edge->indirect_unknown_callee)"}, {"sha": "80ffba329ad3b25d9058851b747854f55ef685a6", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -1,3 +1,7 @@\n+2016-05-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Initialize inline_failed.\n+\n 2016-04-27  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \t* lto-partition.h (lto_balanced_map): New parameter."}, {"sha": "ce9e1465e3c186f9d55d815f9d0e8acbc5e53f7b", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0bf5e11baddeb3b12e02d85b5e2504ce151abd/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=1a0bf5e11baddeb3b12e02d85b5e2504ce151abd", "patch": "@@ -81,7 +81,10 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \t ???  We really need a way to match function signatures for ABI\n \t compatibility and perform related promotions at inlining time.  */\n       if (!compatible_p)\n-\te->call_stmt_cannot_inline_p = 1;\n+\t{\n+\t  e->inline_failed = CIF_LTO_MISMATCHED_DECLARATIONS;\n+\t  e->call_stmt_cannot_inline_p = 1;\n+\t}\n     }\n   /* Redirect incomming references.  */\n   prevailing_node->clone_referring (node);"}]}