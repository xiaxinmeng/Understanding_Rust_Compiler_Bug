{"sha": "6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkNDA5Y2ZjODM2ODNhOWJlNWM2YjNiOGY5YTNlYzg5NTlmOTM1Ng==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-02-26T00:55:43Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-02-26T00:55:43Z"}, "message": "c++: abbreviated function template return type rewriting [PR98990]\n\nWhen an abbreviated function template has a complex placeholder return\ntype such auto& or auto**, the level adjustment performed by\nsplice_late_return_type directly replaces the 'auto' inside the original\nreturn type with the level-adjusted 'auto', but that breaks\nTYPE_CANONICAL caching.  Instead, we should rebuild the entire return\ntype using the adjusted 'auto'.\n\nThis patch makes this happen by tsubsting the original return type with\nan argument vector that maps the original 'auto' to the adjusted 'auto'.\nIn passing, this patch also reverts the misguided changes to\nfind_type_usage in r10-6571 that made find_type_usage return a tree*\ninstead of a tree so as to discourage this kind of in-place type\nmodification.\n\nIt occurred to me that the constraint also needs to be rebuilt so that\nit refers to the adjusted 'auto', but this oversight doesn't seem to\ncause any issues at the moment due to how do_auto_deduction \"manually\"\nsubstitutes the 'auto' inside the constraint before performing\nsatisfaction.  So this'll be fixed later as part of a rework of\nplaceholder type constraint checking.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98990\n\t* pt.c (splice_late_return_type): Rebuild the entire return type\n\tif we have to adjust the level of an auto within.\n\t(type_uses_auto): Adjust call to find_type_usage.\n\t* type-utils.h (find_type_usage): Revert r10-6571 change that\n\tmade this function return a pointer to the auto node.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98990\n\t* g++.dg/concepts/abbrev8.C: New test.", "tree": {"sha": "0de9b13388914af63a614a70b41415f197cf0df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0de9b13388914af63a614a70b41415f197cf0df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/comments", "author": null, "committer": null, "parents": [{"sha": "daa6884432b09b0ec1207dacf1a467dd90538360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa6884432b09b0ec1207dacf1a467dd90538360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daa6884432b09b0ec1207dacf1a467dd90538360"}], "stats": {"total": 83, "additions": 52, "deletions": 31}, "files": [{"sha": "51abc866bce3f893813db5d827b504041c1a4ea5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "patch": "@@ -29645,22 +29645,24 @@ splice_late_return_type (tree type, tree late_return_type)\n       return late_return_type;\n     }\n \n-  if (tree *auto_node = find_type_usage (&type, is_auto))\n-    {\n-      tree idx = get_template_parm_index (*auto_node);\n-      if (TEMPLATE_PARM_LEVEL (idx) <= processing_template_decl)\n-\t{\n-\t  /* In an abbreviated function template we didn't know we were dealing\n-\t     with a function template when we saw the auto return type, so update\n-\t     it to have the correct level.  */\n-\t  tree new_auto = make_auto_1 (TYPE_IDENTIFIER (*auto_node), false);\n-\t  PLACEHOLDER_TYPE_CONSTRAINTS (new_auto)\n-\t    = PLACEHOLDER_TYPE_CONSTRAINTS (*auto_node);\n-\t  TYPE_CANONICAL (new_auto) = canonical_type_parameter (new_auto);\n-\t  new_auto = cp_build_qualified_type (new_auto, TYPE_QUALS (*auto_node));\n-\t  *auto_node = new_auto;\n-\t}\n-    }\n+  if (tree auto_node = find_type_usage (type, is_auto))\n+    if (TEMPLATE_TYPE_LEVEL (auto_node) <= processing_template_decl)\n+      {\n+\t/* In an abbreviated function template we didn't know we were dealing\n+\t   with a function template when we saw the auto return type, so rebuild\n+\t   the return type using an auto with the correct level.  */\n+\ttree new_auto = make_auto_1 (TYPE_IDENTIFIER (auto_node), false);\n+\ttree auto_vec = make_tree_vec (1);\n+\tTREE_VEC_ELT (auto_vec, 0) = new_auto;\n+\ttree targs = add_outermost_template_args (current_template_args (),\n+\t\t\t\t\t\t  auto_vec);\n+\t/* FIXME: We should also rebuild the constraint to refer to the new\n+\t   auto.  */\n+\tPLACEHOLDER_TYPE_CONSTRAINTS (new_auto)\n+\t  = PLACEHOLDER_TYPE_CONSTRAINTS (auto_node);\n+\tTYPE_CANONICAL (new_auto) = canonical_type_parameter (new_auto);\n+\treturn tsubst (type, targs, tf_none, NULL_TREE);\n+      }\n   return type;\n }\n \n@@ -29705,10 +29707,8 @@ type_uses_auto (tree type)\n       else\n \treturn NULL_TREE;\n     }\n-  else if (tree *tp = find_type_usage (&type, is_auto))\n-    return *tp;\n   else\n-    return NULL_TREE;\n+    return find_type_usage (type, is_auto);\n }\n \n /* Report ill-formed occurrences of auto types in ARGUMENTS.  If"}, {"sha": "138fed6c51e894393aa9ddb2768ff994f45eb337", "filename": "gcc/cp/type-utils.h", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/gcc%2Fcp%2Ftype-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/gcc%2Fcp%2Ftype-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftype-utils.h?ref=6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "patch": "@@ -20,36 +20,35 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CP_TYPE_UTILS_H\n #define GCC_CP_TYPE_UTILS_H\n \n-/* Returns a pointer to the first tree within *TP that is directly matched by\n-   PRED.  *TP may be a type or PARM_DECL and is incrementally decomposed toward\n-   its type-specifier until a match is found.  NULL is returned if PRED does not\n-   match any part of *TP.\n+/* Returns the first tree within T that is directly matched by PRED.  T may be a\n+   type or PARM_DECL and is incrementally decomposed toward its type-specifier\n+   until a match is found.  NULL is returned if PRED does not match any\n+   part of T.\n \n-   This is primarily intended for detecting whether *TP uses `auto' or a concept\n+   This is primarily intended for detecting whether T uses `auto' or a concept\n    identifier.  Since either of these can only appear as a type-specifier for\n    the declaration in question, only top-level qualifications are traversed;\n    find_type_usage does not look through the whole type.  */\n \n-inline tree *\n-find_type_usage (tree *tp, bool (*pred) (const_tree))\n+inline tree\n+find_type_usage (tree t, bool (*pred) (const_tree))\n {\n-  tree t = *tp;\n   if (pred (t))\n-    return tp;\n+    return t;\n \n   enum tree_code code = TREE_CODE (t);\n \n   if (code == POINTER_TYPE || code == REFERENCE_TYPE\n       || code == PARM_DECL || code == OFFSET_TYPE\n       || code == FUNCTION_TYPE || code == METHOD_TYPE\n       || code == ARRAY_TYPE)\n-    return find_type_usage (&TREE_TYPE (t), pred);\n+    return find_type_usage (TREE_TYPE (t), pred);\n \n   if (TYPE_PTRMEMFUNC_P (t))\n     return find_type_usage\n-      (&TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t)), pred);\n+      (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (t)), pred);\n \n-  return NULL;\n+  return NULL_TREE;\n }\n \n #endif // GCC_CP_TYPE_UTILS_H"}, {"sha": "51828b66d45de4e46528a8ff1b97819662dcea25", "filename": "gcc/testsuite/g++.dg/concepts/abbrev8.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fabbrev8.C?ref=6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/98990\n+// { dg-do compile { target concepts } }\n+\n+int x;\n+\n+auto& f() { return x; }\n+auto& f(auto) { return x; }\n+\n+using T1 = int&;\n+using T1 = decltype(f('a'));\n+\n+int* y;\n+\n+template <class>\n+struct S\n+{\n+  static auto** f() { return &y; }\n+  static auto** f(auto) { return &y; }\n+};\n+\n+using T2 = int**;\n+using T2 = decltype(S<void>::f('a'));"}]}