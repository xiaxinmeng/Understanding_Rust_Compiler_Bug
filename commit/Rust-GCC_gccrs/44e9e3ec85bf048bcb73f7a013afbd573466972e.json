{"sha": "44e9e3ec85bf048bcb73f7a013afbd573466972e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRlOWUzZWM4NWJmMDQ4YmNiNzNmN2EwMTNhZmJkNTczNDY2OTcyZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-01-20T10:51:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-01-20T10:51:46Z"}, "message": "decl.c (gnat_to_gnu_entity): Tidy up.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <case E_Record_Subtype>:\n\tTidy up.  For a subtype with discriminants and variant part, if a\n\tvariant is statically selected and the fields all have a constant\n\tposition, put them in order of increasing position.  Likewise if\n\tno variant part but representation clause is present.\n\t* gcc-interface/utils.c (make_packable_type): Robustify.\n\t(maybe_pad_type): Use local variable and tidy up condition.  If no\n\talignment is specified, use the original one.\n\t(create_type_stub_decl): Minor tweak.\n\t(convert) <case VECTOR_CST>: Fix typo.\n\t<case CONSTRUCTOR>: Deal with padding types around the same type.\n\tDo not punt on missing fields.\n\t(unchecked_convert): Call finish_record_type to lay out the special\n\trecord types made for conversions from/to problematic integer types.\n\tBump the alignment of CONSTRUCTORs before converting them to a more\n\taligned type.\n\nFrom-SVN: r206796", "tree": {"sha": "0abf9652349928c6a4a433eef4046071074ba0cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0abf9652349928c6a4a433eef4046071074ba0cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44e9e3ec85bf048bcb73f7a013afbd573466972e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e9e3ec85bf048bcb73f7a013afbd573466972e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44e9e3ec85bf048bcb73f7a013afbd573466972e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e9e3ec85bf048bcb73f7a013afbd573466972e/comments", "author": null, "committer": null, "parents": [{"sha": "59f5c969a5c5ac08e450ae74c260d57db574a5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59f5c969a5c5ac08e450ae74c260d57db574a5d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59f5c969a5c5ac08e450ae74c260d57db574a5d0"}], "stats": {"total": 166, "additions": 118, "deletions": 48}, "files": [{"sha": "4a93e9aadeeee982692688bcc13a7f173b1544ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e9e3ec85bf048bcb73f7a013afbd573466972e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e9e3ec85bf048bcb73f7a013afbd573466972e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=44e9e3ec85bf048bcb73f7a013afbd573466972e", "patch": "@@ -1,3 +1,22 @@\n+2014-01-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <case E_Record_Subtype>:\n+\tTidy up.  For a subtype with discriminants and variant part, if a\n+\tvariant is statically selected and the fields all have a constant\n+\tposition, put them in order of increasing position.  Likewise if\n+\tno variant part but representation clause is present.\n+\t* gcc-interface/utils.c (make_packable_type): Robustify.\n+\t(maybe_pad_type): Use local variable and tidy up condition.  If no\n+\talignment is specified, use the original one.\n+\t(create_type_stub_decl): Minor tweak.\n+\t(convert) <case VECTOR_CST>: Fix typo.\n+\t<case CONSTRUCTOR>: Deal with padding types around the same type.\n+\tDo not punt on missing fields.\n+\t(unchecked_convert): Call finish_record_type to lay out the special\n+\trecord types made for conversions from/to problematic integer types.\n+\tBump the alignment of CONSTRUCTORs before converting them to a more\n+\taligned type.\n+\n 2014-01-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <case E_Component>: Remove"}, {"sha": "dd912f37c97561e5950e653d7842d7cb667875f1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e9e3ec85bf048bcb73f7a013afbd573466972e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e9e3ec85bf048bcb73f7a013afbd573466972e/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=44e9e3ec85bf048bcb73f7a013afbd573466972e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -147,6 +147,7 @@ static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n static bool constructor_address_p (tree);\n+static int compare_field_bitpos (const PTR, const PTR);\n static bool components_to_record (tree, Node_Id, tree, int, bool, bool, bool,\n \t\t\t\t  bool, bool, bool, bool, bool, tree, tree *);\n static Uint annotate_value (tree);\n@@ -3341,9 +3342,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      vec<subst_pair> gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n-\t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part, t;\n+\t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part;\n \t      tree gnu_pos_list, gnu_field_list = NULL_TREE;\n-\t      bool selected_variant = false;\n+\t      bool selected_variant = false, all_constant_pos = true;\n \t      Entity_Id gnat_field;\n \t      vec<variant_desc> gnu_variant_list;\n \n@@ -3362,7 +3363,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      else\n \t\tgnu_unpad_base_type = gnu_base_type;\n \n-\t      /* Look for a variant part in the base type.  */\n+\t      /* Look for REP and variant parts in the base type.  */\n+\t      gnu_rep_part = get_rep_part (gnu_unpad_base_type);\n \t      gnu_variant_part = get_variant_part (gnu_unpad_base_type);\n \n \t      /* If there is a variant part, we must compute whether the\n@@ -3414,22 +3416,26 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  selected_variant = false;\n \t\t}\n \n+\t      /* Make a list of fields and their position in the base type.  */\n \t      gnu_pos_list\n \t\t= build_position_list (gnu_unpad_base_type,\n \t\t\t\t       gnu_variant_list.exists ()\n-\t\t\t\t\t  && !selected_variant,\n+\t\t\t\t       && !selected_variant,\n \t\t\t\t       size_zero_node, bitsize_zero_node,\n \t\t\t\t       BIGGEST_ALIGNMENT, NULL_TREE);\n \n+\t      /* Now go down every component in the subtype and compute its\n+\t\t size and position from those of the component in the base\n+\t\t type and from the constraints of the subtype.  */\n \t      for (gnat_field = First_Entity (gnat_entity);\n \t\t   Present (gnat_field);\n \t\t   gnat_field = Next_Entity (gnat_field))\n \t\tif ((Ekind (gnat_field) == E_Component\n \t\t     || Ekind (gnat_field) == E_Discriminant)\n \t\t    && !(Present (Corresponding_Discriminant (gnat_field))\n \t\t\t && Is_Tagged_Type (gnat_base_type))\n-\t\t    && Underlying_Type (Scope (Original_Record_Component\n-\t\t\t\t\t       (gnat_field)))\n+\t\t    && Underlying_Type\n+\t\t       (Scope (Original_Record_Component (gnat_field)))\n \t\t       == gnat_base_type)\n \t\t  {\n \t\t    Name_Id gnat_name = Chars (gnat_field);\n@@ -3438,7 +3444,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    tree gnu_old_field\n \t\t      = gnat_to_gnu_field_decl (gnat_old_field);\n \t\t    tree gnu_context = DECL_CONTEXT (gnu_old_field);\n-\t\t    tree gnu_field, gnu_field_type, gnu_size;\n+\t\t    tree gnu_field, gnu_field_type, gnu_size, gnu_pos;\n \t\t    tree gnu_cont_type, gnu_last = NULL_TREE;\n \n \t\t    /* If the type is the same, retrieve the GCC type from the\n@@ -3489,24 +3495,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       and put the field either in the new type if there is a\n \t\t       selected variant or in one of the new variants.  */\n \t\t    if (gnu_context == gnu_unpad_base_type\n-\t\t        || ((gnu_rep_part = get_rep_part (gnu_unpad_base_type))\n+\t\t        || (gnu_rep_part\n \t\t\t    && gnu_context == TREE_TYPE (gnu_rep_part)))\n \t\t      gnu_cont_type = gnu_type;\n \t\t    else\n \t\t      {\n \t\t\tvariant_desc *v;\n \t\t\tunsigned int i;\n+\t\t\ttree rep_part;\n \n-\t\t\tt = NULL_TREE;\n \t\t\tFOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n \t\t\t  if (gnu_context == v->type\n-\t\t\t      || ((gnu_rep_part = get_rep_part (v->type))\n-\t\t\t\t  && gnu_context == TREE_TYPE (gnu_rep_part)))\n-\t\t\t    {\n-\t\t\t      t = v->type;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\tif (t)\n+\t\t\t      || ((rep_part = get_rep_part (v->type))\n+\t\t\t\t  && gnu_context == TREE_TYPE (rep_part)))\n+\t\t\t    break;\n+\t\t\tif (v)\n \t\t\t  {\n \t\t\t    if (selected_variant)\n \t\t\t      gnu_cont_type = gnu_type;\n@@ -3525,6 +3528,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      = create_field_decl_from (gnu_old_field, gnu_field_type,\n \t\t\t\t\t\tgnu_cont_type, gnu_size,\n \t\t\t\t\t\tgnu_pos_list, gnu_subst_list);\n+\t\t    gnu_pos = DECL_FIELD_OFFSET (gnu_field);\n \n \t\t    /* Put it in one of the new variants directly.  */\n \t\t    if (gnu_cont_type != gnu_type)\n@@ -3557,14 +3561,42 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\tgnu_field_list = gnu_field;\n \t\t\tif (!gnu_last)\n \t\t\t  gnu_last = gnu_field;\n+\t\t\tif (TREE_CODE (gnu_pos) != INTEGER_CST)\n+\t\t\t  all_constant_pos = false;\n \t\t      }\n \n \t\t    save_gnu_tree (gnat_field, gnu_field, false);\n \t\t  }\n \n+\t      /* If there is a variant list, a selected variant and the fields\n+\t\t all have a constant position, put them in order of increasing\n+\t\t position to match that of constant CONSTRUCTORs.  Likewise if\n+\t\t there is no variant list but a REP part, since the latter has\n+\t\t been flattened in the process.  */\n+\t      if (((gnu_variant_list.exists () && selected_variant)\n+\t\t   || (!gnu_variant_list.exists () && gnu_rep_part))\n+\t\t  && all_constant_pos)\n+\t\t{\n+\t\t  const int len = list_length (gnu_field_list);\n+\t\t  tree *field_arr = XALLOCAVEC (tree, len), t;\n+\t\t  int i;\n+\n+\t\t  for (t = gnu_field_list, i = 0; t; t = DECL_CHAIN (t), i++)\n+\t\t    field_arr[i] = t;\n+\n+\t\t  qsort (field_arr, len, sizeof (tree), compare_field_bitpos);\n+\n+\t\t  gnu_field_list = NULL_TREE;\n+\t\t  for (i = 0; i < len; i++)\n+\t\t    {\n+\t\t      DECL_CHAIN (field_arr[i]) = gnu_field_list;\n+\t\t      gnu_field_list = field_arr[i];\n+\t\t    }\n+\t\t}\n+\n \t      /* If there is a variant list and no selected variant, we need\n \t\t to create the nest of variant parts from the old nest.  */\n-\t      if (gnu_variant_list.exists () && !selected_variant)\n+\t      else if (gnu_variant_list.exists () && !selected_variant)\n \t\t{\n \t\t  tree new_variant_part\n \t\t    = create_variant_part_from (gnu_variant_part,"}, {"sha": "69ea026e6d3e0f97bf9c1f4f4cd047639342b233", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e9e3ec85bf048bcb73f7a013afbd573466972e/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e9e3ec85bf048bcb73f7a013afbd573466972e/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=44e9e3ec85bf048bcb73f7a013afbd573466972e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -869,8 +869,9 @@ make_packable_type (tree type, bool in_record)\n \n   finish_record_type (new_type, nreverse (field_list), 2, false);\n   relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n-  SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n-\t\t\t  DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n+  if (TYPE_STUB_DECL (type))\n+    SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n+\t\t\t    DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n \n   /* If this is a padding record, we never want to make the size smaller\n      than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */\n@@ -1049,6 +1050,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\tbool is_user_type, bool definition, bool set_rm_size)\n {\n   tree orig_size = TYPE_SIZE (type);\n+  unsigned int orig_align = TYPE_ALIGN (type);\n   tree record, field;\n \n   /* If TYPE is a padded type, see if it agrees with any size and alignment\n@@ -1059,21 +1061,18 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (TYPE_IS_PADDING_P (type))\n     {\n       if ((!size\n-\t   || operand_equal_p (round_up (size,\n-\t\t\t\t\t MAX (align, TYPE_ALIGN (type))),\n-\t\t\t       round_up (TYPE_SIZE (type),\n-\t\t\t\t\t MAX (align, TYPE_ALIGN (type))),\n-\t\t\t       0))\n-\t  && (align == 0 || align == TYPE_ALIGN (type)))\n+\t   || operand_equal_p (round_up (size, orig_align), orig_size, 0))\n+\t  && (align == 0 || align == orig_align))\n \treturn type;\n \n       if (!size)\n-\tsize = TYPE_SIZE (type);\n+\tsize = orig_size;\n       if (align == 0)\n-\talign = TYPE_ALIGN (type);\n+\talign = orig_align;\n \n       type = TREE_TYPE (TYPE_FIELDS (type));\n       orig_size = TYPE_SIZE (type);\n+      orig_align = TYPE_ALIGN (type);\n     }\n \n   /* If the size is either not being changed or is being made smaller (which\n@@ -1086,7 +1085,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t      && tree_int_cst_lt (size, orig_size))))\n     size = NULL_TREE;\n \n-  if (align == TYPE_ALIGN (type))\n+  if (align == orig_align)\n     align = 0;\n \n   if (align == 0 && !size)\n@@ -1110,7 +1109,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (Present (gnat_entity))\n     TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n \n-  TYPE_ALIGN (record) = align;\n+  TYPE_ALIGN (record) = align ? align : orig_align;\n   TYPE_SIZE (record) = size ? size : orig_size;\n   TYPE_SIZE_UNIT (record)\n     = convert (sizetype,\n@@ -2063,8 +2062,7 @@ create_type_stub_decl (tree type_name, tree type)\n   /* Using a named TYPE_DECL ensures that a type name marker is emitted in\n      STABS while setting DECL_ARTIFICIAL ensures that no DW_TAG_typedef is\n      emitted in DWARF.  */\n-  tree type_decl = build_decl (input_location,\n-\t\t\t       TYPE_DECL, type_name, type);\n+  tree type_decl = build_decl (input_location, TYPE_DECL, type_name, type);\n   DECL_ARTIFICIAL (type_decl) = 1;\n   TYPE_ARTIFICIAL (type) = 1;\n   return type_decl;\n@@ -4626,7 +4624,7 @@ convert (tree type, tree expr)\n       break;\n \n     case VECTOR_CST:\n-      /* If we are converting a VECTOR_CST to a mere variant type, just make\n+      /* If we are converting a VECTOR_CST to a mere type variant, just make\n \t a new one in the proper type.  */\n       if (code == ecode && gnat_types_compatible_p (type, etype))\n \t{\n@@ -4636,9 +4634,15 @@ convert (tree type, tree expr)\n \t}\n \n     case CONSTRUCTOR:\n-      /* If we are converting a CONSTRUCTOR to a mere variant type, just make\n-\t a new one in the proper type.  */\n-      if (code == ecode && gnat_types_compatible_p (type, etype))\n+      /* If we are converting a CONSTRUCTOR to a mere type variant, or to\n+\t another padding type around the same type, just make a new one in\n+\t the proper type.  */\n+      if (code == ecode\n+\t  && (gnat_types_compatible_p (type, etype)\n+\t      || (code == RECORD_TYPE\n+\t\t  && TYPE_PADDING_P (type) && TYPE_PADDING_P (etype)\n+\t\t  && TREE_TYPE (TYPE_FIELDS (type))\n+\t\t     == TREE_TYPE (TYPE_FIELDS (etype)))))\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n@@ -4669,13 +4673,17 @@ convert (tree type, tree expr)\n \n \t  FOR_EACH_CONSTRUCTOR_ELT(e, idx, index, value)\n \t    {\n-\t      /* We expect only simple constructors.  */\n-\t      if (!SAME_FIELD_P (index, efield))\n-\t\tbreak;\n+\t      /* Skip the missing fields in the CONSTRUCTOR.  */\n+\t      while (efield && field && !SAME_FIELD_P (efield, index))\n+\t        {\n+\t\t  efield = DECL_CHAIN (efield);\n+\t\t  field = DECL_CHAIN (field);\n+\t\t}\n \t      /* The field must be the same.  */\n-\t      if (!SAME_FIELD_P (efield, field))\n+\t      if (!(efield && field && SAME_FIELD_P (efield, field)))\n \t\tbreak;\n-\t      constructor_elt elt = {field, convert (TREE_TYPE (field), value)};\n+\t      constructor_elt elt\n+\t        = {field, convert (TREE_TYPE (field), value)};\n \t      v->quick_push (elt);\n \n \t      /* If packing has made this field a bitfield and the input\n@@ -5321,10 +5329,9 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (type));\n \n       field = create_field_decl (get_identifier (\"OBJ\"), field_type, rec_type,\n-\t\t\t\t NULL_TREE, NULL_TREE, 1, 0);\n+\t\t\t\t NULL_TREE, bitsize_zero_node, 1, 0);\n \n-      TYPE_FIELDS (rec_type) = field;\n-      layout_type (rec_type);\n+      finish_record_type (rec_type, field, 1, false);\n \n       expr = unchecked_convert (rec_type, expr, notrunc_p);\n       expr = build_component_ref (expr, NULL_TREE, field, false);\n@@ -5352,10 +5359,9 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       SET_TYPE_RM_SIZE (field_type, TYPE_RM_SIZE (etype));\n \n       field = create_field_decl (get_identifier (\"OBJ\"), field_type, rec_type,\n-\t\t\t\t NULL_TREE, NULL_TREE, 1, 0);\n+\t\t\t\t NULL_TREE, bitsize_zero_node, 1, 0);\n \n-      TYPE_FIELDS (rec_type) = field;\n-      layout_type (rec_type);\n+      finish_record_type (rec_type, field, 1, false);\n \n       expr = fold_build1 (NOP_EXPR, field_type, expr);\n       CONSTRUCTOR_APPEND_ELT (v, field, expr);\n@@ -5412,6 +5418,19 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t\t\t\t       etype))\n     expr = convert (type, expr);\n \n+  /* If we are converting a CONSTRUCTOR to a more aligned RECORD_TYPE, bump\n+     the alignment of the CONSTRUCTOR to speed up the copy operation.  */\n+  else if (TREE_CODE (expr) == CONSTRUCTOR\n+\t   && code == RECORD_TYPE\n+\t   && TYPE_ALIGN (etype) < TYPE_ALIGN (type))\n+    {\n+      expr = convert (maybe_pad_type (etype, NULL_TREE, TYPE_ALIGN (type),\n+\t\t\t\t      Empty, false, false, false, true),\n+\t\t      expr);\n+      return unchecked_convert (type, expr, notrunc_p);\n+    }\n+\n+  /* Otherwise, just build a VIEW_CONVERT_EXPR of the expression.  */\n   else\n     {\n       expr = maybe_unconstrained_array (expr);"}]}