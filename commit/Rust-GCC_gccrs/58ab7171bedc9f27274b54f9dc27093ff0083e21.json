{"sha": "58ab7171bedc9f27274b54f9dc27093ff0083e21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThhYjcxNzFiZWRjOWYyNzI3NGI1NGY5ZGMyNzA5M2ZmMDA4M2UyMQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-08-28T17:37:54Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-08-28T17:37:54Z"}, "message": "sh.c (calc_live_regs): Save FPSCR_REG in an interrupt handler if it is ever live.\n\n\t* sh.c (calc_live_regs): Save FPSCR_REG in an interrupt handler\n\tif it is ever live.\n\n\t* sh.c (sh_handle_interrupt_handler_attribute): Reject interrupt_handler\n\tattribute for SHCOMPACT.\n\n\t* sh.h (OVERRIDE_OPTIONS): If align_function isn't set, set it\n\tappropriately.\n\t(FUNCTION_BOUNDARY): Specify only the minimum alignment required\n\tby the ABI.\n\n\t* sh.h (SH5_WOULD_BE_PARTIAL_NREGS): Also handle TImode case.\n\nFrom-SVN: r56637", "tree": {"sha": "8cf7fcb6a27b860d837e54e5bca3c14d55f94461", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cf7fcb6a27b860d837e54e5bca3c14d55f94461"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58ab7171bedc9f27274b54f9dc27093ff0083e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ab7171bedc9f27274b54f9dc27093ff0083e21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58ab7171bedc9f27274b54f9dc27093ff0083e21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ab7171bedc9f27274b54f9dc27093ff0083e21/comments", "author": null, "committer": null, "parents": [{"sha": "6625f89451d8ca1f0dd4ec9a4de3229e71c7652c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6625f89451d8ca1f0dd4ec9a4de3229e71c7652c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6625f89451d8ca1f0dd4ec9a4de3229e71c7652c"}], "stats": {"total": 40, "additions": 33, "deletions": 7}, "files": [{"sha": "e77e48797a8b855c1db99661605c6f2ba17a4131", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ab7171bedc9f27274b54f9dc27093ff0083e21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ab7171bedc9f27274b54f9dc27093ff0083e21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58ab7171bedc9f27274b54f9dc27093ff0083e21", "patch": "@@ -1,3 +1,18 @@\n+Wed Aug 28 15:35:17 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c (calc_live_regs): Save FPSCR_REG in an interrupt handler\n+\tif it is ever live.\n+\n+\t* sh.c (sh_handle_interrupt_handler_attribute): Reject interrupt_handler\n+\tattribute for SHCOMPACT.\n+\n+\t* sh.h (OVERRIDE_OPTIONS): If align_function isn't set, set it\n+\tappropriately.\n+\t(FUNCTION_BOUNDARY): Specify only the minimum alignment required\n+\tby the ABI.\n+\n+\t* sh.h (SH5_WOULD_BE_PARTIAL_NREGS): Also handle TImode case.\n+\n 2002-08-28  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config.gcc (mips*-*-netbsd*): Set target_cpu_default to"}, {"sha": "e49881ba866b3c1e9ad68315f5eb4b7e226b06c9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ab7171bedc9f27274b54f9dc27093ff0083e21/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ab7171bedc9f27274b54f9dc27093ff0083e21/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=58ab7171bedc9f27274b54f9dc27093ff0083e21", "patch": "@@ -4440,7 +4440,7 @@ calc_live_regs (count_ptr, live_regs_mask)\n \t\t  && pr_live))\n \t     && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n \t     && reg != RETURN_ADDRESS_POINTER_REGNUM\n-\t     && reg != T_REG && reg != GBR_REG && reg != FPSCR_REG)\n+\t     && reg != T_REG && reg != GBR_REG)\n \t  : (/* Only push those regs which are used and need to be saved.  */\n \t     regs_ever_live[reg] && ! call_used_regs[reg]))\n \t{\n@@ -5677,6 +5677,11 @@ sh_handle_interrupt_handler_attribute (node, name, args, flags, no_add_attrs)\n \t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n+  else if (TARGET_SHCOMPACT)\n+    {\n+      error (\"attribute interrupt_handler is not compatible with -m5-compact\");\n+      *no_add_attrs = true;\n+    }\n \n   return NULL_TREE;\n }"}, {"sha": "6f010864fc7eea4f7347fb9cf8d5cad02ca35860", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ab7171bedc9f27274b54f9dc27093ff0083e21/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ab7171bedc9f27274b54f9dc27093ff0083e21/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=58ab7171bedc9f27274b54f9dc27093ff0083e21", "patch": "@@ -472,6 +472,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n      break global alloc, and generates slower code anyway due\t\t\\\n      to the pressure on R0.  */\t\t\t\t\t\t\\\n   flag_schedule_insns = 0;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Allocation boundary (in *bits*) for the code of a function.\t\\\n+     SH1: 32 bit alignment is faster, because instructions are always\t\\\n+     fetched as a pair from a longword boundary.\t\t\t\\\n+     SH2 .. SH5 : align to cache line start.  */\t\t\t\\\n+  if (align_functions == 0)\t\t\t\t\t\t\\\n+    align_functions\t\t\t\t\t\t\t\\\n+      = TARGET_SMALLCODE ? FUNCTION_BOUNDARY : (1 << CACHE_LOG) * 8;\t\\\n } while (0)\n \f\n /* Target machine storage layout.  */\n@@ -532,11 +540,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n    The SH2/3 have 16 byte cache lines, and the SH4 has a 32 byte cache line */\n #define CACHE_LOG (TARGET_CACHE32 ? 5 : TARGET_SH2 ? 4 : 2)\n \n-/* Allocation boundary (in *bits*) for the code of a function.\n-   32 bit alignment is faster, because instructions are always fetched as a\n-   pair from a longword boundary.  */\n-#define FUNCTION_BOUNDARY  \\\n-  (TARGET_SMALLCODE ? 16 << TARGET_SHMEDIA : (1 << CACHE_LOG) * 8)\n+/* ABI given & required minimum allocation boundary (in *bits*) for the\n+   code of a function.  */\n+#define FUNCTION_BOUNDARY (16 << TARGET_SHMEDIA)\n \n /* On SH5, the lowest bit is used to indicate SHmedia functions, so\n    the vbit must go into the delta field of\n@@ -2018,7 +2024,7 @@ struct sh_args {\n    : 0)\n \n #define SH5_WOULD_BE_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  (TARGET_SH5 && (MODE) == BLKmode\t\t\t\t\\\n+  (TARGET_SH5 && ((MODE) == BLKmode || (MODE) == TImode)\t\\\n    && ((CUM).arg_count[(int) SH_ARG_INT]\t\t\t\\\n        + (int_size_in_bytes (TYPE) + 7) / 8) > NPARM_REGS (SImode))\n "}]}