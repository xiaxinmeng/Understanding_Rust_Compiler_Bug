{"sha": "73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNiYmFmZTU3ODVjMWJjZjZlZTk4YzY1MGQ5MWRkNzgzODJlZTVlYg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-06-27T15:20:41Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-06-27T15:20:41Z"}, "message": "error.c (pp_template_argument_list_start): Remove.\n\n\t* error.c (pp_template_argument_list_start): Remove.\n\t(pp_template_argument_list_end): Likewise.\n\t(pp_separate_with_comma): Use pp_cxx_separate_with.\n\t(reinit_global_formatting_buffer): Remove.\n\t(pp_non_consecutive_character): Likewise.\n\t(dump_scope): Use pp_cxx_colon_colon.\n\t(dump_template_parameter): Use pp_cxx_identifier,\n\tpp_cxx_tree_identifier and pp_cxx_whitespace.\n\t(dump_templat_bindings): Replace use of pp_string with\n\tsequence\n\tof pp_cxx_whitespace and pp_equal.\n\t(dump_type): Use pp_cxx_identifier, pp_cxx_tree_identifier,\n\tpp_cxx_colon_colon, pp_cxx_whitespace throughout.  Don't set\n\tpadding here.\n\t(dump_aggr_type): Use pp_cxx_identifier amd\n\tpp_cxx_tree_identifier.\n\t(dump_type_prefix): Don't set padding.  Use pp_cxx_whitespace,\n\tpp_cxx_left_parent, pp_cxx_colon_colon and pp_cxx_star\n\ttroughout.\n\t(dump_type_suffix): Use pp_cxx_right_paren,\n\tpp_cxx_left_bracket,\n\tpp_cxx_right_bracket, pp_cxx_identifier throughout,\n\t(dump_decl): Likewise.\n\t(dump_template_decl): Likewise.\n\t(dump_function_decl): Likewise.  Set padding as appropriate.\n\t(dump_parameters): Use pp_cxx_left_paren, pp_cxx_identifier\n\tand\n\tpp_cxx_right_paren.\n\t(dump_exception_spec): Likewise.\n\t(dump_function_name): Use pp_cxx_tree_identifier and\n\tpp_cxx_identifier.\n\t(dump_template_parms): Use pp_cxx_begin_template_argument_list\n\tand\n\tpp_cxx_end_template_argument_list.\n\t(dump_expr): Use pp_cxx_left_paren, pp_cxx_right_paren,\n\tpp_cxx_colon_colon, pp_cxx_identifier, pp_cxx_tree_identifier\n\tand\n\tpp_cxx_whitespace throughout.\n\t(dump_binary_op): Use pp_cxx_whitespace, pp_cxx_left_paren and\n\tpp_cxx_right_paren.\n\t(dump_unary_op): Likewise.\n\t(reinit_cxx_pp): New function.\n\t(type_as_string); Use it.\n\t(expr_as_string): Likewise.\n\t(decl_as_string); Likewise.\n\t(context_as_string): Likewise.\n\t(lang_decl_name): Likewise.\n\t(decl_to_string): Likewise.\n\t(expr_to_string): Likewise.\n\t(parm_to_string): Likewise.\n\t(type_to_string): Likewise.\n\t(args_to_string): Likewise.\n\t(cv_to_string): Likewise.\n\nFrom-SVN: r83732", "tree": {"sha": "d0994e20bebe3c816128ad87a22eeb1df1f69f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0994e20bebe3c816128ad87a22eeb1df1f69f89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66a74d2a079df4c1945926eda5d482e88214a101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a74d2a079df4c1945926eda5d482e88214a101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66a74d2a079df4c1945926eda5d482e88214a101"}], "stats": {"total": 458, "additions": 259, "deletions": 199}, "files": [{"sha": "92eb2c7d7a1b23cc22399564c9e68f4c080dc245", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "patch": "@@ -1,3 +1,52 @@\n+2004-06-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* error.c (pp_template_argument_list_start): Remove.\n+\t(pp_template_argument_list_end): Likewise.\n+\t(pp_separate_with_comma): Use pp_cxx_separate_with.\n+\t(reinit_global_formatting_buffer): Remove.\n+\t(pp_non_consecutive_character): Likewise.\n+\t(dump_scope): Use pp_cxx_colon_colon.\n+\t(dump_template_parameter): Use pp_cxx_identifier,\n+\tpp_cxx_tree_identifier and pp_cxx_whitespace. \n+\t(dump_templat_bindings): Replace use of pp_string with sequence\n+\tof pp_cxx_whitespace and pp_equal.\n+\t(dump_type): Use pp_cxx_identifier, pp_cxx_tree_identifier,\n+\tpp_cxx_colon_colon, pp_cxx_whitespace throughout.  Don't set\n+\tpadding here. \n+\t(dump_aggr_type): Use pp_cxx_identifier amd pp_cxx_tree_identifier.\n+\t(dump_type_prefix): Don't set padding.  Use pp_cxx_whitespace,\n+\tpp_cxx_left_parent, pp_cxx_colon_colon and pp_cxx_star troughout.\n+\t(dump_type_suffix): Use pp_cxx_right_paren, pp_cxx_left_bracket,\n+\tpp_cxx_right_bracket, pp_cxx_identifier throughout,\n+\t(dump_decl): Likewise.\n+\t(dump_template_decl): Likewise.\n+\t(dump_function_decl): Likewise.  Set padding as appropriate.\n+\t(dump_parameters): Use pp_cxx_left_paren, pp_cxx_identifier and\n+\tpp_cxx_right_paren. \n+\t(dump_exception_spec): Likewise.\n+\t(dump_function_name): Use pp_cxx_tree_identifier and\n+\tpp_cxx_identifier. \n+\t(dump_template_parms): Use pp_cxx_begin_template_argument_list and\n+\tpp_cxx_end_template_argument_list.\n+\t(dump_expr): Use pp_cxx_left_paren, pp_cxx_right_paren,\n+\tpp_cxx_colon_colon, pp_cxx_identifier, pp_cxx_tree_identifier and\n+\tpp_cxx_whitespace throughout. \n+\t(dump_binary_op): Use pp_cxx_whitespace, pp_cxx_left_paren and\n+\tpp_cxx_right_paren. \n+\t(dump_unary_op): Likewise.\n+\t(reinit_cxx_pp): New function.\n+\t(type_as_string); Use it.\n+\t(expr_as_string): Likewise.\n+\t(decl_as_string); Likewise.\n+\t(context_as_string): Likewise.\n+\t(lang_decl_name): Likewise.\n+\t(decl_to_string): Likewise.\n+\t(expr_to_string): Likewise.\n+\t(parm_to_string): Likewise.\n+\t(type_to_string): Likewise.\n+\t(args_to_string): Likewise.\n+\t(cv_to_string): Likewise.\n+\n 2004-06-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (cp_cv_quals): New type."}, {"sha": "81bba562c9d562295bb848d770441612b322be8b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 210, "deletions": 199, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73bbafe5785c1bcf6ee98c650d91dd78382ee5eb/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=73bbafe5785c1bcf6ee98c650d91dd78382ee5eb", "patch": "@@ -32,11 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks-def.h\"\n #include \"cxx-pretty-print.h\"\n \n-#define pp_template_argument_list_start(PP) \\\n-   pp_non_consecutive_character (PP, '<')\n-#define pp_template_argument_list_end(PP)  \\\n-   pp_non_consecutive_character (PP, '>')\n-#define pp_separate_with_comma(PP) pp_string (PP, \", \")\n+#define pp_separate_with_comma(PP) pp_cxx_separate_with (PP, ',')\n \n /* The global buffer where we dump everything.  It is there only for\n    transitional purpose.  It is expected, in the near future, to be\n@@ -46,9 +42,6 @@ static cxx_pretty_printer scratch_pretty_printer;\n \n # define NEXT_CODE(T) (TREE_CODE (TREE_TYPE (T)))\n \n-#define reinit_global_formatting_buffer() \\\n-   pp_clear_output_area (scratch_buffer)\n-\n static const char *args_to_string (tree, int);\n static const char *assop_to_string (enum tree_code);\n static const char *code_to_string (enum tree_code);\n@@ -95,7 +88,6 @@ static void cp_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n \n static bool cp_printer (pretty_printer *, text_info *);\n-static void pp_non_consecutive_character (cxx_pretty_printer *, int);\n static tree locate_error (const char *, va_list);\n static location_t location_of (tree);\n \n@@ -125,18 +117,18 @@ dump_scope (tree scope, int flags)\n       if (scope != global_namespace)\n         {\n           dump_decl (scope, f);\n-          pp_colon_colon (cxx_pp);\n+          pp_cxx_colon_colon (cxx_pp);\n         }\n     }\n   else if (AGGREGATE_TYPE_P (scope))\n     {\n       dump_type (scope, f);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n     }\n   else if ((flags & TFF_SCOPE) && TREE_CODE (scope) == FUNCTION_DECL)\n     {\n       dump_function_decl (scope, f);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n     }\n }\n \n@@ -182,15 +174,12 @@ dump_template_parameter (tree parm, int flags)\n     {\n       if (flags & TFF_DECL_SPECIFIERS)\n         {\n-          pp_identifier (cxx_pp, \"class\");\n+          pp_cxx_identifier (cxx_pp, \"class\");\n           if (DECL_NAME (p))\n-            {\n-              pp_space (cxx_pp);\n-              pp_tree_identifier (cxx_pp, DECL_NAME (p));\n-            }\n+            pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n         }\n       else if (DECL_NAME (p))\n-        pp_tree_identifier (cxx_pp, DECL_NAME (p));\n+        pp_cxx_tree_identifier (cxx_pp, DECL_NAME (p));\n       else\n         pp_cxx_canonical_template_parameter (cxx_pp, TREE_TYPE (p));\n     }\n@@ -199,7 +188,9 @@ dump_template_parameter (tree parm, int flags)\n \n   if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && a != NULL_TREE)\n     {\n-      pp_string (cxx_pp, \" = \");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_equal (cxx_pp);\n+      pp_cxx_whitespace (cxx_pp);\n       if (TREE_CODE (p) == TYPE_DECL || TREE_CODE (p) == TEMPLATE_DECL)\n         dump_type (a, flags & ~TFF_CHASE_TYPEDEF);\n       else\n@@ -238,7 +229,9 @@ dump_template_bindings (tree parms, tree args)\n \t  if (need_comma)\n \t    pp_separate_with_comma (cxx_pp);\n \t  dump_template_parameter (TREE_VEC_ELT (p, i), TFF_PLAIN_IDENTIFIER);\n-\t  pp_string (cxx_pp, \" = \");\n+          pp_cxx_whitespace (cxx_pp);\n+          pp_equal (cxx_pp);\n+          pp_cxx_whitespace (cxx_pp);\n \t  if (arg)\n \t    dump_template_argument (arg, TFF_PLAIN_IDENTIFIER);\n \t  else\n@@ -276,7 +269,7 @@ dump_type (tree t, int flags)\n       break;\n \n     case IDENTIFIER_NODE:\n-      pp_tree_identifier (cxx_pp, t);\n+      pp_cxx_tree_identifier (cxx_pp, t);\n       break;\n \n     case TREE_VEC:\n@@ -309,32 +302,31 @@ dump_type (tree t, int flags)\n     case BOOLEAN_TYPE:\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n-      pp_base (cxx_pp)->padding = pp_none;\n       pp_type_specifier_seq (cxx_pp, t);\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n       /* For parameters inside template signature.  */\n       if (TYPE_IDENTIFIER (t))\n-\tpp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n       else\n         pp_cxx_canonical_template_parameter (cxx_pp, t);\n       break;\n \n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n       {\n \ttree args = TYPE_TI_ARGS (t);\n-\tpp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n-\tpp_template_argument_list_start (cxx_pp);\n+\tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_begin_template_argument_list (cxx_pp);\n         dump_template_argument_list (args, flags);\n-\tpp_template_argument_list_end (cxx_pp);\n+\tpp_cxx_end_template_argument_list (cxx_pp);\n       }\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n       pp_cxx_cv_qualifier_seq (cxx_pp, t);\n       if (TYPE_IDENTIFIER (t))\n-\tpp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n+\tpp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (t));\n       else\n         pp_cxx_canonical_template_parameter\n           (cxx_pp, TEMPLATE_TYPE_PARM_INDEX (t));\n@@ -356,21 +348,23 @@ dump_type (tree t, int flags)\n     }\n     case TYPENAME_TYPE:\n       pp_cxx_cv_qualifier_seq (cxx_pp, t);\n-      pp_string (cxx_pp, \"typename \");\n+      pp_cxx_identifier (cxx_pp, \"typename\");\n       dump_typename (t, flags);\n       break;\n \n     case UNBOUND_CLASS_TEMPLATE:\n       dump_type (TYPE_CONTEXT (t), flags);\n-      pp_colon_colon (cxx_pp);\n-      pp_identifier (cxx_pp, \"template \");\n+      pp_cxx_colon_colon (cxx_pp);\n+      pp_cxx_identifier (cxx_pp, \"template\");\n       dump_type (DECL_NAME (TYPE_NAME (t)), flags);\n       break;\n \n     case TYPEOF_TYPE:\n-      pp_string (cxx_pp, \"__typeof (\");\n+      pp_cxx_identifier (cxx_pp, \"__typeof__\");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       dump_expr (TYPEOF_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     default:\n@@ -395,7 +389,7 @@ dump_typename (tree t, int flags)\n     dump_typename (ctx, flags);\n   else\n     dump_type (ctx, flags & ~TFF_CLASS_KEY_OR_ENUM);\n-  pp_colon_colon (cxx_pp);\n+  pp_cxx_colon_colon (cxx_pp);\n   dump_decl (TYPENAME_TYPE_FULLNAME (t), flags);\n }\n \n@@ -428,10 +422,7 @@ dump_aggr_type (tree t, int flags)\n   pp_cxx_cv_qualifier_seq (cxx_pp, t);\n \n   if (flags & TFF_CLASS_KEY_OR_ENUM)\n-    {\n-      pp_identifier (cxx_pp, variety);\n-      pp_space (cxx_pp);\n-    }\n+    pp_cxx_identifier (cxx_pp, variety);\n \n   if (flags & TFF_CHASE_TYPEDEF)\n     t = TYPE_MAIN_VARIANT (t);\n@@ -469,7 +460,7 @@ dump_aggr_type (tree t, int flags)\n         pp_printf (pp_base (cxx_pp), \"<anonymous %s>\", variety);\n     }\n   else\n-    pp_tree_identifier (cxx_pp, name);\n+    pp_cxx_tree_identifier (cxx_pp, name);\n   if (tmplate)\n     dump_template_parms (TYPE_TEMPLATE_INFO (t),\n                          !CLASSTYPE_USE_TEMPLATE (t),\n@@ -490,8 +481,6 @@ dump_aggr_type (tree t, int flags)\n static void \n dump_type_prefix (tree t, int flags)\n {\n-  pp_base (cxx_pp)->padding = pp_none;\n-\n   if (TYPE_PTRMEMFUNC_P (t))\n     {\n       t = TYPE_PTRMEMFUNC_FN_TYPE (t);\n@@ -508,8 +497,8 @@ dump_type_prefix (tree t, int flags)\n \tdump_type_prefix (sub, flags);\n \tif (TREE_CODE (sub) == ARRAY_TYPE)\n \t  {\n-\t    pp_space (cxx_pp);\n-\t    pp_left_paren (cxx_pp);\n+\t    pp_cxx_whitespace (cxx_pp);\n+\t    pp_cxx_left_paren (cxx_pp);\n \t  }\n \tpp_character (cxx_pp, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n         pp_base (cxx_pp)->padding = pp_before;\n@@ -524,9 +513,9 @@ dump_type_prefix (tree t, int flags)\n \t{\n           pp_maybe_space (cxx_pp);\n \t  dump_type (TYPE_OFFSET_BASETYPE (t), flags);\n-\t  pp_colon_colon (cxx_pp);\n+\t  pp_cxx_colon_colon (cxx_pp);\n \t}\n-      pp_star (cxx_pp);\n+      pp_cxx_star (cxx_pp);\n       pp_cxx_cv_qualifier_seq (cxx_pp, t);\n       break;\n \n@@ -535,15 +524,15 @@ dump_type_prefix (tree t, int flags)\n     case FUNCTION_TYPE:\n       dump_type_prefix (TREE_TYPE (t), flags);\n       pp_maybe_space (cxx_pp);\n-      pp_left_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       break;\n \n     case METHOD_TYPE:\n       dump_type_prefix (TREE_TYPE (t), flags);\n       pp_maybe_space (cxx_pp);\n-      pp_left_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       dump_aggr_type (TYPE_METHOD_BASETYPE (t), flags);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n       break;\n \n     case ARRAY_TYPE:\n@@ -597,7 +586,7 @@ dump_type_suffix (tree t, int flags)\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE)\n-\tpp_right_paren (cxx_pp);\n+\tpp_cxx_right_paren (cxx_pp);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n@@ -606,7 +595,7 @@ dump_type_suffix (tree t, int flags)\n     case METHOD_TYPE:\n       {\n \ttree arg;\n-        pp_right_paren (cxx_pp);\n+        pp_cxx_right_paren (cxx_pp);\n \targ = TYPE_ARG_TYPES (t);\n \tif (TREE_CODE (t) == METHOD_TYPE)\n \t  arg = TREE_CHAIN (arg);\n@@ -624,7 +613,7 @@ dump_type_suffix (tree t, int flags)\n       }\n \n     case ARRAY_TYPE:\n-      pp_left_bracket (cxx_pp);\n+      pp_cxx_left_bracket (cxx_pp);\n       if (TYPE_DOMAIN (t))\n \t{\n \t  if (host_integerp (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0))\n@@ -639,7 +628,7 @@ dump_type_suffix (tree t, int flags)\n \t\t\t      integer_one_node)),\n \t               flags & ~TFF_EXPR_IN_PARENS);\n \t}\n-      pp_right_bracket (cxx_pp);\n+      pp_cxx_right_bracket (cxx_pp);\n       dump_type_suffix (TREE_TYPE (t), flags);\n       break;\n \n@@ -724,14 +713,14 @@ dump_decl (tree t, int flags)\n \t    if ((flags & TFF_DECL_SPECIFIERS)\n \t        && TREE_CODE (TREE_TYPE (t)) == TEMPLATE_TYPE_PARM)\n \t      /* Say `class T' not just `T'.  */\n-\t      pp_string (cxx_pp, \"class \");\n+\t      pp_cxx_identifier (cxx_pp, \"class\");\n \n \t    dump_type (TREE_TYPE (t), flags);\n \t    break;\n \t  }\n       }\n       if (flags & TFF_DECL_SPECIFIERS)\n-\tpp_string (cxx_pp, \"typedef \");\n+\tpp_cxx_identifier (cxx_pp, \"typedef\");\n       dump_simple_decl (t, DECL_ORIGINAL_TYPE (t)\n \t\t\t? DECL_ORIGINAL_TYPE (t) : TREE_TYPE (t),\n \t                flags);\n@@ -766,7 +755,7 @@ dump_decl (tree t, int flags)\n           if (DECL_NAME (t) == NULL_TREE)\n             pp_identifier (cxx_pp, \"<unnamed>\");\n           else\n-            pp_tree_identifier (cxx_pp, DECL_NAME (t));\n+            pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n         }\n       break;\n \n@@ -778,9 +767,9 @@ dump_decl (tree t, int flags)\n \n     case ARRAY_REF:\n       dump_decl (TREE_OPERAND (t, 0), flags);\n-      pp_left_bracket (cxx_pp);\n+      pp_cxx_left_bracket (cxx_pp);\n       dump_decl (TREE_OPERAND (t, 1), flags);\n-      pp_right_bracket (cxx_pp);\n+      pp_cxx_right_bracket (cxx_pp);\n       break;\n \n       /* So that we can do dump_decl on an aggr type.  */\n@@ -793,7 +782,7 @@ dump_decl (tree t, int flags)\n     case BIT_NOT_EXPR:\n       /* This is a pseudo destructor call which has not been folded into\n          a PSEUDO_DTOR_EXPR yet.  */\n-      pp_complement (cxx_pp);\n+      pp_cxx_complement (cxx_pp);\n       dump_type (TREE_OPERAND (t, 0), flags);\n       break;\n \n@@ -806,13 +795,13 @@ dump_decl (tree t, int flags)\n     case IDENTIFIER_NODE:\n       if (IDENTIFIER_TYPENAME_P (t))\n \t{\n-\t  pp_string (cxx_pp, \"operator \");\n+\t  pp_cxx_identifier (cxx_pp, \"operator\");\n \t  /* Not exactly IDENTIFIER_TYPE_VALUE.  */\n \t  dump_type (TREE_TYPE (t), flags);\n \t  break;\n \t}\n       else\n-\tpp_tree_identifier (cxx_pp, t);\n+\tpp_cxx_tree_identifier (cxx_pp, t);\n       break;\n \n     case OVERLOAD:\n@@ -822,12 +811,12 @@ dump_decl (tree t, int flags)\n \t  if (DECL_CLASS_SCOPE_P (t))\n \t    {\n \t      dump_type (DECL_CONTEXT (t), flags);\n-              pp_colon_colon (cxx_pp);\n+              pp_cxx_colon_colon (cxx_pp);\n \t    }\n \t  else if (DECL_CONTEXT (t))\n \t    {\n \t      dump_decl (DECL_CONTEXT (t), flags);\n-              pp_colon_colon (cxx_pp);\n+              pp_cxx_colon_colon (cxx_pp);\n \t    }\n \t  dump_decl (DECL_NAME (t), flags);\n \t  break;\n@@ -858,15 +847,15 @@ dump_decl (tree t, int flags)\n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n \tdump_decl (name, flags);\n-\tpp_template_argument_list_start (cxx_pp);\n+\tpp_cxx_begin_template_argument_list (cxx_pp);\n \tif (TREE_OPERAND (t, 1))\n \t  dump_template_argument_list (TREE_OPERAND (t, 1), flags);\n-\tpp_template_argument_list_end (cxx_pp);\n+\tpp_cxx_end_template_argument_list (cxx_pp);\n       }\n       break;\n \n     case LABEL_DECL:\n-      pp_tree_identifier (cxx_pp, DECL_NAME (t));\n+      pp_cxx_tree_identifier (cxx_pp, DECL_NAME (t));\n       break;\n \n     case CONST_DECL:\n@@ -883,9 +872,9 @@ dump_decl (tree t, int flags)\n       break;\n \n     case USING_DECL:\n-      pp_string (cxx_pp, \"using \");\n+      pp_cxx_identifier (cxx_pp, \"using\");\n       dump_type (DECL_INITIAL (t), flags);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n       dump_decl (DECL_NAME (t), flags);\n       break;\n \n@@ -933,7 +922,8 @@ dump_template_decl (tree t, int flags)\n \t  tree inner_parms = INNERMOST_TEMPLATE_PARMS (parms);\n           int len = TREE_VEC_LENGTH (inner_parms);\n \n-          pp_string (cxx_pp, \"template<\");\n+          pp_cxx_identifier (cxx_pp, \"template\");\n+          pp_cxx_begin_template_argument_list (cxx_pp);\n \n \t  /* If we've shown the template prefix, we'd better show the\n \t     parameters' and decl's type too.  */\n@@ -945,14 +935,14 @@ dump_template_decl (tree t, int flags)\n                 pp_separate_with_comma (cxx_pp);\n               dump_template_parameter (TREE_VEC_ELT (inner_parms, i), flags);\n             }\n-          pp_template_argument_list_end (cxx_pp);\n-          pp_space (cxx_pp);\n+          pp_cxx_end_template_argument_list (cxx_pp);\n+          pp_cxx_whitespace (cxx_pp);\n         }\n       nreverse(orig_parms);\n \n       if (DECL_TEMPLATE_TEMPLATE_PARM_P (t))\n \t/* Say `template<arg> class TT' not just `template<arg> TT'.  */\n-\tpp_string (cxx_pp, \"class \");\n+\tpp_cxx_identifier (cxx_pp, \"class\");\n     }\n \n   if (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n@@ -1022,25 +1012,22 @@ dump_function_decl (tree t, int flags)\n   if (!(flags & TFF_DECL_SPECIFIERS))\n     /* OK */;\n   else if (DECL_STATIC_FUNCTION_P (t))\n-    pp_identifier (cxx_pp, \"static \");\n+    pp_cxx_identifier (cxx_pp, \"static\");\n   else if (DECL_VIRTUAL_P (t))\n-    pp_identifier (cxx_pp, \"virtual \");\n+    pp_cxx_identifier (cxx_pp, \"virtual\");\n \n   /* Print the return type?  */\n   if (show_return)\n     show_return = !DECL_CONV_FN_P (t)  && !DECL_CONSTRUCTOR_P (t)\n                   && !DECL_DESTRUCTOR_P (t);\n   if (show_return)\n-    {\n-      dump_type_prefix (TREE_TYPE (fntype), flags);\n-      pp_space (cxx_pp);\n-    }\n+    dump_type_prefix (TREE_TYPE (fntype), flags);\n \n   /* Print the function name.  */\n   if (cname)\n     {\n       dump_type (cname, flags);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n     }\n   else\n     dump_scope (CP_DECL_CONTEXT (t), flags);\n@@ -1052,11 +1039,17 @@ dump_function_decl (tree t, int flags)\n       dump_parameters (parmtypes, flags);\n \n       if (TREE_CODE (fntype) == METHOD_TYPE)\n-        pp_cxx_cv_qualifier_seq\n-          (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))));\n+        {\n+          pp_base (cxx_pp)->padding = pp_before;\n+          pp_cxx_cv_qualifier_seq\n+            (cxx_pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))));\n+        }\n \n       if (flags & TFF_EXCEPTION_SPECIFICATION)\n-\tdump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n+        {\n+          pp_base (cxx_pp)->padding = pp_before;\n+          dump_exception_spec (TYPE_RAISES_EXCEPTIONS (fntype), flags);\n+        }\n \n       if (show_return)\n \tdump_type_suffix (TREE_TYPE (fntype), flags);\n@@ -1065,9 +1058,12 @@ dump_function_decl (tree t, int flags)\n   /* If T is a template instantiation, dump the parameter binding.  */\n   if (template_parms != NULL_TREE && template_args != NULL_TREE)\n     {\n-      pp_string (cxx_pp, \" [with \");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_bracket (cxx_pp);\n+      pp_cxx_identifier (cxx_pp, \"with\");\n+      pp_cxx_whitespace (cxx_pp);\n       dump_template_bindings (template_parms, template_args);\n-      pp_right_bracket (cxx_pp);\n+      pp_cxx_right_bracket (cxx_pp);\n     }\n }\n \n@@ -1080,7 +1076,7 @@ dump_parameters (tree parmtypes, int flags)\n {\n   int first;\n \n-  pp_left_paren (cxx_pp);\n+  pp_cxx_left_paren (cxx_pp);\n \n   for (first = 1; parmtypes != void_list_node;\n        parmtypes = TREE_CHAIN (parmtypes))\n@@ -1090,19 +1086,21 @@ dump_parameters (tree parmtypes, int flags)\n       first = 0;\n       if (!parmtypes)\n         {\n-          pp_identifier (cxx_pp, \"...\");\n+          pp_cxx_identifier (cxx_pp, \"...\");\n           break;\n         }\n       dump_type (TREE_VALUE (parmtypes), flags);\n \n       if ((flags & TFF_FUNCTION_DEFAULT_ARGUMENTS) && TREE_PURPOSE (parmtypes))\n         {\n-          pp_string (cxx_pp, \" = \");\n+          pp_cxx_whitespace (cxx_pp);\n+          pp_equal (cxx_pp);\n+          pp_cxx_whitespace (cxx_pp);\n           dump_expr (TREE_PURPOSE (parmtypes), flags | TFF_EXPR_IN_PARENS);\n         }\n     }\n \n-  pp_right_paren (cxx_pp);\n+  pp_cxx_right_paren (cxx_pp);\n }\n \n /* Print an exception specification. T is the exception specification.  */\n@@ -1112,7 +1110,9 @@ dump_exception_spec (tree t, int flags)\n {\n   if (t)\n     {\n-      pp_string (cxx_pp, \" throw (\");\n+      pp_cxx_identifier (cxx_pp, \"throw\");\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       if (TREE_VALUE (t) != NULL_TREE)\n         while (1)\n           {\n@@ -1122,7 +1122,7 @@ dump_exception_spec (tree t, int flags)\n               break;\n             pp_separate_with_comma (cxx_pp);\n           }\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n     }\n }\n \n@@ -1141,7 +1141,7 @@ dump_function_name (tree t, int flags)\n      literal name.  */\n   if (!DECL_LANG_SPECIFIC (t))\n     {\n-      pp_tree_identifier (cxx_pp, name);\n+      pp_cxx_tree_identifier (cxx_pp, name);\n       return;\n     }\n \n@@ -1155,7 +1155,7 @@ dump_function_name (tree t, int flags)\n \n   if (DECL_DESTRUCTOR_P (t))\n     {\n-      pp_complement (cxx_pp);\n+      pp_cxx_complement (cxx_pp);\n       dump_decl (name, TFF_PLAIN_IDENTIFIER);\n     }\n   else if (DECL_CONV_FN_P (t))\n@@ -1166,11 +1166,11 @@ dump_function_name (tree t, int flags)\n \t declarations, both will have the same name, yet\n \t the types will be different, hence the TREE_TYPE field\n \t of the first name will be clobbered by the second.  */\n-      pp_string (cxx_pp, \"operator \");\n+      pp_cxx_identifier (cxx_pp, \"operator\");\n       dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n   else if (IDENTIFIER_OPNAME_P (name))\n-    pp_tree_identifier (cxx_pp, name);\n+    pp_cxx_tree_identifier (cxx_pp, name);\n   else\n     dump_decl (name, flags);\n \n@@ -1197,7 +1197,7 @@ dump_template_parms (tree info, int primary, int flags)\n   if (primary && flags & TFF_TEMPLATE_NAME)\n     return;\n   flags &= ~(TFF_CLASS_KEY_OR_ENUM | TFF_TEMPLATE_NAME);\n-  pp_template_argument_list_start (cxx_pp);\n+  pp_cxx_begin_template_argument_list (cxx_pp);\n \n   /* Be careful only to print things when we have them, so as not\n \t to crash producing error messages.  */\n@@ -1242,7 +1242,7 @@ dump_template_parms (tree info, int primary, int flags)\n           dump_decl (parm, flags & ~TFF_DECL_SPECIFIERS);\n         }\n     }\n-  pp_template_argument_list_end (cxx_pp);\n+  pp_cxx_end_template_argument_list (cxx_pp);\n }\n \n /* Print out a list of initializers (subr of dump_expr).  */\n@@ -1288,39 +1288,40 @@ dump_expr (tree t, int flags)\n       break;\n \n     case THROW_EXPR:\n-      pp_identifier (cxx_pp, \"throw\");\n+      pp_cxx_identifier (cxx_pp, \"throw\");\n       dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n     case PTRMEM_CST:\n       pp_ampersand (cxx_pp);\n       dump_type (PTRMEM_CST_CLASS (t), flags);\n-      pp_colon_colon (cxx_pp);\n-      pp_tree_identifier (cxx_pp, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n+      pp_cxx_colon_colon (cxx_pp);\n+      pp_cxx_tree_identifier (cxx_pp, DECL_NAME (PTRMEM_CST_MEMBER (t)));\n       break;\n \n     case COMPOUND_EXPR:\n-      pp_left_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       pp_separate_with_comma (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case COND_EXPR:\n-      pp_left_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n       pp_string (cxx_pp, \" ? \");\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n       pp_string (cxx_pp, \" : \");\n       dump_expr (TREE_OPERAND (t, 2), flags | TFF_EXPR_IN_PARENS);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case SAVE_EXPR:\n       if (TREE_HAS_CONSTRUCTOR (t))\n \t{\n-\t  pp_string (cxx_pp, \"new \");\n+\t  pp_cxx_identifier (cxx_pp, \"new\");\n+          pp_cxx_whitespace (cxx_pp);\n \t  dump_type (TREE_TYPE (TREE_TYPE (t)), flags);\n \t}\n       else\n@@ -1337,17 +1338,17 @@ dump_expr (tree t, int flags)\n \tif (fn && TREE_CODE (fn) == FUNCTION_DECL)\n \t  {\n \t    if (DECL_CONSTRUCTOR_P (fn))\n-\t      pp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (TREE_TYPE (t)));\n+\t      pp_cxx_tree_identifier (cxx_pp, TYPE_IDENTIFIER (TREE_TYPE (t)));\n \t    else\n \t      dump_decl (fn, 0);\n \t  }\n \telse\n \t  dump_expr (TREE_OPERAND (t, 0), 0);\n       }\n-      pp_left_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       if (TREE_OPERAND (t, 1))\n \tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case CALL_EXPR:\n@@ -1375,9 +1376,9 @@ dump_expr (tree t, int flags)\n \t    args = TREE_CHAIN (args);\n \t  }\n \tdump_expr (fn, flags | TFF_EXPR_IN_PARENS);\n-\tpp_left_paren (cxx_pp);\n+\tpp_cxx_left_paren (cxx_pp);\n \tdump_expr_list (args, flags);\n-\tpp_right_paren (cxx_pp);\n+\tpp_cxx_right_paren (cxx_pp);\n       }\n       break;\n \n@@ -1386,13 +1387,14 @@ dump_expr (tree t, int flags)\n \ttree type = TREE_OPERAND (t, 1);\n \ttree init = TREE_OPERAND (t, 2);\n \tif (NEW_EXPR_USE_GLOBAL (t))\n-          pp_colon_colon (cxx_pp);\n-\tpp_string (cxx_pp, \"new \");\n+          pp_cxx_colon_colon (cxx_pp);\n+\tpp_cxx_identifier (cxx_pp, \"new\");\n \tif (TREE_OPERAND (t, 0))\n \t  {\n-\t    pp_left_paren (cxx_pp);\n+\t    pp_cxx_left_paren (cxx_pp);\n \t    dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t    pp_string (cxx_pp, \") \");\n+            pp_cxx_right_paren (cxx_pp);\n+            pp_cxx_whitespace (cxx_pp);\n \t  }\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n@@ -1403,7 +1405,7 @@ dump_expr (tree t, int flags)\n \tdump_type (type, flags);\n \tif (init)\n \t  {\n-\t    pp_left_paren (cxx_pp);\n+\t    pp_cxx_left_paren (cxx_pp);\n \t    if (TREE_CODE (init) == TREE_LIST)\n \t      dump_expr_list (init, flags);\n \t    else if (init == void_zero_node)\n@@ -1412,7 +1414,7 @@ dump_expr (tree t, int flags)\n \t      ;\n \t    else\n \t      dump_expr (init, flags);\n-\t    pp_right_paren (cxx_pp);\n+\t    pp_cxx_right_paren (cxx_pp);\n \t  }\n       }\n       break;\n@@ -1475,31 +1477,31 @@ dump_expr (tree t, int flags)\n \t\t|| strcmp (IDENTIFIER_POINTER (DECL_NAME (ob)), \"this\"))\n \t      {\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_arrow (cxx_pp);\n+\t\tpp_cxx_arrow (cxx_pp);\n \t      }\n \t  }\n \telse\n \t  {\n \t    dump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t    pp_dot (cxx_pp);\n+\t    pp_cxx_dot (cxx_pp);\n \t  }\n \tdump_expr (TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n       }\n       break;\n \n     case ARRAY_REF:\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_left_bracket (cxx_pp);\n+      pp_cxx_left_bracket (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-      pp_right_bracket (cxx_pp);\n+      pp_cxx_right_bracket (cxx_pp);\n       break;\n \n     case CONVERT_EXPR:\n       if (TREE_TYPE (t) && VOID_TYPE_P (TREE_TYPE (t)))\n \t{\n-\t  pp_left_paren (cxx_pp);\n+\t  pp_cxx_left_paren (cxx_pp);\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  pp_right_paren (cxx_pp);\n+\t  pp_cxx_right_paren (cxx_pp);\n \t  dump_expr (TREE_OPERAND (t, 0), flags);\n \t}\n       else\n@@ -1525,9 +1527,9 @@ dump_expr (tree t, int flags)\n \t  t = TREE_OPERAND (t, 0);\n \t  my_friendly_assert (TREE_CODE (t) == CALL_EXPR, 237);\n \t  dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-\t  pp_left_paren (cxx_pp);\n+\t  pp_cxx_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)), flags);\n-\t  pp_right_paren (cxx_pp);\n+\t  pp_cxx_right_paren (cxx_pp);\n \t}\n       else\n \t{\n@@ -1550,10 +1552,10 @@ dump_expr (tree t, int flags)\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      pp_left_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-      pp_identifier (cxx_pp, operator_name_info[(int)TREE_CODE (t)].name);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_identifier (cxx_pp, operator_name_info[(int)TREE_CODE (t)].name);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case NON_LVALUE_EXPR:\n@@ -1570,11 +1572,11 @@ dump_expr (tree t, int flags)\n \t  if (TREE_CODE (next) == FUNCTION_TYPE)\n \t    {\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t        pp_left_paren (cxx_pp);\n-\t      pp_star (cxx_pp);\n+\t        pp_cxx_left_paren (cxx_pp);\n+\t      pp_cxx_star (cxx_pp);\n \t      dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n \t      if (flags & TFF_EXPR_IN_PARENS)\n-\t        pp_right_paren (cxx_pp);\n+\t        pp_cxx_right_paren (cxx_pp);\n \t      break;\n \t    }\n \t  /* Else fall through.  */\n@@ -1591,13 +1593,13 @@ dump_expr (tree t, int flags)\n \t    /* It is a cast, but we cannot tell whether it is a\n \t       reinterpret or static cast. Use the C style notation.  */\n \t    if (flags & TFF_EXPR_IN_PARENS)\n-\t      pp_left_paren (cxx_pp);\n-\t    pp_left_paren (cxx_pp);\n+\t      pp_cxx_left_paren (cxx_pp);\n+\t    pp_cxx_left_paren (cxx_pp);\n \t    dump_type (TREE_TYPE (t), flags);\n-\t    pp_right_paren (cxx_pp);\n+\t    pp_cxx_right_paren (cxx_pp);\n \t    dump_expr (op, flags | TFF_EXPR_IN_PARENS);\n \t    if (flags & TFF_EXPR_IN_PARENS)\n-\t      pp_right_paren (cxx_pp);\n+\t      pp_cxx_right_paren (cxx_pp);\n \t  }\n \telse\n \t  dump_expr (op, flags);\n@@ -1612,11 +1614,12 @@ dump_expr (tree t, int flags)\n \t  if (integer_zerop (idx))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n-              pp_left_paren (cxx_pp);\n-              pp_left_paren (cxx_pp);\n+              pp_cxx_left_paren (cxx_pp);\n+              pp_cxx_left_paren (cxx_pp);\n \t      dump_type (TREE_TYPE (t), flags);\n-              pp_right_paren (cxx_pp);\n-              pp_string (cxx_pp, \")0)\");\n+              pp_cxx_right_paren (cxx_pp);\n+              pp_character (cxx_pp, '0');\n+              pp_cxx_right_paren (cxx_pp);\n \t      break;\n \t    }\n \t  else if (host_integerp (idx, 0))\n@@ -1650,14 +1653,14 @@ dump_expr (tree t, int flags)\n       if (TREE_TYPE (t) && !CONSTRUCTOR_ELTS (t))\n \t{\n \t  dump_type (TREE_TYPE (t), 0);\n-          pp_left_paren (cxx_pp);\n-          pp_right_paren (cxx_pp);\n+          pp_cxx_left_paren (cxx_pp);\n+          pp_cxx_right_paren (cxx_pp);\n \t}\n       else\n \t{\n-          pp_left_brace (cxx_pp);\n+          pp_cxx_left_brace (cxx_pp);\n \t  dump_expr_list (CONSTRUCTOR_ELTS (t), flags);\n-          pp_right_brace (cxx_pp);\n+          pp_cxx_right_brace (cxx_pp);\n \t}\n       \n       break;\n@@ -1682,12 +1685,14 @@ dump_expr (tree t, int flags)\n \t    if (TREE_CODE (ob) == INDIRECT_REF)\n \t      {\n \t\tdump_expr (TREE_OPERAND (ob, 0), flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_string (cxx_pp, \"->*\");\n+                pp_cxx_arrow (cxx_pp);\n+                pp_cxx_star (cxx_pp);\n \t      }\n \t    else\n \t      {\n \t\tdump_expr (ob, flags | TFF_EXPR_IN_PARENS);\n-\t\tpp_string (cxx_pp, \".*\");\n+                pp_cxx_dot (cxx_pp);\n+                pp_cxx_star (cxx_pp);\n \t      }\n \t    dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n \t  }\n@@ -1700,7 +1705,7 @@ dump_expr (tree t, int flags)\n \n     case SCOPE_REF:\n       dump_type (TREE_OPERAND (t, 0), flags);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n       break;\n \n@@ -1709,63 +1714,68 @@ dump_expr (tree t, int flags)\n \t  || TREE_CHAIN (TREE_OPERAND (t, 0)))\n \t{\n \t  dump_type (TREE_TYPE (t), flags);\n-\t  pp_left_paren (cxx_pp);\n+\t  pp_cxx_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  pp_right_paren (cxx_pp);\n+\t  pp_cxx_right_paren (cxx_pp);\n \t}\n       else\n \t{\n-\t  pp_left_paren (cxx_pp);\n+\t  pp_cxx_left_paren (cxx_pp);\n \t  dump_type (TREE_TYPE (t), flags);\n-          pp_string (cxx_pp, \")(\");\n+          pp_cxx_right_paren (cxx_pp);\n+          pp_cxx_left_paren (cxx_pp);\n \t  dump_expr_list (TREE_OPERAND (t, 0), flags);\n-\t  pp_right_paren (cxx_pp);\n+\t  pp_cxx_right_paren (cxx_pp);\n \t}\n       break;\n \n     case STATIC_CAST_EXPR:\n-      pp_string (cxx_pp, \"static_cast<\");\n+      pp_cxx_identifier (cxx_pp, \"static_cast\");\n       goto cast;\n     case REINTERPRET_CAST_EXPR:\n-      pp_string (cxx_pp, \"reinterpret_cast<\");\n+      pp_cxx_identifier (cxx_pp, \"reinterpret_cast\");\n       goto cast;\n     case CONST_CAST_EXPR:\n-      pp_string (cxx_pp, \"const_cast<\");\n+      pp_cxx_identifier (cxx_pp, \"const_cast\");\n       goto cast;\n     case DYNAMIC_CAST_EXPR:\n-      pp_string (cxx_pp, \"dynamic_cast<\");\n+      pp_cxx_identifier (cxx_pp, \"dynamic_cast\");\n     cast:\n+      pp_cxx_begin_template_argument_list (cxx_pp);\n       dump_type (TREE_TYPE (t), flags);\n-      pp_string (cxx_pp, \">(\");\n+      pp_cxx_end_template_argument_list (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case ARROW_EXPR:\n       dump_expr (TREE_OPERAND (t, 0), flags);\n-      pp_arrow (cxx_pp);\n+      pp_cxx_arrow (cxx_pp);\n       break;\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n-\tpp_string (cxx_pp, \"sizeof (\");\n+        pp_cxx_identifier (cxx_pp, \"sizeof\");\n       else\n \t{\n \t  my_friendly_assert (TREE_CODE (t) == ALIGNOF_EXPR, 0);\n-\t  pp_string (cxx_pp, \"__alignof__ (\");\n+\t  pp_cxx_identifier (cxx_pp, \"__alignof__\");\n \t}\n+      pp_cxx_whitespace (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n \tdump_type (TREE_OPERAND (t, 0), flags);\n       else\n         dump_expr (TREE_OPERAND (t, 0), flags);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_identifier (cxx_pp, operator_name_info[TREE_CODE (t)].name);\n-      pp_space (cxx_pp);\n+      pp_cxx_identifier (cxx_pp, operator_name_info[TREE_CODE (t)].name);\n+      pp_cxx_whitespace (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 0), flags);\n       break;\n \n@@ -1781,10 +1791,10 @@ dump_expr (tree t, int flags)\n \n     case PSEUDO_DTOR_EXPR:\n       dump_expr (TREE_OPERAND (t, 2), flags);\n-      pp_dot (cxx_pp);\n+      pp_cxx_dot (cxx_pp);\n       dump_type (TREE_OPERAND (t, 0), flags);\n-      pp_colon_colon (cxx_pp);\n-      pp_complement (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n+      pp_cxx_complement (cxx_pp);\n       dump_type (TREE_OPERAND (t, 1), flags);\n       break;\n \n@@ -1799,15 +1809,15 @@ dump_expr (tree t, int flags)\n       break;\n \n     case BIND_EXPR:\n-      pp_left_brace (cxx_pp);\n+      pp_cxx_left_brace (cxx_pp);\n       dump_expr (TREE_OPERAND (t, 1), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_right_brace (cxx_pp);\n+      pp_cxx_right_brace (cxx_pp);\n       break;\n \n     case LOOP_EXPR:\n       pp_string (cxx_pp, \"while (1) { \");\n       dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n-      pp_right_brace (cxx_pp);\n+      pp_cxx_right_brace (cxx_pp);\n       break;\n \n     case EXIT_EXPR:\n@@ -1822,8 +1832,8 @@ dump_expr (tree t, int flags)\n \n     case EMPTY_CLASS_EXPR:\n       dump_type (TREE_TYPE (t), flags);\n-      pp_left_paren (cxx_pp);\n-      pp_right_paren (cxx_pp);\n+      pp_cxx_left_paren (cxx_pp);\n+      pp_cxx_right_paren (cxx_pp);\n       break;\n \n     case NON_DEPENDENT_EXPR:\n@@ -1845,60 +1855,71 @@ dump_expr (tree t, int flags)\n static void\n dump_binary_op (const char *opstring, tree t, int flags)\n {\n-  pp_left_paren (cxx_pp);\n+  pp_cxx_left_paren (cxx_pp);\n   dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n-  pp_space (cxx_pp);\n+  pp_cxx_whitespace (cxx_pp);\n   if (opstring)\n-    pp_identifier (cxx_pp, opstring);\n+    pp_cxx_identifier (cxx_pp, opstring);\n   else\n     pp_identifier (cxx_pp, \"<unknown operator>\");\n-  pp_space (cxx_pp);\n+  pp_cxx_whitespace (cxx_pp);\n   dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n-  pp_right_paren (cxx_pp);\n+  pp_cxx_right_paren (cxx_pp);\n }\n \n static void\n dump_unary_op (const char *opstring, tree t, int flags)\n {\n   if (flags & TFF_EXPR_IN_PARENS)\n-    pp_left_paren (cxx_pp);\n-  pp_identifier (cxx_pp, opstring);\n+    pp_cxx_left_paren (cxx_pp);\n+  pp_cxx_identifier (cxx_pp, opstring);\n   dump_expr (TREE_OPERAND (t, 0), flags & ~TFF_EXPR_IN_PARENS);\n   if (flags & TFF_EXPR_IN_PARENS)\n-    pp_right_paren (cxx_pp);\n+    pp_cxx_right_paren (cxx_pp);\n }\n \n+static void\n+reinit_cxx_pp (void)\n+{\n+  pp_clear_output_area (cxx_pp);\n+  pp_base (cxx_pp)->padding = pp_none;\n+  pp_indentation (cxx_pp) = 0;\n+  pp_needs_newline (cxx_pp) = false;\n+  cxx_pp->enclosing_scope = 0;\n+}\n+\n+\n /* Exported interface to stringifying types, exprs and decls under TFF_*\n    control.  */\n \n const char *\n type_as_string (tree typ, int flags)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_type (typ, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n const char *\n expr_as_string (tree decl, int flags)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_expr (decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n const char *\n decl_as_string (tree decl, int flags)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_decl (decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n const char *\n context_as_string (tree context, int flags)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_scope (context, flags);\n   return pp_formatted_text (cxx_pp);\n }\n@@ -1911,11 +1932,11 @@ lang_decl_name (tree decl, int v)\n   if (v >= 2)\n     return decl_as_string (decl, TFF_DECL_SPECIFIERS);\n \n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   if (v == 1 && DECL_CLASS_SCOPE_P (decl))\n     {\n       dump_type (CP_DECL_CONTEXT (decl), TFF_PLAIN_IDENTIFIER);\n-      pp_colon_colon (cxx_pp);\n+      pp_cxx_colon_colon (cxx_pp);\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -1957,15 +1978,15 @@ decl_to_string (tree decl, int verbose)\n     flags |= TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE;\n   flags |= TFF_TEMPLATE_HEADER;\n \n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_decl (decl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n \n static const char *\n expr_to_string (tree decl)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_expr (decl, 0);\n   return pp_formatted_text (cxx_pp);\n }\n@@ -1978,7 +1999,7 @@ fndecl_to_string (tree fndecl, int verbose)\n   flags = TFF_EXCEPTION_SPECIFICATION | TFF_DECL_SPECIFIERS;\n   if (verbose)\n     flags |= TFF_FUNCTION_DEFAULT_ARGUMENTS;\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_decl (fndecl, flags);\n   return pp_formatted_text (cxx_pp);\n }\n@@ -2015,7 +2036,7 @@ language_to_string (enum languages c)\n static const char *\n parm_to_string (int p)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   if (p < 0)\n     pp_string (cxx_pp, \"'this'\");\n   else\n@@ -2038,7 +2059,7 @@ type_to_string (tree typ, int verbose)\n     flags |= TFF_CLASS_KEY_OR_ENUM;\n   flags |= TFF_TEMPLATE_HEADER;\n \n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   dump_type (typ, flags);\n   return pp_formatted_text (cxx_pp);\n }\n@@ -2063,11 +2084,11 @@ args_to_string (tree p, int verbose)\n   if (TYPE_P (TREE_VALUE (p)))\n     return type_as_string (p, flags);\n \n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   for (; p; p = TREE_CHAIN (p))\n     {\n       if (TREE_VALUE (p) == null_node)\n-\tpp_identifier (cxx_pp, \"NULL\");\n+\tpp_cxx_identifier (cxx_pp, \"NULL\");\n       else\n \tdump_type (error_type (TREE_VALUE (p)), flags);\n       if (TREE_CHAIN (p))\n@@ -2079,7 +2100,7 @@ args_to_string (tree p, int verbose)\n static const char *\n cv_to_string (tree p, int v)\n {\n-  pp_clear_output_area (cxx_pp);\n+  reinit_cxx_pp ();\n   pp_base (cxx_pp)->padding = v ? pp_before : pp_none;\n   pp_cxx_cv_qualifier_seq (cxx_pp, p);\n   return pp_formatted_text (cxx_pp);\n@@ -2289,16 +2310,6 @@ cp_printer (pretty_printer *pp, text_info *text)\n #undef next_int\n }\n \n-static void\n-pp_non_consecutive_character (cxx_pretty_printer *pp, int c)\n-{\n-  const char *p = pp_last_position_in_text (pp);\n-\n-  if (p != NULL && *p == c)\n-    pp_space (pp);\n-  pp_character (pp, c);\n-}\n-\n /* These are temporary wrapper functions which handle the historic\n    behavior of cp_*_at.  */\n "}]}