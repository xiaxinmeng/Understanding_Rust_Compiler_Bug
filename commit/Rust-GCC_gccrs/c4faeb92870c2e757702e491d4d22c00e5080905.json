{"sha": "c4faeb92870c2e757702e491d4d22c00e5080905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRmYWViOTI4NzBjMmU3NTc3MDJlNDkxZDRkMjJjMDBlNTA4MDkwNQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-01-25T22:25:22Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-01-25T22:25:22Z"}, "message": "ChangeLog (2001-01-21): Fixed typo.\n\n2001-01-25  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* ChangeLog (2001-01-21): Fixed typo.\n\t* class.c (layout_class_method): Code accounting for WFLed\n\tmethod DECL_NAMEs deleted.\n\t* constant.c (find_methodref_index): Likewise.\n\t* decl.c (lang_mark_tree): Mark `wfl' field in struct lang_decl.\n\t* java-tree.h (DECL_FUNCTION_WFL): New macro.\n\t(struct lang_decl): New field `wfl'.\n\t(java_get_real_method_name): Prototype deleted.\n\t* mangle.c (mangle_method_decl): Code accounting for WFLed\n\tmethod DECL_NAMEs deleted.\n\t* parse.h (GET_METHOD_NAME): Macro deleted.\n\t* parse.y (reset_method_name): Deleted.\n\t(method_header): Set DECL_FUNCTION_WFL.\n\t(check_abstract_method_header): Code accounting for WFLed method\n\tDECL_NAMEs deleted.\n\t(java_get_real_method_name): Deleted.\n\t(check_method_redefinition): Code accounting for WFLed method\n\tDECL_NAMEs deleted. Use DECL_FUNCTION_WFL.\n\t(java_check_regular_methods): Likewise.\n\t(java_check_abstract_methods): Likewise.\n\t(java_expand_classes): Don't call `reset_method_name.'\n\t(search_applicable_method_list): Use DECL_NAMEs instead of\n\tGET_METHOD_NAME.\n\t* typeck.c (lookup_do): Code accounting for WFLed method\n\tDECL_NAMEs deleted.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-01/msg01954.html)\n\nFrom-SVN: r39274", "tree": {"sha": "0784ed59de14fb0bb1d22a8534203fe2bd586799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0784ed59de14fb0bb1d22a8534203fe2bd586799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4faeb92870c2e757702e491d4d22c00e5080905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4faeb92870c2e757702e491d4d22c00e5080905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4faeb92870c2e757702e491d4d22c00e5080905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4faeb92870c2e757702e491d4d22c00e5080905/comments", "author": null, "committer": null, "parents": [{"sha": "a8d1550a43a5d5ad6fbc6a07b36c654001b0ad84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d1550a43a5d5ad6fbc6a07b36c654001b0ad84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8d1550a43a5d5ad6fbc6a07b36c654001b0ad84"}], "stats": {"total": 175, "additions": 52, "deletions": 123}, "files": [{"sha": "0f279e64a55196654fb05d24015de88e0db84bbb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -1,3 +1,31 @@\n+2001-01-25  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* ChangeLog (2001-01-21): Fixed typo.\n+\t* class.c (layout_class_method): Code accounting for WFLed\n+\tmethod DECL_NAMEs deleted.\n+\t* constant.c (find_methodref_index): Likewise.\n+\t* decl.c (lang_mark_tree): Mark `wfl' field in struct lang_decl.\n+\t* java-tree.h (DECL_FUNCTION_WFL): New macro.\n+\t(struct lang_decl): New field `wfl'.\n+\t(java_get_real_method_name): Prototype deleted.\n+\t* mangle.c (mangle_method_decl): Code accounting for WFLed\n+\tmethod DECL_NAMEs deleted.\n+\t* parse.h (GET_METHOD_NAME): Macro deleted.\n+\t* parse.y (reset_method_name): Deleted.\n+\t(method_header): Set DECL_FUNCTION_WFL.\n+\t(check_abstract_method_header): Code accounting for WFLed method\n+\tDECL_NAMEs deleted.\n+\t(java_get_real_method_name): Deleted.\n+\t(check_method_redefinition): Code accounting for WFLed method\n+\tDECL_NAMEs deleted. Use DECL_FUNCTION_WFL.\n+\t(java_check_regular_methods): Likewise.\n+\t(java_check_abstract_methods): Likewise.\n+\t(java_expand_classes): Don't call `reset_method_name.'\n+\t(search_applicable_method_list): Use DECL_NAMEs instead of\n+\tGET_METHOD_NAME.\n+\t* typeck.c (lookup_do): Code accounting for WFLed method\n+\tDECL_NAMEs deleted.\n+\n 2001-01-25  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* lex.c (java_read_char): Check for EOF from getc first.\n@@ -101,7 +129,7 @@\n \n 2001-01-21  Per Bothner  <per@bothner.com>\n \n-\t* verify.c (merge_type_state):  Stil may have to merge even if\n+\t* verify.c (merge_type_state):  Still may have to merge even if\n \tLABEL_VERIFIED (label).\n \n 2001-01-21  Per Bothner  <per@bothner.com>"}, {"sha": "b0b47199983c3a8a43e47eb6428eb8d4384fe576", "filename": "gcc/java/class.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -1773,10 +1773,6 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n      tree this_class, super_class, method_decl, dtable_count;\n {\n   tree method_name = DECL_NAME (method_decl);\n-  int method_name_is_wfl = \n-    (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION);\n-  if (method_name_is_wfl)\n-    method_name = java_get_real_method_name (method_decl);\n \n   TREE_PUBLIC (method_decl) = 1;\n \n@@ -1799,10 +1795,6 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n \t  if (*ptr++ == '.')\n \t    p = ptr;\n \t}\n-      if (method_name_is_wfl)\n-\tEXPR_WFL_NODE (DECL_NAME (method_decl)) = get_identifier (p);\n-      else\n-\tDECL_NAME (method_decl) = get_identifier (p);\n       DECL_CONSTRUCTOR_P (method_decl) = 1;\n       build_java_argument_signature (TREE_TYPE (method_decl));\n     }"}, {"sha": "ee7be0b008dfbc89aa1a99f5b33502550a700ef6", "filename": "gcc/java/constants.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -202,8 +202,6 @@ find_methodref_index (cpool, decl)\n   tree name = DECL_CONSTRUCTOR_P (decl) ? init_identifier_node\n     : DECL_NAME (decl);\n   int name_type_index;\n-  if (TREE_CODE (name) == EXPR_WITH_FILE_LOCATION)\n-    name = EXPR_WFL_NODE (name);    \n   name_type_index = \n       find_name_and_type_constant (cpool, name, TREE_TYPE (decl));\n   return find_constant1 (cpool,"}, {"sha": "ae5339c7faf2e5e71719c4d2352714df9a81a2b7", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -1920,6 +1920,7 @@ lang_mark_tree (t)\n       if (ld)\n \t{\n \t  ggc_mark (ld);\n+\t  ggc_mark_tree (ld->wfl);\n \t  ggc_mark_tree (ld->throws_list);\n \t  ggc_mark_tree (ld->function_decl_body);\n \t  ggc_mark_tree (ld->called_constructor);"}, {"sha": "46e8f8a89a314b01fa26cdcbdbe6318e91bbdaf9", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -669,6 +669,8 @@ struct lang_identifier\n #define DECL_MAX_STACK(DECL) (DECL_LANG_SPECIFIC(DECL)->max_stack)\n /* Number of local variable slots needed for the arguments of this function. */\n #define DECL_ARG_SLOT_COUNT(DECL) (DECL_LANG_SPECIFIC(DECL)->arg_slot_count)\n+/* Information on declaration location */\n+#define DECL_FUNCTION_WFL(DECL)  (DECL_LANG_SPECIFIC(DECL)->wfl)\n /* List of checked thrown exceptions, as specified with the `throws'\n    keyword */\n #define DECL_FUNCTION_THROWS(DECL) (DECL_LANG_SPECIFIC(DECL)->throws_list)\n@@ -835,6 +837,7 @@ struct lang_decl\n   long localvariables_offset;\n   int arg_slots;\n   int max_locals, max_stack, arg_slot_count;\n+  tree wfl;\t\t\t/* Information on the original location */\n   tree throws_list;\t\t/* Exception specified by `throws' */\n   tree function_decl_body;\t/* Hold all function's statements */\n   tree called_constructor;\t/* When decl is a constructor, the\n@@ -1037,7 +1040,6 @@ extern char *print_int_node PARAMS ((tree));\n extern void parse_error_context PARAMS ((tree cl, const char *, ...))\n   ATTRIBUTE_PRINTF_2;\n extern tree build_primtype_type_ref PARAMS ((const char *));\n-extern tree java_get_real_method_name PARAMS ((tree));\n extern void finish_class PARAMS ((void));\n extern void java_layout_seen_class_methods PARAMS ((void));\n extern void check_for_initialization PARAMS ((tree));"}, {"sha": "e6ead9b5114af091e1acebf8a8840c7f1b79601f", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -152,11 +152,6 @@ mangle_method_decl (mdecl)\n   /* Mangle the name of the type that contains mdecl */\n   mangle_record_type (DECL_CONTEXT (mdecl), /* from_pointer = */ 0);\n \n-  /* Before working on the method name, get to it. It might be burried\n-     in a WFL. */\n-  if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)\n-    method_name = java_get_real_method_name (mdecl);\n-\n   /* Mangle the function name. There three cases\n        - mdecl is java.lang.Object.Object(), use `C2' for its name\n          (denotes a base object constructor.)"}, {"sha": "15e9852b767075cfd6098ff082787efe1cfac3c0", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -125,10 +125,6 @@ extern tree stabilize_reference PARAMS ((tree));\n #define GET_REAL_TYPE(TYPE) \t\t\t\t\t\\\n   (TREE_CODE (TYPE) == TREE_LIST ? TREE_PURPOSE (TYPE) : TYPE)\n \n-#define GET_METHOD_NAME(METHOD)\t\t\t\t\t\\\n-  (TREE_CODE (DECL_NAME (METHOD)) == EXPR_WITH_FILE_LOCATION ?\t\\\n-   EXPR_WFL_NODE (DECL_NAME (METHOD)) : DECL_NAME (METHOD))\n-\n /* Get TYPE name string, regardless whether TYPE is a class or an\n    array. */\n #define GET_TYPE_NAME(TYPE)\t\t\t\t\\"}, {"sha": "491dfb4bb7498ce94a555bfc1a8a9e6815be6e4c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 17, "deletions": 95, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -249,7 +249,6 @@ static tree create_artificial_method PARAMS ((tree, int, tree, tree, tree));\n static void start_artificial_method_body PARAMS ((tree));\n static void end_artificial_method_body PARAMS ((tree));\n static int check_method_redefinition PARAMS ((tree, tree));\n-static int reset_method_name PARAMS ((tree));\n static int check_method_types_complete PARAMS ((tree));\n static void java_check_regular_methods PARAMS ((tree));\n static void java_check_abstract_methods PARAMS ((tree));\n@@ -4513,6 +4512,9 @@ method_header (flags, type, mdecl, throws)\n       DECL_FUNCTION_THROWS (meth) = throws;\n     }\n \n+  if (TREE_TYPE (GET_CPC ()) != object_type_node)\n+    DECL_FUNCTION_WFL (meth) = id;\n+\n   /* Set the flag if we correctly processed a constructor */\n   if (constructor_ok)\n     {\n@@ -4715,15 +4717,13 @@ check_abstract_method_header (meth)\n      tree meth;\n {\n   int flags = get_access_flags_from_decl (meth);\n-  /* DECL_NAME might still be a WFL node */\n-  tree name = GET_METHOD_NAME (meth);\n \n   OBSOLETE_MODIFIER_WARNING2 (MODIFIER_WFL (ABSTRACT_TK), flags,\n \t\t\t      ACC_ABSTRACT, \"abstract method\",\n-\t\t\t      IDENTIFIER_POINTER (name));\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (meth)));\n   OBSOLETE_MODIFIER_WARNING2 (MODIFIER_WFL (PUBLIC_TK), flags, \n \t\t\t      ACC_PUBLIC, \"abstract method\",\n-\t\t\t      IDENTIFIER_POINTER (name));\n+\t\t\t      IDENTIFIER_POINTER (DECL_NAME (meth)));\n \n   check_modifiers (\"Illegal modifier `%s' for interface method\",\n \t\t  flags, INTERFACE_METHOD_MODIFIERS);\n@@ -5809,50 +5809,6 @@ get_printable_method_name (decl)\n   return to_return;\n }\n \n-/* Reinstall the proper DECL_NAME on METHOD. Return 0 if the method\n-   nevertheless needs to be verfied, 1 otherwise.  */\n-\n-static int\n-reset_method_name (method)\n-     tree method;\n-{\n-  if (!DECL_CLINIT_P (method) && !DECL_FINIT_P (method))\n-    {\n-      /* NAME is just the plain name when Object is being defined */\n-      if (DECL_CONTEXT (method) != object_type_node)\n-\tDECL_NAME (method) = (DECL_CONSTRUCTOR_P (method) ? \n-\t\t\t      init_identifier_node : GET_METHOD_NAME (method));\n-      return 0;\n-    }\n-  else \n-    return 1;\n-}\n-\n-/* Return the name of METHOD_DECL, when DECL_NAME is a WFL */\n-\n-tree\n-java_get_real_method_name (method_decl)\n-     tree method_decl;\n-{\n-  tree method_name = DECL_NAME (method_decl);\n-  if (DECL_CONSTRUCTOR_P (method_decl))\n-    return init_identifier_node;\n-\n-  /* Explain here why METHOD_DECL doesn't have the DECL_CONSTRUCTUR_P\n-     and still can be a constructor. FIXME */\n-\n-  /* Don't confuse method only bearing the name of their class as\n-     constructors */\n-  else if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (method_decl))\n-\t   && ctxp\n-\t   && GET_CPC_UN () == EXPR_WFL_NODE (method_name)\n-\t   && get_access_flags_from_decl (method_decl) <= ACC_PROTECTED\n-\t   && TREE_TYPE (TREE_TYPE (method_decl)) == void_type_node)\n-    return init_identifier_node;\n-  else\n-    return EXPR_WFL_NODE (method_name);\n-}\n-\n /* Track method being redefined inside the same class. As a side\n    effect, set DECL_NAME to an IDENTIFIER (prior entering this\n    function it's a FWL, so we can track errors more accurately.)  */\n@@ -5861,28 +5817,23 @@ static int\n check_method_redefinition (class, method)\n      tree class, method;\n {\n-  tree redef, name;\n-  tree cl = DECL_NAME (method);\n-  tree sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n-  /* decl name of artificial <clinit> and finit$ doesn't need to be\n-     fixed and checked */\n+  tree redef, sig;\n \n-  /* Reset the method name before running the check. If it returns 1,\n-     the method doesn't need to be verified with respect to method\n-     redeclaration and we return 0 */\n-  if (reset_method_name (method))\n+  /* There's no need to verify <clinit> and finit$ */\n+  if (DECL_CLINIT_P (method) || DECL_FINIT_P (method))\n     return 0;\n \n-  name = DECL_NAME (method);\n+  sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n   for (redef = TYPE_METHODS (class); redef; redef = TREE_CHAIN (redef))\n     {\n       if (redef == method)\n \tbreak;\n-      if (DECL_NAME (redef) == name \n-\t  && sig == TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (redef)))\n+      if (DECL_NAME (redef) == DECL_NAME (method)\n+\t  && sig == TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (redef))\n+\t  && !DECL_ARTIFICIAL (method))\n \t{\n \t  parse_error_context \n-\t    (cl, \"Duplicate %s declaration `%s'\",\n+\t    (DECL_FUNCTION_WFL (method), \"Duplicate %s declaration `%s'\",\n \t     (DECL_CONSTRUCTOR_P (redef) ? \"constructor\" : \"method\"),\n \t     get_printable_method_name (redef));\n \t  return 1;\n@@ -6078,7 +6029,7 @@ java_check_regular_methods (class_decl)\n   int saw_constructor = ANONYMOUS_CLASS_P (TREE_TYPE (class_decl));\n   tree method;\n   tree class = CLASS_TO_HANDLE_TYPE (TREE_TYPE (class_decl));\n-  tree saved_found_wfl = NULL_TREE, found = NULL_TREE;\n+  tree found = NULL_TREE;\n   tree mthrows;\n \n   /* It is not necessary to check methods defined in java.lang.Object */\n@@ -6092,17 +6043,9 @@ java_check_regular_methods (class_decl)\n   for (method = TYPE_METHODS (class); method; method = TREE_CHAIN (method))\n     {\n       tree sig;\n-      tree method_wfl = DECL_NAME (method);\n+      tree method_wfl = DECL_FUNCTION_WFL (method);\n       int aflags;\n \n-      /* If we previously found something and its name was saved,\n-         reinstall it now */\n-      if (found && saved_found_wfl)\n-\t{\n-\t  DECL_NAME (found) = saved_found_wfl;\n-\t  saved_found_wfl = NULL_TREE;\n-\t}\n-\n       /* Check for redefinitions */\n       if (check_method_redefinition (class, method))\n \tcontinue;\n@@ -6150,11 +6093,6 @@ java_check_regular_methods (class_decl)\n \t  continue;\n \t}\n \n-      /* If found wasn't verified, it's DECL_NAME won't be set properly. \n-\t We set it temporarily for the sake of the error report. */\n-      saved_found_wfl = DECL_NAME (found);\n-      reset_method_name (found);\n-\n       /* If `found' is declared in an interface, make sure the\n \t modifier matches. */\n       if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (found))) \n@@ -6245,13 +6183,6 @@ java_check_regular_methods (class_decl)\n       /* Inheriting multiple methods with the same signature. FIXME */\n     }\n   \n-  /* Don't forget eventual pending found and saved_found_wfl. Take\n-     into account that we might have exited because we saw an\n-     artificial method as the last entry. */\n-\n-  if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)\n-    DECL_NAME (found) = saved_found_wfl;\n-\n   if (!TYPE_NVIRTUALS (class))\n     TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n@@ -6311,8 +6242,6 @@ java_check_abstract_methods (interface_decl)\n \n   for (method = TYPE_METHODS (interface); method; method = TREE_CHAIN (method))\n     {\n-      tree method_wfl = DECL_NAME (method);\n-\n       /* 2- Check for double definition inside the defining interface */\n       if (check_method_redefinition (interface, method))\n \tcontinue;\n@@ -6323,17 +6252,14 @@ java_check_abstract_methods (interface_decl)\n       if (found)\n \t{\n \t  char *t;\n-\t  tree saved_found_wfl = DECL_NAME (found);\n-\t  reset_method_name (found);\n \t  t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n \t  parse_error_context \n-\t    (method_wfl,\n+\t    (DECL_FUNCTION_WFL (found),\n \t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n \t     lang_printable_name (found, 0), t,\n \t     IDENTIFIER_POINTER \n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t  free (t);\n-\t  DECL_NAME (found) = saved_found_wfl;\n \t  continue;\n \t}\n     }\n@@ -6357,8 +6283,6 @@ java_check_abstract_methods (interface_decl)\n \t\t\t\t\t\t sub_interface_method);\n \t  if (found && (found != sub_interface_method))\n \t    {\n-\t      tree saved_found_wfl = DECL_NAME (found);\n-\t      reset_method_name (found);\n \t      parse_error_context \n \t\t(lookup_cl (sub_interface_method),\n \t\t \"Interface `%s' inherits method `%s' from interface `%s'. This method is redefined with a different return type in interface `%s'\",\n@@ -6369,7 +6293,6 @@ java_check_abstract_methods (interface_decl)\n \t\t\t       (DECL_CONTEXT (sub_interface_method)))),\n \t\t IDENTIFIER_POINTER \n \t           (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n-\t      DECL_NAME (found) = saved_found_wfl;\n \t    }\n \t}\n     }\n@@ -8681,7 +8604,6 @@ java_expand_classes ()\n \t\t  if (DECL_CONSTRUCTOR_P (d))\n \t\t    {\n \t\t      restore_line_number_status (1);\n-\t\t      reset_method_name (d);\n \t\t      java_complete_expand_method (d);\n \t\t      restore_line_number_status (0);\n \t\t      break;\t/* We now there are no other ones */\n@@ -10605,7 +10527,7 @@ search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n       if (lc && !DECL_CONSTRUCTOR_P (method))\n \tcontinue;\n       else if (!lc && (DECL_CONSTRUCTOR_P (method) \n-\t\t       || (GET_METHOD_NAME (method) != name)))\n+\t\t       || (DECL_NAME (method) != name)))\n \tcontinue;\n \n       if (argument_types_convertible (method, arglist))"}, {"sha": "5ed5d53c9e1aa067c41d8eb0eb336c66cd16b58d", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4faeb92870c2e757702e491d4d22c00e5080905/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=c4faeb92870c2e757702e491d4d22c00e5080905", "patch": "@@ -812,11 +812,8 @@ lookup_do (searched_class, searched_interface, method_name, signature, signature\n               method != NULL_TREE;  method = TREE_CHAIN (method))\n            {\n              tree method_sig = (*signature_builder) (TREE_TYPE (method));\n-\t     tree name = DECL_NAME (method);\n \n-\t     if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n-\t\t  EXPR_WFL_NODE (name) : name) == method_name\n-\t\t && method_sig == signature)\n+\t     if (DECL_NAME (method) == method_name && method_sig == signature)\n                return method;\n            }\n \n@@ -839,9 +836,7 @@ lookup_do (searched_class, searched_interface, method_name, signature, signature\n \t  tree method_sig = (*signature_builder) (TREE_TYPE (method));\n \t  tree name = DECL_NAME (method);\n \n-\t  if ((TREE_CODE (name) == EXPR_WITH_FILE_LOCATION ?\n-\t       EXPR_WFL_NODE (name) : name) == method_name\n-\t      && method_sig == signature)\n+\t  if (DECL_NAME (method) == method_name && method_sig == signature)\n \t    return method;\n \t}\n       searched_class = CLASSTYPE_SUPER (searched_class);"}]}