{"sha": "71dbabccbfb295c87d91719fe72d9d60511c0b44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkYmFiY2NiZmIyOTVjODdkOTE3MTlmZTcyZDlkNjA1MTFjMGI0NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-12T14:17:10Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-12T14:17:10Z"}, "message": "Cleanup ipa-modref\n\nthis is largely mechanical patch fixing some suboptimal datastructure decision\nin modref.  It records three different things\n 1) optimization_summaries that are used by tree-ssa-alias to disambiguate\n    (computed by local passes or ipa execute)\n 2) summaries produced by local analysis and used by the ipa execute\n 3) summaries_lto produced by analysis when streaming is expected,\n    streamed, used by ipa execute\n\nAll three items are stored in \"summaries\" datastructure where 1 dn 2\nare mixed and differentiated by \"finished\" flags.\n\nThis use extra memory and also makes it impossible to use modref while producing\nother IPA summaries (by ipa-prop and ipa-devirt).  This patch separates the\nsummaries into three special purpose datastructures.\n\nThere is one fix to propagation in ipa_merge_modref_summary_after_inlining\nwhere check to ignore stores was placed incorrectly. This seems to lead\nto increased clobber disambiguations:\n\nAlias oracle query stats:\n  refs_may_alias_p: 64267006 disambiguations, 74475486 queries\n  ref_maybe_used_by_call_p: 142119 disambiguations, 65169365 queries\n  call_may_clobber_ref_p: 22975 disambiguations, 28762 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 36803 queries\n  nonoverlapping_refs_since_match_p: 19401 disambiguations, 55550 must overlaps, 75722 queries\n  aliasing_component_refs_p: 54714 disambiguations, 759027 queries\n  TBAA oracle: 23636760 disambiguations 56001742 queries\n               16112157 are in alias set 0\n               10614737 queries asked about the same object\n               125 queries asked about the same alias set\n               0 access volatile\n               3994423 are dependent in the DAG\n               1643540 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 11667 disambiguations, 40207 queries\n  modref clobber: 1508990 disambiguations, 1829697 queries\n  3916688 tbaa queries (2.140621 per modref query)\n  623504 base compares (0.340769 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 967354 disambiguations, 13605701 queries\n  pt_solutions_intersect: 1032982 disambiguations, 13121107 queries\n\nBootstrapped/regtested x86_64-linux. I plan to commit it tomorrow if there are\nno complains.\n\ngcc/ChangeLog:\n\n2020-10-11  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (modref_summaries): Remove field IPA.\n\t(class modref_summary_lto): New global variable.\n\t(class modref_summaries_lto): New.\n\t(modref_summary::modref_summary): Remove loads_lto and stores_lto.\n\t(modref_summary::~modref_summary): Remove loads_lto and stores_lto.\n\t(modref_summary::useful_p): Do not use lto_useful.\n\t(modref_records_lto): New typedef.\n\t(struct modref_summary_lto): New type.\n\t(modref_summary_lto::modref_summary_lto): New member function.\n\t(modref_summary_lto::~modref_summary_lto): New member function.\n\t(modref_summary_lto::useful_p): New member function.\n\t(modref_summary::dump): Do not handle lto.\n\t(modref_summary_lto::dump): New member function.\n\t(get_modref_function_summary): Use optimization_summary.\n\t(merge_call_side_effects): Use optimization_summary.\n\t(analyze_call): Use optimization_summary.\n\t(struct summary_ptrs): New struture.\n\t(analyze_load): Update to handle separate lto and non-lto summaries.\n\t(analyze_store): Likewise.\n\t(analyze_stmt): Likewise.\n\t(remove_summary): Break out from ...\n\t(analyze_function): ... here; update to handle seprated summaries.\n\t(modref_summaries::insert): Do not handle lto summary.\n\t(modref_summaries_lto::insert): New member function.\n\t(modref_summaries::duplicate): Do not handle lto summary.\n\t(modref_summaries_lto::duplicate): New member function.\n\t(read_modref_records): Expect nolto_ret or lto_ret to be NULL>\n\t(modref_write): Write lto summary.\n\t(read_section): Handle separated summaries.\n\t(modref_read): Initialize separated summaries.\n\t(modref_transform): Handle separated summaries.\n\t(pass_modref::execute): Turn summary to optimization_summary; handle\n\tseparate summaries.\n\t(ignore_edge): Handle separate summaries.\n\t(ipa_merge_modref_summary_after_inlining): Likewise.\n\t(collapse_loads): Likewise.\n\t(modref_propagate_in_scc): Likewise.\n\t(pass_ipa_modref::execute): Likewise.\n\t(ipa_modref_c_finalize): Likewise.\n\t* ipa-modref.h (modref_records_lto): Remove typedef.\n\t(struct modref_summary): Remove stores_lto, loads_lto and finished\n\tfields; remove lto_useful_p member function.", "tree": {"sha": "52fe05fe931eed416791970d44b424171b4113f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52fe05fe931eed416791970d44b424171b4113f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71dbabccbfb295c87d91719fe72d9d60511c0b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dbabccbfb295c87d91719fe72d9d60511c0b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71dbabccbfb295c87d91719fe72d9d60511c0b44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dbabccbfb295c87d91719fe72d9d60511c0b44/comments", "author": null, "committer": null, "parents": [{"sha": "f10f11eb63b0ed082674d9a589e67230aa49efb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f10f11eb63b0ed082674d9a589e67230aa49efb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f10f11eb63b0ed082674d9a589e67230aa49efb5"}], "stats": {"total": 785, "additions": 528, "deletions": 257}, "files": [{"sha": "1d4eaf8d7ade021676fd5036f7580b98f2d81f9c", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 528, "deletions": 248, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dbabccbfb295c87d91719fe72d9d60511c0b44/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dbabccbfb295c87d91719fe72d9d60511c0b44/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=71dbabccbfb295c87d91719fe72d9d60511c0b44", "patch": "@@ -73,26 +73,56 @@ class GTY((user)) modref_summaries\n \t\t\t  cgraph_node *dst_node,\n \t\t\t  modref_summary *src_data,\n \t\t\t  modref_summary *dst_data);\n-  /* This flag controls whether newly inserted functions should be analyzed\n-     in IPA or normal mode.  Functions inserted between IPA analysis and\n-     ipa-modref pass execution needs to be analyzed in IPA mode while all\n-     other insertions leads to normal analysis.  */\n-  bool ipa;\n   static modref_summaries *create_ggc (symbol_table *symtab)\n   {\n     return new (ggc_alloc_no_dtor<modref_summaries> ())\n \t     modref_summaries (symtab);\n   }\n };\n \n-/* Global variable holding all modref summaries.  */\n-static GTY(()) fast_function_summary <modref_summary *, va_gc> *summaries;\n+class modref_summary_lto;\n+\n+/* Class (from which there is one global instance) that holds modref summaries\n+   for all analyzed functions.  */\n+class GTY((user)) modref_summaries_lto\n+  : public fast_function_summary <modref_summary_lto *, va_gc>\n+{\n+public:\n+  modref_summaries_lto (symbol_table *symtab)\n+      : fast_function_summary <modref_summary_lto *, va_gc> (symtab),\n+\tpropagated (false) {}\n+  virtual void insert (cgraph_node *, modref_summary_lto *state);\n+  virtual void duplicate (cgraph_node *src_node,\n+\t\t\t  cgraph_node *dst_node,\n+\t\t\t  modref_summary_lto *src_data,\n+\t\t\t  modref_summary_lto *dst_data);\n+  static modref_summaries_lto *create_ggc (symbol_table *symtab)\n+  {\n+    return new (ggc_alloc_no_dtor<modref_summaries_lto> ())\n+\t     modref_summaries_lto (symtab);\n+  }\n+  bool propagated;\n+};\n+\n+/* Global variable holding all modref summaries\n+   (from analysis to IPA propagation time).  */\n+static GTY(()) fast_function_summary <modref_summary *, va_gc>\n+\t *summaries;\n+\n+/* Global variable holding all modref optimizaiton summaries\n+   (from IPA propagation time or used by local optimization pass).  */\n+static GTY(()) fast_function_summary <modref_summary *, va_gc>\n+\t *optimization_summaries;\n+\n+/* LTO summaries hold info from analysis to LTO streaming or from LTO\n+   stream-in through propagation to LTO stream-out.  */\n+static GTY(()) fast_function_summary <modref_summary_lto *, va_gc>\n+\t *summaries_lto;\n \n /* Summary for a single function which this pass produces.  */\n \n modref_summary::modref_summary ()\n-  : loads (NULL), stores (NULL), loads_lto (NULL),\n-    stores_lto (NULL), finished (0)\n+  : loads (NULL), stores (NULL)\n {\n }\n \n@@ -102,35 +132,63 @@ modref_summary::~modref_summary ()\n     ggc_delete (loads);\n   if (stores)\n     ggc_delete (stores);\n-  if (loads_lto)\n-    ggc_delete (loads_lto);\n-  if (stores_lto)\n-    ggc_delete (stores_lto);\n }\n \n-/* Return true if lto summary is potentially useful for optimization.  */\n+/* Return true if summary is potentially useful for optimization.  */\n \n bool\n-modref_summary::lto_useful_p (int ecf_flags)\n+modref_summary::useful_p (int ecf_flags)\n {\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n-  if (loads_lto && !loads_lto->every_base)\n+  if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n     return false;\n-  return stores_lto && !stores_lto->every_base;\n+  return stores && !stores->every_base;\n }\n \n-/* Return true if summary is potentially useful for optimization.  */\n+/* Single function summary used for LTO.  */\n+\n+typedef modref_tree <tree> modref_records_lto;\n+struct GTY(()) modref_summary_lto\n+{\n+  /* Load and stores in functions using types rather then alias sets.\n+\n+     This is necessary to make the information streamable for LTO but is also\n+     more verbose and thus more likely to hit the limits.  */\n+  modref_records_lto *loads;\n+  modref_records_lto *stores;\n+\n+  modref_summary_lto ();\n+  ~modref_summary_lto ();\n+  void dump (FILE *);\n+  bool useful_p (int ecf_flags);\n+};\n+\n+/* Summary for a single function which this pass produces.  */\n+\n+modref_summary_lto::modref_summary_lto ()\n+  : loads (NULL), stores (NULL)\n+{\n+}\n+\n+modref_summary_lto::~modref_summary_lto ()\n+{\n+  if (loads)\n+    ggc_delete (loads);\n+  if (stores)\n+    ggc_delete (stores);\n+}\n+\n+\n+/* Return true if lto summary is potentially useful for optimization.  */\n \n bool\n-modref_summary::useful_p (int ecf_flags)\n+modref_summary_lto::useful_p (int ecf_flags)\n {\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n-  if (lto_useful_p (ecf_flags))\n-    return true;\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n@@ -266,26 +324,32 @@ modref_summary::dump (FILE *out)\n       fprintf (out, \"  stores:\\n\");\n       dump_records (stores, out);\n     }\n-  if (loads_lto)\n+}\n+\n+/* Dump summary.  */\n+\n+void\n+modref_summary_lto::dump (FILE *out)\n+{\n+  if (loads)\n     {\n-      fprintf (out, \"  LTO loads:\\n\");\n-      dump_lto_records (loads_lto, out);\n+      fprintf (out, \"  loads:\\n\");\n+      dump_lto_records (loads, out);\n     }\n-  if (stores_lto)\n+  if (stores)\n     {\n-      fprintf (out, \"  LTO stores:\\n\");\n-      dump_lto_records (stores_lto, out);\n+      fprintf (out, \"  stores:\\n\");\n+      dump_lto_records (stores, out);\n     }\n }\n \n-\n /* Get function summary for FUNC if it exists, return NULL otherwise.  */\n \n modref_summary *\n get_modref_function_summary (cgraph_node *func)\n {\n   /* Avoid creation of the summary too early (e.g. when front-end calls us).  */\n-  if (!summaries)\n+  if (!optimization_summaries)\n     return NULL;\n \n   /* A single function body may be represented by multiple symbols with\n@@ -298,13 +362,8 @@ get_modref_function_summary (cgraph_node *func)\n   if (avail <= AVAIL_INTERPOSABLE)\n     return NULL;\n \n-  /* Attempt to get summary for FUNC.  If analysis of FUNC hasn't finished yet,\n-     don't return anything.  */\n-  modref_summary *r = summaries->get (func);\n-  if (r && r->finished)\n-    return r;\n-\n-  return NULL;\n+  modref_summary *r = optimization_summaries->get (func);\n+  return r;\n }\n \n /* Construct modref_access_node from REF.  */\n@@ -509,17 +568,11 @@ merge_call_side_effects (modref_summary *cur_summary,\n   /* Merge with callee's summary.  */\n   if (cur_summary->loads)\n     changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map);\n-  if (cur_summary->loads_lto)\n-    changed |= cur_summary->loads_lto->merge (callee_summary->loads_lto,\n-\t\t\t\t\t      &parm_map);\n   if (!ignore_stores)\n     {\n       if (cur_summary->stores)\n \tchanged |= cur_summary->stores->merge (callee_summary->stores,\n \t\t\t\t\t       &parm_map);\n-      if (cur_summary->stores_lto)\n-\tchanged |= cur_summary->stores_lto->merge (callee_summary->stores_lto,\n-\t\t\t\t\t\t   &parm_map);\n     }\n   return changed;\n }\n@@ -562,10 +615,7 @@ analyze_call (modref_summary *cur_summary,\n \t  if (dump_file)\n \t    fprintf (dump_file, \" - Indirect call which does not write memory, \"\n \t\t    \"discarding loads.\\n\");\n-\t  if (cur_summary->loads)\n-\t    cur_summary->loads->collapse ();\n-\t  if (cur_summary->loads_lto)\n-\t    cur_summary->loads_lto->collapse ();\n+\t  cur_summary->loads->collapse ();\n \t  return true;\n \t}\n       if (dump_file)\n@@ -583,10 +633,7 @@ analyze_call (modref_summary *cur_summary,\n     {\n       if (dump_file)\n \tfprintf (dump_file, \" - May be interposed: collapsing loads.\\n\");\n-      if (cur_summary->loads)\n-\tcur_summary->loads->collapse ();\n-      if (cur_summary->loads_lto)\n-\tcur_summary->loads_lto->collapse ();\n+      cur_summary->loads->collapse ();\n     }\n \n   /* If this is a recursive call, the target summary is the same as ours, so\n@@ -610,10 +657,7 @@ analyze_call (modref_summary *cur_summary,\n \t symbols.  */\n       if (ignore_stores)\n \t{\n-\t  if (cur_summary->loads)\n-\t    cur_summary->loads->collapse ();\n-\t  if (cur_summary->loads_lto)\n-\t    cur_summary->loads_lto->collapse ();\n+\t  cur_summary->loads->collapse ();\n \t  return true;\n \t}\n       if (dump_file)\n@@ -623,15 +667,13 @@ analyze_call (modref_summary *cur_summary,\n \n   /* Get callee's modref summary.  As above, if there's no summary, we either\n      have to give up or, if stores are ignored, we can just purge loads.  */\n-  modref_summary *callee_summary = summaries->get (callee_node);\n+  modref_summary *callee_summary = optimization_summaries->get (callee_node);\n   if (!callee_summary)\n     {\n       if (ignore_stores)\n \t{\n \t  if (cur_summary->loads)\n \t    cur_summary->loads->collapse ();\n-\t  if (cur_summary->loads_lto)\n-\t    cur_summary->loads_lto->collapse ();\n \t  return true;\n \t}\n       if (dump_file)\n@@ -644,12 +686,21 @@ analyze_call (modref_summary *cur_summary,\n   return true;\n }\n \n+/* Support analyzis in non-lto and lto mode in parallel.  */\n+\n+struct summary_ptrs\n+{\n+  struct modref_summary *nolto;\n+  struct modref_summary_lto *lto;\n+};\n+\n /* Helper for analyze_stmt.  */\n \n static bool\n analyze_load (gimple *, tree, tree op, void *data)\n {\n-  modref_summary *summary = (modref_summary *)data;\n+  modref_summary *summary = ((summary_ptrs *)data)->nolto;\n+  modref_summary_lto *summary_lto = ((summary_ptrs *)data)->lto;\n \n   if (dump_file)\n     {\n@@ -664,10 +715,10 @@ analyze_load (gimple *, tree, tree op, void *data)\n   ao_ref r;\n   ao_ref_init (&r, op);\n \n-  if (summary->loads)\n+  if (summary)\n     record_access (summary->loads, &r);\n-  if (summary->loads_lto)\n-    record_access_lto (summary->loads_lto, &r);\n+  if (summary_lto)\n+    record_access_lto (summary_lto->loads, &r);\n   return false;\n }\n \n@@ -676,7 +727,8 @@ analyze_load (gimple *, tree, tree op, void *data)\n static bool\n analyze_store (gimple *, tree, tree op, void *data)\n {\n-  modref_summary *summary = (modref_summary *)data;\n+  modref_summary *summary = ((summary_ptrs *)data)->nolto;\n+  modref_summary_lto *summary_lto = ((summary_ptrs *)data)->lto;\n \n   if (dump_file)\n     {\n@@ -691,19 +743,19 @@ analyze_store (gimple *, tree, tree op, void *data)\n   ao_ref r;\n   ao_ref_init (&r, op);\n \n-  if (summary->stores)\n-    record_access (((modref_summary *)data)->stores, &r);\n-  if (summary->stores_lto)\n-    record_access_lto (((modref_summary *)data)->stores_lto, &r);\n+  if (summary)\n+    record_access (summary->stores, &r);\n+  if (summary_lto)\n+    record_access_lto (summary_lto->stores, &r);\n   return false;\n }\n \n /* Analyze statement STMT of function F.\n    If IPA is true do not merge in side effects of calls.  */\n \n static bool\n-analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa,\n-\t      vec <gimple *> *recursive_calls)\n+analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n+\t      gimple *stmt, bool ipa, vec <gimple *> *recursive_calls)\n {\n   /* In general we can not ignore clobbers because they are barries for code\n      motion, however after inlining it is safe to do becuase local optimization\n@@ -712,8 +764,10 @@ analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa,\n   if ((ipa || cfun->after_inlining) && gimple_clobber_p (stmt))\n     return true;\n \n+  struct summary_ptrs sums = {summary, summary_lto};\n+\n   /* Analyze all loads and stores in STMT.  */\n-  walk_stmt_load_store_ops (stmt, summary,\n+  walk_stmt_load_store_ops (stmt, &sums,\n \t\t\t    analyze_load, analyze_store);\n \n   switch (gimple_code (stmt))\n@@ -737,8 +791,30 @@ analyze_stmt (modref_summary *summary, gimple *stmt, bool ipa,\n    }\n }\n \n-/* Analyze function F.  IPA indicates whether we're running in local mode (false)\n-   or the IPA mode (true).  */\n+/* Remove summary of current function because during the function body\n+   scan we determined it is not useful.  LTO, NOLTO and IPA determines the\n+   mode of scan.  */\n+\n+static void\n+remove_summary (bool lto, bool nolto, bool ipa)\n+{\n+  cgraph_node *fnode = cgraph_node::get (current_function_decl);\n+  if (!ipa)\n+    optimization_summaries->remove (fnode);\n+  else\n+    {\n+      if (nolto)\n+\tsummaries->remove (fnode);\n+      if (lto)\n+\tsummaries_lto->remove (fnode);\n+    }\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \" - modref done with result: not tracked.\\n\");\n+}\n+\n+/* Analyze function F.  IPA indicates whether we're running in local mode\n+   (false) or the IPA mode (true).  */\n \n static void\n analyze_function (function *f, bool ipa)\n@@ -753,32 +829,62 @@ analyze_function (function *f, bool ipa)\n   if (!flag_ipa_modref)\n     return;\n \n-  /* Initialize the summary.  */\n-  if (!summaries)\n-    summaries = modref_summaries::create_ggc (symtab);\n-  else /* Remove existing summary if we are re-running the pass.  */\n-    {\n-      if (dump_file && summaries->get (cgraph_node::get (f->decl)))\n-\t{\n-\t  fprintf (dump_file, \"Past summary:\\n\");\n-\t  summaries->get (cgraph_node::get (f->decl))->dump (dump_file);\n-\t}\n-      summaries->remove (cgraph_node::get (f->decl));\n-    }\n-\n-  ((modref_summaries *)summaries)->ipa = ipa;\n-\n-  modref_summary *summary = summaries->get_create (cgraph_node::get (f->decl));\n-\n   /* Compute no-LTO summaries when local optimization is going to happen.  */\n   bool nolto = (!ipa || ((!flag_lto || flag_fat_lto_objects) && !in_lto_p)\n \t\t|| (in_lto_p && !flag_wpa\n \t\t    && flag_incremental_link != INCREMENTAL_LINK_LTO));\n-\n   /* Compute LTO when LTO streaming is going to happen.  */\n   bool lto = ipa && ((flag_lto && !in_lto_p)\n \t\t     || flag_wpa\n \t\t     || flag_incremental_link == INCREMENTAL_LINK_LTO);\n+  cgraph_node *fnode = cgraph_node::get (current_function_decl);\n+\n+  modref_summary *summary = NULL;\n+  modref_summary_lto *summary_lto = NULL;\n+\n+  /* Initialize the summary.\n+     If we run in local mode there is possibly pre-existing summary from\n+     IPA pass.  Dump it so it is easy to compare if mod-ref info has\n+     improved.  */\n+  if (!ipa)\n+    {\n+      if (!optimization_summaries)\n+\toptimization_summaries = modref_summaries::create_ggc (symtab);\n+      else /* Remove existing summary if we are re-running the pass.  */\n+\t{\n+\t  if (dump_file\n+\t      && optimization_summaries->get (cgraph_node::get (f->decl)))\n+\t    {\n+\t      fprintf (dump_file, \"Past summary:\\n\");\n+\t      optimization_summaries->get\n+\t\t (cgraph_node::get (f->decl))->dump (dump_file);\n+\t    }\n+\t  optimization_summaries->remove (cgraph_node::get (f->decl));\n+\t}\n+      summary = optimization_summaries->get_create (cgraph_node::get (f->decl));\n+      gcc_checking_assert (nolto && !lto);\n+    }\n+  /* In IPA mode we analyze every function precisely once.  Asser that.  */\n+  else\n+    {\n+      if (nolto)\n+\t{\n+\t  if (!summaries)\n+\t    summaries = modref_summaries::create_ggc (symtab);\n+\t  else\n+\t    summaries->remove (cgraph_node::get (f->decl));\n+\t  summary = summaries->get_create (cgraph_node::get (f->decl));\n+\t}\n+      if (lto)\n+\t{\n+\t  if (!summaries_lto)\n+\t    summaries_lto = modref_summaries_lto::create_ggc (symtab);\n+\t  else\n+\t    summaries_lto->remove (cgraph_node::get (f->decl));\n+\t  summary_lto = summaries_lto->get_create (cgraph_node::get (f->decl));\n+\t}\n+     }\n+\n \n   /* Create and initialize summary for F.\n      Note that summaries may be already allocated from previous\n@@ -796,18 +902,17 @@ analyze_function (function *f, bool ipa)\n     }\n   if (lto)\n     {\n-      gcc_assert (!summary->loads_lto);\n-      summary->loads_lto = modref_records_lto::create_ggc\n+      gcc_assert (!summary_lto->loads);\n+      summary_lto->loads = modref_records_lto::create_ggc\n \t\t\t\t (param_modref_max_bases,\n \t\t\t\t  param_modref_max_refs,\n \t\t\t\t  param_modref_max_accesses);\n-      gcc_assert (!summary->stores_lto);\n-      summary->stores_lto = modref_records_lto::create_ggc\n+      gcc_assert (!summary_lto->stores);\n+      summary_lto->stores = modref_records_lto::create_ggc\n \t\t\t\t (param_modref_max_bases,\n \t\t\t\t  param_modref_max_refs,\n \t\t\t\t  param_modref_max_accesses);\n     }\n-  summary->finished = false;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n   auto_vec <gimple *, 32> recursive_calls;\n \n@@ -820,14 +925,12 @@ analyze_function (function *f, bool ipa)\n       gimple_stmt_iterator si;\n       for (si = gsi_after_labels (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n-\t  if (!analyze_stmt (summary, gsi_stmt (si), ipa, &recursive_calls)\n-\t      || !summary->useful_p (ecf_flags))\n+\t  if (!analyze_stmt (summary, summary_lto,\n+\t\t\t     gsi_stmt (si), ipa, &recursive_calls)\n+\t      || ((!summary || !summary->useful_p (ecf_flags))\n+\t\t  && (!summary_lto || !summary_lto->useful_p (ecf_flags))))\n \t    {\n-\t      cgraph_node *fnode = cgraph_node::get (current_function_decl);\n-\t      summaries->remove (fnode);\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \" - modref done with result: not tracked.\\n\");\n+\t      remove_summary (lto, nolto, ipa);\n \t      return;\n \t    }\n \t}\n@@ -850,24 +953,33 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t\t\t (recursive_calls[i])));\n \t      if (!summary->useful_p (ecf_flags))\n \t\t{\n-\t\t  cgraph_node *fnode = cgraph_node::get (current_function_decl);\n-\t\t  summaries->remove (fnode);\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \" - modref done with result: not tracked.\\n\");\n+\t\t  remove_summary (lto, nolto, ipa);\n \t\t  return;\n \t\t}\n \t    }\n \t}\n     }\n-\n-  if (!ipa)\n-    summary->finished = true;\n+  if (summary && !summary->useful_p (ecf_flags))\n+    {\n+      if (!ipa)\n+\toptimization_summaries->remove (fnode);\n+      else\n+\tsummaries->remove (fnode);\n+      summary = NULL;\n+    }\n+  if (summary_lto && !summary_lto->useful_p (ecf_flags))\n+    {\n+      summaries_lto->remove (fnode);\n+      summary_lto = NULL;\n+    }\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \" - modref done with result: tracked.\\n\");\n-      summary->dump (dump_file);\n+      if (summary)\n+\tsummary->dump (dump_file);\n+      if (summary_lto)\n+\tsummary_lto->dump (dump_file);\n     }\n }\n \n@@ -894,9 +1006,36 @@ void\n modref_summaries::insert (struct cgraph_node *node, modref_summary *)\n {\n   if (!DECL_STRUCT_FUNCTION (node->decl))\n-    return;\n+    {\n+      optimization_summaries->remove (node);\n+      summaries->remove (node);\n+    }\n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  /* This is not very pretty: We do not know if we insert into optimization\n+     summary or summary.  Do both but check for duplicated effort.  */\n+  if (optimization_summaries && !optimization_summaries->get (node)->loads)\n+    analyze_function (DECL_STRUCT_FUNCTION (node->decl), false);\n+  if (summaries && !summaries->get (node)->loads)\n+    analyze_function (DECL_STRUCT_FUNCTION (node->decl), true);\n+  pop_cfun ();\n+}\n+\n+/* Called when a new function is inserted to callgraph late.  */\n+\n+void\n+modref_summaries_lto::insert (struct cgraph_node *node, modref_summary_lto *)\n+{\n+  /* We do not support adding new function when IPA information is already\n+     propagated.  This is done only by SIMD cloning that is not very\n+     critical.  */\n+  if (!DECL_STRUCT_FUNCTION (node->decl)\n+      || propagated)\n+    {\n+      summaries_lto->remove (node);\n+      return;\n+    }\n   push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-  analyze_function (DECL_STRUCT_FUNCTION (node->decl), ipa);\n+  analyze_function (DECL_STRUCT_FUNCTION (node->decl), true);\n   pop_cfun ();\n }\n \n@@ -907,7 +1046,6 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t     modref_summary *src_data,\n \t\t\t     modref_summary *dst_data)\n {\n-  dst_data->finished = src_data->finished;\n   if (src_data->stores)\n     {\n       dst_data->stores = modref_records::create_ggc\n@@ -924,21 +1062,30 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *,\n \t\t\t     src_data->loads->max_accesses);\n       dst_data->loads->copy_from (src_data->loads);\n     }\n-  if (src_data->stores_lto)\n+}\n+\n+/* Called when new clone is inserted to callgraph late.  */\n+\n+void\n+modref_summaries_lto::duplicate (cgraph_node *, cgraph_node *,\n+\t\t\t\t modref_summary_lto *src_data,\n+\t\t\t\t modref_summary_lto *dst_data)\n+{\n+  if (src_data->stores)\n     {\n-      dst_data->stores_lto = modref_records_lto::create_ggc\n-\t\t\t    (src_data->stores_lto->max_bases,\n-\t\t\t     src_data->stores_lto->max_refs,\n-\t\t\t     src_data->stores_lto->max_accesses);\n-      dst_data->stores_lto->copy_from (src_data->stores_lto);\n+      dst_data->stores = modref_records_lto::create_ggc\n+\t\t\t    (src_data->stores->max_bases,\n+\t\t\t     src_data->stores->max_refs,\n+\t\t\t     src_data->stores->max_accesses);\n+      dst_data->stores->copy_from (src_data->stores);\n     }\n-  if (src_data->loads_lto)\n+  if (src_data->loads)\n     {\n-      dst_data->loads_lto = modref_records_lto::create_ggc\n-\t\t\t    (src_data->loads_lto->max_bases,\n-\t\t\t     src_data->loads_lto->max_refs,\n-\t\t\t     src_data->stores_lto->max_accesses);\n-      dst_data->loads_lto->copy_from (src_data->loads_lto);\n+      dst_data->loads = modref_records_lto::create_ggc\n+\t\t\t    (src_data->loads->max_bases,\n+\t\t\t     src_data->loads->max_refs,\n+\t\t\t     src_data->loads->max_accesses);\n+      dst_data->loads->copy_from (src_data->loads);\n     }\n }\n \n@@ -1038,24 +1185,23 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n   size_t max_refs = streamer_read_uhwi (ib);\n   size_t max_accesses = streamer_read_uhwi (ib);\n \n-  /* Decide whether we want to turn LTO data types to non-LTO (i.e. when\n-     LTO re-streaming is not going to happen).  */\n-  if (flag_wpa || flag_incremental_link == INCREMENTAL_LINK_LTO)\n+  if (lto_ret)\n     *lto_ret = modref_records_lto::create_ggc (max_bases, max_refs,\n \t\t\t\t\t       max_accesses);\n-  else\n+  if (nolto_ret)\n     *nolto_ret = modref_records::create_ggc (max_bases, max_refs,\n \t\t\t\t\t     max_accesses);\n+  gcc_checking_assert (lto_ret || nolto_ret);\n \n   size_t every_base = streamer_read_uhwi (ib);\n   size_t nbase = streamer_read_uhwi (ib);\n \n   gcc_assert (!every_base || nbase == 0);\n   if (every_base)\n     {\n-      if (*nolto_ret)\n+      if (nolto_ret)\n \t(*nolto_ret)->collapse ();\n-      if (*lto_ret)\n+      if (lto_ret)\n \t(*lto_ret)->collapse ();\n     }\n   for (size_t i = 0; i < nbase; i++)\n@@ -1079,11 +1225,11 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \t  base_tree = NULL;\n \t}\n \n-      if (*nolto_ret)\n+      if (nolto_ret)\n \tnolto_base_node = (*nolto_ret)->insert_base (base_tree\n \t\t\t\t\t\t     ? get_alias_set (base_tree)\n \t\t\t\t\t\t     : 0);\n-      if (*lto_ret)\n+      if (lto_ret)\n \tlto_base_node = (*lto_ret)->insert_base (base_tree);\n       size_t every_ref = streamer_read_uhwi (ib);\n       size_t nref = streamer_read_uhwi (ib);\n@@ -1159,9 +1305,9 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \t    }\n \t}\n     }\n-  if (*lto_ret)\n+  if (lto_ret)\n     (*lto_ret)->cleanup ();\n-  if (*nolto_ret)\n+  if (nolto_ret)\n     (*nolto_ret)->cleanup ();\n }\n \n@@ -1175,7 +1321,7 @@ modref_write ()\n   unsigned int count = 0;\n   int i;\n \n-  if (!summaries)\n+  if (!summaries_lto)\n     {\n       streamer_write_uhwi (ob, 0);\n       streamer_write_char_stream (ob->main_stream, 0);\n@@ -1188,11 +1334,11 @@ modref_write ()\n     {\n       symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n       cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n-      modref_summary *r;\n+      modref_summary_lto *r;\n \n       if (cnode && cnode->definition && !cnode->alias\n-\t  && (r = summaries->get (cnode))\n-\t  && r->lto_useful_p (flags_from_decl_or_type (cnode->decl)))\n+\t  && (r = summaries_lto->get (cnode))\n+\t  && r->useful_p (flags_from_decl_or_type (cnode->decl)))\n \tcount++;\n     }\n   streamer_write_uhwi (ob, count);\n@@ -1205,19 +1351,19 @@ modref_write ()\n       if (cnode && cnode->definition && !cnode->alias)\n \t{\n \n-\t  modref_summary *r = summaries->get (cnode);\n+\t  modref_summary_lto *r = summaries_lto->get (cnode);\n \n-\t  if (!r || !r->lto_useful_p (flags_from_decl_or_type (cnode->decl)))\n+\t  if (!r || !r->useful_p (flags_from_decl_or_type (cnode->decl)))\n \t    continue;\n \n \t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, cnode));\n \n-\t  streamer_write_uhwi (ob, r->loads_lto ? 1 : 0);\n-\t  streamer_write_uhwi (ob, r->stores_lto ? 1 : 0);\n-\t  if (r->loads_lto)\n-\t    write_modref_records (r->loads_lto, ob);\n-\t  if (r->stores_lto)\n-\t    write_modref_records (r->stores_lto, ob);\n+\t  streamer_write_uhwi (ob, r->loads ? 1 : 0);\n+\t  streamer_write_uhwi (ob, r->stores ? 1 : 0);\n+\t  if (r->loads)\n+\t    write_modref_records (r->loads, ob);\n+\t  if (r->stores)\n+\t    write_modref_records (r->stores, ob);\n \t}\n     }\n   streamer_write_char_stream (ob->main_stream, 0);\n@@ -1255,30 +1401,38 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n       node = dyn_cast <cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n \n-      modref_summary *modref_sum = summaries->get_create (node);\n-      modref_sum->finished = false;\n+      modref_summary *modref_sum = summaries\n+\t\t\t\t   ? summaries->get_create (node) : NULL;\n+      modref_summary_lto *modref_sum_lto = summaries_lto\n+\t\t\t\t\t   ? summaries_lto->get_create (node)\n+\t\t\t\t\t   : NULL;\n       int have_loads = streamer_read_uhwi (&ib);\n       int have_stores = streamer_read_uhwi (&ib);\n-      gcc_assert (!modref_sum->loads_lto\n-\t\t  && !modref_sum->stores_lto\n-\t\t  && !modref_sum->loads\n-\t\t  && !modref_sum->stores);\n+\n+      if (optimization_summaries)\n+\tmodref_sum = optimization_summaries->get_create (node);\n+\n+      gcc_assert (!modref_sum || (!modref_sum->loads\n+\t\t\t\t  && !modref_sum->stores));\n+      gcc_assert (!modref_sum_lto || (!modref_sum_lto->loads\n+\t\t\t\t      && !modref_sum_lto->stores));\n       if (have_loads)\n \t read_modref_records (&ib, data_in,\n-\t\t\t      &modref_sum->loads,\n-\t\t\t      &modref_sum->loads_lto);\n+\t\t\t      modref_sum ? &modref_sum->loads : NULL,\n+\t\t\t      modref_sum_lto ? &modref_sum_lto->loads : NULL);\n       if (have_stores)\n \t read_modref_records (&ib, data_in,\n-\t\t\t      &modref_sum->stores,\n-\t\t\t      &modref_sum->stores_lto);\n+\t\t\t      modref_sum ? &modref_sum->stores : NULL,\n+\t\t\t      modref_sum_lto ? &modref_sum_lto->stores : NULL);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Read modref for %s\\n\",\n \t\t   node->dump_name ());\n-\t  modref_sum->dump (dump_file);\n+\t  if (modref_sum)\n+\t    modref_sum->dump (dump_file);\n+\t  if (modref_sum_lto)\n+\t    modref_sum_lto->dump (dump_file);\n \t}\n-      if (flag_ltrans)\n-\tmodref_sum->finished = true;\n     }\n \n   lto_free_section_data (file_data, LTO_section_ipa_modref, NULL, data,\n@@ -1295,9 +1449,18 @@ modref_read (void)\n   struct lto_file_decl_data *file_data;\n   unsigned int j = 0;\n \n-  if (!summaries)\n-    summaries = modref_summaries::create_ggc (symtab);\n-  ((modref_summaries *)summaries)->ipa = !flag_ltrans;\n+  gcc_checking_assert (!optimization_summaries && !summaries && !summaries_lto);\n+  if (flag_ltrans)\n+    optimization_summaries = modref_summaries::create_ggc (symtab);\n+  else\n+    {\n+      if (flag_wpa || flag_incremental_link == INCREMENTAL_LINK_LTO)\n+\tsummaries_lto = modref_summaries_lto::create_ggc (symtab);\n+      if (!flag_wpa\n+\t  || (flag_incremental_link == INCREMENTAL_LINK_LTO\n+\t      && flag_fat_lto_objects))\n+\tsummaries = modref_summaries::create_ggc (symtab);\n+    }\n \n   while ((file_data = file_data_vec[j++]))\n     {\n@@ -1348,9 +1511,9 @@ remap_arguments (vec <int> *map, modref_records *tt)\n static unsigned int\n modref_transform (struct cgraph_node *node)\n {\n-  if (!node->clone.param_adjustments || !summaries)\n+  if (!node->clone.param_adjustments || !optimization_summaries)\n     return 0;\n-  modref_summary *r = summaries->get (node);\n+  modref_summary *r = optimization_summaries->get (node);\n   if (!r)\n     return 0;\n   if (dump_file)\n@@ -1436,7 +1599,7 @@ class pass_ipa_modref : public ipa_opt_pass_d\n unsigned int pass_modref::execute (function *f)\n {\n   /* If new function is being added during IPA, we can skip analysis.  */\n-  if (summaries && ((modref_summaries *)summaries)->ipa)\n+  if (!optimization_summaries)\n     return 0;\n   analyze_function (f, false);\n   return 0;\n@@ -1465,7 +1628,8 @@ ignore_edge (struct cgraph_edge *e)\n \t\t\t  (&avail, e->caller);\n \n   return (avail <= AVAIL_INTERPOSABLE\n-\t  || !summaries->get (callee)\n+\t  || ((!summaries || !summaries->get (callee))\n+\t      && (!summaries_lto || !summaries_lto->get (callee)))\n \t  || flags_from_decl_or_type (e->callee->decl)\n \t     & (ECF_CONST | ECF_NOVOPS));\n }\n@@ -1553,75 +1717,102 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n void\n ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n {\n-  if (!summaries)\n+  if (!summaries && !summaries_lto)\n     return;\n \n   struct cgraph_node *to = (edge->caller->inlined_to\n \t\t\t    ? edge->caller->inlined_to : edge->caller);\n-  class modref_summary *to_info = summaries->get (to);\n+  class modref_summary *to_info = summaries ? summaries->get (to) : NULL;\n+  class modref_summary_lto *to_info_lto = summaries_lto\n+\t\t\t\t\t  ? summaries_lto->get (to) : NULL;\n \n-  if (!to_info)\n-    return;\n+  if (!to_info && !to_info_lto)\n+    {\n+      if (summaries)\n+\tsummaries->remove (edge->callee);\n+      if (summaries_lto)\n+\tsummaries_lto->remove (edge->callee);\n+      return;\n+    }\n \n-  class modref_summary *callee_info = summaries->get (edge->callee);\n+  class modref_summary *callee_info = summaries ? summaries->get (edge->callee)\n+\t\t\t\t      : NULL;\n+  class modref_summary_lto *callee_info_lto\n+\t\t = summaries_lto ? summaries_lto->get (edge->callee) : NULL;\n   int flags = flags_from_decl_or_type (edge->callee->decl);\n \n-  if (!callee_info)\n+  if (!callee_info && to_info)\n     {\n       if (ignore_stores_p (edge->callee->decl, flags))\n+\tto_info->loads->collapse ();\n+      else\n \t{\n-\t  if (to_info->loads)\n-\t    to_info->loads->collapse ();\n-\t  if (to_info->loads_lto)\n-\t    to_info->loads_lto->collapse ();\n+\t  summaries->remove (to);\n+\t  to_info = NULL;\n \t}\n+    }\n+  if (!callee_info_lto && to_info_lto)\n+    {\n+      if (ignore_stores_p (edge->callee->decl, flags))\n+\tto_info_lto->loads->collapse ();\n       else\n \t{\n-\t  summaries->remove (to);\n-\t  summaries->remove (edge->callee);\n-\t  return;\n+\t  summaries_lto->remove (to);\n+\t  to_info_lto = NULL;\n \t}\n     }\n-  else\n+  if (callee_info || callee_info_lto)\n     {\n       auto_vec <modref_parm_map, 32> parm_map;\n \n       compute_parm_map (edge, &parm_map);\n \n       if (!ignore_stores_p (edge->callee->decl, flags))\n \t{\n-\t  if (to_info->loads)\n-\t    to_info->loads->merge (callee_info->loads, &parm_map);\n-\t  if (to_info->stores)\n+\t  if (to_info && callee_info)\n \t    to_info->stores->merge (callee_info->stores, &parm_map);\n+\t  if (to_info_lto && callee_info_lto)\n+\t    to_info_lto->stores->merge (callee_info_lto->stores, &parm_map);\n \t}\n-      if (to_info->loads_lto)\n-\tto_info->loads_lto->merge (callee_info->loads_lto, &parm_map);\n-      if (to_info->stores_lto)\n-\tto_info->stores_lto->merge (callee_info->stores_lto, &parm_map);\n-    }\n-  if (!to_info->useful_p (flags))\n-    summaries->remove (to);\n-  summaries->remove (edge->callee);\n+      if (to_info && callee_info)\n+\tto_info->loads->merge (callee_info->loads, &parm_map);\n+      if (to_info_lto && callee_info_lto)\n+\tto_info_lto->loads->merge (callee_info_lto->loads, &parm_map);\n+    }\n+  if (summaries)\n+    {\n+      if (to_info && !to_info->useful_p (flags))\n+\tsummaries->remove (to);\n+      if (callee_info)\n+\tsummaries->remove (edge->callee);\n+    }\n+  if (summaries_lto)\n+    {\n+      if (to_info_lto && !to_info_lto->useful_p (flags))\n+\tsummaries_lto->remove (to);\n+      if (callee_info_lto)\n+\tsummaries_lto->remove (edge->callee);\n+    }\n   return;\n }\n \n /* Collapse loads and return true if something changed.  */\n \n bool\n-collapse_loads (modref_summary *cur_summary)\n+collapse_loads (modref_summary *cur_summary,\n+\t\tmodref_summary_lto *cur_summary_lto)\n {\n   bool changed = false;\n \n-  if (cur_summary->loads && !cur_summary->loads->every_base)\n+  if (cur_summary && !cur_summary->loads->every_base)\n     {\n       cur_summary->loads->collapse ();\n       changed = true;\n     }\n-  if (cur_summary->loads_lto\n-      && !cur_summary->loads_lto->every_base)\n+  if (cur_summary_lto\n+      && !cur_summary_lto->loads->every_base)\n     {\n-      cur_summary->loads_lto->collapse ();\n+      cur_summary_lto->loads->collapse ();\n       changed = true;\n     }\n   return changed;\n@@ -1642,9 +1833,14 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n \t{\n \t  cgraph_node *node = cur->inlined_to ? cur->inlined_to : cur;\n-\t  modref_summary *cur_summary = summaries->get (node);\n-\n-\t  if (!cur_summary)\n+\t  modref_summary *cur_summary = optimization_summaries\n+\t\t\t\t\t? optimization_summaries->get (node)\n+\t\t\t\t\t: NULL;\n+\t  modref_summary_lto *cur_summary_lto = summaries_lto\n+\t\t\t\t\t\t? summaries_lto->get (node)\n+\t\t\t\t\t\t: NULL;\n+\n+\t  if (!cur_summary && !cur_summary_lto)\n \t    continue;\n \n \t  if (dump_file)\n@@ -1662,27 +1858,32 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"    Indirect call: \"\n \t\t\t     \"collapsing loads\\n\");\n-\t\t  changed |= collapse_loads (cur_summary);\n+\t\t  changed |= collapse_loads (cur_summary, cur_summary_lto);\n \t\t}\n \t      else\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"    Indirect call: giving up\\n\");\n-\t\t  summaries->remove (node);\n+\t\t  if (optimization_summaries)\n+\t\t    optimization_summaries->remove (node);\n+\t\t  if (summaries_lto)\n+\t\t    summaries_lto->remove (node);\n \t\t  changed = true;\n \t\t  cur_summary = NULL;\n+\t\t  cur_summary_lto = NULL;\n \t\t  break;\n \t\t}\n \t    }\n \n-\t  if (!cur_summary)\n+\t  if (!cur_summary && !cur_summary_lto)\n \t    continue;\n \n \t  for (cgraph_edge *callee_edge = cur->callees; callee_edge;\n \t       callee_edge = callee_edge->next_callee)\n \t    {\n \t      int flags = flags_from_decl_or_type (callee_edge->callee->decl);\n-\t      modref_summary *callee_summary;\n+\t      modref_summary *callee_summary = NULL;\n+\t      modref_summary_lto *callee_summary_lto = NULL;\n \t      struct cgraph_node *callee;\n \n \t      if (flags & (ECF_CONST | ECF_NOVOPS)\n@@ -1708,35 +1909,83 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \n \t      bool ignore_stores = ignore_stores_p (cur->decl, flags);\n \n-\t      /* We don't know anything about CALLEE, hence we cannot tell\n-\t\t anything about the entire component.  */\n-\n-\t      if (avail <= AVAIL_INTERPOSABLE\n-\t\t  || !(callee_summary = summaries->get (callee)))\n+\t      if (avail <= AVAIL_INTERPOSABLE)\n \t\t{\n \t\t  if (!ignore_stores)\n \t\t    {\n-\t\t      if (dump_file && avail <= AVAIL_INTERPOSABLE)\n+\t\t      if (dump_file)\n \t\t\tfprintf (dump_file, \"      Call target interposable\"\n \t\t\t\t \" or not available\\n\");\n-\t\t      else if (dump_file)\n-\t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n \n-\t\t      summaries->remove (node);\n+\t\t      if (optimization_summaries)\n+\t\t\toptimization_summaries->remove (node);\n+\t\t      if (summaries_lto)\n+\t\t\tsummaries_lto->remove (node);\n \t\t      changed = true;\n \t\t      break;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      if (dump_file && avail <= AVAIL_INTERPOSABLE)\n+\t\t      if (dump_file)\n \t\t\tfprintf (dump_file, \"      Call target interposable\"\n \t\t\t\t \" or not available; collapsing loads\\n\");\n-\t\t      else if (dump_file)\n+\n+\t\t      changed |= collapse_loads (cur_summary, cur_summary_lto);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n+\t      /* We don't know anything about CALLEE, hence we cannot tell\n+\t\t anything about the entire component.  */\n+\n+\t      if (cur_summary\n+\t\t  && !(callee_summary = optimization_summaries->get (callee)))\n+\t\t{\n+\t\t  if (!ignore_stores)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n+\n+\t\t      optimization_summaries->remove (node);\n+\t\t      cur_summary = NULL;\n+\t\t      changed = true;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (dump_file)\n \t\t\tfprintf (dump_file, \"      No call target summary;\"\n \t\t\t\t \" collapsing loads\\n\");\n \n-\t\t      changed |= collapse_loads (cur_summary);\n-\t\t      continue;\n+\t\t      if (!cur_summary->loads->every_base)\n+\t\t\t{\n+\t\t\t  cur_summary->loads->collapse ();\n+\t\t\t  changed = true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      if (cur_summary_lto\n+\t\t  && !(callee_summary_lto = summaries_lto->get (callee)))\n+\t\t{\n+\t\t  if (!ignore_stores)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"      No call target summary\\n\");\n+\n+\t\t      summaries_lto->remove (node);\n+\t\t      cur_summary_lto = NULL;\n+\t\t      changed = true;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"      No call target summary;\"\n+\t\t\t\t \" collapsing loads\\n\");\n+\n+\t\t      if (!cur_summary_lto->loads->every_base)\n+\t\t\t{\n+\t\t\t  cur_summary_lto->loads->collapse ();\n+\t\t\t  changed = true;\n+\t\t\t}\n \t\t    }\n \t\t}\n \n@@ -1746,7 +1995,7 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t the interposed variant.  */\n \t      if (!callee_edge->binds_to_current_def_p ())\n \t\t{\n-\t\t  changed |= collapse_loads (cur_summary);\n+\t\t  changed |= collapse_loads (cur_summary, cur_summary_lto);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"      May not bind local;\"\n \t\t\t     \" collapsing loads\\n\");\n@@ -1758,31 +2007,35 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      compute_parm_map (callee_edge, &parm_map);\n \n \t      /* Merge in callee's information.  */\n-\t      if (callee_summary->loads)\n-\t\tchanged |= cur_summary->loads->merge\n-\t\t\t\t(callee_summary->loads, &parm_map);\n-\t      if (callee_summary->stores)\n-\t\tchanged |= cur_summary->stores->merge\n-\t\t\t\t(callee_summary->stores, &parm_map);\n-\t      if (callee_summary->loads_lto)\n-\t\tchanged |= cur_summary->loads_lto->merge\n-\t\t\t\t(callee_summary->loads_lto, &parm_map);\n-\t      if (callee_summary->stores_lto)\n-\t\tchanged |= cur_summary->stores_lto->merge\n-\t\t\t\t(callee_summary->stores_lto, &parm_map);\n+\t      if (callee_summary)\n+\t\t{\n+\t\t  if (callee_summary->loads)\n+\t\t    changed |= cur_summary->loads->merge\n+\t\t\t\t    (callee_summary->loads, &parm_map);\n+\t\t  if (callee_summary->stores)\n+\t\t    changed |= cur_summary->stores->merge\n+\t\t\t\t    (callee_summary->stores, &parm_map);\n+\t\t}\n+\t      if (callee_summary_lto)\n+\t\t{\n+\t\t  if (callee_summary_lto->loads)\n+\t\t    changed |= cur_summary_lto->loads->merge\n+\t\t\t\t    (callee_summary_lto->loads, &parm_map);\n+\t\t  if (callee_summary_lto->stores)\n+\t\t    changed |= cur_summary_lto->stores->merge\n+\t\t\t\t    (callee_summary_lto->stores, &parm_map);\n+\t\t}\n \t      if (dump_file && changed)\n-\t\tcur_summary->dump (dump_file);\n+\t\t{\n+\t\t  if (cur_summary)\n+\t\t    cur_summary->dump (dump_file);\n+\t\t  if (cur_summary_lto)\n+\t\t    cur_summary_lto->dump (dump_file);\n+\t\t}\n \t    }\n \t}\n       iteration++;\n     }\n-  for (struct cgraph_node *cur = component_node; cur;\n-       cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n-    {\n-      modref_summary *cur_summary = summaries->get (cur);\n-      if (cur_summary)\n-\tcur_summary->finished = true;\n-    }\n   if (dump_file)\n     {\n       fprintf (dump_file,\n@@ -1791,16 +2044,31 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n \tif (!cur->inlined_to)\n \t  {\n-\t    modref_summary *cur_summary = summaries->get (cur);\n+\t    modref_summary *cur_summary = optimization_summaries\n+\t\t\t\t\t  ? optimization_summaries->get (cur)\n+\t\t\t\t\t  : NULL;\n+\t    modref_summary_lto *cur_summary_lto = summaries_lto\n+\t\t\t\t\t\t  ? summaries_lto->get (cur)\n+\t\t\t\t\t\t  : NULL;\n \n \t    fprintf (dump_file, \"Propagated modref for %s%s%s\\n\",\n \t\t     cur->dump_name (),\n \t\t     TREE_READONLY (cur->decl) ? \" (const)\" : \"\",\n \t\t     DECL_PURE_P (cur->decl) ? \" (pure)\" : \"\");\n-\t    if (cur_summary)\n-\t      cur_summary->dump (dump_file);\n-\t    else\n-\t      fprintf (dump_file, \"  Not tracked\\n\");\n+\t    if (optimization_summaries)\n+\t      {\n+\t\tif (cur_summary)\n+\t\t  cur_summary->dump (dump_file);\n+\t\telse\n+\t\t  fprintf (dump_file, \"  Not tracked\\n\");\n+\t      }\n+\t    if (summaries_lto)\n+\t      {\n+\t\tif (cur_summary_lto)\n+\t\t  cur_summary_lto->dump (dump_file);\n+\t\telse\n+\t\t  fprintf (dump_file, \"  Not tracked (lto)\\n\");\n+\t      }\n \t  }\n    }\n }\n@@ -1813,9 +2081,14 @@ modref_propagate_in_scc (cgraph_node *component_node)\n unsigned int\n pass_ipa_modref::execute (function *)\n {\n-  if (!summaries)\n+  if (!summaries && !summaries_lto)\n     return 0;\n \n+  if (optimization_summaries)\n+    ggc_delete (optimization_summaries);\n+  optimization_summaries = summaries;\n+  summaries = NULL;\n+\n   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *,\n \t\t\t\t\t symtab->cgraph_count);\n   int order_pos;\n@@ -1834,7 +2107,8 @@ pass_ipa_modref::execute (function *)\n \n       modref_propagate_in_scc (component_node);\n     }\n-  ((modref_summaries *)summaries)->ipa = false;\n+  if (summaries_lto)\n+    ((modref_summaries_lto *)summaries_lto)->propagated = true;\n   ipa_free_postorder_info ();\n   free (order);\n   return 0;\n@@ -1845,9 +2119,15 @@ pass_ipa_modref::execute (function *)\n void\n ipa_modref_c_finalize ()\n {\n-  if (summaries)\n-    ggc_delete (summaries);\n-  summaries = NULL;\n+  if (optimization_summaries)\n+    ggc_delete (optimization_summaries);\n+  optimization_summaries = NULL;\n+  gcc_checking_assert (!summaries);\n+  if (summaries_lto)\n+    {\n+      ggc_delete (summaries_lto);\n+      summaries_lto = NULL;\n+    }\n }\n \n #include \"gt-ipa-modref.h\""}, {"sha": "882810449511456966d718cc69cef6f635e1d1c7", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dbabccbfb295c87d91719fe72d9d60511c0b44/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dbabccbfb295c87d91719fe72d9d60511c0b44/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=71dbabccbfb295c87d91719fe72d9d60511c0b44", "patch": "@@ -21,7 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #define IPA_MODREF_H\n \n typedef modref_tree <alias_set_type> modref_records;\n-typedef modref_tree <tree> modref_records_lto;\n \n /* Single function summary.  */\n \n@@ -31,18 +30,10 @@ struct GTY(()) modref_summary\n   modref_records *loads;\n   modref_records *stores;\n \n-  /* The same but using tree types rather than alias sets.  This is necessary\n-     to make the information streamable for LTO but is also more verbose\n-     and thus more likely to hit the limits.  */\n-  modref_records_lto *loads_lto;\n-  modref_records_lto *stores_lto;\n-  bool finished;\n-\n   modref_summary ();\n   ~modref_summary ();\n   void dump (FILE *);\n   bool useful_p (int ecf_flags);\n-  bool lto_useful_p (int ecf_flags);\n };\n \n modref_summary *get_modref_function_summary (cgraph_node *func);"}]}