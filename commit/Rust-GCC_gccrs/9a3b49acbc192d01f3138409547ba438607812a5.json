{"sha": "9a3b49acbc192d01f3138409547ba438607812a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzYjQ5YWNiYzE5MmQwMWYzMTM4NDA5NTQ3YmE0Mzg2MDc4MTJhNQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-11-12T19:49:48Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-11-12T19:49:48Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13141", "tree": {"sha": "85cd8cd7131e818db5e41babcf683a757099ac52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85cd8cd7131e818db5e41babcf683a757099ac52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a3b49acbc192d01f3138409547ba438607812a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3b49acbc192d01f3138409547ba438607812a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a3b49acbc192d01f3138409547ba438607812a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a3b49acbc192d01f3138409547ba438607812a5/comments", "author": null, "committer": null, "parents": [{"sha": "3aad04640f70b2c9f75638e2c2143459df4461b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aad04640f70b2c9f75638e2c2143459df4461b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aad04640f70b2c9f75638e2c2143459df4461b7"}], "stats": {"total": 666, "additions": 399, "deletions": 267}, "files": [{"sha": "a5cd33947f20430a63f2ba0a6dc72e22022b75f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -1,3 +1,112 @@\n+Tue Nov 12 08:39:17 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+        * decl.c (cp_finish_decl): In MINIMAL_PARSE_MODE, only try to use\n+        the DECL_VINDEX of DECL if it's set.\n+\n+        * tree.c (mapcar): Handle RTL_EXPR.\n+\n+Mon Nov 11 13:57:31 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (current_template_args): New fn.\n+\t(push_template_decl): Use it.\n+\t* decl.c (grokdeclarator): Use it.\n+\n+\t* decl2.c (build_expr_from_tree): Dereference ref vars.\n+\n+\t* decl.c (grokdeclarator): Generalize handling of TYPENAME_TYPEs in\n+\tthe decl-specifier-seq.\n+\n+\t* decl.c (grok_op_properties): Don't force the type of a conversion\n+\top to be complete.  Don't warn about converting to the same type\n+\tfor template instantiations.\n+\n+\t* decl2.c (finish_file): Don't call instantiate_decl on synthesized\n+\tmethods.\n+\n+Mon Nov 11 13:20:34 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (get_delta_difference): Remove previous bogusness.\n+\tDon't give errors if force is set.\n+\n+Fri Nov  8 17:38:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (finish_file): Don't emit debug info.\n+\t* decl.c (start_function): Call note_debug_info_needed for context.\n+\t(start_decl): Likewise.\n+\t(cp_finish_decl): Not here.\n+\t(finish_function): Or here.\n+\t(pushdecl): Lose obsolete code.\n+\t(grokdeclarator): Still do the long long thing after complaining.\n+\t(finish_enum): Don't call rest_of_type_compilation\n+\tfor DWARF.\n+\t* class.c (finish_struct_1): Don't call rest_of_type_compilation\n+\tfor DWARF.\n+\t* search.c (dfs_debug_mark): For DWARF, just call\n+ \trest_of_type_compilation.\n+\t(note_debug_info_needed): Don't do anything if we're in a template.\n+\t* parse.y (named_complex_class_head_sans_basetype): Likewise.\n+\t* method.c (synthesize_method): For non-local classes,\n+ \tpush_to_top_level first.\n+\n+Fri Nov  8 11:52:28 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* typeck.c (get_delta_difference): Add no_error parameter.\n+\t(build_ptrmemfunc): Call get_delta_difference with no_error set;\n+ \twe don't want error messages when converting unrelated\n+ \tpointer-to-member functions.\n+\n+Thu Nov  7 11:16:24 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* error.c (dump_expr): Improve the wording on error messages that\n+\tinvolve pointer to member functions.\n+\n+Tue Nov  5 17:12:05 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Move code for conversions from\n+ \t(::*)() to void* or (*)() up a bit, so that we can convert from\n+\tMETHOD_TYPEs as well.\n+\n+Tue Nov  5 14:54:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (get_tinfo_fn): Make sure 'type' is permanent.\n+\tThere are no 'member' types.\n+\t(get_tinfo_fn_dynamic): Diagnose typeid of overloaded fn.\n+\t(build_x_typeid): Handle errors.\n+\n+Mon Nov  4 17:43:12 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (convert_for_assignment): Handle anachronistic implicit\n+\tconversions from (::*)() to void* or (*)().\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t(cp_convert_to_pointer_force): Remove cp_convert_to_pointer\n+\tconversions from here.\n+\t* decl2.c (lang_decode_option): Add -W{no-,}pmf-conversions.\n+\t* lang-options.h: Likewise.\n+\t* decl2.c (warn_pmf2ptr): Define.\n+\t* cp-tree.h: Declare it.\n+\t* typeck2.c (digest_init): Allow pmfs down into\n+\tconvert_for_initialization.\n+\n+Sun Nov  3 09:43:00 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (c_expand_return): Fix for returning overloaded fn.\n+\n+Fri Nov  1 08:53:17 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (DIRECT_BIND): Change from INDIRECT_BIND.\n+\t* decl.c (grok_reference_init): Pass DIRECT_BIND.\n+\t* cvt.c (build_up_reference): Don't mark 'this' addressable.  Use\n+ \tDIRECT_BIND.\n+\t* call.c (convert_like): Don't pass INDIRECT_BIND.\n+\t* typeck.c (convert_arguments): Likewise.\n+\t* typeck.c (mark_addressable): Allow &this if flag_this_is_variable.\n+\n+Thu Oct 31 17:08:49 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (mark_addressable): Support TARGET_EXPR, unify with\n+ \tsimilar code in build_up_ref.\n+\t* cvt.c (build_up_reference): Drastically simplify.\n+\n Mon Oct 28 12:45:05 1996  Jeffrey A Law  (law@cygnus.com)\n \n \t* typeck.c (signed_or_unsigned_type): If the given type already"}, {"sha": "576ed3a2e42662a9a8b77a7b831924ac01747806", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -4900,7 +4900,7 @@ convert_like (convs, expr)\n     case REF_BIND:\n       return convert_to_reference\n \t(TREE_TYPE (convs), expr,\n-\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION|INDIRECT_BIND,\n+\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION,\n \t error_mark_node);\n     case LVALUE_CONV:\n       return decay_conversion (expr);"}, {"sha": "356c9ca988d92e0749ab003b730f4bdef697ea8b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -873,7 +873,7 @@ modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n     }\n }\n \n-/* Access the virtual function table entry i.  VIRTUALS is the virtual\n+/* Access the virtual function table entry N.  VIRTUALS is the virtual\n    function table's initializer.  */\n \n static tree\n@@ -4188,7 +4188,10 @@ finish_struct_1 (t, warn_anon)\n \t For example, if a member function is seen and we decide to\n \t write out that member function, then we can change the value\n \t of the DECL_IGNORED_P slot, and the type will be output when\n-\t that member function's debug info is written out.  */\n+\t that member function's debug info is written out.\n+\n+\t We can't do this with DWARF, which does not support name\n+\t references between translation units.  */\n       if (CLASSTYPE_METHOD_VEC (t))\n \t{\n \t  extern tree pending_vtables;\n@@ -4209,10 +4212,10 @@ finish_struct_1 (t, warn_anon)\n \t}\n       else if (CLASSTYPE_INTERFACE_ONLY (t))\n \tTYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 1;\n-    }\n \n-  /* Finish debugging output for this type.  */\n-  rest_of_type_compilation (t, toplevel_bindings_p ());\n+      /* Finish debugging output for this type.  */\n+      rest_of_type_compilation (t, toplevel_bindings_p ());\n+    }\n \n   return t;\n }"}, {"sha": "f9f76a3393282b53f389cd5f3f1412affe11bcdb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -243,6 +243,11 @@ extern int warn_format;\n \n extern int warn_nonvdtor;\n \n+/* Non-zero means warn when we convert a pointer to member function\n+   into a pointer to (void or function).  */\n+\n+extern int warn_pmf2ptr;\n+\n /* Non-zero means warn when a function is declared extern and later inline.  */\n extern int warn_extern_inline;\n \n@@ -1845,9 +1850,9 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    LOOKUP_HAS_IN_CHARGE means that the \"in charge\" variable is already\n      in the parameter list.\n    LOOKUP_ONLYCONVERTING means that non-conversion constructors are not tried.\n-   INDIRECT_BIND means that if a temporary is created, it should be created so\n-     that it lives only as long as WITH_CLEANUP_EXPRs live, else if a temporary\n-     is created then it should live as long as the current variable bindings.\n+   DIRECT_BIND means that if a temporary is created, it should be created so\n+     that it lives as long as the current variable bindings; otherwise it\n+     only lives until the end of the complete-expression.\n    LOOKUP_SPECULATIVELY means return NULL_TREE if we cannot find what we are\n      after.  Note, LOOKUP_COMPLAIN is checked and error messages printed\n      before LOOKUP_SPECULATIVELY is checked.\n@@ -1865,7 +1870,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define LOOKUP_HAS_IN_CHARGE (32)\n #define LOOKUP_SPECULATIVELY (64)\n #define LOOKUP_ONLYCONVERTING (128)\n-#define INDIRECT_BIND (256)\n+#define DIRECT_BIND (256)\n #define LOOKUP_NO_CONVERSION (512)\n #define LOOKUP_DESTRUCTOR (512)\n #define LOOKUP_NO_TEMP_BIND (1024)\n@@ -2290,6 +2295,7 @@ extern void begin_template_parm_list\t\tPROTO((void));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n+extern tree current_template_args\t\tPROTO((void));\n extern void push_template_decl\t\t\tPROTO((tree));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));"}, {"sha": "68b3d6c2de88c7bc819a27eda176c649da1c944d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 66, "deletions": 158, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -154,6 +154,50 @@ cp_convert_to_pointer (type, expr)\n   if (TYPE_PTRMEMFUNC_P (intype))\n     intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n \n+  /* Handle anachronistic conversions from (::*)() to void* or (*)().  */\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n+\t  || TREE_TYPE (type) == void_type_node))\n+    {\n+      /* Allow an implicit this pointer for pointer to member\n+\t functions.  */\n+      if (TREE_CODE (intype) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (intype)) == METHOD_TYPE)\n+\t{\n+\t  tree decl, basebinfo;\n+\t  tree fntype = TREE_TYPE (intype);\n+\t  tree t = TYPE_METHOD_BASETYPE (fntype);\n+\n+\t  if (current_class_type == 0\n+\t      || get_base_distance (t, current_class_type, 0, &basebinfo)\n+\t      == -1)\n+\t    {\n+\t      decl = build1 (NOP_EXPR, t, error_mark_node);\n+\t    }\n+\t  else if (current_class_ptr == 0)\n+\t    decl = build1 (NOP_EXPR, t, error_mark_node);\n+\t  else\n+\t    decl = current_class_ref;\n+\n+\t  expr = build (OFFSET_REF, fntype, decl, expr);\n+\t}\n+\n+      if (TREE_CODE (expr) == OFFSET_REF\n+\t  && TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n+\texpr = resolve_offset_ref (expr);\n+      if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n+\texpr = build_addr_func (expr);\n+      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == METHOD_TYPE)\n+\t    if (pedantic || warn_pmf2ptr)\n+\t      cp_pedwarn (\"converting from `%T' to `%T'\", TREE_TYPE (expr),\n+\t\t\t  type);\n+\t  return build1 (NOP_EXPR, type, expr);\n+\t}\n+      intype = TREE_TYPE (expr);\n+    }\n+\n   form = TREE_CODE (intype);\n \n   if (form == POINTER_TYPE || form == REFERENCE_TYPE)\n@@ -282,44 +326,6 @@ convert_to_pointer_force (type, expr)\n       form = TREE_CODE (intype);\n     }\n \n-  if (TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    {\n-      /* Allow an implicit this pointer for pointer to member\n-         functions.  */\n-      if (TYPE_PTRMEMFUNC_P (intype))\n-\t{\n-\t  tree decl, basebinfo;\n-\t  tree fntype = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (intype));\n-\t  tree t = TYPE_METHOD_BASETYPE (fntype);\n-\n-\t  if (current_class_type == 0\n-\t      || get_base_distance (t, current_class_type, 0, &basebinfo) == -1)\n-\t    {\n-\t      decl = build1 (NOP_EXPR, t, error_mark_node);\n-\t    }\n-\t  else if (current_class_ptr == 0)\n-\t    decl = build1 (NOP_EXPR, t, error_mark_node);\n-\t  else\n-\t    decl = current_class_ref;\n-\n-\t  expr = build (OFFSET_REF, fntype, decl, expr);\n-\t  intype = TREE_TYPE (expr);\n-\t}\n-\n-      if (TREE_CODE (expr) == OFFSET_REF && TREE_CODE (intype) == METHOD_TYPE)\n-\texpr = resolve_offset_ref (expr);\n-      if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n-\texpr = build_addr_func (expr);\n-      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n-\t{\n-\t  if (pedantic\n-\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == METHOD_TYPE)\n-\t    cp_pedwarn (\"cannot convert `%T' to `%T'\", intype, type);\n-\t  return build1 (NOP_EXPR, type, expr);\n-\t}\n-    }\n-\n   if (form == POINTER_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n@@ -355,7 +361,6 @@ convert_to_pointer_force (type, expr)\n \t    }\n \t  return build_vbase_path (code, type, expr, path, 0);\n \t}\n-      return build1 (NOP_EXPR, type, expr);\n     }\n \n   return cp_convert_to_pointer (type, expr);\n@@ -366,7 +371,7 @@ convert_to_pointer_force (type, expr)\n    value we have to begin with is in ARG.\n \n    FLAGS controls how we manage access checking.\n-   INDIRECT_BIND in FLAGS controls how any temporarys are generated.\n+   DIRECT_BIND in FLAGS controls how any temporarys are generated.\n    CHECKCONST controls if we report error messages on const subversion.  */\n \n static tree\n@@ -512,72 +517,20 @@ build_up_reference (type, arg, flags, checkconst)\n \t but complain if we need a reference to something declared\n \t as `register'.  */\n \n-    case RESULT_DECL:\n-      if (staticp (targ))\n-\tliteral_flag = 1;\n-      TREE_ADDRESSABLE (targ) = 1;\n-      put_var_into_stack (targ);\n-      break;\n-\n     case PARM_DECL:\n-#if 0\n-      if (targ == current_class_ptr)\n-\t{\n-\t  error (\"address of `this' not available\");\n-/* #if 0 */\t  \n-\t  /* This code makes the following core dump the compiler on a sun4,\n-\t     if the code below is used.\n-\n-\t     class e_decl;\n-\t     class a_decl;\n-\t     typedef a_decl* a_ref;\n-\n-\t     class a_s {\n-\t     public:\n-\t       a_s();\n-\t       void* append(a_ref& item);\n-\t     };\n-\t     class a_decl {\n-\t     public:\n-\t       a_decl (e_decl *parent);\n-\t       a_s  generic_s;\n-\t       a_s  decls;\n-\t       e_decl* parent;\n-\t     };\n-\n-\t     class e_decl {\n-\t     public:\n-\t       e_decl();\n-\t       a_s implementations;\n-\t     };\n-\n-\t     void foobar(void *);\n-\n-\t     a_decl::a_decl(e_decl *parent) {\n-\t       parent->implementations.append(this);\n-\t     }\n-\t   */\n-\n-\t  TREE_ADDRESSABLE (targ) = 1; /* so compiler doesn't die later */\n-\t  put_var_into_stack (targ);\n-\t  break;\n-/* #else */\n-\t  return error_mark_node;\n-/* #endif */\t  \n-\t}\n-#endif\n-      /* Fall through.  */\n+      /* 'this' is not an lvalue.  */\n+      if (targ == current_class_ptr && ! flag_this_is_variable)\n+\tbreak;\n+\n+    case RESULT_DECL:\n     case VAR_DECL:\n     case CONST_DECL:\n-      if (DECL_REGISTER (targ) && !TREE_ADDRESSABLE (targ)\n-\t  && !DECL_ARTIFICIAL (targ))\n-\tcp_warning (\"address needed to build reference for `%D', which is declared `register'\",\n-\t\t    targ);\n-      else if (staticp (targ))\n+      if (staticp (targ))\n \tliteral_flag = 1;\n \n-      TREE_ADDRESSABLE (targ) = 1;\n-      put_var_into_stack (targ);\n+      /* Fall through.  */\n+    case TARGET_EXPR:\n+      mark_addressable (targ);\n       break;\n \n     case COMPOUND_EXPR:\n@@ -632,75 +585,30 @@ build_up_reference (type, arg, flags, checkconst)\n       TREE_REFERENCE_EXPR (rval) = 1;\n       return rval;\n \n-    case TARGET_EXPR:\n-      TREE_ADDRESSABLE (targ) = 1;\n-      put_var_into_stack (TREE_OPERAND (targ, 0));\n-      break;\n-\n     default:\n       break;\n     }\n \n-  if (TREE_ADDRESSABLE (targ) == 0)\n+  if ((flags&DIRECT_BIND)\n+      && ! real_lvalue_p (targ))\n     {\n-      if (! (flags&INDIRECT_BIND)\n-\t  && toplevel_bindings_p ())\n+      if (toplevel_bindings_p ())\n \t{\n-\t  tree temp = get_temp_name (argtype, 0);\n-\t  /* Give this new temp some rtl and initialize it.  */\n-\t  DECL_INITIAL (temp) = targ;\n-\t  TREE_STATIC (temp) = 1;\n-\t  cp_finish_decl (temp, targ, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n-\t  /* Do this after declaring it static.  */\n-\t  rval = build_unary_op (ADDR_EXPR, temp, 0);\n-\t  TREE_TYPE (rval) = type;\n-\t  literal_flag = TREE_CONSTANT (rval);\n-\t  goto done;\n-\t}\n-\n-      if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n-\t{\n-\t  arg = build_cplus_new (argtype, targ);\n-\t}\n-      else if (flags&INDIRECT_BIND)\n-\t{\n-\t  /* This should be the default, not the below code.  */\n-\t  /* All callers except grok_reference_init should probably\n-             use INDIRECT_BIND.  */\n-\t  tree slot = build (VAR_DECL, argtype);\n-\t  layout_decl (slot, 0);\n-\t  arg = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE, NULL_TREE);\n+\t  arg = get_temp_name (argtype, 1);\n+\t  literal_flag = 1;\n \t}\n       else\n \t{\n-\t  tree temp = get_temp_name (argtype, 0);\n-\t  rval = build_unary_op (ADDR_EXPR, temp, 0);\n-\t  if (binfo && !BINFO_OFFSET_ZEROP (binfo))\n-\t    rval = convert_pointer_to (target_type, rval);\n-\t  else\n-\t    TREE_TYPE (rval) = type;\n-\n-\t  temp = build (MODIFY_EXPR, argtype, temp, arg);\n-\t  TREE_SIDE_EFFECTS (temp) = 1;\n-\t  return build (COMPOUND_EXPR, type, temp, rval);\n+\t  arg = pushdecl (build_decl (VAR_DECL, NULL_TREE, argtype));\n+\t  DECL_ARTIFICIAL (arg) = 1;\n \t}\n+      DECL_INITIAL (arg) = targ;\n+      cp_finish_decl (arg, targ, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n-\n-  if (! (flags&INDIRECT_BIND))\n+  else if (TREE_ADDRESSABLE (targ) == 0 && !(flags&DIRECT_BIND))\n     {\n-      if (TREE_CODE (arg) == TARGET_EXPR)\n-\t{\n-\t  tree decl = TREE_OPERAND (arg, 0);\n-\t  tree cleanup;\n-\n-\t  if (! toplevel_bindings_p () && ! DECL_RTL (decl))\n-\t    {\n-\t      expand_decl (decl);\n-\t      cleanup = maybe_build_cleanup (decl);\n-\t      if (cleanup)\n-\t\texpand_decl_cleanup (decl, cleanup);\n-\t    }\n-\t}\n+      tree slot = build_decl (VAR_DECL, NULL_TREE, argtype);\n+      arg = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE, NULL_TREE);\n     }\n \n   rval = build1 (ADDR_EXPR, type, arg);"}, {"sha": "dbb2a903ed18c5cf03b44075cd197ce8d0232e50", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -3085,20 +3085,6 @@ pushdecl (x)\n               if (global_bindings_p ())\n                 TYPE_NAME (type) = x;\n \t    }\n-\t  else\n-\t    {\n-\t      tree tname = DECL_NAME (name);\n-\n-\t      /* This is a disgusting kludge for dealing with UPTs.  */\n-\t      if (global_bindings_p () && ANON_AGGRNAME_P (tname))\n-\t\t{\n-  \t\t  /* do gratuitous C++ typedefing, and make sure that\n-  \t\t     we access this type either through TREE_TYPE field\n-  \t\t     or via the tags list.  */\n-\t\t  TYPE_NAME (TREE_TYPE (x)) = x;\n-\t\t  pushtag (tname, TREE_TYPE (x), 0);\n-\t\t}\n-\t    }\n \t  my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 140);\n \n \t  if (type != error_mark_node\n@@ -5823,6 +5809,12 @@ start_decl (declarator, declspecs, initialized)\n \t  }\n       }\n \n+  /* Do this before the decl is actually defined so that the DWARF debug\n+     info for the class reflects the declaration, rather than the\n+     definition, of this decl.  */\n+  if (TREE_CODE (decl) == VAR_DECL && context)\n+    note_debug_info_needed (context);\n+\n   if (initialized)\n     {\n       if (! toplevel_bindings_p ()\n@@ -6085,7 +6077,8 @@ grok_reference_init (decl, type, init, cleanupp)\n     }\n \n   tmp = convert_to_reference\n-    (type, init, CONV_IMPLICIT, LOOKUP_SPECULATIVELY|LOOKUP_NORMAL, decl);\n+    (type, init, CONV_IMPLICIT,\n+     LOOKUP_SPECULATIVELY|LOOKUP_NORMAL|DIRECT_BIND, decl);\n \n   if (tmp == error_mark_node)\n     goto fail;\n@@ -6218,7 +6211,8 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n     {\n       if (init && DECL_INITIAL (decl))\n \tDECL_INITIAL (decl) = init;\n-      if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl))\n+      if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl)\n+\t  && DECL_VINDEX (decl))\n \t{\n \t  tree stmt = DECL_VINDEX (decl);\n \t  DECL_VINDEX (decl) = NULL_TREE;\n@@ -6466,10 +6460,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t/* Let debugger know it should output info for this type.  */\n \tnote_debug_info_needed (ttype);\n \n-      if (TREE_STATIC (decl) && DECL_CONTEXT (decl)\n-\t  && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')\n-\tnote_debug_info_needed (DECL_CONTEXT (decl));\n-\n       if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))\n \t  && DECL_SIZE (decl) != NULL_TREE\n \t  && ! TREE_CONSTANT (DECL_SIZE (decl)))\n@@ -7813,7 +7803,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t    {\n \t\t      if (pedantic && ! in_system_header)\n \t\t\tpedwarn (\"ANSI C++ does not support `long long'\");\n-\t\t      else if (longlong)\n+\t\t      if (longlong)\n \t\t\terror (\"`long long long' is too long for GCC\");\n \t\t      else\n \t\t\tlonglong = 1;\n@@ -7834,18 +7824,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  else\n \t    {\n \t      type = TREE_TYPE (id);\n-\t      if (TREE_CODE (type) == TYPENAME_TYPE\n-\t\t  && TYPE_CONTEXT (type) == current_class_type)\n-\t\t{\n-\t\t  /* Members of the current class get resolved immediately;\n-\t\t     we couldn't catch this one earlier because we hadn't\n-\t\t     pushed into the class yet.  */\n-\t\t  if (TREE_TYPE (type))\n-\t\t    type = TREE_TYPE (type);\n-\t\t  else\n-\t\t    type = make_typename_type (TYPE_CONTEXT (type),\n-\t\t\t\t\t       TYPE_IDENTIFIER (type));\n-\t\t}\n \t      TREE_VALUE (spec) = type;\n \t    }\n \t  goto found;\n@@ -8810,6 +8788,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      ;\n \t    else if (TREE_COMPLEXITY (declarator) == current_class_depth)\n \t      {\n+\t\t/* Resolve any TYPENAME_TYPEs from the decl-specifier-seq\n+\t\t   that refer to ctype.  They couldn't be resolved earlier\n+\t\t   because we hadn't pushed into the class yet.\n+\t\t   Example: resolve 'B<T>::type' in\n+\t\t   'B<typename B<T>::type> B<T>::f () { }'.  */\n+\t\tif (current_template_parms\n+\t\t    && uses_template_parms (type)\n+\t\t    && uses_template_parms (current_class_type))\n+\t\t  {\n+\t\t    tree args = current_template_args ();\n+\t\t    type = tsubst (type, &TREE_VEC_ELT (args, 0),\n+\t\t\t\t   TREE_VEC_LENGTH (args), NULL_TREE);\n+\t\t  }\n+\n \t\t/* This pop_nested_class corresponds to the\n                    push_nested_class used to push into class scope for\n                    parsing the argument list of a function decl, in\n@@ -8831,19 +8823,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \t    ctype = TREE_OPERAND (declarator, 0);\n \n-\t    if (TREE_CODE (ctype) == TYPENAME_TYPE\n-\t\t&& TYPE_CONTEXT (ctype) == current_class_type)\n-\t      {\n-\t\t/* Members of the current class get resolved immediately;\n-\t\t   we couldn't catch this one earlier because we hadn't\n-\t\t   pushed into the class yet.  */\n-\t\tif (TREE_TYPE (ctype))\n-\t\t  ctype = TREE_TYPE (ctype);\n-\t\telse\n-\t\t  ctype = make_typename_type (TYPE_CONTEXT (ctype),\n-\t\t\t\t\t      TYPE_IDENTIFIER (ctype));\n-\t      }\n-\n \t    if (sname == NULL_TREE)\n \t      goto done_scoping;\n \n@@ -10139,7 +10118,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t  || name == ansi_opname[(int) METHOD_CALL_EXPR])\n \treturn;\t\t\t/* no restrictions on args */\n \n-      if (IDENTIFIER_TYPENAME_P (name))\n+      if (IDENTIFIER_TYPENAME_P (name) && ! DECL_TEMPLATE_INFO (decl))\n \t{\n \t  tree t = TREE_TYPE (name);\n \t  if (TREE_CODE (t) == VOID_TYPE)\n@@ -10153,7 +10132,9 @@ grok_op_properties (decl, virtualp, friendp)\n \n \t      if (t == current_class_type)\n \t\twhat = \"the same type\";\n+\t      /* Don't force t to be complete here.  */\n \t      else if (IS_AGGR_TYPE (t)\n+\t\t       && TYPE_SIZE (t)\n \t\t       && DERIVED_FROM_P (t, current_class_type))\n \t\twhat = \"a base class\";\n \n@@ -10735,7 +10716,8 @@ finish_enum (enumtype, values)\n   }\n \n   /* Finish debugging output for this type.  */\n-  rest_of_type_compilation (enumtype, global_bindings_p ());\n+  if (write_symbols != DWARF_DEBUG)\n+    rest_of_type_compilation (enumtype, global_bindings_p ());\n \n   return enumtype;\n }\n@@ -11014,6 +10996,12 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t}\n     }\n \n+  /* Do this before the decl is actually defined so that the DWARF debug\n+     info for the class reflects the declaration, rather than the\n+     definition, of this decl.  */\n+  if (DECL_FUNCTION_MEMBER_P (decl1))\n+    note_debug_info_needed (DECL_CLASS_CONTEXT (decl1));\n+\n   /* Warn if function was previously implicitly declared\n      (but not if we warned then).  */\n   if (! warn_implicit\n@@ -12000,9 +11988,6 @@ finish_function (lineno, call_poplevel, nested)\n \t  mark_inline_for_output (fndecl);\n \t}\n \n-      if (ctype && TREE_ASM_WRITTEN (fndecl))\n-\tnote_debug_info_needed (ctype);\n-\n       current_function_returns_null |= can_reach_end;\n \n       /* Since we don't normally go through c_expand_return for constructors,"}, {"sha": "5055d20c6637831dd5118a1c1921bc90e56d570d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -42,7 +42,6 @@ extern tree cleanups_this_call;\n static void grok_function_init PROTO((tree, tree));\n void import_export_decl ();\n extern int current_class_depth;\n-extern int symout_time;\n \n /* A list of virtual function tables we must make sure to write out.  */\n tree pending_vtables;\n@@ -242,6 +241,10 @@ int warn_reorder;\n /* Non-zero means warn when synthesis behavior differs from Cfront's.  */\n int warn_synth;\n \n+/* Non-zero means warn when we convert a pointer to member function\n+   into a pointer to (void or function).  */\n+int warn_pmf2ptr = 1;\n+\n /* Nonzero means `$' can be in an identifier.\n    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */\n \n@@ -555,6 +558,8 @@ lang_decode_option (p)\n \twarn_reorder = setting;\n       else if (!strcmp (p, \"synth\"))\n \twarn_synth = setting;\n+      else if (!strcmp (p, \"pmf-conversions\"))\n+\twarn_pmf2ptr = setting;\n       else if (!strcmp (p, \"comment\"))\n \t;\t\t\t/* cpp handles this one.  */\n       else if (!strcmp (p, \"comments\"))\n@@ -2642,9 +2647,6 @@ extern int parse_time, varconst_time;\n extern tree pending_templates;\n extern tree maybe_templates;\n \n-#define TIMEVAR(VAR, BODY)    \\\n-do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)\n-\n extern struct obstack permanent_obstack;\n extern tree get_id_2 ();\n \n@@ -2711,7 +2713,8 @@ finish_file ()\n \t  instantiate_class_template (decl);\n \t  if (CLASSTYPE_TEMPLATE_INSTANTIATION (decl))\n \t    for (vars = TYPE_METHODS (decl); vars; vars = TREE_CHAIN (vars))\n-\t      instantiate_decl (vars);\n+\t      if (! DECL_ARTIFICIAL (vars))\n+\t\tinstantiate_decl (vars);\n \t}\n       else\n \tinstantiate_decl (decl);\n@@ -2768,13 +2771,6 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (vars);\n \n-#ifdef DWARF_DEBUGGING_INFO\n-\t/* Output DWARF information for file-scope tentative data object\n-\t   declarations.  */\n-\n-\tif (write_symbols == DWARF_DEBUG)\n-\t  TIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 1));\n-#endif\n       if (DECL_TEMPLATE_INSTANTIATION (decl)\n \t  && ! DECL_IN_AGGR_P (decl))\n \t{\n@@ -3430,6 +3426,9 @@ build_expr_from_tree (t)\n     case TYPEID_EXPR:\n       return build_x_typeid (build_expr_from_tree (TREE_OPERAND (t, 0)));\n \n+    case VAR_DECL:\n+      return convert_from_reference (t);\n+\n     default:\n       return t;\n     }"}, {"sha": "5adab9d21ff63a1587bb81a612329596bed3d4e5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -1262,6 +1262,44 @@ dump_expr (t, nop)\n       break;\n \n     case CONSTRUCTOR:\n+      if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n+\t{\n+\t  tree idx = build_component_ref (t, index_identifier, NULL_TREE, 0);\n+\n+\t  if (integer_all_onesp (idx))\n+\t    {\n+\t      tree pfn = PFN_FROM_PTRMEMFUNC (t);\n+\t      dump_expr (pfn);\n+\t      break;\n+\t    }\n+\t  if (TREE_CODE (idx) == INTEGER_CST\n+\t      && TREE_INT_CST_HIGH (idx) == 0)\n+\t    {\n+\t      tree virtuals;\n+\t      unsigned HOST_WIDE_INT n;\n+\n+\t      t = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n+\t      t = TYPE_METHOD_BASETYPE (t);\n+\t      virtuals = BINFO_VIRTUALS (TYPE_BINFO (TYPE_MAIN_VARIANT (t)));\n+\t      \n+\t      n = TREE_INT_CST_LOW (idx);\n+\n+\t      /* Map vtable index back one, to allow for the null pointer to\n+\t\t member.  */\n+\t      --n;\n+\n+\t      while (n > 0 && virtuals)\n+\t\t{\n+\t\t  --n;\n+\t\t  virtuals = TREE_CHAIN (virtuals);\n+\t\t}\n+\t      if (virtuals)\n+\t\t{\n+\t\t  dump_expr (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)));\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n       OB_PUTC ('{');\n       dump_expr_list (CONSTRUCTOR_ELTS (t));\n       OB_PUTC ('}');"}, {"sha": "1869aef0dbd6068044a15b43f5ec4efa992790fb", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -101,3 +101,5 @@ Boston, MA 02111-1307, USA.  */\n   \"-Wno-reorder\",\n   \"-Wsynth\",\n   \"-Wno-synth\",\n+  \"-Wpmf-conversions\",\n+  \"-Wno-pmf-conversions\","}, {"sha": "c7e3a87d68093ad351392baaf9c946906bf1e710", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -2116,7 +2116,9 @@ synthesize_method (fndecl)\n   tree context = hack_decl_function_context (fndecl);\n   tree base = DECL_CLASS_CONTEXT (fndecl);\n \n-  if (nested)\n+  if (! context)\n+    push_to_top_level ();\n+  else if (nested)\n     push_cp_function_context (context);\n \n   interface_unknown = 1;\n@@ -2156,6 +2158,8 @@ synthesize_method (fndecl)\n     }\n \n   extract_interface_info ();\n-  if (nested)\n+  if (! context)\n+    pop_from_top_level ();\n+  else if (nested)\n     pop_cp_function_context (context);\n }"}, {"sha": "cb80c8e566fbc23746f51bbff9dfe5a8ffefbdd0", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -2233,7 +2233,10 @@ named_complex_class_head_sans_basetype:\n \t\t{\n \t\t  current_aggr = $1;\n \t\t  if (TREE_CODE ($3) == TYPE_DECL)\n-\t\t    $$ = $3;\n+\t\t    {\n+\t\t      $$ = $3;\n+\t\t      note_debug_info_needed (DECL_CONTEXT ($$));\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      cp_error (\"`%T' does not have a nested type named `%D'\","}, {"sha": "46a8a149b178bb26ec46491b4ab534acbd1c98e1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -198,26 +198,13 @@ end_template_decl ()\n   (void) get_pending_sizes ();\t/* Why? */\n }\n \n-void\n-push_template_decl (decl)\n-     tree decl;\n+/* Generate a valid set of template args from current_template_parms.  */\n+\n+tree\n+current_template_args ()\n {\n   tree header = current_template_parms;\n-  tree tmpl;\n   tree args = NULL_TREE;\n-  tree info;\n-  tree ctx = DECL_CONTEXT (decl) ? DECL_CONTEXT (decl) : current_class_type;\n-  int primary = 0;\n-\n-  /* Kludge! */\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl)\n-      && DECL_CLASS_CONTEXT (decl))\n-    ;\n-  /* Note that this template is a \"primary template\" */\n-  else if (! ctx || ! CLASSTYPE_TEMPLATE_INFO (ctx)\n-      /* || (processing_template_decl > CLASSTYPE_TEMPLATE_LEVEL (ctx)) */)\n-    primary = 1;\n-\n   while (header)\n     {\n       tree a = copy_node (TREE_VALUE (header));\n@@ -236,8 +223,32 @@ push_template_decl (decl)\n       header = TREE_CHAIN (header);\n     }\n   args = nreverse (args);\n+\n+  /* FIXME Remove this when we support member templates.  */\n   args = TREE_VALUE (args);\n \n+  return args;\n+}\n+  \n+void\n+push_template_decl (decl)\n+     tree decl;\n+{\n+  tree tmpl;\n+  tree args = NULL_TREE;\n+  tree info;\n+  tree ctx = DECL_CONTEXT (decl) ? DECL_CONTEXT (decl) : current_class_type;\n+  int primary = 0;\n+\n+  /* Kludge! */\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl)\n+      && DECL_CLASS_CONTEXT (decl))\n+    ;\n+  /* Note that this template is a \"primary template\" */\n+  else if (! ctx || ! CLASSTYPE_TEMPLATE_INFO (ctx)\n+      /* || (processing_template_decl > CLASSTYPE_TEMPLATE_LEVEL (ctx)) */)\n+    primary = 1;\n+\n   /* Partial specialization.  */\n   if (TREE_CODE (decl) == TYPE_DECL\n       && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n@@ -262,6 +273,8 @@ push_template_decl (decl)\n       return;\n     }\n \n+  args = current_template_args ();\n+\n   if (! ctx || TYPE_BEING_DEFINED (ctx))\n     {\n       tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);"}, {"sha": "1ecccd84e80f3dcab6952235935ea84b77235f1a", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -175,6 +175,12 @@ get_tinfo_fn_dynamic (exp)\n   if (exp == error_mark_node)\n     return error_mark_node;\n \n+  if (type_unknown_p (exp))\n+    {\n+      error (\"typeid of overloaded function\");\n+      return error_mark_node;\n+    }\n+\n   type = TREE_TYPE (exp);\n \n   /* peel back references, so they match.  */\n@@ -244,6 +250,10 @@ build_x_typeid (exp)\n     }\n \n   exp = get_tinfo_fn_dynamic (exp);\n+\n+  if (exp == error_mark_node)\n+    return error_mark_node;\n+\n   exp = build_call (exp, type, NULL_TREE);\n \n   if (cond)\n@@ -316,9 +326,17 @@ tree\n get_tinfo_fn (type)\n      tree type;\n {\n-  tree name = build_overload_with_type (tinfo_fn_id, type);\n+  tree name;\n   tree d;\n \n+  if (TREE_CODE (type) == OFFSET_TYPE)\n+    type = TREE_TYPE (type);\n+  if (TREE_CODE (type) == METHOD_TYPE)\n+    type = build_function_type (TREE_TYPE (type),\n+\t\t\t\tTREE_CHAIN (TYPE_ARG_TYPES (type)));\n+\n+  name = build_overload_with_type (tinfo_fn_id, type);\n+\n   if (IDENTIFIER_GLOBAL_VALUE (name))\n     return IDENTIFIER_GLOBAL_VALUE (name);\n \n@@ -330,7 +348,7 @@ get_tinfo_fn (type)\n   DECL_ARTIFICIAL (d) = 1;\n   DECL_NOT_REALLY_EXTERN (d) = 1;\n   DECL_MUTABLE_P (d) = 1;\n-  TREE_TYPE (name) = type;\n+  TREE_TYPE (name) = copy_to_permanent (type);\n   pushdecl_top_level (d);\n   make_function_rtl (d);\n   assemble_external (d);"}, {"sha": "f2b2a50a0ef2da73fea98268b8395a3859dbf449", "filename": "gcc/cp/search.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -2539,9 +2539,20 @@ dfs_debug_mark (binfo)\n \n   CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n \n-  /* If interface info is known, the value of (?@@?) is correct.  */\n-  if (methods == 0\n-      || CLASSTYPE_INTERFACE_KNOWN (t)\n+  if (methods == 0)\n+    return;\n+\n+  /* We can't do the TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which\n+     does not support name references between translation units.  */\n+  if (write_symbols == DWARF_DEBUG)\n+    {\n+      rest_of_type_compilation (t, global_bindings_p ());\n+      return;\n+    }\n+\n+  /* If interface info is known, either we've already emitted the debug\n+     info or we don't need to.  */\n+  if (CLASSTYPE_INTERFACE_KNOWN (t)\n       || (write_virtuals == 2 && TYPE_VIRTUAL_P (t)))\n     return;\n \n@@ -3120,6 +3131,10 @@ note_debug_info_needed (type)\n      tree type;\n {\n   tree field;\n+\n+  if (current_template_parms)\n+    return;\n+\n   dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp);\n   for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n     {"}, {"sha": "c391d7af0217dedbbd08b0987f2b8c2b4ed36ffc", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -1592,6 +1592,16 @@ mapcar (t, func)\n       TREE_OPERAND (t, 0) = mapcar (TREE_OPERAND (t, 0), func);\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n       return t;\n+      break;\n+\n+    case RTL_EXPR:\n+      t = copy_node (t);\n+      if (RTL_EXPR_SEQUENCE (t))\n+\tRTL_EXPR_SEQUENCE (t) = copy_rtx (RTL_EXPR_SEQUENCE (t));\n+      if (RTL_EXPR_RTL (t))\n+\tRTL_EXPR_RTL (t) = copy_rtx (RTL_EXPR_RTL (t));\n+      return t;\n+      break;\n \n     case CONVERT_EXPR:\n     case ADDR_EXPR:"}, {"sha": "60c8f0031ec83016987d2df2b7734c84a3fd472f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -2822,9 +2822,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    }\n \t  else\n \t    {\n-\t      parmval = convert_for_initialization (return_loc, type, val,\n-\t\t\t\t\t\t    flags|INDIRECT_BIND,\n-\t\t\t\t\t\t    \"argument passing\", fndecl, i);\n+\t      parmval = convert_for_initialization\n+\t\t(return_loc, type, val, flags,\n+\t\t \"argument passing\", fndecl, i);\n #ifdef PROMOTE_PROTOTYPES\n \t      if ((TREE_CODE (type) == INTEGER_TYPE\n \t\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n@@ -4616,7 +4616,8 @@ mark_addressable (exp)\n       case PARM_DECL:\n \tif (x == current_class_ptr)\n \t  {\n-\t    error (\"address of `this' not available\");\n+\t    if (! flag_this_is_variable)\n+\t      error (\"address of `this' not available\");\n \t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later */\n \t    put_var_into_stack (x);\n \t    return 1;\n@@ -4649,8 +4650,10 @@ mark_addressable (exp)\n \n       case CONST_DECL:\n       case RESULT_DECL:\n-\t/* For C++, we don't warn about taking the address of a register\n-\t   variable for CONST_DECLs; ARM p97 explicitly says it's okay.  */\n+\tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n+\t    && !DECL_ARTIFICIAL (x) && extra_warnings)\n+\t  cp_warning (\"address requested for `%D', which is declared `register'\",\n+\t\t      x);\n \tput_var_into_stack (x);\n \tTREE_ADDRESSABLE (x) = 1;\n \treturn 1;\n@@ -4678,6 +4681,11 @@ mark_addressable (exp)\n \tTREE_ADDRESSABLE (x) = 1;\n \treturn 1;\n \n+      case TARGET_EXPR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\tmark_addressable (TREE_OPERAND (x, 0));\n+\treturn 1;\n+\n       default:\n \treturn 1;\n     }\n@@ -6082,7 +6090,7 @@ get_delta_difference (from, to, force)\n   binfo = get_binfo (from, to, 1);\n   if (binfo == error_mark_node)\n     {\n-      error (\"   in pointer to member function conversion\");\n+      error (\"   in pointer to member function conversiona\");\n       return delta;\n     }\n   if (binfo == 0)\n@@ -6096,12 +6104,14 @@ get_delta_difference (from, to, force)\n       binfo = get_binfo (to, from, 1);\n       if (binfo == error_mark_node)\n \t{\n-\t  error (\"   in pointer to member conversion\");\n+\t  if (!force)\n+\t    error (\"   in pointer to member conversion\");\n \t  return delta;\n \t}\n       if (binfo == 0)\n \t{\n-\t  cp_error (\"cannot convert pointer to member of type %T to unrelated pointer to member of type %T\", from, to);\n+\t  if (!force)\n+\t    cp_error (\"cannot convert pointer to member of type %T to unrelated pointer to member of type %T\", from, to);\n \t  return delta;\n \t}\n       if (TREE_VIA_VIRTUAL (binfo))\n@@ -6751,6 +6761,13 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     }\n   else if (TYPE_HAS_CONSTRUCTOR (type) || IS_AGGR_TYPE (TREE_TYPE (rhs)))\n     return convert (type, rhs);\n+  /* Handle anachronistic conversions from (::*)() to void* or (*)().  */\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n+\t       || TREE_TYPE (type) == void_type_node)\n+\t   && TREE_TYPE (rhs)\n+\t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n+    return convert (type, rhs);\n \n   cp_error (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n   return error_mark_node;\n@@ -7180,7 +7197,7 @@ c_expand_return (retval)\n   if (retval == result\n       || DECL_CONSTRUCTOR_P (current_function_decl))\n     /* It's already done for us.  */;\n-  else if (TYPE_MODE (TREE_TYPE (retval)) == VOIDmode)\n+  else if (TREE_TYPE (retval) == void_type_node)\n     {\n       pedwarn (\"return of void value in function returning non-void\");\n       expand_expr_stmt (retval);"}, {"sha": "1c0029744cec26a9d7375c77a3b934c839b7e6ea", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a3b49acbc192d01f3138409547ba438607812a5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9a3b49acbc192d01f3138409547ba438607812a5", "patch": "@@ -829,7 +829,9 @@ digest_init (type, init, tail)\n \t    }\n \t  init = element;\n \t}\n-      while (TREE_CODE (init) == CONSTRUCTOR)\n+      while (TREE_CODE (init) == CONSTRUCTOR\n+\t     && ! (TREE_TYPE (init)\n+\t\t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (init))))\n \t{\n \t  cp_pedwarn (\"braces around scalar initializer for `%T'\", type);\n \t  init = CONSTRUCTOR_ELTS (init);"}]}