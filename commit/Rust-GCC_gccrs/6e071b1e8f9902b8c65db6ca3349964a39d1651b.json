{"sha": "6e071b1e8f9902b8c65db6ca3349964a39d1651b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwNzFiMWU4Zjk5MDJiOGM2NWRiNmNhMzM0OTk2NGEzOWQxNjUxYg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-03-28T22:14:36Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-03-28T22:14:36Z"}, "message": "re PR target/60697 ([aarch64] LRA ICE (Segfault) while building 435.gromacs)\n\n2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/60697\n\t* lra-constraints.c (index_part_to_reg): New.\n\t(process_address): Use it.\n\n2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/60697\n\t* gcc.target/aarch64/pr60697.c: New.\n\nFrom-SVN: r208926", "tree": {"sha": "fdee9bbb1c36405dbb87776539318c3b64c8c6df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdee9bbb1c36405dbb87776539318c3b64c8c6df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e071b1e8f9902b8c65db6ca3349964a39d1651b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e071b1e8f9902b8c65db6ca3349964a39d1651b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e071b1e8f9902b8c65db6ca3349964a39d1651b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e071b1e8f9902b8c65db6ca3349964a39d1651b/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4bb66ef337cc5b0928b7e71ee38ffb82438a9087", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bb66ef337cc5b0928b7e71ee38ffb82438a9087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bb66ef337cc5b0928b7e71ee38ffb82438a9087"}], "stats": {"total": 677, "additions": 676, "deletions": 1}, "files": [{"sha": "d68adcf338e4a4b6ccf04a16f9cd1bb29baf264f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e071b1e8f9902b8c65db6ca3349964a39d1651b", "patch": "@@ -1,3 +1,9 @@\n+2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/60697\n+\t* lra-constraints.c (index_part_to_reg): New.\n+\t(process_address): Use it.\n+\n 2014-03-27  Jeff Law  <law@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "cfc3d7eaaee26d6cb1c7fe2839f1af17863ad78f", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=6e071b1e8f9902b8c65db6ca3349964a39d1651b", "patch": "@@ -2631,6 +2631,20 @@ base_plus_disp_to_reg (struct address_info *ad)\n   return new_reg;\n }\n \n+/* Make reload of index part of address AD.  Return the new\n+   pseudo.  */\n+static rtx\n+index_part_to_reg (struct address_info *ad)\n+{\n+  rtx new_reg;\n+\n+  new_reg = lra_create_new_reg (GET_MODE (*ad->index), NULL_RTX,\n+\t\t\t\tINDEX_REG_CLASS, \"index term\");\n+  expand_mult (GET_MODE (*ad->index), *ad->index_term,\n+\t       GEN_INT (get_index_scale (ad)), new_reg, 1);\n+  return new_reg;\n+}\n+\n /* Return true if we can add a displacement to address AD, even if that\n    makes the address invalid.  The fix-up code requires any new address\n    to be the sum of the BASE_TERM, INDEX and DISP_TERM fields.  */\n@@ -2935,14 +2949,26 @@ process_address (int nop, rtx *before, rtx *after)\n       emit_insn (insns);\n       *ad.inner = new_reg;\n     }\n-  else\n+  else if (ad.disp_term != NULL)\n     {\n       /* base + scale * index + disp => new base + scale * index,\n \t case (1) above.  */\n       new_reg = base_plus_disp_to_reg (&ad);\n       *ad.inner = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n \t\t\t\t       new_reg, *ad.index);\n     }\n+  else\n+    {\n+      /* base + scale * index => base + new_reg,\n+\t case (1) above.\n+      Index part of address may become invalid.  For example, we\n+      changed pseudo on the equivalent memory and a subreg of the\n+      pseudo onto the memory of different mode for which the scale is\n+      prohibitted.  */\n+      new_reg = index_part_to_reg (&ad);\n+      *ad.inner = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n+\t\t\t\t       *ad.base_term, new_reg);\n+    }\n   *before = get_insns ();\n   end_sequence ();\n   return true;"}, {"sha": "fa427966cf8a168cf9e6cc22ff47631b6e89ea9f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e071b1e8f9902b8c65db6ca3349964a39d1651b", "patch": "@@ -1,3 +1,8 @@\n+2014-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/60697\n+\t* gcc.target/aarch64/pr60697.c: New.\n+\n 2014-03-27  Jeff Law  <law@redhat.com>\n \n        PR target/60648"}, {"sha": "57ccecb1dadbae45af4720eb766bc98214fe3692", "filename": "gcc/testsuite/gcc.target/aarch64/pr60697.c", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr60697.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e071b1e8f9902b8c65db6ca3349964a39d1651b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr60697.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr60697.c?ref=6e071b1e8f9902b8c65db6ca3349964a39d1651b", "patch": "@@ -0,0 +1,638 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w -O3 -mcpu=cortex-a53\" } */\n+typedef struct __sFILE __FILE;\n+typedef __FILE FILE;\n+typedef int atom_id;\n+typedef float real;\n+typedef real rvec[3];\n+typedef real matrix[3][3];\n+enum {\n+  ebCGS,ebMOLS,ebSBLOCKS,ebNR\n+};\n+enum {\n+  efepNO, efepYES, efepNR\n+};\n+enum {\n+  esolNO, esolMNO, esolWATER, esolWATERWATER, esolNR\n+};\n+typedef struct {\n+  int nr;\n+  atom_id *index;\n+  atom_id *a;\n+} t_block;\n+enum {\n+  F_LJ,\n+  F_LJLR,\n+  F_SR,\n+  F_LR,\n+  F_DVDL,\n+};\n+typedef struct {\n+  t_block excl;\n+} t_atoms;\n+typedef struct {\n+  t_atoms atoms;\n+  t_block blocks[ebNR];\n+} t_topology;\n+typedef struct {\n+} t_nsborder;\n+extern FILE *debug;\n+typedef struct {\n+} t_nrnb;\n+typedef struct {\n+  int nri,maxnri;\n+  int nrj,maxnrj;\n+  int maxlen;\n+  int solvent;\n+  int *gid;\n+  int *jindex;\n+  atom_id *jjnr;\n+  int *nsatoms;\n+} t_nblist;\n+typedef struct {\n+  int nrx,nry,nrz;\n+} t_grid;\n+typedef struct {\n+} t_commrec;\n+enum { eNL_VDWQQ, eNL_VDW, eNL_QQ,\n+       eNL_VDWQQ_FREE, eNL_VDW_FREE, eNL_QQ_FREE,\n+       eNL_VDWQQ_SOLMNO, eNL_VDW_SOLMNO, eNL_QQ_SOLMNO,\n+       eNL_VDWQQ_WATER, eNL_QQ_WATER,\n+       eNL_VDWQQ_WATERWATER, eNL_QQ_WATERWATER,\n+       eNL_NR };\n+typedef struct {\n+  real rlist,rlistlong;\n+  real rcoulomb_switch,rcoulomb;\n+  real rvdw_switch,rvdw;\n+  int efep;\n+  int cg0,hcg;\n+  int *solvent_type;\n+  int *mno_index;\n+  rvec *cg_cm;\n+  t_nblist nlist_sr[eNL_NR];\n+  t_nblist nlist_lr[eNL_NR];\n+  int bTwinRange;\n+  rvec *f_twin;\n+  int *eg_excl;\n+} t_forcerec;\n+typedef struct {\n+  real *chargeA,*chargeB,*chargeT;\n+  int *bPerturbed;\n+  int *typeA,*typeB;\n+  unsigned short *cTC,*cENER,*cACC,*cFREEZE,*cXTC,*cVCM;\n+} t_mdatoms;\n+enum { egCOUL, egLJ, egBHAM, egLR, egLJLR, egCOUL14, egLJ14, egNR };\n+typedef struct {\n+  real *ee[egNR];\n+} t_grp_ener;\n+typedef struct {\n+  t_grp_ener estat;\n+} t_groups;\n+typedef unsigned long t_excl;\n+static void reset_nblist(t_nblist *nl)\n+{\n+  nl->nri = 0;\n+  nl->nrj = 0;\n+  nl->maxlen = 0;\n+  if (nl->maxnri > 0) {\n+    nl->gid[0] = -1;\n+    if (nl->maxnrj > 1) {\n+      nl->jindex[0] = 0;\n+      nl->jindex[1] = 0;\n+    }\n+  }\n+}\n+static void reset_neighbor_list(t_forcerec *fr,int bLR,int eNL)\n+{\n+    reset_nblist(&(fr->nlist_lr[eNL]));\n+}\n+static void close_i_nblist(t_nblist *nlist)\n+{\n+  int nri = nlist->nri;\n+  int len;\n+  nlist->jindex[nri+1] = nlist->nrj;\n+  len=nlist->nrj - nlist->jindex[nri];\n+  if (nlist->solvent==esolMNO)\n+    len *= nlist->nsatoms[3*nri];\n+  if(len > nlist->maxlen)\n+    nlist->maxlen = len;\n+}\n+static void close_nblist(t_nblist *nlist)\n+{\n+  if (nlist->maxnri > 0) {\n+    int nri = nlist->nri;\n+    if ((nlist->jindex[nri+1] > nlist->jindex[nri]) &&\n+ (nlist->gid[nri] != -1)) {\n+      nlist->nri++;\n+      nlist->jindex[nri+2] = nlist->nrj;\n+    }\n+  }\n+}\n+static void close_neighbor_list(t_forcerec *fr,int bLR,int eNL)\n+{\n+    close_nblist(&(fr->nlist_lr[eNL]));\n+}\n+static void add_j_to_nblist(t_nblist *nlist,atom_id j_atom)\n+{\n+  int nrj=nlist->nrj;\n+  nlist->jjnr[nrj] = j_atom;\n+  nlist->nrj ++;\n+}\n+static void put_in_list(int bHaveLJ[],\n+          int ngid,t_mdatoms *md,\n+          int icg,int jgid,int nj,atom_id jjcg[],\n+          atom_id index[],\n+          t_excl bExcl[],int shift,\n+          t_forcerec *fr,int bLR,\n+          int bVDWOnly,int bCoulOnly)\n+{\n+  t_nblist *vdwc,*vdw,*coul;\n+  t_nblist *vdwc_ww=((void *)0),*coul_ww=((void *)0);\n+  t_nblist *vdwc_free=((void *)0),*vdw_free=((void *)0),*coul_free=((void *)0);\n+  int i,j,jcg,igid,gid,ind_ij;\n+  atom_id jj,jj0,jj1,i_atom;\n+  int i0,nicg,len;\n+  int *type,*typeB;\n+  unsigned short *cENER;\n+  real *charge,*chargeB;\n+  real qi,qiB,qq,rlj;\n+  int bWater,bMNO,bFree,bFreeJ,bNotEx,*bPert;\n+  charge = md->chargeA;\n+  chargeB = md->chargeB;\n+  type = md->typeA;\n+  typeB = md->typeB;\n+  cENER = md->cENER;\n+  bPert = md->bPerturbed;\n+  i0 = index[icg];\n+  nicg = index[icg+1]-i0;\n+  bMNO = (fr->solvent_type[icg] == esolMNO);\n+  if (bLR) {\n+    if (bWater) {\n+      vdw = &fr->nlist_lr[eNL_VDW];\n+      coul = &fr->nlist_lr[eNL_QQ_WATER];\n+      vdwc_ww = &fr->nlist_lr[eNL_VDWQQ_WATERWATER];\n+    } else if(bMNO) {\n+      vdwc = &fr->nlist_lr[eNL_VDWQQ_SOLMNO];\n+    }\n+    if (fr->efep != efepNO) {\n+      vdw_free = &fr->nlist_lr[eNL_VDW_FREE];\n+      coul_free = &fr->nlist_lr[eNL_QQ_FREE];\n+    }\n+  }\n+  else {\n+    if (bWater) {\n+    } else if(bMNO) {\n+      vdwc = &fr->nlist_sr[eNL_VDWQQ_SOLMNO];\n+    }\n+    if (fr->efep != efepNO) {\n+      vdwc_free = &fr->nlist_sr[eNL_VDWQQ_FREE];\n+    }\n+  }\n+  if (fr->efep==efepNO) {\n+    if (bWater) {\n+      igid = cENER[i_atom];\n+      gid = ((igid < jgid) ? (igid*ngid+jgid) : (jgid*ngid+igid));\n+      if (!bCoulOnly && !bVDWOnly) {\n+ new_i_nblist(vdwc,bLR ? F_LJLR : F_LJ,i_atom,shift,gid,((void *)0));\n+ new_i_nblist(vdwc_ww,bLR ? F_LJLR : F_LJ,i_atom,shift,gid,((void *)0));\n+      }\n+      if (!bCoulOnly)\n+ new_i_nblist(vdw,bLR ? F_LJLR : F_LJ,i_atom,shift,gid,((void *)0));\n+      if (!bVDWOnly) {\n+ new_i_nblist(coul,bLR ? F_LR : F_SR,i_atom,shift,gid,((void *)0));\n+ new_i_nblist(coul_ww,bLR ? F_LR : F_SR,i_atom,shift,gid,((void *)0));\n+      }\n+      for(j=0; (j<nj); j++) {\n+ jcg=jjcg[j];\n+ if (jcg==icg)\n+ jj0 = index[jcg];\n+ if (bWater && (fr->solvent_type[jcg] == esolWATER)) {\n+   if (bVDWOnly)\n+     add_j_to_nblist(vdw,jj0);\n+   else {\n+       add_j_to_nblist(coul_ww,jj0);\n+       add_j_to_nblist(vdwc_ww,jj0);\n+   }\n+ } else {\n+   jj1 = index[jcg+1];\n+   if (bCoulOnly) {\n+     for(jj=jj0; (jj<jj1); jj++) {\n+       if (fabs(charge[jj]) > 1.2e-38)\n+  add_j_to_nblist(coul,jj);\n+     }\n+   } else if (bVDWOnly) {\n+     for(jj=jj0; (jj<jj1); jj++)\n+       if (bHaveLJ[type[jj]])\n+  add_j_to_nblist(vdw,jj);\n+   } else {\n+     for(jj=jj0; (jj<jj1); jj++) {\n+       if (bHaveLJ[type[jj]]) {\n+  if (fabs(charge[jj]) > 1.2e-38)\n+    add_j_to_nblist(vdwc,jj);\n+    add_j_to_nblist(vdw,jj);\n+       } else if (fabs(charge[jj]) > 1.2e-38)\n+  add_j_to_nblist(coul,jj);\n+     }\n+   }\n+ }\n+      }\n+      close_i_nblist(vdw);\n+      close_i_nblist(coul);\n+      close_i_nblist(vdwc);\n+      close_i_nblist(coul_ww);\n+      close_i_nblist(vdwc_ww);\n+    } else if (bMNO) {\n+      igid = cENER[i_atom];\n+      gid = ((igid < jgid) ? (igid*ngid+jgid) : (jgid*ngid+igid));\n+      if (!bCoulOnly && !bVDWOnly)\n+ new_i_nblist(vdwc,bLR ? F_LJLR : F_LJ,i_atom,shift,gid,\n+       &(fr->mno_index[icg*3]));\n+      if (!bCoulOnly)\n+ new_i_nblist(vdw,bLR ? F_LR : F_SR,i_atom,shift,gid,\n+       &(fr->mno_index[icg*3]));\n+      if (!bVDWOnly)\n+ new_i_nblist(coul,bLR ? F_LR : F_SR,i_atom,shift,gid,\n+       &(fr->mno_index[icg*3]));\n+      for(j=0; (j<nj); j++) {\n+ jcg=jjcg[j];\n+ if (jcg == icg)\n+ jj0 = index[jcg];\n+ jj1=index[jcg+1];\n+ for(jj=jj0; (jj<jj1); jj++) {\n+   if (bCoulOnly) {\n+     if (fabs(charge[jj]) > 1.2e-38)\n+       add_j_to_nblist(coul,jj);\n+   } else if (bVDWOnly) {\n+     if (bHaveLJ[type[jj]])\n+       add_j_to_nblist(vdw,jj);\n+   } else {\n+     if (bHaveLJ[type[jj]]) {\n+       if (fabs(charge[jj]) > 1.2e-38)\n+  add_j_to_nblist(vdwc,jj);\n+  add_j_to_nblist(vdw,jj);\n+     } else if (fabs(charge[jj]) > 1.2e-38)\n+       add_j_to_nblist(coul,jj);\n+   }\n+ }\n+ close_i_nblist(vdw);\n+ close_i_nblist(coul);\n+ close_i_nblist(vdwc);\n+      }\n+    } else {\n+      for(i=0; i<nicg; i++) {\n+ igid = cENER[i_atom];\n+ gid = ((igid < jgid) ? (igid*ngid+jgid) : (jgid*ngid+igid));\n+ qi = charge[i_atom];\n+ if (!bCoulOnly && !bVDWOnly)\n+   new_i_nblist(vdwc,bLR ? F_LJLR : F_LJ,i_atom,shift,gid,((void *)0));\n+ if (!bCoulOnly)\n+   new_i_nblist(vdw,bLR ? F_LR : F_SR,i_atom,shift,gid,((void *)0));\n+ if (!bVDWOnly)\n+   new_i_nblist(coul,bLR ? F_LR : F_SR,i_atom,shift,gid,((void *)0));\n+ if (!(bVDWOnly || fabs(qi)<1.2e-38) || !(bCoulOnly || !bHaveLJ[type[i_atom]])) {\n+   for(j=0; (j<nj); j++) {\n+     jcg=jjcg[j];\n+     if (jcg == icg)\n+       jj0 = i0 + i + 1;\n+     else\n+       jj0 = index[jcg];\n+     jj1=index[jcg+1];\n+     for(jj=jj0; jj<jj1; jj++) {\n+       bNotEx = !((int) ((bExcl)[((atom_id) (jj))] & (1<<((atom_id) (i)))));\n+       if (bNotEx) {\n+  if (bCoulOnly) {\n+                  if (fabs(charge[jj]) > 1.2e-38)\n+                    add_j_to_nblist(coul,jj);\n+  } else if (bVDWOnly) {\n+    if (bHaveLJ[type[jj]])\n+      add_j_to_nblist(vdw,jj);\n+  } else {\n+    if (bHaveLJ[type[jj]]) {\n+      if (fabs(qi) > 1.2e-38 && (fabs(charge[jj]) > 1.2e-38))\n+        add_j_to_nblist(vdwc,jj);\n+        add_j_to_nblist(vdw,jj);\n+    } else if (fabs(qi) > 1.2e-38 && (fabs(charge[jj]) > 1.2e-38))\n+      add_j_to_nblist(coul,jj);\n+  }\n+       }\n+     }\n+   }\n+ }\n+ close_i_nblist(vdw);\n+ close_i_nblist(coul);\n+ close_i_nblist(vdwc);\n+      }\n+    }\n+  } else {\n+    for(i=0; i<nicg; i++) {\n+      igid = cENER[i_atom];\n+      gid = ((igid < jgid) ? (igid*ngid+jgid) : (jgid*ngid+igid));\n+      qi = charge[i_atom];\n+      qiB = chargeB[i_atom];\n+      if (!bCoulOnly && !bVDWOnly)\n+ new_i_nblist(vdwc,bLR ? F_LJLR : F_LJ,i_atom,shift,gid,\n+       bMNO ? &(fr->mno_index[icg*3]) : ((void *)0));\n+      if (!bCoulOnly)\n+ new_i_nblist(vdw,bLR ? F_LR : F_SR,i_atom,shift,gid,\n+       bMNO ? &(fr->mno_index[icg*3]) : ((void *)0));\n+ new_i_nblist(coul,bLR ? F_LR : F_SR,i_atom,shift,gid,\n+       bMNO ? &(fr->mno_index[icg*3]) : ((void *)0));\n+      new_i_nblist(vdw_free,F_DVDL,i_atom,shift,gid,((void *)0));\n+      new_i_nblist(coul_free,F_DVDL,i_atom,shift,gid,((void *)0));\n+      new_i_nblist(vdwc_free,F_DVDL,i_atom,shift,gid,((void *)0));\n+      if (!(bVDWOnly || (fabs(qi)<1.2e-38 && fabs(qiB)<1.2e-38)) ||\n+   !(bCoulOnly || (!bHaveLJ[type[i_atom]] && !bHaveLJ[typeB[i_atom]]))) {\n+ for(j=0; (j<nj); j++) {\n+   jcg=jjcg[j];\n+   if (jcg == icg)\n+     jj0 = i0 + i + 1;\n+   else\n+     jj0 = index[jcg];\n+   jj1=index[jcg+1];\n+   bFree = bPert[i_atom];\n+   for(jj=jj0; (jj<jj1); jj++) {\n+     bFreeJ = bFree || bPert[jj];\n+     if ((!bWater && !bMNO) || i==0 || bFreeJ) {\n+       bNotEx = !((int) ((bExcl)[((atom_id) (jj))] & (1<<((atom_id) (i)))));\n+       if (bNotEx) {\n+                if (bFreeJ) {\n+    if (bCoulOnly)\n+      add_j_to_nblist(coul_free,jj);\n+    else if (bVDWOnly)\n+      add_j_to_nblist(vdw_free,jj);\n+      add_j_to_nblist(vdwc_free,jj);\n+  } else if (bCoulOnly) {\n+                    add_j_to_nblist(coul,jj);\n+                } else if (bVDWOnly) {\n+                  if (bHaveLJ[type[jj]])\n+                    add_j_to_nblist(vdw,jj);\n+                } else {\n+                  if (bHaveLJ[type[jj]]) {\n+                    if (fabs(qi) > 1.2e-38 && (fabs(charge[jj]) > 1.2e-38))\n+                      add_j_to_nblist(vdwc,jj);\n+                      add_j_to_nblist(vdw,jj);\n+                  } else if (fabs(qi) > 1.2e-38 && (fabs(charge[jj]) > 1.2e-38))\n+                    add_j_to_nblist(coul,jj);\n+                }\n+       }\n+     }\n+   }\n+ }\n+      }\n+      close_i_nblist(vdw);\n+      close_i_nblist(coul);\n+      close_i_nblist(vdwc);\n+      if (bWater && (i==0)) {\n+ close_i_nblist(coul_ww);\n+ close_i_nblist(vdwc_ww);\n+      }\n+      close_i_nblist(vdw_free);\n+      close_i_nblist(coul_free);\n+      close_i_nblist(vdwc_free);\n+    }\n+  }\n+}\n+static void setexcl(atom_id start,atom_id end,t_block *excl,int b,\n+      t_excl bexcl[])\n+{\n+  atom_id i,k;\n+  if (b) {\n+    for(i=start; i<end; i++) {\n+      for(k=excl->index[i]; k<excl->index[i+1]; k++) {\n+ (bexcl)[((atom_id) (excl->a[k]))] |= (1<<((atom_id) (i-start)));\n+      }\n+    }\n+  }\n+}\n+int calc_naaj(int icg,int cgtot)\n+{\n+  int naaj;\n+  if ((cgtot % 2) == 1) {\n+    naaj = 1+(cgtot/2);\n+  }\n+  else if ((cgtot % 4) == 0) {\n+    if (icg < cgtot/2) {\n+      if ((icg % 2) == 0)\n+ naaj=1+(cgtot/2);\n+    }\n+    else {\n+      if ((icg % 2) == 1)\n+ naaj=1+(cgtot/2);\n+    }\n+  }\n+  else {\n+    if ((icg % 2) == 0)\n+      naaj=1+(cgtot/2);\n+    else\n+      naaj=cgtot/2;\n+  }\n+  return naaj;\n+}\n+static void get_dx(int Nx,real gridx,real grid_x,real rc2,real x,\n+         int *dx0,int *dx1,real *dcx2)\n+{\n+  real dcx,tmp;\n+  int xgi,xgi0,xgi1,i;\n+  xgi = (int)(Nx+x*grid_x)-Nx;\n+  if (xgi < 0) {\n+    *dx0 = 0;\n+    *dx1 = -1;\n+  } else if (xgi >= Nx) {\n+    *dx0 = Nx;\n+    *dx1 = Nx-1;\n+  } else {\n+    dcx2[xgi] = 0;\n+    *dx0 = xgi;\n+    xgi0 = xgi-1;\n+    *dx1 = xgi;\n+    xgi1 = xgi+1;\n+  }\n+  for(i=xgi0; i>=0; i--) {\n+     dcx = (i+1)*gridx-x;\n+     tmp = dcx*dcx;\n+     if (tmp >= rc2)\n+     *dx0 = i;\n+     dcx2[i] = tmp;\n+  }\n+  for(i=xgi1; i<Nx; i++) {\n+     dcx = i*gridx-x;\n+     tmp = dcx*dcx;\n+     if (tmp >= rc2)\n+     *dx1 = i;\n+     dcx2[i] = tmp;\n+  }\n+}\n+static void do_longrange(FILE *log,t_commrec *cr,t_topology *top,t_forcerec *fr,\n+    int ngid,t_mdatoms *md,int icg,\n+    int jgid,int nlr,\n+    atom_id lr[],t_excl bexcl[],int shift,\n+    rvec x[],rvec box_size,t_nrnb *nrnb,\n+    real lambda,real *dvdlambda,\n+    t_groups *grps,int bVDWOnly,int bCoulOnly,\n+    int bDoForces,int bHaveLJ[])\n+{\n+  int i;\n+  for(i=0; (i<eNL_NR); i++) {\n+    if ((fr->nlist_lr[i].nri > fr->nlist_lr[i].maxnri-32) || bDoForces) {\n+      close_neighbor_list(fr,1,i);\n+      do_fnbf(log,cr,fr,x,fr->f_twin,md,\n+       grps->estat.ee[egLJLR],grps->estat.ee[egLR],box_size,\n+       nrnb,lambda,dvdlambda,1,i);\n+      reset_neighbor_list(fr,1,i);\n+    }\n+  }\n+  if (!bDoForces) {\n+    put_in_list(bHaveLJ,ngid,md,icg,jgid,nlr,lr,top->blocks[ebCGS].index,\n+                              bexcl,shift,fr,\n+  1,bVDWOnly,bCoulOnly);\n+  }\n+}\n+static int ns5_core(FILE *log,t_commrec *cr,t_forcerec *fr,int cg_index[],\n+      matrix box,rvec box_size,int ngid,\n+      t_topology *top,t_groups *grps,\n+      t_grid *grid,rvec x[],t_excl bexcl[],int *bExcludeAlleg,\n+      t_nrnb *nrnb,t_mdatoms *md,\n+      real lambda,real *dvdlambda,\n+      int bHaveLJ[])\n+{\n+  static atom_id **nl_lr_ljc,**nl_lr_one,**nl_sr=((void *)0);\n+  static int *nlr_ljc,*nlr_one,*nsr;\n+  static real *dcx2=((void *)0),*dcy2=((void *)0),*dcz2=((void *)0);\n+  t_block *cgs=&(top->blocks[ebCGS]);\n+  unsigned short *gid=md->cENER;\n+  int tx,ty,tz,dx,dy,dz,cj;\n+  int dx0,dx1,dy0,dy1,dz0,dz1;\n+  int Nx,Ny,Nz,shift=-1,j,nrj,nns,nn=-1;\n+  real gridx,gridy,gridz,grid_x,grid_y,grid_z;\n+  int icg=-1,iicg,cgsnr,i0,nri,naaj,min_icg,icg_naaj,jjcg,cgj0,jgid;\n+  int bVDWOnly,bCoulOnly;\n+  rvec xi,*cgcm;\n+  real r2,rs2,rvdw2,rcoul2,rm2,rl2,XI,YI,ZI,dcx,dcy,dcz,tmp1,tmp2;\n+  int *i_eg_excl;\n+  int use_twinrange,use_two_cutoffs;\n+  cgsnr = cgs->nr;\n+  rs2 = ((fr->rlist)*(fr->rlist));\n+  if (fr->bTwinRange) {\n+    rvdw2 = ((fr->rvdw)*(fr->rvdw));\n+    rcoul2 = ((fr->rcoulomb)*(fr->rcoulomb));\n+  } else {\n+  }\n+  rm2 = (((rvdw2) < (rcoul2)) ? (rvdw2) : (rcoul2) );\n+  rl2 = (((rvdw2) > (rcoul2)) ? (rvdw2) : (rcoul2) );\n+  use_twinrange = (rs2 < rm2);\n+  use_two_cutoffs = (rm2 < rl2);\n+  bVDWOnly = (rvdw2 > rcoul2);\n+  bCoulOnly = !bVDWOnly;\n+  if (nl_sr == ((void *)0)) {\n+    (nl_sr)=save_calloc(\"nl_sr\",\"ns.c\",1341, (ngid),sizeof(*(nl_sr)));\n+    (nsr)=save_calloc(\"nsr\",\"ns.c\",1343, (ngid),sizeof(*(nsr)));\n+    (nlr_ljc)=save_calloc(\"nlr_ljc\",\"ns.c\",1344, (ngid),sizeof(*(nlr_ljc)));\n+    (nlr_one)=save_calloc(\"nlr_one\",\"ns.c\",1345, (ngid),sizeof(*(nlr_one)));\n+    if (use_twinrange)\n+      (nl_lr_ljc)=save_calloc(\"nl_lr_ljc\",\"ns.c\",1349, (ngid),sizeof(*(nl_lr_ljc)));\n+    if (use_two_cutoffs)\n+      (nl_lr_one)=save_calloc(\"nl_lr_one\",\"ns.c\",1353, (ngid),sizeof(*(nl_lr_one)));\n+    for(j=0; (j<ngid); j++) {\n+      (nl_sr[j])=save_calloc(\"nl_sr[j]\",\"ns.c\",1356, (1024),sizeof(*(nl_sr[j])));\n+      if (use_twinrange)\n+ (nl_lr_ljc[j])=save_calloc(\"nl_lr_ljc[j]\",\"ns.c\",1358, (1024),sizeof(*(nl_lr_ljc[j])));\n+      if (use_two_cutoffs)\n+ (nl_lr_one[j])=save_calloc(\"nl_lr_one[j]\",\"ns.c\",1360, (1024),sizeof(*(nl_lr_one[j])));\n+    }\n+    if (debug)\n+      fprintf(debug,\"ns5_core: rs2 = %g, rvdw2 = %g, rcoul2 = %g (nm^2)\\n\",\n+       rs2,rvdw2,rcoul2);\n+  }\n+  cgcm = fr->cg_cm;\n+  Nx = grid->nrx;\n+  Ny = grid->nry;\n+  if (dcx2 == ((void *)0)) {\n+    (dcx2)=save_calloc(\"dcx2\",\"ns.c\",1379, (Nx*2),sizeof(*(dcx2)));\n+    (dcy2)=save_calloc(\"dcy2\",\"ns.c\",1380, (Ny*2),sizeof(*(dcy2)));\n+    (dcz2)=save_calloc(\"dcz2\",\"ns.c\",1381, (Nz*2),sizeof(*(dcz2)));\n+  }\n+  gridx = box[0][0]/grid->nrx;\n+  gridy = box[1][1]/grid->nry;\n+  gridz = box[2][2]/grid->nrz;\n+  grid_x = 1/gridx;\n+  grid_y = 1/gridy;\n+  grid_z = 1/gridz;\n+  for(iicg=fr->cg0; (iicg < fr->hcg); iicg++) {\n+    icg = cg_index[iicg];\n+    if (icg != iicg)\n+      fatal_error(0,\"icg = %d, iicg = %d, file %s, line %d\",icg,iicg,\"ns.c\",\n+    1408);\n+    if(bExcludeAlleg[icg])\n+    i_eg_excl = fr->eg_excl + ngid*gid[cgs->index[icg]];\n+    setexcl(cgs->index[icg],cgs->index[icg+1],&top->atoms.excl,1,bexcl);\n+    naaj = calc_naaj(icg,cgsnr);\n+    icg_naaj = icg+naaj;\n+    for (tz=-1; tz<=1; tz++) {\n+      ZI = cgcm[icg][2]+tz*box[2][2];\n+      get_dx(Nz,gridz,grid_z,rcoul2,ZI,&dz0,&dz1,dcz2);\n+      if (dz0 > dz1)\n+      for (ty=-1; ty<=1; ty++) {\n+ YI = cgcm[icg][1]+ty*box[1][1]+tz*box[2][1];\n+ get_dx(Ny,gridy,grid_y,rcoul2,YI,&dy0,&dy1,dcy2);\n+        for (tx=-1; tx<=1; tx++) {\n+   get_dx(Nx,gridx,grid_x,rcoul2,XI,&dx0,&dx1,dcx2);\n+   shift=((2*1 +1)*((2*1 +1)*((tz)+1)+(ty)+1)+(tx)+1);\n+   for (dx=dx0; (dx<=dx1); dx++) {\n+     for (dy=dy0; (dy<=dy1); dy++) {\n+  for (dz=dz0; (dz<=dz1); dz++) {\n+    if (tmp2 > dcz2[dz]) {\n+      for (j=0; (j<nrj); j++) {\n+        if (((jjcg >= icg) && (jjcg < icg_naaj)) ||\n+     ((jjcg < min_icg))) {\n+   if (r2 < rl2) {\n+     if (!i_eg_excl[jgid]) {\n+       if (r2 < rs2) {\n+         if (nsr[jgid] >= 1024) {\n+    put_in_list(bHaveLJ,ngid,md,icg,jgid,\n+         nsr[jgid],nl_sr[jgid],\n+         cgs->index, bexcl,\n+         shift,fr,0,0,0);\n+         }\n+       } else if (r2 < rm2) {\n+       } else if (use_two_cutoffs) {\n+         if (nlr_one[jgid] >= 1024) {\n+    do_longrange(log,cr,top,fr,ngid,md,icg,jgid,\n+          nlr_one[jgid],\n+          nl_lr_one[jgid],bexcl,shift,x,\n+          box_size,nrnb,\n+          lambda,dvdlambda,grps,\n+          bVDWOnly,bCoulOnly,0,\n+          bHaveLJ);\n+         }\n+       }\n+     }\n+   }\n+        }\n+      }\n+    }\n+  }\n+     }\n+   }\n+ }\n+      }\n+    }\n+  }\n+}\n+int search_neighbours(FILE *log,t_forcerec *fr,\n+        rvec x[],matrix box,\n+        t_topology *top,t_groups *grps,\n+        t_commrec *cr,t_nsborder *nsb,\n+        t_nrnb *nrnb,t_mdatoms *md,\n+        real lambda,real *dvdlambda)\n+{\n+  static t_grid *grid=((void *)0);\n+  static t_excl *bexcl;\n+  static int *bHaveLJ;\n+  static int *cg_index=((void *)0),*slab_index=((void *)0);\n+  static int *bExcludeAlleg;\n+  rvec box_size;\n+  int i,j,m,ngid;\n+  int nsearch;\n+    nsearch = ns5_core(log,cr,fr,cg_index,box,box_size,ngid,top,grps,\n+         grid,x,bexcl,bExcludeAlleg,nrnb,md,lambda,dvdlambda,bHaveLJ);\n+}"}]}