{"sha": "8441bc30354967518401cd47ff5355cc2e3abbfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ0MWJjMzAzNTQ5Njc1MTg0MDFjZDQ3ZmY1MzU1Y2MyZTNhYmJmZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-09-07T11:07:07Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-09-07T11:07:07Z"}, "message": "Handle multiword modes in regno_clobbered_p\n\nFrom-SVN: r36233", "tree": {"sha": "65b445029f288c5e129d33bebd33211ec797ee74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65b445029f288c5e129d33bebd33211ec797ee74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8441bc30354967518401cd47ff5355cc2e3abbfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8441bc30354967518401cd47ff5355cc2e3abbfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8441bc30354967518401cd47ff5355cc2e3abbfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8441bc30354967518401cd47ff5355cc2e3abbfe/comments", "author": null, "committer": null, "parents": [{"sha": "ff42776491b30801b8c4f04085761856f38ffc09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff42776491b30801b8c4f04085761856f38ffc09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff42776491b30801b8c4f04085761856f38ffc09"}], "stats": {"total": 37, "additions": 26, "deletions": 11}, "files": [{"sha": "a477e6f8b92d412b5a561fdee8de0168252aef7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8441bc30354967518401cd47ff5355cc2e3abbfe", "patch": "@@ -2,7 +2,10 @@\n \n \t* rtl.c (class_narrowest_mode): Add entries for MODE_VECTOR_INT and\n \tMODE_VECTOR_FLOAT.\n-\n+\t* reload.c (regno_clobbered_p): Accept new arg, MODE, and use it\n+\tto handle multiword modes correctly.  All callers and the declaration\n+\tchanged.\n+  \n 2000-09-06  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-common.h (prep_stmt): Declare."}, {"sha": "d83b1f69e3122f4b53379fbb7d761921bf9cea68", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=8441bc30354967518401cd47ff5355cc2e3abbfe", "patch": "@@ -4519,7 +4519,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \n       else if (regno < FIRST_PSEUDO_REGISTER\n \t       && REGNO_MODE_OK_FOR_BASE_P (regno, mode)\n-\t       && ! regno_clobbered_p (regno, this_insn))\n+\t       && ! regno_clobbered_p (regno, this_insn, mode))\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n@@ -5427,7 +5427,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t   in this insn, reload it into some other register to be safe.\n \t   The CLOBBER is supposed to make the register unavailable\n \t   from before this insn to after it.  */\n-\tif (regno_clobbered_p (regno, this_insn))\n+\tif (regno_clobbered_p (regno, this_insn, GET_MODE (x)))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n@@ -6544,13 +6544,21 @@ find_inc_amount (x, inced)\n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n \n int\n-regno_clobbered_p (regno, insn)\n+regno_clobbered_p (regno, insn, mode)\n      unsigned int regno;\n      rtx insn;\n+     enum machine_mode mode;\n {\n+  int nregs = HARD_REGNO_NREGS (regno, mode);\n+  int endregno = regno + nregs;\n+\n   if (GET_CODE (PATTERN (insn)) == CLOBBER\n       && GET_CODE (XEXP (PATTERN (insn), 0)) == REG)\n-    return REGNO (XEXP (PATTERN (insn), 0)) == regno;\n+    {\n+      int test = REGNO (XEXP (PATTERN (insn), 0));\n+\n+      return regno >= test && test < endregno;\n+    }\n \n   if (GET_CODE (PATTERN (insn)) == PARALLEL)\n     {\n@@ -6559,9 +6567,13 @@ regno_clobbered_p (regno, insn)\n       for (; i >= 0; i--)\n \t{\n \t  rtx elt = XVECEXP (PATTERN (insn), 0, i);\n-\t  if (GET_CODE (elt) == CLOBBER && GET_CODE (XEXP (elt, 0)) == REG\n-\t      && REGNO (XEXP (elt, 0)) == regno)\n-\t    return 1;\n+\t  if (GET_CODE (elt) == CLOBBER && GET_CODE (XEXP (elt, 0)) == REG)\n+\t    {\n+\t      int test = REGNO (XEXP (elt, 0));\n+\t      \n+\t      if (regno >= test && test < endregno)\n+\t\treturn 1;\n+\t    }\n \t}\n     }\n "}, {"sha": "a2df3b1caa5d02d9f26a2a75c40d169fd0e7e1c9", "filename": "gcc/reload.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=8441bc30354967518401cd47ff5355cc2e3abbfe", "patch": "@@ -335,7 +335,7 @@ extern rtx find_equiv_reg PARAMS ((rtx, rtx, enum reg_class, int, short *,\n \t\t\t\t int, enum machine_mode));\n \n /* Return 1 if register REGNO is the subject of a clobber in insn INSN.  */\n-extern int regno_clobbered_p PARAMS ((unsigned int, rtx));\n+extern int regno_clobbered_p PARAMS ((unsigned int, rtx, enum machine_mode));\n \n /* Return 1 if X is an operand of an insn that is being earlyclobbered.  */\n int earlyclobber_operand_p PARAMS ((rtx));"}, {"sha": "b09f9eb8222b6f2f0f0e55a168123b0e19057eed", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8441bc30354967518401cd47ff5355cc2e3abbfe/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8441bc30354967518401cd47ff5355cc2e3abbfe", "patch": "@@ -5514,7 +5514,7 @@ choose_reload_regs (chain)\n \t\t In particular, we then can't use EQUIV for a\n \t\t RELOAD_FOR_OUTPUT_ADDRESS reload.  */\n \n-\t      if (equiv != 0 && regno_clobbered_p (regno, insn))\n+\t      if (equiv != 0 && regno_clobbered_p (regno, insn, rld[r].mode))\n \t\t{\n \t\t  switch (rld[r].when_needed)\n \t\t    {\n@@ -6536,7 +6536,7 @@ emit_output_reload_insns (chain, rl, j)\n \t  || !(set = single_set (insn))\n \t  || rtx_equal_p (old, SET_DEST (set))\n \t  || !reg_mentioned_p (old, SET_SRC (set))\n-\t  || !regno_clobbered_p (REGNO (old), insn))\n+\t  || !regno_clobbered_p (REGNO (old), insn, rl->mode))\n \tgen_reload (old, reloadreg, rl->opnum,\n \t\t    rl->when_needed);\n     }"}]}