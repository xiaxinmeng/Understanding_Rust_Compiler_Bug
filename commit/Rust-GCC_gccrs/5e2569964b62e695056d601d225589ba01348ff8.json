{"sha": "5e2569964b62e695056d601d225589ba01348ff8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyNTY5OTY0YjYyZTY5NTA1NmQ2MDFkMjI1NTg5YmEwMTM0OGZmOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-06T22:46:10Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-06T22:46:10Z"}, "message": "re PR c++/9965 (ICE in cp_expr_size)\n\n\tPR c++/9965\n\t* call.c (reference_binding): Add ref_is_var parameter.\n\t(implicit_conversion): Adjust call to reference_binding.\n\t(initialize_reference): Likewise.\n\n\tPR c++/9965\n\t* g++.dg/init/ref2.C: New test.\n\nFrom-SVN: r63909", "tree": {"sha": "1d244e8b7aa4d71995d155f1b8bc28dc30e5f960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d244e8b7aa4d71995d155f1b8bc28dc30e5f960"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e2569964b62e695056d601d225589ba01348ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2569964b62e695056d601d225589ba01348ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2569964b62e695056d601d225589ba01348ff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2569964b62e695056d601d225589ba01348ff8/comments", "author": null, "committer": null, "parents": [{"sha": "a9aa7083edffef0a326154cc39f429e55a12d846", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9aa7083edffef0a326154cc39f429e55a12d846", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9aa7083edffef0a326154cc39f429e55a12d846"}], "stats": {"total": 63, "additions": 41, "deletions": 22}, "files": [{"sha": "25bba1b8498dd9b67f02cd8f6be5e931c1a12d2d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5e2569964b62e695056d601d225589ba01348ff8", "patch": "@@ -1,5 +1,10 @@\n 2003-03-06  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/9965\n+\t* call.c (reference_binding): Add ref_is_var parameter.\n+\t(implicit_conversion): Adjust call to reference_binding.\n+\t(initialize_reference): Likewise.\n+\n \tPR c++/9400\n \t* decl.c (pushdecl): Don't check for shadowing of DECL_ARTIFICIAL\n \tPARM_DECLs."}, {"sha": "45cb23b40b1a0d44db8c1acd6afd2b0c6fcc65f6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5e2569964b62e695056d601d225589ba01348ff8", "patch": "@@ -85,7 +85,7 @@ static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, tree, tree, int);\n static tree implicit_conversion (tree, tree, tree, int);\n static tree standard_conversion (tree, tree, tree);\n-static tree reference_binding (tree, tree, tree, int, bool *);\n+static tree reference_binding (tree, tree, tree, int, bool);\n static tree non_reference (tree);\n static tree build_conv (enum tree_code, tree, tree);\n static bool is_subseq (tree, tree);\n@@ -1111,14 +1111,12 @@ direct_reference_binding (tree type, tree conv)\n    purposes of reference binding.  For lvalue binding, either pass a\n    reference type to FROM or an lvalue expression to EXPR.  If the\n    reference will be bound to a temporary, NEED_TEMPORARY_P is set for\n-   the conversion returned.  If non-NULL,\n-   *REF_BOUND_DIRECTLY_TO_RVALUE_P is set to true if and only if the\n-   conversion sequence returned binds the reference directly to an\n-   rvalue.  */\n+   the conversion returned.  REF_IS_VAR is true iff the reference is\n+   a variable (rather than, say, a parameter declaration).  */\n \n static tree\n reference_binding (tree rto, tree rfrom, tree expr, int flags,\n-\t\t   bool *ref_bound_directly_to_rvalue_p)\n+\t\t   bool ref_is_var)\n {\n   tree conv = NULL_TREE;\n   tree to = TREE_TYPE (rto);\n@@ -1127,10 +1125,6 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags,\n   bool compatible_p;\n   cp_lvalue_kind lvalue_p = clk_none;\n \n-  /* Assume that the reference is not bound directly to an rvalue.  */\n-  if (ref_bound_directly_to_rvalue_p)\n-    *ref_bound_directly_to_rvalue_p = false;\n-\n   if (TREE_CODE (to) == FUNCTION_TYPE && expr && type_unknown_p (expr))\n     {\n       expr = instantiate_type (to, expr, tf_none);\n@@ -1234,15 +1228,23 @@ reference_binding (tree rto, tree rfrom, tree expr, int flags,\n      -- The reference is bound to the object represented by the rvalue\n         or to a sub-object within that object.  \n \n-     In this case, the implicit conversion sequence is supposed to be\n-     same as we would obtain by generating a temporary.  Fortunately,\n-     if the types are reference compatible, then this is either an\n-     identity conversion or the derived-to-base conversion, just as\n-     for direct binding.  */\n-  if (CLASS_TYPE_P (from) && compatible_p)\n+     -- A temporary of type \"cv1 T2\" [sic] is created, and a\n+        constructor is called to copy the entire rvalue object into\n+        the temporary.  The reference is bound to the temporary or to\n+        a sub-object within the temporary\n+\t\n+     In general, we choose the first alternative, since it avoids the\n+     copy.  However, if REF_IS_VAR is true, then we cannot do that; we\n+     need to bind the reference to a temporary that wil live as long\n+     as the reference itself.\n+\n+     In the first alternative, the implicit conversion sequence is\n+     supposed to be same as we would obtain by generating a temporary.\n+     Fortunately, if the types are reference compatible, then this is\n+     either an identity conversion or the derived-to-base conversion,\n+     just as for direct binding.  */\n+  if (CLASS_TYPE_P (from) && compatible_p && !ref_is_var)\n     {\n-      if (ref_bound_directly_to_rvalue_p)\n-\t*ref_bound_directly_to_rvalue_p = true;\n       conv = build1 (IDENTITY_CONV, from, expr);\n       return direct_reference_binding (rto, conv);\n     }\n@@ -1297,8 +1299,7 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n   complete_type (to);\n \n   if (TREE_CODE (to) == REFERENCE_TYPE)\n-    conv = reference_binding (to, from, expr, flags, \n-\t\t\t      /*ref_bound_directly_to_rvalue_p=*/NULL);\n+    conv = reference_binding (to, from, expr, flags, /*ref_is_var=*/false);\n   else\n     conv = standard_conversion (to, from, expr);\n \n@@ -5847,13 +5848,13 @@ tree\n initialize_reference (tree type, tree expr, tree decl)\n {\n   tree conv;\n-  bool ref_bound_directly_to_rvalue_p;\n+  bool ref_bound_directly_to_rvalue_p = false;\n \n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n \n   conv = reference_binding (type, TREE_TYPE (expr), expr, LOOKUP_NORMAL,\n-\t\t\t    &ref_bound_directly_to_rvalue_p);\n+\t\t\t    decl != NULL_TREE);\n   if (!conv || ICS_BAD_FLAG (conv))\n     {\n       error (\"could not convert `%E' to `%T'\", expr, type);"}, {"sha": "9fabfd1805cc48699f1c6ac9584ea90056193121", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e2569964b62e695056d601d225589ba01348ff8", "patch": "@@ -1,5 +1,8 @@\n 2003-03-06  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/9965\n+\t* g++.dg/init/ref2.C: New test.\n+\t\n \tPR c++/9400\n \t* g++.dg/warn/Wshadow-2.C: New test.\n "}, {"sha": "231ea047fff0f84b3e5c002e70a75e6a368dd2bc", "filename": "gcc/testsuite/g++.dg/init/ref2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e2569964b62e695056d601d225589ba01348ff8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref2.C?ref=5e2569964b62e695056d601d225589ba01348ff8", "patch": "@@ -0,0 +1,10 @@\n+struct Base {\n+        Base();\n+  Base(const Base &);\n+  Base & operator = (const Base &);\n+};\n+\n+struct Derived : public Base {};\n+\n+Derived derived();\n+const Base &b = derived();"}]}