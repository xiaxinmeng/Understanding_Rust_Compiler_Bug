{"sha": "2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5ZjhjMGFmYTIwYzE0ZTE5ZWNiM2RjNzYwYmM0Y2RmZTFlZTY2ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-18T11:56:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-18T11:56:35Z"}, "message": "[multiple changes]\n\n2014-02-18  Robert Dewar  <dewar@adacore.com>\n\n\t* cstand.adb (Build_Signed_Integer_Type): Minor change of formal\n\tfrom Int to Nat (Build_Unsigned_Integer_Type): New procedure\n\t(Create_Standard): Create new unsigned types.\n\t* exp_ch4.adb (Expand_N_Op_Mod): Expand mod in Modify_Tree_For_C\n\tmode (Expand_N_Reference): Removed, problematic and not needed\n\tfor now.\n\t* exp_ch4.ads (Expand_N_Reference): Removed, problematic and\n\tnot needed for now.\n\t* exp_util.ads, exp_util.adb (Power_Of_Two): New function.\n\t* expander.adb: Remove call to Expand_N_Reference (problematic,\n\tand not needed now).\n\t* sem_aux.ads, sem_aux.adb (Corresponding_Unsigned_Type): New function.\n\t* stand.adb: Read and write unsigned type entities.\n\t* stand.ads: Add new unsigned types.\n\n2014-02-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Call): Do not mark a function call\n\tas being inside an assertion expression as the flag is now removed.\n\t(Check_Ghost_Subprogram_Call): Do not query the\n\tIn_Assertion_Expression flag as it is now removed, instead use\n\ta predicate function.\n\t* sem_elab.adb (Check_Internal_Call_Continue): Do not query the\n\tIn_Assertion_Expression flag as it is now removed, instead use\n\ta predicate function.\n\t* sem_prag.ads: Add new table Assertion_Expression_Pragma.\n\t* sem_util.adb Add with and use clause for Sem_Prag.\n\t(In_Assertion_Expression_Pragma): New routine.\n\t* sem_util.ads (In_Assertion_Expression_Pragma): New routine.\n\t* sinfo.adb (In_Assertion_Expression): Removed.\n\t(Set_In_Assertion_Expression): Removed.\n\t* sinfo.ads Remove flag In_Assertion_Expression along with its\n\tuse in nodes.\n\t(In_Assertion_Expression): Removed along with\n\tpragma Inline.\t(Set_In_Assertion_Expression): Removed along\n\twith pragma Inline.\n\n2014-02-18  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi: gnatpp section: add note that '-j' cannot be\n\tused together with '-r', '-rf' or '-rnb' options.\n\n2014-02-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_attr.adb (Analyze_Attribute): Comment\n\tand code reformatting. Use separate routines to check the\n\tlegality of attribute 'Old in certain pragmas. Verify\n\tthe use of 'Old, 'Result and locally declared entities\n\twithin the prefix of 'Old.\n\t(Check_References_In_Prefix): New routine.\n\t(Check_Use_In_Contract_Cases): New routine.\n\t(Check_Use_In_Test_Case): New routine.\n\nFrom-SVN: r207843", "tree": {"sha": "9117345bce17a4248ac27fba841550b41220d000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9117345bce17a4248ac27fba841550b41220d000"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/comments", "author": null, "committer": null, "parents": [{"sha": "3b821fe9fe8ba49149509f4f7bea6353602ad2d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b821fe9fe8ba49149509f4f7bea6353602ad2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b821fe9fe8ba49149509f4f7bea6353602ad2d2"}], "stats": {"total": 800, "additions": 569, "deletions": 231}, "files": [{"sha": "a7937443ddc736bc796d76eb1c7410b14c606b7f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -1,3 +1,58 @@\n+2014-02-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* cstand.adb (Build_Signed_Integer_Type): Minor change of formal\n+\tfrom Int to Nat (Build_Unsigned_Integer_Type): New procedure\n+\t(Create_Standard): Create new unsigned types.\n+\t* exp_ch4.adb (Expand_N_Op_Mod): Expand mod in Modify_Tree_For_C\n+\tmode (Expand_N_Reference): Removed, problematic and not needed\n+\tfor now.\n+\t* exp_ch4.ads (Expand_N_Reference): Removed, problematic and\n+\tnot needed for now.\n+\t* exp_util.ads, exp_util.adb (Power_Of_Two): New function.\n+\t* expander.adb: Remove call to Expand_N_Reference (problematic,\n+\tand not needed now).\n+\t* sem_aux.ads, sem_aux.adb (Corresponding_Unsigned_Type): New function.\n+\t* stand.adb: Read and write unsigned type entities.\n+\t* stand.ads: Add new unsigned types.\n+\n+2014-02-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Call): Do not mark a function call\n+\tas being inside an assertion expression as the flag is now removed.\n+\t(Check_Ghost_Subprogram_Call): Do not query the\n+\tIn_Assertion_Expression flag as it is now removed, instead use\n+\ta predicate function.\n+\t* sem_elab.adb (Check_Internal_Call_Continue): Do not query the\n+\tIn_Assertion_Expression flag as it is now removed, instead use\n+\ta predicate function.\n+\t* sem_prag.ads: Add new table Assertion_Expression_Pragma.\n+\t* sem_util.adb Add with and use clause for Sem_Prag.\n+\t(In_Assertion_Expression_Pragma): New routine.\n+\t* sem_util.ads (In_Assertion_Expression_Pragma): New routine.\n+\t* sinfo.adb (In_Assertion_Expression): Removed.\n+\t(Set_In_Assertion_Expression): Removed.\n+\t* sinfo.ads Remove flag In_Assertion_Expression along with its\n+\tuse in nodes.\n+\t(In_Assertion_Expression): Removed along with\n+\tpragma Inline.\t(Set_In_Assertion_Expression): Removed along\n+\twith pragma Inline.\n+\n+2014-02-18  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi: gnatpp section: add note that '-j' cannot be\n+\tused together with '-r', '-rf' or '-rnb' options.\n+\n+2014-02-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute): Comment\n+\tand code reformatting. Use separate routines to check the\n+\tlegality of attribute 'Old in certain pragmas. Verify\n+\tthe use of 'Old, 'Result and locally declared entities\n+\twithin the prefix of 'Old.\n+\t(Check_References_In_Prefix): New routine.\n+\t(Check_Use_In_Contract_Cases): New routine.\n+\t(Check_Use_In_Test_Case): New routine.\n+\n 2014-02-18  Vincent Celier  <celier@adacore.com>\n \n \t* sem_aux.adb (Is_By_Reference_Type): For each components of"}, {"sha": "28844c72b6e7609ebd2d738ea259d1afec6d2cd7", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 78, "deletions": 47, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -73,12 +73,21 @@ package body CStand is\n    --  to be used. The fourth parameter is the digits value. Each type\n    --  is added to the list of predefined floating point types.\n \n-   procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Int);\n+   procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Nat);\n    --  Procedure to build standard predefined signed integer subtype. The\n    --  first parameter is the entity for the subtype. The second parameter\n    --  is the size in bits. The corresponding base type is not built by\n    --  this routine but instead must be built by the caller where needed.\n \n+   procedure Build_Unsigned_Integer_Type\n+     (Uns : Entity_Id;\n+      Siz : Nat;\n+      Nam : String);\n+   --  Procedure to build standard predefined unsigned integer subtype. These\n+   --  subtypes are not user visible, but they are used internally. The first\n+   --  parameter is the entity for the subtype. The second parameter is the\n+   --  size in bits. The third parameter is an identifying name.\n+\n    procedure Copy_Float_Type (To : Entity_Id; From : Entity_Id);\n    --  Build a floating point type, copying representation details from From.\n    --  This is used to create predefined floating point types based on\n@@ -218,7 +227,7 @@ package body CStand is\n    -- Build_Signed_Integer_Type --\n    -------------------------------\n \n-   procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Int) is\n+   procedure Build_Signed_Integer_Type (E : Entity_Id; Siz : Nat) is\n       U2Siz1 : constant Uint := 2 ** (Siz - 1);\n       Lbound : constant Uint := -U2Siz1;\n       Ubound : constant Uint := U2Siz1 - 1;\n@@ -240,6 +249,41 @@ package body CStand is\n       Set_Size_Known_At_Compile_Time (E);\n    end Build_Signed_Integer_Type;\n \n+   ---------------------------------\n+   -- Build_Unsigned_Integer_Type --\n+   ---------------------------------\n+\n+   procedure Build_Unsigned_Integer_Type\n+     (Uns : Entity_Id;\n+      Siz : Nat;\n+      Nam : String)\n+   is\n+      Decl   : Node_Id;\n+      R_Node : Node_Id;\n+\n+   begin\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Uns);\n+      Make_Name (Uns, Nam);\n+\n+      Set_Ekind                      (Uns, E_Modular_Integer_Type);\n+      Set_Scope                      (Uns, Standard_Standard);\n+      Set_Etype                      (Uns, Uns);\n+      Init_Size                      (Uns, Siz);\n+      Set_Elem_Alignment             (Uns);\n+      Set_Modulus                    (Uns, Uint_2 ** Siz);\n+      Set_Is_Unsigned_Type           (Uns);\n+      Set_Size_Known_At_Compile_Time (Uns);\n+      Set_Is_Known_Valid             (Uns, True);\n+\n+      R_Node := New_Node (N_Range, Stloc);\n+      Set_Low_Bound  (R_Node, Make_Integer (Uint_0));\n+      Set_High_Bound (R_Node, Make_Integer (Modulus (Uns) - 1));\n+      Set_Etype (Low_Bound  (R_Node), Uns);\n+      Set_Etype (High_Bound (R_Node), Uns);\n+      Set_Scalar_Range (Uns, R_Node);\n+   end Build_Unsigned_Integer_Type;\n+\n    ---------------------\n    -- Copy_Float_Type --\n    ---------------------\n@@ -1305,58 +1349,45 @@ package body CStand is\n       Set_Scope (Standard_Integer_64, Standard_Standard);\n       Build_Signed_Integer_Type (Standard_Integer_64, 64);\n \n-      --  Standard_Unsigned is not user visible, but is used internally. It\n-      --  is an unsigned type with the same length as Standard.Integer.\n+      --  Standard_*_Unsigned subtypes are not user visible, but they are\n+      --  used internally. They are unsigned types with the same length as\n+      --  the correspondingly named signed integer types.\n \n-      Standard_Unsigned := New_Standard_Entity;\n-      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n-      Set_Defining_Identifier (Decl, Standard_Unsigned);\n-      Make_Name (Standard_Unsigned, \"unsigned\");\n-\n-      Set_Ekind             (Standard_Unsigned, E_Modular_Integer_Type);\n-      Set_Scope             (Standard_Unsigned, Standard_Standard);\n-      Set_Etype             (Standard_Unsigned, Standard_Unsigned);\n-      Init_Size             (Standard_Unsigned, Standard_Integer_Size);\n-      Set_Elem_Alignment    (Standard_Unsigned);\n-      Set_Modulus           (Standard_Unsigned,\n-                              Uint_2 ** Standard_Integer_Size);\n-      Set_Is_Unsigned_Type  (Standard_Unsigned);\n-      Set_Size_Known_At_Compile_Time\n-                            (Standard_Unsigned);\n-      Set_Is_Known_Valid    (Standard_Unsigned, True);\n+      Standard_Short_Short_Unsigned := New_Standard_Entity;\n+      Build_Unsigned_Integer_Type\n+        (Standard_Short_Short_Unsigned,\n+         Standard_Short_Short_Integer_Size,\n+         \"short_short_unsigned\");\n \n-      R_Node := New_Node (N_Range, Stloc);\n-      Set_Low_Bound  (R_Node, Make_Integer (Uint_0));\n-      Set_High_Bound (R_Node, Make_Integer (Modulus (Standard_Unsigned) - 1));\n-      Set_Etype (Low_Bound (R_Node), Standard_Unsigned);\n-      Set_Etype (High_Bound (R_Node), Standard_Unsigned);\n-      Set_Scalar_Range (Standard_Unsigned, R_Node);\n+      Standard_Short_Unsigned := New_Standard_Entity;\n+      Build_Unsigned_Integer_Type\n+        (Standard_Short_Unsigned,\n+         Standard_Short_Integer_Size,\n+         \"short_unsigned\");\n+\n+      Standard_Unsigned := New_Standard_Entity;\n+      Build_Unsigned_Integer_Type\n+        (Standard_Unsigned,\n+         Standard_Integer_Size,\n+         \"unsigned\");\n+\n+      Standard_Long_Unsigned := New_Standard_Entity;\n+      Build_Unsigned_Integer_Type\n+        (Standard_Long_Unsigned,\n+         Standard_Long_Integer_Size,\n+         \"long_unsigned\");\n+\n+      Standard_Long_Long_Unsigned := New_Standard_Entity;\n+      Build_Unsigned_Integer_Type\n+        (Standard_Long_Long_Unsigned,\n+         Standard_Long_Long_Integer_Size,\n+         \"long_long_unsigned\");\n \n       --  Standard_Unsigned_64 is not user visible, but is used internally. It\n       --  is an unsigned type mod 2**64, 64-bits unsigned, size is 64.\n \n       Standard_Unsigned_64 := New_Standard_Entity;\n-      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n-      Set_Defining_Identifier (Decl, Standard_Unsigned_64);\n-      Make_Name (Standard_Unsigned_64, \"unsigned_64\");\n-\n-      Set_Ekind             (Standard_Unsigned_64, E_Modular_Integer_Type);\n-      Set_Scope             (Standard_Unsigned_64, Standard_Standard);\n-      Set_Etype             (Standard_Unsigned_64, Standard_Unsigned_64);\n-      Init_Size             (Standard_Unsigned_64, 64);\n-      Set_Elem_Alignment    (Standard_Unsigned_64);\n-      Set_Modulus           (Standard_Unsigned_64, Uint_2 ** 64);\n-      Set_Is_Unsigned_Type  (Standard_Unsigned_64);\n-      Set_Size_Known_At_Compile_Time\n-                            (Standard_Unsigned_64);\n-      Set_Is_Known_Valid    (Standard_Unsigned_64, True);\n-\n-      R_Node := New_Node (N_Range, Stloc);\n-      Set_Low_Bound  (R_Node, Make_Integer (Uint_0));\n-      Set_High_Bound (R_Node, Make_Integer (Uint_2 ** 64 - 1));\n-      Set_Etype (Low_Bound (R_Node), Standard_Unsigned_64);\n-      Set_Etype (High_Bound (R_Node), Standard_Unsigned_64);\n-      Set_Scalar_Range (Standard_Unsigned_64, R_Node);\n+      Build_Unsigned_Integer_Type (Standard_Unsigned_64, 64, \"unsigned_64\");\n \n       --  Note: universal integer and universal real are constructed as fully\n       --  formed signed numeric types, with parameters corresponding to the"}, {"sha": "d5bd8048fdc8f25c7ef9820ae91fa063ae05af1c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 116, "deletions": 69, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -7956,12 +7956,19 @@ package body Exp_Ch4 is\n       Determine_Range (Right, ROK, Rlo, Rhi, Assume_Valid => True);\n       Determine_Range (Left,  LOK, Llo, Lhi, Assume_Valid => True);\n \n-      --  Convert mod to rem if operands are known non-negative. We do this\n-      --  since it is quite likely that this will improve the quality of code,\n-      --  (the operation now corresponds to the hardware remainder), and it\n-      --  does not seem likely that it could be harmful.\n-\n-      if LOK and then Llo >= 0 and then ROK and then Rlo >= 0 then\n+      --  Convert mod to rem if operands are both known to be non-negative, or\n+      --  both known to be non-positive (these are the cases in which rem and\n+      --  mod are the same, see (RM 4.5.5(28-30)). We do this since it is quite\n+      --  likely that this will improve the quality of code, (the operation now\n+      --  corresponds to the hardware remainder), and it does not seem likely\n+      --  that it could be harmful. It also avoids some cases of the elaborate\n+      --  expansion in Modify_Tree_For_C mode below (since Ada rem = C %).\n+\n+      if (LOK and ROK)\n+        and then ((Llo >= 0 and then Rlo >= 0)\n+                    or else\n+                  (Lhi <= 0 and then Rhi <= 0))\n+      then\n          Rewrite (N,\n            Make_Op_Rem (Sloc (N),\n              Left_Opnd  => Left_Opnd (N),\n@@ -7976,6 +7983,7 @@ package body Exp_Ch4 is\n          Set_Do_Division_Check (N, DDC);\n          Expand_N_Op_Rem (N);\n          Set_Analyzed (N);\n+         return;\n \n       --  Otherwise, normal mod processing\n \n@@ -7999,10 +8007,108 @@ package body Exp_Ch4 is\n             return;\n          end if;\n \n-         --  Deal with annoying case of largest negative number remainder\n-         --  minus one. Gigi may not handle this case correctly, because\n-         --  on some targets, the mod value is computed using a divide\n-         --  instruction which gives an overflow trap for this case.\n+         --  If we still have a mod operator and we are in Modify_Tree_For_C\n+         --  mode, and we have a signed integer type, then here is where we do\n+         --  the rewrite in terms of Rem. Note this rewrite bypasses the need\n+         --  for the special handling of the annoying case of largest negative\n+         --  number mod minus one.\n+\n+         if Nkind (N) = N_Op_Mod\n+           and then Is_Signed_Integer_Type (Typ)\n+           and then Modify_Tree_For_C\n+         then\n+            --  In the general case, we expand A mod B as\n+\n+            --    Tnn : constant typ := A rem B;\n+            --    ..\n+            --    (if (A >= 0) = (B >= 0) then Tnn\n+            --     elsif Tnn = 0 then 0\n+            --     else Tnn + B)\n+\n+            --  The comparison can be written simply as A >= 0 if we know that\n+            --  B >= 0 which is a very common case.\n+\n+            --  An important optimization is when B is known at compile time\n+            --  to be 2**K for some constant. In this case we can simply AND\n+            --  the left operand with the bit string 2**K-1 (i.e. K 1-bits)\n+            --  and that works for both the positive and negative cases.\n+\n+            declare\n+               P2 : constant Nat := Power_Of_Two (Right);\n+\n+            begin\n+               if P2 /= 0 then\n+                  Rewrite (N,\n+                    Unchecked_Convert_To (Typ,\n+                      Make_Op_And (Loc,\n+                        Left_Opnd  =>\n+                          Unchecked_Convert_To\n+                            (Corresponding_Unsigned_Type (Typ), Left),\n+                        Right_Opnd =>\n+                          Make_Integer_Literal (Loc, 2 ** P2 - 1))));\n+                  Analyze_And_Resolve (N, Typ);\n+                  return;\n+               end if;\n+            end;\n+\n+            --  Here for the full rewrite\n+\n+            declare\n+               Tnn : constant Entity_Id := Make_Temporary (Sloc (N), 'T', N);\n+               Cmp : Node_Id;\n+\n+            begin\n+               Cmp :=\n+                 Make_Op_Ge (Loc,\n+                   Left_Opnd  => Duplicate_Subexpr_No_Checks (Left),\n+                   Right_Opnd => Make_Integer_Literal (Loc, 0));\n+\n+               if not LOK or else Rlo < 0 then\n+                  Cmp :=\n+                     Make_Op_Eq (Loc,\n+                       Left_Opnd  => Cmp,\n+                       Right_Opnd =>\n+                         Make_Op_Ge (Loc,\n+                           Left_Opnd  => Duplicate_Subexpr_No_Checks (Right),\n+                           Right_Opnd => Make_Integer_Literal (Loc, 0)));\n+               end if;\n+\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Tnn,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                   Expression          =>\n+                     Make_Op_Rem (Loc,\n+                       Left_Opnd  => Left,\n+                       Right_Opnd => Right)));\n+\n+               Rewrite (N,\n+                 Make_If_Expression (Loc,\n+                   Expressions => New_List (\n+                     Cmp,\n+                     New_Occurrence_Of (Tnn, Loc),\n+                     Make_If_Expression (Loc,\n+                       Is_Elsif    => True,\n+                       Expressions => New_List (\n+                         Make_Op_Eq (Loc,\n+                           Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n+                           Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+                         Make_Integer_Literal (Loc, 0),\n+                         Make_Op_Add (Loc,\n+                           Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n+                           Right_Opnd =>\n+                             Duplicate_Subexpr_No_Checks (Right)))))));\n+\n+               Analyze_And_Resolve (N, Typ);\n+               return;\n+            end;\n+         end if;\n+\n+         --  Deal with annoying case of largest negative number mod minus one.\n+         --  Gigi may not handle this case correctly, because on some targets,\n+         --  the mod value is computed using a divide instruction which gives\n+         --  an overflow trap for this case.\n \n          --  It would be a bit more efficient to figure out which targets\n          --  this is really needed for, but in practice it is reasonable\n@@ -9225,65 +9331,6 @@ package body Exp_Ch4 is\n       Analyze_And_Resolve (N, Standard_Boolean);\n    end Expand_N_Quantified_Expression;\n \n-   ------------------------\n-   -- Expand_N_Reference --\n-   ------------------------\n-\n-   --  It is a little unclear why we generate references to expression values,\n-   --  but we definitely do! At the very least in Modify_Tree_For_C, we need to\n-   --  get rid of such constructs. We do this by expanding:\n-\n-   --    expression'Reference\n-\n-   --  into\n-\n-   --    Tnn : constant typ := expression;\n-   --    ...\n-   --    Tnn'Reference\n-\n-   procedure Expand_N_Reference (N : Node_Id) is\n-   begin\n-      --  No problem if Modify_Tree_For_C not set, the existing back ends will\n-      --  correctly handle P'Reference where P is a general expression.\n-\n-      if not Modify_Tree_For_C then\n-         return;\n-\n-      --  No problem if we have an entity name since we can take its address\n-\n-      elsif Is_Entity_Name (Prefix (N)) then\n-         return;\n-\n-      --  Can't go copying limited types\n-\n-      elsif Is_Limited_Record (Etype (Prefix (N)))\n-        or else Is_Limited_Composite (Etype (Prefix (N)))\n-      then\n-         return;\n-\n-      --  Here is the case where we do the transformation discussed above\n-\n-      else\n-         declare\n-            Loc  : constant Source_Ptr := Sloc (N);\n-            Expr : constant Node_Id    := Prefix (N);\n-            Typ  : constant Entity_Id  := Etype (N);\n-            Tnn  : constant Entity_Id  := Make_Temporary (Loc, 'T', Expr);\n-         begin\n-            Insert_Action (N,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Tnn,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Occurrence_Of (Etype (Expr), Loc),\n-                Expression          => Expr));\n-            Rewrite (N,\n-              Make_Reference (Loc,\n-                Prefix => New_Occurrence_Of (Tnn, Loc)));\n-            Analyze_And_Resolve (N, Typ);\n-         end;\n-      end if;\n-   end Expand_N_Reference;\n-\n    ---------------------------------\n    -- Expand_N_Selected_Component --\n    ---------------------------------"}, {"sha": "676aeb22588f5c1d0a0ea77c01cff4945c974b66", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -68,7 +68,6 @@ package Exp_Ch4 is\n    procedure Expand_N_Or_Else                     (N : Node_Id);\n    procedure Expand_N_Qualified_Expression        (N : Node_Id);\n    procedure Expand_N_Quantified_Expression       (N : Node_Id);\n-   procedure Expand_N_Reference                   (N : Node_Id);\n    procedure Expand_N_Selected_Component          (N : Node_Id);\n    procedure Expand_N_Slice                       (N : Node_Id);\n    procedure Expand_N_Type_Conversion             (N : Node_Id);"}, {"sha": "b3f6c1983ec152d07006846d46e4eb3152c10ed8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -6391,6 +6391,32 @@ package body Exp_Util is\n       end case;\n    end Process_Statements_For_Controlled_Objects;\n \n+   ------------------\n+   -- Power_Of_Two --\n+   ------------------\n+\n+   function Power_Of_Two (N : Node_Id) return Nat is\n+      Typ : constant Entity_Id := Etype (N);\n+      pragma Assert (Is_Integer_Type (Typ));\n+      Siz : constant Nat := UI_To_Int (Esize (Typ));\n+      Val : Uint;\n+\n+   begin\n+      if not Compile_Time_Known_Value (N) then\n+         return 0;\n+\n+      else\n+         Val := Expr_Value (N);\n+         for J in 1 .. Siz - 1 loop\n+            if Val = Uint_2 ** J then\n+               return J;\n+            end if;\n+         end loop;\n+\n+         return 0;\n+      end if;\n+   end Power_Of_Two;\n+\n    ----------------------\n    -- Remove_Init_Call --\n    ----------------------"}, {"sha": "808af9865822a31dfad814b8c001bc95cb644079", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -726,6 +726,12 @@ package Exp_Util is\n    --  causes trouble for the back end (see Component_May_Be_Bit_Aligned for\n    --  further details).\n \n+   function Power_Of_Two (N : Node_Id) return Nat;\n+   --  Determines if N is a known at compile time value which  is of the form\n+   --  2**K, where K is in the range 1 .. M, where the Esize of N is 2**(M+1).\n+   --  If so, returns the value K, otherwise returns zero. The caller checks\n+   --  that N is of an integer type.\n+\n    procedure Process_Statements_For_Controlled_Objects (N : Node_Id);\n    --  N is a node which contains a non-handled statement list. Inspect the\n    --  statements looking for declarations of controlled objects. If at least"}, {"sha": "9f57cda26a844eeaa2dbe244d2ac8b3c1a04171b", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -411,9 +411,6 @@ package body Expander is\n                   when N_Record_Representation_Clause =>\n                      Expand_N_Record_Representation_Clause (N);\n \n-                  when N_Reference =>\n-                     Expand_N_Reference (N);\n-\n                   when N_Requeue_Statement =>\n                      Expand_N_Requeue_Statement (N);\n "}, {"sha": "d3567cf7ff6fffbd927e997d603200aba7d6131e", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -14484,19 +14484,19 @@ uses the same switches as the GNAT compiler, with the same effects.\n \n @table @option\n @item ^-I^/SEARCH=^@var{dir}\n-@cindex @option{^-I^/SEARCH^} (@code{gnatpp})\n+@cindex @option{^-I^/SEARCH^} (@command{gnatpp})\n The same as the corresponding gcc switch\n \n @item ^-I-^/NOCURRENT_DIRECTORY^\n-@cindex @option{^-I-^/NOCURRENT_DIRECTORY^} (@code{gnatpp})\n+@cindex @option{^-I-^/NOCURRENT_DIRECTORY^} (@command{gnatpp})\n The same as the corresponding gcc switch\n \n @item ^-gnatec^/CONFIGURATION_PRAGMAS_FILE^=@var{path}\n-@cindex @option{^-gnatec^/CONFIGURATION_PRAGMAS_FILE^} (@code{gnatpp})\n+@cindex @option{^-gnatec^/CONFIGURATION_PRAGMAS_FILE^} (@command{gnatpp})\n The same as the corresponding gcc switch\n \n @item ^--RTS^/RUNTIME_SYSTEM^=@var{path}\n-@cindex @option{^--RTS^/RUNTIME_SYSTEM^} (@code{gnatpp})\n+@cindex @option{^--RTS^/RUNTIME_SYSTEM^} (@command{gnatpp})\n The same as the corresponding gcc switch\n \n @end table\n@@ -14515,7 +14515,7 @@ The output may be redirected by the following switches:\n \n @table @option\n @item ^-pipe^/STANDARD_OUTPUT^\n-@cindex @option{^-pipe^/STANDARD_OUTPUT^} (@code{gnatpp})\n+@cindex @option{^-pipe^/STANDARD_OUTPUT^} (@command{gnatpp})\n Send the output to @code{Standard_Output}\n \n @item ^-o @var{output_file}^/OUTPUT=@var{output_file}^\n@@ -14525,12 +14525,12 @@ If @var{output_file} already exists, @command{gnatpp} terminates without\n reading or processing the input file.\n \n @item ^-of ^/FORCED_OUTPUT=^@var{output_file}\n-@cindex @option{^-of^/FORCED_OUTPUT^} (@code{gnatpp})\n+@cindex @option{^-of^/FORCED_OUTPUT^} (@command{gnatpp})\n Write the output into @var{output_file}, overwriting the existing file\n (if one is present).\n \n @item ^-r^/REPLACE^\n-@cindex @option{^-r^/REPLACE^} (@code{gnatpp})\n+@cindex @option{^-r^/REPLACE^} (@command{gnatpp})\n Replace the input source file with the reformatted output, and copy the\n original input source into the file whose name is obtained by appending the\n ^@file{.npp}^@file{$NPP}^ suffix to the name of the input file.\n@@ -14543,7 +14543,7 @@ Like @option{^-r^/REPLACE^} except that if the file with the specified name\n already exists, it is overwritten.\n \n @item ^-rnb^/REPLACE_NO_BACKUP^\n-@cindex @option{^-rnb^/REPLACE_NO_BACKUP^} (@code{gnatpp})\n+@cindex @option{^-rnb^/REPLACE_NO_BACKUP^} (@command{gnatpp})\n Replace the input source file with the reformatted output without\n creating any backup copy of the input source.\n \n@@ -14644,6 +14644,9 @@ Use @var{n} processes to carry out the tree creations (internal representations\n of the argument sources). On a multiprocessor machine this speeds up processing\n of big sets of argument sources. If @var{n} is 0, then the maximum number of\n parallel tree creations is the number of core processors on the platform.\n+This option cannot be used together with @option{^-r^/REPLACE^},\n+@option{^-rf^/OVERRIDING_REPLACE^} or\n+@option{^-rnb^/REPLACE_NO_BACKUP^} option.\n \n @cindex @option{^-t^/TIME^} (@command{gnatpp})\n @item ^-t^/TIME^"}, {"sha": "ed4a677e1815241ccfc88f7523e162bb1202a7ad", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 150, "deletions": 55, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -4373,6 +4373,137 @@ package body Sem_Attr is\n       ---------\n \n       when Attribute_Old => Old : declare\n+         procedure Check_References_In_Prefix (Subp_Id : Entity_Id);\n+         --  Inspect the contents of the prefix and detect illegal uses of a\n+         --  nested 'Old, attribute 'Result or a use of an entity declared in\n+         --  the related postcondition expression. Subp_Id is the subprogram to\n+         --  which the related postcondition applies.\n+\n+         procedure Check_Use_In_Contract_Cases (Prag : Node_Id);\n+         --  Perform various semantic checks related to the placement of the\n+         --  attribute in pragma Contract_Cases.\n+\n+         procedure Check_Use_In_Test_Case (Prag : Node_Id);\n+         --  Perform various semantic checks related to the placement of the\n+         --  attribute in pragma Contract_Cases.\n+\n+         --------------------------------\n+         -- Check_References_In_Prefix --\n+         --------------------------------\n+\n+         procedure Check_References_In_Prefix (Subp_Id : Entity_Id) is\n+            function Check_Reference (Nod : Node_Id) return Traverse_Result;\n+            --  Detect attribute 'Old, attribute 'Result of a use of an entity\n+            --  and perform the appropriate semantic check.\n+\n+            ---------------------\n+            -- Check_Reference --\n+            ---------------------\n+\n+            function Check_Reference (Nod : Node_Id) return Traverse_Result is\n+            begin\n+               --  Attributes 'Old and 'Result cannot appear in the prefix of\n+               --  another attribute 'Old.\n+\n+               if Nkind (Nod) = N_Attribute_Reference\n+                 and then Nam_In (Attribute_Name (Nod), Name_Old,\n+                                                        Name_Result)\n+               then\n+                  Error_Msg_Name_1 := Attribute_Name (Nod);\n+                  Error_Msg_Name_2 := Name_Old;\n+                  Error_Msg_N\n+                    (\"attribute % cannot appear in the prefix of attribute %\",\n+                     Nod);\n+                  return Abandon;\n+\n+               --  Entities mentioned within the prefix of attribute 'Old must\n+               --  be global to the related postcondition. If this is not the\n+               --  case, then the scope of the local entity is be nested within\n+               --  that of the subprogram.\n+\n+               elsif Nkind (Nod) = N_Identifier\n+                 and then Present (Entity (Nod))\n+                 and then Scope_Within (Scope (Entity (Nod)), Subp_Id)\n+               then\n+                  Error_Attr\n+                    (\"prefix of attribute % cannot reference local entities\",\n+                     Nod);\n+                  return Abandon;\n+               else\n+                  return OK;\n+               end if;\n+            end Check_Reference;\n+\n+            procedure Check_References is new Traverse_Proc (Check_Reference);\n+\n+         --  Start of processing for Check_References_In_Prefix\n+\n+         begin\n+            Check_References (P);\n+         end Check_References_In_Prefix;\n+\n+         ---------------------------------\n+         -- Check_Use_In_Contract_Cases --\n+         ---------------------------------\n+\n+         procedure Check_Use_In_Contract_Cases (Prag : Node_Id) is\n+            Cases : constant Node_Id :=\n+                      Get_Pragma_Arg\n+                        (First (Pragma_Argument_Associations (Prag)));\n+            Expr  : Node_Id;\n+\n+         begin\n+            --  Climb the parent chain to reach the top of the expression where\n+            --  attribute 'Old resides.\n+\n+            Expr := N;\n+            while Parent (Parent (Expr)) /= Cases loop\n+               Expr := Parent (Expr);\n+            end loop;\n+\n+            --  Ensure that the obtained expression is the consequence of a\n+            --  contract case as this is the only postcondition-like part of\n+            --  the pragma.\n+\n+            if Expr /= Expression (Parent (Expr)) then\n+               Error_Attr\n+                 (\"attribute % cannot appear in the condition of a contract \"\n+                  & \"case (SPARK RM 6.1.3(2))\", P);\n+            end if;\n+         end Check_Use_In_Contract_Cases;\n+\n+         ----------------------------\n+         -- Check_Use_In_Test_Case --\n+         ----------------------------\n+\n+         procedure Check_Use_In_Test_Case (Prag : Node_Id) is\n+            Ensures : constant Node_Id := Get_Ensures_From_CTC_Pragma (Prag);\n+            Expr    : Node_Id;\n+\n+         begin\n+            --  Climb the parent chain to reach the top of the Ensures part of\n+            --  pragma Test_Case.\n+\n+            Expr := N;\n+            while Expr /= Prag loop\n+               if Expr = Ensures then\n+                  return;\n+               end if;\n+\n+               Expr := Parent (Expr);\n+            end loop;\n+\n+            --  If we get there, then attribute 'Old appears in the requires\n+            --  expression of pragma Test_Case which is not a postcondition-\n+            --  like context.\n+\n+            Error_Attr\n+              (\"attribute % cannot appear in the requires expression of a \"\n+               & \"test case\", P);\n+         end Check_Use_In_Test_Case;\n+\n+         --  Local variables\n+\n          CS : Entity_Id;\n          --  The enclosing scope, excluding loops for quantified expressions.\n          --  During analysis, it is the postcondition subprogram. During\n@@ -4381,6 +4512,8 @@ package body Sem_Attr is\n          Prag : Node_Id;\n          --  During pre-analysis, Prag is the enclosing pragma node if any\n \n+      --  Start of processing for Old\n+\n       begin\n          Prag := Empty;\n \n@@ -4391,19 +4524,17 @@ package body Sem_Attr is\n             CS := Scope (CS);\n          end loop;\n \n-         --  If we are in Spec_Expression mode, this should be the prescan of\n-         --  the postcondition (or contract case, or test case) pragma.\n+         --  A Contract_Cases, Postcondition or Test_Case pragma is in the\n+         --  process of being preanalyzed. Perform the semantic checks now\n+         --  before the pragma is relocated and/or expanded.\n \n          if In_Spec_Expression then\n-\n-            --  Check in postcondition, Test_Case or Contract_Cases\n-\n             Prag := N;\n             while Present (Prag)\n-               and then not Nkind_In (Prag, N_Pragma,\n+               and then not Nkind_In (Prag, N_Aspect_Specification,\n                                             N_Function_Specification,\n+                                            N_Pragma,\n                                             N_Procedure_Specification,\n-                                            N_Aspect_Specification,\n                                             N_Subprogram_Body)\n             loop\n                Prag := Parent (Prag);\n@@ -4416,64 +4547,25 @@ package body Sem_Attr is\n             if Nkind (Prag) = N_Aspect_Specification then\n                null;\n \n-            --  We must have a pragma\n+            --  In all other cases the related context must be a pragma\n \n             elsif Nkind (Prag) /= N_Pragma then\n                Error_Attr (\"% attribute can only appear in postcondition\", P);\n \n-            --  Processing depends on which pragma we have\n+            --  Verify the placement of the attribute with respect to the\n+            --  related pragma.\n \n             else\n                case Get_Pragma_Id (Prag) is\n-                  when Pragma_Test_Case =>\n-                     declare\n-                        Arg_Ens : constant Node_Id :=\n-                                    Get_Ensures_From_CTC_Pragma (Prag);\n-                        Arg     : Node_Id;\n-\n-                     begin\n-                        Arg := N;\n-                        while Arg /= Prag and then Arg /= Arg_Ens loop\n-                           Arg := Parent (Arg);\n-                        end loop;\n-\n-                        if Arg /= Arg_Ens then\n-                           Error_Attr\n-                             (\"% attribute misplaced inside test case\", P);\n-                        end if;\n-                     end;\n-\n                   when Pragma_Contract_Cases =>\n-                     declare\n-                        Aggr : constant Node_Id :=\n-                          Expression\n-                            (First (Pragma_Argument_Associations (Prag)));\n-                        Arg  : Node_Id;\n-\n-                     begin\n-                        Arg := N;\n-                        while Arg /= Prag\n-                          and then Parent (Parent (Arg)) /= Aggr\n-                        loop\n-                           Arg := Parent (Arg);\n-                        end loop;\n-\n-                        --  At this point, Parent (Arg) should be a component\n-                        --  association. Attribute Result is only allowed in\n-                        --  the expression part of this association.\n-\n-                        if Nkind (Parent (Arg)) /= N_Component_Association\n-                          or else Arg /= Expression (Parent (Arg))\n-                        then\n-                           Error_Attr\n-                             (\"% attribute misplaced inside contract cases\",\n-                              P);\n-                        end if;\n-                     end;\n+                     Check_Use_In_Contract_Cases (Prag);\n \n                   when Pragma_Postcondition | Pragma_Refined_Post =>\n                      null;\n \n+                  when Pragma_Test_Case =>\n+                     Check_Use_In_Test_Case (Prag);\n+\n                   when others =>\n                      Error_Attr\n                        (\"% attribute can only appear in postcondition\", P);\n@@ -4489,6 +4581,7 @@ package body Sem_Attr is\n \n          elsif not Expander_Active and then In_Refined_Post then\n             Preanalyze_And_Resolve (P);\n+            Check_References_In_Prefix (CS);\n             P_Type := Etype (P);\n             Set_Etype (N, P_Type);\n \n@@ -4548,6 +4641,7 @@ package body Sem_Attr is\n          --  place during expansion (see below).\n \n          Preanalyze_And_Resolve (P);\n+         Check_References_In_Prefix (CS);\n          P_Type := Etype (P);\n          Set_Etype (N, P_Type);\n \n@@ -4570,8 +4664,9 @@ package body Sem_Attr is\n            and then Is_Potentially_Unevaluated (N)\n            and then not Is_Entity_Name (P)\n          then\n-            Error_Attr_P (\"prefix of attribute % that is potentially \"\n-                 & \"unevaluated must denote an entity\");\n+            Error_Attr_P\n+              (\"prefix of attribute % that is potentially unevaluated must \"\n+               & \"denote an entity\");\n          end if;\n \n          --  The attribute appears within a pre/postcondition, but refers to"}, {"sha": "77ed9c2a225395f9ac7af8aa89c9320d99ccf9ce", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -35,6 +35,7 @@ with Einfo;  use Einfo;\n with Sinfo;  use Sinfo;\n with Snames; use Snames;\n with Stand;  use Stand;\n+with Uintp;  use Uintp;\n \n package body Sem_Aux is\n \n@@ -164,6 +165,29 @@ package body Sem_Aux is\n       end if;\n    end Constant_Value;\n \n+   ---------------------------------\n+   -- Corresponding_Unsigned_Type --\n+   ---------------------------------\n+\n+   function Corresponding_Unsigned_Type (Typ : Entity_Id) return Entity_Id is\n+      pragma Assert (Is_Signed_Integer_Type (Typ));\n+      Siz : constant Uint := Esize (Base_Type (Typ));\n+   begin\n+      if Siz = Esize (Standard_Short_Short_Integer) then\n+         return Standard_Short_Short_Unsigned;\n+      elsif Siz = Esize (Standard_Short_Integer) then\n+         return Standard_Short_Unsigned;\n+      elsif Siz = Esize (Standard_Unsigned) then\n+         return Standard_Unsigned;\n+      elsif Siz = Esize (Standard_Long_Integer) then\n+         return Standard_Long_Unsigned;\n+      elsif Siz = Esize (Standard_Long_Long_Integer) then\n+         return Standard_Long_Long_Unsigned;\n+      else\n+         raise Program_Error;\n+      end if;\n+   end Corresponding_Unsigned_Type;\n+\n    -----------------------------\n    -- Enclosing_Dynamic_Scope --\n    -----------------------------"}, {"sha": "f5b71ee22206bbb059b443532fd72ca029547c86", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -103,6 +103,11 @@ package Sem_Aux is\n    --  constants from the point of view of constant folding. Empty is also\n    --  returned for variables with no initialization expression.\n \n+   function Corresponding_Unsigned_Type (Typ : Entity_Id) return Entity_Id;\n+   --  Typ is a signed integer subtype. This routine returns the standard\n+   --  unsigned type with the same Esize as the implementation base type of\n+   --  Typ, e.g. Long_Integer => Long_Unsigned.\n+\n    function Enclosing_Dynamic_Scope (Ent : Entity_Id) return Entity_Id;\n    --  For any entity, Ent, returns the closest dynamic scope in which the\n    --  entity is declared or Standard_Standard for library-level entities."}, {"sha": "b09814f3ccd39c75d3d300493b373d161f09f0d0", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -888,10 +888,10 @@ package body Sem_Ch4 is\n          if In_Spec_Expression then\n             return;\n \n-         --  The ghost subprogram appears inside an assertion expression\n-         --  which is one of the allowed cases.\n+         --  The ghost subprogram appears inside an assertion expression which\n+         --  is one of the allowed cases.\n \n-         elsif In_Assertion_Expression (N) then\n+         elsif In_Assertion_Expression_Pragma (N) then\n             return;\n \n          --  Otherwise see if it inside another ghost subprogram\n@@ -1010,12 +1010,6 @@ package body Sem_Ch4 is\n          Check_Mixed_Parameter_And_Named_Associations;\n       end if;\n \n-      --  Mark a function that appears inside an assertion expression\n-\n-      if Nkind (N) = N_Function_Call and then In_Assertion_Expr > 0 then\n-         Set_In_Assertion_Expression (N);\n-      end if;\n-\n       --  Initialize the type of the result of the call to the error type,\n       --  which will be reset if the type is successfully resolved.\n "}, {"sha": "5ab711d52332dd7d136f3a5d975792c8fe288e3f", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -2292,8 +2292,9 @@ package body Sem_Elab is\n            --  within an assertion expression, since we can get false warnings\n            --  in this case, due to the out of order handling in this case.\n \n-           and then (Nkind (Original_Node (N)) /= N_Function_Call\n-                      or else not In_Assertion_Expression (Original_Node (N)))\n+           and then\n+             (Nkind (Original_Node (N)) /= N_Function_Call\n+               or else not In_Assertion_Expression_Pragma (Original_Node (N)))\n          then\n             Error_Msg_Warn := SPARK_Mode /= On;\n "}, {"sha": "354886dc868f5172a81638f8632cbb081cad9383", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -33,6 +33,32 @@ with Types;  use Types;\n \n package Sem_Prag is\n \n+   --  The following table lists all pragmas that act as an assertion\n+   --  expression.\n+\n+   Assertion_Expression_Pragma : constant array (Pragma_Id) of Boolean :=\n+     (Pragma_Assert               => True,\n+      Pragma_Assert_And_Cut       => True,\n+      Pragma_Assume               => True,\n+      Pragma_Check                => True,\n+      Pragma_Contract_Cases       => True,\n+      Pragma_Initial_Condition    => True,\n+      Pragma_Invariant            => True,\n+      Pragma_Loop_Invariant       => True,\n+      Pragma_Loop_Variant         => True,\n+      Pragma_Post                 => True,\n+      Pragma_Post_Class           => True,\n+      Pragma_Postcondition        => True,\n+      Pragma_Pre                  => True,\n+      Pragma_Pre_Class            => True,\n+      Pragma_Precondition         => True,\n+      Pragma_Predicate            => True,\n+      Pragma_Refined_Post         => True,\n+      Pragma_Test_Case            => True,\n+      Pragma_Type_Invariant       => True,\n+      Pragma_Type_Invariant_Class => True,\n+      others                      => False);\n+\n    --  The following table lists all the implementation-defined pragmas that\n    --  may apply to a body stub (no language defined pragmas apply). The table\n    --  should be synchronized with Aspect_On_Body_Or_Stub_OK in unit Aspects if"}, {"sha": "37e0877a2ba6a5bff165a16d2b72a397c017f8ed", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -51,6 +51,7 @@ with Sem_Attr; use Sem_Attr;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sinfo;    use Sinfo;\n@@ -8325,6 +8326,44 @@ package body Sem_Util is\n       return False;\n    end Implements_Interface;\n \n+   ------------------------------------\n+   -- In_Assertion_Expression_Pragma --\n+   ------------------------------------\n+\n+   function In_Assertion_Expression_Pragma (N : Node_Id) return Boolean is\n+      Par  : Node_Id;\n+      Prag : Node_Id := Empty;\n+\n+   begin\n+      --  Climb the parent chain looking for an enclosing pragma\n+\n+      Par := N;\n+      while Present (Par) loop\n+         if Nkind (Par) = N_Pragma then\n+            Prag := Par;\n+            exit;\n+\n+         --  Precondition-like pragmas are expanded into if statements, check\n+         --  the original node instead.\n+\n+         elsif Nkind (Original_Node (Par)) = N_Pragma then\n+            Prag := Original_Node (Par);\n+            exit;\n+\n+         --  Prevent the search from going too far\n+\n+         elsif Is_Body_Or_Package_Declaration (Par) then\n+            return False;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      return\n+        Present (Prag)\n+          and then Assertion_Expression_Pragma (Get_Pragma_Id (Prag));\n+   end In_Assertion_Expression_Pragma;\n+\n    -----------------\n    -- In_Instance --\n    -----------------\n@@ -10537,11 +10576,11 @@ package body Sem_Util is\n       Expr := N;\n       Par  := Parent (N);\n       while not Nkind_In (Par, N_If_Expression,\n-                                N_Case_Expression,\n-                                N_And_Then,\n-                                N_Or_Else,\n-                                N_In,\n-                                N_Not_In)\n+                               N_Case_Expression,\n+                               N_And_Then,\n+                               N_Or_Else,\n+                               N_In,\n+                               N_Not_In)\n       loop\n          Expr := Par;\n          Par  := Parent (Par);"}, {"sha": "d8dfaaaeb5dd50ab49b271febd5b2b53ede0c62f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -999,6 +999,10 @@ package Sem_Util is\n       Exclude_Parents : Boolean := False) return Boolean;\n    --  Returns true if the Typ_Ent implements interface Iface_Ent\n \n+   function In_Assertion_Expression_Pragma (N : Node_Id) return Boolean;\n+   --  Determine whether an arbitrary node appears in a pragma that acts as an\n+   --  assertion expression. See Sem_Prag for the list of qualifying pragmas.\n+\n    function In_Instance return Boolean;\n    --  Returns True if the current scope is within a generic instance\n "}, {"sha": "6140e676e48695e530861e55ac69e307ba5ad243", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -1679,14 +1679,6 @@ package body Sinfo is\n       return Flag16 (N);\n    end Import_Interface_Present;\n \n-   function In_Assertion_Expression\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Function_Call);\n-      return Flag4 (N);\n-   end In_Assertion_Expression;\n-\n    function In_Present\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4819,14 +4811,6 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Import_Interface_Present;\n \n-   procedure Set_In_Assertion_Expression\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Function_Call);\n-      Set_Flag4 (N, Val);\n-   end Set_In_Assertion_Expression;\n-\n    procedure Set_In_Present\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "d3c3608ebbeec78a719a0db378d2c4da7c91fd67", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -1402,11 +1402,6 @@ package Sinfo is\n    --     pragma of the other kind is also present. This is used to avoid\n    --     generating some unwanted error messages.\n \n-   --  In_Assertion_Expression (Flag4-Sem)\n-   --     This flag is present in N_Function_Call nodes. It is set if the\n-   --     function is called from within an assertion expression. This is\n-   --     used to avoid some bogus warnings about early elaboration.\n-\n    --  Includes_Infinities (Flag11-Sem)\n    --    This flag is present in N_Range nodes. It is set for the range of\n    --    unconstrained float types defined in Standard, which include not only\n@@ -5036,7 +5031,6 @@ package Sinfo is\n       --   actual parameter part)\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n-      --  In_Assertion_Expression (Flag4-Sem)\n       --  Is_Expanded_Build_In_Place_Call (Flag11-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n       --  No_Elaboration_Check (Flag14-Sem)\n@@ -8986,9 +8980,6 @@ package Sinfo is\n    function Import_Interface_Present\n      (N : Node_Id) return Boolean;    -- Flag16\n \n-   function In_Assertion_Expression\n-     (N : Node_Id) return Boolean;    -- Flag4\n-\n    function In_Present\n      (N : Node_Id) return Boolean;    -- Flag15\n \n@@ -9985,9 +9976,6 @@ package Sinfo is\n    procedure Set_Import_Interface_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n-   procedure Set_In_Assertion_Expression\n-     (N : Node_Id; Val : Boolean := True);    -- Flag4\n-\n    procedure Set_In_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n@@ -12393,7 +12381,6 @@ package Sinfo is\n    pragma Inline (Interface_Present);\n    pragma Inline (Includes_Infinities);\n    pragma Inline (Import_Interface_Present);\n-   pragma Inline (In_Assertion_Expression);\n    pragma Inline (In_Present);\n    pragma Inline (Inherited_Discriminant);\n    pragma Inline (Instance_Spec);\n@@ -12719,7 +12706,6 @@ package Sinfo is\n    pragma Inline (Set_Identifier);\n    pragma Inline (Set_Implicit_With);\n    pragma Inline (Set_Import_Interface_Present);\n-   pragma Inline (Set_In_Assertion_Expression);\n    pragma Inline (Set_In_Present);\n    pragma Inline (Set_Includes_Infinities);\n    pragma Inline (Set_Inherited_Discriminant);"}, {"sha": "3ce891e19fa2b24f73f799e4caa832a801da4b49", "filename": "gcc/ada/stand.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.adb?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -70,6 +70,12 @@ package body Stand is\n       Tree_Read_Int (Int (Standard_Integer_16));\n       Tree_Read_Int (Int (Standard_Integer_32));\n       Tree_Read_Int (Int (Standard_Integer_64));\n+      Tree_Read_Int (Int (Standard_Unsigned_64));\n+      Tree_Read_Int (Int (Standard_Short_Short_Unsigned));\n+      Tree_Read_Int (Int (Standard_Short_Unsigned));\n+      Tree_Read_Int (Int (Standard_Unsigned));\n+      Tree_Read_Int (Int (Standard_Long_Unsigned));\n+      Tree_Read_Int (Int (Standard_Long_Long_Unsigned));\n       Tree_Read_Int (Int (Abort_Signal));\n       Tree_Read_Int (Int (Standard_Op_Rotate_Left));\n       Tree_Read_Int (Int (Standard_Op_Rotate_Right));\n@@ -114,6 +120,12 @@ package body Stand is\n       Tree_Write_Int (Int (Standard_Integer_16));\n       Tree_Write_Int (Int (Standard_Integer_32));\n       Tree_Write_Int (Int (Standard_Integer_64));\n+      Tree_Write_Int (Int (Standard_Unsigned_64));\n+      Tree_Write_Int (Int (Standard_Short_Short_Unsigned));\n+      Tree_Write_Int (Int (Standard_Short_Unsigned));\n+      Tree_Write_Int (Int (Standard_Unsigned));\n+      Tree_Write_Int (Int (Standard_Long_Unsigned));\n+      Tree_Write_Int (Int (Standard_Long_Long_Unsigned));\n       Tree_Write_Int (Int (Abort_Signal));\n       Tree_Write_Int (Int (Standard_Op_Rotate_Left));\n       Tree_Write_Int (Int (Standard_Op_Rotate_Right));"}, {"sha": "555c2fc5c4bf0d87ee58f225e50d9aa514d99393", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=2c9f8c0afa20c14e19ecb3dc760bc4cdfe1ee66e", "patch": "@@ -454,8 +454,12 @@ package Stand is\n    --  These are signed integer types with the indicated sizes. Used for the\n    --  underlying implementation types for fixed-point and enumeration types.\n \n-   Standard_Unsigned : Entity_Id;\n-   --  An unsigned type of the same size as Standard_Integer\n+   Standard_Short_Short_Unsigned : Entity_Id;\n+   Standard_Short_Unsigned       : Entity_Id;\n+   Standard_Unsigned             : Entity_Id;\n+   Standard_Long_Unsigned        : Entity_Id;\n+   Standard_Long_Long_Unsigned   : Entity_Id;\n+   --  Unsigned types with same Esize as corresponding signed integer types\n \n    Standard_Unsigned_64 : Entity_Id;\n    --  An unsigned type, mod 2 ** 64, size of 64 bits."}]}