{"sha": "3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y5N2NiMGIyNzhkNTliODkyM2QwYjEwZWRmZDYwZDM1N2RjNTVhNw==", "commit": {"author": {"name": "Alexander Ivchenko", "email": "alexander.ivchenko@intel.com", "date": "2013-08-22T06:06:03Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-08-22T06:06:03Z"}, "message": "i386-common.c (OPTION_MASK_ISA_AVX512F_SET): New.\n\n* common/config/i386/i386-common.c (OPTION_MASK_ISA_AVX512F_SET): New.\n(OPTION_MASK_ISA_AVX512CD_SET): Ditto.\n(OPTION_MASK_ISA_AVX512PF_SET): Ditto.\n(OPTION_MASK_ISA_AVX512ER_SET): Ditto.\n(OPTION_MASK_ISA_AVX2_UNSET): Update.\n(OPTION_MASK_ISA_AVX512F_UNSET): New.\n(OPTION_MASK_ISA_AVX512CD_UNSET): Ditto.\n(OPTION_MASK_ISA_AVX512PF_UNSET): Ditto.\n(OPTION_MASK_ISA_AVX512ER_UNSET): Ditto.\n(ix86_handle_option): Handle OPT_mavx512f, OPT_mavx512cd,\nOPT_mavx512pf, OPT_mavx512er cases.\n* config/i386/constraints.md (v): New constraint.\n(Yi, Yj): Replace SSE_REGS with ALL_SSE_REGS.\n* config/i386/cpuid.h (bit_AVX512F, bit_AVX512PF, bit_AVX512ER)\n(bit_AVX512CD): New.\n* config/i386/driver-i386.c (host_detect_local_cpu): Detect\nAVX512F, AVX512ER, AVX512PF, AVX512CD features.\n* config/i386/i386-c.c (ix86_target_macros_internal):\nConditionally define __AVX512F__, __AVX512ER__, __AVX512CD__,\n__AVX512PF__.\n* config/i386/i386-modes.def (VECTOR_MODES (INT, 128))\n(VECTOR_MODES (FLOAT, 128), INT_MODE (XI, 64)): New modes.\n* config/i386/i386.c (regclass_map, dbx_register_map)\n(dbx64_register_map, svr4_dbx_register_map): Add new SSE registers.\n(gate_insert_vzeroupper): Disable vzeroupper for TARGET_AVX512F.\n(ix86_target_string): Define -mavx512f, -mavx512er, -mavx512cd,\n-mavx512pf options.\n(ix86_option_override_internal): Define PTA_AVX512F, PTA_AVX512ER,\nPTA_AVX512PF, PTA_AVX512CD.  Handle -mavx512f, -mavx512er, -mavx512cd,\n-mavx512pf options.  Fix formatting.\n(ix86_conditional_register_usage): Squash EXT_REX_SSE_REGs for 32-bit\ntargets.  Squash EVEX_SSE_REGS if AVX512F is disabled.\n(ix86_valid_target_attribute_inner_p): Handle -mavx512f, -mavx512er,\n-mavx512cd, -mavx512pf options.\n(standard_sse_constant_opcode): Add vpternlogd for 512-bit modes.\n(print_reg, ix86_print_operand): Handle 'g' to output 512-bit operands.\n(ix86_preferred_output_reload_class): Replace SSE_REGS with\nALL_SSE_REGS.\n(ix86_hard_regno_mode_ok): Support 512-bit registers.\n(ix86_set_reg_reg_cost): Ditto.\n(x86_order_regs_for_local_alloc): Ditto.\n(MAX_VECT_LEN): Extend to 64-byte.\n(ix86_spill_class): Replace SSE_REGS with ALL_SSE_REGS.\n* config/i386/i386.h (TARGET_AVX512F, TARGET_AVX512PF)\n(TARGET_AVX512ER, TARGET_AVX512CD): New.\n(BIGGEST_ALIGNMENT): Extend to 512-bits.\n(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS): Add new registers.\n(CALL_USED_REGISTERS, REG_ALLOC_ORDER): Likewise.\n(VALID_AVX512F_SCALAR_MODE, VALID_AVX512F_REG_MODE): New.\n(SSE_REG_MODE_P): Support new modes.\n(FIRST_MMX_REG, FIRST_REX_INT_REG, FIRST_REX_SSE_REG): Add comments.\n(FIRST_EXT_REX_SSE_REG, LAST_EXT_REX_SSE_REG): New.\n(reg_class, REG_CLASS_NAMES): Add EVEX_SSE_REGS, ALL_SSE_REGS.\n(SSE_CLASS_P, MAYBE_SSE_CLASS_P): Replace SSE_REGS with ALL_SSE_REGS.\n(REG_CLASS_CONTENTS): Add new registers.\n(SSE_REGNO_P, SSE_REGNO, HARD_REGNO_RENAME_OK): Support new registers.\n(EXT_REX_SSE_REGNO_P): New.\n(HI_REGISTER_NAMES): Add new registers.\n* config/i386/i386.md: Define constants for new registers.\n(mode): Add new 512-bit modes.\n(prefix): Support evex prefix.\n(isa): Support avx512f, noavx512f, fma_avx512f.\n(ssemodesuffix): Add new 512-bit modes.\n(movxi): New.\n(*movxi_internal_avx512f): Ditto.\n(*movdi_internal): Replace constraint \"x\" with the new constraint \"v\".\nSupport MODE_XI.\n(*movsi_internal): Likewise.\n(*movdf_internal): Likewise.\n(*movsf_internal): Likewise.\n(*fop_<mode>_comm_sse): Replace constraint \"x\" with new constraint \"v\".\n(<code><mode>3): Likewise.\n* config/i386/i386.opt (mavx512f, mavx512pf, mavx512er, mavx512cd): New.\n* config/i386/mmx.md (*mov<mode>_internal): Replace constraint \"x\"\nwith the new constraint \"v\".\n* config/i386/sse.md (*mov<mode>_internal): Support new registers and\nmodes.\n(<sse>_loadu<ssemodesuffix><avxsizesuffix>): Replace constraint \"x\"\nwith the new constraint \"v\".\n(<sse2>_loaddqu<avxsizesuffix>): Likewise.\n(<sse2>_storedqu<avxsizesuffix>): Likewise.\n(*<plusminus_insn><mode>3): Likewise.\n(<sse>_vm<plusminus_insn><mode>3): Likewise.\n(*mul<mode>3): Likewise.\n(<sse>_vmmul<mode>3): Likewise.\n(<sse>_div<mode>3): Likewise.\n(<sse>_vmdiv<mode>3): Likewise.\n(<sse>_sqrt<mode>2): Likewise.\n(<sse>_vmsqrt<mode>2): Likewise.\n(*<code><mode>3_finite): Likewise.\n(*<code><mode>3) <smaxmin>: Likewise.\n(<sse>_vm<code><mode>3): Likewise.\n(*<code><mode>3) <any_logic>: Likewise.\n(*fma_fmadd_<mode>): Likewise.\n(*fma_fmsub_<mode>): Likewise.\n(*fma_fnmadd_<mode>): Likewise.\n(*fma_fnmsub_<mode>): Likewise.\n(*fma_fmaddsub_<mode>): Likewise.\n(*fma_fmsubadd_<mode>): Likewise.\n(*fmai_fmadd_<mode>): Likewise.\n(*fmai_fmsub_<mode>): Likewise.\n(*fmai_fnmadd_<mode>): Likewise.\n(*fmai_fnmsub_<mode>): Likewise.\n(sse_cvtsi2ss): Likewise.\n(sse_cvtsi2ssq): Likewise.\n(sse_cvtss2si): Likewise.\n(sse_cvtss2si_2): Likewise.\n(sse_cvtss2siq): Likewise.\n(sse_cvtss2siq_2): Likewise.\n(sse_cvttss2si): Likewise.\n(sse_cvtss2siq_2): Likewise.\n(float<sseintvecmodelower><mode>2): Likewise.\n(sse2_cvtsd2si_2): Likewise.\n(sse2_cvtsd2siq_2): Likewise.\n(*<plusminus_insn><mode>3): Likewise.\n(*<sse2_avx2>_<plusminus_insn><mode>3): Likewise.\n(*<sse4_1_avx2>_mul<mode>3): Likewise.\n(ashr<mode>3): Likewise.\n(<shift_insn><mode>3): Likewise.\n(avx2_<code><mode>3): Likewise.\n(*avx2_<code><mode>3): Likewise.\n(*andnot<mode>3): Likewise.\n(*<code><mode>3) <any_logic>: Likewise.\n(abs<mode>2): Likewise.\n(avx2_permvar<mode>): Likewise.\n(avx2_perm<mode>_1): Likewise.\n(*avx_vpermilp<mode>): Likewise.\n(avx_vpermilvar<mode>3): Likewise.\n(avx2_ashrv<mode>): Likewise.\n(avx2_<shift_insn>v<mode>): Likewise.\n* doc/invoke.texi: Document -mavx512f, -mavx512pf, -mavx512er,\n-mavx512cd.\n* doc/rtl.texi: Document XImode.\n\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Anna Tikhonova <anna.tikhonova@intel.com>\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Maxim Kuznetsov <maxim.kuznetsov@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\nCo-Authored-By: Sergey Lega <sergey.s.lega@intel.com>\n\nFrom-SVN: r201915", "tree": {"sha": "27578b75db34951d6bd28838e71fdcb5d25a2270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27578b75db34951d6bd28838e71fdcb5d25a2270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/comments", "author": null, "committer": null, "parents": [{"sha": "1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b488e33b66845b5eb1ac0dbff934fc2d8f75890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b488e33b66845b5eb1ac0dbff934fc2d8f75890"}], "stats": {"total": 1048, "additions": 808, "deletions": 240}, "files": [{"sha": "864645ab24fbaa0aef5680795acacf48c800ae04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -1,3 +1,147 @@\n+2013-08-22  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n+\t    Sergey Lega  <sergey.s.lega@intel.com>\n+\t    Anna Tikhonova  <anna.tikhonova@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* common/config/i386/i386-common.c (OPTION_MASK_ISA_AVX512F_SET): New.\n+\t(OPTION_MASK_ISA_AVX512CD_SET): Ditto.\n+\t(OPTION_MASK_ISA_AVX512PF_SET): Ditto.\n+\t(OPTION_MASK_ISA_AVX512ER_SET): Ditto.\n+\t(OPTION_MASK_ISA_AVX2_UNSET): Update.\n+\t(OPTION_MASK_ISA_AVX512F_UNSET): New.\n+\t(OPTION_MASK_ISA_AVX512CD_UNSET): Ditto.\n+\t(OPTION_MASK_ISA_AVX512PF_UNSET): Ditto.\n+\t(OPTION_MASK_ISA_AVX512ER_UNSET): Ditto.\n+\t(ix86_handle_option): Handle OPT_mavx512f, OPT_mavx512cd,\n+\tOPT_mavx512pf, OPT_mavx512er cases.\n+\t* config/i386/constraints.md (v): New constraint.\n+\t(Yi, Yj): Replace SSE_REGS with ALL_SSE_REGS.\n+\t* config/i386/cpuid.h (bit_AVX512F, bit_AVX512PF, bit_AVX512ER)\n+\t(bit_AVX512CD): New.\n+\t* config/i386/driver-i386.c (host_detect_local_cpu): Detect\n+\tAVX512F, AVX512ER, AVX512PF, AVX512CD features.\n+\t* config/i386/i386-c.c (ix86_target_macros_internal):\n+\tConditionally define __AVX512F__, __AVX512ER__, __AVX512CD__,\n+\t__AVX512PF__.\n+\t* config/i386/i386-modes.def (VECTOR_MODES (INT, 128))\n+\t(VECTOR_MODES (FLOAT, 128), INT_MODE (XI, 64)): New modes.\n+\t* config/i386/i386.c (regclass_map, dbx_register_map)\n+\t(dbx64_register_map, svr4_dbx_register_map): Add new SSE registers.\n+\t(gate_insert_vzeroupper): Disable vzeroupper for TARGET_AVX512F.\n+\t(ix86_target_string): Define -mavx512f, -mavx512er, -mavx512cd,\n+\t-mavx512pf options.\n+\t(ix86_option_override_internal): Define PTA_AVX512F, PTA_AVX512ER,\n+\tPTA_AVX512PF, PTA_AVX512CD.  Handle -mavx512f, -mavx512er, -mavx512cd,\n+\t-mavx512pf options.  Fix formatting.\n+\t(ix86_conditional_register_usage): Squash EXT_REX_SSE_REGs for 32-bit\n+\ttargets.  Squash EVEX_SSE_REGS if AVX512F is disabled.\n+\t(ix86_valid_target_attribute_inner_p): Handle -mavx512f, -mavx512er,\n+\t-mavx512cd, -mavx512pf options.\n+\t(standard_sse_constant_opcode): Add vpternlogd for 512-bit modes.\n+\t(print_reg, ix86_print_operand): Handle 'g' to output 512-bit operands.\n+\t(ix86_preferred_output_reload_class): Replace SSE_REGS with\n+\tALL_SSE_REGS.\n+\t(ix86_hard_regno_mode_ok): Support 512-bit registers.\n+\t(ix86_set_reg_reg_cost): Ditto.\n+\t(x86_order_regs_for_local_alloc): Ditto.\n+\t(MAX_VECT_LEN): Extend to 64-byte.\n+\t(ix86_spill_class): Replace SSE_REGS with ALL_SSE_REGS.\n+\t* config/i386/i386.h (TARGET_AVX512F, TARGET_AVX512PF)\n+\t(TARGET_AVX512ER, TARGET_AVX512CD): New.\n+\t(BIGGEST_ALIGNMENT): Extend to 512-bits.\n+\t(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS): Add new registers.\n+\t(CALL_USED_REGISTERS, REG_ALLOC_ORDER): Likewise.\n+\t(VALID_AVX512F_SCALAR_MODE, VALID_AVX512F_REG_MODE): New.\n+\t(SSE_REG_MODE_P): Support new modes.\n+\t(FIRST_MMX_REG, FIRST_REX_INT_REG, FIRST_REX_SSE_REG): Add comments.\n+\t(FIRST_EXT_REX_SSE_REG, LAST_EXT_REX_SSE_REG): New.\n+\t(reg_class, REG_CLASS_NAMES): Add EVEX_SSE_REGS, ALL_SSE_REGS.\n+\t(SSE_CLASS_P, MAYBE_SSE_CLASS_P): Replace SSE_REGS with ALL_SSE_REGS.\n+\t(REG_CLASS_CONTENTS): Add new registers.\n+\t(SSE_REGNO_P, SSE_REGNO, HARD_REGNO_RENAME_OK): Support new registers.\n+\t(EXT_REX_SSE_REGNO_P): New.\n+\t(HI_REGISTER_NAMES): Add new registers.\n+\t* config/i386/i386.md: Define constants for new registers.\n+\t(mode): Add new 512-bit modes.\n+\t(prefix): Support evex prefix.\n+\t(isa): Support avx512f, noavx512f, fma_avx512f.\n+\t(ssemodesuffix): Add new 512-bit modes.\n+\t(movxi): New.\n+\t(*movxi_internal_avx512f): Ditto.\n+\t(*movdi_internal): Replace constraint \"x\" with the new constraint \"v\".\n+\tSupport MODE_XI.\n+\t(*movsi_internal): Likewise.\n+\t(*movdf_internal): Likewise.\n+\t(*movsf_internal): Likewise.\n+\t(*fop_<mode>_comm_sse): Replace constraint \"x\" with new constraint \"v\".\n+\t(<code><mode>3): Likewise.\n+\t* config/i386/i386.opt (mavx512f, mavx512pf, mavx512er, mavx512cd): New.\n+\t* config/i386/mmx.md (*mov<mode>_internal): Replace constraint \"x\"\n+\twith the new constraint \"v\".\n+\t* config/i386/sse.md (*mov<mode>_internal): Support new registers and\n+\tmodes.\n+\t(<sse>_loadu<ssemodesuffix><avxsizesuffix>): Replace constraint \"x\"\n+\twith the new constraint \"v\".\n+\t(<sse2>_loaddqu<avxsizesuffix>): Likewise.\n+\t(<sse2>_storedqu<avxsizesuffix>): Likewise.\n+\t(*<plusminus_insn><mode>3): Likewise.\n+\t(<sse>_vm<plusminus_insn><mode>3): Likewise.\n+\t(*mul<mode>3): Likewise.\n+\t(<sse>_vmmul<mode>3): Likewise.\n+\t(<sse>_div<mode>3): Likewise.\n+\t(<sse>_vmdiv<mode>3): Likewise.\n+\t(<sse>_sqrt<mode>2): Likewise.\n+\t(<sse>_vmsqrt<mode>2): Likewise.\n+\t(*<code><mode>3_finite): Likewise.\n+\t(*<code><mode>3) <smaxmin>: Likewise.\n+\t(<sse>_vm<code><mode>3): Likewise.\n+\t(*<code><mode>3) <any_logic>: Likewise.\n+\t(*fma_fmadd_<mode>): Likewise.\n+\t(*fma_fmsub_<mode>): Likewise.\n+\t(*fma_fnmadd_<mode>): Likewise.\n+\t(*fma_fnmsub_<mode>): Likewise.\n+\t(*fma_fmaddsub_<mode>): Likewise.\n+\t(*fma_fmsubadd_<mode>): Likewise.\n+\t(*fmai_fmadd_<mode>): Likewise.\n+\t(*fmai_fmsub_<mode>): Likewise.\n+\t(*fmai_fnmadd_<mode>): Likewise.\n+\t(*fmai_fnmsub_<mode>): Likewise.\n+\t(sse_cvtsi2ss): Likewise.\n+\t(sse_cvtsi2ssq): Likewise.\n+\t(sse_cvtss2si): Likewise.\n+\t(sse_cvtss2si_2): Likewise.\n+\t(sse_cvtss2siq): Likewise.\n+\t(sse_cvtss2siq_2): Likewise.\n+\t(sse_cvttss2si): Likewise.\n+\t(sse_cvtss2siq_2): Likewise.\n+\t(float<sseintvecmodelower><mode>2): Likewise.\n+\t(sse2_cvtsd2si_2): Likewise.\n+\t(sse2_cvtsd2siq_2): Likewise.\n+\t(*<plusminus_insn><mode>3): Likewise.\n+\t(*<sse2_avx2>_<plusminus_insn><mode>3): Likewise.\n+\t(*<sse4_1_avx2>_mul<mode>3): Likewise.\n+\t(ashr<mode>3): Likewise.\n+\t(<shift_insn><mode>3): Likewise.\n+\t(avx2_<code><mode>3): Likewise.\n+\t(*avx2_<code><mode>3): Likewise.\n+\t(*andnot<mode>3): Likewise.\n+\t(*<code><mode>3) <any_logic>: Likewise.\n+\t(abs<mode>2): Likewise.\n+\t(avx2_permvar<mode>): Likewise.\n+\t(avx2_perm<mode>_1): Likewise.\n+\t(*avx_vpermilp<mode>): Likewise.\n+\t(avx_vpermilvar<mode>3): Likewise.\n+\t(avx2_ashrv<mode>): Likewise.\n+\t(avx2_<shift_insn>v<mode>): Likewise.\n+\t* doc/invoke.texi: Document -mavx512f, -mavx512pf, -mavx512er,\n+\t-mavx512cd.\n+\t* doc/rtl.texi: Document XImode.\n+\n 2013-08-21  Jeff Law  <law@redhat.com>\n \n \t* tree-flow.h (register_jump_thread): Pass vector of edges"}, {"sha": "8ca74b9be494bed542f7099fda4adfc94c9962b4", "filename": "gcc/common/config/i386/i386-common.c", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fi386-common.c?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -57,6 +57,14 @@ along with GCC; see the file COPYING3.  If not see\n #define OPTION_MASK_ISA_XSAVE_SET OPTION_MASK_ISA_XSAVE\n #define OPTION_MASK_ISA_XSAVEOPT_SET \\\n   (OPTION_MASK_ISA_XSAVEOPT | OPTION_MASK_ISA_XSAVE)\n+#define OPTION_MASK_ISA_AVX512F_SET \\\n+  (OPTION_MASK_ISA_AVX512F | OPTION_MASK_ISA_AVX2_SET)\n+#define OPTION_MASK_ISA_AVX512CD_SET \\\n+  (OPTION_MASK_ISA_AVX512CD | OPTION_MASK_ISA_AVX512F_SET)\n+#define OPTION_MASK_ISA_AVX512PF_SET \\\n+  (OPTION_MASK_ISA_AVX512PF | OPTION_MASK_ISA_AVX512F_SET)\n+#define OPTION_MASK_ISA_AVX512ER_SET \\\n+  (OPTION_MASK_ISA_AVX512ER | OPTION_MASK_ISA_AVX512F_SET)\n #define OPTION_MASK_ISA_RTM_SET OPTION_MASK_ISA_RTM\n #define OPTION_MASK_ISA_PRFCHW_SET OPTION_MASK_ISA_PRFCHW\n #define OPTION_MASK_ISA_RDSEED_SET OPTION_MASK_ISA_RDSEED\n@@ -128,11 +136,18 @@ along with GCC; see the file COPYING3.  If not see\n    | OPTION_MASK_ISA_FMA4_UNSET | OPTION_MASK_ISA_F16C_UNSET \\\n    | OPTION_MASK_ISA_AVX2_UNSET | OPTION_MASK_ISA_XSAVE_UNSET)\n #define OPTION_MASK_ISA_FMA_UNSET OPTION_MASK_ISA_FMA\n-#define OPTION_MASK_ISA_AVX2_UNSET OPTION_MASK_ISA_AVX2\n #define OPTION_MASK_ISA_FXSR_UNSET OPTION_MASK_ISA_FXSR\n #define OPTION_MASK_ISA_XSAVE_UNSET \\\n   (OPTION_MASK_ISA_XSAVE | OPTION_MASK_ISA_XSAVEOPT_UNSET)\n #define OPTION_MASK_ISA_XSAVEOPT_UNSET OPTION_MASK_ISA_XSAVEOPT\n+#define OPTION_MASK_ISA_AVX2_UNSET \\\n+  (OPTION_MASK_ISA_AVX2 | OPTION_MASK_ISA_AVX512F_UNSET)\n+#define OPTION_MASK_ISA_AVX512F_UNSET \\\n+  (OPTION_MASK_ISA_AVX512F | OPTION_MASK_ISA_AVX512CD_UNSET \\\n+   | OPTION_MASK_ISA_AVX512PF_UNSET | OPTION_MASK_ISA_AVX512ER_UNSET)\n+#define OPTION_MASK_ISA_AVX512CD_UNSET OPTION_MASK_ISA_AVX512CD\n+#define OPTION_MASK_ISA_AVX512PF_UNSET OPTION_MASK_ISA_AVX512PF\n+#define OPTION_MASK_ISA_AVX512ER_UNSET OPTION_MASK_ISA_AVX512ER\n #define OPTION_MASK_ISA_RTM_UNSET OPTION_MASK_ISA_RTM\n #define OPTION_MASK_ISA_PRFCHW_UNSET OPTION_MASK_ISA_PRFCHW\n #define OPTION_MASK_ISA_RDSEED_UNSET OPTION_MASK_ISA_RDSEED\n@@ -313,6 +328,58 @@ ix86_handle_option (struct gcc_options *opts,\n \t}\n       return true;\n \n+    case OPT_mavx512f:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512F_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512F_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags &= ~OPTION_MASK_ISA_AVX512F_UNSET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512F_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mavx512cd:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512CD_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512CD_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags &= ~OPTION_MASK_ISA_AVX512CD_UNSET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512CD_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mavx512pf:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512PF_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512PF_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags &= ~OPTION_MASK_ISA_AVX512PF_UNSET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512PF_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mavx512er:\n+      if (value)\n+\t{\n+\t  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_AVX512ER_SET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512ER_SET;\n+\t}\n+      else\n+\t{\n+\t  opts->x_ix86_isa_flags &= ~OPTION_MASK_ISA_AVX512ER_UNSET;\n+\t  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_AVX512ER_UNSET;\n+\t}\n+      return true;\n+\n     case OPT_mfma:\n       if (value)\n \t{"}, {"sha": "28e626ff3be40b953381ec843f3ec810a41d1b7e", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -19,7 +19,7 @@\n \n ;;; Unused letters:\n ;;;     B     H           T\n-;;;           h jk          v\n+;;;           h jk\n \n ;; Integer register constraints.\n ;; It is not necessary to define 'r' here.\n@@ -101,11 +101,11 @@\n  \"First SSE register (@code{%xmm0}).\")\n \n (define_register_constraint \"Yi\"\n- \"TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_TO_VEC ? SSE_REGS : NO_REGS\"\n+ \"TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_TO_VEC ? ALL_SSE_REGS : NO_REGS\"\n  \"@internal Any SSE register, when SSE2 and inter-unit moves to vector registers are enabled.\")\n \n (define_register_constraint \"Yj\"\n- \"TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_FROM_VEC ? SSE_REGS : NO_REGS\"\n+ \"TARGET_SSE2 && TARGET_INTER_UNIT_MOVES_FROM_VEC ? ALL_SSE_REGS : NO_REGS\"\n  \"@internal Any SSE register, when SSE2 and inter-unit moves from vector registers are enabled.\")\n \n (define_register_constraint \"Ym\"\n@@ -138,6 +138,9 @@\n  \"(ix86_fpmath & FPMATH_387) ? FLOAT_REGS : NO_REGS\"\n  \"@internal Any x87 register when 80387 FP arithmetic is enabled.\")\n \n+(define_register_constraint \"v\" \"TARGET_SSE ? ALL_SSE_REGS : NO_REGS\"\n+ \"Any EVEX encodable SSE register (@code{%xmm0-%xmm31}).\")\n+\n (define_constraint \"z\"\n   \"@internal Constant call address operand.\"\n   (match_operand 0 \"constant_call_address_operand\"))"}, {"sha": "aa91e1ab8d86ee97b289f0ca386a45a9df54f4b1", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -71,8 +71,12 @@\n #define bit_AVX2\t(1 << 5)\n #define bit_BMI2\t(1 << 8)\n #define bit_RTM\t(1 << 11)\n+#define bit_AVX512F\t(1 << 16)\n #define bit_RDSEED\t(1 << 18)\n #define bit_ADX\t(1 << 19)\n+#define bit_AVX512PF\t(1 << 26)\n+#define bit_AVX512ER\t(1 << 27)\n+#define bit_AVX512CD\t(1 << 28)\n \n /* Extended State Enumeration Sub-leaf (%eax == 13, %ecx == 1) */\n #define bit_XSAVEOPT\t(1 << 0)"}, {"sha": "ee7ed23c8bb9ffa17650392dc2bb432d3ad413aa", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -390,6 +390,8 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   unsigned int has_rdrnd = 0, has_f16c = 0, has_fsgsbase = 0;\n   unsigned int has_rdseed = 0, has_prfchw = 0, has_adx = 0;\n   unsigned int has_osxsave = 0, has_fxsr = 0, has_xsave = 0, has_xsaveopt = 0;\n+  unsigned int has_avx512er = 0, has_avx512pf = 0, has_avx512cd = 0;\n+  unsigned int has_avx512f = 0;\n \n   bool arch;\n \n@@ -461,6 +463,10 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       has_fsgsbase = ebx & bit_FSGSBASE;\n       has_rdseed = ebx & bit_RDSEED;\n       has_adx = ebx & bit_ADX;\n+      has_avx512f = ebx & bit_AVX512F;\n+      has_avx512er = ebx & bit_AVX512ER;\n+      has_avx512pf = ebx & bit_AVX512PF;\n+      has_avx512cd = ebx & bit_AVX512CD;\n     }\n \n   if (max_level >= 13)\n@@ -828,13 +834,18 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       const char *fxsr = has_fxsr ? \" -mfxsr\" : \" -mno-fxsr\";\n       const char *xsave = has_xsave ? \" -mxsave\" : \" -mno-xsave\";\n       const char *xsaveopt = has_xsaveopt ? \" -mxsaveopt\" : \" -mno-xsaveopt\";\n+      const char *avx512f = has_avx512f ? \" -mavx512f\" : \" -mno-avx512f\";\n+      const char *avx512er = has_avx512er ? \" -mavx512er\" : \" -mno-avx512er\";\n+      const char *avx512cd = has_avx512cd ? \" -mavx512cd\" : \" -mno-avx512cd\";\n+      const char *avx512pf = has_avx512pf ? \" -mavx512pf\" : \" -mno-avx512pf\";\n \n       options = concat (options, mmx, mmx3dnow, sse, sse2, sse3, ssse3,\n \t\t\tsse4a, cx16, sahf, movbe, aes, pclmul,\n \t\t\tpopcnt, abm, lwp, fma, fma4, xop, bmi, bmi2,\n \t\t\ttbm, avx, avx2, sse4_2, sse4_1, lzcnt, rtm,\n \t\t\thle, rdrnd, f16c, fsgsbase, rdseed, prfchw, adx,\n-\t\t\tfxsr, xsave, xsaveopt, NULL);\n+\t\t\tfxsr, xsave, xsaveopt, avx512f, avx512er,\n+\t\t\tavx512cd, avx512pf, NULL);\n     }\n \n done:"}, {"sha": "14349be0af5f9da0f71483c9f4228c45ea2eee74", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -306,6 +306,14 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     def_or_undef (parse_in, \"__AVX__\");\n   if (isa_flag & OPTION_MASK_ISA_AVX2)\n     def_or_undef (parse_in, \"__AVX2__\");\n+  if (isa_flag & OPTION_MASK_ISA_AVX512F)\n+    def_or_undef (parse_in, \"__AVX512F__\");\n+  if (isa_flag & OPTION_MASK_ISA_AVX512ER)\n+    def_or_undef (parse_in, \"__AVX512ER__\");\n+  if (isa_flag & OPTION_MASK_ISA_AVX512CD)\n+    def_or_undef (parse_in, \"__AVX512CD__\");\n+  if (isa_flag & OPTION_MASK_ISA_AVX512PF)\n+    def_or_undef (parse_in, \"__AVX512PF__\");\n   if (isa_flag & OPTION_MASK_ISA_FMA)\n     def_or_undef (parse_in, \"__FMA__\");\n   if (isa_flag & OPTION_MASK_ISA_RTM)"}, {"sha": "e0b8fc826abce73d87a4bcb8845357e7a7d2bf4e", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -76,16 +76,19 @@ VECTOR_MODES (INT, 8);        /*         V8QI V4HI V2SI */\n VECTOR_MODES (INT, 16);       /*   V16QI V8HI V4SI V2DI */\n VECTOR_MODES (INT, 32);       /*  V32QI V16HI V8SI V4DI */\n VECTOR_MODES (INT, 64);       /* V64QI V32HI V16SI V8DI */\n+VECTOR_MODES (INT, 128);      /* V128QI V64HI V32SI V16DI */\n VECTOR_MODES (FLOAT, 8);      /*              V4HF V2SF */\n VECTOR_MODES (FLOAT, 16);     /*         V8HF V4SF V2DF */\n VECTOR_MODES (FLOAT, 32);     /*        V16HF V8SF V4DF */\n VECTOR_MODES (FLOAT, 64);     /*       V32HF V16SF V8DF */\n+VECTOR_MODES (FLOAT, 128);    /*      V64HF V32SF V16DF */\n VECTOR_MODE (INT, TI, 1);     /*                   V1TI */\n VECTOR_MODE (INT, DI, 1);     /*                   V1DI */\n VECTOR_MODE (INT, SI, 1);     /*                   V1SI */\n VECTOR_MODE (INT, QI, 2);     /*                   V2QI */\n \n INT_MODE (OI, 32);\n+INT_MODE (XI, 64);\n \n /* The symbol Pmode stands for one of the above machine modes (usually SImode).\n    The tm.h file specifies which one.  It is not a distinct mode.  */"}, {"sha": "d05dbf02db05e7809d99f80e7e6bcebecdff6d79", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 101, "deletions": 21, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -2027,6 +2027,11 @@ enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER] =\n   /* SSE REX registers */\n   SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS, SSE_REGS,\n   SSE_REGS, SSE_REGS,\n+  /* AVX-512 SSE registers */\n+  EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n+  EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n+  EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n+  EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS, EVEX_SSE_REGS,\n };\n \n /* The \"default\" register map used in 32bit mode.  */\n@@ -2040,6 +2045,8 @@ int const dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   29, 30, 31, 32, 33, 34, 35, 36,       /* MMX */\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended integer registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n+  -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n+  -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -2053,6 +2060,8 @@ int const dbx64_register_map[FIRST_PSEUDO_REGISTER] =\n   41, 42, 43, 44, 45, 46, 47, 48,       /* MMX */\n   8,9,10,11,12,13,14,15,\t\t/* extended integer registers */\n   25, 26, 27, 28, 29, 30, 31, 32,\t/* extended SSE registers */\n+  67, 68, 69, 70, 71, 72, 73, 74,       /* AVX-512 registers 16-23 */\n+  75, 76, 77, 78, 79, 80, 81, 82,       /* AVX-512 registers 24-31 */\n };\n \n /* Define the register numbers to be used in Dwarf debugging information.\n@@ -2118,6 +2127,8 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   29, 30, 31, 32, 33, 34, 35, 36,\t/* MMX registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended integer registers */\n   -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n+  -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 16-23*/\n+  -1, -1, -1, -1, -1, -1, -1, -1,       /* AVX-512 registers 24-31*/\n };\n \n /* Define parameter passing and return registers.  */\n@@ -2417,7 +2428,7 @@ static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =\n static bool\n gate_insert_vzeroupper (void)\n {\n-  return TARGET_AVX && TARGET_VZEROUPPER;\n+  return TARGET_AVX && !TARGET_AVX512F && TARGET_VZEROUPPER;\n }\n \n static unsigned int\n@@ -2507,6 +2518,10 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, const char *arch,\n     { \"-mfma\",\t\tOPTION_MASK_ISA_FMA },\n     { \"-mxop\",\t\tOPTION_MASK_ISA_XOP },\n     { \"-mlwp\",\t\tOPTION_MASK_ISA_LWP },\n+    { \"-mavx512f\",\tOPTION_MASK_ISA_AVX512F },\n+    { \"-mavx512er\",\tOPTION_MASK_ISA_AVX512ER },\n+    { \"-mavx512cd\",\tOPTION_MASK_ISA_AVX512CD },\n+    { \"-mavx512pf\",\tOPTION_MASK_ISA_AVX512PF },\n     { \"-msse4a\",\tOPTION_MASK_ISA_SSE4A },\n     { \"-msse4.2\",\tOPTION_MASK_ISA_SSE4_2 },\n     { \"-msse4.1\",\tOPTION_MASK_ISA_SSE4_1 },\n@@ -3026,6 +3041,10 @@ ix86_option_override_internal (bool main_args_p)\n #define PTA_FXSR\t\t(HOST_WIDE_INT_1 << 37)\n #define PTA_XSAVE\t\t(HOST_WIDE_INT_1 << 38)\n #define PTA_XSAVEOPT\t\t(HOST_WIDE_INT_1 << 39)\n+#define PTA_AVX512F\t\t(HOST_WIDE_INT_1 << 40)\n+#define PTA_AVX512ER\t\t(HOST_WIDE_INT_1 << 41)\n+#define PTA_AVX512PF\t\t(HOST_WIDE_INT_1 << 42)\n+#define PTA_AVX512CD\t\t(HOST_WIDE_INT_1 << 43)\n \n /* if this reaches 64, need to widen struct pta flags below */\n \n@@ -3547,6 +3566,18 @@ ix86_option_override_internal (bool main_args_p)\n \tif (processor_alias_table[i].flags & PTA_XSAVEOPT\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_XSAVEOPT))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_XSAVEOPT;\n+\tif (processor_alias_table[i].flags & PTA_AVX512F\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512F))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512F;\n+\tif (processor_alias_table[i].flags & PTA_AVX512ER\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512ER))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512ER;\n+\tif (processor_alias_table[i].flags & PTA_AVX512PF\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512PF))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512PF;\n+\tif (processor_alias_table[i].flags & PTA_AVX512CD\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AVX512CD))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_AVX512CD;\n \tif (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE))\n \t  x86_prefetch_sse = true;\n \n@@ -4007,22 +4038,22 @@ ix86_option_override_internal (bool main_args_p)\n      TARGET_AVX with -fexpensive-optimizations and split 32-byte\n      AVX unaligned load/store.  */\n   if (!optimize_size)\n-  {\n-     if (flag_expensive_optimizations\n-\t   && !(target_flags_explicit & MASK_VZEROUPPER))\n+    {\n+      if (flag_expensive_optimizations\n+\t  && !(target_flags_explicit & MASK_VZEROUPPER))\n \ttarget_flags |= MASK_VZEROUPPER;\n-     if ((x86_avx256_split_unaligned_load & ix86_tune_mask)\n-\t   && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n+      if ((x86_avx256_split_unaligned_load & ix86_tune_mask)\n+\t  && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n \ttarget_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n-     if ((x86_avx256_split_unaligned_store & ix86_tune_mask)\n-\t   && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n+      if ((x86_avx256_split_unaligned_store & ix86_tune_mask)\n+\t  && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_STORE))\n \ttarget_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;\n-     /* Enable 128-bit AVX instruction generation\n-\tfor the auto-vectorizer.  */\n-     if (TARGET_AVX128_OPTIMAL\n-\t   && !(target_flags_explicit & MASK_PREFER_AVX128))\n+      /* Enable 128-bit AVX instruction generation\n+         for the auto-vectorizer.  */\n+      if (TARGET_AVX128_OPTIMAL\n+\t  && !(target_flags_explicit & MASK_PREFER_AVX128))\n \ttarget_flags |= MASK_PREFER_AVX128;\n-  }\n+    }\n \n   if (ix86_recip_name)\n     {\n@@ -4143,6 +4174,8 @@ ix86_conditional_register_usage (void)\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n       for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+      for (i = FIRST_EXT_REX_SSE_REG; i <= LAST_EXT_REX_SSE_REG; i++)\n+\tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n     }\n \n   /*  See the definition of CALL_USED_REGISTERS in i386.h.  */\n@@ -4183,6 +4216,11 @@ ix86_conditional_register_usage (void)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n       if (TEST_HARD_REG_BIT (reg_class_contents[(int)FLOAT_REGS], i))\n \tfixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n+\n+  /* If AVX512F is disabled, squash the registers.  */\n+  if (! TARGET_AVX512F)\n+    for (i = FIRST_EXT_REX_SSE_REG; i < LAST_EXT_REX_SSE_REG; i++)\n+      fixed_regs[i] = call_used_regs[i] = 1, reg_names[i] = \"\";\n }\n \n \f\n@@ -4322,6 +4360,10 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[],\n     IX86_ATTR_ISA (\"aes\",\tOPT_maes),\n     IX86_ATTR_ISA (\"avx\",\tOPT_mavx),\n     IX86_ATTR_ISA (\"avx2\",\tOPT_mavx2),\n+    IX86_ATTR_ISA (\"avx512f\",\tOPT_mavx512f),\n+    IX86_ATTR_ISA (\"avx512pf\",\tOPT_mavx512pf),\n+    IX86_ATTR_ISA (\"avx512er\",\tOPT_mavx512er),\n+    IX86_ATTR_ISA (\"avx512cd\",\tOPT_mavx512cd),\n     IX86_ATTR_ISA (\"mmx\",\tOPT_mmmx),\n     IX86_ATTR_ISA (\"pclmul\",\tOPT_mpclmul),\n     IX86_ATTR_ISA (\"popcnt\",\tOPT_mpopcnt),\n@@ -8648,6 +8690,10 @@ standard_sse_constant_opcode (rtx insn, rtx x)\n \t}\n \n     case 2:\n+      if (get_attr_mode (insn) == MODE_XI\n+\t  || get_attr_mode (insn) == MODE_V8DF\n+\t  || get_attr_mode (insn) == MODE_V16SF)\n+\treturn \"vpternlogd\\t{$0xFF, %g0, %g0, %g0|%g0, %g0, %g0, 0xFF}\";\n       if (TARGET_AVX)\n \treturn \"vpcmpeqd\\t%0, %0, %0\";\n       else\n@@ -14173,6 +14219,7 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, bool reverse,\n    If CODE is 'q', pretend the mode is DImode.\n    If CODE is 'x', pretend the mode is V4SFmode.\n    If CODE is 't', pretend the mode is V8SFmode.\n+   If CODE is 'g', pretend the mode is V16SFmode.\n    If CODE is 'h', pretend the reg is the 'high' byte register.\n    If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op.\n    If CODE is 'd', duplicate the operand for AVX instruction.\n@@ -14218,6 +14265,8 @@ print_reg (rtx x, int code, FILE *file)\n     code = 16;\n   else if (code == 't')\n     code = 32;\n+  else if (code == 'g')\n+    code = 64;\n   else\n     code = GET_MODE_SIZE (GET_MODE (x));\n \n@@ -14291,6 +14340,14 @@ print_reg (rtx x, int code, FILE *file)\n \t  fputs (hi_reg_name[regno] + 1, file);\n \t  return;\n \t}\n+    case 64:\n+      if (SSE_REG_P (x))\n+        {\n+          gcc_assert (!duplicated);\n+          putc ('z', file);\n+          fputs (hi_reg_name[REGNO (x)] + 1, file);\n+          return;\n+        }\n       break;\n     default:\n       gcc_unreachable ();\n@@ -14364,6 +14421,7 @@ get_some_local_dynamic_name (void)\n    q --  likewise, print the DImode name of the register.\n    x --  likewise, print the V4SFmode name of the register.\n    t --  likewise, print the V8SFmode name of the register.\n+   g --  likewise, print the V16SFmode name of the register.\n    h -- print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n    y -- print \"st(0)\" instead of \"st\" as a register.\n    d -- print duplicated register operand for AVX instruction.\n@@ -14593,6 +14651,7 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \tcase 'q':\n \tcase 'h':\n \tcase 't':\n+\tcase 'g':\n \tcase 'y':\n \tcase 'x':\n \tcase 'X':\n@@ -14901,6 +14960,7 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t\tsize = \"XMMWORD\";\n               break;\n \t    case 32: size = \"YMMWORD\"; break;\n+\t    case 64: size = \"ZMMWORD\"; break;\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -33898,7 +33958,7 @@ ix86_preferred_output_reload_class (rtx x, reg_class_t regclass)\n      alternative: if reload cannot do this, it will still use its choice.  */\n   mode = GET_MODE (x);\n   if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n-    return MAYBE_SSE_CLASS_P (regclass) ? SSE_REGS : NO_REGS;\n+    return MAYBE_SSE_CLASS_P (regclass) ? ALL_SSE_REGS : NO_REGS;\n \n   if (X87_FLOAT_MODE_P (mode))\n     {\n@@ -34365,8 +34425,23 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n     {\n       /* We implement the move patterns for all vector modes into and\n \t out of SSE registers, even when no operation instructions\n-\t are available.  OImode move is available only when AVX is\n-\t enabled.  */\n+\t are available.  */\n+\n+      /* For AVX-512 we allow, regardless of regno:\n+\t  - XI mode\n+\t  - any of 512-bit wide vector mode\n+\t  - any scalar mode.  */\n+      if (TARGET_AVX512F\n+\t  && (mode == XImode\n+\t      || VALID_AVX512F_REG_MODE (mode)\n+\t      || VALID_AVX512F_SCALAR_MODE (mode)))\n+\treturn true;\n+\n+      /* xmm16-xmm31 are only available for AVX-512.  */\n+      if (EXT_REX_SSE_REGNO_P (regno))\n+\treturn false;\n+\n+      /* OImode move is available only when AVX is enabled.  */\n       return ((TARGET_AVX && mode == OImode)\n \t      || VALID_AVX256_REG_MODE (mode)\n \t      || VALID_SSE_REG_MODE (mode)\n@@ -34518,7 +34593,8 @@ ix86_set_reg_reg_cost (enum machine_mode mode)\n \n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n-      if ((TARGET_AVX && VALID_AVX256_REG_MODE (mode))\n+      if ((TARGET_AVX512F && VALID_AVX512F_REG_MODE (mode))\n+\t  || (TARGET_AVX && VALID_AVX256_REG_MODE (mode))\n \t  || (TARGET_SSE2 && VALID_SSE2_REG_MODE (mode))\n \t  || (TARGET_SSE && VALID_SSE_REG_MODE (mode))\n \t  || (TARGET_MMX && VALID_MMX_REG_MODE (mode)))\n@@ -35150,6 +35226,10 @@ x86_order_regs_for_local_alloc (void)\n    for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n      reg_alloc_order [pos++] = i;\n \n+   /* Extended REX SSE registers.  */\n+   for (i = FIRST_EXT_REX_SSE_REG; i <= LAST_EXT_REX_SSE_REG; i++)\n+     reg_alloc_order [pos++] = i;\n+\n    /* x87 registers.  */\n    if (TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -36147,9 +36227,9 @@ x86_emit_floatuns (rtx operands[2])\n   emit_label (donelab);\n }\n \f\n-/* AVX2 does support 32-byte integer vector operations,\n-   thus the longest vector we are faced with is V32QImode.  */\n-#define MAX_VECT_LEN\t32\n+/* AVX512F does support 64-byte integer vector operations,\n+   thus the longest vector we are faced with is V64QImode.  */\n+#define MAX_VECT_LEN\t64\n \n struct expand_vec_perm_d\n {\n@@ -42686,7 +42766,7 @@ ix86_spill_class (reg_class_t rclass, enum machine_mode mode)\n   if (TARGET_SSE && TARGET_GENERAL_REGS_SSE_SPILL && ! TARGET_MMX\n       && (mode == SImode || (TARGET_64BIT && mode == DImode))\n       && INTEGER_CLASS_P (rclass))\n-    return SSE_REGS;\n+    return ALL_SSE_REGS;\n   return NO_REGS;\n }\n "}, {"sha": "e820aa65ac5870c436bd0cc35e591413c8b8e7f5", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 91, "deletions": 39, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -51,6 +51,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define TARGET_SSE4_2\tTARGET_ISA_SSE4_2\n #define TARGET_AVX\tTARGET_ISA_AVX\n #define TARGET_AVX2\tTARGET_ISA_AVX2\n+#define TARGET_AVX512F  TARGET_ISA_AVX512F\n+#define TARGET_AVX512PF TARGET_ISA_AVX512PF\n+#define TARGET_AVX512ER TARGET_ISA_AVX512ER\n+#define TARGET_AVX512CD TARGET_ISA_AVX512CD\n #define TARGET_FMA\tTARGET_ISA_FMA\n #define TARGET_SSE4A\tTARGET_ISA_SSE4A\n #define TARGET_FMA4\tTARGET_ISA_FMA4\n@@ -732,7 +736,8 @@ enum target_cpu_default\n    Pentium+ prefers DFmode values to be aligned to 64 bit boundary\n    and Pentium Pro XFmode values at 128 bit boundaries.  */\n \n-#define BIGGEST_ALIGNMENT (TARGET_AVX ? 256 : 128)\n+#define BIGGEST_ALIGNMENT \\\n+  (TARGET_AVX512F ? 512 : (TARGET_AVX ? 256 : 128))\n \n /* Maximum stack alignment.  */\n #define MAX_STACK_ALIGNMENT MAX_OFILE_ALIGNMENT\n@@ -888,7 +893,7 @@ enum target_cpu_default\n    eliminated during reloading in favor of either the stack or frame\n    pointer.  */\n \n-#define FIRST_PSEUDO_REGISTER 53\n+#define FIRST_PSEUDO_REGISTER 69\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -914,6 +919,10 @@ enum target_cpu_default\n /*  r8,  r9, r10, r11, r12, r13, r14, r15*/\t\t\t\\\n      0,   0,   0,   0,   0,   0,   0,   0,\t\t\t\\\n /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n+     0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n+/*xmm16,xmm17,xmm18,xmm19,xmm20,xmm21,xmm22,xmm23*/\t\t\\\n+     0,   0,    0,    0,    0,    0,    0,    0,\t\t\\\n+/*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n      0,   0,    0,    0,    0,    0,    0,    0 }\n \n /* 1 for registers not available across function calls.\n@@ -942,7 +951,11 @@ enum target_cpu_default\n /*  r8,  r9, r10, r11, r12, r13, r14, r15*/\t\t\t\\\n      1,   1,   1,   1,   2,   2,   2,   2,\t\t\t\\\n /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n-     6,   6,    6,    6,    6,    6,    6,    6 }\n+     6,   6,    6,    6,    6,    6,    6,    6,\t\t\\\n+/*xmm16,xmm17,xmm18,xmm19,xmm20,xmm21,xmm22,xmm23*/\t\t\\\n+     6,    6,     6,    6,    6,    6,    6,    6,\t\t\\\n+/*xmm24,xmm25,xmm26,xmm27,xmm28,xmm29,xmm30,xmm31*/\t\t\\\n+     6,    6,     6,    6,    6,    6,    6,    6 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -957,7 +970,8 @@ enum target_cpu_default\n {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\\\n    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\t\\\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  \\\n-   48, 49, 50, 51, 52 }\n+   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\\\n+   63, 64, 65, 66, 67, 68 }\n \n /* ADJUST_REG_ALLOC_ORDER is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n@@ -1003,6 +1017,14 @@ enum target_cpu_default\n #define VALID_AVX256_REG_OR_OI_MODE(MODE)\t\t\t\t\t\\\n   (VALID_AVX256_REG_MODE (MODE) || (MODE) == OImode)\n \n+#define VALID_AVX512F_SCALAR_MODE(MODE)\t\t\t\t\t\\\n+  ((MODE) == DImode || (MODE) == DFmode || (MODE) == SImode\t\t\\\n+   || (MODE) == SFmode)\n+\n+#define VALID_AVX512F_REG_MODE(MODE)\t\t\t\t\t\\\n+  ((MODE) == V8DImode || (MODE) == V8DFmode || (MODE) == V64QImode\t\\\n+   || (MODE) == V16SImode || (MODE) == V16SFmode || (MODE) == V32HImode)\n+\n #define VALID_SSE2_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode\t\\\n    || (MODE) == V2DImode || (MODE) == DFmode)\n@@ -1042,7 +1064,9 @@ enum target_cpu_default\n    || (MODE) == V2DImode || (MODE) == V4SFmode || (MODE) == V4SImode\t\\\n    || (MODE) == V32QImode || (MODE) == V16HImode || (MODE) == V8SImode\t\\\n    || (MODE) == V4DImode || (MODE) == V8SFmode || (MODE) == V4DFmode\t\\\n-   || (MODE) == V2TImode)\n+   || (MODE) == V2TImode || (MODE) == V8DImode || (MODE) == V64QImode\t\\\n+   || (MODE) == V16SImode || (MODE) == V32HImode || (MODE) == V8DFmode\t\\\n+   || (MODE) == V16SFmode)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n@@ -1105,15 +1129,18 @@ enum target_cpu_default\n #define FIRST_SSE_REG (FRAME_POINTER_REGNUM + 1)\n #define LAST_SSE_REG  (FIRST_SSE_REG + 7)\n \n-#define FIRST_MMX_REG  (LAST_SSE_REG + 1)\n+#define FIRST_MMX_REG  (LAST_SSE_REG + 1)   /*29*/\n #define LAST_MMX_REG   (FIRST_MMX_REG + 7)\n \n-#define FIRST_REX_INT_REG  (LAST_MMX_REG + 1)\n+#define FIRST_REX_INT_REG  (LAST_MMX_REG + 1) /*37*/\n #define LAST_REX_INT_REG   (FIRST_REX_INT_REG + 7)\n \n-#define FIRST_REX_SSE_REG  (LAST_REX_INT_REG + 1)\n+#define FIRST_REX_SSE_REG  (LAST_REX_INT_REG + 1) /*45*/\n #define LAST_REX_SSE_REG   (FIRST_REX_SSE_REG + 7)\n \n+#define FIRST_EXT_REX_SSE_REG  (LAST_REX_SSE_REG + 1) /*53*/\n+#define LAST_EXT_REX_SSE_REG   (FIRST_EXT_REX_SSE_REG + 15) /*68*/\n+\n /* Override this in other tm.h files to cope with various OS lossage\n    requiring a frame pointer.  */\n #ifndef SUBTARGET_FRAME_POINTER_REQUIRED\n@@ -1193,6 +1220,8 @@ enum reg_class\n   FLOAT_REGS,\n   SSE_FIRST_REG,\n   SSE_REGS,\n+  EVEX_SSE_REGS,\n+  ALL_SSE_REGS,\n   MMX_REGS,\n   FP_TOP_SSE_REGS,\n   FP_SECOND_SSE_REGS,\n@@ -1210,15 +1239,15 @@ enum reg_class\n #define FLOAT_CLASS_P(CLASS) \\\n   reg_class_subset_p ((CLASS), FLOAT_REGS)\n #define SSE_CLASS_P(CLASS) \\\n-  reg_class_subset_p ((CLASS), SSE_REGS)\n+  reg_class_subset_p ((CLASS), ALL_SSE_REGS)\n #define MMX_CLASS_P(CLASS) \\\n   ((CLASS) == MMX_REGS)\n #define MAYBE_INTEGER_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), GENERAL_REGS)\n #define MAYBE_FLOAT_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), FLOAT_REGS)\n #define MAYBE_SSE_CLASS_P(CLASS) \\\n-  reg_classes_intersect_p ((CLASS), SSE_REGS)\n+  reg_classes_intersect_p ((CLASS), ALL_SSE_REGS)\n #define MAYBE_MMX_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), MMX_REGS)\n \n@@ -1244,6 +1273,8 @@ enum reg_class\n    \"FLOAT_REGS\",\t\t\t\\\n    \"SSE_FIRST_REG\",\t\t\t\\\n    \"SSE_REGS\",\t\t\t\t\\\n+   \"EVEX_SSE_REGS\",\t\t\t\\\n+   \"ALL_SSE_REGS\",\t\t\t\\\n    \"MMX_REGS\",\t\t\t\t\\\n    \"FP_TOP_SSE_REGS\",\t\t\t\\\n    \"FP_SECOND_SSE_REGS\",\t\t\\\n@@ -1259,30 +1290,36 @@ enum reg_class\n    Note that CLOBBERED_REGS are calculated by\n    TARGET_CONDITIONAL_REGISTER_USAGE.  */\n \n-#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n-{     { 0x00,     0x0 },\t\t\t\t\t\t\\\n-      { 0x01,     0x0 }, { 0x02, 0x0 },\t/* AREG, DREG */\t\t\\\n-      { 0x04,     0x0 }, { 0x08, 0x0 },\t/* CREG, BREG */\t\t\\\n-      { 0x10,     0x0 }, { 0x20, 0x0 },\t/* SIREG, DIREG */\t\t\\\n-      { 0x03,     0x0 },\t\t/* AD_REGS */\t\t\t\\\n-      { 0x0f,     0x0 },\t\t/* Q_REGS */\t\t\t\\\n-  { 0x1100f0,  0x1fe0 },\t\t/* NON_Q_REGS */\t\t\\\n-      { 0x7f,  0x1fe0 },\t\t/* INDEX_REGS */\t\t\\\n-  { 0x1100ff,     0x0 },\t\t/* LEGACY_REGS */\t\t\\\n-      { 0x00,     0x0 },\t\t/* CLOBBERED_REGS */\t\t\\\n-  { 0x1100ff,  0x1fe0 },\t\t/* GENERAL_REGS */\t\t\\\n-     { 0x100,     0x0 }, { 0x0200, 0x0 },/* FP_TOP_REG, FP_SECOND_REG */\\\n-    { 0xff00,     0x0 },\t\t/* FLOAT_REGS */\t\t\\\n-  { 0x200000,     0x0 },\t\t/* SSE_FIRST_REG */\t\t\\\n-{ 0x1fe00000,0x1fe000 },\t\t/* SSE_REGS */\t\t\t\\\n-{ 0xe0000000,    0x1f },\t\t/* MMX_REGS */\t\t\t\\\n-{ 0x1fe00100,0x1fe000 },\t\t/* FP_TOP_SSE_REG */\t\t\\\n-{ 0x1fe00200,0x1fe000 },\t\t/* FP_SECOND_SSE_REG */\t\t\\\n-{ 0x1fe0ff00,0x1fe000 },\t\t/* FLOAT_SSE_REGS */\t\t\\\n-  { 0x11ffff,  0x1fe0 },\t\t/* FLOAT_INT_REGS */\t\t\\\n-{ 0x1ff100ff,0x1fffe0 },\t\t/* INT_SSE_REGS */\t\t\\\n-{ 0x1ff1ffff,0x1fffe0 },\t\t/* FLOAT_INT_SSE_REGS */\t\\\n-{ 0xffffffff,0x1fffff }\t\t\t\t\t\t\t\\\n+#define REG_CLASS_CONTENTS                                              \\\n+{     { 0x00,       0x0,   0x0 },                                       \\\n+      { 0x01,       0x0,   0x0 },       /* AREG */                      \\\n+      { 0x02,       0x0,   0x0 },       /* DREG */                      \\\n+      { 0x04,       0x0,   0x0 },       /* CREG */                      \\\n+      { 0x08,       0x0,   0x0 },       /* BREG */                      \\\n+      { 0x10,       0x0,   0x0 },       /* SIREG */                     \\\n+      { 0x20,       0x0,   0x0 },       /* DIREG */                     \\\n+      { 0x03,       0x0,   0x0 },       /* AD_REGS */                   \\\n+      { 0x0f,       0x0,   0x0 },       /* Q_REGS */                    \\\n+  { 0x1100f0,    0x1fe0,   0x0 },       /* NON_Q_REGS */                \\\n+      { 0x7f,    0x1fe0,   0x0 },       /* INDEX_REGS */                \\\n+  { 0x1100ff,       0x0,   0x0 },       /* LEGACY_REGS */               \\\n+      { 0x07,       0x0,   0x0 },       /* CLOBBERED_REGS */            \\\n+  { 0x1100ff,    0x1fe0,   0x0 },       /* GENERAL_REGS */              \\\n+     { 0x100,       0x0,   0x0 },       /* FP_TOP_REG */                \\\n+    { 0x0200,       0x0,   0x0 },       /* FP_SECOND_REG */             \\\n+    { 0xff00,       0x0,   0x0 },       /* FLOAT_REGS */                \\\n+  { 0x200000,       0x0,   0x0 },       /* SSE_FIRST_REG */             \\\n+{ 0x1fe00000,  0x1fe000,   0x0 },       /* SSE_REGS */                  \\\n+       { 0x0,0xffe00000,  0x1f },       /* EVEX_SSE_REGS */             \\\n+{ 0x1fe00000,0xffffe000,  0x1f },       /* ALL_SSE_REGS */              \\\n+{ 0xe0000000,      0x1f,   0x0 },       /* MMX_REGS */                  \\\n+{ 0x1fe00100,0xffffe000,  0x1f },       /* FP_TOP_SSE_REG */            \\\n+{ 0x1fe00200,0xffffe000,  0x1f },       /* FP_SECOND_SSE_REG */         \\\n+{ 0x1fe0ff00,0xffffe000,  0x1f },       /* FLOAT_SSE_REGS */            \\\n+{   0x11ffff,    0x1fe0,   0x0 },       /* FLOAT_INT_REGS */            \\\n+{ 0x1ff100ff,0xffffffe0,  0x1f },       /* INT_SSE_REGS */              \\\n+{ 0x1ff1ffff,0xffffffe0,  0x1f },       /* FLOAT_INT_SSE_REGS */        \\\n+{ 0xffffffff,0xffffffff,  0x1f }                                        \\\n }\n \n /* The same information, inverted:\n@@ -1326,13 +1363,20 @@ enum reg_class\n #define SSE_REG_P(X) (REG_P (X) && SSE_REGNO_P (REGNO (X)))\n #define SSE_REGNO_P(N)\t\t\t\t\t\t\\\n   (IN_RANGE ((N), FIRST_SSE_REG, LAST_SSE_REG)\t\t\t\\\n-   || REX_SSE_REGNO_P (N))\n+   || REX_SSE_REGNO_P (N)\t\t\t\t\t\\\n+   || EXT_REX_SSE_REGNO_P (N))\n \n #define REX_SSE_REGNO_P(N) \\\n   IN_RANGE ((N), FIRST_REX_SSE_REG, LAST_REX_SSE_REG)\n \n+#define EXT_REX_SSE_REGNO_P(N) \\\n+  IN_RANGE ((N), FIRST_EXT_REX_SSE_REG, LAST_EXT_REX_SSE_REG)\n+\n #define SSE_REGNO(N) \\\n-  ((N) < 8 ? FIRST_SSE_REG + (N) : FIRST_REX_SSE_REG + (N) - 8)\n+  ((N) < 8 ? FIRST_SSE_REG + (N) \\\n+         : (N) <= LAST_REX_SSE_REG ? (FIRST_REX_SSE_REG + (N) - 8) \\\n+                                   : (FIRST_EXT_REX_SSE_REG + (N) - 16))\n+\n \n #define SSE_FLOAT_MODE_P(MODE) \\\n   ((TARGET_SSE && (MODE) == SFmode) || (TARGET_SSE2 && (MODE) == DFmode))\n@@ -1885,7 +1929,11 @@ do {\t\t\t\t\t\t\t\\\n  \"xmm0\",\"xmm1\",\"xmm2\",\"xmm3\",\"xmm4\",\"xmm5\",\"xmm6\",\"xmm7\",\t\t\\\n  \"mm0\", \"mm1\", \"mm2\", \"mm3\", \"mm4\", \"mm5\", \"mm6\", \"mm7\",\t\t\\\n  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\t\\\n- \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\", \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\"}\n+ \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\", \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\",\t\\\n+ \"xmm16\", \"xmm17\", \"xmm18\", \"xmm19\",\t\t\t\t\t\\\n+ \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\t\t\t\t\t\\\n+ \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\t\t\t\t\t\\\n+ \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n \n@@ -2206,9 +2254,13 @@ enum avx_u128_state\n    scheduling just increases amount of live registers at time and in\n    the turn amount of fxch instructions needed.\n \n-   ??? Maybe Pentium chips benefits from renaming, someone can try....  */\n+   ??? Maybe Pentium chips benefits from renaming, someone can try....\n+\n+   Don't rename evex to non-evex sse registers.  */\n \n-#define HARD_REGNO_RENAME_OK(SRC, TARGET) !STACK_REGNO_P (SRC)\n+#define HARD_REGNO_RENAME_OK(SRC, TARGET) (!STACK_REGNO_P (SRC) &&\t \\\n+\t\t\t\t\t   (EXT_REX_SSE_REGNO_P (SRC) == \\\n+\t\t\t\t\t    EXT_REX_SSE_REGNO_P (TARGET)))\n \n \f\n #define FASTCALL_PREFIX '@'"}, {"sha": "b55fd6fbe0a8c5614180d218066c0193a9aceb96", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 127, "deletions": 29, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -312,6 +312,22 @@\n    (XMM13_REG\t\t\t50)\n    (XMM14_REG\t\t\t51)\n    (XMM15_REG\t\t\t52)\n+   (XMM16_REG\t\t\t53)\n+   (XMM17_REG\t\t\t54)\n+   (XMM18_REG\t\t\t55)\n+   (XMM19_REG\t\t\t56)\n+   (XMM20_REG\t\t\t57)\n+   (XMM21_REG\t\t\t58)\n+   (XMM22_REG\t\t\t59)\n+   (XMM23_REG\t\t\t60)\n+   (XMM24_REG\t\t\t61)\n+   (XMM25_REG\t\t\t62)\n+   (XMM26_REG\t\t\t63)\n+   (XMM27_REG\t\t\t64)\n+   (XMM28_REG\t\t\t65)\n+   (XMM29_REG\t\t\t66)\n+   (XMM30_REG\t\t\t67)\n+   (XMM31_REG\t\t\t68)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls\n@@ -350,7 +366,8 @@\n \n ;; Main data type used by the insn\n (define_attr \"mode\"\n-  \"unknown,none,QI,HI,SI,DI,TI,OI,SF,DF,XF,TF,V8SF,V4DF,V4SF,V2DF,V2SF,V1DF\"\n+  \"unknown,none,QI,HI,SI,DI,TI,OI,XI,SF,DF,XF,TF,V16SF,V8SF,V4DF,V4SF,\n+  V2DF,V2SF,V1DF,V8DF\"\n   (const_string \"unknown\"))\n \n ;; The CPU unit operations uses.\n@@ -471,10 +488,13 @@\n \t(const_int 0)))\n \n ;; Prefix used: original, VEX or maybe VEX.\n-(define_attr \"prefix\" \"orig,vex,maybe_vex\"\n-  (if_then_else (eq_attr \"mode\" \"OI,V8SF,V4DF\")\n-    (const_string \"vex\")\n-    (const_string \"orig\")))\n+(define_attr \"prefix\" \"orig,vex,maybe_vex,evex,maybe_evex\"\n+  (cond [(eq_attr \"mode\" \"OI,V8SF,V4DF\")\n+           (const_string \"vex\")\n+         (eq_attr \"mode\" \"XI,V16SF,V8DF\")\n+           (const_string \"evex\")\n+        ]\n+        (const_string \"orig\")))\n \n ;; VEX W bit is used.\n (define_attr \"prefix_vex_w\" \"\" (const_int 0))\n@@ -493,6 +513,9 @@\n       (symbol_ref \"ix86_attr_length_vex_default (insn, false, true)\")\n       (symbol_ref \"ix86_attr_length_vex_default (insn, false, false)\"))))\n \n+;; 4-bytes evex prefix and 1 byte opcode.\n+(define_attr \"length_evex\" \"\" (const_int 5))\n+\n ;; Set when modrm byte is used.\n (define_attr \"modrm\" \"\"\n   (cond [(eq_attr \"type\" \"str,leave\")\n@@ -544,8 +567,17 @@\n \t   (plus (const_int 2)\n \t\t (plus (attr \"prefix_data16\")\n \t\t       (attr \"length_address\")))\n+\t (ior (eq_attr \"prefix\" \"evex\")\n+\t      (and (ior (eq_attr \"prefix\" \"maybe_evex\")\n+\t\t\t(eq_attr \"prefix\" \"maybe_vex\"))\n+\t\t   (match_test \"TARGET_AVX512F\")))\n+\t   (plus (attr \"length_evex\")\n+\t\t (plus (attr \"length_immediate\")\n+\t\t       (plus (attr \"modrm\")\n+\t\t\t     (attr \"length_address\"))))\n \t (ior (eq_attr \"prefix\" \"vex\")\n-\t      (and (eq_attr \"prefix\" \"maybe_vex\")\n+\t      (and (ior (eq_attr \"prefix\" \"maybe_vex\")\n+\t\t\t(eq_attr \"prefix\" \"maybe_evex\"))\n \t\t   (match_test \"TARGET_AVX\")))\n \t   (plus (attr \"length_vex\")\n \t\t (plus (attr \"length_immediate\")\n@@ -663,7 +695,7 @@\n ;; Used to control the \"enabled\" attribute on a per-instruction basis.\n (define_attr \"isa\" \"base,x64,x64_sse4,x64_sse4_noavx,x64_avx,nox64,\n \t\t    sse2,sse2_noavx,sse3,sse4,sse4_noavx,avx,noavx,\n-\t\t    avx2,noavx2,bmi2,fma4,fma\"\n+\t\t    avx2,noavx2,bmi2,fma4,fma,avx512f,noavx512f,fma_avx512f\"\n   (const_string \"base\"))\n \n (define_attr \"enabled\" \"\"\n@@ -689,6 +721,10 @@\n \t (eq_attr \"isa\" \"bmi2\") (symbol_ref \"TARGET_BMI2\")\n \t (eq_attr \"isa\" \"fma4\") (symbol_ref \"TARGET_FMA4\")\n \t (eq_attr \"isa\" \"fma\") (symbol_ref \"TARGET_FMA\")\n+\t (eq_attr \"isa\" \"avx512f\") (symbol_ref \"TARGET_AVX512F\")\n+\t (eq_attr \"isa\" \"noavx512f\") (symbol_ref \"!TARGET_AVX512F\")\n+\t (eq_attr \"isa\" \"fma_avx512f\")\n+\t   (symbol_ref \"TARGET_FMA || TARGET_AVX512F\")\n \t]\n \t(const_int 1)))\n \n@@ -924,10 +960,12 @@\n ;; SSE instruction suffix for various modes\n (define_mode_attr ssemodesuffix\n   [(SF \"ss\") (DF \"sd\")\n+   (V16SF \"ps\") (V8DF \"pd\")\n    (V8SF \"ps\") (V4DF \"pd\")\n    (V4SF \"ps\") (V2DF \"pd\")\n    (V16QI \"b\") (V8HI \"w\") (V4SI \"d\") (V2DI \"q\")\n-   (V32QI \"b\") (V16HI \"w\") (V8SI \"d\") (V4DI \"q\")])\n+   (V32QI \"b\") (V16HI \"w\") (V8SI \"d\") (V4DI \"q\")\n+   (V64QI \"b\") (V16SI \"d\") (V8DI \"q\")])\n \n ;; SSE vector suffix for floating point modes\n (define_mode_attr ssevecmodesuffix [(SF \"ps\") (DF \"pd\")])\n@@ -1649,6 +1687,12 @@\n \f\n ;; Move instructions.\n \n+(define_expand \"movxi\"\n+  [(set (match_operand:XI 0 \"nonimmediate_operand\")\n+\t(match_operand:XI 1 \"general_operand\"))]\n+  \"TARGET_AVX512F\"\n+  \"ix86_expand_move (XImode, operands); DONE;\")\n+\n ;; Reload patterns to support multi-word load/store\n ;; with non-offsetable address.\n (define_expand \"reload_noff_store\"\n@@ -1746,6 +1790,30 @@\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"length_immediate\" \"1\")])\n \n+(define_insn \"*movxi_internal_avx512f\"\n+  [(set (match_operand:XI 0 \"nonimmediate_operand\" \"=x,x ,m\")\n+\t(match_operand:XI 1 \"vector_move_operand\"  \"C ,xm,x\"))]\n+  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return standard_sse_constant_opcode (insn, operands[1]);\n+    case 1:\n+    case 2:\n+      if (misaligned_operand (operands[0], XImode)\n+\t  || misaligned_operand (operands[1], XImode))\n+\treturn \"vmovdqu32\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"vmovdqa32\\t{%1, %0|%0, %1}\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n+   (set_attr \"prefix\" \"evex\")\n+   (set_attr \"mode\" \"XI\")])\n+\n (define_insn \"*movoi_internal_avx\"\n   [(set (match_operand:OI 0 \"nonimmediate_operand\" \"=x,x ,m\")\n \t(match_operand:OI 1 \"vector_move_operand\"  \"C ,xm,x\"))]\n@@ -1857,9 +1925,9 @@\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*x,*x,*x,m ,?r ,?r,?*Yi,?*Ym,?*Yi\")\n+    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,?r ,?r,?*Yi,?*Ym,?*Yi\")\n \t(match_operand:DI 1 \"general_operand\"\n-    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*x,m ,*x,*Yj,*x,r   ,*Yj ,*Yn\"))]\n+    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,*Yj,*v,r   ,*Yj ,*Yn\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -1896,6 +1964,8 @@\n \t  return \"%vmovq\\t{%1, %0|%0, %1}\";\n \tcase MODE_TI:\n \t  return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\tcase MODE_XI:\n+\t  return \"vmovdqa64\\t{%g1, %g0|%g0, %g1}\";\n \n \tcase MODE_V2SF:\n \t  gcc_assert (!TARGET_AVX);\n@@ -1989,7 +2059,11 @@\n      (cond [(eq_attr \"alternative\" \"2\")\n \t      (const_string \"SI\")\n \t    (eq_attr \"alternative\" \"12,13\")\n-\t      (cond [(ior (not (match_test \"TARGET_SSE2\"))\n+\t      (cond [(ior (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[0]))\")\n+\t\t\t  (and (match_test \"REG_P (operands[1])\")\n+\t\t\t       (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[1]))\")))\n+\t\t       (const_string \"XI\")\n+\t\t     (ior (not (match_test \"TARGET_SSE2\"))\n \t\t\t  (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t       (const_string \"V4SF\")\n \t\t     (match_test \"TARGET_AVX\")\n@@ -2018,9 +2092,9 @@\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\"=r,m ,*y,*y,?rm,?*y,*x,*x,*x,m ,?r ,?r,?*Yi\")\n+\t\t\t\"=r,m ,*y,*y,?rm,?*y,*v,*v,*v,m ,?r ,?r,?*Yi\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*x,m ,*x,*Yj,*x,r\"))]\n+\t\t\t\"g ,re,C ,*y,*y ,rm ,C ,*v,m ,*v,*Yj,*v,r\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2038,6 +2112,8 @@\n           return \"%vmovd\\t{%1, %0|%0, %1}\";\n \tcase MODE_TI:\n \t  return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\tcase MODE_XI:\n+\t  return \"vmovdqa32\\t{%g1, %g0|%g0, %g1}\";\n \n \tcase MODE_V4SF:\n \t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n@@ -2116,7 +2192,11 @@\n      (cond [(eq_attr \"alternative\" \"2,3\")\n \t      (const_string \"DI\")\n \t    (eq_attr \"alternative\" \"6,7\")\n-\t      (cond [(ior (not (match_test \"TARGET_SSE2\"))\n+\t      (cond [(ior (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[0]))\")\n+\t\t\t  (and (match_test \"REG_P (operands[1])\")\n+\t\t\t       (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[1]))\")))\n+\t\t       (const_string \"XI\")\n+\t\t     (ior (not (match_test \"TARGET_SSE2\"))\n \t\t\t  (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t       (const_string \"V4SF\")\n \t\t     (match_test \"TARGET_AVX\")\n@@ -2703,9 +2783,9 @@\n ;; Possible store forwarding (partial memory) stall in alternative 4.\n (define_insn \"*movdf_internal\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n-    \"=Yf*f,m   ,Yf*f,?Yd*r ,!o   ,?r,?m,?r,?r,x,x,x,m,*x,*x,*x,m ,r ,Yi\")\n+    \"=Yf*f,m   ,Yf*f,?Yd*r ,!o   ,?r,?m,?r,?r,v,v,v,m,*x,*x,*x,m ,r ,Yi\")\n \t(match_operand:DF 1 \"general_operand\"\n-    \"Yf*fm,Yf*f,G   ,Yd*roF,Yd*rF,rm,rC,C ,F ,C,x,m,x,C ,*x,m ,*x,Yj,r\"))]\n+    \"Yf*fm,Yf*f,G   ,Yd*roF,Yd*rF,rm,rC,C ,F ,C,v,m,v,C ,*x,m ,*x,Yj,r\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n@@ -2750,6 +2830,8 @@\n \n \tcase MODE_V4SF:\n \t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n+\tcase MODE_V8DF:\n+\t  return \"vmovapd\\t{%g1, %g0|%g0, %g1}\";\n \tcase MODE_V2DF:\n \t  return \"%vmovapd\\t{%1, %0|%0, %1}\";\n \n@@ -2824,6 +2906,8 @@\n \t       (eq_attr \"alternative\" \"9,13\")\n \t\t (cond [(not (match_test \"TARGET_SSE2\"))\n \t\t \t  (const_string \"V4SF\")\n+\t\t\t(match_test \"TARGET_AVX512F\")\n+\t\t\t  (const_string \"XI\")\n \t\t\t(match_test \"TARGET_AVX\")\n \t\t\t  (const_string \"V2DF\")\n \t\t\t(match_test \"optimize_function_for_size_p (cfun)\")\n@@ -2839,7 +2923,11 @@\n \n \t       /* movaps is one byte shorter for non-AVX targets.  */\n \t       (eq_attr \"alternative\" \"10,14\")\n-\t\t (cond [(ior (not (match_test \"TARGET_SSE2\"))\n+\t\t (cond [(ior (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[0]))\")\n+\t\t\t     (and (match_test \"REG_P (operands[1])\")\n+\t\t\t\t  (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[1]))\")))\n+\t\t\t  (const_string \"V8DF\")\n+\t\t\t(ior (not (match_test \"TARGET_SSE2\"))\n \t\t\t     (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t\t  (const_string \"V4SF\")\n \t\t\t(match_test \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n@@ -2872,9 +2960,9 @@\n \n (define_insn \"*movsf_internal\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\"\n-\t  \"=Yf*f,m   ,Yf*f,?r ,?m,x,x,x,m,?r,?Yi,!*y,!*y,!m,!r ,!*Ym\")\n+\t  \"=Yf*f,m   ,Yf*f,?r ,?m,v,v,v,m,?r,?Yi,!*y,!*y,!m,!r ,!*Ym\")\n \t(match_operand:SF 1 \"general_operand\"\n-\t  \"Yf*fm,Yf*f,G   ,rmF,rF,C,x,m,x,Yj,r  ,*y ,m  ,*y,*Yn,r\"))]\n+\t  \"Yf*fm,Yf*f,G   ,rmF,rF,C,v,m,v,Yj,r  ,*y ,m  ,*y,*Yn,r\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (!can_create_pseudo_p ()\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n@@ -2907,6 +2995,8 @@\n \t    return \"vmovss\\t{%1, %0, %0|%0, %0, %1}\";\n \t  return \"%vmovss\\t{%1, %0|%0, %1}\";\n \n+\tcase MODE_V16SF:\n+\t  return \"vmovaps\\t{%g1, %g0|%g0, %g1}\";\n \tcase MODE_V4SF:\n \t  return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \n@@ -2960,6 +3050,8 @@\n \t       (eq_attr \"alternative\" \"5\")\n \t\t (cond [(not (match_test \"TARGET_SSE2\"))\n  \t\t \t  (const_string \"V4SF\")\n+\t\t\t(match_test \"TARGET_AVX512F\")\n+\t\t\t  (const_string \"V16SF\")\n \t\t\t(match_test \"TARGET_AVX\")\n \t\t\t  (const_string \"V4SF\")\n  \t\t\t(match_test \"optimize_function_for_size_p (cfun)\")\n@@ -2979,10 +3071,16 @@\n \t\t  of instructions to load just part of the register.  It is\n \t\t  better to maintain the whole registers in single format\n \t\t  to avoid problems on using packed logical operations.  */\n-\t       (and (eq_attr \"alternative\" \"6\")\n-\t\t    (ior (match_test \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n-\t\t\t (match_test \"TARGET_SSE_SPLIT_REGS\")))\n-\t\t (const_string \"V4SF\")\n+\t       (eq_attr \"alternative\" \"6\")\n+\t\t (cond [(ior (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[0]))\")\n+\t\t\t     (and (match_test \"REG_P (operands[1])\")\n+\t\t\t\t  (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[1]))\")))\n+\t\t\t  (const_string \"V16SF\")\n+\t\t\t(ior (match_test \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n+\t\t\t     (match_test \"TARGET_SSE_SPLIT_REGS\"))\n+\t\t\t  (const_string \"V4SF\")\n+\t\t       ]\n+\t\t       (const_string \"SF\"))\n \t      ]\n \t      (const_string \"SF\")))])\n \n@@ -12654,10 +12752,10 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_<mode>_comm_sse\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,v\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,x\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")]))]\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,v\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,vm\")]))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n@@ -16002,10 +16100,10 @@\n ;; are undefined in this condition, we're certain this is correct.\n \n (define_insn \"<code><mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,v\")\n \t(smaxmin:MODEF\n-\t  (match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,x\")\n-\t  (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,v\")\n+\t  (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n   \"@\n    <maxmin_float><ssemodesuffix>\\t{%2, %0|%0, %2}"}, {"sha": "5495c295f57cfd17c6beffdb5aff1b8718a8f64c", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -517,6 +517,22 @@ mavx2\n Target Report Mask(ISA_AVX2) Var(ix86_isa_flags) Save\n Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and AVX2 built-in functions and code generation\n \n+mavx512f\n+Target Report Mask(ISA_AVX512F) Var(ix86_isa_flags) Save\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2 and AVX512F built-in functions and code generation\n+\n+mavx512pf\n+Target Report Mask(ISA_AVX512PF) Var(ix86_isa_flags) Save\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2 and AVX512F and AVX512PF built-in functions and code generation\n+\n+mavx512er\n+Target Report Mask(ISA_AVX512ER) Var(ix86_isa_flags) Save\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2 and AVX512F and AVX512ER built-in functions and code generation\n+\n+mavx512cd\n+Target Report Mask(ISA_AVX512CD) Var(ix86_isa_flags) Save\n+Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2 and AVX512F and AVX512CD built-in functions and code generation\n+\n mfma\n Target Report Mask(ISA_FMA) Var(ix86_isa_flags) Save\n Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX and FMA built-in functions and code generation"}, {"sha": "681cdb785852b0043eb98a60d4d7ecb58162fc04", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -78,9 +78,9 @@\n \n (define_insn \"*mov<mode>_internal\"\n   [(set (match_operand:MMXMODE 0 \"nonimmediate_operand\"\n-    \"=r ,o ,r,r ,m ,?!y,!y,?!y,m  ,r   ,?!Ym,x,x,x,m,*x,*x,*x,m ,r ,Yi,!Ym,*Yi\")\n+    \"=r ,o ,r,r ,m ,?!y,!y,?!y,m  ,r   ,?!Ym,v,v,v,m,*x,*x,*x,m ,r ,Yi,!Ym,*Yi\")\n \t(match_operand:MMXMODE 1 \"vector_move_operand\"\n-    \"rCo,rC,C,rm,rC,C  ,!y,m  ,?!y,?!Yn,r   ,C,x,m,x,C ,*x,m ,*x,Yj,r ,*Yj,!Yn\"))]\n+    \"rCo,rC,C,rm,rC,C  ,!y,m  ,?!y,?!Yn,r   ,C,v,m,v,C ,*x,m ,*x,Yj,r ,*Yj,!Yn\"))]\n   \"TARGET_MMX\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n@@ -128,6 +128,9 @@\n \tcase MODE_TI:\n \t  return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n \n+\tcase MODE_XI:\n+\t  return \"vmovdqa64\\t{%g1, %g0|%g0, %g1}\";\n+\n \tcase MODE_V2SF:\n \t  if (TARGET_AVX && REG_P (operands[0]))\n \t    return \"vmovlps\\t{%1, %0, %0|%0, %0, %1}\";\n@@ -182,7 +185,11 @@\n      (cond [(eq_attr \"alternative\" \"2\")\n \t      (const_string \"SI\")\n \t    (eq_attr \"alternative\" \"11,12,15,16\")\n-\t      (cond [(match_test \"<MODE>mode == V2SFmode\")\n+\t      (cond [(ior (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[0]))\")\n+\t\t\t  (and (match_test \"REG_P (operands[1])\")\n+\t\t\t       (match_test \"EXT_REX_SSE_REGNO_P (REGNO (operands[1]))\")))\n+\t\t\t(const_string \"XI\")\n+\t\t     (match_test \"<MODE>mode == V2SFmode\")\n \t\t       (const_string \"V4SF\")\n \t\t     (ior (not (match_test \"TARGET_SSE2\"))\n \t\t\t  (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))"}, {"sha": "9d9469e2c62f796adc8e631e2d358c4b4df7b114", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 198, "deletions": 138, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -244,6 +244,13 @@\n    (V4SI \"vec\") (V8SI \"avx2\")\n    (V2DI \"vec\") (V4DI \"avx2\")])\n \n+(define_mode_attr shuffletype\n+  [(V16SF \"f\") (V16SI \"i\") (V8DF \"f\") (V8DI \"i\")\n+  (V8SF \"f\") (V8SI \"i\") (V4DF \"f\") (V4DI \"i\")\n+  (V4SF \"f\") (V4SI \"i\") (V2DF \"f\") (V2DI \"i\")\n+  (V32QI \"i\") (V16HI \"u\") (V16QI \"i\") (V8HI \"i\")\n+  (V64QI \"i\") (V1TI \"i\") (V2TI \"i\")])\n+\n (define_mode_attr ssedoublemode\n   [(V16HI \"V16SI\") (V8HI \"V8SI\") (V4HI \"V4SI\")\n    (V32QI \"V32HI\") (V16QI \"V16HI\")])\n@@ -301,8 +308,10 @@\n \n ;; SSE instruction mode\n (define_mode_attr sseinsnmode\n-  [(V32QI \"OI\") (V16HI \"OI\") (V8SI \"OI\") (V4DI \"OI\") (V2TI \"OI\")\n+  [(V64QI \"XI\") (V32HI \"XI\") (V16SI \"XI\") (V8DI \"XI\")\n+   (V32QI \"OI\") (V16HI \"OI\") (V8SI \"OI\") (V4DI \"OI\") (V2TI \"OI\")\n    (V16QI \"TI\") (V8HI \"TI\") (V4SI \"TI\") (V2DI \"TI\") (V1TI \"TI\")\n+   (V16SF \"V16SF\") (V8DF \"V8DF\")\n    (V8SF \"V8SF\") (V4DF \"V4DF\")\n    (V4SF \"V4SF\") (V2DF \"V2DF\")\n    (TI \"TI\")])\n@@ -444,20 +453,64 @@\n })\n \n (define_insn \"*mov<mode>_internal\"\n-  [(set (match_operand:VMOVE 0 \"nonimmediate_operand\"               \"=x,x ,m\")\n-\t(match_operand:VMOVE 1 \"nonimmediate_or_sse_const_operand\"  \"C ,xm,x\"))]\n+  [(set (match_operand:VMOVE 0 \"nonimmediate_operand\"               \"=v,v ,m\")\n+\t(match_operand:VMOVE 1 \"nonimmediate_or_sse_const_operand\"  \"C ,vm,v\"))]\n   \"TARGET_SSE\n    && (register_operand (operands[0], <MODE>mode)\n        || register_operand (operands[1], <MODE>mode))\"\n {\n+  int mode = get_attr_mode (insn);\n   switch (which_alternative)\n     {\n     case 0:\n       return standard_sse_constant_opcode (insn, operands[1]);\n     case 1:\n     case 2:\n-      switch (get_attr_mode (insn))\n+      /* There is no evex-encoded vmov* for sizes smaller than 64-bytes\n+\t in avx512f, so we need to use workarounds, to access sse registers\n+\t 16-31, which are evex-only.  */\n+      if (TARGET_AVX512F && GET_MODE_SIZE (<MODE>mode) < 64\n+\t  && (EXT_REX_SSE_REGNO_P (REGNO (operands[0]))\n+\t      || EXT_REX_SSE_REGNO_P (REGNO (operands[1]))))\n+\t{\n+\t  if (memory_operand (operands[0], <MODE>mode))\n+\t    {\n+\t      if (GET_MODE_SIZE (<MODE>mode) == 32)\n+\t\treturn \"vextract<shuffletype>64x4\\t{$0x0, %g1, %0|%0, %g1, 0x0}\";\n+\t      else if (GET_MODE_SIZE (<MODE>mode) == 16)\n+\t\treturn \"vextract<shuffletype>32x4\\t{$0x0, %g1, %0|%0, %g1, 0x0}\";\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  else if (memory_operand (operands[1], <MODE>mode))\n+\t    {\n+\t      if (GET_MODE_SIZE (<MODE>mode) == 32)\n+\t\treturn \"vbroadcast<shuffletype>64x4\\t{%1, %g0|%g0, %1}\";\n+\t      else if (GET_MODE_SIZE (<MODE>mode) == 16)\n+\t\treturn \"vbroadcast<shuffletype>32x4\\t{%1, %g0|%g0, %1}\";\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  else\n+\t    /* Reg -> reg move is always aligned.  Just use wider move.  */\n+\t    switch (mode)\n+\t      {\n+\t      case MODE_V8SF:\n+\t      case MODE_V4SF:\n+\t\treturn \"vmovaps\\t{%g1, %g0|%g0, %g1}\";\n+\t      case MODE_V4DF:\n+\t      case MODE_V2DF:\n+\t\treturn \"vmovapd\\t{%g1, %g0|%g0, %g1}\";\n+\t      case MODE_OI:\n+\t      case MODE_TI:\n+\t\treturn \"vmovdqa64\\t{%g1, %g0|%g0, %g1}\";\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t}\n+      switch (mode)\n \t{\n+\tcase MODE_V16SF:\n \tcase MODE_V8SF:\n \tcase MODE_V4SF:\n \t  if (TARGET_AVX\n@@ -467,6 +520,7 @@\n \t  else\n \t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n \n+\tcase MODE_V8DF:\n \tcase MODE_V4DF:\n \tcase MODE_V2DF:\n \t  if (TARGET_AVX\n@@ -484,6 +538,12 @@\n \t    return \"vmovdqu\\t{%1, %0|%0, %1}\";\n \t  else\n \t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n+\tcase MODE_XI:\n+\t  if (misaligned_operand (operands[0], <MODE>mode)\n+\t      || misaligned_operand (operands[1], <MODE>mode))\n+\t    return \"vmovdqu64\\t{%1, %0|%0, %1}\";\n+\t  else\n+\t    return \"vmovdqa64\\t{%1, %0|%0, %1}\";\n \n \tdefault:\n \t  gcc_unreachable ();\n@@ -603,7 +663,7 @@\n })\n \n (define_insn \"<sse>_loadu<ssemodesuffix><avxsizesuffix>\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n \t(unspec:VF\n \t  [(match_operand:VF 1 \"memory_operand\" \"m\")]\n \t  UNSPEC_LOADU))]\n@@ -662,7 +722,7 @@\n \t      (const_string \"<MODE>\")))])\n \n (define_insn \"<sse2>_loaddqu<avxsizesuffix>\"\n-  [(set (match_operand:VI1 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI1 0 \"register_operand\" \"=v\")\n \t(unspec:VI1 [(match_operand:VI1 1 \"memory_operand\" \"m\")]\n \t\t    UNSPEC_LOADU))]\n   \"TARGET_SSE2\"\n@@ -696,7 +756,7 @@\n \n (define_insn \"<sse2>_storedqu<avxsizesuffix>\"\n   [(set (match_operand:VI1 0 \"memory_operand\" \"=m\")\n-\t(unspec:VI1 [(match_operand:VI1 1 \"register_operand\" \"x\")]\n+\t(unspec:VI1 [(match_operand:VI1 1 \"register_operand\" \"v\")]\n \t\t    UNSPEC_STOREU))]\n   \"TARGET_SSE2\"\n {\n@@ -863,10 +923,10 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<plusminus_insn><mode>3\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(plusminus:VF\n-\t  (match_operand:VF 1 \"nonimmediate_operand\" \"<comm>0,x\")\n-\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"<comm>0,v\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n    <plusminus_mnemonic><ssemodesuffix>\\t{%2, %0|%0, %2}\n@@ -877,11 +937,11 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"<sse>_vm<plusminus_insn><mode>3\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,v\")\n \t(vec_merge:VF_128\n \t  (plusminus:VF_128\n-\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n-\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,v\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,vm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n@@ -917,11 +977,11 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"<sse>_vmmul<mode>3\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,v\")\n \t(vec_merge:VF_128\n \t  (mult:VF_128\n-\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n-\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,v\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,vm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n@@ -960,10 +1020,10 @@\n })\n \n (define_insn \"<sse>_div<mode>3\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(div:VF\n-\t  (match_operand:VF 1 \"register_operand\" \"0,x\")\n-\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VF 1 \"register_operand\" \"0,v\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE\"\n   \"@\n    div<ssemodesuffix>\\t{%2, %0|%0, %2}\n@@ -974,11 +1034,11 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"<sse>_vmdiv<mode>3\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,v\")\n \t(vec_merge:VF_128\n \t  (div:VF_128\n-\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n-\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,v\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,vm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n@@ -1043,8 +1103,8 @@\n })\n \n (define_insn \"<sse>_sqrt<mode>2\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x\")\n-\t(sqrt:VF (match_operand:VF 1 \"nonimmediate_operand\" \"xm\")))]\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n+\t(sqrt:VF (match_operand:VF 1 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_SSE\"\n   \"%vsqrt<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n@@ -1054,11 +1114,11 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"<sse>_vmsqrt<mode>2\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,v\")\n \t(vec_merge:VF_128\n \t  (sqrt:VF_128\n-\t    (match_operand:VF_128 1 \"nonimmediate_operand\" \"xm,xm\"))\n-\t  (match_operand:VF_128 2 \"register_operand\" \"0,x\")\n+\t    (match_operand:VF_128 1 \"nonimmediate_operand\" \"xm,vm\"))\n+\t  (match_operand:VF_128 2 \"register_operand\" \"0,v\")\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n   \"@\n@@ -1124,10 +1184,10 @@\n })\n \n (define_insn \"*<code><mode>3_finite\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(smaxmin:VF\n-\t  (match_operand:VF 1 \"nonimmediate_operand\" \"%0,x\")\n-\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"%0,v\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE && flag_finite_math_only\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n@@ -1140,10 +1200,10 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*<code><mode>3\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(smaxmin:VF\n-\t  (match_operand:VF 1 \"register_operand\" \"0,x\")\n-\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VF 1 \"register_operand\" \"0,v\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE && !flag_finite_math_only\"\n   \"@\n    <maxmin_float><ssemodesuffix>\\t{%2, %0|%0, %2}\n@@ -1155,11 +1215,11 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"<sse>_vm<code><mode>3\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,v\")\n \t(vec_merge:VF_128\n \t  (smaxmin:VF_128\n-\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n-\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,v\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,vm\"))\n \t (match_dup 1)\n \t (const_int 1)))]\n   \"TARGET_SSE\"\n@@ -1790,10 +1850,10 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<code><mode>3\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,v\")\n \t(any_logic:VF\n-\t  (match_operand:VF 1 \"nonimmediate_operand\" \"%0,x\")\n-\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"%0,v\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n   static char buf[32];\n@@ -2101,74 +2161,74 @@\n   \"TARGET_FMA || TARGET_FMA4\")\n \n (define_insn \"*fma_fmadd_<mode>\"\n-  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=v,v,v,x,x\")\n \t(fma:FMAMODE\n-\t  (match_operand:FMAMODE 1 \"nonimmediate_operand\" \"%0, 0,x, x,x\")\n-\t  (match_operand:FMAMODE 2 \"nonimmediate_operand\" \"xm, x,xm,x,m\")\n-\t  (match_operand:FMAMODE 3 \"nonimmediate_operand\" \" x,xm,0,xm,x\")))]\n+\t  (match_operand:FMAMODE 1 \"nonimmediate_operand\" \"%0, 0, v, x,x\")\n+\t  (match_operand:FMAMODE 2 \"nonimmediate_operand\" \"vm, v,vm, x,m\")\n+\t  (match_operand:FMAMODE 3 \"nonimmediate_operand\" \" v,vm, 0,xm,x\")))]\n   \"TARGET_FMA || TARGET_FMA4\"\n   \"@\n    vfmadd132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n    vfmadd213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfmadd231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n    vfmadd<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n    vfmadd<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n-  [(set_attr \"isa\" \"fma,fma,fma,fma4,fma4\")\n+  [(set_attr \"isa\" \"fma_avx512f,fma_avx512f,fma_avx512f,fma4,fma4\")\n    (set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fma_fmsub_<mode>\"\n-  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=v,v,v,x,x\")\n \t(fma:FMAMODE\n-\t  (match_operand:FMAMODE   1 \"nonimmediate_operand\" \"%0, 0,x, x,x\")\n-\t  (match_operand:FMAMODE   2 \"nonimmediate_operand\" \"xm, x,xm,x,m\")\n+\t  (match_operand:FMAMODE   1 \"nonimmediate_operand\" \"%0, 0, v, x,x\")\n+\t  (match_operand:FMAMODE   2 \"nonimmediate_operand\" \"vm, v,vm, x,m\")\n \t  (neg:FMAMODE\n-\t    (match_operand:FMAMODE 3 \"nonimmediate_operand\" \" x,xm,0,xm,x\"))))]\n+\t    (match_operand:FMAMODE 3 \"nonimmediate_operand\" \" v,vm, 0,xm,x\"))))]\n   \"TARGET_FMA || TARGET_FMA4\"\n   \"@\n    vfmsub132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n    vfmsub213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfmsub231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n    vfmsub<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n    vfmsub<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n-  [(set_attr \"isa\" \"fma,fma,fma,fma4,fma4\")\n+  [(set_attr \"isa\" \"fma_avx512f,fma_avx512f,fma_avx512f,fma4,fma4\")\n    (set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fma_fnmadd_<mode>\"\n-  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=v,v,v,x,x\")\n \t(fma:FMAMODE\n \t  (neg:FMAMODE\n-\t    (match_operand:FMAMODE 1 \"nonimmediate_operand\" \"%0, 0,x, x,x\"))\n-\t  (match_operand:FMAMODE   2 \"nonimmediate_operand\" \"xm, x,xm,x,m\")\n-\t  (match_operand:FMAMODE   3 \"nonimmediate_operand\" \" x,xm,0,xm,x\")))]\n+\t    (match_operand:FMAMODE 1 \"nonimmediate_operand\" \"%0, 0, v, x,x\"))\n+\t  (match_operand:FMAMODE   2 \"nonimmediate_operand\" \"vm, v,vm, x,m\")\n+\t  (match_operand:FMAMODE   3 \"nonimmediate_operand\" \" v,vm, 0,xm,x\")))]\n   \"TARGET_FMA || TARGET_FMA4\"\n   \"@\n    vfnmadd132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n    vfnmadd213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfnmadd231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n    vfnmadd<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n    vfnmadd<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n-  [(set_attr \"isa\" \"fma,fma,fma,fma4,fma4\")\n+  [(set_attr \"isa\" \"fma_avx512f,fma_avx512f,fma_avx512f,fma4,fma4\")\n    (set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fma_fnmsub_<mode>\"\n-  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:FMAMODE 0 \"register_operand\" \"=v,v,v,x,x\")\n \t(fma:FMAMODE\n \t  (neg:FMAMODE\n-\t    (match_operand:FMAMODE 1 \"nonimmediate_operand\" \"%0, 0,x, x,x\"))\n-\t  (match_operand:FMAMODE   2 \"nonimmediate_operand\" \"xm, x,xm,x,m\")\n+\t    (match_operand:FMAMODE 1 \"nonimmediate_operand\" \"%0, 0, v, x,x\"))\n+\t  (match_operand:FMAMODE   2 \"nonimmediate_operand\" \"vm, v,vm, x,m\")\n \t  (neg:FMAMODE\n-\t    (match_operand:FMAMODE 3 \"nonimmediate_operand\" \" x,xm,0,xm,x\"))))]\n+\t    (match_operand:FMAMODE 3 \"nonimmediate_operand\" \" v,vm, 0,xm,x\"))))]\n   \"TARGET_FMA || TARGET_FMA4\"\n   \"@\n    vfnmsub132<ssemodesuffix>\\t{%2, %3, %0|%0, %3, %2}\n    vfnmsub213<ssemodesuffix>\\t{%3, %2, %0|%0, %2, %3}\n    vfnmsub231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n    vfnmsub<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n    vfnmsub<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n-  [(set_attr \"isa\" \"fma,fma,fma,fma4,fma4\")\n+  [(set_attr \"isa\" \"fma_avx512f,fma_avx512f,fma_avx512f,fma4,fma4\")\n    (set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -2193,11 +2253,11 @@\n   \"TARGET_FMA || TARGET_FMA4\")\n \n (define_insn \"*fma_fmaddsub_<mode>\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v,v,v,x,x\")\n \t(unspec:VF\n-\t  [(match_operand:VF 1 \"nonimmediate_operand\" \"%0, 0,x, x,x\")\n-\t   (match_operand:VF 2 \"nonimmediate_operand\" \"xm, x,xm,x,m\")\n-\t   (match_operand:VF 3 \"nonimmediate_operand\" \" x,xm,0,xm,x\")]\n+\t  [(match_operand:VF 1 \"nonimmediate_operand\" \"%0, 0, v, x,x\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\" \"vm, v,vm, x,m\")\n+\t   (match_operand:VF 3 \"nonimmediate_operand\" \" v,vm, 0,xm,x\")]\n \t  UNSPEC_FMADDSUB))]\n   \"TARGET_FMA || TARGET_FMA4\"\n   \"@\n@@ -2206,17 +2266,17 @@\n    vfmaddsub231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n    vfmaddsub<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n    vfmaddsub<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n-  [(set_attr \"isa\" \"fma,fma,fma,fma4,fma4\")\n+  [(set_attr \"isa\" \"fma_avx512f,fma_avx512f,fma_avx512f,fma4,fma4\")\n    (set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fma_fmsubadd_<mode>\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x,x,x,x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v,v,v,x,x\")\n \t(unspec:VF\n-\t  [(match_operand:VF   1 \"nonimmediate_operand\" \"%0, 0,x, x,x\")\n-\t   (match_operand:VF   2 \"nonimmediate_operand\" \"xm, x,xm,x,m\")\n+\t  [(match_operand:VF   1 \"nonimmediate_operand\" \"%0, 0, v, x,x\")\n+\t   (match_operand:VF   2 \"nonimmediate_operand\" \"vm, v,vm, x,m\")\n \t   (neg:VF\n-\t     (match_operand:VF 3 \"nonimmediate_operand\" \" x,xm,0,xm,x\"))]\n+\t     (match_operand:VF 3 \"nonimmediate_operand\" \" v,vm, 0,xm,x\"))]\n \t  UNSPEC_FMADDSUB))]\n   \"TARGET_FMA || TARGET_FMA4\"\n   \"@\n@@ -2225,7 +2285,7 @@\n    vfmsubadd231<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n    vfmsubadd<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\n    vfmsubadd<ssemodesuffix>\\t{%3, %2, %1, %0|%0, %1, %2, %3}\"\n-  [(set_attr \"isa\" \"fma,fma,fma,fma4,fma4\")\n+  [(set_attr \"isa\" \"fma_avx512f,fma_avx512f,fma_avx512f,fma4,fma4\")\n    (set_attr \"type\" \"ssemuladd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -2244,12 +2304,12 @@\n   \"TARGET_FMA\")\n \n (define_insn \"*fmai_fmadd_<mode>\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=v,v\")\n         (vec_merge:VF_128\n \t  (fma:VF_128\n \t    (match_operand:VF_128 1 \"nonimmediate_operand\" \" 0, 0\")\n-\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm, x\")\n-\t    (match_operand:VF_128 3 \"nonimmediate_operand\" \" x,xm\"))\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"vm, v\")\n+\t    (match_operand:VF_128 3 \"nonimmediate_operand\" \" v,vm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_FMA\"\n@@ -2260,13 +2320,13 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fmai_fmsub_<mode>\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=v,v\")\n         (vec_merge:VF_128\n \t  (fma:VF_128\n \t    (match_operand:VF_128   1 \"nonimmediate_operand\" \" 0, 0\")\n-\t    (match_operand:VF_128   2 \"nonimmediate_operand\" \"xm, x\")\n+\t    (match_operand:VF_128   2 \"nonimmediate_operand\" \"vm, v\")\n \t    (neg:VF_128\n-\t      (match_operand:VF_128 3 \"nonimmediate_operand\" \" x,xm\")))\n+\t      (match_operand:VF_128 3 \"nonimmediate_operand\" \" v,vm\")))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_FMA\"\n@@ -2277,13 +2337,13 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fmai_fnmadd_<mode>\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=v,v\")\n         (vec_merge:VF_128\n \t  (fma:VF_128\n \t    (neg:VF_128\n-\t      (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm, x\"))\n+\t      (match_operand:VF_128 2 \"nonimmediate_operand\" \"vm, v\"))\n \t    (match_operand:VF_128   1 \"nonimmediate_operand\" \" 0, 0\")\n-\t    (match_operand:VF_128   3 \"nonimmediate_operand\" \" x,xm\"))\n+\t    (match_operand:VF_128   3 \"nonimmediate_operand\" \" v,vm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_FMA\"\n@@ -2294,14 +2354,14 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fmai_fnmsub_<mode>\"\n-  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=v,v\")\n         (vec_merge:VF_128\n \t  (fma:VF_128\n \t    (neg:VF_128\n-\t      (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm, x\"))\n+\t      (match_operand:VF_128 2 \"nonimmediate_operand\" \"vm, v\"))\n \t    (match_operand:VF_128   1 \"nonimmediate_operand\" \" 0, 0\")\n \t    (neg:VF_128\n-\t      (match_operand:VF_128 3 \"nonimmediate_operand\" \" x,xm\")))\n+\t      (match_operand:VF_128 3 \"nonimmediate_operand\" \" v,vm\")))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n   \"TARGET_FMA\"\n@@ -2429,11 +2489,11 @@\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"sse_cvtsi2ss\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,v\")\n \t(vec_merge:V4SF\n \t  (vec_duplicate:V4SF\n \t    (float:SF (match_operand:SI 2 \"nonimmediate_operand\" \"r,m,rm\")))\n-\t  (match_operand:V4SF 1 \"register_operand\" \"0,0,x\")\n+\t  (match_operand:V4SF 1 \"register_operand\" \"0,0,v\")\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n   \"@\n@@ -2450,11 +2510,11 @@\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"sse_cvtsi2ssq\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,v\")\n \t(vec_merge:V4SF\n \t  (vec_duplicate:V4SF\n \t    (float:SF (match_operand:DI 2 \"nonimmediate_operand\" \"r,m,rm\")))\n-\t  (match_operand:V4SF 1 \"register_operand\" \"0,0,x\")\n+\t  (match_operand:V4SF 1 \"register_operand\" \"0,0,v\")\n \t  (const_int 1)))]\n   \"TARGET_SSE && TARGET_64BIT\"\n   \"@\n@@ -2476,7 +2536,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(unspec:SI\n \t  [(vec_select:SF\n-\t     (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,m\")\n+\t     (match_operand:V4SF 1 \"nonimmediate_operand\" \"v,m\")\n \t     (parallel [(const_int 0)]))]\n \t  UNSPEC_FIX_NOTRUNC))]\n   \"TARGET_SSE\"\n@@ -2490,7 +2550,7 @@\n \n (define_insn \"sse_cvtss2si_2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(unspec:SI [(match_operand:SF 1 \"nonimmediate_operand\" \"x,m\")]\n+\t(unspec:SI [(match_operand:SF 1 \"nonimmediate_operand\" \"v,m\")]\n \t\t   UNSPEC_FIX_NOTRUNC))]\n   \"TARGET_SSE\"\n   \"%vcvtss2si\\t{%1, %0|%0, %k1}\"\n@@ -2506,7 +2566,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(unspec:DI\n \t  [(vec_select:SF\n-\t     (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,m\")\n+\t     (match_operand:V4SF 1 \"nonimmediate_operand\" \"v,m\")\n \t     (parallel [(const_int 0)]))]\n \t  UNSPEC_FIX_NOTRUNC))]\n   \"TARGET_SSE && TARGET_64BIT\"\n@@ -2536,7 +2596,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(fix:SI\n \t  (vec_select:SF\n-\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,m\")\n+\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"v,m\")\n \t    (parallel [(const_int 0)]))))]\n   \"TARGET_SSE\"\n   \"%vcvttss2si\\t{%1, %0|%0, %k1}\"\n@@ -2552,7 +2612,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(fix:DI\n \t  (vec_select:SF\n-\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"x,m\")\n+\t    (match_operand:V4SF 1 \"nonimmediate_operand\" \"v,m\")\n \t    (parallel [(const_int 0)]))))]\n   \"TARGET_SSE && TARGET_64BIT\"\n   \"%vcvttss2si{q}\\t{%1, %0|%0, %k1}\"\n@@ -2565,9 +2625,9 @@\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"float<sseintvecmodelower><mode>2\"\n-  [(set (match_operand:VF1 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VF1 0 \"register_operand\" \"=v\")\n \t(float:VF1\n-\t  (match_operand:<sseintvecmode> 1 \"nonimmediate_operand\" \"xm\")))]\n+\t  (match_operand:<sseintvecmode> 1 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_SSE2\"\n   \"%vcvtdq2ps\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n@@ -2752,7 +2812,7 @@\n \n (define_insn \"sse2_cvtsd2si_2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(unspec:SI [(match_operand:DF 1 \"nonimmediate_operand\" \"x,m\")]\n+\t(unspec:SI [(match_operand:DF 1 \"nonimmediate_operand\" \"v,m\")]\n \t\t   UNSPEC_FIX_NOTRUNC))]\n   \"TARGET_SSE2\"\n   \"%vcvtsd2si\\t{%1, %0|%0, %q1}\"\n@@ -2782,7 +2842,7 @@\n \n (define_insn \"sse2_cvtsd2siq_2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(unspec:DI [(match_operand:DF 1 \"nonimmediate_operand\" \"x,m\")]\n+\t(unspec:DI [(match_operand:DF 1 \"nonimmediate_operand\" \"v,m\")]\n \t\t   UNSPEC_FIX_NOTRUNC))]\n   \"TARGET_SSE2 && TARGET_64BIT\"\n   \"%vcvtsd2si{q}\\t{%1, %0|%0, %q1}\"\n@@ -2981,12 +3041,12 @@\n    (set_attr \"mode\" \"TI\")])\n \n (define_insn \"sse2_cvtsd2ss\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,v\")\n \t(vec_merge:V4SF\n \t  (vec_duplicate:V4SF\n \t    (float_truncate:V2SF\n-\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,m,xm\")))\n-\t  (match_operand:V4SF 1 \"register_operand\" \"0,0,x\")\n+\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"x,m,vm\")))\n+\t  (match_operand:V4SF 1 \"register_operand\" \"0,0,v\")\n \t  (const_int 1)))]\n   \"TARGET_SSE2\"\n   \"@\n@@ -3003,13 +3063,13 @@\n    (set_attr \"mode\" \"SF\")])\n \n (define_insn \"sse2_cvtss2sd\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x,x\")\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x,v\")\n \t(vec_merge:V2DF\n \t  (float_extend:V2DF\n \t    (vec_select:V2SF\n-\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,m,xm\")\n+\t      (match_operand:V4SF 2 \"nonimmediate_operand\" \"x,m,vm\")\n \t      (parallel [(const_int 0) (const_int 1)])))\n-\t  (match_operand:V2DF 1 \"register_operand\" \"0,0,x\")\n+\t  (match_operand:V2DF 1 \"register_operand\" \"0,0,v\")\n \t  (const_int 1)))]\n   \"TARGET_SSE2\"\n   \"@\n@@ -5243,10 +5303,10 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<plusminus_insn><mode>3\"\n-  [(set (match_operand:VI_AVX2 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VI_AVX2 0 \"register_operand\" \"=x,v\")\n \t(plusminus:VI_AVX2\n-\t  (match_operand:VI_AVX2 1 \"nonimmediate_operand\" \"<comm>0,x\")\n-\t  (match_operand:VI_AVX2 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VI_AVX2 1 \"nonimmediate_operand\" \"<comm>0,v\")\n+\t  (match_operand:VI_AVX2 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE2 && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n    p<plusminus_mnemonic><ssemodesuffix>\\t{%2, %0|%0, %2}\n@@ -5266,10 +5326,10 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<sse2_avx2>_<plusminus_insn><mode>3\"\n-  [(set (match_operand:VI12_AVX2 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VI12_AVX2 0 \"register_operand\" \"=x,v\")\n \t(sat_plusminus:VI12_AVX2\n-\t  (match_operand:VI12_AVX2 1 \"nonimmediate_operand\" \"<comm>0,x\")\n-\t  (match_operand:VI12_AVX2 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VI12_AVX2 1 \"nonimmediate_operand\" \"<comm>0,v\")\n+\t  (match_operand:VI12_AVX2 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE2 && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"@\n    p<plusminus_mnemonic><ssemodesuffix>\\t{%2, %0|%0, %2}\n@@ -5641,10 +5701,10 @@\n })\n \n (define_insn \"*<sse4_1_avx2>_mul<mode>3\"\n-  [(set (match_operand:VI4_AVX2 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VI4_AVX2 0 \"register_operand\" \"=x,v\")\n \t(mult:VI4_AVX2\n-\t  (match_operand:VI4_AVX2 1 \"nonimmediate_operand\" \"%0,x\")\n-\t  (match_operand:VI4_AVX2 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VI4_AVX2 1 \"nonimmediate_operand\" \"%0,v\")\n+\t  (match_operand:VI4_AVX2 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE4_1 && ix86_binary_operator_ok (MULT, <MODE>mode, operands)\"\n   \"@\n    pmulld\\t{%2, %0|%0, %2}\n@@ -5765,9 +5825,9 @@\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n (define_insn \"<shift_insn><mode>3\"\n-  [(set (match_operand:VI248_AVX2 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VI248_AVX2 0 \"register_operand\" \"=x,v\")\n \t(any_lshift:VI248_AVX2\n-\t  (match_operand:VI248_AVX2 1 \"register_operand\" \"0,x\")\n+\t  (match_operand:VI248_AVX2 1 \"register_operand\" \"0,v\")\n \t  (match_operand:SI 2 \"nonmemory_operand\" \"xN,xN\")))]\n   \"TARGET_SSE2\"\n   \"@\n@@ -5868,10 +5928,10 @@\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*avx2_<code><mode>3\"\n-  [(set (match_operand:VI124_256 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI124_256 0 \"register_operand\" \"=v\")\n \t(maxmin:VI124_256\n-\t  (match_operand:VI124_256 1 \"nonimmediate_operand\" \"%x\")\n-\t  (match_operand:VI124_256 2 \"nonimmediate_operand\" \"xm\")))]\n+\t  (match_operand:VI124_256 1 \"nonimmediate_operand\" \"%v\")\n+\t  (match_operand:VI124_256 2 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_AVX2 && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n   \"vp<maxmin_int><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sseiadd\")\n@@ -6345,10 +6405,10 @@\n   \"TARGET_SSE2\")\n \n (define_insn \"*andnot<mode>3\"\n-  [(set (match_operand:VI 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VI 0 \"register_operand\" \"=x,v\")\n \t(and:VI\n-\t  (not:VI (match_operand:VI 1 \"register_operand\" \"0,x\"))\n-\t  (match_operand:VI 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (not:VI (match_operand:VI 1 \"register_operand\" \"0,v\"))\n+\t  (match_operand:VI 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE\"\n {\n   static char buf[32];\n@@ -6429,10 +6489,10 @@\n })\n \n (define_insn \"*<code><mode>3\"\n-  [(set (match_operand:VI 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:VI 0 \"register_operand\" \"=x,v\")\n \t(any_logic:VI\n-\t  (match_operand:VI 1 \"nonimmediate_operand\" \"%0,x\")\n-\t  (match_operand:VI 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+\t  (match_operand:VI 1 \"nonimmediate_operand\" \"%0,v\")\n+\t  (match_operand:VI 2 \"nonimmediate_operand\" \"xm,vm\")))]\n   \"TARGET_SSE\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n {\n@@ -8368,9 +8428,9 @@\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"abs<mode>2\"\n-  [(set (match_operand:VI124_AVX2 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI124_AVX2 0 \"register_operand\" \"=v\")\n \t(abs:VI124_AVX2\n-\t  (match_operand:VI124_AVX2 1 \"nonimmediate_operand\" \"xm\")))]\n+\t  (match_operand:VI124_AVX2 1 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_SSSE3\"\n   \"%vpabs<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sselog1\")\n@@ -10481,10 +10541,10 @@\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n (define_insn \"avx2_permvar<mode>\"\n-  [(set (match_operand:VI4F_256 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI4F_256 0 \"register_operand\" \"=v\")\n \t(unspec:VI4F_256\n-\t  [(match_operand:VI4F_256 1 \"nonimmediate_operand\" \"xm\")\n-\t   (match_operand:V8SI 2 \"register_operand\" \"x\")]\n+\t  [(match_operand:VI4F_256 1 \"nonimmediate_operand\" \"vm\")\n+\t   (match_operand:V8SI 2 \"register_operand\" \"v\")]\n \t  UNSPEC_VPERMVAR))]\n   \"TARGET_AVX2\"\n   \"vperm<ssemodesuffix>\\t{%1, %2, %0|%0, %2, %1}\"\n@@ -10508,9 +10568,9 @@\n })\n \n (define_insn \"avx2_perm<mode>_1\"\n-  [(set (match_operand:VI8F_256 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI8F_256 0 \"register_operand\" \"=v\")\n \t(vec_select:VI8F_256\n-\t  (match_operand:VI8F_256 1 \"nonimmediate_operand\" \"xm\")\n+\t  (match_operand:VI8F_256 1 \"nonimmediate_operand\" \"vm\")\n \t  (parallel [(match_operand 2 \"const_0_to_3_operand\")\n \t\t     (match_operand 3 \"const_0_to_3_operand\")\n \t\t     (match_operand 4 \"const_0_to_3_operand\")\n@@ -10735,9 +10795,9 @@\n })\n \n (define_insn \"*avx_vpermilp<mode>\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n \t(vec_select:VF\n-\t  (match_operand:VF 1 \"nonimmediate_operand\" \"xm\")\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"vm\")\n \t  (match_parallel 2 \"\"\n \t    [(match_operand 3 \"const_int_operand\")])))]\n   \"TARGET_AVX\n@@ -10754,10 +10814,10 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"avx_vpermilvar<mode>3\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n \t(unspec:VF\n-\t  [(match_operand:VF 1 \"register_operand\" \"x\")\n-\t   (match_operand:<sseintvecmode> 2 \"nonimmediate_operand\" \"xm\")]\n+\t  [(match_operand:VF 1 \"register_operand\" \"v\")\n+\t   (match_operand:<sseintvecmode> 2 \"nonimmediate_operand\" \"vm\")]\n \t  UNSPEC_VPERMIL))]\n   \"TARGET_AVX\"\n   \"vpermil<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n@@ -11149,21 +11209,21 @@\n })\n \n (define_insn \"avx2_ashrv<mode>\"\n-  [(set (match_operand:VI4_AVX2 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI4_AVX2 0 \"register_operand\" \"=v\")\n \t(ashiftrt:VI4_AVX2\n-\t  (match_operand:VI4_AVX2 1 \"register_operand\" \"x\")\n-\t  (match_operand:VI4_AVX2 2 \"nonimmediate_operand\" \"xm\")))]\n+\t  (match_operand:VI4_AVX2 1 \"register_operand\" \"v\")\n+\t  (match_operand:VI4_AVX2 2 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_AVX2\"\n   \"vpsravd\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sseishft\")\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n (define_insn \"avx2_<shift_insn>v<mode>\"\n-  [(set (match_operand:VI48_AVX2 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:VI48_AVX2 0 \"register_operand\" \"=v\")\n \t(any_lshift:VI48_AVX2\n-\t  (match_operand:VI48_AVX2 1 \"register_operand\" \"x\")\n-\t  (match_operand:VI48_AVX2 2 \"nonimmediate_operand\" \"xm\")))]\n+\t  (match_operand:VI48_AVX2 1 \"register_operand\" \"v\")\n+\t  (match_operand:VI48_AVX2 2 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_AVX2\"\n   \"vp<vshift>v<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sseishft\")"}, {"sha": "411c8be66c15ba54056828ae1f33336b0cff1539", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -648,7 +648,8 @@ Objective-C and Objective-C++ Dialects}.\n -mrecip -mrecip=@var{opt} @gol\n -mvzeroupper -mprefer-avx128 @gol\n -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 -mavx @gol\n--mavx2 -maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfma @gol\n+-mavx2 -mavx512f -mavx512pf -mavx512er -mavx512cd @gol\n+-maes -mpclmul -mfsgsbase -mrdrnd -mf16c -mfma @gol\n -msse4a -m3dnow -mpopcnt -mabm -mbmi -mtbm -mfma4 -mxop -mlzcnt @gol\n -mbmi2 -mrtm -mlwp -mthreads @gol\n -mno-align-stringops  -minline-all-stringops @gol\n@@ -14368,11 +14369,20 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -mno-avx\n @itemx -mavx2\n @itemx -mno-avx2\n+@itemx -mavx512f\n+@itemx -mno-avx512f\n+@need 800\n+@itemx -mavx512pf\n+@itemx -mno-avx512pf\n+@itemx -mavx512er\n+@itemx -mno-avx512er\n+@itemx -mavx512cd\n+@itemx -mno-avx512cd\n @itemx -maes\n @itemx -mno-aes\n @itemx -mpclmul\n-@need 800\n @itemx -mno-pclmul\n+@need 800\n @itemx -mfsgsbase\n @itemx -mno-fsgsbase\n @itemx -mrdrnd\n@@ -14384,8 +14394,8 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @itemx -msse4a\n @itemx -mno-sse4a\n @itemx -mfma4\n-@need 800\n @itemx -mno-fma4\n+@need 800\n @itemx -mxop\n @itemx -mno-xop\n @itemx -mlwp\n@@ -14412,8 +14422,9 @@ preferred alignment to @option{-mpreferred-stack-boundary=2}.\n @opindex m3dnow\n @opindex mno-3dnow\n These switches enable or disable the use of instructions in the MMX, SSE,\n-SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AES, PCLMUL, FSGSBASE, RDRND, F16C,\n-FMA, SSE4A, FMA4, XOP, LWP, ABM, BMI, BMI2, LZCNT, RTM or 3DNow!@:\n+SSE2, SSE3, SSSE3, SSE4.1, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD,\n+AES, PCLMUL, FSGSBASE, RDRND, F16C, FMA, SSE4A, FMA4, XOP, LWP, ABM, BMI, BMI2,\n+LZCNT, RTM or 3DNow!@:\n extended instruction sets.\n These extensions are also available as built-in functions: see\n @ref{X86 Built-in Functions}, for details of the functions enabled and"}, {"sha": "1d6222382b8d84073b9b50f988663f7751c1c06a", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f97cb0b278d59b8923d0b10edfd60d357dc55a7/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=3f97cb0b278d59b8923d0b10edfd60d357dc55a7", "patch": "@@ -1097,6 +1097,10 @@ this is the right mode to use for certain pointers.\n @item OImode\n ``Octa Integer'' (?) mode represents a thirty-two-byte integer.\n \n+@findex XImode\n+@item XImode\n+``Hexadeca Integer'' (?) mode represents a sixty-four-byte integer.\n+\n @findex QFmode\n @item QFmode\n ``Quarter-Floating'' mode represents a quarter-precision (single byte)"}]}