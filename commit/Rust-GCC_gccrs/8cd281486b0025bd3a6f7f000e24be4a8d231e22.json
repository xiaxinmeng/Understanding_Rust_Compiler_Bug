{"sha": "8cd281486b0025bd3a6f7f000e24be4a8d231e22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNkMjgxNDg2YjAwMjViZDNhNmY3ZjAwMGUyNGJlNGE4ZDIzMWUyMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-06-03T10:26:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-06-03T10:26:20Z"}, "message": "decl.c (substitution_list): Rename to build_subst_list, remove unused parameter and simplify.\n\n\t* gcc-interface/decl.c (substitution_list): Rename to build_subst_list,\n\tremove unused parameter and simplify.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Do not set TYPE_FIELDS.  Factor\n\tcommon predicate.  Rewrite loop for clarity.  Use GNU_TYPE directly\n\tas context for all discriminants.  Fix formatting nits.\n\t<E_Record_Subtype>: Add cosmetic 'break'.  Test Has_Discriminants\n\tbefore Discriminant_Constraint.  Adjust for above renaming.  Do not\n\tset GNU_TYPE more than once.\n\t(elaborate_entity): Test Has_Discriminants on the entity and use\n\tImplementation_Base_Type.\n\t(components_to_record): Rename component_list to gnat_component_list.\n\tRetrieve the _Parent field from the list.  Fix nits in comments.\n\tClarify logic in loop.  Pass correct arguments to create_field_decl.\n\nFrom-SVN: r148121", "tree": {"sha": "c833d0c3da4817c882c31a5e4d3f40ce6af59186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c833d0c3da4817c882c31a5e4d3f40ce6af59186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cd281486b0025bd3a6f7f000e24be4a8d231e22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd281486b0025bd3a6f7f000e24be4a8d231e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd281486b0025bd3a6f7f000e24be4a8d231e22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd281486b0025bd3a6f7f000e24be4a8d231e22/comments", "author": null, "committer": null, "parents": [{"sha": "2f2c62a01c83501641695f64c88139386552bd35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2c62a01c83501641695f64c88139386552bd35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2c62a01c83501641695f64c88139386552bd35"}], "stats": {"total": 374, "additions": 197, "deletions": 177}, "files": [{"sha": "15b8cf3447422f6a1a18231172cc9629be6bd336", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd281486b0025bd3a6f7f000e24be4a8d231e22/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd281486b0025bd3a6f7f000e24be4a8d231e22/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8cd281486b0025bd3a6f7f000e24be4a8d231e22", "patch": "@@ -1,3 +1,19 @@\n+2009-06-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (substitution_list): Rename to build_subst_list,\n+\tremove unused parameter and simplify.\n+\t(gnat_to_gnu_entity) <E_Record_Type>: Do not set TYPE_FIELDS.  Factor\n+\tcommon predicate.  Rewrite loop for clarity.  Use GNU_TYPE directly\n+\tas context for all discriminants.  Fix formatting nits.\n+\t<E_Record_Subtype>: Add cosmetic 'break'.  Test Has_Discriminants\n+\tbefore Discriminant_Constraint.  Adjust for above renaming.  Do not\n+\tset GNU_TYPE more than once.\n+\t(elaborate_entity): Test Has_Discriminants on the entity and use\n+\tImplementation_Base_Type.\n+\t(components_to_record): Rename component_list to gnat_component_list.\n+\tRetrieve the _Parent field from the list.  Fix nits in comments.\n+\tClarify logic in loop.  Pass correct arguments to create_field_decl.\n+\n 2009-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Fix formatting."}, {"sha": "f344f359b6c8dea10bff505f88af21402aa9d7de", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 181, "deletions": 177, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd281486b0025bd3a6f7f000e24be4a8d231e22/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd281486b0025bd3a6f7f000e24be4a8d231e22/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8cd281486b0025bd3a6f7f000e24be4a8d231e22", "patch": "@@ -121,7 +121,7 @@ enum alias_set_op\n \n static void relate_alias_sets (tree, tree, enum alias_set_op);\n \n-static tree substitution_list (Entity_Id, Entity_Id, tree, bool);\n+static tree build_subst_list (Entity_Id, Entity_Id, bool);\n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute_to (struct attrib **,\n \t\t\t\t      enum attr_type, tree, tree, Node_Id);\n@@ -1820,7 +1820,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type = make_node (UNCONSTRAINED_ARRAY_TYPE);\n \n \tif (!definition)\n-\t  defer_incomplete_level++, this_deferred = true;\n+\t  {\n+\t    defer_incomplete_level++;\n+\t    this_deferred = true;\n+\t  }\n \n \t/* Build the fat pointer type.  Use a \"void *\" object instead of\n \t   a pointer to the array type since we don't have the array type\n@@ -2743,16 +2746,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool is_extension\n \t  = (Is_Tagged_Type (gnat_entity)\n \t     && Nkind (record_definition) == N_Derived_Type_Definition);\n+\tbool is_unchecked_union = Is_Unchecked_Union (gnat_entity);\n \n \t/* See if all fields have a rep clause.  Stop when we find one\n \t   that doesn't.  */\n-\tfor (gnat_field = First_Entity (gnat_entity);\n-\t     Present (gnat_field) && all_rep;\n-\t     gnat_field = Next_Entity (gnat_field))\n-\t  if ((Ekind (gnat_field) == E_Component\n-\t       || Ekind (gnat_field) == E_Discriminant)\n-\t      && No (Component_Clause (gnat_field)))\n-\t    all_rep = false;\n+\tif (all_rep)\n+\t  for (gnat_field = First_Entity (gnat_entity);\n+\t       Present (gnat_field);\n+\t       gnat_field = Next_Entity (gnat_field))\n+\t    if ((Ekind (gnat_field) == E_Component\n+\t\t || Ekind (gnat_field) == E_Discriminant)\n+\t\t&& No (Component_Clause (gnat_field)))\n+\t      {\n+\t\tall_rep = false;\n+\t\tbreak;\n+\t      }\n \n \t/* If this is a record extension, go a level further to find the\n \t   record definition.  Also, verify we have a Parent_Subtype.  */\n@@ -2773,7 +2781,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_PACKED (gnu_type) = (packed != 0) || has_rep;\n \n \tif (!definition)\n-\t  defer_incomplete_level++, this_deferred = true;\n+\t  {\n+\t    defer_incomplete_level++;\n+\t    this_deferred = true;\n+\t  }\n \n \t/* If both a size and rep clause was specified, put the size in\n \t   the record type now so that it can get the proper mode.  */\n@@ -2908,7 +2919,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       proper type...  */\n \t    TREE_TYPE (gnu_get_parent) = gnu_parent;\n \n-\t    /* ...and reference the _parent field of this record.  */\n+\t    /* ...and reference the _Parent field of this record.  */\n \t    gnu_field_list\n \t      = create_field_decl (get_identifier\n \t\t\t\t   (Get_Name_String (Name_uParent)),\n@@ -2926,9 +2937,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       Present (gnat_field);\n \t       gnat_field = Next_Stored_Discriminant (gnat_field))\n \t    {\n-\t      /* If this is a record extension and this discriminant\n-\t\t is the renaming of another discriminant, we've already\n-\t\t handled the discriminant above.  */\n+\t      /* If this is a record extension and this discriminant is the\n+\t\t renaming of another discriminant, we've handled it above.  */\n \t      if (Present (Parent_Subtype (gnat_entity))\n \t\t  && Present (Corresponding_Discriminant (gnat_field)))\n \t\tcontinue;\n@@ -2938,53 +2948,46 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* Make an expression using a PLACEHOLDER_EXPR from the\n \t\t FIELD_DECL node just created and link that with the\n-\t\t corresponding GNAT defining identifier.  Then add to the\n-\t\t list of fields.  */\n+\t\t corresponding GNAT defining identifier.  */\n \t      save_gnu_tree (gnat_field,\n \t\t\t     build3 (COMPONENT_REF, TREE_TYPE (gnu_field),\n-\t\t\t\t     build0 (PLACEHOLDER_EXPR,\n-\t\t\t\t\t     DECL_CONTEXT (gnu_field)),\n+\t\t\t\t     build0 (PLACEHOLDER_EXPR, gnu_type),\n \t\t\t\t     gnu_field, NULL_TREE),\n \t\t\t     true);\n \n-\t      if (!Is_Unchecked_Union (gnat_entity))\n+\t      if (!is_unchecked_union)\n \t\t{\n \t\t  TREE_CHAIN (gnu_field) = gnu_field_list;\n \t\t  gnu_field_list = gnu_field;\n \t\t}\n \t    }\n \n-\t/* Put the discriminants into the record (backwards), so we can\n-\t   know the appropriate discriminant to use for the names of the\n-\t   variants.  */\n-\tTYPE_FIELDS (gnu_type) = gnu_field_list;\n-\n-\t/* Add the listed fields into the record and finish it up.  */\n+\t/* Add the fields into the record type and finish it up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, NULL,\n-\t\t\t      false, all_rep, false,\n-\t\t\t      Is_Unchecked_Union (gnat_entity));\n+\t\t\t      false, all_rep, false, is_unchecked_union);\n \n-\t/* We used to remove the associations of the discriminants and\n-\t   _Parent for validity checking, but we may need them if there's\n-\t   Freeze_Node for a subtype used in this record.  */\n+\t/* We used to remove the associations of the discriminants and _Parent\n+\t   for validity checking but we may need them if there's a Freeze_Node\n+\t   for a subtype used in this record.  */\n \tTYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \tTYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_entity);\n \n-\t/* If it is a tagged record force the type to BLKmode to insure\n-\t   that these objects will always be placed in memory.  Do the\n-\t   same thing for limited record types.  */\n+\t/* If it is a tagged record force the type to BLKmode to insure that\n+\t   these objects will always be put in memory.  Likewise for limited\n+\t   record types.  */\n \tif (Is_Tagged_Type (gnat_entity) || Is_Limited_Record (gnat_entity))\n \t  SET_TYPE_MODE (gnu_type, BLKmode);\n \n \t/* Fill in locations of fields.  */\n \tannotate_rep (gnat_entity, gnu_type);\n \n-\t/* If there are any entities in the chain corresponding to\n-\t   components that we did not elaborate, ensure we elaborate their\n-\t   types if they are Itypes.  */\n+\t/* If there are any entities in the chain corresponding to components\n+\t   that we did not elaborate, ensure we elaborate their types if they\n+\t   are Itypes.  */\n \tfor (gnat_temp = First_Entity (gnat_entity);\n-\t     Present (gnat_temp); gnat_temp = Next_Entity (gnat_temp))\n+\t     Present (gnat_temp);\n+\t     gnat_temp = Next_Entity (gnat_temp))\n \t  if ((Ekind (gnat_temp) == E_Component\n \t       || Ekind (gnat_temp) == E_Discriminant)\n \t      && Is_Itype (Etype (gnat_temp))\n@@ -3007,7 +3010,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* ... fall through ... */\n \n     case E_Record_Subtype:\n-\n       /* If Cloned_Subtype is Present it means this record subtype has\n \t identical layout to that type or subtype and we should use\n \t that GCC type for this one.  The front end guarantees that\n@@ -3017,68 +3019,67 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_decl = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity),\n \t\t\t\t\t NULL_TREE, 0);\n \t  maybe_present = true;\n+\t  break;\n \t}\n \n       /* Otherwise, first ensure the base type is elaborated.  Then, if we are\n-\t changing the type, make a new type with each field having the\n-\t type of the field in the new subtype but having the position\n-\t computed by transforming every discriminant reference according\n-\t to the constraints.  We don't see any difference between\n-\t private and nonprivate type here since derivations from types should\n-\t have been deferred until the completion of the private type.  */\n+\t changing the type, make a new type with each field having the type of\n+\t the field in the new subtype but the position computed by transforming\n+\t every discriminant reference according to the constraints.  We don't\n+\t see any difference between private and non-private type here since\n+\t derivations from types should have been deferred until the completion\n+\t of the private type.  */\n       else\n \t{\n \t  Entity_Id gnat_base_type = Implementation_Base_Type (gnat_entity);\n-\t  tree gnu_base_type;\n-\t  tree gnu_orig_type;\n+\t  tree gnu_base_type, gnu_orig_type;\n \n \t  if (!definition)\n-\t    defer_incomplete_level++, this_deferred = true;\n+\t    {\n+\t      defer_incomplete_level++;\n+\t      this_deferred = true;\n+\t    }\n \n-\t  /* Get the base type initially for its alignment and sizes.  But\n-\t     if it is a padded type, we do all the other work with the\n-\t     unpadded type.  */\n+\t  /* Get the base type initially for its alignment and sizes.\n+\t     But if it is a padded type, we do all the other work with\n+\t     the unpadded type.  */\n \t  gnu_base_type = gnat_to_gnu_type (gnat_base_type);\n \n \t  if (TREE_CODE (gnu_base_type) == RECORD_TYPE\n \t      && TYPE_IS_PADDING_P (gnu_base_type))\n-\t    gnu_type = gnu_orig_type = TREE_TYPE (TYPE_FIELDS (gnu_base_type));\n+\t    gnu_orig_type = TREE_TYPE (TYPE_FIELDS (gnu_base_type));\n \t  else\n-\t    gnu_type = gnu_orig_type = gnu_base_type;\n+\t    gnu_orig_type = gnu_base_type;\n \n \t  if (present_gnu_tree (gnat_entity))\n \t    {\n \t      maybe_present = true;\n \t      break;\n \t    }\n \n-\t  /* When the type has discriminants, and these discriminants\n-\t     affect the shape of what it built, factor them in.\n-\n-\t     If we are making a subtype of an Unchecked_Union (must be an\n-\t     Itype), just return the type.\n-\n-\t     We can't just use Is_Constrained because private subtypes without\n-\t     discriminants of full types with discriminants with default\n-\t     expressions are Is_Constrained but aren't constrained!  */\n+\t  /* When the subtype has discriminants and these discriminants affect\n+\t     the initial shape it has inherited, factor them in.  But for the\n+\t     of an Unchecked_Union (it must be an Itype), just return the type.\n \n+\t     We can't just test Is_Constrained because private subtypes without\n+\t     discriminants of types with discriminants with default expressions\n+\t     are Is_Constrained but aren't constrained!  */\n \t  if (IN (Ekind (gnat_base_type), Record_Kind)\n-\t      && !Is_For_Access_Subtype (gnat_entity)\n \t      && !Is_Unchecked_Union (gnat_base_type)\n+\t      && !Is_For_Access_Subtype (gnat_entity)\n \t      && Is_Constrained (gnat_entity)\n-\t      && Stored_Constraint (gnat_entity) != No_Elist\n-\t      && Present (Discriminant_Constraint (gnat_entity)))\n+\t      && Has_Discriminants (gnat_entity)\n+\t      && Present (Discriminant_Constraint (gnat_entity))\n+\t      && Stored_Constraint (gnat_entity) != No_Elist)\n \t    {\n-\t      Entity_Id gnat_field;\n-\t      tree gnu_field_list = 0;\n \t      tree gnu_pos_list\n \t\t= compute_field_positions (gnu_orig_type, NULL_TREE,\n \t\t\t\t\t   size_zero_node, bitsize_zero_node,\n \t\t\t\t\t   BIGGEST_ALIGNMENT);\n \t      tree gnu_subst_list\n-\t\t= substitution_list (gnat_entity, gnat_base_type, NULL_TREE,\n-\t\t\t\t     definition);\n-\t      tree gnu_temp;\n+\t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n+\t      tree gnu_field_list = NULL_TREE, gnu_temp;\n+\t      Entity_Id gnat_field;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n@@ -3122,9 +3123,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   Present (gnat_field); gnat_field = Next_Entity (gnat_field))\n \t\tif ((Ekind (gnat_field) == E_Component\n \t\t     || Ekind (gnat_field) == E_Discriminant)\n-\t\t    && (Underlying_Type (Scope (Original_Record_Component\n-\t\t\t\t\t\t(gnat_field)))\n-\t\t\t== gnat_base_type)\n+\t\t    && Underlying_Type (Scope (Original_Record_Component\n+\t\t\t\t\t       (gnat_field)))\n+\t\t       == gnat_base_type\n \t\t    && (No (Corresponding_Discriminant (gnat_field))\n \t\t\t|| !Is_Tagged_Type (gnat_base_type)))\n \t\t  {\n@@ -3192,8 +3193,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t      TREE_VALUE (gnu_temp));\n \n \t\t    /* If the position is now a constant, we can set it as the\n-\t\t       position of the field when we make it.  Otherwise, we need\n-\t\t       to deal with it specially below.  */\n+\t\t       position of the field when we make it.  Otherwise, we\n+\t\t       need to deal with it specially below.  */\n \t\t    if (TREE_CONSTANT (gnu_pos))\n \t\t      {\n \t\t        gnu_new_pos = bit_from_pos (gnu_pos, gnu_bitpos);\n@@ -3309,17 +3310,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      rest_of_record_type_compilation (gnu_type);\n \t    }\n \n-\t  /* Otherwise, go down all the components in the new type and\n-\t     make them equivalent to those in the base type.  */\n+\t  /* Otherwise, go down all the components in the new type and make\n+\t     them equivalent to those in the base type.  */\n \t  else\n-\t    for (gnat_temp = First_Entity (gnat_entity); Present (gnat_temp);\n-\t\t gnat_temp = Next_Entity (gnat_temp))\n-\t      if ((Ekind (gnat_temp) == E_Discriminant\n-\t\t   && !Is_Unchecked_Union (gnat_base_type))\n-\t\t  || Ekind (gnat_temp) == E_Component)\n-\t\tsave_gnu_tree (gnat_temp,\n-\t\t\t       gnat_to_gnu_field_decl\n-\t\t\t       (Original_Record_Component (gnat_temp)), false);\n+\t    {\n+\t      gnu_type = gnu_orig_type;\n+\n+\t      for (gnat_temp = First_Entity (gnat_entity);\n+\t\t   Present (gnat_temp);\n+\t\t   gnat_temp = Next_Entity (gnat_temp))\n+\t\tif ((Ekind (gnat_temp) == E_Discriminant\n+\t\t     && !Is_Unchecked_Union (gnat_base_type))\n+\t\t    || Ekind (gnat_temp) == E_Component)\n+\t\t  save_gnu_tree (gnat_temp,\n+\t\t\t\t gnat_to_gnu_field_decl\n+\t\t\t\t (Original_Record_Component (gnat_temp)),\n+\t\t\t\t false);\n+\t    }\n \t}\n       break;\n \n@@ -3876,10 +3883,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool has_stub = false;\n \tint parmnum;\n \n+\t/* A parameter may refer to this type, so defer completion of any\n+\t   incomplete types.  */\n \tif (kind == E_Subprogram_Type && !definition)\n-\t  /* A parameter may refer to this type, so defer completion\n-\t     of any incomplete types.  */\n-\t  defer_incomplete_level++, this_deferred = true;\n+\t  {\n+\t    defer_incomplete_level++;\n+\t    this_deferred = true;\n+\t  }\n \n \t/* If the subprogram has an alias, it is probably inherited, so\n \t   we can use the original one.  If the original \"subprogram\"\n@@ -5301,13 +5311,14 @@ elaborate_entity (Entity_Id gnat_entity)\n     case E_Limited_Private_Subtype:\n     case E_Record_Subtype_With_Private:\n       if (Is_Constrained (gnat_entity)\n-\t  && Has_Discriminants (Base_Type (gnat_entity))\n+\t  && Has_Discriminants (gnat_entity)\n \t  && Present (Discriminant_Constraint (gnat_entity)))\n \t{\n \t  Node_Id gnat_discriminant_expr;\n \t  Entity_Id gnat_field;\n \n-\t  for (gnat_field = First_Discriminant (Base_Type (gnat_entity)),\n+\t  for (gnat_field\n+\t       = First_Discriminant (Implementation_Base_Type (gnat_entity)),\n \t       gnat_discriminant_expr\n \t       = First_Elmt (Discriminant_Constraint (gnat_entity));\n \t       Present (gnat_field);\n@@ -5439,38 +5450,33 @@ relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n   record_component_aliases (gnu_new_type);\n }\n \f\n-/* Return a TREE_LIST describing the substitutions needed to reflect\n-   discriminant substitutions from GNAT_SUBTYPE to GNAT_TYPE and add\n-   them to GNU_LIST.  If GNAT_TYPE is not specified, use the base type\n-   of GNAT_SUBTYPE.  The substitutions can be in any order.  TREE_PURPOSE\n-   gives the tree for the discriminant and TREE_VALUES is the replacement\n-   value.  They are in the form of operands to substitute_in_expr.\n-   DEFINITION is as in gnat_to_gnu_entity.  */\n+/* Return a TREE_LIST describing the substitutions needed to reflect the\n+   discriminant substitutions from GNAT_TYPE to GNAT_SUBTYPE.  They can\n+   be in any order.  TREE_PURPOSE gives the tree for the discriminant and\n+   TREE_VALUE is the replacement value.  They are in the form of operands\n+   to substitute_in_expr.  DEFINITION is true if this is for a definition\n+   of GNAT_SUBTYPE.  */\n \n static tree\n-substitution_list (Entity_Id gnat_subtype, Entity_Id gnat_type,\n-\t\t   tree gnu_list, bool definition)\n+build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n {\n+  tree gnu_list = NULL_TREE;\n   Entity_Id gnat_discrim;\n   Node_Id gnat_value;\n \n-  if (No (gnat_type))\n-    gnat_type = Implementation_Base_Type (gnat_subtype);\n-\n-  if (Has_Discriminants (gnat_type))\n-    for (gnat_discrim = First_Stored_Discriminant (gnat_type),\n-\t gnat_value = First_Elmt (Stored_Constraint (gnat_subtype));\n-\t Present (gnat_discrim);\n-\t gnat_discrim = Next_Stored_Discriminant (gnat_discrim),\n-\t gnat_value = Next_Elmt (gnat_value))\n-      /* Ignore access discriminants.  */\n-      if (!Is_Access_Type (Etype (Node (gnat_value))))\n-\tgnu_list = tree_cons (gnat_to_gnu_field_decl (gnat_discrim),\n-\t\t\t      elaborate_expression\n-\t\t\t      (Node (gnat_value), gnat_subtype,\n-\t\t\t       get_entity_name (gnat_discrim), definition,\n-\t\t\t       true, false),\n-\t\t\t      gnu_list);\n+  for (gnat_discrim = First_Stored_Discriminant (gnat_type),\n+       gnat_value = First_Elmt (Stored_Constraint (gnat_subtype));\n+       Present (gnat_discrim);\n+       gnat_discrim = Next_Stored_Discriminant (gnat_discrim),\n+       gnat_value = Next_Elmt (gnat_value))\n+    /* Ignore access discriminants.  */\n+    if (!Is_Access_Type (Etype (Node (gnat_value))))\n+      gnu_list = tree_cons (gnat_to_gnu_field_decl (gnat_discrim),\n+\t\t\t    elaborate_expression\n+\t\t\t    (Node (gnat_value), gnat_subtype,\n+\t\t\t     get_entity_name (gnat_discrim), definition,\n+\t\t\t     true, false),\n+\t\t\t    gnu_list);\n \n   return gnu_list;\n }\n@@ -6620,12 +6626,13 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n   return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n }\n \n-/* Return a GCC tree for a record type given a GNAT Component_List and a chain\n-   of GCC trees for fields that are in the record and have already been\n-   processed.  When called from gnat_to_gnu_entity during the processing of a\n-   record type definition, the GCC nodes for the discriminants will be on\n-   the chain.  The other calls to this function are recursive calls from\n-   itself for the Component_List of a variant and the chain is empty.\n+/* Translate and chain the GNAT_COMPONENT_LIST to the GNU_FIELD_LIST, set\n+   the result as the field list of GNU_RECORD_TYPE and finish it up.  When\n+   called from gnat_to_gnu_entity during the processing of a record type\n+   definition, the GCC nodes for the discriminants and the parent, if any,\n+   will be on the GNU_FIELD_LIST.  The other calls to this function are\n+   recursive calls for the component list of a variant and, in this case,\n+   GNU_FIELD_LIST is empty.\n \n    PACKED is 1 if this is for a packed record, -1 if this is for a record\n    with Component_Alignment of Storage_Unit, -2 if this is for a record\n@@ -6634,51 +6641,49 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n    DEFINITION is true if we are defining this record.\n \n    P_GNU_REP_LIST, if nonzero, is a pointer to a list to which each field\n-   with a rep clause is to be added.  If it is nonzero, that is all that\n-   should be done with such fields.\n+   with a rep clause is to be added; in this case, that is all that should\n+   be done with such fields.\n \n    CANCEL_ALIGNMENT, if true, means the alignment should be zeroed before\n-   laying out the record.  This means the alignment only serves to force fields\n-   to be bitfields, but not require the record to be that aligned.  This is\n-   used for variants.\n+   laying out the record.  This means the alignment only serves to force\n+   fields to be bitfields, but not require the record to be that aligned.\n+   This is used for variants.\n \n    ALL_REP, if true, means a rep clause was found for all the fields.  This\n    simplifies the logic since we know we're not in the mixed case.\n \n    DO_NOT_FINALIZE, if true, means that the record type is expected to be\n-   modified afterwards so it will not be sent to the back-end for finalization.\n+   modified afterwards so it will not be finalized here.\n \n    UNCHECKED_UNION, if true, means that we are building a type for a record\n-   with a Pragma Unchecked_Union.\n-\n-   The processing of the component list fills in the chain with all of the\n-   fields of the record and then the record type is finished.  */\n+   with a Pragma Unchecked_Union.  */\n \n static void\n-components_to_record (tree gnu_record_type, Node_Id component_list,\n+components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      tree gnu_field_list, int packed, bool definition,\n \t\t      tree *p_gnu_rep_list, bool cancel_alignment,\n \t\t      bool all_rep, bool do_not_finalize, bool unchecked_union)\n {\n-  Node_Id component_decl;\n-  Entity_Id gnat_field;\n-  Node_Id variant_part;\n-  tree gnu_our_rep_list = NULL_TREE;\n-  tree gnu_field, gnu_last;\n-  bool layout_with_rep = false;\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n+  bool layout_with_rep = false;\n+  Node_Id component_decl, variant_part;\n+  tree gnu_our_rep_list = NULL_TREE;\n+  tree gnu_field, gnu_next, gnu_last;\n \n-  /* For each variable within each component declaration create a GCC field\n-     and add it to the list, skipping any pragmas in the list.  */\n-  if (Present (Component_Items (component_list)))\n-    for (component_decl = First_Non_Pragma (Component_Items (component_list));\n+  /* For each component referenced in a component declaration create a GCC\n+     field and add it to the list, skipping pragmas in the GNAT list.  */\n+  if (Present (Component_Items (gnat_component_list)))\n+    for (component_decl\n+\t   = First_Non_Pragma (Component_Items (gnat_component_list));\n \t Present (component_decl);\n \t component_decl = Next_Non_Pragma (component_decl))\n       {\n-\tgnat_field = Defining_Entity (component_decl);\n+\tEntity_Id gnat_field = Defining_Entity (component_decl);\n \n+\t/* If present, the _Parent field must have been created and added\n+\t   as the last field to the list.  */\n \tif (Chars (gnat_field) == Name_uParent)\n-\t  gnu_field = tree_last (TYPE_FIELDS (gnu_record_type));\n+\t  gnu_field = tree_last (gnu_field_list);\n \telse\n \t  {\n \t    gnu_field = gnat_to_gnu_field (gnat_field, gnu_record_type,\n@@ -6699,7 +6704,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n       }\n \n   /* At the end of the component list there may be a variant part.  */\n-  variant_part = Variant_Part (component_list);\n+  variant_part = Variant_Part (gnat_component_list);\n \n   /* We create a QUAL_UNION_TYPE for the variant part since the variants are\n      mutually exclusive and should go in the same memory.  To do this we need\n@@ -6757,23 +6762,23 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t\t\t   IDENTIFIER_POINTER (gnu_inner_name));\n \n \t  /* Set the alignment of the inner type in case we need to make\n-\t     inner objects into bitfields, but then clear it out\n-\t     so the record actually gets only the alignment required.  */\n+\t     inner objects into bitfields, but then clear it out so the\n+\t     record actually gets only the alignment required.  */\n \t  TYPE_ALIGN (gnu_variant_type) = TYPE_ALIGN (gnu_record_type);\n \t  TYPE_PACKED (gnu_variant_type) = TYPE_PACKED (gnu_record_type);\n \n-\t  /* Similarly, if the outer record has a size specified and all fields\n-\t     have record rep clauses, we can propagate the size into the\n-\t     variant part.  */\n+\t  /* Similarly, if the outer record has a size specified and all\n+\t     fields have record rep clauses, we can propagate the size\n+\t     into the variant part.  */\n \t  if (all_rep_and_size)\n \t    {\n \t      TYPE_SIZE (gnu_variant_type) = TYPE_SIZE (gnu_record_type);\n \t      TYPE_SIZE_UNIT (gnu_variant_type)\n \t\t= TYPE_SIZE_UNIT (gnu_record_type);\n \t    }\n \n-\t  /* Create the record type for the variant.  Note that we defer\n-\t     finalizing it until after we are sure to actually use it.  */\n+\t  /* Add the fields into the record type for the variant.  Note that we\n+\t     defer finalizing it until after we are sure to really use it.  */\n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n \t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep,\n@@ -6821,7 +6826,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t  gnu_variant_list = gnu_field;\n \t}\n \n-      /* Only make the QUAL_UNION_TYPE if there are any non-empty variants.  */\n+      /* Only make the QUAL_UNION_TYPE if there are non-empty variants.  */\n       if (gnu_variant_list)\n \t{\n \t  int union_field_packed;\n@@ -6864,50 +6869,48 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n     }\n \n   /* Scan GNU_FIELD_LIST and see if any fields have rep clauses.  If they\n-     do, pull them out and put them into GNU_OUR_REP_LIST.  We have to do this\n-     in a separate pass since we want to handle the discriminants but can't\n-     play with them until we've used them in debugging data above.\n-\n-     ??? Note: if we then reorder them, debugging information will be wrong,\n-     but there's nothing that can be done about this at the moment.  */\n-  for (gnu_field = gnu_field_list, gnu_last = NULL_TREE; gnu_field; )\n+     do, pull them out and put them into GNU_OUR_REP_LIST.  We have to do\n+     this in a separate pass since we want to handle the discriminants but\n+     can't play with them until we've used them in debugging data above.\n+\n+     ??? If we then reorder them, debugging information will be wrong but\n+     there's nothing that can be done about this at the moment.  */\n+  gnu_last = NULL_TREE;\n+  for (gnu_field = gnu_field_list; gnu_field; gnu_field = gnu_next)\n     {\n+      gnu_next = TREE_CHAIN (gnu_field);\n+\n       if (DECL_FIELD_OFFSET (gnu_field))\n \t{\n-\t  tree gnu_next = TREE_CHAIN (gnu_field);\n-\n \t  if (!gnu_last)\n \t    gnu_field_list = gnu_next;\n \t  else\n \t    TREE_CHAIN (gnu_last) = gnu_next;\n \n \t  TREE_CHAIN (gnu_field) = gnu_our_rep_list;\n \t  gnu_our_rep_list = gnu_field;\n-\t  gnu_field = gnu_next;\n \t}\n       else\n-\t{\n-\t  gnu_last = gnu_field;\n-\t  gnu_field = TREE_CHAIN (gnu_field);\n-\t}\n+\tgnu_last = gnu_field;\n     }\n \n-  /* If we have any items in our rep'ed field list, it is not the case that all\n-     the fields in the record have rep clauses, and P_REP_LIST is nonzero,\n-     set it and ignore the items.  */\n+  /* If we have any fields in our rep'ed field list and it is not the case that\n+     all the fields in the record have rep clauses and P_REP_LIST is nonzero,\n+     set it and ignore these fields.  */\n   if (gnu_our_rep_list && p_gnu_rep_list && !all_rep)\n     *p_gnu_rep_list = chainon (*p_gnu_rep_list, gnu_our_rep_list);\n+\n+  /* Otherwise, sort the fields by bit position and put them into their own\n+     record, before the others, if we also have fields without rep clauses.  */\n   else if (gnu_our_rep_list)\n     {\n-      /* Otherwise, sort the fields by bit position and put them into their\n-\t own record if we have any fields without rep clauses.  */\n       tree gnu_rep_type\n \t= (gnu_field_list ? make_node (RECORD_TYPE) : gnu_record_type);\n-      int len = list_length (gnu_our_rep_list);\n+      int i, len = list_length (gnu_our_rep_list);\n       tree *gnu_arr = (tree *) alloca (sizeof (tree) * len);\n-      int i;\n \n-      for (i = 0, gnu_field = gnu_our_rep_list; gnu_field;\n+      for (gnu_field = gnu_our_rep_list, i = 0;\n+\t   gnu_field;\n \t   gnu_field = TREE_CHAIN (gnu_field), i++)\n \tgnu_arr[i] = gnu_field;\n \n@@ -6926,8 +6929,9 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n       if (gnu_field_list)\n \t{\n \t  finish_record_type (gnu_rep_type, gnu_our_rep_list, 1, false);\n-\t  gnu_field = create_field_decl (get_identifier (\"REP\"), gnu_rep_type,\n-\t\t\t\t\t gnu_record_type, 0, 0, 0, 1);\n+\t  gnu_field\n+\t    = create_field_decl (get_identifier (\"REP\"), gnu_rep_type,\n+\t\t\t\t gnu_record_type, 0, NULL_TREE, NULL_TREE, 1);\n \t  DECL_INTERNAL_P (gnu_field) = 1;\n \t  gnu_field_list = chainon (gnu_field_list, gnu_field);\n \t}"}]}