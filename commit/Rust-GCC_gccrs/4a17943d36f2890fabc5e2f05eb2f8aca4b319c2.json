{"sha": "4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGExNzk0M2QzNmYyODkwZmFiYzVlMmYwNWViMmY4YWNhNGIzMTljMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2017-03-17T15:10:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-03-17T15:10:13Z"}, "message": "re PR rtl-optimization/79910 (wrong code with -O -fweb)\n\n\tPR rtl-optimization/79910\n\t* combine.c (record_used_regs): New static function.\n\t(try_combine): Handle situations where there is an additional\n\tinstruction between I2 and I3 which needs to have a LOG_LINK\n\tupdated.\n\n\tPR rtl-optimization/79910\n\t* gcc.dg/torture/pr79910.c: New test.\n\nFrom-SVN: r246226", "tree": {"sha": "b6b93ff7ec850cd309e3de2969d25c1e8c288c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6b93ff7ec850cd309e3de2969d25c1e8c288c69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/comments", "author": null, "committer": null, "parents": [{"sha": "7f166d94478f406bc59ed40d9ff24c9d98f30c90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f166d94478f406bc59ed40d9ff24c9d98f30c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f166d94478f406bc59ed40d9ff24c9d98f30c90"}], "stats": {"total": 180, "additions": 180, "deletions": 0}, "files": [{"sha": "f6caadb967f37d11e718165c05743d562b238827", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "patch": "@@ -1,3 +1,11 @@\n+2017-03-17  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR rtl-optimization/79910\n+\t* combine.c (record_used_regs): New static function.\n+\t(try_combine): Handle situations where there is an additional\n+\tinstruction between I2 and I3 which needs to have a LOG_LINK\n+\tupdated.\n+\n 2017-03-17  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/71437"}, {"sha": "ff0df80a801e0e62c2eba6654cbdd5e9055c3b1c", "filename": "gcc/combine.c", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "patch": "@@ -2559,6 +2559,57 @@ can_split_parallel_of_n_reg_sets (rtx_insn *insn, int n)\n   return true;\n }\n \n+/* Set up a set of registers used in an insn.  Called through note_uses,\n+   arguments as described for that function.  */\n+\n+static void\n+record_used_regs (rtx *xptr, void *data)\n+{\n+  bitmap set = (bitmap)data;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  rtx x = *xptr;\n+\n+  /* repeat is used to turn tail-recursion into iteration since GCC\n+     can't do it when there's no return value.  */\n+ repeat:\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+  if (REG_P (x))\n+    {\n+      unsigned regno = REGNO (x);\n+      unsigned end_regno = END_REGNO (x);\n+      while (regno < end_regno)\n+\tbitmap_set_bit (set, regno++);\n+      return;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = XEXP (x, 0);\n+\t      goto repeat;\n+\t    }\n+\n+\t  record_used_regs (&XEXP (x, i), data);\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  record_used_regs (&XVECEXP (x, i, j), data);\n+    }\n+}\n+\n /* Try to combine the insns I0, I1 and I2 into I3.\n    Here I0, I1 and I2 appear earlier than I3.\n    I0 and I1 can be zero; then we combine just I2 into I3, or I1 and I2 into\n@@ -2742,6 +2793,27 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n   added_links_insn = 0;\n \n+  /* For combinations that may result in two insns, we have to gather\n+     some extra information about registers used, so that we can\n+     update all relevant LOG_LINKS later.  */\n+  auto_bitmap i2_regset, i3_regset, links_regset;\n+  if (i1)\n+    {\n+      note_uses (&PATTERN (i2), record_used_regs, (bitmap)i2_regset);\n+      note_uses (&PATTERN (i3), record_used_regs, (bitmap)i3_regset);\n+      insn_link *ll;\n+      FOR_EACH_LOG_LINK (ll, i3)\n+\tbitmap_set_bit (links_regset, ll->regno);\n+      FOR_EACH_LOG_LINK (ll, i2)\n+\tbitmap_set_bit (links_regset, ll->regno);\n+      if (i1)\n+\tFOR_EACH_LOG_LINK (ll, i1)\n+\t  bitmap_set_bit (links_regset, ll->regno);\n+      if (i0)\n+\tFOR_EACH_LOG_LINK (ll, i0)\n+\t  bitmap_set_bit (links_regset, ll->regno);\n+    }\n+\n   /* First check for one important special case that the code below will\n      not handle.  Namely, the case where I1 is zero, I2 is a PARALLEL\n      and I3 is a SET whose SET_SRC is a SET_DEST in I2.  In that case,\n@@ -4051,6 +4123,33 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       return 0;\n     }\n \n+  auto_bitmap new_regs_in_i2;\n+  if (newi2pat)\n+    {\n+      /* We need to discover situations where we introduce a use of a\n+\t register into I2, where none of the existing LOG_LINKS contain\n+\t a reference to it.  This can happen if previously I3 referenced\n+\t the reg, and there is an additional use between I2 and I3.  We\n+\t must remove the LOG_LINKS entry from that additional use and\n+\t distribute it along with our own ones.  */\n+\tnote_uses (&newi2pat, record_used_regs, (bitmap)new_regs_in_i2);\n+\tbitmap_and_compl_into (new_regs_in_i2, i2_regset);\n+\tbitmap_and_compl_into (new_regs_in_i2, links_regset);\n+\n+\t/* Here, we first look for situations where a hard register use\n+\t   moved, and just give up.  This should happen approximately\n+\t   never, and it's not worth it to deal with possibilities like\n+\t   multi-word registers.  Later, when fixing up LOG_LINKS, we\n+\t   deal with the case where a pseudo use moved.  */\n+\tif (!bitmap_empty_p (new_regs_in_i2)\n+\t    && prev_nonnote_insn (i3) != i2\n+\t    && bitmap_first_set_bit (new_regs_in_i2) < FIRST_PSEUDO_REGISTER)\n+\t  {\n+\t    undo_all ();\n+\t    return 0;\n+\t  }\n+    }\n+\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       struct undo *undo;\n@@ -4493,6 +4592,45 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t\t\t    NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n+    if (newi2pat)\n+      {\n+\tbitmap_iterator iter;\n+\tunsigned int i;\n+\n+\t/* See comments above where we calculate the bitmap.  */\n+\tEXECUTE_IF_SET_IN_BITMAP ((bitmap)new_regs_in_i2,\n+\t\t\t\t  LAST_VIRTUAL_REGISTER, i, iter)\n+\t  {\n+\t    rtx reg = regno_reg_rtx[i];\n+\t    rtx_insn *other;\n+\t    for (other = NEXT_INSN (i2); other != i3; other = NEXT_INSN (other))\n+\t      if (NONDEBUG_INSN_P (other)\n+\t\t  && (reg_overlap_mentioned_p (reg, PATTERN (other))\n+\t\t      || (CALL_P (other) && find_reg_fusage (other, USE, reg))))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"found extra use of reg %d at insn %d\\n\", i,\n+\t\t\t     INSN_UID (other));\n+\t\t  insn_link **plink;\n+\t\t  for (plink = &LOG_LINKS (other);\n+\t\t       *plink;\n+\t\t       plink = &(*plink)->next)\n+\t\t    {\n+\t\t      insn_link *link = *plink;\n+\t\t      if (link->regno == i)\n+\t\t\t{\n+\t\t\t  *plink = link->next;\n+\t\t\t  link->next = i3links;\n+\t\t\t  i3links = link;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\t  }\n+      }\n+\n     distribute_links (i3links);\n     distribute_links (i2links);\n     distribute_links (i1links);"}, {"sha": "4162ca23eedc89fb16f054d38dc93c948cf4d941", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "patch": "@@ -1,3 +1,8 @@\n+2017-03-17  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR rtl-optimization/79910\n+\t* gcc.dg/torture/pr79910.c: New test.\n+\n 2017-03-17  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/71437"}, {"sha": "5fe80aee1446894dfe370853fe248f5f7fc8d591", "filename": "gcc/testsuite/gcc.dg/torture/pr79910.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr79910.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a17943d36f2890fabc5e2f05eb2f8aca4b319c2/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr79910.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr79910.c?ref=4a17943d36f2890fabc5e2f05eb2f8aca4b319c2", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fweb\" } */\n+\n+typedef unsigned char u8;\n+typedef unsigned int u32;\n+typedef unsigned long long u64;\n+int a;\n+\n+static __attribute__ ((noinline, noclone)) u64\n+foo (u8 p1, u32 p2)\n+{\n+  u64 b = a <= 0;\n+  p2 = 4;\n+  b >>= a == 0;\n+  p1 %= 0xfffffffff;\n+  p2 >>= b & 31;\n+  p1 += b;\n+  p2 <<= 31;\n+  return p1 + p2 + b;\n+}\n+\n+int\n+main (void)\n+{\n+  u64 x = foo (0, 1);\n+  if (x != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}]}