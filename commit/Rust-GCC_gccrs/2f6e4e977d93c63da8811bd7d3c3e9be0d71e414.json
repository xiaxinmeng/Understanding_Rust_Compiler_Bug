{"sha": "2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY2ZTRlOTc3ZDkzYzYzZGE4ODExYmQ3ZDNjM2U5YmUwZDcxZTQxNA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-22T13:41:26Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-22T13:41:26Z"}, "message": "c-lex.c: Convert to ISO C90.\n\n\n\t* c-lex.c: Convert to ISO C90.\n\t* c-objc-common.c: Likewise.\n\t* c-opts.c: Likewise.\n\t* c-pch.c: Likewise.\n\t* c-ppoutput.c: Likewise.\n\t* c-pragma.h: Likewise.\n\t* c-pretty-print.c: Likewise.\n\t* c-pretty-print.h: Likewise.\n\t* c-semantics.c: Likewise.\n\t* c-tree.h: Likewise.\n\t* c-typeck.c: Likewise.\n\nFrom-SVN: r68327", "tree": {"sha": "25db40631432a7695af6af0b9995522fa0bf6716", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25db40631432a7695af6af0b9995522fa0bf6716"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3346b668cadabd4e0f1679d390c999e2532a53f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3346b668cadabd4e0f1679d390c999e2532a53f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3346b668cadabd4e0f1679d390c999e2532a53f4"}], "stats": {"total": 1552, "additions": 612, "deletions": 940}, "files": [{"sha": "26f6b279c6738b199873f501aa6194adbf55552e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -1,5 +1,17 @@\n 2003-06-22  Andreas Jaeger  <aj@suse.de>\n \n+\t* c-lex.c: Convert to ISO C90.\n+\t* c-objc-common.c: Likewise.\n+\t* c-opts.c: Likewise.\n+\t* c-pch.c: Likewise.\n+\t* c-ppoutput.c: Likewise.\n+\t* c-pragma.h: Likewise.\n+\t* c-pretty-print.c: Likewise.\n+\t* c-pretty-print.h: Likewise.\n+\t* c-semantics.c: Likewise.\n+\t* c-tree.h: Likewise.\n+\t* c-typeck.c: Likewise.\n+\n \t* c-lang.c: Convert to ISO C90.\n \n 2003-06-22  Neil Booth  <neil@daikokuya.co.uk>"}, {"sha": "f9c422545270d88cd0ca146e77442ee0c95e6ae1", "filename": "gcc/c-lex.c", "status": "modified", "additions": 40, "deletions": 69, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -64,27 +64,24 @@ int c_header_level;\t /* depth in C headers - C++ only */\n /* Nonzero tells yylex to ignore \\ in string constants.  */\n static int ignore_escape_flag;\n \n-static tree interpret_integer\tPARAMS ((const cpp_token *, unsigned int));\n-static tree interpret_float\tPARAMS ((const cpp_token *, unsigned int));\n+static tree interpret_integer (const cpp_token *, unsigned int);\n+static tree interpret_float (const cpp_token *, unsigned int);\n static enum integer_type_kind\n-  narrowest_unsigned_type\tPARAMS ((tree, unsigned int));\n+  narrowest_unsigned_type (tree, unsigned int);\n static enum integer_type_kind\n-  narrowest_signed_type\t\tPARAMS ((tree, unsigned int));\n-static tree lex_string\t\tPARAMS ((const cpp_string *));\n-static tree lex_charconst\tPARAMS ((const cpp_token *));\n-static void update_header_times\tPARAMS ((const char *));\n-static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n-static void cb_line_change     PARAMS ((cpp_reader *, const cpp_token *, int));\n-static void cb_ident\t\tPARAMS ((cpp_reader *, unsigned int,\n-\t\t\t\t\t const cpp_string *));\n-static void cb_def_pragma\tPARAMS ((cpp_reader *, unsigned int));\n-static void cb_define\t\tPARAMS ((cpp_reader *, unsigned int,\n-\t\t\t\t\t cpp_hashnode *));\n-static void cb_undef\t\tPARAMS ((cpp_reader *, unsigned int,\n-\t\t\t\t\t cpp_hashnode *));\n+  narrowest_signed_type (tree, unsigned int);\n+static tree lex_string (const cpp_string *);\n+static tree lex_charconst (const cpp_token *);\n+static void update_header_times (const char *);\n+static int dump_one_header (splay_tree_node, void *);\n+static void cb_line_change (cpp_reader *, const cpp_token *, int);\n+static void cb_ident (cpp_reader *, unsigned int, const cpp_string *);\n+static void cb_def_pragma (cpp_reader *, unsigned int);\n+static void cb_define (cpp_reader *, unsigned int, cpp_hashnode *);\n+static void cb_undef (cpp_reader *, unsigned int, cpp_hashnode *);\n \f\n void\n-init_c_lex ()\n+init_c_lex (void)\n {\n   struct cpp_callbacks *cb;\n   struct c_fileinfo *toplevel;\n@@ -100,7 +97,7 @@ init_c_lex ()\n       body_time = get_run_time ();\n       toplevel->time = body_time;\n     }\n-  \n+\n   cb = cpp_get_callbacks (parse_in);\n \n   cb->line_change = cb_line_change;\n@@ -120,8 +117,7 @@ init_c_lex ()\n }\n \n struct c_fileinfo *\n-get_fileinfo (name)\n-     const char *name;\n+get_fileinfo (const char *name)\n {\n   splay_tree_node n;\n   struct c_fileinfo *fi;\n@@ -140,8 +136,7 @@ get_fileinfo (name)\n }\n \n static void\n-update_header_times (name)\n-     const char *name;\n+update_header_times (const char *name)\n {\n   /* Changing files again.  This means currently collected time\n      is charged against header time, and body time starts back at 0.  */\n@@ -156,17 +151,15 @@ update_header_times (name)\n }\n \n static int\n-dump_one_header (n, dummy)\n-     splay_tree_node n;\n-     void *dummy ATTRIBUTE_UNUSED;\n+dump_one_header (splay_tree_node n, void *dummy ATTRIBUTE_UNUSED)\n {\n   print_time ((const char *) n->key,\n \t      ((struct c_fileinfo *) n->value)->time);\n   return 0;\n }\n \n void\n-dump_time_statistics ()\n+dump_time_statistics (void)\n {\n   struct c_fileinfo *file = get_fileinfo (input_filename);\n   int this_time = get_run_time ();\n@@ -183,10 +176,9 @@ dump_time_statistics ()\n }\n \n static void\n-cb_ident (pfile, line, str)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const cpp_string *str ATTRIBUTE_UNUSED;\n+cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t  unsigned int line ATTRIBUTE_UNUSED,\n+\t  const cpp_string *str ATTRIBUTE_UNUSED)\n {\n #ifdef ASM_OUTPUT_IDENT\n   if (! flag_no_ident)\n@@ -201,17 +193,14 @@ cb_ident (pfile, line, str)\n /* Called at the start of every non-empty line.  TOKEN is the first\n    lexed token on the line.  Used for diagnostic line numbers.  */\n static void\n-cb_line_change (pfile, token, parsing_args)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const cpp_token *token;\n-     int parsing_args ATTRIBUTE_UNUSED;\n+cb_line_change (cpp_reader *pfile ATTRIBUTE_UNUSED, const cpp_token *token,\n+\t\tint parsing_args ATTRIBUTE_UNUSED)\n {\n   src_lineno = SOURCE_LINE (map, token->line);\n }\n \n void\n-fe_file_change (new_map)\n-     const struct line_map *new_map;\n+fe_file_change (const struct line_map *new_map)\n {\n   unsigned int to_line = SOURCE_LINE (new_map, new_map->to_line);\n \n@@ -250,7 +239,7 @@ fe_file_change (new_map)\n \t}\n #endif\n       pop_srcloc ();\n-      \n+\n       (*debug_hooks->end_source_file) (to_line);\n     }\n \n@@ -265,9 +254,7 @@ fe_file_change (new_map)\n }\n \n static void\n-cb_def_pragma (pfile, line)\n-     cpp_reader *pfile;\n-     unsigned int line;\n+cb_def_pragma (cpp_reader *pfile, unsigned int line)\n {\n   /* Issue a warning message if we have been asked to do so.  Ignore\n      unknown pragmas in system headers unless an explicit\n@@ -294,29 +281,23 @@ cb_def_pragma (pfile, line)\n \n /* #define callback for DWARF and DWARF2 debug info.  */\n static void\n-cb_define (pfile, line, node)\n-     cpp_reader *pfile;\n-     unsigned int line;\n-     cpp_hashnode *node;\n+cb_define (cpp_reader *pfile, unsigned int line, cpp_hashnode *node)\n {\n   (*debug_hooks->define) (SOURCE_LINE (map, line),\n \t\t\t  (const char *) cpp_macro_definition (pfile, node));\n }\n \n /* #undef callback for DWARF and DWARF2 debug info.  */\n static void\n-cb_undef (pfile, line, node)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line;\n-     cpp_hashnode *node;\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, unsigned int line,\n+\t  cpp_hashnode *node)\n {\n   (*debug_hooks->undef) (SOURCE_LINE (map, line),\n \t\t\t (const char *) NODE_NAME (node));\n }\n \f\n int\n-c_lex (value)\n-     tree *value;\n+c_lex (tree *value)\n {\n   const cpp_token *tok;\n \n@@ -403,9 +384,7 @@ c_lex (value)\n    minimum specified by FLAGS, that can fit VALUE, or itk_none if\n    there isn't one.  */\n static enum integer_type_kind\n-narrowest_unsigned_type (value, flags)\n-     tree value;\n-     unsigned int flags;\n+narrowest_unsigned_type (tree value, unsigned int flags)\n {\n   enum integer_type_kind itk;\n \n@@ -429,9 +408,7 @@ narrowest_unsigned_type (value, flags)\n \n /* Ditto, but narrowest signed type.  */\n static enum integer_type_kind\n-narrowest_signed_type (value, flags)\n-     tree value;\n-     unsigned int flags;\n+narrowest_signed_type (tree value, unsigned int flags)\n {\n   enum integer_type_kind itk;\n \n@@ -455,9 +432,7 @@ narrowest_signed_type (value, flags)\n \n /* Interpret TOKEN, an integer with FLAGS as classified by cpplib.  */\n static tree\n-interpret_integer (token, flags)\n-     const cpp_token *token;\n-     unsigned int flags;\n+interpret_integer (const cpp_token *token, unsigned int flags)\n {\n   tree value, type;\n   enum integer_type_kind itk;\n@@ -535,9 +510,7 @@ interpret_integer (token, flags)\n /* Interpret TOKEN, a floating point number with FLAGS as classified\n    by cpplib.  */\n static tree\n-interpret_float (token, flags)\n-     const cpp_token *token;\n-     unsigned int flags;\n+interpret_float (const cpp_token *token, unsigned int flags)\n {\n   tree type;\n   tree value;\n@@ -599,15 +572,14 @@ interpret_float (token, flags)\n }\n \n static tree\n-lex_string (str)\n-     const cpp_string *str;\n+lex_string (const cpp_string *str)\n {\n   bool wide;\n   tree value;\n   char *buf, *q;\n   cppchar_t c;\n   const unsigned char *p, *limit;\n-  \n+\n   wide = str->text[0] == 'L';\n   p = str->text + 1 + wide;\n   limit = str->text + str->len - 1;\n@@ -619,7 +591,7 @@ lex_string (str)\n \n       if (c == '\\\\' && !ignore_escape_flag)\n \tc = cpp_parse_escape (parse_in, &p, limit, wide);\n-\t\n+\n       /* Add this single character into the buffer either as a wchar_t,\n \t a multibyte sequence, or as a single byte.  */\n       if (wide)\n@@ -672,16 +644,15 @@ lex_string (str)\n \n /* Converts a (possibly wide) character constant token into a tree.  */\n static tree\n-lex_charconst (token)\n-     const cpp_token *token;\n+lex_charconst (const cpp_token *token)\n {\n   cppchar_t result;\n   tree type, value;\n   unsigned int chars_seen;\n   int unsignedp;\n \n   result = cpp_interpret_charconst (parse_in, token,\n- \t\t\t\t    &chars_seen, &unsignedp);\n+\t\t\t\t    &chars_seen, &unsignedp);\n \n   /* Cast to cppchar_signed_t to get correct sign-extension of RESULT\n      before possibly widening to HOST_WIDE_INT for build_int_2.  */"}, {"sha": "438b3fba808f938e45b908c28b16936924ab6bcc", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -1,5 +1,5 @@\n /* Some code common to C and ObjC front ends.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -39,17 +39,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"cgraph.h\"\n \n-static bool c_tree_printer PARAMS ((output_buffer *, text_info *));\n-static tree inline_forbidden_p PARAMS ((tree *, int *, void *));\n-static void expand_deferred_fns PARAMS ((void));\n-static tree start_cdtor\tPARAMS ((int));\n-static void finish_cdtor PARAMS ((tree));\n+static bool c_tree_printer (output_buffer *, text_info *);\n+static tree inline_forbidden_p (tree *, int *, void *);\n+static void expand_deferred_fns (void);\n+static tree start_cdtor (int);\n+static void finish_cdtor (tree);\n \n static GTY(()) varray_type deferred_fns;\n \n int\n-c_missing_noreturn_ok_p (decl)\n-     tree decl;\n+c_missing_noreturn_ok_p (tree decl)\n {\n   /* A missing noreturn is not ok for freestanding implementations and\n      ok for the `main' function in hosted implementations.  */\n@@ -61,8 +60,7 @@ c_missing_noreturn_ok_p (decl)\n    such functions always being inlined when optimizing.  */\n \n int\n-c_disregard_inline_limits (fn)\n-     tree fn;\n+c_disregard_inline_limits (tree fn)\n {\n   if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) != NULL)\n     return 1;\n@@ -71,10 +69,8 @@ c_disregard_inline_limits (fn)\n }\n \n static tree\n-inline_forbidden_p (nodep, walk_subtrees, fn)\n-     tree *nodep;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *fn;\n+inline_forbidden_p (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t    void *fn)\n {\n   tree node = *nodep;\n   tree t;\n@@ -160,8 +156,7 @@ inline_forbidden_p (nodep, walk_subtrees, fn)\n }\n \n int\n-c_cannot_inline_tree_fn (fnp)\n-     tree *fnp;\n+c_cannot_inline_tree_fn (tree *fnp)\n {\n   tree fn = *fnp;\n   tree t;\n@@ -170,7 +165,7 @@ c_cannot_inline_tree_fn (fnp)\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n     return 1;\n \n-  /* Don't auto-inline anything that might not be bound within \n+  /* Don't auto-inline anything that might not be bound within\n      this unit of translation.  */\n   if (!DECL_DECLARED_INLINE_P (fn) && !(*targetm.binds_local_p) (fn))\n     goto cannot_inline;\n@@ -215,7 +210,7 @@ c_cannot_inline_tree_fn (fnp)\n       if (! t)\n \treturn 0;\n     }\n-    \n+\n   if (walk_tree (&DECL_SAVED_TREE (fn), inline_forbidden_p, fn, NULL))\n     goto cannot_inline;\n \n@@ -229,8 +224,7 @@ c_cannot_inline_tree_fn (fnp)\n /* Called from check_global_declarations.  */\n \n bool\n-c_warn_unused_global_decl (decl)\n-     tree decl;\n+c_warn_unused_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl))\n     return false;\n@@ -242,7 +236,7 @@ c_warn_unused_global_decl (decl)\n \n /* Initialization common to C and Objective-C front ends.  */\n bool\n-c_objc_common_init ()\n+c_objc_common_init (void)\n {\n   static const enum tree_code stmt_codes[] = {\n     c_common_stmt_codes\n@@ -282,8 +276,7 @@ c_objc_common_init ()\n    to RTL is only done at the end of the compilation.  */\n \n int\n-defer_fn (fn)\n-     tree fn;\n+defer_fn (tree fn)\n {\n   VARRAY_PUSH_TREE (deferred_fns, fn);\n \n@@ -293,7 +286,7 @@ defer_fn (fn)\n /* Expand deferred functions for C and ObjC.  */\n \n static void\n-expand_deferred_fns ()\n+expand_deferred_fns (void)\n {\n   unsigned int i;\n \n@@ -315,8 +308,7 @@ expand_deferred_fns ()\n }\n \n static tree\n-start_cdtor (method_type)\n-     int method_type;\n+start_cdtor (int method_type)\n {\n   tree fnname = get_file_function_name (method_type);\n   tree void_list_node_1 = build_tree_list (NULL_TREE, void_type_node);\n@@ -342,8 +334,7 @@ start_cdtor (method_type)\n }\n \n static void\n-finish_cdtor (body)\n-     tree body;\n+finish_cdtor (tree body)\n {\n   tree scope;\n   tree block;\n@@ -361,7 +352,7 @@ finish_cdtor (body)\n /* Called at end of parsing, but before end-of-file processing.  */\n \n void\n-c_objc_common_finish_file ()\n+c_objc_common_finish_file (void)\n {\n   if (pch_file)\n     c_common_write_pch ();\n@@ -420,9 +411,7 @@ c_objc_common_finish_file ()\n    Please notice when called, the `%' part was already skipped by the\n    diagnostic machinery.  */\n static bool\n-c_tree_printer (buffer, text)\n-     output_buffer *buffer;\n-     text_info *text;\n+c_tree_printer (output_buffer *buffer, text_info *text)\n {\n   tree t = va_arg (*text->args_ptr, tree);\n "}, {"sha": "3de89e488f6135e25c116089b3b45af5db984591", "filename": "gcc/c-opts.c", "status": "modified", "additions": 46, "deletions": 63, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -100,30 +100,30 @@ static size_t deferred_count, deferred_size;\n /* Number of deferred options scanned for -include.  */\n static size_t include_cursor;\n \n-static void missing_arg PARAMS ((enum opt_code));\n-static void set_Wimplicit PARAMS ((int));\n-static void complain_wrong_lang PARAMS ((size_t, int));\n-static void write_langs PARAMS ((char *, int));\n-static void print_help PARAMS ((void));\n-static void handle_OPT_d PARAMS ((const char *));\n-static void set_std_cxx98 PARAMS ((int));\n-static void set_std_c89 PARAMS ((int, int));\n-static void set_std_c99 PARAMS ((int));\n-static void check_deps_environment_vars PARAMS ((void));\n-static void handle_deferred_opts PARAMS ((void));\n-static void sanitize_cpp_opts PARAMS ((void));\n-static void add_prefixed_path PARAMS ((const char *, size_t));\n-static void push_command_line_include PARAMS ((void));\n-static void cb_file_change PARAMS ((cpp_reader *, const struct line_map *));\n-static void finish_options PARAMS ((void));\n+static void missing_arg (enum opt_code);\n+static void set_Wimplicit (int);\n+static void complain_wrong_lang (size_t, int);\n+static void write_langs (char *, int);\n+static void print_help (void);\n+static void handle_OPT_d (const char *);\n+static void set_std_cxx98 (int);\n+static void set_std_c89 (int, int);\n+static void set_std_c99 (int);\n+static void check_deps_environment_vars (void);\n+static void handle_deferred_opts (void);\n+static void sanitize_cpp_opts (void);\n+static void add_prefixed_path (const char *, size_t);\n+static void push_command_line_include (void);\n+static void cb_file_change (cpp_reader *, const struct line_map *);\n+static void finish_options (void);\n \n #ifndef STDC_0_IN_SYSTEM_HEADERS\n #define STDC_0_IN_SYSTEM_HEADERS 0\n #endif\n \n /* Holds switches parsed by c_common_handle_option (), but whose\n    handling is deferred to c_common_post_options ().  */\n-static void defer_opt PARAMS ((enum opt_code, const char *));\n+static void defer_opt (enum opt_code, const char *);\n static struct deferred_opt\n {\n   enum opt_code code;\n@@ -193,9 +193,7 @@ missing_arg (enum opt_code code)\n \n /* Defer option CODE with argument ARG.  */\n static void\n-defer_opt (code, arg)\n-     enum opt_code code;\n-     const char *arg;\n+defer_opt (enum opt_code code, const char *arg)\n {\n   /* FIXME: this should be in c_common_init_options, which should take\n      argc and argv.  */\n@@ -217,8 +215,7 @@ defer_opt (code, arg)\n \n /* Common initialization before parsing options.  */\n int\n-c_common_init_options (lang)\n-     enum c_language_kind lang;\n+c_common_init_options (enum c_language_kind lang)\n {\n   c_language = lang;\n   parse_in = cpp_create_reader (lang == clk_c ? CLK_GNUC89 : CLK_GNUCXX,\n@@ -388,9 +385,9 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \twarn_sign_compare = value;\n       warn_switch = value;\n       warn_strict_aliasing = value;\n-      \n+\n       /* Only warn about unknown pragmas that are not in system\n-\t headers.  */                                        \n+\t headers.  */\n       warn_unknown_pragmas = value;\n \n       /* We save the value of warn_uninitialized, since if they put\n@@ -653,7 +650,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \n     case OPT_Wunknown_pragmas:\n       /* Set to greater than 1, so that even unknown pragmas in\n-\t system headers will be warned about.  */  \n+\t system headers will be warned about.  */\n       warn_unknown_pragmas = value * 2;\n       break;\n \n@@ -667,7 +664,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       else\n \twarn_write_strings = value;\n       break;\n-      \n+\n     case OPT_ansi:\n       if (c_language == clk_c)\n \tset_std_c89 (false, true);\n@@ -1054,8 +1051,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \n /* Post-switch processing.  */\n bool\n-c_common_post_options (pfilename)\n-     const char **pfilename;\n+c_common_post_options (const char **pfilename)\n {\n   /* Canonicalize the input and output filenames.  */\n   if (in_fname == NULL || !strcmp (in_fname, \"-\"))\n@@ -1153,7 +1149,7 @@ c_common_post_options (pfilename)\n \n /* Front end initialization common to C, ObjC and C++.  */\n bool\n-c_common_init ()\n+c_common_init (void)\n {\n   input_line = saved_lineno;\n \n@@ -1179,13 +1175,12 @@ c_common_init ()\n   return true;\n }\n \n-/* A thin wrapper around the real parser that initializes the \n+/* A thin wrapper around the real parser that initializes the\n    integrated preprocessor after debug output has been initialized.\n    Also, make sure the start_source_file debug hook gets called for\n    the primary source file.  */\n void\n-c_common_parse_file (set_yydebug)\n-     int set_yydebug ATTRIBUTE_UNUSED;\n+c_common_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n {\n #if YYDEBUG != 0\n   yydebug = set_yydebug;\n@@ -1202,7 +1197,7 @@ c_common_parse_file (set_yydebug)\n \n /* Common finish hook for the C, ObjC and C++ front ends.  */\n void\n-c_common_finish ()\n+c_common_finish (void)\n {\n   FILE *deps_stream = NULL;\n \n@@ -1240,7 +1235,7 @@ c_common_finish ()\n    rather than overwriting it, and like Sun's compiler\n    SUNPRO_DEPENDENCIES suppresses the dependency on the main file.  */\n static void\n-check_deps_environment_vars ()\n+check_deps_environment_vars (void)\n {\n   char *spec;\n \n@@ -1278,7 +1273,7 @@ check_deps_environment_vars ()\n \n /* Handle deferred command line switches.  */\n static void\n-handle_deferred_opts ()\n+handle_deferred_opts (void)\n {\n   size_t i;\n \n@@ -1294,7 +1289,7 @@ handle_deferred_opts ()\n /* These settings are appropriate for GCC, but not necessarily so for\n    cpplib as a library.  */\n static void\n-sanitize_cpp_opts ()\n+sanitize_cpp_opts (void)\n {\n   /* If we don't know what style of dependencies to output, complain\n      if any other dependency switches have been given.  */\n@@ -1326,9 +1321,7 @@ sanitize_cpp_opts ()\n \n /* Add include path with a prefix at the front of its name.  */\n static void\n-add_prefixed_path (suffix, chain)\n-     const char *suffix;\n-     size_t chain;\n+add_prefixed_path (const char *suffix, size_t chain)\n {\n   char *path;\n   const char *prefix;\n@@ -1348,7 +1341,7 @@ add_prefixed_path (suffix, chain)\n \n /* Handle -D, -U, -A, -imacros, and the first -include.  */\n static void\n-finish_options ()\n+finish_options (void)\n {\n   if (!cpp_opts->preprocessed)\n     {\n@@ -1403,15 +1396,15 @@ finish_options ()\n \n /* Give CPP the next file given by -include, if any.  */\n static void\n-push_command_line_include ()\n+push_command_line_include (void)\n {\n   if (cpp_opts->preprocessed)\n     return;\n-    \n+\n   while (include_cursor < deferred_count)\n     {\n       struct deferred_opt *opt = &deferred_opts[include_cursor++];\n-      \n+\n       if (opt->code == OPT_include && cpp_push_include (parse_in, opt->arg))\n \treturn;\n     }\n@@ -1428,9 +1421,8 @@ push_command_line_include ()\n \n /* File change callback.  Has to handle -include files.  */\n static void\n-cb_file_change (pfile, new_map)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const struct line_map *new_map;\n+cb_file_change (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\tconst struct line_map *new_map)\n {\n   if (flag_preprocess_only)\n     pp_file_change (new_map);\n@@ -1444,8 +1436,7 @@ cb_file_change (pfile, new_map)\n /* Set the C 89 standard (with 1994 amendments if C94, without GNU\n    extensions if ISO).  There is no concept of gnu94.  */\n static void\n-set_std_c89 (c94, iso)\n-     int c94, iso;\n+set_std_c89 (int c94, int iso)\n {\n   cpp_set_lang (parse_in, c94 ? CLK_STDC94: iso ? CLK_STDC89: CLK_GNUC89);\n   flag_iso = iso;\n@@ -1460,8 +1451,7 @@ set_std_c89 (c94, iso)\n \n /* Set the C 99 standard (without GNU extensions if ISO).  */\n static void\n-set_std_c99 (iso)\n-     int iso;\n+set_std_c99 (int iso)\n {\n   cpp_set_lang (parse_in, iso ? CLK_STDC99: CLK_GNUC99);\n   flag_no_asm = iso;\n@@ -1475,8 +1465,7 @@ set_std_c99 (iso)\n \n /* Set the C++ 98 standard (without GNU extensions if ISO).  */\n static void\n-set_std_cxx98 (iso)\n-     int iso;\n+set_std_cxx98 (int iso)\n {\n   cpp_set_lang (parse_in, iso ? CLK_CXX98: CLK_GNUCXX);\n   flag_no_gnu_keywords = iso;\n@@ -1487,8 +1476,7 @@ set_std_cxx98 (iso)\n \n /* Handle setting implicit to ON.  */\n static void\n-set_Wimplicit (on)\n-     int on;\n+set_Wimplicit (int on)\n {\n   warn_implicit = on;\n   warn_implicit_int = on;\n@@ -1504,8 +1492,7 @@ set_Wimplicit (on)\n /* Args to -d specify what to dump.  Silently ignore\n    unrecognized options; they may be aimed at toplev.c.  */\n static void\n-handle_OPT_d (arg)\n-     const char *arg;\n+handle_OPT_d (const char *arg)\n {\n   char c;\n \n@@ -1526,9 +1513,7 @@ handle_OPT_d (arg)\n \n /* Write a slash-separated list of languages in FLAGS to BUF.  */\n static void\n-write_langs (buf, flags)\n-     char *buf;\n-     int flags;\n+write_langs (char *buf, int flags)\n {\n   *buf = '\\0';\n   if (flags & CL_C)\n@@ -1549,9 +1534,7 @@ write_langs (buf, flags)\n \n /* Complain that switch OPT_INDEX does not apply to this front end.  */\n static void\n-complain_wrong_lang (opt_index, on)\n-     size_t opt_index;\n-     int on;\n+complain_wrong_lang (size_t opt_index, int on)\n {\n   char ok_langs[60], bad_langs[60];\n   int ok_flags = cl_options[opt_index].flags;\n@@ -1566,7 +1549,7 @@ complain_wrong_lang (opt_index, on)\n \n /* Handle --help output.  */\n static void\n-print_help ()\n+print_help (void)\n {\n   /* To keep the lines from getting too long for some compilers, limit\n      to about 500 characters (6 lines) per chunk.  */"}, {"sha": "22b7ccc3a1aae736c04ef37f11a7eca70f87d7ed", "filename": "gcc/c-pch.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -1,5 +1,5 @@\n /* Precompiled header implementation for the C languages.\n-   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -48,15 +48,15 @@ static FILE *pch_outfile;\n \n static long asm_file_startpos;\n \n-static const char * get_ident PARAMS((void));\n+static const char *get_ident (void);\n \n /* Compute an appropriate 8-byte magic number for the PCH file, so that\n    utilities like file(1) can identify it, and so that GCC can quickly\n    ignore non-PCH files and PCH files that are of a completely different\n    format.  */\n \n static const char *\n-get_ident()\n+get_ident(void)\n {\n   static char result[IDENT_LENGTH];\n   static const char template[IDENT_LENGTH] = \"gpch.011\";\n@@ -75,7 +75,7 @@ get_ident()\n    compilation.  */\n \n void\n-pch_init ()\n+pch_init (void)\n {\n   FILE *f;\n   struct c_pch_validity v;\n@@ -111,7 +111,7 @@ pch_init ()\n    will produce a PCH file.  */\n \n void\n-c_common_write_pch ()\n+c_common_write_pch (void)\n {\n   char *buf;\n   long asm_file_end;\n@@ -157,10 +157,7 @@ c_common_write_pch ()\n    in this compilation.  */\n \n int\n-c_common_valid_pch (pfile, name, fd)\n-     cpp_reader *pfile;\n-     const char *name;\n-     int fd;\n+c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n {\n   int sizeread;\n   int result;\n@@ -232,11 +229,8 @@ c_common_valid_pch (pfile, name, fd)\n    by ORIG_NAME.  */\n \n void\n-c_common_read_pch (pfile, name, fd, orig_name)\n-     cpp_reader *pfile;\n-     const char *name;\n-     int fd;\n-     const char *orig_name ATTRIBUTE_UNUSED;\n+c_common_read_pch (cpp_reader *pfile, const char *name,\n+\t\t   int fd, const char *orig_name ATTRIBUTE_UNUSED)\n {\n   FILE *f;\n   struct c_pch_header h;"}, {"sha": "333da30b2e923b858a1a5ec911eebfebc3c1d81a", "filename": "gcc/c-ppoutput.c", "status": "modified", "additions": 32, "deletions": 64, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -40,30 +40,28 @@ static struct\n } print;\n \n /* General output routines.  */\n-static void scan_translation_unit PARAMS ((cpp_reader *));\n-static void scan_translation_unit_trad PARAMS ((cpp_reader *));\n-static void account_for_newlines PARAMS ((const uchar *, size_t));\n-static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n+static void scan_translation_unit (cpp_reader *);\n+static void scan_translation_unit_trad (cpp_reader *);\n+static void account_for_newlines (const uchar *, size_t);\n+static int dump_macro (cpp_reader *, cpp_hashnode *, void *);\n \n-static void print_line PARAMS ((const struct line_map *, unsigned int,\n-\t\t\t\tconst char *));\n-static void maybe_print_line PARAMS ((const struct line_map *, unsigned int));\n+static void print_line (const struct line_map *, unsigned int,\n+\t\t\tconst char *);\n+static void maybe_print_line (const struct line_map *, unsigned int);\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n-static void cb_line_change PARAMS ((cpp_reader *, const cpp_token *, int));\n-static void cb_define\tPARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n-static void cb_undef\tPARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n-static void cb_include\tPARAMS ((cpp_reader *, unsigned int,\n-\t\t\t\t const unsigned char *, const char *, int));\n-static void cb_ident\t  PARAMS ((cpp_reader *, unsigned int,\n-\t\t\t\t   const cpp_string *));\n-static void cb_def_pragma PARAMS ((cpp_reader *, unsigned int));\n+static void cb_line_change (cpp_reader *, const cpp_token *, int);\n+static void cb_define (cpp_reader *, unsigned int, cpp_hashnode *);\n+static void cb_undef (cpp_reader *, unsigned int, cpp_hashnode *);\n+static void cb_include (cpp_reader *, unsigned int, const unsigned char *,\n+\t\t\tconst char *, int);\n+static void cb_ident (cpp_reader *, unsigned int, const cpp_string *);\n+static void cb_def_pragma (cpp_reader *, unsigned int);\n \n /* Preprocess and output.  */\n void\n-preprocess_file (pfile)\n-     cpp_reader *pfile;\n+preprocess_file (cpp_reader *pfile)\n {\n   /* A successful cpp_read_main_file guarantees that we can call\n      cpp_scan_nooutput or cpp_get_token next.  */\n@@ -90,8 +88,7 @@ preprocess_file (pfile)\n \n /* Set up the callbacks as appropriate.  */\n void\n-init_pp_output (out_stream)\n-     FILE *out_stream;\n+init_pp_output (FILE *out_stream)\n {\n   cpp_callbacks *cb = cpp_get_callbacks (parse_in);\n \n@@ -129,8 +126,7 @@ init_pp_output (out_stream)\n /* Writes out the preprocessed file, handling spacing and paste\n    avoidance issues.  */\n static void\n-scan_translation_unit (pfile)\n-     cpp_reader *pfile;\n+scan_translation_unit (cpp_reader *pfile)\n {\n   bool avoid_paste = false;\n \n@@ -178,9 +174,7 @@ scan_translation_unit (pfile)\n \n /* Adjust print.line for newlines embedded in output.  */\n static void\n-account_for_newlines (str, len)\n-     const uchar *str;\n-     size_t len;\n+account_for_newlines (const uchar *str, size_t len)\n {\n   while (len--)\n     if (*str++ == '\\n')\n@@ -189,8 +183,7 @@ account_for_newlines (str, len)\n \n /* Writes out a traditionally preprocessed file.  */\n static void\n-scan_translation_unit_trad (pfile)\n-     cpp_reader *pfile;\n+scan_translation_unit_trad (cpp_reader *pfile)\n {\n   while (_cpp_read_logical_line_trad (pfile))\n     {\n@@ -207,9 +200,7 @@ scan_translation_unit_trad (pfile)\n    different line to the current one, output the required newlines or\n    a line marker, and return 1.  Otherwise return 0.  */\n static void\n-maybe_print_line (map, line)\n-     const struct line_map *map;\n-     unsigned int line;\n+maybe_print_line (const struct line_map *map, unsigned int line)\n {\n   /* End the previous line of text.  */\n   if (print.printed)\n@@ -234,10 +225,7 @@ maybe_print_line (map, line)\n /* Output a line marker for logical line LINE.  Special flags are \"1\"\n    or \"2\" indicating entering or leaving a file.  */\n static void\n-print_line (map, line, special_flags)\n-     const struct line_map *map;\n-     unsigned int line;\n-     const char *special_flags;\n+print_line (const struct line_map *map, unsigned int line, const char *special_flags)\n {\n   /* End any previous line of text.  */\n   if (print.printed)\n@@ -272,10 +260,7 @@ print_line (map, line, special_flags)\n /* Called when a line of output is started.  TOKEN is the first token\n    of the line, and at end of file will be CPP_EOF.  */\n static void\n-cb_line_change (pfile, token, parsing_args)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-     int parsing_args;\n+cb_line_change (cpp_reader *pfile, const cpp_token *token, int parsing_args)\n {\n   if (token->type == CPP_EOF || parsing_args)\n     return;\n@@ -303,21 +288,16 @@ cb_line_change (pfile, token, parsing_args)\n }\n \n static void\n-cb_ident (pfile, line, str)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line;\n-     const cpp_string * str;\n+cb_ident (cpp_reader *pfile ATTRIBUTE_UNUSED, unsigned int line,\n+\t  const cpp_string *str)\n {\n   maybe_print_line (print.map, line);\n   fprintf (print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n   print.line++;\n }\n \n static void\n-cb_define (pfile, line, node)\n-     cpp_reader *pfile;\n-     unsigned int line;\n-     cpp_hashnode *node;\n+cb_define (cpp_reader *pfile, unsigned int line, cpp_hashnode *node)\n {\n   maybe_print_line (print.map, line);\n   fputs (\"#define \", print.outf);\n@@ -334,23 +314,17 @@ cb_define (pfile, line, node)\n }\n \n static void\n-cb_undef (pfile, line, node)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line;\n-     cpp_hashnode *node;\n+cb_undef (cpp_reader *pfile ATTRIBUTE_UNUSED, unsigned int line,\n+\t  cpp_hashnode *node)\n {\n   maybe_print_line (print.map, line);\n   fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n   print.line++;\n }\n \n static void\n-cb_include (pfile, line, dir, header, angle_brackets)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line;\n-     const unsigned char *dir;\n-     const char *header;\n-     int angle_brackets;\n+cb_include (cpp_reader *pfile ATTRIBUTE_UNUSED, unsigned int line,\n+\t    const unsigned char *dir, const char *header, int angle_brackets)\n {\n   maybe_print_line (print.map, line);\n   if (angle_brackets)\n@@ -365,8 +339,7 @@ cb_include (pfile, line, dir, header, angle_brackets)\n    pointing to freed memory, and so must not be dereferenced.  */\n \n void\n-pp_file_change (map)\n-     const struct line_map *map;\n+pp_file_change (const struct line_map *map)\n {\n   const char *flags = \"\";\n \n@@ -398,9 +371,7 @@ pp_file_change (map)\n \n /* Copy a #pragma directive to the preprocessed output.  */\n static void\n-cb_def_pragma (pfile, line)\n-     cpp_reader *pfile;\n-     unsigned int line;\n+cb_def_pragma (cpp_reader *pfile, unsigned int line)\n {\n   maybe_print_line (print.map, line);\n   fputs (\"#pragma \", print.outf);\n@@ -410,10 +381,7 @@ cb_def_pragma (pfile, line)\n \n /* Dump out the hash table.  */\n static int\n-dump_macro (pfile, node, v)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n-     void *v ATTRIBUTE_UNUSED;\n+dump_macro (cpp_reader *pfile, cpp_hashnode *node, void *v ATTRIBUTE_UNUSED)\n {\n   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n     {"}, {"sha": "b376ac94901cde42a4810311862004bf6895b637", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 111, "deletions": 200, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines common to both C and C++ pretty-printers.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -28,55 +28,51 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-tree.h\"\n \n /* literal  */\n-static void pp_c_char              PARAMS ((c_pretty_printer, int));\n-static void pp_c_character_literal PARAMS ((c_pretty_printer, tree));\n-static void pp_c_bool_literal      PARAMS ((c_pretty_printer, tree));\n-static bool pp_c_enumerator        PARAMS ((c_pretty_printer, tree));\n-static void pp_c_integer_literal   PARAMS ((c_pretty_printer, tree));\n-static void pp_c_real_literal      PARAMS ((c_pretty_printer, tree));\n-static void pp_c_string_literal    PARAMS ((c_pretty_printer, tree));\n+static void pp_c_char (c_pretty_printer, int);\n+static void pp_c_character_literal (c_pretty_printer, tree);\n+static void pp_c_bool_literal (c_pretty_printer, tree);\n+static bool pp_c_enumerator (c_pretty_printer, tree);\n+static void pp_c_integer_literal (c_pretty_printer, tree);\n+static void pp_c_real_literal (c_pretty_printer, tree);\n+static void pp_c_string_literal (c_pretty_printer, tree);\n \n-static void pp_c_primary_expression PARAMS ((c_pretty_printer, tree));\n+static void pp_c_primary_expression (c_pretty_printer, tree);\n \n /* postfix-expression  */\n-static void pp_c_initializer_list        PARAMS ((c_pretty_printer, tree));\n-\n-static void pp_c_unary_expression        PARAMS ((c_pretty_printer, tree));\n-static void pp_c_multiplicative_expression PARAMS ((c_pretty_printer, tree));\n-static void pp_c_additive_expression     PARAMS ((c_pretty_printer, tree));\n-static void pp_c_shift_expression        PARAMS ((c_pretty_printer, tree));\n-static void pp_c_relational_expression   PARAMS ((c_pretty_printer, tree));\n-static void pp_c_equality_expression     PARAMS ((c_pretty_printer, tree));\n-static void pp_c_and_expression          PARAMS ((c_pretty_printer, tree));\n-static void pp_c_exclusive_or_expression PARAMS ((c_pretty_printer,\n-\t\t\t\t\t\t  tree));\n-static void pp_c_inclusive_or_expression PARAMS ((c_pretty_printer,\n-\t\t\t\t\t\t  tree));\n-static void pp_c_logical_and_expression PARAMS ((c_pretty_printer, tree));\n-static void pp_c_conditional_expression PARAMS ((c_pretty_printer, tree));\n-static void pp_c_assignment_expression  PARAMS ((c_pretty_printer, tree));\n+static void pp_c_initializer_list (c_pretty_printer, tree);\n+\n+static void pp_c_unary_expression (c_pretty_printer, tree);\n+static void pp_c_multiplicative_expression (c_pretty_printer, tree);\n+static void pp_c_additive_expression (c_pretty_printer, tree);\n+static void pp_c_shift_expression (c_pretty_printer, tree);\n+static void pp_c_relational_expression (c_pretty_printer, tree);\n+static void pp_c_equality_expression (c_pretty_printer, tree);\n+static void pp_c_and_expression (c_pretty_printer, tree);\n+static void pp_c_exclusive_or_expression (c_pretty_printer, tree);\n+static void pp_c_inclusive_or_expression (c_pretty_printer, tree);\n+static void pp_c_logical_and_expression (c_pretty_printer, tree);\n+static void pp_c_conditional_expression (c_pretty_printer, tree);\n+static void pp_c_assignment_expression (c_pretty_printer, tree);\n \n /* declarations.  */\n-static void pp_c_declaration_specifiers   PARAMS ((c_pretty_printer, tree));\n-static void pp_c_init_declarator          PARAMS ((c_pretty_printer, tree));\n-static void pp_c_declarator               PARAMS ((c_pretty_printer, tree));\n-static void pp_c_direct_declarator        PARAMS ((c_pretty_printer, tree));\n-static void pp_c_abstract_declarator      PARAMS ((c_pretty_printer, tree));\n-static void pp_c_specifier_qualifier_list PARAMS ((c_pretty_printer, tree));\n-static void pp_c_simple_type_specifier    PARAMS ((c_pretty_printer, tree));\n-static void pp_c_parameter_declaration    PARAMS ((c_pretty_printer, tree));\n-static void pp_c_type_id                  PARAMS ((c_pretty_printer, tree));\n-static void pp_c_storage_class_specifier  PARAMS ((c_pretty_printer, tree));\n-static void pp_c_function_specifier       PARAMS ((c_pretty_printer, tree));\n+static void pp_c_declaration_specifiers (c_pretty_printer, tree);\n+static void pp_c_init_declarator (c_pretty_printer, tree);\n+static void pp_c_declarator (c_pretty_printer, tree);\n+static void pp_c_direct_declarator (c_pretty_printer, tree);\n+static void pp_c_abstract_declarator (c_pretty_printer, tree);\n+static void pp_c_specifier_qualifier_list (c_pretty_printer, tree);\n+static void pp_c_simple_type_specifier (c_pretty_printer, tree);\n+static void pp_c_parameter_declaration (c_pretty_printer, tree);\n+static void pp_c_type_id (c_pretty_printer, tree);\n+static void pp_c_storage_class_specifier (c_pretty_printer, tree);\n+static void pp_c_function_specifier (c_pretty_printer, tree);\n \n \f\n /* Declarations.  */\n \n /* Print out CV-qualifiers.  Take care of possible extensions.  */\n void\n-pp_c_cv_qualifier (ppi, cv)\n-     c_pretty_printer ppi;\n-     int cv;\n+pp_c_cv_qualifier (c_pretty_printer ppi, int cv)\n {\n   if (cv & TYPE_QUAL_CONST)\n     pp_c_identifier (ppi, \"const\");\n@@ -87,9 +83,7 @@ pp_c_cv_qualifier (ppi, cv)\n }\n \n static void\n-pp_c_simple_type_specifier (ppi, t)\n-     c_pretty_printer ppi;\n-     tree t;\n+pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n {\n   const enum tree_code code = TREE_CODE (t);\n   switch (code)\n@@ -107,15 +101,15 @@ pp_c_simple_type_specifier (ppi, t)\n     case IDENTIFIER_NODE:\n       pp_c_tree_identifier (ppi, t);\n       break;\n-      \n+\n     case VOID_TYPE:\n     case BOOLEAN_TYPE:\n     case CHAR_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n       pp_c_tree_identifier (ppi, DECL_NAME (t));\n       break;\n-      \n+\n     case COMPLEX_TYPE:\n     case VECTOR_TYPE:\n       pp_c_simple_type_specifier (ppi, TYPE_MAIN_VARIANT (TREE_TYPE (t)));\n@@ -143,7 +137,7 @@ pp_c_simple_type_specifier (ppi, t)\n \tpp_c_identifier (ppi, \"enum\");\n       else\n \tpp_c_identifier (ppi, \"<tag-error>\");\n-      \n+\n       if (TYPE_NAME (t))\n \tpp_c_tree_identifier (ppi, TYPE_NAME (t));\n       else\n@@ -156,36 +150,28 @@ pp_c_simple_type_specifier (ppi, t)\n }\n \n static inline void\n-pp_c_specifier_qualifier_list (ppi, t)\n-     c_pretty_printer ppi;\n-     tree t;\n+pp_c_specifier_qualifier_list (c_pretty_printer ppi, tree t)\n {\n   pp_c_simple_type_specifier (ppi, TYPE_MAIN_VARIANT (TREE_TYPE (t)));\n   pp_c_cv_qualifier (ppi, TYPE_QUALS (t));\n }\n \n static void\n-pp_c_abstract_declarator (ppi, t)\n-     c_pretty_printer ppi;\n-     tree t;\n+pp_c_abstract_declarator (c_pretty_printer ppi, tree t)\n {\n   pp_unsupported_tree (ppi, t);\n }\n \n \n static inline void\n-pp_c_type_id (ppi, t)\n-     c_pretty_printer ppi;\n-     tree t;\n+pp_c_type_id (c_pretty_printer ppi, tree t)\n {\n   pp_c_specifier_qualifier_list (ppi, t);\n   pp_c_abstract_declarator (ppi, t);\n }\n \n static inline void\n-pp_c_storage_class_specifier (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_storage_class_specifier (c_pretty_printer pp, tree t)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n     pp_c_identifier (pp, \"typedef\");\n@@ -194,18 +180,14 @@ pp_c_storage_class_specifier (pp, t)\n }\n \n static inline void\n-pp_c_function_specifier (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_function_specifier (c_pretty_printer pp, tree t)\n {\n   if (TREE_CODE (t) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (t))\n     pp_c_identifier (pp, \"inline\");\n }\n \n static inline void\n-pp_c_declaration_specifiers (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_declaration_specifiers (c_pretty_printer pp, tree t)\n {\n   pp_c_storage_class_specifier (pp, t);\n   pp_c_function_specifier (pp, t);\n@@ -214,25 +196,19 @@ pp_c_declaration_specifiers (pp, t)\n }\n \n static inline void\n-pp_c_direct_declarator (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_direct_declarator (c_pretty_printer pp, tree t)\n {\n   pp_unsupported_tree (pp, t);\n }\n \n static inline void\n-pp_c_declarator (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_declarator (c_pretty_printer pp, tree t)\n {\n   pp_unsupported_tree (pp, t);\n }\n \n static inline void\n-pp_c_init_declarator (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_init_declarator (c_pretty_printer pp, tree t)\n {\n   pp_declarator (pp, t);\n   if (DECL_INITIAL (t))\n@@ -245,33 +221,27 @@ pp_c_init_declarator (pp, t)\n }\n \n void\n-pp_c_declaration (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_declaration (c_pretty_printer pp, tree t)\n {\n   pp_declaration_specifiers (pp, t);\n   pp_c_init_declarator (pp, t);\n }\n \n static void\n-pp_c_parameter_declaration (pp, t)\n-     c_pretty_printer pp;\n-     tree t;\n+pp_c_parameter_declaration (c_pretty_printer pp, tree t)\n {\n   pp_unsupported_tree (pp, t);\n }\n \n /* Pretty-print ATTRIBUTES using GNU C extension syntax.  */\n-void \n-pp_c_attributes (pp, attributes)\n-     c_pretty_printer pp;\n-     tree attributes;\n+void\n+pp_c_attributes (c_pretty_printer pp, tree attributes)\n {\n   if (attributes == NULL_TREE)\n     return;\n-  \n+\n   pp_c_identifier (pp, \"__attribute__\");\n-  pp_c_left_paren (pp); \n+  pp_c_left_paren (pp);\n   pp_c_left_paren (pp);\n   for (; attributes != NULL_TREE; attributes = TREE_CHAIN (attributes))\n     {\n@@ -282,7 +252,7 @@ pp_c_attributes (pp, attributes)\n \t  pp_c_expression_list (pp, TREE_VALUE (attributes));\n \t  pp_c_right_paren (pp);\n \t}\n-      \n+\n       if (TREE_CHAIN (attributes))\n \tpp_separate_with (pp, ',');\n     }\n@@ -295,9 +265,7 @@ pp_c_attributes (pp, attributes)\n \n /* Print out a c-char.  */\n static void\n-pp_c_char (ppi, c)\n-     c_pretty_printer ppi;\n-     int c;\n+pp_c_char (c_pretty_printer ppi, int c)\n {\n   switch (c)\n     {\n@@ -342,9 +310,7 @@ pp_c_char (ppi, c)\n \n /* Print out a STRING literal.  */\n static inline void\n-pp_c_string_literal (ppi, s)\n-     c_pretty_printer ppi;\n-     tree s;\n+pp_c_string_literal (c_pretty_printer ppi, tree s)\n {\n   const char *p = TREE_STRING_POINTER (s);\n   int n = TREE_STRING_LENGTH (s) - 1;\n@@ -357,9 +323,7 @@ pp_c_string_literal (ppi, s)\n \n /* Print out a CHARACTER literal.  */\n static inline void\n-pp_c_character_literal (ppi, c)\n-     c_pretty_printer ppi;\n-     tree c;\n+pp_c_character_literal (c_pretty_printer ppi, tree c)\n {\n   pp_quote (ppi);\n   pp_c_char (ppi, tree_low_cst (c, 0));\n@@ -368,9 +332,7 @@ pp_c_character_literal (ppi, c)\n \n /* Print out a BOOLEAN literal.  */\n static inline void\n-pp_c_bool_literal (ppi, b)\n-     c_pretty_printer ppi;\n-     tree b;\n+pp_c_bool_literal (c_pretty_printer ppi, tree b)\n {\n   if (b == boolean_false_node || integer_zerop (b))\n     {\n@@ -394,24 +356,22 @@ pp_c_bool_literal (ppi, b)\n     pp_unsupported_tree (ppi, b);\n }\n \n-/* Attempt to print out an ENUMERATOR.  Return true on success.  Else return \n+/* Attempt to print out an ENUMERATOR.  Return true on success.  Else return\n    false; that means the value was obtained by a cast, in which case\n    print out the type-id part of the cast-expression -- the casted value\n    is then printed by pp_c_integer_literal.  */\n static bool\n-pp_c_enumerator (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_enumerator (c_pretty_printer ppi, tree e)\n {\n   tree type = TREE_TYPE (e);\n   tree value;\n \n   /* Find the name of this constant.  */\n-  for (value = TYPE_VALUES (type); \n+  for (value = TYPE_VALUES (type);\n        value != NULL_TREE && !tree_int_cst_equal (TREE_VALUE (value), e);\n        value = TREE_CHAIN (value))\n     ;\n-  \n+\n   if (value != NULL_TREE)\n     pp_c_tree_identifier (ppi, TREE_PURPOSE (value));\n   else\n@@ -422,18 +382,16 @@ pp_c_enumerator (ppi, e)\n       pp_c_right_paren (ppi);\n       return false;\n     }\n-  \n+\n   return true;\n }\n \n /* Print out an INTEGER constant value.  */\n static void\n-pp_c_integer_literal (ppi, i)\n-     c_pretty_printer ppi;\n-     tree i;\n+pp_c_integer_literal (c_pretty_printer ppi, tree i)\n {\n   tree type = TREE_TYPE (i);\n-  \n+\n   if (type == boolean_type_node)\n     pp_c_bool_literal (ppi, i);\n   else if (type == char_type_node)\n@@ -453,7 +411,7 @@ pp_c_integer_literal (ppi, i)\n \t      i = build_int_2 (-TREE_INT_CST_LOW (i),\n \t\t\t       ~TREE_INT_CST_HIGH (i) + !TREE_INT_CST_LOW (i));\n \t      sprintf (pp_buffer (ppi)->digit_buffer,\n-\t\t       HOST_WIDE_INT_PRINT_DOUBLE_HEX, \n+\t\t       HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n \t\t       TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n \t      pp_identifier (ppi, pp_buffer (ppi)->digit_buffer);\n \n@@ -464,9 +422,7 @@ pp_c_integer_literal (ppi, i)\n \n /* Print out a REAL value.  */\n static inline void\n-pp_c_real_literal (ppi, r)\n-     c_pretty_printer ppi;\n-     tree r;\n+pp_c_real_literal (c_pretty_printer ppi, tree r)\n {\n   real_to_decimal (pp_buffer (ppi)->digit_buffer, &TREE_REAL_CST (r),\n \t\t   sizeof (pp_buffer (ppi)->digit_buffer), 0, 1);\n@@ -475,23 +431,21 @@ pp_c_real_literal (ppi, r)\n \n \n void\n-pp_c_literal (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_literal (c_pretty_printer ppi, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case INTEGER_CST:\n       pp_c_integer_literal (ppi, e);\n       break;\n-      \n+\n     case REAL_CST:\n       pp_c_real_literal (ppi, e);\n       break;\n-      \n+\n     case STRING_CST:\n       pp_c_string_literal (ppi, e);\n-      break;      \n+      break;\n \n     default:\n       pp_unsupported_tree (ppi, e);\n@@ -501,9 +455,7 @@ pp_c_literal (ppi, e)\n \n /* Pretty-print a C primary-expression.  */\n static void\n-pp_c_primary_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_primary_expression (c_pretty_printer ppi, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n@@ -522,7 +474,7 @@ pp_c_primary_expression (ppi, e)\n     case ERROR_MARK:\n       pp_c_identifier (ppi, \"<erroneous-expression>\");\n       break;\n-\t\t       \n+\n     case RESULT_DECL:\n       pp_c_identifier (ppi, \"<return-value>\");\n       break;\n@@ -566,9 +518,7 @@ pp_c_primary_expression (ppi, e)\n \n /* Print out a C initializer -- also support C compound-literals.  */\n void\n-pp_c_initializer (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_initializer (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == CONSTRUCTOR)\n     {\n@@ -587,9 +537,7 @@ pp_c_initializer (ppi, e)\n }\n \n static void\n-pp_c_initializer_list (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_initializer_list (c_pretty_printer ppi, tree e)\n {\n   tree type = TREE_TYPE (e);\n   const enum tree_code code = TREE_CODE (type);\n@@ -624,9 +572,7 @@ pp_c_initializer_list (ppi, e)\n }\n \n void\n-pp_c_postfix_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -636,7 +582,7 @@ pp_c_postfix_expression (ppi, e)\n       pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n       pp_identifier (ppi, code == POSTINCREMENT_EXPR ? \"++\" : \"--\");\n       break;\n-      \n+\n     case ARROW_EXPR:\n       pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n       pp_arrow (ppi);\n@@ -658,7 +604,7 @@ pp_c_postfix_expression (ppi, e)\n \n     case ABS_EXPR:\n     case FFS_EXPR:\n-      pp_c_identifier (ppi, \n+      pp_c_identifier (ppi,\n \t\t       code == ABS_EXPR ? \"__builtin_abs\" : \"__builtin_ffs\");\n       pp_c_left_paren (ppi);\n       pp_c_expression (ppi, TREE_OPERAND (e, 0));\n@@ -689,7 +635,7 @@ pp_c_postfix_expression (ppi, e)\n       pp_type_id (ppi, TREE_TYPE (e));\n       pp_c_right_paren (ppi);\n       pp_left_brace (ppi);\n-      \n+\n       if (code == COMPLEX_CST)\n \t{\n \t  pp_c_expression (ppi, TREE_REALPART (e));\n@@ -704,7 +650,7 @@ pp_c_postfix_expression (ppi, e)\n \t  pp_separate_with (ppi, ',');\n \t  pp_c_expression (ppi, TREE_OPERAND (e, 1));\n \t}\n-      \n+\n       pp_right_brace (ppi);\n       break;\n \n@@ -714,7 +660,7 @@ pp_c_postfix_expression (ppi, e)\n     case CONSTRUCTOR:\n       pp_initializer (ppi, e);\n       break;\n-      \n+\n     case VA_ARG_EXPR:\n       pp_c_identifier (ppi, \"__builtin_va_arg\");\n       pp_c_left_paren (ppi);\n@@ -732,9 +678,7 @@ pp_c_postfix_expression (ppi, e)\n \n /* Print out an expression-list; E is expected to be a TREE_LIST  */\n void\n-pp_c_expression_list (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_expression_list (c_pretty_printer ppi, tree e)\n {\n   for (; e != NULL_TREE; e = TREE_CHAIN (e))\n     {\n@@ -745,9 +689,7 @@ pp_c_expression_list (ppi, e)\n }\n \n static void\n-pp_c_unary_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_unary_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -757,7 +699,7 @@ pp_c_unary_expression (ppi, e)\n       pp_identifier (ppi, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n       pp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n       break;\n-      \n+\n     case ADDR_EXPR:\n     case INDIRECT_REF:\n     case CONVERT_EXPR:\n@@ -798,17 +740,15 @@ pp_c_unary_expression (ppi, e)\n       pp_c_whitespace (ppi);\n       pp_unary_expression (ppi, TREE_OPERAND (e, 0));\n       break;\n-      \n+\n     default:\n       pp_postfix_expression (ppi, e);\n       break;\n     }\n }\n \n void\n-pp_c_cast_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_cast_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == CONVERT_EXPR || TREE_CODE (e) == FLOAT_EXPR)\n     {\n@@ -822,9 +762,7 @@ pp_c_cast_expression (ppi, e)\n }\n \n static void\n-pp_c_multiplicative_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_multiplicative_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -851,9 +789,7 @@ pp_c_multiplicative_expression (ppi, e)\n }\n \n static inline void\n-pp_c_additive_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_additive_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -877,9 +813,7 @@ pp_c_additive_expression (ppi, e)\n }\n \n static inline void\n-pp_c_shift_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_shift_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -899,9 +833,7 @@ pp_c_shift_expression (ppi, e)\n }\n \n static void\n-pp_c_relational_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_relational_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -931,9 +863,7 @@ pp_c_relational_expression (ppi, e)\n }\n \n static inline void\n-pp_c_equality_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_equality_expression (c_pretty_printer ppi, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -945,18 +875,16 @@ pp_c_equality_expression (ppi, e)\n       pp_identifier (ppi, code == EQ_EXPR ? \"==\" : \"!=\");\n       pp_c_whitespace (ppi);\n       pp_c_relational_expression (ppi, TREE_OPERAND (e, 1));\n-      break;\t\n-      \n+      break;\n+\n     default:\n       pp_c_relational_expression (ppi, e);\n       break;\n     }\n }\n \n static inline void\n-pp_c_and_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_and_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == BIT_AND_EXPR)\n     {\n@@ -971,9 +899,7 @@ pp_c_and_expression (ppi, e)\n }\n \n static inline void\n-pp_c_exclusive_or_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_exclusive_or_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == BIT_XOR_EXPR)\n     {\n@@ -988,9 +914,7 @@ pp_c_exclusive_or_expression (ppi, e)\n }\n \n static inline void\n-pp_c_inclusive_or_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_inclusive_or_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == BIT_IOR_EXPR)\n     {\n@@ -1005,9 +929,7 @@ pp_c_inclusive_or_expression (ppi, e)\n }\n \n static inline void\n-pp_c_logical_and_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_logical_and_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == TRUTH_ANDIF_EXPR)\n     {\n@@ -1022,9 +944,7 @@ pp_c_logical_and_expression (ppi, e)\n }\n \n void\n-pp_c_logical_or_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_logical_or_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == TRUTH_ORIF_EXPR)\n     {\n@@ -1039,9 +959,7 @@ pp_c_logical_or_expression (ppi, e)\n }\n \n static void\n-pp_c_conditional_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_conditional_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == COND_EXPR)\n     {\n@@ -1062,9 +980,7 @@ pp_c_conditional_expression (ppi, e)\n \n /* Pretty-print a C assignment-expression.  */\n static void\n-pp_c_assignment_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_assignment_expression (c_pretty_printer ppi, tree e)\n {\n   if (TREE_CODE (e) == MODIFY_EXPR || TREE_CODE (e) == INIT_EXPR)\n     {\n@@ -1080,24 +996,22 @@ pp_c_assignment_expression (ppi, e)\n \n /* Pretty-print an expression.  */\n void\n-pp_c_expression (ppi, e)\n-     c_pretty_printer ppi;\n-     tree e;\n+pp_c_expression (c_pretty_printer ppi, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case INTEGER_CST:\n       pp_c_integer_literal (ppi, e);\n       break;\n-      \n+\n     case REAL_CST:\n       pp_c_real_literal (ppi, e);\n       break;\n \n     case STRING_CST:\n       pp_c_string_literal (ppi, e);\n       break;\n-      \n+\n     case FUNCTION_DECL:\n     case VAR_DECL:\n     case CONST_DECL:\n@@ -1206,7 +1120,7 @@ pp_c_expression (ppi, e)\n       pp_assignment_expression (ppi, TREE_OPERAND (e, 1));\n       pp_c_right_paren (ppi);\n       break;\n-\t\t     \n+\n \n     default:\n       pp_unsupported_tree (ppi, e);\n@@ -1217,9 +1131,7 @@ pp_c_expression (ppi, e)\n \f\n /* Statements.  */\n void\n-pp_c_statement (ppi, stmt)\n-     c_pretty_printer ppi;\n-     tree stmt;\n+pp_c_statement (c_pretty_printer ppi, tree stmt)\n {\n   const enum tree_code code = TREE_CODE (stmt);\n   switch (code)\n@@ -1262,7 +1174,7 @@ pp_c_statement (ppi, stmt)\n     case EXPR_STMT:\n     case CLEANUP_STMT:\n       pp_newline (ppi);\n-      pp_c_expression (ppi, code == EXPR_STMT \n+      pp_c_expression (ppi, code == EXPR_STMT\n \t\t       ? EXPR_STMT_EXPR (stmt)\n \t\t       : CLEANUP_EXPR (stmt));\n       pp_semicolon (ppi);\n@@ -1346,7 +1258,7 @@ pp_c_statement (ppi, stmt)\n       pp_statement (ppi, FOR_BODY (stmt));\n       pp_newline_and_indent (ppi, -3);\n       break;\n-      \n+\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n       pp_newline (ppi);\n@@ -1358,7 +1270,7 @@ pp_c_statement (ppi, stmt)\n     case RETURN_STMT:\n     case GOTO_STMT:\n       {\n-\ttree e = code == RETURN_STMT \n+\ttree e = code == RETURN_STMT\n \t  ? RETURN_STMT_EXPR (stmt)\n \t  : GOTO_DESTINATION (stmt);\n \n@@ -1396,7 +1308,7 @@ pp_c_statement (ppi, stmt)\n     case ASM_STMT:\n       {\n \tbool has_volatile_p = ASM_VOLATILE_P (stmt);\n-\tbool is_extended = has_volatile_p || ASM_INPUTS (stmt) \n+\tbool is_extended = has_volatile_p || ASM_INPUTS (stmt)\n \t  || ASM_OUTPUTS (stmt) || ASM_CLOBBERS (stmt);\n \tpp_c_identifier (ppi, is_extended ? \"__asm__\" : \"asm\");\n \tif (has_volatile_p)\n@@ -1443,8 +1355,7 @@ pp_c_statement (ppi, stmt)\n \f\n /* Initialize the PRETTY-PRINTER for handling C codes.  */\n void\n-pp_c_pretty_printer_init (pp)\n-     c_pretty_printer pp;\n+pp_c_pretty_printer_init (c_pretty_printer pp)\n {\n   pp->offset_list               = 0;\n "}, {"sha": "95cd4eff19851a31778d311c6d9eb03ba8b118e4", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -1,5 +1,5 @@\n /* Various declarations for the C and C++ pretty-printers.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n This file is part of GCC.\n@@ -32,7 +32,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n typedef struct c_pretty_print_info *c_pretty_printer;\n \n /* The type of a C pretty-printer 'member' function.  */\n-typedef void (*c_pretty_print_fn) PARAMS ((c_pretty_printer, tree));\n+typedef void (*c_pretty_print_fn) (c_pretty_printer, tree);\n \n struct c_pretty_print_info\n {\n@@ -144,22 +144,22 @@ struct c_pretty_print_info\n    macro must be overridden by any subclass of c_pretty_print_info.  */\n #define pp_c_base(PP)  (PP)\n \n-extern void pp_c_pretty_printer_init   PARAMS ((c_pretty_printer));\n+extern void pp_c_pretty_printer_init (c_pretty_printer);\n \n /* Declarations.  */\n-void pp_c_attributes                   PARAMS ((c_pretty_printer, tree));\n-void pp_c_cv_qualifier                 PARAMS ((c_pretty_printer, int));\n-void pp_c_parameter_declaration_clause PARAMS ((c_pretty_printer, tree));\n-void pp_c_declaration                  PARAMS ((c_pretty_printer, tree));\n+void pp_c_attributes (c_pretty_printer, tree);\n+void pp_c_cv_qualifier (c_pretty_printer, int);\n+void pp_c_parameter_declaration_clause (c_pretty_printer, tree);\n+void pp_c_declaration (c_pretty_printer, tree);\n /* Statements.  */\n-void pp_c_statement                    PARAMS ((c_pretty_printer, tree));\n+void pp_c_statement (c_pretty_printer, tree);\n /* Expressions.  */\n-void pp_c_expression                   PARAMS ((c_pretty_printer, tree));\n-void pp_c_logical_or_expression        PARAMS ((c_pretty_printer, tree));\n-void pp_c_expression_list              PARAMS ((c_pretty_printer, tree));\n-void pp_c_cast_expression              PARAMS ((c_pretty_printer, tree));\n-void pp_c_postfix_expression           PARAMS ((c_pretty_printer, tree));\n-void pp_c_initializer                  PARAMS ((c_pretty_printer, tree));\n-void pp_c_literal                      PARAMS ((c_pretty_printer, tree));\n+void pp_c_expression (c_pretty_printer, tree);\n+void pp_c_logical_or_expression (c_pretty_printer, tree);\n+void pp_c_expression_list (c_pretty_printer, tree);\n+void pp_c_cast_expression (c_pretty_printer, tree);\n+void pp_c_postfix_expression (c_pretty_printer, tree);\n+void pp_c_initializer (c_pretty_printer, tree);\n+void pp_c_literal (c_pretty_printer, tree);\n \n #endif /* GCC_C_PRETTY_PRINTER */"}, {"sha": "3d747e62d7f0e35c910f527603f88876ff31ebeb", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 80, "deletions": 124, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -1,6 +1,6 @@\n /* This file contains the definitions and documentation for the common\n    tree codes used in the GNU C and C++ compilers (see c-common.def\n-   for the standard codes).  \n+   for the standard codes).\n    Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Written by Benjamin Chelf (chelf@codesourcery.com).\n \n@@ -43,26 +43,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* If non-NULL, the address of a language-specific function for\n    expanding statements.  */\n-void (*lang_expand_stmt) PARAMS ((tree));\n+void (*lang_expand_stmt) (tree);\n \n /* If non-NULL, the address of a language-specific function for\n    expanding a DECL_STMT.  After the language-independent cases are\n    handled, this function will be called.  If this function is not\n    defined, it is assumed that declarations other than those for\n    variables and labels do not require any RTL generation.  */\n-void (*lang_expand_decl_stmt) PARAMS ((tree));\n+void (*lang_expand_decl_stmt) (tree);\n \n-static tree find_reachable_label_1\tPARAMS ((tree *, int *, void *));\n-static tree find_reachable_label\tPARAMS ((tree));\n-static bool expand_unreachable_if_stmt\tPARAMS ((tree));\n-static tree expand_unreachable_stmt\tPARAMS ((tree, int));\n-static void genrtl_do_stmt_1\t\tPARAMS ((tree, tree));\n+static tree find_reachable_label_1 (tree *, int *, void *);\n+static tree find_reachable_label (tree);\n+static bool expand_unreachable_if_stmt (tree);\n+static tree expand_unreachable_stmt (tree, int);\n+static void genrtl_do_stmt_1 (tree, tree);\n \n /* Create an empty statement tree rooted at T.  */\n \n void\n-begin_stmt_tree (t)\n-     tree *t;\n+begin_stmt_tree (tree *t)\n {\n   /* We create a trivial EXPR_STMT so that last_tree is never NULL in\n      what follows.  We remove the extraneous statement in\n@@ -76,8 +75,7 @@ begin_stmt_tree (t)\n /* T is a statement.  Add it to the statement-tree.  */\n \n tree\n-add_stmt (t)\n-     tree t;\n+add_stmt (tree t)\n {\n   if (input_filename != last_expr_filename)\n     {\n@@ -95,7 +93,7 @@ add_stmt (t)\n   /* Add T to the statement-tree.  */\n   TREE_CHAIN (last_tree) = t;\n   last_tree = t;\n-  \n+\n   /* When we expand a statement-tree, we must know whether or not the\n      statements are full-expressions.  We record that fact here.  */\n   STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n@@ -111,14 +109,13 @@ add_stmt (t)\n    DECL.  */\n \n void\n-add_decl_stmt (decl)\n-     tree decl;\n+add_decl_stmt (tree decl)\n {\n   tree decl_stmt;\n \n   /* We need the type to last until instantiation time.  */\n   decl_stmt = build_stmt (DECL_STMT, decl);\n-  add_stmt (decl_stmt); \n+  add_stmt (decl_stmt);\n }\n \n /* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n@@ -132,9 +129,7 @@ add_decl_stmt (decl)\n    SCOPE_BEGIN_P set.  */\n \n tree\n-add_scope_stmt (begin_p, partial_p)\n-     int begin_p;\n-     int partial_p;\n+add_scope_stmt (int begin_p, int partial_p)\n {\n   tree *stack_ptr = current_scope_stmt_stack ();\n   tree ss;\n@@ -168,11 +163,10 @@ add_scope_stmt (begin_p, partial_p)\n /* Finish the statement tree rooted at T.  */\n \n void\n-finish_stmt_tree (t)\n-     tree *t;\n+finish_stmt_tree (tree *t)\n {\n   tree stmt;\n-  \n+\n   /* Remove the fake extra statement added in begin_stmt_tree.  */\n   stmt = TREE_CHAIN (*t);\n   *t = stmt;\n@@ -200,7 +194,7 @@ build_stmt (enum tree_code code, ...)\n   int length;\n   int i;\n   va_list p;\n-  \n+\n   va_start (p, code);\n \n   t = make_node (code);\n@@ -220,23 +214,21 @@ build_stmt (enum tree_code code, ...)\n    as the condition is returned.  Otherwise, T itself is returned.  */\n \n tree\n-expand_cond (t)\n-     tree t;\n+expand_cond (tree t)\n {\n   if (t && TREE_CODE (t) == TREE_LIST)\n     {\n       expand_stmt (TREE_PURPOSE (t));\n       return TREE_VALUE (t);\n     }\n-  else \n+  else\n     return t;\n }\n \n /* Create RTL for the local static variable DECL.  */\n \n void\n-make_rtl_for_local_static (decl)\n-     tree decl;\n+make_rtl_for_local_static (tree decl)\n {\n   const char *asmspec = NULL;\n \n@@ -271,8 +263,7 @@ make_rtl_for_local_static (decl)\n /* Let the back-end know about DECL.  */\n \n void\n-emit_local_var (decl)\n-     tree decl;\n+emit_local_var (tree decl)\n {\n   /* Create RTL for this variable.  */\n   if (!DECL_RTL_SET_P (decl))\n@@ -303,7 +294,7 @@ emit_local_var (decl)\n /* Helper for generating the RTL at the beginning of a scope.  */\n \n void\n-genrtl_do_pushlevel ()\n+genrtl_do_pushlevel (void)\n {\n   emit_line_note (input_filename, input_line);\n   clear_last_expr ();\n@@ -312,23 +303,22 @@ genrtl_do_pushlevel ()\n /* Generate the RTL for DESTINATION, which is a GOTO_STMT.  */\n \n void\n-genrtl_goto_stmt (destination)\n-     tree destination;\n+genrtl_goto_stmt (tree destination)\n {\n   if (TREE_CODE (destination) == IDENTIFIER_NODE)\n     abort ();\n-  \n+\n   /* We warn about unused labels with -Wunused.  That means we have to\n      mark the used labels as used.  */\n   if (TREE_CODE (destination) == LABEL_DECL)\n     TREE_USED (destination) = 1;\n-  \n+\n   emit_line_note (input_filename, input_line);\n-  \n+\n   if (TREE_CODE (destination) == LABEL_DECL)\n     {\n       label_rtx (destination);\n-      expand_goto (destination); \n+      expand_goto (destination);\n     }\n   else\n     expand_computed_goto (destination);\n@@ -339,8 +329,7 @@ genrtl_goto_stmt (destination)\n    used for new code.  */\n \n void\n-genrtl_expr_stmt (expr)\n-     tree expr;\n+genrtl_expr_stmt (tree expr)\n {\n   genrtl_expr_stmt_value (expr, -1, 1);\n }\n@@ -352,21 +341,19 @@ genrtl_expr_stmt (expr)\n    MAYBE_LAST is nonzero if this EXPR_STMT might be the last statement\n    in expression statement.  */\n \n-void \n-genrtl_expr_stmt_value (expr, want_value, maybe_last)\n-     tree expr;\n-     int want_value, maybe_last;\n+void\n+genrtl_expr_stmt_value (tree expr, int want_value, int maybe_last)\n {\n   if (expr != NULL_TREE)\n     {\n       emit_line_note (input_filename, input_line);\n-      \n+\n       if (stmts_are_full_exprs_p ())\n \texpand_start_target_temps ();\n-      \n+\n       if (expr != error_mark_node)\n \texpand_expr_stmt_value (expr, want_value, maybe_last);\n-      \n+\n       if (stmts_are_full_exprs_p ())\n \texpand_end_target_temps ();\n     }\n@@ -375,8 +362,7 @@ genrtl_expr_stmt_value (expr, want_value, maybe_last)\n /* Generate the RTL for T, which is a DECL_STMT.  */\n \n void\n-genrtl_decl_stmt (t)\n-     tree t;\n+genrtl_decl_stmt (tree t)\n {\n   tree decl;\n   emit_line_note (input_filename, input_line);\n@@ -387,20 +373,20 @@ genrtl_decl_stmt (t)\n      `extern').  We don't have to handle the initialization\n      of those objects here; they can only be declarations,\n      rather than definitions.  */\n-  if (TREE_CODE (decl) == VAR_DECL \n+  if (TREE_CODE (decl) == VAR_DECL\n       && !TREE_STATIC (decl)\n       && !DECL_EXTERNAL (decl))\n     {\n       /* Let the back-end know about this variable.  */\n       if (!anon_aggr_type_p (TREE_TYPE (decl)))\n \temit_local_var (decl);\n       else\n-\texpand_anon_union_decl (decl, NULL_TREE, \n+\texpand_anon_union_decl (decl, NULL_TREE,\n \t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n     }\n   else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n     make_rtl_for_local_static (decl);\n-  else if (TREE_CODE (decl) == LABEL_DECL \n+  else if (TREE_CODE (decl) == LABEL_DECL\n \t   && C_DECLARED_LABEL_FLAG (decl))\n     declare_nonlocal_label (decl);\n   else if (lang_expand_decl_stmt)\n@@ -410,8 +396,7 @@ genrtl_decl_stmt (t)\n /* Generate the RTL for T, which is an IF_STMT.  */\n \n void\n-genrtl_if_stmt (t)\n-     tree t;\n+genrtl_if_stmt (tree t)\n {\n   tree cond;\n   genrtl_do_pushlevel ();\n@@ -421,7 +406,7 @@ genrtl_if_stmt (t)\n   if (THEN_CLAUSE (t))\n     {\n       tree nextt = THEN_CLAUSE (t);\n-      \n+\n       if (cond && integer_zerop (cond))\n \tnextt = expand_unreachable_stmt (nextt, warn_notreached);\n       expand_stmt (nextt);\n@@ -441,14 +426,13 @@ genrtl_if_stmt (t)\n /* Generate the RTL for T, which is a WHILE_STMT.  */\n \n void\n-genrtl_while_stmt (t)\n-     tree t;\n+genrtl_while_stmt (tree t)\n {\n   tree cond = WHILE_COND (t);\n \n   emit_nop ();\n   emit_line_note (input_filename, input_line);\n-  expand_start_loop (1); \n+  expand_start_loop (1);\n   genrtl_do_pushlevel ();\n \n   if (cond && !integer_nonzerop (cond))\n@@ -458,7 +442,7 @@ genrtl_while_stmt (t)\n       expand_exit_loop_top_cond (0, cond);\n       genrtl_do_pushlevel ();\n     }\n-  \n+\n   expand_stmt (WHILE_BODY (t));\n \n   expand_end_loop ();\n@@ -468,8 +452,7 @@ genrtl_while_stmt (t)\n    body.  This is reused for expanding unreachable WHILE_STMTS.  */\n \n static void\n-genrtl_do_stmt_1 (cond, body)\n-     tree cond, body;\n+genrtl_do_stmt_1 (tree cond, tree body)\n {\n   /* Recognize the common special-case of do { ... } while (0) and do\n      not emit the loop widgetry in this case.  In particular this\n@@ -512,26 +495,23 @@ genrtl_do_stmt_1 (cond, body)\n /* Generate the RTL for T, which is a DO_STMT.  */\n \n void\n-genrtl_do_stmt (t)\n-     tree t;\n+genrtl_do_stmt (tree t)\n {\n   genrtl_do_stmt_1 (DO_COND (t), DO_BODY (t));\n }\n \n /* Build the node for a return statement and return it.  */\n \n tree\n-build_return_stmt (expr)\n-     tree expr;\n+build_return_stmt (tree expr)\n {\n   return (build_stmt (RETURN_STMT, expr));\n }\n \n /* Generate the RTL for STMT, which is a RETURN_STMT.  */\n \n void\n-genrtl_return_stmt (stmt)\n-     tree stmt;\n+genrtl_return_stmt (tree stmt)\n {\n   tree expr;\n \n@@ -551,8 +531,7 @@ genrtl_return_stmt (stmt)\n /* Generate the RTL for T, which is a FOR_STMT.  */\n \n void\n-genrtl_for_stmt (t)\n-     tree t;\n+genrtl_for_stmt (tree t)\n {\n   tree cond = FOR_COND (t);\n   location_t saved_loc;\n@@ -566,7 +545,7 @@ genrtl_for_stmt (t)\n   emit_nop ();\n   emit_line_note (input_filename, input_line);\n   if (FOR_EXPR (t))\n-    expand_start_loop_continue_elsewhere (1); \n+    expand_start_loop_continue_elsewhere (1);\n   else\n     expand_start_loop (1);\n   genrtl_do_pushlevel ();\n@@ -601,15 +580,15 @@ genrtl_for_stmt (t)\n /* Build a break statement node and return it.  */\n \n tree\n-build_break_stmt ()\n+build_break_stmt (void)\n {\n   return (build_stmt (BREAK_STMT));\n }\n \n /* Generate the RTL for a BREAK_STMT.  */\n \n void\n-genrtl_break_stmt ()\n+genrtl_break_stmt (void)\n {\n   emit_line_note (input_filename, input_line);\n   if ( ! expand_exit_something ())\n@@ -619,26 +598,25 @@ genrtl_break_stmt ()\n /* Build a continue statement node and return it.  */\n \n tree\n-build_continue_stmt ()\n+build_continue_stmt (void)\n {\n   return (build_stmt (CONTINUE_STMT));\n }\n \n /* Generate the RTL for a CONTINUE_STMT.  */\n \n void\n-genrtl_continue_stmt ()\n+genrtl_continue_stmt (void)\n {\n   emit_line_note (input_filename, input_line);\n   if (! expand_continue_loop (0))\n-    error (\"continue statement not within a loop\");   \n+    error (\"continue statement not within a loop\");\n }\n \n /* Generate the RTL for T, which is a SCOPE_STMT.  */\n \n void\n-genrtl_scope_stmt (t)\n-     tree t;\n+genrtl_scope_stmt (tree t)\n {\n   tree block = SCOPE_STMT_BLOCK (t);\n \n@@ -652,7 +630,7 @@ genrtl_scope_stmt (t)\n   else if (!SCOPE_NULLIFIED_P (t))\n     {\n       rtx note = emit_note (NULL,\n-\t\t\t    (SCOPE_BEGIN_P (t) \n+\t\t\t    (SCOPE_BEGIN_P (t)\n \t\t\t     ? NOTE_INSN_BLOCK_BEG\n \t\t\t     : NOTE_INSN_BLOCK_END));\n       NOTE_BLOCK (note) = block;\n@@ -666,7 +644,7 @@ genrtl_scope_stmt (t)\n \n       for (fn = BLOCK_VARS (block); fn; fn = TREE_CHAIN (fn))\n \t{\n-\t  if (TREE_CODE (fn) == FUNCTION_DECL \n+\t  if (TREE_CODE (fn) == FUNCTION_DECL\n \t      && DECL_CONTEXT (fn) == current_function_decl\n \t      && DECL_SAVED_INSNS (fn)\n \t      && !TREE_ASM_WRITTEN (fn)\n@@ -683,12 +661,11 @@ genrtl_scope_stmt (t)\n /* Generate the RTL for T, which is a SWITCH_STMT.  */\n \n void\n-genrtl_switch_stmt (t)\n-     tree t;\n+genrtl_switch_stmt (tree t)\n {\n   tree cond;\n   genrtl_do_pushlevel ();\n- \n+\n   cond = expand_cond (SWITCH_COND (t));\n   if (cond == error_mark_node)\n     /* The code is in error, but we don't want expand_end_case to\n@@ -704,20 +681,16 @@ genrtl_switch_stmt (t)\n /* Create a CASE_LABEL tree node and return it.  */\n \n tree\n-build_case_label (low_value, high_value, label_decl)\n-     tree low_value;\n-     tree high_value;\n-     tree label_decl;\n+build_case_label (tree low_value, tree high_value, tree label_decl)\n {\n   return build_stmt (CASE_LABEL, low_value, high_value, label_decl);\n }\n \n \n /* Generate the RTL for a CASE_LABEL.  */\n \n-void \n-genrtl_case_label (case_label)\n-     tree case_label;\n+void\n+genrtl_case_label (tree case_label)\n {\n   tree duplicate;\n   tree cleanup;\n@@ -735,15 +708,14 @@ genrtl_case_label (case_label)\n \t}\n     }\n \n-  add_case_node (CASE_LOW (case_label), CASE_HIGH (case_label), \n+  add_case_node (CASE_LOW (case_label), CASE_HIGH (case_label),\n \t\t CASE_LABEL_DECL (case_label), &duplicate);\n }\n \n /* Generate the RTL for T, which is a COMPOUND_STMT.  */\n \n void\n-genrtl_compound_stmt (t)\n-    tree t;\n+genrtl_compound_stmt (tree t)\n {\n #ifdef ENABLE_CHECKING\n   struct nesting *n = current_nesting_level ();\n@@ -761,14 +733,8 @@ genrtl_compound_stmt (t)\n /* Generate the RTL for an ASM_STMT.  */\n \n void\n-genrtl_asm_stmt (cv_qualifier, string, output_operands,\n-\t\t input_operands, clobbers, asm_input_p)\n-     tree cv_qualifier;\n-     tree string;\n-     tree output_operands;\n-     tree input_operands;\n-     tree clobbers;\n-     int asm_input_p;\n+genrtl_asm_stmt (tree cv_qualifier, tree string, tree output_operands,\n+\t\t tree input_operands, tree clobbers, int asm_input_p)\n {\n   if (cv_qualifier != NULL_TREE\n       && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n@@ -782,16 +748,15 @@ genrtl_asm_stmt (cv_qualifier, string, output_operands,\n   if (asm_input_p)\n     expand_asm (string, cv_qualifier != NULL_TREE);\n   else\n-    c_expand_asm_operands (string, output_operands, input_operands, \n+    c_expand_asm_operands (string, output_operands, input_operands,\n \t\t\t   clobbers, cv_qualifier != NULL_TREE,\n \t\t\t   input_filename, input_line);\n }\n \n /* Generate the RTL for a CLEANUP_STMT.  */\n \n-void \n-genrtl_cleanup_stmt (t)\n-     tree t;\n+void\n+genrtl_cleanup_stmt (tree t)\n {\n   tree decl = CLEANUP_DECL (t);\n   if (!decl || (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node))\n@@ -802,8 +767,7 @@ genrtl_cleanup_stmt (t)\n    for the substitution.  */\n \n void\n-prep_stmt (t)\n-     tree t;\n+prep_stmt (tree t)\n {\n   if (!STMT_LINENO_FOR_FN_P (t))\n     input_line = STMT_LINENO (t);\n@@ -814,8 +778,7 @@ prep_stmt (t)\n    other statements at its nesting level.  */\n \n void\n-expand_stmt (t)\n-     tree t;\n+expand_stmt (tree t)\n {\n   while (t && t != error_mark_node)\n     {\n@@ -920,7 +883,7 @@ expand_stmt (t)\n \tdefault:\n \t  if (lang_expand_stmt)\n \t    (*lang_expand_stmt) (t);\n-\t  else \n+\t  else\n \t    abort ();\n \t  break;\n \t}\n@@ -938,10 +901,8 @@ expand_stmt (t)\n /* If *TP is a potentially reachable label, return nonzero.  */\n \n static tree\n-find_reachable_label_1 (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+find_reachable_label_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n   switch (TREE_CODE (*tp))\n     {\n@@ -958,8 +919,7 @@ find_reachable_label_1 (tp, walk_subtrees, data)\n /* Determine whether expression EXP contains a potentially\n    reachable label.  */\n static tree\n-find_reachable_label (exp)\n-     tree exp;\n+find_reachable_label (tree exp)\n {\n   location_t saved_loc = input_location;\n   tree ret = walk_tree (&exp, find_reachable_label_1, NULL, NULL);\n@@ -970,11 +930,10 @@ find_reachable_label (exp)\n /* Expand an unreachable if statement, T.  This function returns\n    true if the IF_STMT contains a potentially reachable code_label.  */\n static bool\n-expand_unreachable_if_stmt (t)\n-     tree t;\n+expand_unreachable_if_stmt (tree t)\n {\n   tree n;\n-  \n+\n   if (find_reachable_label (IF_COND (t)) != NULL_TREE)\n     {\n       genrtl_if_stmt (t);\n@@ -984,7 +943,7 @@ expand_unreachable_if_stmt (t)\n   if (THEN_CLAUSE (t) && ELSE_CLAUSE (t))\n     {\n       n = expand_unreachable_stmt (THEN_CLAUSE (t), 0);\n-      \n+\n       if (n != NULL_TREE)\n \t{\n \t  rtx label;\n@@ -1004,9 +963,9 @@ expand_unreachable_if_stmt (t)\n     n = expand_unreachable_stmt (ELSE_CLAUSE (t), 0);\n   else\n     n = NULL_TREE;\n-  \n+\n   expand_stmt (n);\n-  \n+\n   return n != NULL_TREE;\n }\n \n@@ -1015,9 +974,7 @@ expand_unreachable_if_stmt (t)\n    then returns the label (or, in same cases, the statement after\n    one containing the label).  */\n static tree\n-expand_unreachable_stmt (t, warn)\n-     tree t;\n-     int warn;\n+expand_unreachable_stmt (tree t, int warn)\n {\n   int saved;\n \n@@ -1102,4 +1059,3 @@ expand_unreachable_stmt (t, warn)\n     }\n   return NULL_TREE;\n }\n-"}, {"sha": "36f1ee9176df2140cfc7532baeb031a1167fea3c", "filename": "gcc/c-tree.h", "status": "modified", "additions": 110, "deletions": 116, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -153,90 +153,88 @@ struct lang_type GTY(())\n \n \f\n /* in c-lang.c and objc-act.c */\n-extern tree lookup_interface\t\t\tPARAMS ((tree));\n-extern tree is_class_name\t\t\tPARAMS ((tree));\n-extern tree objc_is_id\t\t\t\tPARAMS ((tree));\n-extern void objc_check_decl\t\t\tPARAMS ((tree));\n-extern void finish_file\t\t\t\tPARAMS ((void));\n-extern int objc_comptypes                 \tPARAMS ((tree, tree, int));\n-extern tree objc_message_selector\t\tPARAMS ((void));\n-extern tree lookup_objc_ivar\t\t\tPARAMS ((tree));\n-extern void c_expand_body\t\t\tPARAMS ((tree));\n+extern tree lookup_interface (tree);\n+extern tree is_class_name (tree);\n+extern tree objc_is_id (tree);\n+extern void objc_check_decl (tree);\n+extern void finish_file (void);\n+extern int objc_comptypes (tree, tree, int);\n+extern tree objc_message_selector (void);\n+extern tree lookup_objc_ivar (tree);\n+extern void c_expand_body (tree);\n \n \f\n /* in c-parse.in */\n-extern void c_parse_init\t\t\tPARAMS ((void));\n+extern void c_parse_init (void);\n \n /* in c-aux-info.c */\n-extern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n+extern void gen_aux_info_record (tree, int, int, int);\n \n /* in c-decl.c */\n-extern int global_bindings_p\t\t\tPARAMS ((void));\n-extern int kept_level_p\t\t\t\tPARAMS ((void));\n-extern tree getdecls\t\t\t\tPARAMS ((void));\n-extern void pushlevel\t\t\t\tPARAMS ((int));\n-extern void insert_block\t\t\tPARAMS ((tree));\n-extern void set_block\t\t\t\tPARAMS ((tree));\n-extern tree pushdecl\t\t\t\tPARAMS ((tree));\n-\n-extern void c_insert_default_attributes\t\tPARAMS ((tree));\n-extern void c_init_decl_processing\t\tPARAMS ((void));\n-extern void c_dup_lang_specific_decl\t\tPARAMS ((tree));\n-extern void c_print_identifier\t\t\tPARAMS ((FILE *, tree, int));\n-extern tree build_array_declarator              PARAMS ((tree, tree, int, int));\n-extern tree build_enumerator                    PARAMS ((tree, tree));\n-extern void check_for_loop_decls                PARAMS ((void));\n-extern void clear_parm_order                    PARAMS ((void));\n-extern int  complete_array_type                 PARAMS ((tree, tree, int));\n-extern void declare_parm_level                  PARAMS ((int));\n-extern tree define_label                        PARAMS ((const char *, int,\n-\t\t\t\t\t\t\t tree));\n-extern void finish_decl                         PARAMS ((tree, tree, tree));\n-extern tree finish_enum                         PARAMS ((tree, tree, tree));\n-extern void finish_function                     PARAMS ((int, int));\n-extern tree finish_struct                       PARAMS ((tree, tree, tree));\n-extern tree get_parm_info                       PARAMS ((int));\n-extern tree grokfield                           PARAMS ((const char *, int, tree, tree, tree));\n-extern tree groktypename                        PARAMS ((tree));\n-extern tree groktypename_in_parm_context        PARAMS ((tree));\n-extern tree implicitly_declare                  PARAMS ((tree));\n-extern int  in_parm_level_p                     PARAMS ((void));\n-extern void keep_next_level                     PARAMS ((void));\n-extern tree lookup_name                         PARAMS ((tree));\n-extern void parmlist_tags_warning               PARAMS ((void));\n-extern void pending_xref_error                  PARAMS ((void));\n-extern void c_push_function_context             PARAMS ((struct function *));\n-extern void c_pop_function_context              PARAMS ((struct function *));\n-extern void pop_label_level                     PARAMS ((void));\n-extern void push_label_level                    PARAMS ((void));\n-extern void push_parm_decl                      PARAMS ((tree));\n-extern tree pushdecl_top_level                  PARAMS ((tree));\n-extern tree pushdecl_function_level\t\tPARAMS ((tree, tree));\n-extern void pushtag                             PARAMS ((tree, tree));\n-extern tree set_array_declarator_type           PARAMS ((tree, tree, int));\n-extern tree shadow_label                        PARAMS ((tree));\n-extern void shadow_tag                          PARAMS ((tree));\n-extern void shadow_tag_warned                   PARAMS ((tree, int));\n-extern tree start_enum                          PARAMS ((tree));\n-extern int  start_function                      PARAMS ((tree, tree, tree));\n-extern tree start_decl                          PARAMS ((tree, tree, int,\n-\t\t\t\t\t\t\t tree));\n-extern tree start_struct                        PARAMS ((enum tree_code, tree));\n-extern void store_parm_decls                    PARAMS ((void));\n-extern tree xref_tag                            PARAMS ((enum tree_code, tree));\n-extern tree c_begin_compound_stmt               PARAMS ((void));\n-extern void c_expand_deferred_function          PARAMS ((tree));\n-extern void c_expand_decl_stmt                  PARAMS ((tree));\n-extern tree make_pointer_declarator\t\tPARAMS ((tree, tree));\n+extern int global_bindings_p (void);\n+extern int kept_level_p (void);\n+extern tree getdecls (void);\n+extern void pushlevel (int);\n+extern void insert_block (tree);\n+extern void set_block (tree);\n+extern tree pushdecl (tree);\n+\n+extern void c_insert_default_attributes (tree);\n+extern void c_init_decl_processing (void);\n+extern void c_dup_lang_specific_decl (tree);\n+extern void c_print_identifier (FILE *, tree, int);\n+extern tree build_array_declarator (tree, tree, int, int);\n+extern tree build_enumerator (tree, tree);\n+extern void check_for_loop_decls (void);\n+extern void clear_parm_order (void);\n+extern int  complete_array_type (tree, tree, int);\n+extern void declare_parm_level (int);\n+extern tree define_label (const char *, int, tree);\n+extern void finish_decl (tree, tree, tree);\n+extern tree finish_enum (tree, tree, tree);\n+extern void finish_function (int, int);\n+extern tree finish_struct (tree, tree, tree);\n+extern tree get_parm_info (int);\n+extern tree grokfield (const char *, int, tree, tree, tree);\n+extern tree groktypename (tree);\n+extern tree groktypename_in_parm_context (tree);\n+extern tree implicitly_declare (tree);\n+extern int  in_parm_level_p (void);\n+extern void keep_next_level (void);\n+extern tree lookup_name (tree);\n+extern void parmlist_tags_warning (void);\n+extern void pending_xref_error (void);\n+extern void c_push_function_context (struct function *);\n+extern void c_pop_function_context (struct function *);\n+extern void pop_label_level (void);\n+extern void push_label_level (void);\n+extern void push_parm_decl (tree);\n+extern tree pushdecl_top_level (tree);\n+extern tree pushdecl_function_level (tree, tree);\n+extern void pushtag (tree, tree);\n+extern tree set_array_declarator_type (tree, tree, int);\n+extern tree shadow_label (tree);\n+extern void shadow_tag (tree);\n+extern void shadow_tag_warned (tree, int);\n+extern tree start_enum (tree);\n+extern int  start_function (tree, tree, tree);\n+extern tree start_decl (tree, tree, int, tree);\n+extern tree start_struct (enum tree_code, tree);\n+extern void store_parm_decls (void);\n+extern tree xref_tag (enum tree_code, tree);\n+extern tree c_begin_compound_stmt (void);\n+extern void c_expand_deferred_function (tree);\n+extern void c_expand_decl_stmt (tree);\n+extern tree make_pointer_declarator (tree, tree);\n \n /* in c-objc-common.c */\n-extern int c_disregard_inline_limits\t\tPARAMS ((tree));\n-extern int c_cannot_inline_tree_fn\t\tPARAMS ((tree *));\n-extern bool c_objc_common_init\t\t\tPARAMS ((void));\n-extern int c_missing_noreturn_ok_p\t\tPARAMS ((tree));\n-extern void c_objc_common_finish_file\t\tPARAMS ((void));\n-extern int defer_fn\t\t\t\tPARAMS ((tree));\n-extern bool c_warn_unused_global_decl\t\tPARAMS ((tree));\n+extern int c_disregard_inline_limits (tree);\n+extern int c_cannot_inline_tree_fn (tree *);\n+extern bool c_objc_common_init (void);\n+extern int c_missing_noreturn_ok_p (tree);\n+extern void c_objc_common_finish_file (void);\n+extern int defer_fn (tree);\n+extern bool c_warn_unused_global_decl (tree);\n \n #define c_build_type_variant(TYPE, CONST_P, VOLATILE_P)\t\t  \\\n   c_build_qualified_type ((TYPE),\t\t\t\t  \\\n@@ -245,46 +243,42 @@ extern bool c_warn_unused_global_decl\t\tPARAMS ((tree));\n \n #define c_sizeof_nowarn(T)  c_sizeof_or_alignof_type (T, SIZEOF_EXPR, 0)\n /* in c-typeck.c */\n-extern tree require_complete_type\t\tPARAMS ((tree));\n-extern int comptypes\t\t\t\tPARAMS ((tree, tree));\n-extern tree c_size_in_bytes                     PARAMS ((tree));\n-extern bool c_mark_addressable\t\t\tPARAMS ((tree));\n-extern void c_incomplete_type_error\t\tPARAMS ((tree, tree));\n-extern tree c_type_promotes_to\t\t\tPARAMS ((tree));\n-extern tree build_component_ref                 PARAMS ((tree, tree));\n-extern tree build_indirect_ref                  PARAMS ((tree, const char *));\n-extern tree build_array_ref                     PARAMS ((tree, tree));\n-extern tree build_external_ref\t\t\tPARAMS ((tree, int));\n-extern tree parser_build_binary_op              PARAMS ((enum tree_code,\n-\t\t\t\t\t\t\t tree, tree));\n-extern int c_tree_expr_nonnegative_p          \tPARAMS ((tree));\n-extern void readonly_warning\t\t\tPARAMS ((tree, const char *));\n-extern tree build_conditional_expr              PARAMS ((tree, tree, tree));\n-extern tree build_compound_expr                 PARAMS ((tree));\n-extern tree c_cast_expr\t\t\t\tPARAMS ((tree, tree));\n-extern tree build_c_cast\t                PARAMS ((tree, tree));\n-extern tree build_modify_expr                   PARAMS ((tree, enum tree_code,\n-\t\t\t\t\t\t\t tree));\n-extern void store_init_value                    PARAMS ((tree, tree));\n-extern void error_init\t\t\t\tPARAMS ((const char *));\n-extern void pedwarn_init\t\t\tPARAMS ((const char *));\n-extern void start_init\t\t\t\tPARAMS ((tree, tree, int));\n-extern void finish_init\t\t\t\tPARAMS ((void));\n-extern void really_start_incremental_init\tPARAMS ((tree));\n-extern void push_init_level\t\t\tPARAMS ((int));\n-extern tree pop_init_level\t\t\tPARAMS ((int));\n-extern void set_init_index\t\t\tPARAMS ((tree, tree));\n-extern void set_init_label\t\t\tPARAMS ((tree));\n-extern void process_init_element\t\tPARAMS ((tree));\n-extern tree build_compound_literal\t\tPARAMS ((tree, tree));\n-extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n-extern tree c_start_case                        PARAMS ((tree));\n-extern void c_finish_case                       PARAMS ((void));\n-extern tree simple_asm_stmt\t\t\tPARAMS ((tree));\n-extern tree build_asm_stmt\t\t\tPARAMS ((tree, tree, tree,\n-\t\t\t\t\t\t\t tree, tree));\n-extern tree c_convert_parm_for_inlining\t\tPARAMS ((tree, tree, tree));\n+extern tree require_complete_type (tree);\n+extern int comptypes (tree, tree);\n+extern tree c_size_in_bytes (tree);\n+extern bool c_mark_addressable (tree);\n+extern void c_incomplete_type_error (tree, tree);\n+extern tree c_type_promotes_to (tree);\n+extern tree build_component_ref (tree, tree);\n+extern tree build_indirect_ref (tree, const char *);\n+extern tree build_array_ref (tree, tree);\n+extern tree build_external_ref (tree, int);\n+extern tree parser_build_binary_op (enum tree_code, tree, tree);\n+extern int c_tree_expr_nonnegative_p (tree);\n+extern void readonly_warning (tree, const char *);\n+extern tree build_conditional_expr (tree, tree, tree);\n+extern tree build_compound_expr (tree);\n+extern tree c_cast_expr (tree, tree);\n+extern tree build_c_cast (tree, tree);\n+extern tree build_modify_expr (tree, enum tree_code, tree);\n+extern void store_init_value (tree, tree);\n+extern void error_init (const char *);\n+extern void pedwarn_init (const char *);\n+extern void start_init (tree, tree, int);\n+extern void finish_init (void);\n+extern void really_start_incremental_init (tree);\n+extern void push_init_level (int);\n+extern tree pop_init_level (int);\n+extern void set_init_index (tree, tree);\n+extern void set_init_label (tree);\n+extern void process_init_element (tree);\n+extern tree build_compound_literal (tree, tree);\n+extern void pedwarn_c99 (const char *, ...) ATTRIBUTE_PRINTF_1;\n+extern tree c_start_case (tree);\n+extern void c_finish_case (void);\n+extern tree simple_asm_stmt (tree);\n+extern tree build_asm_stmt (tree, tree, tree, tree, tree);\n+extern tree c_convert_parm_for_inlining (tree, tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */\n@@ -306,7 +300,7 @@ extern int current_function_returns_abnormally;\n extern int system_header_p;\n \n /* In c-decl.c */\n-extern void c_finish_incomplete_decl PARAMS ((tree));\n+extern void c_finish_incomplete_decl (tree);\n \n extern GTY(()) tree static_ctors;\n extern GTY(()) tree static_dtors;"}, {"sha": "4bb171f660961db57036cf79beaf9b3f012e175f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 137, "deletions": 243, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f6e4e977d93c63da8811bd7d3c3e9be0d71e414/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2f6e4e977d93c63da8811bd7d3c3e9be0d71e414", "patch": "@@ -90,8 +90,7 @@ static tree find_init_member\t\tPARAMS ((tree));\n    does not have an incomplete type.  (That includes void types.)  */\n \n tree\n-require_complete_type (value)\n-     tree value;\n+require_complete_type (tree value)\n {\n   tree type = TREE_TYPE (value);\n \n@@ -111,9 +110,7 @@ require_complete_type (value)\n    and TYPE is the type that was invalid.  */\n \n void\n-c_incomplete_type_error (value, type)\n-     tree value;\n-     tree type;\n+c_incomplete_type_error (tree value, tree type)\n {\n   const char *type_code_string;\n \n@@ -180,8 +177,7 @@ c_incomplete_type_error (value, type)\n    arguments and return the new type.  */\n \n tree\n-c_type_promotes_to (type)\n-     tree type;\n+c_type_promotes_to (tree type)\n {\n   if (TYPE_MAIN_VARIANT (type) == float_type_node)\n     return double_type_node;\n@@ -202,10 +198,9 @@ c_type_promotes_to (type)\n    as well as those of TYPE.  */\n \n static tree\n-qualify_type (type, like)\n-     tree type, like;\n+qualify_type (tree type, tree like)\n {\n-  return c_build_qualified_type (type, \n+  return c_build_qualified_type (type,\n \t\t\t\t TYPE_QUALS (type) | TYPE_QUALS (like));\n }\n \f\n@@ -218,8 +213,7 @@ qualify_type (type, like)\n    if the operands have the given two types.  */\n \n tree\n-common_type (t1, t2)\n-     tree t1, t2;\n+common_type (tree t1, tree t2)\n {\n   enum tree_code code1;\n   enum tree_code code2;\n@@ -328,9 +322,9 @@ common_type (t1, t2)\n \ttree pointed_to_2 = TREE_TYPE (t2);\n \ttree target = common_type (TYPE_MAIN_VARIANT (pointed_to_1),\n \t\t\t\t   TYPE_MAIN_VARIANT (pointed_to_2));\n-\tt1 = build_pointer_type (c_build_qualified_type \n-\t\t\t\t (target, \n-\t\t\t\t  TYPE_QUALS (pointed_to_1) | \n+\tt1 = build_pointer_type (c_build_qualified_type\n+\t\t\t\t (target,\n+\t\t\t\t  TYPE_QUALS (pointed_to_1) |\n \t\t\t\t  TYPE_QUALS (pointed_to_2)));\n \treturn build_type_attribute_variant (t1, attributes);\n       }\n@@ -406,7 +400,7 @@ common_type (t1, t2)\n \t\tTREE_VALUE (n) = TREE_VALUE (p1);\n \t\tgoto parm_done;\n \t      }\n-\t      \n+\n \t    /* Given  wait (union {union wait *u; int *i} *)\n \t       and  wait (union wait *),\n \t       prefer  union wait *  as type of parm.  */\n@@ -459,8 +453,7 @@ common_type (t1, t2)\n    but a warning may be needed if you use them together.  */\n \n int\n-comptypes (type1, type2)\n-     tree type1, type2;\n+comptypes (tree type1, tree type2)\n {\n   tree t1 = type1;\n   tree t2 = type2;\n@@ -482,7 +475,7 @@ comptypes (type1, type2)\n       && TYPE_DOMAIN (t2) != 0)\n     t2 = TYPE_DOMAIN (t2);\n \n-  /* Treat an enum type as the integer type of the same width and \n+  /* Treat an enum type as the integer type of the same width and\n      signedness.  */\n \n   if (TREE_CODE (t1) == ENUMERAL_TYPE)\n@@ -591,9 +584,7 @@ comptypes (type1, type2)\n */\n \n static int\n-comp_target_types (ttl, ttr, reflexive)\n-     tree ttl, ttr;\n-     int reflexive;\n+comp_target_types (tree ttl, tree ttr, int reflexive)\n {\n   int val;\n \n@@ -614,13 +605,12 @@ comp_target_types (ttl, ttr, reflexive)\n /* Return 1 if two function types F1 and F2 are compatible.\n    If either type specifies no argument types,\n    the other must specify a fixed number of self-promoting arg types.\n-   Otherwise, if one type specifies only the number of arguments, \n+   Otherwise, if one type specifies only the number of arguments,\n    the other must specify that number of self-promoting arg types.\n    Otherwise, the argument types must match.  */\n \n static int\n-function_types_compatible_p (f1, f2)\n-     tree f1, f2;\n+function_types_compatible_p (tree f1, tree f2)\n {\n   tree args1, args2;\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -683,8 +673,7 @@ function_types_compatible_p (f1, f2)\n    or 2 for compatible with warning.  */\n \n static int\n-type_lists_compatible_p (args1, args2)\n-     tree args1, args2;\n+type_lists_compatible_p (tree args1, tree args2)\n {\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n   int val = 1;\n@@ -712,7 +701,7 @@ type_lists_compatible_p (args1, args2)\n \t  if (c_type_promotes_to (TREE_VALUE (args1)) != TREE_VALUE (args1))\n \t    return 0;\n \t}\n-      else if (! (newval = comptypes (TYPE_MAIN_VARIANT (TREE_VALUE (args1)), \n+      else if (! (newval = comptypes (TYPE_MAIN_VARIANT (TREE_VALUE (args1)),\n \t\t\t\t      TYPE_MAIN_VARIANT (TREE_VALUE (args2)))))\n \t{\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n@@ -763,8 +752,7 @@ type_lists_compatible_p (args1, args2)\n /* Compute the size to increment a pointer by.  */\n \n tree\n-c_size_in_bytes (type)\n-     tree type;\n+c_size_in_bytes (tree type)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -786,8 +774,7 @@ c_size_in_bytes (type)\n /* Return either DECL or its known constant value (if it has one).  */\n \n tree\n-decl_constant_value (decl)\n-     tree decl;\n+decl_constant_value (tree decl)\n {\n   if (/* Don't change a variable array bound or initial value to a constant\n \t in a place where a variable is invalid.  */\n@@ -815,8 +802,7 @@ decl_constant_value (decl)\n    right test for avoiding misoptimizations either.  */\n \n static tree\n-decl_constant_value_for_broken_optimization (decl)\n-     tree decl;\n+decl_constant_value_for_broken_optimization (tree decl)\n {\n   if (pedantic || DECL_MODE (decl) == BLKmode)\n     return decl;\n@@ -830,16 +816,15 @@ decl_constant_value_for_broken_optimization (decl)\n    return EXP.  */\n \n static tree\n-default_function_array_conversion (exp)\n-     tree exp;\n+default_function_array_conversion (tree exp)\n {\n   tree orig_exp;\n   tree type = TREE_TYPE (exp);\n   enum tree_code code = TREE_CODE (type);\n   int not_lvalue = 0;\n \n   /* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as\n-     an lvalue. \n+     an lvalue.\n \n      Do not use STRIP_NOPS here!  It will remove conversions from pointer\n      to integer and cause infinite recursion.  */\n@@ -877,9 +862,9 @@ default_function_array_conversion (exp)\n \t}\n \n       if (TYPE_QUALS (type) || constp || volatilep)\n-\trestype \n+\trestype\n \t  = c_build_qualified_type (restype,\n-\t\t\t\t    TYPE_QUALS (type) \n+\t\t\t\t    TYPE_QUALS (type)\n \t\t\t\t    | (constp * TYPE_QUAL_CONST)\n \t\t\t\t    | (volatilep * TYPE_QUAL_VOLATILE));\n \n@@ -933,8 +918,7 @@ default_function_array_conversion (exp)\n    In addition, manifest constants symbols are replaced by their values.  */\n \n tree\n-default_conversion (exp)\n-     tree exp;\n+default_conversion (tree exp)\n {\n   tree orig_exp;\n   tree type = TREE_TYPE (exp);\n@@ -957,7 +941,7 @@ default_conversion (exp)\n     }\n \n   /* Strip NON_LVALUE_EXPRs and no-op conversions, since we aren't using as\n-     an lvalue. \n+     an lvalue.\n \n      Do not use STRIP_NOPS here!  It will remove conversions from pointer\n      to integer and cause infinite recursion.  */\n@@ -1018,10 +1002,9 @@ default_conversion (exp)\n    TREE_VALUE of the list.  Normally the list is of length one, but if\n    the component is embedded within (nested) anonymous structures or\n    unions, the list steps down the chain to the component.  */\n-     \n+\n static tree\n-lookup_field (decl, component)\n-     tree decl, component;\n+lookup_field (tree decl, tree component)\n {\n   tree type = TREE_TYPE (decl);\n   tree field;\n@@ -1057,7 +1040,7 @@ lookup_field (decl, component)\n \n \t\t      if (anon)\n \t\t\treturn tree_cons (NULL_TREE, field, anon);\n-\t\t    } \n+\t\t    }\n \t\t}\n \n \t      /* Entire record is only anon unions.  */\n@@ -1110,8 +1093,7 @@ lookup_field (decl, component)\n    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */\n \n tree\n-build_component_ref (datum, component)\n-     tree datum, component;\n+build_component_ref (tree datum, tree component)\n {\n   tree type = TREE_TYPE (datum);\n   enum tree_code code = TREE_CODE (type);\n@@ -1199,9 +1181,7 @@ build_component_ref (datum, component)\n    ERRORSTRING is the name of the operator to appear in error messages.  */\n \n tree\n-build_indirect_ref (ptr, errorstring)\n-     tree ptr;\n-     const char *errorstring;\n+build_indirect_ref (tree ptr, const char *errorstring)\n {\n   tree pointer = default_conversion (ptr);\n   tree type = TREE_TYPE (pointer);\n@@ -1254,8 +1234,7 @@ build_indirect_ref (ptr, errorstring)\n    by functions).  */\n \n tree\n-build_array_ref (array, index)\n-     tree array, index;\n+build_array_ref (tree array, tree index)\n {\n   if (index == 0)\n     {\n@@ -1339,7 +1318,7 @@ build_array_ref (array, index)\n       TREE_THIS_VOLATILE (rval)\n \t|= (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (array)))\n \t    /* This was added by rms on 16 Nov 91.\n-\t       It fixes  vol struct foo *a;  a->elts[1] \n+\t       It fixes  vol struct foo *a;  a->elts[1]\n \t       in an inline function.\n \t       Hope it doesn't break something else.  */\n \t    | TREE_THIS_VOLATILE (array));\n@@ -1390,8 +1369,7 @@ build_array_ref (array, index)\n    including a reference to a builtin outside of function-call context.\n    Arrange to suppress further errors for the same identifier.  */\n static void\n-undeclared_variable (id)\n-     tree id;\n+undeclared_variable (tree id)\n {\n   if (current_function_decl == 0)\n     {\n@@ -1421,9 +1399,7 @@ undeclared_variable (id)\n /* Build an external reference to identifier ID.  FUN indicates\n    whether this will be used for a function call.  */\n tree\n-build_external_ref (id, fun)\n-     tree id;\n-     int fun;\n+build_external_ref (tree id, int fun)\n {\n   tree ref;\n   tree decl = lookup_name (id);\n@@ -1480,7 +1456,7 @@ build_external_ref (id, fun)\n \t       || TREE_CODE (ref) == FUNCTION_DECL))\n     {\n       tree context = decl_function_context (ref);\n-    \n+\n       if (context != 0 && context != current_function_decl)\n \tDECL_NONLOCAL (ref) = 1;\n     }\n@@ -1494,8 +1470,7 @@ build_external_ref (id, fun)\n    FUNCTION's data type may be a function type or a pointer-to-function.  */\n \n tree\n-build_function_call (function, params)\n-     tree function, params;\n+build_function_call (tree function, tree params)\n {\n   tree fntype, fundecl = 0;\n   tree coerced_params;\n@@ -1592,8 +1567,7 @@ build_function_call (function, params)\n    with the elements of the list in the TREE_VALUE slots of those nodes.  */\n \n static tree\n-convert_arguments (typelist, values, name, fundecl)\n-     tree typelist, values, name, fundecl;\n+convert_arguments (tree typelist, tree values, tree name, tree fundecl)\n {\n   tree typetail, valtail;\n   tree result = NULL;\n@@ -1724,10 +1698,10 @@ convert_arguments (typelist, values, name, fundecl)\n \t\t    }\n \t\t}\n \n-\t      parmval = convert_for_assignment (type, val, \n+\t      parmval = convert_for_assignment (type, val,\n \t\t\t\t\t        (char *) 0, /* arg passing  */\n \t\t\t\t\t\tfundecl, name, parmnum + 1);\n-\t      \n+\n \t      if (PROMOTE_PROTOTYPES\n \t\t  && INTEGRAL_TYPE_P (type)\n \t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n@@ -1767,9 +1741,7 @@ convert_arguments (typelist, values, name, fundecl)\n    in a way that is likely to confuse the user.  */\n \n tree\n-parser_build_binary_op (code, arg1, arg2)\n-     enum tree_code code;\n-     tree arg1, arg2;\n+parser_build_binary_op (enum tree_code code, tree arg1, tree arg2)\n {\n   tree result = build_binary_op (code, arg1, arg2, 1);\n \n@@ -1887,10 +1859,7 @@ parser_build_binary_op (code, arg1, arg2)\n    the arithmetic is to be done.  */\n \n tree\n-build_binary_op (code, orig_op0, orig_op1, convert_p)\n-     enum tree_code code;\n-     tree orig_op0, orig_op1;\n-     int convert_p;\n+build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1, int convert_p)\n {\n   tree type0, type1;\n   enum tree_code code0, code1;\n@@ -2223,7 +2192,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  if (comp_target_types (type0, type1, 1))\n \t    {\n \t      result_type = common_type (type0, type1);\n-\t      if (pedantic \n+\t      if (pedantic\n \t\t  && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t\tpedwarn (\"ISO C forbids ordered comparisons of pointers to functions\");\n \t    }\n@@ -2251,7 +2220,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n \t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n \t\tpedwarn (\"comparison of complete and incomplete pointers\");\n-\t      else if (pedantic \n+\t      else if (pedantic\n \t\t       && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t\tpedwarn (\"ISO C forbids ordered comparisons of pointers to functions\");\n \t    }\n@@ -2436,7 +2405,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t     pass the copies by reference, then copy them back afterward.  */\n \t  tree xop0 = op0, xop1 = op1, xresult_type = result_type;\n \t  enum tree_code xresultcode = resultcode;\n-\t  tree val \n+\t  tree val\n \t    = shorten_compare (&xop0, &xop1, &xresult_type, &xresultcode);\n \n \t  if (val != 0)\n@@ -2460,7 +2429,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t      STRIP_TYPE_NOPS (xop1);\n \n \t      /* Give warnings for comparisons between signed and unsigned\n-\t\t quantities that may fail. \n+\t\t quantities that may fail.\n \n \t\t Do the checking based on the original operand trees, so that\n \t\t casts will be considered, but default promotions won't be.\n@@ -2527,7 +2496,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t\t  else\n \t\t    primop1 = get_narrower (TREE_OPERAND (primop1, 0),\n \t\t\t\t\t    &unsignedp1);\n-\t      \n+\n \t\t  if (host_integerp (primop0, 0) || host_integerp (primop1, 0))\n \t\t    {\n \t\t      tree primop;\n@@ -2582,9 +2551,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n   if (! converted)\n     {\n       if (TREE_TYPE (op0) != result_type)\n-\top0 = convert (result_type, op0); \n+\top0 = convert (result_type, op0);\n       if (TREE_TYPE (op1) != result_type)\n-\top1 = convert (result_type, op1); \n+\top1 = convert (result_type, op1);\n     }\n \n   if (build_type == NULL_TREE)\n@@ -2607,16 +2576,15 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n /* Return true if `t' is known to be non-negative.  */\n \n int\n-c_tree_expr_nonnegative_p (t)\n-     tree t;\n+c_tree_expr_nonnegative_p (tree t)\n {\n   if (TREE_CODE (t) == STMT_EXPR)\n     {\n       t = COMPOUND_BODY (STMT_EXPR_STMT (t));\n \n       /* Find the last statement in the chain, ignoring the final\n \t     * scope statement */\n-      while (TREE_CHAIN (t) != NULL_TREE \n+      while (TREE_CHAIN (t) != NULL_TREE\n              && TREE_CODE (TREE_CHAIN (t)) != SCOPE_STMT)\n         t = TREE_CHAIN (t);\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n@@ -2628,8 +2596,7 @@ c_tree_expr_nonnegative_p (t)\n    The resulting tree has type int.  */\n \n static tree\n-pointer_diff (op0, op1)\n-     tree op0, op1;\n+pointer_diff (tree op0, tree op1)\n {\n   tree result, folded;\n   tree restype = ptrdiff_type_node;\n@@ -2714,10 +2681,7 @@ pointer_diff (op0, op1)\n    arrays to pointers in C99.  */\n \n tree\n-build_unary_op (code, xarg, flag)\n-     enum tree_code code;\n-     tree xarg;\n-     int flag;\n+build_unary_op (enum tree_code code, tree xarg, int flag)\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n@@ -2835,7 +2799,7 @@ build_unary_op (code, xarg, flag)\n \treturn fold (build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n       else\n \treturn convert (TREE_TYPE (arg), integer_zero_node);\n-      \n+\n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n@@ -2973,7 +2937,7 @@ build_unary_op (code, xarg, flag)\n \n \t/* Report a read-only lvalue.  */\n \tif (TREE_READONLY (arg))\n-\t  readonly_warning (arg, \n+\t  readonly_warning (arg,\n \t\t\t    ((code == PREINCREMENT_EXPR\n \t\t\t      || code == POSTINCREMENT_EXPR)\n \t\t\t     ? \"increment\" : \"decrement\"));\n@@ -3086,8 +3050,7 @@ build_unary_op (code, xarg, flag)\n    Lvalues can have their address taken, unless they have DECL_REGISTER.  */\n \n int\n-lvalue_p (ref)\n-     tree ref;\n+lvalue_p (tree ref)\n {\n   enum tree_code code = TREE_CODE (ref);\n \n@@ -3124,9 +3087,7 @@ lvalue_p (ref)\n    otherwise, print an error message and return zero.  */\n \n int\n-lvalue_or_else (ref, msgid)\n-     tree ref;\n-     const char *msgid;\n+lvalue_or_else (tree ref, const char *msgid)\n {\n   int win = lvalue_p (ref);\n \n@@ -3143,12 +3104,9 @@ lvalue_or_else (ref, msgid)\n    a pointer in C99.\n \n    If ARG is not a kind of expression we can handle, return zero.  */\n-   \n+\n static tree\n-unary_complex_lvalue (code, arg, flag)\n-     enum tree_code code;\n-     tree arg;\n-     int flag;\n+unary_complex_lvalue (enum tree_code code, tree arg, int flag)\n {\n   /* Handle (a, b) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n@@ -3185,8 +3143,7 @@ unary_complex_lvalue (code, arg, flag)\n    COMPOUND_EXPR, or CONVERT_EXPR (for casts).  */\n \n static void\n-pedantic_lvalue_warning (code)\n-     enum tree_code code;\n+pedantic_lvalue_warning (enum tree_code code)\n {\n   if (pedantic)\n     switch (code)\n@@ -3206,9 +3163,7 @@ pedantic_lvalue_warning (code)\n /* Warn about storing in something that is `const'.  */\n \n void\n-readonly_warning (arg, msgid)\n-     tree arg;\n-     const char *msgid;\n+readonly_warning (tree arg, const char *msgid)\n {\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n@@ -3230,8 +3185,7 @@ readonly_warning (arg, msgid)\n    Returns true if successful.  */\n \n bool\n-c_mark_addressable (exp)\n-     tree exp;\n+c_mark_addressable (tree exp)\n {\n   tree x = exp;\n \n@@ -3312,8 +3266,7 @@ c_mark_addressable (exp)\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  */\n \n tree\n-build_conditional_expr (ifexp, op1, op2)\n-     tree ifexp, op1, op2;\n+build_conditional_expr (tree ifexp, tree op1, tree op2)\n {\n   tree type1;\n   tree type2;\n@@ -3340,7 +3293,7 @@ build_conditional_expr (ifexp, op1, op2)\n   code1 = TREE_CODE (type1);\n   type2 = TREE_TYPE (op2);\n   code2 = TREE_CODE (type2);\n-      \n+\n   /* Quickly detect the usual case where op1 and op2 have the same type\n      after promotion.  */\n   if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2))\n@@ -3463,7 +3416,7 @@ build_conditional_expr (ifexp, op1, op2)\n     op1 = convert_and_check (result_type, op1);\n   if (result_type != TREE_TYPE (op2))\n     op2 = convert_and_check (result_type, op2);\n-    \n+\n   if (TREE_CODE (ifexp) == INTEGER_CST)\n     return pedantic_non_lvalue (integer_zerop (ifexp) ? op2 : op1);\n \n@@ -3474,16 +3427,13 @@ build_conditional_expr (ifexp, op1, op2)\n    that performs them all and returns the value of the last of them.  */\n \n tree\n-build_compound_expr (list)\n-     tree list;\n+build_compound_expr (tree list)\n {\n   return internal_build_compound_expr (list, TRUE);\n }\n \n static tree\n-internal_build_compound_expr (list, first_p)\n-     tree list;\n-     int first_p;\n+internal_build_compound_expr (tree list, int first_p)\n {\n   tree rest;\n \n@@ -3532,12 +3482,10 @@ internal_build_compound_expr (list, first_p)\n /* Build an expression representing a cast to type TYPE of expression EXPR.  */\n \n tree\n-build_c_cast (type, expr)\n-     tree type;\n-     tree expr;\n+build_c_cast (tree type, tree expr)\n {\n   tree value = expr;\n-  \n+\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n@@ -3689,7 +3637,7 @@ build_c_cast (type, expr)\n \t  && flag_strict_aliasing && warn_strict_aliasing\n \t  && !VOID_TYPE_P (TREE_TYPE (type)))\n \t{\n- \t  /* Casting the address of a decl to non void pointer. Warn\n+\t  /* Casting the address of a decl to non void pointer. Warn\n \t     if the cast breaks type based aliasing.  */\n \t  if (!COMPLETE_TYPE_P (TREE_TYPE (type)))\n \t    warning (\"type-punning to incomplete type might break strict-aliasing rules\");\n@@ -3728,8 +3676,7 @@ build_c_cast (type, expr)\n \n /* Interpret a cast of expression EXPR to type TYPE.  */\n tree\n-c_cast_expr (type, expr)\n-     tree type, expr;\n+c_cast_expr (tree type, tree expr)\n {\n   int saved_wsp = warn_strict_prototypes;\n \n@@ -3750,9 +3697,7 @@ c_cast_expr (type, expr)\n    Or else MODIFYCODE is NOP_EXPR meaning do a simple assignment.  */\n \n tree\n-build_modify_expr (lhs, modifycode, rhs)\n-     tree lhs, rhs;\n-     enum tree_code modifycode;\n+build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n {\n   tree result;\n   tree newrhs;\n@@ -3786,7 +3731,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \treturn error_mark_node;\n       return build (COMPOUND_EXPR, lhstype,\n \t\t    TREE_OPERAND (lhs, 0), newrhs);\n- \n+\n       /* Handle (a ? b : c) used as an \"lvalue\".  */\n     case COND_EXPR:\n       pedantic_lvalue_warning (COND_EXPR);\n@@ -3850,7 +3795,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \tpedantic_lvalue_warning (CONVERT_EXPR);\n \treturn convert (TREE_TYPE (lhs), result);\n       }\n-      \n+\n     default:\n       break;\n     }\n@@ -3927,11 +3872,7 @@ build_modify_expr (lhs, modifycode, rhs)\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n static tree\n-convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n-     tree type, rhs;\n-     const char *errtype;\n-     tree fundecl, funname;\n-     int parmnum;\n+convert_for_assignment (tree type, tree rhs, const char *errtype, tree fundecl, tree funname, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n   tree rhstype;\n@@ -3971,7 +3912,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n       error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  /* A type converts to a reference to it.  \n+  /* A type converts to a reference to it.\n      This code doesn't fully support references, it's just for the\n      special case of va_start and va_copy.  */\n   if (codel == REFERENCE_TYPE\n@@ -4003,7 +3944,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t       || (*targetm.vector_opaque_p) (rhstype)))\n     return convert (type, rhs);\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n-  else if ((codel == INTEGER_TYPE || codel == REAL_TYPE \n+  else if ((codel == INTEGER_TYPE || codel == REAL_TYPE\n \t    || codel == ENUMERAL_TYPE || codel == COMPLEX_TYPE\n \t    || codel == BOOLEAN_TYPE)\n \t   && (coder == INTEGER_TYPE || coder == REAL_TYPE\n@@ -4096,7 +4037,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t\t\t\t     errtype, funname,\n \t\t\t\t     parmnum);\n \t    }\n-\t  \n+\n \t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (fundecl))\n \t    pedwarn (\"ISO C prohibits argument conversion to union type\");\n \n@@ -4202,13 +4143,13 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n   if (!errtype)\n     {\n       if (funname)\n- \t{\n- \t  tree selector = objc_message_selector ();\n- \n- \t  if (selector && parmnum > 2)\n- \t    error (\"incompatible type for argument %d of `%s'\",\n+\t{\n+\t  tree selector = objc_message_selector ();\n+\n+\t  if (selector && parmnum > 2)\n+\t    error (\"incompatible type for argument %d of `%s'\",\n \t\t   parmnum - 2, IDENTIFIER_POINTER (selector));\n- \t  else\n+\t  else\n \t    error (\"incompatible type for argument %d of `%s'\",\n \t\t   parmnum, IDENTIFIER_POINTER (funname));\n \t}\n@@ -4225,8 +4166,7 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n /* Convert VALUE for assignment into inlined parameter PARM.  */\n \n tree\n-c_convert_parm_for_inlining (parm, value, fn)\n-     tree parm, value, fn;\n+c_convert_parm_for_inlining (tree parm, tree value, tree fn)\n {\n   tree ret, type;\n \n@@ -4236,7 +4176,7 @@ c_convert_parm_for_inlining (parm, value, fn)\n     return value;\n \n   type = TREE_TYPE (parm);\n-  ret = convert_for_assignment (type, value, \n+  ret = convert_for_assignment (type, value,\n \t\t\t\t(char *) 0 /* arg passing  */, fn,\n \t\t\t\tDECL_NAME (fn), 0);\n   if (PROMOTE_PROTOTYPES\n@@ -4254,17 +4194,13 @@ c_convert_parm_for_inlining (parm, value, fn)\n    Objective-C selector.  */\n \n static void\n-warn_for_assignment (msgid, opname, function, argnum)\n-     const char *msgid;\n-     const char *opname;\n-     tree function;\n-     int argnum;\n+warn_for_assignment (const char *msgid, const char *opname, tree function, int argnum)\n {\n   if (opname == 0)\n     {\n       tree selector = objc_message_selector ();\n       char * new_opname;\n-      \n+\n       if (selector && argnum > 2)\n \t{\n \t  function = selector;\n@@ -4273,7 +4209,7 @@ warn_for_assignment (msgid, opname, function, argnum)\n       if (argnum == 0)\n \t{\n \t  if (function)\n-\t    {\t    \n+\t    {\n \t      /* Function name is known; supply it.  */\n \t      const char *const argstring = _(\"passing arg of `%s'\");\n \t      new_opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n@@ -4319,9 +4255,7 @@ warn_for_assignment (msgid, opname, function, argnum)\n    which is allowed with a warning when -pedantic is specified.  */\n \n static tree\n-valid_compound_expr_initializer (value, endtype)\n-     tree value;\n-     tree endtype;\n+valid_compound_expr_initializer (tree value, tree endtype)\n {\n   if (TREE_CODE (value) == COMPOUND_EXPR)\n     {\n@@ -4344,8 +4278,7 @@ valid_compound_expr_initializer (value, endtype)\n    If the init is invalid, store an ERROR_MARK.  */\n \n void\n-store_init_value (decl, init)\n-     tree decl, init;\n+store_init_value (tree decl, tree init)\n {\n   tree value, type;\n \n@@ -4456,18 +4389,15 @@ static int spelling_size;\t\t/* Size of the spelling stack.  */\n /* Push STRING on the stack.  Printed literally.  */\n \n static void\n-push_string (string)\n-     const char *string;\n+push_string (const char *string)\n {\n   PUSH_SPELLING (SPELLING_STRING, string, u.s);\n }\n \n /* Push a member name on the stack.  Printed as '.' STRING.  */\n \n static void\n-push_member_name (decl)\n-     tree decl;\n-     \n+push_member_name (tree decl)\n {\n   const char *const string\n     = DECL_NAME (decl) ? IDENTIFIER_POINTER (DECL_NAME (decl)) : \"<anonymous>\";\n@@ -4477,16 +4407,15 @@ push_member_name (decl)\n /* Push an array bounds on the stack.  Printed as [BOUNDS].  */\n \n static void\n-push_array_bounds (bounds)\n-     int bounds;\n+push_array_bounds (int bounds)\n {\n   PUSH_SPELLING (SPELLING_BOUNDS, bounds, u.i);\n }\n \n /* Compute the maximum size in bytes of the printed spelling.  */\n \n static int\n-spelling_length ()\n+spelling_length (void)\n {\n   int size = 0;\n   struct spelling *p;\n@@ -4505,8 +4434,7 @@ spelling_length ()\n /* Print the spelling to BUFFER and return it.  */\n \n static char *\n-print_spelling (buffer)\n-     char *buffer;\n+print_spelling (char *buffer)\n {\n   char *d = buffer;\n   struct spelling *p;\n@@ -4534,8 +4462,7 @@ print_spelling (buffer)\n    The component name is taken from the spelling stack.  */\n \n void\n-error_init (msgid)\n-     const char *msgid;\n+error_init (const char *msgid)\n {\n   char *ofwhat;\n \n@@ -4550,8 +4477,7 @@ error_init (msgid)\n    The component name is taken from the spelling stack.  */\n \n void\n-pedwarn_init (msgid)\n-     const char *msgid;\n+pedwarn_init (const char *msgid)\n {\n   char *ofwhat;\n \n@@ -4566,8 +4492,7 @@ pedwarn_init (msgid)\n    The component name is taken from the spelling stack.  */\n \n static void\n-warning_init (msgid)\n-     const char *msgid;\n+warning_init (const char *msgid)\n {\n   char *ofwhat;\n \n@@ -4584,9 +4509,7 @@ warning_init (msgid)\n    elements are seen.  */\n \n static tree\n-digest_init (type, init, require_constant)\n-     tree type, init;\n-     int require_constant;\n+digest_init (tree type, tree init, int require_constant)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree inside_init = init;\n@@ -4726,7 +4649,7 @@ digest_init (type, init, require_constant)\n \t  if (flag_pedantic_errors)\n \t    inside_init = error_mark_node;\n \t}\n-      else if (require_constant \n+      else if (require_constant\n \t       && (!TREE_CONSTANT (inside_init)\n \t\t   /* This test catches things like `7 / 0' which\n \t\t      result in an expression for which TREE_CONSTANT\n@@ -4954,10 +4877,7 @@ struct initializer_stack *initializer_stack;\n /* Prepare to parse and output the initializer for variable DECL.  */\n \n void\n-start_init (decl, asmspec_tree, top_level)\n-     tree decl;\n-     tree asmspec_tree;\n-     int top_level;\n+start_init (tree decl, tree asmspec_tree, int top_level)\n {\n   const char *locus;\n   struct initializer_stack *p\n@@ -5020,7 +4940,7 @@ start_init (decl, asmspec_tree, top_level)\n }\n \n void\n-finish_init ()\n+finish_init (void)\n {\n   struct initializer_stack *p = initializer_stack;\n \n@@ -5059,8 +4979,7 @@ finish_init ()\n    For an initializer for a decl, TYPE is zero.  */\n \n void\n-really_start_incremental_init (type)\n-     tree type;\n+really_start_incremental_init (tree type)\n {\n   struct constructor_stack *p\n     = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n@@ -5166,8 +5085,7 @@ really_start_incremental_init (type)\n    IMPLICIT is 1 (or 2 if the push is because of designator list).  */\n \n void\n-push_init_level (implicit)\n-     int implicit;\n+push_init_level (int implicit)\n {\n   struct constructor_stack *p;\n   tree value = NULL_TREE;\n@@ -5181,7 +5099,7 @@ push_init_level (implicit)\n \t  && constructor_fields == 0)\n \tprocess_init_element (pop_init_level (1));\n       else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n-\t       && constructor_max_index \n+\t       && constructor_max_index\n \t       && tree_int_cst_lt (constructor_max_index, constructor_index))\n \tprocess_init_element (pop_init_level (1));\n       else\n@@ -5327,7 +5245,7 @@ push_init_level (implicit)\n \t    constructor_max_index = build_int_2 (-1, -1);\n \n \t  constructor_index\n-\t    = convert (bitsizetype, \n+\t    = convert (bitsizetype,\n \t\t       TYPE_MIN_VALUE (TYPE_DOMAIN (constructor_type)));\n \t}\n       else\n@@ -5350,7 +5268,7 @@ push_init_level (implicit)\n     }\n }\n \n-/* At the end of an implicit or explicit brace level, \n+/* At the end of an implicit or explicit brace level,\n    finish up that level of constructor.\n    If we were outputting the elements as they are read, return 0\n    from inner levels (process_init_element ignores that),\n@@ -5359,8 +5277,7 @@ push_init_level (implicit)\n    Otherwise, return a CONSTRUCTOR expression.  */\n \n tree\n-pop_init_level (implicit)\n-     int implicit;\n+pop_init_level (int implicit)\n {\n   struct constructor_stack *p;\n   tree constructor = 0;\n@@ -5512,8 +5429,7 @@ pop_init_level (implicit)\n    ARRAY argument is nonzero for array ranges.  Returns zero for success.  */\n \n static int\n-set_designator (array)\n-     int array;\n+set_designator (int array)\n {\n   tree subtype;\n   enum tree_code subcode;\n@@ -5582,8 +5498,7 @@ set_designator (array)\n    NULL_TREE if there is no range designator at this level.  */\n \n static void\n-push_range_stack (range_end)\n-     tree range_end;\n+push_range_stack (tree range_end)\n {\n   struct constructor_range_stack *p;\n \n@@ -5606,8 +5521,7 @@ push_range_stack (range_end)\n    of indices, running from FIRST through LAST.  */\n \n void\n-set_init_index (first, last)\n-     tree first, last;\n+set_init_index (tree first, tree last)\n {\n   if (set_designator (1))\n     return;\n@@ -5673,8 +5587,7 @@ set_init_index (first, last)\n /* Within a struct initializer, specify the next field to be initialized.  */\n \n void\n-set_init_label (fieldname)\n-     tree fieldname;\n+set_init_label (tree fieldname)\n {\n   tree tail;\n \n@@ -5689,7 +5602,7 @@ set_init_label (fieldname)\n       error_init (\"field name not in record or union initializer\");\n       return;\n     }\n-    \n+\n   for (tail = TYPE_FIELDS (constructor_type); tail;\n        tail = TREE_CHAIN (tail))\n     {\n@@ -5711,12 +5624,11 @@ set_init_label (fieldname)\n }\n \f\n /* Add a new initializer to the tree of pending initializers.  PURPOSE\n-   identifies the initializer, either array index or field in a structure. \n+   identifies the initializer, either array index or field in a structure.\n    VALUE is the value of that index or field.  */\n \n static void\n-add_pending_init (purpose, value)\n-     tree purpose, value;\n+add_pending_init (tree purpose, tree value)\n {\n   struct init_node *p, **q, *r;\n \n@@ -5931,7 +5843,7 @@ add_pending_init (purpose, value)\n /* Build AVL tree from a sorted chain.  */\n \n static void\n-set_nonincremental_init ()\n+set_nonincremental_init (void)\n {\n   tree chain;\n \n@@ -5950,7 +5862,7 @@ set_nonincremental_init ()\n \t     && DECL_C_BIT_FIELD (constructor_unfilled_fields)\n \t     && DECL_NAME (constructor_unfilled_fields) == 0)\n \tconstructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n-      \n+\n     }\n   else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n     {\n@@ -5967,8 +5879,7 @@ set_nonincremental_init ()\n /* Build AVL tree from a string constant.  */\n \n static void\n-set_nonincremental_init_from_string (str)\n-     tree str;\n+set_nonincremental_init_from_string (tree str)\n {\n   tree value, purpose, type;\n   HOST_WIDE_INT val[2];\n@@ -6051,8 +5962,7 @@ set_nonincremental_init_from_string (str)\n    not initialized yet.  */\n \n static tree\n-find_init_member (field)\n-     tree field;\n+find_init_member (tree field)\n {\n   struct init_node *p;\n \n@@ -6114,9 +6024,7 @@ find_init_member (field)\n    it is 0 while outputting pending elements, to avoid recursion.)  */\n \n static void\n-output_init_element (value, type, field, pending)\n-     tree value, type, field;\n-     int pending;\n+output_init_element (tree value, tree type, tree field, int pending)\n {\n   if (type == error_mark_node)\n     {\n@@ -6273,8 +6181,7 @@ output_init_element (value, type, field, pending)\n    we can output all the pending elements.  */\n \n static void\n-output_pending_init_elements (all)\n-     int all;\n+output_pending_init_elements (int all)\n {\n   struct init_node *elt = constructor_pending_elts;\n   tree next;\n@@ -6285,7 +6192,7 @@ output_pending_init_elements (all)\n      If we find an element that should be output now,\n      output it.  Otherwise, set NEXT to the element\n      that comes first among those still pending.  */\n-     \n+\n   next = 0;\n   while (elt)\n     {\n@@ -6414,8 +6321,7 @@ output_pending_init_elements (all)\n    it calls output_init_element.  */\n \n void\n-process_init_element (value)\n-     tree value;\n+process_init_element (tree value)\n {\n   tree orig_value = value;\n   int string_flag = value != 0 && TREE_CODE (value) == STRING_CST;\n@@ -6771,8 +6677,7 @@ process_init_element (value)\n \f\n /* Build a simple asm-statement, from one string literal.  */\n tree\n-simple_asm_stmt (expr)\n-     tree expr;\n+simple_asm_stmt (tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -6798,12 +6703,7 @@ simple_asm_stmt (expr)\n    STRING, some OUTPUTS, some INPUTS, and some CLOBBERS.  */\n \n tree\n-build_asm_stmt (cv_qualifier, string, outputs, inputs, clobbers)\n-     tree cv_qualifier;\n-     tree string;\n-     tree outputs;\n-     tree inputs;\n-     tree clobbers;\n+build_asm_stmt (tree cv_qualifier, tree string, tree outputs, tree inputs, tree clobbers)\n {\n   tree tail;\n \n@@ -6852,7 +6752,7 @@ build_asm_stmt (cv_qualifier, string, outputs, inputs, clobbers)\n       TREE_VALUE (tail) = output;\n     }\n \n-  /* Perform default conversions on array and function inputs. \n+  /* Perform default conversions on array and function inputs.\n      Don't do this for other types as it would screw up operands\n      expected to be in memory.  */\n   for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n@@ -6869,11 +6769,9 @@ build_asm_stmt (cv_qualifier, string, outputs, inputs, clobbers)\n    Arguments are same as for expand_asm_operands.  */\n \n void\n-c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n-     tree string, outputs, inputs, clobbers;\n-     int vol;\n-     const char *filename;\n-     int line;\n+c_expand_asm_operands (tree string, tree outputs, tree inputs,\n+\t\t       tree clobbers, int vol, const char *filename,\n+\t\t       int line)\n {\n   int noutputs = list_length (outputs);\n   int i;\n@@ -6929,8 +6827,7 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n    or a null pointer for `return;' with no value.  */\n \n tree\n-c_expand_return (retval)\n-     tree retval;\n+c_expand_return (tree retval)\n {\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n \n@@ -6993,7 +6890,7 @@ c_expand_return (retval)\n \t\tinner = TREE_OPERAND (inner, 0);\n \t\tcontinue;\n \t      }\n-\t      \n+\n \t    case ADDR_EXPR:\n \t      inner = TREE_OPERAND (inner, 0);\n \n@@ -7045,8 +6942,7 @@ static struct c_switch *switch_stack;\n    SWITCH_STMT.  */\n \n tree\n-c_start_case (exp)\n-     tree exp;\n+c_start_case (tree exp)\n {\n   enum tree_code code;\n   tree type, orig_type = error_mark_node;\n@@ -7090,18 +6986,16 @@ c_start_case (exp)\n /* Process a case label.  */\n \n tree\n-do_case (low_value, high_value)\n-     tree low_value;\n-     tree high_value;\n+do_case (tree low_value, tree high_value)\n {\n   tree label = NULL_TREE;\n \n   if (switch_stack)\n     {\n       bool switch_was_empty_p = (SWITCH_BODY (switch_stack->switch_stmt) == NULL_TREE);\n \n-      label = c_add_case_label (switch_stack->cases, \n-\t\t\t\tSWITCH_COND (switch_stack->switch_stmt), \n+      label = c_add_case_label (switch_stack->cases,\n+\t\t\t\tSWITCH_COND (switch_stack->switch_stmt),\n \t\t\t\tlow_value, high_value);\n       if (label == error_mark_node)\n \tlabel = NULL_TREE;\n@@ -7123,7 +7017,7 @@ do_case (low_value, high_value)\n /* Finish the switch statement.  */\n \n void\n-c_finish_case ()\n+c_finish_case (void)\n {\n   struct c_switch *cs = switch_stack;\n "}]}