{"sha": "360139876e080a505c41ad40e7fec7383a93fc8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYwMTM5ODc2ZTA4MGE1MDVjNDFhZDQwZTdmZWM3MzgzYTkzZmM4Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-03-08T12:01:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-03-08T12:01:17Z"}, "message": "alpha.c (code_for_builtin): Replace special-case builtin codes with ctzdi2, clzdi2, popcountdi2.\n\n        * config/alpha/alpha.c (code_for_builtin): Replace special-case\n        builtin codes with ctzdi2, clzdi2, popcountdi2.\n        (struct alpha_builtin_def): Add is_const.\n        (zero_arg_builtins, one_arg_builtins, two_arg_builtins): Init it.\n        (alpha_v8qi_u, alpha_v8qi_s, alpha_v4hi_u, alpha_v4hi_s): New.\n        (alpha_init_builtins): Init them.  Set nothrow and const attributes\n        on builtins.\n        (alpha_fold_builtin_cmpbge, alpha_fold_builtin_zapnot,\n        alpha_fold_builtin_extxx, alpha_fold_builtin_insxx,\n        alpha_fold_builtin_mskxx, alpha_fold_builtin_umulh,\n        alpha_fold_vector_minmax, alpha_fold_builtin_perr,\n        alpha_fold_builtin_pklb, alpha_fold_builtin_pkwb,\n        alpha_fold_builtin_unpkbl, alpha_fold_builtin_unpkbw,\n        alpha_fold_builtin_cttz, alpha_fold_builtin_ctlz,\n        alpha_fold_builtin_ctpop, alpha_fold_builtin): New.\n        (TARGET_FOLD_BUILTIN): New.\n        * config/alpha/alpha.md (UNSPEC_CTTZ): Remove.\n        (UNSPEC_CTLZ, UNSPEC_CTPOP): Remove.\n        (ffsdi2): Use ctz.\n        (cttz, builtin_cttz, builtin_ctlz, builtin_ctpop): Remove.\n\nFrom-SVN: r96098", "tree": {"sha": "ca9d4140dfe57915b40135466a7e552e51bd84e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca9d4140dfe57915b40135466a7e552e51bd84e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/360139876e080a505c41ad40e7fec7383a93fc8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360139876e080a505c41ad40e7fec7383a93fc8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/360139876e080a505c41ad40e7fec7383a93fc8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360139876e080a505c41ad40e7fec7383a93fc8f/comments", "author": null, "committer": null, "parents": [{"sha": "fe8a06f20a82dceb608ad8ba9f7b771ea8421b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe8a06f20a82dceb608ad8ba9f7b771ea8421b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe8a06f20a82dceb608ad8ba9f7b771ea8421b9d"}], "stats": {"total": 661, "additions": 571, "deletions": 90}, "files": [{"sha": "82bd14d75fbb1c99f0c53498e25120689288dc68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360139876e080a505c41ad40e7fec7383a93fc8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360139876e080a505c41ad40e7fec7383a93fc8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=360139876e080a505c41ad40e7fec7383a93fc8f", "patch": "@@ -1,3 +1,26 @@\n+2005-03-08  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (code_for_builtin): Replace special-case\n+\tbuiltin codes with ctzdi2, clzdi2, popcountdi2.\n+\t(struct alpha_builtin_def): Add is_const.\n+\t(zero_arg_builtins, one_arg_builtins, two_arg_builtins): Init it.\n+\t(alpha_v8qi_u, alpha_v8qi_s, alpha_v4hi_u, alpha_v4hi_s): New.\n+\t(alpha_init_builtins): Init them.  Set nothrow and const attributes\n+\ton builtins.\n+\t(alpha_fold_builtin_cmpbge, alpha_fold_builtin_zapnot, \n+\talpha_fold_builtin_extxx, alpha_fold_builtin_insxx, \n+\talpha_fold_builtin_mskxx, alpha_fold_builtin_umulh, \n+\talpha_fold_vector_minmax, alpha_fold_builtin_perr,\n+\talpha_fold_builtin_pklb, alpha_fold_builtin_pkwb,\n+\talpha_fold_builtin_unpkbl, alpha_fold_builtin_unpkbw,\n+\talpha_fold_builtin_cttz, alpha_fold_builtin_ctlz,\n+\talpha_fold_builtin_ctpop, alpha_fold_builtin): New.\n+\t(TARGET_FOLD_BUILTIN): New.\n+\t* config/alpha/alpha.md (UNSPEC_CTTZ): Remove.\n+\t(UNSPEC_CTLZ, UNSPEC_CTPOP): Remove.\n+\t(ffsdi2): Use ctz.\n+\t(cttz, builtin_cttz, builtin_ctlz, builtin_ctpop): Remove.\n+\n 2005-03-08  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/20122"}, {"sha": "773bd0d1c15b3ab895339a04d26468fad852c09d", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 546, "deletions": 53, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360139876e080a505c41ad40e7fec7383a93fc8f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360139876e080a505c41ad40e7fec7383a93fc8f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=360139876e080a505c41ad40e7fec7383a93fc8f", "patch": "@@ -5901,85 +5901,94 @@ static unsigned int const code_for_builtin[ALPHA_BUILTIN_max] = {\n   CODE_FOR_builtin_unpkbw,\n \n   /* TARGET_CIX */\n-  CODE_FOR_builtin_cttz,\n-  CODE_FOR_builtin_ctlz,\n-  CODE_FOR_builtin_ctpop\n+  CODE_FOR_ctzdi2,\n+  CODE_FOR_clzdi2,\n+  CODE_FOR_popcountdi2\n };\n \n struct alpha_builtin_def\n {\n   const char *name;\n   enum alpha_builtin code;\n   unsigned int target_mask;\n+  bool is_const;\n };\n \n static struct alpha_builtin_def const zero_arg_builtins[] = {\n-  { \"__builtin_alpha_implver\",\tALPHA_BUILTIN_IMPLVER,\t0 },\n-  { \"__builtin_alpha_rpcc\",\tALPHA_BUILTIN_RPCC,\t0 }\n+  { \"__builtin_alpha_implver\",\tALPHA_BUILTIN_IMPLVER,\t0, true },\n+  { \"__builtin_alpha_rpcc\",\tALPHA_BUILTIN_RPCC,\t0, false }\n };\n \n static struct alpha_builtin_def const one_arg_builtins[] = {\n-  { \"__builtin_alpha_amask\",\tALPHA_BUILTIN_AMASK,\t0 },\n-  { \"__builtin_alpha_pklb\",\tALPHA_BUILTIN_PKLB,\tMASK_MAX },\n-  { \"__builtin_alpha_pkwb\",\tALPHA_BUILTIN_PKWB,\tMASK_MAX },\n-  { \"__builtin_alpha_unpkbl\",\tALPHA_BUILTIN_UNPKBL,\tMASK_MAX },\n-  { \"__builtin_alpha_unpkbw\",\tALPHA_BUILTIN_UNPKBW,\tMASK_MAX },\n-  { \"__builtin_alpha_cttz\",\tALPHA_BUILTIN_CTTZ,\tMASK_CIX },\n-  { \"__builtin_alpha_ctlz\",\tALPHA_BUILTIN_CTLZ,\tMASK_CIX },\n-  { \"__builtin_alpha_ctpop\",\tALPHA_BUILTIN_CTPOP,\tMASK_CIX }\n+  { \"__builtin_alpha_amask\",\tALPHA_BUILTIN_AMASK,\t0, true },\n+  { \"__builtin_alpha_pklb\",\tALPHA_BUILTIN_PKLB,\tMASK_MAX, true },\n+  { \"__builtin_alpha_pkwb\",\tALPHA_BUILTIN_PKWB,\tMASK_MAX, true },\n+  { \"__builtin_alpha_unpkbl\",\tALPHA_BUILTIN_UNPKBL,\tMASK_MAX, true },\n+  { \"__builtin_alpha_unpkbw\",\tALPHA_BUILTIN_UNPKBW,\tMASK_MAX, true },\n+  { \"__builtin_alpha_cttz\",\tALPHA_BUILTIN_CTTZ,\tMASK_CIX, true },\n+  { \"__builtin_alpha_ctlz\",\tALPHA_BUILTIN_CTLZ,\tMASK_CIX, true },\n+  { \"__builtin_alpha_ctpop\",\tALPHA_BUILTIN_CTPOP,\tMASK_CIX, true }\n };\n \n static struct alpha_builtin_def const two_arg_builtins[] = {\n-  { \"__builtin_alpha_cmpbge\",\tALPHA_BUILTIN_CMPBGE,\t0 },\n-  { \"__builtin_alpha_extbl\",\tALPHA_BUILTIN_EXTBL,\t0 },\n-  { \"__builtin_alpha_extwl\",\tALPHA_BUILTIN_EXTWL,\t0 },\n-  { \"__builtin_alpha_extll\",\tALPHA_BUILTIN_EXTLL,\t0 },\n-  { \"__builtin_alpha_extql\",\tALPHA_BUILTIN_EXTQL,\t0 },\n-  { \"__builtin_alpha_extwh\",\tALPHA_BUILTIN_EXTWH,\t0 },\n-  { \"__builtin_alpha_extlh\",\tALPHA_BUILTIN_EXTLH,\t0 },\n-  { \"__builtin_alpha_extqh\",\tALPHA_BUILTIN_EXTQH,\t0 },\n-  { \"__builtin_alpha_insbl\",\tALPHA_BUILTIN_INSBL,\t0 },\n-  { \"__builtin_alpha_inswl\",\tALPHA_BUILTIN_INSWL,\t0 },\n-  { \"__builtin_alpha_insll\",\tALPHA_BUILTIN_INSLL,\t0 },\n-  { \"__builtin_alpha_insql\",\tALPHA_BUILTIN_INSQL,\t0 },\n-  { \"__builtin_alpha_inswh\",\tALPHA_BUILTIN_INSWH,\t0 },\n-  { \"__builtin_alpha_inslh\",\tALPHA_BUILTIN_INSLH,\t0 },\n-  { \"__builtin_alpha_insqh\",\tALPHA_BUILTIN_INSQH,\t0 },\n-  { \"__builtin_alpha_mskbl\",\tALPHA_BUILTIN_MSKBL,\t0 },\n-  { \"__builtin_alpha_mskwl\",\tALPHA_BUILTIN_MSKWL,\t0 },\n-  { \"__builtin_alpha_mskll\",\tALPHA_BUILTIN_MSKLL,\t0 },\n-  { \"__builtin_alpha_mskql\",\tALPHA_BUILTIN_MSKQL,\t0 },\n-  { \"__builtin_alpha_mskwh\",\tALPHA_BUILTIN_MSKWH,\t0 },\n-  { \"__builtin_alpha_msklh\",\tALPHA_BUILTIN_MSKLH,\t0 },\n-  { \"__builtin_alpha_mskqh\",\tALPHA_BUILTIN_MSKQH,\t0 },\n-  { \"__builtin_alpha_umulh\",\tALPHA_BUILTIN_UMULH,\t0 },\n-  { \"__builtin_alpha_zap\",\tALPHA_BUILTIN_ZAP,\t0 },\n-  { \"__builtin_alpha_zapnot\",\tALPHA_BUILTIN_ZAPNOT,\t0 },\n-  { \"__builtin_alpha_minub8\",\tALPHA_BUILTIN_MINUB8,\tMASK_MAX },\n-  { \"__builtin_alpha_minsb8\",\tALPHA_BUILTIN_MINSB8,\tMASK_MAX },\n-  { \"__builtin_alpha_minuw4\",\tALPHA_BUILTIN_MINUW4,\tMASK_MAX },\n-  { \"__builtin_alpha_minsw4\",\tALPHA_BUILTIN_MINSW4,\tMASK_MAX },\n-  { \"__builtin_alpha_maxub8\",\tALPHA_BUILTIN_MAXUB8,\tMASK_MAX },\n-  { \"__builtin_alpha_maxsb8\",\tALPHA_BUILTIN_MAXSB8,\tMASK_MAX },\n-  { \"__builtin_alpha_maxuw4\",\tALPHA_BUILTIN_MAXUW4,\tMASK_MAX },\n-  { \"__builtin_alpha_maxsw4\",\tALPHA_BUILTIN_MAXSW4,\tMASK_MAX },\n-  { \"__builtin_alpha_perr\",\tALPHA_BUILTIN_PERR,\tMASK_MAX }\n+  { \"__builtin_alpha_cmpbge\",\tALPHA_BUILTIN_CMPBGE,\t0, true },\n+  { \"__builtin_alpha_extbl\",\tALPHA_BUILTIN_EXTBL,\t0, true },\n+  { \"__builtin_alpha_extwl\",\tALPHA_BUILTIN_EXTWL,\t0, true },\n+  { \"__builtin_alpha_extll\",\tALPHA_BUILTIN_EXTLL,\t0, true },\n+  { \"__builtin_alpha_extql\",\tALPHA_BUILTIN_EXTQL,\t0, true },\n+  { \"__builtin_alpha_extwh\",\tALPHA_BUILTIN_EXTWH,\t0, true },\n+  { \"__builtin_alpha_extlh\",\tALPHA_BUILTIN_EXTLH,\t0, true },\n+  { \"__builtin_alpha_extqh\",\tALPHA_BUILTIN_EXTQH,\t0, true },\n+  { \"__builtin_alpha_insbl\",\tALPHA_BUILTIN_INSBL,\t0, true },\n+  { \"__builtin_alpha_inswl\",\tALPHA_BUILTIN_INSWL,\t0, true },\n+  { \"__builtin_alpha_insll\",\tALPHA_BUILTIN_INSLL,\t0, true },\n+  { \"__builtin_alpha_insql\",\tALPHA_BUILTIN_INSQL,\t0, true },\n+  { \"__builtin_alpha_inswh\",\tALPHA_BUILTIN_INSWH,\t0, true },\n+  { \"__builtin_alpha_inslh\",\tALPHA_BUILTIN_INSLH,\t0, true },\n+  { \"__builtin_alpha_insqh\",\tALPHA_BUILTIN_INSQH,\t0, true },\n+  { \"__builtin_alpha_mskbl\",\tALPHA_BUILTIN_MSKBL,\t0, true },\n+  { \"__builtin_alpha_mskwl\",\tALPHA_BUILTIN_MSKWL,\t0, true },\n+  { \"__builtin_alpha_mskll\",\tALPHA_BUILTIN_MSKLL,\t0, true },\n+  { \"__builtin_alpha_mskql\",\tALPHA_BUILTIN_MSKQL,\t0, true },\n+  { \"__builtin_alpha_mskwh\",\tALPHA_BUILTIN_MSKWH,\t0, true },\n+  { \"__builtin_alpha_msklh\",\tALPHA_BUILTIN_MSKLH,\t0, true },\n+  { \"__builtin_alpha_mskqh\",\tALPHA_BUILTIN_MSKQH,\t0, true },\n+  { \"__builtin_alpha_umulh\",\tALPHA_BUILTIN_UMULH,\t0, true },\n+  { \"__builtin_alpha_zap\",\tALPHA_BUILTIN_ZAP,\t0, true },\n+  { \"__builtin_alpha_zapnot\",\tALPHA_BUILTIN_ZAPNOT,\t0, true },\n+  { \"__builtin_alpha_minub8\",\tALPHA_BUILTIN_MINUB8,\tMASK_MAX, true },\n+  { \"__builtin_alpha_minsb8\",\tALPHA_BUILTIN_MINSB8,\tMASK_MAX, true },\n+  { \"__builtin_alpha_minuw4\",\tALPHA_BUILTIN_MINUW4,\tMASK_MAX, true },\n+  { \"__builtin_alpha_minsw4\",\tALPHA_BUILTIN_MINSW4,\tMASK_MAX, true },\n+  { \"__builtin_alpha_maxub8\",\tALPHA_BUILTIN_MAXUB8,\tMASK_MAX, true },\n+  { \"__builtin_alpha_maxsb8\",\tALPHA_BUILTIN_MAXSB8,\tMASK_MAX, true },\n+  { \"__builtin_alpha_maxuw4\",\tALPHA_BUILTIN_MAXUW4,\tMASK_MAX, true },\n+  { \"__builtin_alpha_maxsw4\",\tALPHA_BUILTIN_MAXSW4,\tMASK_MAX, true },\n+  { \"__builtin_alpha_perr\",\tALPHA_BUILTIN_PERR,\tMASK_MAX, true }\n };\n \n+static GTY(()) tree alpha_v8qi_u;\n+static GTY(()) tree alpha_v8qi_s;\n+static GTY(()) tree alpha_v4hi_u;\n+static GTY(()) tree alpha_v4hi_s;\n+\n static void\n alpha_init_builtins (void)\n {\n   const struct alpha_builtin_def *p;\n-  tree ftype;\n+  tree ftype, attrs[2];\n   size_t i;\n \n+  attrs[0] = tree_cons (get_identifier (\"nothrow\"), NULL, NULL);\n+  attrs[1] = tree_cons (get_identifier (\"const\"), NULL, attrs[0]);\n+\n   ftype = build_function_type (long_integer_type_node, void_list_node);\n \n   p = zero_arg_builtins;\n   for (i = 0; i < ARRAY_SIZE (zero_arg_builtins); ++i, ++p)\n     if ((target_flags & p->target_mask) == p->target_mask)\n       lang_hooks.builtin_function (p->name, ftype, p->code, BUILT_IN_MD,\n-\t\t\t\t   NULL, NULL_TREE);\n+\t\t\t\t   NULL, attrs[p->is_const]);\n \n   ftype = build_function_type_list (long_integer_type_node,\n \t\t\t\t    long_integer_type_node, NULL_TREE);\n@@ -5988,7 +5997,7 @@ alpha_init_builtins (void)\n   for (i = 0; i < ARRAY_SIZE (one_arg_builtins); ++i, ++p)\n     if ((target_flags & p->target_mask) == p->target_mask)\n       lang_hooks.builtin_function (p->name, ftype, p->code, BUILT_IN_MD,\n-\t\t\t\t   NULL, NULL_TREE);\n+\t\t\t\t   NULL, attrs[p->is_const]);\n \n   ftype = build_function_type_list (long_integer_type_node,\n \t\t\t\t    long_integer_type_node,\n@@ -5998,17 +6007,22 @@ alpha_init_builtins (void)\n   for (i = 0; i < ARRAY_SIZE (two_arg_builtins); ++i, ++p)\n     if ((target_flags & p->target_mask) == p->target_mask)\n       lang_hooks.builtin_function (p->name, ftype, p->code, BUILT_IN_MD,\n-\t\t\t\t   NULL, NULL_TREE);\n+\t\t\t\t   NULL, attrs[p->is_const]);\n \n   ftype = build_function_type (ptr_type_node, void_list_node);\n   lang_hooks.builtin_function (\"__builtin_thread_pointer\", ftype,\n \t\t\t       ALPHA_BUILTIN_THREAD_POINTER, BUILT_IN_MD,\n-\t\t\t       NULL, NULL_TREE);\n+\t\t\t       NULL, attrs[0]);\n \n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   lang_hooks.builtin_function (\"__builtin_set_thread_pointer\", ftype,\n \t\t\t       ALPHA_BUILTIN_SET_THREAD_POINTER, BUILT_IN_MD,\n-\t\t\t       NULL, NULL_TREE);\n+\t\t\t       NULL, attrs[0]);\n+\n+  alpha_v8qi_u = build_vector_type (unsigned_intQI_type_node, 8);\n+  alpha_v8qi_s = build_vector_type (intQI_type_node, 8);\n+  alpha_v4hi_u = build_vector_type (unsigned_intHI_type_node, 4);\n+  alpha_v4hi_s = build_vector_type (intHI_type_node, 4);\n }\n \n /* Expand an expression EXP that calls a built-in function,\n@@ -6096,6 +6110,483 @@ alpha_expand_builtin (tree exp, rtx target,\n   else\n     return const0_rtx;\n }\n+\n+\n+/* Several bits below assume HWI >= 64 bits.  This should be enforced\n+   by config.gcc.  */\n+#if HOST_BITS_PER_WIDE_INT < 64\n+# error \"HOST_WIDE_INT too small\"\n+#endif\n+\n+/* Fold the builtin for the CMPBGE instruction.  This is a vector comparison\n+   with an 8 bit output vector.  OPINT contains the integer operands; bit N\n+   of OP_CONST is set if OPINT[N] is valid.  */\n+\n+static tree\n+alpha_fold_builtin_cmpbge (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  if (op_const == 3)\n+    {\n+      int i, val;\n+      for (i = 0, val = 0; i < 8; ++i)\n+\t{\n+\t  unsigned HOST_WIDE_INT c0 = (opint[0] >> (i * 8)) & 0xff;\n+\t  unsigned HOST_WIDE_INT c1 = (opint[1] >> (i * 8)) & 0xff;\n+\t  if (c0 >= c1)\n+\t    val |= 1 << i;\n+\t}\n+      return build_int_cst (long_integer_type_node, val);\n+    }\n+  else if (op_const == 1 && opint[0] == 0)\n+    return build_int_cst (long_integer_type_node, 0xff);\n+  return NULL;\n+}\n+\n+/* Fold the builtin for the ZAPNOT instruction.  This is essentially a \n+   specialized form of an AND operation.  Other byte manipulation instructions\n+   are defined in terms of this instruction, so this is also used as a\n+   subroutine for other builtins.\n+\n+   OP contains the tree operands; OPINT contains the extracted integer values.\n+   Bit N of OP_CONST it set if OPINT[N] is valid.  OP may be null if only\n+   OPINT may be considered.  */\n+\n+static tree\n+alpha_fold_builtin_zapnot (tree *op, unsigned HOST_WIDE_INT opint[],\n+\t\t\t   long op_const)\n+{\n+  if (op_const & 2)\n+    {\n+      unsigned HOST_WIDE_INT mask = 0;\n+      int i;\n+\n+      for (i = 0; i < 8; ++i)\n+\tif ((opint[1] >> i) & 1)\n+\t  mask |= (unsigned HOST_WIDE_INT)0xff << (i * 8);\n+\n+      if (op_const & 1)\n+\treturn build_int_cst (long_integer_type_node, opint[0] & mask);\n+\n+      if (op)\n+\treturn fold (build2 (BIT_AND_EXPR, long_integer_type_node, op[0],\n+\t\t\t     build_int_cst (long_integer_type_node, mask)));\n+    }\n+  else if ((op_const & 1) && opint[0] == 0)\n+    return build_int_cst (long_integer_type_node, 0);\n+  return NULL;\n+}\n+\n+/* Fold the builtins for the EXT family of instructions.  */\n+\n+static tree\n+alpha_fold_builtin_extxx (tree op[], unsigned HOST_WIDE_INT opint[],\n+\t\t\t  long op_const, unsigned HOST_WIDE_INT bytemask,\n+\t\t\t  bool is_high)\n+{\n+  long zap_const = 2;\n+  tree *zap_op = NULL;\n+\n+  if (op_const & 2)\n+    {\n+      unsigned HOST_WIDE_INT loc;\n+\n+      loc = opint[1] & 7;\n+      if (BYTES_BIG_ENDIAN)\n+        loc ^= 7;\n+      loc *= 8;\n+\n+      if (loc != 0)\n+\t{\n+\t  if (op_const & 1)\n+\t    {\n+\t      unsigned HOST_WIDE_INT temp = opint[0];\n+\t      if (is_high)\n+\t\ttemp <<= loc;\n+\t      else\n+\t\ttemp >>= loc;\n+\t      opint[0] = temp;\n+\t      zap_const = 3;\n+\t    }\n+\t}\n+      else\n+\tzap_op = op;\n+    }\n+  \n+  opint[1] = bytemask;\n+  return alpha_fold_builtin_zapnot (zap_op, opint, zap_const);\n+}\n+\n+/* Fold the builtins for the INS family of instructions.  */\n+\n+static tree\n+alpha_fold_builtin_insxx (tree op[], unsigned HOST_WIDE_INT opint[],\n+\t\t\t  long op_const, unsigned HOST_WIDE_INT bytemask,\n+\t\t\t  bool is_high)\n+{\n+  if ((op_const & 1) && opint[0] == 0)\n+    return build_int_cst (long_integer_type_node, 0);\n+\n+  if (op_const & 2)\n+    {\n+      unsigned HOST_WIDE_INT temp, loc, byteloc;\n+      tree *zap_op = NULL;\n+\n+      loc = opint[1] & 7;\n+      if (BYTES_BIG_ENDIAN)\n+        loc ^= 7;\n+      bytemask <<= loc;\n+\n+      temp = opint[0];\n+      if (is_high)\n+\t{\n+\t  byteloc = (64 - (loc * 8)) & 0x3f;\n+\t  if (byteloc == 0)\n+\t    zap_op = op;\n+\t  else\n+\t    temp >>= byteloc;\n+\t  bytemask >>= 8;\n+\t}\n+      else\n+\t{\n+\t  byteloc = loc * 8;\n+\t  if (byteloc == 0)\n+\t    zap_op = op;\n+\t  else\n+\t    temp <<= byteloc;\n+\t}\n+\n+      opint[0] = temp;\n+      opint[1] = bytemask;\n+      return alpha_fold_builtin_zapnot (zap_op, opint, op_const);\n+    }\n+\n+  return NULL;\n+}\n+\n+static tree\n+alpha_fold_builtin_mskxx (tree op[], unsigned HOST_WIDE_INT opint[],\n+\t\t\t  long op_const, unsigned HOST_WIDE_INT bytemask,\n+\t\t\t  bool is_high)\n+{\n+  if (op_const & 2)\n+    {\n+      unsigned HOST_WIDE_INT loc;\n+\n+      loc = opint[1] & 7;\n+      if (BYTES_BIG_ENDIAN)\n+        loc ^= 7;\n+      bytemask <<= loc;\n+\n+      if (is_high)\n+\tbytemask >>= 8;\n+\n+      opint[1] = bytemask ^ 0xff;\n+    }\n+\n+  return alpha_fold_builtin_zapnot (op, opint, op_const);\n+}\n+\n+static tree\n+alpha_fold_builtin_umulh (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  switch (op_const)\n+    {\n+    case 3:\n+      {\n+\tunsigned HOST_WIDE_INT l;\n+\tHOST_WIDE_INT h;\n+\n+\tmul_double (opint[0], 0, opint[1], 0, &l, &h);\n+\n+#if HOST_BITS_PER_WIDE_INT > 64\n+# error fixme\n+#endif\n+\n+\treturn build_int_cst (long_integer_type_node, h);\n+      }\n+\n+    case 1:\n+      opint[1] = opint[0];\n+      /* FALLTHRU */\n+    case 2:\n+      /* Note that (X*1) >> 64 == 0.  */\n+      if (opint[1] == 0 || opint[1] == 1)\n+\treturn build_int_cst (long_integer_type_node, 0);\n+      break;\n+    }\n+  return NULL;\n+}\n+\n+static tree\n+alpha_fold_vector_minmax (enum tree_code code, tree op[], tree vtype)\n+{\n+  tree op0 = fold_convert (vtype, op[0]);\n+  tree op1 = fold_convert (vtype, op[1]);\n+  tree val = fold (build2 (code, vtype, op0, op1));\n+  return fold_convert (long_integer_type_node, val);\n+}\n+\n+static tree\n+alpha_fold_builtin_perr (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp = 0;\n+  int i;\n+\n+  if (op_const != 3)\n+    return NULL;\n+\n+  for (i = 0; i < 8; ++i)\n+    {\n+      unsigned HOST_WIDE_INT a = (opint[0] >> (i * 8)) & 0xff;\n+      unsigned HOST_WIDE_INT b = (opint[1] >> (i * 8)) & 0xff;\n+      if (a >= b)\n+\ttemp += a - b;\n+      else\n+\ttemp += b - a;\n+    }\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_pklb (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  temp = opint[0] & 0xff;\n+  temp |= (opint[0] >> 24) & 0xff00;\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_pkwb (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  temp = opint[0] & 0xff;\n+  temp |= (opint[0] >>  8) & 0xff00;\n+  temp |= (opint[0] >> 16) & 0xff0000;\n+  temp |= (opint[0] >> 24) & 0xff000000;\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_unpkbl (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  temp = opint[0] & 0xff;\n+  temp |= (opint[0] & 0xff00) << 24;\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_unpkbw (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  temp = opint[0] & 0xff;\n+  temp |= (opint[0] & 0x0000ff00) << 8;\n+  temp |= (opint[0] & 0x00ff0000) << 16;\n+  temp |= (opint[0] & 0xff000000) << 24;\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_cttz (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  if (opint[0] == 0)\n+    temp = 64;\n+  else\n+    temp = exact_log2 (opint[0] & -opint[0]);\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_ctlz (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  if (opint[0] == 0)\n+    temp = 64;\n+  else\n+    temp = 64 - floor_log2 (opint[0]) - 1;\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+static tree\n+alpha_fold_builtin_ctpop (unsigned HOST_WIDE_INT opint[], long op_const)\n+{\n+  unsigned HOST_WIDE_INT temp, op;\n+\n+  if (op_const == 0)\n+    return NULL;\n+\n+  op = opint[0];\n+  temp = 0;\n+  while (op)\n+    temp++, op &= op - 1;\n+\n+  return build_int_cst (long_integer_type_node, temp);\n+}\n+\n+/* Fold one of our builtin functions.  */\n+\n+static tree\n+alpha_fold_builtin (tree exp, bool ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+  tree op[MAX_ARGS], t;\n+  unsigned HOST_WIDE_INT opint[MAX_ARGS];\n+  long op_const = 0, arity = 0;\n+\n+  for (t = TREE_OPERAND (exp, 1); t ; t = TREE_CHAIN (t), ++arity)\n+    {\n+      tree arg = TREE_VALUE (t);\n+      if (arg == error_mark_node)\n+\treturn NULL;\n+      if (arity >= MAX_ARGS)\n+\treturn NULL;\n+\n+      op[arity] = arg;\n+      opint[arity] = 0;\n+      if (TREE_CODE (arg) == INTEGER_CST)\n+\t{\n+          op_const |= 1L << arity;\n+\t  opint[arity] = int_cst_value (arg);\n+\t}\n+    }\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case ALPHA_BUILTIN_CMPBGE:\n+      return alpha_fold_builtin_cmpbge (opint, op_const);\n+\n+    case ALPHA_BUILTIN_EXTBL:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0x01, false);\n+    case ALPHA_BUILTIN_EXTWL:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0x03, false);\n+    case ALPHA_BUILTIN_EXTLL:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0x0f, false);\n+    case ALPHA_BUILTIN_EXTQL:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0xff, false);\n+    case ALPHA_BUILTIN_EXTWH:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0x03, true);\n+    case ALPHA_BUILTIN_EXTLH:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0x0f, true);\n+    case ALPHA_BUILTIN_EXTQH:\n+      return alpha_fold_builtin_extxx (op, opint, op_const, 0xff, true);\n+\n+    case ALPHA_BUILTIN_INSBL:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0x01, false);\n+    case ALPHA_BUILTIN_INSWL:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0x03, false);\n+    case ALPHA_BUILTIN_INSLL:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0x0f, false);\n+    case ALPHA_BUILTIN_INSQL:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0xff, false);\n+    case ALPHA_BUILTIN_INSWH:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0x03, true);\n+    case ALPHA_BUILTIN_INSLH:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0x0f, true);\n+    case ALPHA_BUILTIN_INSQH:\n+      return alpha_fold_builtin_insxx (op, opint, op_const, 0xff, true);\n+\n+    case ALPHA_BUILTIN_MSKBL:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0x01, false);\n+    case ALPHA_BUILTIN_MSKWL:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0x03, false);\n+    case ALPHA_BUILTIN_MSKLL:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0x0f, false);\n+    case ALPHA_BUILTIN_MSKQL:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0xff, false);\n+    case ALPHA_BUILTIN_MSKWH:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0x03, true);\n+    case ALPHA_BUILTIN_MSKLH:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0x0f, true);\n+    case ALPHA_BUILTIN_MSKQH:\n+      return alpha_fold_builtin_mskxx (op, opint, op_const, 0xff, true);\n+\n+    case ALPHA_BUILTIN_UMULH:\n+      return alpha_fold_builtin_umulh (opint, op_const);\n+\n+    case ALPHA_BUILTIN_ZAP:\n+      opint[1] ^= 0xff;\n+      /* FALLTHRU */\n+    case ALPHA_BUILTIN_ZAPNOT:\n+      return alpha_fold_builtin_zapnot (op, opint, op_const);\n+\n+    case ALPHA_BUILTIN_MINUB8:\n+      return alpha_fold_vector_minmax (MIN_EXPR, op, alpha_v8qi_u);\n+    case ALPHA_BUILTIN_MINSB8:\n+      return alpha_fold_vector_minmax (MIN_EXPR, op, alpha_v8qi_s);\n+    case ALPHA_BUILTIN_MINUW4:\n+      return alpha_fold_vector_minmax (MIN_EXPR, op, alpha_v4hi_u);\n+    case ALPHA_BUILTIN_MINSW4:\n+      return alpha_fold_vector_minmax (MIN_EXPR, op, alpha_v4hi_s);\n+    case ALPHA_BUILTIN_MAXUB8:\n+      return alpha_fold_vector_minmax (MAX_EXPR, op, alpha_v8qi_u);\n+    case ALPHA_BUILTIN_MAXSB8:\n+      return alpha_fold_vector_minmax (MAX_EXPR, op, alpha_v8qi_s);\n+    case ALPHA_BUILTIN_MAXUW4:\n+      return alpha_fold_vector_minmax (MAX_EXPR, op, alpha_v4hi_u);\n+    case ALPHA_BUILTIN_MAXSW4:\n+      return alpha_fold_vector_minmax (MAX_EXPR, op, alpha_v4hi_s);\n+\n+    case ALPHA_BUILTIN_PERR:\n+      return alpha_fold_builtin_perr (opint, op_const);\n+    case ALPHA_BUILTIN_PKLB:\n+      return alpha_fold_builtin_pklb (opint, op_const);\n+    case ALPHA_BUILTIN_PKWB:\n+      return alpha_fold_builtin_pkwb (opint, op_const);\n+    case ALPHA_BUILTIN_UNPKBL:\n+      return alpha_fold_builtin_unpkbl (opint, op_const);\n+    case ALPHA_BUILTIN_UNPKBW:\n+      return alpha_fold_builtin_unpkbw (opint, op_const);\n+\n+    case ALPHA_BUILTIN_CTTZ:\n+      return alpha_fold_builtin_cttz (opint, op_const);\n+    case ALPHA_BUILTIN_CTLZ:\n+      return alpha_fold_builtin_ctlz (opint, op_const);\n+    case ALPHA_BUILTIN_CTPOP:\n+      return alpha_fold_builtin_ctpop (opint, op_const);\n+\n+    case ALPHA_BUILTIN_AMASK:\n+    case ALPHA_BUILTIN_IMPLVER:\n+    case ALPHA_BUILTIN_RPCC:\n+    case ALPHA_BUILTIN_THREAD_POINTER:\n+    case ALPHA_BUILTIN_SET_THREAD_POINTER:\n+      /* None of these are foldable at compile-time.  */\n+    default:\n+      return NULL;\n+    }\n+}\n \f\n /* This page contains routines that are used to determine what the function\n    prologue and epilogue code will do and write them out.  */\n@@ -9597,6 +10088,8 @@ alpha_init_libfuncs (void)\n #define TARGET_INIT_BUILTINS alpha_init_builtins\n #undef  TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN alpha_expand_builtin\n+#undef  TARGET_FOLD_BUILTIN\n+#define TARGET_FOLD_BUILTIN alpha_fold_builtin\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL alpha_function_ok_for_sibcall"}, {"sha": "5af462e3987930146f92db883cda36062a0ccb66", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360139876e080a505c41ad40e7fec7383a93fc8f/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360139876e080a505c41ad40e7fec7383a93fc8f/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=360139876e080a505c41ad40e7fec7383a93fc8f", "patch": "@@ -26,7 +26,6 @@\n \n (define_constants\n   [(UNSPEC_ARG_HOME\t0)\n-   (UNSPEC_CTTZ\t\t1)\n    (UNSPEC_INSXH\t2)\n    (UNSPEC_MSKXH\t3)\n    (UNSPEC_CVTQL\t4)\n@@ -56,9 +55,7 @@\n    (UNSPEC_AMASK\t24)\n    (UNSPEC_IMPLVER\t25)\n    (UNSPEC_PERR\t\t26)\n-   (UNSPEC_CTLZ\t\t27)\n-   (UNSPEC_CTPOP\t28)\n-   (UNSPEC_COPYSIGN     29)\n+   (UNSPEC_COPYSIGN     27)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -1333,7 +1330,7 @@\n \n (define_expand \"ffsdi2\"\n   [(set (match_dup 2)\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"\")] UNSPEC_CTTZ))\n+\t(ctz:DI (match_operand:DI 1 \"register_operand\" \"\")))\n    (set (match_dup 3)\n \t(plus:DI (match_dup 2) (const_int 1)))\n    (set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -1345,15 +1342,6 @@\n   operands[3] = gen_reg_rtx (DImode);\n })\n \n-(define_insn \"*cttz\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] UNSPEC_CTTZ))]\n-  \"TARGET_CIX\"\n-  \"cttz %1,%0\"\n-  ; EV6 calls all mvi and cttz/ctlz/popc class imisc, so just\n-  ; reuse the existing type name.\n-  [(set_attr \"type\" \"mvi\")])\n-\n (define_insn \"clzdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(clz:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n@@ -7716,29 +7704,6 @@\n   \"TARGET_MAX\"\n   \"unpkbw %r1,%0\"\n   [(set_attr \"type\" \"mvi\")])\n-\n-(define_expand \"builtin_cttz\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"\")]\n-\t\t   UNSPEC_CTTZ))]\n-  \"TARGET_CIX\"\n-  \"\")\n-\n-(define_insn \"builtin_ctlz\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")]\n-\t\t   UNSPEC_CTLZ))]\n-  \"TARGET_CIX\"\n-  \"ctlz %1,%0\"\n-  [(set_attr \"type\" \"mvi\")])\n-\n-(define_insn \"builtin_ctpop\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")]\n-\t\t   UNSPEC_CTPOP))]\n-  \"TARGET_CIX\"\n-  \"ctpop %1,%0\"\n-  [(set_attr \"type\" \"mvi\")])\n \f\n ;; The call patterns are at the end of the file because their\n ;; wildcard operand0 interferes with nice recognition."}]}