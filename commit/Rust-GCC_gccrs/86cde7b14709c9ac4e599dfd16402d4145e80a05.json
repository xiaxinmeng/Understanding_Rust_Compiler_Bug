{"sha": "86cde7b14709c9ac4e599dfd16402d4145e80a05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjZGU3YjE0NzA5YzlhYzRlNTk5ZGZkMTY0MDJkNDE0NWU4MGEwNQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:39:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:39:20Z"}, "message": "exp_util.ads, [...]: This patch replaces a number of occurrences of explicit tests for N_Null with...\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_util.ads, exp_util.adb: \n\tThis patch replaces a number of occurrences of explicit tests for N_Null\n\twith calls to Known_Null. This improves tracking of null values, since\n\tKnown_Null also catches null constants, and variables currently known to\n\tbe null, so we get better tracking.\n\t(Ensure_Defined): create an itype reference only in the scope of the\n\titype.\n\t(Side_Effect_Free): A selected component of an access type that\n\tdenotes a component with a rep clause must be treated as not\n\tside-effect free, because if it is part of a linked structure its\n\tvalue may be affected by a renaming.\n\t(Expand_Subtype_From_Expr): For limited objects initialized with build\n\tin place function calls, do nothing; otherwise we prematurely introduce\n\tan N_Reference node in the expression initializing the object, which\n\tbreaks the circuitry that detects and adds the additional arguments to\n\tthe called function. Bug found working in the new patch for statically\n\tallocated dispatch tables.\n\t(Is_Library_Level_Tagged_Type): New subprogram.\n\t(Remove_Side_Effects): If the expression of an elementary type is an\n\toperator treat as a function call.\n\t(Make_Literal_Range): If the index type of the array is not integer, use\n\tattributes properly to compute the constraint on the resulting aggregate\n\twhich is a string.\n\n\t* freeze.ads, freeze.adb (Freeze_Entity): If the entity is a\n\tclass-wide type whose base type is an incomplete private type, leave\n\tclass-wide type unfrozen so that freeze nodes can be generated\n\tproperly at a later point.\n\t(Freeze_Entity, array case): Handle case of pragma Pack and component\n\tsize attributre clause for same array.\n\nFrom-SVN: r127419", "tree": {"sha": "7d8fb8afdbfead121390726f986ccb88012cdda1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d8fb8afdbfead121390726f986ccb88012cdda1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86cde7b14709c9ac4e599dfd16402d4145e80a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cde7b14709c9ac4e599dfd16402d4145e80a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86cde7b14709c9ac4e599dfd16402d4145e80a05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86cde7b14709c9ac4e599dfd16402d4145e80a05/comments", "author": null, "committer": null, "parents": [{"sha": "b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72"}], "stats": {"total": 535, "additions": 348, "deletions": 187}, "files": [{"sha": "0f84960fcdcf008637dc4ec05b83ef8b8edd7887", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 111, "deletions": 63, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=86cde7b14709c9ac4e599dfd16402d4145e80a05", "patch": "@@ -31,6 +31,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Inline;   use Inline;\n with Itypes;   use Itypes;\n@@ -89,8 +90,8 @@ package body Exp_Util is\n        Pos    : out Entity_Id;\n        Prefix : Entity_Id;\n        Sum    : Node_Id;\n-       Decls  : in out List_Id;\n-       Stats  : in out List_Id);\n+       Decls  : List_Id;\n+       Stats  : List_Id);\n    --  Common processing for Task_Array_Image and Task_Record_Image.\n    --  Create local variables and assign prefix of name to result string.\n \n@@ -125,8 +126,14 @@ package body Exp_Util is\n       Literal_Typ : Entity_Id) return Node_Id;\n    --  Produce a Range node whose bounds are:\n    --    Low_Bound (Literal_Type) ..\n-   --        Low_Bound (Literal_Type) + Length (Literal_Typ) - 1\n+   --        Low_Bound (Literal_Type) + (Length (Literal_Typ) - 1)\n    --  this is used for expanding declarations like X : String := \"sdfgdfg\";\n+   --\n+   --  If the index type of the target array is not integer, we generate:\n+   --     Low_Bound (Literal_Type) ..\n+   --        Literal_Type'Val\n+   --          (Literal_Type'Pos (Low_Bound (Literal_Type))\n+   --             + (Length (Literal_Typ) -1))\n \n    function New_Class_Wide_Subtype\n      (CW_Typ : Entity_Id;\n@@ -400,8 +407,8 @@ package body Exp_Util is\n       T : Entity_Id;\n       --  Entity for name at one index position\n \n-      Decls : List_Id := New_List;\n-      Stats : List_Id := New_List;\n+      Decls : constant List_Id := New_List;\n+      Stats : constant List_Id := New_List;\n \n    begin\n       Pref := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n@@ -680,7 +687,7 @@ package body Exp_Util is\n \n    begin\n       Append_To (Stats,\n-        Make_Return_Statement (Loc,\n+        Make_Simple_Return_Statement (Loc,\n           Expression => New_Occurrence_Of (Res, Loc)));\n \n       Spec := Make_Function_Specification (Loc,\n@@ -709,8 +716,8 @@ package body Exp_Util is\n        Pos    : out Entity_Id;\n        Prefix : Entity_Id;\n        Sum    : Node_Id;\n-       Decls  : in out List_Id;\n-       Stats  : in out List_Id)\n+       Decls  : List_Id;\n+       Stats  : List_Id)\n    is\n    begin\n       Len := Make_Defining_Identifier (Loc, New_Internal_Name ('L'));\n@@ -805,8 +812,8 @@ package body Exp_Util is\n       Sel : Entity_Id;\n       --  Entity for selector name\n \n-      Decls : List_Id := New_List;\n-      Stats : List_Id := New_List;\n+      Decls : constant List_Id := New_List;\n+      Stats : constant List_Id := New_List;\n \n    begin\n       Pref := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n@@ -1052,36 +1059,17 @@ package body Exp_Util is\n \n    procedure Ensure_Defined (Typ : Entity_Id; N : Node_Id) is\n       IR : Node_Id;\n-      P  : Node_Id;\n \n    begin\n-      if Is_Itype (Typ) then\n+      --  An itype reference must only be created if this is a local\n+      --  itype, so that gigi can elaborate it on the proper objstack.\n+\n+      if Is_Itype (Typ)\n+        and then  Scope (Typ) = Current_Scope\n+      then\n          IR := Make_Itype_Reference (Sloc (N));\n          Set_Itype (IR, Typ);\n-\n-         if not In_Open_Scopes (Scope (Typ))\n-           and then Is_Subprogram (Current_Scope)\n-           and then Scope (Current_Scope) /= Standard_Standard\n-         then\n-            --  Insert node in front of subprogram, to avoid scope anomalies\n-            --  in gigi.\n-\n-            P := Parent (N);\n-            while Present (P)\n-              and then Nkind (P) /= N_Subprogram_Body\n-            loop\n-               P := Parent (P);\n-            end loop;\n-\n-            if Present (P) then\n-               Insert_Action (P, IR);\n-            else\n-               Insert_Action (N, IR);\n-            end if;\n-\n-         else\n-            Insert_Action (N, IR);\n-         end if;\n+         Insert_Action (N, IR);\n       end if;\n    end Ensure_Defined;\n \n@@ -1318,6 +1306,15 @@ package body Exp_Util is\n       then\n          null;\n \n+      --  For limited objects initialized with build in place function calls,\n+      --  nothing to be done; otherwise we prematurely introduce an N_Reference\n+      --  node in the expression initializing the object, which breaks the\n+      --  circuitry that detects and adds the additional arguments to the\n+      --  called function.\n+\n+      elsif Is_Build_In_Place_Function_Call (Exp) then\n+         null;\n+\n       else\n          Remove_Side_Effects (Exp);\n          Rewrite (Subtype_Indic,\n@@ -2948,6 +2945,16 @@ package body Exp_Util is\n       return True;\n    end Is_All_Null_Statements;\n \n+   ----------------------------------\n+   -- Is_Library_Level_Tagged_Type --\n+   ----------------------------------\n+\n+   function Is_Library_Level_Tagged_Type (Typ : Entity_Id) return Boolean is\n+   begin\n+      return Is_Tagged_Type (Typ)\n+        and then Is_Library_Level_Entity (Typ);\n+   end Is_Library_Level_Tagged_Type;\n+\n    -----------------------------------------\n    -- Is_Predefined_Dispatching_Operation --\n    -----------------------------------------\n@@ -3386,7 +3393,7 @@ package body Exp_Util is\n \n          if Warn then\n             Error_Msg_F\n-              (\"?this code can never be executed and has been deleted\", N);\n+              (\"?this code can never be executed and has been deleted!\", N);\n          end if;\n \n          --  Recurse into block statements and bodies to process declarations\n@@ -3514,7 +3521,7 @@ package body Exp_Util is\n \n             Get_Current_Value_Condition (N, Op, Val);\n \n-            if Nkind (Val) = N_Null then\n+            if Known_Null (Val) then\n                if Op = N_Op_Eq then\n                   return False;\n                elsif Op = N_Op_Ne then\n@@ -3578,11 +3585,19 @@ package body Exp_Util is\n             Val : Node_Id;\n \n          begin\n+            --  Constant null value is for sure null\n+\n+            if Ekind (E) = E_Constant\n+              and then Known_Null (Constant_Value (E))\n+            then\n+               return True;\n+            end if;\n+\n             --  First check if we are in decisive conditional\n \n             Get_Current_Value_Condition (N, Op, Val);\n \n-            if Nkind (Val) = N_Null then\n+            if Known_Null (Val) then\n                if Op = N_Op_Eq then\n                   return True;\n                elsif Op = N_Op_Ne then\n@@ -3797,25 +3812,46 @@ package body Exp_Util is\n      (Loc         : Source_Ptr;\n       Literal_Typ : Entity_Id) return Node_Id\n    is\n-      Lo : constant Node_Id :=\n-             New_Copy_Tree (String_Literal_Low_Bound (Literal_Typ));\n+      Lo          : constant Node_Id :=\n+                      New_Copy_Tree (String_Literal_Low_Bound (Literal_Typ));\n+      Index       : constant Entity_Id := Etype (Lo);\n+\n+      Hi          : Node_Id;\n+      Length_Expr : constant Node_Id :=\n+                      Make_Op_Subtract (Loc,\n+                        Left_Opnd =>\n+                          Make_Integer_Literal (Loc,\n+                            Intval => String_Literal_Length (Literal_Typ)),\n+                        Right_Opnd =>\n+                          Make_Integer_Literal (Loc, 1));\n \n    begin\n       Set_Analyzed (Lo, False);\n \n+         if Is_Integer_Type (Index) then\n+            Hi :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd  => New_Copy_Tree (Lo),\n+                Right_Opnd => Length_Expr);\n+         else\n+            Hi :=\n+              Make_Attribute_Reference (Loc,\n+                Attribute_Name => Name_Val,\n+                Prefix => New_Occurrence_Of (Index, Loc),\n+                Expressions => New_List (\n+                 Make_Op_Add (Loc,\n+                   Left_Opnd =>\n+                     Make_Attribute_Reference (Loc,\n+                       Attribute_Name => Name_Pos,\n+                       Prefix => New_Occurrence_Of (Index, Loc),\n+                       Expressions => New_List (New_Copy_Tree (Lo))),\n+                  Right_Opnd => Length_Expr)));\n+         end if;\n+\n          return\n            Make_Range (Loc,\n-             Low_Bound => Lo,\n-\n-             High_Bound =>\n-               Make_Op_Subtract (Loc,\n-                  Left_Opnd =>\n-                    Make_Op_Add (Loc,\n-                      Left_Opnd  => New_Copy_Tree (Lo),\n-                      Right_Opnd =>\n-                        Make_Integer_Literal (Loc,\n-                          String_Literal_Length (Literal_Typ))),\n-                  Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+             Low_Bound  => Lo,\n+             High_Bound => Hi);\n    end Make_Literal_Range;\n \n    ----------------------------\n@@ -4401,10 +4437,23 @@ package body Exp_Util is\n                return Side_Effect_Free (Expression (N));\n \n             --  A selected component is side effect free only if it is a\n-            --  side effect free prefixed reference.\n+            --  side effect free prefixed reference. If it designates a\n+            --  component with a rep. clause it must be treated has having\n+            --  a potential side effect, because it may be modified through\n+            --  a renaming, and a subsequent use of the renaming as a macro\n+            --  will yield the wrong value. This complex interaction between\n+            --  renaming and removing side effects is a reminder that the\n+            --  latter has become a headache to maintain, and that it should\n+            --  be removed in favor of the gcc mechanism to capture values ???\n \n             when N_Selected_Component =>\n-               return Safe_Prefixed_Reference (N);\n+               if Nkind (Parent (N)) = N_Explicit_Dereference\n+                 and then Has_Non_Standard_Rep (Designated_Type (Etype (N)))\n+               then\n+                  return False;\n+               else\n+                  return Safe_Prefixed_Reference (N);\n+               end if;\n \n             --  A range is side effect free if the bounds are side effect free\n \n@@ -4419,8 +4468,8 @@ package body Exp_Util is\n                return Side_Effect_Free (Discrete_Range (N))\n                  and then Safe_Prefixed_Reference (N);\n \n-            --  A type conversion is side effect free if the expression\n-            --  to be converted is side effect free.\n+            --  A type conversion is side effect free if the expression to be\n+            --  converted is side effect free.\n \n             when N_Type_Conversion =>\n                return Side_Effect_Free (Expression (N));\n@@ -4496,8 +4545,7 @@ package body Exp_Util is\n             return False;\n \n          elsif Is_Entity_Name (N) then\n-            return\n-              Ekind (Entity (N)) = E_In_Parameter;\n+            return Ekind (Entity (N)) = E_In_Parameter;\n \n          elsif Nkind (N) = N_Indexed_Component\n            or else Nkind (N) = N_Selected_Component\n@@ -4523,19 +4571,19 @@ package body Exp_Util is\n \n       Scope_Suppress := (others => True);\n \n-      --  If it is a scalar type and we need to capture the value, just\n-      --  make a copy.  Likewise for a function call.  And if we have a\n-      --  volatile variable and Nam_Req is not set (see comments above\n-      --  for Side_Effect_Free).\n+      --  If it is a scalar type and we need to capture the value, just make\n+      --  a copy. Likewise for a function or operator call. And if we have a\n+      --  volatile variable and Nam_Req is not set (see comments above for\n+      --  Side_Effect_Free).\n \n       if Is_Elementary_Type (Exp_Type)\n         and then (Variable_Ref\n                    or else Nkind (Exp) = N_Function_Call\n+                   or else Nkind (Exp) in N_Op\n                    or else (not Name_Req\n                              and then Is_Entity_Name (Exp)\n                              and then Treat_As_Volatile (Entity (Exp))))\n       then\n-\n          Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n          Set_Etype (Def_Id, Exp_Type);\n          Res := New_Reference_To (Def_Id, Loc);"}, {"sha": "cd344077d14e88466858eb0eb289e45c62c8ef43", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=86cde7b14709c9ac4e599dfd16402d4145e80a05", "patch": "@@ -438,6 +438,10 @@ package Exp_Util is\n    --  False otherwise. True for an empty list. It is an error to call this\n    --  routine with No_List as the argument.\n \n+   function Is_Library_Level_Tagged_Type (Typ : Entity_Id) return Boolean;\n+   --  Return True if Typ is a library level tagged type. Currently we use\n+   --  this information to build statically allocated dispatch tables.\n+\n    function Is_Predefined_Dispatching_Operation (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-251): Determines if E is a predefined primitive operation\n \n@@ -628,7 +632,7 @@ package Exp_Util is\n    --  control to escape doing the undefer call.\n \n private\n-   pragma Inline (Force_Evaluation);\n    pragma Inline (Duplicate_Subexpr);\n-\n+   pragma Inline (Force_Evaluation);\n+   pragma Inline (Is_Library_Level_Tagged_Type);\n end Exp_Util;"}, {"sha": "44cb73be6639634b0a76575ba75b0e2d3e393533", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 224, "deletions": 121, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=86cde7b14709c9ac4e599dfd16402d4145e80a05", "patch": "@@ -369,20 +369,20 @@ package body Freeze is\n                   and then Etype (Old_S) /= Standard_Void_Type)\n       then\n          Call_Node :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n               Expression =>\n                 Make_Function_Call (Loc,\n                   Name => Call_Name,\n                   Parameter_Associations => Actuals));\n \n       elsif Ekind (Old_S) = E_Enumeration_Literal then\n          Call_Node :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n               Expression => New_Occurrence_Of (Old_S, Loc));\n \n       elsif Nkind (Nam) = N_Character_Literal then\n          Call_Node :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n              Expression => Call_Name);\n \n       else\n@@ -2235,7 +2235,9 @@ package body Freeze is\n                            Set_Is_Frozen (E, False);\n                            return No_List;\n \n-                        elsif not After_Last_Declaration then\n+                        elsif not After_Last_Declaration\n+                          and then not Freezing_Library_Level_Tagged_Type\n+                        then\n                            Error_Msg_Node_1 := F_Type;\n                            Error_Msg\n                              (\"type& must be fully defined before this point\",\n@@ -2465,15 +2467,15 @@ package body Freeze is\n                then\n                   Error_Msg_N\n                     (\"stand alone atomic constant must be \" &\n-                     \"imported ('R'M 'C.6(13))\", E);\n+                     \"imported ('R'M C.6(13))\", E);\n \n                elsif Has_Rep_Pragma (E, Name_Volatile)\n                        or else\n                      Has_Rep_Pragma (E, Name_Volatile_Components)\n                then\n                   Error_Msg_N\n                     (\"stand alone volatile constant must be \" &\n-                     \"imported ('R'M 'C.6(13))\", E);\n+                     \"imported (RM C.6(13))\", E);\n                end if;\n             end if;\n \n@@ -2530,6 +2532,100 @@ package body Freeze is\n \n          if E /= Base_Type (E) then\n \n+            --  Before we do anything else, a specialized test for the case of\n+            --  a size given for an array where the array needs to be packed,\n+            --  but was not so the size cannot be honored. This would of course\n+            --  be caught by the backend, and indeed we don't catch all cases.\n+            --  The point is that we can give a better error message in those\n+            --  cases that we do catch with the circuitry here. Also if pragma\n+            --  Implicit_Packing is set, this is where the packing occurs.\n+\n+            --  The reason we do this so early is that the processing in the\n+            --  automatic packing case affects the layout of the base type, so\n+            --  it must be done before we freeze the base type.\n+\n+            if Is_Array_Type (E) then\n+               declare\n+                  Lo, Hi : Node_Id;\n+                  Ctyp   : constant Entity_Id := Component_Type (E);\n+\n+               begin\n+                  --  Check enabling conditions. These are straightforward\n+                  --  except for the test for a limited composite type. This\n+                  --  eliminates the rare case of a array of limited components\n+                  --  where there are issues of whether or not we can go ahead\n+                  --  and pack the array (since we can't freely pack and unpack\n+                  --  arrays if they are limited).\n+\n+                  --  Note that we check the root type explicitly because the\n+                  --  whole point is we are doing this test before we have had\n+                  --  a chance to freeze the base type (and it is that freeze\n+                  --  action that causes stuff to be inherited).\n+\n+                  if Present (Size_Clause (E))\n+                    and then Known_Static_Esize (E)\n+                    and then not Is_Packed (E)\n+                    and then not Has_Pragma_Pack (E)\n+                    and then Number_Dimensions (E) = 1\n+                    and then not Has_Component_Size_Clause (E)\n+                    and then Known_Static_Esize (Ctyp)\n+                    and then not Is_Limited_Composite (E)\n+                    and then not Is_Packed (Root_Type (E))\n+                    and then not Has_Component_Size_Clause (Root_Type (E))\n+                  then\n+                     Get_Index_Bounds (First_Index (E), Lo, Hi);\n+\n+                     if Compile_Time_Known_Value (Lo)\n+                       and then Compile_Time_Known_Value (Hi)\n+                       and then Known_Static_RM_Size (Ctyp)\n+                       and then RM_Size (Ctyp) < 64\n+                     then\n+                        declare\n+                           Lov  : constant Uint      := Expr_Value (Lo);\n+                           Hiv  : constant Uint      := Expr_Value (Hi);\n+                           Len  : constant Uint      := UI_Max\n+                                                         (Uint_0,\n+                                                          Hiv - Lov + 1);\n+                           Rsiz : constant Uint      := RM_Size (Ctyp);\n+                           SZ   : constant Node_Id   := Size_Clause (E);\n+                           Btyp : constant Entity_Id := Base_Type (E);\n+\n+                        --  What we are looking for here is the situation where\n+                        --  the RM_Size given would be exactly right if there\n+                        --  was a pragma Pack (resulting in the component size\n+                        --  being the same as the RM_Size). Furthermore, the\n+                        --  component type size must be an odd size (not a\n+                        --  multiple of storage unit)\n+\n+                        begin\n+                           if RM_Size (E) = Len * Rsiz\n+                             and then Rsiz mod System_Storage_Unit /= 0\n+                           then\n+                              --  For implicit packing mode, just set the\n+                              --  component size silently\n+\n+                              if Implicit_Packing then\n+                                 Set_Component_Size       (Btyp, Rsiz);\n+                                 Set_Is_Bit_Packed_Array  (Btyp);\n+                                 Set_Is_Packed            (Btyp);\n+                                 Set_Has_Non_Standard_Rep (Btyp);\n+\n+                                 --  Otherwise give an error message\n+\n+                              else\n+                                 Error_Msg_NE\n+                                   (\"size given for& too small\", SZ, E);\n+                                 Error_Msg_N\n+                                   (\"\\use explicit pragma Pack \"\n+                                    & \"or use pragma Implicit_Packing\", SZ);\n+                              end if;\n+                           end if;\n+                        end;\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n+\n             --  If ancestor subtype present, freeze that first.\n             --  Note that this will also get the base type frozen.\n \n@@ -2558,7 +2654,6 @@ package body Freeze is\n          if Is_Array_Type (E) then\n             declare\n                Ctyp : constant Entity_Id := Component_Type (E);\n-               Pnod : Node_Id;\n \n                Non_Standard_Enum : Boolean := False;\n                --  Set true if any of the index types is an enumeration type\n@@ -2644,80 +2739,110 @@ package body Freeze is\n                         if Csiz /= 0 then\n                            declare\n                               A : constant Uint := Alignment_In_Bits (Ctyp);\n-\n                            begin\n                               if Csiz < A then\n                                  Csiz := A;\n                               end if;\n                            end;\n                         end if;\n-\n                      end if;\n \n+                     --  Case of component size that may result in packing\n+\n                      if 1 <= Csiz and then Csiz <= 64 then\n+                        declare\n+                           Ent         : constant Entity_Id :=\n+                                           First_Subtype (E);\n+                           Pack_Pragma : constant Node_Id :=\n+                                           Get_Rep_Pragma (Ent, Name_Pack);\n+                           Comp_Size_C : constant Node_Id :=\n+                                           Get_Attribute_Definition_Clause\n+                                             (Ent, Attribute_Component_Size);\n+                        begin\n+                           --  Warn if we have pack and component size so that\n+                           --  the pack is ignored.\n \n-                        --  We set the component size for all cases 1-64\n+                           --  Note: here we must check for the presence of a\n+                           --  component size before checking for a Pack pragma\n+                           --  to deal with the case where the array type is a\n+                           --  derived type whose parent is currently private.\n+\n+                           if Present (Comp_Size_C)\n+                             and then Has_Pragma_Pack (Ent)\n+                           then\n+                              Error_Msg_Sloc := Sloc (Comp_Size_C);\n+                              Error_Msg_NE\n+                                (\"?pragma Pack for& ignored!\",\n+                                 Pack_Pragma, Ent);\n+                              Error_Msg_N\n+                                (\"\\?explicit component size given#!\",\n+                                 Pack_Pragma);\n+                           end if;\n \n-                        Set_Component_Size (Base_Type (E), Csiz);\n+                           --  Set component size if not already set by a\n+                           --  component size clause.\n \n-                        --  Check for base type of 8, 16, 32 bits, where the\n-                        --  subtype has a length one less than the base type\n-                        --  and is unsigned (e.g. Natural subtype of Integer).\n+                           if not Present (Comp_Size_C) then\n+                              Set_Component_Size (E, Csiz);\n+                           end if;\n \n-                        --  In such cases, if a component size was not set\n-                        --  explicitly, then generate a warning.\n+                           --  Check for base type of 8, 16, 32 bits, where an\n+                           --  unsigned subtype has a length one less than the\n+                           --  base type (e.g. Natural subtype of Integer).\n \n-                        if Has_Pragma_Pack (E)\n-                          and then not Has_Component_Size_Clause (E)\n-                          and then\n-                            (Csiz = 7 or else Csiz = 15 or else Csiz = 31)\n-                          and then Esize (Base_Type (Ctyp)) = Csiz + 1\n-                        then\n-                           Error_Msg_Uint_1 := Csiz;\n-                           Pnod :=\n-                             Get_Rep_Pragma (First_Subtype (E), Name_Pack);\n+                           --  In such cases, if a component size was not set\n+                           --  explicitly, then generate a warning.\n \n-                           if Present (Pnod) then\n-                              Error_Msg_N\n-                                (\"pragma Pack causes component size to be ^?\",\n-                                 Pnod);\n-                              Error_Msg_N\n-                                (\"\\use Component_Size to set desired value\",\n-                                 Pnod);\n+                           if Has_Pragma_Pack (E)\n+                             and then not Present (Comp_Size_C)\n+                             and then\n+                               (Csiz = 7 or else Csiz = 15 or else Csiz = 31)\n+                             and then Esize (Base_Type (Ctyp)) = Csiz + 1\n+                           then\n+                              Error_Msg_Uint_1 := Csiz;\n+\n+                              if Present (Pack_Pragma) then\n+                                 Error_Msg_N\n+                                   (\"?pragma Pack causes component size \"\n+                                    & \"to be ^!\", Pack_Pragma);\n+                                 Error_Msg_N\n+                                   (\"\\?use Component_Size to set \"\n+                                    & \"desired value!\", Pack_Pragma);\n+                              end if;\n                            end if;\n-                        end if;\n \n-                        --  Actual packing is not needed for 8, 16, 32, 64.\n-                        --  Also not needed for 24 if alignment is 1.\n+                           --  Actual packing is not needed for 8, 16, 32, 64.\n+                           --  Also not needed for 24 if alignment is 1.\n \n-                        if        Csiz = 8\n-                          or else Csiz = 16\n-                          or else Csiz = 32\n-                          or else Csiz = 64\n-                          or else (Csiz = 24 and then Alignment (Ctyp) = 1)\n-                        then\n-                           --  Here the array was requested to be packed, but\n-                           --  the packing request had no effect, so Is_Packed\n-                           --  is reset.\n+                           if        Csiz = 8\n+                             or else Csiz = 16\n+                             or else Csiz = 32\n+                             or else Csiz = 64\n+                             or else (Csiz = 24 and then Alignment (Ctyp) = 1)\n+                           then\n+                              --  Here the array was requested to be packed,\n+                              --  but the packing request had no effect, so\n+                              --  Is_Packed is reset.\n \n-                           --  Note: semantically this means that we lose track\n-                           --  of the fact that a derived type inherited a\n-                           --  pragma Pack that was non-effective, but that\n-                           --  seems fine.\n+                              --  Note: semantically this means that we lose\n+                              --  track of the fact that a derived type\n+                              --  inherited a pragma Pack that was non-\n+                              --  effective, but that seems fine.\n \n-                           --  We regard a Pack pragma as a request to set a\n-                           --  representation characteristic, and this request\n-                           --  may be ignored.\n+                              --  We regard a Pack pragma as a request to set\n+                              --  a representation characteristic, and this\n+                              --  request may be ignored.\n \n-                           Set_Is_Packed (Base_Type (E), False);\n+                              Set_Is_Packed (Base_Type (E), False);\n \n-                        --  In all other cases, packing is indeed needed\n+                              --  In all other cases, packing is indeed needed\n \n-                        else\n-                           Set_Has_Non_Standard_Rep (Base_Type (E));\n-                           Set_Is_Bit_Packed_Array  (Base_Type (E));\n-                           Set_Is_Packed            (Base_Type (E));\n-                        end if;\n+                           else\n+                              Set_Has_Non_Standard_Rep (Base_Type (E));\n+                              Set_Is_Bit_Packed_Array  (Base_Type (E));\n+                              Set_Is_Packed            (Base_Type (E));\n+                           end if;\n+                        end;\n                      end if;\n                   end;\n \n@@ -2755,63 +2880,6 @@ package body Freeze is\n                   end;\n                end if;\n \n-               --  Check one common case of a size given where the array\n-               --  needs to be packed, but was not so the size cannot be\n-               --  honored. This would of course be caught by the backend,\n-               --  and indeed we don't catch all cases. The point is that\n-               --  we can give a better error message in those cases that\n-               --  we do catch with the circuitry here.\n-\n-               declare\n-                  Lo, Hi : Node_Id;\n-                  Ctyp   : constant Entity_Id := Component_Type (E);\n-\n-               begin\n-                  if Present (Size_Clause (E))\n-                    and then Known_Static_Esize (E)\n-                    and then not Is_Bit_Packed_Array (E)\n-                    and then not Has_Pragma_Pack (E)\n-                    and then Number_Dimensions (E) = 1\n-                    and then not Has_Component_Size_Clause (E)\n-                    and then Known_Static_Esize (Ctyp)\n-                  then\n-                     Get_Index_Bounds (First_Index (E), Lo, Hi);\n-\n-                     if Compile_Time_Known_Value (Lo)\n-                       and then Compile_Time_Known_Value (Hi)\n-                       and then Known_Static_RM_Size (Ctyp)\n-                       and then RM_Size (Ctyp) < 64\n-                     then\n-                        declare\n-                           Lov  : constant Uint := Expr_Value (Lo);\n-                           Hiv  : constant Uint := Expr_Value (Hi);\n-                           Len  : constant Uint :=\n-                                    UI_Max (Uint_0, Hiv - Lov + 1);\n-                           Rsiz : constant Uint := RM_Size (Ctyp);\n-\n-                        --  What we are looking for here is the situation where\n-                        --  the RM_Size given would be exactly right if there\n-                        --  was a pragma Pack (resulting in the component size\n-                        --  being the same as the RM_Size). Furthermore, the\n-                        --  component type size must be an odd size (not a\n-                        --  multiple of storage unit)\n-\n-                        begin\n-                           if RM_Size (E) = Len * Rsiz\n-                             and then Rsiz mod System_Storage_Unit /= 0\n-                           then\n-                              Error_Msg_NE\n-                                (\"size given for& too small\",\n-                                   Size_Clause (E), E);\n-                              Error_Msg_N\n-                                (\"\\explicit pragma Pack is required\",\n-                                   Size_Clause (E));\n-                           end if;\n-                        end;\n-                     end if;\n-                  end if;\n-               end;\n-\n                --  If any of the index types was an enumeration type with\n                --  a non-standard rep clause, then we indicate that the\n                --  array type is always packed (even if it is not bit packed).\n@@ -2871,6 +2939,16 @@ package body Freeze is\n          elsif Is_Class_Wide_Type (E) then\n             Freeze_And_Append (Root_Type (E), Loc, Result);\n \n+            --  If the base type of the class-wide type is still incomplete,\n+            --  the class-wide remains unfrozen as well. This is legal when\n+            --  E is the formal of a primitive operation of some other type\n+            --  which is being frozen.\n+\n+            if not Is_Frozen (Root_Type (E)) then\n+               Set_Is_Frozen (E, False);\n+               return Result;\n+            end if;\n+\n             --  If the Class_Wide_Type is an Itype (when type is the anonymous\n             --  parent of a derived type) and it is a library-level entity,\n             --  generate an itype reference for it. Otherwise, its first\n@@ -2967,9 +3045,34 @@ package body Freeze is\n          elsif Is_Incomplete_Or_Private_Type (E)\n            and then not Is_Generic_Type (E)\n          then\n+            --  The construction of the dispatch table associated with library\n+            --  level tagged types forces freezing of all the primitives of the\n+            --  type, which may cause premature freezing of the partial view.\n+            --  For example:\n+\n+            --     package Pkg is\n+            --        type T is tagged private;\n+            --        type DT is new T with private;\n+            --        procedure Prim (X : in out T; Y : in out DT'class);\n+            --     private\n+            --        type T is tagged null record;\n+            --        Obj : T;\n+            --        type DT is new T with null record;\n+            --     end;\n+\n+            --  In this case the type will be frozen later by the usual\n+            --  mechanism: an object declaration, an instantiation, or the\n+            --  end of a declarative part.\n+\n+            if Is_Library_Level_Tagged_Type (E)\n+              and then not Present (Full_View (E))\n+            then\n+               Set_Is_Frozen (E, False);\n+               return Result;\n+\n             --  Case of full view present\n \n-            if Present (Full_View (E)) then\n+            elsif Present (Full_View (E)) then\n \n                --  If full view has already been frozen, then no further\n                --  processing is required\n@@ -4783,8 +4886,9 @@ package body Freeze is\n             return True;\n          end;\n \n-      else return not Is_Private_Type (T)\n-        or else Present (Full_View (Base_Type (T)));\n+      else\n+         return not Is_Private_Type (T)\n+           or else Present (Full_View (Base_Type (T)));\n       end if;\n    end Is_Fully_Defined;\n \n@@ -4818,7 +4922,6 @@ package body Freeze is\n       end if;\n \n       Formal := First_Formal (E);\n-\n       while Present (Formal) loop\n          if Present (Default_Value (Formal)) then\n \n@@ -4841,7 +4944,7 @@ package body Freeze is\n                         and then not Vax_Float (Etype (Dcopy)))\n               or else Nkind (Dcopy) = N_Character_Literal\n               or else Nkind (Dcopy) = N_String_Literal\n-              or else Nkind (Dcopy) = N_Null\n+              or else Known_Null (Dcopy)\n               or else (Nkind (Dcopy) = N_Attribute_Reference\n                         and then\n                        Attribute_Name (Dcopy) = Name_Null_Parameter)\n@@ -5180,7 +5283,7 @@ package body Freeze is\n \n          Error_Msg_N\n            (\"\\use pragma Import for & to \" &\n-            \"suppress initialization ('R'M B.1(24))?\",\n+            \"suppress initialization (RM B.1(24))?\",\n             Nam);\n       end if;\n    end Warn_Overlay;"}, {"sha": "13afe3701f620f4bc6502ed4fc9dfe72f49be1a6", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86cde7b14709c9ac4e599dfd16402d4145e80a05/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=86cde7b14709c9ac4e599dfd16402d4145e80a05", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,6 +121,12 @@ package Freeze is\n    --  base types, where the freeze node is preallocated at the point of\n    --  declaration, so that the First_Subtype_Link field can be set.\n \n+   Freezing_Library_Level_Tagged_Type : Boolean := False;\n+   --  Flag used to indicate that we are freezing the primitives of a library\n+   --  level tagged types. Used to disable checks on premature freezing.\n+   --  More documentation needed??? why is this flag needed? what are these\n+   --  checks? why do they need disabling in some cases?\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}]}