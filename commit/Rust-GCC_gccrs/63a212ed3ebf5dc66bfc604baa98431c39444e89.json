{"sha": "63a212ed3ebf5dc66bfc604baa98431c39444e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNhMjEyZWQzZWJmNWRjNjZiZmM2MDRiYWE5ODQzMWMzOTQ0NGU4OQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T21:48:14Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-12-12T21:48:14Z"}, "message": "Loks of changes so we can better compile from source.\n\n8\nLoks of changes so we can better compile from source.  See ChangeLog.\n\nFrom-SVN: r24280", "tree": {"sha": "3618f3490d406530e474caa40d130508ce032f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3618f3490d406530e474caa40d130508ce032f6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63a212ed3ebf5dc66bfc604baa98431c39444e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a212ed3ebf5dc66bfc604baa98431c39444e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63a212ed3ebf5dc66bfc604baa98431c39444e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63a212ed3ebf5dc66bfc604baa98431c39444e89/comments", "author": null, "committer": null, "parents": [{"sha": "502f194fa0b65cb5e3bcd62e19567fa097176af3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502f194fa0b65cb5e3bcd62e19567fa097176af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502f194fa0b65cb5e3bcd62e19567fa097176af3"}], "stats": {"total": 1706, "additions": 875, "deletions": 831}, "files": [{"sha": "d669cb9bc17d0f10093356b9b15b1ec25f693a41", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=63a212ed3ebf5dc66bfc604baa98431c39444e89", "patch": "@@ -1643,7 +1643,7 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n      this is also needed to avoid circularities in the implementation\n      of these fields in libjava. */\n   if (field_name == TYPE_identifier_node && ! is_putting\n-      && field_type == class_ptr_type\n+      && ! flag_emit_class_files && field_type == class_ptr_type\n       && strncmp (self_name, \"java.lang.\", 10) == 0)\n     {\n       tree typ = build_primtype_type_ref (self_name);"}, {"sha": "265312690c53011bde5230cf6367f63d20568a8b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=63a212ed3ebf5dc66bfc604baa98431c39444e89", "patch": "@@ -419,9 +419,6 @@ struct lang_identifier\n    slot_number in decl_map. */\n #define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_chain)\n-/* For a static field seen from the parser, it holds its associated\n-   value, the one returned when the field is looked up. */\n-#define DECL_LOCAL_STATIC_VALUE(NODE) DECL_LOCAL_SLOT_CHAIN (NODE)\n \n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl"}, {"sha": "5d8a5e09c0483b37b8eb6bf37a6f8e39e716ddb1", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=63a212ed3ebf5dc66bfc604baa98431c39444e89", "patch": "@@ -55,6 +55,11 @@ extern struct obstack *saveable_obstack;\n extern struct obstack temporary_obstack;\n extern struct obstack permanent_obstack;\n \n+/* This is true if the user specified a `.java' file on the command\n+   line.  Otherwise it is 0.  FIXME: this is temporary, until our\n+   .java parser is fully working.  */\n+int saw_java_source = 0;\n+\n /* The class we are currently processing. */\n tree current_class = NULL_TREE;\n \n@@ -477,8 +482,13 @@ load_class (class_or_name, verbose)\n   /* Search in current zip first.  */\n   if (find_in_current_zip (IDENTIFIER_POINTER (name),\n \t\t\t   IDENTIFIER_LENGTH (name), &jcf) == 0)\n+    /* FIXME: until the `.java' parser is fully working, we only\n+       look for a .java file when one was mentioned on the\n+       command line.  This lets us test the .java parser fairly\n+       easily, without compromising our ability to use the\n+       .class parser without fear.  */\n     if (find_class (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name),\n-\t\t     &this_jcf, 1) == 0)\n+\t\t     &this_jcf, saw_java_source) == 0)\n       {\n \tif (verbose)\n \t  {\n@@ -739,7 +749,6 @@ yyparse ()\n       if (list[0]) \n \t{\n \t  char *value, len;\n-\t  extern int saw_java_source; /* FIXME: temporary.  */\n \n \t  len = strlen (list);\n \t  /* FIXME: this test is only needed until our .java parser is\n@@ -961,7 +970,8 @@ DEFUN(jcf_figure_file_type, (jcf),\n     return JCF_CLASS;\n \n   /* FIXME: is it a system file?  */\n-  if (!open_in_zip (jcf, input_filename, NULL, 0))\n+  if (magic ==  (JCF_u4)ZIPMAGIC\n+      && !open_in_zip (jcf, input_filename, NULL, 0))\n     {\n       localToFile = ALLOC (sizeof (struct ZipFileCache));\n       bcopy (SeenZipFiles, localToFile, sizeof (struct ZipFileCache));"}, {"sha": "6211cf9b34a58438e0cb4752fa3f1c4a000ac5d2", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=63a212ed3ebf5dc66bfc604baa98431c39444e89", "patch": "@@ -410,7 +410,13 @@ put_linenumber (line, state)\n      int line;\n      struct jcf_partial *state;\n {\n-  (get_jcf_label_here (state))->linenumber = line;\n+  struct jcf_block *label = get_jcf_label_here (state);\n+  if (label->linenumber > 0)\n+    {\n+      label = gen_jcf_label (state);\n+      define_jcf_label (label, state);\n+    }\n+  label->linenumber = line;\n   state->linenumber_count++;\n }\n \n@@ -1276,12 +1282,15 @@ generate_bytecode_insns (exp, target, state)\n     case EXPR_WITH_FILE_LOCATION:\n       {\n \tchar *saved_input_filename = input_filename;\n+\ttree body = EXPR_WFL_NODE (exp);\n \tint saved_lineno = lineno;\n+\tif (body == empty_stmt_node)\n+\t  break;\n \tinput_filename = EXPR_WFL_FILENAME (exp);\n \tlineno = EXPR_WFL_LINENO (exp);\n-\tif (EXPR_WFL_EMIT_LINE_NOTE (exp))\n-\t  put_linenumber (EXPR_WFL_LINENO (exp), state);\n-\tgenerate_bytecode_insns (EXPR_WFL_NODE (exp), target, state);\n+\tif (EXPR_WFL_EMIT_LINE_NOTE (exp) && lineno > 0)\n+\t  put_linenumber (lineno, state);\n+\tgenerate_bytecode_insns (body, target, state);\n \tinput_filename = saved_input_filename;\n \tlineno = saved_lineno;\n       }\n@@ -1703,7 +1712,7 @@ generate_bytecode_insns (exp, target, state)\n \t  emit_dup (1, 0, state);\n \t  /* Stack:  ..., objectref, objectref. */\n \t  field_op (TREE_OPERAND (exp, 1), OPCODE_getfield, state);\n-\t  NOTE_PUSH (size);\n+\t  NOTE_PUSH (size-1);\n \t  /* Stack:  ..., objectref, oldvalue. */\n \t  offset = 1;\n \t}\n@@ -1742,7 +1751,9 @@ generate_bytecode_insns (exp, target, state)\n       emit_binop (OPCODE_iadd + adjust_typed_op (type, 3), type, state);\n       if (target != IGNORE_TARGET && ! post_op)\n \temit_dup (size, offset, state);\n-      /* Stack:  ..., [result,] newvalue. */\n+      /* Stack, if ARRAY_REF:  ..., [result, ] array, index, newvalue. */\n+      /* Stack, if COMPONENT_REF:  ..., [result, ] objectref, newvalue. */\n+      /* Stack, otherwise:  ..., [result, ] newvalue. */\n       goto finish_assignment;\n \n     case MODIFY_EXPR:\n@@ -1817,30 +1828,28 @@ generate_bytecode_insns (exp, target, state)\n \t  if (! FIELD_STATIC (field))\n \t    NOTE_POP (1);\n \t  field_op (field,\n-\t\t    FIELD_STATIC (field) ? OPCODE_putstatic\n-\t\t    : OPCODE_putfield,\n+\t\t    FIELD_STATIC (field) ? OPCODE_putstatic : OPCODE_putfield,\n \t\t    state);\n \n-\t  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (field)) ? 2 : 1);\n+\t  NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (field)) ? 2 : 1);\n \t}\n       else if (TREE_CODE (exp) == VAR_DECL\n \t       || TREE_CODE (exp) == PARM_DECL)\n \t{\n \t  if (FIELD_STATIC (exp))\n \t    {\n \t      field_op (exp, OPCODE_putstatic, state);\n-\t      NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n+\t      NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n \t    }\n \t  else\n \t    emit_store (exp, state);\n \t}\n       else if (TREE_CODE (exp) == ARRAY_REF)\n \t{\n-\t  NOTE_POP (2);\n \t  jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (exp), 7);\n \t  RESERVE(1);\n \t  OP1 (jopcode);\n-\t  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n+\t  NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 4 : 3);\n \t}\n       else\n \tfatal (\"internal error (bad lhs to MODIFY_EXPR)\");\n@@ -1883,8 +1892,11 @@ generate_bytecode_insns (exp, target, state)\n \t  generate_bytecode_insns (arg0, target, state);\n \t  generate_bytecode_insns (arg1, target, state);\n \t}\n+      /* For most binary operations, both operands and the result have the\n+\t same type.  Shift operations are different.  Using arg1's type\n+\t gets us the correct SP adjustment in all casesd. */\n       if (target == STACK_TARGET)\n-\temit_binop (jopcode, type, state);\n+\temit_binop (jopcode, TREE_TYPE (arg1), state);\n       break;\n     }\n     case TRUTH_NOT_EXPR:\n@@ -2054,10 +2066,16 @@ generate_bytecode_insns (exp, target, state)\n       break;\n     case NEW_ARRAY_INIT:\n       {\n-\ttree values;\n+\ttree values = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n \ttree array_type = TREE_TYPE (TREE_TYPE (exp));\n \ttree element_type = TYPE_ARRAY_ELEMENT (array_type);\n \tHOST_WIDE_INT length = java_array_type_length (array_type);\n+\tif (target == IGNORE_TARGET)\n+\t  {\n+\t    for ( ;  values != NULL_TREE;  values = TREE_CHAIN (values))\n+\t      generate_bytecode_insns (TREE_VALUE (values), target, state);\n+\t    break;\n+\t  }\n \tpush_int_const (length, state);\n \tNOTE_PUSH (1);\n \tRESERVE (3);\n@@ -2074,14 +2092,14 @@ generate_bytecode_insns (exp, target, state)\n \t    OP1 (OPCODE_anewarray);\n \t    OP2 (index);\n \t  }\n-\tvalues = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0));\n \toffset = 0;\n \tjopcode = OPCODE_iastore + adjust_typed_op (element_type, 7);\n \tfor ( ;  values != NULL_TREE;  values = TREE_CHAIN (values), offset++)\n \t  {\n \t    int save_SP = state->code_SP;\n \t    emit_dup (1, 0, state);\n \t    push_int_const (offset, state);\n+\t    NOTE_PUSH (1);\n \t    generate_bytecode_insns (TREE_VALUE (values), STACK_TARGET, state);\n \t    RESERVE (1);\n \t    OP1 (jopcode);\n@@ -2183,11 +2201,11 @@ generate_bytecode_insns (exp, target, state)\n \t    int index = find_methodref_index (&state->cpool, f);\n \t    int interface = 0;\n \t    RESERVE (5);\n-\t    if (DECL_CONSTRUCTOR_P (f) || CALL_USING_SUPER (exp)\n+\t    if (METHOD_STATIC (f))\n+\t      OP1 (OPCODE_invokestatic);\n+\t    else if (DECL_CONSTRUCTOR_P (f) || CALL_USING_SUPER (exp)\n \t\t|| METHOD_PRIVATE (f))\n \t      OP1 (OPCODE_invokespecial);\n-\t    else if (METHOD_STATIC (f))\n-\t      OP1 (OPCODE_invokestatic);\n \t    else if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (f))))\n \t      {\n \t\tOP1 (OPCODE_invokeinterface);\n@@ -2496,7 +2514,7 @@ generate_classfile (clas, state)\n   for (part = TYPE_FIELDS (clas);  part;  part = TREE_CHAIN (part))\n     {\n       int have_value;\n-      if (DECL_NAME (part) == NULL_TREE)\n+      if (DECL_NAME (part) == NULL_TREE || DECL_ARTIFICIAL (part))\n \tcontinue;\n       ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n@@ -2533,6 +2551,8 @@ generate_classfile (clas, state)\n       tree name = DECL_CONSTRUCTOR_P (part) ? init_identifier_node\n \t: DECL_NAME (part);\n       tree type = TREE_TYPE (part);\n+      tree save_function = current_function_decl;\n+      current_function_decl = part;\n       ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n       i = find_utf8_constant (&state->cpool, name);  PUT2 (i);\n@@ -2653,6 +2673,7 @@ generate_classfile (clas, state)\n \t    }\n \t}\n       methods_count++;\n+      current_function_decl = save_function;\n     }\n   ptr = methods_count_ptr;  PUT2 (methods_count);\n "}, {"sha": "64c302b9d95fc7d938619828d89b146beb226bea", "filename": "gcc/java/parse.c", "status": "modified", "additions": 670, "deletions": 670, "changes": 1340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=63a212ed3ebf5dc66bfc604baa98431c39444e89"}, {"sha": "e41658a2bbe5d3c62cbeda43c3b637059ab3734d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 151, "deletions": 135, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63a212ed3ebf5dc66bfc604baa98431c39444e89/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=63a212ed3ebf5dc66bfc604baa98431c39444e89", "patch": "@@ -68,6 +68,7 @@ definitions and other extensions.  */\n #include \"parse.h\"\n #include \"zipfile.h\"\n #include \"convert.h\"\n+#include \"buffer.h\"\n \n /* Local function prototypes */\n static char *java_accstring_lookup PROTO ((int));\n@@ -593,11 +594,7 @@ type_import_on_demand_declaration:\n \t\t{\n \t\t  tree name = EXPR_WFL_NODE ($2);\n \t\t  tree node = build_tree_list ($2, NULL_TREE);\n-\t\t  if (!IS_AN_IMPORT_ON_DEMAND_P (name))\n-\t\t    {\n-\t\t      read_import_dir ($2);\n-\t\t      IS_AN_IMPORT_ON_DEMAND_P (name) = 1;\n-\t\t    }\n+\t\t  read_import_dir ($2);\n \t\t  TREE_CHAIN (node) = ctxp->import_demand_list;\n \t\t  ctxp->import_demand_list = node;\n \t\t}\n@@ -4864,70 +4861,22 @@ find_in_imports (class_type)\n   return 0;\n }\n \n-/* Process a import on demand statement (lazy) */\n-\n static int\n-read_import_entry (jcf, dirp, returned_name)\n-     JCF *jcf;\n-     DIR *dirp;\n-     char **returned_name;\n+note_possible_classname (name, len)\n+     char *name;\n+     int len;\n {\n-  if (dirp)\n-    {\n-      struct dirent *direntp = readdir (dirp);\n-      if (!direntp)\n-\t{\n-\t  *returned_name = NULL;\n-\t  return 0;\n-\t}\n-      else\n-\t{\n-\t  *returned_name = direntp->d_name;\n-\t  return (strlen (direntp->d_name));\n-\t}\n-    }\n+  tree node;\n+  if (len > 5 && strncmp (&name [len-5], \".java\", 5) == 0)\n+    len = len - 5;\n+  else if (len > 6 && strncmp (&name [len-6], \".class\", 6) == 0)\n+    len = len - 6;\n   else\n-    {\n-      int current_dir_len = strlen (jcf->classname);\n-      char *current_entry;\n-      int current_entry_len;\n-\n-      /* Here we read a zip directory as a file directory. The files\n-\t we're selecting must have the same root than the directory\n-\t we're examining. */\n-\n-      ZipDirectory *zipd = (ZipDirectory *)jcf->zipd; \n-\n-      while (zipd)\n-\t{\n-\t  current_entry = ZIPDIR_FILENAME (zipd);\n-\t  current_entry_len = zipd->filename_length;\n-\t  while (current_entry_len && current_entry [current_entry_len] != '/')\n-\t    current_entry_len--;\n-\t  /* If the path of the current file doesn't match the directory we're\n-\t     scanning, that the end of the search */\n-\t  current_entry_len++;\n-\t  if (strncmp (jcf->classname, current_entry, current_dir_len))\n-\t    {\n-\t      *returned_name = NULL;\n-\t      return 0;\n-\t    }\n-\t  /* Ok, we have at least the same path. The position of the last '/'\n-\t     of the current file we're examining should match the size of\n-\t     name of the directory we're browsing, otherwise that an entry\n-\t     belonging to a sub directory, we want to skip it. */\n-\t  if (current_entry_len != current_dir_len)\n-\t    zipd = ZIPDIR_NEXT (zipd);\n-\t  else\n-\t    {\n-\t      jcf->zipd = ZIPDIR_NEXT (zipd); /* Prepare next read */\n-\t      *returned_name = &current_entry [current_entry_len];\n-\t      return (zipd->filename_length - current_entry_len);\n-\t    }\n-\t}\n-      *returned_name = NULL;\n-      return 0;\n-    }\n+    return 0;\n+  node = ident_subst (name, len, \"\", '/', '.', \"\");\n+  IS_A_CLASSFILE_NAME (node) = 1; /* Or soon to be */\n+  QUALIFIED_P (node) = 1; /* As soon as we turn / into . */\n+  return 1;\n }\n \n /* Read a import directory, gathering potential match for further type\n@@ -4938,80 +4887,122 @@ static void\n read_import_dir (wfl)\n      tree wfl;\n {\n-  char *name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n-  int name_len = IDENTIFIER_LENGTH (EXPR_WFL_NODE (wfl)), reclen;\n+  tree package_id = EXPR_WFL_NODE (wfl);\n+  char *package_name = IDENTIFIER_POINTER (package_id);\n+  int package_length = IDENTIFIER_LENGTH (package_id);\n   DIR *dirp = NULL;\n   JCF jcfr, *jcf, *saved_jcf = current_jcf;\n-  char *founddirname, *d_name;\n \n-  jcf = &jcfr;\n-  if (!(founddirname = find_class (name, name_len, jcf, 0)))\n-    fatal (\"Can't import `%s'\", name);\n-  if (jcf->outofsynch)\n-    jcf_out_of_synch (jcf);\n-  if (jcf->seen_in_zip)\n-    jcf->zipd = ZIPDIR_NEXT ((ZipDirectory *)jcf->zipd);\n+  int found = 0;\n+  int k;\n+  void *entry;\n+  struct buffer filename[1];\n+\n+\n+  if (IS_AN_IMPORT_ON_DEMAND_P (package_id))\n+    return;\n+  IS_AN_IMPORT_ON_DEMAND_P (package_id) = 1;\n+\n+  BUFFER_INIT (filename);\n+  buffer_grow (filename, package_length + 100);\n+\n+  for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n+    {\n+      char *entry_name = jcf_path_name (entry);\n+      int entry_length = strlen (entry_name);\n+      if (jcf_path_is_zipfile (entry))\n+\t{\n+\t  ZipFile *zipf;\n+\t  buffer_grow (filename, entry_length);\n+\t  memcpy (filename->data, entry_name, entry_length - 1);\n+\t  filename->data[entry_length-1] = '\\0';\n+\t  zipf = opendir_in_zip (filename->data, jcf_path_is_system (entry));\n+\t  if (zipf == NULL)\n+\t    error (\"malformed .zip archive in CLASSPATH: %s\", entry_name);\n+\t  else\n+\t    {\n+\t      ZipDirectory *zipd = (ZipDirectory *) zipf->central_directory;\n+\t      BUFFER_RESET (filename);\n+\t      for (k = 0; k < package_length; k++)\n+\t\t{\n+\t\t  char ch = package_name[k];\n+\t\t  *filename->ptr++ = ch == '.' ? '/' : ch;\n+\t\t}\n+\t      *filename->ptr++ = '/';\n+\n+\t      for (; k < zipf->count;  k++, zipd = ZIPDIR_NEXT (zipd))\n+\t\t{\n+\t\t  char *current_entry = ZIPDIR_FILENAME (zipd);\n+\t\t  int current_entry_len = zipd->filename_length;\n+\n+\t\t  if (strncmp (filename->data, current_entry, \n+\t\t\t       BUFFER_LENGTH (filename)) != 0)\n+\t\t    continue;\n+\t\t  found += note_possible_classname (current_entry,\n+\t\t\t\t\t\t    current_entry_len);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  BUFFER_RESET (filename);\n+\t  buffer_grow (filename, entry_length + package_length + 4);\n+\t  strcpy (filename->data, entry_name);\n+\t  filename->ptr = filename->data + entry_length;\n+\t  for (k = 0; k < package_length; k++)\n+\t    {\n+\t      char ch = package_name[k];\n+\t      *filename->ptr++ = ch == '.' ? '/' : ch;\n+\t    }\n+\t  *filename->ptr = '\\0';\n+\n+\t  dirp = opendir (filename->data);\n+\t  if (dirp == NULL)\n+\t    continue;\n+\t  *filename->ptr++ = '/';\n+\t  for (;;)\n+\t    {\n+\t      int java_or_class = 0;\n+\t      int len; \n+\t      char *d_name;\n+\t      struct dirent *direntp = readdir (dirp);\n+\t      if (!direntp)\n+\t\tbreak;\n+\t      d_name = direntp->d_name;\n+\t      len = strlen (direntp->d_name);\n+\t      buffer_grow (filename, len+1);\n+\t      strcpy (filename->ptr, d_name);\n+\t      found += note_possible_classname (filename->data + entry_length,\n+\t\t\t\t\t\tpackage_length+len+1);\n+\t    }\n+\t  if (dirp)\n+\t    closedir (dirp);\n+\t}\n+    }\n \n-  else if (founddirname)\n-    dirp = opendir (founddirname);\n+  free (filename->data);\n \n-  if (!founddirname && !dirp)\n+  /* Here we should have a unified way of retrieving an entry, to be\n+     indexed. */\n+  if (!found)\n     {\n       static int first = 1;\n       if (first)\n \t{\n \t  char buffer [256];\n \t  sprintf (buffer, \"Can't find default package `%s'. Check \"\n \t\t   \"the CLASSPATH environment variable and the access to the \"\n-\t\t   \"archives.\", name);\n+\t\t   \"archives.\", package_name);\n \t  error (buffer);\n \t  java_error_count++;\n \t  first = 0;\n \t}\n       else\n-\tparse_error_context (wfl, \"Package `%s' not found in import\", name);\n+\tparse_error_context (wfl, \"Package `%s' not found in import\",\n+\t\t\t     package_name);\n       current_jcf = saved_jcf;\n       return;\n     }\n-\n-  /* Here we should have a unified way of retrieving an entry, to be\n-     indexed. */\n-  while ((reclen = read_import_entry (jcf, dirp, &d_name)))\n-    {\n-      int java_or_class = 0;\n-      int len; \n-      if ((reclen > 5) \n-\t  && !strcmp (&d_name [reclen-5], \".java\"))\n-\t{\n-\t  java_or_class = 1;\n-\t  len = reclen - 5;\n-\t}\n-\t  \n-      if (!java_or_class && (reclen > 6) &&\n-\t  !strcmp (&d_name [reclen-6], \".class\"))\n-\t{\n-\t  java_or_class = 2;\n-\t  len = reclen - 6;\n-\t}\n-\n-      if (java_or_class)\n-\t{\n-\t  char *id_name;\n-\t  tree node;\n-\n-\t  obstack_grow (&temporary_obstack, name, name_len);\n-\t  obstack_1grow (&temporary_obstack, '/');\n-\t  obstack_grow0 (&temporary_obstack, d_name, len);\n-\t  id_name = obstack_finish (&temporary_obstack);\n-\n-\t  node = get_identifier (id_name);\n-\t  IS_A_CLASSFILE_NAME (node) = 1; /* Or soon to be */\n-\t  QUALIFIED_P (node) = 1; /* As soon as we turn / into . */\n-\t}\n-    }\n-  if (dirp)\n-    closedir (dirp);\n-  \n   current_jcf = saved_jcf;\n }\n \n@@ -5033,7 +5024,7 @@ find_in_imports_on_demand (class_type)\n       obstack_grow (&temporary_obstack, \n \t\t    IDENTIFIER_POINTER (EXPR_WFL_NODE (TREE_PURPOSE (import))),\n \t\t    IDENTIFIER_LENGTH (EXPR_WFL_NODE (TREE_PURPOSE (import))));\n-      obstack_1grow (&temporary_obstack, '/');\n+      obstack_1grow (&temporary_obstack, '.');\n       obstack_grow0 (&temporary_obstack, \n \t\t     IDENTIFIER_POINTER (TYPE_NAME (class_type)),\n \t\t     IDENTIFIER_LENGTH (TYPE_NAME (class_type)));\n@@ -5066,9 +5057,7 @@ find_in_imports_on_demand (class_type)\n       tree decl;\n       int saved_lineno = lineno;\n       lineno = EXPR_WFL_LINENO (cl);\n-      TYPE_NAME (class_type) = ident_subst (IDENTIFIER_POINTER (node_to_use),\n-\t\t\t\t\t    IDENTIFIER_LENGTH (node_to_use),\n-\t\t\t\t\t    \"\", '/', '.', \"\");\n+      TYPE_NAME (class_type) = node_to_use;\n       QUALIFIED_P (TYPE_NAME (class_type)) = 1;\n       decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n       /* If there is no DECL set for the class or if the class isn't\n@@ -5617,8 +5606,13 @@ java_complete_expand_methods ()\n \n       /* Make the class data, register it and run the rest of decl\n          compilation on it */\n-      if (!java_error_count && ! flag_emit_class_files)\n-\tfinish_class (current_class);\n+      if (!java_error_count)\n+\t{\n+\t  if (flag_emit_class_files)\n+\t    write_classfile (current_class);\n+\t  else\n+\t    finish_class (current_class);\n+\t}\n     }\n }\n \n@@ -5809,8 +5803,6 @@ java_expand_classes ()\n       java_parse_abort_on_error ();\n       java_check_final ();            /* Check unitialized final  */\n       java_parse_abort_on_error ();\n-      if (flag_emit_class_files)\n-\twrite_classfile (current_class);\n     }\n }\n \n@@ -7860,12 +7852,32 @@ java_complete_tree (node)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n       return patch_array_ref (node);\n \n-#if 0 \n-    COMPONENT_REF:\n-      /* Planned re-write FIXME */\n+    case RECORD_TYPE:\n+      return node;;\n+\n+    case COMPONENT_REF:\n+      /* The first step in the re-write of qualified name handling.  FIXME.\n+\t So far, this is only to support PRIMTYPE.class -> PRIMCLASS.TYPE. */\n       TREE_OPERAND (node, 0) = java_complete_tree (TREE_OPERAND (node, 0));\n+      if (TREE_CODE (TREE_OPERAND (node, 0)) == RECORD_TYPE)\n+\t{\n+\t  tree name = TREE_OPERAND (node, 1);\n+\t  tree field = lookup_field_wrapper (TREE_OPERAND (node, 0), name);\n+\t  if (field == NULL_TREE)\n+\t    {\n+\t      error (\"missing static field `%s'\", IDENTIFIER_POINTER (name));\n+\t      return error_mark_node;\n+\t    }\n+\t  if (! FIELD_STATIC (field))\n+\t    {\n+\t      error (\"not a static field `%s'\", IDENTIFIER_POINTER (name));\n+\t      return error_mark_node;\n+\t    }\n+\t  return field;\n+\t}\n+      else\n+\tfatal (\"unimplemented java_complete_tree for COMPONENT_REF\");\n       break;\n-#endif\n \n     case THIS_EXPR:\n       /* Can't use THIS in a static environment */\n@@ -10726,9 +10738,13 @@ patch_synchronized_statement (node, wfl_op1)\n   BUILD_MONITOR_ENTER (stmt, expr);\n   compound = add_stmt_to_compound (NULL_TREE, int_type_node, stmt);\n   compound = add_stmt_to_compound (compound, void_type_node, block);\n-  BUILD_MONITOR_EXIT (stmt, expr);\n-  compound = add_stmt_to_compound (compound, int_type_node, stmt);\n+  if (CAN_COMPLETE_NORMALLY (block))\n+    {\n+      BUILD_MONITOR_EXIT (stmt, expr);\n+      compound = add_stmt_to_compound (compound, int_type_node, stmt);\n+    }\n   try_block = build_expr_block (compound, NULL_TREE);\n+  CAN_COMPLETE_NORMALLY (try_block) = CAN_COMPLETE_NORMALLY (block);\n \n   /* CATCH_ALL block */\n   decl = build_decl (VAR_DECL, generate_name (), ptr_type_node);\n@@ -10744,7 +10760,7 @@ patch_synchronized_statement (node, wfl_op1)\n \n   /* TRY-CATCH statement */\n   compound = build (TRY_EXPR, void_type_node, try_block, catch_all, NULL_TREE);\n-  CAN_COMPLETE_NORMALLY (compound) = CAN_COMPLETE_NORMALLY (block);\n+  CAN_COMPLETE_NORMALLY (compound) = CAN_COMPLETE_NORMALLY (try_block);\n   return compound;\n }\n "}]}