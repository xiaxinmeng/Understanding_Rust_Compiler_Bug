{"sha": "7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NkZmNmNjAwYTg2YWE1ODk1ODQxOTJjOTYzYTljYzVmYTFhMTJiMw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2006-02-13T21:17:59Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-02-13T21:17:59Z"}, "message": "Index: gcc/ChangeLog\n2006-02-13  Geoffrey Keating  <geoffk@apple.com>\n\n\t* dwarf2out.c (base_type_die): Don't add AT_name here.\n\t(subrange_type_die): Don't add AT_name here.\n\t(modified_type_die): Rearrange code flow.  Do add AT_name here.\n\nIndex: gcc/testsuite/ChangeLog\n2006-02-13  Geoffrey Keating  <geoffk@apple.com>\n\n\t* objc.dg/dwarf-1.m: New.\n\nFrom-SVN: r110925", "tree": {"sha": "c58bec94469b40b94853de0628e033f9930e827c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58bec94469b40b94853de0628e033f9930e827c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd361d85c7cf2c5083f6c595cec251ef4edec77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd361d85c7cf2c5083f6c595cec251ef4edec77f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd361d85c7cf2c5083f6c595cec251ef4edec77f"}], "stats": {"total": 264, "additions": 127, "deletions": 137}, "files": [{"sha": "15c3fc47c19500ffd6967f160e245f3a56e4fc3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "patch": "@@ -1,3 +1,9 @@\n+2006-02-13  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* dwarf2out.c (base_type_die): Don't add AT_name here.\n+\t(subrange_type_die): Don't add AT_name here.\n+\t(modified_type_die): Rearrange code flow.  Do add AT_name here.\n+\n 2006-02-13  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR rtl-optimization/26247"}, {"sha": "48c917324c4e1a26c988656ebc5b70bc5c0fdd4d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 112, "deletions": 137, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "patch": "@@ -8085,23 +8085,11 @@ static dw_die_ref\n base_type_die (tree type)\n {\n   dw_die_ref base_type_result;\n-  const char *type_name;\n   enum dwarf_type encoding;\n-  tree name = TYPE_NAME (type);\n \n   if (TREE_CODE (type) == ERROR_MARK || TREE_CODE (type) == VOID_TYPE)\n     return 0;\n \n-  if (name)\n-    {\n-      if (TREE_CODE (name) == TYPE_DECL)\n-\tname = DECL_NAME (name);\n-\n-      type_name = IDENTIFIER_POINTER (name);\n-    }\n-  else\n-    type_name = \"__unknown__\";\n-\n   switch (TREE_CODE (type))\n     {\n     case INTEGER_TYPE:\n@@ -8145,10 +8133,11 @@ base_type_die (tree type)\n     }\n \n   base_type_result = new_die (DW_TAG_base_type, comp_unit_die, type);\n-  if (demangle_name_func)\n-    type_name = (*demangle_name_func) (type_name);\n \n-  add_AT_string (base_type_result, DW_AT_name, type_name);\n+  /* This probably indicates a bug.  */\n+  if (! TYPE_NAME (type))\n+    add_name_attribute (base_type_result, \"__unknown__\");\n+\n   add_AT_unsigned (base_type_result, DW_AT_byte_size,\n \t\t   int_size_in_bytes (type));\n   add_AT_unsigned (base_type_result, DW_AT_encoding, encoding);\n@@ -8302,30 +8291,15 @@ is_subrange_type (tree type)\n static dw_die_ref\n subrange_type_die (tree type, dw_die_ref context_die)\n {\n-  dw_die_ref subtype_die;\n   dw_die_ref subrange_die;\n-  tree name = TYPE_NAME (type);\n   const HOST_WIDE_INT size_in_bytes = int_size_in_bytes (type);\n-  tree subtype = TREE_TYPE (type);\n \n   if (context_die == NULL)\n     context_die = comp_unit_die;\n \n-  if (TREE_CODE (subtype) == ENUMERAL_TYPE)\n-    subtype_die = gen_enumeration_type_die (subtype, context_die);\n-  else\n-    subtype_die = base_type_die (subtype);\n-\n   subrange_die = new_die (DW_TAG_subrange_type, context_die, type);\n \n-  if (name != NULL)\n-    {\n-      if (TREE_CODE (name) == TYPE_DECL)\n-        name = DECL_NAME (name);\n-      add_name_attribute (subrange_die, IDENTIFIER_POINTER (name));\n-    }\n-\n-  if (int_size_in_bytes (subtype) != size_in_bytes)\n+  if (int_size_in_bytes (TREE_TYPE (type)) != size_in_bytes)\n     {\n       /* The size of the subrange type and its base type do not match,\n          so we need to generate a size attribute for the subrange type.  */\n@@ -8338,7 +8312,6 @@ subrange_type_die (tree type, dw_die_ref context_die)\n   if (TYPE_MAX_VALUE (type) != NULL)\n     add_bound_info (subrange_die, DW_AT_upper_bound,\n                     TYPE_MAX_VALUE (type));\n-  add_AT_die_ref (subrange_die, DW_AT_type, subtype_die);\n \n   return subrange_die;\n }\n@@ -8351,118 +8324,120 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t\t   dw_die_ref context_die)\n {\n   enum tree_code code = TREE_CODE (type);\n-  dw_die_ref mod_type_die = NULL;\n+  dw_die_ref mod_type_die;\n   dw_die_ref sub_die = NULL;\n   tree item_type = NULL;\n-\n-  if (code != ERROR_MARK)\n+  tree qualified_type;\n+  tree name;\n+\n+  if (code == ERROR_MARK)\n+    return NULL;\n+\n+  /* See if we already have the appropriately qualified variant of\n+     this type.  */\n+  qualified_type\n+    = get_qualified_type (type,\n+\t\t\t  ((is_const_type ? TYPE_QUAL_CONST : 0)\n+\t\t\t   | (is_volatile_type ? TYPE_QUAL_VOLATILE : 0)));\n+  \n+  /* If we do, then we can just use its DIE, if it exists.  */\n+  if (qualified_type)\n     {\n-      tree qualified_type;\n-\n-      /* See if we already have the appropriately qualified variant of\n-\t this type.  */\n-      qualified_type\n-\t= get_qualified_type (type,\n-\t\t\t      ((is_const_type ? TYPE_QUAL_CONST : 0)\n-\t\t\t       | (is_volatile_type\n-\t\t\t\t  ? TYPE_QUAL_VOLATILE : 0)));\n-\n-      /* If we do, then we can just use its DIE, if it exists.  */\n-      if (qualified_type)\n-\t{\n-\t  mod_type_die = lookup_type_die (qualified_type);\n-\t  if (mod_type_die)\n-\t    return mod_type_die;\n-\t}\n-\n-      /* Handle C typedef types.  */\n-      if (qualified_type && TYPE_NAME (qualified_type)\n-\t  && TREE_CODE (TYPE_NAME (qualified_type)) == TYPE_DECL\n-\t  && DECL_ORIGINAL_TYPE (TYPE_NAME (qualified_type)))\n-\t{\n-\t  tree type_name = TYPE_NAME (qualified_type);\n-\t  tree dtype = TREE_TYPE (type_name);\n-\n-\t  if (qualified_type == dtype)\n-\t    {\n-\t      /* For a named type, use the typedef.  */\n-\t      gen_type_die (qualified_type, context_die);\n-\t      mod_type_die = lookup_type_die (qualified_type);\n-\t    }\n-\t  else if (is_const_type < TYPE_READONLY (dtype)\n-\t\t   || is_volatile_type < TYPE_VOLATILE (dtype))\n-\t    /* cv-unqualified version of named type.  Just use the unnamed\n-\t       type to which it refers.  */\n-\t    mod_type_die\n-\t      = modified_type_die (DECL_ORIGINAL_TYPE (type_name),\n-\t\t\t\t   is_const_type, is_volatile_type,\n-\t\t\t\t   context_die);\n-\n-\t  /* Else cv-qualified version of named type; fall through.  */\n-\t}\n-\n+      mod_type_die = lookup_type_die (qualified_type);\n       if (mod_type_die)\n-\t/* OK.  */\n-\t;\n-      else if (is_const_type)\n-\t{\n-\t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die, type);\n-\t  sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n-\t}\n-      else if (is_volatile_type)\n-\t{\n-\t  mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die, type);\n-\t  sub_die = modified_type_die (type, 0, 0, context_die);\n-\t}\n-      else if (code == POINTER_TYPE)\n-\t{\n-\t  mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die, type);\n-\t  add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n-\t\t\t   simple_type_size_in_bits (type) / BITS_PER_UNIT);\n-#if 0\n-\t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n-#endif\n-\t  item_type = TREE_TYPE (type);\n-\t}\n-      else if (code == REFERENCE_TYPE)\n-\t{\n-\t  mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die, type);\n-\t  add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n-\t\t\t   simple_type_size_in_bits (type) / BITS_PER_UNIT);\n-#if 0\n-\t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n-#endif\n-\t  item_type = TREE_TYPE (type);\n-\t}\n-      else if (is_subrange_type (type))\n-        mod_type_die = subrange_type_die (type, context_die);\n-      else if (is_base_type (type))\n-\tmod_type_die = base_type_die (type);\n+\treturn mod_type_die;\n+    }\n+  \n+  name = qualified_type ? TYPE_NAME (qualified_type) : NULL;\n+  \n+  /* Handle C typedef types.  */\n+  if (name && TREE_CODE (name) == TYPE_DECL && DECL_ORIGINAL_TYPE (name))\n+    {\n+      tree dtype = TREE_TYPE (name);\n+      \n+      if (qualified_type == dtype)\n+\t{\n+\t  /* For a named type, use the typedef.  */\n+\t  gen_type_die (qualified_type, context_die);\n+\t  return lookup_type_die (qualified_type);\n+\t}\n+      else if (DECL_ORIGINAL_TYPE (name)\n+\t       && (is_const_type < TYPE_READONLY (dtype)\n+\t\t   || is_volatile_type < TYPE_VOLATILE (dtype)))\n+\t/* cv-unqualified version of named type.  Just use the unnamed\n+\t   type to which it refers.  */\n+\treturn modified_type_die (DECL_ORIGINAL_TYPE (name),\n+\t\t\t\t  is_const_type, is_volatile_type,\n+\t\t\t\t  context_die);\n+      /* Else cv-qualified version of named type; fall through.  */\n+    }\n+  \n+  if (is_const_type)\n+    {\n+      mod_type_die = new_die (DW_TAG_const_type, comp_unit_die, type);\n+      sub_die = modified_type_die (type, 0, is_volatile_type, context_die);\n+    }\n+  else if (is_volatile_type)\n+    {\n+      mod_type_die = new_die (DW_TAG_volatile_type, comp_unit_die, type);\n+      sub_die = modified_type_die (type, 0, 0, context_die);\n+    }\n+  else if (code == POINTER_TYPE)\n+    {\n+      mod_type_die = new_die (DW_TAG_pointer_type, comp_unit_die, type);\n+      add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n+\t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n+      item_type = TREE_TYPE (type);\n+    }\n+  else if (code == REFERENCE_TYPE)\n+    {\n+      mod_type_die = new_die (DW_TAG_reference_type, comp_unit_die, type);\n+      add_AT_unsigned (mod_type_die, DW_AT_byte_size,\n+\t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n+      item_type = TREE_TYPE (type);\n+    }\n+  else if (is_subrange_type (type))\n+    {\n+      mod_type_die = subrange_type_die (type, context_die);\n+      item_type = TREE_TYPE (type);\n+    }\n+  else if (is_base_type (type))\n+    mod_type_die = base_type_die (type);\n+  else\n+    {\n+      gen_type_die (type, context_die);\n+      \n+      /* We have to get the type_main_variant here (and pass that to the\n+\t `lookup_type_die' routine) because the ..._TYPE node we have\n+\t might simply be a *copy* of some original type node (where the\n+\t copy was created to help us keep track of typedef names) and\n+\t that copy might have a different TYPE_UID from the original\n+\t ..._TYPE node.  */\n+      if (TREE_CODE (type) != VECTOR_TYPE)\n+\treturn lookup_type_die (type_main_variant (type));\n       else\n-\t{\n-\t  gen_type_die (type, context_die);\n-\n-\t  /* We have to get the type_main_variant here (and pass that to the\n-\t     `lookup_type_die' routine) because the ..._TYPE node we have\n-\t     might simply be a *copy* of some original type node (where the\n-\t     copy was created to help us keep track of typedef names) and\n-\t     that copy might have a different TYPE_UID from the original\n-\t     ..._TYPE node.  */\n-\t  if (TREE_CODE (type) != VECTOR_TYPE)\n-\t    mod_type_die = lookup_type_die (type_main_variant (type));\n-\t  else\n-\t    /* Vectors have the debugging information in the type,\n-\t       not the main variant.  */\n-\t    mod_type_die = lookup_type_die (type);\n-\t  gcc_assert (mod_type_die);\n-\t}\n-\n-      /* We want to equate the qualified type to the die below.  */\n-      type = qualified_type;\n+\t/* Vectors have the debugging information in the type,\n+\t   not the main variant.  */\n+\treturn lookup_type_die (type);\n     }\n+  \n+  /* Builtin types don't have a DECL_ORIGINAL_TYPE.  For those,\n+     don't output a DW_TAG_typedef, since there isn't one in the\n+     user's program; just attach a DW_AT_name to the type.  */\n+  if (name\n+      && (TREE_CODE (name) != TYPE_DECL || TREE_TYPE (name) == qualified_type))\n+    {\n+      if (TREE_CODE (name) == TYPE_DECL)\n+\t/* Could just call add_name_and_src_coords_attributes here,\n+\t   but since this is a builtin type it doesn't have any\n+\t   useful source coordinates anyway.  */\n+\tname = DECL_NAME (name);\n+      add_name_attribute (mod_type_die, IDENTIFIER_POINTER (name));\n+    }\n+  \n+  if (qualified_type)\n+    equate_type_number_to_die (qualified_type, mod_type_die);\n \n-  if (type)\n-    equate_type_number_to_die (type, mod_type_die);\n   if (item_type)\n     /* We must do this after the equate_type_number_to_die call, in case\n        this is a recursive type.  This ensures that the modified_type_die"}, {"sha": "c0b191169c221b5ae92340d0aa3354e328f0d661", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "patch": "@@ -1,3 +1,7 @@\n+2006-02-13  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* objc.dg/dwarf-1.m: New.\n+\n 2006-02-13  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/24427"}, {"sha": "c427da9dd653a1f4160c2780954309d29c170c19", "filename": "gcc/testsuite/objc.dg/dwarf-1.m", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2Ftestsuite%2Fobjc.dg%2Fdwarf-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdfcf600a86aa589584192c963a9cc5fa1a12b3/gcc%2Ftestsuite%2Fobjc.dg%2Fdwarf-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fdwarf-1.m?ref=7cdfcf600a86aa589584192c963a9cc5fa1a12b3", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-options \"-gdwarf-2 -dA\" } */\n+/* { dg-final { scan-assembler \"\\\"id.0\\\".*DW_AT_name\" } } */\n+@interface foo\n+  id x;\n+@end"}]}