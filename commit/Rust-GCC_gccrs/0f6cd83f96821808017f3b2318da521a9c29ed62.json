{"sha": "0f6cd83f96821808017f3b2318da521a9c29ed62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY2Y2Q4M2Y5NjgyMTgwODAxN2YzYjIzMThkYTUyMWE5YzI5ZWQ2Mg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-06-27T15:30:06Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-06-27T15:30:06Z"}, "message": "re PR java/15715 (member interfaces are always static)\n\n2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n\n       PR java/15715.\n       * parse.y (create_interface): Set correct access modifiers for\n       interfaces.\n       * jcf-write.c (get_classfile_modifiers): New function.\n       (generate_classfile): Use get_classfile_modifiers, not\n       get_access_flags.\n\n2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n\n       * parse.y (register_incomplete_type): Set JDEP_ENCLOSING for \"super\"\n       dependency to current parser context, not NULL_TREE, for top-level\n       classes.\n       (jdep_resolve_class): Enable member access check for all inner\n       class dependencies.\n\nFrom-SVN: r83734", "tree": {"sha": "011e3f2b332966ef19bafd54bb8b7f8351779679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/011e3f2b332966ef19bafd54bb8b7f8351779679"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f6cd83f96821808017f3b2318da521a9c29ed62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6cd83f96821808017f3b2318da521a9c29ed62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f6cd83f96821808017f3b2318da521a9c29ed62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6cd83f96821808017f3b2318da521a9c29ed62/comments", "author": null, "committer": null, "parents": [{"sha": "64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b663f8bd8abd190e9f2f2aa47dddf60769b8e3"}], "stats": {"total": 62, "additions": 54, "deletions": 8}, "files": [{"sha": "e7594069ea7164ed82ad681bb6a7c15fe8e28f1c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6cd83f96821808017f3b2318da521a9c29ed62/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6cd83f96821808017f3b2318da521a9c29ed62/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0f6cd83f96821808017f3b2318da521a9c29ed62", "patch": "@@ -1,3 +1,20 @@\n+2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tPR java/15715.\n+\t* parse.y (create_interface): Set correct access modifiers for\n+\tinterfaces.\n+\t* jcf-write.c (get_classfile_modifiers): New function.\n+\t(generate_classfile): Use get_classfile_modifiers, not \n+\tget_access_flags.\n+\n+2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* parse.y (register_incomplete_type): Set JDEP_ENCLOSING for \"super\"\n+\tdependency to current parser context, not NULL_TREE, for top-level\n+\tclasses.\n+\t(jdep_resolve_class): Enable member access check for all inner\n+\tclass dependencies.\n+\n 2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* parse.y (qualify_and_find): Pass type decl, not identifier, to "}, {"sha": "8ead88661819d1a28062428be733588f52ab96d7", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6cd83f96821808017f3b2318da521a9c29ed62/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6cd83f96821808017f3b2318da521a9c29ed62/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=0f6cd83f96821808017f3b2318da521a9c29ed62", "patch": "@@ -304,6 +304,7 @@ static void perform_relocations (struct jcf_partial *);\n static void init_jcf_state (struct jcf_partial *, struct obstack *);\n static void init_jcf_method (struct jcf_partial *, tree);\n static void release_jcf_state (struct jcf_partial *);\n+static int get_classfile_modifiers (tree class);\n static struct chunk * generate_classfile (tree, struct jcf_partial *);\n static struct jcf_handler *alloc_handler (struct jcf_block *,\n \t\t\t\t\t  struct jcf_block *,\n@@ -2886,6 +2887,32 @@ release_jcf_state (struct jcf_partial *state)\n   obstack_free (state->chunk_obstack, state->first);\n }\n \n+/* Get the access flags (modifiers) of a class (TYPE_DECL) to be used in the\n+   access_flags field of the class file header.  */\n+\n+static int get_classfile_modifiers (tree class)\n+{\n+  /* These are the flags which are valid class file modifiers. \n+     See JVMS2 S4.1.  */\n+  int valid_toplevel_class_flags = ACC_PUBLIC | ACC_FINAL | ACC_SUPER | \n+\t\t\t\t   ACC_INTERFACE | ACC_ABSTRACT;\n+  int flags = get_access_flags (class);\n+\n+  /* ACC_SUPER should always be set, except for interfaces.  */\n+  if (! (flags & ACC_INTERFACE))\n+    flags |= ACC_SUPER;\n+   \n+  /* A protected member class becomes public at the top level. */\n+  if (flags & ACC_PROTECTED)\n+    flags |= ACC_PUBLIC;\n+ \n+  /* Filter out flags that are not valid for a class or interface in the \n+     top-level access_flags field.  */\n+  flags &= valid_toplevel_class_flags;\n+\n+  return flags;\n+}\n+\n /* Generate and return a list of chunks containing the class CLAS\n    in the .class file representation.  The list can be written to a\n    .class file using write_chunks.  Allocate chunks from obstack WORK. */\n@@ -2921,9 +2948,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n   else\n     i = 8 + 2 * total_supers;\n   ptr = append_chunk (NULL, i, state);\n-  i = get_access_flags (TYPE_NAME (clas));\n-  if (! (i & ACC_INTERFACE))\n-    i |= ACC_SUPER;\n+  i = get_classfile_modifiers (TYPE_NAME (clas));  \n   PUT2 (i); /* access_flags */\n   i = find_class_constant (&state->cpool, clas);  PUT2 (i);  /* this_class */\n   if (clas == object_type_node)"}, {"sha": "4d7f21865423b3c2935ea3291e999e02595551f8", "filename": "gcc/java/parse.y", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6cd83f96821808017f3b2318da521a9c29ed62/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6cd83f96821808017f3b2318da521a9c29ed62/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=0f6cd83f96821808017f3b2318da521a9c29ed62", "patch": "@@ -3852,6 +3852,13 @@ create_interface (int flags, tree id, tree super)\n   /* Create a new decl if DECL is NULL, otherwise fix it */\n   decl = maybe_create_class_interface_decl (decl, raw_name, q_name, id);\n \n+  /* Interfaces are always abstract. */\n+  flags |= ACC_ABSTRACT;\n+\n+  /* Inner interfaces are always static.  */\n+  if (INNER_CLASS_DECL_P (decl))\n+    flags |= ACC_STATIC;\n+\n   /* Set super info and mark the class a complete */\n   set_super_info (ACC_INTERFACE | flags, TREE_TYPE (decl),\n \t\t  object_type_node, ctxp->interface_number);\n@@ -5187,12 +5194,9 @@ register_incomplete_type (int kind, tree wfl, tree decl, tree ptr)\n   JDEP_MISC (new) = NULL_TREE;\n   /* For some dependencies, set the enclosing class of the current\n      class to be the enclosing context */\n-  if ((kind == JDEP_INTERFACE  || kind == JDEP_ANONYMOUS)\n+  if ((kind == JDEP_INTERFACE || kind == JDEP_ANONYMOUS || kind == JDEP_SUPER)\n       && GET_ENCLOSING_CPC ())\n     JDEP_ENCLOSING (new) = TREE_VALUE (GET_ENCLOSING_CPC ());\n-  else if (kind == JDEP_SUPER)\n-    JDEP_ENCLOSING (new) = (GET_ENCLOSING_CPC () ?\n-\t\t\t    TREE_VALUE (GET_ENCLOSING_CPC ()) : NULL_TREE);\n   else\n     JDEP_ENCLOSING (new) = GET_CPC ();\n   JDEP_GET_PATCH (new) = (tree *)NULL;\n@@ -5512,7 +5516,7 @@ jdep_resolve_class (jdep *dep)\n \n   if (!decl)\n     complete_class_report_errors (dep);\n-  else if (PURE_INNER_CLASS_DECL_P (decl))\n+  else if (INNER_CLASS_DECL_P (decl))\n     {\n       tree inner = TREE_TYPE (decl);\n       if (! CLASS_LOADED_P (inner))"}]}