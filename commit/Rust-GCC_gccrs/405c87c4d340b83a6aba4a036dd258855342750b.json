{"sha": "405c87c4d340b83a6aba4a036dd258855342750b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA1Yzg3YzRkMzQwYjgzYTZhYmE0YTAzNmRkMjU4ODU1MzQyNzUwYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-03T03:25:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-03T03:25:18Z"}, "message": "compiler: Fix nil func panics, constant type conversions.\n\nFrom-SVN: r194064", "tree": {"sha": "4f1a38beb547fc41b31fa8d28e24b825fdc69ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f1a38beb547fc41b31fa8d28e24b825fdc69ad6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/405c87c4d340b83a6aba4a036dd258855342750b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405c87c4d340b83a6aba4a036dd258855342750b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405c87c4d340b83a6aba4a036dd258855342750b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405c87c4d340b83a6aba4a036dd258855342750b/comments", "author": null, "committer": null, "parents": [{"sha": "9b8a4017255cc8cbba51df7fa8652457be4de579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8a4017255cc8cbba51df7fa8652457be4de579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8a4017255cc8cbba51df7fa8652457be4de579"}], "stats": {"total": 161, "additions": 98, "deletions": 63}, "files": [{"sha": "5fee25650b0636437bb5a1ba5fbba89df4d02cc8", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 96, "deletions": 61, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405c87c4d340b83a6aba4a036dd258855342750b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405c87c4d340b83a6aba4a036dd258855342750b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=405c87c4d340b83a6aba4a036dd258855342750b", "patch": "@@ -2965,46 +2965,6 @@ Type_conversion_expression::do_lower(Gogo*, Named_object*,\n \t{\n \t  if (!nc.set_type(type, true, location))\n \t    return Expression::make_error(location);\n-\n-\t  // Don't simply convert to or from a float or complex type\n-\t  // with a different size.  That may change the value.\n-\t  Type* vtype = val->type();\n-\t  if (vtype->is_abstract())\n-\t    ;\n-\t  else if (type->float_type() != NULL)\n-\t    {\n-\t      if (vtype->float_type() != NULL)\n-\t\t{\n-\t\t  if (type->float_type()->bits() != vtype->float_type()->bits())\n-\t\t    return this;\n-\t\t}\n-\t      else if (vtype->complex_type() != NULL)\n-\t\t{\n-\t\t  if (type->float_type()->bits() * 2\n-\t\t      != vtype->complex_type()->bits())\n-\t\t    return this;\n-\t\t}\n-\t    }\n-\t  else if (type->complex_type() != NULL)\n-\t    {\n-\t      if (vtype->complex_type() != NULL)\n-\t\t{\n-\t\t  if (type->complex_type()->bits()\n-\t\t      != vtype->complex_type()->bits())\n-\t\t    return this;\n-\t\t}\n-\t      else if (vtype->float_type() != NULL)\n-\t\t{\n-\t\t  if (type->complex_type()->bits()\n-\t\t      != vtype->float_type()->bits() * 2)\n-\t\t    return this;\n-\t\t}\n-\t    }\n-\t  else if (vtype->float_type() != NULL)\n-\t    return this;\n-\t  else if (vtype->complex_type() != NULL)\n-\t    return this;\n-\n \t  return nc.expression(location);\n \t}\n     }\n@@ -9239,6 +9199,9 @@ Call_expression::do_get_tree(Translate_context* context)\n \t}\n     }\n \n+  if (func == NULL)\n+    fn = save_expr(fn);\n+\n   tree ret = build_call_array(excess_type != NULL_TREE ? excess_type : rettype,\n \t\t\t      fn, nargs, args);\n   delete[] args;\n@@ -9272,6 +9235,24 @@ Call_expression::do_get_tree(Translate_context* context)\n   if (this->results_ != NULL)\n     ret = this->set_results(context, ret);\n \n+  // We can't unwind the stack past a call to nil, so we need to\n+  // insert an explicit check so that the panic can be recovered.\n+  if (func == NULL)\n+    {\n+      tree compare = fold_build2_loc(location.gcc_location(), EQ_EXPR,\n+\t\t\t\t     boolean_type_node, fn,\n+\t\t\t\t     fold_convert_loc(location.gcc_location(),\n+\t\t\t\t\t\t      TREE_TYPE(fn),\n+\t\t\t\t\t\t      null_pointer_node));\n+      tree crash = build3_loc(location.gcc_location(), COND_EXPR,\n+\t\t\t      void_type_node, compare,\n+\t\t\t      gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n+\t\t\t\t\t\t  location),\n+\t\t\t      NULL_TREE);\n+      ret = fold_build2_loc(location.gcc_location(), COMPOUND_EXPR,\n+\t\t\t    TREE_TYPE(ret), crash, ret);\n+    }\n+\n   this->tree_ = ret;\n \n   return ret;\n@@ -14229,7 +14210,7 @@ Numeric_constant::check_int_type(Integer_type* type, bool issue_error,\n \n bool\n Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n-\t\t\t\t   Location location) const\n+\t\t\t\t   Location location)\n {\n   mpfr_t val;\n   switch (this->classification_)\n@@ -14282,6 +14263,29 @@ Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n \t}\n \n       ret = exp <= max_exp;\n+\n+      if (ret)\n+\t{\n+\t  // Round the constant to the desired type.\n+\t  mpfr_t t;\n+\t  mpfr_init(t);\n+\t  switch (type->bits())\n+\t    {\n+\t    case 32:\n+\t      mpfr_set_prec(t, 24);\n+\t      break;\n+\t    case 64:\n+\t      mpfr_set_prec(t, 53);\n+\t      break;\n+\t    default:\n+\t      go_unreachable();\n+\t    }\n+\t  mpfr_set(t, val, GMP_RNDN);\n+\t  mpfr_set(val, t, GMP_RNDN);\n+\t  mpfr_clear(t);\n+\n+\t  this->set_float(type, val);\n+\t}\n     }\n \n   mpfr_clear(val);\n@@ -14296,7 +14300,7 @@ Numeric_constant::check_float_type(Float_type* type, bool issue_error,\n \n bool\n Numeric_constant::check_complex_type(Complex_type* type, bool issue_error,\n-\t\t\t\t     Location location) const\n+\t\t\t\t     Location location)\n {\n   if (type->is_abstract())\n     return true;\n@@ -14315,46 +14319,77 @@ Numeric_constant::check_complex_type(Complex_type* type, bool issue_error,\n     }\n \n   mpfr_t real;\n+  mpfr_t imag;\n   switch (this->classification_)\n     {\n     case NC_INT:\n     case NC_RUNE:\n       mpfr_init_set_z(real, this->u_.int_val, GMP_RNDN);\n+      mpfr_init_set_ui(imag, 0, GMP_RNDN);\n       break;\n \n     case NC_FLOAT:\n       mpfr_init_set(real, this->u_.float_val, GMP_RNDN);\n+      mpfr_init_set_ui(imag, 0, GMP_RNDN);\n       break;\n \n     case NC_COMPLEX:\n-      if (!mpfr_nan_p(this->u_.complex_val.imag)\n-\t  && !mpfr_inf_p(this->u_.complex_val.imag)\n-\t  && !mpfr_zero_p(this->u_.complex_val.imag))\n-\t{\n-\t  if (mpfr_get_exp(this->u_.complex_val.imag) > max_exp)\n-\t    {\n-\t      if (issue_error)\n-\t\terror_at(location, \"complex imaginary part overflow\");\n-\t      return false;\n-\t    }\n-\t}\n       mpfr_init_set(real, this->u_.complex_val.real, GMP_RNDN);\n+      mpfr_init_set(imag, this->u_.complex_val.imag, GMP_RNDN);\n       break;\n \n     default:\n       go_unreachable();\n     }\n \n-  bool ret;\n-  if (mpfr_nan_p(real) || mpfr_inf_p(real) || mpfr_zero_p(real))\n-    ret = true;\n-  else\n-    ret = mpfr_get_exp(real) <= max_exp;\n+  bool ret = true;\n+  if (!mpfr_nan_p(real)\n+      && !mpfr_inf_p(real)\n+      && !mpfr_zero_p(real)\n+      && mpfr_get_exp(real) > max_exp)\n+    {\n+      if (issue_error)\n+\terror_at(location, \"complex real part overflow\");\n+      ret = false;\n+    }\n \n-  mpfr_clear(real);\n+  if (!mpfr_nan_p(imag)\n+      && !mpfr_inf_p(imag)\n+      && !mpfr_zero_p(imag)\n+      && mpfr_get_exp(imag) > max_exp)\n+    {\n+      if (issue_error)\n+\terror_at(location, \"complex imaginary part overflow\");\n+      ret = false;\n+    }\n \n-  if (!ret && issue_error)\n-    error_at(location, \"complex real part overflow\");\n+  if (ret)\n+    {\n+      // Round the constant to the desired type.\n+      mpfr_t t;\n+      mpfr_init(t);\n+      switch (type->bits())\n+\t{\n+\tcase 64:\n+\t  mpfr_set_prec(t, 24);\n+\t  break;\n+\tcase 128:\n+\t  mpfr_set_prec(t, 53);\n+\t  break;\n+\tdefault:\n+\t  go_unreachable();\n+\t}\n+      mpfr_set(t, real, GMP_RNDN);\n+      mpfr_set(real, t, GMP_RNDN);\n+      mpfr_set(t, imag, GMP_RNDN);\n+      mpfr_set(imag, t, GMP_RNDN);\n+      mpfr_clear(t);\n+\n+      this->set_complex(type, real, imag);\n+    }\n+\n+  mpfr_clear(real);\n+  mpfr_clear(imag);\n \n   return ret;\n }"}, {"sha": "eb4406dc9eb80b06fa6075a11fa04ec31a045100", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405c87c4d340b83a6aba4a036dd258855342750b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405c87c4d340b83a6aba4a036dd258855342750b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=405c87c4d340b83a6aba4a036dd258855342750b", "patch": "@@ -2224,10 +2224,10 @@ class Numeric_constant\n   check_int_type(Integer_type*, bool, Location) const;\n \n   bool\n-  check_float_type(Float_type*, bool, Location) const;\n+  check_float_type(Float_type*, bool, Location);\n \n   bool\n-  check_complex_type(Complex_type*, bool, Location) const;\n+  check_complex_type(Complex_type*, bool, Location);\n \n   // The kinds of constants.\n   enum Classification"}]}