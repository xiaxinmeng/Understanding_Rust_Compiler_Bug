{"sha": "60378a964a2a6b32b9d05de053e181d691f68d52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAzNzhhOTY0YTJhNmIzMmI5ZDA1ZGUwNTNlMTgxZDY5MWY2OGQ1Mg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2019-02-13T17:42:39Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-02-13T17:42:39Z"}, "message": "[PR87322] move cp_evaluated up to tsubst all lambda parms\n\nA lambda capture variable initialized with a lambda expr taking more\nthan one parameter got us confused.\n\nThe first problem was that the parameter list was cut short during\ntsubsting because we tsubsted it with cp_unevaluated_operand.  We\nreset it right after, to tsubst the function body, so I've moved the\nreset up so that it's in effect while processing the parameters as\nwell.\n\nThe second problem was that the lambda expr appeared twice, once in a\ndecltype that gave the capture variable its type, and once in its\ninitializer.  This caused us to instantiate two separate lambda exprs\nand closure types, and then to flag that the lambda expr in the\ninitializer could not be converted to the unrelated closure type\ndetermined for the capture variable.  Recording the tsubsted expr in\nthe local specialization map, and retrieving it for reuse fixed it.\nHowever, that required some care to avoid reusing the lambda expr\nacross different indices in pack expansions.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/87322\n\t* pt.c (tsubst_lambda_expr): Avoid duplicate tsubsting.\n\tMove cp_evaluated resetting before signature tsubsting.\n\t(gen_elem_of_pack_expansion_instantiation): Separate local\n\tspecializations per index.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR c++/87322\n\t* g++.dg/cpp1y/pr87322.C: New.\n\t* g++.dg/cpp0x/lambda/lambda-variadic5.C: Test that we\n\tinstantiate the expected number of lambda functions.\n\nFrom-SVN: r268850", "tree": {"sha": "15235c60c3d0ca6c9c6eb290ebe34f1ff02366b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15235c60c3d0ca6c9c6eb290ebe34f1ff02366b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60378a964a2a6b32b9d05de053e181d691f68d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60378a964a2a6b32b9d05de053e181d691f68d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60378a964a2a6b32b9d05de053e181d691f68d52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60378a964a2a6b32b9d05de053e181d691f68d52/comments", "author": null, "committer": null, "parents": [{"sha": "2db698cefc5b7e2a66ca64d8485dd9156ee7442f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2db698cefc5b7e2a66ca64d8485dd9156ee7442f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2db698cefc5b7e2a66ca64d8485dd9156ee7442f"}], "stats": {"total": 62, "additions": 58, "deletions": 4}, "files": [{"sha": "9627f3b1444bc567d4ed5d088cd34a72b9a14206", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=60378a964a2a6b32b9d05de053e181d691f68d52", "patch": "@@ -1,3 +1,11 @@\n+2019-02-13  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/87322\n+\t* pt.c (tsubst_lambda_expr): Avoid duplicate tsubsting.\n+\tMove cp_evaluated resetting before signature tsubsting.\n+\t(gen_elem_of_pack_expansion_instantiation): Separate local\n+\tspecializations per index.\n+\n 2019-02-13  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/89036"}, {"sha": "48cbf3d9892c2e42a7265ac673bd13518820aeac", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=60378a964a2a6b32b9d05de053e181d691f68d52", "patch": "@@ -11700,6 +11700,10 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n       ARGUMENT_PACK_SELECT_INDEX (aps) = index;\n     }\n \n+  // Any local specialization bindings arising from this substitution\n+  // cannot be reused for a different INDEX.\n+  local_specialization_stack lss (lss_copy);\n+\n   /* Substitute into the PATTERN with the (possibly altered)\n      arguments.  */\n   if (pattern == in_decl)\n@@ -17932,8 +17936,17 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   tree oldfn = lambda_function (t);\n   in_decl = oldfn;\n \n+  /* If we have already specialized this lambda expr, reuse it.  See\n+     PR c++/87322.  */\n+  if (local_specializations)\n+    if (tree r = retrieve_local_specialization (t))\n+      return r;\n+\n   tree r = build_lambda_expr ();\n \n+  if (local_specializations)\n+    register_local_specialization (r, t);\n+\n   LAMBDA_EXPR_LOCATION (r)\n     = LAMBDA_EXPR_LOCATION (t);\n   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)\n@@ -18025,6 +18038,11 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     r = error_mark_node;\n   else\n     {\n+      /* The body of a lambda-expression is not a subexpression of the\n+\t enclosing expression.  Parms are to have DECL_CHAIN tsubsted,\n+\t which would be skipped if cp_unevaluated_operand.  */\n+      cp_evaluated ev;\n+\n       /* Fix the type of 'this'.  */\n       fntype = build_memfn_type (fntype, type,\n \t\t\t\t type_memfn_quals (fntype),\n@@ -18046,10 +18064,6 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       /* Let finish_function set this.  */\n       DECL_DECLARED_CONSTEXPR_P (fn) = false;\n \n-      /* The body of a lambda-expression is not a subexpression of the\n-\t enclosing expression.  */\n-      cp_evaluated ev;\n-\n       bool nested = cfun;\n       if (nested)\n \tpush_function_context ();"}, {"sha": "ad25ccb7dc5b25246be2e08cc1fb97ba23bc4d0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60378a964a2a6b32b9d05de053e181d691f68d52", "patch": "@@ -1,3 +1,10 @@\n+2019-02-13  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/87322\n+\t* g++.dg/cpp1y/pr87322.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-variadic5.C: Test that we\n+\tinstantiate the expected number of lambda functions.\n+\n 2019-02-13  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/77304"}, {"sha": "1f931757b72f22aee819c291205b9c9e88f82ccb", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic5.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic5.C?ref=60378a964a2a6b32b9d05de053e181d691f68d52", "patch": "@@ -1,5 +1,7 @@\n // PR c++/47226\n // { dg-do compile { target c++11 } }\n+// { dg-options \"-fdump-tree-original\" }\n+// { dg-final { scan-tree-dump-times \"::<lambda\\\\(\\\\)> \\\\(null\\\\)\" 6 \"original\" } }\n \n template<class T>\n void print(const T&) {}"}, {"sha": "8f52e0e3b99bae9564ea0565740870570659a258", "filename": "gcc/testsuite/g++.dg/cpp1y/pr87322.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr87322.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60378a964a2a6b32b9d05de053e181d691f68d52/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr87322.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr87322.C?ref=60378a964a2a6b32b9d05de053e181d691f68d52", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile { target c++14 } }\n+\n+#include <array>\n+#include <algorithm>\n+\n+int main()\n+{\n+  constexpr std::array<std::array<double,2>,3> my_mat { \n+     { { 1., 1. },\n+       { 1., 1. },\n+       { 1., 1. }, }\n+  };\n+  \n+  std::for_each(my_mat.begin(), my_mat.end(), [\n+      inner_func =  [] (auto a, auto b) { return a + b; } ](auto& row) {\n+    std::for_each(row.begin(), row.end(), [&,\n+      inner_func2 =  [] (auto a, auto b) { return a + b; } ]\n+      (const double&) {\n+        return;\n+    });\n+  }); \n+  \n+}"}]}