{"sha": "a29262fd4476d0d0e5144b794d966cc676e9cef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5MjYyZmQ0NDc2ZDBkMGU1MTQ0Yjc5NGQ5NjZjYzY3NmU5Y2VmMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T12:44:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T12:44:17Z"}, "message": "[multiple changes]\n\n2009-04-08  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-nmsc.adb (Check_File, Process_Sources_In_Multi_Language_Mode):\n\tavoid copies of Source_Data variables when possible, since these\n\tinvolve calls to memcpy() which are done too many times.\n\n2009-04-08  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Clean up code\n\nFrom-SVN: r145721", "tree": {"sha": "a2a551bee270f1913fac097232a8bb8e6d194b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2a551bee270f1913fac097232a8bb8e6d194b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29262fd4476d0d0e5144b794d966cc676e9cef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29262fd4476d0d0e5144b794d966cc676e9cef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29262fd4476d0d0e5144b794d966cc676e9cef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29262fd4476d0d0e5144b794d966cc676e9cef3/comments", "author": null, "committer": null, "parents": [{"sha": "ad1536a1e7bb1b180235a79bed387ca53cf063c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1536a1e7bb1b180235a79bed387ca53cf063c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad1536a1e7bb1b180235a79bed387ca53cf063c5"}], "stats": {"total": 314, "additions": 164, "deletions": 150}, "files": [{"sha": "91ac2e5b1b00fcb24b6ad4cc491b7f370b2eb048", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29262fd4476d0d0e5144b794d966cc676e9cef3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29262fd4476d0d0e5144b794d966cc676e9cef3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a29262fd4476d0d0e5144b794d966cc676e9cef3", "patch": "@@ -1,3 +1,13 @@\n+2009-04-08  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_File, Process_Sources_In_Multi_Language_Mode):\n+\tavoid copies of Source_Data variables when possible, since these\n+\tinvolve calls to memcpy() which are done too many times.\n+\n+2009-04-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Clean up code\n+\n 2009-04-07  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_ch4.adb (Expand_Concatenate): Add missing conversion to index"}, {"sha": "fa8ef46389e15575f55368fc6e9db8ab0b019a05", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29262fd4476d0d0e5144b794d966cc676e9cef3/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29262fd4476d0d0e5144b794d966cc676e9cef3/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a29262fd4476d0d0e5144b794d966cc676e9cef3", "patch": "@@ -62,7 +62,6 @@ with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -2168,7 +2167,14 @@ package body Exp_Ch4 is\n       --  Number of concatenation operands including possibly null operands\n \n       NN : Nat := 0;\n-      --  Number of operands excluding any known to be null\n+      --  Number of operands excluding any known to be null, except that the\n+      --  last operand is always retained, in case it provides the bounds for\n+      --  a null result.\n+\n+      Opnd : Node_Id;\n+      --  Current operand being processed in the loop through operands. After\n+      --  this loop is complete, always contains the last operand (which is not\n+      --  the same as Operands (NN), since null operands are skipped).\n \n       --  Arrays describing the operands, only the first NN entries of each\n       --  array are set (NN < N when we exclude known null operands).\n@@ -2177,7 +2183,8 @@ package body Exp_Ch4 is\n       --  True if length of corresponding operand known at compile time\n \n       Operands : array (1 .. N) of Node_Id;\n-      --  Set to the corresponding entry in the Opnds list\n+      --  Set to the corresponding entry in the Opnds list (but note that null\n+      --  operands are excluded, so not all entries in the list are stored).\n \n       Fixed_Length : array (1 .. N) of Uint;\n       --  Set to length of operand. Entries in this array are set only if the\n@@ -2188,11 +2195,6 @@ package body Exp_Ch4 is\n       --  where the bound is known at compile time, else actual lower bound.\n       --  The operand low bound is of type Ityp.\n \n-      Opnd_High_Bound : array (1 .. N) of Node_Id;\n-      --  Set to upper bound of operand. Either an integer literal in the case\n-      --  where the bound is known at compile time, else actual upper bound.\n-      --  The operand bound is of type Ityp.\n-\n       Var_Length : array (1 .. N) of Entity_Id;\n       --  Set to an entity of type Natural that contains the length of an\n       --  operand whose length is not known at compile time. Entries in this\n@@ -2211,6 +2213,12 @@ package body Exp_Ch4 is\n       --  This is either an integer literal node, or an identifier reference to\n       --  a constant entity initialized to the appropriate value.\n \n+      Last_Opnd_High_Bound : Node_Id;\n+      --  A tree node representing the high bound of the last operand. This\n+      --  need only be set if the result could be null. It is used for the\n+      --  special case of setting the right high bound for a null result.\n+      --  This is of type Ityp.\n+\n       High_Bound : Node_Id;\n       --  A tree node representing the high bound of the result (of type Ityp)\n \n@@ -2274,7 +2282,7 @@ package body Exp_Ch4 is\n             --  we analyzed and resolved the expression.\n \n             Set_Parent (X, Cnode);\n-            Analyze_And_Resolve (X, Intyp);\n+            Analyze_And_Resolve (X);\n \n             if Compile_Time_Compare\n                  (X, Type_High_Bound (Ityp),\n@@ -2302,7 +2310,6 @@ package body Exp_Ch4 is\n \n       --  Local Declarations\n \n-      Opnd     : Node_Id;\n       Opnd_Typ : Entity_Id;\n       Ent      : Entity_Id;\n       Len      : Uint;\n@@ -2383,9 +2390,8 @@ package body Exp_Ch4 is\n             Fixed_Length (NN) := Uint_1;\n             Result_May_Be_Null := False;\n \n-            --  Set bounds of operand (no need to set high bound since we know\n-            --  for sure that result won't be null, so we won't ever use\n-            --  Opnd_High_Bound).\n+            --  Set low bound of operand (no need to set Last_Opnd_High_Bound\n+            --  since we know that the result cannot be null).\n \n             Opnd_Low_Bound (NN) :=\n               Make_Attribute_Reference (Loc,\n@@ -2399,7 +2405,21 @@ package body Exp_Ch4 is\n          elsif Nkind (Opnd) = N_String_Literal then\n             Len := String_Literal_Length (Opnd_Typ);\n \n-            --  Skip null string literal unless last operand\n+            if Len /= 0 then\n+               Result_May_Be_Null := False;\n+            end if;\n+\n+            --  Capture last operand high bound if result could be null\n+\n+            if J = N and then Result_May_Be_Null then\n+               Last_Opnd_High_Bound :=\n+                 Make_Op_Add (Loc,\n+                   Left_Opnd  =>\n+                     New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ)),\n+                   Right_Opnd => Make_Integer_Literal (Loc, 1));\n+            end if;\n+\n+            --  Skip null string literal\n \n             if J < N and then Len = 0 then\n                goto Continue;\n@@ -2416,14 +2436,7 @@ package body Exp_Ch4 is\n             Opnd_Low_Bound (NN) :=\n               New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ));\n \n-            Opnd_High_Bound (NN) :=\n-              Make_Op_Add (Loc,\n-                Left_Opnd  =>\n-                  New_Copy_Tree (String_Literal_Low_Bound (Opnd_Typ)),\n-                Right_Opnd => Make_Integer_Literal (Loc, 1));\n-\n             Set := True;\n-            Result_May_Be_Null := False;\n \n          --  All other cases\n \n@@ -2456,10 +2469,18 @@ package body Exp_Ch4 is\n                            Result_May_Be_Null := False;\n                         end if;\n \n-                        --  Exclude null length case except for last operand\n-                        --  (where we may need it to get proper bounds).\n+                        --  Capture last operand bound if result could be null\n+\n+                        if J = N and then Result_May_Be_Null then\n+                           Last_Opnd_High_Bound :=\n+                             Convert_To (Ityp,\n+                               Make_Integer_Literal (Loc,\n+                                 Intval => Expr_Value (Hi)));\n+                        end if;\n+\n+                        --  Exclude null length case unless last operand\n \n-                        if Len = 0 and then J < N then\n+                        if J < N and then Len = 0 then\n                            goto Continue;\n                         end if;\n \n@@ -2472,10 +2493,6 @@ package body Exp_Ch4 is\n                           Make_Integer_Literal (Loc,\n                             Intval => Expr_Value (Lo)));\n \n-                        Opnd_High_Bound (NN) := To_Ityp (\n-                          Make_Integer_Literal (Loc,\n-                            Intval => Expr_Value (Hi)));\n-\n                         Set := True;\n                      end;\n                   end if;\n@@ -2497,11 +2514,14 @@ package body Exp_Ch4 is\n                      Duplicate_Subexpr (Opnd, Name_Req => True),\n                    Attribute_Name => Name_First);\n \n-               Opnd_High_Bound (NN) :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         =>\n-                     Duplicate_Subexpr (Opnd, Name_Req => True),\n-                   Attribute_Name => Name_Last);\n+               if J = N and Result_May_Be_Null then\n+                  Last_Opnd_High_Bound :=\n+                    Convert_To (Ityp,\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix         =>\n+                          Duplicate_Subexpr (Opnd, Name_Req => True),\n+                        Attribute_Name => Name_Last));\n+               end if;\n \n                --  Capture length of operand in entity\n \n@@ -2593,14 +2613,10 @@ package body Exp_Ch4 is\n          J := J + 1;\n       end loop;\n \n-      --  If we have only skipped null operands, return a null string literal.\n-      --  Note that this means the lower bound is 1 and the type is string,\n-      --  since we retained any null operands with a type other than string,\n-      --  or a lower bound other than one, so this is a legitimate assumption.\n+      --  If we have only skipped null operands, return the last operand\n \n       if NN = 0 then\n-         Start_String;\n-         Result := Make_String_Literal (Loc, Strval => End_String);\n+         Result := Opnd;\n          goto Done;\n       end if;\n \n@@ -2703,10 +2719,7 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n-      --  Now find the upper bound. This is normally the Low_Bound + Length - 1\n-      --  but there is one exception, namely when the result is null in which\n-      --  case the bounds come from the last operand (so that we get the proper\n-      --  bounds if the last operand is super-flat).\n+      --  Now find the upper bound, normally this is Low_Bound + Length - 1\n \n       High_Bound :=\n         To_Ityp (\n@@ -2717,14 +2730,18 @@ package body Exp_Ch4 is\n                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n                 Right_Opnd => Make_Integer_Literal (Loc, 1))));\n \n+      --  But there is one exception, namely when the result is null in which\n+      --  case the bounds come from the last operand (so that we get the proper\n+      --  bounds if the last operand is super-flat).\n+\n       if Result_May_Be_Null then\n          High_Bound :=\n            Make_Conditional_Expression (Loc,\n              Expressions => New_List (\n                Make_Op_Eq (Loc,\n                  Left_Opnd  => New_Copy (Aggr_Length (NN)),\n                  Right_Opnd => Make_Integer_Literal (Loc, 0)),\n-               Opnd_High_Bound (NN),\n+               Last_Opnd_High_Bound,\n                High_Bound));\n       end if;\n "}, {"sha": "8ad0d7ebcd5b07b41a5f2a6f4dcfd1c3fa2c0753", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 93, "deletions": 106, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29262fd4476d0d0e5144b794d966cc676e9cef3/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29262fd4476d0d0e5144b794d966cc676e9cef3/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=a29262fd4476d0d0e5144b794d966cc676e9cef3", "patch": "@@ -50,6 +50,8 @@ with Ada.Strings.Maps.Constants; use Ada.Strings.Maps.Constants;\n \n package body Prj.Nmsc is\n \n+   type Source_Data_Access is access Source_Data;\n+\n    No_Continuation_String : aliased String := \"\";\n    Continuation_String    : aliased String := \"\\\";\n    --  Used in Check_Library for continuation error messages at the same\n@@ -796,7 +798,7 @@ package body Prj.Nmsc is\n             declare\n                Language      : Language_Index;\n                Source        : Source_Id;\n-               Src_Data      : Source_Data;\n+               Src_Data      : Source_Data_Access;\n                Alt_Lang      : Alternate_Language_Id;\n                Alt_Lang_Data : Alternate_Language_Data;\n                Continuation  : Boolean := False;\n@@ -806,7 +808,8 @@ package body Prj.Nmsc is\n                while Language /= No_Language_Index loop\n                   Source := Data.First_Source;\n                   Source_Loop : while Source /= No_Source loop\n-                     Src_Data := In_Tree.Sources.Table (Source);\n+                     Src_Data :=\n+                       In_Tree.Sources.Table (Source)'Unrestricted_Access;\n \n                      exit Source_Loop when Src_Data.Language = Language;\n \n@@ -2494,7 +2497,7 @@ package body Prj.Nmsc is\n       Name    : File_Name_Type;\n \n       Source   : Source_Id;\n-      Src_Data : Source_Data;\n+      Src_Data : Source_Data_Access;\n \n       Project_2 : Project_Id;\n       Data_2     : Project_Data;\n@@ -2510,9 +2513,8 @@ package body Prj.Nmsc is\n          loop\n             Source := Data_2.First_Source;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source);\n+               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n                Src_Data.In_Interfaces := False;\n-               In_Tree.Sources.Table (Source) := Src_Data;\n                Source := Src_Data.Next_In_Project;\n             end loop;\n \n@@ -2536,12 +2538,12 @@ package body Prj.Nmsc is\n             loop\n                Source := Data_2.First_Source;\n                while Source /= No_Source loop\n-                  Src_Data := In_Tree.Sources.Table (Source);\n+                  Src_Data :=\n+                    In_Tree.Sources.Table (Source)'Unrestricted_Access;\n                   if Src_Data.File = Name then\n                      if not Src_Data.Locally_Removed then\n-                        In_Tree.Sources.Table (Source).In_Interfaces := True;\n-                        In_Tree.Sources.Table\n-                          (Source).Declared_In_Interfaces := True;\n+                        Src_Data.In_Interfaces := True;\n+                        Src_Data.Declared_In_Interfaces := True;\n \n                         if Src_Data.Other_Part /= No_Source then\n                            In_Tree.Sources.Table\n@@ -2594,11 +2596,10 @@ package body Prj.Nmsc is\n          if Data.Interfaces_Defined then\n             Source := Data.First_Source;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source);\n+               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n \n                if not Src_Data.Declared_In_Interfaces then\n                   Src_Data.In_Interfaces := False;\n-                  In_Tree.Sources.Table (Source) := Src_Data;\n                end if;\n \n                Source := Src_Data.Next_In_Project;\n@@ -3529,7 +3530,7 @@ package body Prj.Nmsc is\n       procedure Check_Library (Proj : Project_Id; Extends : Boolean) is\n          Proj_Data : Project_Data;\n          Src_Id    : Source_Id;\n-         Src       : Source_Data;\n+         Src       : Source_Data_Access;\n \n       begin\n          if Proj /= No_Project then\n@@ -3543,7 +3544,7 @@ package body Prj.Nmsc is\n \n                Src_Id := Proj_Data.First_Source;\n                while Src_Id /= No_Source loop\n-                  Src := In_Tree.Sources.Table (Src_Id);\n+                  Src := In_Tree.Sources.Table (Src_Id)'Unrestricted_Access;\n \n                   exit when Src.Lang_Kind /= File_Based\n                     or else Src.Kind /= Spec;\n@@ -6412,8 +6413,6 @@ package body Prj.Nmsc is\n    is\n       Mains : constant Variable_Value :=\n                 Prj.Util.Value_Of (Name_Main, Data.Decl.Attributes, In_Tree);\n-      List  : String_List_Id;\n-      Elem  : String_Element;\n \n    begin\n       Data.Mains := Mains.Values;\n@@ -6434,24 +6433,6 @@ package body Prj.Nmsc is\n            (Project, In_Tree,\n             \"a library project file cannot have Main specified\",\n             Mains.Location);\n-\n-      --  Normal case where Main was specified\n-\n-      else\n-         List := Mains.Values;\n-         while List /= Nil_String loop\n-            Elem := In_Tree.String_Elements.Table (List);\n-\n-            if Length_Of_Name (Elem.Value) = 0 then\n-               Error_Msg\n-                 (Project, In_Tree,\n-                  \"?a main cannot have an empty name\",\n-                  Elem.Location);\n-               exit;\n-            end if;\n-\n-            List := Elem.Next;\n-         end loop;\n       end if;\n    end Get_Mains;\n \n@@ -7385,12 +7366,12 @@ package body Prj.Nmsc is\n \n          declare\n             Source   : Source_Id;\n-            Src_Data : Source_Data;\n+            Src_Data : Source_Data_Access;\n \n          begin\n             Source := Data.First_Source;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source);\n+               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n \n                if Src_Data.Naming_Exception\n                  and then Src_Data.Path = No_Path_Information\n@@ -8025,7 +8006,6 @@ package body Prj.Nmsc is\n       Other_Part        : Source_Id;\n       Add_Src           : Boolean;\n       Src_Ind           : Source_File_Index;\n-      Src_Data          : Source_Data;\n       Unit              : Name_Id;\n       Source_To_Replace : Source_Id := No_Source;\n       Language_Name         : Name_Id;\n@@ -8131,86 +8111,94 @@ package body Prj.Nmsc is\n             Source := In_Tree.First_Source;\n             Add_Src := True;\n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source);\n+               declare\n+                  Src_Data : constant Source_Data_Access :=\n+                    In_Tree.Sources.Table (Source)'Unrestricted_Access;\n+               begin\n \n-               if Unit /= No_Name\n-                 and then Src_Data.Unit = Unit\n-                 and then\n-                   ((Src_Data.Kind = Spec and then Kind = Impl)\n-                      or else\n-                    (Src_Data.Kind = Impl and then Kind = Spec))\n-               then\n-                  Other_Part := Source;\n+                  if Unit /= No_Name\n+                    and then Src_Data.Unit = Unit\n+                    and then\n+                      ((Src_Data.Kind = Spec and then Kind = Impl)\n+                       or else\n+                         (Src_Data.Kind = Impl and then Kind = Spec))\n+                  then\n+                     Other_Part := Source;\n \n-               elsif (Unit /= No_Name\n-                       and then Src_Data.Unit = Unit\n-                       and then\n-                         (Src_Data.Kind = Kind\n+                  elsif (Unit /= No_Name\n+                         and then Src_Data.Unit = Unit\n+                         and then\n+                           (Src_Data.Kind = Kind\n                             or else\n-                         (Src_Data.Kind = Sep and then Kind = Impl)\n+                              (Src_Data.Kind = Sep and then Kind = Impl)\n                             or else\n-                         (Src_Data.Kind = Impl and then Kind = Sep)))\n-                 or else (Unit = No_Name and then Src_Data.File = File_Name)\n-               then\n-                  --  Duplication of file/unit in same project is only\n-                  --  allowed if order of source directories is known.\n+                              (Src_Data.Kind = Impl and then Kind = Sep)))\n+                    or else\n+                      (Unit = No_Name and then Src_Data.File = File_Name)\n+                  then\n+                     --  Duplication of file/unit in same project is only\n+                     --  allowed if order of source directories is known.\n \n-                  if Project = Src_Data.Project then\n-                     if Data.Known_Order_Of_Source_Dirs then\n-                        Add_Src := False;\n+                     if Project = Src_Data.Project then\n+                        if Data.Known_Order_Of_Source_Dirs then\n+                           Add_Src := False;\n \n-                     elsif Unit /= No_Name then\n-                        Error_Msg_Name_1 := Unit;\n-                        Error_Msg\n-                          (Project, In_Tree, \"duplicate unit %%\", No_Location);\n-                        Add_Src := False;\n+                        elsif Unit /= No_Name then\n+                           Error_Msg_Name_1 := Unit;\n+                           Error_Msg\n+                             (Project, In_Tree, \"duplicate unit %%\",\n+                              No_Location);\n+                           Add_Src := False;\n \n-                     else\n-                        Error_Msg_File_1 := File_Name;\n-                        Error_Msg\n-                          (Project, In_Tree, \"duplicate source file name {\",\n-                           No_Location);\n-                        Add_Src := False;\n-                     end if;\n+                        else\n+                           Error_Msg_File_1 := File_Name;\n+                           Error_Msg\n+                             (Project, In_Tree, \"duplicate source file name {\",\n+                              No_Location);\n+                           Add_Src := False;\n+                        end if;\n \n-                     --  Do not allow the same unit name in different\n-                     --  projects, except if one is extending the other.\n+                        --  Do not allow the same unit name in different\n+                        --  projects, except if one is extending the other.\n \n-                     --  For a file based language, the same file name\n-                     --  replaces a file in a project being extended, but\n-                     --  it is allowed to have the same file name in\n-                     --  unrelated projects.\n+                        --  For a file based language, the same file name\n+                        --  replaces a file in a project being extended, but\n+                        --  it is allowed to have the same file name in\n+                        --  unrelated projects.\n \n-                  elsif Is_Extending\n-                    (Project, Src_Data.Project, In_Tree)\n-                  then\n-                     Source_To_Replace := Source;\n+                     elsif Is_Extending\n+                       (Project, Src_Data.Project, In_Tree)\n+                     then\n+                        Source_To_Replace := Source;\n \n-                  elsif Unit /= No_Name\n-                    and then not Src_Data.Locally_Removed\n-                  then\n-                     Error_Msg_Name_1 := Unit;\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"unit %% cannot belong to several projects\",\n-                        No_Location);\n+                     elsif Unit /= No_Name\n+                       and then not Src_Data.Locally_Removed\n+                     then\n+                        Error_Msg_Name_1 := Unit;\n+                        Error_Msg\n+                          (Project, In_Tree,\n+                           \"unit %% cannot belong to several projects\",\n+                           No_Location);\n \n-                     Error_Msg_Name_1 := In_Tree.Projects.Table (Project).Name;\n-                     Error_Msg_Name_2 := Name_Id (Display_Path_Id);\n-                     Error_Msg\n-                       (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n+                        Error_Msg_Name_1 :=\n+                          In_Tree.Projects.Table (Project).Name;\n+                        Error_Msg_Name_2 := Name_Id (Display_Path_Id);\n+                        Error_Msg\n+                          (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n \n-                     Error_Msg_Name_1 :=\n-                       In_Tree.Projects.Table (Src_Data.Project).Name;\n-                     Error_Msg_Name_2 := Name_Id (Src_Data.Path.Display_Name);\n-                     Error_Msg\n-                       (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n+                        Error_Msg_Name_1 :=\n+                          In_Tree.Projects.Table (Src_Data.Project).Name;\n+                        Error_Msg_Name_2 :=\n+                          Name_Id (Src_Data.Path.Display_Name);\n+                        Error_Msg\n+                          (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n \n-                     Add_Src := False;\n+                        Add_Src := False;\n+                     end if;\n                   end if;\n-               end if;\n \n-               Source := Src_Data.Next_In_Sources;\n+                  Source := Src_Data.Next_In_Sources;\n+               end;\n             end loop;\n \n             if Add_Src then\n@@ -8449,7 +8437,7 @@ package body Prj.Nmsc is\n \n       procedure Process_Sources_In_Multi_Language_Mode is\n          Source   : Source_Id;\n-         Src_Data : Source_Data;\n+         Src_Data : Source_Data_Access;\n          Name_Loc : Name_Location;\n          OK       : Boolean;\n          FF       : File_Found;\n@@ -8461,7 +8449,7 @@ package body Prj.Nmsc is\n \n          Source := Data.First_Source;\n          while Source /= No_Source loop\n-            Src_Data := In_Tree.Sources.Table (Source);\n+            Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n \n             --  A file that is excluded cannot also be an exception file name\n \n@@ -8525,7 +8513,7 @@ package body Prj.Nmsc is\n             Source := In_Tree.First_Source;\n \n             while Source /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Source);\n+               Src_Data := In_Tree.Sources.Table (Source)'Unrestricted_Access;\n \n                if Src_Data.File = FF.File then\n \n@@ -8537,7 +8525,6 @@ package body Prj.Nmsc is\n                   then\n                      Src_Data.Locally_Removed := True;\n                      Src_Data.In_Interfaces := False;\n-                     In_Tree.Sources.Table (Source) := Src_Data;\n                      Add_Forbidden_File_Name (FF.File);\n                      OK := True;\n                      exit;\n@@ -8560,7 +8547,7 @@ package body Prj.Nmsc is\n \n          Check_Object_File_Names : declare\n             Src_Id      : Source_Id;\n-            Src_Data    : Source_Data;\n+            Src_Data    : Source_Data_Access;\n             Source_Name : File_Name_Type;\n \n             procedure Check_Object;\n@@ -8596,7 +8583,7 @@ package body Prj.Nmsc is\n             Object_File_Names.Reset;\n             Src_Id := In_Tree.First_Source;\n             while Src_Id /= No_Source loop\n-               Src_Data := In_Tree.Sources.Table (Src_Id);\n+               Src_Data := In_Tree.Sources.Table (Src_Id)'Unrestricted_Access;\n \n                if Src_Data.Compiled and then Src_Data.Object_Exists\n                  and then Project_Extends (Project, Src_Data.Project, In_Tree)"}]}