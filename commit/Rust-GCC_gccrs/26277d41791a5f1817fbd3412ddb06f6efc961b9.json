{"sha": "26277d41791a5f1817fbd3412ddb06f6efc961b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyNzdkNDE3OTFhNWYxODE3ZmJkMzQxMmRkYjA2ZjZlZmM5NjFiOQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-07-22T08:20:40Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-22T08:20:40Z"}, "message": "tree-cfg.c (gimplify_val): Move from tree-complex.c.\n\n2004-07-22  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* tree-cfg.c (gimplify_val): Move from tree-complex.c.\n\t(gimplify_build1): Move from tree-complex.c do_unop.\n\t(gimplify_build2): Move from tree-complex.c do_binop.\n\t(gimplify_build3): New.\n\t* tree-complex.c (gimplify_val, do_unop, do_binop): Remove.\n\tAdjust throughout to call the functions above.\n\t* tree-flow.h: Declare the functions above.\n\t* tree-nested.c (gimplify_val): Rename to...\n\t(tsi_gimplify_val): ... this.\n\n\t* Makefile.in (tree_complex.o): Update dependencies.\n\t(stor-layout.o): Depend on regs.h.\n\t* c-common.c (handle_vector_size_attribute): Update for\n\tvector types without corresponding vector modes.\n\t* expr.c (expand_expr): Treat VECTOR_CST's like CONSTRUCTORS if\n\ta corresponding vector mode is not available.\n\t* print-tree.c (print_node): Print nunits for vector types\n\t* regclass.c (have_regs_of_mode): New.\n\t(init_reg_sets_1): Initialize it and use it instead\n\tof allocatable_regs_of_mode.\n\t* regs.h (have_regs_of_mode): Declare it.\n\t* stor-layout.c (layout_type): Pick a mode for vector types.\n\t* tree-complex.c (build_word_mode_vector_type, tree_vec_extract,\n\tbuild_replicated_const, do_unop, do_binop, do_plus_minus,\n\tdo_negate, expand_vector_piecewise, expand_vector_parallel,\n\texpand_vector_addition, expand_vector_operations_1,\n\texpand_vector_operations, tree_lower_operations,\n\tpass_lower_vector_ssa, pass_pre_expand): New.\n\t(expand_complex_operations, pass_lower_complex): Remove.\n\t* tree-optimize.c (init_tree_optimization_passes): Adjust\n\tpass ordering for changes in tree-complex.c.\n\t* tree-pass.h: Declare new passes.\n\t* tree.c (finish_vector_type): Remove.\n\t(make_vector_type): New.\n\t(build_vector_type_for_mode, build_vector_type): Rewritten.\n\t* tree.def (VECTOR_TYPE): Document where the number of\n\tsubparts is stored.\n\t* tree.h (TYPE_VECTOR_SUBPARTS): Use TYPE_PRECISION field.\n\t(make_vector): Remove declaration.\n\nFrom-SVN: r85039", "tree": {"sha": "4646f9e5e0b2387d4bcc7fc94aff9d320ae0030d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4646f9e5e0b2387d4bcc7fc94aff9d320ae0030d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26277d41791a5f1817fbd3412ddb06f6efc961b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26277d41791a5f1817fbd3412ddb06f6efc961b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26277d41791a5f1817fbd3412ddb06f6efc961b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26277d41791a5f1817fbd3412ddb06f6efc961b9/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "727a31fab813e31263cc0ee9f56940ee6d95782f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/727a31fab813e31263cc0ee9f56940ee6d95782f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/727a31fab813e31263cc0ee9f56940ee6d95782f"}], "stats": {"total": 1000, "additions": 827, "deletions": 173}, "files": [{"sha": "cdd99137bc89c94cf8ddf49d5cb6a9bb8fe80636", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -1,3 +1,45 @@\n+2004-07-22  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* tree-cfg.c (gimplify_val): Move from tree-complex.c.\n+\t(gimplify_build1): Move from tree-complex.c do_unop.\n+\t(gimplify_build2): Move from tree-complex.c do_binop.\n+\t(gimplify_build3): New.\n+\t* tree-complex.c (gimplify_val, do_unop, do_binop): Remove.\n+\tAdjust throughout to call the functions above.\n+\t* tree-flow.h: Declare the functions above.\n+\t* tree-nested.c (gimplify_val): Rename to...\n+\t(tsi_gimplify_val): ... this.\n+\n+\t* Makefile.in (tree_complex.o): Update dependencies.\n+\t(stor-layout.o): Depend on regs.h.\n+\t* c-common.c (handle_vector_size_attribute): Update for\n+\tvector types without corresponding vector modes.\n+\t* expr.c (expand_expr): Treat VECTOR_CST's like CONSTRUCTORS if\n+\ta corresponding vector mode is not available.\n+\t* print-tree.c (print_node): Print nunits for vector types\n+\t* regclass.c (have_regs_of_mode): New.\n+\t(init_reg_sets_1): Initialize it and use it instead\n+\tof allocatable_regs_of_mode.\n+\t* regs.h (have_regs_of_mode): Declare it.\n+\t* stor-layout.c (layout_type): Pick a mode for vector types.\n+\t* tree-complex.c (build_word_mode_vector_type, tree_vec_extract,\n+\tbuild_replicated_const, do_unop, do_binop, do_plus_minus,\n+\tdo_negate, expand_vector_piecewise, expand_vector_parallel,\n+\texpand_vector_addition, expand_vector_operations_1,\n+\texpand_vector_operations, tree_lower_operations,\n+\tpass_lower_vector_ssa, pass_pre_expand): New.\n+\t(expand_complex_operations, pass_lower_complex): Remove.\n+\t* tree-optimize.c (init_tree_optimization_passes): Adjust\n+\tpass ordering for changes in tree-complex.c.\n+\t* tree-pass.h: Declare new passes.\n+\t* tree.c (finish_vector_type): Remove.\n+\t(make_vector_type): New.\n+\t(build_vector_type_for_mode, build_vector_type): Rewritten.\n+\t* tree.def (VECTOR_TYPE): Document where the number of\n+\tsubparts is stored.\n+\t* tree.h (TYPE_VECTOR_SUBPARTS): Use TYPE_PRECISION field.\n+\t(make_vector): Remove declaration.\n+\n 2004-07-21  Richard Henderson  <rth@redhat.com>\n \n \t* gimple-low.c (expand_var_p): Don't look at TREE_ADDRESSABLE,"}, {"sha": "32bb1fe513e73bf1136323b1d213a468e1b8c697", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -1585,7 +1585,7 @@ print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H\n    $(GGC_H) langhooks.h real.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(FLAGS_H) function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H) $(TM_P_H) $(TARGET_H) \\\n-   langhooks.h\n+   langhooks.h $(REGS_H)\n tree-alias-type.o: tree-alias-type.c tree-alias-type.h $(SYSTEM_H) $(CONFIG_H) \\\n    $(GGC_H) $(TM_H) coretypes.h $(VARRAY_H)\n tree-alias-ander.o: tree-alias-ander.c tree-alias-ander.h $(SYSTEM_H) \\\n@@ -1922,7 +1922,8 @@ tree-sra.o : tree-sra.c $(CONFIG_H) system.h errors.h $(TREE_H) $(RTL_H) \\\n     langhooks.h tree-pass.h $(FLAGS_H) $(EXPR_H)\n tree-complex.o : tree-complex.c $(CONFIG_H) system.h $(TREE_H) \\\n     $(TM_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) tree-iterator.h tree-pass.h \\\n-    $(FLAGS_H)\n+    $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \\\n+    langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H)\n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(DF_H)"}, {"sha": "2f9e2e24e78d80d4f5a8f1039d0e159aea1e66d5", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -4783,7 +4783,7 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \t\t\t      bool *no_add_attrs)\n {\n   unsigned HOST_WIDE_INT vecsize, nunits;\n-  enum machine_mode mode, orig_mode, new_mode;\n+  enum machine_mode orig_mode;\n   tree type = *node, new_type, size;\n \n   *no_add_attrs = true;\n@@ -4832,28 +4832,13 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n \n   /* Calculate how many units fit in the vector.  */\n   nunits = vecsize / tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n-\n-  /* Find a suitably sized vector.  */\n-  new_mode = VOIDmode;\n-  for (mode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_mode) == MODE_INT\n-\t\t\t\t\t? MODE_VECTOR_INT\n-\t\t\t\t\t: MODE_VECTOR_FLOAT);\n-       mode != VOIDmode;\n-       mode = GET_MODE_WIDER_MODE (mode))\n-    if (vecsize == GET_MODE_SIZE (mode)\n-\t&& nunits == (unsigned HOST_WIDE_INT) GET_MODE_NUNITS (mode))\n-      {\n-\tnew_mode = mode;\n-\tbreak;\n-      }\n-\n-  if (new_mode == VOIDmode)\n+  if (nunits & (nunits - 1))\n     {\n-      error (\"no vector mode with the size and type specified could be found\");\n+      error (\"number of components of the vector not a power of two\");\n       return NULL_TREE;\n     }\n \n-  new_type = build_vector_type_for_mode (type, new_mode);\n+  new_type = build_vector_type (type, nunits);\n \n   /* Build back pointers if needed.  */\n   *node = reconstruct_complex_type (*node, new_type);"}, {"sha": "1f013f37a6092192dd7716f5acb8f1a8cdedcc07", "filename": "gcc/optabs.c", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -627,6 +627,89 @@ expand_cmplxdiv_wide (rtx real0, rtx real1, rtx imag0, rtx imag1, rtx realr,\n \n   return 1;\n }\n+\f\n+/* Return the optab used for computing the operation given by\n+   the tree code, CODE.  This function is not always usable (for\n+   example, it cannot give complete results for multiplication\n+   or division) but probably ought to be relied on more widely\n+   throughout the expander.  */\n+optab\n+optab_for_tree_code (enum tree_code code, tree type)\n+{\n+  bool trapv;\n+  switch (code)\n+    {\n+    case BIT_AND_EXPR:\n+      return and_optab;\n+\n+    case BIT_IOR_EXPR:\n+      return ior_optab;\n+\n+    case BIT_NOT_EXPR:\n+      return one_cmpl_optab;\n+\n+    case BIT_XOR_EXPR:\n+      return xor_optab;\n+\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+      return TYPE_UNSIGNED (type) ? umod_optab : smod_optab;\n+\n+    case RDIV_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      return TYPE_UNSIGNED (type) ? udiv_optab : sdiv_optab;\n+\n+    case LSHIFT_EXPR:\n+      return ashl_optab;\n+\n+    case RSHIFT_EXPR:\n+      return TYPE_UNSIGNED (type) ? lshr_optab : ashr_optab;\n+\n+    case LROTATE_EXPR:\n+      return rotl_optab;\n+\n+    case RROTATE_EXPR:\n+      return rotr_optab;\n+\n+    case MAX_EXPR:\n+      return TYPE_UNSIGNED (type) ? umax_optab : smax_optab;\n+\n+    case MIN_EXPR:\n+      return TYPE_UNSIGNED (type) ? umin_optab : smin_optab;\n+\n+    default:\n+      break;\n+    }\n+\n+  trapv = flag_trapv && INTEGRAL_TYPE_P (type) && !TYPE_UNSIGNED (type);\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      return trapv ? addv_optab : add_optab;\n+\n+    case MINUS_EXPR:\n+      return trapv ? subv_optab : sub_optab;\n+\n+    case MULT_EXPR:\n+      return trapv ? smulv_optab : smul_optab;\n+\n+    case NEGATE_EXPR:\n+      return trapv ? negv_optab : neg_optab;\n+\n+    case ABS_EXPR:\n+      return trapv ? absv_optab : abs_optab;\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n \f\n /* Wrapper around expand_binop which takes an rtx code to specify\n    the operation to perform, not an optab pointer.  All other\n@@ -2804,7 +2887,8 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n     }\n \n   /* If there is no negate operation, try doing a subtract from zero.\n-     The US Software GOFAST library needs this.  */\n+     The US Software GOFAST library needs this.  FIXME: This is *wrong*\n+     for floating-point operations due to negative zeros!  */\n   if (unoptab->code == NEG)\n     {\n       rtx temp;"}, {"sha": "dec53d37e29e56db042038d19b426f8d248cd6f9", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -454,6 +454,10 @@ enum can_compare_purpose\n   ccp_store_flag\n };\n \n+/* Return the optab used for computing the given operation on the type\n+   given by the second argument.  */\n+extern optab optab_for_tree_code (enum tree_code, tree);\n+\n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n extern int can_compare_p (enum rtx_code, enum machine_mode,"}, {"sha": "3944842635da0f7d675960d8133b85972e511da8", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -537,6 +537,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \tprint_node (file, \"values\", TYPE_VALUES (node), indent + 4);\n       else if (TREE_CODE (node) == ARRAY_TYPE || TREE_CODE (node) == SET_TYPE)\n \tprint_node (file, \"domain\", TYPE_DOMAIN (node), indent + 4);\n+      else if (TREE_CODE (node) == VECTOR_TYPE)\n+\tfprintf (file, \" nunits %d\", (int) TYPE_VECTOR_SUBPARTS (node));\n       else if (TREE_CODE (node) == RECORD_TYPE\n \t       || TREE_CODE (node) == UNION_TYPE\n \t       || TREE_CODE (node) == QUAL_UNION_TYPE)"}, {"sha": "f341c39c2145609b76a2d22489be81c930bb2181", "filename": "gcc/regclass.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -191,6 +191,10 @@ const char * reg_names[] = REGISTER_NAMES;\n \n enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n \n+/* 1 if there is a register of given mode.  */\n+\n+bool have_regs_of_mode [MAX_MACHINE_MODE];\n+\n /* 1 if class does contain register of given mode.  */\n \n static char contains_reg_of_mode [N_REG_CLASSES] [MAX_MACHINE_MODE];\n@@ -305,7 +309,6 @@ init_reg_sets_1 (void)\n {\n   unsigned int i, j;\n   unsigned int /* enum machine_mode */ m;\n-  char allocatable_regs_of_mode [MAX_MACHINE_MODE];\n \n   /* This macro allows the fixed or call-used registers\n      and the register classes to depend on target flags.  */\n@@ -469,8 +472,8 @@ init_reg_sets_1 (void)\n \tSET_HARD_REG_BIT (regs_invalidated_by_call, i);\n     }\n \n+  memset (have_regs_of_mode, 0, sizeof (have_regs_of_mode));\n   memset (contains_reg_of_mode, 0, sizeof (contains_reg_of_mode));\n-  memset (allocatable_regs_of_mode, 0, sizeof (allocatable_regs_of_mode));\n   for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n     for (i = 0; i < N_REG_CLASSES; i++)\n       if ((unsigned) CLASS_MAX_NREGS (i, m) <= reg_class_size[i])\n@@ -479,15 +482,15 @@ init_reg_sets_1 (void)\n \t      && HARD_REGNO_MODE_OK (j, m))\n \t     {\n \t       contains_reg_of_mode [i][m] = 1;\n-\t       allocatable_regs_of_mode [m] = 1;\n+\t       have_regs_of_mode [m] = 1;\n \t       break;\n \t     }\n \n   /* Initialize the move cost table.  Find every subset of each class\n      and take the maximum cost of moving any subset to any other.  */\n \n   for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n-    if (allocatable_regs_of_mode [m])\n+    if (have_regs_of_mode [m])\n       {\n \tfor (i = 0; i < N_REG_CLASSES; i++)\n \t  if (contains_reg_of_mode [i][m])"}, {"sha": "027b0e33c67e5570732301f8bceb1f6dea9a6c81", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -163,6 +163,10 @@ extern char regs_ever_live[FIRST_PSEUDO_REGISTER];\n \n extern char regs_asm_clobbered[FIRST_PSEUDO_REGISTER];\n \n+/* Vector indexed by machine mode saying whether there are regs of that mode.  */\n+\n+extern bool have_regs_of_mode [MAX_MACHINE_MODE];\n+\n /* For each hard register, the widest mode object that it can contain.\n    This will be a MODE_INT mode if the register can hold integers.  Otherwise\n    it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the"}, {"sha": "139ba510435766c22657e7e35cb539d195e6211c", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -34,6 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n+#include \"regs.h\"\n \n /* Set to one when set_sizetype has been called.  */\n static int sizetype_set;\n@@ -1582,10 +1583,52 @@ layout_type (tree type)\n       break;\n \n     case VECTOR_TYPE:\n-      TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n-      TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n-      TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n-      break;\n+      {\n+\tint nunits = TYPE_VECTOR_SUBPARTS (type);\n+\ttree nunits_tree = build_int_2 (nunits, 0);\n+\ttree innertype = TREE_TYPE (type);\n+\n+\tif (nunits & (nunits - 1))\n+\t  abort ();\n+\n+\t/* Find an appropriate mode for the vector type.  */\n+\tif (TYPE_MODE (type) == VOIDmode)\n+\t  {\n+\t    enum machine_mode innermode = TYPE_MODE (innertype);\n+\t    enum machine_mode mode;\n+\n+\t    /* First, look for a supported vector type.  */\n+\t    if (GET_MODE_CLASS (innermode) == MODE_FLOAT)\n+\t      mode = MIN_MODE_VECTOR_FLOAT;\n+\t    else\n+\t      mode = MIN_MODE_VECTOR_INT;\n+\n+\t    for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n+\t      if (GET_MODE_NUNITS (mode) == nunits\n+\t  \t  && GET_MODE_INNER (mode) == innermode\n+\t  \t  && VECTOR_MODE_SUPPORTED_P (mode))\n+\t        break;\n+\n+\t    /* For integers, try mapping it to a same-sized scalar mode.  */\n+\t    if (mode == VOIDmode\n+\t        && GET_MODE_CLASS (innermode) == MODE_INT)\n+\t      mode = mode_for_size (nunits * GET_MODE_BITSIZE (innermode),\n+\t\t\t\t    MODE_INT, 0);\n+\n+\t    if (mode == VOIDmode || !have_regs_of_mode[mode])\n+\t      TYPE_MODE (type) = BLKmode;\n+\t    else\n+\t      TYPE_MODE (type) = mode;\n+\t  }\n+\n+        TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n+\tTYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n+\t\t\t\t\t         TYPE_SIZE_UNIT (innertype),\n+\t\t\t\t\t         nunits_tree, 0);\n+\tTYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),\n+\t\t\t\t\t    nunits_tree, 0);\n+        break;\n+      }\n \n     case VOID_TYPE:\n       /* This is an incomplete type and so doesn't have a size.  */"}, {"sha": "1c04e528cee5dab4be55d22df023bdd63baad3c6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -4793,6 +4793,79 @@ struct tree_opt_pass pass_split_crit_edges =\n   0,                             /* todo_flags_start */\n   TODO_dump_func,                             /* todo_flags_finish */\n };\n+\n+\f\n+/* Return EXP if it is a valid GIMPLE rvalue, else gimplify it into\n+   a temporary, make sure and register it to be renamed if necessary,\n+   and finally return the temporary.  Put the statements to compute\n+   EXP before the current statement in BSI.  */\n+\n+tree\n+gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n+{\n+  tree t, new_stmt, orig_stmt;\n+\n+  if (is_gimple_val (exp))\n+    return exp;\n+\n+  t = make_rename_temp (type, NULL);\n+  new_stmt = build (MODIFY_EXPR, type, t, exp);\n+\n+  orig_stmt = bsi_stmt (*bsi);\n+  SET_EXPR_LOCUS (new_stmt, EXPR_LOCUS (orig_stmt));\n+  TREE_BLOCK (new_stmt) = TREE_BLOCK (orig_stmt);\n+\n+  bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n+\n+  return t;\n+}\n+\n+/* Build a ternary operation and gimplify it.  Emit code before BSI.\n+   Return the gimple_val holding the result.  */\n+\n+tree\n+gimplify_build3 (block_stmt_iterator *bsi, enum tree_code code,\n+\t\t tree type, tree a, tree b, tree c)\n+{\n+  tree ret;\n+\n+  ret = fold (build3 (code, type, a, b, c));\n+  STRIP_NOPS (ret);\n+\n+  return gimplify_val (bsi, type, ret);\n+}\n+\n+/* Build a binary operation and gimplify it.  Emit code before BSI.\n+   Return the gimple_val holding the result.  */\n+\n+tree\n+gimplify_build2 (block_stmt_iterator *bsi, enum tree_code code,\n+\t\t tree type, tree a, tree b)\n+{\n+  tree ret;\n+\n+  ret = fold (build2 (code, type, a, b));\n+  STRIP_NOPS (ret);\n+\n+  return gimplify_val (bsi, type, ret);\n+}\n+\n+/* Build a unary operation and gimplify it.  Emit code before BSI.\n+   Return the gimple_val holding the result.  */\n+\n+tree\n+gimplify_build1 (block_stmt_iterator *bsi, enum tree_code code, tree type,\n+\t\t tree a)\n+{\n+  tree ret;\n+\n+  ret = fold (build1 (code, type, a));\n+  STRIP_NOPS (ret);\n+\n+  return gimplify_val (bsi, type, ret);\n+}\n+\n+\n \f\n /* Emit return warnings.  */\n "}, {"sha": "a960f92c42427b76bfa17426a978bffa9a6a103b", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 499, "deletions": 104, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -1,4 +1,4 @@\n-/* Lower complex operations to scalar operations.\n+/* Lower complex number and vector operations to scalar operations.\n    Copyright (C) 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -23,35 +23,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coretypes.h\"\n #include \"tree.h\"\n #include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"insn-codes.h\"\n+#include \"diagnostic.h\"\n+#include \"optabs.h\"\n+#include \"machmode.h\"\n+#include \"langhooks.h\"\n #include \"tree-flow.h\"\n #include \"tree-gimple.h\"\n #include \"tree-iterator.h\"\n #include \"tree-pass.h\"\n #include \"flags.h\"\n \n \n-/* Force EXP to be a gimple_val.  */\n-\n-static tree\n-gimplify_val (block_stmt_iterator *bsi, tree type, tree exp)\n-{\n-  tree t, new_stmt, orig_stmt;\n-\n-  if (is_gimple_val (exp))\n-    return exp;\n-\n-  t = make_rename_temp (type, NULL);\n-  new_stmt = build (MODIFY_EXPR, type, t, exp);\n-\n-  orig_stmt = bsi_stmt (*bsi);\n-  SET_EXPR_LOCUS (new_stmt, EXPR_LOCUS (orig_stmt));\n-  TREE_BLOCK (new_stmt) = TREE_BLOCK (orig_stmt);\n-\n-  bsi_insert_before (bsi, new_stmt, BSI_SAME_STMT);\n-\n-  return t;\n-}\n-\n /* Extract the real or imaginary part of a complex variable or constant.\n    Make sure that it's a proper gimple_val and gimplify it if not.\n    Emit any new code before BSI.  */\n@@ -85,35 +70,6 @@ extract_component (block_stmt_iterator *bsi, tree t, bool imagpart_p)\n   return gimplify_val (bsi, inner_type, ret);\n }\n \n-/* Build a binary operation and gimplify it.  Emit code before BSI.\n-   Return the gimple_val holding the result.  */\n-\n-static tree\n-do_binop (block_stmt_iterator *bsi, enum tree_code code,\n-\t  tree type, tree a, tree b)\n-{\n-  tree ret;\n-\n-  ret = fold (build (code, type, a, b));\n-  STRIP_NOPS (ret);\n-\n-  return gimplify_val (bsi, type, ret);\n-}\n-\n-/* Build a unary operation and gimplify it.  Emit code before BSI.\n-   Return the gimple_val holding the result.  */\n-\n-static tree\n-do_unop (block_stmt_iterator *bsi, enum tree_code code, tree type, tree a)\n-{\n-  tree ret;\n-\n-  ret = fold (build1 (code, type, a));\n-  STRIP_NOPS (ret);\n-\n-  return gimplify_val (bsi, type, ret);\n-}\n-\n /* Update an assignment to a complex variable in place.  */\n \n static void\n@@ -142,8 +98,8 @@ expand_complex_addition (block_stmt_iterator *bsi, tree inner_type,\n {\n   tree rr, ri;\n \n-  rr = do_binop (bsi, code, inner_type, ar, br);\n-  ri = do_binop (bsi, code, inner_type, ai, bi);\n+  rr = gimplify_build2 (bsi, code, inner_type, ar, br);\n+  ri = gimplify_build2 (bsi, code, inner_type, ai, bi);\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -158,19 +114,19 @@ expand_complex_multiplication (block_stmt_iterator *bsi, tree inner_type,\n {\n   tree t1, t2, t3, t4, rr, ri;\n \n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, ar, br);\n-  t2 = do_binop (bsi, MULT_EXPR, inner_type, ai, bi);\n-  t3 = do_binop (bsi, MULT_EXPR, inner_type, ar, bi);\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n+  t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n+  t3 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, bi);\n \n   /* Avoid expanding redundant multiplication for the common\n      case of squaring a complex number.  */\n   if (ar == br && ai == bi)\n     t4 = t3;\n   else\n-    t4 = do_binop (bsi, MULT_EXPR, inner_type, ai, br);\n+    t4 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, br);\n \n-  rr = do_binop (bsi, MINUS_EXPR, inner_type, t1, t2);\n-  ri = do_binop (bsi, PLUS_EXPR, inner_type, t3, t4);\n+  rr = gimplify_build2 (bsi, MINUS_EXPR, inner_type, t1, t2);\n+  ri = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t3, t4);\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -187,19 +143,19 @@ expand_complex_div_straight (block_stmt_iterator *bsi, tree inner_type,\n {\n   tree rr, ri, div, t1, t2, t3;\n \n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, br, br);\n-  t2 = do_binop (bsi, MULT_EXPR, inner_type, bi, bi);\n-  div = do_binop (bsi, PLUS_EXPR, inner_type, t1, t2);\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, br, br);\n+  t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, bi, bi);\n+  div = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, t2);\n \n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, ar, br);\n-  t2 = do_binop (bsi, MULT_EXPR, inner_type, ai, bi);\n-  t3 = do_binop (bsi, PLUS_EXPR, inner_type, t1, t2);\n-  rr = do_binop (bsi, code, inner_type, t3, div);\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, br);\n+  t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, bi);\n+  t3 = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, t2);\n+  rr = gimplify_build2 (bsi, code, inner_type, t3, div);\n \n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, ai, br);\n-  t2 = do_binop (bsi, MULT_EXPR, inner_type, ar, bi);\n-  t3 = do_binop (bsi, MINUS_EXPR, inner_type, t1, t2);\n-  ri = do_binop (bsi, code, inner_type, t3, div);\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, br);\n+  t2 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, bi);\n+  t3 = gimplify_build2 (bsi, MINUS_EXPR, inner_type, t1, t2);\n+  ri = gimplify_build2 (bsi, code, inner_type, t3, div);\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -215,8 +171,8 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n   tree rr, ri, ratio, div, t1, t2, min, max, cond;\n \n   /* Examine |br| < |bi|, and branch.  */\n-  t1 = do_unop (bsi, ABS_EXPR, inner_type, br);\n-  t2 = do_unop (bsi, ABS_EXPR, inner_type, bi);\n+  t1 = gimplify_build1 (bsi, ABS_EXPR, inner_type, br);\n+  t2 = gimplify_build1 (bsi, ABS_EXPR, inner_type, bi);\n   cond = fold (build (LT_EXPR, boolean_type_node, t1, t2));\n   STRIP_NOPS (cond);\n \n@@ -292,20 +248,20 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n   \n   /* Now we have MIN(|br|, |bi|) and MAX(|br|, |bi|).  We now use the\n      ratio min/max to scale both the dividend and divisor.  */\n-  ratio = do_binop (bsi, code, inner_type, min, max);\n+  ratio = gimplify_build2 (bsi, code, inner_type, min, max);\n \n   /* Calculate the divisor: min*ratio + max.  */\n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, min, ratio);\n-  div = do_binop (bsi, PLUS_EXPR, inner_type, t1, max);\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, min, ratio);\n+  div = gimplify_build2 (bsi, PLUS_EXPR, inner_type, t1, max);\n \n-  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div).  */\n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, ai, ratio);\n-  t2 = do_binop (bsi, PLUS_EXPR, inner_type, ar, t1);\n-  rr = do_binop (bsi, code, inner_type, t2, div);\n+  /* Result is now ((ar + ai*ratio)/div) + i((ai - ar*ratio)/div). */\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ai, ratio);\n+  t2 = gimplify_build2 (bsi, PLUS_EXPR, inner_type, ar, t1);\n+  rr = gimplify_build2 (bsi, code, inner_type, t2, div);\n \n-  t1 = do_binop (bsi, MULT_EXPR, inner_type, ar, ratio);\n-  t2 = do_binop (bsi, MINUS_EXPR, inner_type, ai, t1);\n-  ri = do_binop (bsi, code, inner_type, t2, div);\n+  t1 = gimplify_build2 (bsi, MULT_EXPR, inner_type, ar, ratio);\n+  t2 = gimplify_build2 (bsi, MINUS_EXPR, inner_type, ai, t1);\n+  ri = gimplify_build2 (bsi, code, inner_type, t2, div);\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -343,8 +299,8 @@ expand_complex_negation (block_stmt_iterator *bsi, tree inner_type,\n {\n   tree rr, ri;\n \n-  rr = do_unop (bsi, NEGATE_EXPR, inner_type, ar);\n-  ri = do_unop (bsi, NEGATE_EXPR, inner_type, ai);\n+  rr = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, ar);\n+  ri = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, ai);\n \n   update_complex_assignment (bsi, rr, ri);\n }\n@@ -359,7 +315,7 @@ expand_complex_conjugate (block_stmt_iterator *bsi, tree inner_type,\n {\n   tree ri;\n \n-  ri = do_unop (bsi, NEGATE_EXPR, inner_type, ai);\n+  ri = gimplify_build1 (bsi, NEGATE_EXPR, inner_type, ai);\n \n   update_complex_assignment (bsi, ar, ri);\n }\n@@ -372,10 +328,11 @@ expand_complex_comparison (block_stmt_iterator *bsi, tree ar, tree ai,\n {\n   tree cr, ci, cc, stmt, type;\n \n-  cr = do_binop (bsi, code, boolean_type_node, ar, br);\n-  ci = do_binop (bsi, code, boolean_type_node, ai, bi);\n-  cc = do_binop (bsi, (code == EQ_EXPR ? TRUTH_AND_EXPR : TRUTH_OR_EXPR),\n-\t\t boolean_type_node, cr, ci);\n+  cr = gimplify_build2 (bsi, code, boolean_type_node, ar, br);\n+  ci = gimplify_build2 (bsi, code, boolean_type_node, ai, bi);\n+  cc = gimplify_build2 (bsi,\n+\t\t\t(code == EQ_EXPR ? TRUTH_AND_EXPR : TRUTH_OR_EXPR),\n+\t\t\tboolean_type_node, cr, ci);\n \n   stmt = bsi_stmt (*bsi);\n   modify_stmt (stmt);\n@@ -517,17 +474,434 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n       abort ();\n     }\n }\n+\f\n+/* Build a constant of type TYPE, made of VALUE's bits replicated\n+   every TYPE_SIZE (INNER_TYPE) bits to fit TYPE's precision.  */\n+static tree\n+build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n+{\n+  int width = tree_low_cst (TYPE_SIZE (inner_type), 1);\n+  int n = HOST_BITS_PER_WIDE_INT / width;\n+  unsigned HOST_WIDE_INT low, high, mask;\n+  tree ret;\n+\n+  if (n == 0)\n+    abort ();\n+\n+  if (width == HOST_BITS_PER_WIDE_INT)\n+    low = value;\n+  else\n+    {\n+      mask = ((HOST_WIDE_INT)1 << width) - 1;\n+      low = (unsigned HOST_WIDE_INT) ~0 / mask * (value & mask);\n+    }\n+\n+  if (TYPE_PRECISION (type) < HOST_BITS_PER_WIDE_INT)\n+    low &= ((HOST_WIDE_INT)1 << TYPE_PRECISION (type)) - 1, high = 0;\n+  else if (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT)\n+    high = 0;\n+  else if (TYPE_PRECISION (type) == 2 * HOST_BITS_PER_WIDE_INT)\n+    high = low;\n+  else\n+    abort ();\n+\n+  ret = build_int_2 (low, high);\n+  TREE_TYPE (ret) = type;\n+  return ret;\n+}\n \n-/* Main loop to process each statement.  */\n-/* ??? Could use dominator bits to propagate from complex_expr at the\n-   same time.  This might reveal more constants, particularly in cases\n-   such as (complex = complex op scalar).  This may not be relevant\n-   after SRA and subsequent cleanups.  Proof of this would be if we\n-   verify that the code generated by expand_complex_div_wide is\n-   simplified properly to straight-line code.  */\n+/* Return a suitable vector types made of SUBPARTS units each of mode\n+   \"word_mode\" (the global variable).  */\n+static tree\n+build_word_mode_vector_type (int nunits)\n+{\n+  static tree innertype;\n+  static tree last;\n+  static int last_nunits;\n+\n+  if (!innertype)\n+    innertype = lang_hooks.types.type_for_mode (word_mode, 1);\n+  else if (last_nunits == nunits)\n+    return last;\n+\n+  /* We build a new type, but we canonicalize it nevertheless,\n+     because it still saves some memory.  */\n+  last_nunits = nunits;\n+  last = type_hash_canon (nunits, build_vector_type (innertype, nunits));\n+  return last;\n+}\n+\n+typedef tree (*elem_op_func) (block_stmt_iterator *,\n+\t\t\t      tree, tree, tree, tree, tree, enum tree_code);\n+\n+static inline tree\n+tree_vec_extract (block_stmt_iterator *bsi, tree type,\n+\t\t  tree t, tree bitsize, tree bitpos)\n+{\n+  if (bitpos)\n+    return gimplify_build3 (bsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n+  else\n+    return gimplify_build1 (bsi, VIEW_CONVERT_EXPR, type, t);\n+}\n+\n+static tree\n+do_unop (block_stmt_iterator *bsi, tree inner_type, tree a,\n+\t tree b ATTRIBUTE_UNUSED, tree bitpos, tree bitsize,\n+\t enum tree_code code)\n+{\n+  a = tree_vec_extract (bsi, inner_type, a, bitsize, bitpos);\n+  return gimplify_build1 (bsi, code, inner_type, a);\n+}\n+\n+static tree\n+do_binop (block_stmt_iterator *bsi, tree inner_type, tree a, tree b,\n+\t  tree bitpos, tree bitsize, enum tree_code code)\n+{\n+  a = tree_vec_extract (bsi, inner_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (bsi, inner_type, b, bitsize, bitpos);\n+  return gimplify_build2 (bsi, code, inner_type, a, b);\n+}\n+\n+/* Expand vector addition to scalars.  This does bit twiddling\n+   in order to increase parallelism:\n+\n+   a + b = (((int) a & 0x7f7f7f7f) + ((int) b & 0x7f7f7f7f)) ^\n+           (a ^ b) & 0x80808080\n+\n+   a - b =  (((int) a | 0x80808080) - ((int) b & 0x7f7f7f7f)) ^\n+            (a ^ ~b) & 0x80808080\n+\n+   -b = (0x80808080 - ((int) b & 0x7f7f7f7f)) ^ (~b & 0x80808080)\n+\n+   This optimization should be done only if 4 vector items or more\n+   fit into a word.  */\n+static tree\n+do_plus_minus (block_stmt_iterator *bsi, tree word_type, tree a, tree b,\n+\t       tree bitpos ATTRIBUTE_UNUSED, tree bitsize ATTRIBUTE_UNUSED,\n+\t       enum tree_code code)\n+{\n+  tree inner_type = TREE_TYPE (TREE_TYPE (a));\n+  unsigned HOST_WIDE_INT max;\n+  tree low_bits, high_bits, a_low, b_low, result_low, signs;\n+\n+  max = GET_MODE_MASK (TYPE_MODE (inner_type));\n+  low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n+  high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n+\n+  a = tree_vec_extract (bsi, word_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (bsi, word_type, b, bitsize, bitpos);\n+\n+  signs = gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, a, b);\n+  b_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, b, low_bits);\n+  if (code == PLUS_EXPR)\n+    a_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, a, low_bits);\n+  else\n+    {\n+      a_low = gimplify_build2 (bsi, BIT_IOR_EXPR, word_type, a, high_bits);\n+      signs = gimplify_build1 (bsi, BIT_NOT_EXPR, word_type, signs);\n+    }\n+\n+  signs = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, signs, high_bits);\n+  result_low = gimplify_build2 (bsi, code, word_type, a_low, b_low);\n+  return gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, result_low, signs);\n+}\n+\n+static tree\n+do_negate (block_stmt_iterator *bsi, tree word_type, tree b,\n+\t   tree unused ATTRIBUTE_UNUSED, tree bitpos ATTRIBUTE_UNUSED,\n+\t   tree bitsize ATTRIBUTE_UNUSED,\n+\t   enum tree_code code ATTRIBUTE_UNUSED)\n+{\n+  tree inner_type = TREE_TYPE (TREE_TYPE (b));\n+  HOST_WIDE_INT max;\n+  tree low_bits, high_bits, b_low, result_low, signs;\n+\n+  max = GET_MODE_MASK (TYPE_MODE (inner_type));\n+  low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n+  high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n+\n+  b = tree_vec_extract (bsi, word_type, b, bitsize, bitpos);\n+\n+  b_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, b, low_bits);\n+  signs = gimplify_build1 (bsi, BIT_NOT_EXPR, word_type, b);\n+  signs = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, signs, high_bits);\n+  result_low = gimplify_build2 (bsi, MINUS_EXPR, word_type, high_bits, b_low);\n+  return gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, result_low, signs);\n+}\n+\n+/* Expand a vector operation to scalars, by using many operations\n+   whose type is the vector type's inner type.  */\n+static tree\n+expand_vector_piecewise (block_stmt_iterator *bsi, elem_op_func f,\n+\t\t\t tree type, tree inner_type,\n+\t\t\t tree a, tree b, enum tree_code code)\n+{\n+  tree head, *chain = &head;\n+  tree part_width = TYPE_SIZE (inner_type);\n+  tree index = bitsize_int (0);\n+  int nunits = TYPE_VECTOR_SUBPARTS (type);\n+  int delta = tree_low_cst (part_width, 1)\n+\t      / tree_low_cst (TYPE_SIZE (TREE_TYPE (type)), 1);\n+  int i;\n+\n+  for (i = 0; i < nunits;\n+       i += delta, index = int_const_binop (PLUS_EXPR, index, part_width, 0))\n+    {\n+      tree result = f (bsi, inner_type, a, b, index, part_width, code);\n+      *chain = tree_cons (NULL_TREE, result, NULL_TREE);\n+      chain = &TREE_CHAIN (*chain);\n+    }\n+\n+  return build1 (CONSTRUCTOR, type, head);\n+}\n+\n+/* Expand a vector operation to scalars with the freedom to use\n+   a scalar integer type, or to use a different size for the items\n+   in the vector type.  */\n+static tree\n+expand_vector_parallel (block_stmt_iterator *bsi, elem_op_func f, tree type,\n+\t\t\ttree a, tree b,\n+\t\t\tenum tree_code code)\n+{\n+  tree result, compute_type;\n+  enum machine_mode mode;\n+  int n_words = tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n+\n+  /* We have three strategies.  If the type is already correct, just do\n+     the operation an element at a time.  Else, if the vector is wider than\n+     one word, do it a word at a time; finally, if the vector is smaller\n+     than one word, do it as a scalar.  */\n+  if (TYPE_MODE (TREE_TYPE (type)) == word_mode)\n+     return expand_vector_piecewise (bsi, f,\n+\t\t\t\t     type, TREE_TYPE (type),\n+\t\t\t\t     a, b, code);\n+  else if (n_words > 1)\n+    {\n+      tree word_type = build_word_mode_vector_type (n_words);\n+      result = expand_vector_piecewise (bsi, f,\n+\t\t\t\t        word_type, TREE_TYPE (word_type),\n+\t\t\t\t\ta, b, code);\n+      result = gimplify_val (bsi, word_type, result);\n+    }\n+  else\n+    {\n+      /* Use a single scalar operation with a mode no wider than word_mode.  */\n+      mode = mode_for_size (tree_low_cst (TYPE_SIZE (type), 1), MODE_INT, 0);\n+      compute_type = lang_hooks.types.type_for_mode (mode, 1);\n+      result = f (bsi, compute_type, a, b, NULL_TREE, NULL_TREE, code);\n+    }\n+\n+  return build1 (VIEW_CONVERT_EXPR, type, result);\n+}\n+\n+/* Expand a vector operation to scalars; for integer types we can use\n+   special bit twiddling tricks to do the sums a word at a time, using\n+   function F_PARALLEL instead of F.  These tricks are done only if\n+   they can process at least four items, that is, only if the vector\n+   holds at least four items and if a word can hold four items.  */\n+static tree\n+expand_vector_addition (block_stmt_iterator *bsi,\n+\t\t\telem_op_func f, elem_op_func f_parallel,\n+\t\t\ttree type, tree a, tree b, enum tree_code code)\n+{\n+  int parts_per_word = UNITS_PER_WORD\n+\t  \t       / tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (type)), 1);\n+\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (type))\n+      && parts_per_word >= 4\n+      && TYPE_VECTOR_SUBPARTS (type) >= 4)\n+    return expand_vector_parallel (bsi, f_parallel,\n+\t\t\t\t   type, a, b, code);\n+  else\n+    return expand_vector_piecewise (bsi, f,\n+\t\t\t\t    type, TREE_TYPE (type),\n+\t\t\t\t    a, b, code);\n+}\n+\n+/* Return a type for the widest vector mode whose components are of mode\n+   INNER_MODE, or NULL_TREE if none is found.  */\n+static tree\n+type_for_widest_vector_mode (enum machine_mode inner_mode, optab op)\n+{\n+  enum machine_mode best_mode = VOIDmode, mode;\n+  int best_nunits = 0;\n+\n+  if (GET_MODE_CLASS (inner_mode) == MODE_FLOAT)\n+    mode = MIN_MODE_VECTOR_FLOAT;\n+  else\n+    mode = MIN_MODE_VECTOR_INT;\n+\n+  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_INNER (mode) == inner_mode\n+        && GET_MODE_NUNITS (mode) > best_nunits\n+\t&& op->handlers[mode].insn_code != CODE_FOR_nothing)\n+      best_mode = mode, best_nunits = GET_MODE_NUNITS (mode);\n+\n+  if (best_mode == VOIDmode)\n+    return NULL_TREE;\n+  else\n+    return lang_hooks.types.type_for_mode (best_mode, 1);\n+}\n+\n+/* Process one statement.  If we identify a vector operation, expand it.  */\n+\n+static void\n+expand_vector_operations_1 (block_stmt_iterator *bsi)\n+{\n+  tree stmt = bsi_stmt (*bsi);\n+  tree *p_rhs, rhs, type, compute_type;\n+  enum tree_code code;\n+  enum machine_mode compute_mode;\n+  optab op;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case RETURN_EXPR:\n+      stmt = TREE_OPERAND (stmt, 0);\n+      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+\treturn;\n+\n+      /* FALLTHRU */\n+\n+    case MODIFY_EXPR:\n+      p_rhs = &TREE_OPERAND (stmt, 1);\n+      rhs = *p_rhs;\n+      break;\n+\n+    default:\n+      return;\n+    }\n+\n+  type = TREE_TYPE (rhs);\n+  if (TREE_CODE (type) != VECTOR_TYPE)\n+    return;\n+\n+  code = TREE_CODE (rhs);\n+  if (TREE_CODE_CLASS (code) != '1'\n+      && TREE_CODE_CLASS (code) != '2')\n+    return;\n+\n+  if (code == NOP_EXPR || code == VIEW_CONVERT_EXPR)\n+    return;\n+\n+  if (code == CONVERT_EXPR)\n+    abort ();\n+\n+  op = optab_for_tree_code (code, type);\n+\n+  /* Optabs will try converting a negation into a subtraction, so\n+     look for it as well.  TODO: negation of floating-point vectors\n+     might be turned into an exclusive OR toggling the sign bit.  */\n+  if (op == NULL\n+      && code == NEGATE_EXPR\n+      && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n+    op = optab_for_tree_code (MINUS_EXPR, type);\n+\n+  /* For very wide vectors, try using a smaller vector mode.  */\n+  compute_type = type;\n+  if (TYPE_MODE (type) == BLKmode && op)\n+    {\n+      tree vector_compute_type\n+        = type_for_widest_vector_mode (TYPE_MODE (TREE_TYPE (type)), op);\n+      if (vector_compute_type != NULL_TREE)\n+        compute_type = vector_compute_type;\n+    }\n+\n+  compute_mode = TYPE_MODE (compute_type);\n+\n+  /* If we are breaking a BLKmode vector into smaller pieces,\n+     type_for_widest_vector_mode has already looked into the optab,\n+     so skip these checks.  */\n+  if (compute_type == type)\n+    {\n+      if ((GET_MODE_CLASS (compute_mode) == MODE_VECTOR_INT\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT)\n+          && op != NULL\n+\t  && op->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n+\treturn;\n+      else\n+\t{\n+\t  /* There is no operation in hardware, so fall back to scalars.  */\n+\t  compute_type = TREE_TYPE (type);\n+\t  compute_mode = TYPE_MODE (compute_type);\n+\t}\n+    }\n+\n+  /* If the compute mode is not a vector mode (hence we are decomposing\n+     a BLKmode vector to smaller, hardware-supported vectors), we may\n+     want to expand the operations in parallel.  */\n+  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT)\n+    switch (code)\n+      {\n+      case PLUS_EXPR:\n+      case MINUS_EXPR:\n+        if (TYPE_TRAP_SIGNED (type))\n+\t  break;\n+\n+        *p_rhs = expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t         TREE_OPERAND (rhs, 1), code);\n+\tmodify_stmt (bsi_stmt (*bsi));\n+        return;\n+\n+      case NEGATE_EXPR:\n+        if (TYPE_TRAP_SIGNED (type))\n+\t  break;\n+\n+        *p_rhs = expand_vector_addition (bsi, do_unop, do_negate, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t NULL_TREE, code);\n+\tmodify_stmt (bsi_stmt (*bsi));\n+        return;\n+\n+      case BIT_AND_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+        *p_rhs = expand_vector_parallel (bsi, do_binop, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t         TREE_OPERAND (rhs, 1), code);\n+\tmodify_stmt (bsi_stmt (*bsi));\n+        return;\n+\n+      case BIT_NOT_EXPR:\n+        *p_rhs = expand_vector_parallel (bsi, do_unop, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t NULL_TREE, code);\n+\tmodify_stmt (bsi_stmt (*bsi));\n+        return;\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  if (TREE_CODE_CLASS (code) == '1')\n+    *p_rhs = expand_vector_piecewise (bsi, do_unop, type, compute_type,\n+\t\t\t\t      TREE_OPERAND (rhs, 0),\n+\t\t\t\t      NULL_TREE, code);\n+  else\n+    *p_rhs = expand_vector_piecewise (bsi, do_binop, type, compute_type,\n+\t\t\t\t      TREE_OPERAND (rhs, 0),\n+\t\t\t\t      TREE_OPERAND (rhs, 1), code);\n+\n+  modify_stmt (bsi_stmt (*bsi));\n+}\n+\f\n+static void\n+expand_vector_operations (void)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\texpand_vector_operations_1 (&bsi);\n+    }\n+}\n \n static void\n-expand_complex_operations (void)\n+tree_lower_operations (void)\n {\n   int old_last_basic_block = last_basic_block;\n   block_stmt_iterator bsi;\n@@ -538,15 +912,19 @@ expand_complex_operations (void)\n       if (bb->index >= old_last_basic_block)\n \tcontinue;\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\texpand_complex_operations_1 (&bsi);\n+\t{\n+\t  expand_complex_operations_1 (&bsi);\n+\t  expand_vector_operations_1 (&bsi);\n+\t}\n     }\n }\n \n-struct tree_opt_pass pass_lower_complex = \n+\n+struct tree_opt_pass pass_lower_vector_ssa = \n {\n-  \"complex\",\t\t\t\t/* name */\n+  \"vector\",\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n-  expand_complex_operations,\t\t/* execute */\n+  expand_vector_operations,\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -555,7 +933,24 @@ struct tree_opt_pass pass_lower_complex =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_rename_vars\n+  TODO_dump_func | TODO_rename_vars\t/* todo_flags_finish */\n     | TODO_ggc_collect | TODO_verify_ssa\n-    | TODO_verify_stmts | TODO_verify_flow /* todo_flags_finish */\n+    | TODO_verify_stmts | TODO_verify_flow\n+};\n+\n+struct tree_opt_pass pass_pre_expand = \n+{\n+  \"oplower\",\t\t\t\t/* name */\n+  0,\t\t\t\t\t/* gate */\n+  tree_lower_operations,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_ggc_collect\n+    | TODO_verify_stmts\t\t\t/* todo_flags_finish */\n };"}, {"sha": "4d9a18f10ca248e10b6418bba8df60de1c9a5cf9", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -496,6 +496,13 @@ extern tree tree_block_label (basic_block bb);\n extern void extract_true_false_edges_from_block (basic_block, edge *, edge *);\n extern bool tree_purge_dead_eh_edges (basic_block);\n extern bool tree_purge_all_dead_eh_edges (bitmap);\n+extern tree gimplify_val (block_stmt_iterator *, tree, tree);\n+extern tree gimplify_build1 (block_stmt_iterator *, enum tree_code,\n+\t\t\t     tree, tree);\n+extern tree gimplify_build2 (block_stmt_iterator *, enum tree_code,\n+\t\t\t     tree, tree, tree);\n+extern tree gimplify_build3 (block_stmt_iterator *, enum tree_code,\n+\t\t\t     tree, tree, tree, tree);\n \n /* In tree-pretty-print.c.  */\n extern void dump_generic_bb (FILE *, basic_block, int, int);"}, {"sha": "e884260d2b3951c52bb66f9c7df7e45d34fa92b1", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -373,7 +373,7 @@ init_tmp_var (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n /* Similarly, but only do so to force EXP to satisfy is_gimple_val.  */\n \n static tree\n-gimplify_val (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n+tsi_gimplify_val (struct nesting_info *info, tree exp, tree_stmt_iterator *tsi)\n {\n   if (is_gimple_val (exp))\n     return exp;\n@@ -790,7 +790,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \t       where we only accept variables (and min_invariant, presumably),\n \t       then compute the address into a temporary.  */\n \t    if (save_val_only)\n-\t      *tp = gimplify_val (wi->info, t, &wi->tsi);\n+\t      *tp = tsi_gimplify_val (wi->info, t, &wi->tsi);\n \t  }\n       }\n       break;\n@@ -904,7 +904,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t    /* If we are in a context where we only accept values, then\n \t       compute the address into a temporary.  */\n \t    if (save_val_only)\n-\t      *tp = gimplify_val (wi->info, t, &wi->tsi);\n+\t      *tp = tsi_gimplify_val (wi->info, t, &wi->tsi);\n \t  }\n       }\n       break;\n@@ -1041,7 +1041,7 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n   field = get_nl_goto_field (i);\n   x = get_frame_field (info, target_context, field, &wi->tsi);\n   x = build_addr (x);\n-  x = gimplify_val (info, x, &wi->tsi);\n+  x = tsi_gimplify_val (info, x, &wi->tsi);\n   arg = tree_cons (NULL, x, NULL);\n   x = build_addr (new_label);\n   arg = tree_cons (NULL, x, arg);\n@@ -1139,7 +1139,7 @@ convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n       /* Compute the address of the field holding the trampoline.  */\n       x = get_frame_field (info, target_context, x, &wi->tsi);\n       x = build_addr (x);\n-      x = gimplify_val (info, x, &wi->tsi);\n+      x = tsi_gimplify_val (info, x, &wi->tsi);\n       arg = tree_cons (NULL, x, NULL);\n \n       /* Do machine-specific ugliness.  Normally this will involve"}, {"sha": "f2d98af7309e3ebc8d493a23fbb4fb1b9c7b6534", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -299,6 +299,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_lower_cf);\n   NEXT_PASS (pass_lower_eh);\n   NEXT_PASS (pass_build_cfg);\n+  NEXT_PASS (pass_pre_expand);\n   NEXT_PASS (pass_tree_profile);\n   NEXT_PASS (pass_init_datastructures);\n   NEXT_PASS (pass_all_optimizations);\n@@ -325,7 +326,6 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_tail_recursion);\n   NEXT_PASS (pass_ch);\n   NEXT_PASS (pass_profile);\n-  NEXT_PASS (pass_lower_complex);\n   NEXT_PASS (pass_sra);\n   NEXT_PASS (DUP_PASS (pass_rename_ssa_copies));\n   NEXT_PASS (DUP_PASS (pass_dominator));"}, {"sha": "1edff2df24eb09a4c2fb9d5d14d752b28c75a712", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -120,7 +120,8 @@ extern struct tree_opt_pass pass_may_alias;\n extern struct tree_opt_pass pass_split_crit_edges;\n extern struct tree_opt_pass pass_pre;\n extern struct tree_opt_pass pass_profile;\n-extern struct tree_opt_pass pass_lower_complex;\n+extern struct tree_opt_pass pass_pre_expand;\n+extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_fold_builtins;\n extern struct tree_opt_pass pass_early_warn_uninitialized;\n extern struct tree_opt_pass pass_late_warn_uninitialized;"}, {"sha": "4ed3b6714a10f2e7906e20560e02d7282cb288ac", "filename": "gcc/tree.c", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -111,7 +111,7 @@ static void set_type_quals (tree, int);\n static int type_hash_eq (const void *, const void *);\n static hashval_t type_hash_hash (const void *);\n static void print_type_hash_statistics (void);\n-static void finish_vector_type (tree);\n+static tree make_vector_type (tree, int, enum machine_mode);\n static int type_hash_marked_p (const void *);\n static unsigned int type_hash_list (tree, hashval_t);\n static unsigned int attribute_hash_list (tree, hashval_t);\n@@ -5279,18 +5279,23 @@ tree_operand_check_failed (int idx, enum tree_code code, const char *file,\n }\n #endif /* ENABLE_TREE_CHECKING */\n \f\n-/* For a new vector type node T, build the information necessary for\n-   debugging output.  */\n+/* Create a new vector type node holding SUBPARTS units of type INNERTYPE,\n+   and mapped to the machine mode MODE.  Initialize its fields and build\n+   the information necessary for debugging output.  */\n \n-static void\n-finish_vector_type (tree t)\n+static tree\n+make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n {\n+  tree t = make_node (VECTOR_TYPE);\n+\n+  TREE_TYPE (t) = innertype;\n+  TYPE_VECTOR_SUBPARTS (t) = nunits;\n+  TYPE_MODE (t) = mode;\n   layout_type (t);\n \n   {\n-    tree index = build_int_2 (TYPE_VECTOR_SUBPARTS (t) - 1, 0);\n-    tree array = build_array_type (TREE_TYPE (t),\n-\t\t\t\t   build_index_type (index));\n+    tree index = build_int_2 (nunits - 1, 0);\n+    tree array = build_array_type (innertype, build_index_type (index));\n     tree rt = make_node (RECORD_TYPE);\n \n     TYPE_FIELDS (rt) = build_decl (FIELD_DECL, get_identifier (\"f\"), array);\n@@ -5303,6 +5308,8 @@ finish_vector_type (tree t)\n        numbers equal.  */\n     TYPE_UID (rt) = TYPE_UID (t);\n   }\n+\n+  return t;\n }\n \n static tree\n@@ -5521,36 +5528,39 @@ reconstruct_complex_type (tree type, tree bottom)\n   return outer;\n }\n \n-/* Returns a vector tree node given a vector mode and inner type.  */\n+/* Returns a vector tree node given a mode (integer, vector, or BLKmode) and\n+   the inner type.  */\n tree\n build_vector_type_for_mode (tree innertype, enum machine_mode mode)\n {\n-  tree t;\n-  t = make_node (VECTOR_TYPE);\n-  TREE_TYPE (t) = innertype;\n-  TYPE_MODE (t) = mode;\n-  finish_vector_type (t);\n-  return t;\n-}\n+  int nunits;\n \n-/* Similarly, but takes inner type and units.  */\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n+      || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+    nunits = GET_MODE_NUNITS (mode);\n \n-tree\n-build_vector_type (tree innertype, int nunits)\n-{\n-  enum machine_mode innermode = TYPE_MODE (innertype);\n-  enum machine_mode mode;\n+  else if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      /* Check that there are no leftover bits.  */\n+      if (GET_MODE_BITSIZE (mode) % TREE_INT_CST_LOW (TYPE_SIZE (innertype)))\n+\tabort ();\n \n-  if (GET_MODE_CLASS (innermode) == MODE_FLOAT)\n-    mode = MIN_MODE_VECTOR_FLOAT;\n+      nunits = GET_MODE_BITSIZE (mode)\n+\t       / TREE_INT_CST_LOW (TYPE_SIZE (innertype));\n+    }\n   else\n-    mode = MIN_MODE_VECTOR_INT;\n+    abort ();\n \n-  for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_NUNITS (mode) == nunits && GET_MODE_INNER (mode) == innermode)\n-      return build_vector_type_for_mode (innertype, mode);\n+  return make_vector_type (innertype, nunits, mode);\n+}\n \n-  return NULL_TREE;\n+/* Similarly, but takes the inner type and number of units, which must be\n+   a power of two.  */\n+\n+tree\n+build_vector_type (tree innertype, int nunits)\n+{\n+  return make_vector_type (innertype, nunits, VOIDmode);\n }\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some"}, {"sha": "80e42e0f86260f9cacab79ab1da7144487dc4396", "filename": "gcc/tree.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -151,7 +151,8 @@ DEFTREECODE (REAL_TYPE, \"real_type\", 't', 0)\n DEFTREECODE (COMPLEX_TYPE, \"complex_type\", 't', 0)\n \n /* Vector types.  The TREE_TYPE field is the data type of the vector\n-   elements.  */\n+   elements.  The TYPE_PRECISION field is the number of subparts of\n+   the vector.  */\n DEFTREECODE (VECTOR_TYPE, \"vector_type\", 't', 0)\n \n /* C enums.  The type node looks just like an INTEGER_TYPE node."}, {"sha": "41d967c3465678b8dddadf29e708b89a6a06cddf", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26277d41791a5f1817fbd3412ddb06f6efc961b9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=26277d41791a5f1817fbd3412ddb06f6efc961b9", "patch": "@@ -1516,7 +1516,7 @@ struct tree_block GTY(())\n \n /* For a VECTOR_TYPE, this is the number of sub-parts of the vector.  */\n #define TYPE_VECTOR_SUBPARTS(VECTOR_TYPE) \\\n-  GET_MODE_NUNITS (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.mode)\n+  (VECTOR_TYPE_CHECK (VECTOR_TYPE)->type.precision)\n \n /* Indicates that objects of this type must be initialized by calling a\n    function when they are created.  */\n@@ -3480,7 +3480,6 @@ extern void expand_function_start (tree);\n extern void expand_pending_sizes (tree);\n extern void recompute_tree_invarant_for_addr_expr (tree);\n extern bool needs_to_live_in_memory (tree);\n-extern tree make_vector (enum machine_mode, tree, int);\n extern tree reconstruct_complex_type (tree, tree);\n \n extern int real_onep (tree);"}]}