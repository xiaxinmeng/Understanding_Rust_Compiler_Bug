{"sha": "f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUzMTZkZmU4OGI4ZDFiOGQzMDEyYzFmNzUzNDllZGYyYmExYmRkZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-08T17:59:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-08T17:59:18Z"}, "message": "Add support for -mreg-alloc=<xxx>\n\nFrom-SVN: r8040", "tree": {"sha": "4539f2afd4cec5391458adbad088c180787efd5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4539f2afd4cec5391458adbad088c180787efd5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde/comments", "author": null, "committer": null, "parents": [{"sha": "0be5d99ff22bb43d45d13c620071ba377d3e02d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be5d99ff22bb43d45d13c620071ba377d3e02d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be5d99ff22bb43d45d13c620071ba377d3e02d6"}], "stats": {"total": 212, "additions": 195, "deletions": 17}, "files": [{"sha": "3133a36db6bcdbe6c2bebce749803d53240a0133", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 113, "deletions": 1, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde", "patch": "@@ -74,8 +74,120 @@ enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n /* Test and compare insns in i386.md store the information needed to\n    generate branch and scc insns here.  */\n \n-struct rtx_def *i386_compare_op0, *i386_compare_op1;\n+struct rtx_def *i386_compare_op0 = NULL_RTX;\n+struct rtx_def *i386_compare_op1 = NULL_RTX;\n struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n+\n+/* Register allocation order */\n+char *i386_reg_alloc_order = (char *)0;\n+static char regs_allocated[FIRST_PSEUDO_REGISTER];\n+\n+\f\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+\n+void\n+override_options ()\n+{\n+  int ch, i, regno;\n+\n+#ifdef SUBTARGET_OVERRIDE_OPTIONS\n+  SUBTARGET_OVERRIDE_OPTIONS;\n+#endif\n+\n+  /* Validate registers in register allocation order */\n+  if (i386_reg_alloc_order)\n+    {\n+      for (i = 0; (ch = i386_reg_alloc_order[i]) != '\\0'; i++)\n+\t{\n+\t  switch (ch)\n+\t    {\n+\t    case 'a':\tregno = 0;\tbreak;\n+\t    case 'd':\tregno = 1;\tbreak;\n+\t    case 'c':\tregno = 2;\tbreak;\n+\t    case 'b':\tregno = 3;\tbreak;\n+\t    case 'S':\tregno = 4;\tbreak;\n+\t    case 'D':\tregno = 5;\tbreak;\n+\t    case 'B':\tregno = 6;\tbreak;\n+\n+\t    default:\tfatal (\"Register '%c' is unknown\", ch);\n+\t    }\n+\n+\t  if (regs_allocated[regno])\n+\t    fatal (\"Register '%c' was already specified in the allocation order\", ch);\n+\n+\t  regs_allocated[regno] = 1;\n+\t}\n+    }\n+}\n+\f\n+/* A C statement (sans semicolon) to choose the order in which to\n+   allocate hard registers for pseudo-registers local to a basic\n+   block.\n+\n+   Store the desired register order in the array `reg_alloc_order'.\n+   Element 0 should be the register to allocate first; element 1, the\n+   next register; and so on.\n+\n+   The macro body should not assume anything about the contents of\n+   `reg_alloc_order' before execution of the macro.\n+\n+   On most machines, it is not necessary to define this macro.  */\n+\n+void\n+order_regs_for_local_alloc ()\n+{\n+  int i, ch, order, regno;\n+\n+  /* User specified the register allocation order */\n+  if (i386_reg_alloc_order)\n+    {\n+      for (i = order = 0; (ch = i386_reg_alloc_order[i]) != '\\0'; i++)\n+\t{\n+\t  switch (ch)\n+\t    {\n+\t    case 'a':\tregno = 0;\tbreak;\n+\t    case 'd':\tregno = 1;\tbreak;\n+\t    case 'c':\tregno = 2;\tbreak;\n+\t    case 'b':\tregno = 3;\tbreak;\n+\t    case 'S':\tregno = 4;\tbreak;\n+\t    case 'D':\tregno = 5;\tbreak;\n+\t    case 'B':\tregno = 6;\tbreak;\n+\t    }\n+\n+\t  reg_alloc_order[order++] = regno;\n+\t}\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t{\n+\t  if (!regs_allocated[i])\n+\t    reg_alloc_order[order++] = i;\n+\t}\n+    }\n+\n+  /* If users did not specify a register allocation order, favor eax\n+     normally except if cse is following jumps, then favor edx so\n+     that function returns are cse'ed */\n+  else\n+    {\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\treg_alloc_order[i] = i;\n+\n+      if (optimize && flag_cse_follow_jumps && !leaf_function_p ())\n+\t{\n+\t  reg_alloc_order[0] = 1;\t/* edx */\n+\t  reg_alloc_order[1] = 2;\t/* ecx */\n+\t  reg_alloc_order[2] = 0;\t/* eax */\n+\t}\n+    }\n+}\n+\n \f\n /* Output an insn whose source is a 386 integer register.  SRC is the\n    rtx for the register, and TEMPLATE is the op-code template.  SRC may"}, {"sha": "c68b32d6b84c6c779498b4b51133848d67e51fbc", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 82, "deletions": 16, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f5316dfe88b8d1b8d3012c1f75349edf2ba1bdde", "patch": "@@ -158,16 +158,34 @@ extern int target_flags;\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   { \"\", TARGET_DEFAULT | TARGET_CPU_DEFAULT}}\n \n-/* This is meant to be redefined in the host dependent files */\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable.  The\n+   variable, type `char *', is set to the variable part of the given\n+   option if the fixed part matches.  The actual option name is made\n+   by appending `-m' to the specified name.  */\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+{ { \"reg-alloc=\", &i386_reg_alloc_order },\t\t\t\t\\\n+  SUBTARGET_OPTIONS }\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+/* These are meant to be redefined in the host dependent files */\n #define SUBTARGET_SWITCHES\n+#define SUBTARGET_OPTIONS\n \n-#define OVERRIDE_OPTIONS\t\\\n-{\t\t\t\t\\\n-  SUBTARGET_OVERRIDE_OPTIONS\t\\\n-}\n-\n-/* This is meant to be redefined in the host dependent files */\n-#define SUBTARGET_OVERRIDE_OPTIONS\n \f\n /* target machine storage layout */\n \n@@ -313,11 +331,24 @@ extern int target_flags;\n    functions, and a slightly slower compiler.  Users complained about the code\n    generated by allocating edx first, so restore the 'natural' order of things. */\n \n-#if 0\n #define REG_ALLOC_ORDER \\\n-/*dx,cx,ax,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n-{  1, 2, 0, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16 }\n-#endif\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n+{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16 }\n+\n+/* A C statement (sans semicolon) to choose the order in which to\n+   allocate hard registers for pseudo-registers local to a basic\n+   block.\n+\n+   Store the desired register order in the array `reg_alloc_order'.\n+   Element 0 should be the register to allocate first; element 1, the\n+   next register; and so on.\n+\n+   The macro body should not assume anything about the contents of\n+   `reg_alloc_order' before execution of the macro.\n+\n+   On most machines, it is not necessary to define this macro.  */\n+\n+#define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n@@ -509,7 +540,6 @@ enum reg_class\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n \n /* When defined, the compiler allows registers explicitly used in the\n@@ -641,6 +671,32 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n  (FLOAT_CLASS_P (CLASS) ? 1 :\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* A C expression whose value is nonzero if pseudos that have been\n+   assigned to registers of class CLASS would likely be spilled\n+   because registers of CLASS are needed for spill registers.\n+\n+   The default value of this macro returns 1 if CLASS has exactly one\n+   register and zero otherwise.  On most machines, this default\n+   should be used.  Only define this macro to some other expression\n+   if pseudo allocated by `local-alloc.c' end up in memory because\n+   their hard registers were needed for spill regisers.  If this\n+   macro returns nonzero for those classes, those pseudos will only\n+   be allocated by `global.c', which knows how to reallocate the\n+   pseudo to another register.  If there would not be another\n+   register available for reallocation, you should not change the\n+   definition of this macro since the only effect of such a\n+   definition would be to slow down register allocation.  */\n+\n+#define CLASS_LIKELY_SPILLED_P(CLASS)\t\t\t\t\t\\\n+  (((CLASS) == AREG)\t\t\t\t\t\t\t\\\n+   || ((CLASS) == DREG)\t\t\t\t\t\t\t\\\n+   || ((CLASS) == CREG)\t\t\t\t\t\t\t\\\n+   || ((CLASS) == BREG)\t\t\t\t\t\t\t\\\n+   || ((CLASS) == AD_REGS)\t\t\t\t\t\t\\\n+   || ((CLASS) == SIREG)\t\t\t\t\t\t\\\n+   || ((CLASS) == DIREG))\n+\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1296,7 +1352,6 @@ while (0)\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n \n-extern struct rtx_def *i386_compare_op0, *i386_compare_op1;\n extern struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n@@ -1643,6 +1698,8 @@ extern char *qi_high_reg_name[];\n #define AT_SP(mode) (gen_rtx (MEM, (mode), stack_pointer_rtx))\n \f\n /* Functions in i386.c */\n+extern void override_options ();\n+extern void order_regs_for_local_alloc ();\n extern void output_op_from_reg ();\n extern void output_to_reg ();\n extern char *singlemove_string ();\n@@ -1676,9 +1733,18 @@ extern void restore_386_machine_status ();\n extern void clear_386_stack_locals ();\n extern struct rtx_def *assign_386_stack_local ();\n \n+/* Variables in i386.c */\n+extern char *i386_reg_alloc_order;\t\t/* register allocation order */\n+extern char *hi_reg_name[];\t\t\t/* names for 16 bit regs */\n+extern char *qi_reg_name[];\t\t\t/* names for 8 bit regs (low) */\n+extern char *qi_high_reg_name[];\t\t/* names for 8 bit regs (high) */\n+extern enum reg_class regclass_map[];\t\t/* smalled class containing REGNO */\n+extern struct rtx_def *i386_compare_op0;\t/* operand 0 for comparisons */\n+extern struct rtx_def *i386_compare_op1;\t/* operand 1 for comparisons */\n+\n /* External variables used */\n-extern int optimize;\t\t/* optimization level */\n-extern int obey_regdecls;\t/* TRUE if stupid register allocation */\n+extern int optimize;\t\t\t/* optimization level */\n+extern int obey_regdecls;\t\t/* TRUE if stupid register allocation */\n \n /* External functions used */\n extern struct rtx_def *force_operand ();"}]}