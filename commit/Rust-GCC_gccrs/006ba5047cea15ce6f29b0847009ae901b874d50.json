{"sha": "006ba5047cea15ce6f29b0847009ae901b874d50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2YmE1MDQ3Y2VhMTVjZTZmMjliMDg0NzAwOWFlOTAxYjg3NGQ1MA==", "commit": {"author": {"name": "Ilya Enkovich", "email": "enkovich.gnu@gmail.com", "date": "2015-09-29T09:32:40Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-09-29T09:32:40Z"}, "message": "re PR target/65105 ([i386] XMM registers are not used for 64bit computations on 32bit target)\n\ngcc/\n\n\tPR target/65105\n\t* config/i386/i386.c: Include dbgcnt.h.\n\t(has_non_address_hard_reg): New.\n\t(convertible_comparison_p): New.\n\t(scalar_to_vector_candidate_p): New.\n\t(remove_non_convertible_regs): New.\n\t(scalar_chain): New.\n\t(scalar_chain::scalar_chain): New.\n\t(scalar_chain::~scalar_chain): New.\n\t(scalar_chain::add_to_queue): New.\n\t(scalar_chain::mark_dual_mode_def): New.\n\t(scalar_chain::analyze_register_chain): New.\n\t(scalar_chain::add_insn): New.\n\t(scalar_chain::build): New.\n\t(scalar_chain::compute_convert_gain): New.\n\t(scalar_chain::replace_with_subreg): New.\n\t(scalar_chain::replace_with_subreg_in_insn): New.\n\t(scalar_chain::emit_conversion_insns): New.\n\t(scalar_chain::make_vector_copies): New.\n\t(scalar_chain::convert_reg): New.\n\t(scalar_chain::convert_op): New.\n\t(scalar_chain::convert_insn): New.\n\t(scalar_chain::convert): New.\n\t(convert_scalars_to_vector): New.\n\t(pass_data_stv): New.\n\t(pass_stv): New.\n\t(make_pass_stv): New.\n\t(ix86_option_override): Created and register stv pass.\n\t(flag_opts): Add -mstv.\n\t(ix86_option_override_internal): Likewise.\n\t* config/i386/i386.md (SWIM1248x): New.\n\t(*movdi_internal): Add xmm to mem alternative for TARGET_STV.\n\t(and<mode>3): Use SWIM1248x iterator instead of SWIM.\n\t(*anddi3_doubleword): New.\n\t(*zext<mode>_doubleword): New.\n\t(*zextsi_doubleword): New.\n\t(<code><mode>3): Use SWIM1248x iterator instead of SWIM.\n\t(*<code>di3_doubleword): New.\n\t* config/i386/i386.opt (mstv): New.\n\t* dbgcnt.def (stv_conversion): New.\n\ngcc/testsuite/\n\n\tPR target/65105\n\t* gcc.target/i386/pr65105-1.c: New.\n\t* gcc.target/i386/pr65105-2.c: New.\n\t* gcc.target/i386/pr65105-3.c: New.\n\t* gcc.target/i386/pr65105-4.C: New.\n\t* gcc.dg/lower-subreg-1.c: Add -mno-stv options for ia32.\n\nFrom-SVN: r228231", "tree": {"sha": "e4330bab14416db15ce0d200ccaf8f41519c10d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4330bab14416db15ce0d200ccaf8f41519c10d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/006ba5047cea15ce6f29b0847009ae901b874d50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006ba5047cea15ce6f29b0847009ae901b874d50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/006ba5047cea15ce6f29b0847009ae901b874d50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006ba5047cea15ce6f29b0847009ae901b874d50/comments", "author": null, "committer": null, "parents": [{"sha": "2943f6f71601fa523f777d974f889efe8cf9b66b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2943f6f71601fa523f777d974f889efe8cf9b66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2943f6f71601fa523f777d974f889efe8cf9b66b"}], "stats": {"total": 1219, "additions": 1199, "deletions": 20}, "files": [{"sha": "12de2e10ae7331f41a8664b8c0220e5522e9834f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -1,3 +1,46 @@\n+2015-09-29  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\tPR target/65105\n+\t* config/i386/i386.c: Include dbgcnt.h.\n+\t(has_non_address_hard_reg): New.\n+\t(convertible_comparison_p): New.\n+\t(scalar_to_vector_candidate_p): New.\n+\t(remove_non_convertible_regs): New.\n+\t(scalar_chain): New.\n+\t(scalar_chain::scalar_chain): New.\n+\t(scalar_chain::~scalar_chain): New.\n+\t(scalar_chain::add_to_queue): New.\n+\t(scalar_chain::mark_dual_mode_def): New.\n+\t(scalar_chain::analyze_register_chain): New.\n+\t(scalar_chain::add_insn): New.\n+\t(scalar_chain::build): New.\n+\t(scalar_chain::compute_convert_gain): New.\n+\t(scalar_chain::replace_with_subreg): New.\n+\t(scalar_chain::replace_with_subreg_in_insn): New.\n+\t(scalar_chain::emit_conversion_insns): New.\n+\t(scalar_chain::make_vector_copies): New.\n+\t(scalar_chain::convert_reg): New.\n+\t(scalar_chain::convert_op): New.\n+\t(scalar_chain::convert_insn): New.\n+\t(scalar_chain::convert): New.\n+\t(convert_scalars_to_vector): New.\n+\t(pass_data_stv): New.\n+\t(pass_stv): New.\n+\t(make_pass_stv): New.\n+\t(ix86_option_override): Created and register stv pass.\n+\t(flag_opts): Add -mstv.\n+\t(ix86_option_override_internal): Likewise.\n+\t* config/i386/i386.md (SWIM1248x): New.\n+\t(*movdi_internal): Add xmm to mem alternative for TARGET_STV.\n+\t(and<mode>3): Use SWIM1248x iterator instead of SWIM.\n+\t(*anddi3_doubleword): New.\n+\t(*zext<mode>_doubleword): New.\n+\t(*zextsi_doubleword): New.\n+\t(<code><mode>3): Use SWIM1248x iterator instead of SWIM.\n+\t(*<code>di3_doubleword): New.\n+\t* config/i386/i386.opt (mstv): New.\n+\t* dbgcnt.def (stv_conversion): New.\n+\n 2015-09-29  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-cfg.c (dump_function_to_file): Dump function attributes."}, {"sha": "6f2380f28219fbf0e337128d0e599a997a7f5268", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -87,6 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"tree-chkp.h\"\n #include \"rtl-chkp.h\"\n+#include \"dbgcnt.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -2602,6 +2603,908 @@ rest_of_handle_insert_vzeroupper (void)\n   return 0;\n }\n \n+/* Return 1 if INSN uses or defines a hard register.\n+   Hard register uses in a memory address are ignored.\n+   Clobbers and flags definitions are ignored.  */\n+\n+static bool\n+has_non_address_hard_reg (rtx_insn *insn)\n+{\n+  df_ref ref;\n+  FOR_EACH_INSN_DEF (ref, insn)\n+    if (HARD_REGISTER_P (DF_REF_REAL_REG (ref))\n+\t&& !DF_REF_FLAGS_IS_SET (ref, DF_REF_MUST_CLOBBER)\n+\t&& DF_REF_REGNO (ref) != FLAGS_REG)\n+      return true;\n+\n+  FOR_EACH_INSN_USE (ref, insn)\n+    if (!DF_REF_REG_MEM_P (ref) && HARD_REGISTER_P (DF_REF_REAL_REG (ref)))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Check if comparison INSN may be transformed\n+   into vector comparison.  Currently we transform\n+   zero checks only which look like:\n+\n+   (set (reg:CCZ 17 flags)\n+        (compare:CCZ (ior:SI (subreg:SI (reg:DI x) 4)\n+                             (subreg:SI (reg:DI x) 0))\n+\t\t     (const_int 0 [0])))  */\n+\n+static bool\n+convertible_comparison_p (rtx_insn *insn)\n+{\n+  if (!TARGET_SSE4_1)\n+    return false;\n+\n+  rtx def_set = single_set (insn);\n+\n+  gcc_assert (def_set);\n+\n+  rtx src = SET_SRC (def_set);\n+  rtx dst = SET_DEST (def_set);\n+\n+  gcc_assert (GET_CODE (src) == COMPARE);\n+\n+  if (GET_CODE (dst) != REG\n+      || REGNO (dst) != FLAGS_REG\n+      || GET_MODE (dst) != CCZmode)\n+    return false;\n+\n+  rtx op1 = XEXP (src, 0);\n+  rtx op2 = XEXP (src, 1);\n+\n+  if (op2 != CONST0_RTX (GET_MODE (op2)))\n+    return false;\n+\n+  if (GET_CODE (op1) != IOR)\n+    return false;\n+\n+  op2 = XEXP (op1, 1);\n+  op1 = XEXP (op1, 0);\n+\n+  if (!SUBREG_P (op1)\n+      || !SUBREG_P (op2)\n+      || GET_MODE (op1) != SImode\n+      || GET_MODE (op2) != SImode\n+      || ((SUBREG_BYTE (op1) != 0\n+\t   || SUBREG_BYTE (op2) != GET_MODE_SIZE (SImode))\n+\t  && (SUBREG_BYTE (op2) != 0\n+\t      || SUBREG_BYTE (op1) != GET_MODE_SIZE (SImode))))\n+    return false;\n+\n+  op1 = SUBREG_REG (op1);\n+  op2 = SUBREG_REG (op2);\n+\n+  if (op1 != op2\n+      || !REG_P (op1)\n+      || GET_MODE (op1) != DImode)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return 1 if INSN may be converted into vector\n+   instruction.  */\n+\n+static bool\n+scalar_to_vector_candidate_p (rtx_insn *insn)\n+{\n+  rtx def_set = single_set (insn);\n+\n+  if (!def_set)\n+    return false;\n+\n+  if (has_non_address_hard_reg (insn))\n+    return false;\n+\n+  rtx src = SET_SRC (def_set);\n+  rtx dst = SET_DEST (def_set);\n+\n+  if (GET_CODE (src) == COMPARE)\n+    return convertible_comparison_p (insn);\n+\n+  /* We are interested in DImode promotion only.  */\n+  if (GET_MODE (src) != DImode\n+      || GET_MODE (dst) != DImode)\n+    return false;\n+\n+  if (!REG_P (dst) && !MEM_P (dst))\n+    return false;\n+\n+  switch (GET_CODE (src))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case IOR:\n+    case XOR:\n+    case AND:\n+      break;\n+\n+    case REG:\n+      return true;\n+\n+    case MEM:\n+      return REG_P (dst);\n+\n+    default:\n+      return false;\n+    }\n+\n+  if (!REG_P (XEXP (src, 0)) && !MEM_P (XEXP (src, 0)))\n+      return false;\n+\n+  if (!REG_P (XEXP (src, 1)) && !MEM_P (XEXP (src, 1)))\n+      return false;\n+\n+  if (GET_MODE (XEXP (src, 0)) != DImode\n+      || GET_MODE (XEXP (src, 1)) != DImode)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* For a given bitmap of insn UIDs scans all instruction and\n+   remove insn from CANDIDATES in case it has both convertible\n+   and not convertible definitions.\n+\n+   All insns in a bitmap are conversion candidates according to\n+   scalar_to_vector_candidate_p.  Currently it implies all insns\n+   are single_set.  */\n+\n+static void\n+remove_non_convertible_regs (bitmap candidates)\n+{\n+  bitmap_iterator bi;\n+  unsigned id;\n+  bitmap regs = BITMAP_ALLOC (NULL);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (candidates, 0, id, bi)\n+    {\n+      rtx def_set = single_set (DF_INSN_UID_GET (id)->insn);\n+      rtx reg = SET_DEST (def_set);\n+\n+      if (!REG_P (reg)\n+\t  || bitmap_bit_p (regs, REGNO (reg))\n+\t  || HARD_REGISTER_P (reg))\n+\tcontinue;\n+\n+      for (df_ref def = DF_REG_DEF_CHAIN (REGNO (reg));\n+\t   def;\n+\t   def = DF_REF_NEXT_REG (def))\n+\t{\n+\t  if (!bitmap_bit_p (candidates, DF_REF_INSN_UID (def)))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"r%d has non convertible definition in insn %d\\n\",\n+\t\t\t REGNO (reg), DF_REF_INSN_UID (def));\n+\n+\t      bitmap_set_bit (regs, REGNO (reg));\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  EXECUTE_IF_SET_IN_BITMAP (regs, 0, id, bi)\n+    {\n+      for (df_ref def = DF_REG_DEF_CHAIN (id);\n+\t   def;\n+\t   def = DF_REF_NEXT_REG (def))\n+\tif (bitmap_bit_p (candidates, DF_REF_INSN_UID (def)))\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"Removing insn %d from candidates list\\n\",\n+\t\t       DF_REF_INSN_UID (def));\n+\n+\t    bitmap_clear_bit (candidates, DF_REF_INSN_UID (def));\n+\t  }\n+    }\n+\n+  BITMAP_FREE (regs);\n+}\n+\n+class scalar_chain\n+{\n+ public:\n+  scalar_chain ();\n+  ~scalar_chain ();\n+\n+  static unsigned max_id;\n+\n+  /* ID of a chain.  */\n+  unsigned int chain_id;\n+  /* A queue of instructions to be included into a chain.  */\n+  bitmap queue;\n+  /* Instructions included into a chain.  */\n+  bitmap insns;\n+  /* All registers defined by a chain.  */\n+  bitmap defs;\n+  /* Registers used in both vector and sclar modes.  */\n+  bitmap defs_conv;\n+\n+  void build (bitmap candidates, unsigned insn_uid);\n+  int compute_convert_gain ();\n+  int convert ();\n+\n+ private:\n+  void add_insn (bitmap candidates, unsigned insn_uid);\n+  void add_to_queue (unsigned insn_uid);\n+  void mark_dual_mode_def (df_ref def);\n+  void analyze_register_chain (bitmap candidates, df_ref ref);\n+  rtx replace_with_subreg (rtx x, rtx reg, rtx subreg);\n+  void emit_conversion_insns (rtx insns, rtx_insn *pos);\n+  void replace_with_subreg_in_insn (rtx_insn *insn, rtx reg, rtx subreg);\n+  void convert_insn (rtx_insn *insn);\n+  void convert_op (rtx *op, rtx_insn *insn);\n+  void convert_reg (unsigned regno);\n+  void make_vector_copies (unsigned regno);\n+};\n+\n+unsigned scalar_chain::max_id = 0;\n+\n+/* Initialize new chain.  */\n+\n+scalar_chain::scalar_chain ()\n+{\n+  chain_id = ++max_id;\n+\n+   if (dump_file)\n+    fprintf (dump_file, \"Created a new instruction chain #%d\\n\", chain_id);\n+\n+  bitmap_obstack_initialize (NULL);\n+  insns = BITMAP_ALLOC (NULL);\n+  defs = BITMAP_ALLOC (NULL);\n+  defs_conv = BITMAP_ALLOC (NULL);\n+  queue = NULL;\n+}\n+\n+/* Free chain's data.  */\n+\n+scalar_chain::~scalar_chain ()\n+{\n+  BITMAP_FREE (insns);\n+  BITMAP_FREE (defs);\n+  BITMAP_FREE (defs_conv);\n+  bitmap_obstack_release (NULL);\n+}\n+\n+/* Add instruction into chains' queue.  */\n+\n+void\n+scalar_chain::add_to_queue (unsigned insn_uid)\n+{\n+  if (bitmap_bit_p (insns, insn_uid)\n+      || bitmap_bit_p (queue, insn_uid))\n+    return;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Adding insn %d into chain's #%d queue\\n\",\n+\t     insn_uid, chain_id);\n+  bitmap_set_bit (queue, insn_uid);\n+}\n+\n+/* Mark register defined by DEF as requiring conversion.  */\n+\n+void\n+scalar_chain::mark_dual_mode_def (df_ref def)\n+{\n+  gcc_assert (DF_REF_REG_DEF_P (def));\n+\n+  if (bitmap_bit_p (defs_conv, DF_REF_REGNO (def)))\n+    return;\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"  Mark r%d def in insn %d as requiring both modes in chain #%d\\n\",\n+\t     DF_REF_REGNO (def), DF_REF_INSN_UID (def), chain_id);\n+\n+  bitmap_set_bit (defs_conv, DF_REF_REGNO (def));\n+}\n+\n+/* Check REF's chain to add new insns into a queue\n+   and find registers requiring conversion.  */\n+\n+void\n+scalar_chain::analyze_register_chain (bitmap candidates, df_ref ref)\n+{\n+  df_link *chain;\n+\n+  gcc_assert (bitmap_bit_p (insns, DF_REF_INSN_UID (ref))\n+\t      || bitmap_bit_p (candidates, DF_REF_INSN_UID (ref)));\n+  add_to_queue (DF_REF_INSN_UID (ref));\n+\n+  for (chain = DF_REF_CHAIN (ref); chain; chain = chain->next)\n+    {\n+      unsigned uid = DF_REF_INSN_UID (chain->ref);\n+      if (!DF_REF_REG_MEM_P (chain->ref))\n+\t{\n+\t  if (bitmap_bit_p (insns, uid))\n+\t    continue;\n+\n+\t  if (bitmap_bit_p (candidates, uid))\n+\t    {\n+\t      add_to_queue (uid);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (DF_REF_REG_DEF_P (chain->ref))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  r%d def in insn %d isn't convertible\\n\",\n+\t\t     DF_REF_REGNO (chain->ref), uid);\n+\t  mark_dual_mode_def (chain->ref);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  r%d use in insn %d isn't convertible\\n\",\n+\t\t     DF_REF_REGNO (chain->ref), uid);\n+\t  mark_dual_mode_def (ref);\n+\t}\n+    }\n+}\n+\n+/* Add instruction into a chain.  */\n+\n+void\n+scalar_chain::add_insn (bitmap candidates, unsigned int insn_uid)\n+{\n+  if (bitmap_bit_p (insns, insn_uid))\n+    return;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Adding insn %d to chain #%d\\n\", insn_uid, chain_id);\n+\n+  bitmap_set_bit (insns, insn_uid);\n+\n+  rtx_insn *insn = DF_INSN_UID_GET (insn_uid)->insn;\n+  rtx def_set = single_set (insn);\n+  if (def_set && REG_P (SET_DEST (def_set))\n+      && !HARD_REGISTER_P (SET_DEST (def_set)))\n+    bitmap_set_bit (defs, REGNO (SET_DEST (def_set)));\n+\n+  df_ref ref;\n+  df_ref def;\n+  for (ref = DF_INSN_UID_DEFS (insn_uid); ref; ref = DF_REF_NEXT_LOC (ref))\n+    if (!HARD_REGISTER_P (DF_REF_REG (ref)))\n+      for (def = DF_REG_DEF_CHAIN (DF_REF_REGNO (ref));\n+\t   def;\n+\t   def = DF_REF_NEXT_REG (def))\n+\tanalyze_register_chain (candidates, def);\n+  for (ref = DF_INSN_UID_USES (insn_uid); ref; ref = DF_REF_NEXT_LOC (ref))\n+    if (!DF_REF_REG_MEM_P (ref))\n+      analyze_register_chain (candidates, ref);\n+}\n+\n+/* Build new chain starting from insn INSN_UID recursively\n+   adding all dependent uses and definitions.  */\n+\n+void\n+scalar_chain::build (bitmap candidates, unsigned insn_uid)\n+{\n+  queue = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (queue, insn_uid);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Building chain #%d...\\n\", chain_id);\n+\n+  while (!bitmap_empty_p (queue))\n+    {\n+      insn_uid = bitmap_first_set_bit (queue);\n+      bitmap_clear_bit (queue, insn_uid);\n+      bitmap_clear_bit (candidates, insn_uid);\n+      add_insn (candidates, insn_uid);\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Collected chain #%d...\\n\", chain_id);\n+      fprintf (dump_file, \"  insns: \");\n+      dump_bitmap (dump_file, insns);\n+      if (!bitmap_empty_p (defs_conv))\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned id;\n+\t  const char *comma = \"\";\n+\t  fprintf (dump_file, \"  defs to convert: \");\n+\t  EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, id, bi)\n+\t    {\n+\t      fprintf (dump_file, \"%sr%d\", comma, id);\n+\t      comma = \", \";\n+\t    }\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+\n+  BITMAP_FREE (queue);\n+}\n+\n+/* Compute a gain for chain conversion.  */\n+\n+int\n+scalar_chain::compute_convert_gain ()\n+{\n+  bitmap_iterator bi;\n+  unsigned insn_uid;\n+  int gain = 0;\n+  int cost = 0;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Computing gain for chain #%d...\\n\", chain_id);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (insns, 0, insn_uid, bi)\n+    {\n+      rtx_insn *insn = DF_INSN_UID_GET (insn_uid)->insn;\n+      rtx def_set = single_set (insn);\n+      rtx src = SET_SRC (def_set);\n+      rtx dst = SET_DEST (def_set);\n+\n+      if (REG_P (src) && REG_P (dst))\n+\tgain += COSTS_N_INSNS (2) - ix86_cost->sse_move;\n+      else if (REG_P (src) && MEM_P (dst))\n+\tgain += 2 * ix86_cost->int_store[2] - ix86_cost->sse_store[1];\n+      else if (MEM_P (src) && REG_P (dst))\n+\tgain += 2 * ix86_cost->int_load[2] - ix86_cost->sse_load[1];\n+      else if (GET_CODE (src) == PLUS\n+\t       || GET_CODE (src) == MINUS\n+\t       || GET_CODE (src) == IOR\n+\t       || GET_CODE (src) == XOR\n+\t       || GET_CODE (src) == AND)\n+\tgain += ix86_cost->add;\n+      else if (GET_CODE (src) == COMPARE)\n+\t{\n+\t  /* Assume comparison cost is the same.  */\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Instruction convertion gain: %d\\n\", gain);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, insn_uid, bi)\n+    cost += DF_REG_DEF_COUNT (insn_uid) * ix86_cost->mmxsse_to_integer;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Registers convertion cost: %d\\n\", cost);\n+\n+  gain -= cost;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"  Total gain: %d\\n\", gain);\n+\n+  return gain;\n+}\n+\n+/* Replace REG in X with a V2DI subreg of NEW_REG.  */\n+\n+rtx\n+scalar_chain::replace_with_subreg (rtx x, rtx reg, rtx new_reg)\n+{\n+  if (x == reg)\n+    return gen_rtx_SUBREG (V2DImode, new_reg, 0);\n+\n+  const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  int i, j;\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tXEXP (x, i) = replace_with_subreg (XEXP (x, i), reg, new_reg);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  XVECEXP (x, i, j) = replace_with_subreg (XVECEXP (x, i, j),\n+\t\t\t\t\t\t   reg, new_reg);\n+    }\n+\n+  return x;\n+}\n+\n+/* Replace REG in INSN with a V2DI subreg of NEW_REG.  */\n+\n+void\n+scalar_chain::replace_with_subreg_in_insn (rtx_insn *insn, rtx reg, rtx new_reg)\n+{\n+  replace_with_subreg (single_set (insn), reg, new_reg);\n+}\n+\n+/* Insert generated conversion instruction sequence INSNS\n+   after instruction AFTER.  New BB may be required in case\n+   instruction has EH region attached.  */\n+\n+void\n+scalar_chain::emit_conversion_insns (rtx insns, rtx_insn *after)\n+{\n+  if (!control_flow_insn_p (after))\n+    {\n+      emit_insn_after (insns, after);\n+      return;\n+    }\n+\n+  basic_block bb = BLOCK_FOR_INSN (after);\n+  edge e = find_fallthru_edge (bb->succs);\n+  gcc_assert (e);\n+\n+  basic_block new_bb = split_edge (e);\n+  emit_insn_after (insns, BB_HEAD (new_bb));\n+}\n+\n+/* Make vector copies for all register REGNO definitions\n+   and replace its uses in a chain.  */\n+\n+void\n+scalar_chain::make_vector_copies (unsigned regno)\n+{\n+  rtx reg = regno_reg_rtx[regno];\n+  rtx vreg = gen_reg_rtx (DImode);\n+  df_ref ref;\n+\n+  for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n+    if (!bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n+      {\n+\trtx_insn *insn = DF_REF_INSN (ref);\n+\n+\tstart_sequence ();\n+\tif (TARGET_SSE4_1)\n+\t  {\n+\t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\tCONST0_RTX (V4SImode),\n+\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 0)));\n+\t    emit_insn (gen_sse4_1_pinsrd (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t  gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\t  gen_rtx_SUBREG (SImode, reg, 4),\n+\t\t\t\t\t  GEN_INT (2)));\n+\t  }\n+\telse if (TARGET_INTER_UNIT_MOVES_TO_VEC)\n+\t  {\n+\t    rtx tmp = gen_reg_rtx (DImode);\n+\t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\t\t\tCONST0_RTX (V4SImode),\n+\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 0)));\n+\t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, tmp, 0),\n+\t\t\t\t\tCONST0_RTX (V4SImode),\n+\t\t\t\t\tgen_rtx_SUBREG (SImode, reg, 4)));\n+\t    emit_insn (gen_vec_interleave_lowv4si\n+\t\t       (gen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\tgen_rtx_SUBREG (V4SImode, vreg, 0),\n+\t\t\tgen_rtx_SUBREG (V4SImode, tmp, 0)));\n+\t  }\n+\telse\n+\t  {\n+\t    rtx tmp = assign_386_stack_local (DImode, SLOT_TEMP);\n+\t    emit_move_insn (adjust_address (tmp, SImode, 0),\n+\t\t\t    gen_rtx_SUBREG (SImode, reg, 0));\n+\t    emit_move_insn (adjust_address (tmp, SImode, 4),\n+\t\t\t    gen_rtx_SUBREG (SImode, reg, 4));\n+\t    emit_move_insn (vreg, tmp);\n+\t  }\n+\temit_conversion_insns (get_insns (), insn);\n+\tend_sequence ();\n+\n+\tif (dump_file)\n+\t  fprintf (dump_file,\n+\t\t   \"  Copied r%d to a vector register r%d for insn %d\\n\",\n+\t\t   regno, REGNO (vreg), DF_REF_INSN_UID (ref));\n+      }\n+\n+  for (ref = DF_REG_USE_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n+    if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n+      {\n+\treplace_with_subreg_in_insn (DF_REF_INSN (ref), reg, vreg);\n+\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"  Replaced r%d with r%d in insn %d\\n\",\n+\t\t   regno, REGNO (vreg), DF_REF_INSN_UID (ref));\n+      }\n+}\n+\n+/* Convert all definitions of register REGNO\n+   and fix its uses.  Scalar copies may be created\n+   in case register is used in not convertible insn.  */\n+\n+void\n+scalar_chain::convert_reg (unsigned regno)\n+{\n+  bool scalar_copy = bitmap_bit_p (defs_conv, regno);\n+  rtx reg = regno_reg_rtx[regno];\n+  rtx scopy = NULL_RTX;\n+  df_ref ref;\n+  bitmap conv;\n+\n+  conv = BITMAP_ALLOC (NULL);\n+  bitmap_copy (conv, insns);\n+\n+  if (scalar_copy)\n+    scopy = gen_reg_rtx (DImode);\n+\n+  for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n+    {\n+      rtx_insn *insn = DF_REF_INSN (ref);\n+      rtx def_set = single_set (insn);\n+      rtx src = SET_SRC (def_set);\n+      rtx reg = DF_REF_REG (ref);\n+\n+      if (!MEM_P (src))\n+\t{\n+\t  replace_with_subreg_in_insn (insn, reg, reg);\n+\t  bitmap_clear_bit (conv, INSN_UID (insn));\n+\t}\n+\n+      if (scalar_copy)\n+\t{\n+\t  rtx vcopy = gen_reg_rtx (V2DImode);\n+\n+\t  start_sequence ();\n+\t  if (TARGET_INTER_UNIT_MOVES_FROM_VEC)\n+\t    {\n+\t      emit_move_insn (vcopy, gen_rtx_SUBREG (V2DImode, reg, 0));\n+\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n+\t\t\t      gen_rtx_SUBREG (SImode, vcopy, 0));\n+\t      emit_move_insn (vcopy,\n+\t\t\t      gen_rtx_LSHIFTRT (V2DImode, vcopy, GEN_INT (32)));\n+\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n+\t\t\t      gen_rtx_SUBREG (SImode, vcopy, 0));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx tmp = assign_386_stack_local (DImode, SLOT_TEMP);\n+\t      emit_move_insn (tmp, reg);\n+\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 0),\n+\t\t\t      adjust_address (tmp, SImode, 0));\n+\t      emit_move_insn (gen_rtx_SUBREG (SImode, scopy, 4),\n+\t\t\t      adjust_address (tmp, SImode, 4));\n+\t    }\n+\t  emit_conversion_insns (get_insns (), insn);\n+\t  end_sequence ();\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"  Copied r%d to a scalar register r%d for insn %d\\n\",\n+\t\t     regno, REGNO (scopy), INSN_UID (insn));\n+\t}\n+    }\n+\n+  for (ref = DF_REG_USE_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n+    if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n+      {\n+\tif (bitmap_bit_p (conv, DF_REF_INSN_UID (ref)))\n+\t  {\n+\t    rtx def_set = single_set (DF_REF_INSN (ref));\n+\t    if (!MEM_P (SET_DEST (def_set))\n+\t\t|| !REG_P (SET_SRC (def_set)))\n+\t      replace_with_subreg_in_insn (DF_REF_INSN (ref), reg, reg);\n+\t    bitmap_clear_bit (conv, DF_REF_INSN_UID (ref));\n+\t  }\n+      }\n+    else\n+      {\n+\treplace_rtx (DF_REF_INSN (ref), reg, scopy);\n+\tdf_insn_rescan (DF_REF_INSN (ref));\n+      }\n+\n+  BITMAP_FREE (conv);\n+}\n+\n+/* Convert operand OP in INSN.  All register uses\n+   are converted during registers conversion.\n+   Therefore we should just handle memory operands.  */\n+\n+void\n+scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n+{\n+  *op = copy_rtx_if_shared (*op);\n+\n+  if (MEM_P (*op))\n+    {\n+      rtx tmp = gen_reg_rtx (DImode);\n+\n+      emit_insn_before (gen_move_insn (tmp, *op), insn);\n+      *op = gen_rtx_SUBREG (V2DImode, tmp, 0);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"  Preloading operand for insn %d into r%d\\n\",\n+\t\t INSN_UID (insn), REGNO (tmp));\n+    }\n+  else\n+    {\n+      gcc_assert (SUBREG_P (*op));\n+      gcc_assert (GET_MODE (*op) == V2DImode);\n+    }\n+}\n+\n+/* Convert INSN to vector mode.  */\n+\n+void\n+scalar_chain::convert_insn (rtx_insn *insn)\n+{\n+  rtx def_set = single_set (insn);\n+  rtx src = SET_SRC (def_set);\n+  rtx dst = SET_DEST (def_set);\n+  rtx subreg;\n+\n+  if (MEM_P (dst) && !REG_P (src))\n+    {\n+      /* There are no scalar integer instructions and therefore\n+\t temporary register usage is required.  */\n+      rtx tmp = gen_reg_rtx (DImode);\n+      emit_conversion_insns (gen_move_insn (dst, tmp), insn);\n+      dst = gen_rtx_SUBREG (V2DImode, tmp, 0);\n+    }\n+\n+  switch (GET_CODE (src))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case IOR:\n+    case XOR:\n+    case AND:\n+      convert_op (&XEXP (src, 0), insn);\n+      convert_op (&XEXP (src, 1), insn);\n+      PUT_MODE (src, V2DImode);\n+      break;\n+\n+    case MEM:\n+      if (!REG_P (dst))\n+\tconvert_op (&src, insn);\n+      break;\n+\n+    case REG:\n+      break;\n+\n+    case SUBREG:\n+      gcc_assert (GET_MODE (src) == V2DImode);\n+      break;\n+\n+    case COMPARE:\n+      src = SUBREG_REG (XEXP (XEXP (src, 0), 0));\n+\n+      gcc_assert ((REG_P (src) && GET_MODE (src) == DImode)\n+\t\t  || (SUBREG_P (src) && GET_MODE (src) == V2DImode));\n+\n+      if (REG_P (src))\n+\tsubreg = gen_rtx_SUBREG (V2DImode, src, 0);\n+      else\n+\tsubreg = copy_rtx_if_shared (src);\n+      emit_insn_before (gen_vec_interleave_lowv2di (copy_rtx_if_shared (subreg),\n+\t\t\t\t\t\t    copy_rtx_if_shared (subreg),\n+\t\t\t\t\t\t    copy_rtx_if_shared (subreg)),\n+\t\t\tinsn);\n+      dst = gen_rtx_REG (CCmode, FLAGS_REG);\n+      src = gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (src),\n+\t\t\t\t\t       copy_rtx_if_shared (src)),\n+\t\t\t    UNSPEC_PTEST);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  SET_SRC (def_set) = src;\n+  SET_DEST (def_set) = dst;\n+\n+  /* Drop possible dead definitions.  */\n+  PATTERN (insn) = def_set;\n+\n+  INSN_CODE (insn) = -1;\n+  recog_memoized (insn);\n+  df_insn_rescan (insn);\n+}\n+\n+/* Convert whole chain creating required register\n+   conversions and copies.  */\n+\n+int\n+scalar_chain::convert ()\n+{\n+  bitmap_iterator bi;\n+  unsigned id;\n+  int converted_insns = 0;\n+\n+  if (!dbg_cnt (stv_conversion))\n+    return 0;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Converting chain #%d...\\n\", chain_id);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (defs, 0, id, bi)\n+    convert_reg (id);\n+\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (defs_conv, defs, 0, id, bi)\n+    make_vector_copies (id);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (insns, 0, id, bi)\n+    {\n+      convert_insn (DF_INSN_UID_GET (id)->insn);\n+      converted_insns++;\n+    }\n+\n+  return converted_insns;\n+}\n+\n+/* Main STV pass function.  Find and convert scalar\n+   instructions into vector mode when profitable.  */\n+\n+static unsigned int\n+convert_scalars_to_vector ()\n+{\n+  basic_block bb;\n+  bitmap candidates;\n+  int converted_insns = 0;\n+\n+  bitmap_obstack_initialize (NULL);\n+  candidates = BITMAP_ALLOC (NULL);\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);\n+  df_md_add_problem ();\n+  df_analyze ();\n+\n+  /* Find all instructions we want to convert into vector mode.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"Searching for mode convertion candidates...\\n\");\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *insn;\n+      FOR_BB_INSNS (bb, insn)\n+\tif (scalar_to_vector_candidate_p (insn))\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"  insn %d is marked as a candidate\\n\",\n+\t\t       INSN_UID (insn));\n+\n+\t    bitmap_set_bit (candidates, INSN_UID (insn));\n+\t  }\n+    }\n+\n+  remove_non_convertible_regs (candidates);\n+\n+  if (bitmap_empty_p (candidates))\n+    if (dump_file)\n+      fprintf (dump_file, \"There are no candidates for optimization.\\n\");\n+\n+  while (!bitmap_empty_p (candidates))\n+    {\n+      unsigned uid = bitmap_first_set_bit (candidates);\n+      scalar_chain chain;\n+\n+      /* Find instructions chain we want to convert to vector mode.\n+\t Check all uses and definitions to estimate all required\n+\t conversions.  */\n+      chain.build (candidates, uid);\n+\n+      if (chain.compute_convert_gain () > 0)\n+\tconverted_insns += chain.convert ();\n+      else\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"Chain #%d conversion is not profitable\\n\",\n+\t\t   chain.chain_id);\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Total insns converted: %d\\n\", converted_insns);\n+\n+  BITMAP_FREE (candidates);\n+  bitmap_obstack_release (NULL);\n+  df_process_deferred_rescans ();\n+\n+  /* Conversion means we may have 128bit register spills/fills\n+     which require aligned stack.  */\n+  if (converted_insns)\n+    {\n+      if (crtl->stack_alignment_needed < 128)\n+\tcrtl->stack_alignment_needed = 128;\n+      if (crtl->stack_alignment_estimated < 128)\n+\tcrtl->stack_alignment_estimated = 128;\n+    }\n+\n+  return 0;\n+}\n+\n namespace {\n \n const pass_data pass_data_insert_vzeroupper =\n@@ -2639,6 +3542,39 @@ class pass_insert_vzeroupper : public rtl_opt_pass\n \n }; // class pass_insert_vzeroupper\n \n+const pass_data pass_data_stv =\n+{\n+  RTL_PASS, /* type */\n+  \"stv\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+class pass_stv : public rtl_opt_pass\n+{\n+public:\n+  pass_stv (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_stv, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return !TARGET_64BIT && TARGET_STV && TARGET_SSE2 && optimize > 1;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return convert_scalars_to_vector ();\n+    }\n+\n+}; // class pass_stv\n+\n } // anon namespace\n \n rtl_opt_pass *\n@@ -2647,6 +3583,12 @@ make_pass_insert_vzeroupper (gcc::context *ctxt)\n   return new pass_insert_vzeroupper (ctxt);\n }\n \n+rtl_opt_pass *\n+make_pass_stv (gcc::context *ctxt)\n+{\n+  return new pass_stv (ctxt);\n+}\n+\n /* Return true if a red-zone is in use.  */\n \n static inline bool\n@@ -2756,6 +3698,7 @@ ix86_target_string (HOST_WIDE_INT isa, int flags, const char *arch,\n     { \"-mvect8-ret-in-mem\",\t\tMASK_VECT8_RETURNS },\n     { \"-m8bit-idiv\",\t\t\tMASK_USE_8BIT_IDIV },\n     { \"-mvzeroupper\",\t\t\tMASK_VZEROUPPER },\n+    { \"-mstv\",\t\t\t\tMASK_STV},\n     { \"-mavx256-split-unaligned-load\",\tMASK_AVX256_SPLIT_UNALIGNED_LOAD},\n     { \"-mavx256-split-unaligned-store\",\tMASK_AVX256_SPLIT_UNALIGNED_STORE},\n     { \"-mprefer-avx128\",\t\tMASK_PREFER_AVX128},\n@@ -4372,6 +5315,8 @@ ix86_option_override_internal (bool main_args_p,\n \n   if (!(opts_set->x_target_flags & MASK_VZEROUPPER))\n     opts->x_target_flags |= MASK_VZEROUPPER;\n+  if (!(opts_set->x_target_flags & MASK_STV))\n+    opts->x_target_flags |= MASK_STV;\n   if (!ix86_tune_features[X86_TUNE_AVX256_UNALIGNED_LOAD_OPTIMAL]\n       && !(opts_set->x_target_flags & MASK_AVX256_SPLIT_UNALIGNED_LOAD))\n     opts->x_target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;\n@@ -4485,12 +5430,18 @@ ix86_option_override (void)\n     = { pass_insert_vzeroupper, \"reload\",\n \t1, PASS_POS_INSERT_AFTER\n       };\n+  opt_pass *pass_stv = make_pass_stv (g);\n+  struct register_pass_info stv_info\n+    = { pass_stv, \"combine\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n \n   ix86_option_override_internal (true, &global_options, &global_options_set);\n \n \n   /* This needs to be done at start up.  It's convenient to do it here.  */\n   register_pass (&insert_vzeroupper_info);\n+  register_pass (&stv_info);\n }\n \n /* Implement the TARGET_OFFLOAD_OPTIONS hook.  */"}, {"sha": "8c2ed606dee5abc93de2b1916c0afa2ccf2766b2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 92, "deletions": 20, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -981,6 +981,11 @@\n \t\t\t       (HI \"TARGET_HIMODE_MATH\")\n \t\t\t       SI])\n \n+;; Math-dependant integer modes with DImode.\n+(define_mode_iterator SWIM1248x [(QI \"TARGET_QIMODE_MATH\")\n+\t\t\t\t (HI \"TARGET_HIMODE_MATH\")\n+\t\t\t\t SI (DI \"(TARGET_STV && TARGET_SSE2) || TARGET_64BIT\")])\n+\n ;; Math-dependant single word integer modes without QImode.\n (define_mode_iterator SWIM248 [(HI \"TARGET_HIMODE_MATH\")\n \t\t      \t       SI (DI \"TARGET_64BIT\")])\n@@ -2097,9 +2102,9 @@\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,?r ,?r,?*Yi,?*Ym,?*Yi,*k,*k ,*r ,*m\")\n+    \"=r  ,o  ,r,r  ,r,m ,*y,*y,?*y,?m,?r ,?*Ym,*v,*v,*v,m ,m,?r ,?r,?*Yi,?*Ym,?*Yi,*k,*k ,*r ,*m\")\n \t(match_operand:DI 1 \"general_operand\"\n-    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,*Yj,*v,r   ,*Yj ,*Yn ,*r ,*km,*k,*k\"))]\n+    \"riFo,riF,Z,rem,i,re,C ,*y,m  ,*y,*Yn,r   ,C ,*v,m ,*v,v,*Yj,*v,r   ,*Yj ,*Yn ,*r ,*km,*k,*k\"))]\n   \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n@@ -2177,9 +2182,9 @@\n   [(set (attr \"isa\")\n      (cond [(eq_attr \"alternative\" \"0,1\")\n \t      (const_string \"nox64\")\n-\t    (eq_attr \"alternative\" \"2,3,4,5,10,11,16,18,21,23\")\n+\t    (eq_attr \"alternative\" \"2,3,4,5,10,11,17,19,22,24\")\n \t      (const_string \"x64\")\n-\t    (eq_attr \"alternative\" \"17\")\n+\t    (eq_attr \"alternative\" \"18\")\n \t      (const_string \"x64_sse4\")\n \t   ]\n \t   (const_string \"*\")))\n@@ -2190,13 +2195,13 @@\n \t      (const_string \"mmx\")\n \t    (eq_attr \"alternative\" \"7,8,9,10,11\")\n \t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"12,17\")\n+\t    (eq_attr \"alternative\" \"12,18\")\n \t      (const_string \"sselog1\")\n-\t    (eq_attr \"alternative\" \"13,14,15,16,18\")\n+\t    (eq_attr \"alternative\" \"13,14,15,16,17,19\")\n \t      (const_string \"ssemov\")\n-\t    (eq_attr \"alternative\" \"19,20\")\n+\t    (eq_attr \"alternative\" \"20,21\")\n \t      (const_string \"ssecvt\")\n-\t    (eq_attr \"alternative\" \"21,22,23,24\")\n+\t    (eq_attr \"alternative\" \"22,23,24,25\")\n \t      (const_string \"mskmov\")\n \t    (and (match_operand 0 \"register_operand\")\n \t\t (match_operand 1 \"pic_32bit_operand\"))\n@@ -2211,16 +2216,16 @@\n    (set (attr \"length_immediate\")\n      (cond [(and (eq_attr \"alternative\" \"4\") (eq_attr \"type\" \"imov\"))\n \t      (const_string \"8\")\n-\t    (eq_attr \"alternative\" \"17\")\n+\t    (eq_attr \"alternative\" \"18\")\n \t      (const_string \"1\")\n \t   ]\n \t   (const_string \"*\")))\n    (set (attr \"prefix_rex\")\n-     (if_then_else (eq_attr \"alternative\" \"10,11,16,17,18\")\n+     (if_then_else (eq_attr \"alternative\" \"10,11,17,18,19\")\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set (attr \"prefix_extra\")\n-     (if_then_else (eq_attr \"alternative\" \"17\")\n+     (if_then_else (eq_attr \"alternative\" \"18\")\n        (const_string \"1\")\n        (const_string \"*\")))\n    (set (attr \"prefix\")\n@@ -2248,13 +2253,26 @@\n \t\t    ]\n \t\t    (const_string \"TI\"))\n \n-\t    (and (eq_attr \"alternative\" \"14,15\")\n+\t    (and (eq_attr \"alternative\" \"14,15,16\")\n \t\t (not (match_test \"TARGET_SSE2\")))\n \t      (const_string \"V2SF\")\n-\t    (eq_attr \"alternative\" \"17\")\n+\t    (eq_attr \"alternative\" \"18\")\n \t      (const_string \"TI\")\n \t   ]\n-\t   (const_string \"DI\")))])\n+\t   (const_string \"DI\")))\n+   (set (attr \"enabled\")\n+     (cond [(eq_attr \"alternative\" \"15\")\n+              (if_then_else\n+\t\t(match_test \"TARGET_STV && TARGET_SSE2\")\n+\t\t(symbol_ref \"false\")\n+\t\t(const_string \"*\"))\n+\t    (eq_attr \"alternative\" \"16\")\n+              (if_then_else\n+\t\t(match_test \"TARGET_STV && TARGET_SSE2\")\n+\t\t(symbol_ref \"true\")\n+\t\t(symbol_ref \"false\"))\n+\t   ]\n+\t   (const_string \"*\")))])\n \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\")\n@@ -3814,6 +3832,26 @@\n   \"movz{bl|x}\\t{%1, %k0|%k0, %1}\"\n   [(set_attr \"type\" \"imovx\")\n    (set_attr \"mode\" \"SI\")])\n+\n+(define_insn_and_split \"*zext<mode>_doubleword\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand:SWI12 1 \"nonimmediate_operand\" \"<r>m\")))]\n+  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\"\n+  \"#\"\n+  \"&& reload_completed && GENERAL_REG_P (operands[0])\"\n+  [(set (match_dup 0) (zero_extend:SI (match_dup 1)))\n+   (set (match_dup 2) (const_int 0))]\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[0], &operands[2]);\")\n+\n+(define_insn_and_split \"*zextsi_doubleword\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2\"\n+  \"#\"\n+  \"&& reload_completed && GENERAL_REG_P (operands[0])\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2) (const_int 0))]\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[0], &operands[2]);\")\n \f\n ;; Sign extension instructions\n \n@@ -7863,9 +7901,9 @@\n ;; it should be done with splitters.\n \n (define_expand \"and<mode>3\"\n-  [(set (match_operand:SWIM 0 \"nonimmediate_operand\")\n-\t(and:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\")\n-\t\t  (match_operand:SWIM 2 \"<general_szext_operand>\")))]\n+  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n+\t(and:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")\n+\t\t      (match_operand:SWIM1248x 2 \"<general_szext_operand>\")))]\n   \"\"\n {\n   machine_mode mode = <MODE>mode;\n@@ -7943,6 +7981,23 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"SI,DI,DI,SI,DI\")])\n \n+(define_insn_and_split \"*anddi3_doubleword\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r\")\n+\t(and:DI\n+\t (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2 && ix86_binary_operator_ok (AND, DImode, operands)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 3)\n+\t\t   (and:SI (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\")\n+\n (define_insn \"*andsi_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r,Ya,!k\")\n \t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,qm,k\")\n@@ -8430,9 +8485,9 @@\n ;; If this is considered useful, it should be done with splitters.\n \n (define_expand \"<code><mode>3\"\n-  [(set (match_operand:SWIM 0 \"nonimmediate_operand\")\n-\t(any_or:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\")\n-\t\t     (match_operand:SWIM 2 \"<general_operand>\")))]\n+  [(set (match_operand:SWIM1248x 0 \"nonimmediate_operand\")\n+\t(any_or:SWIM1248x (match_operand:SWIM1248x 1 \"nonimmediate_operand\")\n+\t\t\t     (match_operand:SWIM1248x 2 \"<general_operand>\")))]\n   \"\"\n   \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n@@ -8450,6 +8505,23 @@\n   [(set_attr \"type\" \"alu,alu,msklog\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn_and_split \"*<code>di3_doubleword\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,rm,r\")\n+\t(any_or:DI\n+\t (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t (match_operand:DI 2 \"x86_64_szext_general_operand\" \"Z,re,rm\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_64BIT && TARGET_STV && TARGET_SSE2 && ix86_binary_operator_ok (<CODE>, DImode, operands)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (any_or:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 3)\n+\t\t   (any_or:SI (match_dup 4) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\")\n+\n (define_insn \"*<code>hi_1\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm,!k\")\n \t(any_or:HI"}, {"sha": "dae5c5d5464af07306d460843056ef579e0658cd", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -567,6 +567,11 @@ Target Report Mask(VZEROUPPER) Save\n Generate vzeroupper instruction before a transfer of control flow out of\n the function.\n \n+mstv\n+Target Report Mask(STV) Save\n+Disable Scalar to Vector optimization pass transforming 64-bit integer\n+computations into a vector ones.\n+\n mdispatch-scheduler\n Target RejectNegative Var(flag_dispatch_scheduler)\n Do dispatch scheduling if processor is bdver1 or bdver2 or bdver3 or bdver4 and Haifa scheduling"}, {"sha": "583b16b0f4fc95f52e1fd3ddcfa32d6e05035779", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -186,6 +186,7 @@ DEBUG_COUNTER (sel_sched_region_cnt)\n DEBUG_COUNTER (sms_sched_loop)\n DEBUG_COUNTER (split_for_sched2)\n DEBUG_COUNTER (store_motion)\n+DEBUG_COUNTER (stv_conversion)\n DEBUG_COUNTER (tail_call)\n DEBUG_COUNTER (treepre_insert)\n DEBUG_COUNTER (tree_sra)"}, {"sha": "26f4911c3654e4e19e5d1e4219def1f898a0fd94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -1,3 +1,12 @@\n+2015-09-29  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\tPR target/65105\n+\t* gcc.target/i386/pr65105-1.c: New.\n+\t* gcc.target/i386/pr65105-2.c: New.\n+\t* gcc.target/i386/pr65105-3.c: New.\n+\t* gcc.target/i386/pr65105-4.C: New.\n+\t* gcc.dg/lower-subreg-1.c: Add -mno-stv options for ia32.\n+\n 2015-09-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* gcc.dg/asm-4.c: Use braced words for the regular expressions."}, {"sha": "47057fe0afa84d5b46987b0dea43c518b0b64071", "filename": "gcc/testsuite/gcc.dg/lower-subreg-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flower-subreg-1.c?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target { ! { mips64 || { aarch64*-*-* arm*-*-* ia64-*-* sparc*-*-* spu-*-* tilegx-*-* } } } } } */\n /* { dg-options \"-O -fdump-rtl-subreg1\" } */\n+/* { dg-additional-options \"-mno-stv\" { target ia32 } } */\n /* { dg-skip-if \"\" { { i?86-*-* x86_64-*-* } && x32 } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target ilp32 } */\n "}, {"sha": "bac6c075ab0acc906775fbb13f3c537886ab8a94", "filename": "gcc/testsuite/gcc.target/i386/pr65105-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-1.c?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -0,0 +1,50 @@\n+/* PR target/pr65105 */\n+/* { dg-do run { target { ia32 } } } */\n+/* { dg-options \"-O2 -march=slm\" } */\n+/* { dg-final { scan-assembler \"por\" } } */\n+/* { dg-final { scan-assembler \"pand\" } } */\n+\n+#include \"stdlib.h\"\n+\n+static int count = 0;\n+\n+void __attribute__((noinline))\n+counter (long long l)\n+{\n+  count++;\n+  if (!l || count > 5)\n+    exit (1);\n+}\n+\n+void __attribute__((noinline))\n+test (long long *arr)\n+{\n+  register unsigned long long tmp;\n+\n+  tmp = arr[0] | arr[1] & arr[2];\n+  while (tmp)\n+    {\n+      counter (tmp);\n+      tmp = *(arr++) & tmp;\n+    }\n+}\n+\n+void  __attribute__((noinline))\n+fill_data (long long *arr)\n+{\n+  arr[0] = 0x00ffffffL;\n+  arr[1] = 0xffffff00L;\n+  arr[2] = 0x00ffffffL;\n+  arr[3] = 0x0000ff00L;\n+  arr[4] = 0x00ff0000L;\n+  arr[5] = 0xff000000L;\n+}\n+\n+int\n+main (int argc, const char **argv)\n+{\n+  long long arr[6];\n+  fill_data (arr);\n+  test (arr);\n+  return count - 5;\n+}"}, {"sha": "92168942d11203f33642cbd5fdeb0ea712e66a48", "filename": "gcc/testsuite/gcc.target/i386/pr65105-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-2.c?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -0,0 +1,12 @@\n+/* PR target/pr65105 */\n+/* { dg-do compile { target { ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"por\" } } */\n+\n+long long i1, i2, res;\n+\n+void\n+test ()\n+{\n+  res = i1 | i2;\n+}"}, {"sha": "b83989fa4d2f106fc321498ebb110d0372ca4349", "filename": "gcc/testsuite/gcc.target/i386/pr65105-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-3.c?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -0,0 +1,16 @@\n+/* PR target/pr65105 */\n+/* { dg-do compile { target { ia32 } } } */\n+/* { dg-options \"-O2 -march=slm -msse4.2\" } */\n+/* { dg-final { scan-assembler \"pand\" } } */\n+/* { dg-final { scan-assembler \"por\" } } */\n+/* { dg-final { scan-assembler \"ptest\" } } */\n+\n+long long i1, i2, i3, res;\n+\n+void\n+test ()\n+{\n+  res = i1 | i2;\n+  if (res)\n+    res &= i3;\n+}"}, {"sha": "9acf368e1fcc127460278935e3f66893e325e0d9", "filename": "gcc/testsuite/gcc.target/i386/pr65105-4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/006ba5047cea15ce6f29b0847009ae901b874d50/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr65105-4.C?ref=006ba5047cea15ce6f29b0847009ae901b874d50", "patch": "@@ -0,0 +1,19 @@\n+/* PR target/pr65105 */\n+/* { dg-do run { target { ia32 } } } */\n+/* { dg-options \"-O2 -march=slm\" } */\n+\n+struct s {\n+  long long l1, l2, l3, l4, l5;\n+} *a;\n+long long b;\n+long long fn1()\n+{\n+  try\n+    {\n+      b = (a->l1 | a->l2 | a->l3 | a->l4 | a->l5);\n+      return a->l1;\n+    }\n+  catch (int)\n+    {\n+    }\n+}"}]}