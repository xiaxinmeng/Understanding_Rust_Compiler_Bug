{"sha": "6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3YjIyM2I3MTIyYThjYTJkYmFlYzc0ZmYwZjc5Yjg2NWU2MGY5MA==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2010-10-29T21:33:32Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2010-10-29T21:33:32Z"}, "message": "tm.texi.in (REGNO_OK_FOR_BASE_P, [...]): Delete non-strict variant.\n\n* doc/tm.texi.in (REGNO_OK_FOR_BASE_P, REGNO_MODE_OK_FOR_BASE_P,\nREGNO_MODE_OK_FOR_REG_BASE, REGNO_MODE_CODE_OK_FOR_BASE_P,\nREGNO_OK_FOR_INDEX_P): Delete non-strict variant.\n(REG_OK_STRICT): Move description.\n\nFrom-SVN: r166077", "tree": {"sha": "2c3991a30d049a4cf3dc7335b4f98f6244a0084b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c3991a30d049a4cf3dc7335b4f98f6244a0084b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/comments", "author": null, "committer": null, "parents": [{"sha": "396acafd0d5d41157fd3bf5052735000f44786f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396acafd0d5d41157fd3bf5052735000f44786f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/396acafd0d5d41157fd3bf5052735000f44786f0"}], "stats": {"total": 63, "additions": 21, "deletions": 42}, "files": [{"sha": "22bc5953a0d7905b9e363f7557baeec5e16391fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "patch": "@@ -1,3 +1,10 @@\n+2010-10-29  Paul Koning  <ni1d@arrl.net>\n+\n+\t* doc/tm.texi.in (REGNO_OK_FOR_BASE_P, REGNO_MODE_OK_FOR_BASE_P,\n+\tREGNO_MODE_OK_FOR_REG_BASE, REGNO_MODE_CODE_OK_FOR_BASE_P,\n+\tREGNO_OK_FOR_INDEX_P): Delete non-strict variant.\n+\t(REG_OK_STRICT): Move description.\n+\n 2010-10-29  Paul Koning  <ni1d@arrl.net>\n \n \t* config/pdp11/pdp11.md (*and<mode>): Rename to *bic<mode>."}, {"sha": "0c2db4739d021fe751f74cebc549e762ee6e3d11", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "patch": "@@ -2486,17 +2486,6 @@ added to another register (as well as added to a displacement).\n @defmac REGNO_OK_FOR_BASE_P (@var{num})\n A C expression which is nonzero if register number @var{num} is\n suitable for use as a base register in operand addresses.\n-Like @code{TARGET_LEGITIMATE_ADDRESS_P}, this macro should also\n-define a strict and a non-strict variant.  Both variants behave\n-the same for hard register; for pseudos, the strict variant will\n-pass only those that have been allocated to a valid hard registers,\n-while the non-strict variant will pass all pseudos.\n-\n-@findex REG_OK_STRICT\n-Compiler source files that want to use the strict variant of this and\n-other macros define the macro @code{REG_OK_STRICT}.  You should use an\n-@code{#ifdef REG_OK_STRICT} conditional to define the strict variant in\n-that case and the non-strict variant otherwise.\n @end defmac\n \n @defmac REGNO_MODE_OK_FOR_BASE_P (@var{num}, @var{mode})\n@@ -2508,8 +2497,6 @@ you define this macro, the compiler will use it instead of\n @code{REGNO_OK_FOR_BASE_P}.  The mode may be @code{VOIDmode} for\n addresses that appear outside a @code{MEM}, i.e., as an\n @code{address_operand}.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @defmac REGNO_MODE_OK_FOR_REG_BASE_P (@var{num}, @var{mode})\n@@ -2522,8 +2509,6 @@ than other base register uses.\n \n Use of this macro is deprecated; please use the more general\n @code{REGNO_MODE_CODE_OK_FOR_BASE_P}.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})\n@@ -2536,8 +2521,6 @@ address, @code{ADDRESS} for something that occurs in an\n corresponding index expression if @var{outer_code} is @code{PLUS};\n @code{SCRATCH} otherwise.  The mode may be @code{VOIDmode} for addresses\n that appear outside a @code{MEM}, i.e., as an @code{address_operand}.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @defmac REGNO_OK_FOR_INDEX_P (@var{num})\n@@ -2554,8 +2537,6 @@ labeling is used must fit the machine's constraints of which registers\n may serve in each capacity.  The compiler will try both labelings,\n looking for one that is valid, and will reload one or both registers\n only if neither labeling works.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @deftypefn {Target Hook} reg_class_t TARGET_PREFERRED_RELOAD_CLASS (rtx @var{x}, reg_class_t @var{rclass})\n@@ -5493,8 +5474,13 @@ has this syntax:\n @noindent\n and should @code{goto @var{label}} if the address @var{x} is a valid\n address on the target machine for a memory operand of mode @var{mode}.\n-Whether the strict or non-strict variants are desired is defined by\n-the @code{REG_OK_STRICT} macro introduced earlier in this section.\n+\n+@findex REG_OK_STRICT\n+Compiler source files that want to use the strict variant of this\n+macro define the macro @code{REG_OK_STRICT}.  You should use an\n+@code{#ifdef REG_OK_STRICT} conditional to define the strict variant in\n+that case and the non-strict variant otherwise.\n+\n Using the hook is usually simpler because it limits the number of\n files that are recompiled when changes are made.\n @end deftypefn"}, {"sha": "c4d5e8ab150a923c1244bcf75ad1bd28d33e4d1a", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7b223b7122a8ca2dbaec74ff0f79b865e60f90/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=6f7b223b7122a8ca2dbaec74ff0f79b865e60f90", "patch": "@@ -2480,17 +2480,6 @@ added to another register (as well as added to a displacement).\n @defmac REGNO_OK_FOR_BASE_P (@var{num})\n A C expression which is nonzero if register number @var{num} is\n suitable for use as a base register in operand addresses.\n-Like @code{TARGET_LEGITIMATE_ADDRESS_P}, this macro should also\n-define a strict and a non-strict variant.  Both variants behave\n-the same for hard register; for pseudos, the strict variant will\n-pass only those that have been allocated to a valid hard registers,\n-while the non-strict variant will pass all pseudos.\n-\n-@findex REG_OK_STRICT\n-Compiler source files that want to use the strict variant of this and\n-other macros define the macro @code{REG_OK_STRICT}.  You should use an\n-@code{#ifdef REG_OK_STRICT} conditional to define the strict variant in\n-that case and the non-strict variant otherwise.\n @end defmac\n \n @defmac REGNO_MODE_OK_FOR_BASE_P (@var{num}, @var{mode})\n@@ -2502,8 +2491,6 @@ you define this macro, the compiler will use it instead of\n @code{REGNO_OK_FOR_BASE_P}.  The mode may be @code{VOIDmode} for\n addresses that appear outside a @code{MEM}, i.e., as an\n @code{address_operand}.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @defmac REGNO_MODE_OK_FOR_REG_BASE_P (@var{num}, @var{mode})\n@@ -2516,8 +2503,6 @@ than other base register uses.\n \n Use of this macro is deprecated; please use the more general\n @code{REGNO_MODE_CODE_OK_FOR_BASE_P}.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})\n@@ -2530,8 +2515,6 @@ address, @code{ADDRESS} for something that occurs in an\n corresponding index expression if @var{outer_code} is @code{PLUS};\n @code{SCRATCH} otherwise.  The mode may be @code{VOIDmode} for addresses\n that appear outside a @code{MEM}, i.e., as an @code{address_operand}.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @defmac REGNO_OK_FOR_INDEX_P (@var{num})\n@@ -2548,8 +2531,6 @@ labeling is used must fit the machine's constraints of which registers\n may serve in each capacity.  The compiler will try both labelings,\n looking for one that is valid, and will reload one or both registers\n only if neither labeling works.\n-\n-This macro also has strict and non-strict variants.\n @end defmac\n \n @hook TARGET_PREFERRED_RELOAD_CLASS\n@@ -5481,8 +5462,13 @@ has this syntax:\n @noindent\n and should @code{goto @var{label}} if the address @var{x} is a valid\n address on the target machine for a memory operand of mode @var{mode}.\n-Whether the strict or non-strict variants are desired is defined by\n-the @code{REG_OK_STRICT} macro introduced earlier in this section.\n+\n+@findex REG_OK_STRICT\n+Compiler source files that want to use the strict variant of this\n+macro define the macro @code{REG_OK_STRICT}.  You should use an\n+@code{#ifdef REG_OK_STRICT} conditional to define the strict variant in\n+that case and the non-strict variant otherwise.\n+\n Using the hook is usually simpler because it limits the number of\n files that are recompiled when changes are made.\n @end deftypefn"}]}