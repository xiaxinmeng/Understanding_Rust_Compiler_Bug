{"sha": "050809ed8af639d385251b95bf0d8d11fd7d3863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwODA5ZWQ4YWY2MzlkMzg1MjUxYjk1YmYwZDhkMTFmZDdkMzg2Mw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-06-16T21:03:08Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-06-16T21:03:08Z"}, "message": "[arm] Split CPU, architecture and tuning data tables.\n\n\nThe driver really needs to handle some canonicalization of the new\n-mcpu and -march options in order to make multilib selection\ntractable.  This will require moving much of the logic to parse the\nnew options into the common code file.  However, the tuning data\ndefinitely does not want to be there as it is very specific to the\ncompiler passes.  To facilitate this we need to split up the generated\nconfiguration data into architectural and tuning related tables.\n\nThis patch starts that process, but does not yet move any code out of\nthe compiler backend.  Since I'm reworking all that code I took the\nopportunity to also separate out the CPU data tables from the\narchitecture data tables.  Although they are related, there is a lot\nof redundancy in the CPU options that is best handled by simply\nindirecting to the architecture entry.\n\n\t* config/arm/arm-protos.h (arm_build_target): Remove arch_core.\n\t(cpu_arch_extension): New structure.\n\t(cpu_arch_option, arch_option, cpu_option): New structures.\n\t* config/arm/parsecpu.awk (gen_headers): Build an enumeration of\n\tarchitecture types.\n\t(gen_data): Generate new format data tables.\n\t* config/arm/arm.c (cpu_tune): New structure.\n\t(cpu_option, processors): Delete.\n\t(arm_print_hint_for_core_or_arch): Delete.  Replace with ...\n\t(arm_print_hint_for_cpu_option): ... this and ...\n\t(arm_print_hint_for_arch_option): ... this.\n\t(arm_parse_arch_cpu_name): Delete.  Replace with ...\n\t(arm_parse_cpu_option_name): ... this and ...\n\t(arm_parse_arch_option_name): ... this.\n\t(arm_unrecognized_feature): Change type of target parameter to\n\tcpu_arch_option.\n\t(arm_parse_arch_cpu_features): Delete.  Replace with ...\n\t(arm_parse_option_features): ... this.\n\t(arm_configure_build_target): Rework to use new configuration data\n\ttables.\n\t(arm_print_tune_info): Rework for new configuration data tables.\n\t* config/arm/arm-cpu-data.h: Regenerated.\n\t* config/arm/arm-cpu.h: Regenerated.\n\nFrom-SVN: r249286", "tree": {"sha": "6a805c5c54c62144e8594b42f0ebb08a4601c037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a805c5c54c62144e8594b42f0ebb08a4601c037"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/050809ed8af639d385251b95bf0d8d11fd7d3863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050809ed8af639d385251b95bf0d8d11fd7d3863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050809ed8af639d385251b95bf0d8d11fd7d3863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050809ed8af639d385251b95bf0d8d11fd7d3863/comments", "author": null, "committer": null, "parents": [{"sha": "9ef88abef4a75cea3c48bd32f65b0c0fd18d4f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef88abef4a75cea3c48bd32f65b0c0fd18d4f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef88abef4a75cea3c48bd32f65b0c0fd18d4f6b"}], "stats": {"total": 3153, "additions": 1866, "deletions": 1287}, "files": [{"sha": "59eafb9e86e3685d65b2a9b77c2c80aadce742f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=050809ed8af639d385251b95bf0d8d11fd7d3863", "patch": "@@ -1,3 +1,29 @@\n+2017-06-16  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm-protos.h (arm_build_target): Remove arch_core.\n+\t(cpu_arch_extension): New structure.\n+\t(cpu_arch_option, arch_option, cpu_option): New structures.\n+\t* config/arm/parsecpu.awk (gen_headers): Build an enumeration of\n+\tarchitecture types.\n+\t(gen_data): Generate new format data tables.\n+\t* config/arm/arm.c (cpu_tune): New structure.\n+\t(cpu_option, processors): Delete.\n+\t(arm_print_hint_for_core_or_arch): Delete.  Replace with ...\n+\t(arm_print_hint_for_cpu_option): ... this and ...\n+\t(arm_print_hint_for_arch_option): ... this.\n+\t(arm_parse_arch_cpu_name): Delete.  Replace with ...\n+\t(arm_parse_cpu_option_name): ... this and ...\n+\t(arm_parse_arch_option_name): ... this.\n+\t(arm_unrecognized_feature): Change type of target parameter to\n+\tcpu_arch_option.\n+\t(arm_parse_arch_cpu_features): Delete.\tReplace with ...\n+\t(arm_parse_option_features): ... this.\n+\t(arm_configure_build_target): Rework to use new configuration data\n+\ttables.\n+\t(arm_print_tune_info): Rework for new configuration data tables.\n+\t* config/arm/arm-cpu-data.h: Regenerated.\n+\t* config/arm/arm-cpu.h: Regenerated.\n+\n 2017-06-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* Makefile.in (OBJS): Move sbitmap.o from here ..."}, {"sha": "646f8e11cd7f4e8df200be1deeb99f5f6e8aa054", "filename": "gcc/config/arm/arm-cpu-data.h", "status": "modified", "additions": 1552, "deletions": 1149, "changes": 2701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm-cpu-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm-cpu-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cpu-data.h?ref=050809ed8af639d385251b95bf0d8d11fd7d3863"}, {"sha": "e27634c6dd9666d0a0726e5963c083a55e6ba08f", "filename": "gcc/config/arm/arm-cpu.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm-cpu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm-cpu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cpu.h?ref=050809ed8af639d385251b95bf0d8d11fd7d3863", "patch": "@@ -133,6 +133,44 @@ enum processor_type\n   TARGET_CPU_arm_none\n };\n \n+enum arch_type\n+{\n+  TARGET_ARCH_armv2,\n+  TARGET_ARCH_armv2a,\n+  TARGET_ARCH_armv3,\n+  TARGET_ARCH_armv3m,\n+  TARGET_ARCH_armv4,\n+  TARGET_ARCH_armv4t,\n+  TARGET_ARCH_armv5,\n+  TARGET_ARCH_armv5t,\n+  TARGET_ARCH_armv5e,\n+  TARGET_ARCH_armv5te,\n+  TARGET_ARCH_armv5tej,\n+  TARGET_ARCH_armv6,\n+  TARGET_ARCH_armv6j,\n+  TARGET_ARCH_armv6k,\n+  TARGET_ARCH_armv6z,\n+  TARGET_ARCH_armv6kz,\n+  TARGET_ARCH_armv6zk,\n+  TARGET_ARCH_armv6t2,\n+  TARGET_ARCH_armv6_m,\n+  TARGET_ARCH_armv6s_m,\n+  TARGET_ARCH_armv7,\n+  TARGET_ARCH_armv7_a,\n+  TARGET_ARCH_armv7ve,\n+  TARGET_ARCH_armv7_r,\n+  TARGET_ARCH_armv7_m,\n+  TARGET_ARCH_armv7e_m,\n+  TARGET_ARCH_armv8_a,\n+  TARGET_ARCH_armv8_1_a,\n+  TARGET_ARCH_armv8_2_a,\n+  TARGET_ARCH_armv8_m_base,\n+  TARGET_ARCH_armv8_m_main,\n+  TARGET_ARCH_iwmmxt,\n+  TARGET_ARCH_iwmmxt2,\n+  TARGET_ARCH_arm_none\n+};\n+\n enum fpu_type\n {\n   TARGET_FPU_vfp,"}, {"sha": "ada2503f378dc78a2c591d2578fd4ad82d28f667", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=050809ed8af639d385251b95bf0d8d11fd7d3863", "patch": "@@ -462,8 +462,6 @@ struct arm_build_target\n   const char *arch_name;\n   /* Preprocessor substring (never NULL).  */\n   const char *arch_pp_name;\n-  /* CPU identifier for the core we're compiling for (architecturally).  */\n-  enum processor_type arch_core;\n   /* The base architecture value.  */\n   enum base_architecture base_arch;\n   /* Bitmap encapsulating the isa_bits for the target environment.  */\n@@ -478,5 +476,41 @@ struct arm_build_target\n \n extern struct arm_build_target arm_active_target;\n \n+struct cpu_arch_extension\n+{\n+  const char *const name;\n+  bool remove;\n+  const enum isa_feature isa_bits[isa_num_bits];\n+};\n+\n+struct cpu_arch_option\n+{\n+  /* Name for this option.  */\n+  const char *name;\n+  /* List of feature extensions permitted.  */\n+  const struct cpu_arch_extension *extensions;\n+  /* Standard feature bits.  */\n+  enum isa_feature isa_bits[isa_num_bits];\n+};\n+\n+struct arch_option\n+{\n+  /* Common option fields.  */\n+  cpu_arch_option common;\n+  /* Short string for this architecture.  */\n+  const char *arch;\n+  /* Base architecture, from which this specific architecture is derived.  */\n+  enum base_architecture base_arch;\n+  /* Default tune target (in the absence of any more specific data).  */\n+  enum processor_type tune_id;\n+};\n+\n+struct cpu_option\n+{\n+  /* Common option fields.  */\n+  cpu_arch_option common;\n+  /* Architecture upon which this CPU is based.  */\n+  enum arch_type arch;\n+};\n \n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "dbba1d310d1a6e330c09d571e5089748320f7d5b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 140, "deletions": 91, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=050809ed8af639d385251b95bf0d8d11fd7d3863", "patch": "@@ -975,26 +975,13 @@ int arm_regs_in_sequence[] =\n \f\n /* Initialization code.  */\n \n-struct cpu_option\n+struct cpu_tune\n {\n-  const char *const name;\n-  bool remove;\n-  const enum isa_feature isa_bits[isa_num_bits];\n-};\n-\n-struct processors\n-{\n-  const char *const name;\n-  enum processor_type core;\n+  enum processor_type scheduler;\n   unsigned int tune_flags;\n-  const char *arch;\n-  enum base_architecture base_arch;\n-  const enum isa_feature isa_bits[isa_num_bits];\n-  const struct cpu_option* const opttab;\n-  const struct tune_params *const tune;\n+  const struct tune_params *tune;\n };\n \n-\n #define ARM_PREFETCH_NOT_BENEFICIAL { 0, -1, -1 }\n #define ARM_PREFETCH_BENEFICIAL(num_slots,l1_size,l1_line_size) \\\n   {\t\t\t\t\t\t\t\t\\\n@@ -3047,15 +3034,59 @@ arm_initialize_isa (sbitmap isa, const enum isa_feature *isa_bits)\n     bitmap_set_bit (isa, *(isa_bits++));\n }\n \n-/* List the permitted CPU or architecture names.  If TARGET is a near\n+/* List the permitted CPU option names.  If TARGET is a near miss for an\n+   entry, print out the suggested alternative.  */\n+static void\n+arm_print_hint_for_cpu_option (const char *target,\n+\t\t\t       const cpu_option *list)\n+{\n+  auto_vec<const char*> candidates;\n+  for (; list->common.name != NULL; list++)\n+    candidates.safe_push (list->common.name);\n+  char *s;\n+  const char *hint = candidates_list_and_hint (target, s, candidates);\n+  if (hint)\n+    inform (input_location, \"valid arguments are: %s; did you mean %qs?\",\n+\t    s, hint);\n+  else\n+    inform (input_location, \"valid arguments are: %s\", s);\n+\n+  XDELETEVEC (s);\n+}\n+\n+/* Parse the base component of a CPU selection in LIST.  Return a\n+   pointer to the entry in the architecture table.  OPTNAME is the\n+   name of the option we are parsing and can be used if a diagnostic\n+   is needed.  */\n+static const cpu_option *\n+arm_parse_cpu_option_name (const cpu_option *list, const char *optname,\n+\t\t       const char *target)\n+{\n+  const cpu_option *entry;\n+  const char *end  = strchr (target, '+');\n+  size_t len = end ? end - target : strlen (target);\n+\n+  for (entry = list; entry->common.name != NULL; entry++)\n+    {\n+      if (strncmp (entry->common.name, target, len) == 0\n+\t  && entry->common.name[len] == '\\0')\n+\treturn entry;\n+    }\n+\n+  error_at (input_location, \"unrecognized %s target: %s\", optname, target);\n+  arm_print_hint_for_cpu_option (target, list);\n+  return NULL;\n+}\n+\n+/* List the permitted architecture option names.  If TARGET is a near\n    miss for an entry, print out the suggested alternative.  */\n static void\n-arm_print_hint_for_core_or_arch (const char *target,\n-\t\t\t\t const struct processors *list)\n+arm_print_hint_for_arch_option (const char *target,\n+\t\t\t       const arch_option *list)\n {\n   auto_vec<const char*> candidates;\n-  for (; list->name != NULL; list++)\n-    candidates.safe_push (list->name);\n+  for (; list->common.name != NULL; list++)\n+    candidates.safe_push (list->common.name);\n   char *s;\n   const char *hint = candidates_list_and_hint (target, s, candidates);\n   if (hint)\n@@ -3071,23 +3102,23 @@ arm_print_hint_for_core_or_arch (const char *target,\n    LIST.  Return a pointer to the entry in the architecture table.\n    OPTNAME is the name of the option we are parsing and can be used if\n    a diagnostic is needed.  */\n-static const struct processors *\n-arm_parse_arch_cpu_name (const struct processors *list, const char *optname,\n-\t\t\t const char *target)\n+static const arch_option *\n+arm_parse_arch_option_name (const arch_option *list, const char *optname,\n+\t\t\t    const char *target)\n {\n-  const struct processors *entry;\n+  const arch_option *entry;\n   const char *end  = strchr (target, '+');\n   size_t len = end ? end - target : strlen (target);\n \n-  for (entry = list; entry->name != NULL; entry++)\n+  for (entry = list; entry->common.name != NULL; entry++)\n     {\n-      if (strncmp (entry->name, target, len) == 0\n-\t  && entry->name[len] == '\\0')\n+      if (strncmp (entry->common.name, target, len) == 0\n+\t  && entry->common.name[len] == '\\0')\n \treturn entry;\n     }\n \n   error_at (input_location, \"unrecognized %s target: %s\", optname, target);\n-  arm_print_hint_for_core_or_arch (target, list);\n+  arm_print_hint_for_arch_option (target, list);\n   return NULL;\n }\n \n@@ -3096,7 +3127,7 @@ arm_parse_arch_cpu_name (const struct processors *list, const char *optname,\n    values.  */\n static void\n arm_unrecognized_feature (const char *opt, size_t len,\n-\t\t\t  const struct processors *target)\n+\t\t\t  const cpu_arch_option *target)\n {\n   char *this_opt = XALLOCAVEC (char, len+1);\n   auto_vec<const char*> candidates;\n@@ -3106,7 +3137,9 @@ arm_unrecognized_feature (const char *opt, size_t len,\n \n   error_at (input_location, \"%qs does not support feature %qs\", target->name,\n \t    this_opt);\n-  for (const cpu_option *list = target->opttab; list->name != NULL; list++)\n+  for (const cpu_arch_extension *list = target->extensions;\n+       list->name != NULL;\n+       list++)\n     candidates.safe_push (list->name);\n \n   char *s;\n@@ -3124,15 +3157,15 @@ arm_unrecognized_feature (const char *opt, size_t len,\n /* Parse any feature extensions to add to (or remove from) the\n    permitted ISA selection.  */\n static void\n-arm_parse_arch_cpu_features (sbitmap isa, const struct processors *target,\n-\t\t\t     const char *opts_in)\n+arm_parse_option_features (sbitmap isa, const cpu_arch_option *target,\n+\t\t\t   const char *opts_in)\n {\n   const char *opts = opts_in;\n \n   if (!opts)\n     return;\n \n-  if (!target->opttab)\n+  if (!target->extensions)\n     {\n       error_at (input_location, \"%s does not take any feature options\",\n \t\ttarget->name);\n@@ -3142,12 +3175,14 @@ arm_parse_arch_cpu_features (sbitmap isa, const struct processors *target,\n   while (opts)\n     {\n       gcc_assert (*opts == '+');\n-      const struct cpu_option *entry;\n+      const struct cpu_arch_extension *entry;\n       const char *end = strchr (++opts, '+');\n       size_t len = end ? end - opts : strlen (opts);\n       bool matched = false;\n \n-      for (entry = target->opttab; !matched && entry->name != NULL; entry++)\n+      for (entry = target->extensions;\n+\t   !matched && entry->name != NULL;\n+\t   entry++)\n \t{\n \t  if (strncmp (entry->name, opts, len) == 0\n \t      && entry->name[len] == '\\0')\n@@ -3189,10 +3224,10 @@ arm_configure_build_target (struct arm_build_target *target,\n \t\t\t    struct gcc_options *opts_set,\n \t\t\t    bool warn_compatible)\n {\n-  const struct processors *arm_selected_tune = NULL;\n-  const struct processors *arm_selected_arch = NULL;\n-  const struct processors *arm_selected_cpu = NULL;\n-  const struct arm_fpu_desc *arm_selected_fpu = NULL;\n+  const cpu_option *arm_selected_tune = NULL;\n+  const arch_option *arm_selected_arch = NULL;\n+  const cpu_option *arm_selected_cpu = NULL;\n+  const arm_fpu_desc *arm_selected_fpu = NULL;\n   const char *tune_opts = NULL;\n   const char *arch_opts = NULL;\n   const char *cpu_opts = NULL;\n@@ -3203,16 +3238,16 @@ arm_configure_build_target (struct arm_build_target *target,\n \n   if (opts_set->x_arm_arch_string)\n     {\n-      arm_selected_arch = arm_parse_arch_cpu_name (all_architectures,\n-\t\t\t\t\t\t   \"-march\",\n-\t\t\t\t\t\t   opts->x_arm_arch_string);\n+      arm_selected_arch = arm_parse_arch_option_name (all_architectures,\n+\t\t\t\t\t\t      \"-march\",\n+\t\t\t\t\t\t      opts->x_arm_arch_string);\n       arch_opts = strchr (opts->x_arm_arch_string, '+');\n     }\n \n   if (opts_set->x_arm_cpu_string)\n     {\n-      arm_selected_cpu = arm_parse_arch_cpu_name (all_cores, \"-mcpu\",\n-\t\t\t\t\t\t  opts->x_arm_cpu_string);\n+      arm_selected_cpu = arm_parse_cpu_option_name (all_cores, \"-mcpu\",\n+\t\t\t\t\t\t    opts->x_arm_cpu_string);\n       cpu_opts = strchr (opts->x_arm_cpu_string, '+');\n       arm_selected_tune = arm_selected_cpu;\n       /* If taking the tuning from -mcpu, we don't need to rescan the\n@@ -3221,73 +3256,83 @@ arm_configure_build_target (struct arm_build_target *target,\n \n   if (opts_set->x_arm_tune_string)\n     {\n-      arm_selected_tune = arm_parse_arch_cpu_name (all_cores, \"-mtune\",\n-\t\t\t\t\t\t   opts->x_arm_tune_string);\n+      arm_selected_tune = arm_parse_cpu_option_name (all_cores, \"-mtune\",\n+\t\t\t\t\t\t     opts->x_arm_tune_string);\n       tune_opts = strchr (opts->x_arm_tune_string, '+');\n     }\n \n   if (arm_selected_arch)\n     {\n-      arm_initialize_isa (target->isa, arm_selected_arch->isa_bits);\n-      arm_parse_arch_cpu_features (target->isa, arm_selected_arch, arch_opts);\n+      arm_initialize_isa (target->isa, arm_selected_arch->common.isa_bits);\n+      arm_parse_option_features (target->isa, &arm_selected_arch->common,\n+\t\t\t\t arch_opts);\n \n       if (arm_selected_cpu)\n \t{\n \t  auto_sbitmap cpu_isa (isa_num_bits);\n+\t  auto_sbitmap isa_delta (isa_num_bits);\n \n-\t  arm_initialize_isa (cpu_isa, arm_selected_cpu->isa_bits);\n-\t  arm_parse_arch_cpu_features (cpu_isa, arm_selected_cpu, cpu_opts);\n-\t  bitmap_xor (cpu_isa, cpu_isa, target->isa);\n+\t  arm_initialize_isa (cpu_isa, arm_selected_cpu->common.isa_bits);\n+\t  arm_parse_option_features (cpu_isa, &arm_selected_cpu->common,\n+\t\t\t\t     cpu_opts);\n+\t  bitmap_xor (isa_delta, cpu_isa, target->isa);\n \t  /* Ignore any bits that are quirk bits.  */\n-\t  bitmap_and_compl (cpu_isa, cpu_isa, isa_quirkbits);\n+\t  bitmap_and_compl (isa_delta, isa_delta, isa_quirkbits);\n \t  /* Ignore (for now) any bits that might be set by -mfpu.  */\n-\t  bitmap_and_compl (cpu_isa, cpu_isa, isa_all_fpubits);\n+\t  bitmap_and_compl (isa_delta, isa_delta, isa_all_fpubits);\n \n-\t  if (!bitmap_empty_p (cpu_isa))\n+\t  if (!bitmap_empty_p (isa_delta))\n \t    {\n \t      if (warn_compatible)\n \t\twarning (0, \"switch -mcpu=%s conflicts with -march=%s switch\",\n-\t\t\t arm_selected_cpu->name, arm_selected_arch->name);\n+\t\t\t arm_selected_cpu->common.name,\n+\t\t\t arm_selected_arch->common.name);\n \t      /* -march wins for code generation.\n \t\t -mcpu wins for default tuning.  */\n \t      if (!arm_selected_tune)\n \t\tarm_selected_tune = arm_selected_cpu;\n \n-\t      arm_selected_cpu = arm_selected_arch;\n-\t      target->arch_name = arm_selected_arch->name;\n+\t      arm_selected_cpu = all_cores + arm_selected_arch->tune_id;\n+\t      target->arch_name = arm_selected_arch->common.name;\n \t    }\n \t  else\n \t    {\n \t      /* Architecture and CPU are essentially the same.\n \t\t Prefer the CPU setting.  */\n-\t      arm_selected_arch = NULL;\n-\t      target->core_name = arm_selected_cpu->name;\n+\t      arm_selected_arch = all_architectures + arm_selected_cpu->arch;\n+\t      target->core_name = arm_selected_cpu->common.name;\n+\t      /* Copy the CPU's capabilities, so that we inherit the\n+\t\t appropriate extensions and quirks.  */\n+\t      bitmap_copy (target->isa, cpu_isa);\n \t    }\n \t}\n       else\n \t{\n \t  /* Pick a CPU based on the architecture.  */\n-\t  arm_selected_cpu = arm_selected_arch;\n-\t  target->arch_name = arm_selected_arch->name;\n+\t  arm_selected_cpu = all_cores + arm_selected_arch->tune_id;\n+\t  target->arch_name = arm_selected_arch->common.name;\n \t  /* Note: target->core_name is left unset in this path.  */\n \t}\n     }\n   else if (arm_selected_cpu)\n     {\n-      target->core_name = arm_selected_cpu->name;\n-      arm_initialize_isa (target->isa, arm_selected_cpu->isa_bits);\n-      arm_parse_arch_cpu_features (target->isa, arm_selected_cpu, cpu_opts);\n+      target->core_name = arm_selected_cpu->common.name;\n+      arm_initialize_isa (target->isa, arm_selected_cpu->common.isa_bits);\n+      arm_parse_option_features (target->isa, &arm_selected_cpu->common,\n+\t\t\t\t cpu_opts);\n+      arm_selected_arch = all_architectures + arm_selected_cpu->arch;\n     }\n-  /* If the user did not specify a processor, choose one for them.  */\n+  /* If the user did not specify a processor or architecture, choose\n+     one for them.  */\n   else\n     {\n-      const struct processors * sel;\n+      const cpu_option *sel;\n       auto_sbitmap sought_isa (isa_num_bits);\n       bitmap_clear (sought_isa);\n       auto_sbitmap default_isa (isa_num_bits);\n \n       arm_selected_cpu = &all_cores[TARGET_CPU_DEFAULT];\n-      gcc_assert (arm_selected_cpu->name);\n+      gcc_assert (arm_selected_cpu->common.name);\n \n       /* RWE: All of the selection logic below (to the end of this\n \t 'if' clause) looks somewhat suspect.  It appears to be mostly\n@@ -3296,7 +3341,7 @@ arm_configure_build_target (struct arm_build_target *target,\n \t user might be expecting).  I think it should be removed once\n \t support for the pre-thumb era cores is removed.  */\n       sel = arm_selected_cpu;\n-      arm_initialize_isa (default_isa, sel->isa_bits);\n+      arm_initialize_isa (default_isa, sel->common.isa_bits);\n \n       /* Now check to see if the user has specified any command line\n \t switches that require certain abilities from the cpu.  */\n@@ -3329,18 +3374,18 @@ arm_configure_build_target (struct arm_build_target *target,\n \t  /* Try to locate a CPU type that supports all of the abilities\n \t     of the default CPU, plus the extra abilities requested by\n \t     the user.  */\n-\t  for (sel = all_cores; sel->name != NULL; sel++)\n+\t  for (sel = all_cores; sel->common.name != NULL; sel++)\n \t    {\n-\t      arm_initialize_isa (candidate_isa, sel->isa_bits);\n+\t      arm_initialize_isa (candidate_isa, sel->common.isa_bits);\n \t      /* An exact match?  */\n \t      if (bitmap_equal_p (default_isa, candidate_isa))\n \t\tbreak;\n \t    }\n \n-\t  if (sel->name == NULL)\n+\t  if (sel->common.name == NULL)\n \t    {\n \t      unsigned current_bit_count = isa_num_bits;\n-\t      const struct processors * best_fit = NULL;\n+\t      const cpu_option *best_fit = NULL;\n \n \t      /* Ideally we would like to issue an error message here\n \t\t saying that it was not possible to find a CPU compatible\n@@ -3354,9 +3399,9 @@ arm_configure_build_target (struct arm_build_target *target,\n \t\t command line options we scan the array again looking\n \t\t for a best match.  The best match must have at least\n \t\t the capabilities of the perfect match.  */\n-\t      for (sel = all_cores; sel->name != NULL; sel++)\n+\t      for (sel = all_cores; sel->common.name != NULL; sel++)\n \t\t{\n-\t\t  arm_initialize_isa (candidate_isa, sel->isa_bits);\n+\t\t  arm_initialize_isa (candidate_isa, sel->common.isa_bits);\n \n \t\t  if (bitmap_subset_p (default_isa, candidate_isa))\n \t\t    {\n@@ -3382,11 +3427,13 @@ arm_configure_build_target (struct arm_build_target *target,\n \n       /* Now we know the CPU, we can finally initialize the target\n \t structure.  */\n-      target->core_name = arm_selected_cpu->name;\n-      arm_initialize_isa (target->isa, arm_selected_cpu->isa_bits);\n+      target->core_name = arm_selected_cpu->common.name;\n+      arm_initialize_isa (target->isa, arm_selected_cpu->common.isa_bits);\n+      arm_selected_arch = all_architectures + arm_selected_cpu->arch;\n     }\n \n   gcc_assert (arm_selected_cpu);\n+  gcc_assert (arm_selected_arch);\n \n   if (opts->x_arm_fpu_index != TARGET_FPU_auto)\n     {\n@@ -3398,20 +3445,20 @@ arm_configure_build_target (struct arm_build_target *target,\n       bitmap_ior (target->isa, target->isa, fpu_bits);\n     }\n \n-  /* The selected cpu may be an architecture, so lookup tuning by core ID.  */\n   if (!arm_selected_tune)\n-    arm_selected_tune = &all_cores[arm_selected_cpu->core];\n+    arm_selected_tune = arm_selected_cpu;\n   else /* Validate the features passed to -mtune.  */\n-    arm_parse_arch_cpu_features (NULL, arm_selected_tune, tune_opts);\n+    arm_parse_option_features (NULL, &arm_selected_tune->common, tune_opts);\n+\n+  const cpu_tune *tune_data = &all_tunes[arm_selected_tune - all_cores];\n \n   /* Finish initializing the target structure.  */\n-  target->arch_pp_name = arm_selected_cpu->arch;\n-  target->base_arch = arm_selected_cpu->base_arch;\n-  target->arch_core = arm_selected_cpu->core;\n+  target->arch_pp_name = arm_selected_arch->arch;\n+  target->base_arch = arm_selected_arch->base_arch;\n \n-  target->tune_flags = arm_selected_tune->tune_flags;\n-  target->tune = arm_selected_tune->tune;\n-  target->tune_core = arm_selected_tune->core;\n+  target->tune_flags = tune_data->tune_flags;\n+  target->tune = tune_data->tune;\n+  target->tune_core = tune_data->scheduler;\n }\n \n /* Fix up any incompatible options that the user has specified.  */\n@@ -26283,18 +26330,20 @@ arm_print_tune_info (void)\n static void\n arm_print_asm_arch_directives ()\n {\n-  const struct processors *arch\n-    = arm_parse_arch_cpu_name (all_architectures, \"-march\",\n-\t\t\t       arm_active_target.arch_name);\n+  const arch_option *arch\n+    = arm_parse_arch_option_name (all_architectures, \"-march\",\n+\t\t\t\t  arm_active_target.arch_name);\n   auto_sbitmap opt_bits (isa_num_bits);\n \n   gcc_assert (arch);\n \n   asm_fprintf (asm_out_file, \"\\t.arch %s\\n\", arm_active_target.arch_name);\n-  if (!arch->opttab)\n+  if (!arch->common.extensions)\n     return;\n \n-  for (const struct cpu_option *opt = arch->opttab; opt->name != NULL; opt++)\n+  for (const struct cpu_arch_extension *opt = arch->common.extensions;\n+       opt->name != NULL;\n+       opt++)\n     {\n       if (!opt->remove)\n \t{"}, {"sha": "57565bdcef61103e9bf222297aff7c921fde28a1", "filename": "gcc/config/arm/parsecpu.awk", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Fparsecpu.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050809ed8af639d385251b95bf0d8d11fd7d3863/gcc%2Fconfig%2Farm%2Fparsecpu.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fparsecpu.awk?ref=050809ed8af639d385251b95bf0d8d11fd7d3863", "patch": "@@ -102,6 +102,17 @@ function gen_headers () {\n     print \"  TARGET_CPU_arm_none\"\n     print \"};\\n\"\n \n+    print \"enum arch_type\"\n+    print \"{\"\n+\n+    narchs = split (arch_list, archs)\n+\n+    for (n = 1; n <= narchs; n++) {\n+\tprint \"  TARGET_ARCH_\"arch_cnames[archs[n]]\",\"\n+    }\n+    print \"  TARGET_ARCH_arm_none\"\n+    print \"};\\n\"\n+\n     print \"enum fpu_type\"\n     print \"{\"\n \n@@ -121,7 +132,7 @@ function gen_data () {\n \n     for (n = 1; n <= ncpus; n++) {\n \tif (cpus[n] in cpu_opts) {\n-\t    print \"static const struct cpu_option cpu_opttab_\" \\\n+\t    print \"static const cpu_arch_extension cpu_opttab_\" \\\n \t\tcpu_cnames[cpus[n]] \"[] = {\"\n \t    nopts = split (cpu_opts[cpus[n]], opts)\n \t    for (opt = 1; opt <= nopts; opt++) {\n@@ -136,61 +147,78 @@ function gen_data () {\n \t}\n     }\n \n-    print \"static const struct processors all_cores[] =\"\n+    print \"static const cpu_option all_cores[] =\"\n     print \"{\"\n \n     for (n = 1; n <= ncpus; n++) {\n \tprint \"  {\"\n-\tprint \"    \\\"\" cpus[n] \"\\\",\"\n-\tif (cpus[n] in cpu_tune_for) {\n-\t    if (! (cpu_tune_for[cpus[n]] in cpu_cnames)) {\n-\t\tfatal(\"unknown \\\"tune for\\\" target \" cpu_tune_for[cpus[n]] \\\n-\t\t      \" for CPU \" cpus[n])\n-\t    }\n-\t    print \"    TARGET_CPU_\" cpu_cnames[cpu_tune_for[cpus[n]]] \",\"\n-\t} else {\n-\t    print \"    TARGET_CPU_\" cpu_cnames[cpus[n]] \",\"\n-\t}\n-\tif (cpus[n] in cpu_tune_flags) {\n-\t    print \"    (\" cpu_tune_flags[cpus[n]] \"),\"\n-\t} else print \"    0,\"\n+\tprint \"    {\"\n+\t# common.name\n+\tprint \"      \\\"\" cpus[n] \"\\\",\"\n+\t# common.extensions\n+\tif (cpus[n] in cpu_opts) {\n+\t    print \"      cpu_opttab_\" cpu_cnames[cpus[n]] \",\"\n+\t} else print \"      NULL,\"\n+\t# common.isa_bits\n \tnfeats = split (cpu_arch[cpus[n]], feats, \"+\")\n \tif (! (feats[1] in arch_isa)) {\n \t    fatal(\"unknown arch \" feats[1] \" for cpu \" cpus[n])\n \t}\n-\tprint \"    \\\"\" arch_base[feats[1]] \"\\\", BASE_ARCH_\" \\\n-\t    arch_base[feats[1]] \",\"\n-\tprint \"    {\"\n-\tprint \"      \" arch_isa[feats[1]] \",\"\n+\tprint \"      {\"\n+\tprint \"        \" arch_isa[feats[1]] \",\"\n \tfor (m = 2; m <= nfeats; m++) {\n \t    if (! ((feats[1], feats[m]) in arch_opt_isa)) {\n \t\tfatal(\"unknown feature \" feats[m] \" for architecture \" feats[1])\n \t    }\n \t    if (arch_opt_remove[feats[1],feats[m]] == \"true\") {\n \t\tfatal(\"cannot remove features from architecture specs\")\n \t    }\n-\t    print \"      \" arch_opt_isa[feats[1],feats[m]] \",\"\n+\t    print \"        \" arch_opt_isa[feats[1],feats[m]] \",\"\n \t}\n-\tif (cpus[n] in cpu_fpu) print \"      \" fpu_isa[cpu_fpu[cpus[n]]] \",\"\n-\tif (cpus[n] in cpu_isa) print \"      \" cpu_isa[cpus[n]] \",\"\n-\tprint \"      isa_nobit\"\n+\tif (cpus[n] in cpu_fpu) print \"        \" fpu_isa[cpu_fpu[cpus[n]]] \",\"\n+\tif (cpus[n] in cpu_isa) print \"        \" cpu_isa[cpus[n]] \",\"\n+\tprint \"        isa_nobit\"\n+\tprint \"      }\"\n \tprint \"    },\"\n-\tif (cpus[n] in cpu_opts) {\n-\t    print \"    cpu_opttab_\" cpu_cnames[cpus[n]] \",\"\n-\t} else print \"    NULL,\"\n-\tprint \"    &arm_\" cpu_cost[cpus[n]] \"_tune\"\n+\t# arch\n+\tprint \"    TARGET_ARCH_\" arch_cnames[feats[1]]\n \tprint \"  },\"\n     }\n \n-    print \"  {NULL, TARGET_CPU_arm_none, 0, NULL, BASE_ARCH_0,\" \\\n-\t\" {isa_nobit}, NULL, NULL}\"\n-    print \"};\\n\"\n+    print \"  {{NULL, NULL, {isa_nobit}}, TARGET_ARCH_arm_none}\"\n+    print \"};\"\n \n+    print \"static const cpu_tune all_tunes[] =\"\n+    print \"{\"\n+\n+    for (n = 1; n <= ncpus; n++) {\n+\tprint \"  { /* \" cpus[n] \".  */\"\n+\t# scheduler\n+\tif (cpus[n] in cpu_tune_for) {\n+\t    if (! (cpu_tune_for[cpus[n]] in cpu_cnames)) {\n+\t\tfatal(\"unknown \\\"tune for\\\" target \" cpu_tune_for[cpus[n]] \\\n+\t\t      \" for CPU \" cpus[n])\n+\t    }\n+\t    print \"    TARGET_CPU_\" cpu_cnames[cpu_tune_for[cpus[n]]] \",\"\n+\t} else {\n+\t    print \"    TARGET_CPU_\" cpu_cnames[cpus[n]] \",\"\n+\t}\n+\t# tune_flags\n+\tif (cpus[n] in cpu_tune_flags) {\n+\t    print \"    (\" cpu_tune_flags[cpus[n]] \"),\"\n+\t} else print \"    0,\"\n+\t# tune\n+\tprint \"    &arm_\" cpu_cost[cpus[n]] \"_tune\"\n+\tprint \"  },\"\n+    }\n+    print \"  {TARGET_CPU_arm_none, 0, NULL}\"\n+    print \"};\"\n+    \n     narchs = split (arch_list, archs)\n \n     for (n = 1; n <= narchs; n++) {\n \tif (archs[n] in arch_opts) {\n-\t    print \"static const struct cpu_option arch_opttab_\" \\\n+\t    print \"static const struct cpu_arch_extension arch_opttab_\" \\\n \t\tarch_cnames[archs[n]] \"[] = {\"\n \t    nopts = split (arch_opts[archs[n]], opts)\n \t    for (opt = 1; opt <= nopts; opt++) {\n@@ -205,7 +233,7 @@ function gen_data () {\n \t}\n     }\n \n-    print \"static const struct processors all_architectures[] =\"\n+    print \"static const struct arch_option all_architectures[] =\"\n     print \"{\"\n \n     for (n = 1; n <= narchs; n++) {\n@@ -214,26 +242,27 @@ function gen_data () {\n \t    fatal(\"unknown \\\"tune for\\\" target \" arch_tune_for[archs[n]] \\\n \t\t  \" for architecture \" archs[n])\n \t}\n-\tprint \"    \\\"\" archs[n] \\\n-\t    \"\\\", TARGET_CPU_\" cpu_cnames[arch_tune_for[archs[n]]] \",\"\n-\tif (archs[n] in arch_tune_flags) {\n-\t    print \"    (\" arch_tune_flags[archs[n]] \"),\"\n-\t} else print \"    0,\"\n-\tprint \"    \\\"\" arch_base[archs[n]] \"\\\", BASE_ARCH_\" \\\n-\t    arch_base[archs[n]] \",\"\n+\t# common.name\n+\tprint \"    \\\"\" archs[n] \"\\\",\"\n+\t# common.extensions\n+\tif (archs[n] in arch_opts) {\n+\t    print \"    arch_opttab_\" arch_cnames[archs[n]] \",\"\n+\t} else print \"    NULL,\"\n+\t# common.isa_bits\n \tprint \"    {\"\n \tprint \"      \" arch_isa[archs[n]] \",\"\n \tprint \"      isa_nobit\"\n \tprint \"    },\"\n-\tif (archs[n] in arch_opts) {\n-\t    print \"    arch_opttab_\" arch_cnames[archs[n]] \",\"\n-\t} else print \"    NULL,\"\n-\tprint \"    NULL\"\n+\t# arch, base_arch\n+\tprint \"    \\\"\" arch_base[archs[n]] \"\\\", BASE_ARCH_\" \\\n+\t    arch_base[archs[n]] \",\"\n+\t# tune_id\n+\tprint \"    TARGET_CPU_\" cpu_cnames[arch_tune_for[archs[n]]] \",\"\n \tprint \"  },\"\n     }\n \n-    print \"  {NULL, TARGET_CPU_arm_none, 0, NULL, BASE_ARCH_0,\" \\\n-\t\" {isa_nobit}, NULL, NULL}\"\n+    print \"  {{NULL, NULL, {isa_nobit}},\"\n+    print \"   NULL, BASE_ARCH_0, TARGET_CPU_arm_none}\"\n     print \"};\\n\"\n \n     print \"const struct arm_fpu_desc all_fpus[] =\""}]}