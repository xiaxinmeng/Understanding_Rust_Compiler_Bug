{"sha": "a04c0734e366a167a55f635b7d09de09b5013051", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA0YzA3MzRlMzY2YTE2N2E1NWY2MzViN2QwOWRlMDliNTAxMzA1MQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-06-19T19:08:24Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-06-19T19:08:24Z"}, "message": "PR translation/90156 - add linter check suggesting to replace %<%s%> with %qs\n\ngcc/c-family/ChangeLog:\n\n\tPR translation/90156\n\t* c-format.c (function_format_info::format_type): Adjust type.\n\t(function_format_info::is_raw): New member.\n\t(decode_format_type): Adjust signature.  Handle \"raw\" diag attributes.\n\t(decode_format_attr): Adjust call to decode_format_type.\n\tAvoid a redundant call to convert_format_name_to_system_name.\n\tAvoid abbreviating the word \"arguments\" in a diagnostic.\n\t(format_warning_substr): New function.\n\t(avoid_dollar_number): Quote dollar sign in a diagnostic.\n\t(finish_dollar_format_checking): Same.\n\t(check_format_info): Same.\n\t(struct baltoks_t): New.\n\t(c_opers, c_keywords, cxx_keywords, badwords, contrs): New arrays.\n\t(maybe_diag_unbalanced_tokens, check_tokens, check_plain): New\n\tfunctions.\n\t(check_format_info_main): Call check_plain.  Use baltoks_t.  Call\n\tmaybe_diag_unbalanced_tokens.\n\t(handle_format_attribute): Spell out the word \"arguments\" in\n\ta diagnostic.\n\ngcc/testsuite/ChangeLog:\n\n\tPR translation/90156\n\t* gcc.dg/format/gcc_diag-11.c: Enable.\n\nFrom-SVN: r272483", "tree": {"sha": "b96003c3241a11305bffd62138ebc12d78091107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b96003c3241a11305bffd62138ebc12d78091107"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a04c0734e366a167a55f635b7d09de09b5013051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a04c0734e366a167a55f635b7d09de09b5013051", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a04c0734e366a167a55f635b7d09de09b5013051", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a04c0734e366a167a55f635b7d09de09b5013051/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef3e6aa32043fd8a285342aa6c668b636f5f0d41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3e6aa32043fd8a285342aa6c668b636f5f0d41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3e6aa32043fd8a285342aa6c668b636f5f0d41"}], "stats": {"total": 1081, "additions": 1044, "deletions": 37}, "files": [{"sha": "f64b749e86beb1d3da2c38f7e32bb29e30d47969", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a04c0734e366a167a55f635b7d09de09b5013051", "patch": "@@ -1,3 +1,25 @@\n+2019-06-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR translation/90156\n+\t* c-format.c (function_format_info::format_type): Adjust type.\n+\t(function_format_info::is_raw): New member.\n+\t(decode_format_type): Adjust signature.  Handle \"raw\" diag attributes.\n+\t(decode_format_attr): Adjust call to decode_format_type.\n+\tAvoid a redundant call to convert_format_name_to_system_name.\n+\tAvoid abbreviating the word \"arguments\" in a diagnostic.\n+\t(format_warning_substr): New function.\n+\t(avoid_dollar_number): Quote dollar sign in a diagnostic.\n+\t(finish_dollar_format_checking): Same.\n+\t(check_format_info): Same.\n+\t(struct baltoks_t): New.\n+\t(c_opers, c_keywords, cxx_keywords, badwords, contrs): New arrays.\n+\t(maybe_diag_unbalanced_tokens, check_tokens, check_plain): New\n+\tfunctions.\n+\t(check_format_info_main): Call check_plain.  Use baltoks_t.  Call\n+\tmaybe_diag_unbalanced_tokens.\n+\t(handle_format_attribute): Spell out the word \"arguments\" in\n+\ta diagnostic.\n+\n 2019-06-11  Matthew Beliveau  <mbelivea@redhat.com>\n \n \tPR c++/90449 - add -Winaccessible-base option."}, {"sha": "a790f3c0394bab3cfcee68dc068e0c3f4594463b", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 1016, "deletions": 35, "changes": 1051, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=a04c0734e366a167a55f635b7d09de09b5013051", "patch": "@@ -52,7 +52,13 @@ enum format_type { printf_format_type, asm_fprintf_format_type,\n \n struct function_format_info\n {\n-  int format_type;\t\t\t/* type of format (printf, scanf, etc.) */\n+  enum format_type format_type;\t\t/* type of format (printf, scanf, etc.) */\n+  /* IS_RAW is relevant only for GCC diagnostic format functions.\n+     It is set for \"raw\" formatting functions like pp_printf that\n+     are not intended to produce complete diagnostics according to\n+     GCC guidelines, and clear for others like error and warning\n+     whose format string is checked for proper quoting and spelling.  */\n+  bool is_raw;\n   unsigned HOST_WIDE_INT format_num;\t/* number of format argument */\n   unsigned HOST_WIDE_INT first_arg_num;\t/* number of first arg (zero for varargs) */\n };\n@@ -65,7 +71,7 @@ static GTY(()) tree locus;\n \n static bool decode_format_attr (const_tree, tree, tree, function_format_info *,\n \t\t\t\tbool);\n-static int decode_format_type (const char *);\n+static format_type decode_format_type (const char *, bool * = NULL);\n \n static bool check_format_string (const_tree argument,\n \t\t\t\t unsigned HOST_WIDE_INT format_num,\n@@ -111,6 +117,32 @@ format_warning_at_char (location_t fmt_string_loc, tree format_string_cst,\n   return warned;\n }\n \n+\n+/* Emit a warning as per format_warning_va, but construct the substring_loc\n+   for the substring at offset (POS1, POS2 - 1) within a string constant\n+   FORMAT_STRING_CST at FMT_STRING_LOC.  */\n+\n+ATTRIBUTE_GCC_DIAG (6,7)\n+static bool\n+format_warning_substr (location_t fmt_string_loc, tree format_string_cst,\n+\t\t       int pos1, int pos2, int opt, const char *gmsgid, ...)\n+{\n+  va_list ap;\n+  va_start (ap, gmsgid);\n+  tree string_type = TREE_TYPE (format_string_cst);\n+\n+  pos2 -= 1;\n+\n+  substring_loc fmt_loc (fmt_string_loc, string_type, pos1, pos1, pos2);\n+  format_string_diagnostic_t diag (fmt_loc, NULL, UNKNOWN_LOCATION, NULL,\n+\t\t\t\t   NULL);\n+  bool warned = diag.emit_warning_va (opt, gmsgid, &ap);\n+  va_end (ap);\n+\n+  return warned;\n+}\n+\n+\n /* Check that we have a pointer to a string suitable for use as a format.\n    The default is to check for a char type.\n    For objective-c dialects, this is extended to include references to string\n@@ -320,10 +352,8 @@ decode_format_attr (const_tree fntype, tree atname, tree args,\n     {\n       const char *p = IDENTIFIER_POINTER (format_type_id);\n \n-      p = convert_format_name_to_system_name (p);\n+      info->format_type = decode_format_type (p, &info->is_raw);\n \n-      info->format_type = decode_format_type (p);\n-      \n       if (!c_dialect_objc ()\n \t   && info->format_type == gcc_objc_string_format_type)\n \t{\n@@ -359,7 +389,7 @@ decode_format_attr (const_tree fntype, tree atname, tree args,\n   if (info->first_arg_num != 0 && info->first_arg_num <= info->format_num)\n     {\n       gcc_assert (!validated_p);\n-      error (\"format string argument follows the args to be formatted\");\n+      error (\"format string argument follows the arguments to be formatted\");\n       return false;\n     }\n \n@@ -1067,27 +1097,55 @@ static void format_type_warning (const substring_loc &fmt_loc,\n \t\t\t\t char conversion_char);\n \n /* Decode a format type from a string, returning the type, or\n-   format_type_error if not valid, in which case the caller should print an\n-   error message.  */\n-static int\n-decode_format_type (const char *s)\n+   format_type_error if not valid, in which case the caller should\n+   print an error message.  On success, when IS_RAW is non-null, set\n+   *IS_RAW when the format type corresponds to a GCC \"raw\" diagnostic\n+   formatting function and clear it otherwise.  */\n+static format_type\n+decode_format_type (const char *s, bool *is_raw /* = NULL */)\n {\n-  int i;\n-  int slen;\n+  bool is_raw_buf;\n+\n+  if (!is_raw)\n+    is_raw = &is_raw_buf;\n+\n+  *is_raw = false;\n \n   s = convert_format_name_to_system_name (s);\n-  slen = strlen (s);\n-  for (i = 0; i < n_format_types; i++)\n+\n+  size_t slen = strlen (s);\n+  for (int i = 0; i < n_format_types; i++)\n     {\n-      int alen;\n+      /* Check for a match with no underscores.  */\n       if (!strcmp (s, format_types[i].name))\n-\treturn i;\n-      alen = strlen (format_types[i].name);\n+\treturn static_cast<format_type> (i);\n+\n+      /* Check for leading and trailing underscores.  */\n+      size_t alen = strlen (format_types[i].name);\n       if (slen == alen + 4 && s[0] == '_' && s[1] == '_'\n \t  && s[slen - 1] == '_' && s[slen - 2] == '_'\n \t  && !strncmp (s + 2, format_types[i].name, alen))\n-\treturn i;\n+\treturn static_cast<format_type>(i);\n+\n+      /* Check for the \"_raw\" suffix and no leading underscores.  */\n+      if (slen == alen + 4\n+\t  && !strncmp (s, format_types[i].name, alen)\n+\t  && !strcmp (s + alen, \"_raw\"))\n+\t{\n+\t  *is_raw = true;\n+\t  return static_cast<format_type>(i);\n+\t}\n+\n+      /* Check for the \"_raw__\" suffix and leading underscores.  */\n+      if (slen == alen + 8 && s[0] == '_' && s[1] == '_'\n+\t  && !strncmp (s + 2, format_types[i].name, alen)\n+\t  && !strcmp (s + 2 + alen, \"_raw__\"))\n+\t{\n+\t  *is_raw = true;\n+\t  return static_cast<format_type>(i);\n+\t}\n     }\n+\n   return format_type_error;\n }\n \n@@ -1350,7 +1408,8 @@ avoid_dollar_number (const char *format)\n     format++;\n   if (*format == '$')\n     {\n-      warning (OPT_Wformat_, \"$ operand number used after format without operand number\");\n+      warning (OPT_Wformat_,\n+\t       \"%<$%>operand number used after format without operand number\");\n       return true;\n     }\n   return false;\n@@ -1381,7 +1440,8 @@ finish_dollar_format_checking (format_check_results *res, int pointer_gap_ok)\n \t    found_pointer_gap = true;\n \t  else\n \t    warning_at (res->format_string_loc, OPT_Wformat_,\n-\t\t\t\"format argument %d unused before used argument %d in $-style format\",\n+\t\t\t\"format argument %d unused before used argument %d \"\n+\t\t\t\"in %<$%>-style format\",\n \t\t\ti + 1, dollar_max_arg_used);\n \t}\n     }\n@@ -1525,7 +1585,8 @@ check_format_info (function_format_info *info, tree params,\n     }\n   if (res.number_dollar_extra_args > 0 && res.number_non_literal == 0\n       && res.number_other == 0)\n-    warning_at (loc, OPT_Wformat_extra_args, \"unused arguments in $-style format\");\n+    warning_at (loc, OPT_Wformat_extra_args,\n+\t\t\"unused arguments in %<$%>-style format\");\n   if (res.number_empty > 0 && res.number_non_literal == 0\n       && res.number_other == 0)\n     warning_at (loc, OPT_Wformat_zero_length, \"zero-length %s format string\",\n@@ -2789,6 +2850,907 @@ check_argument_type (const format_char_info *fci,\n   return true;\n }\n \n+/* Describes \"paired tokens\" within the format string that are\n+   expected to be balanced.  */\n+\n+struct baltoks_t\n+{\n+  baltoks_t (): singlequote (), doublequote () { }\n+\n+  typedef auto_vec<const char *> balanced_tokens_t;\n+  /* Vectors of pointers to opening brackets ('['), curly brackets ('{'),\n+     quoting directives (like GCC \"%<\"), parentheses, and angle brackets\n+     ('<').  Used to detect unbalanced tokens.  */\n+  balanced_tokens_t brackets;\n+  balanced_tokens_t curly;\n+  balanced_tokens_t quotdirs;\n+  balanced_tokens_t parens;\n+  balanced_tokens_t pointy;\n+  /* Pointer to the last opening quote.  */\n+  const char *singlequote;\n+  const char *doublequote;\n+};\n+\n+/* Describes a keyword, operator, or other name.  */\n+\n+struct token_t\n+{\n+  const char *name;   /* Keyword/operator name.  */\n+  unsigned char len;  /* Its length.  */\n+  const char *alt;    /* Alternate spelling.  */\n+};\n+\n+/* Helper for initializing global token_t arrays below.  */\n+#define NAME(name) { name, sizeof name - 1, NULL }\n+\n+/* C/C++ operators that are expected to be quoted within the format\n+   string.  */\n+\n+static const token_t c_opers[] =\n+  {\n+   NAME (\"!=\"), NAME (\"%=\"),  NAME (\"&&\"),  NAME (\"&=\"), NAME (\"*=\"),\n+   NAME (\"++\"), NAME (\"+=\"),  NAME (\"--\"),  NAME (\"-=\"), NAME (\"->\"),\n+   NAME (\"/=\"), NAME (\"<<\"),  NAME (\"<<=\"), NAME (\"<=\"), NAME (\"==\"),\n+   NAME (\">=\"), NAME (\">>=\"), NAME (\">>\"),  NAME (\"?:\"),  NAME (\"^=\"),\n+   NAME (\"|=\"), NAME (\"||\")\n+  };\n+\n+static const token_t cxx_opers[] =\n+  {\n+   NAME (\"->*\"), NAME (\".*\"),  NAME (\"::\"),  NAME (\"<=>\")\n+  };\n+\n+/* Common C/C++ keywords that are expected to be quoted within the format\n+   string.  Keywords like auto, inline, or volatile are exccluded because\n+   they are sometimes used in common terms like /auto variables/, /inline\n+   function/, or /volatile access/ where they should not be quoted.  */\n+\n+static const token_t c_keywords[] =\n+  {\n+#undef NAME\n+#define NAME(name, alt)  { name, sizeof name - 1, alt }\n+\n+   NAME (\"alignas\", NULL),\n+   NAME (\"alignof\", NULL),\n+   NAME (\"asm\", NULL),\n+   NAME (\"bool\", NULL),\n+   NAME (\"char\", NULL),\n+   NAME (\"const %\", NULL),\n+   NAME (\"const-qualified\", \"%<const%>-qualified\"),\n+   NAME (\"float\", NULL),\n+   NAME (\"ifunc\", NULL),\n+   NAME (\"int\", NULL),\n+   NAME (\"long double\", NULL),\n+   NAME (\"long int\", NULL),\n+   NAME (\"long long\", NULL),\n+   NAME (\"malloc\", NULL),\n+   NAME (\"noclone\", NULL),\n+   NAME (\"noinline\", NULL),\n+   NAME (\"nonnull\", NULL),\n+   NAME (\"noreturn\", NULL),\n+   NAME (\"nothrow\", NULL),\n+   NAME (\"offsetof\", NULL),\n+   NAME (\"readonly\", \"read-only\"),\n+   NAME (\"readwrite\", \"read-write\"),\n+   NAME (\"restrict %\", NULL),\n+   NAME (\"restrict-qualified\", \"%<restrict%>-qualified\"),\n+   NAME (\"short int\", NULL),\n+   NAME (\"signed char\", NULL),\n+   NAME (\"signed int\", NULL),\n+   NAME (\"signed long\", NULL),\n+   NAME (\"signed short\", NULL),\n+   NAME (\"sizeof\", NULL),\n+   NAME (\"typeof\", NULL),\n+   NAME (\"unsigned char\", NULL),\n+   NAME (\"unsigned int\", NULL),\n+   NAME (\"unsigned long\", NULL),\n+   NAME (\"unsigned short\", NULL),\n+   NAME (\"volatile %\", NULL),\n+   NAME (\"volatile-qualified\", \"%<volatile%>-qualified\"),\n+   NAME (\"weakref\", NULL),\n+  };\n+\n+static const token_t cxx_keywords[] =\n+  {\n+   /* C++ only keywords and operators.  */\n+   NAME (\"catch\", NULL),\n+   NAME (\"constexpr if\", NULL),\n+   NAME (\"constexpr\", NULL),\n+   NAME (\"consteval\", NULL),\n+   NAME (\"decltype\", NULL),\n+   NAME (\"nullptr\", NULL),\n+   NAME (\"operator delete\", NULL),\n+   NAME (\"operator new\", NULL),\n+   NAME (\"typeid\", NULL),\n+   NAME (\"typeinfo\", NULL)\n+  };\n+\n+/* Blacklisted words such as misspellings that should be avoided in favor\n+   of the specified alternatives.  */\n+static const struct\n+{\n+  const char *name;   /* Bad word.  */\n+  unsigned char len;  /* Its length.  */\n+  const char *alt;    /* Preferred alternative.  */\n+} badwords[] =\n+  {\n+   NAME (\"arg\", \"argument\"),\n+   NAME (\"bitfield\", \"bit-field\"),\n+   NAME (\"builtin function\", \"built-in function\"),\n+   NAME (\"can not\", \"cannot\"),\n+   NAME (\"commandline option\", \"command-line option\"),\n+   NAME (\"commandline\", \"command line\"),\n+   NAME (\"command line option\", \"command-line option\"),\n+   NAME (\"decl\", \"declaration\"),\n+   NAME (\"enumeral\", \"enumerated\"),\n+   NAME (\"floating point\", \"floating-point\"),\n+   NAME (\"non-zero\", \"nonzero\"),\n+   NAME (\"reg\", \"register\"),\n+   NAME (\"stmt\", \"statement\"),\n+  };\n+\n+/* Common contractions that should be avoided in favor of the specified\n+   alternatives.  */\n+\n+static const struct\n+{\n+  const char *name;   /* Contraction.  */\n+  unsigned char len;  /* Its length.  */\n+  const char *alt;    /* Preferred alternative.  */\n+} contrs[] =\n+  {\n+   NAME (\"can't\", \"cannot\"),\n+   NAME (\"didn't\", \"did not\"),\n+   /* These are commonly abused.  Avoid diagnosing them for now.\n+      NAME (\"isn't\", \"is not\"),\n+      NAME (\"don't\", \"is not\"),\n+   */\n+   NAME (\"mustn't\", \"must not\"),\n+   NAME (\"needn't\", \"need not\"),\n+   NAME (\"should't\", \"should not\"),\n+   NAME (\"that's\", \"that is\"),\n+   NAME (\"there's\", \"there is\"),\n+   NAME (\"they're\", \"they are\"),\n+   NAME (\"what's\", \"what is\"),\n+   NAME (\"won't\", \"will not\")\n+  };\n+\n+/* Check for unquoted TOKENS.  FORMAT_STRING_LOC is the location of\n+   the format string, FORMAT_STRING_CST the format string itself (as\n+   a tree), ORIG_FORMAT_CHARS and FORMAT_CHARS are pointers to\n+   the beginning of the format string and the character currently\n+   being processed, and BALTOKS describes paired \"tokens\" within\n+   the format string that are expected to be balanced.\n+   Returns a pointer to the last processed character or null when\n+   nothing was done.  */\n+\n+static const char*\n+check_tokens (const token_t *tokens, unsigned ntoks,\n+\t      location_t format_string_loc, tree format_string_cst,\n+\t      const char *orig_format_chars, const char *format_chars,\n+\t      baltoks_t &baltoks)\n+{\n+  /* For brevity.  */\n+  const int opt = OPT_Wformat_diag;\n+  /* Zero-based starting position of a problem sequence.  */\n+  int fmtchrpos = format_chars - orig_format_chars;\n+\n+  /* For identifier-like \"words,\" set to the word length.  */\n+  unsigned wlen = 0;\n+  /* Set for an operator, clear for an identifier/word.  */\n+  bool is_oper = false;\n+  bool underscore = false;\n+\n+  if (format_chars[0] == '_' || ISALPHA (format_chars[0]))\n+    {\n+      while (format_chars[wlen] == '_' || ISALNUM (format_chars[wlen]))\n+\t{\n+\t  underscore |= format_chars[wlen] == '_';\n+\t  ++wlen;\n+\t}\n+    }\n+  else\n+    is_oper = true;\n+\n+  for (unsigned i = 0; i != ntoks; ++i)\n+    {\n+      unsigned toklen = tokens[i].len;\n+\n+      if (toklen < wlen\n+\t  || strncmp (format_chars, tokens[i].name, toklen))\n+\tcontinue;\n+\n+      if (toklen == 2\n+\t  && format_chars - orig_format_chars > 0\n+\t  && (TOUPPER (format_chars[-1]) == 'C'\n+\t      || TOUPPER (format_chars[-1]) == 'G'))\n+\treturn format_chars + toklen - 1;   /* Reference to C++ or G++.  */\n+\n+      if (ISPUNCT (format_chars[toklen - 1]))\n+\t{\n+\t  if (format_chars[toklen - 1] == format_chars[toklen])\n+\t    return NULL;   /* Operator followed by another punctuator.  */\n+\t}\n+      else if (ISALNUM (format_chars[toklen]))\n+\treturn NULL;   /* Keyword prefix for a longer word.  */\n+\n+      if (toklen == 2\n+\t  && format_chars[0] == '-'\n+\t  && format_chars[1] == '-'\n+\t  && ISALNUM (format_chars[2]))\n+\treturn NULL;   /* Probably option like --help.  */\n+\n+      /* Allow this ugly warning for the time being.  */\n+      if (toklen == 2\n+\t  && format_chars - orig_format_chars > 6\n+\t  && !strncmp (format_chars - 7, \" count >= width of \", 19))\n+\treturn format_chars + 10;\n+\n+      /* The token is a type if it ends in an alphabetic character.  */\n+      bool is_type = (ISALPHA (tokens[i].name[toklen - 1])\n+\t\t      && strchr (tokens[i].name, ' '));\n+\n+      /* Backtrack to the last alphabetic character (for tokens whose\n+\t names end in '%').  */\n+      if (!is_oper)\n+\twhile (!ISALPHA (tokens[i].name[toklen - 1]))\n+\t  --toklen;\n+\n+      if (format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t fmtchrpos, fmtchrpos + toklen, opt,\n+\t\t\t\t (is_type\n+\t\t\t\t  ? G_(\"unquoted type name %<%.*s%> in format\")\n+\t\t\t\t  : (is_oper\n+\t\t\t\t     ? G_(\"unquoted operator %<%.*s%> in format\")\n+\t\t\t\t     : G_(\"unquoted keyword %<%.*s%> in format\"))),\n+\t\t\t\t toklen, format_chars)\n+\t  && tokens[i].alt)\n+\tinform (format_string_loc, \"use %qs instead\", tokens[i].alt);\n+\n+      return format_chars + toklen - 1;\n+    }\n+\n+  /* Diagnose unquoted __attribute__.  Consider any parenthesized\n+     argument to the attribute to avoid redundant warnings for\n+     the double parentheses that might follow.  */\n+  if (!strncmp (format_chars, \"__attribute\", sizeof \"__attribute\" - 1))\n+    {\n+      unsigned nchars = sizeof \"__attribute\" - 1;\n+      while ('_' == format_chars[nchars])\n+\t++nchars;\n+\n+      for (int i = nchars; format_chars[i]; ++i)\n+\tif (' ' != format_chars[i])\n+\t  {\n+\t    nchars = i;\n+\t    break;\n+\t  }\n+\n+      if (format_chars[nchars] == '(')\n+\t{\n+\t  baltoks.parens.safe_push (format_chars + nchars);\n+\n+\t  ++nchars;\n+\t  bool close = false;\n+\t  if (format_chars[nchars] == '(')\n+\t    {\n+\t      baltoks.parens.safe_push (format_chars + nchars);\n+\t      close = true;\n+\t      ++nchars;\n+\t    }\n+\t  for (int i = nchars; format_chars[i]; ++i)\n+\t    if (')' == format_chars[i])\n+\t      {\n+\t\tif (baltoks.parens.length () > 0)\n+\t\t  baltoks.parens.pop ();\n+\t\tnchars = i + 1;\n+\t\tbreak;\n+\t      }\n+\n+\t  if (close && format_chars[nchars] == ')')\n+\t    {\n+\t      if (baltoks.parens.length () > 0)\n+\t\tbaltoks.parens.pop ();\n+\t      ++nchars;\n+\t    }\n+\t}\n+\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t      \"unquoted attribute in format\");\n+      return format_chars + nchars - 1;\n+    }\n+\n+  /* Diagnose unquoted built-ins.  */\n+  if (format_chars[0] == '_'\n+      && format_chars[1] == '_'\n+      && (!strncmp (format_chars + 2, \"atomic\", sizeof \"atomic\" - 1)\n+\t  || !strncmp (format_chars + 2, \"builtin\", sizeof \"builtin\" - 1)\n+\t  || !strncmp (format_chars + 2, \"sync\", sizeof \"sync\" - 1)))\n+    {\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + wlen, opt,\n+\t\t\t     \"unquoted name of built-in function %<%.*s%> \"\n+\t\t\t     \"in format\",\n+\t\t\t     wlen, format_chars);\n+      return format_chars + wlen - 1;\n+    }\n+\n+  /* Diagnose unquoted substrings of alphanumeric characters containing\n+     underscores.  They most likely refer to identifiers and should be\n+     quoted.  */\n+  if (underscore)\n+    format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t   format_chars - orig_format_chars,\n+\t\t\t   format_chars + wlen - orig_format_chars,\n+\t\t\t   opt,\n+\t\t\t   \"unquoted identifier or keyword %<%.*s%> in format\",\n+\t\t\t   wlen, format_chars);\n+  else\n+    {\n+      /* Diagnose some common missspellings.  */\n+      for (unsigned i = 0; i != sizeof badwords / sizeof *badwords; ++i)\n+\t{\n+\t  unsigned badwlen = strspn (badwords[i].name, \" -\");\n+\t  if (wlen >= badwlen\n+\t      && (wlen <= badwords[i].len\n+\t\t  || (wlen == badwords[i].len + 1U\n+\t\t      && TOUPPER (format_chars[wlen - 1]) == 'S'))\n+\t      && !strncasecmp (format_chars, badwords[i].name, badwords[i].len))\n+\t    {\n+\t      /* Handle singular as well as plural forms of all bad words\n+\t\t even though the latter don't necessarily make sense for\n+\t\t all of the former (like \"can nots\").  */\n+\t      badwlen = badwords[i].len;\n+\t      const char *plural = \"\";\n+\t      if (TOUPPER (format_chars[badwlen]) == 'S')\n+\t\t{\n+\t\t  ++badwlen;\n+\t\t  plural = \"s\";\n+\t\t}\n+\n+\t      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t     fmtchrpos, fmtchrpos + badwords[i].len,\n+\t\t\t\t     opt,\n+\t\t\t\t     \"misspelled term %<%.*s%> in format; \"\n+\t\t\t\t     \"use %<%s%s%> instead\",\n+\t\t\t\t     badwlen, format_chars,\n+\t\t\t\t     badwords[i].alt, plural);\n+\n+\t      return format_chars + badwords[i].len - 1;\n+\t    }\n+\t}\n+\n+      /* Skip C++/G++.  */\n+      if (!strncasecmp (format_chars, \"c++\", 3)\n+\t  || !strncasecmp (format_chars, \"g++\", 3))\n+\treturn format_chars + 2;\n+    }\n+\n+  return wlen ? format_chars + wlen - 1 : NULL;\n+}\n+\n+/* Check plain text in a format string of a GCC diagnostic function\n+   for common quoting, punctuation, and spelling mistakes, and issue\n+   -Wformat-diag warnings if they are found.   FORMAT_STRING_LOC is\n+   the location of the format string, FORMAT_STRING_CST the format\n+   string itself (as a tree), ORIG_FORMAT_CHARS and FORMAT_CHARS are\n+   pointers to the beginning of the format string and the character\n+   currently being processed, and BALTOKS describes paired \"tokens\"\n+   within the format string that are expected to be balanced.\n+   Returns a pointer to the last processed character.  */\n+\n+static const char*\n+check_plain (location_t format_string_loc, tree format_string_cst,\n+\t     const char *orig_format_chars, const char *format_chars,\n+\t     baltoks_t &baltoks)\n+{\n+  /* For brevity.  */\n+  const int opt = OPT_Wformat_diag;\n+  /* Zero-based starting position of a problem sequence.  */\n+  int fmtchrpos = format_chars - orig_format_chars;\n+\n+  if (*format_chars == '%')\n+    {\n+      /* Diagnose %<%s%> and suggest using %qs instead.  */\n+      if (!strncmp (format_chars, \"%<%s%>\", 6))\n+\tformat_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t       fmtchrpos, fmtchrpos + 6, opt,\n+\t\t\t       \"quoted %qs directive in format; \"\n+\t\t\t       \"use %qs instead\", \"%s\", \"%qs\");\n+      else if (format_chars - orig_format_chars > 2\n+\t       && !strncasecmp (format_chars - 3, \"can%'t\", 5)\n+\t       && !ISALPHA (format_chars[1]))\n+\tformat_warning_substr (format_string_loc,\n+\t\t\t       format_string_cst,\n+\t\t\t       fmtchrpos - 3, fmtchrpos + 3, opt,\n+\t\t\t       \"contraction %<%.*s%> in format; \"\n+\t\t\t       \"use %qs instead\",\n+\t\t\t       6, format_chars - 3, \"cannot\");\n+\n+      return format_chars;\n+    }\n+\n+  if (baltoks.quotdirs.length ())\n+    {\n+      /* Skip over all plain text within a quoting directive until\n+\t the next directive.  */\n+      while (*format_chars && '%' != *format_chars)\n+\t++format_chars;\n+\n+      return format_chars;\n+    }\n+\n+  /* The length of the problem sequence.  */\n+  int nchars = 0;\n+\n+  /* Diagnose any whitespace characters other than <space> but only\n+     leading, trailing, and two or more consecutive <space>s.  Do\n+     this before diagnosing control characters because whitespace\n+     is a subset of controls.  */\n+  const char *other_than_space = NULL;\n+  while (ISSPACE (format_chars[nchars]))\n+    {\n+      if (format_chars[nchars] != ' ' && !other_than_space)\n+\tother_than_space = format_chars + nchars;\n+      ++nchars;\n+    }\n+\n+  if (nchars)\n+    {\n+      /* This is the most common problem: go the extra mile to describe\n+\t the problem in as much helpful detail as possible.  */\n+      if (other_than_space)\n+\t{\n+\t  format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t \"unquoted whitespace character %qc in format\",\n+\t\t\t\t *other_than_space);\n+\t  return format_chars + nchars - 1;\n+\t}\n+\n+      if (fmtchrpos == 0)\n+\t/* Accept strings of leading spaces with no warning.  */\n+\treturn format_chars + nchars - 1;\n+\n+      if (!format_chars[nchars])\n+\t{\n+\t  format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t \"spurious trailing space in format\");\n+\t  return format_chars + nchars - 1;\n+\t}\n+\n+      if (nchars > 1)\n+\t{\n+\t  if (nchars == 2\n+\t      && orig_format_chars < format_chars\n+\t      && format_chars[-1] == '.'\n+\t      && format_chars[0] == ' '\n+\t      && format_chars[1] == ' ')\n+\t    {\n+\t      /* A period followed by two spaces.  */\n+\t      if (ISUPPER (*orig_format_chars))\n+\t\t{\n+\t\t  /* If the part before the period is a capitalized\n+\t\t     sentence check to make sure that what follows\n+\t\t     is also capitalized.  */\n+\t\t  if (ISLOWER (format_chars[2]))\n+\t\t    format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t\t   fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t\t   \"inconsistent capitalization in \"\n+\t\t\t\t\t   \"format\");\n+\t\t}\n+\t    }\n+\t  else\n+\t    format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t   fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t   \"unquoted sequence of %i consecutive \"\n+\t\t\t\t   \"space characters in format\", nchars);\n+\t  return format_chars + nchars - 1;\n+\t}\n+\n+      format_chars += nchars;\n+      nchars = 0;\n+    }\n+\n+  fmtchrpos = format_chars - orig_format_chars;\n+\n+  /* Diagnose any unquoted control characters other than the terminating\n+     NUL.  */\n+  while (format_chars[nchars] && ISCNTRL (format_chars[nchars]))\n+    ++nchars;\n+\n+  if (nchars > 1)\n+    {\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t     \"unquoted control characters in format\");\n+      return format_chars + nchars - 1;\n+    }\n+  if (nchars)\n+    {\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t     \"unquoted control character %qc in format\",\n+\t\t\t     *format_chars);\n+      return format_chars + nchars - 1;\n+    }\n+\n+  if (ISPUNCT (format_chars[0]))\n+    {\n+      size_t nelts = sizeof c_opers / sizeof *c_opers;\n+      if (const char *ret = check_tokens (c_opers, nelts,\n+\t\t\t\t\t  format_string_loc, format_string_cst,\n+\t\t\t\t\t  orig_format_chars, format_chars,\n+\t\t\t\t\t  baltoks))\n+\treturn ret;\n+\n+      nelts = c_dialect_cxx () ? sizeof cxx_opers / sizeof *cxx_opers : 0;\n+      if (const char *ret = check_tokens (cxx_opers, nelts,\n+\t\t\t\t\t  format_string_loc, format_string_cst,\n+\t\t\t\t\t  orig_format_chars, format_chars,\n+\t\t\t\t\t  baltoks))\n+\treturn ret;\n+    }\n+\n+  if (ISALPHA (format_chars[0]))\n+    {\n+      size_t nelts = sizeof c_keywords / sizeof *c_keywords;\n+      if (const char *ret = check_tokens (c_keywords, nelts,\n+\t\t\t\t\t  format_string_loc, format_string_cst,\n+\t\t\t\t\t  orig_format_chars, format_chars,\n+\t\t\t\t\t  baltoks))\n+\treturn ret;\n+\n+      nelts = c_dialect_cxx () ? sizeof cxx_keywords / sizeof *cxx_keywords : 0;\n+      if (const char *ret = check_tokens (cxx_keywords, nelts,\n+\t\t\t\t\t  format_string_loc, format_string_cst,\n+\t\t\t\t\t  orig_format_chars, format_chars,\n+\t\t\t\t\t  baltoks))\n+\treturn ret;\n+    }\n+\n+  nchars = 0;\n+\n+  /* Diagnose unquoted options.  */\n+  if  ((format_chars == orig_format_chars\n+\t|| format_chars[-1] == ' ')\n+       && format_chars[0] == '-'\n+       && ((format_chars[1] == '-'\n+\t    && ISALPHA (format_chars[2]))\n+\t   || ISALPHA (format_chars[1])))\n+    {\n+      nchars = 1;\n+      while (ISALNUM (format_chars[nchars])\n+\t     || '_' == format_chars[nchars]\n+\t     || '-' == format_chars[nchars]\n+\t     || '+' == format_chars[nchars])\n+\t++nchars;\n+\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t     \"unquoted option name %<%.*s%> in format\",\n+\t\t\t     nchars, format_chars);\n+      return format_chars + nchars - 1;\n+    }\n+\n+  /* Diagnose leading, trailing, and two or more consecutive punctuation\n+     characters.  */\n+  const char *unbalanced = NULL;\n+  while ('%' != format_chars[nchars]\n+\t && ISPUNCT (format_chars[nchars])\n+\t && !unbalanced)\n+    {\n+      switch (format_chars[nchars])\n+\t{\n+\tcase '[':\n+\t  baltoks.brackets.safe_push (format_chars + nchars);\n+\t  break;\n+\tcase '{':\n+\t  baltoks.curly.safe_push (format_chars + nchars);\n+\t  break;\n+\tcase '(':\n+\t  baltoks.parens.safe_push (format_chars + nchars);\n+\t  break;\n+\tcase '<':\n+\t  baltoks.pointy.safe_push (format_chars + nchars);\n+\t  break;\n+\n+\tcase ']':\n+\t  if (baltoks.brackets.length () > 0)\n+\t    baltoks.brackets.pop ();\n+\t  else\n+\t    unbalanced = format_chars + nchars;\n+\t  break;\n+\tcase '}':\n+\t  if (baltoks.curly.length () > 0)\n+\t    baltoks.curly.pop ();\n+\t  else\n+\t    unbalanced = format_chars + nchars;\n+\t  break;\n+\tcase ')':\n+\t  if (baltoks.parens.length () > 0)\n+\t    baltoks.parens.pop ();\n+\t  else\n+\t    unbalanced = format_chars + nchars;\n+\t  break;\n+\tcase '>':\n+\t  if (baltoks.pointy.length () > 0)\n+\t    baltoks.pointy.pop ();\n+\t  else\n+\t    unbalanced = format_chars + nchars;\n+\t  break;\n+\t}\n+\n+      ++nchars;\n+    }\n+\n+  if (unbalanced)\n+    {\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t     \"unbalanced punctuation character %qc in format\",\n+\t\t\t     *unbalanced);\n+      return format_chars + nchars - 1;\n+    }\n+\n+  if (nchars)\n+    {\n+      /* Consider any identifier that follows the pound ('#') sign\n+\t a preprocessing directive.  */\n+      if (nchars == 1\n+\t  && format_chars[0] == '#'\n+\t  && ISALPHA (format_chars[1]))\n+\t{\n+\t  while (ISALNUM (format_chars[nchars])\n+\t\t || format_chars[nchars] == '_')\n+\t    ++nchars;\n+\n+\t  format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t \"unquoted preprocessing directive %<%.*s%> \"\n+\t\t\t\t \"in format\", nchars, format_chars);\n+\t  return format_chars + nchars - 1;\n+\t}\n+\n+      /* Diagnose a bare single quote.  */\n+      if (nchars == 1\n+\t  && format_chars[0] == '\\''\n+\t  && format_chars - orig_format_chars\n+\t  && ISALPHA (format_chars[-1])\n+\t  && ISALPHA (format_chars[1]))\n+\t{\n+\t  /* Diagnose a subset of contractions that are best avoided.  */\n+\t  for (unsigned i = 0; i != sizeof contrs / sizeof *contrs; ++i)\n+\t    {\n+\t      const char *apos = strchr (contrs[i].name, '\\'');\n+\t      gcc_assert (apos != NULL);\n+\t      int off = apos - contrs[i].name;\n+\n+\t      if (format_chars - orig_format_chars >= off\n+\t\t  && !strncmp (format_chars - off,\n+\t\t\t       contrs[i].name, contrs[i].len))\n+\t\t{\n+\t\t  format_warning_substr (format_string_loc,\n+\t\t\t\t\t format_string_cst,\n+\t\t\t\t\t fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t\t \"contraction %<%.*s%> in format; \"\n+\t\t\t\t\t \"use %qs instead\",\n+\t\t\t\t\t contrs[i].len, contrs[i].name,\n+\t\t\t\t\t contrs[i].alt);\n+\t\t  return format_chars + nchars - 1;\n+\t\t}\n+\t    }\n+\n+\t  if (format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t     \"bare apostrophe %<'%> in format\"))\n+\t    inform (format_string_loc,\n+\t\t    \"if avoiding the apostrophe is not feasible, enclose \"\n+\t\t    \"it in a pair of %qs and %qs directives instead\",\n+\t\t    \"%<\", \"%>\");\n+\t  return format_chars + nchars - 1;\n+\t}\n+\n+      /* Diagnose a backtick (grave accent).  */\n+      if (nchars == 1\n+\t  && format_chars[0] == '`')\n+\t{\n+\t  if (format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t     \"grave accent %<`%> in format\"))\n+\t    inform (format_string_loc,\n+\t\t    \"use the apostrophe directive %qs instead\", \"%'\");\n+\t  return format_chars + nchars - 1;\n+\t}\n+\n+      /* Diagnose a punctuation character after a space.  */\n+      if (nchars == 1\n+\t  && format_chars - orig_format_chars\n+\t  && format_chars[-1] == ' '\n+\t  && strspn (format_chars, \"!?:;.,\") == 1)\n+\t{\n+\t  format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t fmtchrpos - 1, fmtchrpos, opt,\n+\t\t\t\t \"space followed by punctuation character \"\n+\t\t\t\t \"%<%c%>\", format_chars[0]);\n+\t  return format_chars;\n+\t}\n+\n+      if (nchars == 1)\n+\t{\n+\t  if (!strncmp (format_chars, \"\\\"%s\\\"\", 4))\n+\t    {\n+\t      if (format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t\t fmtchrpos, fmtchrpos + 4, opt,\n+\t\t\t\t\t \"quoted %qs directive in format\",\n+\t\t\t\t\t \"%s\"))\n+\t\tinform (format_string_loc, \"if using %qs is not feasible, \"\n+\t\t\t\"use %qs instead\", \"%qs\", \"\\\"%-s\\\"\");\n+\t    }\n+\n+\t  if (format_chars[0] == '\"')\n+\t    {\n+\t      baltoks.doublequote = baltoks.doublequote ? NULL : format_chars;\n+\t      return format_chars + nchars - 1;\n+\t    }\n+\t  if (format_chars[0] == '\\'')\n+\t    {\n+\t      baltoks.singlequote = baltoks.singlequote ? NULL : format_chars;\n+\t      return format_chars + nchars - 1;\n+\t    }\n+\t}\n+\n+      if (fmtchrpos == 0)\n+\t{\n+\t  if (nchars == 1\n+\t      && format_chars[0] == '(')\n+\t    ;   /* Text beginning in an open parenthesis.  */\n+\t  else if (nchars == 3\n+\t      && !strncmp (format_chars, \"...\", 3)\n+\t      && format_chars[3])\n+\t    ;   /* Text beginning in an ellipsis.  */\n+\t  else\n+\t    {\n+\t      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t     \"spurious leading punctuation sequence \"\n+\t\t\t\t     \"%<%.*s%> in format\",\n+\t\t\t\t     nchars, format_chars);\n+\t      return format_chars + nchars - 1;\n+\t    }\n+\t}\n+      else if (!format_chars[nchars])\n+\t{\n+\t  if (nchars == 1\n+\t      && (format_chars[nchars - 1] == ':'\n+\t\t  || format_chars[nchars - 1] == ')'))\n+\t    ;   /* Text ending in a colon or a closing parenthesis.  */\n+\t  else if (nchars == 1\n+\t\t   && ((ISUPPER (*orig_format_chars)\n+\t\t\t&& format_chars[nchars - 1] == '.')\n+\t\t       || strspn (format_chars + nchars - 1, \"?])\") == 1))\n+\t\t  ;   /* Capitalized sentence terminated by a single period,\n+\t\t\t or text ending in a question mark, closing bracket,\n+\t\t\t or parenthesis.  */\n+\t  else if (nchars == 2\n+\t\t   && format_chars[0] == '?'\n+\t\t   && format_chars[1] == ')')\n+\t    ;   /* A question mark after a closing parenthetical note.  */\n+\t  else if (nchars == 2\n+\t\t   && format_chars[0] == ')'\n+\t\t   && (format_chars[1] == '?'\n+\t\t       || format_chars[1] == ';'\n+\t\t       || format_chars[1] == ':'\n+\t\t       || (ISUPPER (*orig_format_chars)\n+\t\t\t   && format_chars[1] == '.')))\n+\t    ;   /* Closing parenthetical note followed by a question mark,\n+\t\t   semicolon, or colon at the end of the string, or by\n+\t\t   a period at the end of a capitalized sentence.  */\n+\t  else if (nchars == 3\n+\t\t   && format_chars - orig_format_chars > 0\n+\t\t   && !strncmp (format_chars, \"...\", 3))\n+\t    ;   /* Text ending in the ellipsis.  */\n+\t  else\n+\t    format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t\t   fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t\t   \"spurious trailing punctuation sequence \"\n+\t\t\t\t   \"%<%.*s%> in format\",\n+\t\t\t\t   nchars, format_chars);\n+\n+\t  return format_chars + nchars - 1;\n+\t}\n+      else if (nchars == 2\n+\t       && format_chars[0] == ')'\n+\t       && (format_chars[1] == ':'\n+\t\t   || format_chars[1] == ';'\n+\t\t   || format_chars[1] == ',')\n+\t       && format_chars[2] == ' ')\n+\t;   /* Closing parenthetical note followed by a colon, semicolon\n+\t       or a comma followed by a space in the middle of the string.  */\n+      else if (nchars > 1)\n+\tformat_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t       fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t       \"unquoted sequence of %i consecutive \"\n+\t\t\t       \"punctuation characters %q.*s in format\",\n+\t\t\t       nchars, nchars, format_chars);\n+      return format_chars + nchars - 1;\n+    }\n+\n+  nchars = 0;\n+\n+  /* Finally, diagnose any unquoted non-graph, non-punctuation characters\n+     other than the terminating NUL.  */\n+  while (format_chars[nchars]\n+\t && '%' != format_chars[nchars]\n+\t && !ISPUNCT (format_chars[nchars])\n+\t && !ISGRAPH (format_chars[nchars]))\n+    ++nchars;\n+\n+  if (nchars > 1)\n+    {\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t     \"unquoted non-graph characters in format\");\n+      return format_chars + nchars - 1;\n+    }\n+  if (nchars)\n+    {\n+      format_warning_substr (format_string_loc, format_string_cst,\n+\t\t\t     fmtchrpos, fmtchrpos + nchars, opt,\n+\t\t\t     \"unquoted non-graph character %qc in format\",\n+\t\t\t     *format_chars);\n+      return format_chars + nchars - 1;\n+    }\n+\n+  return format_chars;\n+}\n+\n+/* Diagnose unbalanced tokens described by BALTOKS in format string\n+   ORIG_FORMAT_CHARS and the corresponding FORMAT_STRING_CST.  */\n+\n+static void\n+maybe_diag_unbalanced_tokens (location_t format_string_loc,\n+\t\t\t      const char *orig_format_chars,\n+\t\t\t      tree format_string_cst,\n+\t\t\t      baltoks_t &baltoks)\n+{\n+  const char *unbalanced = NULL;\n+\n+  if (baltoks.brackets.length ())\n+    unbalanced = baltoks.brackets.pop ();\n+  else if (baltoks.curly.length ())\n+    unbalanced = baltoks.curly.pop ();\n+  else if (baltoks.parens.length ())\n+    unbalanced = baltoks.parens.pop ();\n+  else if (baltoks.pointy.length ())\n+    unbalanced = baltoks.pointy.pop ();\n+\n+  if (unbalanced)\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    unbalanced - orig_format_chars + 1,\n+\t\t\t    OPT_Wformat_diag,\n+\t\t\t    \"unbalanced punctuation character %<%c%> in format\",\n+\t\t\t    *unbalanced);\n+\n+  if (baltoks.quotdirs.length ())\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    baltoks.quotdirs.pop () - orig_format_chars,\n+\t\t\t    OPT_Wformat_,\n+\t\t\t    \"unterminated quoting directive\");\n+\n+  const char *quote\n+    = baltoks.singlequote ? baltoks.singlequote : baltoks.doublequote;\n+\n+  if (quote)\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+  \t\t\t    quote - orig_format_chars + 1,\n+\t\t\t    OPT_Wformat_diag,\n+  \t\t\t    \"unterminated quote character %<%c%> in format\",\n+  \t\t\t    *quote);\n+}\n+\n /* Do the main part of checking a call to a format function.  FORMAT_CHARS\n    is the NUL-terminated format string (which at this point may contain\n    internal NUL characters); FORMAT_LENGTH is its length (excluding the\n@@ -2816,8 +3778,10 @@ check_format_info_main (format_check_results *res,\n      and it didn't use $; 1 if $ formats are in use.  */\n   int has_operand_number = -1;\n \n-  /* Vector of pointers to opening quoting directives (like GCC \"%<\").  */\n-  auto_vec<const char*> quotdirs;\n+  /* Vectors of pointers to opening quoting directives (like GCC \"%<\"),\n+     opening braces, brackets, and parentheses.  Used to detect unbalanced\n+     tokens.  */\n+  baltoks_t baltoks;\n \n   /* Pointers to the most recent color directives (like GCC's \"%r or %R\").\n      A starting color directive much be terminated before the end of\n@@ -2828,10 +3792,26 @@ check_format_info_main (format_check_results *res,\n \n   init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n \n+  /* In GCC diagnostic functions check plain directives (substrings within\n+     the format string that don't start with %) for quoting and punctuations\n+     problems.  */\n+  bool ck_plain = (!info->is_raw\n+\t\t   && (info->format_type == gcc_diag_format_type\n+\t\t       || info->format_type == gcc_tdiag_format_type\n+\t\t       || info->format_type == gcc_cdiag_format_type\n+\t\t       || info->format_type == gcc_cxxdiag_format_type));\n+\n   while (*format_chars != 0)\n     {\n-      if (*format_chars++ != '%')\n+      if (ck_plain)\n+\tformat_chars = check_plain (format_string_loc,\n+\t\t\t\t    format_string_cst,\n+\t\t\t\t    orig_format_chars, format_chars,\n+\t\t\t\t    baltoks);\n+\n+      if (*format_chars == 0 || *format_chars++ != '%')\n \tcontinue;\n+\n       if (*format_chars == 0)\n \t{\n \t  format_warning_at_char (format_string_loc, format_string_cst,\n@@ -2846,6 +3826,8 @@ check_format_info_main (format_check_results *res,\n \t  continue;\n \t}\n \n+      /* ARGUMENT_PARSER ctor takes FORMAT_CHARS by reference and calls\n+\t to ARG_PARSER members may modify the variable.  */\n       flag_chars_t flag_chars;\n       argument_parser arg_parser (info, format_chars, format_string_cst,\n \t\t\t\t  orig_format_chars, format_string_loc,\n@@ -2908,7 +3890,7 @@ check_format_info_main (format_check_results *res,\n       flag_chars.validate (fki, fci, flag_specs, format_chars,\n \t\t\t   format_string_cst,\n \t\t\t   format_string_loc, orig_format_chars, format_char,\n-\t\t\t   quotdirs.length () > 0);\n+\t\t\t   baltoks.quotdirs.length () > 0);\n \n       const int alloc_flag = flag_chars.get_alloc_flag (fki);\n       const bool suppressed = flag_chars.assignment_suppression_p (fki);\n@@ -2920,17 +3902,17 @@ check_format_info_main (format_check_results *res,\n \n       if (quot_begin_p && !quot_end_p)\n \t{\n-\t  if (quotdirs.length ())\n+\t  if (baltoks.quotdirs.length ())\n \t    format_warning_at_char (format_string_loc, format_string_cst,\n \t\t\t\t    format_chars - orig_format_chars,\n \t\t\t\t    OPT_Wformat_,\n \t\t\t\t    \"nested quoting directive\");\n-\t  quotdirs.safe_push (format_chars);\n+\t  baltoks.quotdirs.safe_push (format_chars);\n \t}\n       else if (!quot_begin_p && quot_end_p)\n \t{\n-\t  if (quotdirs.length ())\n-\t    quotdirs.pop ();\n+\t  if (baltoks.quotdirs.length ())\n+\t    baltoks.quotdirs.pop ();\n \t  else\n \t    format_warning_at_char (format_string_loc, format_string_cst,\n \t\t\t\t    format_chars - orig_format_chars,\n@@ -2962,7 +3944,7 @@ check_format_info_main (format_check_results *res,\n \n       /* Diagnose directives that shouldn't appear in a quoted sequence.\n \t (They are denoted by a double quote in FLAGS2.)  */\n-      if (quotdirs.length ())\n+      if (baltoks.quotdirs.length ())\n \t{\n \t  if (strchr (fci->flags2, '\"'))\n \t    format_warning_at_char (format_string_loc, format_string_cst,\n@@ -3018,10 +4000,9 @@ check_format_info_main (format_check_results *res,\n   if (has_operand_number > 0)\n     finish_dollar_format_checking (res, fki->flags & (int) FMT_FLAG_DOLLAR_GAP_POINTER_OK);\n \n-  if (quotdirs.length ())\n-    format_warning_at_char (format_string_loc, format_string_cst,\n-\t\t\t    quotdirs.pop () - orig_format_chars,\n-\t\t\t    OPT_Wformat_, \"unterminated quoting directive\");\n+  maybe_diag_unbalanced_tokens (format_string_loc, orig_format_chars,\n+\t\t\t\tformat_string_cst, baltoks);\n+\n   if (color_begin && !color_end)\n     format_warning_at_char (format_string_loc, format_string_cst,\n \t\t\t    color_begin - orig_format_chars,\n@@ -4199,7 +5180,7 @@ handle_format_attribute (tree *node, tree atname, tree args,\n \t  if (arg_num != info.first_arg_num)\n \t    {\n \t      if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\t\terror (\"args to be formatted is not %<...%>\");\n+\t\terror (\"argument to be formatted is not %<...%>\");\n \t      *no_add_attrs = true;\n \t      return NULL_TREE;\n \t    }"}, {"sha": "678de635777c203fd7f3a7b3f05a002b3d5568fd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a04c0734e366a167a55f635b7d09de09b5013051", "patch": "@@ -1,3 +1,8 @@\n+2019-06-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR translation/90156\n+\t* gcc.dg/format/gcc_diag-11.c: Enable.\n+\n 2019-06-19  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/69499"}, {"sha": "a976c7aa5191373648bb9ca06f605c54e69ab1ca", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-11.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a04c0734e366a167a55f635b7d09de09b5013051/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-11.c?ref=a04c0734e366a167a55f635b7d09de09b5013051", "patch": "@@ -1,8 +1,7 @@\n /* Test warnings for common punctuation, quoting, and spelling issues\n    in GCC diagnostics.\n    { dg-do compile }\n-   { dg-options \"-Wformat -Wformat-diag\" }\n-   { dg-skip-if \"-Wformat-diag not available yet\" { *-*-* } }\n+   { dg-options \"-Wformat -Wformat-diag\" } */\n \n /* Magic identifiers must be set before the attribute is used.  */\n "}]}