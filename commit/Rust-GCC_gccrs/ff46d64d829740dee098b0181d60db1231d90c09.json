{"sha": "ff46d64d829740dee098b0181d60db1231d90c09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY0NmQ2NGQ4Mjk3NDBkZWUwOThiMDE4MWQ2MGRiMTIzMWQ5MGMwOQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2014-07-24T17:11:02Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2014-07-24T17:11:02Z"}, "message": "rs6000.c (rs6000_function_arg): If a float argument does not fit fully into floating-point registers...\n\ngcc/\n\n\t* config/rs6000/rs6000.c (rs6000_function_arg): If a float argument\n\tdoes not fit fully into floating-point registers, and there is still\n\tspace in the register parameter area, use GPRs to pass those parts\n\tof the argument.  Issue -Wpsabi note if any parameter is now treated\n\tdifferently than before.\n\t(rs6000_arg_partial_bytes): Update.\n\ngcc/testsuite/\n\n\t* gcc.target/powerpc/ppc64-abi-warn-1.c: New test.\n\nFrom-SVN: r213015", "tree": {"sha": "23523450e5e7f50219b97dbe687585e7113e9bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23523450e5e7f50219b97dbe687585e7113e9bd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff46d64d829740dee098b0181d60db1231d90c09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff46d64d829740dee098b0181d60db1231d90c09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff46d64d829740dee098b0181d60db1231d90c09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff46d64d829740dee098b0181d60db1231d90c09/comments", "author": null, "committer": null, "parents": [{"sha": "c41e1ae6c0ee5face983669fc23e418be1faa1da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c41e1ae6c0ee5face983669fc23e418be1faa1da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c41e1ae6c0ee5face983669fc23e418be1faa1da"}], "stats": {"total": 86, "additions": 84, "deletions": 2}, "files": [{"sha": "244cf230c41be099c5cee5ad1f75705db437be75", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff46d64d829740dee098b0181d60db1231d90c09", "patch": "@@ -1,3 +1,12 @@\n+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_function_arg): If a float argument\n+\tdoes not fit fully into floating-point registers, and there is still\n+\tspace in the register parameter area, use GPRs to pass those parts\n+\tof the argument.  Issue -Wpsabi note if any parameter is now treated\n+\tdifferently than before.\n+\t(rs6000_arg_partial_bytes): Update.\n+\n 2014-07-24  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/elf.h: Define TARGET_UNWIND_TABLES_DEFAULT."}, {"sha": "0f028623871faa1bbceb6fc3ee21495b1811e929", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ff46d64d829740dee098b0181d60db1231d90c09", "patch": "@@ -10229,6 +10229,7 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t  rtx r, off;\n \t  int i, k = 0;\n \t  unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;\n+\t  int fpr_words;\n \n \t  /* Do we also need to pass this argument in the parameter\n \t     save area?  */\n@@ -10257,6 +10258,47 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n \t    }\n \n+\t  /* If there were not enough FPRs to hold the argument, the rest\n+\t     usually goes into memory.  However, if the current position\n+\t     is still within the register parameter area, a portion may\n+\t     actually have to go into GPRs.\n+\n+\t     Note that it may happen that the portion of the argument\n+\t     passed in the first \"half\" of the first GPR was already\n+\t     passed in the last FPR as well.\n+\n+\t     For unnamed arguments, we already set up GPRs to cover the\n+\t     whole argument in rs6000_psave_function_arg, so there is\n+\t     nothing further to do at this point.  */\n+\t  fpr_words = (i * GET_MODE_SIZE (elt_mode)) / (TARGET_32BIT ? 4 : 8);\n+\t  if (i < n_elts && align_words + fpr_words < GP_ARG_NUM_REG\n+\t      && cum->nargs_prototype > 0)\n+            {\n+\t      static bool warned;\n+\n+\t      enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n+\t      int n_words = rs6000_arg_size (mode, type);\n+\n+\t      align_words += fpr_words;\n+\t      n_words -= fpr_words;\n+\n+\t      do\n+\t\t{\n+\t\t  r = gen_rtx_REG (rmode, GP_ARG_MIN_REG + align_words);\n+\t\t  off = GEN_INT (fpr_words++ * GET_MODE_SIZE (rmode));\n+\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n+\t\t}\n+\t      while (++align_words < GP_ARG_NUM_REG && --n_words != 0);\n+\n+\t      if (!warned && warn_psabi)\n+\t\t{\n+\t\t  warned = true;\n+\t\t  inform (input_location,\n+\t\t\t  \"the ABI of passing homogeneous float aggregates\"\n+\t\t\t  \" has changed in GCC 4.10\");\n+\t\t}\n+\t    }\n+\n \t  return rs6000_finish_function_arg (mode, rvec, k);\n \t}\n       else if (align_words < GP_ARG_NUM_REG)\n@@ -10332,8 +10374,23 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, enum machine_mode mode,\n       /* Otherwise, we pass in FPRs only.  Check for partial copies.  */\n       passed_in_gprs = false;\n       if (cum->fregno + n_elts * n_fpreg > FP_ARG_MAX_REG + 1)\n-\tret = ((FP_ARG_MAX_REG + 1 - cum->fregno)\n-\t       * MIN (8, GET_MODE_SIZE (elt_mode)));\n+\t{\n+\t  /* Compute number of bytes / words passed in FPRs.  If there\n+\t     is still space available in the register parameter area\n+\t     *after* that amount, a part of the argument will be passed\n+\t     in GPRs.  In that case, the total amount passed in any\n+\t     registers is equal to the amount that would have been passed\n+\t     in GPRs if everything were passed there, so we fall back to\n+\t     the GPR code below to compute the appropriate value.  */\n+\t  int fpr = ((FP_ARG_MAX_REG + 1 - cum->fregno)\n+\t\t     * MIN (8, GET_MODE_SIZE (elt_mode)));\n+\t  int fpr_words = fpr / (TARGET_32BIT ? 4 : 8);\n+\n+\t  if (align_words + fpr_words < GP_ARG_NUM_REG)\n+\t    passed_in_gprs = true;\n+\t  else\n+\t    ret = fpr;\n+\t}\n     }\n \n   if (passed_in_gprs"}, {"sha": "f64ab591c9864f78ccf2cfcc3d4c3d6d7936c893", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ff46d64d829740dee098b0181d60db1231d90c09", "patch": "@@ -1,3 +1,7 @@\n+2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* gcc.target/powerpc/ppc64-abi-warn-1.c: New test.\n+\n 2014-07-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* g++.dg/compat/struct-layout-1.exp: Load g++-dg.exp."}, {"sha": "c70c14c2858a191403d7a028743db67ca75f670b", "filename": "gcc/testsuite/gcc.target/powerpc/ppc64-abi-warn-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff46d64d829740dee098b0181d60db1231d90c09/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fppc64-abi-warn-1.c?ref=ff46d64d829740dee098b0181d60db1231d90c09", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-options \"-mabi=elfv2\" } */\n+\n+struct f8\n+  {\n+    float x[8];\n+  };\n+\n+void test (struct f8 a, struct f8 b) /* { dg-message \"note: the ABI of passing homogeneous float aggregates has changed\" } */\n+{\n+}\n+"}]}