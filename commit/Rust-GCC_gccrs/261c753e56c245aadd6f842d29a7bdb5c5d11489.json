{"sha": "261c753e56c245aadd6f842d29a7bdb5c5d11489", "node_id": "C_kwDOANBUbNoAKDI2MWM3NTNlNTZjMjQ1YWFkZDZmODQyZDI5YTdiZGI1YzVkMTE0ODk", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-03-22T17:42:52Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-03-24T15:59:35Z"}, "message": "macros: implement include_bytes! and include_str!", "tree": {"sha": "8b8615a3c10d667a382cb60c9476edac825e1418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8615a3c10d667a382cb60c9476edac825e1418"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/261c753e56c245aadd6f842d29a7bdb5c5d11489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261c753e56c245aadd6f842d29a7bdb5c5d11489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261c753e56c245aadd6f842d29a7bdb5c5d11489", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261c753e56c245aadd6f842d29a7bdb5c5d11489/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc6e405912c83aee41efd3015d9157cdbe9134fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6e405912c83aee41efd3015d9157cdbe9134fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6e405912c83aee41efd3015d9157cdbe9134fe"}], "stats": {"total": 273, "additions": 273, "deletions": 0}, "files": [{"sha": "14f60d202cca9c009ce814d212c7f993737aa9b6", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -20,6 +20,9 @@\n #include \"rust-diagnostics.h\"\n #include \"rust-expr.h\"\n #include \"rust-session-manager.h\"\n+#include \"rust-macro-invoc-lexer.h\"\n+#include \"rust-lex.h\"\n+#include \"rust-parse.h\"\n \n namespace Rust {\n namespace {\n@@ -30,6 +33,107 @@ make_string (Location locus, std::string value)\n     new AST::LiteralExpr (value, AST::Literal::STRING,\n \t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n }\n+\n+/* Parse a single string literal from the given delimited token tree,\n+   and return the LiteralExpr for it. Allow for an optional trailing comma,\n+   but otherwise enforce that these are the only tokens.  */\n+\n+std::unique_ptr<AST::LiteralExpr>\n+parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n+\t\t\t     Location invoc_locus)\n+{\n+  MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n+  Parser<MacroInvocLexer> parser (std::move (lex));\n+\n+  auto last_token_id = TokenId::RIGHT_CURLY;\n+  switch (invoc_token_tree.get_delim_type ())\n+    {\n+    case AST::DelimType::PARENS:\n+      last_token_id = TokenId::RIGHT_PAREN;\n+      rust_assert (parser.skip_token (LEFT_PAREN));\n+      break;\n+\n+    case AST::DelimType::CURLY:\n+      rust_assert (parser.skip_token (LEFT_CURLY));\n+      break;\n+\n+    case AST::DelimType::SQUARE:\n+      last_token_id = TokenId::RIGHT_SQUARE;\n+      rust_assert (parser.skip_token (LEFT_SQUARE));\n+      break;\n+    }\n+\n+  std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n+\n+  if (parser.peek_current_token ()->get_id () == STRING_LITERAL)\n+    {\n+      lit_expr = parser.parse_literal_expr ();\n+      parser.maybe_skip_token (COMMA);\n+      if (parser.peek_current_token ()->get_id () != last_token_id)\n+\t{\n+\t  lit_expr = nullptr;\n+\t  rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+\t}\n+    }\n+  else if (parser.peek_current_token ()->get_id () == last_token_id)\n+    rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+  else\n+    rust_error_at (invoc_locus, \"argument must be a string literal\");\n+\n+  parser.skip_token (last_token_id);\n+\n+  return lit_expr;\n+}\n+\n+/* Treat PATH as a path relative to the source file currently being\n+   compiled, and return the absolute path for it.  */\n+\n+std::string\n+source_relative_path (std::string path, Location locus)\n+{\n+  std::string compile_fname\n+    = Session::get_instance ().linemap->location_file (locus);\n+\n+  auto dir_separator_pos = compile_fname.rfind (file_separator);\n+\n+  /* If there is no file_separator in the path, use current dir ('.').  */\n+  std::string dirname;\n+  if (dir_separator_pos == std::string::npos)\n+    dirname = std::string (\".\") + file_separator;\n+  else\n+    dirname = compile_fname.substr (0, dir_separator_pos) + file_separator;\n+\n+  return dirname + path;\n+}\n+\n+/* Read the full contents of the file FILENAME and return them in a vector.\n+   FIXME: platform specific.  */\n+\n+std::vector<uint8_t>\n+load_file_bytes (const char *filename)\n+{\n+  RAIIFile file_wrap (filename);\n+  if (file_wrap.get_raw () == nullptr)\n+    {\n+      rust_error_at (Location (), \"cannot open filename %s: %m\", filename);\n+      return std::vector<uint8_t> ();\n+    }\n+\n+  FILE *f = file_wrap.get_raw ();\n+  fseek (f, 0L, SEEK_END);\n+  long fsize = ftell (f);\n+  fseek (f, 0L, SEEK_SET);\n+\n+  std::vector<uint8_t> buf (fsize);\n+\n+  if (fread (&buf[0], fsize, 1, f) != 1)\n+    {\n+      rust_error_at (Location (), \"error reading file %s: %m\", filename);\n+      return std::vector<uint8_t> ();\n+    }\n+\n+  return buf;\n+}\n } // namespace\n \n AST::ASTFragment\n@@ -63,4 +167,73 @@ MacroBuiltin::column (Location invoc_locus, AST::MacroInvocData &invoc)\n \n   return AST::ASTFragment ({column_no});\n }\n+\n+/* Expand builtin macro include_bytes!(\"filename\"), which includes the contents\n+   of the given file as reference to a byte array. Yields an expression of type\n+   &'static [u8; N].  */\n+\n+AST::ASTFragment\n+MacroBuiltin::include_bytes (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string target_filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+\n+  std::vector<uint8_t> bytes = load_file_bytes (target_filename.c_str ());\n+\n+  /* Is there a more efficient way to do this?  */\n+  std::vector<std::unique_ptr<AST::Expr>> elts;\n+  for (uint8_t b : bytes)\n+    {\n+      elts.emplace_back (\n+\tnew AST::LiteralExpr (std::string (1, (char) b), AST::Literal::BYTE,\n+\t\t\t      PrimitiveCoreType::CORETYPE_U8,\n+\t\t\t      {} /* outer_attrs */, invoc_locus));\n+    }\n+\n+  auto elems = std::unique_ptr<AST::ArrayElems> (\n+    new AST::ArrayElemsValues (std::move (elts), invoc_locus));\n+\n+  auto array = std::unique_ptr<AST::Expr> (\n+    new AST::ArrayExpr (std::move (elems), {}, {}, invoc_locus));\n+\n+  auto borrow = std::unique_ptr<AST::Expr> (\n+    new AST::BorrowExpr (std::move (array), false, false, {}, invoc_locus));\n+\n+  auto node = AST::SingleASTNode (std::move (borrow));\n+  return AST::ASTFragment ({node});\n+}\n+\n+/* Expand builtin macro include_str!(\"filename\"), which includes the contents\n+   of the given file as a string. The file must be UTF-8 encoded. Yields an\n+   expression of type &'static str.  */\n+\n+AST::ASTFragment\n+MacroBuiltin::include_str (Location invoc_locus, AST::MacroInvocData &invoc)\n+{\n+  /* Get target filename from the macro invocation, which is treated as a path\n+     relative to the include!-ing file (currently being compiled).  */\n+  auto lit_expr\n+    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus);\n+  if (lit_expr == nullptr)\n+    return AST::ASTFragment::create_error ();\n+\n+  std::string target_filename\n+    = source_relative_path (lit_expr->as_string (), invoc_locus);\n+\n+  std::vector<uint8_t> bytes = load_file_bytes (target_filename.c_str ());\n+\n+  /* FIXME: Enforce that the file contents are valid UTF-8.  */\n+  std::string str ((const char *) &bytes[0], bytes.size ());\n+\n+  auto node = AST::SingleASTNode (make_string (invoc_locus, str));\n+  return AST::ASTFragment ({node});\n+}\n+\n } // namespace Rust"}, {"sha": "8b7c016b2533c5c0d412042febfdcef1046de38b", "filename": "gcc/rust/expand/rust-macro-builtins.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.h?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -71,6 +71,12 @@ class MacroBuiltin\n \n   static AST::ASTFragment column (Location invoc_locus,\n \t\t\t\t  AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include_bytes (Location invoc_locus,\n+\t\t\t\t\t AST::MacroInvocData &invoc);\n+\n+  static AST::ASTFragment include_str (Location invoc_locus,\n+\t\t\t\t       AST::MacroInvocData &invoc);\n };\n } // namespace Rust\n "}, {"sha": "7fbdbb0fc6db708134a001ffe15081f28b18e94d", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -751,6 +751,8 @@ Mappings::insert_macro_def (AST::MacroRulesDefinition *macro)\n       {\"assert\", MacroBuiltin::assert},\n       {\"file\", MacroBuiltin::file},\n       {\"column\", MacroBuiltin::column},\n+      {\"include_bytes\", MacroBuiltin::include_bytes},\n+      {\"include_str\", MacroBuiltin::include_str},\n     };\n \n   auto builtin = builtin_macros.find (macro->get_rule_name ());"}, {"sha": "966c073a794e9fbd030e8ba3f8bef32e492767ef", "filename": "gcc/testsuite/rust/compile/builtin_macro_include_bytes.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_bytes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_bytes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_bytes.rs?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! include_bytes {\n+  () => {{}};\n+}\n+\n+fn main () {\n+  let file = \"include.txt\";\n+  include_bytes! (file); // { dg-error \"argument must be a string literal\" \"\" }\n+  include_bytes! (); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_bytes! (\"foo.txt\", \"bar.txt\"); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_bytes! (\"builtin_macro_include_bytes.rs\"); // ok\n+  include_bytes! (\"builtin_macro_include_bytes.rs\",); // trailing comma ok\n+}"}, {"sha": "3e559cb92cb327eba63e6212b14c184cb126df0f", "filename": "gcc/testsuite/rust/compile/builtin_macro_include_str.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_include_str.rs?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! include_str {\n+  () => {{}};\n+}\n+\n+fn main () {\n+  let file = \"include.txt\";\n+  include_str! (file); // { dg-error \"argument must be a string literal\" \"\" }\n+  include_str! (); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_str! (\"foo.txt\", \"bar.txt\"); // { dg-error \"macro takes 1 argument\" \"\" }\n+  include_str! (\"builtin_macro_include_str.rs\"); // ok\n+  include_str! (\"builtin_macro_include_str.rs\",); // trailing comma ok\n+}"}, {"sha": "3f7ebd288d9019918a862c4af9c0efe51be1c708", "filename": "gcc/testsuite/rust/execute/torture/builtin_macro_include_bytes.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_bytes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_bytes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_bytes.rs?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -0,0 +1,44 @@\n+// { dg-output \"104\\n33\\n1\\n\" }\n+\n+macro_rules! include_bytes {\n+  () => {{}};\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn print_int(value: i32) {\n+    let s = \"%d\\n\\0\" as *const str as *const i8;\n+    printf(s, value);\n+}\n+\n+fn main() -> i32 {\n+  let bytes = include_bytes! (\"include.txt\");\n+\n+  print_int (bytes[0] as i32);\n+  print_int (bytes[14] as i32);\n+\n+  let the_bytes = b\"hello, include!\\n\";\n+\n+  let x = bytes[0] == the_bytes[0]\n+    && bytes[1] == the_bytes [1]\n+    && bytes[2] == the_bytes [2]\n+    && bytes[3] == the_bytes [3]\n+    && bytes[4] == the_bytes [4]\n+    && bytes[5] == the_bytes [5]\n+    && bytes[6] == the_bytes [6]\n+    && bytes[7] == the_bytes [7]\n+    && bytes[8] == the_bytes [8]\n+    && bytes[9] == the_bytes [9]\n+    && bytes[10] == the_bytes [10]\n+    && bytes[11] == the_bytes [11]\n+    && bytes[12] == the_bytes [12]\n+    && bytes[13] == the_bytes [13]\n+    && bytes[14] == the_bytes [14]\n+    && bytes[15] == the_bytes [15];\n+\n+  print_int (x as i32);\n+\n+  0\n+}"}, {"sha": "095d7cbc6e8d2253bf677917e97d8b7a9230d033", "filename": "gcc/testsuite/rust/execute/torture/builtin_macro_include_str.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fbuiltin_macro_include_str.rs?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -0,0 +1,23 @@\n+// { dg-output \"hello, include!\\n\" }\n+\n+macro_rules! include_str {\n+  () => {{}};\n+}\n+\n+extern \"C\" {\n+    fn printf(fmt: *const i8, ...);\n+}\n+\n+fn print(s: &str) {\n+  printf(\"%s\" as *const str as *const i8, s as *const str as *const i8);\n+}\n+\n+\n+fn main() -> i32 {\n+  // include_str! (and include_bytes!) allow for an optional trailing comma.\n+  let my_str = include_str! (\"include.txt\",);\n+\n+  print (my_str);\n+\n+  0\n+}"}, {"sha": "12c368778e1503c8099e7dc96a4d74b0de0ee386", "filename": "gcc/testsuite/rust/execute/torture/include.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Finclude.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/261c753e56c245aadd6f842d29a7bdb5c5d11489/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Finclude.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Finclude.txt?ref=261c753e56c245aadd6f842d29a7bdb5c5d11489", "patch": "@@ -0,0 +1 @@\n+hello, include!"}]}