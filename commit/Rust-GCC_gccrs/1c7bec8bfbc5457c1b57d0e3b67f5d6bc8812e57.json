{"sha": "1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM3YmVjOGJmYmM1NDU3YzFiNTdkMGUzYjY3ZjVkNmJjODgxMmU1Nw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-03-03T08:38:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-03-16T14:54:23Z"}, "message": "c++: support target attr for DECL_LOCAL_DECL_P fns [PR99108]\n\nWe crash when target attribute get_function_versions_dispatcher is called\nfor a function that is not registered in call graph.  This was happening\nbecause we were calling it for the function-local decls that aren't in the\nsymbol table, instead of the corresponding namespace-scope decls that are.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/99108\n\t* call.c (get_function_version_dispatcher): Handle\n\tDECL_LOCAL_DECL_P.\n\t* decl.c (maybe_version_functions): Likewise.\n\t(maybe_mark_function_versioned): New.\n\t* name-lookup.c (push_local_extern_decl_alias): No longer static.\n\t* name-lookup.h (push_local_extern_decl_alias): Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/99108\n\t* g++.target/i386/pr99108.C: New test.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>", "tree": {"sha": "cfb2c3641e076ce41f60e86f757cd17b4263ca63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfb2c3641e076ce41f60e86f757cd17b4263ca63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e9c1c9191c8b9998e03cb15de8600a2a4b9188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6e9c1c9191c8b9998e03cb15de8600a2a4b9188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6e9c1c9191c8b9998e03cb15de8600a2a4b9188"}], "stats": {"total": 62, "additions": 52, "deletions": 10}, "files": [{"sha": "29f4b50fb664061b5e94b6fef533af62071be14b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "patch": "@@ -8469,6 +8469,9 @@ get_function_version_dispatcher (tree fn)\n {\n   tree dispatcher_decl = NULL;\n \n+  if (DECL_LOCAL_DECL_P (fn))\n+    fn = DECL_LOCAL_DECL_ALIAS (fn);\n+\n   gcc_assert (TREE_CODE (fn) == FUNCTION_DECL\n \t      && DECL_FUNCTION_VERSIONED (fn));\n "}, {"sha": "56092ebdc9c4926f55c4324af0e689f72ecd89c7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "patch": "@@ -1110,6 +1110,21 @@ decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n   return types_match;\n }\n \n+/* Mark DECL as versioned if it isn't already.  */\n+\n+static void\n+maybe_mark_function_versioned (tree decl)\n+{\n+  if (!DECL_FUNCTION_VERSIONED (decl))\n+    {\n+      DECL_FUNCTION_VERSIONED (decl) = 1;\n+      /* If DECL_ASSEMBLER_NAME has already been set, re-mangle\n+\t to include the version marker.  */\n+      if (DECL_ASSEMBLER_NAME_SET_P (decl))\n+\tmangle_decl (decl);\n+    }\n+}\n+\n /* NEWDECL and OLDDECL have identical signatures.  If they are\n    different versions adjust them and return true.\n    If RECORD is set to true, record function versions.  */\n@@ -1120,18 +1135,22 @@ maybe_version_functions (tree newdecl, tree olddecl, bool record)\n   if (!targetm.target_option.function_versions (newdecl, olddecl))\n     return false;\n \n-  if (!DECL_FUNCTION_VERSIONED (olddecl))\n+  maybe_mark_function_versioned (olddecl);\n+  if (DECL_LOCAL_DECL_P (olddecl))\n     {\n-      DECL_FUNCTION_VERSIONED (olddecl) = 1;\n-      if (DECL_ASSEMBLER_NAME_SET_P (olddecl))\n-\tmangle_decl (olddecl);\n+      olddecl = DECL_LOCAL_DECL_ALIAS (olddecl);\n+      maybe_mark_function_versioned (olddecl);\n     }\n \n-  if (!DECL_FUNCTION_VERSIONED (newdecl))\n+  maybe_mark_function_versioned (newdecl);\n+  if (DECL_LOCAL_DECL_P (newdecl))\n     {\n-      DECL_FUNCTION_VERSIONED (newdecl) = 1;\n-      if (DECL_ASSEMBLER_NAME_SET_P (newdecl))\n-\tmangle_decl (newdecl);\n+      /* Unfortunately, we can get here before pushdecl naturally calls\n+\t push_local_extern_decl_alias, so we need to call it directly.  */\n+      if (!DECL_LOCAL_DECL_ALIAS (newdecl))\n+\tpush_local_extern_decl_alias (newdecl);\n+      newdecl = DECL_LOCAL_DECL_ALIAS (newdecl);\n+      maybe_mark_function_versioned (newdecl);\n     }\n \n   if (record)"}, {"sha": "a6257f5da32f61bdff9932d3be17f79df16d61ee", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "patch": "@@ -3374,7 +3374,7 @@ set_decl_context_in_fn (tree ctx, tree decl)\n /* DECL is a local extern decl.  Find or create the namespace-scope\n    decl that it aliases.  Also, determines the linkage of DECL.  */\n \n-static void\n+void\n push_local_extern_decl_alias (tree decl)\n {\n   if (dependent_type_p (TREE_TYPE (decl)))\n@@ -3408,7 +3408,7 @@ push_local_extern_decl_alias (tree decl)\n \n       if (binding && TREE_CODE (binding) != TREE_LIST)\n \tfor (ovl_iterator iter (binding); iter; ++iter)\n-\t  if (decls_match (*iter, decl))\n+\t  if (decls_match (decl, *iter, /*record_versions*/false))\n \t    {\n \t      alias = *iter;\n \t      break;"}, {"sha": "f63c4f5b8bb885464b66286d9a2de012c506bd8a", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "patch": "@@ -453,6 +453,7 @@ extern void cp_emit_debug_info_for_using (tree, tree);\n \n extern void finish_nonmember_using_decl (tree scope, tree name);\n extern void finish_using_directive (tree target, tree attribs);\n+void push_local_extern_decl_alias (tree decl);\n extern tree pushdecl (tree, bool hiding = false);\n extern tree pushdecl_outermost_localscope (tree);\n extern tree pushdecl_top_level (tree);"}, {"sha": "b1f0a711672825de63b2ec14007def0751926373", "filename": "gcc/testsuite/g++.target/i386/pr99108.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr99108.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr99108.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr99108.C?ref=1c7bec8bfbc5457c1b57d0e3b67f5d6bc8812e57", "patch": "@@ -0,0 +1,19 @@\n+/* PR c++/99108 */\n+/* { dg-require-ifunc \"\" }  */\n+\n+struct A {\n+  template <class T>\n+  void foo(T);\n+};\n+template <class T>\n+void A::foo(T)\n+{\n+  int f(void) __attribute__((target(\"default\")));\n+  int f(void) __attribute__((target(\"arch=atom\")));\n+  int b = f();\n+}\n+void bar(void)\n+{\n+  A c;\n+  c.foo(7);\n+}"}]}