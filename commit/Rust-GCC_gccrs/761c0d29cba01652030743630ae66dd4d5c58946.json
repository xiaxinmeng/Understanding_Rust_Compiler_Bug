{"sha": "761c0d29cba01652030743630ae66dd4d5c58946", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYxYzBkMjljYmEwMTY1MjAzMDc0MzYzMGFlNjZkZDRkNWM1ODk0Ng==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2005-12-12T05:47:52Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2005-12-12T05:47:52Z"}, "message": "re PR libobjc/25354 (There should be an automated testsuite for objc_sizeof_type and objc_alignof_type)\n\n2005-12-12  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        PR libobjc/25354\n        * objc.dg/gnu-encoding: New directory.\n        * objc.dg/gnu-encoding/compat-common.h: New file.\n        * objc.dg/gnu-encoding/struct-layout-1.h: New file.\n        * objc.dg/gnu-encoding/struct-layout-1_test.h: New file.\n        * objc.dg/gnu-encoding/vector-defs.h: New file.\n        * objc.dg/gnu-encoding/gnu-encoding.exp: New file.\n        * objc.dg/gnu-encoding/generate-random.c: New file.\n        * objc.dg/gnu-encoding/generate-random_r.c: New file.\n        * objc.dg/gnu-encoding/struct-layout-encoding-1_generate.c: New file.\n        * objc.dg/gnu-encoding/generate-random.h: New file.\n\n\n2005-12-12  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        * encoding.c (TYPE_FIELDS): Fix to skip over just _C_STRUCT_B and        the name.\n        (get_inner_array_type): Fix to skip over _C_ARY_B and size.\n        (rs6000_special_round_type_align): Update for the ABI fix.\n        (objc_layout_finish_structure): Correct the encoding which is passed to\n        ROUND_TYPE_ALIGN.\n\nFrom-SVN: r108398", "tree": {"sha": "cad2815889ab8ddb6c0aa7e2b53c6ff52d21b597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cad2815889ab8ddb6c0aa7e2b53c6ff52d21b597"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/761c0d29cba01652030743630ae66dd4d5c58946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761c0d29cba01652030743630ae66dd4d5c58946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/761c0d29cba01652030743630ae66dd4d5c58946", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761c0d29cba01652030743630ae66dd4d5c58946/comments", "author": null, "committer": null, "parents": [{"sha": "3897c0aae8cdd410c306f775e424fd32fd918257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3897c0aae8cdd410c306f775e424fd32fd918257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3897c0aae8cdd410c306f775e424fd32fd918257"}], "stats": {"total": 3571, "additions": 3564, "deletions": 7}, "files": [{"sha": "bdade3ec6f609c395bb72ec8330313b3868e6f73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -1,3 +1,17 @@\n+2005-12-12  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR libobjc/25354\n+\t* objc.dg/gnu-encoding: New directory.\n+\t* objc.dg/gnu-encoding/compat-common.h: New file.\n+\t* objc.dg/gnu-encoding/struct-layout-1.h: New file.\n+\t* objc.dg/gnu-encoding/struct-layout-1_test.h: New file.\n+\t* objc.dg/gnu-encoding/vector-defs.h: New file.\n+\t* objc.dg/gnu-encoding/gnu-encoding.exp: New file.\n+\t* objc.dg/gnu-encoding/generate-random.c: New file.\n+\t* objc.dg/gnu-encoding/generate-random_r.c: New file.\n+\t* objc.dg/gnu-encoding/struct-layout-encoding-1_generate.c: New file.\n+\t* objc.dg/gnu-encoding/generate-random.h: New file.\n+\n 2005-12-11  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/25337"}, {"sha": "635e7446d7600ed02c6c222c11689f72026e953b", "filename": "gcc/testsuite/objc.dg/gnu-encoding/compat-common.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fcompat-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fcompat-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fcompat-common.h?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,43 @@\n+/*  Several of the binary compatibility tests use these macros to\n+    allow debugging the test or tracking down a failure by getting an\n+    indication of whether each individual check passed or failed.\n+    When DBG is defined, each check is shown by a dot (pass) or 'F'\n+    (fail) rather than aborting as soon as a failure is detected.  */\n+ \n+#ifdef DBG\n+#include <stdio.h>\n+#define DEBUG_INIT setbuf (stdout, NULL);\n+#define DEBUG_FPUTS(x) fputs (x, stdout)\n+#define DEBUG_DOT putc ('.', stdout)\n+#define DEBUG_NL putc ('\\n', stdout)\n+#define DEBUG_FAIL putc ('F', stdout); fails++\n+#define DEBUG_CHECK { DEBUG_FAIL; } else { DEBUG_DOT; }\n+#define DEBUG_FINI if (fails) DEBUG_FPUTS (\"failed\\n\"); \\\n+\t\t   else DEBUG_FPUTS (\"passed\\n\");\n+#else\n+#define DEBUG_INIT\n+#define DEBUG_FPUTS(x)\n+#define DEBUG_DOT\n+#define DEBUG_NL\n+#define DEBUG_FAIL abort ()\n+#define DEBUG_CHECK abort ();\n+#define DEBUG_FINI\n+#endif\n+\n+#ifdef __GNUC__\n+#define CINT(x, y) (x + y * __extension__ 1i)\n+#define CDBL(x, y) (x + y * __extension__ 1i)\n+#else\n+#ifdef __SUNPRO_C\n+/* ??? Complex support without <complex.h>.  */\n+#else\n+#include <complex.h>\n+#endif\n+#ifndef SKIP_COMPLEX_INT\n+#define CINT(x, y) ((_Complex int) (x + y * _Complex_I))\n+#endif\n+#define CDBL(x, y) (x + y * _Complex_I)\n+#endif\n+\n+extern void abort (void);\n+extern int fails;"}, {"sha": "c4b06db675ffbe9e03cb981cb5db0d84fc918b99", "filename": "gcc/testsuite/objc.dg/gnu-encoding/generate-random.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random.c?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,265 @@\n+/* Copyright (C) 1995, 2004 Free Software Foundation\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301 USA.  */\n+\n+/*\n+ * This is derived from the Berkeley source:\n+ *\t@(#)random.c\t5.5 (Berkeley) 7/6/88\n+ * It was reworked for the GNU C Library by Roland McGrath.\n+ * Rewritten to use reentrant functions by Ulrich Drepper, 1995.\n+ */\n+\n+/*\n+   Copyright (C) 1983 Regents of the University of California.\n+   All rights reserved.\n+ \n+   Redistribution and use in source and binary forms, with or without\n+   modification, are permitted provided that the following conditions\n+   are met:\n+\n+   1. Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+   2. Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+   4. Neither the name of the University nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+   \n+   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+   SUCH DAMAGE.*/\n+\n+#include <limits.h>\n+#include <stdlib.h>\n+#include \"generate-random.h\"\n+\n+\n+/* An improved random number generation package.  In addition to the standard\n+   rand()/srand() like interface, this package also has a special state info\n+   interface.  The initstate() routine is called with a seed, an array of\n+   bytes, and a count of how many bytes are being passed in; this array is\n+   then initialized to contain information for random number generation with\n+   that much state information.  Good sizes for the amount of state\n+   information are 32, 64, 128, and 256 bytes.  The state can be switched by\n+   calling the setstate() function with the same array as was initialized\n+   with initstate().  By default, the package runs with 128 bytes of state\n+   information and generates far better random numbers than a linear\n+   congruential generator.  If the amount of state information is less than\n+   32 bytes, a simple linear congruential R.N.G. is used.  Internally, the\n+   state information is treated as an array of longs; the zeroth element of\n+   the array is the type of R.N.G. being used (small integer); the remainder\n+   of the array is the state information for the R.N.G.  Thus, 32 bytes of\n+   state information will give 7 longs worth of state information, which will\n+   allow a degree seven polynomial.  (Note: The zeroth word of state\n+   information also has some other information stored in it; see setstate\n+   for details).  The random number generation technique is a linear feedback\n+   shift register approach, employing trinomials (since there are fewer terms\n+   to sum up that way).  In this approach, the least significant bit of all\n+   the numbers in the state table will act as a linear feedback shift register,\n+   and will have period 2^deg - 1 (where deg is the degree of the polynomial\n+   being used, assuming that the polynomial is irreducible and primitive).\n+   The higher order bits will have longer periods, since their values are\n+   also influenced by pseudo-random carries out of the lower bits.  The\n+   total period of the generator is approximately deg*(2**deg - 1); thus\n+   doubling the amount of state information has a vast influence on the\n+   period of the generator.  Note: The deg*(2**deg - 1) is an approximation\n+   only good for large deg, when the period of the shift register is the\n+   dominant factor.  With deg equal to seven, the period is actually much\n+   longer than the 7*(2**7 - 1) predicted by this formula.  */\n+\n+\n+\n+/* For each of the currently supported random number generators, we have a\n+   break value on the amount of state information (you need at least this many\n+   bytes of state info to support this random number generator), a degree for\n+   the polynomial (actually a trinomial) that the R.N.G. is based on, and\n+   separation between the two lower order coefficients of the trinomial.  */\n+\n+/* Linear congruential.  */\n+#define\tTYPE_0\t\t0\n+#define\tBREAK_0\t\t8\n+#define\tDEG_0\t\t0\n+#define\tSEP_0\t\t0\n+\n+/* x**7 + x**3 + 1.  */\n+#define\tTYPE_1\t\t1\n+#define\tBREAK_1\t\t32\n+#define\tDEG_1\t\t7\n+#define\tSEP_1\t\t3\n+\n+/* x**15 + x + 1.  */\n+#define\tTYPE_2\t\t2\n+#define\tBREAK_2\t\t64\n+#define\tDEG_2\t\t15\n+#define\tSEP_2\t\t1\n+\n+/* x**31 + x**3 + 1.  */\n+#define\tTYPE_3\t\t3\n+#define\tBREAK_3\t\t128\n+#define\tDEG_3\t\t31\n+#define\tSEP_3\t\t3\n+\n+/* x**63 + x + 1.  */\n+#define\tTYPE_4\t\t4\n+#define\tBREAK_4\t\t256\n+#define\tDEG_4\t\t63\n+#define\tSEP_4\t\t1\n+\n+\n+/* Array versions of the above information to make code run faster.\n+   Relies on fact that TYPE_i == i.  */\n+\n+#define\tMAX_TYPES\t5\t/* Max number of types above.  */\n+\n+\n+/* Initially, everything is set up as if from:\n+\tinitstate(1, randtbl, 128);\n+   Note that this initialization takes advantage of the fact that srandom\n+   advances the front and rear pointers 10*rand_deg times, and hence the\n+   rear pointer which starts at 0 will also end up at zero; thus the zeroth\n+   element of the state information, which contains info about the current\n+   position of the rear pointer is just\n+\t(MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.  */\n+\n+static int randtbl[DEG_3 + 1] =\n+  {\n+    TYPE_3,\n+\n+    -1726662223, 379960547, 1735697613, 1040273694, 1313901226,\n+    1627687941, -179304937, -2073333483, 1780058412, -1989503057,\n+    -615974602, 344556628, 939512070, -1249116260, 1507946756,\n+    -812545463, 154635395, 1388815473, -1926676823, 525320961,\n+    -1009028674, 968117788, -123449607, 1284210865, 435012392,\n+    -2017506339, -911064859, -370259173, 1132637927, 1398500161,\n+    -205601318,\n+  };\n+\n+\n+static struct generate_random_data unsafe_state =\n+  {\n+/* FPTR and RPTR are two pointers into the state info, a front and a rear\n+   pointer.  These two pointers are always rand_sep places aparts, as they\n+   cycle through the state information.  (Yes, this does mean we could get\n+   away with just one pointer, but the code for random is more efficient\n+   this way).  The pointers are left positioned as they would be from the call:\n+\tinitstate(1, randtbl, 128);\n+   (The position of the rear pointer, rptr, is really 0 (as explained above\n+   in the initialization of randtbl) because the state table pointer is set\n+   to point to randtbl[1] (as explained below).)  */\n+\n+   &randtbl[SEP_3 + 1],  /* fptr */\n+   &randtbl[1],          /* rptr */\n+\n+/* The following things are the pointer to the state information table,\n+   the type of the current generator, the degree of the current polynomial\n+   being used, and the separation between the two pointers.\n+   Note that for efficiency of random, we remember the first location of\n+   the state information, not the zeroth.  Hence it is valid to access\n+   state[-1], which is used to store the type of the R.N.G.\n+   Also, we remember the last location, since this is more efficient than\n+   indexing every time to find the address of the last element to see if\n+   the front and rear pointers have wrapped.  */\n+\n+    &randtbl[1],  /* state */\n+\n+    TYPE_3,  /* rand_type */\n+    DEG_3,   /* rand_deg */\n+    SEP_3,   /* rand_sep */\n+\n+    &randtbl[sizeof (randtbl) / sizeof (randtbl[0])]  /* end_ptr */\n+};\n+\f\n+/* Initialize the random number generator based on the given seed.  If the\n+   type is the trivial no-state-information type, just remember the seed.\n+   Otherwise, initializes state[] based on the given \"seed\" via a linear\n+   congruential generator.  Then, the pointers are set to known locations\n+   that are exactly rand_sep places apart.  Lastly, it cycles the state\n+   information a given number of times to get rid of any initial dependencies\n+   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]\n+   for default usage relies on values produced by this routine.  */\n+void\n+generate_srandom (unsigned int x)\n+{\n+  (void) generate_srandom_r (x, &unsafe_state);\n+}\n+\f\n+/* Initialize the state information in the given array of N bytes for\n+   future random number generation.  Based on the number of bytes we\n+   are given, and the break values for the different R.N.G.'s, we choose\n+   the best (largest) one we can and set things up for it.  srandom is\n+   then called to initialize the state information.  Note that on return\n+   from srandom, we set state[-1] to be the type multiplexed with the current\n+   value of the rear pointer; this is so successive calls to initstate won't\n+   lose this information and will be able to restart with setstate.\n+   Note: The first thing we do is save the current state, if any, just like\n+   setstate so that it doesn't matter when initstate is called.\n+   Returns a pointer to the old state.  */\n+char *\n+generate_initstate (unsigned int seed, char *arg_state, size_t n)\n+{\n+  int *ostate;\n+\n+  ostate = &unsafe_state.state[-1];\n+  generate_initstate_r (seed, arg_state, n, &unsafe_state);\n+  return (char *) ostate;\n+}\n+\f\n+/* Restore the state from the given state array.\n+   Note: It is important that we also remember the locations of the pointers\n+   in the current state information, and restore the locations of the pointers\n+   from the old state information.  This is done by multiplexing the pointer\n+   location into the zeroth word of the state information. Note that due\n+   to the order in which things are done, it is OK to call setstate with the\n+   same state as the current state\n+   Returns a pointer to the old state information.  */\n+char *\n+generate_setstate (char *arg_state)\n+{\n+  int *ostate;\n+\n+  ostate = &unsafe_state.state[-1];\n+  if (generate_setstate_r (arg_state, &unsafe_state) < 0)\n+    ostate = NULL;\n+  return (char *) ostate;\n+}\n+\f\n+/* If we are using the trivial TYPE_0 R.N.G., just do the old linear\n+   congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the\n+   same in all the other cases due to all the global variables that have been\n+   set up.  The basic operation is to add the number at the rear pointer into\n+   the one at the front pointer.  Then both pointers are advanced to the next\n+   location cyclically in the table.  The value returned is the sum generated,\n+   reduced to 31 bits by throwing away the \"least random\" low bit.\n+   Note: The code takes advantage of the fact that both the front and\n+   rear pointers can't wrap on the same call by not testing the rear\n+   pointer if the front one has wrapped.  Returns a 31-bit random number.  */\n+\n+long int\n+generate_random (void)\n+{\n+  int retval;\n+  (void) generate_random_r (&unsafe_state, &retval);\n+  return retval;\n+}"}, {"sha": "e14f526bb956d76eedddcb37c03913b87b0a01cd", "filename": "gcc/testsuite/objc.dg/gnu-encoding/generate-random.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random.h?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2004 Free Software Foundation\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301 USA.  */\n+\n+struct generate_random_data\n+  {\n+    int *fptr, *rptr, *state;\n+    int rand_type, rand_deg, rand_sep;\n+    int *end_ptr;\n+  };\n+\n+extern void generate_srandom (unsigned int);\n+extern char *generate_initstate (unsigned int, char *, size_t);\n+extern char *generate_setstate (char *);\n+extern long int generate_random (void);\n+extern int generate_random_r (struct generate_random_data *, int *);\n+extern int generate_srandom_r (unsigned int, struct generate_random_data *);\n+extern int generate_initstate_r (unsigned int, char *, size_t,\n+\t\t\t\t struct generate_random_data *);\n+extern int generate_setstate_r (char *, struct generate_random_data *);"}, {"sha": "6e83f3596df4045b4ae3ed20cc7bec125c762f93", "filename": "gcc/testsuite/objc.dg/gnu-encoding/generate-random_r.c", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random_r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random_r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgenerate-random_r.c?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,385 @@\n+/* \n+   Copyright (C) 1995, 2004 Free Software Foundation\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301 USA.  */\n+\n+/*\n+   Copyright (C) 1983 Regents of the University of California.\n+   All rights reserved.\n+\n+   Redistribution and use in source and binary forms, with or without\n+   modification, are permitted provided that the following conditions\n+   are met:\n+\n+   1. Redistributions of source code must retain the above copyright\n+      notice, this list of conditions and the following disclaimer.\n+   2. Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+   4. Neither the name of the University nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+   \n+   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+   SUCH DAMAGE.*/\n+\n+/*\n+ * This is derived from the Berkeley source:\n+ *\t@(#)random.c\t5.5 (Berkeley) 7/6/88\n+ * It was reworked for the GNU C Library by Roland McGrath.\n+ * Rewritten to be reentrant by Ulrich Drepper, 1995\n+ */\n+\n+#include <limits.h>\n+#include <stdlib.h>\n+#include \"generate-random.h\"\n+\n+\n+/* An improved random number generation package.  In addition to the standard\n+   rand()/srand() like interface, this package also has a special state info\n+   interface.  The initstate() routine is called with a seed, an array of\n+   bytes, and a count of how many bytes are being passed in; this array is\n+   then initialized to contain information for random number generation with\n+   that much state information.  Good sizes for the amount of state\n+   information are 32, 64, 128, and 256 bytes.  The state can be switched by\n+   calling the setstate() function with the same array as was initialized\n+   with initstate().  By default, the package runs with 128 bytes of state\n+   information and generates far better random numbers than a linear\n+   congruential generator.  If the amount of state information is less than\n+   32 bytes, a simple linear congruential R.N.G. is used.  Internally, the\n+   state information is treated as an array of longs; the zeroth element of\n+   the array is the type of R.N.G. being used (small integer); the remainder\n+   of the array is the state information for the R.N.G.  Thus, 32 bytes of\n+   state information will give 7 longs worth of state information, which will\n+   allow a degree seven polynomial.  (Note: The zeroth word of state\n+   information also has some other information stored in it; see setstate\n+   for details).  The random number generation technique is a linear feedback\n+   shift register approach, employing trinomials (since there are fewer terms\n+   to sum up that way).  In this approach, the least significant bit of all\n+   the numbers in the state table will act as a linear feedback shift register,\n+   and will have period 2^deg - 1 (where deg is the degree of the polynomial\n+   being used, assuming that the polynomial is irreducible and primitive).\n+   The higher order bits will have longer periods, since their values are\n+   also influenced by pseudo-random carries out of the lower bits.  The\n+   total period of the generator is approximately deg*(2**deg - 1); thus\n+   doubling the amount of state information has a vast influence on the\n+   period of the generator.  Note: The deg*(2**deg - 1) is an approximation\n+   only good for large deg, when the period of the shift register is the\n+   dominant factor.  With deg equal to seven, the period is actually much\n+   longer than the 7*(2**7 - 1) predicted by this formula.  */\n+\n+\n+\n+/* For each of the currently supported random number generators, we have a\n+   break value on the amount of state information (you need at least this many\n+   bytes of state info to support this random number generator), a degree for\n+   the polynomial (actually a trinomial) that the R.N.G. is based on, and\n+   separation between the two lower order coefficients of the trinomial.  */\n+\n+/* Linear congruential.  */\n+#define\tTYPE_0\t\t0\n+#define\tBREAK_0\t\t8\n+#define\tDEG_0\t\t0\n+#define\tSEP_0\t\t0\n+\n+/* x**7 + x**3 + 1.  */\n+#define\tTYPE_1\t\t1\n+#define\tBREAK_1\t\t32\n+#define\tDEG_1\t\t7\n+#define\tSEP_1\t\t3\n+\n+/* x**15 + x + 1.  */\n+#define\tTYPE_2\t\t2\n+#define\tBREAK_2\t\t64\n+#define\tDEG_2\t\t15\n+#define\tSEP_2\t\t1\n+\n+/* x**31 + x**3 + 1.  */\n+#define\tTYPE_3\t\t3\n+#define\tBREAK_3\t\t128\n+#define\tDEG_3\t\t31\n+#define\tSEP_3\t\t3\n+\n+/* x**63 + x + 1.  */\n+#define\tTYPE_4\t\t4\n+#define\tBREAK_4\t\t256\n+#define\tDEG_4\t\t63\n+#define\tSEP_4\t\t1\n+\n+\n+/* Array versions of the above information to make code run faster.\n+   Relies on fact that TYPE_i == i.  */\n+\n+#define\tMAX_TYPES\t5\t/* Max number of types above.  */\n+\n+struct random_poly_info\n+{\n+  int seps[MAX_TYPES];\n+  int degrees[MAX_TYPES];\n+};\n+\n+static const struct random_poly_info random_poly_info =\n+{\n+  { SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 },\n+  { DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 }\n+};\n+\n+\n+\n+\f\n+/* Initialize the random number generator based on the given seed.  If the\n+   type is the trivial no-state-information type, just remember the seed.\n+   Otherwise, initializes state[] based on the given \"seed\" via a linear\n+   congruential generator.  Then, the pointers are set to known locations\n+   that are exactly rand_sep places apart.  Lastly, it cycles the state\n+   information a given number of times to get rid of any initial dependencies\n+   introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]\n+   for default usage relies on values produced by this routine.  */\n+int\n+generate_srandom_r (unsigned int seed, struct generate_random_data *buf)\n+{\n+  int type;\n+  int *state;\n+  long int i;\n+  long int word;\n+  int *dst;\n+  int kc;\n+\n+  if (buf == NULL)\n+    goto fail;\n+  type = buf->rand_type;\n+  if ((unsigned int) type >= MAX_TYPES)\n+    goto fail;\n+\n+  state = buf->state;\n+  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */\n+  if (seed == 0)\n+    seed = 1;\n+  state[0] = seed;\n+  if (type == TYPE_0)\n+    goto done;\n+\n+  dst = state;\n+  word = seed;\n+  kc = buf->rand_deg;\n+  for (i = 1; i < kc; ++i)\n+    {\n+      /* This does:\n+\t   state[i] = (16807 * state[i - 1]) % 2147483647;\n+\t but avoids overflowing 31 bits.  */\n+      long int hi = word / 127773;\n+      long int lo = word % 127773;\n+      word = 16807 * lo - 2836 * hi;\n+      if (word < 0)\n+\tword += 2147483647;\n+      *++dst = word;\n+    }\n+\n+  buf->fptr = &state[buf->rand_sep];\n+  buf->rptr = &state[0];\n+  kc *= 10;\n+  while (--kc >= 0)\n+    {\n+      int discard;\n+      (void) generate_random_r (buf, &discard);\n+    }\n+\n+ done:\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}\n+\f\n+/* Initialize the state information in the given array of N bytes for\n+   future random number generation.  Based on the number of bytes we\n+   are given, and the break values for the different R.N.G.'s, we choose\n+   the best (largest) one we can and set things up for it.  srandom is\n+   then called to initialize the state information.  Note that on return\n+   from srandom, we set state[-1] to be the type multiplexed with the current\n+   value of the rear pointer; this is so successive calls to initstate won't\n+   lose this information and will be able to restart with setstate.\n+   Note: The first thing we do is save the current state, if any, just like\n+   setstate so that it doesn't matter when initstate is called.\n+   Returns a pointer to the old state.  */\n+int\n+generate_initstate_r (unsigned int seed, char *arg_state, size_t n,\n+\t\t      struct generate_random_data *buf)\n+{\n+  int type;\n+  int degree;\n+  int separation;\n+  int *state;\n+\n+  if (buf == NULL)\n+    goto fail;\n+\n+  if (n >= BREAK_3)\n+    type = n < BREAK_4 ? TYPE_3 : TYPE_4;\n+  else if (n < BREAK_1)\n+    {\n+      if (n < BREAK_0)\n+\t{\n+\t  goto fail;\n+\t}\n+      type = TYPE_0;\n+    }\n+  else\n+    type = n < BREAK_2 ? TYPE_1 : TYPE_2;\n+\n+  degree = random_poly_info.degrees[type];\n+  separation = random_poly_info.seps[type];\n+\n+  buf->rand_type = type;\n+  buf->rand_sep = separation;\n+  buf->rand_deg = degree;\n+  state = &((int *) arg_state)[1];\t/* First location.  */\n+  /* Must set END_PTR before srandom.  */\n+  buf->end_ptr = &state[degree];\n+\n+  buf->state = state;\n+\n+  generate_srandom_r (seed, buf);\n+\n+  state[-1] = TYPE_0;\n+  if (type != TYPE_0)\n+    state[-1] = (buf->rptr - state) * MAX_TYPES + type;\n+\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}\n+\f\n+/* Restore the state from the given state array.\n+   Note: It is important that we also remember the locations of the pointers\n+   in the current state information, and restore the locations of the pointers\n+   from the old state information.  This is done by multiplexing the pointer\n+   location into the zeroth word of the state information. Note that due\n+   to the order in which things are done, it is OK to call setstate with the\n+   same state as the current state\n+   Returns a pointer to the old state information.  */\n+int\n+generate_setstate_r (char *arg_state, struct generate_random_data *buf)\n+{\n+  int *new_state = 1 + (int *) arg_state;\n+  int type;\n+  int old_type;\n+  int *old_state;\n+  int degree;\n+  int separation;\n+\n+  if (arg_state == NULL || buf == NULL)\n+    goto fail;\n+\n+  old_type = buf->rand_type;\n+  old_state = buf->state;\n+  if (old_type == TYPE_0)\n+    old_state[-1] = TYPE_0;\n+  else\n+    old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;\n+\n+  type = new_state[-1] % MAX_TYPES;\n+  if (type < TYPE_0 || type > TYPE_4)\n+    goto fail;\n+\n+  buf->rand_deg = degree = random_poly_info.degrees[type];\n+  buf->rand_sep = separation = random_poly_info.seps[type];\n+  buf->rand_type = type;\n+\n+  if (type != TYPE_0)\n+    {\n+      int rear = new_state[-1] / MAX_TYPES;\n+      buf->rptr = &new_state[rear];\n+      buf->fptr = &new_state[(rear + separation) % degree];\n+    }\n+  buf->state = new_state;\n+  /* Set end_ptr too.  */\n+  buf->end_ptr = &new_state[degree];\n+\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}\n+\f\n+/* If we are using the trivial TYPE_0 R.N.G., just do the old linear\n+   congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the\n+   same in all the other cases due to all the global variables that have been\n+   set up.  The basic operation is to add the number at the rear pointer into\n+   the one at the front pointer.  Then both pointers are advanced to the next\n+   location cyclically in the table.  The value returned is the sum generated,\n+   reduced to 31 bits by throwing away the \"least random\" low bit.\n+   Note: The code takes advantage of the fact that both the front and\n+   rear pointers can't wrap on the same call by not testing the rear\n+   pointer if the front one has wrapped.  Returns a 31-bit random number.  */\n+\n+int\n+generate_random_r (struct generate_random_data *buf, int *result)\n+{\n+  int *state;\n+\n+  if (buf == NULL || result == NULL)\n+    goto fail;\n+\n+  state = buf->state;\n+\n+  if (buf->rand_type == TYPE_0)\n+    {\n+      int val = state[0];\n+      val = ((state[0] * 1103515245) + 12345) & 0x7fffffff;\n+      state[0] = val;\n+      *result = val;\n+    }\n+  else\n+    {\n+      int *fptr = buf->fptr;\n+      int *rptr = buf->rptr;\n+      int *end_ptr = buf->end_ptr;\n+      int val;\n+\n+      val = *fptr += *rptr;\n+      /* Chucking least random bit.  */\n+      *result = (val >> 1) & 0x7fffffff;\n+      ++fptr;\n+      if (fptr >= end_ptr)\n+\t{\n+\t  fptr = state;\n+\t  ++rptr;\n+\t}\n+      else\n+\t{\n+\t  ++rptr;\n+\t  if (rptr >= end_ptr)\n+\t    rptr = state;\n+\t}\n+      buf->fptr = fptr;\n+      buf->rptr = rptr;\n+    }\n+  return 0;\n+\n+ fail:\n+  return -1;\n+}"}, {"sha": "f1cd252a0ec55716bfdb30727f0d522e38c855c7", "filename": "gcc/testsuite/objc.dg/gnu-encoding/gnu-encoding.exp", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgnu-encoding.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgnu-encoding.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fgnu-encoding.exp?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,73 @@\n+# GCC Objective-C testsuite that uses the `dg.exp' driver.\n+#   Copyright (C) 1997, 2001 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# Load support procs.\n+load_lib objc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \"-fgnu-runtime\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+#\n+# gnu-encoding tests\n+#\n+set tstobjdir \"$tmpdir/objc.dg-struct-layout-encoding-1\"\n+set generator \"$tmpdir/objc.dg-struct-layout-encoding-1_generate\"\n+\n+set generator_src \"$srcdir/$subdir/struct-layout-encoding-1_generate.c\"\n+set generator_src \"$generator_src $srcdir/$subdir/generate-random.c\"\n+set generator_src \"$generator_src $srcdir/$subdir/generate-random_r.c\"\n+set generator_cmd \"-o $generator $generator_src\"\n+set status [remote_exec host \"$HOSTCC $HOSTCFLAGS $generator_cmd\"]\n+set status [lindex $status 0]\n+if { $status == 0 } then {\n+    file delete -force $tstobjdir\n+    file mkdir $tstobjdir\n+    set generator_args \"-s $srcdir/$subdir -d $tstobjdir\"\n+#    set generator_args \"$generator_args -n 15000\"\n+    set status [remote_exec host \"$generator $generator_args\"]\n+    set status [lindex $status 0]\n+    if { $status == 0 } then {\n+        foreach src [lsort [find $tstobjdir *_main.m]] {\n+            # If we're only testing specific files and this isn't one\n+            # of them, skip it.\n+            if ![runtest_file_p $runtests $src] then {\n+                continue\n+            }\n+\n+            dg-runtest $src \"\" $DEFAULT_CFLAGS\n+        }\n+    } else {\n+        warning \"Could not execute objc.dg/gnu-encoding/struct-layout-encoding-1 generator\"\n+    }\n+} else {\n+    warning \"Could not compile objc.dg/gnu-encoding/struct-layout-encoding-1 generator\"\n+}\n+\n+\n+\n+\n+\n+\n+# All done.\n+dg-finish\n+"}, {"sha": "e165e203a32609a6ac4f7682912f02712216fb91", "filename": "gcc/testsuite/objc.dg/gnu-encoding/struct-layout-1.h", "status": "added", "additions": 704, "deletions": 0, "changes": 704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-1.h?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,704 @@\n+#include <limits.h>\n+#include <stdarg.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"compat-common.h\"\n+\n+#ifndef SKIP_ATTRIBUTE\n+# include \"vector-defs.h\"\n+#else\n+typedef int qi;\n+typedef int hi;\n+typedef int si;\n+typedef int di;\n+typedef float sf;\n+typedef float df;\n+typedef int v8qi;\n+typedef int v16qi;\n+typedef int v2hi;\n+typedef int v4hi;\n+typedef int v8hi;\n+typedef int v2si;\n+typedef int v4si;\n+typedef int v1di;\n+typedef int v2di;\n+typedef int v2sf;\n+typedef int v4sf;\n+typedef int v16sf;\n+typedef int v2df;\n+typedef int u8qi;\n+typedef int u16qi;\n+typedef int u2hi;\n+typedef int u4hi;\n+typedef int u8hi;\n+typedef int u2si;\n+typedef int u4si;\n+typedef int u1di;\n+typedef int u2di;\n+typedef int u2sf;\n+typedef int u4sf;\n+typedef int u16sf;\n+typedef int u2df;\n+#endif\n+#if (defined __i386__ || defined __x86_64__) && !defined SKIP_ATTRIBUTE\n+# ifdef __MMX__\n+#  include <mmintrin.h>\n+# else\n+typedef int __m64;\n+# endif\n+# ifdef __SSE__\n+#  include <xmmintrin.h>\n+# else\n+typedef int __m128;\n+# endif\n+#else\n+typedef int __m64;\n+typedef int __m128;\n+#endif\n+\n+#define FLDS_MAX\t32\n+extern struct Info\n+{\n+  int nfields, nbitfields;\n+  void *sp, *a0p, *a3p;\n+  void *flds[FLDS_MAX];\n+  size_t sz, sizes[FLDS_MAX];\n+  size_t als, ala0, ala3, aligns[FLDS_MAX];\n+} info;\n+\n+extern int intarray[256];\n+extern int fn0 (void), fn1 (void), fn2 (void), fn3 (void), fn4 (void);\n+extern int fn5 (void), fn6 (void), fn7 (void), fn8 (void), fn9 (void);\n+\n+#ifdef DBG\n+#define FAIL(n, m) printf (\"fail %d.%d\\n\", n, m), ++fails\n+#else\n+#define FAIL(n, m) ++fails\n+#endif\n+\n+#ifdef SKIP_ATTRIBUTE\n+# define __attribute__(x)\n+#endif\n+#define atal\t\t__attribute__((aligned))\n+#define atpa\t\t__attribute__((packed))\n+#define atalpa\t\t__attribute__((aligned, packed))\n+#define atpaal\t\t__attribute__((packed, aligned))\n+#define atal1\t\t__attribute__((aligned (1)))\n+#define atal2\t\t__attribute__((aligned (2)))\n+#define atal4\t\t__attribute__((aligned (4)))\n+#define atal8\t\t__attribute__((aligned (8)))\n+#define atal16\t\t__attribute__((aligned (16)))\n+#define atal1pa\t\t__attribute__((aligned (1), packed))\n+#define atal2pa\t\t__attribute__((aligned (2), packed))\n+#define atal4pa\t\t__attribute__((aligned (4), packed))\n+#define atal8pa\t\t__attribute__((aligned (8), packed))\n+#define atal16pa\t__attribute__((aligned (16), packed))\n+#define atpaal1\t\t__attribute__((packed, aligned (1)))\n+#define atpaal2\t\t__attribute__((packed, aligned (2)))\n+#define atpaal4\t\t__attribute__((packed, aligned (4)))\n+#define atpaal8\t\t__attribute__((packed, aligned (8)))\n+#define atpaal16\t__attribute__((packed, aligned (16)))\n+\n+#if UCHAR_MAX == 255 && USHORT_MAX == 65535 && UINT_MAX == 4294967295U \\\n+    && ULLONG_MAX == 18446744073709551615ULL\n+/* For ILP32 and LP64 targets, assume float is at least 32-bit\n+   and double plus long double at least 64-bit.  */\n+# define atalx1\t\tatal1\n+# define atalx2\t\tatal2\n+# define atalx4\t\tatal4\n+# define atalx8\t\tatal8\n+# define atalx16\tatal16\n+# define atalx1pa\tatal1pa\n+# define atalx2pa\tatal2pa\n+# define atalx4pa\tatal4pa\n+# define atalx8pa\tatal8pa\n+# define atalx16pa\tatal16pa\n+# define atpaalx1\tatpaal1\n+# define atpaalx2\tatpaal2\n+# define atpaalx4\tatpaal4\n+# define atpaalx8\tatpaal8\n+# define atpaalx16\tatpaal16\n+# if ULONG_MAX > 4294967295UL\n+#  define ataly8\tatal8\n+#  define ataly8pa\tatal8pa\n+#  define atpaaly8\tatpaal8\n+#  define ataly16\tatal16\n+#  define ataly16pa\tatal16pa\n+#  define atpaaly16\tatpaal16\n+# else\n+#  define ataly8\n+#  define ataly8pa\n+#  define atpaaly8\n+#  define ataly16\n+#  define ataly16pa\n+#  define atpaaly16\n+# endif\n+#else\n+# define atalx1\n+# define atalx2\n+# define atalx4\n+# define atalx8\n+# define atalx16\n+# define atalx1pa\n+# define atalx2pa\n+# define atalx4pa\n+# define atalx8pa\n+# define atalx16pa\n+# define atpaalx1\n+# define atpaalx2\n+# define atpaalx4\n+# define atpaalx8\n+# define atpaalx16\n+# define ataly8\n+# define ataly8pa\n+# define atpaaly8\n+# define ataly16\n+# define ataly16pa\n+# define atpaaly16\n+#endif\n+\n+#define atQI\t\t__attribute__((mode (QI)))\n+#define atHI\t\t__attribute__((mode (HI)))\n+#define atSI\t\t__attribute__((mode (SI)))\n+#define atDI\t\t__attribute__((mode (DI)))\n+\n+enum E0 { e0_0 };\n+enum E1 { e1_0, e1_1 };\n+enum E2 { e2_m3 = -3, e2_m2, e2_m1, e2_0, e2_1, e2_2, e2_3 };\n+enum E3 { e3_m127 = -127, e3_m126, e3_m125, e3_0 = 0, e3_125 = 125, e3_126, e3_127 };\n+enum E4 { e4_0, e4_1, e4_2, e4_3, e4_253 = 253, e4_254, e4_255 };\n+enum E5 { e5_m32767 = -32767, e5_m32766, e5_m32765, e5_0 = 0, e5_32765 = 32765, e5_32766, e5_32767 };\n+enum E6 { e6_0, e6_1, e6_2, e6_3, e6_65533 = 65533, e6_65534, e6_65535 };\n+enum E7 { e7_m2147483647 = -2147483647, e7_m2147483646, e7_m2147483645,\n+\t  e7_0, e7_2147483645 = 2147483645, e7_2147483646, e7_2147483647 };\n+enum E8 { e8_0, e8_1, e8_2, e8_3, e8_4294967293 = 4294967293U, e8_4294967294, e8_4294967295 };\n+enum E9 { e9_m1099511627775 = -1099511627775LL, e9_m1099511627774, e9_m1099511627773,\n+\t  e9_0, e9_1099511627773 = 1099511627773LL, e9_1099511627774, e9_1099511627775 };\n+\n+typedef char Tchar;\n+typedef signed char Tschar;\n+typedef unsigned char Tuchar;\n+typedef short int Tshort;\n+typedef unsigned short int Tushort;\n+typedef int Tint;\n+typedef unsigned int Tuint;\n+typedef long int Tlong;\n+typedef unsigned long int Tulong;\n+typedef long long int Tllong;\n+typedef unsigned long long int Tullong;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tcchar;\n+typedef _Complex signed char Tcschar;\n+typedef _Complex unsigned char Tcuchar;\n+typedef _Complex short int Tcshort;\n+typedef _Complex unsigned short int Tcushort;\n+typedef _Complex int Tcint;\n+typedef _Complex unsigned int Tcuint;\n+typedef _Complex long int Tclong;\n+typedef _Complex unsigned long int Tculong;\n+typedef _Complex long long int Tcllong;\n+typedef _Complex unsigned long long int Tcullong;\n+#endif\n+typedef float Tfloat;\n+typedef double Tdouble;\n+typedef long double Tldouble;\n+typedef _Complex float Tcfloat;\n+typedef _Complex double Tcdouble;\n+typedef _Complex long double Tcldouble;\n+typedef bool Tbool;\n+typedef enum E0 TE0;\n+typedef enum E1 TE1;\n+typedef enum E2 TE2;\n+typedef enum E3 TE3;\n+typedef enum E4 TE4;\n+typedef enum E5 TE5;\n+typedef enum E6 TE6;\n+typedef enum E7 TE7;\n+typedef enum E8 TE8;\n+typedef enum E9 TE9;\n+typedef void *Tptr;\n+typedef char *Tcptr;\n+typedef int *Tiptr;\n+typedef char Talchar atal;\n+typedef signed char Talschar atal;\n+typedef unsigned char Taluchar atal;\n+typedef short int Talshort atal;\n+typedef unsigned short int Talushort atal;\n+typedef int Talint atal;\n+typedef unsigned int Taluint atal;\n+typedef long int Tallong atal;\n+typedef unsigned long int Talulong atal;\n+typedef long long int Talllong atal;\n+typedef unsigned long long int Talullong atal;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Talcchar atal;\n+typedef _Complex signed char Talcschar atal;\n+typedef _Complex unsigned char Talcuchar atal;\n+typedef _Complex short int Talcshort atal;\n+typedef _Complex unsigned short int Talcushort atal;\n+typedef _Complex int Talcint atal;\n+typedef _Complex unsigned int Talcuint atal;\n+typedef _Complex long int Talclong atal;\n+typedef _Complex unsigned long int Talculong atal;\n+typedef _Complex long long int Talcllong atal;\n+typedef _Complex unsigned long long int Talcullong atal;\n+#endif\n+typedef float Talfloat atal;\n+typedef double Taldouble atal;\n+typedef long double Talldouble atal;\n+typedef _Complex float Talcfloat atal;\n+typedef _Complex double Talcdouble atal;\n+typedef _Complex long double Talcldouble atal;\n+typedef bool Talbool atal;\n+typedef enum E0 TalE0 atal;\n+typedef enum E1 TalE1 atal;\n+typedef enum E2 TalE2 atal;\n+typedef enum E3 TalE3 atal;\n+typedef enum E4 TalE4 atal;\n+typedef enum E5 TalE5 atal;\n+typedef enum E6 TalE6 atal;\n+typedef enum E7 TalE7 atal;\n+typedef enum E8 TalE8 atal;\n+typedef enum E9 TalE9 atal;\n+typedef void *Talptr atal;\n+typedef char *Talcptr atal;\n+typedef int *Taliptr atal;\n+typedef char Tal1char atal1;\n+typedef signed char Tal1schar atal1;\n+typedef unsigned char Tal1uchar atal1;\n+typedef short int Tal1short atal1;\n+typedef unsigned short int Tal1ushort atal1;\n+typedef int Tal1int atal1;\n+typedef unsigned int Tal1uint atal1;\n+typedef long int Tal1long atal1;\n+typedef unsigned long int Tal1ulong atal1;\n+typedef long long int Tal1llong atal1;\n+typedef unsigned long long int Tal1ullong atal1;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal1cchar atal1;\n+typedef _Complex signed char Tal1cschar atal1;\n+typedef _Complex unsigned char Tal1cuchar atal1;\n+typedef _Complex short int Tal1cshort atal1;\n+typedef _Complex unsigned short int Tal1cushort atal1;\n+typedef _Complex int Tal1cint atal1;\n+typedef _Complex unsigned int Tal1cuint atal1;\n+typedef _Complex long int Tal1clong atal1;\n+typedef _Complex unsigned long int Tal1culong atal1;\n+typedef _Complex long long int Tal1cllong atal1;\n+typedef _Complex unsigned long long int Tal1cullong atal1;\n+#endif\n+typedef float Tal1float atal1;\n+typedef double Tal1double atal1;\n+typedef long double Tal1ldouble atal1;\n+typedef _Complex float Tal1cfloat atal1;\n+typedef _Complex double Tal1cdouble atal1;\n+typedef _Complex long double Tal1cldouble atal1;\n+typedef bool Tal1bool atal1;\n+typedef enum E0 Tal1E0 atal1;\n+typedef enum E1 Tal1E1 atal1;\n+typedef enum E2 Tal1E2 atal1;\n+typedef enum E3 Tal1E3 atal1;\n+typedef enum E4 Tal1E4 atal1;\n+typedef enum E5 Tal1E5 atal1;\n+typedef enum E6 Tal1E6 atal1;\n+typedef enum E7 Tal1E7 atal1;\n+typedef enum E8 Tal1E8 atal1;\n+typedef enum E9 Tal1E9 atal1;\n+typedef void *Tal1ptr atal1;\n+typedef char *Tal1cptr atal1;\n+typedef int *Tal1iptr atal1;\n+typedef char Tal2char atal2;\n+typedef signed char Tal2schar atal2;\n+typedef unsigned char Tal2uchar atal2;\n+typedef short int Tal2short atal2;\n+typedef unsigned short int Tal2ushort atal2;\n+typedef int Tal2int atal2;\n+typedef unsigned int Tal2uint atal2;\n+typedef long int Tal2long atal2;\n+typedef unsigned long int Tal2ulong atal2;\n+typedef long long int Tal2llong atal2;\n+typedef unsigned long long int Tal2ullong atal2;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal2cchar atal2;\n+typedef _Complex signed char Tal2cschar atal2;\n+typedef _Complex unsigned char Tal2cuchar atal2;\n+typedef _Complex short int Tal2cshort atal2;\n+typedef _Complex unsigned short int Tal2cushort atal2;\n+typedef _Complex int Tal2cint atal2;\n+typedef _Complex unsigned int Tal2cuint atal2;\n+typedef _Complex long int Tal2clong atal2;\n+typedef _Complex unsigned long int Tal2culong atal2;\n+typedef _Complex long long int Tal2cllong atal2;\n+typedef _Complex unsigned long long int Tal2cullong atal2;\n+#endif\n+typedef float Tal2float atal2;\n+typedef double Tal2double atal2;\n+typedef long double Tal2ldouble atal2;\n+typedef _Complex float Tal2cfloat atal2;\n+typedef _Complex double Tal2cdouble atal2;\n+typedef _Complex long double Tal2cldouble atal2;\n+typedef bool Tal2bool atal2;\n+typedef enum E0 Tal2E0 atal2;\n+typedef enum E1 Tal2E1 atal2;\n+typedef enum E2 Tal2E2 atal2;\n+typedef enum E3 Tal2E3 atal2;\n+typedef enum E4 Tal2E4 atal2;\n+typedef enum E5 Tal2E5 atal2;\n+typedef enum E6 Tal2E6 atal2;\n+typedef enum E7 Tal2E7 atal2;\n+typedef enum E8 Tal2E8 atal2;\n+typedef enum E9 Tal2E9 atal2;\n+typedef void *Tal2ptr atal2;\n+typedef char *Tal2cptr atal2;\n+typedef int *Tal2iptr atal2;\n+typedef char Tal4char atal4;\n+typedef signed char Tal4schar atal4;\n+typedef unsigned char Tal4uchar atal4;\n+typedef short int Tal4short atal4;\n+typedef unsigned short int Tal4ushort atal4;\n+typedef int Tal4int atal4;\n+typedef unsigned int Tal4uint atal4;\n+typedef long int Tal4long atal4;\n+typedef unsigned long int Tal4ulong atal4;\n+typedef long long int Tal4llong atal4;\n+typedef unsigned long long int Tal4ullong atal4;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal4cchar atal4;\n+typedef _Complex signed char Tal4cschar atal4;\n+typedef _Complex unsigned char Tal4cuchar atal4;\n+typedef _Complex short int Tal4cshort atal4;\n+typedef _Complex unsigned short int Tal4cushort atal4;\n+typedef _Complex int Tal4cint atal4;\n+typedef _Complex unsigned int Tal4cuint atal4;\n+typedef _Complex long int Tal4clong atal4;\n+typedef _Complex unsigned long int Tal4culong atal4;\n+typedef _Complex long long int Tal4cllong atal4;\n+typedef _Complex unsigned long long int Tal4cullong atal4;\n+#endif\n+typedef float Tal4float atal4;\n+typedef double Tal4double atal4;\n+typedef long double Tal4ldouble atal4;\n+typedef _Complex float Tal4cfloat atal4;\n+typedef _Complex double Tal4cdouble atal4;\n+typedef _Complex long double Tal4cldouble atal4;\n+typedef bool Tal4bool atal4;\n+typedef enum E0 Tal4E0 atal4;\n+typedef enum E1 Tal4E1 atal4;\n+typedef enum E2 Tal4E2 atal4;\n+typedef enum E3 Tal4E3 atal4;\n+typedef enum E4 Tal4E4 atal4;\n+typedef enum E5 Tal4E5 atal4;\n+typedef enum E6 Tal4E6 atal4;\n+typedef enum E7 Tal4E7 atal4;\n+typedef enum E8 Tal4E8 atal4;\n+typedef enum E9 Tal4E9 atal4;\n+typedef void *Tal4ptr atal4;\n+typedef char *Tal4cptr atal4;\n+typedef int *Tal4iptr atal4;\n+typedef char Tal8char atal8;\n+typedef signed char Tal8schar atal8;\n+typedef unsigned char Tal8uchar atal8;\n+typedef short int Tal8short atal8;\n+typedef unsigned short int Tal8ushort atal8;\n+typedef int Tal8int atal8;\n+typedef unsigned int Tal8uint atal8;\n+typedef long int Tal8long atal8;\n+typedef unsigned long int Tal8ulong atal8;\n+typedef long long int Tal8llong atal8;\n+typedef unsigned long long int Tal8ullong atal8;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal8cchar atal8;\n+typedef _Complex signed char Tal8cschar atal8;\n+typedef _Complex unsigned char Tal8cuchar atal8;\n+typedef _Complex short int Tal8cshort atal8;\n+typedef _Complex unsigned short int Tal8cushort atal8;\n+typedef _Complex int Tal8cint atal8;\n+typedef _Complex unsigned int Tal8cuint atal8;\n+typedef _Complex long int Tal8clong atal8;\n+typedef _Complex unsigned long int Tal8culong atal8;\n+typedef _Complex long long int Tal8cllong atal8;\n+typedef _Complex unsigned long long int Tal8cullong atal8;\n+#endif\n+typedef float Tal8float atal8;\n+typedef double Tal8double atal8;\n+typedef long double Tal8ldouble atal8;\n+typedef _Complex float Tal8cfloat atal8;\n+typedef _Complex double Tal8cdouble atal8;\n+typedef _Complex long double Tal8cldouble atal8;\n+typedef bool Tal8bool atal8;\n+typedef enum E0 Tal8E0 atal8;\n+typedef enum E1 Tal8E1 atal8;\n+typedef enum E2 Tal8E2 atal8;\n+typedef enum E3 Tal8E3 atal8;\n+typedef enum E4 Tal8E4 atal8;\n+typedef enum E5 Tal8E5 atal8;\n+typedef enum E6 Tal8E6 atal8;\n+typedef enum E7 Tal8E7 atal8;\n+typedef enum E8 Tal8E8 atal8;\n+typedef enum E9 Tal8E9 atal8;\n+typedef void *Tal8ptr atal8;\n+typedef char *Tal8cptr atal8;\n+typedef int *Tal8iptr atal8;\n+typedef char Tal16char atal16;\n+typedef signed char Tal16schar atal16;\n+typedef unsigned char Tal16uchar atal16;\n+typedef short int Tal16short atal16;\n+typedef unsigned short int Tal16ushort atal16;\n+typedef int Tal16int atal16;\n+typedef unsigned int Tal16uint atal16;\n+typedef long int Tal16long atal16;\n+typedef unsigned long int Tal16ulong atal16;\n+typedef long long int Tal16llong atal16;\n+typedef unsigned long long int Tal16ullong atal16;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Tal16cchar atal16;\n+typedef _Complex signed char Tal16cschar atal16;\n+typedef _Complex unsigned char Tal16cuchar atal16;\n+typedef _Complex short int Tal16cshort atal16;\n+typedef _Complex unsigned short int Tal16cushort atal16;\n+typedef _Complex int Tal16cint atal16;\n+typedef _Complex unsigned int Tal16cuint atal16;\n+typedef _Complex long int Tal16clong atal16;\n+typedef _Complex unsigned long int Tal16culong atal16;\n+typedef _Complex long long int Tal16cllong atal16;\n+typedef _Complex unsigned long long int Tal16cullong atal16;\n+#endif\n+typedef float Tal16float atal16;\n+typedef double Tal16double atal16;\n+typedef long double Tal16ldouble atal16;\n+typedef _Complex float Tal16cfloat atal16;\n+typedef _Complex double Tal16cdouble atal16;\n+typedef _Complex long double Tal16cldouble atal16;\n+typedef bool Tal16bool atal16;\n+typedef enum E0 Tal16E0 atal16;\n+typedef enum E1 Tal16E1 atal16;\n+typedef enum E2 Tal16E2 atal16;\n+typedef enum E3 Tal16E3 atal16;\n+typedef enum E4 Tal16E4 atal16;\n+typedef enum E5 Tal16E5 atal16;\n+typedef enum E6 Tal16E6 atal16;\n+typedef enum E7 Tal16E7 atal16;\n+typedef enum E8 Tal16E8 atal16;\n+typedef enum E9 Tal16E9 atal16;\n+typedef void *Tal16ptr atal16;\n+typedef char *Tal16cptr atal16;\n+typedef int *Tal16iptr atal16;\n+typedef char Talx1char atalx1;\n+typedef signed char Talx1schar atalx1;\n+typedef unsigned char Talx1uchar atalx1;\n+typedef short int Talx1short atalx1;\n+typedef unsigned short int Talx1ushort atalx1;\n+typedef int Talx1int atalx1;\n+typedef unsigned int Talx1uint atalx1;\n+typedef long int Talx1long atalx1;\n+typedef unsigned long int Talx1ulong atalx1;\n+typedef long long int Talx1llong atalx1;\n+typedef unsigned long long int Talx1ullong atalx1;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Talx1cchar atalx1;\n+typedef _Complex signed char Talx1cschar atalx1;\n+typedef _Complex unsigned char Talx1cuchar atalx1;\n+typedef _Complex short int Talx1cshort atalx1;\n+typedef _Complex unsigned short int Talx1cushort atalx1;\n+typedef _Complex int Talx1cint atalx1;\n+typedef _Complex unsigned int Talx1cuint atalx1;\n+typedef _Complex long int Talx1clong atalx1;\n+typedef _Complex unsigned long int Talx1culong atalx1;\n+typedef _Complex long long int Talx1cllong atalx1;\n+typedef _Complex unsigned long long int Talx1cullong atalx1;\n+#endif\n+typedef float Talx1float atalx1;\n+typedef double Talx1double atalx1;\n+typedef long double Talx1ldouble atalx1;\n+typedef _Complex float Talx1cfloat atalx1;\n+typedef _Complex double Talx1cdouble atalx1;\n+typedef _Complex long double Talx1cldouble atalx1;\n+typedef bool Talx1bool atalx1;\n+typedef enum E0 Talx1E0 atalx1;\n+typedef enum E1 Talx1E1 atalx1;\n+typedef enum E2 Talx1E2 atalx1;\n+typedef enum E3 Talx1E3 atalx1;\n+typedef enum E4 Talx1E4 atalx1;\n+typedef enum E5 Talx1E5 atalx1;\n+typedef enum E6 Talx1E6 atalx1;\n+typedef enum E7 Talx1E7 atalx1;\n+typedef enum E8 Talx1E8 atalx1;\n+typedef enum E9 Talx1E9 atalx1;\n+typedef void *Talx1ptr atalx1;\n+typedef char *Talx1cptr atalx1;\n+typedef int *Talx1iptr atalx1;\n+typedef short int Talx2short atalx2;\n+typedef unsigned short int Talx2ushort atalx2;\n+typedef int Talx2int atalx2;\n+typedef unsigned int Talx2uint atalx2;\n+typedef long int Talx2long atalx2;\n+typedef unsigned long int Talx2ulong atalx2;\n+typedef long long int Talx2llong atalx2;\n+typedef unsigned long long int Talx2ullong atalx2;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex char Talx2cchar atalx2;\n+typedef _Complex signed char Talx2cschar atalx2;\n+typedef _Complex unsigned char Talx2cuchar atalx2;\n+typedef _Complex short int Talx2cshort atalx2;\n+typedef _Complex unsigned short int Talx2cushort atalx2;\n+typedef _Complex int Talx2cint atalx2;\n+typedef _Complex unsigned int Talx2cuint atalx2;\n+typedef _Complex long int Talx2clong atalx2;\n+typedef _Complex unsigned long int Talx2culong atalx2;\n+typedef _Complex long long int Talx2cllong atalx2;\n+typedef _Complex unsigned long long int Talx2cullong atalx2;\n+#endif\n+typedef float Talx2float atalx2;\n+typedef double Talx2double atalx2;\n+typedef long double Talx2ldouble atalx2;\n+typedef _Complex float Talx2cfloat atalx2;\n+typedef _Complex double Talx2cdouble atalx2;\n+typedef _Complex long double Talx2cldouble atalx2;\n+typedef enum E0 Talx2E0 atalx2;\n+typedef enum E1 Talx2E1 atalx2;\n+typedef enum E2 Talx2E2 atalx2;\n+typedef enum E3 Talx2E3 atalx2;\n+typedef enum E4 Talx2E4 atalx2;\n+typedef enum E5 Talx2E5 atalx2;\n+typedef enum E6 Talx2E6 atalx2;\n+typedef enum E7 Talx2E7 atalx2;\n+typedef enum E8 Talx2E8 atalx2;\n+typedef enum E9 Talx2E9 atalx2;\n+typedef void *Talx2ptr atalx2;\n+typedef char *Talx2cptr atalx2;\n+typedef int *Talx2iptr atalx2;\n+typedef int Talx4int atalx4;\n+typedef unsigned int Talx4uint atalx4;\n+typedef long int Talx4long atalx4;\n+typedef unsigned long int Talx4ulong atalx4;\n+typedef long long int Talx4llong atalx4;\n+typedef unsigned long long int Talx4ullong atalx4;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex short int Talx4cshort atalx4;\n+typedef _Complex unsigned short int Talx4cushort atalx4;\n+typedef _Complex int Talx4cint atalx4;\n+typedef _Complex unsigned int Talx4cuint atalx4;\n+typedef _Complex long int Talx4clong atalx4;\n+typedef _Complex unsigned long int Talx4culong atalx4;\n+typedef _Complex long long int Talx4cllong atalx4;\n+typedef _Complex unsigned long long int Talx4cullong atalx4;\n+#endif\n+typedef float Talx4float atalx4;\n+typedef double Talx4double atalx4;\n+typedef long double Talx4ldouble atalx4;\n+typedef _Complex float Talx4cfloat atalx4;\n+typedef _Complex double Talx4cdouble atalx4;\n+typedef _Complex long double Talx4cldouble atalx4;\n+typedef enum E0 Talx4E0 atalx4;\n+typedef enum E1 Talx4E1 atalx4;\n+typedef enum E2 Talx4E2 atalx4;\n+typedef enum E3 Talx4E3 atalx4;\n+typedef enum E4 Talx4E4 atalx4;\n+typedef enum E5 Talx4E5 atalx4;\n+typedef enum E6 Talx4E6 atalx4;\n+typedef enum E7 Talx4E7 atalx4;\n+typedef enum E8 Talx4E8 atalx4;\n+typedef enum E9 Talx4E9 atalx4;\n+typedef void *Talx4ptr atalx4;\n+typedef char *Talx4cptr atalx4;\n+typedef int *Talx4iptr atalx4;\n+typedef long int Taly8long ataly8;\n+typedef unsigned long int Taly8ulong ataly8;\n+typedef long long int Talx8llong atalx8;\n+typedef unsigned long long int Talx8ullong atalx8;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex int Talx8cint atalx8;\n+typedef _Complex unsigned int Talx8cuint atalx8;\n+typedef _Complex long int Talx8clong atalx8;\n+typedef _Complex unsigned long int Talx8culong atalx8;\n+typedef _Complex long long int Talx8cllong atalx8;\n+typedef _Complex unsigned long long int Talx8cullong atalx8;\n+#endif\n+typedef double Talx8double atalx8;\n+typedef long double Talx8ldouble atalx8;\n+typedef _Complex float Talx8cfloat atalx8;\n+typedef _Complex double Talx8cdouble atalx8;\n+typedef _Complex long double Talx8cldouble atalx8;\n+typedef void *Taly8ptr ataly8;\n+typedef char *Taly8cptr ataly8;\n+typedef int *Taly8iptr ataly8;\n+#ifndef SKIP_COMPLEX_INT\n+typedef _Complex long int Taly16clong ataly16;\n+typedef _Complex unsigned long int Taly16culong ataly16;\n+typedef _Complex long long int Talx16cllong atalx16;\n+typedef _Complex unsigned long long int Talx16cullong atalx16;\n+#endif\n+typedef _Complex double Talx16cdouble atalx16;\n+typedef _Complex long double Talx16cldouble atalx16;\n+typedef int (*Tfnptr) (void);\n+\n+/* Bitfield macros.  In C, it is invalid to use numbers larger\n+   than type's bitsize, but we don't know the size when generating\n+   the testcases.  */\n+#define BN8(n) ((((n) - 1) & 7) + 1)\n+#define BN16(n) ((((n) - 1) & 15) + 1)\n+#define BN32(n) ((((n) - 1) & 31) + 1)\n+#define BN64(n) ((((n) - 1) & 63) + 1)\n+#define BCN(n) BN8 (n)\n+#if USHRT_MAX == 255\n+# define BSN(n) BN8 (n)\n+#elif USHRT_MAX == 65535\n+# define BSN(n) BN16 (n)\n+#elif USHRT_MAX == 4294967295U\n+# define BSN(n) BN32 (n)\n+#elif USHRT_MAX == 18446744073709551615ULL\n+# define BSN(n) BN64 (n)\n+#endif\n+#if UINT_MAX == 255\n+# define BIN(n) BN8 (n)\n+#elif UINT_MAX == 65535\n+# define BIN(n) BN16 (n)\n+#elif UINT_MAX == 4294967295U\n+# define BIN(n) BN32 (n)\n+#elif UINT_MAX == 18446744073709551615ULL\n+# define BIN(n) BN64 (n)\n+#endif\n+#if ULONG_MAX == 255\n+# define BLN(n) BN8 (n)\n+#elif ULONG_MAX == 65535\n+# define BLN(n) BN16 (n)\n+#elif ULONG_MAX == 4294967295U\n+# define BLN(n) BN32 (n)\n+#elif ULONG_MAX == 18446744073709551615ULL\n+# define BLN(n) BN64 (n)\n+#endif\n+#if ULONG_MAX == 255\n+# define BLN(n) BN8 (n)\n+#elif ULONG_MAX == 65535\n+# define BLN(n) BN16 (n)\n+#elif ULONG_MAX == 4294967295U\n+# define BLN(n) BN32 (n)\n+#elif ULONG_MAX == 18446744073709551615ULL\n+# define BLN(n) BN64 (n)\n+#endif\n+#if !defined ULLONG_MAX && defined __LONG_LONG_MAX__\n+# define ULLONG_MAX (__LONG_LONG_MAX__ * 2ULL + 1ULL)\n+#endif\n+#if ULLONG_MAX == 255\n+# define BQN(n) BN8 (n)\n+#elif ULLONG_MAX == 65535\n+# define BQN(n) BN16 (n)\n+#elif ULLONG_MAX == 4294967295U\n+# define BQN(n) BN32 (n)\n+#elif ULLONG_MAX == 18446744073709551615ULL\n+# define BQN(n) BN64 (n)\n+#endif\n+\n+#define T(n, fields, ops) TX(n, struct, , fields, ({ ops });)\n+#define U(n, fields, ops) TX(n, union, , fields, ({ ops });)\n+#ifdef SKIP_COMPLEX_INT\n+#define TXCI(n, type, attrs, fields, ops)\n+#define TCI(n, fields, ops)\n+#define UCI(n, fields, ops)\n+#else\n+#define TXCI(n, type, attrs, fields, ops) TX(n, type, attrs, fields, ({ ops });)\n+#define TCI(n, fields, ops) TX(n, struct, , fields, ({ ops });)\n+#define UCI(n, fields, ops) TX(n, union, , fields, ({ ops });)\n+#endif"}, {"sha": "3463bb912a483eb72d779ebb32a4ad49dbbd8d6f", "filename": "gcc/testsuite/objc.dg/gnu-encoding/struct-layout-1_test.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-1_test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-1_test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-1_test.h?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,9 @@\n+#include \"struct-layout-1.h\"\n+\n+#define TX(n, type, attrs, fields, ops) \t\t\t\\\n+type S##n { fields } attrs;\t\t\t\t\t\\\n+void test##n (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (objc_sizeof_type (@encoding (type S##n)) != sizeof(type S##n)) \\\n+    fails ++;\t\t\t\t\t\t\t\\\n+}"}, {"sha": "d9a81d7342909d6c01bb3e842e41b481a0af9d96", "filename": "gcc/testsuite/objc.dg/gnu-encoding/struct-layout-encoding-1_generate.c", "status": "added", "additions": 1938, "deletions": 0, "changes": 1938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-encoding-1_generate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-encoding-1_generate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fstruct-layout-encoding-1_generate.c?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,1938 @@\n+/* Structure layout test generator.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* Compile with gcc -o struct-layout-1_generate{,.c} generate_random{,_r}.c */\n+\n+/* N.B. -- This program cannot use libiberty as that will not work\n+   when testing an installed compiler.  */\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stddef.h>\n+/* We use our own pseudo-random number generator, so that it gives the same\n+   values on all hosts.  */\n+#include \"generate-random.h\"\n+\n+#if LLONG_MAX != 9223372036854775807LL && __LONG_LONG_MAX__ != 9223372036854775807LL\n+# error Need 64-bit long long\n+#endif\n+\n+typedef unsigned int hashval_t;\n+\n+enum TYPE\n+{\n+  TYPE_INT,\n+  TYPE_UINT,\n+  TYPE_CINT,\n+  TYPE_CUINT,\n+  TYPE_FLOAT,\n+  TYPE_CFLOAT,\n+  TYPE_SENUM,\n+  TYPE_UENUM,\n+  TYPE_PTR,\n+  TYPE_FNPTR,\n+  TYPE_OTHER\n+};\n+\n+struct types\n+{\n+  const char *name;\n+  enum TYPE type;\n+  unsigned long long int maxval;\n+  char bitfld;\n+};\n+\n+struct types base_types[] = {\n+/* As we don't know whether char will be signed or not, just limit ourselves\n+   to unsigned values less than maximum signed char value.  */\n+{ \"char\", TYPE_UINT, 127, 'C' },\n+{ \"signed char\", TYPE_INT, 127, 'C' },\n+{ \"unsigned char\", TYPE_UINT, 255, 'C' },\n+{ \"short int\", TYPE_INT, 32767, 'S' },\n+{ \"unsigned short int\", TYPE_UINT, 65535, 'S' },\n+{ \"int\", TYPE_INT, 2147483647, 'I' },\n+{ \"unsigned int\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"long int\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"unsigned long int\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"long long int\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"unsigned long long int\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"bool\", TYPE_UINT, 1, 'B' },\n+{ \"void *\", TYPE_PTR, 0, 0 },\n+{ \"char *\", TYPE_PTR, 0, 0 },\n+{ \"int *\", TYPE_PTR, 0, 0 },\n+{ \"float\", TYPE_FLOAT, 0, 0 },\n+{ \"double\", TYPE_FLOAT, 0, 0 },\n+//{ \"long double\", TYPE_FLOAT, 0, 0 }, //disabled as double and long double are encoded thee same\n+// currently\n+#define NTYPES1 16\n+/* objc encoding does not handle attributes at all.   */\n+#if 0\n+{ \"Tchar\", TYPE_UINT, 127, 'C' },\n+{ \"Tschar\", TYPE_INT, 127, 'C' },\n+{ \"Tuchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tshort\", TYPE_INT, 32767, 'S' },\n+{ \"Tushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tint\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tuint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tlong\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tllong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tbool\", TYPE_UINT, 1, 'B' },\n+{ \"size_t\", TYPE_UINT, 18446744073709551615ULL, 0 },\n+{ \"Tptr\", TYPE_PTR, 0, 0 },\n+{ \"Tcptr\", TYPE_PTR, 0, 0 },\n+{ \"Tiptr\", TYPE_PTR, 0, 0 },\n+{ \"Tfnptr\", TYPE_FNPTR, 0, 0 },\n+{ \"Tfloat\", TYPE_FLOAT, 0, 0 },\n+{ \"Tdouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tldouble\", TYPE_FLOAT, 0, 0 },\n+#endif\n+#if 0\n+/* enums are disabled for now as it seems like their encoding is broken, we should\n+   just encode them using their underlaying type but we don't.   */\n+{ \"enum E0\", TYPE_UENUM, 0, ' ' },\n+{ \"enum E1\", TYPE_UENUM, 1, ' ' },\n+{ \"enum E2\", TYPE_SENUM, 3, ' ' },\n+{ \"enum E3\", TYPE_SENUM, 127, ' ' },\n+{ \"enum E4\", TYPE_UENUM, 255, ' ' },\n+{ \"enum E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"enum E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"enum E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"enum E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"enum E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"TE0\", TYPE_UENUM, 0, ' ' },\n+{ \"TE1\", TYPE_UENUM, 1, ' ' },\n+{ \"TE2\", TYPE_SENUM, 3, ' ' },\n+{ \"TE3\", TYPE_SENUM, 127, ' ' },\n+{ \"TE4\", TYPE_UENUM, 255, ' ' },\n+{ \"TE5\", TYPE_SENUM, 32767, ' ' },\n+{ \"TE6\", TYPE_UENUM, 65535, ' ' },\n+{ \"TE7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"TE8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"TE9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+#endif\n+#if 0\n+/* vector-defs.h typedefs */\n+{ \"qi\", TYPE_INT, 127, 0 },\n+{ \"hi\", TYPE_INT, 32767, 0 },\n+{ \"si\", TYPE_INT, 2147483647, 0 },\n+{ \"di\", TYPE_INT, 9223372036854775807LL, 0 },\n+{ \"sf\", TYPE_FLOAT, 0, 0 },\n+{ \"df\", TYPE_FLOAT, 0, 0 }\n+#endif\n+#define NTYPES2 (sizeof (base_types) / sizeof (base_types[0]))\n+};\n+struct types complex_types[] = {\n+{ \"_Complex char\", TYPE_CUINT, 127, 0 },\n+{ \"_Complex signed char\", TYPE_CINT, 127, 0 },\n+{ \"_Complex unsigned char\", TYPE_CUINT, 255, 0 },\n+{ \"_Complex short int\", TYPE_CINT, 32767, 0 },\n+{ \"_Complex unsigned short int\", TYPE_CUINT, 65535, 0 },\n+{ \"_Complex int\", TYPE_CINT, 2147483647, 0 },\n+{ \"_Complex unsigned int\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"_Complex long int\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"_Complex unsigned long int\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"_Complex long long int\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"_Complex unsigned long long int\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"_Complex float\", TYPE_CFLOAT, 0, 0 },\n+{ \"_Complex double\", TYPE_CFLOAT, 0, 0 },\n+{ \"_Complex long double\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tcchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tcschar\", TYPE_CINT, 127, 0 },\n+{ \"Tcuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tcshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tcushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tcint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tcuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tclong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tculong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tcllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tcullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tcfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tcdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tcldouble\", TYPE_CFLOAT, 0, 0 }\n+#define NCTYPES2 (sizeof (complex_types) / sizeof (complex_types[0]))\n+};\n+struct types vector_types[] = {\n+/* vector-defs.h typedefs */\n+{ \"v8qi\", TYPE_OTHER, 0, 0 },\n+{ \"v16qi\", TYPE_OTHER, 0, 0 },\n+{ \"v2hi\", TYPE_OTHER, 0, 0 },\n+{ \"v4hi\", TYPE_OTHER, 0, 0 },\n+{ \"v8hi\", TYPE_OTHER, 0, 0 },\n+{ \"v2si\", TYPE_OTHER, 0, 0 },\n+{ \"v4si\", TYPE_OTHER, 0, 0 },\n+{ \"v1di\", TYPE_OTHER, 0, 0 },\n+{ \"v2di\", TYPE_OTHER, 0, 0 },\n+{ \"v2sf\", TYPE_OTHER, 0, 0 },\n+{ \"v4sf\", TYPE_OTHER, 0, 0 },\n+{ \"v16sf\", TYPE_OTHER, 0, 0 },\n+{ \"v2df\", TYPE_OTHER, 0, 0 },\n+{ \"u8qi\", TYPE_OTHER, 0, 0 },\n+{ \"u16qi\", TYPE_OTHER, 0, 0 },\n+{ \"u2hi\", TYPE_OTHER, 0, 0 },\n+{ \"u4hi\", TYPE_OTHER, 0, 0 },\n+{ \"u8hi\", TYPE_OTHER, 0, 0 },\n+{ \"u2si\", TYPE_OTHER, 0, 0 },\n+{ \"u4si\", TYPE_OTHER, 0, 0 },\n+{ \"u1di\", TYPE_OTHER, 0, 0 },\n+{ \"u2di\", TYPE_OTHER, 0, 0 },\n+{ \"u2sf\", TYPE_OTHER, 0, 0 },\n+{ \"u4sf\", TYPE_OTHER, 0, 0 },\n+{ \"u16sf\", TYPE_OTHER, 0, 0 },\n+{ \"u2df\", TYPE_OTHER, 0, 0 },\n+{ \"__m64\", TYPE_OTHER, 0, 0 },\n+{ \"__m128\", TYPE_OTHER, 0, 0 }\n+#define NVTYPES2 (sizeof (vector_types) / sizeof (vector_types[0]))\n+};\n+struct types attrib_types[] = {\n+#if 0\n+{ \"Talchar\", TYPE_UINT, 127, 'C' },\n+{ \"Talschar\", TYPE_INT, 127, 'C' },\n+{ \"Taluchar\", TYPE_UINT, 255, 'C' },\n+{ \"Talshort\", TYPE_INT, 32767, 'S' },\n+{ \"Talushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talint\", TYPE_INT, 2147483647, 'I' },\n+{ \"Taluint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tallong\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talllong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talbool\", TYPE_UINT, 1, 'B' },\n+{ \"Talptr\", TYPE_PTR, 0, 0 },\n+{ \"Talcptr\", TYPE_PTR, 0, 0 },\n+{ \"Taliptr\", TYPE_PTR, 0, 0 },\n+{ \"Talfloat\", TYPE_FLOAT, 0, 0 },\n+{ \"Taldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"TalE0\", TYPE_UENUM, 0, ' ' },\n+{ \"TalE1\", TYPE_UENUM, 1, ' ' },\n+{ \"TalE2\", TYPE_SENUM, 3, ' ' },\n+{ \"TalE3\", TYPE_SENUM, 127, ' ' },\n+{ \"TalE4\", TYPE_UENUM, 255, ' ' },\n+{ \"TalE5\", TYPE_SENUM, 32767, ' ' },\n+{ \"TalE6\", TYPE_UENUM, 65535, ' ' },\n+{ \"TalE7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"TalE8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"TalE9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal1char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal1schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal1uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal1short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal1ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal1int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal1uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal1long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal1ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal1llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal1ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal1bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal1ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal1float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal1E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal1E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal1E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal1E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal1E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal1E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal1E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal1E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal1E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal1E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal2char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal2schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal2uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal2short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal2ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal2int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal2uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal2long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal2ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal2llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal2ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal2bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal2ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal2float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal2E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal2E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal2E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal2E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal2E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal2E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal2E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal2E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal2E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal2E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal4char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal4schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal4uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal4short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal4ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal4int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal4uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal4long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal4ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal4llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal4ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal4bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal4ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal4float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal4E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal4E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal4E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal4E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal4E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal4E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal4E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal4E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal4E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal4E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal8char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal8schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal8uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal8short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal8ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal8int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal8uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal8long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal8ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal8llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal8ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal8bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal8ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal8float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal8E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal8E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal8E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal8E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal8E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal8E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal8E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal8E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal8E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal8E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Tal16char\", TYPE_UINT, 127, 'C' },\n+{ \"Tal16schar\", TYPE_INT, 127, 'C' },\n+{ \"Tal16uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Tal16short\", TYPE_INT, 32767, 'S' },\n+{ \"Tal16ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Tal16int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Tal16uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Tal16long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Tal16ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Tal16llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Tal16ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Tal16bool\", TYPE_UINT, 1, 'B' },\n+{ \"Tal16ptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16cptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16iptr\", TYPE_PTR, 0, 0 },\n+{ \"Tal16float\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16double\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Tal16E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Tal16E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Tal16E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Tal16E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Tal16E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Tal16E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Tal16E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Tal16E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Tal16E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Tal16E9\", TYPE_SENUM, 1099511627775LL, ' ' }\n+#endif\n+#define NATYPES2 (sizeof (attrib_types) / sizeof (attrib_types[0]))\n+};\n+struct types complex_attrib_types[] = {\n+#if 0\n+{ \"Talcchar\", TYPE_CUINT, 127, 0 },\n+{ \"Talcschar\", TYPE_CINT, 127, 0 },\n+{ \"Talcuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Talcshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talcushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talcint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talcuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talclong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talculong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talcllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talcullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talcfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talcdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talcldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal1cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal1cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal1cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal1cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal1cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal1cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal1cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal1clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal1culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal1cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal1cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal1cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal1cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal1cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal2cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal2cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal2cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal2cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal2cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal2cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal2cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal2clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal2culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal2cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal2cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal2cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal2cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal2cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal4cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal4cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal4cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal4cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal4cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal4cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal4cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal4clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal4culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal4cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal4cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal4cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal4cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal4cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal8cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal8cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal8cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal8cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal8cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal8cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal8cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal8clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal8culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal8cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal8cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal8cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal8cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal8cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal16cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Tal16cschar\", TYPE_CINT, 127, 0 },\n+{ \"Tal16cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Tal16cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Tal16cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Tal16cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Tal16cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Tal16clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal16culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal16cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Tal16cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Tal16cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal16cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Tal16cldouble\", TYPE_CFLOAT, 0, 0 }\n+#endif\n+#define NCATYPES2 (sizeof (complex_attrib_types) / sizeof (complex_attrib_types[0]))\n+};\n+struct types attrib_array_types[] = {\n+#if 0\n+{ \"Talx1char\", TYPE_UINT, 127, 'C' },\n+{ \"Talx1schar\", TYPE_INT, 127, 'C' },\n+{ \"Talx1uchar\", TYPE_UINT, 255, 'C' },\n+{ \"Talx1short\", TYPE_INT, 32767, 'S' },\n+{ \"Talx1ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talx1int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx1uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx1long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx1ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx1llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx1ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx1bool\", TYPE_UINT, 1, 'B' },\n+{ \"Talx1ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx1float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx1E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx1E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx1E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx1E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx1E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx1E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx1E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx1E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx1E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx1E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Talx2short\", TYPE_INT, 32767, 'S' },\n+{ \"Talx2ushort\", TYPE_UINT, 65535, 'S' },\n+{ \"Talx2int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx2uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx2long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx2ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx2llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx2ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx2ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx2float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx2E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx2E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx2E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx2E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx2E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx2E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx2E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx2E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx2E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx2E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Talx4int\", TYPE_INT, 2147483647, 'I' },\n+{ \"Talx4uint\", TYPE_UINT, 4294967295U, 'I' },\n+{ \"Talx4long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Talx4ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx4llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx4ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Talx4ptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4cptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx4float\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4ldouble\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx4E0\", TYPE_UENUM, 0, ' ' },\n+{ \"Talx4E1\", TYPE_UENUM, 1, ' ' },\n+{ \"Talx4E2\", TYPE_SENUM, 3, ' ' },\n+{ \"Talx4E3\", TYPE_SENUM, 127, ' ' },\n+{ \"Talx4E4\", TYPE_UENUM, 255, ' ' },\n+{ \"Talx4E5\", TYPE_SENUM, 32767, ' ' },\n+{ \"Talx4E6\", TYPE_UENUM, 65535, ' ' },\n+{ \"Talx4E7\", TYPE_SENUM, 2147483647, ' ' },\n+{ \"Talx4E8\", TYPE_UENUM, 4294967295U, ' ' },\n+{ \"Talx4E9\", TYPE_SENUM, 1099511627775LL, ' ' },\n+{ \"Taly8long\", TYPE_INT, 9223372036854775807LL, 'L' },\n+{ \"Taly8ulong\", TYPE_UINT, 18446744073709551615ULL, 'L' },\n+{ \"Talx8llong\", TYPE_INT, 9223372036854775807LL, 'Q' },\n+{ \"Talx8ullong\", TYPE_UINT, 18446744073709551615ULL, 'Q' },\n+{ \"Taly8ptr\", TYPE_PTR, 0, 0 },\n+{ \"Taly8cptr\", TYPE_PTR, 0, 0 },\n+{ \"Taly8iptr\", TYPE_PTR, 0, 0 },\n+{ \"Talx8double\", TYPE_FLOAT, 0, 0 },\n+{ \"Talx8ldouble\", TYPE_FLOAT, 0, 0 }\n+#endif\n+#define NAATYPES2 (sizeof (attrib_array_types) / sizeof (attrib_array_types[0]))\n+};\n+struct types complex_attrib_array_types[] = {\n+#if 0\n+{ \"Talx1cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Talx1cschar\", TYPE_CINT, 127, 0 },\n+{ \"Talx1cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Talx1cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talx1cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talx1cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx1cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx1clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx1culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx1cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx1cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx1cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx1cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx1cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx2cchar\", TYPE_CUINT, 127, 0 },\n+{ \"Talx2cschar\", TYPE_CINT, 127, 0 },\n+{ \"Talx2cuchar\", TYPE_CUINT, 255, 0 },\n+{ \"Talx2cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talx2cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talx2cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx2cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx2clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx2culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx2cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx2cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx2cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx2cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx2cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx4cshort\", TYPE_CINT, 32767, 0 },\n+{ \"Talx4cushort\", TYPE_CUINT, 65535, 0 },\n+{ \"Talx4cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx4cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx4clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx4culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx4cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx4cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx4cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx4cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx4cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx8cint\", TYPE_CINT, 2147483647, 0 },\n+{ \"Talx8cuint\", TYPE_CUINT, 4294967295U, 0 },\n+{ \"Talx8clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx8culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx8cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx8cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx8cfloat\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx8cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx8cldouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Taly16clong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Taly16culong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx16cllong\", TYPE_CINT, 9223372036854775807LL, 0 },\n+{ \"Talx16cullong\", TYPE_CUINT, 18446744073709551615ULL, 0 },\n+{ \"Talx16cdouble\", TYPE_CFLOAT, 0, 0 },\n+{ \"Talx16cldouble\", TYPE_CFLOAT, 0, 0 }\n+#endif\n+#define NCAATYPES2 (sizeof (complex_attrib_array_types) / sizeof (complex_attrib_array_types[0]))\n+};\n+\n+struct types bitfld_types[NTYPES2];\n+int n_bitfld_types;\n+struct types aligned_bitfld_types[NATYPES2];\n+int n_aligned_bitfld_types;\n+\n+const char *attributes[] = {\n+#if 0\n+\"atal\", \n+\"atpa\", \n+\"atal1\", \n+\"atal2\", \n+\"atal4\", \n+\"atal8\", \n+\"atal16\", \n+#endif\n+#define NATTRIBS1 0\n+#if 0\n+\"atalpa\", \n+\"atpaal\", \n+\"atal1pa\", \n+\"atal2pa\", \n+\"atal4pa\", \n+\"atal8pa\", \n+\"atal16pa\", \n+\"atpaal1\", \n+\"atpaal2\", \n+\"atpaal4\", \n+\"atpaal8\", \n+\"atpaal16\"\n+#endif\n+#define NATTRIBS2 (sizeof (attributes) / sizeof (attributes[0]))\n+};\n+\n+enum ETYPE\n+{\n+  ETYPE_TYPE,\n+  ETYPE_ARRAY,\n+  ETYPE_BITFLD,\n+  ETYPE_STRUCT,\n+  ETYPE_UNION,\n+  ETYPE_STRUCT_ARRAY,\n+  ETYPE_UNION_ARRAY\n+};\n+\n+struct entry\n+{\n+#ifdef __GNUC__\n+  enum ETYPE etype : 8;\n+#else\n+  unsigned char etype;\n+#endif\n+  unsigned short len;\n+  unsigned char arr_len;\n+  struct types *type;\n+  const char *attrib;\n+  /* Used to chain together entries in the hash table.  */\n+  struct entry *next;\n+};\n+\n+/* A prime number giving the number of slots in the hash table.  */ \n+#define HASH_SIZE 32749 \n+static struct entry *hash_table[HASH_SIZE];\n+\n+static int idx, limidx, output_one;\n+static const char *destdir;\n+static const char *srcdir;\n+FILE *outfile;\n+\n+void\n+switchfiles (int fields)\n+{\n+  static int filecnt;\n+  static char *destbuf, *destptr;\n+  ++filecnt;\n+  if (outfile)\n+    fclose (outfile);\n+  if (output_one)\n+    {\n+      outfile = stdout;\n+      return;\n+    }\n+  if (destbuf == NULL)\n+    {\n+      size_t len = strlen (destdir);\n+      destbuf = malloc (len + 20);\n+      if (!destbuf)\n+\tabort ();\n+      memcpy (destbuf, destdir, len);\n+      if (!len || destbuf[len - 1] != '/')\n+\tdestbuf[len++] = '/';\n+      destptr = destbuf + len;\n+    }\n+  sprintf (destptr, \"t%03d_main.m\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    {\n+    fail:\n+      fputs (\"failed to create test files\\n\", stderr);\n+      exit (1);\n+    }\n+  fprintf (outfile, \"\\\n+/* { dg-do run } */\\n\\\n+/* { dg-options \\\"-w -I%s -fgnu-runtime\\\" } */\\n\\\n+#include <objc/encoding.h> \\n\\\n+#include \\\"struct-layout-1.h\\\"\\n\\\n+\\n\\\n+int fails; \\n\\\n+#define TX(n, type, attrs, fields, ops)                         \\\\\\n\\\n+type S##n { fields } attrs;                                     \\\\\\n\\\n+void test##n (void)                                             \\\\\\n\\\n+{                                                               \\\\\\n\\\n+  char *encoding = @encode (type S##n);\t\t\t\t\\\\\\n\\\n+  if (objc_sizeof_type (encoding) != sizeof(type S##n)) \t\\\\\\n\\\n+    {   \t                                                \\\\\\n\\\n+      fails ++;                                                 \\\\\\n\\\n+      printf(#type \\\" { \\\" #fields \\\"} size is %%u, but is calulated as %%u\\\\n\\\", \\\\\\n\\\n+      \t      sizeof(type S##n), objc_sizeof_type (encoding));  \\\\\\n\\\n+    }           \t                                        \\\\\\n\\\n+  if (objc_alignof_type (encoding) != __alignof__ (type S##n)) \t\\\\\\n\\\n+    {   \t                                                \\\\\\n\\\n+      fails ++;                                                 \\\\\\n\\\n+      printf(#type \\\" { \\\" #fields \\\"} align is %%u, but is calulated as %%u\\\\n\\\", \\\\\\n\\\n+      \t      __alignof__ (type S##n), objc_alignof_type (encoding));  \\\\\\n\\\n+    }           \t                                        \\\\\\n\\\n+}\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#undef TX\\n\\\n+\\n\\\n+int main (void)\\n\\\n+{\\n\\\n+#define TX(n, type, attrs, fields, ops)   test##n ();\\n\\\n+#include \\\"t%03d_test.h\\\"\\n\\\n+#undef TX\\n\\\n+  if (fails)\\n\\\n+    {\\n\\\n+      fflush (stdout);\\n\\\n+      abort ();\\n\\\n+    }\\n\\\n+  exit (0);\\n\\\n+}\\n\", srcdir, filecnt, filecnt);\n+  fclose (outfile);\n+  sprintf (destptr, \"t%03d_test.h\", filecnt);\n+  outfile = fopen (destbuf, \"w\");\n+  if (outfile == NULL)\n+    goto fail;\n+  if (fields <= 2)\n+    limidx = idx + 300;\n+  else if (fields <= 4)\n+    limidx = idx + 200;\n+  else if (fields <= 6)\n+    limidx = idx + 100;\n+  else\n+    limidx = idx + 50;\n+}\n+\n+unsigned long long int\n+getrandll (void)\n+{\n+  unsigned long long int ret;\n+  ret = generate_random () & 0xffffff;\n+  ret |= (generate_random () & 0xffffffLL) << 24;\n+  ret |= ((unsigned long long int) generate_random ()) << 48;\n+  return ret;\n+}\n+\n+int\n+subfield (struct entry *e, char *letter)\n+{\n+  int i, type;\n+  char buf[20];\n+  const char *p;\n+  switch (e[0].etype)\n+    {\n+    case ETYPE_STRUCT:\n+    case ETYPE_UNION:\n+    case ETYPE_STRUCT_ARRAY:\n+    case ETYPE_UNION_ARRAY:\n+      type = e[0].attrib ? 1 + (generate_random () & 3) : 0;\n+      if (e[0].etype == ETYPE_STRUCT || e[0].etype == ETYPE_STRUCT_ARRAY)\n+\tp = \"struct\";\n+      else\n+\tp = \"union\";\n+      if (e[0].etype == ETYPE_STRUCT_ARRAY || e[0].etype == ETYPE_UNION_ARRAY)\n+\t{\n+\t  if (e[0].arr_len == 255)\n+\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t  else\n+\t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n+\t}\n+      else\n+        {\n+          buf[0] = *letter;\n+          buf[1] = '\\0';\n+        }\n+      ++*letter;\n+      switch (type)\n+        {\n+        case 0:\n+        case 3:\n+        case 4:\n+          fprintf (outfile, \"%s{\", p);\n+          break;\n+        case 1:\n+          fprintf (outfile, \"%s %s{\", e[0].attrib, p);\n+          break;\n+        case 2:\n+          fprintf (outfile, \"%s %s{\", p, e[0].attrib);\n+          break;\n+        }\n+\n+      for (i = 1; i <= e[0].len; )\n+\ti += subfield (e + i, letter);\n+\n+      switch (type)\n+        {\n+        case 0:\n+        case 1:\n+        case 2:\n+          fprintf (outfile, \"}%s;\", buf);\n+          break;\n+\tcase 3:\n+\t  fprintf (outfile, \"}%s %s;\", e[0].attrib, buf);\n+\t  break;\n+\tcase 4:\n+\t  fprintf (outfile, \"}%s %s;\", buf, e[0].attrib);\n+\t  break;\n+        }\n+      return 1 + e[0].len;\n+    case ETYPE_TYPE:\n+    case ETYPE_ARRAY:\n+      if (e[0].etype == ETYPE_ARRAY)\n+\t{\n+\t  if (e[0].arr_len == 255)\n+\t    snprintf (buf, 20, \"%c[]\", *letter);\n+\t  else\n+\t    snprintf (buf, 20, \"%c[%d]\", *letter, e[0].arr_len);\n+\t}\n+      else\n+        {\n+          buf[0] = *letter;\n+          buf[1] = '\\0';\n+        }\n+      ++*letter;\n+      if (e[0].attrib)\n+\tswitch (generate_random () % 3)\n+          {\n+          case 0:\n+            fprintf (outfile, \"%s %s %s;\", e[0].attrib, e[0].type->name, buf);\n+            break;\n+          case 1:\n+            fprintf (outfile, \"%s %s %s;\", e[0].type->name, e[0].attrib, buf);\n+            break;\n+          case 2:\n+            fprintf (outfile, \"%s %s %s;\", e[0].type->name, buf, e[0].attrib);\n+            break;\n+          }\n+      else\n+\tfprintf (outfile, \"%s %s;\", e[0].type->name, buf);\n+      return 1;\n+    case ETYPE_BITFLD:\n+      if (e[0].len == 0)\n+\t{\n+\t  if (e[0].attrib)\n+\t    switch (generate_random () % 3)\n+\t      {\n+\t      case 0:\n+\t\tfprintf (outfile, \"%s %s:0;\", e[0].attrib, e[0].type->name);\n+\t\tbreak;\n+\t      case 1:\n+\t\tfprintf (outfile, \"%s %s:0;\", e[0].type->name, e[0].attrib);\n+\t\tbreak;\n+\t      case 2:\n+\t\tfprintf (outfile, \"%s:0 %s;\", e[0].type->name, e[0].attrib);\n+\t\tbreak;\n+\t      }\n+\t  else\n+\t    fprintf (outfile, \"%s:0;\", e[0].type->name);\n+\t  ++*letter;\n+\t  return 1;\n+\t}\n+      switch (e[0].type->bitfld)\n+\t{\n+\tcase 'C':\n+\tcase 'S':\n+\tcase 'I':\n+\tcase 'L':\n+\tcase 'Q':\n+\t  snprintf (buf, 20, \"B%cN(%d)\", e[0].type->bitfld, e[0].len);\n+\t  break;\n+\tcase 'B':\n+\tcase ' ':\n+\t  snprintf (buf, 20, \"%d\", e[0].len);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      if (e[0].attrib)\n+\tswitch (generate_random () % 3)\n+\t  {\n+\t  case 0:\n+\t    fprintf (outfile, \"%s %s %c:%s;\", e[0].attrib, e[0].type->name,\n+\t\t     *letter, buf);\n+\t    break;\n+\t  case 1:\n+\t    fprintf (outfile, \"%s %s %c:%s;\", e[0].type->name, e[0].attrib,\n+\t\t     *letter, buf);\n+\t    break;\n+\t  case 2:\n+\t    fprintf (outfile, \"%s %c:%s %s;\", e[0].type->name, *letter,\n+\t\t     buf, e[0].attrib);\n+\t    break;\n+\t  }\n+      else\n+\tfprintf (outfile, \"%s %c:%s;\", e[0].type->name, *letter, buf);\n+      ++*letter;\n+      return 1;\n+    default:\n+      abort ();\n+  }\n+}\n+\n+char namebuf[1024];\n+\n+void\n+output_FNB (char mode, struct entry *e)\n+{\n+  unsigned long long int l1, l2, m;\n+  int signs = 0;\n+  const char *p, *q;\n+\n+  if (e->type->type == TYPE_OTHER)\n+    {\n+      if (mode == 'B')\n+        abort ();\n+      fprintf (outfile, \"N(%d,%s)\", idx, namebuf);\n+      return;\n+    }\n+  fprintf (outfile, \"%c(%d,%s,\", mode, idx, namebuf);\n+  l1 = getrandll ();\n+  l2 = getrandll ();\n+  switch (e->type->type)\n+    {\n+    case TYPE_INT:\n+      signs = generate_random () & 3;\n+      m = e->type->maxval;\n+      if (mode == 'B')\n+\tm &= e->len > 1 ? (1ULL << (e->len - 1)) - 1 : 1;\n+      l1 &= m;\n+      l2 &= m;\n+      fprintf (outfile, \"%s%llu%s,%s%llu%s\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      break;\n+    case TYPE_UINT:\n+      m = e->type->maxval;\n+      if (mode == 'B')\n+\tm &= (1ULL << e->len) - 1;\n+      l1 &= m;\n+      l2 &= m;\n+      fprintf (outfile, \"%lluU%s,%lluU%s\", l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      break;\n+    case TYPE_FLOAT:\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"%s%f,%s%f\", (signs & 1) ? \"-\" : \"\",\n+\t       ((double) l1) / 64, (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      break;\n+    case TYPE_CINT:\n+      signs = generate_random () & 3;\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%s%llu%s,%s%llu%s),\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      signs = generate_random () & 3;\n+      l1 = getrandll ();\n+      l2 = getrandll ();\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%s%llu%s,%s%llu%s)\",\n+\t       (signs & 1) ? \"-\" : \"\", l1, l1 > 2147483647 ? \"LL\" : \"\",\n+\t       (signs & 2) ? \"-\" : \"\", l2, l2 > 2147483647 ? \"LL\" : \"\");\n+      break;\n+    case TYPE_CUINT:\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%lluU%s,%lluU%s),\",\n+\t       l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      l1 = getrandll ();\n+      l2 = getrandll ();\n+      l1 &= e->type->maxval;\n+      l2 &= e->type->maxval;\n+      fprintf (outfile, \"CINT(%lluU%s,%lluU%s)\",\n+\t       l1, l1 > 4294967295U ? \"LL\" : \"\",\n+\t       l2, l2 > 4294967295U ? \"LL\" : \"\");\n+      break;\n+    case TYPE_CFLOAT:\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"CDBL(%s%f,%s%f),\",\n+\t       (signs & 1) ? \"-\" : \"\", ((double) l1) / 64,\n+\t       (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      l1 = getrandll ();\n+      l2 = getrandll ();\n+      l1 &= 0xffffff;\n+      l2 &= 0xffffff;\n+      signs = generate_random () & 3;\n+      fprintf (outfile, \"CDBL(%s%f,%s%f)\",\n+\t       (signs & 1) ? \"-\" : \"\", ((double) l1) / 64,\n+\t       (signs & 2) ? \"-\" : \"\", ((double) l2) / 64);\n+      break;\n+    case TYPE_UENUM:\n+      if (e->type->maxval == 0)\n+\tfputs (\"e0_0,e0_0\", outfile);\n+      else if (e->type->maxval == 1)\n+        fprintf (outfile, \"e1_%lld,e1_%lld\", l1 & 1, l2 & 1);\n+      else\n+        {\n+\t  p = strchr (e->type->name, '\\0');\n+\t  while (--p >= e->type->name && *p >= '0' && *p <= '9');\n+\t  p++;\n+          l1 %= 7;\n+          l2 %= 7;\n+          if (l1 > 3)\n+            l1 += e->type->maxval - 6;\n+          if (l2 > 3)\n+            l2 += e->type->maxval - 6;\n+\t  fprintf (outfile, \"e%s_%lld,e%s_%lld\", p, l1, p, l2);\n+        }\n+      break;\n+    case TYPE_SENUM:\n+      p = strchr (e->type->name, '\\0');\n+      while (--p >= e->type->name && *p >= '0' && *p <= '9');\n+      p++;\n+      l1 %= 7;\n+      l2 %= 7;\n+      fprintf (outfile, \"e%s_%s%lld,e%s_%s%lld\",\n+\t       p, l1 < 3 ? \"m\" : \"\",\n+\t       l1 == 3 ? 0LL : e->type->maxval - (l1 & 3),\n+\t       p, l2 < 3 ? \"m\" : \"\",\n+\t       l2 == 3 ? 0LL : e->type->maxval - (l2 & 3));\n+      break;\n+    case TYPE_PTR:\n+      l1 %= 256;\n+      l2 %= 256;\n+      fprintf (outfile, \"(%s)&intarray[%lld],(%s)&intarray[%lld]\",\n+\t       e->type->name, l1, e->type->name, l2);\n+      break;\n+    case TYPE_FNPTR:\n+      l1 %= 10;\n+      l2 %= 10;\n+      fprintf (outfile, \"fn%lld,fn%lld\", l1, l2);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  fputs (\")\", outfile);\n+}\n+\n+int\n+subvalues (struct entry *e, char *p, char *letter)\n+{\n+  int i, j;\n+  char *q;\n+  if (p >= namebuf + sizeof (namebuf) - 32)\n+    abort ();\n+  p[0] = *letter;\n+  p[1] = '\\0';\n+  q = p + 1;\n+  switch (e[0].etype)\n+    {\n+    case ETYPE_STRUCT_ARRAY:\n+    case ETYPE_UNION_ARRAY:\n+      if (e[0].arr_len == 0 || e[0].arr_len == 255)\n+\t{\n+\t  *letter += 1 + e[0].len;\n+\t  return 1 + e[0].len;\n+\t}\n+      i = generate_random () % e[0].arr_len;\n+      snprintf (p, sizeof (namebuf) - (p - namebuf) - 1,\n+\t\t\"%c[%d]\", *letter, i);\n+      q = strchr (p, '\\0');\n+      /* FALLTHROUGH */\n+    case ETYPE_STRUCT:\n+    case ETYPE_UNION:\n+      *q++ = '.';\n+      ++*letter;\n+      for (i = 1; i <= e[0].len; )\n+\t{\n+\t  i += subvalues (e + i, q, letter);\n+\t  if (e[0].etype == ETYPE_UNION || e[0].etype == ETYPE_UNION_ARRAY)\n+\t    {\n+\t      *letter += e[0].len - i + 1;\n+\t      break;\n+\t    }\n+\t}\n+      return 1 + e[0].len;\n+    case ETYPE_TYPE:\n+      ++*letter;\n+      output_FNB ('F', e);\n+      return 1;\n+    case ETYPE_ARRAY:\n+      if (e[0].arr_len == 0 || e[0].arr_len == 255)\n+\t{\n+\t  ++*letter;\n+\t  return 1;\n+\t}\n+      i = generate_random () % e[0].arr_len;\n+      snprintf (p, sizeof (namebuf) - (p - namebuf),\n+\t\t\"%c[%d]\", *letter, i);\n+      output_FNB ('F', e);\n+      if ((generate_random () & 7) == 0)\n+\t{\n+\t  j = generate_random () % e[0].arr_len;\n+\t  if (i != j)\n+\t    {\n+\t      snprintf (p, sizeof (namebuf) - (p - namebuf),\n+\t\t\t\"%c[%d]\", *letter, j);\n+\t      output_FNB ('F', e);\n+\t    }\n+\t}\n+      ++*letter;\n+      return 1;\n+    case ETYPE_BITFLD:\n+      ++*letter;\n+      if (e[0].len != 0)\n+\toutput_FNB ('B', e);\n+      return 1;\n+    }\n+}\n+\n+/* DERIVED FROM:\n+--------------------------------------------------------------------\n+lookup2.c, by Bob Jenkins, December 1996, Public Domain.\n+hash(), hash2(), hash3, and mix() are externally useful functions.\n+Routines to test the hash are included if SELF_TEST is defined.\n+You can use this free for any purpose.  It has no warranty.\n+--------------------------------------------------------------------\n+*/\n+\n+/*\n+--------------------------------------------------------------------\n+mix -- mix 3 32-bit values reversibly.\n+For every delta with one or two bit set, and the deltas of all three\n+  high bits or all three low bits, whether the original value of a,b,c\n+  is almost all zero or is uniformly distributed,\n+* If mix() is run forward or backward, at least 32 bits in a,b,c\n+  have at least 1/4 probability of changing.\n+* If mix() is run forward, every bit of c will change between 1/3 and\n+  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)\n+mix() was built out of 36 single-cycle latency instructions in a \n+  structure that could supported 2x parallelism, like so:\n+      a -= b; \n+      a -= c; x = (c>>13);\n+      b -= c; a ^= x;\n+      b -= a; x = (a<<8);\n+      c -= a; b ^= x;\n+      c -= b; x = (b>>13);\n+      ...\n+  Unfortunately, superscalar Pentiums and Sparcs can't take advantage \n+  of that parallelism.  They've also turned some of those single-cycle\n+  latency instructions into multi-cycle latency instructions.  Still,\n+  this is the fastest good hash I could find.  There were about 2^^68\n+  to choose from.  I only looked at a billion or so.\n+--------------------------------------------------------------------\n+*/\n+/* same, but slower, works on systems that might have 8 byte hashval_t's */\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= b; a -= c; a ^= (c>>13); \\\n+  b -= c; b -= a; b ^= (a<< 8); \\\n+  c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \\\n+  a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \\\n+  b -= c; b -= a; b = (b ^ (a<<16)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>> 5)) & 0xffffffff; \\\n+  a -= b; a -= c; a = (a ^ (c>> 3)) & 0xffffffff; \\\n+  b -= c; b -= a; b = (b ^ (a<<10)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>>15)) & 0xffffffff; \\\n+}\n+\n+/*\n+--------------------------------------------------------------------\n+hash() -- hash a variable-length key into a 32-bit value\n+  k     : the key (the unaligned variable-length array of bytes)\n+  len   : the length of the key, counting by bytes\n+  level : can be any 4-byte value\n+Returns a 32-bit value.  Every bit of the key affects every bit of\n+the return value.  Every 1-bit and 2-bit delta achieves avalanche.\n+About 36+6len instructions.\n+\n+The best hash table sizes are powers of 2.  There is no need to do\n+mod a prime (mod is sooo slow!).  If you need less than 32 bits,\n+use a bitmask.  For example, if you need only 10 bits, do\n+  h = (h & hashmask(10));\n+In which case, the hash table should have hashsize(10) elements.\n+\n+If you are hashing n strings (ub1 **)k, do it like this:\n+  for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);\n+\n+By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this\n+code any way you wish, private, educational, or commercial.  It's free.\n+\n+See http://burtleburtle.net/bob/hash/evahash.html\n+Use for hash table lookup, or anything where one collision in 2^32 is\n+acceptable.  Do NOT use for cryptographic purposes.\n+--------------------------------------------------------------------\n+*/\n+\n+static hashval_t\n+iterative_hash (const void *k_in /* the key */,\n+                register size_t  length /* the length of the key */,\n+                register hashval_t initval /* the previous hash, or\n+                                              an arbitrary value */)\n+{\n+  register const unsigned char *k = (const unsigned char *)k_in;\n+  register hashval_t a,b,c,len;\n+\n+  /* Set up the internal state */\n+  len = length;\n+  a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */\n+  c = initval;           /* the previous hash value */\n+\n+  /*---------------------------------------- handle most of the key */\n+    while (len >= 12)\n+      {\n+\ta += (k[0] +((hashval_t)k[1]<<8) +((hashval_t)k[2]<<16) +((hashval_t)k[3]<<24));\n+\tb += (k[4] +((hashval_t)k[5]<<8) +((hashval_t)k[6]<<16) +((hashval_t)k[7]<<24));\n+\tc += (k[8] +((hashval_t)k[9]<<8) +((hashval_t)k[10]<<16)+((hashval_t)k[11]<<24));\n+\tmix(a,b,c);\n+\tk += 12; len -= 12;\n+      }\n+\n+  /*------------------------------------- handle the last 11 bytes */\n+  c += length;\n+  switch(len)              /* all the case statements fall through */\n+    {\n+    case 11: c+=((hashval_t)k[10]<<24);\n+    case 10: c+=((hashval_t)k[9]<<16);\n+    case 9 : c+=((hashval_t)k[8]<<8);\n+      /* the first byte of c is reserved for the length */\n+    case 8 : b+=((hashval_t)k[7]<<24);\n+    case 7 : b+=((hashval_t)k[6]<<16);\n+    case 6 : b+=((hashval_t)k[5]<<8);\n+    case 5 : b+=k[4];\n+    case 4 : a+=((hashval_t)k[3]<<24);\n+    case 3 : a+=((hashval_t)k[2]<<16);\n+    case 2 : a+=((hashval_t)k[1]<<8);\n+    case 1 : a+=k[0];\n+      /* case 0: nothing left to add */\n+    }\n+  mix(a,b,c);\n+  /*-------------------------------------------- report the result */\n+  return c;\n+}\n+\n+hashval_t\n+e_hash (const void *a)\n+{\n+  const struct entry *e = a;\n+  hashval_t ret = 0;\n+  int i;\n+\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+  for (i = 0; i <= e[0].len; ++i)\n+    {\n+      int attriblen;\n+      ret = iterative_hash (&e[i], offsetof (struct entry, attrib), ret);\n+      attriblen = e[i].attrib ? strlen (e[i].attrib) : -1;\n+      ret = iterative_hash (&attriblen, sizeof (int), ret);\n+      if (e[i].attrib)\n+        ret = iterative_hash (e[i].attrib, attriblen, ret);\n+    }\n+  return ret;\n+}\n+\n+int\n+e_eq (const void *a, const void *b)\n+{\n+  const struct entry *ea = a, *eb = b;\n+  int i;\n+  if (ea[0].etype != ETYPE_STRUCT && ea[0].etype != ETYPE_UNION)\n+    abort ();\n+  if (ea[0].len != eb[0].len)\n+    return 0;\n+  for (i = 0; i <= ea[0].len; ++i)\n+    {\n+      if (ea[i].etype != eb[i].etype\n+\t  || ea[i].len != eb[i].len\n+\t  || ea[i].arr_len != eb[i].arr_len\n+\t  || ea[i].type != eb[i].type)\n+\treturn 0;\n+      if ((ea[i].attrib == NULL) ^ (eb[i].attrib == NULL))\n+\treturn 0;\n+      if (ea[i].attrib && strcmp (ea[i].attrib, eb[i].attrib) != 0)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+static int \n+e_exists (const struct entry *e) \n+{\n+  struct entry *h;\n+  hashval_t hval;\n+\n+  hval = e_hash (e);\n+  for (h = hash_table[hval % HASH_SIZE]; h; h = h->next)\n+    if (e_eq (e, h))\n+      return 1;\n+  return 0;\n+}\n+\n+static void\n+e_insert (struct entry *e)\n+{\n+  hashval_t hval;\n+\n+  hval = e_hash (e);\n+  e->next = hash_table[hval % HASH_SIZE];\n+  hash_table[hval % HASH_SIZE] = e;\n+}\n+\n+void\n+output (struct entry *e)\n+{\n+  int i;\n+  char c;\n+  struct entry *n;\n+  const char *skip_cint = \"\";\n+\n+  if (e[0].etype != ETYPE_STRUCT && e[0].etype != ETYPE_UNION)\n+    abort ();\n+\n+  if (e_exists (e))\n+    return;\n+\n+  n = (struct entry *) malloc ((e[0].len + 1) * sizeof (struct entry));\n+  memcpy (n, e, (e[0].len + 1) * sizeof (struct entry));\n+  e_insert (n);\n+\n+  if (idx == limidx)\n+    switchfiles (e[0].len);\n+\n+  for (i = 1; i <= e[0].len; ++i)\n+    if ((e[i].etype == ETYPE_TYPE || e[i].etype == ETYPE_ARRAY)\n+\t&& (e[i].type->type == TYPE_CINT || e[i].type->type == TYPE_CUINT))\n+      break;\n+  if (i <= e[0].len)\n+    skip_cint = \"CI\";\n+  if (e[0].attrib)\n+    fprintf (outfile, (generate_random () & 1)\n+\t     ? \"TX%s(%d,%s %s,,\" : \"TX%s(%d,%s,%s,\", skip_cint,\n+\t     idx, e[0].etype == ETYPE_STRUCT ? \"struct\" : \"union\",\n+\t     e[0].attrib);\n+  else if (e[0].etype == ETYPE_STRUCT)\n+    fprintf (outfile, \"T%s(%d,\", skip_cint, idx);\n+  else\n+    fprintf (outfile, \"U%s(%d,\", skip_cint, idx);\n+  c = 'a';\n+  for (i = 1; i <= e[0].len; )\n+    i += subfield (e + i, &c);\n+  fputs (\",\", outfile);\n+  c = 'a';\n+  for (i = 1; i <= e[0].len; )\n+    {\n+      i += subvalues (e + i, namebuf, &c);\n+      if (e[0].etype == ETYPE_UNION)\n+        break;\n+    }\n+  fputs (\")\\n\", outfile);\n+  if (output_one && idx == limidx)\n+    exit (0);\n+  ++idx;\n+}\n+\n+enum FEATURE\n+{\n+  FEATURE_VECTOR = 1,\n+  FEATURE_COMPLEX = 2,\n+  FEATURE_ALIGNEDPACKED = 4,\n+  FEATURE_ZEROARRAY = 8,\n+  FEATURE_ZEROBITFLD = 16,\n+  ALL_FEATURES = FEATURE_COMPLEX | FEATURE_VECTOR | FEATURE_ZEROARRAY\n+\t\t | FEATURE_ALIGNEDPACKED | FEATURE_ZEROBITFLD\n+};\n+\n+void\n+singles (enum FEATURE features)\n+{\n+  struct entry e[2];\n+  int i;\n+  memset (e, 0, sizeof (e));\n+  e[0].etype = ETYPE_STRUCT;\n+  output (e);\n+  e[0].etype = ETYPE_UNION;\n+  output (e);\n+  for (i = 0;\n+       i < ((features & FEATURE_ALIGNEDPACKED) ? NATTRIBS2 : NATTRIBS1);\n+       ++i)\n+    {\n+      e[0].attrib = attributes[i];\n+      e[0].etype = ETYPE_STRUCT;\n+      output (e);\n+      e[0].etype = ETYPE_UNION;\n+      output (e);\n+    }\n+  e[0].len = 1;\n+  e[0].attrib = NULL;\n+  for (i = 0; i < NTYPES2; ++i)\n+    {\n+      e[0].etype = ETYPE_STRUCT;\n+      e[1].etype = ETYPE_TYPE;\n+      e[1].type = &base_types[i];\n+      output (e);\n+      e[0].etype = ETYPE_UNION;\n+      output (e);\n+    }\n+  if (features & FEATURE_COMPLEX)\n+    for (i = 0; i < NCTYPES2; ++i)\n+      {\n+\te[0].etype = ETYPE_STRUCT;\n+\te[1].etype = ETYPE_TYPE;\n+\te[1].type = &complex_types[i];\n+\toutput (e);\n+\te[0].etype = ETYPE_UNION;\n+\toutput (e);\n+      }\n+  if (features & FEATURE_VECTOR)\n+    for (i = 0; i < NVTYPES2; ++i)\n+      {\n+\te[0].etype = ETYPE_STRUCT;\n+\te[1].etype = ETYPE_TYPE;\n+\te[1].type = &vector_types[i];\n+\toutput (e);\n+\te[0].etype = ETYPE_UNION;\n+\toutput (e);\n+      }\n+}\n+\n+void\n+choose_type (enum FEATURE features, struct entry *e, int r, int in_array)\n+{\n+  int i;\n+\n+  i = NTYPES2 - NTYPES1;\n+  if (features & FEATURE_COMPLEX)\n+    i += NCTYPES2;\n+  if (features & FEATURE_VECTOR)\n+    i += NVTYPES2;\n+  if ((r & 3) == 0)\n+    {\n+      if (in_array)\n+\t{\n+\t  i += NAATYPES2;\n+\t  if (features & FEATURE_COMPLEX)\n+\t    i += NCAATYPES2;\n+\t}\n+      else\n+\t{\n+\t  i += NATYPES2;\n+\t  if (features & FEATURE_COMPLEX)\n+\t    i += NCATYPES2;\n+\t}\n+    }\n+  r >>= 2;\n+  r %= i;\n+  if (r < NTYPES2 - NTYPES1)\n+    e->type = &base_types[r + NTYPES1];\n+  r -= NTYPES2 - NTYPES1;\n+  if (e->type == NULL && (features & FEATURE_COMPLEX))\n+    {\n+      if (r < NCTYPES2)\n+\te->type = &complex_types[r];\n+      r -= NCTYPES2;\n+    }\n+  if (e->type == NULL && (features & FEATURE_VECTOR))\n+    {\n+      if (r < NVTYPES2)\n+\te->type = &vector_types[r];\n+      r -= NVTYPES2;\n+    }\n+  if (e->type == NULL && !in_array)\n+    {\n+      if (r < NATYPES2)\n+\te->type = &attrib_types[r];\n+      r -= NATYPES2;\n+    }\n+  if (e->type == NULL && !in_array && (features & FEATURE_COMPLEX))\n+    {\n+      if (r < NCATYPES2)\n+\te->type = &complex_attrib_types[r];\n+      r -= NCATYPES2;\n+    }\n+  if (e->type == NULL && in_array)\n+    {\n+      if (r < NAATYPES2)\n+\te->type = &attrib_array_types[r];\n+      r -= NAATYPES2;\n+    }\n+  if (e->type == NULL && in_array && (features & FEATURE_COMPLEX))\n+    {\n+      if (r < NCAATYPES2)\n+\te->type = &complex_attrib_array_types[r];\n+      r -= NCAATYPES2;\n+    }\n+  if (e->type == NULL)\n+    abort ();\n+}\n+\n+/* This is from gcc.c-torture/execute/builtin-bitops-1.c.  */\n+static int\n+my_ffsll (unsigned long long x)\n+{\n+  int i;\n+  if (x == 0)\n+    return 0;\n+  /* We've tested LLONG_MAX for 64 bits so this should be safe.  */\n+  for (i = 0; i < 64; i++)\n+    if (x & (1ULL << i))\n+      break;\n+  return i + 1;\n+}\n+\n+void\n+generate_fields (enum FEATURE features, struct entry *e, struct entry *parent,\n+\t\t int len)\n+{\n+  int r, i, j, ret = 1, n, incr, sametype;\n+\n+  for (n = 0; n < len; n += incr)\n+    {\n+      r = generate_random ();\n+      /* 50% ETYPE_TYPE base_types NTYPES1\n+\t 12.5% ETYPE_TYPE other\n+\t 12.5% ETYPE_ARRAY\n+\t 12.5% ETYPE_BITFLD\n+\t 12.5% ETYPE_STRUCT|ETYPE_UNION|ETYPE_STRUCT_ARRAY|ETYPE_UNION_ARRAY */\n+      i = (r & 7);\n+      r >>= 3;\n+      incr = 1;\n+      switch (i)\n+\t{\n+\tcase 6: /* BITfields disabled for now. */\n+\tcase 0:\n+\tcase 1:\n+\tcase 2:\n+\tcase 3:\n+\t  e[n].etype = ETYPE_TYPE;\n+\t  e[n].type = &base_types[r % NTYPES1];\n+\t  break;\n+\tcase 4:\n+\t  e[n].etype = ETYPE_TYPE;\n+\t  choose_type (features, &e[n], r, 0);\n+\t  break;\n+\tcase 5:\n+\t  e[n].etype = ETYPE_ARRAY;\n+\t  i = r & 1;\n+\t  r >>= 1;\n+\t  if (i)\n+\t    e[n].type = &base_types[r % NTYPES1];\n+\t  else\n+\t    choose_type (features, &e[n], r, 1);\n+\t  r = generate_random ();\n+\t  if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n+\t    {\n+\t      e[n].arr_len = 0;\n+\t      if (n == len - 1 && (r & 4)\n+\t\t  && (parent->etype == ETYPE_STRUCT\n+\t\t      || parent->etype == ETYPE_STRUCT_ARRAY))\n+\t\t{\n+\t\t  int k;\n+\t\t  for (k = 0; k < n; ++k)\n+\t\t    if (e[k].etype != ETYPE_BITFLD || e[k].len)\n+\t\t      {\n+\t\t\te[n].arr_len = 255;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\t  else if ((r & 3) != 3)\n+\t    e[n].arr_len = (r >> 2) & 7;\n+\t  else\n+\t    e[n].arr_len = (r >> 2) & 31;\n+\t  break;\n+#if 0\n+\tcase 6:\n+\t  sametype = 1;\n+\t  switch (r & 7)\n+\t    {\n+\t    case 0:\n+\t    case 1:\n+\t    case 2:\n+\t      break;\n+\t    case 3:\n+\t    case 4:\n+\t    case 5:\n+\t      incr = 1 + (r >> 3) % (len - n);\n+\t      break;\n+\t    case 6:\n+\t    case 7:\n+\t      sametype = 0;\n+\t      incr = 1 + (r >> 3) % (len - n);\n+\t      break;\n+\t    }\n+\t  for (j = n; j < n + incr; ++j)\n+\t    {\n+\t      int mi, ma;\n+\n+\t      e[j].etype = ETYPE_BITFLD;\n+\t      if (j == n || !sametype)\n+\t\t{\n+\t\t  int k;\n+\t\t  r = generate_random ();\n+\t\t  k = r & 3;\n+\t\t  r >>= 2;\n+\t\t  if (!k)\n+\t\t    e[j].type\n+\t\t      = &aligned_bitfld_types[r % n_aligned_bitfld_types];\n+\t\t  else\n+\t\t    e[j].type\n+\t\t      = &bitfld_types[r % n_bitfld_types];\n+\t\t}\n+\t      else\n+\t\te[j].type = e[n].type;\n+\t      r = generate_random ();\n+\t      mi = 0;\n+\t      ma = 0;\n+\t      switch (e[j].type->bitfld)\n+\t        {\n+\t        case 'C': ma = 8; break;\n+\t        case 'S': ma = 16; break;\n+\t        case 'I': ma = 32; break;\n+\t        case 'L':\n+\t        case 'Q': ma = 64; break;\n+\t        case 'B': ma = 1; break;\n+\t        case ' ':\n+\t\t  if (e[j].type->type == TYPE_UENUM)\n+\t\t    mi = my_ffsll (e[j].type->maxval + 1) - 1;\n+\t\t  else if (e[j].type->type == TYPE_SENUM)\n+\t\t    mi = my_ffsll (e[j].type->maxval + 1);\n+\t\t  else\n+\t\t    abort ();\n+\t\t  if (!mi)\n+\t\t    mi = 1;\n+\t\t  if (mi <= 32)\n+\t\t    ma = 32;\n+\t\t  else\n+\t\t    ma = 64;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t        }\n+\t      e[j].len = ma + 1;\n+\t      if (sametype && (r & 3) == 0 && ma > 1)\n+\t\t{\n+\t\t  int sum = 0, k;\n+\t\t  for (k = n; k < j; ++k)\n+\t\t    sum += e[k].len;\n+\t\t  sum %= ma;\n+\t\t  e[j].len = sum ? ma - sum : ma;\n+\t\t}\n+\t      r >>= 2;\n+\t      if (! (features & FEATURE_ZEROBITFLD) && mi == 0)\n+\t\tmi = 1;\n+\t      if (e[j].len < mi || e[j].len > ma)\n+\t\te[j].len = mi + (r % (ma + 1 - mi));\n+\t      r >>= 6;\n+\t      if ((features & FEATURE_ZEROBITFLD) && (r & 3) == 0\n+\t\t  && mi == 0)\n+\t\te[j].len = 0;\n+\t    }\n+\t  break;\n+#endif\n+\tcase 7:\n+\t  switch (r & 7)\n+\t    {\n+\t    case 0:\n+\t    case 1:\n+\t    case 2:\n+\t      e[n].etype = ETYPE_STRUCT;\n+\t      break;\n+\t    case 3:\n+\t    case 4:\n+\t      e[n].etype = ETYPE_UNION;\n+\t      break;\n+\t    case 5:\n+\t    case 6:\n+\t      e[n].etype = ETYPE_STRUCT_ARRAY;\n+\t      break;\n+\t    case 7:\n+\t      e[n].etype = ETYPE_UNION_ARRAY;\n+\t      break;\n+\t    }\n+\t  r >>= 3;\n+\t  e[n].len = r % (len - n);\n+\t  incr = 1 + e[n].len;\n+\t  generate_fields (features, &e[n + 1], &e[n], e[n].len);\n+\t  if (e[n].etype == ETYPE_STRUCT_ARRAY\n+\t      || e[n].etype == ETYPE_UNION_ARRAY)\n+\t    {\n+\t      r = generate_random ();\n+\t      if ((features & FEATURE_ZEROARRAY) && (r & 3) == 0)\n+\t\t{\n+\t\t  e[n].arr_len = 0;\n+\t\t  if (n + incr == len && (r & 4)\n+\t\t      && (parent->etype == ETYPE_STRUCT\n+\t\t\t  || parent->etype == ETYPE_STRUCT_ARRAY))\n+\t\t    {\n+\t\t      int k;\n+\t\t      for (k = 0; k < n; ++k)\n+\t\t\tif (e[k].etype != ETYPE_BITFLD || e[k].len)\n+\t\t\t  {\n+\t\t\t    e[n].arr_len = 255;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t      else if ((r & 3) != 3)\n+\t\te[n].arr_len = (r >> 2) & 7;\n+\t      else\n+\t\te[n].arr_len = (r >> 2) & 31;\n+\t    }\n+\t  break;\n+\t}\n+      r = generate_random ();\n+      if (0 && (r & 7) == 0)\n+\t{\n+\t  r >>= 3;\n+\t  i = (features & FEATURE_ALIGNEDPACKED) ? NATTRIBS2 : NATTRIBS1;\n+\t  e[n].attrib = attributes[r % i];\n+\t  if (! (features & FEATURE_ALIGNEDPACKED)\n+\t      && strcmp (e[n].attrib, \"atpa\") == 0\n+\t      && ((e[n].type >= &attrib_types[0]\n+\t\t   && e[n].type < &attrib_types[NATYPES2])\n+\t\t  || (e[n].type >= &complex_attrib_types[0]\n+\t\t      && e[n].type < &complex_attrib_types[NCATYPES2])\n+\t\t  || (e[n].type >= &attrib_array_types[0]\n+\t\t      && e[n].type < &attrib_array_types[NAATYPES2])\n+\t\t  || (e[n].type >= &complex_attrib_array_types[0]\n+\t\t      && e[n].type < &complex_attrib_array_types[NAATYPES2])\n+\t\t  || (e[n].type >= &aligned_bitfld_types[0]\n+\t\t      && e[n].type < &aligned_bitfld_types[n_aligned_bitfld_types])))\n+\t    e[n].attrib = NULL;\n+\n+\t  /* If this is an array type, do not put aligned attributes on\n+\t     elements.  Aligning elements to a value greater than their\n+\t     size will result in a compiler error.  */\n+\n+\t  if ((e[n].etype == ETYPE_ARRAY)\n+\t      && e[n].attrib != NULL\n+\t      && (strncmp (e[n].attrib, \"atal\", 4) == 0))\n+            e[n].attrib = NULL;\n+\t}\n+    }\n+}\n+\n+void\n+generate_random_tests (enum FEATURE features, int len)\n+{\n+  struct entry e[len + 1];\n+  int i, r;\n+  if (len > 'z' - 'a' + 1)\n+    abort ();\n+  memset (e, 0, sizeof (e));\n+  r = generate_random ();\n+  if ((r & 7) == 0)\n+    e[0].etype = ETYPE_UNION;\n+  else\n+    e[0].etype = ETYPE_STRUCT;\n+  r >>= 3;\n+  e[0].len = len;\n+  if (0 && (r & 31) == 0)\n+    {\n+      r >>= 5;\n+      if (features & FEATURE_ALIGNEDPACKED)\n+\tr %= NATTRIBS2;\n+      else\n+\tr %= NATTRIBS1;\n+      e[0].attrib = attributes[r];\n+    }\n+  generate_fields (features, &e[1], &e[0], len);\n+  output (e);\n+}\n+\n+struct { const char *name; enum FEATURE f; }\n+features[] = {\n+{ \"normal\", 0 },\n+{ \"complex\", FEATURE_COMPLEX },\n+{ \"vector\", FEATURE_VECTOR },\n+/*\n+{ \"[0] :0\", FEATURE_ZEROARRAY | FEATURE_ZEROBITFLD },\n+{ \"complex vector [0]\",\n+  FEATURE_COMPLEX | FEATURE_VECTOR | FEATURE_ZEROARRAY },\n+{ \"aligned packed complex vector [0] :0\",\n+  FEATURE_COMPLEX | FEATURE_VECTOR | FEATURE_ZEROARRAY\n+  | FEATURE_ALIGNEDPACKED | FEATURE_ZEROBITFLD },*/\n+};\n+\n+int\n+main (int argc, char **argv)\n+{\n+  int i, j, count, c, n = 3000;\n+  char *optarg;\n+\n+  if (sizeof (int) != 4 || sizeof (long long) != 8)\n+    return 1;\n+  \n+  i = 1;\n+  while (i < argc) \n+    {\n+      c = '\\0';\n+      if (argv[i][0] == '-' && argv[i][2] == '\\0')\n+\tc = argv[i][1];\n+      optarg = argv[i + 1];\n+      if (!optarg)\n+\tgoto usage;\n+      switch (c)\n+\t{\n+\tcase 'n':\n+\t  n = atoi (optarg);\n+\t  break;\n+\tcase 'd':\n+\t  destdir = optarg;\n+\t  break;\n+\tcase 's':\n+\t  srcdir = optarg;\n+\t  break;\n+\tcase 'i':\n+\t  output_one = 1;\n+\t  limidx = atoi (optarg);\n+\t  break;\n+\tdefault:\n+\t  fprintf (stderr, \"unrecognized option %s\\n\", argv[i]);\n+\t  goto usage;\n+      }\n+      i += 2;\n+    }\n+\n+  if (output_one)\n+    {\n+      outfile = fopen (\"/dev/null\", \"w\");\n+      if (outfile == NULL)\n+        {\n+\t  fputs (\"could not open /dev/null\", stderr);\n+\t  return 1;\n+        }\n+      n = limidx + 1;\n+    }\n+\n+  if (destdir == NULL && !output_one)\n+    {\n+    usage:\n+      fprintf (stderr, \"Usage:\\n\\\n+%s [-s srcdir -d destdir] [-n count] [-i idx]\\n\\\n+Either -s srcdir -d destdir or -i idx must be used\\n\", argv[0]);\n+      return 1;\n+    }\n+\n+  if (srcdir == NULL && !output_one)\n+    goto usage;\n+\n+  for (i = 0; i < NTYPES2; ++i)\n+    if (base_types[i].bitfld)\n+      bitfld_types[n_bitfld_types++] = base_types[i];\n+  for (i = 0; i < NATYPES2; ++i)\n+    if (attrib_types[i].bitfld)\n+      aligned_bitfld_types[n_aligned_bitfld_types++] = attrib_types[i];\n+  for (i = 0; i < sizeof (features) / sizeof (features[0]); ++i)\n+    {\n+      int startidx = idx;\n+      if (! output_one)\n+\tlimidx = idx;\n+      if (!i)\n+        count = 200;\n+      else\n+        count = 20;\n+      for (j = 1; j <= 9; ++j)\n+        while (idx < startidx + j * count)\n+\t  generate_random_tests (features[i].f, j);\n+      while (idx < startidx + count * 10)\n+\tgenerate_random_tests (features[i].f, 10 + (generate_random () % 16));\n+    }\n+  for (i = 0; n > 3000 && i < sizeof (features) / sizeof (features[0]); ++i)\n+    {\n+      int startidx;\n+      startidx = idx;\n+      if (! output_one)\n+\tlimidx = idx;\n+      singles (features[i].f);\n+      if (!i)\n+\t{\n+\t  count = 1000;\n+\t  while (idx < startidx + 1000)\n+\t    generate_random_tests (features[i].f, 1);\n+\t}\n+      else\n+\t{\n+\t  startidx = idx;\n+\t  count = 100;\n+\t  while (idx < startidx + 100)\n+\t    generate_random_tests (features[i].f, 1);\n+\t}\n+      startidx = idx;\n+      for (j = 2; j <= 9; ++j)\n+\twhile (idx < startidx + (j - 1) * count)\n+\t  generate_random_tests (features[i].f, j);\n+      while (idx < startidx + count * 9)\n+        generate_random_tests (features[i].f, 10 + (generate_random () % 16));\n+    }\n+  if (! output_one)\n+    limidx = idx;\n+ // while (idx < n)\n+ //   generate_random_tests (ALL_FEATURES, 1 + (generate_random () % 25));\n+  fclose (outfile);\n+  return 0;\n+}"}, {"sha": "57140f115cd02596aec770613570324b0a72b525", "filename": "gcc/testsuite/objc.dg/gnu-encoding/vector-defs.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fvector-defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fvector-defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-encoding%2Fvector-defs.h?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -0,0 +1,72 @@\n+/* This includes all of the vector modes that are recognized by\n+   c_common_type_for_mode.  */\n+\n+typedef int __attribute__((mode(QI))) qi;\n+typedef int __attribute__((mode(HI))) hi;\n+typedef int __attribute__((mode(SI))) si;\n+typedef int __attribute__((mode(DI))) di;\n+typedef float __attribute__((mode(SF))) sf;\n+typedef float __attribute__((mode(DF))) df;\n+\n+#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 5)\n+\n+typedef qi __attribute__((vector_size (8))) v8qi;\n+typedef qi __attribute__((vector_size (16))) v16qi;\n+\n+typedef hi __attribute__((vector_size (4))) v2hi;\n+typedef hi __attribute__((vector_size (8))) v4hi;\n+typedef hi __attribute__((vector_size (16))) v8hi;\n+\n+typedef si __attribute__((vector_size (8))) v2si;\n+typedef si __attribute__((vector_size (16))) v4si;\n+\n+typedef di __attribute__((vector_size (8))) v1di;\n+typedef di __attribute__((vector_size (16))) v2di;\n+\n+typedef sf __attribute__((vector_size (8))) v2sf;\n+typedef sf __attribute__((vector_size (16))) v4sf;\n+typedef sf __attribute__((vector_size (64))) v16sf;\n+\n+typedef df __attribute__((vector_size (16))) v2df;\n+\n+#else\n+\n+typedef int __attribute__((mode(V8QI))) v8qi;\n+typedef int __attribute__((mode(V16QI))) v16qi;\n+\n+typedef int __attribute__((mode(V2HI))) v2hi;\n+typedef int __attribute__((mode(V4HI))) v4hi;\n+typedef int __attribute__((mode(V8HI))) v8hi;\n+\n+typedef int __attribute__((mode(V2SI))) v2si;\n+typedef int __attribute__((mode(V4SI))) v4si;\n+\n+typedef int __attribute__((mode(V1DI))) v1di;\n+typedef int __attribute__((mode(V2DI))) v2di;\n+\n+typedef float __attribute__((mode(V2SF))) v2sf;\n+typedef float __attribute__((mode(V4SF))) v4sf;\n+typedef float __attribute__((mode(V16SF))) v16sf;\n+\n+typedef float __attribute__((mode(V2DF))) v2df;\n+\n+#endif\n+\n+typedef union U8QI { v8qi v; qi a[8]; } u8qi;\n+typedef union U16QI { v16qi v; qi a[16]; } u16qi;\n+\n+typedef union U2HI { v2hi v; hi a[2]; } u2hi;\n+typedef union U4HI { v4hi v; hi a[4]; } u4hi;\n+typedef union U8HI { v8hi v; hi a[8]; } u8hi;\n+\n+typedef union U2SI { v2si v; si a[2]; } u2si;\n+typedef union U4SI { v4si v; si a[4]; } u4si;\n+\n+typedef union U1DI { v1di v; di a[1]; } u1di;\n+typedef union U2DI { v2di v; di a[2]; } u2di;\n+\n+typedef union U2SF { v2sf v; sf a[2]; } u2sf;\n+typedef union U4SF { v4sf v; sf a[4]; } u4sf;\n+typedef union U16SF { v16sf v; sf a[16]; } u16sf;\n+\n+typedef union U2DF { v2df v; df a[2]; } u2df;"}, {"sha": "8273db801efa52515fc6b7114f468d501a55a434", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -1,3 +1,12 @@\n+2005-12-12  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* encoding.c (TYPE_FIELDS): Fix to skip over just _C_STRUCT_B and\n+\tthe name.\n+\t(get_inner_array_type): Fix to skip over _C_ARY_B and size.\n+\t(rs6000_special_round_type_align): Update for the ABI fix.\n+\t(objc_layout_finish_structure): Correct the encoding which is passed to\n+\tROUND_TYPE_ALIGN.\n+\n 2005-12-11  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR libobjc/25347"}, {"sha": "af6b93d4498c92f5efd10c9d52945bdf4a6a1277", "filename": "libobjc/encoding.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/761c0d29cba01652030743630ae66dd4d5c58946/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/761c0d29cba01652030743630ae66dd4d5c58946/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=761c0d29cba01652030743630ae66dd4d5c58946", "patch": "@@ -67,14 +67,24 @@ Boston, MA 02110-1301, USA.  */\n \n #define VECTOR_TYPE\t_C_VECTOR\n \n-#define TYPE_FIELDS(TYPE)     objc_skip_typespec (TYPE)\n+#define TYPE_FIELDS(TYPE)           ({const char *_field = (TYPE)+1; \\\n+    while (*_field != _C_STRUCT_E && *_field != _C_STRUCT_B \\\n+           && *_field != _C_UNION_B && *_field++ != '=') \\\n+    /* do nothing */; \\\n+    _field;})\n \n #define DECL_MODE(TYPE) *(TYPE)\n #define TYPE_MODE(TYPE) *(TYPE)\n \n #define DFmode          _C_DBL\n \n-#define get_inner_array_type(TYPE)      ((TYPE) + 1)\n+#define get_inner_array_type(TYPE)      ({const char *_field = (TYPE); \\\n+  while (*_field == _C_ARY_B)\\\n+    {\\\n+      while (isdigit ((unsigned char)*++_field))\\\n+\t;\\\n+    }\\\n+    _field;})\n \n /* Some ports (eg ARM) allow the structure size boundary to be\n    selected at compile-time.  We override the normal definition with\n@@ -103,10 +113,13 @@ static int __attribute__ ((__unused__)) not_target_flags = 0;\n     is only way around without really rewritting this file,\n     should look after the branch of 3.4 to fix this.  */\n #define rs6000_special_round_type_align(STRUCT, COMPUTED, SPECIFIED)\t\\\n-  ((TYPE_FIELDS (STRUCT) != 0\t\t\t\t\t\t\\\n-    && DECL_MODE (TYPE_FIELDS (STRUCT)) == DFmode)\t\t\t\\\n+  ({ const char *_fields = TYPE_FIELDS (STRUCT);\t\t\t\t\\\n+  ((_fields != 0\t\t\t\t\t\t\t\\\n+    && TYPE_MODE (TREE_CODE (TREE_TYPE (_fields)) == ARRAY_TYPE\t\t\\\n+\t\t    ? get_inner_array_type (_fields)\t\t\t\\\n+\t\t    : TREE_TYPE (_fields)) == DFmode)\t\t\t\\\n    ? MAX (MAX (COMPUTED, SPECIFIED), 64)\t\t\t\t\\\n-   : MAX (COMPUTED, SPECIFIED))\n+   : MAX (COMPUTED, SPECIFIED));})\n \n /*\n   return the size of an object specified by type\n@@ -901,9 +914,8 @@ void objc_layout_finish_structure (struct objc_struct_layout *layout,\n       /* Work out the alignment of the record as one expression and store\n          in the record type.  Round it up to a multiple of the record's\n          alignment. */\n-\n #if defined (ROUND_TYPE_ALIGN) && ! defined (__sparc__)\n-      layout->record_align = ROUND_TYPE_ALIGN (layout->original_type,\n+      layout->record_align = ROUND_TYPE_ALIGN (layout->original_type-1,\n                                                1,\n                                                layout->record_align);\n #else"}]}