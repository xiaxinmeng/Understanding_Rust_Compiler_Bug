{"sha": "a278b1c38f8bc1f14f6d07c303b81a8856491efa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI3OGIxYzM4ZjhiYzFmMTRmNmQwN2MzMDNiODFhODg1NjQ5MWVmYQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-03-09T09:26:45Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-03-09T09:26:45Z"}, "message": "Support BIT_FIELD_REF in MPX (PR ipa/79764).\n\n2017-03-09  Martin Liska  <mliska@suse.cz>\n\n\tPR ipa/79764\n\t(chkp_narrow_size_and_offset): New function.\n\t(chkp_parse_array_and_component_ref): Support BIT_FIELD_REF.\n\t(void chkp_parse_bit_field_ref): New function.\n\t(chkp_make_addressed_object_bounds): Add case for BIT_FIELD_REF.\n\t(chkp_process_stmt): Use chkp_parse_bit_field_ref.\n2017-03-09  Martin Liska  <mliska@suse.cz>\n\n\tPR ipa/79764\n\t* g++.dg/pr79764.C: New test.\n\nFrom-SVN: r245994", "tree": {"sha": "7d1ac3e0301a2d14141b00cf32cd4f0e82288e67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d1ac3e0301a2d14141b00cf32cd4f0e82288e67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a278b1c38f8bc1f14f6d07c303b81a8856491efa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a278b1c38f8bc1f14f6d07c303b81a8856491efa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a278b1c38f8bc1f14f6d07c303b81a8856491efa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a278b1c38f8bc1f14f6d07c303b81a8856491efa/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dc19053e1f5af5af97ce7b9e8ebd6e657b23277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc19053e1f5af5af97ce7b9e8ebd6e657b23277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc19053e1f5af5af97ce7b9e8ebd6e657b23277"}], "stats": {"total": 114, "additions": 98, "deletions": 16}, "files": [{"sha": "752a5324b0dd75f76b3a8d4f95b0acbf71e4927b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a278b1c38f8bc1f14f6d07c303b81a8856491efa", "patch": "@@ -1,3 +1,12 @@\n+2017-03-09  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/79764\n+\t(chkp_narrow_size_and_offset): New function.\n+\t(chkp_parse_array_and_component_ref): Support BIT_FIELD_REF.\n+\t(void chkp_parse_bit_field_ref): New function.\n+\t(chkp_make_addressed_object_bounds): Add case for BIT_FIELD_REF.\n+\t(chkp_process_stmt): Use chkp_parse_bit_field_ref.\n+\n 2017-03-09  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/79761"}, {"sha": "4c8ee64b255fa4752e89504b68f72b6f88c2e5b6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a278b1c38f8bc1f14f6d07c303b81a8856491efa", "patch": "@@ -1,3 +1,8 @@\n+2017-03-09  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/79764\n+\t* g++.dg/pr79764.C: New test.\n+\n 2017-03-09  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/79761"}, {"sha": "293aa33769309eb4fef1098cd06c5acb1cda3ff0", "filename": "gcc/testsuite/g++.dg/pr79764.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79764.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79764.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr79764.C?ref=a278b1c38f8bc1f14f6d07c303b81a8856491efa", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target { { i?86-*-* x86_64-*-* } && { ! x32 } } } } */\n+/* { dg-options \"-fcheck-pointer-bounds -mmpx\" } */\n+\n+typedef float __m256 __attribute__ (( __vector_size__(32), __may_alias__ ));\n+struct A {\n+  __m256 ymm;\n+  const float &f() const;\n+};\n+\n+const float &A::f() const {\n+  return ymm[1];\n+}"}, {"sha": "acd57eac5efdbdfbac0f5594a9b1ee10baa6b2da", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a278b1c38f8bc1f14f6d07c303b81a8856491efa/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=a278b1c38f8bc1f14f6d07c303b81a8856491efa", "patch": "@@ -325,6 +325,8 @@ static void chkp_parse_array_and_component_ref (tree node, tree *ptr,\n \t\t\t\t\t\ttree *bounds,\n \t\t\t\t\t\tgimple_stmt_iterator *iter,\n \t\t\t\t\t\tbool innermost_bounds);\n+static void chkp_parse_bit_field_ref (tree node, location_t loc,\n+\t\t\t\t      tree *offset, tree *size);\n \n #define chkp_bndldx_fndecl \\\n   (targetm.builtin_chkp_function (BUILT_IN_CHKP_BNDLDX))\n@@ -3295,7 +3297,7 @@ chkp_narrow_bounds_for_field (tree ref, tree field)\n   if (!chkp_may_narrow_to_field (ref, field))\n     return false;\n \n-  /* Accesse to compiler generated fields should not cause\n+  /* Access to compiler generated fields should not cause\n      bounds narrowing.  */\n   if (DECL_ARTIFICIAL (field))\n     return false;\n@@ -3309,9 +3311,36 @@ chkp_narrow_bounds_for_field (tree ref, tree field)\n \t      || bit_offs));\n }\n \n+/* Perform narrowing for BOUNDS of an INNER reference.  Shift boundary\n+   by OFFSET bytes and limit to SIZE bytes.  Newly created statements are\n+   added to ITER.  */\n+\n+static tree\n+chkp_narrow_size_and_offset (tree bounds, tree inner, tree offset,\n+\t\t\t     tree size, gimple_stmt_iterator *iter)\n+{\n+  tree addr = chkp_build_addr_expr (unshare_expr (inner));\n+  tree t = TREE_TYPE (addr);\n+\n+  gimple *stmt = gimple_build_assign (NULL_TREE, addr);\n+  addr = make_temp_ssa_name (t, stmt, CHKP_BOUND_TMP_NAME);\n+  gimple_assign_set_lhs (stmt, addr);\n+  gsi_insert_seq_before (iter, stmt, GSI_SAME_STMT);\n+\n+  stmt = gimple_build_assign (NULL_TREE, POINTER_PLUS_EXPR, addr, offset);\n+  tree shifted = make_temp_ssa_name (t, stmt, CHKP_BOUND_TMP_NAME);\n+  gimple_assign_set_lhs (stmt, shifted);\n+  gsi_insert_seq_before (iter, stmt, GSI_SAME_STMT);\n+\n+  tree bounds2 = chkp_make_bounds (shifted, size, iter, false);\n+\n+  return chkp_intersect_bounds (bounds, bounds2, iter);\n+}\n+\n /* Perform narrowing for BOUNDS using bounds computed for field\n    access COMPONENT.  ITER meaning is the same as for\n    chkp_intersect_bounds.  */\n+\n static tree\n chkp_narrow_bounds_to_field (tree bounds, tree component,\n \t\t\t    gimple_stmt_iterator *iter)\n@@ -3364,7 +3393,8 @@ chkp_parse_array_and_component_ref (tree node, tree *ptr,\n   len = 1;\n   while (TREE_CODE (var) == COMPONENT_REF\n \t || TREE_CODE (var) == ARRAY_REF\n-\t || TREE_CODE (var) == VIEW_CONVERT_EXPR)\n+\t || TREE_CODE (var) == VIEW_CONVERT_EXPR\n+\t || TREE_CODE (var) == BIT_FIELD_REF)\n     {\n       var = TREE_OPERAND (var, 0);\n       len++;\n@@ -3383,9 +3413,10 @@ chkp_parse_array_and_component_ref (tree node, tree *ptr,\n   if (bounds)\n     *bounds = NULL;\n   *safe = true;\n-  *bitfield = (TREE_CODE (node) == COMPONENT_REF\n-\t       && DECL_BIT_FIELD_TYPE (TREE_OPERAND (node, 1)));\n-  /* To get bitfield address we will need outer elemnt.  */\n+  *bitfield = ((TREE_CODE (node) == COMPONENT_REF\n+\t       && DECL_BIT_FIELD_TYPE (TREE_OPERAND (node, 1)))\n+\t       || TREE_CODE (node) == BIT_FIELD_REF);\n+  /* To get bitfield address we will need outer element.  */\n   if (*bitfield)\n     *elt = nodes[len - 2];\n   else\n@@ -3455,6 +3486,17 @@ chkp_parse_array_and_component_ref (tree node, tree *ptr,\n \t      comp_to_narrow = NULL;\n \t    }\n \t}\n+      else if (TREE_CODE (var) == BIT_FIELD_REF)\n+\t{\n+\t  if (flag_chkp_narrow_bounds && bounds)\n+\t    {\n+\t      tree offset, size;\n+\t      chkp_parse_bit_field_ref (var, UNKNOWN_LOCATION, &offset, &size);\n+\t      *bounds\n+\t\t= chkp_narrow_size_and_offset (*bounds, TREE_OPERAND (var, 0),\n+\t\t\t\t\t       offset, size, iter);\n+\t    }\n+\t}\n       else if (TREE_CODE (var) == VIEW_CONVERT_EXPR)\n \t/* Nothing to do for it.  */\n \t;\n@@ -3469,6 +3511,27 @@ chkp_parse_array_and_component_ref (tree node, tree *ptr,\n     *bounds = chkp_find_bounds (*ptr, iter);\n }\n \n+/* Parse BIT_FIELD_REF to a NODE for a given location LOC.  Return OFFSET\n+   and SIZE in bytes.  */\n+\n+static\n+void chkp_parse_bit_field_ref (tree node, location_t loc, tree *offset,\n+\t\t\t       tree *size)\n+{\n+  tree bpu = fold_convert (size_type_node, bitsize_int (BITS_PER_UNIT));\n+  tree offs = fold_convert (size_type_node, TREE_OPERAND (node, 2));\n+  tree rem = size_binop_loc (loc, TRUNC_MOD_EXPR, offs, bpu);\n+  offs = size_binop_loc (loc, TRUNC_DIV_EXPR, offs, bpu);\n+\n+  tree s = fold_convert (size_type_node, TREE_OPERAND (node, 1));\n+  s = size_binop_loc (loc, PLUS_EXPR, s, rem);\n+  s = size_binop_loc (loc, CEIL_DIV_EXPR, s, bpu);\n+  s = fold_convert (size_type_node, s);\n+\n+  *offset = offs;\n+  *size = s;\n+}\n+\n /* Compute and return bounds for address of OBJ.  */\n static tree\n chkp_make_addressed_object_bounds (tree obj, gimple_stmt_iterator *iter)\n@@ -3492,6 +3555,7 @@ chkp_make_addressed_object_bounds (tree obj, gimple_stmt_iterator *iter)\n \n     case ARRAY_REF:\n     case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n       {\n \ttree elt;\n \ttree ptr;\n@@ -3993,23 +4057,15 @@ chkp_process_stmt (gimple_stmt_iterator *iter, tree node,\n \n     case BIT_FIELD_REF:\n       {\n-\ttree offs, rem, bpu;\n+\ttree offset, size;\n \n \tgcc_assert (!access_offs);\n \tgcc_assert (!access_size);\n \n-\tbpu = fold_convert (size_type_node, bitsize_int (BITS_PER_UNIT));\n-\toffs = fold_convert (size_type_node, TREE_OPERAND (node, 2));\n-\trem = size_binop_loc (loc, TRUNC_MOD_EXPR, offs, bpu);\n-\toffs = size_binop_loc (loc, TRUNC_DIV_EXPR, offs, bpu);\n-\n-\tsize = fold_convert (size_type_node, TREE_OPERAND (node, 1));\n-        size = size_binop_loc (loc, PLUS_EXPR, size, rem);\n-        size = size_binop_loc (loc, CEIL_DIV_EXPR, size, bpu);\n-        size = fold_convert (size_type_node, size);\n+\tchkp_parse_bit_field_ref (node, loc, &offset, &size);\n \n \tchkp_process_stmt (iter, TREE_OPERAND (node, 0), loc,\n-\t\t\t dirflag, offs, size, safe);\n+\t\t\t   dirflag, offset, size, safe);\n \treturn;\n       }\n       break;"}]}