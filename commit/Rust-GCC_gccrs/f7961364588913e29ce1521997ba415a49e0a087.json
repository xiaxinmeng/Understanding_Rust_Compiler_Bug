{"sha": "f7961364588913e29ce1521997ba415a49e0a087", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc5NjEzNjQ1ODg5MTNlMjljZTE1MjE5OTdiYTQxNWE0OWUwYTA4Nw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2014-04-23T10:35:49Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2014-04-23T10:35:49Z"}, "message": "msp430.c (msp430_handle_option): Move function to msp430-common.c\n\n\t* config/msp430/msp430.c (msp430_handle_option): Move function\n\tto msp430-common.c\n\t(msp430_option_override): Simplify mcu and mcpu option handling.\n\t(msp430_is_f5_mcu): Rename to msp430_use_f5_series_hwmult.  Add\n\tsupport for -mhwmult command line option.\n\t(has_32bit_hwmult): Rename to use_32bit_hwmult.  Add support for\n\t-mhwmult command line option.\n\t(msp430_hwmult_enabled): Delete.\n\t(msp43o_output_labelref): Add support for -mhwmult command line\n\toption.\n\t* config/msp430/msp430.md (mulhisi3, umulhisi3, mulsidi3)\n\t(umulsidi3): Likewise.\n\t* config/msp430/msp430.opt (mmcu): Add Report attribute.\n\t(mcpu, mlarge, msmall): Likewise.\n\t(mhwmult): New option.\n\t* config/msp430/msp430-protos.h (msp430_hwmult_enabled): Remove\n\tprototype.\n\t(msp430_is_f5_mcu): Remove prototype.\n\t(msp430_use_f5_series_hwmult): Add prototype.\n\t* config/msp430/msp430-opts.h: New file.\n\t* common/config/msp430: New directory.\n\t* common/config/msp430/msp430-common.c: New file.\n\t* config.gcc (msp430): Remove target_has_targetm_common.\n\t* doc/invoke.texi: Document -mhwmult command line option.\n\nFrom-SVN: r209685", "tree": {"sha": "e6d366b90183a341f777c2d97b420c3e3e9b1893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6d366b90183a341f777c2d97b420c3e3e9b1893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7961364588913e29ce1521997ba415a49e0a087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7961364588913e29ce1521997ba415a49e0a087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7961364588913e29ce1521997ba415a49e0a087", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7961364588913e29ce1521997ba415a49e0a087/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f78ecdbe08233a96bad6d268a6bd06c754949b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f78ecdbe08233a96bad6d268a6bd06c754949b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f78ecdbe08233a96bad6d268a6bd06c754949b0"}], "stats": {"total": 345, "additions": 248, "deletions": 97}, "files": [{"sha": "0fe6f7bbe6e3ccab27b82772dc3a4dcd55952f52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -1,3 +1,30 @@\n+2014-04-23  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/msp430/msp430.c (msp430_handle_option): Move function\n+\tto msp430-common.c\n+\t(msp430_option_override): Simplify mcu and mcpu option handling.\n+\t(msp430_is_f5_mcu): Rename to msp430_use_f5_series_hwmult.  Add\n+\tsupport for -mhwmult command line option.\n+\t(has_32bit_hwmult): Rename to use_32bit_hwmult.  Add support for\n+\t-mhwmult command line option.\n+\t(msp430_hwmult_enabled): Delete.\n+\t(msp43o_output_labelref): Add support for -mhwmult command line\n+\toption.\n+\t* config/msp430/msp430.md (mulhisi3, umulhisi3, mulsidi3)\n+\t(umulsidi3): Likewise.\n+\t* config/msp430/msp430.opt (mmcu): Add Report attribute.\n+\t(mcpu, mlarge, msmall): Likewise.\n+\t(mhwmult): New option.\n+\t* config/msp430/msp430-protos.h (msp430_hwmult_enabled): Remove\n+\tprototype.\n+\t(msp430_is_f5_mcu): Remove prototype.\n+\t(msp430_use_f5_series_hwmult): Add prototype.\n+\t* config/msp430/msp430-opts.h: New file.\n+\t* common/config/msp430: New directory.\n+\t* common/config/msp430/msp430-common.c: New file.\n+\t* config.gcc (msp430): Remove target_has_targetm_common.\n+\t* doc/invoke.texi: Document -mhwmult command line option.\n+\n 2014-04-23  Nick Clifton  <nickc@redhat.com>\n \n \t* config/i386/cygwin.h (ENDFILE_SPEC): Include"}, {"sha": "fc2c1f27d453d0a9297dba82ae95e8e44310a54f", "filename": "gcc/common/config/msp430/msp430-common.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fcommon%2Fconfig%2Fmsp430%2Fmsp430-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fcommon%2Fconfig%2Fmsp430%2Fmsp430-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fmsp430%2Fmsp430-common.c?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -0,0 +1,91 @@\n+/* Common hooks for Texas Instruments MSP430.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic-core.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+\n+/* Handle -mcpu= and -mmcu= here.  We want to ensure that only one\n+   of these two options - the last specified on the command line -\n+   is passed on to the msp430 backend.  */\n+\n+static bool\n+msp430_handle_option (struct gcc_options *opts ATTRIBUTE_UNUSED,\n+\t\t      struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n+\t\t      const struct cl_decoded_option *decoded,\n+\t\t      location_t loc ATTRIBUTE_UNUSED)\n+{\n+  switch (decoded->opt_index)\n+    {\n+    case OPT_mcpu_:\n+      if (strcasecmp (decoded->arg, \"msp430x\") == 0\n+\t  || strcasecmp (decoded->arg, \"msp430xv2\") == 0\n+\t  || strcasecmp (decoded->arg, \"430x\") == 0\n+\t  || strcasecmp (decoded->arg, \"430xv2\") == 0)\n+\t{\n+\t  target_cpu = \"msp430x\";\n+\t  target_mcu = NULL;\n+\t}\n+      else if (strcasecmp (decoded->arg, \"msp430\") == 0\n+\t       || strcasecmp (decoded->arg, \"430\") == 0)\n+\t{\n+\t  target_cpu = \"msp430\";\n+\t  target_mcu = NULL;\n+\t}\n+      else\n+\t{\n+\t  error (\"unrecognised argument of -mcpu: %s\", decoded->arg);\n+\t  return false;\n+\t}\n+      break;\n+\n+    case OPT_mmcu_:\n+      /* For backwards compatibility we recognise two generic MCU\n+\t 430X names.  However we want to be able to generate special C\n+\t preprocessor defines for them, which is why we set target_mcu\n+\t to NULL.  */\n+      if (strcasecmp (decoded->arg, \"msp430\") == 0)\n+\t{\n+\t  target_cpu = \"msp430\";\n+\t  target_mcu = NULL;\n+\t}\n+      else if (strcasecmp (decoded->arg, \"msp430x\") == 0\n+\t       || strcasecmp (decoded->arg, \"msp430xv2\") == 0)\n+\t{\n+\t  target_cpu = \"msp430x\";\n+\t  target_mcu = NULL;\n+\t}\n+      else\n+\ttarget_cpu = NULL;\n+      break;\n+    }\n+      \n+  return true;\n+}\n+\n+#undef  TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION\t\t\tmsp430_handle_option\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "92f8a94b3e67e1eeda3a246f83c6fb6df213de8c", "filename": "gcc/config.gcc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -2108,7 +2108,6 @@ msp430*-*-*)\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n \tc_target_objs=\"msp430-c.o\"\n \tcxx_target_objs=\"msp430-c.o\"\n-\ttarget_has_targetm_common=no\n \ttmake_file=\"${tmake_file} msp430/t-msp430\"\n \t;;\n nds32le-*-*)"}, {"sha": "119cfcb7fc7738414d4ce446ed48a2f39192448f", "filename": "gcc/config/msp430/msp430-opts.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-opts.h?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -0,0 +1,32 @@\n+/* GCC option-handling definitions for the TI MSP430\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef MSP430_OPTS_H\n+#define MSP430_OPTS_H\n+\n+enum msp430_hwmult_types\n+{\n+  NONE,\n+  AUTO,\n+  SMALL,\n+  LARGE,\n+  F5SERIES\n+};\n+\n+#endif"}, {"sha": "f0b8aea0306b095fc3077b2c77d4100f0c33c544", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -30,11 +30,9 @@ const char * msp430x_extendhisi (rtx *);\n void\tmsp430_fixup_compare_operands (enum machine_mode, rtx *);\n int\tmsp430_hard_regno_mode_ok (int, enum machine_mode);\n int\tmsp430_hard_regno_nregs (int, enum machine_mode);\n-bool    msp430_hwmult_enabled (void);\n rtx\tmsp430_incoming_return_addr_rtx (void);\n void\tmsp430_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n int\tmsp430_initial_elimination_offset (int, int);\n-bool    msp430_is_f5_mcu (void);\n bool    msp430_is_interrupt_func (void);\n const char * msp430x_logical_shift_right (rtx);\n const char * msp430_mcu_name (void);\n@@ -45,5 +43,6 @@ rtx\tmsp430_return_addr_rtx (int);\n void\tmsp430_split_movsi (rtx *);\n void    msp430_start_function (FILE *, const char *, tree);\n rtx\tmsp430_subreg (enum machine_mode, rtx, enum machine_mode, int);\n+bool    msp430_use_f5_series_hwmult (void);\n \n #endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "63812705d0b1c59436179b9cfd34e9694f9b0845", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 27, "deletions": 68, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -95,18 +95,6 @@ msp430_init_machine_status (void)\n   return m;\n }\n \n-#undef  TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION msp430_handle_option\n-\n-bool\n-msp430_handle_option (struct gcc_options *opts ATTRIBUTE_UNUSED,\n-\t\t      struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n-\t\t      const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n-\t\t      location_t loc ATTRIBUTE_UNUSED)\n-{\n-  return true;\n-}\n-\n #undef  TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE\t\tmsp430_option_override\n \n@@ -196,19 +184,14 @@ msp430_option_override (void)\n \n   if (target_cpu)\n     {\n-      if (strcasecmp (target_cpu, \"msp430x\") == 0\n-\t  || strcasecmp (target_cpu, \"msp430xv2\") == 0\n-\t  || strcasecmp (target_cpu, \"430x\") == 0\n-\t  || strcasecmp (target_cpu, \"430xv2\") == 0)\n+      if (strcasecmp (target_cpu, \"msp430x\") == 0)\n \tmsp430x = true;\n-      else if (strcasecmp (target_cpu, \"msp430\") == 0\n-\t       || strcasecmp (target_cpu, \"430\") == 0)\n+      else /* target_cpu == \"msp430\" - already handled by the front end.  */\n \tmsp430x = false;\n-      else\n-\terror (\"unrecognised argument of -mcpu: %s\", target_cpu);\n     }\n-\n-  if (target_mcu)\n+  /* Note - the front end has already ensured at most\n+     one of target_cpu and target_mcu will be set.  */\n+  else if (target_mcu)\n     {\n       int i;\n \n@@ -217,25 +200,12 @@ msp430_option_override (void)\n \t supports 430.  */\n       msp430x = true;\n \n-      /* For backwards compatibility we recognise two generic MCU\n-\t 430X names.  However we want to be able to generate special C\n-\t preprocessor defines for them, which is why we set target_mcu\n-\t to NULL.  */\n-      if (strcasecmp (target_mcu, \"msp430\") == 0)\n-\t{\n-\t  msp430x = false;\n-\t  target_mcu = NULL;\n-\t}\n-      else if (strcasecmp (target_mcu, \"msp430x\") == 0\n-\t       || strcasecmp (target_mcu, \"msp430xv2\") == 0)\n-\ttarget_mcu = NULL;\n-      else\n-\tfor (i = ARRAY_SIZE (msp430_mcu_names); i--;)\n-\t  if (strcasecmp (msp430_mcu_names[i], target_mcu) == 0)\n-\t    {\n-\t      msp430x = false;\n-\t      break;\n-\t    }\n+      for (i = ARRAY_SIZE (msp430_mcu_names); i--;)\n+\tif (strcasecmp (msp430_mcu_names[i], target_mcu) == 0)\n+\t  {\n+\t    msp430x = false;\n+\t    break;\n+\t  }\n       /* It is not an error if we do not match the MCU name.  There are\n \t hundreds of them.  */\n     }\n@@ -1847,16 +1817,20 @@ static const struct\n \n /* Returns true if the current MCU is an F5xxx series.  */\n bool\n-msp430_is_f5_mcu (void)\n+msp430_use_f5_series_hwmult (void)\n {\n-  if (target_mcu == NULL)\n+  if (msp430_hwmult_type == F5SERIES)\n+    return true;\n+\n+  if (target_mcu == NULL || msp430_hwmult_type != AUTO)\n     return false;\n+\n   return strncasecmp (target_mcu, \"msp430f5\", 8) == 0;\n }\n \n /* Returns true id the current MCU has a second generation 32-bit hardware multiplier.  */\n static bool\n-has_32bit_hw_mult (void)\n+use_32bit_hwmult (void)\n {\n   static const char * known_32bit_mult_mcus [] =\n     {\n@@ -1868,7 +1842,11 @@ has_32bit_hw_mult (void)\n       \"msp430f47177\",     \"msp430f47187\",     \"msp430f47197\"\n     };\n   int i;\n-  if (target_mcu == NULL)\n+\n+  if (msp430_hwmult_type == LARGE)\n+    return true;\n+\n+  if (target_mcu == NULL || msp430_hwmult_type != AUTO)\n     return false;\n \n   for (i = ARRAY_SIZE (known_32bit_mult_mcus); i--;)\n@@ -1878,25 +1856,6 @@ has_32bit_hw_mult (void)\n   return false;\n }\n \n-/* Returns true if hardware multiply is supported by the chosen MCU.  */\n-bool\n-msp430_hwmult_enabled (void)\n-{\n-  if (target_mcu == NULL)\n-    return false;\n-\n-  if (!ENABLE_HWMULT)\n-    return false;\n-\n-  if (msp430_is_interrupt_func ())\n-    return false;\n-\n-  if (msp430_is_f5_mcu () || has_32bit_hw_mult ())\n-    return true;\n-\n-  return false;\n-}\n-\n /* This function does the same as the default, but it will replace GCC\n    function names with the MSPABI-specified ones.  */\n void\n@@ -1913,20 +1872,20 @@ msp430_output_labelref (FILE *file, const char *name)\n \n   /* If we have been given a specific MCU name then we may be\n      able to make use of its hardware multiply capabilities.  */\n-  if (msp430_hwmult_enabled ())\n+  if (msp430_hwmult_type != NONE)\n     {\n       if (strcmp (\"__mspabi_mpyi\", name) == 0)\n \t{\n-\t  if (msp430_is_f5_mcu ())\n+\t  if (msp430_use_f5_series_hwmult ())\n \t    name = \"__mulhi2_f5\";\n \t  else\n \t    name = \"__mulhi2\";\n \t}\n       else if (strcmp (\"__mspabi_mpyl\", name) == 0)\n \t{\n-\t  if (msp430_is_f5_mcu ())\n+\t  if (msp430_use_f5_series_hwmult ())\n \t    name = \"__mulsi2_f5\";\n-\t  else if (has_32bit_hw_mult ())\n+\t  else if (use_32bit_hwmult ())\n \t    name = \"__mulsi2_hw32\";\n \t  else\n \t    name = \"__mulsi2\";"}, {"sha": "5d930c3790167ae87d98002807cc425f2dc9facb", "filename": "gcc/config/msp430/msp430.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -1321,50 +1321,50 @@\n   [(set (match_operand:SI                          0 \"register_operand\" \"=r\")\n \t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"optimize > 2 && msp430_hwmult_enabled ()\"\n+  \"optimize > 2 && msp430_hwmult_type != NONE && ! msp430_is_interrupt_func ()\"\n   \"*\n-    if (msp430_is_f5_mcu ())\n-      return \\\"MOV.W %1, &0x04C2 { MOV.W %2, &0x04C8 { MOV.W &0x04CA, %L0 { MOV.W &0x04CC, %H0\\\";\n+    if (msp430_use_f5_series_hwmult ())\n+      return \\\"PUSH.W sr { DINT { MOV.W %1, &0x04C2 { MOV.W %2, &0x04C8 { MOV.W &0x04CA, %L0 { MOV.W &0x04CC, %H0 { POP.W sr\\\";\n     else\n-      return \\\"MOV.W %1, &0x0132 { MOV.W %2, &0x0138 { MOV.W &0x013A, %L0 { MOV.W &0x013C, %H0\\\";\n+      return \\\"PUSH.W sr { DINT { MOV.W %1, &0x0132 { MOV.W %2, &0x0138 { MOV.W &0x013A, %L0 { MOV.W &0x013C, %H0 { POP.W sr\\\";\n   \"\n )\n \n (define_insn \"umulhisi3\"\n   [(set (match_operand:SI                          0 \"register_operand\" \"=r\")\n \t(mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n \t\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n-  \"optimize > 2 && msp430_hwmult_enabled ()\"\n+  \"optimize > 2 && msp430_hwmult_type != NONE\"\n   \"*\n-    if (msp430_is_f5_mcu ())\n-      return \\\"MOV.W %1, &0x04C0 { MOV.W %2, &0x04C8 { MOV.W &0x04CA, %L0 { MOV.W &0x04CC, %H0\\\";\n+    if (msp430_use_f5_series_hwmult ())\n+      return \\\"PUSH.W sr { DINT { MOV.W %1, &0x04C0 { MOV.W %2, &0x04C8 { MOV.W &0x04CA, %L0 { MOV.W &0x04CC, %H0 { POP.W sr\\\";\n     else\n-      return \\\"MOV.W %1, &0x0130 { MOV.W %2, &0x0138 { MOV.W &0x013A, %L0 { MOV.W &0x013C, %H0\\\";\n+      return \\\"PUSH.W sr { DINT { MOV.W %1, &0x0130 { MOV.W %2, &0x0138 { MOV.W &0x013A, %L0 { MOV.W &0x013C, %H0 { POP.W sr\\\";\n   \"\n )\n \n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI                          0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"optimize > 2 && msp430_hwmult_enabled ()\"\n+  \"optimize > 2 && msp430_hwmult_type != NONE\"\n   \"*\n-    if (msp430_is_f5_mcu ())\n-      return \\\"MOV.W %L1, &0x04D4 { MOV.W %H1, &0x04D6 { MOV.W %L2, &0x04E0 { MOV.W %H2, &0x04E2 { MOV.W &0x04E4, %A0 { MOV.W &0x04E6, %B0 { MOV.W &0x04E8, %C0 { MOV.W &0x04EA, %D0\\\";\n+    if (msp430_use_f5_series_hwmult ())\n+      return \\\"PUSH.W sr { DINT { MOV.W %L1, &0x04D4 { MOV.W %H1, &0x04D6 { MOV.W %L2, &0x04E0 { MOV.W %H2, &0x04E2 { MOV.W &0x04E4, %A0 { MOV.W &0x04E6, %B0 { MOV.W &0x04E8, %C0 { MOV.W &0x04EA, %D0 { POP.W sr\\\";\n     else\n-      return \\\"MOV.W %L1, &0x0144 { MOV.W %H1, &0x0146 { MOV.W %L2, &0x0150 { MOV.W %H2, &0x0152 { MOV.W &0x0154, %A0 { MOV.W &0x0156, %B0 { MOV.W &0x0158, %C0 { MOV.W &0x015A, %D0\\\";\n+      return \\\"PUSH.W sr { DINT { MOV.W %L1, &0x0144 { MOV.W %H1, &0x0146 { MOV.W %L2, &0x0150 { MOV.W %H2, &0x0152 { MOV.W &0x0154, %A0 { MOV.W &0x0156, %B0 { MOV.W &0x0158, %C0 { MOV.W &0x015A, %D0 { POP.W sr\\\";\n   \"\n )\n \n (define_insn \"umulsidi3\"\n   [(set (match_operand:DI                          0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"optimize > 2 && msp430_hwmult_enabled ()\"\n+  \"optimize > 2 && msp430_hwmult_type != NONE\"\n   \"*\n-    if (msp430_is_f5_mcu ())\n-      return \\\"MOV.W %L1, &0x04D0 { MOV.W %H1, &0x04D2 { MOV.W %L2, &0x04E0 { MOV.W %H2, &0x04E2 { MOV.W &0x04E4, %A0 { MOV.W &0x04E6, %B0 { MOV.W &0x04E8, %C0 { MOV.W &0x04EA, %D0\\\";\n+    if (msp430_use_f5_series_hwmult ())\n+      return \\\"PUSH.W sr { DINT { MOV.W %L1, &0x04D0 { MOV.W %H1, &0x04D2 { MOV.W %L2, &0x04E0 { MOV.W %H2, &0x04E2 { MOV.W &0x04E4, %A0 { MOV.W &0x04E6, %B0 { MOV.W &0x04E8, %C0 { MOV.W &0x04EA, %D0 { POP.W sr\\\";\n     else\n-      return \\\"MOV.W %L1, &0x0140 { MOV.W %H1, &0x0141 { MOV.W %L2, &0x0150 { MOV.W %H2, &0x0152 { MOV.W &0x0154, %A0 { MOV.W &0x0156, %B0 { MOV.W &0x0158, %C0 { MOV.W &0x015A, %D0\\\";\n+      return \\\"PUSH.W sr { DINT { MOV.W %L1, &0x0140 { MOV.W %H1, &0x0141 { MOV.W %L2, &0x0150 { MOV.W %H2, &0x0152 { MOV.W &0x0154, %A0 { MOV.W &0x0156, %B0 { MOV.W &0x0158, %C0 { MOV.W &0x015A, %D0 { POP.W sr\\\";\n   \"\n )"}, {"sha": "8215013e84673e6e1067a824404acf5d9a6c10ea", "filename": "gcc/config/msp430/msp430.opt", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -7,19 +7,19 @@ Target Mask(ASM_HEX)\n Force assembly output to always use hex constants\n \n mmcu=\n-Target ToLower Joined RejectNegative Var(target_mcu)\n+Target Report ToLower Joined RejectNegative Var(target_mcu)\n Specify the MCU to build for.\n \n mcpu=\n-Target Joined RejectNegative Var(target_cpu)\n+Target Report Joined RejectNegative Var(target_cpu)\n Specify the ISA to build for: msp430, mdsp430x, msp430xv2\n \n mlarge\n-Target Mask(LARGE) RejectNegative\n+Target Report Mask(LARGE) RejectNegative\n Select large model - 20-bit addresses/pointers\n \n msmall\n-Target InverseMask(LARGE) RejectNegative\n+Target Report InverseMask(LARGE) RejectNegative\n Select small model - 16-bit addresses/pointers (default)\n \n mrelax\n@@ -33,6 +33,27 @@ minrt\n Target Report Mask(MINRT) RejectNegative\n Use a minimum runtime (no static initializers or ctors) for memory-constrained devices.\n \n-mhwmult\n-Target Report Var(ENABLE_HWMULT, 1) Init(1)\n-Enable hardware multiply (except in interrupt routines)\n+HeaderInclude\n+config/msp430/msp430-opts.h\n+\n+mhwmult=\n+Target Joined RejectNegative Report ToLower Var(msp430_hwmult_type) Enum(msp430_hwmult_types) Init(AUTO)\n+Specify the type of hardware multiply to support\n+\n+Enum\n+Name(msp430_hwmult_types) Type(enum msp430_hwmult_types)\n+\n+EnumValue\n+Enum(msp430_hwmult_types) String(none) Value(NONE)\n+\n+EnumValue\n+Enum(msp430_hwmult_types) String(auto) Value(AUTO)\n+\n+EnumValue\n+Enum(msp430_hwmult_types) String(16bit) Value(SMALL)\n+\n+EnumValue\n+Enum(msp430_hwmult_types) String(32bit) Value(LARGE)\n+\n+EnumValue\n+Enum(msp430_hwmult_types) String(f5series) Value(F5SERIES)"}, {"sha": "23e9bac5c3f57e85d4cd58993c40e87a22e33fe2", "filename": "gcc/config/rl78/rl78-virt.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fconfig%2Frl78%2Frl78-virt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-virt.md?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -42,8 +42,8 @@\n )\n \n (define_insn \"*movhi_virt\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=vYS,v,Wfr\")\n-\t(match_operand:HI 1 \"general_operand\" \"viYS,Wfr,v\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=vS,  Y,   v,   Wfr\")\n+\t(match_operand:HI 1 \"general_operand\"      \"viYS, viS, Wfr, v\"))]\n   \"rl78_virt_insns_ok ()\"\n   \"v.movw %0, %1\"\n   [(set_attr \"valloc\" \"op1\")]"}, {"sha": "ff43f262323e8cc3d4ebbd5635bf037310068ece", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7961364588913e29ce1521997ba415a49e0a087/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f7961364588913e29ce1521997ba415a49e0a087", "patch": "@@ -826,7 +826,8 @@ Objective-C and Objective-C++ Dialects}.\n @gccoptlist{-meb -mel -mno-crt0}\n \n @emph{MSP430 Options}\n-@gccoptlist{-msim -masm-hex -mmcu= -mcpu= -mlarge -msmall -mrelax}\n+@gccoptlist{-msim -masm-hex -mmcu= -mcpu= -mlarge -msmall -mrelax @gol\n+-mhwmult=}\n \n @emph{NDS32 Options}\n @gccoptlist{-mbig-endian -mlittle-endian @gol\n@@ -18242,6 +18243,28 @@ This option is passed to the assembler and linker, and allows the\n linker to perform certain optimizations that cannot be done until\n the final link.\n \n+@item mhwmult=\n+@opindex mhwmult=\n+Describes the type of hardware multiply supported by the target.\n+Accepted values are @code{none} for no hardware multiply, @code{16bit}\n+for the original 16-bit-only multiply supported by early MCUs.\n+@code{32bit} for the 16/32-bit multiply supported by later MCUs and\n+@code{f5series} for the 16/32-bit multiply supported by F5-series MCUs.\n+A value of @code{auto} can also be given.  This tells GCC to deduce\n+the hardware multiply support based upon the MCU name provided by the\n+@option{-mmcu} option.  If no @option{-mmcu} option is specified then\n+@code{32bit} hardware multiply support is assumed.  @code{auto} is the\n+default setting.\n+\n+Hardware multiplies are normally performed by calling a library\n+routine.  This saves space in the generated code.  When compiling at\n+@code{-O3} or higher however the hardware multiplier is invoked\n+inline.  This makes for bigger, but faster code.\n+\n+The hardware multiply routines disable interrupts whilst running and\n+restore the previous interrupt state when they finish.  This makes\n+them safe to use inside interrupt handlers as well as in normal code.\n+\n @end table\n \n @node NDS32 Options"}]}