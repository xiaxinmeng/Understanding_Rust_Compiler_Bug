{"sha": "55a19d494b903ffdf754217d3ff5bc66d1ad1954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVhMTlkNDk0YjkwM2ZmZGY3NTQyMTdkM2ZmNWJjNjZkMWFkMTk1NA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-11-03T07:53:05Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-11-03T07:53:05Z"}, "message": "re PR target/41900 (call *%esp shouldn't be generated because of CPU errata)\n\n\tPR target/41900\n\t* config/i386/i386.h (ix86_arch_indices) <X86_ARCH_CALL_ESP>: New.\n\t(TARGET_CALL_ESP): New define.\n\t* config/i386/i386.c (initial_ix86_tune_features): Initialize\n\tX86_ARCH_CALL_ESP.\n\t* config/i386/i386.md \n\t(*call_pop_1_esp, *call_1_esp, *call_value_pop_1_esp,\n\t*call_value_1_esp): Rename from *call_pop_1, *call_1,\n\t*call_value_pop_1 and *call_value_1.  Depend on TARGET_CALL_ESP.\n\t(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1):\n\tNew patterns, use \"lsm\" as operand 1 constraint.\n\t* config/i386/predicates.md (call_insn_operand): Depend on \n\tindex_register_operand for !TARGET_CALL_ESP to avoid %esp register.\n\ntestsuite/ChangeLog:\n\n\tPR target/41900\n\t* gcc.target/i386/pr41900.c: New test.\n\nFrom-SVN: r153838", "tree": {"sha": "98edb715c3d959ea46c8fc662edb84967cd18a61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98edb715c3d959ea46c8fc662edb84967cd18a61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55a19d494b903ffdf754217d3ff5bc66d1ad1954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a19d494b903ffdf754217d3ff5bc66d1ad1954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a19d494b903ffdf754217d3ff5bc66d1ad1954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a19d494b903ffdf754217d3ff5bc66d1ad1954/comments", "author": null, "committer": null, "parents": [{"sha": "b511afdd35b357f589d446ce315aea5e2649d0cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b511afdd35b357f589d446ce315aea5e2649d0cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b511afdd35b357f589d446ce315aea5e2649d0cc"}], "stats": {"total": 147, "additions": 118, "deletions": 29}, "files": [{"sha": "6ab0707c8977755613aad88f0bb7719e5c2c151f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -1,3 +1,19 @@\n+2009-11-03  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/41900\n+\t* config/i386/i386.h (ix86_arch_indices) <X86_ARCH_CALL_ESP>: New.\n+\t(TARGET_CALL_ESP): New define.\n+\t* config/i386/i386.c (initial_ix86_tune_features): Initialize\n+\tX86_ARCH_CALL_ESP.\n+\t* config/i386/i386.md \n+\t(*call_pop_1_esp, *call_1_esp, *call_value_pop_1_esp,\n+\t*call_value_1_esp): Rename from *call_pop_1, *call_1,\n+\t*call_value_pop_1 and *call_value_1.  Depend on TARGET_CALL_ESP.\n+\t(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1):\n+\tNew patterns, use \"lsm\" as operand 1 constraint.\n+\t* config/i386/predicates.md (call_insn_operand): Depend on \n+\tindex_register_operand for !TARGET_CALL_ESP to avoid %esp register.\n+\n 2009-11-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \tPR tree-optimization/41857\n@@ -224,7 +240,7 @@\n 2009-10-28  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* doc/invoke.texi: Rename -use-linker-plugin -fuse-linker-plugin.\n-\t\n+\n 2009-10-28  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* dbxout.c (dbxout_common_check): Accept non public trees."}, {"sha": "c29a7848ae14f1429fd2885ee5cd8edaaf176f32", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -1553,6 +1553,11 @@ static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {\n \n   /* X86_ARCH_BSWAP: Byteswap was added for 80486.  */\n   ~m_386,\n+\n+  /* X86_ARCH_CALL_ESP: P6 processors will jump to the address after\n+     the decrement (so they will execute return address as code).  See\n+     Pentium Pro errata 70, Pentium 2 errata A33, Pentium 3 errata E17.  */\n+  ~(m_386 | m_486 | m_PENT | m_PPRO),\n };\n \n static const unsigned int x86_accumulate_outgoing_args"}, {"sha": "b412604dbd88f0081a613ed9a13e19dd374bccd1", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -400,6 +400,7 @@ enum ix86_arch_indices {\n   X86_ARCH_CMPXCHG8B,\n   X86_ARCH_XADD,\n   X86_ARCH_BSWAP,\n+  X86_ARCH_CALL_ESP,\n \n   X86_ARCH_LAST\n };\n@@ -411,6 +412,7 @@ extern unsigned char ix86_arch_features[X86_ARCH_LAST];\n #define TARGET_CMPXCHG8B\tix86_arch_features[X86_ARCH_CMPXCHG8B]\n #define TARGET_XADD\t\tix86_arch_features[X86_ARCH_XADD]\n #define TARGET_BSWAP\t\tix86_arch_features[X86_ARCH_BSWAP]\n+#define TARGET_CALL_ESP\t\tix86_arch_features[X86_ARCH_CALL_ESP]\n \n #define TARGET_FISTTP\t\t(TARGET_SSE3 && TARGET_80387)\n "}, {"sha": "dc605abde06973b04ba7318b05324221788763ec", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -14566,12 +14566,25 @@\n }\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn \"*call_pop_1\"\n+(define_insn \"*call_pop_1_esp\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand:SI 1 \"\" \"\"))\n    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n \t\t\t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"!SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+{\n+  if (constant_call_address_operand (operands[0], Pmode))\n+    return \"call\\t%P0\";\n+  return \"call\\t%A0\";\n+}\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"*call_pop_1\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n+\t (match_operand:SI 1 \"\" \"\"))\n+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n+\t\t\t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n     return \"call\\t%P0\";\n@@ -14584,7 +14597,7 @@\n \t (match_operand:SI 1 \"\" \"\"))\n    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n \t\t\t    (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n-  \"SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P0\n    jmp\\t%A0\"\n@@ -14622,10 +14635,21 @@\n }\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn \"*call_1\"\n+(define_insn \"*call_1_esp\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"!SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+{\n+  if (constant_call_address_operand (operands[0], Pmode))\n+    return \"call\\t%P0\";\n+  return \"call\\t%A0\";\n+}\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"*call_1\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n+\t (match_operand 1 \"\" \"\"))]\n+  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n     return \"call\\t%P0\";\n@@ -14636,7 +14660,7 @@\n (define_insn \"*sibcall_1\"\n   [(call (mem:QI (match_operand:SI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P0\n    jmp\\t%A0\"\n@@ -14645,7 +14669,7 @@\n (define_insn \"*call_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rsm\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\n+  \"TARGET_64BIT && !SIBLING_CALL_P (insn)\n    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n@@ -14670,7 +14694,7 @@\n    (clobber (reg:TI XMM15_REG))\n    (clobber (reg:DI SI_REG))\n    (clobber (reg:DI DI_REG))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n     return \"call\\t%P0\";\n@@ -14681,14 +14705,14 @@\n (define_insn \"*call_1_rex64_large\"\n   [(call (mem:QI (match_operand:DI 0 \"call_insn_operand\" \"rm\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n   \"call\\t%A0\"\n   [(set_attr \"type\" \"call\")])\n \n (define_insn \"*sibcall_1_rex64\"\n   [(call (mem:QI (match_operand:DI 0 \"sibcall_insn_operand\" \"s,U\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P0\n    jmp\\t%A0\"\n@@ -21084,13 +21108,27 @@\n }\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn \"*call_value_pop_1\"\n+(define_insn \"*call_value_pop_1_esp\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"rsm\"))\n \t      (match_operand:SI 2 \"\" \"\")))\n    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"!SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+{\n+  if (constant_call_address_operand (operands[1], Pmode))\n+    return \"call\\t%P1\";\n+  return \"call\\t%A1\";\n+}\n+  [(set_attr \"type\" \"callv\")])\n+\n+(define_insn \"*call_value_pop_1\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n+\t      (match_operand:SI 2 \"\" \"\")))\n+   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n+\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[1], Pmode))\n     return \"call\\t%P1\";\n@@ -21104,7 +21142,7 @@\n \t      (match_operand:SI 2 \"\" \"\")))\n    (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n \t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i,i\")))]\n-  \"SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P1\n    jmp\\t%A1\"\n@@ -21153,7 +21191,7 @@\n    (clobber (reg:TI XMM15_REG))\n    (clobber (reg:DI SI_REG))\n    (clobber (reg:DI DI_REG))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n {\n   if (SIBLING_CALL_P (insn))\n     return \"jmp\\t%P1\";\n@@ -21162,11 +21200,23 @@\n }\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn \"*call_value_1\"\n+(define_insn \"*call_value_1_esp\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"rsm\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n-  \"!SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+{\n+  if (constant_call_address_operand (operands[1], Pmode))\n+    return \"call\\t%P1\";\n+  return \"call\\t%A1\";\n+}\n+  [(set_attr \"type\" \"callv\")])\n+\n+(define_insn \"*call_value_1\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n+\t      (match_operand:SI 2 \"\" \"\")))]\n+  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[1], Pmode))\n     return \"call\\t%P1\";\n@@ -21178,7 +21228,7 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n-  \"SIBLING_CALL_P (insn) && !TARGET_64BIT\"\n+  \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P1\n    jmp\\t%A1\"\n@@ -21188,7 +21238,7 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rsm\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\n+  \"TARGET_64BIT && !SIBLING_CALL_P (insn)\n    && ix86_cmodel != CM_LARGE && ix86_cmodel != CM_LARGE_PIC\"\n {\n   if (constant_call_address_operand (operands[1], Pmode))\n@@ -21226,15 +21276,15 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"call_insn_operand\" \"rm\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n-  \"!SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n   \"call\\t%A1\"\n   [(set_attr \"type\" \"callv\")])\n \n (define_insn \"*sibcall_value_1_rex64\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:DI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:DI 2 \"\" \"\")))]\n-  \"SIBLING_CALL_P (insn) && TARGET_64BIT\"\n+  \"TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P1\n    jmp\\t%A1\""}, {"sha": "dee6df9fa013060c0b4aba77e9580d9857a41bb3", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -561,7 +561,9 @@\n ;; Test for a valid operand for a call instruction.\n (define_predicate \"call_insn_operand\"\n   (ior (match_operand 0 \"constant_call_address_operand\")\n-       (ior (match_operand 0 \"register_no_elim_operand\")\n+       (ior (and (match_operand 0 \"register_no_elim_operand\")\n+\t\t (ior (match_test \"TARGET_CALL_ESP\")\n+\t\t      (match_operand 0 \"index_register_operand\")))\n \t    (match_operand 0 \"memory_operand\"))))\n \n ;; Similarly, but for tail calls, in which we cannot allow memory references."}, {"sha": "672d36df21102f1d2ca33faf7c2f8e06417b124a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -1,12 +1,16 @@\n-\t2009-11-02  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n+2009-11-03  Uros Bizjak  <ubizjak@gmail.com>\n \n-\t*gcc.c-torture/execute/pr40668.c: Correct for 16bit int size.\n+\tPR target/41900\n+\t* gcc.target/i386/pr41900.c: New test.\n+\n+2009-11-02  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n+\n+\t* gcc.c-torture/execute/pr40668.c: Correct for 16bit int size.\n \n 2009-11-02  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/41856\n-\t* g++.dg/lookup/extern-c-redecl3.C: Make the test x86\n-\tonly.\n+\t* g++.dg/lookup/extern-c-redecl3.C: Make the test x86 only.\n \t* g++.dg/lookup/extern-c-redecl4.C: Likewise.\n \n 2009-11-02  Dodji Seketeli  <dodji@redhat.com>\n@@ -151,7 +155,7 @@\n 2009-10-29  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/41777\n-\tgfortran.dg/associated_target_3.f90: New testcase.\n+\t* gfortran.dg/associated_target_3.f90: New testcase.\n \n 2009-10-29  Rafael Avila de Espindola  <espindola@google.com>\n \n@@ -339,8 +343,7 @@\n \n \t* lib/target-supports.exp (check_profiling_available):\n \tProfiling is not, currently, available for the RX port.\n-\t(check_effective_target_hard_float): Add support for RX\n-\ttarget.\n+\t(check_effective_target_hard_float): Add support for RX target.\n \t* gcc.target/rx: New directory.\n \t* gcc.target/rx/builtins.c: New test file.\n \t* gcc.target/rx/interrupts.c: New test file."}, {"sha": "ac5f8636bbdf6e983eeb0bee17dcade89e1c9547", "filename": "gcc/testsuite/gcc.target/i386/pr41900.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr41900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a19d494b903ffdf754217d3ff5bc66d1ad1954/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr41900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr41900.c?ref=55a19d494b903ffdf754217d3ff5bc66d1ad1954", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fomit-frame-pointer -mpreferred-stack-boundary=2\" } */\n+\n+int main ()\n+{\n+  unsigned code = 0xc3;\n+\n+  ((void (*)(void)) &code) ();\n+  return 0;\n+}"}]}