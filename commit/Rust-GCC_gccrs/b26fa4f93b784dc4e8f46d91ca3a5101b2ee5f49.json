{"sha": "b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI2ZmE0ZjkzYjc4NGRjNGU4ZjQ2ZDkxY2EzYTUxMDFiMmVlNWY0OQ==", "commit": {"author": {"name": "Kuan-Lin Chen", "email": "kuanlinchentw@gmail.com", "date": "2018-05-19T11:03:20Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-05-19T11:03:20Z"}, "message": "[NDS32] Support PIC and TLS.\n\ngcc/\n\t* config/nds32/constants.md: Add TP_REGNUM constant.\n\t(unspec_element): Add UNSPEC_GOTINIT, UNSPEC_GOT, UNSPEC_GOTOFF,\n\tUNSPEC_PLT, UNSPEC_TLSGD, UNSPEC_TLSLD, UNSPEC_TLSIE, UNSPEC_TLSLE and\n\tUNSPEC_ADD32.\n\t* config/nds32/nds32-doubleword.md: Consider flag_pic.\n\t* config/nds32/nds32-dspext.md (mov<mode>): Expand TLS and PIC cases.\n\t* config/nds32/nds32-predicates.c (nds32_const_unspec_p): New.\n\t* config/nds32/nds32-md-auxiliary.c: Implementation that support TLS\n\tand PIC code generation.\n\t* config/nds32/nds32-protos.h: Declarations that support TLS and PIC\n\tcode generation.\n\t* config/nds32/nds32-relax-opt.c: Consider TLS and PIC for relax\n\toptimization.\n\t* config/nds32/nds32.md: Support TLS and PIC.\n\t* config/nds32/nds32.c: Support TLS and PIC.\n\t* config/nds32/nds32.h (nds32_relax_insn_type): New enum type.\n\t* config/nds32/predicates.md (nds32_nonunspec_symbolic_operand): New\n\tpredicate.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r260393", "tree": {"sha": "fbaf49796a3f7b78f7384f1df19ef7eb651bda5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbaf49796a3f7b78f7384f1df19ef7eb651bda5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/comments", "author": {"login": "kuanlinchentw", "id": 24240991, "node_id": "MDQ6VXNlcjI0MjQwOTkx", "avatar_url": "https://avatars.githubusercontent.com/u/24240991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kuanlinchentw", "html_url": "https://github.com/kuanlinchentw", "followers_url": "https://api.github.com/users/kuanlinchentw/followers", "following_url": "https://api.github.com/users/kuanlinchentw/following{/other_user}", "gists_url": "https://api.github.com/users/kuanlinchentw/gists{/gist_id}", "starred_url": "https://api.github.com/users/kuanlinchentw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kuanlinchentw/subscriptions", "organizations_url": "https://api.github.com/users/kuanlinchentw/orgs", "repos_url": "https://api.github.com/users/kuanlinchentw/repos", "events_url": "https://api.github.com/users/kuanlinchentw/events{/privacy}", "received_events_url": "https://api.github.com/users/kuanlinchentw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc32bc72bb8ba03e66c87db9472d6067dd52d09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc32bc72bb8ba03e66c87db9472d6067dd52d09b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc32bc72bb8ba03e66c87db9472d6067dd52d09b"}], "stats": {"total": 1195, "additions": 1058, "deletions": 137}, "files": [{"sha": "b905b54f4f60e0d8b572e61228e8cffc24cafaf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -1,3 +1,25 @@\n+2018-05-19  Kuan-Lin Chen <kuanlinchentw@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/constants.md: Add TP_REGNUM constant.\n+\t(unspec_element): Add UNSPEC_GOTINIT, UNSPEC_GOT, UNSPEC_GOTOFF,\n+\tUNSPEC_PLT, UNSPEC_TLSGD, UNSPEC_TLSLD, UNSPEC_TLSIE, UNSPEC_TLSLE and\n+\tUNSPEC_ADD32.\n+\t* config/nds32/nds32-doubleword.md: Consider flag_pic.\n+\t* config/nds32/nds32-dspext.md (mov<mode>): Expand TLS and PIC cases.\n+\t* config/nds32/nds32-predicates.c (nds32_const_unspec_p): New.\n+\t* config/nds32/nds32-md-auxiliary.c: Implementation that support TLS\n+\tand PIC code generation.\n+\t* config/nds32/nds32-protos.h: Declarations that support TLS and PIC\n+\tcode generation.\n+\t* config/nds32/nds32-relax-opt.c: Consider TLS and PIC for relax\n+\toptimization.\n+\t* config/nds32/nds32.md: Support TLS and PIC.\n+\t* config/nds32/nds32.c: Support TLS and PIC.\n+\t* config/nds32/nds32.h (nds32_relax_insn_type): New enum type.\n+\t* config/nds32/predicates.md (nds32_nonunspec_symbolic_operand): New\n+\tpredicate.\n+\n 2018-05-19  Chung-Ju Wu  <jasonwucj@gmail.com>\n \n \t* config/nds32/nds32-predicates.c (const_vector_to_hwint): Use machine"}, {"sha": "c2994ab386a7e95d5e792bcf5dfd00cb470c4052", "filename": "gcc/config/nds32/constants.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fconstants.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fconstants.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstants.md?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -23,6 +23,7 @@\n (define_constants\n   [(R8_REGNUM  8)\n    (TA_REGNUM 15)\n+   (TP_REGNUM 25)\n    (FP_REGNUM 28)\n    (GP_REGNUM 29)\n    (LP_REGNUM 30)\n@@ -72,6 +73,14 @@\n   UNSPEC_UASTORE_HW\n   UNSPEC_UASTORE_W\n   UNSPEC_UASTORE_DW\n+  UNSPEC_GOTINIT\n+  UNSPEC_GOT\n+  UNSPEC_GOTOFF\n+  UNSPEC_PLT\n+  UNSPEC_TLSGD\n+  UNSPEC_TLSLD\n+  UNSPEC_TLSIE\n+  UNSPEC_TLSLE\n   UNSPEC_ROUND\n   UNSPEC_VEC_COMPARE\n   UNSPEC_KHM\n@@ -83,6 +92,7 @@\n   UNSPEC_LOOP_END\n   UNSPEC_TLS_DESC\n   UNSPEC_TLS_IE\n+  UNSPEC_ADD32\n   UNSPEC_ICT\n   UNSPEC_KADDH\n   UNSPEC_KSUBH"}, {"sha": "7ee6489d0341686c9c8f7cd398a9d082b0bc8221", "filename": "gcc/config/nds32/nds32-doubleword.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-doubleword.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-doubleword.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-doubleword.md?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -139,7 +139,7 @@\n (define_split\n   [(set (match_operand:DIDF 0 \"register_operand\"     \"\")\n \t(match_operand:DIDF 1 \"const_double_operand\" \"\"))]\n-  \"reload_completed\"\n+  \"flag_pic || reload_completed\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n {"}, {"sha": "e3ae79c84feb70c4141de19c700d8b9041500932", "filename": "gcc/config/nds32/nds32-dspext.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-dspext.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-dspext.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-dspext.md?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -44,6 +44,20 @@\n       convert_move (operands[0], tmp_rtx, false);\n       DONE;\n     }\n+\n+  if (REG_P (operands[0]) && SYMBOLIC_CONST_P (operands[1]))\n+    {\n+      if (nds32_tls_referenced_p (operands [1]))\n+\t{\n+\t  nds32_expand_tls_move (operands);\n+\t  DONE;\n+\t}\n+      else if (flag_pic)\n+\t{\n+\t  nds32_expand_pic_move (operands);\n+\t  DONE;\n+\t}\n+    }\n })\n \n (define_insn \"*mov<mode>\""}, {"sha": "32b14dba6b84a54a590fc0289dc101972164b7c9", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 410, "deletions": 101, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -1364,6 +1364,112 @@ nds32_expand_insv (rtx *operands)\n \n /* ------------------------------------------------------------------------ */\n \n+/* Function to generate PC relative jump table.\n+   Refer to nds32.md for more details.\n+\n+   The following is the sample for the case that diff value\n+   can be presented in '.short' size.\n+\n+     addi    $r1, $r1, -(case_lower_bound)\n+     slti    $ta, $r1, (case_number)\n+     beqz    $ta, .L_skip_label\n+\n+     la      $ta, .L35             ! get jump table address\n+     lh      $r1, [$ta + $r1 << 1] ! load symbol diff from jump table entry\n+     addi    $ta, $r1, $ta\n+     jr5     $ta\n+\n+     ! jump table entry\n+   L35:\n+     .short  .L25-.L35\n+     .short  .L26-.L35\n+     .short  .L27-.L35\n+     .short  .L28-.L35\n+     .short  .L29-.L35\n+     .short  .L30-.L35\n+     .short  .L31-.L35\n+     .short  .L32-.L35\n+     .short  .L33-.L35\n+     .short  .L34-.L35 */\n+const char *\n+nds32_output_casesi_pc_relative (rtx *operands)\n+{\n+  machine_mode mode;\n+  rtx diff_vec;\n+\n+  diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[1])));\n+\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n+\n+  /* Step C: \"t <-- operands[1]\".  */\n+  if (flag_pic)\n+    {\n+      output_asm_insn (\"sethi\\t$ta, hi20(%l1@GOTOFF)\", operands);\n+      output_asm_insn (\"ori\\t$ta, $ta, lo12(%l1@GOTOFF)\", operands);\n+      output_asm_insn (\"add\\t$ta, $ta, $gp\", operands);\n+    }\n+  else\n+    output_asm_insn (\"la\\t$ta, %l1\", operands);\n+\n+  /* Get the mode of each element in the difference vector.  */\n+  mode = GET_MODE (diff_vec);\n+\n+  /* Step D: \"z <-- (mem (plus (operands[0] << m) t))\",\n+     where m is 0, 1, or 2 to load address-diff value from table.  */\n+  switch (mode)\n+    {\n+    case E_QImode:\n+      output_asm_insn (\"lb\\t%2, [$ta + %0 << 0]\", operands);\n+      break;\n+    case E_HImode:\n+      output_asm_insn (\"lh\\t%2, [$ta + %0 << 1]\", operands);\n+      break;\n+    case E_SImode:\n+      output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Step E: \"t <-- z + t\".\n+     Add table label_ref with address-diff value to\n+     obtain target case address.  */\n+  output_asm_insn (\"add\\t$ta, %2, $ta\", operands);\n+\n+  /* Step F: jump to target with register t.  */\n+  if (TARGET_16_BIT)\n+    return \"jr5\\t$ta\";\n+  else\n+    return \"jr\\t$ta\";\n+}\n+\n+/* Function to generate normal jump table.  */\n+const char *\n+nds32_output_casesi (rtx *operands)\n+{\n+  /* Step C: \"t <-- operands[1]\".  */\n+  if (flag_pic)\n+    {\n+      output_asm_insn (\"sethi\\t$ta, hi20(%l1@GOTOFF)\", operands);\n+      output_asm_insn (\"ori\\t$ta, $ta, lo12(%l1@GOTOFF)\", operands);\n+      output_asm_insn (\"add\\t$ta, $ta, $gp\", operands);\n+    }\n+  else\n+    output_asm_insn (\"la\\t$ta, %l1\", operands);\n+\n+  /* Step D: \"z <-- (mem (plus (operands[0] << 2) t))\".  */\n+  output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n+\n+  /* No need to perform Step E, which is only used for\n+     pc relative jump table.  */\n+\n+  /* Step F: jump to target with register z.  */\n+  if (TARGET_16_BIT)\n+    return \"jr5\\t%2\";\n+  else\n+    return \"jr\\t%2\";\n+}\n+\n /* Function to return memory format.  */\n enum nds32_16bit_address_type\n nds32_mem_format (rtx op)\n@@ -2189,77 +2295,6 @@ nds32_output_return (void)\n   return \"\";\n }\n \n-/* Function to generate PC relative jump table.\n-   Refer to nds32.md for more details.\n-\n-   The following is the sample for the case that diff value\n-   can be presented in '.short' size.\n-\n-     addi    $r1, $r1, -(case_lower_bound)\n-     slti    $ta, $r1, (case_number)\n-     beqz    $ta, .L_skip_label\n-\n-     la      $ta, .L35             ! get jump table address\n-     lh      $r1, [$ta + $r1 << 1] ! load symbol diff from jump table entry\n-     addi    $ta, $r1, $ta\n-     jr5     $ta\n-\n-     ! jump table entry\n-   L35:\n-     .short  .L25-.L35\n-     .short  .L26-.L35\n-     .short  .L27-.L35\n-     .short  .L28-.L35\n-     .short  .L29-.L35\n-     .short  .L30-.L35\n-     .short  .L31-.L35\n-     .short  .L32-.L35\n-     .short  .L33-.L35\n-     .short  .L34-.L35 */\n-const char *\n-nds32_output_casesi_pc_relative (rtx *operands)\n-{\n-  machine_mode mode;\n-  rtx diff_vec;\n-\n-  diff_vec = PATTERN (NEXT_INSN (as_a <rtx_insn *> (operands[1])));\n-\n-  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n-\n-  /* Step C: \"t <-- operands[1]\".  */\n-  output_asm_insn (\"la\\t$ta, %l1\", operands);\n-\n-  /* Get the mode of each element in the difference vector.  */\n-  mode = GET_MODE (diff_vec);\n-\n-  /* Step D: \"z <-- (mem (plus (operands[0] << m) t))\",\n-     where m is 0, 1, or 2 to load address-diff value from table.  */\n-  switch (mode)\n-    {\n-    case E_QImode:\n-      output_asm_insn (\"lb\\t%2, [$ta + %0 << 0]\", operands);\n-      break;\n-    case E_HImode:\n-      output_asm_insn (\"lh\\t%2, [$ta + %0 << 1]\", operands);\n-      break;\n-    case E_SImode:\n-      output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Step E: \"t <-- z + t\".\n-     Add table label_ref with address-diff value to\n-     obtain target case address.  */\n-  output_asm_insn (\"add\\t$ta, %2, $ta\", operands);\n-\n-  /* Step F: jump to target with register t.  */\n-  if (TARGET_16_BIT)\n-    return \"jr5\\t$ta\";\n-  else\n-    return \"jr\\t$ta\";\n-}\n \n /* output a float load instruction */\n const char *\n@@ -2417,25 +2452,6 @@ nds32_output_float_store (rtx *operands)\n   return \"\";\n }\n \n-/* Function to generate normal jump table.  */\n-const char *\n-nds32_output_casesi (rtx *operands)\n-{\n-  /* Step C: \"t <-- operands[1]\".  */\n-  output_asm_insn (\"la\\t$ta, %l1\", operands);\n-\n-  /* Step D: \"z <-- (mem (plus (operands[0] << 2) t))\".  */\n-  output_asm_insn (\"lw\\t%2, [$ta + %0 << 2]\", operands);\n-\n-  /* No need to perform Step E, which is only used for\n-     pc relative jump table.  */\n-\n-  /* Step F: jump to target with register z.  */\n-  if (TARGET_16_BIT)\n-    return \"jr5\\t%2\";\n-  else\n-    return \"jr\\t%2\";\n-}\n \n /* Auxiliary functions for lwm/smw.  */\n bool\n@@ -2973,29 +2989,32 @@ nds32_output_unpkd8 (rtx output, rtx input,\n   return \"\";\n }\n \n+/* Return true if SYMBOL_REF X binds locally.  */\n+\n+static bool\n+nds32_symbol_binds_local_p (const_rtx x)\n+{\n+  return (SYMBOL_REF_DECL (x)\n+\t  ? targetm.binds_local_p (SYMBOL_REF_DECL (x))\n+\t  : SYMBOL_REF_LOCAL_P (x));\n+}\n+\n const char *\n nds32_output_call (rtx insn, rtx *operands, rtx symbol, const char *long_call,\n \t\t   const char *call, bool align_p)\n {\n   char pattern[100];\n   bool noreturn_p;\n \n-  if (GET_CODE (symbol) == CONST)\n-    {\n-      symbol= XEXP (symbol, 0);\n-\n-      if (GET_CODE (symbol) == PLUS)\n-        symbol = XEXP (symbol, 0);\n-    }\n-\n-  gcc_assert (GET_CODE (symbol) == SYMBOL_REF\n-\t      || REG_P (symbol));\n-\n   if (nds32_long_call_p (symbol))\n     strcpy (pattern, long_call);\n   else\n     strcpy (pattern, call);\n \n+  if (flag_pic && CONSTANT_P (symbol)\n+      && !nds32_symbol_binds_local_p (symbol))\n+    strcat (pattern, \"@PLT\");\n+\n   if (align_p)\n     strcat (pattern, \"\\n\\t.align 2\");\n \n@@ -3423,6 +3442,113 @@ symbolic_reference_mentioned_p (rtx op)\n   return false;\n }\n \n+/* Expand PIC code for @GOTOFF and @GOT.\n+\n+  Example for @GOTOFF:\n+\n+    la $r0, symbol@GOTOFF\n+      -> sethi $ta, hi20(symbol@GOTOFF)\n+\t ori $ta, $ta, lo12(symbol@GOTOFF)\n+\t add $r0, $ta, $gp\n+\n+  Example for @GOT:\n+\n+    la $r0, symbol@GOT\n+      -> sethi $ta, hi20(symbol@GOT)\n+\t ori $ta, $ta, lo12(symbol@GOT)\n+\t lw  $r0, [$ta + $gp]\n+*/\n+rtx\n+nds32_legitimize_pic_address (rtx x)\n+{\n+  rtx addr = x;\n+  rtx reg = gen_reg_rtx (Pmode);\n+  rtx pat;\n+\n+  if (GET_CODE (x) == LABEL_REF\n+      || (GET_CODE (x) == SYMBOL_REF\n+\t  && (CONSTANT_POOL_ADDRESS_P (x)\n+\t      || SYMBOL_REF_LOCAL_P (x))))\n+    {\n+      addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, x), UNSPEC_GOTOFF);\n+      addr = gen_rtx_CONST (SImode, addr);\n+      emit_insn (gen_sethi (reg, addr));\n+      emit_insn (gen_lo_sum (reg, reg, addr));\n+      x = gen_rtx_PLUS (Pmode, reg, pic_offset_table_rtx);\n+    }\n+  else if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, x), UNSPEC_GOT);\n+      addr = gen_rtx_CONST (SImode, addr);\n+      emit_insn (gen_sethi (reg, addr));\n+      emit_insn (gen_lo_sum (reg, reg, addr));\n+\n+      x = gen_const_mem (SImode, gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t\t       reg));\n+    }\n+  else if (GET_CODE (x) == CONST)\n+    {\n+      /* We don't split constant in expand_pic_move because GOTOFF can combine\n+\t the addend with the symbol.  */\n+      addr = XEXP (x, 0);\n+      gcc_assert (GET_CODE (addr) == PLUS);\n+\n+      rtx op0 = XEXP (addr, 0);\n+      rtx op1 = XEXP (addr, 1);\n+\n+      if ((GET_CODE (op0) == LABEL_REF\n+\t   || (GET_CODE (op0) == SYMBOL_REF\n+\t       && (CONSTANT_POOL_ADDRESS_P (op0)\n+\t\t   || SYMBOL_REF_LOCAL_P (op0))))\n+\t  && GET_CODE (op1) == CONST_INT)\n+\t{\n+\t  pat = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), UNSPEC_GOTOFF);\n+\t  pat = gen_rtx_PLUS (Pmode, pat, op1);\n+\t  pat = gen_rtx_CONST (Pmode, pat);\n+\t  emit_insn (gen_sethi (reg, pat));\n+\t  emit_insn (gen_lo_sum (reg, reg, pat));\n+\t  x = gen_rtx_PLUS (Pmode, reg, pic_offset_table_rtx);\n+\t}\n+      else if (GET_CODE (op0) == SYMBOL_REF\n+\t       && GET_CODE (op1) == CONST_INT)\n+\t{\n+\t  /* This is a constant offset from a @GOT symbol reference.  */\n+\t  addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, op0), UNSPEC_GOT);\n+\t  addr = gen_rtx_CONST (SImode, addr);\n+\t  emit_insn (gen_sethi (reg, addr));\n+\t  emit_insn (gen_lo_sum (reg, reg, addr));\n+\t  addr = gen_const_mem (SImode, gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t      pic_offset_table_rtx,\n+\t\t\t\t\t\t      reg));\n+\t  emit_move_insn (reg, addr);\n+\t  if (satisfies_constraint_Is15 (op1))\n+\t    x = gen_rtx_PLUS (Pmode, reg, op1);\n+\t  else\n+\t    {\n+\t      rtx tmp_reg = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_movsi (tmp_reg, op1));\n+\t      x = gen_rtx_PLUS (Pmode, reg, tmp_reg);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Don't handle this pattern.  */\n+\t  debug_rtx (x);\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  return x;\n+}\n+\n+void\n+nds32_expand_pic_move (rtx *operands)\n+{\n+  rtx src;\n+\n+  src = nds32_legitimize_pic_address (operands[1]);\n+  emit_move_insn (operands[0], src);\n+}\n+\n /* Expand ICT symbol.\n     Example for @ICT and ICT model=large:\n \n@@ -3489,6 +3615,129 @@ nds32_long_call_p (rtx symbol)\n     return TARGET_CMODEL_LARGE;\n }\n \n+/* Return true if X contains a thread-local symbol.  */\n+bool\n+nds32_tls_referenced_p (rtx x)\n+{\n+  if (!targetm.have_tls)\n+   return false;\n+\n+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS)\n+    x = XEXP (XEXP (x, 0), 0);\n+\n+  if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (x))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n+   this (thread-local) address.  */\n+rtx\n+nds32_legitimize_tls_address (rtx x)\n+{\n+  rtx tmp_reg;\n+  rtx tp_reg = gen_rtx_REG (Pmode, TP_REGNUM);\n+  rtx pat, insns, reg0;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    switch (SYMBOL_REF_TLS_MODEL (x))\n+      {\n+      case TLS_MODEL_GLOBAL_DYNAMIC:\n+      case TLS_MODEL_LOCAL_DYNAMIC:\n+\t/* Emit UNSPEC_TLS_DESC rather than expand rtl directly because spill\n+\t   may destroy the define-use chain anylysis to insert relax_hint.  */\n+\tif (SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_GLOBAL_DYNAMIC)\n+\t  pat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, x), UNSPEC_TLSGD);\n+\telse\n+\t  pat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, x), UNSPEC_TLSLD);\n+\n+\tpat = gen_rtx_CONST (SImode, pat);\n+\treg0 = gen_rtx_REG (Pmode, 0);\n+\t/* If we can confirm all clobber reigsters, it doesn't have to use call\n+\t   instruction.  */\n+\tinsns = emit_call_insn (gen_tls_desc (pat, GEN_INT (0)));\n+\tuse_reg (&CALL_INSN_FUNCTION_USAGE (insns), pic_offset_table_rtx);\n+\tRTL_CONST_CALL_P (insns) = 1;\n+\ttmp_reg = gen_reg_rtx (SImode);\n+\temit_move_insn (tmp_reg, reg0);\n+\tx = tmp_reg;\n+\tbreak;\n+\n+      case TLS_MODEL_INITIAL_EXEC:\n+\tpat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, x), UNSPEC_TLSIE);\n+\ttmp_reg  = gen_reg_rtx (SImode);\n+\tpat = gen_rtx_CONST (SImode, pat);\n+\temit_insn (gen_tls_ie (tmp_reg, pat, GEN_INT (0)));\n+\tif (flag_pic)\n+\t  emit_use (pic_offset_table_rtx);\n+\tx = gen_rtx_PLUS (Pmode, tmp_reg, tp_reg);\n+\tbreak;\n+\n+      case TLS_MODEL_LOCAL_EXEC:\n+\t/* Expand symbol_ref@TPOFF':\n+\t     sethi $ta, hi20(symbol_ref@TPOFF)\n+\t     ori   $ta, $ta, lo12(symbol_ref@TPOFF)\n+\t     add   $r0, $ta, $tp */\n+\ttmp_reg  = gen_reg_rtx (SImode);\n+\tpat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, x), UNSPEC_TLSLE);\n+\tpat = gen_rtx_CONST (SImode, pat);\n+\temit_insn (gen_sethi (tmp_reg, pat));\n+\temit_insn (gen_lo_sum (tmp_reg, tmp_reg, pat));\n+\tx = gen_rtx_PLUS (Pmode, tmp_reg, tp_reg);\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  else if (GET_CODE (x) == CONST)\n+    {\n+      rtx base, addend;\n+      split_const (x, &base, &addend);\n+\n+      if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_LOCAL_EXEC)\n+\t{\n+\t  /* Expand symbol_ref@TPOFF':\n+\t     sethi $ta, hi20(symbol_ref@TPOFF + addend)\n+\t     ori   $ta, $ta, lo12(symbol_ref@TPOFF + addend)\n+\t     add   $r0, $ta, $tp */\n+\t  tmp_reg  = gen_reg_rtx (SImode);\n+\t  pat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, base), UNSPEC_TLSLE);\n+\t  pat = gen_rtx_PLUS (SImode, pat, addend);\n+\t  pat = gen_rtx_CONST (SImode, pat);\n+\t  emit_insn (gen_sethi (tmp_reg, pat));\n+\t  emit_insn (gen_lo_sum (tmp_reg, tmp_reg, pat));\n+\t  x = gen_rtx_PLUS (Pmode, tmp_reg, tp_reg);\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n+void\n+nds32_expand_tls_move (rtx *operands)\n+{\n+  rtx src = operands[1];\n+  rtx base, addend;\n+\n+  if (CONSTANT_P (src))\n+    split_const (src, &base, &addend);\n+\n+  if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_LOCAL_EXEC)\n+    src = nds32_legitimize_tls_address (src);\n+  else\n+    {\n+      src = nds32_legitimize_tls_address (base);\n+      if (addend != const0_rtx)\n+\t{\n+\t  src = gen_rtx_PLUS (SImode, src, addend);\n+\t  src = force_operand (src, operands[0]);\n+\t}\n+    }\n+\n+  emit_move_insn (operands[0], src);\n+}\n+\n void\n nds32_expand_constant (machine_mode mode, HOST_WIDE_INT val,\n \t\t       rtx target, rtx source)\n@@ -3553,3 +3802,63 @@ rtx nds32_di_low_part_subreg(rtx reg)\n \t   SImode, reg,\n \t   DImode, low_part_offset);\n }\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* Auxiliary function for output TLS patterns.  */\n+\n+const char *\n+nds32_output_tls_desc (rtx *operands)\n+{\n+  char pattern[1000];\n+\n+  if (TARGET_RELAX_HINT)\n+    snprintf (pattern, sizeof (pattern),\n+\t      \".relax_hint %%1\\n\\tsethi $r0, hi20(%%0)\\n\\t\"\n+\t      \".relax_hint %%1\\n\\tori $r0, $r0, lo12(%%0)\\n\\t\"\n+\t      \".relax_hint %%1\\n\\tlw $r15, [$r0 + $gp]\\n\\t\"\n+\t      \".relax_hint %%1\\n\\tadd $r0, $r0, $gp\\n\\t\"\n+\t      \".relax_hint %%1\\n\\tjral $r15\");\n+  else\n+    snprintf (pattern, sizeof (pattern),\n+\t      \"sethi $r0, hi20(%%0)\\n\\t\"\n+\t      \"ori $r0, $r0, lo12(%%0)\\n\\t\"\n+\t      \"lw $r15, [$r0 + $gp]\\n\\t\"\n+\t      \"add $r0, $r0, $gp\\n\\t\"\n+\t      \"jral $r15\");\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+\n+const char *\n+nds32_output_tls_ie (rtx *operands)\n+{\n+  char pattern[1000];\n+\n+  if (flag_pic)\n+  {\n+      if (TARGET_RELAX_HINT)\n+\tsnprintf (pattern, sizeof (pattern),\n+\t\t  \".relax_hint %%2\\n\\tsethi %%0, hi20(%%1)\\n\\t\"\n+\t\t  \".relax_hint %%2\\n\\tori %%0, %%0, lo12(%%1)\\n\\t\"\n+\t\t  \".relax_hint %%2\\n\\tlw %%0, [%%0 + $gp]\");\n+      else\n+\tsnprintf (pattern, sizeof (pattern),\n+\t\t  \"sethi %%0, hi20(%%1)\\n\\t\"\n+\t\t  \"ori %%0, %%0, lo12(%%1)\\n\\t\"\n+\t\t  \"lw %%0, [%%0 + $gp]\");\n+  }\n+  else\n+    {\n+      if (TARGET_RELAX_HINT)\n+\tsnprintf (pattern, sizeof (pattern),\n+\t\t  \".relax_hint %%2\\n\\tsethi %%0, hi20(%%1)\\n\\t\"\n+\t\t  \".relax_hint %%2\\n\\tlwi %%0, [%%0 + lo12(%%1)]\");\n+      else\n+\tsnprintf (pattern, sizeof (pattern),\n+\t\t  \"sethi %%0, hi20(%%1)\\n\\t\"\n+\t\t  \"lwi %%0, [%%0 + lo12(%%1)]\");\n+    }\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}"}, {"sha": "ba7770025e2eda389a861effc00fa4b10eb1e390", "filename": "gcc/config/nds32/nds32-predicates.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -519,6 +519,42 @@ nds32_const_double_range_ok_p (rtx op, machine_mode mode,\n   return val >= lower && val < upper;\n }\n \n+bool\n+nds32_const_unspec_p (rtx x)\n+{\n+  if (GET_CODE (x) == CONST)\n+    {\n+      x = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == PLUS)\n+\tx = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == UNSPEC)\n+\t{\n+\t  switch (XINT (x, 1))\n+\t    {\n+\t    case UNSPEC_GOTINIT:\n+\t    case UNSPEC_GOT:\n+\t    case UNSPEC_GOTOFF:\n+\t    case UNSPEC_PLT:\n+\t    case UNSPEC_TLSGD:\n+\t    case UNSPEC_TLSLD:\n+\t    case UNSPEC_TLSIE:\n+\t    case UNSPEC_TLSLE:\n+\t      return false;\n+\t    default:\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_TLS_MODEL (x))\n+    return false;\n+\n+  return true;\n+}\n+\n HOST_WIDE_INT\n const_vector_to_hwint (rtx op)\n {"}, {"sha": "55988d5910f0e34d86aa37809d6ea75fa8af3b0a", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -151,6 +151,8 @@ extern int nds32_can_use_bitci_p (int);\n extern bool nds32_const_double_range_ok_p (rtx, machine_mode,\n \t\t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT);\n \n+extern bool nds32_const_unspec_p (rtx x);\n+\n /* Auxiliary function for 'Computing the Length of an Insn'.  */\n \n extern int nds32_adjust_insn_length (rtx_insn *, int);\n@@ -183,6 +185,26 @@ extern void nds32_expand_float_movcc (rtx *);\n extern enum nds32_expand_result_type nds32_expand_extv (rtx *);\n extern enum nds32_expand_result_type nds32_expand_insv (rtx *);\n \n+/* Auxiliary functions for expand PIC instruction.  */\n+\n+extern void nds32_expand_pic_move (rtx *);\n+\n+/* Auxiliary functions to legitimize PIC address.  */\n+\n+extern rtx nds32_legitimize_pic_address (rtx);\n+\n+/* Auxiliary functions for expand TLS instruction.  */\n+\n+extern void nds32_expand_tls_move (rtx *);\n+\n+/* Auxiliary functions to legitimize TLS address.  */\n+\n+extern rtx nds32_legitimize_tls_address (rtx);\n+\n+/* Auxiliary functions to identify thread-local symbol.  */\n+\n+extern bool nds32_tls_referenced_p (rtx);\n+\n /* Auxiliary functions for expand ICT instruction.  */\n \n extern void nds32_expand_ict_move (rtx *);\n@@ -236,7 +258,8 @@ extern const char *nds32_output_unpkd8 (rtx, rtx, rtx, rtx, bool);\n \n extern const char *nds32_output_call (rtx, rtx *, rtx,\n \t\t\t\t      const char *, const char *, bool);\n-\n+extern const char *nds32_output_tls_desc (rtx *);\n+extern const char *nds32_output_tls_ie (rtx *);\n \n /* Auxiliary functions to output stack push/pop instruction.  */\n "}, {"sha": "e54bd978c2e73742f2c69876ec4f5bcac680f8cd", "filename": "gcc/config/nds32/nds32-relax-opt.c", "status": "modified", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-relax-opt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32-relax-opt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-relax-opt.c?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -52,6 +52,8 @@\n #include \"cfgrtl.h\"\n #include \"tree-pass.h\"\n \n+using namespace nds32;\n+\n /* This is used to create unique relax hint id value.\n    The initial value is 0.  */\n static int relax_group_id = 0;\n@@ -196,6 +198,110 @@ nds32_ict_const_p (rtx x)\n     }\n   return FALSE;\n }\n+\n+/* Group the following pattern as relax candidates:\n+\n+   GOT:\n+      sethi\t$ra, hi20(sym)\n+      ori\t$ra, $ra, lo12(sym)\n+      lw\t$rb, [$ra + $gp]\n+\n+   GOTOFF, TLSLE:\n+      sethi\t$ra, hi20(sym)\n+      ori\t$ra, $ra, lo12(sym)\n+      LS\t$rb, [$ra + $gp]\n+\n+   GOTOFF, TLSLE:\n+      sethi\t$ra, hi20(sym)\n+      ori\t$ra, $ra, lo12(sym)\n+      add\t$rb, $ra, $gp($tp)\n+\n+   Initial GOT table:\n+      sethi\t$gp,hi20(sym)\n+      ori\t$gp, $gp, lo12(sym)\n+      add5.pc\t$gp  */\n+\n+static auto_vec<rtx_insn *, 32> nds32_group_infos;\n+/* Group the PIC and TLS relax candidate instructions for linker.  */\n+static bool\n+nds32_pic_tls_group (rtx_insn *def_insn,\n+\t\t     enum nds32_relax_insn_type relax_type,\n+\t\t     int sym_type)\n+{\n+  df_ref def_record;\n+  df_link *link;\n+  rtx_insn *use_insn = NULL;\n+  rtx pat, new_pat;\n+  def_record = DF_INSN_DEFS (def_insn);\n+  for (link = DF_REF_CHAIN (def_record); link; link = link->next)\n+    {\n+      if (!DF_REF_INSN_INFO (link->ref))\n+\tcontinue;\n+\n+      use_insn = DF_REF_INSN (link->ref);\n+\n+      /* Skip if define insn and use insn not in the same basic block.  */\n+      if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t   BLOCK_FOR_INSN (use_insn),\n+\t\t\t   BLOCK_FOR_INSN (def_insn)))\n+\treturn FALSE;\n+\n+      /* Skip if use_insn not active insn.  */\n+      if (!active_insn_p (use_insn))\n+\treturn FALSE;\n+\n+      switch (relax_type)\n+\t{\n+\tcase RELAX_ORI:\n+\n+\t  /* GOTOFF, TLSLE:\n+\t     sethi\t$ra, hi20(sym)\n+\t     ori\t$ra, $ra, lo12(sym)\n+\t     add\t$rb, $ra, $gp($tp)  */\n+\t  if ((sym_type == UNSPEC_TLSLE\n+\t       || sym_type == UNSPEC_GOTOFF)\n+\t      && (recog_memoized (use_insn) == CODE_FOR_addsi3))\n+\t    {\n+\t      pat = XEXP (PATTERN (use_insn), 1);\n+\t      new_pat =\n+\t\tgen_rtx_UNSPEC (SImode,\n+\t\t\t\tgen_rtvec (2, XEXP (pat, 0), XEXP (pat, 1)),\n+\t\t\t\tUNSPEC_ADD32);\n+\t      validate_replace_rtx (pat, new_pat, use_insn);\n+\t      nds32_group_infos.safe_push (use_insn);\n+\t    }\n+\t  else if (nds32_plus_reg_load_store_p (use_insn)\n+\t\t   && !nds32_sp_base_or_plus_load_store_p (use_insn))\n+\t    nds32_group_infos.safe_push (use_insn);\n+\t  else\n+\t    return FALSE;\n+\t  break;\n+\n+\tdefault:\n+\t  return FALSE;\n+\t}\n+    }\n+  return TRUE;\n+}\n+\n+static int\n+nds32_pic_tls_symbol_type (rtx x)\n+{\n+  x = XEXP (SET_SRC (PATTERN (x)), 1);\n+\n+  if (GET_CODE (x) == CONST)\n+    {\n+      x = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == PLUS)\n+\tx = XEXP (x, 0);\n+\n+      return XINT (x, 1);\n+    }\n+\n+  return XINT (x, 1);\n+}\n+\n /* Group the relax candidates with group id.  */\n static void\n nds32_group_insns (rtx sethi)\n@@ -204,6 +310,7 @@ nds32_group_insns (rtx sethi)\n   df_link *link;\n   rtx_insn *use_insn = NULL;\n   rtx group_id;\n+  bool valid;\n \n   def_record = DF_INSN_DEFS (sethi);\n \n@@ -253,6 +360,132 @@ nds32_group_insns (rtx sethi)\n       /* Insert .relax_* directive.  */\n       if (active_insn_p (use_insn))\n \temit_insn_before (gen_relax_group (group_id), use_insn);\n+\n+      /* Find ori ra, ra, unspec(symbol) instruction.  */\n+      if (use_insn != NULL\n+\t  && recog_memoized (use_insn) == CODE_FOR_lo_sum\n+\t  && !nds32_const_unspec_p (XEXP (SET_SRC (PATTERN (use_insn)), 1)))\n+\t{\n+\t  int sym_type = nds32_pic_tls_symbol_type (use_insn);\n+\t  valid = nds32_pic_tls_group (use_insn, RELAX_ORI, sym_type);\n+\n+\t  /* Insert .relax_* directive.  */\n+\t  while (!nds32_group_infos.is_empty ())\n+\t    {\n+\t      use_insn = nds32_group_infos.pop ();\n+\t      if (valid)\n+\t\temit_insn_before (gen_relax_group (group_id), use_insn);\n+\t    }\n+\t}\n+    }\n+\n+  relax_group_id++;\n+}\n+\n+/* Convert relax group id in rtl.  */\n+\n+static void\n+nds32_group_tls_insn (rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx unspec_relax_group = XEXP (XVECEXP (pat, 0, 1), 0);\n+\n+  while (GET_CODE (pat) != SET && GET_CODE (pat) == PARALLEL)\n+    {\n+      pat = XVECEXP (pat, 0, 0);\n+    }\n+\n+  if (GET_CODE (unspec_relax_group) == UNSPEC\n+      && XINT (unspec_relax_group, 1) == UNSPEC_VOLATILE_RELAX_GROUP)\n+    {\n+      XVECEXP (unspec_relax_group, 0, 0) = GEN_INT (relax_group_id);\n+    }\n+\n+  relax_group_id++;\n+}\n+\n+static bool\n+nds32_float_reg_load_store_p (rtx_insn *insn)\n+{\n+  rtx pat = PATTERN (insn);\n+\n+  if (get_attr_type (insn) == TYPE_FLOAD\n+      && GET_CODE (pat) == SET\n+      && (GET_MODE (XEXP (pat, 0)) == SFmode\n+\t  || GET_MODE (XEXP (pat, 0)) == DFmode)\n+      && MEM_P (XEXP (pat, 1)))\n+    {\n+      rtx addr = XEXP (XEXP (pat, 1), 0);\n+\n+      /* [$ra] */\n+      if (REG_P (addr))\n+\treturn true;\n+      /* [$ra + offset] */\n+      if (GET_CODE (addr) == PLUS\n+\t  && REG_P (XEXP (addr, 0))\n+\t  && CONST_INT_P (XEXP (addr, 1)))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+\n+/* Group float load-store instructions:\n+   la $ra, symbol\n+   flsi $rt, [$ra + offset] */\n+\n+static void\n+nds32_group_float_insns (rtx insn)\n+{\n+  df_ref def_record, use_record;\n+  df_link *link;\n+  rtx_insn *use_insn = NULL;\n+  rtx group_id;\n+\n+  def_record = DF_INSN_DEFS (insn);\n+\n+  for (link = DF_REF_CHAIN (def_record); link; link = link->next)\n+    {\n+      if (!DF_REF_INSN_INFO (link->ref))\n+\tcontinue;\n+\n+      use_insn = DF_REF_INSN (link->ref);\n+\n+      /* Skip if define insn and use insn not in the same basic block.  */\n+      if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t   BLOCK_FOR_INSN (use_insn),\n+\t\t\t   BLOCK_FOR_INSN (insn)))\n+\treturn;\n+\n+      /* Skip if the low-part used register is from different high-part\n+\t instructions.  */\n+      use_record = DF_INSN_USES (use_insn);\n+      if (DF_REF_CHAIN (use_record) && DF_REF_CHAIN (use_record)->next)\n+\treturn;\n+\n+      /* Skip if use_insn not active insn.  */\n+      if (!active_insn_p (use_insn))\n+\treturn;\n+\n+      if (!nds32_float_reg_load_store_p (use_insn)\n+\t  || find_post_update_rtx (use_insn) != -1)\n+\treturn;\n+    }\n+\n+  group_id = GEN_INT (relax_group_id);\n+  /* Insert .relax_* directive for insn.  */\n+  emit_insn_before (gen_relax_group (group_id), insn);\n+\n+  /* Scan the use insns and insert the directive.  */\n+  for (link = DF_REF_CHAIN (def_record); link; link = link->next)\n+    {\n+      if (!DF_REF_INSN_INFO (link->ref))\n+\tcontinue;\n+\n+      use_insn = DF_REF_INSN (link->ref);\n+\n+      /* Insert .relax_* directive.  */\n+\temit_insn_before (gen_relax_group (group_id), use_insn);\n     }\n \n   relax_group_id++;\n@@ -285,6 +518,18 @@ nds32_relax_group (void)\n \t\t\t\t\t SImode)\n \t      && !nds32_ict_const_p (XEXP (SET_SRC (PATTERN (insn)), 0)))\n \t    nds32_group_insns (insn);\n+\t  else if (recog_memoized (insn) == CODE_FOR_tls_ie)\n+\t    nds32_group_tls_insn (insn);\n+\t  else if (TARGET_FPU_SINGLE\n+\t\t   && recog_memoized (insn) == CODE_FOR_move_addr\n+\t\t   && !nds32_ict_const_p (XEXP (SET_SRC (PATTERN (insn)), 0)))\n+\t    {\n+\t      nds32_group_float_insns (insn);\n+\t    }\n+\t}\n+      else if (CALL_P (insn) && recog_memoized (insn) == CODE_FOR_tls_desc)\n+\t{\n+\t  nds32_group_tls_insn (insn);\n \t}\n     }\n "}, {"sha": "b705ae6a77aac8b24fec62174a66ebd9faf1a973", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 170, "deletions": 15, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -435,7 +435,8 @@ nds32_compute_stack_frame (void)\n \n   /* If $gp value is required to be saved on stack, it needs 4 bytes space.\n      Check whether we are using PIC code genration.  */\n-  cfun->machine->gp_size = (flag_pic) ? 4 : 0;\n+  cfun->machine->gp_size =\n+    (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM)) ? 4 : 0;\n \n   /* If $lp value is required to be saved on stack, it needs 4 bytes space.\n      Check whether $lp is ever live.  */\n@@ -520,7 +521,8 @@ nds32_compute_stack_frame (void)\n \t  && cfun->machine->callee_saved_last_fpr_regno == SP_REGNUM\n \t  && !df_regs_ever_live_p (FP_REGNUM)\n \t  && !df_regs_ever_live_p (LP_REGNUM)\n-\t  && cfun->machine->local_size == 0))\n+\t  && cfun->machine->local_size == 0\n+\t  && !flag_pic))\n     {\n       /* Set this function 'naked_p' and other functions can check this flag.\n \t Note that in nds32 port, the 'naked_p = 1' JUST means there is no\n@@ -1262,6 +1264,32 @@ nds32_emit_stack_v3pop (unsigned Rb,\n   REG_NOTES (parallel_insn) = dwarf;\n }\n \n+static void\n+nds32_emit_load_gp (void)\n+{\n+  rtx got_symbol, pat;\n+\n+  /* Initial GLOBAL OFFSET TABLE don't do the scheduling.  */\n+  emit_insn (gen_blockage ());\n+\n+  got_symbol = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  /* sethi $gp, _GLOBAL_OFFSET_TABLE_ -8 */\n+  pat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, got_symbol), UNSPEC_GOTINIT);\n+  pat = gen_rtx_CONST (SImode, gen_rtx_PLUS (Pmode, pat, GEN_INT (-8)));\n+  emit_insn (gen_sethi (pic_offset_table_rtx,pat));\n+\n+  /* ori $gp, $gp, _GLOBAL_OFFSET_TABLE_ -4 */\n+  pat = gen_rtx_UNSPEC (SImode, gen_rtvec (1, got_symbol), UNSPEC_GOTINIT);\n+  pat = gen_rtx_CONST (SImode, gen_rtx_PLUS (Pmode, pat, GEN_INT (-4)));\n+  emit_insn (gen_lo_sum (pic_offset_table_rtx, pic_offset_table_rtx, pat));\n+\n+  /* add5.pc $gp */\n+  emit_insn (gen_add_pc (pic_offset_table_rtx, pic_offset_table_rtx));\n+\n+  /* Initial GLOBAL OFFSET TABLE don't do the scheduling.  */\n+  emit_insn (gen_blockage ());\n+}\n+\n /* Function that may creates more instructions\n    for large value on adjusting stack pointer.\n \n@@ -2213,6 +2241,26 @@ nds32_asm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t\t? 1\n \t\t: 0);\n \n+  if (flag_pic)\n+    {\n+      fprintf (file, \"\\tsmw.adm\\t$r31, [$r31], $r31, 4\\n\");\n+      fprintf (file, \"\\tsethi\\t%s, hi20(_GLOBAL_OFFSET_TABLE_-8)\\n\",\n+\t\t      reg_names [PIC_OFFSET_TABLE_REGNUM]);\n+      fprintf (file, \"\\tori\\t%s, %s, lo12(_GLOBAL_OFFSET_TABLE_-4)\\n\",\n+\t\t      reg_names [PIC_OFFSET_TABLE_REGNUM],\n+\t\t      reg_names [PIC_OFFSET_TABLE_REGNUM]);\n+\n+      if (TARGET_ISA_V3)\n+\tfprintf (file, \"\\tadd5.pc\\t$gp\\n\");\n+      else\n+\t{\n+\t  fprintf (file, \"\\tmfusr\\t$ta, $pc\\n\");\n+\t  fprintf (file, \"\\tadd\\t%s, $ta, %s\\n\",\n+\t\t\t  reg_names [PIC_OFFSET_TABLE_REGNUM],\n+\t\t\t  reg_names [PIC_OFFSET_TABLE_REGNUM]);\n+\t}\n+    }\n+\n   if (delta != 0)\n     {\n       if (satisfies_constraint_Is15 (GEN_INT (delta)))\n@@ -2237,9 +2285,23 @@ nds32_asm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t}\n     }\n \n-  fprintf (file, \"\\tb\\t\");\n-  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n-  fprintf (file, \"\\n\");\n+  if (flag_pic)\n+    {\n+      fprintf (file, \"\\tla\\t$ta, \");\n+      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n+      fprintf (file, \"@PLT\\n\");\n+      fprintf (file, \"\\t! epilogue\\n\");\n+      fprintf (file, \"\\tlwi.bi\\t%s, [%s], 4\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t       reg_names[STACK_POINTER_REGNUM]);\n+      fprintf (file, \"\\tbr\\t$ta\\n\");\n+    }\n+  else\n+    {\n+      fprintf (file, \"\\tb\\t\");\n+      assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\n+      fprintf (file, \"\\n\");\n+    }\n \n   final_end_function ();\n }\n@@ -2260,10 +2322,12 @@ nds32_function_ok_for_sibcall (tree decl,\n      3. We don't want to apply sibling call optimization for indirect\n \tsibcall because the pop behavior in epilogue may pollute the\n \tcontent of caller-saved regsiter when the register is used for\n-\tindirect sibcall.  */\n+\tindirect sibcall.\n+     4. In pic mode, it may use some registers for PLT call.  */\n   return (!TARGET_V3PUSH\n \t  && (cfun->machine->va_args_size == 0)\n-\t  && decl);\n+\t  && decl\n+\t  && !flag_pic);\n }\n \n /* Determine whether we need to enable warning for function return check.  */\n@@ -2579,6 +2643,10 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \n     case SYMBOL_REF:\n       /* (mem (symbol_ref A)) => [symbol_ref] */\n+\n+      if (flag_pic || SYMBOL_REF_TLS_MODEL (x))\n+\treturn false;\n+\n       if (TARGET_ICT_MODEL_LARGE && nds32_indirect_call_referenced_p (x))\n \treturn false;\n \n@@ -2593,7 +2661,8 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \t the 'symbol_ref' is not a valid address during or after\n \t LRA/reload phase.  */\n       if (TARGET_CMODEL_MEDIUM\n-\t  && NDS32_SYMBOL_REF_RODATA_P (x)\n+\t  && (NDS32_SYMBOL_REF_RODATA_P (x)\n+\t      || CONSTANT_POOL_ADDRESS_P (x))\n \t  && (reload_completed\n \t      || reload_in_progress\n \t      || lra_in_progress))\n@@ -2615,6 +2684,10 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \t    {\n \t      /* Now we see the [ + const_addr ] pattern, but we need\n \t\t some further checking.  */\n+\n+\t      if (flag_pic)\n+\t\treturn false;\n+\n \t      /* If -mcmodel=large, the 'const_addr' is not a valid address\n \t\t during or after LRA/reload phase.  */\n \t      if (TARGET_CMODEL_LARGE\n@@ -2692,9 +2765,18 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n     case LO_SUM:\n       /* (mem (lo_sum (reg) (symbol_ref))) */\n       /* (mem (lo_sum (reg) (const (plus (symbol_ref) (reg)))) */\n+      /* TLS case: (mem (lo_sum (reg) (const (unspec symbol_ref X)))) */\n+      /* The LO_SUM is a valid address if and only if we would like to\n+\t generate 32-bit full address memory access with any of following\n+\t circumstance:\n+\t   1. -mcmodel=large.\n+\t   2. -mcmodel=medium and the symbol_ref references to rodata.  */\n       {\n \trtx sym = NULL_RTX;\n \n+\tif (flag_pic)\n+\t  return false;\n+\n \tif (!REG_P (XEXP (x, 0)))\n \t  return false;\n \n@@ -2736,7 +2818,11 @@ nds32_legitimize_address (rtx x,\n \t\t\t  rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t  machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_ICT_MODEL_LARGE && nds32_indirect_call_referenced_p (x))\n+  if (nds32_tls_referenced_p (x))\n+    x = nds32_legitimize_tls_address (x);\n+  else if (flag_pic && SYMBOLIC_CONST_P (x))\n+    x = nds32_legitimize_pic_address (x);\n+  else if (TARGET_ICT_MODEL_LARGE && nds32_indirect_call_referenced_p (x))\n     x = nds32_legitimize_ict_address (x);\n \n   return x;\n@@ -2766,13 +2852,26 @@ nds32_legitimate_constant_p (machine_mode mode, rtx x)\n \t{\n \t  switch (XINT (x, 1))\n \t    {\n+\t    case UNSPEC_GOT:\n+\t    case UNSPEC_GOTOFF:\n+\t    case UNSPEC_PLT:\n+\t    case UNSPEC_TLSGD:\n+\t    case UNSPEC_TLSLD:\n+\t    case UNSPEC_TLSIE:\n+\t    case UNSPEC_TLSLE:\n \t    case UNSPEC_ICT:\n \t      return false;\n \t    default:\n \t      return true;\n \t    }\n \t}\n       break;\n+    case SYMBOL_REF:\n+      /* TLS symbols need a call to resolve in\n+\t precompute_register_parameters.  */\n+      if (SYMBOL_REF_TLS_MODEL (x))\n+\treturn false;\n+      break;\n     default:\n       return true;\n     }\n@@ -2798,6 +2897,14 @@ nds32_delegitimize_address (rtx x)\n \t{\n \t  switch (XINT (inner, 1))\n \t    {\n+\t    case UNSPEC_GOTINIT:\n+\t    case UNSPEC_GOT:\n+\t    case UNSPEC_GOTOFF:\n+\t    case UNSPEC_PLT:\n+\t    case UNSPEC_TLSGD:\n+\t    case UNSPEC_TLSLD:\n+\t    case UNSPEC_TLSIE:\n+\t    case UNSPEC_TLSLE:\n \t    case UNSPEC_ICT:\n \t      x = XVECEXP (inner, 0, 0);\n \t      break;\n@@ -2838,11 +2945,17 @@ nds32_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n       /* We don't want to force symbol as constant pool in .text section,\n \t because we use the gp-relatived instruction to load in small\n \t or medium model.  */\n-      if (SYMBOL_REF_TLS_MODEL (x)\n+      if (flag_pic\n+\t  || SYMBOL_REF_TLS_MODEL (x)\n \t  || TARGET_CMODEL_SMALL\n \t  || TARGET_CMODEL_MEDIUM)\n \treturn true;\n       break;\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      if (flag_pic && (lra_in_progress || reload_completed))\n+\treturn true;\n+      break;\n     default:\n       return false;\n     }\n@@ -2986,6 +3099,9 @@ nds32_asm_file_start (void)\n {\n   default_file_start ();\n \n+  if (flag_pic)\n+    fprintf (asm_out_file, \"\\t.pic\\n\");\n+\n   /* Tell assembler which ABI we are using.  */\n   fprintf (asm_out_file, \"\\t! ABI version\\n\");\n   if (TARGET_HARD_FLOAT)\n@@ -3102,6 +3218,37 @@ nds32_asm_output_addr_const_extra (FILE *file, rtx x)\n     {\n       switch (XINT (x, 1))\n \t{\n+\tcase UNSPEC_GOTINIT:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  break;\n+\tcase UNSPEC_GOTOFF:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@GOTOFF\", file);\n+\t  break;\n+\tcase UNSPEC_GOT:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@GOT\", file);\n+\t  break;\n+\tcase UNSPEC_PLT:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@PLT\", file);\n+\t  break;\n+\tcase UNSPEC_TLSGD:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@TLSDESC\", file);\n+\t  break;\n+\tcase UNSPEC_TLSLD:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@TLSDESC\", file);\n+\t  break;\n+\tcase UNSPEC_TLSIE:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@GOTTPOFF\", file);\n+\t  break;\n+\tcase UNSPEC_TLSLE:\n+\t  output_addr_const (file, XVECEXP (x, 0, 0));\n+\t  fputs (\"@TPOFF\", file);\n+\t  break;\n \tcase UNSPEC_ICT:\n \t  output_addr_const (file, XVECEXP (x, 0, 0));\n \t  fputs (\"@ICT\", file);\n@@ -3870,6 +4017,9 @@ nds32_option_override (void)\n       target_flags &= ~MASK_EXT_PERF2;\n       /* Under V3M ISA, we need to strictly disable TARGET_EXT_STRING.  */\n       target_flags &= ~MASK_EXT_STRING;\n+\n+      if (flag_pic)\n+\terror (\"not support -fpic option for v3m toolchain\");\n     }\n \n   /* See if we are using reduced-set registers:\n@@ -3903,9 +4053,6 @@ nds32_option_override (void)\n \t       \"must be enable '-mext-fpu-sp' or '-mext-fpu-dp'\");\n     }\n \n-  /* Currently, we don't support PIC code generation yet.  */\n-  if (flag_pic)\n-    sorry (\"position-independent code not supported\");\n \n   nds32_register_passes ();\n }\n@@ -4328,7 +4475,7 @@ nds32_expand_prologue (void)\n \n   /* If the function is 'naked',\n      we do not have to generate prologue code fragment.  */\n-  if (cfun->machine->naked_p)\n+  if (cfun->machine->naked_p && !flag_pic)\n     return;\n \n   /* Get callee_first_regno and callee_last_regno.  */\n@@ -4457,6 +4604,10 @@ nds32_expand_prologue (void)\n \t\t\t       -1 * sp_adjust);\n     }\n \n+  /* Emit gp setup instructions for -fpic.  */\n+  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n+    nds32_emit_load_gp ();\n+\n   /* Prevent the instruction scheduler from\n      moving instructions across the boundary.  */\n   emit_insn (gen_blockage ());\n@@ -4700,7 +4851,7 @@ nds32_expand_prologue_v3push (void)\n \n   /* If the function is 'naked',\n      we do not have to generate prologue code fragment.  */\n-  if (cfun->machine->naked_p)\n+  if (cfun->machine->naked_p && !flag_pic)\n     return;\n \n   /* Get callee_first_regno and callee_last_regno.  */\n@@ -4828,6 +4979,10 @@ nds32_expand_prologue_v3push (void)\n \t\t\t       -1 * sp_adjust);\n     }\n \n+  /* Emit gp setup instructions for -fpic.  */\n+  if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n+    nds32_emit_load_gp ();\n+\n   /* Prevent the instruction scheduler from\n      moving instructions across the boundary.  */\n   emit_insn (gen_blockage ());"}, {"sha": "90b52d1a286535ce863434245f6fae4a2f88345e", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -36,6 +36,16 @@\n #define NDS32_SYMBOL_REF_RODATA_P(x) \\\n   ((SYMBOL_REF_FLAGS (x) & NDS32_SYMBOL_FLAG_RODATA) != 0)\n \n+enum nds32_relax_insn_type\n+{\n+  RELAX_ORI,\n+  RELAX_PLT_ADD,\n+  RELAX_TLS_ADD_or_LW,\n+  RELAX_TLS_ADD_LW,\n+  RELAX_TLS_LW_JRAL,\n+  RELAX_DONE\n+};\n+\n /* Classifies expand result for expand helper function.  */\n enum nds32_expand_result_type\n {"}, {"sha": "7e19dcd04f7e249fce90cefe9be05b91fa7309c3", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 110, "deletions": 19, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -225,6 +225,16 @@\n \t  nds32_expand_ict_move (operands);\n \t  DONE;\n \t}\n+      else if (nds32_tls_referenced_p (operands [1]))\n+\t{\n+\t  nds32_expand_tls_move (operands);\n+\t  DONE;\n+\t}\n+      else if (flag_pic)\n+\t{\n+\t  nds32_expand_pic_move (operands);\n+\t  DONE;\n+\t}\n     }\n })\n \n@@ -288,8 +298,8 @@\n ;; We use nds32_symbolic_operand to limit that only CONST/SYMBOL_REF/LABEL_REF\n ;; are able to match such instruction template.\n (define_insn \"move_addr\"\n-  [(set (match_operand:SI 0 \"register_operand\"       \"=l, r\")\n-\t(match_operand:SI 1 \"nds32_symbolic_operand\" \" i, i\"))]\n+  [(set (match_operand:SI 0 \"nds32_general_register_operand\"   \"=l, r\")\n+\t(match_operand:SI 1 \"nds32_nonunspec_symbolic_operand\" \" i, i\"))]\n   \"\"\n   \"la\\t%0, %1\"\n   [(set_attr \"type\"  \"alu\")\n@@ -1555,9 +1565,11 @@\n \t\t     (const_int 2)\n \t\t     (const_int 4))\n        ;; Alternative 1\n-       (if_then_else (match_test \"nds32_long_call_p (operands[0])\")\n-\t\t     (const_int 12)\n-\t\t     (const_int 4))\n+       (if_then_else (match_test \"flag_pic\")\n+\t\t     (const_int 16)\n+\t\t     (if_then_else (match_test \"nds32_long_call_p (operands[0])\")\n+\t\t\t\t   (const_int 12)\n+\t\t\t\t   (const_int 4)))\n      ])]\n )\n \n@@ -1641,9 +1653,11 @@\n \t\t     (const_int 2)\n \t\t     (const_int 4))\n        ;; Alternative 1\n-       (if_then_else (match_test \"nds32_long_call_p (operands[1])\")\n-\t\t     (const_int 12)\n-\t\t     (const_int 4))\n+       (if_then_else (match_test \"flag_pic\")\n+\t\t     (const_int 16)\n+\t\t     (if_then_else (match_test \"nds32_long_call_p (operands[1])\")\n+\t\t\t\t   (const_int 12)\n+\t\t\t\t   (const_int 4)))\n      ])]\n )\n \n@@ -1731,9 +1745,11 @@\n \t\t     (const_int 2)\n \t\t     (const_int 4))\n        ;; Alternative 1\n-       (if_then_else (match_test \"nds32_long_call_p (operands[0])\")\n-\t\t     (const_int 12)\n-\t\t     (const_int 4))\n+       (if_then_else (match_test \"flag_pic\")\n+\t\t     (const_int 16)\n+\t\t     (if_then_else (match_test \"nds32_long_call_p (operands[0])\")\n+\t\t\t\t   (const_int 12)\n+\t\t\t\t   (const_int 4)))\n      ])]\n )\n \n@@ -1793,9 +1809,11 @@\n \t\t     (const_int 2)\n \t\t     (const_int 4))\n        ;; Alternative 1\n-       (if_then_else (match_test \"nds32_long_call_p (operands[1])\")\n-\t\t     (const_int 12)\n-\t\t     (const_int 4))\n+       (if_then_else (match_test \"flag_pic\")\n+\t\t     (const_int 16)\n+\t\t     (if_then_else (match_test \"nds32_long_call_p (operands[1])\")\n+\t\t\t\t   (const_int 12)\n+\t\t\t\t   (const_int 4)))\n      ])]\n )\n \n@@ -1993,6 +2011,7 @@\n {\n   rtx add_tmp;\n   rtx reg, test;\n+  rtx tmp_reg;\n \n   /* Step A: \"k <-- (plus (operands[0]) (-operands[1]))\".  */\n   if (operands[1] != const0_rtx)\n@@ -2014,9 +2033,14 @@\n   emit_jump_insn (gen_cbranchsi4 (test, operands[0], operands[2],\n \t\t\t\t  operands[4]));\n \n-  /* Step C, D, E, and F, using another temporary register.  */\n-  rtx tmp = gen_reg_rtx (SImode);\n-  emit_jump_insn (gen_casesi_internal (operands[0], operands[3], tmp));\n+  tmp_reg = gen_reg_rtx (SImode);\n+  /* Step C, D, E, and F, using another temporary register tmp_reg.  */\n+  if (flag_pic)\n+    emit_use (pic_offset_table_rtx);\n+\n+  emit_jump_insn (gen_casesi_internal (operands[0],\n+\t\t\t\t       operands[3],\n+\t\t\t\t       tmp_reg));\n   DONE;\n })\n \n@@ -2052,8 +2076,11 @@\n   else\n     return nds32_output_casesi (operands);\n }\n-  [(set_attr \"length\" \"20\")\n-   (set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (match_test \"flag_pic\")\n+\t\t      (const_int 28)\n+\t\t      (const_int 20)))])\n \n ;; ----------------------------------------------------------------------------\n \n@@ -2129,6 +2156,16 @@\n   [(set_attr \"length\" \"0\")]\n )\n \n+;; Add pc\n+(define_insn \"add_pc\"\n+  [(set (match_operand:SI 0 \"register_operand\"          \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\"  \"0\")\n+\t\t (pc)))]\n+  \"flag_pic\"\n+  \"add5.pc\\t%0\"\n+  [(set_attr \"type\"    \"alu\")\n+   (set_attr \"length\"    \"4\")]\n+)\n ;; ----------------------------------------------------------------------------\n \n ;; Patterns for exception handling\n@@ -2193,3 +2230,57 @@\n })\n \n ;; ----------------------------------------------------------------------------\n+\n+;; Patterns for TLS.\n+;; The following two tls patterns don't be expanded directly because the\n+;; intermediate value may be spilled into the stack.  As a result, it is\n+;; hard to analyze the define-use chain in the relax_opt pass.\n+\n+\n+;; There is a unspec operand to record RELAX_GROUP number because each\n+;; emitted instruction need a relax_hint above it.\n+(define_insn \"tls_desc\"\n+  [(set (reg:SI 0)\n+\t(call (unspec_volatile:SI [(match_operand:SI 0 \"nds32_symbolic_operand\" \"i\")] UNSPEC_TLS_DESC)\n+\t      (const_int 1)))\n+   (use (unspec [(match_operand:SI 1 \"immediate_operand\" \"i\")] UNSPEC_VOLATILE_RELAX_GROUP))\n+   (use (reg:SI GP_REGNUM))\n+   (clobber (reg:SI LP_REGNUM))\n+   (clobber (reg:SI TA_REGNUM))]\n+  \"\"\n+  {\n+    return nds32_output_tls_desc (operands);\n+  }\n+  [(set_attr \"length\" \"20\")\n+   (set_attr \"type\" \"branch\")]\n+)\n+\n+;; There is a unspec operand to record RELAX_GROUP number because each\n+;; emitted instruction need a relax_hint above it.\n+(define_insn \"tls_ie\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"nds32_symbolic_operand\" \"i\")] UNSPEC_TLS_IE))\n+   (use (unspec [(match_operand:SI 2 \"immediate_operand\" \"i\")] UNSPEC_VOLATILE_RELAX_GROUP))\n+   (use (reg:SI GP_REGNUM))]\n+  \"\"\n+  {\n+    return nds32_output_tls_ie (operands);\n+  }\n+  [(set (attr \"length\") (if_then_else (match_test \"flag_pic\")\n+\t\t\t\t      (const_int 12)\n+\t\t\t\t      (const_int 8)))\n+   (set_attr \"type\" \"misc\")]\n+)\n+\n+;; The pattern is for some relaxation groups that have to keep addsi3 in 32-bit mode.\n+(define_insn \"addsi3_32bit\"\n+  [(set (match_operand:SI 0 \"register_operand\"             \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \" r\")] UNSPEC_ADD32))]\n+  \"\"\n+  \"add\\t%0, %1, %2\";\n+  [(set_attr \"type\"    \"alu\")\n+   (set_attr \"length\"  \"4\")\n+   (set_attr \"feature\" \"v1\")])\n+\n+;; ----------------------------------------------------------------------------"}, {"sha": "ee4cf3cf48efa0729fb1a21a373d320d2d6c783e", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=b26fa4f93b784dc4e8f46d91ca3a5101b2ee5f49", "patch": "@@ -44,6 +44,12 @@\n        (match_test \"!(TARGET_ICT_MODEL_LARGE\n \t\t      && nds32_indirect_call_referenced_p (op))\")))\n \n+(define_predicate \"nds32_nonunspec_symbolic_operand\"\n+  (and (match_code \"const,symbol_ref,label_ref\")\n+       (match_test \"!flag_pic && nds32_const_unspec_p (op)\n+\t\t    && !(TARGET_ICT_MODEL_LARGE\n+\t\t\t && nds32_indirect_call_referenced_p (op))\")))\n+\n (define_predicate \"nds32_reg_constant_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (match_operand 0 \"const_int_operand\")))"}]}