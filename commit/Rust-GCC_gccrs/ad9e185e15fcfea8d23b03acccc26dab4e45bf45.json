{"sha": "ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "node_id": "C_kwDOANBUbNoAKGFkOWUxODVlMTVmY2ZlYThkMjNiMDNhY2NjYzI2ZGFiNGU0NWJmNDU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-15T14:27:18Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-04-15T20:23:28Z"}, "message": "Fix bad projection substitution\n\nWhen we have a Trait such as:\n\n```\npub unsafe trait SliceIndex<T> {\n    type Output;\n\n    fn index(self, slice: &T) -> &Self::Output;\n}\n\nunsafe impl<T> SliceIndex<[T]> for Range<usize> {\n    type Output = [T];\n\n    fn index(self, slice: &[T]) -> &[T] {\n        unsafe { &*self.get_unchecked(slice) }\n    }\n}\n\n```\n\nWhen we need to verify that the impl index is compatible fir SliceIndex we\nget the Type info for the trait-item which is:\n\n  fn<Self, T> index(self: Self, slice: &T)\n        -> &<placeholder=projection<T>=[T]>\n\nThis projection gets setup and the types are substituted with\nSelf=Range<usize> and T=[T] which ended up substituting the projection\ntwice resulting in a recursive slice [T=[T]]. In this case the associated\ntype is already setup for the placeholder and does not require generic\nsubstitution. This means we added a flag to the substitution generic\narguments mappings to handle this case.\n\nThis patch also addressed memory corruption with the TypeBoundPredicate\nas part of the debugging of this issue which resulted in a segv when\ntrying to debug the mappings. The issue was the copy constructors needed\nto update the used argument mappings each time since the substitution param\nmappings are copied and the addresses no longer exist, valgrind was great\nhere to find this issue.\n\nFixes #1120", "tree": {"sha": "612e6376f4d9b62256d95686000c569270a35c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/612e6376f4d9b62256d95686000c569270a35c22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d17e0aa7695ddb383e0a4fc43185e2ab42c81703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17e0aa7695ddb383e0a4fc43185e2ab42c81703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17e0aa7695ddb383e0a4fc43185e2ab42c81703"}], "stats": {"total": 467, "additions": 332, "deletions": 135}, "files": [{"sha": "a12736f93f377e7153630a2895561a0237c298bd", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -137,9 +137,9 @@ class TraitItemReference\n   // the trait will not be stored in its own map yet\n   void on_resolved ();\n \n-  void associated_type_set (TyTy::BaseType *ty);\n+  void associated_type_set (TyTy::BaseType *ty) const;\n \n-  void associated_type_reset ();\n+  void associated_type_reset () const;\n \n   bool is_object_safe () const;\n \n@@ -301,6 +301,24 @@ class TraitReference\n     return false;\n   }\n \n+  bool lookup_trait_item_by_type (const std::string &ident,\n+\t\t\t\t  TraitItemReference::TraitItemType type,\n+\t\t\t\t  const TraitItemReference **ref) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (item.get_trait_item_type () != type)\n+\t  continue;\n+\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n   bool lookup_hir_trait_item (const HIR::TraitItem &item,\n \t\t\t      const TraitItemReference **ref) const\n   {"}, {"sha": "5681ebdd8219e8c687c458c17bd80854e63c7bd4", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -128,7 +128,7 @@ TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n }\n \n void\n-TraitItemReference::associated_type_set (TyTy::BaseType *ty)\n+TraitItemReference::associated_type_set (TyTy::BaseType *ty) const\n {\n   rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n \n@@ -141,7 +141,7 @@ TraitItemReference::associated_type_set (TyTy::BaseType *ty)\n }\n \n void\n-TraitItemReference::associated_type_reset ()\n+TraitItemReference::associated_type_reset () const\n {\n   rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n "}, {"sha": "52c866cb40deca8cd6281356e919678353f0e2d9", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 78, "deletions": 82, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -385,9 +385,9 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static const TraitItemReference *\n+  static TyTy::TypeBoundPredicateItem\n   Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n-\t   TraitReference &trait_reference,\n+\t   TyTy::TypeBoundPredicate &trait_reference,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n     TypeCheckImplItemWithTrait resolver (parent, self, trait_reference,\n@@ -398,38 +398,46 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::ConstantItem &constant) override\n   {\n-    trait_reference.lookup_trait_item_by_type (\n+    // normal resolution of the item\n+    TypeCheckImplItem::visit (constant);\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    // map the impl item to the associated trait item\n+    const auto tref = trait_reference.get ();\n+    const TraitItemReference *raw_trait_item = nullptr;\n+    bool found = tref->lookup_trait_item_by_type (\n       constant.get_identifier (), TraitItemReference::TraitItemType::CONST,\n-      &resolved_trait_item);\n+      &raw_trait_item);\n \n     // unknown trait item\n-    if (resolved_trait_item->is_error ())\n+    if (!found || raw_trait_item->is_error ())\n       {\n \tRichLocation r (constant.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n \trust_error_at (r, \"constant %<%s%> is not a member of trait %<%s%>\",\n \t\t       constant.get_identifier ().c_str (),\n \t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n       }\n \n-    // normal resolution of the item\n-    TypeCheckImplItem::visit (constant);\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (constant.get_mappings ().get_hirid (), &lookup))\n-      return;\n-    if (resolved_trait_item->is_error ())\n-      return;\n+    // get the item from the predicate\n+    resolved_trait_item\n+      = trait_reference.lookup_associated_item (raw_trait_item);\n+    rust_assert (!resolved_trait_item.is_error ());\n \n     // merge the attributes\n     const HIR::TraitItem *hir_trait_item\n-      = resolved_trait_item->get_hir_trait_item ();\n+      = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n     merge_attributes (constant.get_outer_attrs (), *hir_trait_item);\n \n     // check the types are compatible\n-    if (!resolved_trait_item->get_tyty ()->can_eq (lookup, true))\n+    auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+    if (!trait_item_type->can_eq (lookup, true))\n       {\n \tRichLocation r (constant.get_locus ());\n-\tr.add_range (resolved_trait_item->get_locus ());\n+\tr.add_range (resolved_trait_item.get_locus ());\n \n \trust_error_at (\n \t  r, \"constant %<%s%> has an incompatible type for trait %<%s%>\",\n@@ -440,38 +448,46 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::TypeAlias &type) override\n   {\n-    trait_reference.lookup_trait_item_by_type (\n+    // normal resolution of the item\n+    TypeCheckImplItem::visit (type);\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    // map the impl item to the associated trait item\n+    const auto tref = trait_reference.get ();\n+    const TraitItemReference *raw_trait_item = nullptr;\n+    bool found = tref->lookup_trait_item_by_type (\n       type.get_new_type_name (), TraitItemReference::TraitItemType::TYPE,\n-      &resolved_trait_item);\n+      &raw_trait_item);\n \n     // unknown trait item\n-    if (resolved_trait_item->is_error ())\n+    if (!found || raw_trait_item->is_error ())\n       {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n \trust_error_at (r, \"type alias %<%s%> is not a member of trait %<%s%>\",\n \t\t       type.get_new_type_name ().c_str (),\n \t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n       }\n \n-    // normal resolution of the item\n-    TypeCheckImplItem::visit (type);\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n-      return;\n-    if (resolved_trait_item->is_error ())\n-      return;\n+    // get the item from the predicate\n+    resolved_trait_item\n+      = trait_reference.lookup_associated_item (raw_trait_item);\n+    rust_assert (!resolved_trait_item.is_error ());\n \n     // merge the attributes\n     const HIR::TraitItem *hir_trait_item\n-      = resolved_trait_item->get_hir_trait_item ();\n+      = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n     merge_attributes (type.get_outer_attrs (), *hir_trait_item);\n \n     // check the types are compatible\n-    if (!resolved_trait_item->get_tyty ()->can_eq (lookup, true))\n+    auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+    if (!trait_item_type->can_eq (lookup, true))\n       {\n \tRichLocation r (type.get_locus ());\n-\tr.add_range (resolved_trait_item->get_locus ());\n+\tr.add_range (resolved_trait_item.get_locus ());\n \n \trust_error_at (\n \t  r, \"type alias %<%s%> has an incompatible type for trait %<%s%>\",\n@@ -481,83 +497,63 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n     // its actually a projection, since we need a way to actually bind the\n     // generic substitutions to the type itself\n-    TyTy::ProjectionType *projection = new TyTy::ProjectionType (\n-      type.get_mappings ().get_hirid (), lookup, &trait_reference,\n-      resolved_trait_item->get_mappings ().get_defid (), substitutions);\n+    TyTy::ProjectionType *projection\n+      = new TyTy::ProjectionType (type.get_mappings ().get_hirid (), lookup,\n+\t\t\t\t  tref,\n+\t\t\t\t  raw_trait_item->get_mappings ().get_defid (),\n+\t\t\t\t  substitutions);\n \n     context->insert_type (type.get_mappings (), projection);\n-    resolved_trait_item->associated_type_set (projection);\n+    raw_trait_item->associated_type_set (projection);\n   }\n \n   void visit (HIR::Function &function) override\n   {\n-    // resolved_trait_item = trait_reference.lookup_trait_item (\n-    //   function.get_function_name (), TraitItemReference::TraitItemType::FN);\n-    trait_reference.lookup_trait_item_by_type (\n-      function.get_function_name (), TraitItemReference::TraitItemType::FN,\n-      &resolved_trait_item);\n+    // we get the error checking from the base method here\n+    TypeCheckImplItem::visit (function);\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    // map the impl item to the associated trait item\n+    const auto tref = trait_reference.get ();\n+    const TraitItemReference *raw_trait_item = nullptr;\n+    bool found\n+      = tref->lookup_trait_item_by_type (function.get_function_name (),\n+\t\t\t\t\t TraitItemReference::TraitItemType::FN,\n+\t\t\t\t\t &raw_trait_item);\n \n     // unknown trait item\n-    if (resolved_trait_item->is_error ())\n+    if (!found || raw_trait_item->is_error ())\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (trait_reference.get_locus ());\n \trust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n \t\t       function.get_function_name ().c_str (),\n \t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n       }\n \n-    // we get the error checking from the base method here\n-    TypeCheckImplItem::visit (function);\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n-      return;\n-    if (resolved_trait_item->is_error ())\n-      return;\n+    // get the item from the predicate\n+    resolved_trait_item\n+      = trait_reference.lookup_associated_item (raw_trait_item);\n+    rust_assert (!resolved_trait_item.is_error ());\n \n     // merge the attributes\n     const HIR::TraitItem *hir_trait_item\n-      = resolved_trait_item->get_hir_trait_item ();\n+      = resolved_trait_item.get_raw_item ()->get_hir_trait_item ();\n     merge_attributes (function.get_outer_attrs (), *hir_trait_item);\n \n-    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-    rust_assert (resolved_trait_item->get_tyty ()->get_kind ()\n-\t\t == TyTy::TypeKind::FNDEF);\n-\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-    TyTy::FnType *trait_item_fntype\n-      = static_cast<TyTy::FnType *> (resolved_trait_item->get_tyty ());\n-\n-    // sets substitute self into the trait_item_ref->tyty\n-    TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n-    for (auto &param_mapping : trait_item_fntype->get_substs ())\n-      {\n-\tconst HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n-\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t  {\n-\t    self_mapping = &param_mapping;\n-\t    break;\n-\t  }\n-      }\n-    rust_assert (self_mapping != nullptr);\n-\n-    std::vector<TyTy::SubstitutionArg> mappings;\n-    mappings.push_back (TyTy::SubstitutionArg (self_mapping, self));\n-\n-    TyTy::SubstitutionArgumentMappings implicit_self_substs (\n-      mappings, function.get_locus ());\n-    trait_item_fntype\n-      = trait_item_fntype->handle_substitions (implicit_self_substs);\n-\n     // check the types are compatible\n-    if (!trait_item_fntype->can_eq (fntype, true))\n+    auto trait_item_type = resolved_trait_item.get_tyty_for_receiver (self);\n+    if (!trait_item_type->can_eq (lookup, true))\n       {\n \tRichLocation r (function.get_locus ());\n-\tr.add_range (resolved_trait_item->get_locus ());\n+\tr.add_range (resolved_trait_item.get_locus ());\n \n \trust_error_at (\n \t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n-\t  fntype->get_identifier ().c_str (),\n+\t  function.get_function_name ().c_str (),\n \t  trait_reference.get_name ().c_str ());\n       }\n   }\n@@ -577,19 +573,19 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n private:\n   TypeCheckImplItemWithTrait (\n     HIR::ImplBlock *parent, TyTy::BaseType *self,\n-    TraitReference &trait_reference,\n+    TyTy::TypeBoundPredicate &trait_reference,\n     std::vector<TyTy::SubstitutionParamMapping> substitutions)\n     : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n-      resolved_trait_item (&TraitItemReference::error_node ()),\n+      resolved_trait_item (TyTy::TypeBoundPredicateItem::error ()),\n       substitutions (substitutions)\n   {\n     rust_assert (is_trait_impl_block ());\n   }\n \n   bool is_trait_impl_block () const { return !trait_reference.is_error (); }\n \n-  TraitReference &trait_reference;\n-  TraitItemReference *resolved_trait_item;\n+  TyTy::TypeBoundPredicate &trait_reference;\n+  TyTy::TypeBoundPredicateItem resolved_trait_item;\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n "}, {"sha": "9d3beae7a61ba214c1fce4aaea01381eee22d286", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -78,9 +78,9 @@ class TypeCheckItem : public TypeCheckBase\n \ttrait_reference = TraitResolver::Resolve (*ref.get ());\n \trust_assert (!trait_reference->is_error ());\n \n+\t// we don't error out here see: gcc/testsuite/rust/compile/traits2.rs\n+\t// for example\n \tspecified_bound = get_predicate_from_bound (*ref.get ());\n-\t// FIXME error out maybe?\n-\t// if specified_Bound == TyTy::TypeBoundPredicate::error() ?\n       }\n \n     TyTy::BaseType *self = nullptr;\n@@ -120,9 +120,9 @@ class TypeCheckItem : public TypeCheckBase\n \t    auto trait_item_ref\n \t      = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n \t\t\t\t\t\t     impl_item.get (), self,\n-\t\t\t\t\t\t     *trait_reference,\n+\t\t\t\t\t\t     specified_bound,\n \t\t\t\t\t\t     substitutions);\n-\t    trait_item_refs.push_back (trait_item_ref);\n+\t    trait_item_refs.push_back (trait_item_ref.get_raw_item ());\n \t  }\n       }\n \n@@ -134,7 +134,7 @@ class TypeCheckItem : public TypeCheckBase\n \t// filter the missing impl_items\n \tstd::vector<std::reference_wrapper<const TraitItemReference>>\n \t  missing_trait_items;\n-\tfor (auto &trait_item_ref : trait_reference->get_trait_items ())\n+\tfor (const auto &trait_item_ref : trait_reference->get_trait_items ())\n \t  {\n \t    bool found = false;\n \t    for (auto implemented_trait_item : trait_item_refs)"}, {"sha": "8e337839095e09973c4a1303ef2ac3b1ec56d8da", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -211,8 +211,8 @@ class TypeCheckContext\n   void clear_associated_type_mapping (HirId id)\n   {\n     auto it = associated_type_mappings.find (id);\n-    rust_assert (it != associated_type_mappings.end ());\n-    associated_type_mappings.erase (it);\n+    if (it != associated_type_mappings.end ())\n+      associated_type_mappings.erase (it);\n   }\n \n   // lookup any associated type mappings, the out parameter of mapping is"}, {"sha": "028e10c0efe0cbb67605e230b0c6d0e32d6a2e41", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -208,7 +208,14 @@ class SubstMapperInternal : public TyTy::TyVisitor\n   void visit (TyTy::PlaceholderType &type) override\n   {\n     rust_assert (type.can_resolve ());\n-    resolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+    if (mappings.trait_item_mode ())\n+      {\n+\tresolved = type.resolve ();\n+      }\n+    else\n+      {\n+\tresolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+      }\n   }\n \n   void visit (TyTy::ProjectionType &type) override"}, {"sha": "bda7a7f47a67dc3bd435067a46d26335f8aa65cf", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 61, "deletions": 25, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -103,23 +103,28 @@ namespace TyTy {\n \n TypeBoundPredicate::TypeBoundPredicate (\n   const Resolver::TraitReference &trait_reference, Location locus)\n-  : SubstitutionRef (trait_reference.get_trait_substs (),\n-\t\t     SubstitutionArgumentMappings::error ()),\n+  : SubstitutionRef ({}, SubstitutionArgumentMappings::error ()),\n     reference (trait_reference.get_mappings ().get_defid ()), locus (locus),\n     error_flag (false)\n {\n+  substitutions.clear ();\n+  for (const auto &p : trait_reference.get_trait_substs ())\n+    substitutions.push_back (p.clone ());\n+\n   // we setup a dummy implict self argument\n   SubstitutionArg placeholder_self (&get_substs ().front (), nullptr);\n   used_arguments.get_mappings ().push_back (placeholder_self);\n }\n \n TypeBoundPredicate::TypeBoundPredicate (\n-  DefId reference, std::vector<SubstitutionParamMapping> substitutions,\n-  Location locus)\n-  : SubstitutionRef (std::move (substitutions),\n-\t\t     SubstitutionArgumentMappings::error ()),\n+  DefId reference, std::vector<SubstitutionParamMapping> subst, Location locus)\n+  : SubstitutionRef ({}, SubstitutionArgumentMappings::error ()),\n     reference (reference), locus (locus), error_flag (false)\n {\n+  substitutions.clear ();\n+  for (const auto &p : subst)\n+    substitutions.push_back (p.clone ());\n+\n   // we setup a dummy implict self argument\n   SubstitutionArg placeholder_self (&get_substs ().front (), nullptr);\n   used_arguments.get_mappings ().push_back (placeholder_self);\n@@ -131,7 +136,6 @@ TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n     error_flag (other.error_flag)\n {\n   substitutions.clear ();\n-\n   for (const auto &p : other.get_substs ())\n     substitutions.push_back (p.clone ());\n \n@@ -143,8 +147,19 @@ TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n       mappings.push_back (std::move (arg));\n     }\n \n+  // we need to remap the argument mappings based on this copied constructor\n+  std::vector<SubstitutionArg> copied_arg_mappings;\n+  size_t i = 0;\n+  for (const auto &m : other.used_arguments.get_mappings ())\n+    {\n+      TyTy::BaseType *argument\n+\t= m.get_tyty () == nullptr ? nullptr : m.get_tyty ()->clone ();\n+      SubstitutionArg c (&substitutions.at (i++), argument);\n+      copied_arg_mappings.push_back (std::move (c));\n+    }\n+\n   used_arguments\n-    = SubstitutionArgumentMappings (mappings,\n+    = SubstitutionArgumentMappings (copied_arg_mappings,\n \t\t\t\t    other.used_arguments.get_locus ());\n }\n \n@@ -168,8 +183,19 @@ TypeBoundPredicate::operator= (const TypeBoundPredicate &other)\n       mappings.push_back (std::move (arg));\n     }\n \n+  // we need to remap the argument mappings based on this copied constructor\n+  std::vector<SubstitutionArg> copied_arg_mappings;\n+  size_t i = 0;\n+  for (const auto &m : other.used_arguments.get_mappings ())\n+    {\n+      TyTy::BaseType *argument\n+\t= m.get_tyty () == nullptr ? nullptr : m.get_tyty ()->clone ();\n+      SubstitutionArg c (&substitutions.at (i++), argument);\n+      copied_arg_mappings.push_back (std::move (c));\n+    }\n+\n   used_arguments\n-    = SubstitutionArgumentMappings (mappings,\n+    = SubstitutionArgumentMappings (copied_arg_mappings,\n \t\t\t\t    other.used_arguments.get_locus ());\n \n   return *this;\n@@ -204,16 +230,7 @@ TypeBoundPredicate::get () const\n std::string\n TypeBoundPredicate::get_name () const\n {\n-  auto mappings = Analysis::Mappings::get ();\n-  auto trait = get ();\n-  auto nodeid = trait->get_mappings ().get_nodeid ();\n-\n-  const Resolver::CanonicalPath *p = nullptr;\n-  if (mappings->lookup_canonical_path (mappings->get_current_crate (), nodeid,\n-\t\t\t\t       &p))\n-    return p->get ();\n-\n-  return trait->get_name ();\n+  return get ()->get_name ();\n }\n \n bool\n@@ -285,15 +302,28 @@ TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n   if (is_associated_type)\n     return trait_item_tyty;\n \n-  SubstitutionArgumentMappings gargs = parent->get_substitution_arguments ();\n-\n   // set up the self mapping\n+  SubstitutionArgumentMappings gargs = parent->get_substitution_arguments ();\n   rust_assert (!gargs.is_empty ());\n-  auto &sarg = gargs.get_mappings ().at (0);\n-  SubstitutionArg self (sarg.get_param_mapping (), receiver->clone ());\n-  gargs.get_mappings ()[0] = self;\n \n-  return Resolver::SubstMapperInternal::Resolve (trait_item_tyty, gargs);\n+  // setup the adjusted mappings\n+  std::vector<SubstitutionArg> adjusted_mappings;\n+  for (size_t i = 0; i < gargs.get_mappings ().size (); i++)\n+    {\n+      auto &mapping = gargs.get_mappings ().at (i);\n+\n+      bool is_implicit_self = i == 0;\n+      TyTy::BaseType *argument\n+\t= is_implicit_self ? receiver->clone () : mapping.get_tyty ();\n+\n+      SubstitutionArg arg (mapping.get_param_mapping (), argument);\n+      adjusted_mappings.push_back (std::move (arg));\n+    }\n+\n+  SubstitutionArgumentMappings adjusted (adjusted_mappings, gargs.get_locus (),\n+\t\t\t\t\t gargs.get_subst_cb (),\n+\t\t\t\t\t true /* trait-mode-flag */);\n+  return Resolver::SubstMapperInternal::Resolve (trait_item_tyty, adjusted);\n }\n bool\n TypeBoundPredicate::is_error () const\n@@ -352,6 +382,12 @@ TypeBoundPredicateItem::needs_implementation () const\n   return !get_raw_item ()->is_optional ();\n }\n \n+Location\n+TypeBoundPredicateItem::get_locus () const\n+{\n+  return get_raw_item ()->get_locus ();\n+}\n+\n // TypeBoundsMappings\n \n TypeBoundsMappings::TypeBoundsMappings ("}, {"sha": "d9a42439e74fa03a86af5e980afd27f0535d87be", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -480,7 +480,7 @@ SubstitutionParamMapping::fill_param_ty (\n \n   if (type.get_kind () == TypeKind::PARAM)\n     {\n-      delete param;\n+      // delete param;\n       param = static_cast<ParamType *> (type.clone ());\n     }\n   else\n@@ -643,8 +643,9 @@ SubstitutionRef::adjust_mappings_for_this (\n   if (resolved_mappings.empty ())\n     return SubstitutionArgumentMappings::error ();\n \n-  return SubstitutionArgumentMappings (resolved_mappings,\n-\t\t\t\t       mappings.get_locus ());\n+  return SubstitutionArgumentMappings (resolved_mappings, mappings.get_locus (),\n+\t\t\t\t       mappings.get_subst_cb (),\n+\t\t\t\t       mappings.trait_item_mode ());\n }\n \n bool\n@@ -2699,6 +2700,13 @@ ProjectionType::clone () const\n ProjectionType *\n ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n+  // // do we really need to substitute this?\n+  // if (base->needs_generic_substitutions () || base->contains_type_parameters\n+  // ())\n+  //   {\n+  //     return this;\n+  //   }\n+\n   ProjectionType *projection = static_cast<ProjectionType *> (clone ());\n   projection->set_ty_ref (mappings->get_next_hir_id ());\n   projection->used_arguments = subst_mappings;\n@@ -2755,9 +2763,7 @@ ProjectionType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \t  return nullptr;\n \t}\n \n-      auto new_field = concrete->clone ();\n-      new_field->set_ref (fty->get_ref ());\n-      projection->base = new_field;\n+      projection->base = concrete;\n     }\n \n   return projection;"}, {"sha": "1f157c8c52abed218537a818791ed58282ceb9b5", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -101,6 +101,8 @@ class TypeBoundPredicateItem\n \n   const TypeBoundPredicate *get_parent () const { return parent; }\n \n+  Location get_locus () const;\n+\n private:\n   const TypeBoundPredicate *parent;\n   const Resolver::TraitItemReference *trait_item_ref;\n@@ -661,13 +663,16 @@ class SubstitutionArgumentMappings\n public:\n   SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n \t\t\t\tLocation locus,\n-\t\t\t\tParamSubstCb param_subst_cb = nullptr)\n-    : mappings (mappings), locus (locus), param_subst_cb (param_subst_cb)\n+\t\t\t\tParamSubstCb param_subst_cb = nullptr,\n+\t\t\t\tbool trait_item_flag = false)\n+    : mappings (mappings), locus (locus), param_subst_cb (param_subst_cb),\n+      trait_item_flag (trait_item_flag)\n   {}\n \n   SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n     : mappings (other.mappings), locus (other.locus),\n-      param_subst_cb (other.param_subst_cb)\n+      param_subst_cb (other.param_subst_cb),\n+      trait_item_flag (other.trait_item_flag)\n   {}\n \n   SubstitutionArgumentMappings &\n@@ -676,13 +681,14 @@ class SubstitutionArgumentMappings\n     mappings = other.mappings;\n     locus = other.locus;\n     param_subst_cb = other.param_subst_cb;\n+    trait_item_flag = other.trait_item_flag;\n \n     return *this;\n   }\n \n   static SubstitutionArgumentMappings error ()\n   {\n-    return SubstitutionArgumentMappings ({}, Location (), nullptr);\n+    return SubstitutionArgumentMappings ({}, Location (), nullptr, false);\n   }\n \n   bool is_error () const { return mappings.size () == 0; }\n@@ -754,10 +760,15 @@ class SubstitutionArgumentMappings\n     param_subst_cb (p, a);\n   }\n \n+  ParamSubstCb get_subst_cb () const { return param_subst_cb; }\n+\n+  bool trait_item_mode () const { return trait_item_flag; }\n+\n private:\n   std::vector<SubstitutionArg> mappings;\n   Location locus;\n   ParamSubstCb param_subst_cb;\n+  bool trait_item_flag;\n };\n \n class SubstitutionRef\n@@ -2296,8 +2307,9 @@ class PlaceholderType : public BaseType\n class ProjectionType : public BaseType, public SubstitutionRef\n {\n public:\n-  ProjectionType (HirId ref, BaseType *base, Resolver::TraitReference *trait,\n-\t\t  DefId item, std::vector<SubstitutionParamMapping> subst_refs,\n+  ProjectionType (HirId ref, BaseType *base,\n+\t\t  const Resolver::TraitReference *trait, DefId item,\n+\t\t  std::vector<SubstitutionParamMapping> subst_refs,\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n \t\t  std::set<HirId> refs = std::set<HirId> ())\n@@ -2310,7 +2322,7 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   {}\n \n   ProjectionType (HirId ref, HirId ty_ref, BaseType *base,\n-\t\t  Resolver::TraitReference *trait, DefId item,\n+\t\t  const Resolver::TraitReference *trait, DefId item,\n \t\t  std::vector<SubstitutionParamMapping> subst_refs,\n \t\t  SubstitutionArgumentMappings generic_arguments\n \t\t  = SubstitutionArgumentMappings::error (),\n@@ -2361,7 +2373,7 @@ class ProjectionType : public BaseType, public SubstitutionRef\n \n private:\n   BaseType *base;\n-  Resolver::TraitReference *trait;\n+  const Resolver::TraitReference *trait;\n   DefId item;\n };\n "}, {"sha": "e1aef5397fc9cb02e379cd7ba9ce7a3a2945e4ed", "filename": "gcc/testsuite/rust/compile/traits9.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -1,4 +1,3 @@\n-// { dg-additional-options -frust-crate=example }\n struct Foo(i32);\n trait Bar {\n     fn baz(&self);\n@@ -9,6 +8,6 @@ fn main() {\n     a = Foo(123);\n \n     let b: &dyn Bar = &a;\n-    // { dg-error \"bounds not satisfied for Foo .example::Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"bounds not satisfied for Foo .Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n     // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "ecbc6b2017f2485adfdcadd160bb8741b070f023", "filename": "gcc/testsuite/rust/execute/torture/issue-1120.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1120.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad9e185e15fcfea8d23b03acccc26dab4e45bf45/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1120.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1120.rs?ref=ad9e185e15fcfea8d23b03acccc26dab4e45bf45", "patch": "@@ -0,0 +1,123 @@\n+// { dg-additional-options \"-w\" }\n+extern \"rust-intrinsic\" {\n+    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n+}\n+\n+struct FatPtr<T> {\n+    data: *const T,\n+    len: usize,\n+}\n+\n+pub union Repr<T> {\n+    rust: *const [T],\n+    rust_mut: *mut [T],\n+    raw: FatPtr<T>,\n+}\n+\n+pub enum Option<T> {\n+    None,\n+    Some(T),\n+}\n+\n+#[lang = \"Range\"]\n+pub struct Range<Idx> {\n+    pub start: Idx,\n+    pub end: Idx,\n+}\n+\n+#[lang = \"const_slice_ptr\"]\n+impl<T> *const [T] {\n+    pub const fn len(self) -> usize {\n+        let a = unsafe { Repr { rust: self }.raw };\n+        a.len\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+#[lang = \"const_ptr\"]\n+impl<T> *const T {\n+    pub const unsafe fn offset(self, count: isize) -> *const T {\n+        unsafe { offset(self, count) }\n+    }\n+\n+    pub const unsafe fn add(self, count: usize) -> Self {\n+        unsafe { self.offset(count as isize) }\n+    }\n+\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+}\n+\n+const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n+    unsafe {\n+        Repr {\n+            raw: FatPtr { data, len },\n+        }\n+        .rust\n+    }\n+}\n+\n+#[lang = \"index\"]\n+trait Index<Idx> {\n+    type Output;\n+\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+pub unsafe trait SliceIndex<T> {\n+    type Output;\n+\n+    fn get(self, slice: &T) -> Option<&Self::Output>;\n+\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n+\n+    fn index(self, slice: &T) -> &Self::Output;\n+}\n+\n+unsafe impl<T> SliceIndex<[T]> for Range<usize> {\n+    type Output = [T];\n+\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end\n+        /* || self.end > slice.len() */\n+        {\n+            Option::None\n+        } else {\n+            unsafe { Option::Some(&*self.get_unchecked(slice)) }\n+        }\n+    }\n+\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        unsafe {\n+            let a: *const T = slice.as_ptr();\n+            let b: *const T = a.add(self.start);\n+            slice_from_raw_parts(b, self.end - self.start)\n+        }\n+    }\n+\n+    fn index(self, slice: &[T]) -> &[T] {\n+        unsafe { &*self.get_unchecked(slice) }\n+    }\n+}\n+\n+impl<T, I> Index<I> for [T]\n+where\n+    I: SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = [1, 2, 3, 4, 5];\n+    let b = &a[1..3];\n+\n+    0\n+}"}]}