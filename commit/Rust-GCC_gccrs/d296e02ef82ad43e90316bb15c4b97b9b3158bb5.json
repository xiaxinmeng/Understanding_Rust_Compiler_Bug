{"sha": "d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI5NmUwMmVmODJhZDQzZTkwMzE2YmIxNWM0Yjk3YjliMzE1OGJiNQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2006-11-13T20:14:35Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2006-11-13T20:14:35Z"}, "message": "cell.md: New file.\n\n2006-11-13  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * config/rs6000/cell.md: New file.\n        * config/rs6000/rs6000.c (rs6000_cell_dont_microcode): New\n        variable.\n        (ppccell_cost): New cost matrix.\n        (TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD): Define.\n        (rs6000_override_options): Set rs6000_always_hint to false\n        for cell. Also align functions/lables/loops to 8byte\n        for the Cell. Use PROCESSOR_CELL.\n        (rs6000_emit_epilogue): Rename using_mfcr_multiple to\n        using_mtcr_multiple.\n        (rs6000_variable_issue): If the insn is a nonpipelined instruction\n        on the Cell, return 0.\n        (rs6000_adjust_cost): Add Cell cost adjustments.\n        (is_microcoded_insn): Return true for Cell microcoded\n        instructions.\n        (is_nonpipeline_insn): New function.\n        (rs6000_issue_rate): Add PROCESSOR_CELL.\n        (rs6000_use_sched_lookahead): If Cell, then we should look ahead 8\n        instructions.\n        (rs6000_use_sched_lookahead_guard): New function.\n        (rs6000_sched_reorder):  Reorder the ready list, if the second\n        to last ready insn is a nonepipeline insn on the Cell.\n        * config/rs6000/rs6000.h (processor_type): Add PROCESSOR_CELL.\n        (ASM_CPU_SPEC): Add Cell.\n        * config/rs6000/rs6000.md (cpu): Add Cell.\n        (cell_micro): New Attr.\n        Include cell.md\n\nFrom-SVN: r118776", "tree": {"sha": "6b0ccd62cc1485209f2f69625a8eb021ebc71336", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b0ccd62cc1485209f2f69625a8eb021ebc71336"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/comments", "author": null, "committer": null, "parents": [{"sha": "e8116f402620de806919e34717ec100f5b571dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8116f402620de806919e34717ec100f5b571dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8116f402620de806919e34717ec100f5b571dc8"}], "stats": {"total": 586, "additions": 578, "deletions": 8}, "files": [{"sha": "206bd4358580f7c1fddfb9ae20ca60530e374e31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "patch": "@@ -1,3 +1,33 @@\n+2006-11-13  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/rs6000/cell.md: New file.\n+\t* config/rs6000/rs6000.c (rs6000_cell_dont_microcode): New \n+\tvariable.\n+\t(ppccell_cost): New cost matrix.\n+\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD): Define.\n+\t(rs6000_override_options): Set rs6000_always_hint to false\n+\tfor cell. Also align functions/lables/loops to 8byte\n+\tfor the Cell. Use PROCESSOR_CELL.\n+\t(rs6000_emit_epilogue): Rename using_mfcr_multiple to\n+\tusing_mtcr_multiple.\n+\t(rs6000_variable_issue): If the insn is a nonpipelined instruction\n+\ton the Cell, return 0.\n+\t(rs6000_adjust_cost): Add Cell cost adjustments.\n+\t(is_microcoded_insn): Return true for Cell microcoded\n+\tinstructions.\n+\t(is_nonpipeline_insn): New function.\n+\t(rs6000_issue_rate): Add PROCESSOR_CELL.\n+\t(rs6000_use_sched_lookahead): If Cell, then we should look ahead 8\n+\tinstructions.\n+\t(rs6000_use_sched_lookahead_guard): New function.\n+\t(rs6000_sched_reorder):  Reorder the ready list, if the second\n+\tto last ready insn is a nonepipeline insn on the Cell.\n+\t* config/rs6000/rs6000.h (processor_type): Add PROCESSOR_CELL.\n+\t(ASM_CPU_SPEC): Add Cell.\n+\t* config/rs6000/rs6000.md (cpu): Add Cell.\n+\t(cell_micro): New Attr.\n+\tInclude cell.md\n+\n 2006-11-13  Jakub Jelinek  <jakub@redhat.com>\n \n \t* configure.ac (ld_vers): Parse GNU ld version 2.17.50.0.3-6 20060715"}, {"sha": "f12d2a66cc80ce2da90e9e560189a53441b96d1a", "filename": "gcc/config/rs6000/cell.md", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Fcell.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Fcell.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fcell.md?ref=d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "patch": "@@ -0,0 +1,401 @@\n+;; Scheduling description for cell processor.\n+;; Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+;; Free Software Foundation, Inc.\n+;; Contributed by Sony Computer Entertainment, Inc.,\n+\n+\n+;; This file is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 2 of the License, or (at your option) \n+;; any later version.\n+\n+;; This file is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with this file; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; Sources: BE BOOK4 (/sfs/enc/doc/PPU_BookIV_DD3.0_latest.pdf)\n+\n+;; BE Architechture *DD3.0 and DD3.1*\n+;; This file simulate PPU processor unit backend of pipeline, maualP24. \n+;; manual P27, stall and flush points\n+;; IU, XU, VSU, dipatcher decodes and dispatch 2 insns per cycle in program\n+;;  order, the grouped adress are aligned by 8\n+;; This file only simulate one thread situation\n+;; XU executes all fixed point insns(3 units, a simple alu, a complex unit,\n+;;   and load/store unit)\n+;; VSU executes all scalar floating points insn(a float unit),\n+;;   VMX insns(VMX unit, 4 sub units, simple, permute, complex, floating point)\n+\n+;; Dual issue combination\n+\n+;;\tFXU\tLSU\tBR \t        VMX\t               VMX\n+;;                             (sx,cx,vsu_fp,fp_arith)    (perm,vsu_ls,fp_ls)\n+;;FXU\tX\n+;;LSU\t\tX               \tX               \tX\t\n+;;BR\t\t\tX\n+;;VMX(sx,cx,vsu_fp,fp_arth)\t\tX\n+;;VMX(perm,vsu_ls, fp_ls)\t\t\t\t\tX\n+;;    X are illegal combination.\n+\n+;; Dual issue exceptons: \n+;;(1) nop-pipelined FXU instr in slot 0 \n+;;(2) non-pipelined FPU inst in slot 0\n+;; CSI instr(contex-synchronizing insn)\n+;; Microcode insn\n+\n+;; BRU unit: bru(none register stall), bru_cr(cr register stall)\n+;; VSU unit: vus(vmx simple), vup(vmx permute), vuc(vmx complex),\n+;;  vuf(vmx float), fpu(floats). fpu_div is hypthetical, it is for \n+;;  nonpipelined simulation\n+;; micr insns will stall at least 7 cycles to get the first instr from ROM,\n+;;  micro instructions are not dual issued. \n+\n+;; slot0 is older than slot1\n+;; non-pipelined insn need to be in slot1 to avoid 1cycle stall\n+\n+;; There different stall point\n+;; IB2, only stall one thread if stall here, so try to stall here as much as\n+;; we can \n+;; condition(1) insert nop, OR and ORI instruction form \n+;; condition(2) flush happens, in case of: RAW, WAW, D-ERAT miss, or\n+;;   CR0-access while stdcx, or stwcx\n+;; IS2 stall ;; Page91 for details\n+;; VQ8 stall\n+;; IS2 stall can be activated by VQ8 stall and trying to issue a vsu instr to\n+;;  the vsu issue queue\n+\n+;;(define_automaton \"cellxu\")\n+\n+;;(define_cpu_unit \"fxu_cell,lsu_cell,bru_cell,vsu1_cell,vsu2_cell\" \"cellxu\")\n+\n+;; ndfa\n+(define_automaton \"cellxu,cellvsu,cellbru,cell_mis\")\n+\n+(define_cpu_unit \"fxu_cell,lsu_cell\" \"cellxu\")\n+(define_cpu_unit \"bru_cell\" \"cellbru\")\n+(define_cpu_unit \"vsu1_cell,vsu2_cell\" \"cellvsu\")\n+\n+(define_cpu_unit \"slot0,slot1\" \"cell_mis\")\n+\n+(absence_set \"slot0\" \"slot1\")\n+\n+(define_reservation \"nonpipeline\" \"fxu_cell+lsu_cell+vsu1_cell+vsu2_cell\")\n+(define_reservation \"slot01\" \"slot0|slot1\")\n+\n+\n+;; Load/store\n+;; lmw, lswi, lswx are only generated for optimize for space, MC,\n+;;   these instr are not simulated\n+(define_insn_reservation \"cell-load\" 2\n+  (and (eq_attr \"type\" \"load\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,lsu_cell\")\n+\n+;; ldux, ldu, lbzux, lbzu, hardware breaks it down to two instrs,\n+;;  if with 32bytes alignment, CMC\n+(define_insn_reservation \"cell-load-ux\" 2\n+  (and (eq_attr \"type\" \"load_ux,load_u\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,fxu_cell+lsu_cell\")\n+\n+;; lha, lhax, lhau, lhaux, lwa, lwax, lwaux, MC, latency unknown\n+;;   11/7, 11/8, 11/12\n+(define_insn_reservation \"cell-load-ext\" 2\n+  (and (eq_attr \"type\" \"load_ext,load_ext_u,load_ext_ux\")\n+       (eq_attr \"cpu\" \"cell\")) \n+  \"slot01,fxu_cell+lsu_cell\")\n+\n+;;lfs,lfsx,lfd,lfdx, 1 cycle\n+(define_insn_reservation \"cell-fpload\" 1\n+  (and (eq_attr \"type\" \"fpload\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"vsu2_cell+lsu_cell+slot01\")\n+\n+;; lfsu,lfsux,lfdu,lfdux 1cycle(fpr) 2 cycle(gpr)\n+(define_insn_reservation \"cell-fpload-update\" 1\n+  (and (eq_attr \"type\" \"fpload,fpload_u,fpload_ux\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"fxu_cell+vsu2_cell+lsu_cell+slot01\")\n+\n+(define_insn_reservation \"cell-vecload\" 2\n+  (and (eq_attr \"type\" \"vecload\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu2_cell+lsu_cell\")\n+\n+;;st? stw(MC)\n+(define_insn_reservation \"cell-store\" 1\n+  (and (eq_attr \"type\" \"store\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"lsu_cell+slot01\")\n+\n+;;stdux, stdu, (hardware breaks into store and add) 2 for update reg\n+(define_insn_reservation \"cell-store-update\" 1\n+  (and (eq_attr \"type\" \"store_ux,store_u\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"fxu_cell+lsu_cell+slot01\")\n+\n+(define_insn_reservation \"cell-fpstore\" 1\n+  (and (eq_attr \"type\" \"fpstore\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"vsu2_cell+lsu_cell+slot01\")\n+\n+(define_insn_reservation \"cell-fpstore-update\" 1\n+  (and (eq_attr \"type\" \"fpstore_ux,fpstore_u\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"vsu2_cell+fxu_cell+lsu_cell+slot01\")\n+\n+(define_insn_reservation \"cell-vecstore\" 1\n+  (and (eq_attr \"type\" \"vecstore\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"vsu2_cell+lsu_cell+slot01\")\n+\n+;; Integer latency is 2 cycles\n+(define_insn_reservation \"cell-integer\" 2\n+  (and (eq_attr \"type\" \"integer,insert_dword,shift,trap,\\\n+\t\t\tvar_shift_rotate,cntlz,exts\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,fxu_cell\")\n+\n+;; Two integer latency is 4 cycles\n+(define_insn_reservation \"cell-two\" 4\n+  (and (eq_attr \"type\" \"two\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,fxu_cell,fxu_cell*2\")\n+\n+;; Three integer latency is 6 cycles\n+(define_insn_reservation \"cell-three\" 6\n+  (and (eq_attr \"type\" \"three\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,fxu_cell,fxu_cell*4\")\n+\n+;; rlwimi, alter cr0  \n+(define_insn_reservation \"cell-insert\" 2\n+  (and (eq_attr \"type\" \"insert_word\")\n+       (eq_attr \"cpu\" \"cell\"))\n+ \"slot01,fxu_cell\")\n+\n+;; cmpi, cmpli, cmpla, add, addo, sub, subo, alter cr0 \n+(define_insn_reservation \"cell-cmp\" 1\n+  (and (eq_attr \"type\" \"cmp\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"fxu_cell+slot01\")\n+\n+;; add, addo, sub, subo, alter cr0, rldcli, rlwinm \n+(define_insn_reservation \"cell-fast-cmp\" 2\n+  (and (and (eq_attr \"type\" \"fast_compare,delayed_compare,compare,\\\n+\t\t\t    var_delayed_compare\")\n+            (eq_attr \"cpu\" \"cell\"))\n+        (eq_attr \"cell_micro\" \"not\"))\n+  \"slot01,fxu_cell\")\n+\n+(define_insn_reservation \"cell-cmp-microcoded\" 9\n+  (and (and (eq_attr \"type\" \"fast_compare,delayed_compare,compare,\\\n+\t\t\t    var_delayed_compare\")\n+            (eq_attr \"cpu\" \"cell\"))\n+        (eq_attr \"cell_micro\" \"always\"))\n+  \"slot0+slot1,fxu_cell,fxu_cell*7\")\n+\n+;; mulld\n+(define_insn_reservation \"cell-lmul\" 15\n+  (and (eq_attr \"type\" \"lmul\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*13\")\n+\n+;; mulld. is microcoded\n+(define_insn_reservation \"cell-lmul-cmp\" 22\n+  (and (eq_attr \"type\" \"lmul_compare\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot0+slot1,nonpipeline,nonpipeline*20\")\n+\n+;; mulli, 6 cycles\n+(define_insn_reservation \"cell-imul23\" 6\n+  (and (eq_attr \"type\" \"imul2,imul3\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*4\")\n+\n+;; mullw, 9\n+(define_insn_reservation \"cell-imul\" 9\n+  (and (eq_attr \"type\" \"imul\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*7\")\n+ \n+;; divide\n+(define_insn_reservation \"cell-idiv\" 32\n+  (and (eq_attr \"type\" \"idiv\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*30\")\n+\n+(define_insn_reservation \"cell-ldiv\" 64\n+  (and (eq_attr \"type\" \"ldiv\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*62\")\n+\n+;;mflr and mfctr are pipelined\n+(define_insn_reservation \"cell-mfjmpr\" 1\n+  (and (eq_attr \"type\" \"mfjmpr\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01+bru_cell\")\n+\n+;;mtlr and mtctr,\n+;;mtspr fully pipelined \n+(define_insn_reservation \"cell-mtjmpr\" 1\n+ (and (eq_attr \"type\" \"mtjmpr\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"bru_cell+slot01\")\n+\n+;; Branches\n+;; b, ba, bl, bla, unconditional branch always predicts correctly n/a latency\n+;; bcctr, bcctrl, latency 2, actually adjust by be to 4\n+(define_insn_reservation \"cell-branch\" 1\n+  (and (eq_attr \"type\" \"branch\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"bru_cell+slot1\")\n+\n+(define_insn_reservation \"cell-branchreg\" 1\n+  (and (eq_attr \"type\" \"jmpreg\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"bru_cell+slot1\")\n+\n+;; cr hazard\n+;; page 90, special cases for CR hazard, only one instr can access cr per cycle\n+;; if insn reads CR following a stwcx, pipeline stall till stwcx finish\n+(define_insn_reservation \"cell-crlogical\" 1\n+  (and (eq_attr \"type\" \"cr_logical,delayed_cr\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"bru_cell+slot01\")\n+\n+;; mfcrf and mfcr is about 34 cycles and nonpipelined\n+(define_insn_reservation \"cell-mfcr\" 34\n+  (and (eq_attr \"type\" \"mfcrf,mfcr\")\n+       (eq_attr \"cpu\" \"cell\"))\n+   \"slot1,nonpipeline,nonpipeline*32\")\n+\n+;; mtcrf (1 field)\n+(define_insn_reservation \"cell-mtcrf\" 1\n+  (and (eq_attr \"type\" \"mtcr\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"fxu_cell+slot01\")\n+\n+; Basic FP latency is 10 cycles, thoughput is 1/cycle\n+(define_insn_reservation \"cell-fp\" 10\n+  (and (eq_attr \"type\" \"fp,dmul\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu1_cell,vsu1_cell*8\")\n+\n+(define_insn_reservation \"cell-fpcompare\" 1\n+  (and (eq_attr \"type\" \"fpcompare\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"vsu1_cell+slot01\")\n+\n+;; sdiv thoughput 1/74, not pipelined but only in the FPU\n+(define_insn_reservation \"cell-sdiv\" 74\n+  (and (eq_attr \"type\" \"sdiv,ddiv\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*72\")\n+\n+;; fsqrt thoughput 1/84, not pipelined but only in the FPU\n+(define_insn_reservation \"cell-sqrt\" 84\n+  (and (eq_attr \"type\" \"ssqrt,dsqrt\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot1,nonpipeline,nonpipeline*82\")\n+\n+; VMX\n+(define_insn_reservation \"cell-vecsimple\" 4\n+  (and (eq_attr \"type\" \"vecsimple\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu1_cell,vsu1_cell*2\")\n+\n+;; mult, div, madd\n+(define_insn_reservation \"cell-veccomplex\" 10\n+  (and (eq_attr \"type\" \"veccomplex\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu1_cell,vsu1_cell*8\")\n+\n+;; TODO: add support for recording instructions\n+(define_insn_reservation \"cell-veccmp\" 4\n+  (and (eq_attr \"type\" \"veccmp\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu1_cell,vsu1_cell*2\")\n+\n+(define_insn_reservation \"cell-vecfloat\" 12\n+  (and (eq_attr \"type\" \"vecfloat\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu1_cell,vsu1_cell*10\")\n+\n+(define_insn_reservation \"cell-vecperm\" 4\n+  (and (eq_attr \"type\" \"vecperm\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,vsu2_cell,vsu2_cell*2\")\n+\n+;; New for 4.2, syncs\n+\n+(define_insn_reservation \"cell-sync\" 11\n+  (and (eq_attr \"type\" \"sync\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,lsu_cell,lsu_cell*9\")\n+\n+(define_insn_reservation \"cell-isync\" 11\n+  (and (eq_attr \"type\" \"isync\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,lsu_cell,lsu_cell*9\")\n+\n+(define_insn_reservation \"cell-load_l\" 11\n+  (and (eq_attr \"type\" \"load_l\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,lsu_cell,lsu_cell*9\")\n+\n+(define_insn_reservation \"cell-store_c\" 11\n+  (and (eq_attr \"type\" \"store_c\")\n+       (eq_attr \"cpu\" \"cell\"))\n+  \"slot01,lsu_cell,lsu_cell*9\")\n+\n+;; RAW register dependency\n+\n+;; addi r3, r3, 1\n+;; lw r4,offset(r3)\n+;; there are 5 cycle deplay for r3 bypassing\n+;; there are 5 cycle delay for a dependent load after a load\n+(define_bypass 5 \"cell-integer\" \"cell-load\")\n+(define_bypass 5 \"cell-integer\" \"cell-load-ext\")\n+(define_bypass 5 \"cell-load,cell-load-ext\" \"cell-load,cell-load-ext\")\n+\n+;; there is a 6 cycle delay after a fp compare until you can use the cr.\n+(define_bypass 6 \"cell-fpcompare\" \"cell-branch,cell-branchreg,cell-mfcr,cell-crlogical\")\n+\n+;; VXU float RAW\n+(define_bypass 11 \"cell-vecfloat\" \"cell-vecfloat\")\n+\n+;; VXU and FPU\n+(define_bypass 6 \"cell-veccomplex\" \"cell-vecsimple\")\n+;;(define_bypass 6 \"cell-veccompare\" \"cell-branch,cell-branchreg\")\n+(define_bypass 3 \"cell-vecfloat\" \"cell-veccomplex\")\n+; this is not correct, \n+;;  this is a stall in general and not dependent on result\n+(define_bypass 13 \"cell-vecstore\" \"cell-fpstore\")\n+; this is not correct, this can never be true, not depent on result\n+(define_bypass 7 \"cell-fp\" \"cell-fpload\")\n+;; vsu1 should avoid writing to the same target register as vsu2 insn\n+;;   within 12 cycles. \n+\n+;; WAW hazard\n+\n+;; the target of VSU estimate should not be reused within 10 dispatch groups\n+;; the target of VSU float should not be reused within 8 dispatch groups\n+;; the target of VSU complex should not be reused within 5 dispatch groups\n+;; FP LOAD should not reuse an FPU Arithmetic target with 6 dispatch gropus\n+\n+;; mtctr-bcctr/bcctrl, branch target ctr register shadow update at\n+;;  ex4 stage(10 cycles)\n+(define_bypass 10 \"cell-mtjmpr\" \"cell-branchreg\")\n+\n+;;Things are not simulated:\n+;; update instruction, update address gpr are not simulated\n+;; vrefp, vrsqrtefp have latency(14), currently simluated as 12 cycle float\n+;;  insns\n+"}, {"sha": "dc80f9ff3da78c24e26083529c11e8fc4a21e10e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 125, "deletions": 6, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "patch": "@@ -139,6 +139,8 @@ struct rs6000_cpu_select rs6000_select[3] =\n   { (const char *)0,\t\"-mtune=\",\t\t1,\t0 },\n };\n \n+static GTY(()) bool rs6000_cell_dont_microcode;\n+\n /* Always emit branch hint bits.  */\n static GTY(()) bool rs6000_always_hint;\n \n@@ -519,6 +521,22 @@ struct processor_costs ppc630_cost = {\n   COSTS_N_INSNS (21),   /* ddiv */\n };\n \n+/* Instruction costs on Cell processor.  */\n+/* COSTS_N_INSNS (1) ~ one add.  */\n+static const\n+struct processor_costs ppccell_cost = {\n+  COSTS_N_INSNS (9/2)+2,    /* mulsi */\n+  COSTS_N_INSNS (6/2),    /* mulsi_const */\n+  COSTS_N_INSNS (6/2),    /* mulsi_const9 */\n+  COSTS_N_INSNS (15/2)+2,   /* muldi */\n+  COSTS_N_INSNS (38/2),   /* divsi */\n+  COSTS_N_INSNS (70/2),   /* divdi */\n+  COSTS_N_INSNS (10/2),   /* fp */\n+  COSTS_N_INSNS (10/2),   /* dmul */\n+  COSTS_N_INSNS (74/2),   /* sdiv */\n+  COSTS_N_INSNS (74/2),   /* ddiv */\n+};\n+\n /* Instruction costs on PPC750 and PPC7400 processors.  */\n static const\n struct processor_costs ppc750_cost = {\n@@ -671,6 +689,7 @@ static bool rs6000_rtx_costs (rtx, int, int, int *);\n static int rs6000_adjust_cost (rtx, rtx, rtx, int);\n static void rs6000_sched_init (FILE *, int, int);\n static bool is_microcoded_insn (rtx);\n+static bool is_nonpipeline_insn (rtx);\n static bool is_cracked_insn (rtx);\n static bool is_branch_slot_insn (rtx);\n static bool is_load_insn (rtx);\n@@ -692,6 +711,7 @@ static void rs6000_sched_finish (FILE *, int);\n static int rs6000_sched_reorder (FILE *, int, rtx *, int *, int);\n static int rs6000_sched_reorder2 (FILE *, int, rtx *, int *, int);\n static int rs6000_use_sched_lookahead (void);\n+static int rs6000_use_sched_lookahead_guard (rtx);\n static tree rs6000_builtin_mask_for_load (void);\n static tree rs6000_builtin_mul_widen_even (tree);\n static tree rs6000_builtin_mul_widen_odd (tree);\n@@ -952,6 +972,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD rs6000_use_sched_lookahead\n \n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD rs6000_use_sched_lookahead_guard\n+\n #undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD rs6000_builtin_mask_for_load\n #undef TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN\n@@ -1217,6 +1240,8 @@ rs6000_override_options (const char *default_cpu)\n \t {\"860\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"970\", PROCESSOR_POWER4,\n \t  POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n+\t {\"cell\", PROCESSOR_CELL,\n+\t  POWERPC_7400_MASK  | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n \t {\"common\", PROCESSOR_COMMON, MASK_NEW_MNEMONICS},\n \t {\"ec603e\", PROCESSOR_PPC603, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"G3\", PROCESSOR_PPC750, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n@@ -1445,7 +1470,8 @@ rs6000_override_options (const char *default_cpu)\n \n   rs6000_always_hint = (rs6000_cpu != PROCESSOR_POWER4\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER5\n-                        && rs6000_cpu != PROCESSOR_POWER6);\n+                        && rs6000_cpu != PROCESSOR_POWER6\n+\t\t\t&& rs6000_cpu != PROCESSOR_CELL);\n   rs6000_sched_groups = (rs6000_cpu == PROCESSOR_POWER4\n \t\t\t || rs6000_cpu == PROCESSOR_POWER5);\n   rs6000_align_branch_targets = (rs6000_cpu == PROCESSOR_POWER4\n@@ -1519,6 +1545,16 @@ rs6000_override_options (const char *default_cpu)\n   /* Set branch target alignment, if not optimizing for size.  */\n   if (!optimize_size)\n     {\n+      /* Cell wants to be aligned 8byte for dual issue. */\n+      if (rs6000_cpu == PROCESSOR_CELL)\n+\t{\n+\t  if (align_functions <= 0)\n+\t    align_functions = 8;\n+\t  if (align_jumps <= 0)\n+\t    align_jumps = 8;\n+\t  if (align_loops <= 0)\n+\t    align_loops = 8;\n+ \t}\n       if (rs6000_align_branch_targets)\n \t{\n \t  if (align_functions <= 0)\n@@ -1600,6 +1636,10 @@ rs6000_override_options (const char *default_cpu)\n \trs6000_cost = &ppc630_cost;\n \tbreak;\n \n+      case PROCESSOR_CELL: \n+\trs6000_cost = &ppccell_cost;\n+\tbreak;\n+\n       case PROCESSOR_PPC750:\n       case PROCESSOR_PPC7400:\n \trs6000_cost = &ppc750_cost;\n@@ -14940,7 +14980,7 @@ rs6000_emit_epilogue (int sibcall)\n   rs6000_stack_t *info;\n   int restoring_FPRs_inline;\n   int using_load_multiple;\n-  int using_mfcr_multiple;\n+  int using_mtcr_multiple;\n   int use_backchain_to_restore_sp;\n   int sp_offset = 0;\n   rtx sp_reg_rtx = gen_rtx_REG (Pmode, 1);\n@@ -14969,7 +15009,7 @@ rs6000_emit_epilogue (int sibcall)\n   use_backchain_to_restore_sp = (frame_pointer_needed\n \t\t\t\t || current_function_calls_alloca\n \t\t\t\t || info->total_size > 32767);\n-  using_mfcr_multiple = (rs6000_cpu == PROCESSOR_PPC601\n+  using_mtcr_multiple = (rs6000_cpu == PROCESSOR_PPC601\n \t\t\t || rs6000_cpu == PROCESSOR_PPC603\n \t\t\t || rs6000_cpu == PROCESSOR_PPC750\n \t\t\t || optimize_size);\n@@ -15269,15 +15309,15 @@ rs6000_emit_epilogue (int sibcall)\n       rtx r12_rtx = gen_rtx_REG (SImode, 12);\n       int count = 0;\n \n-      if (using_mfcr_multiple)\n+      if (using_mtcr_multiple)\n \t{\n \t  for (i = 0; i < 8; i++)\n \t    if (regs_ever_live[CR0_REGNO+i] && ! call_used_regs[CR0_REGNO+i])\n \t      count++;\n \t  gcc_assert (count);\n \t}\n \n-      if (using_mfcr_multiple && count > 1)\n+      if (using_mtcr_multiple && count > 1)\n \t{\n \t  rtvec p;\n \t  int ndx;\n@@ -16595,6 +16635,10 @@ rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED,\n       return cached_can_issue_more;\n     }\n \n+  /* If no reservation, but reach here */\n+  if (recog_memoized (insn) < 0)\n+    return more;\n+\n   if (rs6000_sched_groups)\n     {\n       if (is_microcoded_insn (insn))\n@@ -16607,6 +16651,9 @@ rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED,\n       return cached_can_issue_more;\n     }\n \n+  if (rs6000_cpu_attr == CPU_CELL && is_nonpipeline_insn (insn))\n+    return 0;\n+\n   cached_can_issue_more = more - 1;\n   return cached_can_issue_more;\n }\n@@ -16662,7 +16709,8 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n                  || rs6000_cpu_attr == CPU_PPC7400\n                  || rs6000_cpu_attr == CPU_PPC7450\n                  || rs6000_cpu_attr == CPU_POWER4\n-                 || rs6000_cpu_attr == CPU_POWER5)\n+                 || rs6000_cpu_attr == CPU_POWER5\n+                 || rs6000_cpu_attr == CPU_CELL)\n                 && recog_memoized (dep_insn)\n                 && (INSN_CODE (dep_insn) >= 0))\n               \n@@ -16912,6 +16960,9 @@ is_microcoded_insn (rtx insn)\n       || GET_CODE (PATTERN (insn)) == CLOBBER)\n     return false;\n \n+  if (rs6000_cpu_attr == CPU_CELL)\n+    return get_attr_cell_micro (insn) == CELL_MICRO_ALWAYS;\n+\n   if (rs6000_sched_groups)\n     {\n       enum attr_type type = get_attr_type (insn);\n@@ -17115,6 +17166,37 @@ rs6000_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n   return priority;\n }\n \n+/* Return true if the instruction is nonpipelined on the Cell. */\n+static bool\n+is_nonpipeline_insn (rtx insn)\n+{\n+  enum attr_type type;\n+  if (!insn || !INSN_P (insn)\n+      || GET_CODE (PATTERN (insn)) == USE\n+      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+    return false;\n+\n+  type = get_attr_type (insn);\n+  if (type == TYPE_IMUL\n+      || type == TYPE_IMUL2\n+      || type == TYPE_IMUL3\n+      || type == TYPE_LMUL\n+      || type == TYPE_IDIV\n+      || type == TYPE_LDIV\n+      || type == TYPE_SDIV\n+      || type == TYPE_DDIV\n+      || type == TYPE_SSQRT\n+      || type == TYPE_DSQRT\n+      || type == TYPE_MFCR\n+      || type == TYPE_MFCRF\n+      || type == TYPE_MFJMPR)\n+    {\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n /* Return how many instructions the machine can issue per cycle.  */\n \n static int\n@@ -17135,6 +17217,7 @@ rs6000_issue_rate (void)\n   case CPU_PPC750:\n   case CPU_PPC7400:\n   case CPU_PPC8540:\n+  case CPU_CELL:\n     return 2;\n   case CPU_RIOS2:\n   case CPU_PPC604:\n@@ -17159,9 +17242,29 @@ rs6000_use_sched_lookahead (void)\n {\n   if (rs6000_cpu_attr == CPU_PPC8540)\n     return 4;\n+  if (rs6000_cpu_attr == CPU_CELL)\n+    return (reload_completed ? 8 : 0);\n   return 0;\n }\n \n+/* We are choosing insn from the ready queue.  Return nonzero if INSN can be chosen.  */\n+static int\n+rs6000_use_sched_lookahead_guard (rtx insn)\n+{\n+  if (rs6000_cpu_attr != CPU_CELL)\n+    return 1;\n+\n+   if (insn == NULL_RTX || !INSN_P (insn))\n+     abort ();\n+   \n+  if (!reload_completed\n+      || is_nonpipeline_insn (insn)\n+      || is_microcoded_insn (insn))\n+    return 0;\n+\n+  return 1;\n+}\n+\n /* Determine is PAT refers to memory.  */\n \n static bool\n@@ -17337,9 +17440,25 @@ rs6000_sched_reorder (FILE *dump ATTRIBUTE_UNUSED, int sched_verbose,\n                         int *pn_ready ATTRIBUTE_UNUSED,\n \t\t        int clock_var ATTRIBUTE_UNUSED)\n {\n+  int n_ready = *pn_ready;\n+\n   if (sched_verbose)\n     fprintf (dump, \"// rs6000_sched_reorder :\\n\");\n \n+  /* Reorder the ready list, if the second to last ready insn\n+     is a nonepipeline insn.  */\n+  if (rs6000_cpu_attr == CPU_CELL && n_ready > 1)\n+  {\n+    if (is_nonpipeline_insn (ready[n_ready - 1])\n+        && (recog_memoized (ready[n_ready - 2]) > 0))\n+      /* Simply swap first two insns.  */\n+      {\n+\trtx tmp = ready[n_ready - 1];\n+\tready[n_ready - 1] = ready[n_ready - 2];\n+\tready[n_ready - 2] = tmp;\n+      }\n+  }\n+\n   if (rs6000_cpu == PROCESSOR_POWER6)\n     load_store_pendulum = 0;\n "}, {"sha": "6ccc3c01ad4ee0b153b9551c46100e2bc064827c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "patch": "@@ -68,6 +68,7 @@\n   %{mno-power: %{!mpowerpc*: -mcom}} \\\n   %{!mno-power: %{!mpower*: %(asm_default)}}} \\\n %{mcpu=common: -mcom} \\\n+%{mcpu=cell: -mcell} \\\n %{mcpu=power: -mpwr} \\\n %{mcpu=power2: -mpwrx} \\\n %{mcpu=power3: -mppc64} \\\n@@ -222,7 +223,8 @@ enum processor_type\n    PROCESSOR_PPC8540,\n    PROCESSOR_POWER4,\n    PROCESSOR_POWER5,\n-   PROCESSOR_POWER6\n+   PROCESSOR_POWER6,\n+   PROCESSOR_CELL\n };\n \n extern enum processor_type rs6000_cpu;"}, {"sha": "f40e78dfafa219dd88684a00268bc6dec6a4090c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d296e02ef82ad43e90316bb15c4b97b9b3158bb5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d296e02ef82ad43e90316bb15c4b97b9b3158bb5", "patch": "@@ -106,9 +106,26 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,rs64a,mpccore,ppc403,ppc405,ppc440,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,power4,power5,power6\"\n+(define_attr \"cpu\" \"rios1,rios2,rs64a,mpccore,ppc403,ppc405,ppc440,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,power4,power5,power6,cell\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n+\n+;; If this instruction is microcoded on the CELL processor\n+; The default for load and stores is conditional\n+; The default for load extended and the recorded instructions is always microcoded\n+(define_attr \"cell_micro\" \"not,conditional,always\"\n+  (if_then_else (ior (ior (eq_attr \"type\" \"load\")\n+                          (eq_attr \"type\" \"store\"))\n+                     (ior (eq_attr \"type\" \"fpload\")\n+                          (eq_attr \"type\" \"fpstore\")))\n+\t        (const_string \"conditional\")\n+                (if_then_else (ior (eq_attr \"type\" \"load_ext\")\n+\t\t\t\t   (ior (eq_attr \"type\" \"compare\")\n+\t\t\t\t        (eq_attr \"type\" \"delayed_compare\")))\n+\t\t\t      (const_string \"always\")\n+                              (const_string \"not\"))))\n+\n+\n (automata_option \"ndfa\")\n \n (include \"rios1.md\")\n@@ -125,6 +142,7 @@\n (include \"power4.md\")\n (include \"power5.md\")\n (include \"power6.md\")\n+(include \"cell.md\")\n \n (include \"predicates.md\")\n (include \"constraints.md\")"}]}