{"sha": "2c08497af02c674b5f87b988b55f8a79d2e77195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMwODQ5N2FmMDJjNjc0YjVmODdiOTg4YjU1ZjhhNzlkMmU3NzE5NQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-08-09T07:59:12Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-08-09T07:59:12Z"}, "message": "tree-dfa.c (renumber_gimple_stmt_uids_in_blocks): New function.\n\n\t* tree-dfa.c (renumber_gimple_stmt_uids_in_blocks): New function.\n\t* tree-flow.h (renumber_gimple_stmt_uids_in_blocks): Declare it.\n\t* tree-ssa-loop-ivopts.c (comp_cost): Make COST an integer.\n\t(enum iv_position): Add IP_AFTER_USE and IP_BEFORE_USE.\n\t(dump_cand): Handle them.\n\t(struct iv_cand): New members COST_STEP and AINC_USE.\n\t(stmt_after_increment): Likewise.\n\t(stmt_after_inc_pos): Renamed from stmt_after_ip_original_pos.  All\n\tcallers changed.  Use gimple_uid comparison instead of scanning.\n\t(add_candidate_1): When looking for identical candidates, take\n\tAINC_USE into account.  Set it for new candidates.\n\t(force_expr_to_var_cost): Cast target_spill_cost to int.\n\t(get_address_cost): New arguments STMT_AFTER_INC and MAY_AUTOINC.\n\tAll callers changed.  Check for availability of autoinc addressing\n\tmodes, both in general for a given mode, and in the specific use\n\tcase.\n\t(get_computation_cost_at): New argument CAN_AUTOINC.  All callers\n\tchanged.\n\t(get_computation_cost): Likewise.\n\t(autoinc_possible_for_pair, set_autoinc_for_original_candidates,\n\tadd_autoinc_candidates): New static functions.\n\t(add_candidate): Call add_autoinc_candidates for candidates based on\n\ta USE_ADDRESS use.\n\t(find_iv_candidates): Call set_autoinc_for_original_candidates.\n\t(determine_use_iv_cost_address): If we have an autoinc candidate at\n\tthe matching use, verify autoinc is possible and subtract the cost\n\tof the candidate's step from the cost.\n\t(determine_iv_cost): Record the cost of the increment in the COST_STEP\n\tmember of the candidate.\n\t(tree_ssa_iv_optimize_loop): Swap the calls to determine_iv_costs and\n\tdetermine_use_iv_costs.  Call renumber_gimple_stmt_uids_in_blocks.\n\ntestsuite/\n\t* gcc.target/bfin/loop-autoinc.c: New file.\n\nFrom-SVN: r150588", "tree": {"sha": "737dab8544b1f38d0663f7d5b6a29b3494bcec67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/737dab8544b1f38d0663f7d5b6a29b3494bcec67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c08497af02c674b5f87b988b55f8a79d2e77195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c08497af02c674b5f87b988b55f8a79d2e77195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c08497af02c674b5f87b988b55f8a79d2e77195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c08497af02c674b5f87b988b55f8a79d2e77195/comments", "author": null, "committer": null, "parents": [{"sha": "a9a25daa5cbb49676f5adc25360a76d63848912e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9a25daa5cbb49676f5adc25360a76d63848912e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9a25daa5cbb49676f5adc25360a76d63848912e"}], "stats": {"total": 404, "additions": 349, "deletions": 55}, "files": [{"sha": "be426c4c04b962cc0413322dbaffb494f9874126", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c08497af02c674b5f87b988b55f8a79d2e77195", "patch": "@@ -1,3 +1,37 @@\n+2009-08-09  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* tree-dfa.c (renumber_gimple_stmt_uids_in_blocks): New function.\n+\t* tree-flow.h (renumber_gimple_stmt_uids_in_blocks): Declare it.\n+\t* tree-ssa-loop-ivopts.c (comp_cost): Make COST an integer.\n+\t(enum iv_position): Add IP_AFTER_USE and IP_BEFORE_USE.\n+\t(dump_cand): Handle them.\n+\t(struct iv_cand): New members COST_STEP and AINC_USE.\n+\t(stmt_after_increment): Likewise.\n+\t(stmt_after_inc_pos): Renamed from stmt_after_ip_original_pos.  All\n+\tcallers changed.  Use gimple_uid comparison instead of scanning.\n+\t(add_candidate_1): When looking for identical candidates, take\n+\tAINC_USE into account.  Set it for new candidates.\n+\t(force_expr_to_var_cost): Cast target_spill_cost to int.\n+\t(get_address_cost): New arguments STMT_AFTER_INC and MAY_AUTOINC.\n+\tAll callers changed.  Check for availability of autoinc addressing\n+\tmodes, both in general for a given mode, and in the specific use\n+\tcase.\n+\t(get_computation_cost_at): New argument CAN_AUTOINC.  All callers\n+\tchanged.\n+\t(get_computation_cost): Likewise.\n+\t(autoinc_possible_for_pair, set_autoinc_for_original_candidates,\n+\tadd_autoinc_candidates): New static functions.\n+\t(add_candidate): Call add_autoinc_candidates for candidates based on\n+\ta USE_ADDRESS use.\n+\t(find_iv_candidates): Call set_autoinc_for_original_candidates.\n+\t(determine_use_iv_cost_address): If we have an autoinc candidate at\n+\tthe matching use, verify autoinc is possible and subtract the cost\n+\tof the candidate's step from the cost.\n+\t(determine_iv_cost): Record the cost of the increment in the COST_STEP\n+\tmember of the candidate.\n+\t(tree_ssa_iv_optimize_loop): Swap the calls to determine_iv_costs and\n+\tdetermine_use_iv_costs.  Call renumber_gimple_stmt_uids_in_blocks.\n+\n 2009-08-09  Douglas B Rupp  <rupp@gnat.com>\n \n \t* config.build (ia64-hp-*vms*): New target."}, {"sha": "06192702e681554655e6b3c95375868340ce772c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c08497af02c674b5f87b988b55f8a79d2e77195", "patch": "@@ -1,3 +1,7 @@\n+2009-08-09  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* gcc.target/bfin/loop-autoinc.c: New file.\n+\n 2009-08-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/40991"}, {"sha": "3dc7182982c8468f5bea4cace59a6e046e06ccd7", "filename": "gcc/testsuite/gcc.target/bfin/loop-autoinc.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Floop-autoinc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Floop-autoinc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbfin%2Floop-autoinc.c?ref=2c08497af02c674b5f87b988b55f8a79d2e77195", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \" = \\\\\\[\\[PI\\].\\\\+\\\\+\\\\\\];\" } } */\n+extern int x[];\n+extern void bar();\n+int foo ()\n+{\n+  int i;\n+  int sum = 0;\n+  for (i = 0; i < 100; i++) {\n+    sum += x[i];\n+    if (sum & 1)\n+      sum *= sum;\n+  }\n+  return sum;\n+}"}, {"sha": "4147a2866690f136efb491668d03cefa125e0bc6", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=2c08497af02c674b5f87b988b55f8a79d2e77195", "patch": "@@ -157,6 +157,32 @@ renumber_gimple_stmt_uids (void)\n     }\n }\n \n+/* Like renumber_gimple_stmt_uids, but only do work on the basic blocks\n+   in BLOCKS, of which there are N_BLOCKS.  Also renumbers PHIs.  */\n+\n+void \n+renumber_gimple_stmt_uids_in_blocks (basic_block *blocks, int n_blocks)\n+{\n+  int i;\n+\n+  set_gimple_stmt_max_uid (cfun, 0);\n+  for (i = 0; i < n_blocks; i++)\n+    {\n+      basic_block bb = blocks[i];\n+      gimple_stmt_iterator bsi;\n+      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t}\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (bsi);\n+\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t}\n+    }\n+}\n+\n /* Create a new annotation for a tree T.  */\n \n tree_ann_common_t"}, {"sha": "1d2e69a4d1ac3f49a513c65e04d7e9d22c1f66a7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=2c08497af02c674b5f87b988b55f8a79d2e77195", "patch": "@@ -554,6 +554,7 @@ extern const char *op_symbol_code (enum tree_code);\n /* In tree-dfa.c  */\n extern var_ann_t create_var_ann (tree);\n extern void renumber_gimple_stmt_uids (void);\n+extern void renumber_gimple_stmt_uids_in_blocks (basic_block *, int);\n extern tree_ann_common_t create_tree_common_ann (tree);\n extern void dump_dfa_stats (FILE *);\n extern void debug_dfa_stats (void);"}, {"sha": "71d4e17064d43e64c5d9450d3bdfdef90aec6a7a", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 268, "deletions": 55, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c08497af02c674b5f87b988b55f8a79d2e77195/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=2c08497af02c674b5f87b988b55f8a79d2e77195", "patch": "@@ -135,7 +135,7 @@ enum use_type\n /* Cost of a computation.  */\n typedef struct\n {\n-  unsigned cost;\t/* The runtime cost.  */\n+  int cost;\t\t/* The runtime cost.  */\n   unsigned complexity;\t/* The estimate of the complexity of the code for\n \t\t\t   the computation (in no concrete units --\n \t\t\t   complexity field should be larger for more\n@@ -181,6 +181,8 @@ enum iv_position\n {\n   IP_NORMAL,\t\t/* At the end, just before the exit condition.  */\n   IP_END,\t\t/* At the end of the latch block.  */\n+  IP_BEFORE_USE,\t/* Immediately before a specific use.  */\n+  IP_AFTER_USE,\t\t/* Immediately after a specific use.  */\n   IP_ORIGINAL\t\t/* The original biv.  */\n };\n \n@@ -200,6 +202,9 @@ struct iv_cand\n \t\t\t   to replace the final value of an iv by direct\n \t\t\t   computation of the value.  */\n   unsigned cost;\t/* Cost of the candidate.  */\n+  unsigned cost_step;\t/* Cost of the candidate's increment operation.  */\n+  struct iv_use *ainc_use; /* For IP_{BEFORE,AFTER}_USE candidates, the place\n+\t\t\t      where it is incremented.  */\n   bitmap depends_on;\t/* The list of invariants that are used in step of the\n \t\t\t   biv.  */\n };\n@@ -515,6 +520,14 @@ dump_cand (FILE *file, struct iv_cand *cand)\n       fprintf (file, \"  incremented before exit test\\n\");\n       break;\n \n+    case IP_BEFORE_USE:\n+      fprintf (file, \"  incremented before use %d\\n\", cand->ainc_use->id);\n+      break;\n+\n+    case IP_AFTER_USE:\n+      fprintf (file, \"  incremented after use %d\\n\", cand->ainc_use->id);\n+      break;\n+\n     case IP_END:\n       fprintf (file, \"  incremented at end\\n\");\n       break;\n@@ -563,30 +576,25 @@ stmt_after_ip_normal_pos (struct loop *loop, gimple stmt)\n }\n \n /* Returns true if STMT if after the place where the original induction\n-   variable CAND is incremented.  */\n+   variable CAND is incremented.  If TRUE_IF_EQUAL is set, we return true\n+   if the positions are identical.  */\n \n static bool\n-stmt_after_ip_original_pos (struct iv_cand *cand, gimple stmt)\n+stmt_after_inc_pos (struct iv_cand *cand, gimple stmt, bool true_if_equal)\n {\n   basic_block cand_bb = gimple_bb (cand->incremented_at);\n   basic_block stmt_bb = gimple_bb (stmt);\n-  gimple_stmt_iterator bsi;\n \n   if (!dominated_by_p (CDI_DOMINATORS, stmt_bb, cand_bb))\n     return false;\n \n   if (stmt_bb != cand_bb)\n     return true;\n \n-  /* Scan the block from the end, since the original ivs are usually\n-     incremented at the end of the loop body.  */\n-  for (bsi = gsi_last_bb (stmt_bb); ; gsi_prev (&bsi))\n-    {\n-      if (gsi_stmt (bsi) == cand->incremented_at)\n-\treturn false;\n-      if (gsi_stmt (bsi) == stmt)\n-\treturn true;\n-    }\n+  if (true_if_equal\n+      && gimple_uid (stmt) == gimple_uid (cand->incremented_at))\n+    return true;\n+  return gimple_uid (stmt) > gimple_uid (cand->incremented_at);\n }\n \n /* Returns true if STMT if after the place where the induction variable\n@@ -604,7 +612,11 @@ stmt_after_increment (struct loop *loop, struct iv_cand *cand, gimple stmt)\n       return stmt_after_ip_normal_pos (loop, stmt);\n \n     case IP_ORIGINAL:\n-      return stmt_after_ip_original_pos (cand, stmt);\n+    case IP_AFTER_USE:\n+      return stmt_after_inc_pos (cand, stmt, false);\n+\n+    case IP_BEFORE_USE:\n+      return stmt_after_inc_pos (cand, stmt, true);\n \n     default:\n       gcc_unreachable ();\n@@ -2103,7 +2115,9 @@ add_candidate_1 (struct ivopts_data *data,\n       if (cand->pos != pos)\n \tcontinue;\n \n-      if (cand->incremented_at != incremented_at)\n+      if (cand->incremented_at != incremented_at\n+\t  || ((pos == IP_AFTER_USE || pos == IP_BEFORE_USE)\n+\t      && cand->ainc_use != use))\n \tcontinue;\n \n       if (!cand->iv)\n@@ -2149,6 +2163,11 @@ add_candidate_1 (struct ivopts_data *data,\n \t  walk_tree (&step, find_depends, &cand->depends_on, NULL);\n \t}\n \n+      if (pos == IP_AFTER_USE || pos == IP_BEFORE_USE)\n+\tcand->ainc_use = use;\n+      else\n+\tcand->ainc_use = NULL;\n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tdump_cand (dump_file, cand);\n     }\n@@ -2192,6 +2211,56 @@ allow_ip_end_pos_p (struct loop *loop)\n   return false;\n }\n \n+/* If possible, adds autoincrement candidates BASE + STEP * i based on use USE.\n+   Important field is set to IMPORTANT.  */\n+\n+static void\n+add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n+\t\t\tbool important, struct iv_use *use)\n+{\n+  basic_block use_bb = gimple_bb (use->stmt);\n+  enum machine_mode mem_mode;\n+  unsigned HOST_WIDE_INT cstepi;\n+\n+  /* If we insert the increment in any position other than the standard\n+     ones, we must ensure that it is incremented once per iteration.\n+     It must not be in an inner nested loop, or one side of an if\n+     statement.  */\n+  if (use_bb->loop_father != data->current_loop\n+      || !dominated_by_p (CDI_DOMINATORS, data->current_loop->latch, use_bb)\n+      || stmt_could_throw_p (use->stmt)\n+      || !cst_and_fits_in_hwi (step))\n+    return;\n+\n+  cstepi = int_cst_value (step);\n+\n+  mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+  if ((HAVE_PRE_INCREMENT && GET_MODE_SIZE (mem_mode) == cstepi)\n+      || (HAVE_PRE_DECREMENT && GET_MODE_SIZE (mem_mode) == -cstepi))\n+    {\n+      enum tree_code code = MINUS_EXPR;\n+      tree new_base;\n+      tree new_step = step;\n+\n+      if (POINTER_TYPE_P (TREE_TYPE (base)))\n+\t{\n+\t  new_step = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);\n+\t  code = POINTER_PLUS_EXPR;\n+\t}\n+      else\n+\tnew_step = fold_convert (TREE_TYPE (base), new_step);\n+      new_base = fold_build2 (code, TREE_TYPE (base), base, new_step);\n+      add_candidate_1 (data, new_base, step, important, IP_BEFORE_USE, use,\n+\t\t       use->stmt);\n+    }\n+  if ((HAVE_POST_INCREMENT && GET_MODE_SIZE (mem_mode) == cstepi)\n+      || (HAVE_POST_DECREMENT && GET_MODE_SIZE (mem_mode) == -cstepi))\n+    {\n+      add_candidate_1 (data, base, step, important, IP_AFTER_USE, use,\n+\t\t       use->stmt);\n+    }\n+}\n+\n /* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and\n    position to POS.  If USE is not NULL, the candidate is set as related to\n    it.  The candidate computation is scheduled on all available positions.  */\n@@ -2205,6 +2274,9 @@ add_candidate (struct ivopts_data *data,\n   if (ip_end_pos (data->current_loop)\n       && allow_ip_end_pos_p (data->current_loop))\n     add_candidate_1 (data, base, step, important, IP_END, use, NULL);\n+\n+  if (use != NULL && use->type == USE_ADDRESS)\n+    add_autoinc_candidates (data, base, step, important, use);\n }\n \n /* Add a standard \"0 + 1 * iteration\" iv candidate for a\n@@ -2378,24 +2450,6 @@ record_important_candidates (struct ivopts_data *data)\n     }\n }\n \n-/* Finds the candidates for the induction variables.  */\n-\n-static void\n-find_iv_candidates (struct ivopts_data *data)\n-{\n-  /* Add commonly used ivs.  */\n-  add_standard_iv_candidates (data);\n-\n-  /* Add old induction variables.  */\n-  add_old_ivs_candidates (data);\n-\n-  /* Add induction variables derived from uses.  */\n-  add_derived_ivs_candidates (data);\n-\n-  /* Record the important candidates.  */\n-  record_important_candidates (data);\n-}\n-\n /* Allocates the data structure mapping the (use, candidate) pairs to costs.\n    If consider_all_candidates is true, we use a two-dimensional array, otherwise\n    we allocate a simple list to every use.  */\n@@ -2487,7 +2541,7 @@ infinite_cost_p (comp_cost cost)\n \n /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends\n    on invariants DEPENDS_ON and that the value used in expressing it\n-   is VALUE.*/\n+   is VALUE.  */\n \n static void\n set_use_iv_cost (struct ivopts_data *data,\n@@ -3011,21 +3065,30 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n    variable is omitted.  Compute the cost for a memory reference that accesses\n    a memory location of mode MEM_MODE.\n \n+   MAY_AUTOINC is set to true if the autoincrement (increasing index by\n+   size of MEM_MODE / RATIO) is available.  To make this determination, we\n+   look at the size of the increment to be made, which is given in CSTEP.\n+   CSTEP may be zero if the step is unknown.\n+   STMT_AFTER_INC is true iff the statement we're looking at is after the\n+   increment of the original biv.\n+\n    TODO -- there must be some better way.  This all is quite crude.  */\n \n static comp_cost\n get_address_cost (bool symbol_present, bool var_present,\n \t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,\n-\t\t  enum machine_mode mem_mode,\n-\t\t  bool speed)\n+\t\t  HOST_WIDE_INT cstep, enum machine_mode mem_mode, bool speed,\n+\t\t  bool stmt_after_inc, bool *may_autoinc)\n {\n   static bool initialized[MAX_MACHINE_MODE];\n   static HOST_WIDE_INT rat[MAX_MACHINE_MODE], off[MAX_MACHINE_MODE];\n   static HOST_WIDE_INT min_offset[MAX_MACHINE_MODE], max_offset[MAX_MACHINE_MODE];\n   static unsigned costs[MAX_MACHINE_MODE][2][2][2][2];\n+  static bool has_preinc[MAX_MACHINE_MODE], has_postinc[MAX_MACHINE_MODE];\n+  static bool has_predec[MAX_MACHINE_MODE], has_postdec[MAX_MACHINE_MODE];\n   unsigned cost, acost, complexity;\n-  bool offset_p, ratio_p;\n-  HOST_WIDE_INT s_offset;\n+  bool offset_p, ratio_p, autoinc;\n+  HOST_WIDE_INT s_offset, autoinc_offset, msize;\n   unsigned HOST_WIDE_INT mask;\n   unsigned bits;\n \n@@ -3084,6 +3147,26 @@ get_address_cost (bool symbol_present, bool var_present,\n       reg0 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n       reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);\n \n+      if (HAVE_PRE_DECREMENT)\n+\t{\n+\t  addr = gen_rtx_PRE_DEC (Pmode, reg0);\n+\t  has_predec[mem_mode] = memory_address_p (mem_mode, addr);\n+\t}\n+      if (HAVE_POST_DECREMENT)\n+\t{\n+\t  addr = gen_rtx_POST_DEC (Pmode, reg0);\n+\t  has_postdec[mem_mode] = memory_address_p (mem_mode, addr);\n+\t}\n+      if (HAVE_PRE_INCREMENT)\n+\t{\n+\t  addr = gen_rtx_PRE_INC (Pmode, reg0);\n+\t  has_preinc[mem_mode] = memory_address_p (mem_mode, addr);\n+\t}\n+      if (HAVE_POST_INCREMENT)\n+\t{\n+\t  addr = gen_rtx_POST_INC (Pmode, reg0);\n+\t  has_postinc[mem_mode] = memory_address_p (mem_mode, addr);\n+\t}\n       for (i = 0; i < 16; i++)\n \t{\n \t  sym_p = i & 1;\n@@ -3122,7 +3205,7 @@ get_address_cost (bool symbol_present, bool var_present,\n     \n \t  if (base)\n \t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, base);\n-  \n+\n \t  start_sequence ();\n \t  /* To avoid splitting addressing modes, pretend that no cse will\n \t     follow.  */\n@@ -3167,7 +3250,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t  if (acost < costs[mem_mode][1][var_p][off_p][rat_p])\n \t    costs[mem_mode][1][var_p][off_p][rat_p] = acost;\n \t}\n-  \n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Address costs:\\n\");\n@@ -3192,6 +3275,9 @@ get_address_cost (bool symbol_present, bool var_present,\n \t      acost = costs[mem_mode][sym_p][var_p][off_p][rat_p];\n \t      fprintf (dump_file, \"index costs %d\\n\", acost);\n \t    }\n+\t  if (has_predec[mem_mode] || has_postdec[mem_mode]\n+\t      || has_preinc[mem_mode] || has_postinc[mem_mode])\n+\t    fprintf (dump_file, \"  May include autoinc/dec\\n\");\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n@@ -3203,6 +3289,23 @@ get_address_cost (bool symbol_present, bool var_present,\n     offset |= ~mask;\n   s_offset = offset;\n \n+  autoinc = false;\n+  msize = GET_MODE_SIZE (mem_mode);\n+  autoinc_offset = offset;\n+  if (stmt_after_inc)\n+    autoinc_offset += ratio * cstep;\n+  if (symbol_present || var_present || ratio != 1)\n+    autoinc = false;\n+  else if ((has_postinc[mem_mode] && autoinc_offset == 0\n+\t       && msize == cstep)\n+\t   || (has_postdec[mem_mode] && autoinc_offset == 0\n+\t       && msize == -cstep)\n+\t   || (has_preinc[mem_mode] && autoinc_offset == msize\n+\t       && msize == cstep)\n+\t   || (has_predec[mem_mode] && autoinc_offset == -msize\n+\t       && msize == -cstep))\n+    autoinc = true;\n+\n   cost = 0;\n   offset_p = (s_offset != 0\n \t      && min_offset[mem_mode] <= s_offset\n@@ -3216,6 +3319,8 @@ get_address_cost (bool symbol_present, bool var_present,\n   if (s_offset && !offset_p && !symbol_present)\n     cost += add_cost (Pmode, speed);\n \n+  if (may_autoinc)\n+    *may_autoinc = autoinc;\n   acost = costs[mem_mode][symbol_present][var_present][offset_p][ratio_p];\n   complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n   return new_cost (cost + acost, complexity);\n@@ -3368,7 +3473,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n      computations often are either loop invariant or at least can\n      be shared between several iv uses, so letting this grow without\n      limits would not give reasonable results.  */\n-  if (cost.cost > target_spill_cost [speed])\n+  if (cost.cost > (int) target_spill_cost [speed])\n     cost.cost = target_spill_cost [speed];\n \n   return cost;\n@@ -3535,19 +3640,22 @@ difference_cost (struct ivopts_data *data,\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n    to create an address from it, otherwise we want to get it into\n    register.  A set of invariants we depend on is stored in\n-   DEPENDS_ON.  AT is the statement at that the value is computed.  */\n+   DEPENDS_ON.  AT is the statement at that the value is computed.\n+   If CAN_AUTOINC is nonnull, use it to record whether autoinc\n+   addressing is likely.  */\n \n static comp_cost\n get_computation_cost_at (struct ivopts_data *data,\n \t\t\t struct iv_use *use, struct iv_cand *cand,\n-\t\t\t bool address_p, bitmap *depends_on, gimple at)\n+\t\t\t bool address_p, bitmap *depends_on, gimple at,\n+\t\t\t bool *can_autoinc)\n {\n   tree ubase = use->iv->base, ustep = use->iv->step;\n   tree cbase, cstep;\n   tree utype = TREE_TYPE (ubase), ctype;\n   unsigned HOST_WIDE_INT cstepi, offset = 0;\n   HOST_WIDE_INT ratio, aratio;\n-  bool var_present, symbol_present;\n+  bool var_present, symbol_present, stmt_is_after_inc;\n   comp_cost cost;\n   double_int rat;\n   bool speed = optimize_bb_for_speed_p (gimple_bb (at));\n@@ -3656,7 +3764,8 @@ get_computation_cost_at (struct ivopts_data *data,\n \n   /* If we are after the increment, the value of the candidate is higher by\n      one iteration.  */\n-  if (stmt_after_increment (data->current_loop, cand, at))\n+  stmt_is_after_inc = stmt_after_increment (data->current_loop, cand, at);\n+  if (stmt_is_after_inc)\n     offset -= ratio * cstepi;\n \n   /* Now the computation is in shape symbol + var1 + const + ratio * var2.\n@@ -3665,8 +3774,10 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (address_p)\n     return add_costs (cost,\n \t\t      get_address_cost (symbol_present, var_present,\n-\t\t\t\t\toffset, ratio,\n-\t\t\t\t\tTYPE_MODE (TREE_TYPE (utype)), speed));\n+\t\t\t\t\toffset, ratio, cstepi,\n+\t\t\t\t\tTYPE_MODE (TREE_TYPE (utype)),\n+\t\t\t\t\tspeed, stmt_is_after_inc,\n+\t\t\t\t\tcan_autoinc));\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   if (!symbol_present && !var_present && !offset)\n@@ -3694,6 +3805,9 @@ get_computation_cost_at (struct ivopts_data *data,\n     cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype), speed);\n \n fallback:\n+  if (can_autoinc)\n+    *can_autoinc = false;\n+\n   {\n     /* Just get the expression, expand it and measure the cost.  */\n     tree comp = get_computation_at (data->current_loop, use, cand, at);\n@@ -3712,15 +3826,17 @@ get_computation_cost_at (struct ivopts_data *data,\n    from induction variable CAND.  If ADDRESS_P is true, we just need\n    to create an address from it, otherwise we want to get it into\n    register.  A set of invariants we depend on is stored in\n-   DEPENDS_ON.  */\n+   DEPENDS_ON.  If CAN_AUTOINC is nonnull, use it to record whether\n+   autoinc addressing is likely.  */\n \n static comp_cost\n get_computation_cost (struct ivopts_data *data,\n \t\t      struct iv_use *use, struct iv_cand *cand,\n-\t\t      bool address_p, bitmap *depends_on)\n+\t\t      bool address_p, bitmap *depends_on, bool *can_autoinc)\n {\n   return get_computation_cost_at (data,\n-\t\t\t\t  use, cand, address_p, depends_on, use->stmt);\n+\t\t\t\t  use, cand, address_p, depends_on, use->stmt,\n+\t\t\t\t  can_autoinc);\n }\n \n /* Determines cost of basing replacement of USE on CAND in a generic\n@@ -3744,7 +3860,7 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n       return true;\n     }\n \n-  cost = get_computation_cost (data, use, cand, false, &depends_on);\n+  cost = get_computation_cost (data, use, cand, false, &depends_on, NULL);\n   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n   return !infinite_cost_p (cost);\n@@ -3757,8 +3873,20 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n-  comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on);\n+  bool can_autoinc;\n+  comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on,\n+\t\t\t\t\t &can_autoinc);\n \n+  if (cand->ainc_use == use)\n+    {\n+      if (can_autoinc)\n+\tcost.cost -= cand->cost_step;\n+      /* If we generated the candidate solely for exploiting autoincrement\n+\t opportunities, and it turns out it can't be used, set the cost to\n+\t infinity to make sure we ignore it.  */\n+      else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)\n+\tcost = infinite_cost;\n+    }\n   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n   return !infinite_cost_p (cost);\n@@ -3938,7 +4066,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   gcc_assert (ok);\n \n   express_cost = get_computation_cost (data, use, cand, false,\n-\t\t\t\t       &depends_on_express);\n+\t\t\t\t       &depends_on_express, NULL);\n   fd_ivopts_data = data;\n   walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n \n@@ -3990,6 +4118,78 @@ determine_use_iv_cost (struct ivopts_data *data,\n     }\n }\n \n+/* Return true if get_computation_cost indicates that autoincrement is\n+   a possibility for the pair of USE and CAND, false otherwise.  */\n+\n+static bool\n+autoinc_possible_for_pair (struct ivopts_data *data, struct iv_use *use,\n+\t\t\t   struct iv_cand *cand)\n+{\n+  bitmap depends_on;\n+  bool can_autoinc;\n+  comp_cost cost;\n+\n+  if (use->type != USE_ADDRESS)\n+    return false;\n+\n+  cost = get_computation_cost (data, use, cand, true, &depends_on,\n+\t\t\t       &can_autoinc);\n+\n+  BITMAP_FREE (depends_on);\n+\n+  return !infinite_cost_p (cost) && can_autoinc;\n+}\n+\n+/* Examine IP_ORIGINAL candidates to see if they are incremented next to a\n+   use that allows autoincrement, and set their AINC_USE if possible.  */\n+\n+static void\n+set_autoinc_for_original_candidates (struct ivopts_data *data)\n+{\n+  unsigned i, j;\n+\n+  for (i = 0; i < n_iv_cands (data); i++)\n+    {\n+      struct iv_cand *cand = iv_cand (data, i);\n+      struct iv_use *closest = NULL;\n+      if (cand->pos != IP_ORIGINAL)\n+\tcontinue;\n+      for (j = 0; j < n_iv_uses (data); j++)\n+\t{\n+\t  struct iv_use *use = iv_use (data, j);\n+\t  unsigned uid = gimple_uid (use->stmt);\n+\t  if (gimple_bb (use->stmt) != gimple_bb (cand->incremented_at)\n+\t      || uid > gimple_uid (cand->incremented_at))\n+\t    continue;\n+\t  if (closest == NULL || uid > gimple_uid (closest->stmt))\n+\t    closest = use;\n+\t}\n+      if (closest == NULL || !autoinc_possible_for_pair (data, closest, cand))\n+\tcontinue;\n+      cand->ainc_use = closest;\n+    }\n+}\n+\n+/* Finds the candidates for the induction variables.  */\n+\n+static void\n+find_iv_candidates (struct ivopts_data *data)\n+{\n+  /* Add commonly used ivs.  */\n+  add_standard_iv_candidates (data);\n+\n+  /* Add old induction variables.  */\n+  add_old_ivs_candidates (data);\n+\n+  /* Add induction variables derived from uses.  */\n+  add_derived_ivs_candidates (data);\n+\n+  set_autoinc_for_original_candidates (data);\n+\n+  /* Record the important candidates.  */\n+  record_important_candidates (data);\n+}\n+\n /* Determines costs of basing the use of the iv on an iv candidate.  */\n \n static void\n@@ -4105,6 +4305,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n     cost++;\n \n   cand->cost = cost;\n+  cand->cost_step = cost_step;\n }\n \n /* Determines costs of computation of the candidates.  */\n@@ -4129,7 +4330,7 @@ determine_iv_costs (struct ivopts_data *data)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"  %d\\t%d\\n\", i, cand->cost);\n     }\n-  \n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\");\n }\n@@ -5051,6 +5252,13 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)\n       after = true;\n       break;\n \n+    case IP_AFTER_USE:\n+      after = true;\n+      /* fall through */\n+    case IP_BEFORE_USE:\n+      incr_pos = gsi_for_stmt (cand->incremented_at);\n+      break;\n+\n     case IP_ORIGINAL:\n       /* Mark that the iv is preserved.  */\n       name_info (data, cand->var_before)->preserve_biv = true;\n@@ -5512,6 +5720,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   bool changed = false;\n   struct iv_ca *iv_ca;\n   edge exit;\n+  basic_block *body;\n \n   gcc_assert (!data->niters);\n   data->current_loop = loop;\n@@ -5533,6 +5742,10 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  body = get_loop_body (loop);\n+  renumber_gimple_stmt_uids_in_blocks (body, loop->num_nodes);\n+  free (body);\n+\n   /* For each ssa name determines whether it behaves as an induction variable\n      in some loop.  */\n   if (!find_induction_variables (data))\n@@ -5547,8 +5760,8 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   find_iv_candidates (data);\n \n   /* Calculates the costs (item 3, part 1).  */\n-  determine_use_iv_costs (data);\n   determine_iv_costs (data);\n+  determine_use_iv_costs (data);\n   determine_set_costs (data);\n \n   /* Find the optimal set of induction variables (item 3, part 2).  */"}]}