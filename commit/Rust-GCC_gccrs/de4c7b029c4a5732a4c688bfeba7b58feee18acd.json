{"sha": "de4c7b029c4a5732a4c688bfeba7b58feee18acd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0YzdiMDI5YzRhNTczMmE0YzY4OGJmZWJhN2I1OGZlZWUxOGFjZA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-25T17:10:57Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-25T17:10:57Z"}, "message": "java-tree.h (end_params_node): Declare global.\n\n \n\t* java-tree.h (end_params_node):  Declare global.\n\t* decl.c (end_params_node):  New global.\n\t(init_decl_processing, start_java_method):  Use end_params_node for\n\tend of list of parameter types.  Follows correct gcc conventions.\n\t* expr.c (pop_argument_types, pop_arguments):  Likewise.\n\t* lang.c (put_decl_node):  Likewise.\n\t* typeck.c (various places):  Likewise.\n\t* class.y (various places):  Likewise.\n\t* parse.y (various places):  Likewise.\n\t* parse.y (java_complete_tree):  Move CAN_COMPLETE_NORMALLY.\n\t(build_jump_to_finally):  Add missing CAN_COMPLETE_NORMALLY.\n\t* class.c:  Add #include flags.h, remove no-longer needed declaration.\n\t* class.c (layout_class_method):  Remove commented-out code, re-format.\n\tDon't add vtable entry (or index) for private methods.\n\t* expr.c (expand_invoke):  A private method is implicitly final.\n\t* class.c (make_class_data):  If inlining or optimizing,\n\tskip private methods.\n\t* class.c (finish_class):  New function.  Calls existing methods,\n\tbut alls emits deferred inline functions.\n\t* jcf-parse.c (parse_class_file):  Call finish_class.\n\t* parse.y (java_complete_expand_methods):  Likewise.\n\t* expr.c (build_java_binop):  Explicit default, to silence -Wall.\n\nFrom-SVN: r23871", "tree": {"sha": "0b2fe1790380d64ead03f86029625240ca00fbb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b2fe1790380d64ead03f86029625240ca00fbb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de4c7b029c4a5732a4c688bfeba7b58feee18acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4c7b029c4a5732a4c688bfeba7b58feee18acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de4c7b029c4a5732a4c688bfeba7b58feee18acd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de4c7b029c4a5732a4c688bfeba7b58feee18acd/comments", "author": null, "committer": null, "parents": [{"sha": "0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bd2e6dbbf09e94c5c1d0575b2183acea257a518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bd2e6dbbf09e94c5c1d0575b2183acea257a518"}], "stats": {"total": 47, "additions": 22, "deletions": 25}, "files": [{"sha": "6d6c254241280814bece13f1c017190afbfa8a36", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=de4c7b029c4a5732a4c688bfeba7b58feee18acd", "patch": "@@ -249,6 +249,8 @@ extern tree method_type_node;\n extern tree method_ptr_type_node;\n #define nativecode_ptr_type_node ptr_type_node\n \n+extern tree end_params_node;\n+\n /* References to internal libjava functions we use. */\n extern tree alloc_object_node;\n extern tree soft_instanceof_node;"}, {"sha": "75d5775d7d616b29f9ea7304a39c2acd065ab9af", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=de4c7b029c4a5732a4c688bfeba7b58feee18acd", "patch": "@@ -692,9 +692,8 @@ parse_class_file ()\n \n   if (flag_emit_class_files)\n     write_classfile (current_class);\n-  make_class_data (current_class);\n-  register_class ();\n-  rest_of_decl_compilation (TYPE_NAME (current_class), (char*) 0, 1, 0);\n+\n+  finish_class (current_class);\n \n   debug_end_source_file (save_lineno);\n   input_filename = save_input_filename;"}, {"sha": "50a1b67ac4dbad56376b38798bce484d76139622", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=de4c7b029c4a5732a4c688bfeba7b58feee18acd", "patch": "@@ -371,7 +371,7 @@ put_decl_node (node)\n \t  if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE)\n \t    args = TREE_CHAIN (args);\n \t  put_decl_string (\"(\", 1);\n-\t  for ( ; args != NULL_TREE;  args = TREE_CHAIN (args), i++)\n+\t  for ( ; args != end_params_node;  args = TREE_CHAIN (args), i++)\n \t    {\n \t      if (i > 0)\n \t\tput_decl_string (\",\", 1);"}, {"sha": "d99bc933de9513ad69c81e0d0247d6c5c8315d8d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=de4c7b029c4a5732a4c688bfeba7b58feee18acd", "patch": "@@ -2925,7 +2925,7 @@ maybe_generate_finit ()\n \n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_PRIVATE|ACC_FINAL, void_type_node,\n-\t\t\t\t    finit_identifier_node, NULL_TREE);\n+\t\t\t\t    finit_identifier_node, end_params_node);\n   start_artificial_method_body (mdecl);\n \n   ctxp->non_static_initialized = nreverse (ctxp->non_static_initialized);\n@@ -2953,7 +2953,7 @@ maybe_generate_clinit ()\n \n   mdecl = create_artificial_method (TREE_TYPE (ctxp->current_parsed_class),\n \t\t\t\t    ACC_STATIC, void_type_node,\n-\t\t\t\t    clinit_identifier_node, NULL_TREE);\n+\t\t\t\t    clinit_identifier_node, end_params_node);\n   start_artificial_method_body (mdecl);\n \n   /* Keep initialization in order to enforce 8.5 */\n@@ -3179,7 +3179,7 @@ fix_method_argument_names (orig_arg, meth)\n       TREE_PURPOSE (arg) = this_identifier_node;\n       arg = TREE_CHAIN (arg);\n     }\n-  while (orig_arg)\n+  while (orig_arg != end_params_node)\n     {\n       TREE_PURPOSE (arg) = TREE_PURPOSE (orig_arg);\n       orig_arg = TREE_CHAIN (orig_arg);\n@@ -3370,7 +3370,7 @@ method_declarator (id, list)\n       TREE_CHAIN (arg_node) = arg_types;\n       arg_types = arg_node;\n     }\n-  TYPE_ARG_TYPES (meth) = nreverse (arg_types);\n+  TYPE_ARG_TYPES (meth) = chainon (nreverse (arg_types), end_params_node);\n   node = build_tree_list (id, meth);\n   return node;\n }\n@@ -4340,7 +4340,7 @@ java_check_regular_methods (class_decl)\n       flags = (get_access_flags_from_decl (class_decl) & ACC_PUBLIC ?\n \t       ACC_PUBLIC : 0);\n       decl = create_artificial_method (class, flags, void_type_node, \n-\t\t\t\t       init_identifier_node, NULL_TREE);\n+\t\t\t\t       init_identifier_node, end_params_node);\n       DECL_CONSTRUCTOR_P (decl) = 1;\n       layout_class_method (TREE_TYPE (class_decl), NULL_TREE, decl, NULL_TREE);\n     }\n@@ -5031,7 +5031,7 @@ source_start_java_method (fndecl)\n   /* New scope for the function */\n   enter_block ();\n   for (tem = TYPE_ARG_TYPES (TREE_TYPE (fndecl)), i = 0;\n-       tem != NULL_TREE; tem = TREE_CHAIN (tem), i++)\n+       tem != end_params_node; tem = TREE_CHAIN (tem), i++)\n     {\n       tree type = TREE_VALUE (tem);\n       tree name = TREE_PURPOSE (tem);\n@@ -5341,12 +5341,7 @@ java_complete_expand_methods ()\n       /* Make the class data, register it and run the rest of decl\n          compilation on it */\n       if (!java_error_count && ! flag_emit_class_files)\n-\t{\n-\t  make_class_data (current_class);\n-\t  register_class ();\n-\t  rest_of_decl_compilation (TYPE_NAME (current_class), \n-\t\t\t\t    (char*) 0, 1, 0);\n-\t}\n+\tfinish_class (current_class);\n     }\n }\n \n@@ -5514,7 +5509,7 @@ verify_constructor_super ()\n       for (mdecl = TYPE_METHODS (class); mdecl; mdecl = TREE_CHAIN (mdecl))\n \t{\n \t  if (DECL_CONSTRUCTOR_P (mdecl)\n-\t      && !TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))))\n+\t      && TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (mdecl))) == end_params_node)\n \t    return 0;\n \t}\n     }\n@@ -6588,7 +6583,7 @@ patch_invoke (patch, method, args, from_super)\n   t = TYPE_ARG_TYPES (TREE_TYPE (method));\n   if (TREE_CODE (patch) == NEW_CLASS_EXPR)\n     t = TREE_CHAIN (t);\n-  for (ta = args; t && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n+  for (ta = args; t != end_params_node && ta; t = TREE_CHAIN (t), ta = TREE_CHAIN (ta))\n     if (JPRIMITIVE_TYPE_P (TREE_TYPE (TREE_VALUE (ta))) &&\n \tTREE_TYPE (TREE_VALUE (ta)) != TREE_VALUE (t))\n       TREE_VALUE (ta) = convert (TREE_VALUE (t), TREE_VALUE (ta));\n@@ -6698,7 +6693,7 @@ lookup_method_invoke (lc, cl, class, name, arg_list)\n      tree cl;\n      tree class, name, arg_list;\n {\n-  tree atl = NULL_TREE;\t\t/* Arg Type List */\n+  tree atl = end_params_node;\t\t/* Arg Type List */\n   tree method, signature, list, node;\n   char *candidates;\t\t/* Used for error report */\n \n@@ -6899,7 +6894,7 @@ argument_types_convertible (m1, m2_or_arglist)\n       m2_arg_cache = m2_arg;\n     }\n \n-  while (m1_arg && m2_arg)\n+  while (m1_arg != end_params_node && m2_arg != end_params_node)\n     {\n       resolve_and_layout (TREE_VALUE (m1_arg), NULL_TREE);\n       if (!valid_method_invocation_conversion_p (TREE_VALUE (m1_arg),\n@@ -6908,7 +6903,7 @@ argument_types_convertible (m1, m2_or_arglist)\n       m1_arg = TREE_CHAIN (m1_arg);\n       m2_arg = TREE_CHAIN (m2_arg);\n     }\n-  return (!m1_arg && !m2_arg ? 1 : 0);\n+  return m1_arg == end_params_node && m2_arg == end_params_node;\n }\n \n /* Qualification routines */\n@@ -7421,7 +7416,6 @@ java_complete_tree (node)\n \n     case NEW_CLASS_EXPR:\n     case CALL_EXPR:\n-      CAN_COMPLETE_NORMALLY (node) = 1;\n       /* Complete function's argument(s) first */\n       if (complete_function_arguments (node))\n \treturn error_mark_node;\n@@ -7441,6 +7435,7 @@ java_complete_tree (node)\n \t    DECL_CONSTRUCTOR_CALLS (current_function_decl) = \n \t      tree_cons (wfl, decl, \n \t\t\t DECL_CONSTRUCTOR_CALLS (current_function_decl));\n+\t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t  return node;\n \t}\n \n@@ -10015,6 +10010,7 @@ build_jump_to_finally (block, decl, finally_label, type)\n   stmt = build (MODIFY_EXPR, void_type_node, decl,\n \t\tbuild_address_of (LABELED_BLOCK_LABEL (new_block)));\n   TREE_SIDE_EFFECTS (stmt) = 1;\n+  CAN_COMPLETE_NORMALLY (stmt) = 1;\n   add_stmt_to_block (block, type, stmt);\n   stmt = build (GOTO_EXPR, void_type_node, finally_label);\n   TREE_SIDE_EFFECTS (stmt) = 1;"}, {"sha": "8af3a4f51b052daf817f7d40eda820cb82a6c7f7", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de4c7b029c4a5732a4c688bfeba7b58feee18acd/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=de4c7b029c4a5732a4c688bfeba7b58feee18acd", "patch": "@@ -467,8 +467,8 @@ parse_signature_string (sig_string, sig_length)\n       if (str++, str >= limit)\n \tfatal (\"bad signature string\");\n       result_type = parse_signature_type (&str, limit);\n-      result_type = build_function_type (result_type,\n-\t\t\t\t\t nreverse (argtype_list));\n+      argtype_list = chainon (nreverse (argtype_list), end_params_node);\n+      result_type = build_function_type (result_type, argtype_list);\n     }\n   else\n     result_type = parse_signature_type (&str, limit);\n@@ -513,7 +513,7 @@ build_java_argument_signature (type)\n       tree args = TYPE_ARG_TYPES (type);\n       if (TREE_CODE (type) == METHOD_TYPE)\n \targs = TREE_CHAIN (args);  /* Skip \"this\" argument. */\n-      for (; args != NULL_TREE; args = TREE_CHAIN (args))\n+      for (; args != end_params_node; args = TREE_CHAIN (args))\n \t{\n \t  tree t = build_java_signature (TREE_VALUE (args));\n \t  obstack_grow (&temporary_obstack,"}]}