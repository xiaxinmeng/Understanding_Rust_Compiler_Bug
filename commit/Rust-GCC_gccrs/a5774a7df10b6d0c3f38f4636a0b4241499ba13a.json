{"sha": "a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU3NzRhN2RmMTBiNmQwYzNmMzhmNDYzNmEwYjQyNDE0OTliYTEzYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-04-04T10:13:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-04-04T10:13:26Z"}, "message": "sparc.md (movdi_insn_sp64_novis): New pattern.\n\n\t* config/sparc/sparc.md (movdi_insn_sp64_novis): New pattern.\n\t(movdi_insn_sp64_vis): Renamed from movdi_insn_sp64.\n\t(movsf): Don't force any constant to memory if target is integer\n\thard register.\n\tMove fp_zero_operand check below the const0_rtx check.\n\t(movtf): Likewise. Also allow fp_zero_operand for stores into\n\tmemory.\n\t(movdf): Likewise. Also allow fp_zero_operand for stores into\n\tmemory and into integer hard registers.\n\t(clear_df, clear_dfp, movdf_const_intreg_sp32,\n\tmovdf_const_intreg_sp64): Remove.\n\t(movdf_insn_sp32, movdf_no_e_insn_sp32): Redo constraints and\n\tconditions.\n\t(movdf_no_e_insn_v9_sp32): New pattern.\n\t(movdf_insn_v9only): Remove.\n\t(movdf_insn_v9only_novis, movdf_insn_v9only_vis): New patterns.\n\t(movdf_insn_sp64): Remove.\n\t(movdf_insn_sp64_novis, movdf_insn_sp64_vis): New patterns.\n\t(movdf_no_e_insn_sp64): Allow storing 0.0 into memory.\n\t(following splits): Rewrite conditions. Add two new splits\n\tfor storing 0.0 into memory and registers.\n\t(clear_tf, clear_tf+1, clear_tfp, clear_tfp+1): Remove.\n\t(movtf_insn_sp32): Redo constraints and conditions.\n\t(movtf_insn_vis_sp32): New pattern.\n\t(movtf_no_e_insn_sp32): Redo constraints and conditions.\n\t(movtf_insn_hq_sp64): Likewise.\n\t(movtf_insn_hq_vis_sp64): New pattern.\n\t(movtf_insn_sp64): Redo constraints and conditions.\n\t(movtf_insn_vis_sp64): New pattern.\n\t(movtf_no_e_insn_sp64): Redo constraints and conditions.\n\t(movtf_no_e_insn_sp64+1): New split for storing 0.0L into registers\n\tor memory.\n\t* config/sparc/sparc.c (sparc_override_options): Assume v9 if either\n\t-mvis or -m64 to take down the number of various reload patterns.\n\nFrom-SVN: r32901", "tree": {"sha": "d148e0f0d7d04e9462b558abf79681cde24bc20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d148e0f0d7d04e9462b558abf79681cde24bc20a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce3e131171b5113d134b9b4a6366efda60234e21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3e131171b5113d134b9b4a6366efda60234e21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3e131171b5113d134b9b4a6366efda60234e21"}], "stats": {"total": 604, "additions": 395, "deletions": 209}, "files": [{"sha": "4bdff451c3a65a9de0485ccc68155a0e8bf7c090", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "patch": "@@ -6,6 +6,41 @@\n \tnon-optimizing TARGET_ARCH32 in DF or DI modes because it is not\n \toffsetable.\n \n+\t* config/sparc/sparc.md (movdi_insn_sp64_novis): New pattern.\n+\t(movdi_insn_sp64_vis): Renamed from movdi_insn_sp64.\n+\t(movsf): Don't force any constant to memory if target is integer\n+\thard register.\n+\tMove fp_zero_operand check below the const0_rtx check.\n+\t(movtf): Likewise. Also allow fp_zero_operand for stores into\n+\tmemory.\n+\t(movdf): Likewise. Also allow fp_zero_operand for stores into\n+\tmemory and into integer hard registers.\n+\t(clear_df, clear_dfp, movdf_const_intreg_sp32,\n+\tmovdf_const_intreg_sp64): Remove.\n+\t(movdf_insn_sp32, movdf_no_e_insn_sp32): Redo constraints and\n+\tconditions.\n+\t(movdf_no_e_insn_v9_sp32): New pattern.\n+\t(movdf_insn_v9only): Remove.\n+\t(movdf_insn_v9only_novis, movdf_insn_v9only_vis): New patterns.\n+\t(movdf_insn_sp64): Remove.\n+\t(movdf_insn_sp64_novis, movdf_insn_sp64_vis): New patterns.\n+\t(movdf_no_e_insn_sp64): Allow storing 0.0 into memory.\n+\t(following splits): Rewrite conditions. Add two new splits\n+\tfor storing 0.0 into memory and registers.\n+\t(clear_tf, clear_tf+1, clear_tfp, clear_tfp+1): Remove.\n+\t(movtf_insn_sp32): Redo constraints and conditions.\n+\t(movtf_insn_vis_sp32): New pattern.\n+\t(movtf_no_e_insn_sp32): Redo constraints and conditions.\n+\t(movtf_insn_hq_sp64): Likewise.\n+\t(movtf_insn_hq_vis_sp64): New pattern.\n+\t(movtf_insn_sp64): Redo constraints and conditions.\n+\t(movtf_insn_vis_sp64): New pattern.\n+\t(movtf_no_e_insn_sp64): Redo constraints and conditions.\n+\t(movtf_no_e_insn_sp64+1): New split for storing 0.0L into registers\n+\tor memory.\n+\t* config/sparc/sparc.c (sparc_override_options): Assume v9 if either\n+\t-mvis or -m64 to take down the number of various reload patterns.\n+\n Tue Apr  4 00:41:53 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa/pa-64.h: New file."}, {"sha": "557079695ec7d27f517660d43e1e017d3259c80b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "patch": "@@ -342,6 +342,16 @@ sparc_override_options ()\n       target_flags &= ~MASK_FPU_SET;\n     }\n \n+  /* Don't allow -mvis if FPU is disabled.  */\n+  if (! TARGET_FPU)\n+    target_flags &= ~MASK_VIS;\n+\n+  /* -mvis assumes UltraSPARC+, so we are sure v9 instructions\n+     are available.\n+     -m64 also implies v9.  */\n+  if (TARGET_VIS || TARGET_ARCH64)\n+    target_flags |= MASK_V9;\n+\n   /* Use the deprecated v8 insns for sparc64 in 32 bit mode.  */\n   if (TARGET_V9 && TARGET_ARCH32)\n     target_flags |= MASK_DEPRECATED_V8_INSNS;\n@@ -354,10 +364,6 @@ sparc_override_options ()\n   if (TARGET_ARCH32)\n     target_flags &= ~MASK_STACK_BIAS;\n     \n-  /* Don't allow -mvis if FPU is disabled.  */\n-  if (! TARGET_FPU)\n-    target_flags &= ~MASK_VIS;\n-\n   /* Supply a default value for align_functions.  */\n   if (align_functions == 0 && sparc_cpu == PROCESSOR_ULTRASPARC)\n     align_functions = 32;"}, {"sha": "477e45d5b37cfd61f53b266cf5fb9ab50da8dd2f", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "patch": "@@ -2298,7 +2298,7 @@ LFLGRET\"ID\":\\n\\\n #define REG_OK_FOR_BASE_P(X) \\\n   (((unsigned) REGNO (X)) - 32 >= (FIRST_PSEUDO_REGISTER - 32))\n \n-/* 'T', 'U' are for aligned memory loads which aren't needed for v9.  */\n+/* 'T', 'U' are for aligned memory loads which aren't needed for arch64.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n    (EXTRA_CONSTRAINT_BASE(OP, C)                        \\"}, {"sha": "f72f8a81b9da93605baebfe63fa8382231a98594", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 349, "deletions": 204, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5774a7df10b6d0c3f38f4636a0b4241499ba13a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=a5774a7df10b6d0c3f38f4636a0b4241499ba13a", "patch": "@@ -2568,10 +2568,28 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movdi_insn_sp64\"\n+(define_insn \"*movdi_insn_sp64_novis\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?m\")\n+        (match_operand:DI 1 \"input_operand\"   \"rI,K,J,m,rJ,e,m,e\"))]\n+  \"TARGET_ARCH64 && ! TARGET_VIS &&\n+   (register_operand (operands[0], DImode)\n+    || reg_or_0_operand (operands[1], DImode))\"\n+  \"@\n+   mov\\\\t%1, %0\n+   sethi\\\\t%%hi(%a1), %0\n+   clr\\\\t%0\n+   ldx\\\\t%1, %0\n+   stx\\\\t%r1, %0\n+   fmovd\\\\t%1, %0\n+   ldd\\\\t%1, %0\n+   std\\\\t%1, %0\"\n+  [(set_attr \"type\" \"move,move,move,load,store,fpmove,fpload,fpstore\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*movdi_insn_sp64_vis\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?m,b\")\n         (match_operand:DI 1 \"input_operand\"   \"rI,K,J,m,rJ,e,m,e,J\"))]\n-  \"TARGET_ARCH64 &&\n+  \"TARGET_ARCH64 && TARGET_VIS &&\n    (register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n@@ -3127,14 +3145,20 @@\n   if (GET_CODE (operands[0]) == REG\n       && CONSTANT_P (operands[1]))\n     {\n-      if (TARGET_VIS && fp_zero_operand (operands[1], SFmode))\n-\tgoto movsf_is_ok;\n-\n       /* emit_group_store will send such bogosity to us when it is\n          not storing directly into memory.  So fix this up to avoid\n          crashes in output_constant_pool.  */\n       if (operands [1] == const0_rtx)\n         operands[1] = CONST0_RTX (SFmode);\n+\n+      if (TARGET_VIS && fp_zero_operand (operands[1], SFmode))\n+\tgoto movsf_is_ok;\n+\n+      /* We are able to build any SF constant in integer registers\n+\t with at most 2 instructions.  */\n+      if (REGNO (operands[0]) < 32)\n+\tgoto movsf_is_ok;\n+\n       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n                                                    operands[1]));\n     }\n@@ -3174,101 +3198,6 @@\n   ;\n }\")\n \n-(define_insn \"*clear_df\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n-        (match_operand:DF 1 \"fp_zero_operand\" \"\"))]\n-  \"TARGET_VIS\"\n-  \"fzero\\\\t%0\"\n-  [(set_attr \"type\" \"fpmove\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"*clear_dfp\"\n-  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n-        (match_operand:DF 1 \"fp_zero_operand\" \"\"))]\n-  \"TARGET_V9\"\n-  \"stx\\\\t%%g0, %0\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"*movdf_const_intreg_sp32\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,e,?r\")\n-        (match_operand:DF 1 \"const_double_operand\" \"T#F,o#F,F\"))]\n-  \"TARGET_FPU && ! TARGET_ARCH64\"\n-  \"@\n-   ldd\\\\t%1, %0\n-   #\n-   #\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1,2,2\")])\n-\n-;; Now that we redo life analysis with a clean slate after\n-;; instruction splitting for sched2 this can work.\n-(define_insn \"*movdf_const_intreg_sp64\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,?r\")\n-        (match_operand:DF 1 \"const_double_operand\" \"m#F,F\"))]\n-  \"TARGET_FPU && TARGET_ARCH64\"\n-  \"@\n-   ldd\\\\t%1, %0\n-   #\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_FPU\n-   && (GET_CODE (operands[0]) == REG\n-       && REGNO (operands[0]) < 32)\n-   && reload_completed\"\n-  [(clobber (const_int 0))]\n-  \"\n-{\n-  REAL_VALUE_TYPE r;\n-  long l[2];\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-  if (GET_CODE (operands[0]) == SUBREG)\n-    operands[0] = alter_subreg (operands[0]);\n-  operands[0] = gen_rtx_raw_REG (DImode, REGNO (operands[0]));\n-\n-  if (TARGET_ARCH64)\n-    {\n-#if HOST_BITS_PER_WIDE_INT == 64\n-      HOST_WIDE_INT val;\n-\n-      val = ((HOST_WIDE_INT)(unsigned long)l[1] |\n-             ((HOST_WIDE_INT)(unsigned long)l[0] << 32));\n-      emit_insn (gen_movdi (operands[0], GEN_INT (val)));\n-#else\n-      emit_insn (gen_movdi (operands[0],\n-                            gen_rtx_CONST_DOUBLE (VOIDmode, const0_rtx,\n-                                                  l[1], l[0])));\n-#endif\n-    }\n-  else\n-    {\n-      emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n-\t\t\t    GEN_INT (l[0])));\n-\n-      /* Slick... but this trick loses if this subreg constant part\n-         can be done in one insn.  */\n-      if (l[1] == l[0]\n-          && !(SPARC_SETHI_P (l[0])\n-\t       || SPARC_SIMM13_P (l[0])))\n-        {\n-          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t        gen_highpart (SImode, operands[0])));\n-        }\n-      else\n-        {\n-          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n-\t\t\t        GEN_INT (l[1])));\n-        }\n-    }\n-  DONE;\n-}\")\n-\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n@@ -3279,22 +3208,25 @@\n   if (GET_CODE (operands[0]) == REG\n       && CONSTANT_P (operands[1]))\n     {\n-      if (TARGET_VIS && fp_zero_operand (operands[1], DFmode))\n-\tgoto movdf_is_ok;\n-\n       /* emit_group_store will send such bogosity to us when it is\n          not storing directly into memory.  So fix this up to avoid\n          crashes in output_constant_pool.  */\n       if (operands [1] == const0_rtx)\n         operands[1] = CONST0_RTX (DFmode);\n+\n+      if ((TARGET_VIS || REGNO (operands[0]) < 32)\n+\t  && fp_zero_operand (operands[1], DFmode))\n+\tgoto movdf_is_ok;\n+\n       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n                                                    operands[1]));\n     }\n \n   /* Handle MEM cases first.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], DFmode))\n+      if (register_operand (operands[1], DFmode)\n+\t  || fp_zero_operand (operands[1], DFmode))\n \tgoto movdf_is_ok;\n \n       if (! reload_in_progress)\n@@ -3327,12 +3259,13 @@\n \n ;; Be careful, fmovd does not exist when !v9.\n (define_insn \"*movdf_insn_sp32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,T,U,T,e,r,r,o,e,o\")\n-\t(match_operand:DF 1 \"input_operand\"    \"T,e,T,U,e,r,o,r,o,e\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,T,U,T,o,e,*r,o,e,o\")\n+\t(match_operand:DF 1 \"input_operand\"    \"T#F,e,T,U,G,e,*rFo,*r,o#F,e\"))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\\\t%1, %0\n   std\\\\t%1, %0\n@@ -3348,12 +3281,14 @@\n   (set_attr \"length\" \"1,1,1,1,2,2,2,2,2,2\")])\n \n (define_insn \"*movdf_no_e_insn_sp32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,r,r,o\")\n-\t(match_operand:DF 1 \"input_operand\"    \"T,U,r,o,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,o,r,o\")\n+\t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,r\"))]\n   \"! TARGET_FPU\n+   && ! TARGET_V9\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n   \"@\n   ldd\\\\t%1, %0\n   std\\\\t%1, %0\n@@ -3363,62 +3298,191 @@\n   [(set_attr \"type\" \"load,store,*,*,*\")\n    (set_attr \"length\" \"1,1,2,2,2\")])\n \n+(define_insn \"*movdf_no_e_insn_v9_sp32\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,T,r,o\")\n+\t(match_operand:DF 1 \"input_operand\"    \"T,U,G,ro,rG\"))]\n+  \"! TARGET_FPU\n+   && TARGET_V9\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n+  \"@\n+  ldd\\\\t%1, %0\n+  std\\\\t%1, %0\n+  stx\\\\t%r1, %0\n+  #\n+  #\"\n+  [(set_attr \"type\" \"load,store,store,*,*\")\n+   (set_attr \"length\" \"1,1,1,2,2\")])\n+\n ;; We have available v9 double floats but not 64-bit\n-;; integer registers.\n-(define_insn \"*movdf_insn_v9only\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,m,U,T,r,r,o\")\n-        (match_operand:DF 1 \"input_operand\"    \"e,m,e,T,U,r,o,r\"))]\n+;; integer registers and no VIS.\n+(define_insn \"*movdf_insn_v9only_novis\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,T,T,U,T,e,*r,o\")\n+        (match_operand:DF 1 \"input_operand\"    \"e,T#F,G,e,T,U,o#F,*roF,*rGe\"))]\n   \"TARGET_FPU\n    && TARGET_V9\n+   && ! TARGET_VIS\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n+  \"@\n+  fmovd\\\\t%1, %0\n+  ldd\\\\t%1, %0\n+  stx\\\\t%r1, %0\n+  std\\\\t%1, %0\n+  ldd\\\\t%1, %0\n+  std\\\\t%1, %0\n+  #\n+  #\n+  #\"\n+  [(set_attr \"type\" \"fpmove,load,store,store,load,store,*,*,*\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,2,2,2\")])\n+\n+;; We have available v9 double floats but not 64-bit\n+;; integer registers but we have VIS.\n+(define_insn \"*movdf_insn_v9only_vis\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,e,T,T,U,T,e,*r,o\")\n+        (match_operand:DF 1 \"input_operand\" \"G,e,T#F,G,e,T,U,o#F,*roGF,*rGe\"))]\n+  \"TARGET_FPU\n+   && TARGET_VIS\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n   \"@\n+  fzero\\\\t%1, %0\n   fmovd\\\\t%1, %0\n   ldd\\\\t%1, %0\n+  stx\\\\t%r1, %0\n   std\\\\t%1, %0\n   ldd\\\\t%1, %0\n   std\\\\t%1, %0\n   #\n   #\n   #\"\n-  [(set_attr \"type\" \"fpmove,load,store,load,store,*,*,*\")\n-   (set_attr \"length\" \"1,1,1,1,1,2,2,2\")])\n+  [(set_attr \"type\" \"fpmove,fpmove,load,store,store,load,store,*,*,*\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,1,2,2,2\")])\n \n ;; We have available both v9 double floats and 64-bit\n-;; integer registers.\n-(define_insn \"*movdf_insn_sp64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,m,r,r,m\")\n-        (match_operand:DF 1 \"input_operand\"    \"e,m,e,r,m,r\"))]\n+;; integer registers. No VIS though.\n+(define_insn \"*movdf_insn_sp64_novis\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,m,*r,*r,m,*r\")\n+        (match_operand:DF 1 \"input_operand\"    \"e,m#F,e,*rG,m,*rG,F\"))]\n   \"TARGET_FPU\n-   && TARGET_V9\n+   && ! TARGET_VIS\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n   \"@\n   fmovd\\\\t%1, %0\n   ldd\\\\t%1, %0\n   std\\\\t%1, %0\n-  mov\\\\t%1, %0\n+  mov\\\\t%r1, %0\n   ldx\\\\t%1, %0\n-  stx\\\\t%1, %0\"\n-  [(set_attr \"type\" \"fpmove,load,store,move,load,store\")\n-   (set_attr \"length\" \"1\")])\n+  stx\\\\t%r1, %0\n+  #\"\n+  [(set_attr \"type\" \"fpmove,load,store,move,load,store,*\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,2\")])\n+\n+;; We have available both v9 double floats and 64-bit\n+;; integer registers. And we have VIS.\n+(define_insn \"*movdf_insn_sp64_vis\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,e,m,*r,*r,m,*r\")\n+        (match_operand:DF 1 \"input_operand\"    \"G,e,m#F,e,*rG,m,*rG,F\"))]\n+  \"TARGET_FPU\n+   && TARGET_VIS\n+   && TARGET_ARCH64\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n+  \"@\n+  fzero\\\\t%0\n+  fmovd\\\\t%1, %0\n+  ldd\\\\t%1, %0\n+  std\\\\t%1, %0\n+  mov\\\\t%r1, %0\n+  ldx\\\\t%1, %0\n+  stx\\\\t%r1, %0\n+  #\"\n+  [(set_attr \"type\" \"fpmove,fpmove,load,store,move,load,store,*\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,1,2\")])\n \n (define_insn \"*movdf_no_e_insn_sp64\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-        (match_operand:DF 1 \"input_operand\"    \"r,m,r\"))]\n+        (match_operand:DF 1 \"input_operand\"    \"r,m,rG\"))]\n   \"! TARGET_FPU\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n+       || register_operand (operands[1], DFmode)\n+       || fp_zero_operand (operands[1], DFmode))\"\n   \"@\n   mov\\\\t%1, %0\n   ldx\\\\t%1, %0\n-  stx\\\\t%1, %0\"\n+  stx\\\\t%r1, %0\"\n   [(set_attr \"type\" \"move,load,store\")\n    (set_attr \"length\" \"1\")])\n \n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"const_double_operand\" \"\"))]\n+  \"TARGET_FPU\n+   && (GET_CODE (operands[0]) == REG\n+       && REGNO (operands[0]) < 32)\n+   && ! fp_zero_operand(operands[1], DFmode)\n+   && reload_completed\"\n+  [(clobber (const_int 0))]\n+  \"\n+{\n+  REAL_VALUE_TYPE r;\n+  long l[2];\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+  REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+  if (GET_CODE (operands[0]) == SUBREG)\n+    operands[0] = alter_subreg (operands[0]);\n+  operands[0] = gen_rtx_raw_REG (DImode, REGNO (operands[0]));\n+\n+  if (TARGET_ARCH64)\n+    {\n+#if HOST_BITS_PER_WIDE_INT == 64\n+      HOST_WIDE_INT val;\n+\n+      val = ((HOST_WIDE_INT)(unsigned long)l[1] |\n+             ((HOST_WIDE_INT)(unsigned long)l[0] << 32));\n+      emit_insn (gen_movdi (operands[0], GEN_INT (val)));\n+#else\n+      emit_insn (gen_movdi (operands[0],\n+                            gen_rtx_CONST_DOUBLE (VOIDmode, const0_rtx,\n+                                                  l[1], l[0])));\n+#endif\n+    }\n+  else\n+    {\n+      emit_insn (gen_movsi (gen_highpart (SImode, operands[0]),\n+\t\t\t    GEN_INT (l[0])));\n+\n+      /* Slick... but this trick loses if this subreg constant part\n+         can be done in one insn.  */\n+      if (l[1] == l[0]\n+          && !(SPARC_SETHI_P (l[0])\n+\t       || SPARC_SIMM13_P (l[0])))\n+        {\n+          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n+\t\t\t        gen_highpart (SImode, operands[0])));\n+        }\n+      else\n+        {\n+          emit_insn (gen_movsi (gen_lowpart (SImode, operands[0]),\n+\t\t\t        GEN_INT (l[1])));\n+        }\n+    }\n+  DONE;\n+}\")\n+\n ;; Ok, now the splits to handle all the multi insn and\n ;; mis-aligned memory address cases.\n ;; In these splits please take note that we must be\n@@ -3471,17 +3535,11 @@\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(match_operand:DF 1 \"memory_operand\" \"\"))]\n-  \"((! TARGET_V9\n-     || (! TARGET_ARCH64\n-         && ((GET_CODE (operands[0]) == REG\n-              && REGNO (operands[0]) < 32)\n-             || (GET_CODE (operands[0]) == SUBREG\n-                 && GET_CODE (SUBREG_REG (operands[0])) == REG\n-                 && REGNO (SUBREG_REG (operands[0])) < 32))))\n-    && (reload_completed\n-        && (((REGNO (operands[0])) % 2) != 0\n-             || ! mem_min_alignment (operands[1], 8))\n-        && offsettable_memref_p (operands[1])))\"\n+  \"reload_completed\n+   && ! TARGET_ARCH64\n+   && (((REGNO (operands[0]) % 2) != 0)\n+       || ! mem_min_alignment (operands[1], 8))\n+   && offsettable_memref_p (operands[1])\"\n   [(clobber (const_int 0))]\n   \"\n {\n@@ -3512,17 +3570,11 @@\n (define_split\n   [(set (match_operand:DF 0 \"memory_operand\" \"\")\n \t(match_operand:DF 1 \"register_operand\" \"\"))]\n-  \"((! TARGET_V9\n-     || (! TARGET_ARCH64\n-         && ((GET_CODE (operands[1]) == REG\n-              && REGNO (operands[1]) < 32)\n-             || (GET_CODE (operands[1]) == SUBREG\n-                 && GET_CODE (SUBREG_REG (operands[1])) == REG\n-                 && REGNO (SUBREG_REG (operands[1])) < 32))))\n-    && (reload_completed\n-        && (((REGNO (operands[1])) % 2) != 0\n-             || ! mem_min_alignment (operands[0], 8))\n-        && offsettable_memref_p (operands[0])))\"\n+  \"reload_completed\n+   && ! TARGET_ARCH64\n+   && (((REGNO (operands[1]) % 2) != 0)\n+       || ! mem_min_alignment (operands[0], 8))\n+   && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n   \"\n {\n@@ -3539,45 +3591,51 @@\n   DONE;\n }\")\n \n-(define_insn \"*clear_tf\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n-        (match_operand:TF 1 \"fp_zero_operand\" \"\"))]\n-  \"TARGET_VIS\"\n-  \"#\"\n-  [(set_attr \"type\" \"fpmove\")\n-   (set_attr \"length\" \"2\")])\n-\n (define_split\n-  [(set (match_operand:TF 0 \"register_operand\" \"\")\n-        (match_operand:TF 1 \"fp_zero_operand\" \"\"))]\n-  \"TARGET_VIS && reload_completed\"\n-  [(set (subreg:DF (match_dup 0) 0) (match_dup 1))\n-   (set (subreg:DF (match_dup 0) 8) (match_dup 1))]\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+        (match_operand:DF 1 \"fp_zero_operand\" \"\"))]\n+  \"reload_completed\n+   && (! TARGET_V9\n+       || (! TARGET_ARCH64\n+\t   && ! mem_min_alignment (operands[0], 8)))\n+   && offsettable_memref_p (operands[0])\"\n+  [(clobber (const_int 0))]\n   \"\n {\n-  operands[1] = CONST0_RTX (DFmode);\n-}\n-\")\n+  rtx dest1, dest2;\n \n-(define_insn \"*clear_tfp\"\n-  [(set (match_operand:TF 0 \"memory_operand\" \"=m\")\n-        (match_operand:TF 1 \"fp_zero_operand\" \"\"))]\n-  \"TARGET_V9\"\n-  \"#\"\n-  [(set_attr \"type\" \"fpmove\")\n-   (set_attr \"length\" \"2\")])\n+  dest1 = change_address (operands[0], SFmode, NULL_RTX);\n+  dest2 = change_address (operands[0], SFmode,\n+\t\t\t  plus_constant_for_output (XEXP (dest1, 0), 4));\n+  emit_insn (gen_movsf (dest1, CONST0_RTX (SFmode)));\n+  emit_insn (gen_movsf (dest2, CONST0_RTX (SFmode)));\n+  DONE;\n+}\")\n \n (define_split\n-  [(set (match_operand:TF 0 \"memory_operand\" \"=m\")\n-        (match_operand:TF 1 \"fp_zero_operand\" \"\"))]\n-  \"TARGET_V9 && reload_completed\"\n-  [(set (subreg:DF (match_dup 0) 0) (match_dup 1))\n-   (set (subreg:DF (match_dup 0) 8) (match_dup 1))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"fp_zero_operand\" \"\"))]\n+  \"reload_completed\n+   && ! TARGET_ARCH64\n+   && ((GET_CODE (operands[0]) == REG\n+\t&& REGNO (operands[0]) < 32)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) < 32))\"\n+  [(clobber (const_int 0))]\n   \"\n {\n-  operands[1] = CONST0_RTX (DFmode);\n-}\n-\")\n+  rtx set_dest = operands[0];\n+  rtx dest1, dest2;\n+\n+  if (GET_CODE (set_dest) == SUBREG)\n+    set_dest = alter_subreg (set_dest);\n+  dest1 = gen_highpart (SFmode, set_dest);\n+  dest2 = gen_lowpart (SFmode, set_dest);\n+  emit_insn (gen_movsf (dest1, CONST0_RTX (SFmode)));\n+  emit_insn (gen_movsf (dest2, CONST0_RTX (SFmode)));\n+  DONE;\n+}\")\n \n (define_expand \"movtf\"\n   [(set (match_operand:TF 0 \"general_operand\" \"\")\n@@ -3589,14 +3647,15 @@\n   if (GET_CODE (operands[0]) == REG\n       && CONSTANT_P (operands[1]))\n     {\n-      if (TARGET_VIS && fp_zero_operand (operands[1], TFmode))\n-\tgoto movtf_is_ok;\n-\n       /* emit_group_store will send such bogosity to us when it is\n          not storing directly into memory.  So fix this up to avoid\n          crashes in output_constant_pool.  */\n       if (operands [1] == const0_rtx)\n         operands[1] = CONST0_RTX (TFmode);\n+\n+      if (TARGET_VIS && fp_zero_operand (operands[1], TFmode))\n+\tgoto movtf_is_ok;\n+\n       operands[1] = validize_mem (force_const_mem (GET_MODE (operands[0]),\n                                                    operands[1]));\n     }\n@@ -3605,8 +3664,9 @@\n      full 16-byte alignment for quads. */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n-      if (register_operand (operands[1], TFmode))\n-        goto movtf_is_ok;\n+      if (register_operand (operands[1], TFmode)\n+\t  || fp_zero_operand (operands[1], TFmode))\n+\tgoto movtf_is_ok;\n \n       if (! reload_in_progress)\n \t{\n@@ -3639,12 +3699,26 @@\n ;; Be careful, fmovq and {st,ld}{x,q} do not exist when !arch64 so\n ;; we must split them all.  :-(\n (define_insn \"*movtf_insn_sp32\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,U,o,e,r,r,o\")\n-\t(match_operand:TF 1 \"input_operand\"    \"o,e,o,U,e,r,o,r\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,U,o,r,o\")\n+\t(match_operand:TF 1 \"input_operand\"    \"oe,Ge,o,U,ro,r\"))]\n   \"TARGET_FPU\n+   && ! TARGET_VIS\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n+  \"#\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"*movtf_insn_vis_sp32\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,U,o,r,o\")\n+\t(match_operand:TF 1 \"input_operand\"    \"Goe,Ge,o,U,ro,r\"))]\n+  \"TARGET_FPU\n+   && TARGET_VIS\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n@@ -3653,26 +3727,48 @@\n ;; when -mno-fpu.\n \n (define_insn \"*movtf_no_e_insn_sp32\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=U,o,r,r,o\")\n-\t(match_operand:TF 1 \"input_operand\"    \"o,U,r,o,r\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=o,U,o,r,o\")\n+\t(match_operand:TF 1 \"input_operand\"    \"G,o,U,ro,r\"))]\n   \"! TARGET_FPU\n    && ! TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"4\")])\n \n ;; Now handle the float reg cases directly when arch64,\n ;; hard_quad, and proper reg number alignment are all true.\n (define_insn \"*movtf_insn_hq_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,e,m,r,r,o\")\n-        (match_operand:TF 1 \"input_operand\"    \"e,m,e,r,o,r\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,e,m,o,r,o\")\n+        (match_operand:TF 1 \"input_operand\"    \"e,m,e,G,ro,r\"))]\n   \"TARGET_FPU\n+   && ! TARGET_VIS\n    && TARGET_ARCH64\n-   && TARGET_V9\n    && TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n+  \"@\n+  fmovq\\\\t%1, %0\n+  ldq\\\\t%1, %0\n+  stq\\\\t%1, %0\n+  #\n+  #\n+  #\"\n+  [(set_attr \"type\" \"fpmove,fpload,fpstore,*,*,*\")\n+   (set_attr \"length\" \"1,1,1,2,2,2\")])\n+\n+(define_insn \"*movtf_insn_hq_vis_sp64\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,e,m,eo,r,o\")\n+        (match_operand:TF 1 \"input_operand\"    \"e,m,e,G,ro,r\"))]\n+  \"TARGET_FPU\n+   && TARGET_VIS\n+   && TARGET_ARCH64\n+   && TARGET_HARD_QUAD\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n   \"@\n   fmovq\\\\t%1, %0\n   ldq\\\\t%1, %0\n@@ -3686,23 +3782,39 @@\n ;; Now we allow the integer register cases even when\n ;; only arch64 is true.\n (define_insn \"*movtf_insn_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,r,o,e,r\")\n-        (match_operand:TF 1 \"input_operand\"    \"o,e,o,r,e,r\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=o,e,r\")\n+        (match_operand:TF 1 \"input_operand\"    \"Ge,oe,or\"))]\n+  \"TARGET_FPU\n+   && ! TARGET_VIS\n+   && TARGET_ARCH64\n+   && ! TARGET_HARD_QUAD\n+   && (register_operand (operands[0], TFmode)\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n+  \"#\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*movtf_insn_vis_sp64\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=eo,e,r\")\n+        (match_operand:TF 1 \"input_operand\"    \"Ge,o,or\"))]\n   \"TARGET_FPU\n+   && TARGET_VIS\n    && TARGET_ARCH64\n    && ! TARGET_HARD_QUAD\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"*movtf_no_e_insn_sp64\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o,r\")\n-        (match_operand:TF 1 \"input_operand\"    \"o,r,r\"))]\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o\")\n+        (match_operand:TF 1 \"input_operand\"    \"or,rG\"))]\n   \"! TARGET_FPU\n    && TARGET_ARCH64\n    && (register_operand (operands[0], TFmode)\n-       || register_operand (operands[1], TFmode))\"\n+       || register_operand (operands[1], TFmode)\n+       || fp_zero_operand (operands[1], TFmode))\"\n   \"#\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3747,6 +3859,39 @@\n   DONE;\n }\")\n \n+(define_split\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TF 1 \"fp_zero_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(clobber (const_int 0))]\n+  \"\n+{\n+  rtx set_dest = operands[0];\n+  rtx dest1, dest2;\n+\n+  switch (GET_CODE (set_dest))\n+    {\n+    case SUBREG:\n+      set_dest = alter_subreg (set_dest);\n+      /* FALLTHROUGH */\n+    case REG:\n+      dest1 = gen_df_reg (set_dest, 0);\n+      dest2 = gen_df_reg (set_dest, 1);\n+      break;\n+    case MEM:\n+      dest1 = change_address (set_dest, DFmode, NULL_RTX);\n+      dest2 = change_address (set_dest, DFmode,\n+\t\t\t      plus_constant_for_output (XEXP (dest1, 0), 8));\n+      break;\n+    default:\n+      abort ();      \n+    }\n+\n+  emit_insn (gen_movdf (dest1, CONST0_RTX (DFmode)));\n+  emit_insn (gen_movdf (dest2, CONST0_RTX (DFmode)));\n+  DONE;\n+}\")\n+\n (define_split\n   [(set (match_operand:TF 0 \"register_operand\" \"\")\n         (match_operand:TF 1 \"memory_operand\" \"\"))]"}]}