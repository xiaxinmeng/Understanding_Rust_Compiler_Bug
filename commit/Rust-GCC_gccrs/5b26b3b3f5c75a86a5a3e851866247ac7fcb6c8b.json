{"sha": "5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIyNmIzYjNmNWM3NWE4NmE1YTNlODUxODY2MjQ3YWM3ZmNiNmM4Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-09-26T11:32:35Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-09-26T11:32:35Z"}, "message": "Correct overwrite of alloc_comp_result_2.f90 in fix of PR96495.\n\n2020-26-09  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/testsuite/\n\tPR fortran/96495\n\t* gfortran.dg/alloc_comp_result_2.f90 : Restore original.\n\t* gfortran.dg/alloc_comp_result_3.f90 : New test.", "tree": {"sha": "39c53cec6eca581b47b3fa394044cb0a9187e927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39c53cec6eca581b47b3fa394044cb0a9187e927"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b/comments", "author": null, "committer": null, "parents": [{"sha": "a8d2d89de2ef6b87166acc81589bdbb622917705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d2d89de2ef6b87166acc81589bdbb622917705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8d2d89de2ef6b87166acc81589bdbb622917705"}], "stats": {"total": 169, "additions": 98, "deletions": 71}, "files": [{"sha": "2e907e3155857c6f1935fed5dc00d1ec60d8bf6d", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_result_2.f90", "status": "modified", "additions": 23, "deletions": 71, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_2.f90?ref=5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b", "patch": "@@ -1,75 +1,27 @@\n-! { dg-do run }\n+! Tests the fix for PR40440, in which gfortran tried to deallocate\n+! the allocatable components of the actual argument of CALL SUB\n !\n-! Test the fix for PR96495 - segfaults at runtime at locations below.\n+! Contributed by Juergen Reuter <juergen.reuter@desy.de>\n+! Reduced testcase from Tobias Burnus  <burnus@gcc.gnu.org>\n !\n-! Contributed by Paul Luckner  <paul.luckner@rwth-aachen.de>\n-!\n-module foo_m\n-\n   implicit none\n-\n-  type foo\n-    integer, allocatable :: j(:)\n-  end type\n-\n-  interface operator(.unary.)\n-    module procedure neg_foo\n-  end interface\n-\n-  interface operator(.binary.)\n-    module procedure foo_sub_foo\n-  end interface\n-\n-  interface operator(.binaryElemental.)\n-    module procedure foo_add_foo\n-  end interface\n-\n+  type t\n+    integer, allocatable :: A(:)\n+  end type t\n+  type (t) :: arg\n+  arg = t ([1,2,3])\n+  call sub (func (arg))\n contains\n-\n-  elemental function foo_add_foo(f, g) result(h)\n-    !! an example for an elemental binary operator\n-    type(foo), intent(in) :: f, g\n-    type(foo)             :: h\n-\n-    allocate (h%j(size(f%j)), source = f%j+g%j)\n-  end function\n-\n-  elemental function foo_sub_foo(f, g) result(h)\n-    !! an example for an elemental binary operator\n-    type(foo), intent(in) :: f, g\n-    type(foo)             :: h\n-\n-    allocate (h%j(size(f%j)), source = f%j-3*g%j)\n-  end function\n-\n-  pure function neg_foo(f) result(g)\n-    !! an example for a unary operator\n-    type(foo), intent(in) :: f\n-    type(foo)             :: g\n-\n-    allocate (g%j(size(f%j)), source = -f%j)\n-  end function\n-\n-end module\n-\n-program main_tmp\n-\n-  use foo_m\n-\n-  implicit none\n-\n-  type(foo) f, g(2)\n-\n-  allocate (f%j(3))\n-  f%j = [2, 3, 4]\n-\n-  g = f\n-  if (any (g(2)%j .ne. [2, 3, 4])) stop 1\n-\n-  g = g .binaryElemental. (f .binary. f)     ! threw \"Segmentation fault\"\n-  if (any (g(2)%j .ne. [-2,-3,-4])) stop 2\n-\n-  g = g .binaryElemental. (  .unary.  f)     ! threw \"Segmentation fault\"\n-  if (any (g(2)%j .ne. [-4,-6,-8])) stop 3\n-\n-end program\n\\ No newline at end of file\n+  function func (a)\n+    type(t), pointer :: func\n+    type(t), target :: a\n+    integer, save :: i = 0\n+    if (i /= 0) STOP 1! multiple calls would cause this abort\n+    i = i + 1\n+    func => a\n+  end function func\n+  subroutine sub (a)\n+    type(t), intent(IN), target :: a\n+    if (any (a%A .ne. [1,2,3])) STOP 2\n+  end subroutine sub\n+end"}, {"sha": "8c4c982c67f293068105e5bfca49f360aeb50fa7", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_result_3.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_result_3.f90?ref=5b26b3b3f5c75a86a5a3e851866247ac7fcb6c8b", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR96495 - segfaults at runtime at locations below.\n+!\n+! Contributed by Paul Luckner  <paul.luckner@rwth-aachen.de>\n+!\n+module foo_m\n+\n+  implicit none\n+\n+  type foo\n+    integer, allocatable :: j(:)\n+  end type\n+\n+  interface operator(.unary.)\n+    module procedure neg_foo\n+  end interface\n+\n+  interface operator(.binary.)\n+    module procedure foo_sub_foo\n+  end interface\n+\n+  interface operator(.binaryElemental.)\n+    module procedure foo_add_foo\n+  end interface\n+\n+contains\n+\n+  elemental function foo_add_foo(f, g) result(h)\n+    !! an example for an elemental binary operator\n+    type(foo), intent(in) :: f, g\n+    type(foo)             :: h\n+\n+    allocate (h%j(size(f%j)), source = f%j+g%j)\n+  end function\n+\n+  elemental function foo_sub_foo(f, g) result(h)\n+    !! an example for an elemental binary operator\n+    type(foo), intent(in) :: f, g\n+    type(foo)             :: h\n+\n+    allocate (h%j(size(f%j)), source = f%j-3*g%j)\n+  end function\n+\n+  pure function neg_foo(f) result(g)\n+    !! an example for a unary operator\n+    type(foo), intent(in) :: f\n+    type(foo)             :: g\n+\n+    allocate (g%j(size(f%j)), source = -f%j)\n+  end function\n+\n+end module\n+\n+program main_tmp\n+\n+  use foo_m\n+\n+  implicit none\n+\n+  type(foo) f, g(2)\n+\n+  allocate (f%j(3))\n+  f%j = [2, 3, 4]\n+\n+  g = f\n+  if (any (g(2)%j .ne. [2, 3, 4])) stop 1\n+\n+  g = g .binaryElemental. (f .binary. f)     ! threw \"Segmentation fault\"\n+  if (any (g(2)%j .ne. [-2,-3,-4])) stop 2\n+\n+  g = g .binaryElemental. (  .unary.  f)     ! threw \"Segmentation fault\"\n+  if (any (g(2)%j .ne. [-4,-6,-8])) stop 3\n+\n+end program"}]}