{"sha": "72886fcc6269531bbf3d9a09b3d64644963bff0d", "node_id": "C_kwDOANBUbNoAKDcyODg2ZmNjNjI2OTUzMWJiZjNkOWEwOWIzZDY0NjQ0OTYzYmZmMGQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-23T17:42:37Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-23T17:42:37Z"}, "message": "libstdc++: Implement std::pair/tuple/misc enhancements from P2321R2\n\nThis implements the non-<ranges> changes from P2321R2, which primarily\nconsist of additional converting constructors, assignment operator and\nswap overloads for std::pair and std::tuple.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/stl_bvector.h (_Bit_reference::operator=): Define\n\tconst overload for C++23 as per P2321R2.\n\t* include/bits/stl_pair.h (pair::swap): Likewise.\n\t(pair::pair): Define additional converting constructors for\n\tC++23 as per P2321R2.\n\t(pair::operator=): Define const overloads for C++23 as per\n\tP2321R2.\n\t(swap): Define overload taking const pair& for C++23 as per\n\tP2321R2.\n\t(basic_common_reference): Define partial specialization for\n\tpair for C++23 as per P2321R2.\n\t(common_type): Likewise.\n\t* include/bits/uses_allocator_args.h\n\t(uses_allocator_construction_args): Define additional pair\n\toverloads for C++23 as per P2321R2.\n\t* include/std/tuple (_Tuple_impl::_Tuple_impl): Define\n\tadditional converting constructors for C++23 as per P2321R2.\n\t(_Tuple_impl::_M_assign): Define const overloads for C++23\n\tas per P2321R2.\n\t(_Tuple_impl::_M_swap): Likewise.\n\t(tuple::__constructible): Define as a convenient renaming of\n\t_TCC<true>::__constructible.\n\t(tuple::__convertible): As above but for _TCC<true>::__convertible.\n\t(tuple::tuple): Define additional converting constructors for\n\tC++23 as per P2321R2.\n\t(tuple::operator=): Define const overloads for C++23 as per\n\tP2321R2.\n\t(tuple::swap): Likewise.\n\t(basic_common_reference): Define partial specialization for\n\ttuple for C++23 as per P2321R2.\n\t(common_type): Likewise.\n\t* testsuite/20_util/pair/p2321r2.cc: New test.\n\t* testsuite/20_util/tuple/p2321r2.cc: New test.\n\t* testsuite/23_containers/vector/bool/element_access/1.cc: New test.", "tree": {"sha": "ad19ae595e927e200e464a4499b997c8e0d33660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad19ae595e927e200e464a4499b997c8e0d33660"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72886fcc6269531bbf3d9a09b3d64644963bff0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72886fcc6269531bbf3d9a09b3d64644963bff0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72886fcc6269531bbf3d9a09b3d64644963bff0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72886fcc6269531bbf3d9a09b3d64644963bff0d/comments", "author": null, "committer": null, "parents": [{"sha": "02f6b405f0e9dc7a8868fecef9a048b79c433125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f6b405f0e9dc7a8868fecef9a048b79c433125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f6b405f0e9dc7a8868fecef9a048b79c433125"}], "stats": {"total": 1484, "additions": 1479, "deletions": 5}, "files": [{"sha": "e5dc04f084008dce7290ca115ce426065acd1646", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -106,6 +106,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       return *this;\n     }\n \n+#if __cplusplus > 202002L\n+    constexpr const _Bit_reference&\n+    operator=(bool __x) const noexcept\n+    {\n+      if (__x)\n+\t*_M_p |= _M_mask;\n+      else\n+\t*_M_p &= ~_M_mask;\n+      return *this;\n+    }\n+#endif // C++23\n+\n     _GLIBCXX20_CONSTEXPR\n     _Bit_reference&\n     operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT"}, {"sha": "bffca0daf65f6b55eae1103583cadd27f3822887", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 112, "deletions": 5, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -212,6 +212,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tswap(second, __p.second);\n       }\n \n+#if __cplusplus > 202002L\n+      constexpr void\n+      swap(const pair& __p) const\n+      noexcept(__and_v<__is_nothrow_swappable<const _T1>,\n+\t\t       __is_nothrow_swappable<const _T2>>)\n+      {\n+\tusing std::swap;\n+\tswap(first, __p.first);\n+\tswap(second, __p.second);\n+      }\n+#endif // C++23\n+\n     private:\n       template<typename... _Args1, size_t... _Indexes1,\n \t       typename... _Args2, size_t... _Indexes2>\n@@ -283,7 +295,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))\n \t{ }\n \n-      /// Converting constructor from a `pair<U1, U2>` lvalue\n+      /// Converting constructor from a const `pair<U1, U2>` lvalue\n       template<typename _U1, typename _U2>\n \trequires (_S_constructible<const _U1&, const _U2&>())\n \tconstexpr explicit(!_S_convertible<const _U1&, const _U2&>())\n@@ -292,7 +304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: first(__p.first), second(__p.second)\n \t{ }\n \n-      /// Converting constructor from a `pair<U1, U2>` rvalue\n+      /// Converting constructor from a non-const `pair<U1, U2>` rvalue\n       template<typename _U1, typename _U2>\n \trequires (_S_constructible<_U1, _U2>())\n \tconstexpr explicit(!_S_convertible<_U1, _U2>())\n@@ -302,6 +314,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  second(std::forward<_U2>(__p.second))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      /// Converting constructor from a non-const `pair<U1, U2>` lvalue\n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<_U1&, _U2&>())\n+\tconstexpr explicit(!_S_convertible<_U1&, _U2&>())\n+\tpair(pair<_U1, _U2>& __p)\n+\tnoexcept(_S_nothrow_constructible<_U1&, _U2&>())\n+\t: first(__p.first), second(__p.second)\n+\t{ }\n+\n+      /// Converting constructor from a const `pair<U1, U2>` rvalue\n+      template<typename _U1, typename _U2>\n+\trequires (_S_constructible<const _U1, const _U2>())\n+\tconstexpr explicit(!_S_convertible<const _U1, const _U2>())\n+\tpair(const pair<_U1, _U2>&& __p)\n+\tnoexcept(_S_nothrow_constructible<const _U1, const _U2>())\n+\t: first(std::forward<const _U1>(__p.first)),\n+\t  second(std::forward<const _U2>(__p.second))\n+\t{ }\n+#endif // C++23\n+\n   private:\n       /// @cond undocumented\n       template<typename _U1, typename _U2>\n@@ -349,7 +382,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      /// Converting assignment from a `pair<U1, U2>` lvalue\n+      /// Converting assignment from a const `pair<U1, U2>` lvalue\n       template<typename _U1, typename _U2>\n \tconstexpr pair&\n \toperator=(const pair<_U1, _U2>& __p)\n@@ -361,7 +394,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n-      /// Converting assignment from a `pair<U1, U2>` rvalue\n+      /// Converting assignment from a non-const `pair<U1, U2>` rvalue\n       template<typename _U1, typename _U2>\n \tconstexpr pair&\n \toperator=(pair<_U1, _U2>&& __p)\n@@ -372,7 +405,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  second = std::forward<_U2>(__p.second);\n \t  return *this;\n \t}\n-#else\n+\n+#if __cplusplus > 202002L\n+      /// Copy assignment operator (const)\n+      constexpr const pair&\n+      operator=(const pair& __p) const\n+      requires is_copy_assignable_v<const first_type>\n+\t&& is_copy_assignable_v<const second_type>\n+      {\n+\tfirst = __p.first;\n+\tsecond = __p.second;\n+\treturn *this;\n+      }\n+\n+      /// Move assignment operator (const)\n+      constexpr const pair&\n+      operator=(pair&& __p) const\n+      requires is_assignable_v<const first_type&, first_type>\n+\t&& is_assignable_v<const second_type&, second_type>\n+      {\n+\tfirst = std::forward<first_type>(__p.first);\n+\tsecond = std::forward<second_type>(__p.second);\n+\treturn *this;\n+      }\n+\n+      /// Converting assignment from a const `pair<U1, U2>` lvalue\n+      template<typename _U1, typename _U2>\n+\tconstexpr const pair&\n+\toperator=(const pair<_U1, _U2>& __p) const\n+\trequires is_assignable_v<const first_type&, const _U1&>\n+\t  && is_assignable_v<const second_type&, const _U2&>\n+\t{\n+\t  first = __p.first;\n+\t  second = __p.second;\n+\t  return *this;\n+\t}\n+\n+      /// Converting assignment from a non-const `pair<U1, U2>` rvalue\n+      template<typename _U1, typename _U2>\n+\tconstexpr const pair&\n+\toperator=(pair<_U1, _U2>&& __p) const\n+\trequires is_assignable_v<const first_type&, _U1>\n+\t  && is_assignable_v<const second_type&, _U2>\n+\t{\n+\t  first = std::forward<_U1>(__p.first);\n+\t  second = std::forward<_U2>(__p.second);\n+\t  return *this;\n+\t}\n+#endif // C++23\n+#else // !__cpp_lib_concepts\n       // C++11/14/17 implementation using enable_if, partially constexpr.\n \n       /** The default constructor creates @c first and @c second using their\n@@ -710,6 +791,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     noexcept(noexcept(__x.swap(__y)))\n     { __x.swap(__y); }\n \n+#if __cplusplus > 202002L\n+  template<typename _T1, typename _T2>\n+    requires is_swappable_v<const _T1> && is_swappable_v<const _T2>\n+    constexpr void\n+    swap(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    noexcept(noexcept(__x.swap(__y)))\n+    { __x.swap(__y); }\n+#endif // C++23\n+\n #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n   template<typename _T1, typename _T2>\n     typename enable_if<!__and_<__is_swappable<_T1>,\n@@ -918,6 +1008,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     get(const pair<_Up, _Tp>&& __p) noexcept\n     { return std::move(__p.second); }\n \n+#if __cplusplus > 202002L\n+  template<typename _T1, typename _T2, typename _U1, typename _U2,\n+\t   template<typename> class _TQual, template<typename> class _UQual>\n+    requires requires { typename pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,\n+\t\t\t\t      common_reference_t<_TQual<_T2>, _UQual<_U2>>>; }\n+  struct basic_common_reference<pair<_T1, _T2>, pair<_U1, _U2>, _TQual, _UQual>\n+  {\n+    using type = pair<common_reference_t<_TQual<_T1>, _UQual<_U1>>,\n+\t\t      common_reference_t<_TQual<_T2>, _UQual<_U2>>>;\n+  };\n+\n+  template<typename _T1, typename _T2, typename _U1, typename _U2>\n+    requires requires { typename pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; }\n+  struct common_type<pair<_T1, _T2>, pair<_U1, _U2>>\n+  { using type = pair<common_type_t<_T1, _U1>, common_type_t<_T2, _U2>>; };\n+#endif // C++23\n+\n #endif // C++14\n   /// @}\n #endif // C++11"}, {"sha": "ef5c4fffb709c12bcb745cab9cf2465cbb1dd335", "filename": "libstdc++-v3/include/bits/uses_allocator_args.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator_args.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator_args.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fuses_allocator_args.h?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -107,6 +107,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     constexpr auto\n     uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;\n \n+#if __cplusplus > 202002L\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&,\n+\t\t\t\t     pair<_Up, _Vp>&) noexcept;\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc&, const pair<_Up, _Vp>&&) noexcept;\n+#endif // C++23\n+\n   template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>\n     constexpr auto\n     uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,\n@@ -181,6 +192,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    std::move(__pr).second));\n     }\n \n+#if __cplusplus > 202002L\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     pair<_Up, _Vp>& __pr) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));\n+    }\n+\n+  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>\n+    constexpr auto\n+    uses_allocator_construction_args(const _Alloc& __a,\n+\t\t\t\t     const pair<_Up, _Vp>&& __pr) noexcept\n+    {\n+      using _Tp1 = typename _Tp::first_type;\n+      using _Tp2 = typename _Tp::second_type;\n+\n+      return std::make_tuple(piecewise_construct,\n+\t  std::uses_allocator_construction_args<_Tp1>(__a,\n+\t    std::move(__pr).first),\n+\t  std::uses_allocator_construction_args<_Tp2>(__a,\n+\t    std::move(__pr).second));\n+    }\n+#endif // C++23\n+\n   template<typename _Tp, typename _Alloc, typename... _Args>\n     constexpr _Tp\n     make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)"}, {"sha": "05433d5ae36a0ecc14053e4c31c2cd8e1c019513", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -316,6 +316,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      template<typename... _UElements>\n+\tconstexpr\n+\t_Tuple_impl(_Tuple_impl<_Idx, _UElements...>& __in)\n+\t: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),\n+\t  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))\n+\t{ }\n+\n+      template<typename _UHead, typename... _UTails>\n+\tconstexpr\n+\t_Tuple_impl(const _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n+\t: _Inherited(std::move\n+\t\t     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n+\t  _Base(std::forward<const _UHead>\n+\t\t(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))\n+\t{ }\n+#endif // C++23\n+\n       template<typename _Alloc>\n \t_GLIBCXX20_CONSTEXPR\n \t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n@@ -379,6 +397,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      template<typename _Alloc, typename _UHead, typename... _UTails>\n+\tconstexpr\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t\t    _Tuple_impl<_Idx, _UHead, _UTails...>& __in)\n+\t: _Inherited(__tag, __a,\n+\t\t     _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),\n+\t  _Base(__use_alloc<_Head, _Alloc, _UHead&>(__a),\n+\t\t_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _UHead, typename... _UTails>\n+\tconstexpr\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t\t    const _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n+\t: _Inherited(__tag, __a, std::move\n+\t\t     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n+\t  _Base(__use_alloc<_Head, _Alloc, const _UHead>(__a),\n+\t\tstd::forward<const _UHead>\n+\t\t(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))\n+\t{ }\n+#endif // C++23\n+\n       template<typename... _UElements>\n \t_GLIBCXX20_CONSTEXPR\n \tvoid\n@@ -400,6 +441,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));\n \t}\n \n+#if __cplusplus > 202002L\n+      template<typename... _UElements>\n+\tconstexpr void\n+\t_M_assign(const _Tuple_impl<_Idx, _UElements...>& __in) const\n+\t{\n+\t  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);\n+\t  _M_tail(*this)._M_assign(\n+\t      _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));\n+\t}\n+\n+      template<typename _UHead, typename... _UTails>\n+\tconstexpr void\n+\t_M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in) const\n+\t{\n+\t  _M_head(*this) = std::forward<_UHead>\n+\t    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));\n+\t  _M_tail(*this)._M_assign(\n+\t      std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));\n+\t}\n+#endif // C++23\n+\n     protected:\n       _GLIBCXX20_CONSTEXPR\n       void\n@@ -409,6 +471,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tswap(_M_head(*this), _M_head(__in));\n \t_Inherited::_M_swap(_M_tail(__in));\n       }\n+\n+#if __cplusplus > 202002L\n+      constexpr void\n+      _M_swap(const _Tuple_impl& __in) const\n+      {\n+\tusing std::swap;\n+\tswap(_M_head(*this), _M_head(__in));\n+\t_Inherited::_M_swap(_M_tail(__in));\n+      }\n+#endif // C++23\n     };\n \n   // Basis case of inheritance recursion.\n@@ -469,6 +541,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      template<typename _UHead>\n+\tconstexpr\n+\t_Tuple_impl(_Tuple_impl<_Idx, _UHead>& __in)\n+\t: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))\n+\t{ }\n+\n+      template<typename _UHead>\n+\tconstexpr\n+\t_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&& __in)\n+\t: _Base(std::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n+\t{ }\n+#endif // C++23\n+\n       template<typename _Alloc>\n \t_GLIBCXX20_CONSTEXPR\n \t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)\n@@ -521,6 +607,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tstd::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      template<typename _Alloc, typename _UHead>\n+\tconstexpr\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t\t    _Tuple_impl<_Idx, _UHead>& __in)\n+\t: _Base(__use_alloc<_Head, _Alloc, _UHead&>(__a),\n+\t\t_Tuple_impl<_Idx, _UHead>::_M_head(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _UHead>\n+\tconstexpr\n+\t_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,\n+\t\t    const _Tuple_impl<_Idx, _UHead>&& __in)\n+\t: _Base(__use_alloc<_Head, _Alloc, const _UHead>(__a),\n+\t\tstd::forward<const _UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n+\t{ }\n+#endif // C++23\n+\n       template<typename _UHead>\n \t_GLIBCXX20_CONSTEXPR\n \tvoid\n@@ -538,6 +642,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));\n \t}\n \n+#if __cplusplus > 202002L\n+      template<typename _UHead>\n+\tconstexpr void\n+\t_M_assign(const _Tuple_impl<_Idx, _UHead>& __in) const\n+\t{\n+\t  _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);\n+\t}\n+\n+      template<typename _UHead>\n+\tconstexpr void\n+\t_M_assign(_Tuple_impl<_Idx, _UHead>&& __in) const\n+\t{\n+\t  _M_head(*this)\n+\t    = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));\n+\t}\n+#endif // C++23\n+\n     protected:\n       _GLIBCXX20_CONSTEXPR\n       void\n@@ -546,6 +667,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tusing std::swap;\n \tswap(_M_head(*this), _M_head(__in));\n       }\n+\n+#if __cplusplus > 202002L\n+      constexpr void\n+      _M_swap(const _Tuple_impl& __in) const\n+      {\n+\tusing std::swap;\n+\tswap(_M_head(*this), _M_head(__in));\n+      }\n+#endif // C++23\n     };\n \n   // Concept utility functions, reused in conditionally-explicit\n@@ -712,6 +842,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstatic constexpr bool __use_other_ctor()\n \t{ return _UseOtherCtor<_Tuple>::value; }\n \n+#if __cplusplus > 202002L\n+      template<typename... _Args>\n+\tstatic constexpr bool __constructible\n+\t  = _TCC<true>::template __constructible<_Args...>::value;\n+\n+      template<typename... _Args>\n+\tstatic constexpr bool __convertible\n+\t  = _TCC<true>::template __convertible<_Args...>::value;\n+#endif // C++23\n+\n     public:\n       template<typename _Dummy = void,\n \t       _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>\n@@ -799,6 +939,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tnoexcept(__nothrow_constructible<_UElements...>())\n \t: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n \n+#if __cplusplus > 202002L\n+      template<typename... _UElements>\n+\trequires (sizeof...(_Elements) == sizeof...(_UElements))\n+\t  && (!__use_other_ctor<tuple<_UElements...>&>())\n+\t  && __constructible<_UElements&...>\n+\texplicit(!__convertible<_UElements&...>)\n+\tconstexpr\n+\ttuple(tuple<_UElements...>& __in)\n+\tnoexcept(__nothrow_constructible<_UElements&...>())\n+\t: _Inherited(static_cast<_Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n+\n+      template<typename... _UElements>\n+\trequires (sizeof...(_Elements) == sizeof...(_UElements))\n+\t  && (!__use_other_ctor<const tuple<_UElements...>&&>())\n+\t  && __constructible<const _UElements...>\n+\texplicit(!__convertible<const _UElements...>)\n+\tconstexpr\n+\ttuple(const tuple<_UElements...>&& __in)\n+\tnoexcept(__nothrow_constructible<const _UElements...>())\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&&>(__in)) { }\n+#endif // C++23\n+\n       // Allocator-extended constructors.\n \n       template<typename _Alloc,\n@@ -897,6 +1060,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      template<typename _Alloc, typename... _UElements>\n+\trequires (sizeof...(_Elements) == sizeof...(_UElements))\n+\t  && (!__use_other_ctor<tuple<_UElements...>&>())\n+\t  && __constructible<_UElements&...>\n+\texplicit(!__convertible<_UElements&...>)\n+\tconstexpr\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      tuple<_UElements...>& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<_Tuple_impl<0, _UElements...>&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename... _UElements>\n+\trequires (sizeof...(_Elements) == sizeof...(_UElements))\n+\t  && (!__use_other_ctor<const tuple<_UElements...>>())\n+\t  && __constructible<const _UElements...>\n+\texplicit(!__convertible<const _UElements...>)\n+\tconstexpr\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const tuple<_UElements...>&& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<const _Tuple_impl<0, _UElements...>&&>(__in))\n+\t{ }\n+#endif // C++23\n+\n       // tuple assignment\n \n       _GLIBCXX20_CONSTEXPR\n@@ -941,12 +1130,57 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n+#if __cplusplus > 202002L\n+      constexpr const tuple&\n+      operator=(const tuple& __in) const\n+      requires (is_copy_assignable_v<const _Elements> && ...)\n+      {\n+\tthis->_M_assign(__in);\n+\treturn *this;\n+      }\n+\n+      constexpr const tuple&\n+      operator=(tuple&& __in) const\n+      requires (is_assignable_v<const _Elements&, _Elements> && ...)\n+      {\n+\tthis->_M_assign(std::move(__in));\n+\treturn *this;\n+      }\n+\n+      template<typename... _UElements>\n+\tconstexpr const tuple&\n+\toperator=(const tuple<_UElements...>& __in) const\n+\trequires (sizeof...(_Elements) == sizeof...(_UElements))\n+\t  && (is_assignable_v<const _Elements&, const _UElements&> && ...)\n+\t{\n+\t  this->_M_assign(__in);\n+\t  return *this;\n+\t}\n+\n+      template<typename... _UElements>\n+\tconstexpr const tuple&\n+\toperator=(tuple<_UElements...>&& __in) const\n+\trequires (sizeof...(_Elements) == sizeof...(_UElements))\n+\t  && (is_assignable_v<const _Elements&, _UElements> && ...)\n+\t{\n+\t  this->_M_assign(std::move(__in));\n+\t  return *this;\n+\t}\n+#endif // C++23\n+\n       // tuple swap\n       _GLIBCXX20_CONSTEXPR\n       void\n       swap(tuple& __in)\n       noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)\n       { _Inherited::_M_swap(__in); }\n+\n+#if __cplusplus > 202002L\n+      constexpr void\n+      swap(const tuple& __in) const\n+      noexcept(__and_v<__is_nothrow_swappable<const _Elements>...>)\n+      { _Inherited::_M_swap(__in); }\n+#endif // C++23\n     };\n \n #if __cpp_deduction_guides >= 201606\n@@ -969,6 +1203,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     public:\n       _GLIBCXX20_CONSTEXPR\n       void swap(tuple&) noexcept { /* no-op */ }\n+#if __cplusplus > 202002L\n+      constexpr void swap(const tuple&) const noexcept { /* no-op */ }\n+#endif\n       // We need the default since we're going to define no-op\n       // allocator constructors.\n       tuple() = default;\n@@ -1048,6 +1285,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstatic constexpr bool __is_alloc_arg()\n \t{ return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }\n \n+#if __cplusplus > 202002L\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool __constructible\n+\t  = _TCC<true>::template __constructible<_U1, _U2>::value;\n+\n+      template<typename _U1, typename _U2>\n+\tstatic constexpr bool __convertible\n+\t  = _TCC<true>::template __convertible<_U1, _U2>::value;\n+#endif // C++23\n+\n     public:\n       template<bool _Dummy = true,\n \t       _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>\n@@ -1123,6 +1370,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tnoexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n \n+#if __cplusplus > 202002L\n+      template<typename _U1, typename _U2>\n+\trequires __constructible<_U1&, _U2&>\n+\texplicit(!__convertible<_U1&, _U2&>)\n+\tconstexpr\n+\ttuple(tuple<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_constructible<_U1&, _U2&>())\n+\t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&>(__in)) { }\n+\n+      template<typename _U1, typename _U2>\n+\trequires __constructible<const _U1, const _U2>\n+\texplicit(!__convertible<const _U1, const _U2>)\n+\tconstexpr\n+\ttuple(const tuple<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_constructible<const _U1, const _U2>())\n+\t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n+#endif // C++23\n+\n       template<typename _U1, typename _U2,\n \t       _ImplicitCtor<true, const _U1&, const _U2&> = true>\n \tconstexpr\n@@ -1153,6 +1418,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n+#if __cplusplus > 202002L\n+      template<typename _U1, typename _U2>\n+\trequires __constructible<_U1&, _U2&>\n+\texplicit(!__convertible<_U1&, _U2&>)\n+\tconstexpr\n+\ttuple(pair<_U1, _U2>& __in)\n+\tnoexcept(__nothrow_constructible<_U1&, _U2&>())\n+\t: _Inherited(__in.first, __in.second) { }\n+\n+      template<typename _U1, typename _U2>\n+\trequires __constructible<const _U1, const _U2>\n+\texplicit(!__convertible<const _U1, const _U2>)\n+\tconstexpr\n+\ttuple(const pair<_U1, _U2>&& __in)\n+\tnoexcept(__nothrow_constructible<const _U1, const _U2>())\n+\t: _Inherited(std::forward<const _U1>(__in.first),\n+\t\t     std::forward<const _U2>(__in.second)) { }\n+#endif // C++23\n+\n       // Allocator-extended constructors.\n \n       template<typename _Alloc,\n@@ -1236,6 +1520,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))\n \t{ }\n \n+#if __cplusplus > 202002L\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\trequires __constructible<_U1&, _U2&>\n+\texplicit(!__convertible<_U1&, _U2&>)\n+\tconstexpr\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      tuple<_U1, _U2>& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<_Tuple_impl<0, _U1, _U2>&>(__in))\n+\t{ }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\trequires __constructible<const _U1, const _U2>\n+\texplicit(!__convertible<const _U1, const _U2>)\n+\tconstexpr\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      const tuple<_U1, _U2>&& __in)\n+\t: _Inherited(__tag, __a,\n+\t             static_cast<const _Tuple_impl<0, _U1, _U2>&&>(__in))\n+\t{ }\n+#endif // C++23\n+\n       template<typename _Alloc, typename _U1, typename _U2,\n \t       _ImplicitCtor<true, const _U1&, const _U2&> = true>\n \t_GLIBCXX20_CONSTEXPR\n@@ -1266,6 +1572,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _Inherited(__tag, __a, std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n+#if __cplusplus > 202002L\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\trequires __constructible<_U1&, _U2&>\n+\texplicit(!__convertible<_U1&, _U2&>)\n+\tconstexpr\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a,\n+\t      pair<_U1, _U2>& __in)\n+\t: _Inherited(__tag, __a, __in.first, __in.second) { }\n+\n+      template<typename _Alloc, typename _U1, typename _U2>\n+\trequires __constructible<const _U1, const _U2>\n+\texplicit(!__convertible<const _U1, const _U2>)\n+\tconstexpr\n+\ttuple(allocator_arg_t __tag, const _Alloc& __a, const pair<_U1, _U2>&& __in)\n+\t: _Inherited(__tag, __a, std::forward<const _U1>(__in.first),\n+\t\t     std::forward<const _U2>(__in.second)) { }\n+#endif // C++23\n+\n       // Tuple assignment.\n \n       _GLIBCXX20_CONSTEXPR\n@@ -1310,6 +1634,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n+#if __cplusplus > 202002L\n+      constexpr const tuple&\n+      operator=(const tuple& __in) const\n+      requires is_copy_assignable_v<const _T1> && is_copy_assignable_v<const _T2>\n+      {\n+\tthis->_M_assign(__in);\n+\treturn *this;\n+      }\n+\n+      constexpr const tuple&\n+      operator=(tuple&& __in) const\n+      requires is_assignable_v<const _T1&, _T1> && is_assignable_v<const _T2, _T2>\n+      {\n+\tthis->_M_assign(std::move(__in));\n+\treturn *this;\n+      }\n+\n+      template<typename _U1, typename _U2>\n+\tconstexpr const tuple&\n+\toperator=(const tuple<_U1, _U2>& __in) const\n+\trequires is_assignable_v<const _T1&, const _U1&>\n+\t  && is_assignable_v<const _T2&, const _U2&>\n+\t{\n+\t  this->_M_assign(__in);\n+\t  return *this;\n+\t}\n+\n+      template<typename _U1, typename _U2>\n+\tconstexpr const tuple&\n+\toperator=(tuple<_U1, _U2>&& __in) const\n+\trequires is_assignable_v<const _T1&, _U1>\n+\t  && is_assignable_v<const _T2&, _U2>\n+\t{\n+\t  this->_M_assign(std::move(__in));\n+\t  return *this;\n+\t}\n+#endif // C++23\n+\n       template<typename _U1, typename _U2>\n \t_GLIBCXX20_CONSTEXPR\n \t__enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>\n@@ -1332,12 +1694,44 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return *this;\n \t}\n \n+#if __cplusplus > 202002L\n+      template<typename _U1, typename _U2>\n+\tconstexpr const tuple&\n+\toperator=(const pair<_U1, _U2>& __in) const\n+\trequires is_assignable_v<const _T1&, const _U1&>\n+\t  && is_assignable_v<const _T2&, const _U2&>\n+\t{\n+\t  this->_M_head(*this) = __in.first;\n+\t  this->_M_tail(*this)._M_head(*this) = __in.second;\n+\t  return *this;\n+\t}\n+\n+      template<typename _U1, typename _U2>\n+\tconstexpr const tuple&\n+\toperator=(pair<_U1, _U2>&& __in) const\n+\trequires is_assignable_v<const _T1&, _U1>\n+\t  && is_assignable_v<const _T2&, _U2>\n+\t{\n+\t  this->_M_head(*this) = std::forward<_U1>(__in.first);\n+\t  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);\n+\t  return *this;\n+\t}\n+#endif // C++23\n+\n       _GLIBCXX20_CONSTEXPR\n       void\n       swap(tuple& __in)\n       noexcept(__and_<__is_nothrow_swappable<_T1>,\n \t\t      __is_nothrow_swappable<_T2>>::value)\n       { _Inherited::_M_swap(__in); }\n+\n+#if __cplusplus > 202002L\n+      constexpr void\n+      swap(const tuple& __in) const\n+      noexcept(__and_v<__is_nothrow_swappable<const _T1>,\n+\t\t       __is_nothrow_swappable<const _T2>>)\n+      { _Inherited::_M_swap(__in); }\n+#endif // C++23\n     };\n \n \n@@ -1765,6 +2159,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     noexcept(noexcept(__x.swap(__y)))\n     { __x.swap(__y); }\n \n+#if __cplusplus > 202002L\n+  template<typename... _Elements>\n+    requires (is_swappable_v<const _Elements> && ...)\n+    constexpr void\n+    swap(const tuple<_Elements...>& __x, const tuple<_Elements...>& __y)\n+    noexcept(noexcept(__x.swap(__y)))\n+    { __x.swap(__y); }\n+#endif // C++23\n+\n #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n   template<typename... _Elements>\n     _GLIBCXX20_CONSTEXPR\n@@ -1889,6 +2292,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n #endif // C++17\n \n+#if __cplusplus > 202002L\n+  template<typename... _TTypes, typename... _UTypes,\n+\t   template<typename> class TQual, template<typename> class UQual>\n+    requires requires { typename tuple<common_reference_t<TQual<_TTypes>, UQual<_UTypes>>...>; }\n+  struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, TQual, UQual>\n+  { using type = tuple<common_reference_t<TQual<_TTypes>, UQual<_UTypes>>...>; };\n+\n+  template<typename... _TTypes, typename... _UTypes>\n+    requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }\n+  struct common_type<tuple<_TTypes...>, tuple<_UTypes...>>\n+  { using type = tuple<common_type_t<_TTypes, _UTypes>...>; };\n+#endif // C++23\n+\n   /// @}\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "4f436ee03d61f899a4381db06ae223c2c5d02147", "filename": "libstdc++-v3/testsuite/20_util/pair/p2321r2.cc", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fp2321r2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fp2321r2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fp2321r2.cc?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -0,0 +1,208 @@\n+// Verify P2321R2 \"zip\" enhancements to std::pair.\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <utility>\n+#include <testsuite_hooks.h>\n+\n+using std::pair;\n+\n+struct A { };\n+\n+constexpr bool\n+test01()\n+{\n+  struct B { bool v; constexpr B(A&) : v(true) { } };\n+\n+  // template<class U1, class U2>\n+  //   constexpr explicit(false) pair(pair<U1, U2>&);\n+\n+  pair<A, int> p2a0;\n+  pair<B, int> p2b0 = p2a0;\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  pair<int, A> p2a1;\n+  pair<int, B> p2b1 = p2a1;\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  struct B { bool v; explicit constexpr B(A&) : v(true) { } };\n+\n+  // template<class U1, class U2>\n+  //   constexpr explicit(true) pair(pair<U1, U2>&);\n+\n+  static_assert(!std::is_convertible_v<pair<A, int>&, pair<B, int>>);\n+  static_assert(!std::is_convertible_v<pair<int, A>&, pair<int, B>>);\n+\n+  pair<A, int> p2a0;\n+  pair<B, int> p2b0(p2a0);\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  pair<int, A> p2a1;\n+  pair<int, B> p2b1(p2a1);\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  struct B { bool v; constexpr B(const A&&) : v(true) { } };\n+\n+  // template<class U1, class U2>\n+  //   constexpr explicit(false) pair(const pair<U1, U2>&&);\n+\n+  const pair<A, int> p2a0;\n+  pair<B, int> p2b0 = std::move(p2a0);\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  const pair<int, A> p2a1;\n+  pair<int, B> p2b1 = std::move(p2a1);\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  struct B { bool v; explicit constexpr B(const A&&) : v(true) { } };\n+\n+  // template<class U1, class U2>\n+  //   constexpr explicit(true) pair(const pair<U1, U2>&&);\n+\n+  static_assert(!std::is_convertible_v<const pair<A, int>&&, pair<B, int>>);\n+  static_assert(!std::is_convertible_v<const pair<int, A>&&, pair<int, B>>);\n+\n+  const pair<A, int> p2a0;\n+  pair<B, int> p2b0(std::move(p2a0));\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  const pair<int, A> p2a1;\n+  pair<int, B> p2b1(std::move(p2a1));\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test05()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(const A&) const { v = true; return *this; }\n+  };\n+\n+  // template<class U1, class U2>\n+  //   constexpr const pair& operator=(const pair<U1, U2>&) const;\n+\n+  const pair<A, A> p2a;\n+  const pair<B, B> p2b;\n+  p2b = p2a;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test06()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(A&&) const { v = true; return *this; }\n+  };\n+\n+  // template<class U1, class U2>\n+  //   constexpr const pair& operator=(pair<U1, U2>&&) const;\n+\n+  pair<A, A> p2a;\n+  const pair<B, B> p2b;\n+  p2b = std::move(p2a);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test07()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(const B&) const { v = true; return *this; }\n+  };\n+\n+  // constexpr const pair& operator=(const pair&) const;\n+\n+  const pair<B, B> t2a;\n+  const pair<B, B> t2b;\n+  t2b = t2a;\n+  VERIFY( std::get<0>(t2b).v );\n+  VERIFY( std::get<1>(t2b).v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test08()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(B&&) const { v = true; return *this; }\n+  };\n+\n+  // constexpr const pair& operator=(pair&&) const;\n+\n+  pair<B, B> t2a;\n+  const pair<B, B> t2b;\n+  t2b = std::move(t2a);\n+  VERIFY( std::get<0>(t2b).v );\n+  VERIFY( std::get<1>(t2b).v );\n+\n+  return true;\n+}\n+\n+struct S\n+{\n+  mutable int v = 0;\n+  friend constexpr void swap(S&& x, S&& y) = delete;\n+  friend constexpr void swap(const S& x, const S& y) { ++x.v; ++y.v; }\n+};\n+\n+constexpr bool\n+test09()\n+{\n+  const pair<S, S> t2, u2;\n+  std::swap(t2, u2);\n+  VERIFY( std::get<0>(t2).v == 1 );\n+  VERIFY( std::get<0>(u2).v == 1 );\n+  VERIFY( std::get<1>(t2).v == 1 );\n+  VERIFY( std::get<1>(u2).v == 1 );\n+\n+  static_assert(!std::is_swappable_v<const pair<A, int>&>);\n+  static_assert(!std::is_swappable_v<const pair<int, A>&>);\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+  static_assert(test03());\n+  static_assert(test04());\n+  // FIXME: G++ doesn't support reading mutable members during constexpr (PR c++/92505).\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n+}"}, {"sha": "80fc23cf9d4d43e47d6ec2902e47343bf64c9323", "filename": "libstdc++-v3/testsuite/20_util/tuple/p2321r2.cc", "status": "added", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fp2321r2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fp2321r2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fp2321r2.cc?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -0,0 +1,664 @@\n+// Verify P2321R2 \"zip\" enhancements to std::tuple.\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <tuple>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+using std::tuple;\n+using std::pair;\n+using std::allocator;\n+using std::allocator_arg_t;\n+using std::allocator_arg;\n+\n+namespace alloc {\n+  struct B01;\n+  struct B02;\n+  struct B03;\n+  struct B04;\n+}\n+\n+template<> struct std::uses_allocator<alloc::B01, allocator<int>> : std::true_type { };\n+template<> struct std::uses_allocator<alloc::B02, allocator<int>> : std::true_type { };\n+template<> struct std::uses_allocator<alloc::B03, allocator<int>> : std::true_type { };\n+template<> struct std::uses_allocator<alloc::B04, allocator<int>> : std::true_type { };\n+\n+struct A { };\n+\n+constexpr bool\n+test01()\n+{\n+  struct B { bool v; constexpr B(A&) : v(true) { } };\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(false) tuple(tuple<UTypes...>&);\n+\n+  tuple<A> t1a;\n+  tuple<B> t1b = t1a;\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  tuple<A, int> t2a0;\n+  tuple<B, int> t2b0 = t2a0;\n+  VERIFY( std::get<0>(t2b0).v );\n+\n+  tuple<int, A> t2a1;\n+  tuple<int, B> t2b1 = t2a1;\n+  VERIFY( std::get<1>(t2b1).v );\n+\n+  tuple<A, int, int> t3a0;\n+  tuple<B, int, int> t3b0 = t3a0;\n+  VERIFY( std::get<0>(t3b0).v );\n+\n+  tuple<int, A, int> t3a1;\n+  tuple<int, B, int> t3b1 = t3a1;\n+  VERIFY( std::get<1>(t3b1).v );\n+\n+  tuple<int, int, A> t3a2;\n+  tuple<int, int, B> t3b2 = t3a2;\n+  VERIFY( std::get<2>(t3b2).v );\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(false) tuple(pair<UTypes...>&);\n+\n+  pair<A, int> p2a0;\n+  tuple<B, int> p2b0 = p2a0;\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  pair<int, A> p2a1;\n+  tuple<int, B> p2b1 = p2a1;\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+namespace alloc\n+{\n+  struct B01\n+  {\n+    bool v;\n+    B01(A&);\n+    constexpr B01(allocator_arg_t, allocator<int>, A&) : v(true) { }\n+  };\n+\n+  constexpr bool\n+  test01()\n+  {\n+    using B = B01;\n+\n+    // template<class Alloc, class... UTypes>\n+    //   constexpr explicit(false)\n+    //     tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);\n+\n+    tuple<A> t1a;\n+    tuple<B> t1b = {allocator_arg, allocator<int>{}, t1a};\n+    VERIFY( std::get<0>(t1b).v );\n+\n+    tuple<A, int> t2a0;\n+    tuple<B, int> t2b0 = {allocator_arg, allocator<int>{}, t2a0};\n+    VERIFY( std::get<0>(t2b0).v );\n+\n+    tuple<int, A> t2a1;\n+    tuple<int, B> t2b1 = {allocator_arg, allocator<int>{}, t2a1};\n+    VERIFY( std::get<1>(t2b1).v );\n+\n+    tuple<A, int, int> t3a0;\n+    tuple<B, int, int> t3b0 = {allocator_arg, allocator<int>{}, t3a0};\n+    VERIFY( std::get<0>(t3b0).v );\n+\n+    tuple<int, A, int> t3a1;\n+    tuple<int, B, int> t3b1 = {allocator_arg, allocator<int>{}, t3a1};\n+    VERIFY( std::get<1>(t3b1).v );\n+\n+    tuple<int, int, A> t3a2;\n+    tuple<int, int, B> t3b2 = {allocator_arg, allocator<int>{}, t3a2};\n+    VERIFY( std::get<2>(t3b2).v );\n+\n+    // template<class Alloc, class U1, class U2>\n+    //   constexpr explicit(false)\n+    //     tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);\n+\n+    pair<A, int> p2a0;\n+    tuple<B, int> p2b0 = {allocator_arg, allocator<int>{}, p2a0};\n+    VERIFY( std::get<0>(p2b0).v );\n+\n+    pair<int, A> p2a1;\n+    tuple<int, B> p2b1 = {allocator_arg, allocator<int>{}, p2a1};\n+    VERIFY( std::get<1>(p2b1).v );\n+\n+    return true;\n+  }\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  struct B { bool v; explicit constexpr B(A&) : v(true) { } };\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(true) tuple(tuple<UTypes...>&);\n+\n+  static_assert(!std::is_convertible_v<tuple<A>&, tuple<B>>);\n+\n+  tuple<A> t1a;\n+  tuple<B> t1b(t1a);\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  static_assert(!std::is_convertible_v<tuple<A, int>&, tuple<B, int>>);\n+  static_assert(!std::is_convertible_v<tuple<int, A>&, tuple<int, B>>);\n+\n+  tuple<A, int> t2a0;\n+  tuple<B, int> t2b0(t2a0);\n+  VERIFY( std::get<0>(t2b0).v );\n+\n+  tuple<int, A> t2a1;\n+  tuple<int, B> t2b1(t2a1);\n+  VERIFY( std::get<1>(t2b1).v );\n+\n+  static_assert(!std::is_convertible_v<tuple<A, int, int>&, tuple<B, int, int>>);\n+  static_assert(!std::is_convertible_v<tuple<int, A, int>&, tuple<int, B, int>>);\n+  static_assert(!std::is_convertible_v<tuple<int, int, A>&, tuple<int, int, B>>);\n+\n+  tuple<A, int, int> t3a0;\n+  tuple<B, int, int> t3b0(t3a0);\n+  VERIFY( std::get<0>(t3b0).v );\n+\n+  tuple<int, A, int> t3a1;\n+  tuple<int, B, int> t3b1(t3a1);\n+  VERIFY( std::get<1>(t3b1).v );\n+\n+  tuple<int, int, A> t3a2;\n+  tuple<int, int, B> t3b2(t3a2);\n+  VERIFY( std::get<2>(t3b2).v );\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(true) tuple(pair<UTypes...>&);\n+\n+  static_assert(!std::is_convertible_v<pair<A, int>&, tuple<B, int>>);\n+  static_assert(!std::is_convertible_v<pair<int, A>&, tuple<int, B>>);\n+\n+  pair<A, int> p2a0;\n+  tuple<B, int> p2b0(p2a0);\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  pair<int, A> p2a1;\n+  tuple<int, B> p2b1(p2a1);\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+namespace alloc\n+{\n+  struct B02\n+  {\n+    bool v;\n+    explicit B02(A&);\n+    explicit constexpr B02(allocator_arg_t, allocator<int>, A&) : v(true) { }\n+  };\n+\n+  constexpr bool\n+  test02()\n+  {\n+    using B = B02;\n+\n+    // template<class Alloc, class... UTypes>\n+    //   constexpr explicit(true)\n+    //     tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);\n+\n+    tuple<A> t1a;\n+    tuple<B> t1b(allocator_arg, allocator<int>{}, t1a);\n+    VERIFY( std::get<0>(t1b).v );\n+\n+    tuple<A, int> t2a0;\n+    tuple<B, int> t2b0(allocator_arg, allocator<int>{}, t2a0);\n+    VERIFY( std::get<0>(t2b0).v );\n+\n+    tuple<int, A> t2a1;\n+    tuple<int, B> t2b1(allocator_arg, allocator<int>{}, t2a1);\n+    VERIFY( std::get<1>(t2b1).v );\n+\n+    tuple<A, int, int> t3a0;\n+    tuple<B, int, int> t3b0(allocator_arg, allocator<int>{}, t3a0);\n+    VERIFY( std::get<0>(t3b0).v );\n+\n+    tuple<int, A, int> t3a1;\n+    tuple<int, B, int> t3b1(allocator_arg, allocator<int>{}, t3a1);\n+    VERIFY( std::get<1>(t3b1).v );\n+\n+    tuple<int, int, A> t3a2;\n+    tuple<int, int, B> t3b2(allocator_arg, allocator<int>{}, t3a2);\n+    VERIFY( std::get<2>(t3b2).v );\n+\n+    // template<class Alloc, class U1, class U2>\n+    //   constexpr explicit(true)\n+    //     tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);\n+\n+    pair<A, int> p2a0;\n+    tuple<B, int> p2b0(allocator_arg, allocator<int>{}, p2a0);\n+    VERIFY( std::get<0>(p2b0).v );\n+\n+    pair<int, A> p2a1;\n+    tuple<int, B> p2b1(allocator_arg, allocator<int>{}, p2a1);\n+    VERIFY( std::get<1>(p2b1).v );\n+\n+    return true;\n+  }\n+} // namespace alloc\n+\n+constexpr bool\n+test03()\n+{\n+  struct B { bool v; constexpr B(const A&&) : v(true) { } };\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(false) tuple(const tuple<UTypes...>&&);\n+\n+  const tuple<A> t1a;\n+  tuple<B> t1b = std::move(t1a);\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  const tuple<A, int> t2a0;\n+  tuple<B, int> t2b0 = std::move(t2a0);\n+  VERIFY( std::get<0>(t2b0).v );\n+\n+  const tuple<int, A> t2a1;\n+  tuple<int, B> t2b1 = std::move(t2a1);\n+  VERIFY( std::get<1>(t2b1).v );\n+\n+  const tuple<A, int, int> t3a0;\n+  tuple<B, int, int> t3b0 = std::move(t3a0);\n+  VERIFY( std::get<0>(t3b0).v );\n+\n+  const tuple<int, A, int> t3a1;\n+  tuple<int, B, int> t3b1 = std::move(t3a1);\n+  VERIFY( std::get<1>(t3b1).v );\n+\n+  const tuple<int, int, A> t3a2;\n+  tuple<int, int, B> t3b2 = std::move(t3a2);\n+  VERIFY( std::get<2>(t3b2).v );\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(false) tuple(const pair<UTypes...>&&);\n+\n+  const pair<A, int> p2a0;\n+  tuple<B, int> p2b0 = std::move(p2a0);\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  const pair<int, A> p2a1;\n+  tuple<int, B> p2b1 = std::move(p2a1);\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+namespace alloc\n+{\n+  struct B03\n+  {\n+    bool v;\n+    B03(const A&&);\n+    constexpr B03(allocator_arg_t, allocator<int>, const A&&) : v(true) { }\n+  };\n+\n+  constexpr bool\n+  test03()\n+  {\n+    using B = B03;\n+\n+    // template<class Alloc, class... UTypes>\n+    //   constexpr explicit(false)\n+    //     tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);\n+\n+    const tuple<A> t1a;\n+    tuple<B> t1b = {allocator_arg, allocator<int>{}, std::move(t1a)};\n+    VERIFY( std::get<0>(t1b).v );\n+\n+    const tuple<A, int> t2a0;\n+    tuple<B, int> t2b0 = {allocator_arg, allocator<int>{}, std::move(t2a0)};\n+    VERIFY( std::get<0>(t2b0).v );\n+\n+    const tuple<int, A> t2a1;\n+    tuple<int, B> t2b1 = {allocator_arg, allocator<int>{}, std::move(t2a1)};\n+    VERIFY( std::get<1>(t2b1).v );\n+\n+    const tuple<A, int, int> t3a0;\n+    tuple<B, int, int> t3b0 = {allocator_arg, allocator<int>{}, std::move(t3a0)};\n+    VERIFY( std::get<0>(t3b0).v );\n+\n+    const tuple<int, A, int> t3a1;\n+    tuple<int, B, int> t3b1 = {allocator_arg, allocator<int>{}, std::move(t3a1)};\n+    VERIFY( std::get<1>(t3b1).v );\n+\n+    const tuple<int, int, A> t3a2;\n+    tuple<int, int, B> t3b2 = {allocator_arg, allocator<int>{}, std::move(t3a2)};\n+    VERIFY( std::get<2>(t3b2).v );\n+\n+    // template<class Alloc, class U1, class U2>\n+    //   constexpr explicit(false)\n+    //     tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);\n+\n+    const pair<A, int> p2a0;\n+    tuple<B, int> p2b0 = {allocator_arg, allocator<int>{}, std::move(p2a0)};\n+    VERIFY( std::get<0>(p2b0).v );\n+\n+    const pair<int, A> p2a1;\n+    tuple<int, B> p2b1 = {allocator_arg, allocator<int>{}, std::move(p2a1)};\n+    VERIFY( std::get<1>(p2b1).v );\n+\n+    return true;\n+  }\n+};\n+\n+constexpr bool\n+test04()\n+{\n+  struct B { bool v; explicit constexpr B(const A&&) : v(true) { } };\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(true) tuple(const tuple<UTypes...>&&);\n+\n+  static_assert(!std::is_convertible_v<tuple<A>&, tuple<B>>);\n+\n+  const tuple<A> t1a;\n+  tuple<B> t1b(std::move(t1a));\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  static_assert(!std::is_convertible_v<tuple<A, int>&, tuple<B, int>>);\n+  static_assert(!std::is_convertible_v<tuple<int, A>&, tuple<int, B>>);\n+\n+  const tuple<A, int> t2a0;\n+  tuple<B, int> t2b0(std::move(t2a0));\n+  VERIFY( std::get<0>(t2b0).v );\n+\n+  const tuple<int, A> t2a1;\n+  tuple<int, B> t2b1(std::move(t2a1));\n+  VERIFY( std::get<1>(t2b1).v );\n+\n+  static_assert(!std::is_convertible_v<tuple<A, int, int>&, tuple<B, int, int>>);\n+  static_assert(!std::is_convertible_v<tuple<int, A, int>&, tuple<int, B, int>>);\n+  static_assert(!std::is_convertible_v<tuple<int, int, A>&, tuple<int, int, B>>);\n+\n+  const tuple<A, int, int> t3a0;\n+  tuple<B, int, int> t3b0(std::move(t3a0));\n+  VERIFY( std::get<0>(t3b0).v );\n+\n+  const tuple<int, A, int> t3a1;\n+  tuple<int, B, int> t3b1(std::move(t3a1));\n+  VERIFY( std::get<1>(t3b1).v );\n+\n+  const tuple<int, int, A> t3a2;\n+  tuple<int, int, B> t3b2(std::move(t3a2));\n+  VERIFY( std::get<2>(t3b2).v );\n+\n+  // template<class... UTypes>\n+  //   constexpr explicit(true) tuple(const pair<UTypes...>&&);\n+\n+  static_assert(!std::is_convertible_v<pair<A, int>&, tuple<B, int>>);\n+  static_assert(!std::is_convertible_v<pair<int, A>&, tuple<int, B>>);\n+\n+  const pair<A, int> p2a0;\n+  tuple<B, int> p2b0(std::move(p2a0));\n+  VERIFY( std::get<0>(p2b0).v );\n+\n+  const pair<int, A> p2a1;\n+  tuple<int, B> p2b1(std::move(p2a1));\n+  VERIFY( std::get<1>(p2b1).v );\n+\n+  return true;\n+}\n+\n+namespace alloc\n+{\n+  struct B04\n+  {\n+    bool v;\n+    explicit B04(const A&&);\n+    explicit constexpr B04(allocator_arg_t, allocator<int>, const A&&) : v(true) { }\n+  };\n+\n+  constexpr bool\n+  test04()\n+  {\n+    using B = B04;\n+\n+    // template<class Alloc, class... UTypes>\n+    //   constexpr explicit(true)\n+    //     tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);\n+\n+    const tuple<A> t1a;\n+    tuple<B> t1b(allocator_arg, allocator<int>{}, std::move(t1a));\n+    VERIFY( std::get<0>(t1b).v );\n+\n+    const tuple<A, int> t2a0;\n+    tuple<B, int> t2b0(allocator_arg, allocator<int>{}, std::move(t2a0));\n+    VERIFY( std::get<0>(t2b0).v );\n+\n+    const tuple<int, A> t2a1;\n+    tuple<int, B> t2b1(allocator_arg, allocator<int>{}, std::move(t2a1));\n+    VERIFY( std::get<1>(t2b1).v );\n+\n+    const tuple<A, int, int> t3a0;\n+    tuple<B, int, int> t3b0(allocator_arg, allocator<int>{}, std::move(t3a0));\n+    VERIFY( std::get<0>(t3b0).v );\n+\n+    const tuple<int, A, int> t3a1;\n+    tuple<int, B, int> t3b1(allocator_arg, allocator<int>{}, std::move(t3a1));\n+    VERIFY( std::get<1>(t3b1).v );\n+\n+    const tuple<int, int, A> t3a2;\n+    tuple<int, int, B> t3b2(allocator_arg, allocator<int>{}, std::move(t3a2));\n+    VERIFY( std::get<2>(t3b2).v );\n+\n+    // template<class Alloc, class U1, class U2>\n+    //   constexpr explicit(true)\n+    //     tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);\n+\n+    tuple<B, int> p2b0(allocator_arg, allocator<int>{}, std::move(t2a0));\n+    VERIFY( std::get<0>(p2b0).v );\n+\n+    tuple<int, B> p2b1(allocator_arg, allocator<int>{}, std::move(t2a1));\n+    VERIFY( std::get<1>(p2b1).v );\n+\n+    return true;\n+  }\n+};\n+\n+constexpr bool\n+test05()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(const A&) const { v = true; return *this; }\n+  };\n+\n+  // template<class... UTypes>\n+  //   constexpr const tuple& operator=(const tuple<UTypes...>&) const;\n+\n+  const tuple<A> t1a;\n+  const tuple<B> t1b;\n+  t1b = t1a;\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  const tuple<A, A> t2a;\n+  const tuple<B, B> t2b;\n+  t2b = t2a;\n+  VERIFY( std::get<0>(t2b).v );\n+  VERIFY( std::get<1>(t2b).v );\n+\n+  const tuple<A, A, A> t3a;\n+  const tuple<B, B, B> t3b;\n+  t3b = t3a;\n+  VERIFY( std::get<0>(t3b).v );\n+  VERIFY( std::get<1>(t3b).v );\n+  VERIFY( std::get<2>(t3b).v );\n+\n+  // template<class U1, class U2>\n+  //   constexpr const tuple& operator=(const pair<U1, U2>&) const;\n+\n+  const pair<A, A> p2a;\n+  const tuple<B, B> p2b;\n+  p2b = p2a;\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test06()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(A&&) const { v = true; return *this; }\n+  };\n+\n+  // template<class... UTypes>\n+  //   constexpr const tuple& operator=(tuple<UTypes...>&&) const;\n+\n+  tuple<A> t1a;\n+  const tuple<B> t1b;\n+  t1b = std::move(t1a);\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  tuple<A, A> t2a;\n+  const tuple<B, B> t2b;\n+  t2b = std::move(t2a);\n+  VERIFY( std::get<0>(t2b).v );\n+  VERIFY( std::get<1>(t2b).v );\n+\n+  tuple<A, A, A> t3a;\n+  const tuple<B, B, B> t3b;\n+  t3b = std::move(t3a);\n+  VERIFY( std::get<0>(t3b).v );\n+  VERIFY( std::get<1>(t3b).v );\n+  VERIFY( std::get<2>(t3b).v );\n+\n+  // template<class U1, class U2>\n+  //   constexpr const tuple& operator=(pair<U1, U2>&&) const;\n+\n+  pair<A, A> p2a;\n+  const tuple<B, B> p2b;\n+  p2b = std::move(p2a);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test07()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(const B&) const { v = true; return *this; }\n+  };\n+\n+  // constexpr const tuple& operator=(const tuple&) const;\n+\n+  const tuple<B> t1a;\n+  const tuple<B> t1b;\n+  t1b = t1a;\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  const tuple<B, B> t2a;\n+  const tuple<B, B> t2b;\n+  t2b = t2a;\n+  VERIFY( std::get<0>(t2b).v );\n+  VERIFY( std::get<1>(t2b).v );\n+\n+  const tuple<B, B, B> t3a;\n+  const tuple<B, B, B> t3b;\n+  t3b = t3a;\n+  VERIFY( std::get<0>(t3b).v );\n+  VERIFY( std::get<1>(t3b).v );\n+  VERIFY( std::get<2>(t3b).v );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test08()\n+{\n+  struct B\n+  {\n+    mutable bool v;\n+    constexpr const B& operator=(B&&) const { v = true; return *this; }\n+  };\n+\n+  // constexpr const tuple& operator=(tuple&&) const;\n+\n+  tuple<B> t1a;\n+  const tuple<B> t1b;\n+  t1b = std::move(t1a);\n+  VERIFY( std::get<0>(t1b).v );\n+\n+  tuple<B, B> t2a;\n+  const tuple<B, B> t2b;\n+  t2b = std::move(t2a);\n+  VERIFY( std::get<0>(t2b).v );\n+  VERIFY( std::get<1>(t2b).v );\n+\n+  tuple<B, B, B> t3a;\n+  const tuple<B, B, B> t3b;\n+  t3b = std::move(t3a);\n+  VERIFY( std::get<0>(t3b).v );\n+  VERIFY( std::get<1>(t3b).v );\n+  VERIFY( std::get<2>(t3b).v );\n+\n+  return true;\n+}\n+\n+struct S\n+{\n+  mutable int v = 0;\n+  friend constexpr void swap(S&& x, S&& y) = delete;\n+  friend constexpr void swap(const S& x, const S& y) { ++x.v; ++y.v; }\n+};\n+\n+constexpr bool\n+test09()\n+{\n+  const tuple<S> t1, u1;\n+  std::swap(t1, u1);\n+  VERIFY( std::get<0>(t1).v == 1 );\n+  VERIFY( std::get<0>(u1).v == 1 );\n+\n+  const tuple<S, S> t2, u2;\n+  std::swap(t2, u2);\n+  VERIFY( std::get<0>(t2).v == 1 );\n+  VERIFY( std::get<0>(u2).v == 1 );\n+  VERIFY( std::get<1>(t2).v == 1 );\n+  VERIFY( std::get<1>(u2).v == 1 );\n+\n+  const tuple<S, S, S> t3, u3;\n+  std::swap(t3, u3);\n+  VERIFY( std::get<0>(t3).v == 1 );\n+  VERIFY( std::get<0>(u3).v == 1 );\n+  VERIFY( std::get<1>(t3).v == 1 );\n+  VERIFY( std::get<1>(u3).v == 1 );\n+  VERIFY( std::get<2>(t3).v == 1 );\n+  VERIFY( std::get<2>(u3).v == 1 );\n+\n+  static_assert(!std::is_swappable_v<const tuple<A>&>);\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(alloc::test01());\n+  static_assert(test02());\n+  static_assert(alloc::test02());\n+  static_assert(test03());\n+  static_assert(alloc::test03());\n+  static_assert(test04());\n+  static_assert(alloc::test04());\n+  // FIXME: G++ doesn't support reading mutable members during constexpr (PR c++/92505).\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n+}"}, {"sha": "9016c026b336801c72bf168749c0e828246aa24b", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/element_access/1.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Felement_access%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72886fcc6269531bbf3d9a09b3d64644963bff0d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Felement_access%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Felement_access%2F1.cc?ref=72886fcc6269531bbf3d9a09b3d64644963bff0d", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+// { dg-xfail-if \"not supported\" { debug_mode } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+constexpr bool\n+test01()\n+{\n+  // P2321R2\n+  // constexpr const reference& vector<bool>::operator=(bool x) const noexcept;\n+\n+  std::vector<bool> v(1);\n+  const auto e = v[0];\n+  e = true;\n+  VERIFY( v[0] );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+}"}]}