{"sha": "5f5653148b94593632986155b4f283150c52b83d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1NjUzMTQ4Yjk0NTkzNjMyOTg2MTU1YjRmMjgzMTUwYzUyYjgzZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-31T09:52:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-31T09:52:38Z"}, "message": "[AArch64] Rename cmp_result iterator\n\nThe comparison results provided by the V_cmp_result/v_cmp_result\nattribute were simply the corresponding integer vector.  We'd also\nlike to have easy access to the integer vector for SVE, but using\n\"cmp_result\" would be confusing because SVE comparisons return\npredicates instead of vectors.  This patch therefore renames the\nattributes to the more general V_INT_EQUIV/v_int_equiv instead.\n\nAs to the capitalisation: there are already many iterators that use\nall lowercase vs. all uppercase names to distinguish all lowercase\nvs. all uppercase expansions (e.g. fcvt_target and FCVT_TARGET).\nIt's also the convention used for the built-in mode/MODE/code/CODE/etc.\nattributes.  IMO those names are easier to read at a glance, rather than\nrelying on a single letter's difference.\n\n2017-08-22  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/iterators.md (V_cmp_result): Rename to...\n\t(V_INT_EQUIV): ...this.\n\t(v_cmp_result): Rename to...\n\t(v_int_equiv): ...this.\n\t* config/aarch64/aarch64.md (xorsign<mode>3): Update accordingly.\n\t* config/aarch64/aarch64-simd.md (xorsign<mode>3): Likewise.\n\t(copysign<mode>3): Likewise.\n\t(aarch64_simd_bsl<mode>_internal): Likewise.\n\t(aarch64_simd_bsl<mode>): Likewise.\n\t(vec_cmp<mode><mode>): Likewise.\n\t(vcond<mode><mode>): Likewise.\n\t(vcond<v_cmp_mixed><mode>): Likewise.\n\t(vcondu<mode><v_cmp_mixed>): Likewise.\n\t(aarch64_cm<optab><mode>): Likewise.\n\t(aarch64_cmtst<mode>): Likewise.\n\t(aarch64_fac<optab><mode>): Likewise.\n\t(vec_perm_const<mode>): Likewise.\n\t(vcond_mask_<mode><v_cmp_result>): Rename to...\n\t(vcond_mask_<mode><v_int_equiv>): ...this.\n\t(vec_cmp<mode><v_cmp_result>): Rename to...\n\t(vec_cmp<mode><v_int_equiv>): ...this.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251556", "tree": {"sha": "09707ac100dab3e250a34d0cf6c85a73f71f008b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09707ac100dab3e250a34d0cf6c85a73f71f008b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f5653148b94593632986155b4f283150c52b83d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5653148b94593632986155b4f283150c52b83d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f5653148b94593632986155b4f283150c52b83d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f5653148b94593632986155b4f283150c52b83d/comments", "author": null, "committer": null, "parents": [{"sha": "fca7d0a4fdd5a107429f3424600cfcb24b068bac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fca7d0a4fdd5a107429f3424600cfcb24b068bac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fca7d0a4fdd5a107429f3424600cfcb24b068bac"}], "stats": {"total": 202, "additions": 114, "deletions": 88}, "files": [{"sha": "8d724510a4528ba2785d32551e909a4f9b468f0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f5653148b94593632986155b4f283150c52b83d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f5653148b94593632986155b4f283150c52b83d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f5653148b94593632986155b4f283150c52b83d", "patch": "@@ -1,3 +1,29 @@\n+2017-08-31  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/iterators.md (V_cmp_result): Rename to...\n+\t(V_INT_EQUIV): ...this.\n+\t(v_cmp_result): Rename to...\n+\t(v_int_equiv): ...this.\n+\t* config/aarch64/aarch64.md (xorsign<mode>3): Update accordingly.\n+\t* config/aarch64/aarch64-simd.md (xorsign<mode>3): Likewise.\n+\t(copysign<mode>3): Likewise.\n+\t(aarch64_simd_bsl<mode>_internal): Likewise.\n+\t(aarch64_simd_bsl<mode>): Likewise.\n+\t(vec_cmp<mode><mode>): Likewise.\n+\t(vcond<mode><mode>): Likewise.\n+\t(vcond<v_cmp_mixed><mode>): Likewise.\n+\t(vcondu<mode><v_cmp_mixed>): Likewise.\n+\t(aarch64_cm<optab><mode>): Likewise.\n+\t(aarch64_cmtst<mode>): Likewise.\n+\t(aarch64_fac<optab><mode>): Likewise.\n+\t(vec_perm_const<mode>): Likewise.\n+\t(vcond_mask_<mode><v_cmp_result>): Rename to...\n+\t(vcond_mask_<mode><v_int_equiv>): ...this.\n+\t(vec_cmp<mode><v_cmp_result>): Rename to...\n+\t(vec_cmp<mode><v_int_equiv>): ...this.\n+\n 2017-08-31  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a94c6fdabdc2bcdc8e8fcdfec70f41e87f752a17", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f5653148b94593632986155b4f283150c52b83d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f5653148b94593632986155b4f283150c52b83d/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=5f5653148b94593632986155b4f283150c52b83d", "patch": "@@ -364,7 +364,7 @@\n   \"TARGET_SIMD\"\n {\n \n-  machine_mode imode = <V_cmp_result>mode;\n+  machine_mode imode = <V_INT_EQUIV>mode;\n   rtx v_bitmask = gen_reg_rtx (imode);\n   rtx op1x = gen_reg_rtx (imode);\n   rtx op2x = gen_reg_rtx (imode);\n@@ -375,11 +375,11 @@\n   int bits = GET_MODE_UNIT_BITSIZE (<MODE>mode) - 1;\n \n   emit_move_insn (v_bitmask,\n-\t\t  aarch64_simd_gen_const_vector_dup (<V_cmp_result>mode,\n+\t\t  aarch64_simd_gen_const_vector_dup (<V_INT_EQUIV>mode,\n \t\t\t\t\t\t     HOST_WIDE_INT_M1U << bits));\n \n-  emit_insn (gen_and<v_cmp_result>3 (op2x, v_bitmask, arg2));\n-  emit_insn (gen_xor<v_cmp_result>3 (op1x, arg1, op2x));\n+  emit_insn (gen_and<v_int_equiv>3 (op2x, v_bitmask, arg2));\n+  emit_insn (gen_xor<v_int_equiv>3 (op1x, arg1, op2x));\n   emit_move_insn (operands[0],\n \t\t  lowpart_subreg (<MODE>mode, op1x, imode));\n   DONE;\n@@ -392,11 +392,11 @@\n    (match_operand:VHSDF 2 \"register_operand\")]\n   \"TARGET_FLOAT && TARGET_SIMD\"\n {\n-  rtx v_bitmask = gen_reg_rtx (<V_cmp_result>mode);\n+  rtx v_bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);\n   int bits = GET_MODE_UNIT_BITSIZE (<MODE>mode) - 1;\n \n   emit_move_insn (v_bitmask,\n-\t\t  aarch64_simd_gen_const_vector_dup (<V_cmp_result>mode,\n+\t\t  aarch64_simd_gen_const_vector_dup (<V_INT_EQUIV>mode,\n \t\t\t\t\t\t     HOST_WIDE_INT_M1U << bits));\n   emit_insn (gen_aarch64_simd_bsl<mode> (operands[0], v_bitmask,\n \t\t\t\t\t operands[2], operands[1]));\n@@ -2319,10 +2319,10 @@\n \t(xor:VSDQ_I_DI\n \t   (and:VSDQ_I_DI\n \t     (xor:VSDQ_I_DI\n-\t       (match_operand:<V_cmp_result> 3 \"register_operand\" \"w,0,w\")\n+\t       (match_operand:<V_INT_EQUIV> 3 \"register_operand\" \"w,0,w\")\n \t       (match_operand:VSDQ_I_DI 2 \"register_operand\" \"w,w,0\"))\n \t     (match_operand:VSDQ_I_DI 1 \"register_operand\" \"0,w,w\"))\n-\t  (match_dup:<V_cmp_result> 3)\n+\t  (match_dup:<V_INT_EQUIV> 3)\n \t))]\n   \"TARGET_SIMD\"\n   \"@\n@@ -2357,7 +2357,7 @@\n \n (define_expand \"aarch64_simd_bsl<mode>\"\n   [(match_operand:VALLDIF 0 \"register_operand\")\n-   (match_operand:<V_cmp_result> 1 \"register_operand\")\n+   (match_operand:<V_INT_EQUIV> 1 \"register_operand\")\n    (match_operand:VALLDIF 2 \"register_operand\")\n    (match_operand:VALLDIF 3 \"register_operand\")]\n  \"TARGET_SIMD\"\n@@ -2366,26 +2366,26 @@\n   rtx tmp = operands[0];\n   if (FLOAT_MODE_P (<MODE>mode))\n     {\n-      operands[2] = gen_lowpart (<V_cmp_result>mode, operands[2]);\n-      operands[3] = gen_lowpart (<V_cmp_result>mode, operands[3]);\n-      tmp = gen_reg_rtx (<V_cmp_result>mode);\n+      operands[2] = gen_lowpart (<V_INT_EQUIV>mode, operands[2]);\n+      operands[3] = gen_lowpart (<V_INT_EQUIV>mode, operands[3]);\n+      tmp = gen_reg_rtx (<V_INT_EQUIV>mode);\n     }\n-  operands[1] = gen_lowpart (<V_cmp_result>mode, operands[1]);\n-  emit_insn (gen_aarch64_simd_bsl<v_cmp_result>_internal (tmp,\n-\t\t\t\t\t\t\t  operands[1],\n-\t\t\t\t\t\t\t  operands[2],\n-\t\t\t\t\t\t\t  operands[3]));\n+  operands[1] = gen_lowpart (<V_INT_EQUIV>mode, operands[1]);\n+  emit_insn (gen_aarch64_simd_bsl<v_int_equiv>_internal (tmp,\n+\t\t\t\t\t\t\t operands[1],\n+\t\t\t\t\t\t\t operands[2],\n+\t\t\t\t\t\t\t operands[3]));\n   if (tmp != operands[0])\n     emit_move_insn (operands[0], gen_lowpart (<MODE>mode, tmp));\n \n   DONE;\n })\n \n-(define_expand \"vcond_mask_<mode><v_cmp_result>\"\n+(define_expand \"vcond_mask_<mode><v_int_equiv>\"\n   [(match_operand:VALLDI 0 \"register_operand\")\n    (match_operand:VALLDI 1 \"nonmemory_operand\")\n    (match_operand:VALLDI 2 \"nonmemory_operand\")\n-   (match_operand:<V_cmp_result> 3 \"register_operand\")]\n+   (match_operand:<V_INT_EQUIV> 3 \"register_operand\")]\n   \"TARGET_SIMD\"\n {\n   /* If we have (a = (P) ? -1 : 0);\n@@ -2396,7 +2396,7 @@\n   /* Similarly, (a = (P) ? 0 : -1) is just inverting the generated mask.  */\n   else if (operands[1] == CONST0_RTX (<MODE>mode)\n \t   && operands[2] == CONSTM1_RTX (<MODE>mode))\n-    emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[3]));\n+    emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[3]));\n   else\n     {\n       if (!REG_P (operands[1]))\n@@ -2478,7 +2478,7 @@\n     case NE:\n       /* Handle NE as !EQ.  */\n       emit_insn (gen_aarch64_cmeq<mode> (mask, operands[2], operands[3]));\n-      emit_insn (gen_one_cmpl<v_cmp_result>2 (mask, mask));\n+      emit_insn (gen_one_cmpl<v_int_equiv>2 (mask, mask));\n       break;\n \n     case EQ:\n@@ -2492,16 +2492,16 @@\n   DONE;\n })\n \n-(define_expand \"vec_cmp<mode><v_cmp_result>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\")\n+(define_expand \"vec_cmp<mode><v_int_equiv>\"\n+  [(set (match_operand:<V_INT_EQUIV> 0 \"register_operand\")\n \t(match_operator 1 \"comparison_operator\"\n \t    [(match_operand:VDQF 2 \"register_operand\")\n \t     (match_operand:VDQF 3 \"nonmemory_operand\")]))]\n   \"TARGET_SIMD\"\n {\n   int use_zero_form = 0;\n   enum rtx_code code = GET_CODE (operands[1]);\n-  rtx tmp = gen_reg_rtx (<V_cmp_result>mode);\n+  rtx tmp = gen_reg_rtx (<V_INT_EQUIV>mode);\n \n   rtx (*comparison) (rtx, rtx, rtx) = NULL;\n \n@@ -2587,7 +2587,7 @@\n \t a   NE b -> !(a EQ b)  */\n       gcc_assert (comparison != NULL);\n       emit_insn (comparison (operands[0], operands[2], operands[3]));\n-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));\n+      emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n       break;\n \n     case LT:\n@@ -2612,8 +2612,8 @@\n       emit_insn (gen_aarch64_cmgt<mode> (operands[0],\n \t\t\t\t\t operands[2], operands[3]));\n       emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[3], operands[2]));\n-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));\n-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));\n+      emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n+      emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n       break;\n \n     case UNORDERED:\n@@ -2622,15 +2622,15 @@\n       emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));\n       emit_insn (gen_aarch64_cmge<mode> (operands[0],\n \t\t\t\t\t operands[3], operands[2]));\n-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));\n-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));\n+      emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n+      emit_insn (gen_one_cmpl<v_int_equiv>2 (operands[0], operands[0]));\n       break;\n \n     case ORDERED:\n       emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));\n       emit_insn (gen_aarch64_cmge<mode> (operands[0],\n \t\t\t\t\t operands[3], operands[2]));\n-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));\n+      emit_insn (gen_ior<v_int_equiv>3 (operands[0], operands[0], tmp));\n       break;\n \n     default:\n@@ -2662,7 +2662,7 @@\n \t  (match_operand:VALLDI 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  rtx mask = gen_reg_rtx (<V_INT_EQUIV>mode);\n   enum rtx_code code = GET_CODE (operands[3]);\n \n   /* NE is handled as !EQ in vec_cmp patterns, we can explicitly invert\n@@ -2674,10 +2674,10 @@\n \t\t\t\t    operands[4], operands[5]);\n       std::swap (operands[1], operands[2]);\n     }\n-  emit_insn (gen_vec_cmp<mode><v_cmp_result> (mask, operands[3],\n-\t\t\t\t\t      operands[4], operands[5]));\n-  emit_insn (gen_vcond_mask_<mode><v_cmp_result> (operands[0], operands[1],\n-\t\t\t\t\t\t  operands[2], mask));\n+  emit_insn (gen_vec_cmp<mode><v_int_equiv> (mask, operands[3],\n+\t\t\t\t\t     operands[4], operands[5]));\n+  emit_insn (gen_vcond_mask_<mode><v_int_equiv> (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2], mask));\n \n   DONE;\n })\n@@ -2692,7 +2692,7 @@\n \t  (match_operand:<V_cmp_mixed> 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  rtx mask = gen_reg_rtx (<V_INT_EQUIV>mode);\n   enum rtx_code code = GET_CODE (operands[3]);\n \n   /* NE is handled as !EQ in vec_cmp patterns, we can explicitly invert\n@@ -2704,9 +2704,9 @@\n \t\t\t\t    operands[4], operands[5]);\n       std::swap (operands[1], operands[2]);\n     }\n-  emit_insn (gen_vec_cmp<mode><v_cmp_result> (mask, operands[3],\n-\t\t\t\t\t      operands[4], operands[5]));\n-  emit_insn (gen_vcond_mask_<v_cmp_mixed><v_cmp_result> (\n+  emit_insn (gen_vec_cmp<mode><v_int_equiv> (mask, operands[3],\n+\t\t\t\t\t     operands[4], operands[5]));\n+  emit_insn (gen_vcond_mask_<v_cmp_mixed><v_int_equiv> (\n \t\t\t\t\t\toperands[0], operands[1],\n \t\t\t\t\t\toperands[2], mask));\n \n@@ -2737,8 +2737,8 @@\n     }\n   emit_insn (gen_vec_cmp<mode><mode> (mask, operands[3],\n \t\t\t\t      operands[4], operands[5]));\n-  emit_insn (gen_vcond_mask_<mode><v_cmp_result> (operands[0], operands[1],\n-\t\t\t\t\t\t  operands[2], mask));\n+  emit_insn (gen_vcond_mask_<mode><v_int_equiv> (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2], mask));\n   DONE;\n })\n \n@@ -2752,7 +2752,7 @@\n \t  (match_operand:VDQF 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  rtx mask = gen_reg_rtx (<V_INT_EQUIV>mode);\n   enum rtx_code code = GET_CODE (operands[3]);\n \n   /* NE is handled as !EQ in vec_cmp patterns, we can explicitly invert\n@@ -2767,8 +2767,8 @@\n   emit_insn (gen_vec_cmp<v_cmp_mixed><v_cmp_mixed> (\n \t\t\t\t\t\t  mask, operands[3],\n \t\t\t\t\t\t  operands[4], operands[5]));\n-  emit_insn (gen_vcond_mask_<mode><v_cmp_result> (operands[0], operands[1],\n-\t\t\t\t\t\t  operands[2], mask));\n+  emit_insn (gen_vcond_mask_<mode><v_int_equiv> (operands[0], operands[1],\n+\t\t\t\t\t\t operands[2], mask));\n   DONE;\n })\n \n@@ -4208,9 +4208,9 @@\n ;; have different ideas of what should be passed to this pattern.\n \n (define_insn \"aarch64_cm<optab><mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w,w\")\n-\t(neg:<V_cmp_result>\n-\t  (COMPARISONS:<V_cmp_result>\n+  [(set (match_operand:<V_INT_EQUIV> 0 \"register_operand\" \"=w,w\")\n+\t(neg:<V_INT_EQUIV>\n+\t  (COMPARISONS:<V_INT_EQUIV>\n \t    (match_operand:VDQ_I 1 \"register_operand\" \"w,w\")\n \t    (match_operand:VDQ_I 2 \"aarch64_simd_reg_or_zero\" \"w,ZDz\")\n \t  )))]\n@@ -4273,9 +4273,9 @@\n ;; cm(hs|hi)\n \n (define_insn \"aarch64_cm<optab><mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w\")\n-\t(neg:<V_cmp_result>\n-\t  (UCOMPARISONS:<V_cmp_result>\n+  [(set (match_operand:<V_INT_EQUIV> 0 \"register_operand\" \"=w\")\n+\t(neg:<V_INT_EQUIV>\n+\t  (UCOMPARISONS:<V_INT_EQUIV>\n \t    (match_operand:VDQ_I 1 \"register_operand\" \"w\")\n \t    (match_operand:VDQ_I 2 \"register_operand\" \"w\")\n \t  )))]\n@@ -4340,14 +4340,14 @@\n ;; plus (eq (and x y) 0) -1.\n \n (define_insn \"aarch64_cmtst<mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w\")\n-\t(plus:<V_cmp_result>\n-\t  (eq:<V_cmp_result>\n+  [(set (match_operand:<V_INT_EQUIV> 0 \"register_operand\" \"=w\")\n+\t(plus:<V_INT_EQUIV>\n+\t  (eq:<V_INT_EQUIV>\n \t    (and:VDQ_I\n \t      (match_operand:VDQ_I 1 \"register_operand\" \"w\")\n \t      (match_operand:VDQ_I 2 \"register_operand\" \"w\"))\n \t    (match_operand:VDQ_I 3 \"aarch64_simd_imm_zero\"))\n-\t  (match_operand:<V_cmp_result> 4 \"aarch64_simd_imm_minus_one\")))\n+\t  (match_operand:<V_INT_EQUIV> 4 \"aarch64_simd_imm_minus_one\")))\n   ]\n   \"TARGET_SIMD\"\n   \"cmtst\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %<v>2<Vmtype>\"\n@@ -4408,9 +4408,9 @@\n ;; fcm(eq|ge|gt|le|lt)\n \n (define_insn \"aarch64_cm<optab><mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w,w\")\n-\t(neg:<V_cmp_result>\n-\t  (COMPARISONS:<V_cmp_result>\n+  [(set (match_operand:<V_INT_EQUIV> 0 \"register_operand\" \"=w,w\")\n+\t(neg:<V_INT_EQUIV>\n+\t  (COMPARISONS:<V_INT_EQUIV>\n \t    (match_operand:VHSDF_HSDF 1 \"register_operand\" \"w,w\")\n \t    (match_operand:VHSDF_HSDF 2 \"aarch64_simd_reg_or_zero\" \"w,YDz\")\n \t  )))]\n@@ -4426,9 +4426,9 @@\n ;; generating fac(ge|gt).\n \n (define_insn \"aarch64_fac<optab><mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w\")\n-\t(neg:<V_cmp_result>\n-\t  (FAC_COMPARISONS:<V_cmp_result>\n+  [(set (match_operand:<V_INT_EQUIV> 0 \"register_operand\" \"=w\")\n+\t(neg:<V_INT_EQUIV>\n+\t  (FAC_COMPARISONS:<V_INT_EQUIV>\n \t    (abs:VHSDF_HSDF\n \t      (match_operand:VHSDF_HSDF 1 \"register_operand\" \"w\"))\n \t    (abs:VHSDF_HSDF\n@@ -5130,7 +5130,7 @@\n   [(match_operand:VALL_F16 0 \"register_operand\")\n    (match_operand:VALL_F16 1 \"register_operand\")\n    (match_operand:VALL_F16 2 \"register_operand\")\n-   (match_operand:<V_cmp_result> 3)]\n+   (match_operand:<V_INT_EQUIV> 3)]\n   \"TARGET_SIMD\"\n {\n   if (aarch64_expand_vec_perm_const (operands[0], operands[1],"}, {"sha": "bb7f2c045329b378ccc9d09b2cdee9f9fa8c1459", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f5653148b94593632986155b4f283150c52b83d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f5653148b94593632986155b4f283150c52b83d/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=5f5653148b94593632986155b4f283150c52b83d", "patch": "@@ -5196,7 +5196,7 @@\n   \"TARGET_FLOAT && TARGET_SIMD\"\n {\n \n-  machine_mode imode = <V_cmp_result>mode;\n+  machine_mode imode = <V_INT_EQUIV>mode;\n   rtx mask = gen_reg_rtx (imode);\n   rtx op1x = gen_reg_rtx (imode);\n   rtx op2x = gen_reg_rtx (imode);\n@@ -5205,13 +5205,13 @@\n   emit_move_insn (mask, GEN_INT (trunc_int_for_mode (HOST_WIDE_INT_M1U << bits,\n \t\t\t\t\t\t     imode)));\n \n-  emit_insn (gen_and<v_cmp_result>3 (op2x, mask,\n-\t\t\t\t     lowpart_subreg (imode, operands[2],\n-\t\t\t\t\t\t     <MODE>mode)));\n-  emit_insn (gen_xor<v_cmp_result>3 (op1x,\n-\t\t\t\t     lowpart_subreg (imode, operands[1],\n-\t\t\t\t\t\t     <MODE>mode),\n-\t\t\t\t     op2x));\n+  emit_insn (gen_and<v_int_equiv>3 (op2x, mask,\n+\t\t\t\t    lowpart_subreg (imode, operands[2],\n+\t\t\t\t\t\t    <MODE>mode)));\n+  emit_insn (gen_xor<v_int_equiv>3 (op1x,\n+\t\t\t\t    lowpart_subreg (imode, operands[1],\n+\t\t\t\t\t\t    <MODE>mode),\n+\t\t\t\t    op2x));\n   emit_move_insn (operands[0],\n \t\t  lowpart_subreg (<MODE>mode, op1x, imode));\n   DONE;"}, {"sha": "3e387678b45a45a575825b3d95ec215b228c5fc6", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f5653148b94593632986155b4f283150c52b83d/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f5653148b94593632986155b4f283150c52b83d/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=5f5653148b94593632986155b4f283150c52b83d", "patch": "@@ -662,25 +662,25 @@\n ;; Double vector types for ALLX.\n (define_mode_attr Vallxd [(QI \"8b\") (HI \"4h\") (SI \"2s\")])\n \n-;; Mode of result of comparison operations.\n-(define_mode_attr V_cmp_result [(V8QI \"V8QI\") (V16QI \"V16QI\")\n-\t\t\t\t(V4HI \"V4HI\") (V8HI  \"V8HI\")\n-\t\t\t\t(V2SI \"V2SI\") (V4SI  \"V4SI\")\n-\t\t\t\t(DI   \"DI\")   (V2DI  \"V2DI\")\n-\t\t\t\t(V4HF \"V4HI\") (V8HF  \"V8HI\")\n-\t\t\t\t(V2SF \"V2SI\") (V4SF  \"V4SI\")\n-\t\t\t\t(V2DF \"V2DI\") (DF    \"DI\")\n-\t\t\t\t(SF   \"SI\")   (HF    \"HI\")])\n-\n-;; Lower case mode of results of comparison operations.\n-(define_mode_attr v_cmp_result [(V8QI \"v8qi\") (V16QI \"v16qi\")\n-\t\t\t\t(V4HI \"v4hi\") (V8HI  \"v8hi\")\n-\t\t\t\t(V2SI \"v2si\") (V4SI  \"v4si\")\n-\t\t\t\t(DI   \"di\")   (V2DI  \"v2di\")\n-\t\t\t\t(V4HF \"v4hi\") (V8HF  \"v8hi\")\n-\t\t\t\t(V2SF \"v2si\") (V4SF  \"v4si\")\n-\t\t\t\t(V2DF \"v2di\") (DF    \"di\")\n-\t\t\t\t(SF   \"si\")])\n+;; Mode with floating-point values replaced by like-sized integers.\n+(define_mode_attr V_INT_EQUIV [(V8QI \"V8QI\") (V16QI \"V16QI\")\n+\t\t\t       (V4HI \"V4HI\") (V8HI  \"V8HI\")\n+\t\t\t       (V2SI \"V2SI\") (V4SI  \"V4SI\")\n+\t\t\t       (DI   \"DI\")   (V2DI  \"V2DI\")\n+\t\t\t       (V4HF \"V4HI\") (V8HF  \"V8HI\")\n+\t\t\t       (V2SF \"V2SI\") (V4SF  \"V4SI\")\n+\t\t\t       (V2DF \"V2DI\") (DF    \"DI\")\n+\t\t\t       (SF   \"SI\")   (HF    \"HI\")])\n+\n+;; Lower case mode with floating-point values replaced by like-sized integers.\n+(define_mode_attr v_int_equiv [(V8QI \"v8qi\") (V16QI \"v16qi\")\n+\t\t\t       (V4HI \"v4hi\") (V8HI  \"v8hi\")\n+\t\t\t       (V2SI \"v2si\") (V4SI  \"v4si\")\n+\t\t\t       (DI   \"di\")   (V2DI  \"v2di\")\n+\t\t\t       (V4HF \"v4hi\") (V8HF  \"v8hi\")\n+\t\t\t       (V2SF \"v2si\") (V4SF  \"v4si\")\n+\t\t\t       (V2DF \"v2di\") (DF    \"di\")\n+\t\t\t       (SF   \"si\")])\n \n ;; Mode for vector conditional operations where the comparison has\n ;; different type from the lhs."}]}