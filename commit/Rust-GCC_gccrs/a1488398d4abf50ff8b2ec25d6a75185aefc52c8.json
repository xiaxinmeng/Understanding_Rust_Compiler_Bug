{"sha": "a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE0ODgzOThkNGFiZjUwZmY4YjJlYzI1ZDZhNzUxODVhZWZjNTJjOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-02T09:45:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-02T09:45:40Z"}, "message": "Fix mismatched precisions in tree arithmetic\n\nThe tree wi:: decompose routine wasn't asserting that the requested\nprecision matched the tree's precision.  This could make a difference\nfor unsigned trees that are exactly N HWIs wide and that have the upper\nbit set, since we then need an extra zero HWI when extending it to wider\nprecisions (as for wi::to_widest).\n\nThis patch adds the assert and fixes the fallout shown by the testsuite.\nGo seems to be unaffected.\n\n2017-10-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree.h (wi::int_traits <const_tree>::decompose): Assert that the\n\trequested precision matches the type's.\n\t* calls.c (alloc_max_size): Calculate the new candidate size as\n\ta widest_int and use wi::to_widest when comparing it with the\n\tcurrent candidate size.\n\t* gimple-ssa-warn-alloca.c (pass_walloca::execute): Compare with\n\tzero rather than integer_zero_node.\n\t* match.pd: Check for a no-op conversion before using wi::add\n\trather than after.  Use tree_to_uhwi when summing small shift\n\tcounts into an unsigned int.\n\ngcc/c-family/\n\t* c-warn.c (warn_tautological_bitwise_comparison): Use wi::to_widest\n\twhen combining the original unconverted comparison operands.\n\ngcc/cp/\n\t* constexpr.c (cxx_eval_store_expression): Use wi::to_widest\n\twhen comparing the array bounds with an ARRAY_REF index.\n\ngcc/ada/\n\t* gcc-interface/decl.c (annotate_value): Use wi::to_widest when\n\thandling the form (plus/mult (convert @0) @1).\n\nFrom-SVN: r253341", "tree": {"sha": "e5cca47aca114b176833f91da6a74b6829051ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5cca47aca114b176833f91da6a74b6829051ce5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/comments", "author": null, "committer": null, "parents": [{"sha": "1a6da556c414bbbec6df82fdb342e8b84e205507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a6da556c414bbbec6df82fdb342e8b84e205507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a6da556c414bbbec6df82fdb342e8b84e205507"}], "stats": {"total": 65, "additions": 49, "deletions": 16}, "files": [{"sha": "822afa0c88dc1091290ec3b08a6cd8e22b66374e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -1,3 +1,16 @@\n+2017-10-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree.h (wi::int_traits <const_tree>::decompose): Assert that the\n+\trequested precision matches the type's.\n+\t* calls.c (alloc_max_size): Calculate the new candidate size as\n+\ta widest_int and use wi::to_widest when comparing it with the\n+\tcurrent candidate size.\n+\t* gimple-ssa-warn-alloca.c (pass_walloca::execute): Compare with\n+\tzero rather than integer_zero_node.\n+\t* match.pd: Check for a no-op conversion before using wi::add\n+\trather than after.  Use tree_to_uhwi when summing small shift\n+\tcounts into an unsigned int.\n+\n 2017-10-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "848b88faec3cc612eeca4203e10f61237388a228", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -1,3 +1,8 @@\n+2017-10-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc-interface/decl.c (annotate_value): Use wi::to_widest when\n+\thandling the form (plus/mult (convert @0) @1).\n+\n 2017-09-29  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch6.adb (Expand_Call_Helper): Replace with code more similar to"}, {"sha": "e6cd8d6ba50eba1becbeb08cd66ed2c5e5a586ae", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -8153,11 +8153,13 @@ annotate_value (tree gnu_size)\n \t    {\n \t      tree inner_op_op1 = TREE_OPERAND (inner_op, 1);\n \t      tree gnu_size_op1 = TREE_OPERAND (gnu_size, 1);\n-\t      wide_int op1;\n+\t      widest_int op1;\n \t      if (TREE_CODE (gnu_size) == MULT_EXPR)\n-\t\top1 = wi::mul (inner_op_op1, gnu_size_op1);\n+\t\top1 = (wi::to_widest (inner_op_op1)\n+\t\t       * wi::to_widest (gnu_size_op1));\n \t      else\n-\t\top1 = wi::add (inner_op_op1, gnu_size_op1);\n+\t\top1 = (wi::to_widest (inner_op_op1)\n+\t\t       + wi::to_widest (gnu_size_op1));\n \t      ops[1] = UI_From_gnu (wide_int_to_tree (sizetype, op1));\n \t      ops[0] = annotate_value (TREE_OPERAND (inner_op, 0));\n \t    }"}, {"sha": "58797f074641ca1bafce1d869f96f7c9a62ba30e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -1,3 +1,8 @@\n+2017-10-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* c-warn.c (warn_tautological_bitwise_comparison): Use wi::to_widest\n+\twhen combining the original unconverted comparison operands.\n+\n 2017-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-attribs.c (handle_noipa_attribute): Don't add \"stack_protect\""}, {"sha": "f86de10fdd9477d0a72eb503c807d3f6f42932de", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -355,15 +355,17 @@ warn_tautological_bitwise_comparison (location_t loc, tree_code code,\n   else\n     return;\n \n-  wide_int res;\n+  /* Note that the two operands are from before the usual integer\n+     conversions, so their types might not be the same.  */\n+  widest_int res;\n   if (TREE_CODE (bitop) == BIT_AND_EXPR)\n-    res = wi::bit_and (bitopcst, cst);\n+    res = wi::to_widest (bitopcst) & wi::to_widest (cst);\n   else\n-    res = wi::bit_or (bitopcst, cst);\n+    res = wi::to_widest (bitopcst) | wi::to_widest (cst);\n \n   /* For BIT_AND only warn if (CST2 & CST1) != CST1, and\n      for BIT_OR only if (CST2 | CST1) != CST1.  */\n-  if (res == cst)\n+  if (res == wi::to_widest (cst))\n     return;\n \n   if (code == EQ_EXPR)"}, {"sha": "72cf9e016c80555a76ef84ef110a8292bdd31876", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -1252,9 +1252,8 @@ alloc_max_size (void)\n \n \t      if (unit)\n \t\t{\n-\t\t  wide_int w = wi::uhwi (limit, HOST_BITS_PER_WIDE_INT + 64);\n-\t\t  w *= unit;\n-\t\t  if (wi::ltu_p (w, alloc_object_size_limit))\n+\t\t  widest_int w = wi::mul (limit, unit);\n+\t\t  if (w < wi::to_widest (alloc_object_size_limit))\n \t\t    alloc_object_size_limit = wide_int_to_tree (ssizetype, w);\n \t\t}\n \t    }"}, {"sha": "cd0433c66cd3c35ee3ddc94f120f3c222140ec6d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -1,3 +1,8 @@\n+2017-10-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* constexpr.c (cxx_eval_store_expression): Use wi::to_widest\n+\twhen comparing the array bounds with an ARRAY_REF index.\n+\n 2017-09-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/68754"}, {"sha": "8a5be2079d8dfdf0e744df65238aec8401696161", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -3379,7 +3379,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  VERIFY_CONSTANT (nelts);\n \t  gcc_assert (TREE_CODE (nelts) == INTEGER_CST\n \t\t      && TREE_CODE (TREE_OPERAND (probe, 1)) == INTEGER_CST);\n-\t  if (wi::eq_p (TREE_OPERAND (probe, 1), nelts))\n+\t  if (wi::to_widest (TREE_OPERAND (probe, 1)) == wi::to_widest (nelts))\n \t    {\n \t      diag_array_subscript (ctx, ary, TREE_OPERAND (probe, 1));\n \t      *non_constant_p = true;"}, {"sha": "ab4f9d82858f4ccbd888926958a8d5af7373925c", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -491,7 +491,7 @@ pass_walloca::execute (function *fun)\n \t\t\t      is_vla ? G_(\"argument to variable-length array \"\n \t\t\t\t\t  \"may be too large\")\n \t\t\t      : G_(\"argument to %<alloca%> may be too large\"))\n-\t\t  && t.limit != integer_zero_node)\n+\t\t  && t.limit != 0)\n \t\t{\n \t\t  print_decu (t.limit, buff);\n \t\t  inform (loc, G_(\"limit is %u bytes, but argument \"\n@@ -504,7 +504,7 @@ pass_walloca::execute (function *fun)\n \t\t\t      is_vla ? G_(\"argument to variable-length array \"\n \t\t\t\t\t  \"is too large\")\n \t\t\t      : G_(\"argument to %<alloca%> is too large\"))\n-\t\t  && t.limit != integer_zero_node)\n+\t\t  && t.limit != 0)\n \t\t{\n \t\t  print_decu (t.limit, buff);\n \t\t  inform (loc, G_(\"limit is %u bytes, but argument is %s\"),"}, {"sha": "e58a65af59b44a6b82ed8705f62966c5e6f251ac", "filename": "gcc/match.pd", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -358,8 +358,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (div (convert? (bit_and @0 INTEGER_CST@1)) INTEGER_CST@2)\n   (if (integer_pow2p (@2)\n        && tree_int_cst_sgn (@2) > 0\n-       && wi::add (@2, @1) == 0\n-       && tree_nop_conversion_p (type, TREE_TYPE (@0)))\n+       && tree_nop_conversion_p (type, TREE_TYPE (@0))\n+       && wi::add (@2, @1) == 0)\n    (rshift (convert @0) { build_int_cst (integer_type_node,\n \t\t\t\t\t wi::exact_log2 (@2)); }))))\n \n@@ -1883,7 +1883,8 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n         && wi::lt_p (@1, prec, TYPE_SIGN (TREE_TYPE (@1)))\n         && wi::ge_p (@2, 0, TYPE_SIGN (TREE_TYPE (@2)))\n \t&& wi::lt_p (@2, prec, TYPE_SIGN (TREE_TYPE (@2))))\n-    (with { unsigned int low = wi::add (@1, @2).to_uhwi (); }\n+    (with { unsigned int low = (tree_to_uhwi (@1)\n+\t\t\t\t+ tree_to_uhwi (@2)); }\n      /* Deal with a OP (c1 + c2) being undefined but (a OP c1) OP c2\n         being well defined.  */\n      (if (low >= prec)"}, {"sha": "5e8419e259a58ca6317f5b5b4edfaa079ffaac2d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1488398d4abf50ff8b2ec25d6a75185aefc52c8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a1488398d4abf50ff8b2ec25d6a75185aefc52c8", "patch": "@@ -5176,6 +5176,7 @@ inline wi::storage_ref\n wi::int_traits <const_tree>::decompose (HOST_WIDE_INT *,\n \t\t\t\t\tunsigned int precision, const_tree x)\n {\n+  gcc_checking_assert (precision == TYPE_PRECISION (TREE_TYPE (x)));\n   return wi::storage_ref (&TREE_INT_CST_ELT (x, 0), TREE_INT_CST_NUNITS (x),\n \t\t\t  precision);\n }"}]}