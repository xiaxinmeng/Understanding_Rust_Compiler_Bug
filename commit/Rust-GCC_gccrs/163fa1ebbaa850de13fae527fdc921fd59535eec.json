{"sha": "163fa1ebbaa850de13fae527fdc921fd59535eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYzZmExZWJiYWE4NTBkZTEzZmFlNTI3ZmRjOTIxZmQ1OTUzNWVlYw==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-04-30T11:41:34Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-04-30T11:41:34Z"}, "message": "Fix PCH crash on GTYed pointer-to-scalar field of a struct\n\nWhen -ftrack-macro-expansion is activated, the PCH generation\nmachinery can crash in gt_pch_save when it's about to relocate the\npointer for the\nline_maps::info_macro::maps[i]::d.macro.macro_locations member.\n\nThe call that crashes (in ggc-common.c) is:\n\n    state.ptrs[i]->note_ptr_fn (state.ptrs[i]->obj,\n\t\t\t\tstate.ptrs[i]->note_ptr_cookie,\n\t\t\t\trelocate_ptrs, &state);\n\nThe ->note_ptr_fn called in this case is the gengtype-generated\ngt_pch_p_9line_maps function.  It crashes because the second argument\npassed to it is a pointer to struct line_map, instead of being a\npointer to struct line_maps (extra 's') like what the function\nexpects.\n\nYou can see the crash for the test case:\n\n    runtest --tool g++ --tool_opts=\"-ftrack-macro-expansion\" pch.exp=system-1.C\n\nI believe it's because a part of the code of gt_pch_nx_line_maps\n(generated as part of gtype-desc.c by gengtype) is not correct.  Note\nthat this gt_pch_nx_line_maps function is called from gt_pch_save in\nthe snippet:\n\n  for (rt = gt_ggc_rtab; *rt; rt++)\n    for (rti = *rt; rti->base != NULL; rti++)\n      for (i = 0; i < rti->nelt; i++)\n\t(*rti->pchw)(*(void **)((char *)rti->base + rti->stride * i));\n\nSo, in that gt_pch_nx_line_maps, in the branch that starts with the\ncode:\n\n      if ((*x).info_macro.maps != NULL) {\n        size_t i3;\n        for (i3 = 0; i3 != (size_t)(((*x).info_macro).used); i3++) {\n          switch (((*x).info_macro.maps[i3]).reason == LC_ENTER_MACRO)\n\nwe have the code:\n\n    gt_pch_note_object ((*x).info_macro.maps[i3].d.macro.macro_locations,\n\t\t\t(*x).info_macro.maps,\n\t\t\t gt_pch_p_9line_maps,\n\t\t\t  gt_types_enum_last);\n\nThis last snippet registers gt_pch_p_9line_maps to be called on the\nobject pointed by (*x).info_macro.maps[i3].d.macro.macro_locations (as\na first argument), with (*x).info_macro.maps as its second argument.\n\nNote that (*x).info_macro.maps is of type struct line_map*, while 'x'\nis of type struct line_maps* - beware, there is an 's' at the end of\nthe latter.\n\nThe problem is that gt_pch_p_9line_maps requires that its second\nargument be an instance of _struct line_maps_, not struct line_map.\nSo later when gt_pch_p_9line_maps is called, it just crashes.\n\nMore generally, these gt_pch_p_xxx functions seem to require that\ntheir second argument be an instance of the xxx in question.  And that\ninvariant is violated by the snippet of code above.\n\nThe invariant seems to be violated only for the case where a GTYed\nstructure (possibly embedded in another GTYed structure) contains a\npointer to a scalar (that is not a string) which memory is ggc/GTY\nmanaged, like the line_map_macro::macro_locations field.  And this\nonly happens for PCH generation.\n\nLooking at gengtype.c, it seems like write_types_process_field can be\nfooled in that case.  It expects that the expression d->prev_val[3]\ncontains the name of the second argument of the gt_pch_p_xxx (which is\ngenerically referenced by wtd->subfield_marker_routine there).  That\nexpression can resolve to either \"x\", as we would like it to be, but\ncan also resolve to another arbitrary name for e.g, the case of a\npointer-to-struct used as a root).\n\nThis patch simply forces the second argument of gt_pch_p_xxx to be 'x'\neven in the case of a member that is a pointer to a scalar.\n\nAs a result, here is the the diff the new generated gtype-desc.c file:\n\n@@ -5234,7 +5234,7 @@ gt_pch_nx_line_maps (void *x_p)\n                 size_t i2;\n                 for (i2 = 0; i2 != (size_t)(2 * ((*x).info_ordinary.maps[i0].d.macro).n_tokens); i2++) {\n                 }\n-                gt_pch_note_object ((*x).info_ordinary.maps[i0].d.macro.macro_locations, (*x).info_ordinary.maps, gt_pch_p_9line_maps, gt_types_enum_last);\n+                gt_pch_note_object ((*x).info_ordinary.maps[i0].d.macro.macro_locations, x, gt_pch_p_9line_maps, gt_types_enum_last);\n               }\n               break;\n             default:\n@@ -5261,7 +5261,7 @@ gt_pch_nx_line_maps (void *x_p)\n                 size_t i5;\n                 for (i5 = 0; i5 != (size_t)(2 * ((*x).info_macro.maps[i3].d.macro).n_tokens); i5++) {\n                 }\n-                gt_pch_note_object ((*x).info_macro.maps[i3].d.macro.macro_locations, (*x).info_macro.maps, gt_pch_p_9line_maps, gt_types_enum_last);\n+                gt_pch_note_object ((*x).info_macro.maps[i3].d.macro.macro_locations, x, gt_pch_p_9line_maps, gt_types_enum_last);\n               }\n               break;\n             default:\n@@ -9366,7 +9366,7 @@ gt_pch_na_regno_reg_rtx (ATTRIBUTE_UNUSED void *x_p)\n     for (i1 = 0; i1 != (size_t)(crtl->emit.x_reg_rtx_no); i1++) {\n       gt_pch_n_7rtx_def (regno_reg_rtx[i1]);\n     }\n-    gt_pch_note_object (regno_reg_rtx, &regno_reg_rtx, gt_pch_pa_regno_reg_rtx, gt_types_enum_last);\n+    gt_pch_note_object (regno_reg_rtx, x, gt_pch_pa_regno_reg_rtx, gt_types_enum_last);\n   }\n }\n\nI think it's pretty much what I was willing to have.\n\nBootstrapped and tested on x86_64-unknown-linux-gnu against trunk.\n\nNote that the bootstrap with -ftrack-macro-expansion exhibits\nother separate issues that are addressed in subsequent patches.\nThis patch just fixes one class of problems.\n\nThe patch does pass bootstrap with -ftrack-macro-expansion turned\noff, though.\n\ngcc/\n\n\t* gengtype.c (write_types_process_field):  Force second argument\n\tof the call to the PCH object hierarchy walker to be 'x'.\n\nFrom-SVN: r186967", "tree": {"sha": "8fb8845a5d3d8bc4a282ffa0ace5b9972d779891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fb8845a5d3d8bc4a282ffa0ace5b9972d779891"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/163fa1ebbaa850de13fae527fdc921fd59535eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163fa1ebbaa850de13fae527fdc921fd59535eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/163fa1ebbaa850de13fae527fdc921fd59535eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163fa1ebbaa850de13fae527fdc921fd59535eec/comments", "author": null, "committer": null, "parents": [{"sha": "0ff2b8a0225c3b1adeb0ebde107b7f30ba9e2fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff2b8a0225c3b1adeb0ebde107b7f30ba9e2fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff2b8a0225c3b1adeb0ebde107b7f30ba9e2fd1"}], "stats": {"total": 27, "additions": 26, "deletions": 1}, "files": [{"sha": "a1cdc889b9a59297e11191aeccf77db3446afb15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163fa1ebbaa850de13fae527fdc921fd59535eec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163fa1ebbaa850de13fae527fdc921fd59535eec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=163fa1ebbaa850de13fae527fdc921fd59535eec", "patch": "@@ -1,3 +1,9 @@\n+2012-04-30  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tFix PCH crash on GTYed pointer-to-scalar field of a struct\n+\t* gengtype.c (write_types_process_field): Force second argument of\n+\tthe call to the PCH object hierarchy walker to be 'x'.\n+\n 2012-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/i386/i386.c (ix86_handle_struct_attribute): Use the proper"}, {"sha": "02d4c8c89d1e0134b3e178930758d3173fe3f574", "filename": "gcc/gengtype.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/163fa1ebbaa850de13fae527fdc921fd59535eec/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/163fa1ebbaa850de13fae527fdc921fd59535eec/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=163fa1ebbaa850de13fae527fdc921fd59535eec", "patch": "@@ -2930,7 +2930,26 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n \t       wtd->subfield_marker_routine, cast, d->val);\n       if (wtd->param_prefix)\n \t{\n-\t  oprintf (d->of, \", %s\", d->prev_val[3]);\n+\t  if (f->u.p->kind == TYPE_SCALAR)\n+\t    /* The current type is a pointer to a scalar (so not\n+\t       considered like a pointer to instances of user defined\n+\t       types) and we are seeing it; it means we must be even\n+\t       more careful about the second argument of the\n+\t       SUBFIELD_MARKER_ROUTINE call.  That argument must\n+\t       always be the instance of the type for which\n+\t       write_func_for_structure was called - this really is\n+\t       what the function SUBFIELD_MARKER_ROUTINE expects.\n+\t       That is, it must be an instance of the ORIG_S type\n+\t       parameter of write_func_for_structure.  The convention\n+\t       is that that argument must be \"x\" in that case (as set\n+\t       by write_func_for_structure).  The problem is, we can't\n+\t       count on d->prev_val[3] to be always set to \"x\" in that\n+\t       case.  Sometimes walk_type can set it to something else\n+\t       (to e.g cooperate with write_array when called from\n+\t       write_roots).  So let's set it to \"x\" here then.  */\n+\t    oprintf (d->of, \", x\");\n+\t  else\n+\t    oprintf (d->of, \", %s\", d->prev_val[3]);\n \t  if (d->orig_s)\n \t    {\n \t      oprintf (d->of, \", gt_%s_\", wtd->param_prefix);"}]}