{"sha": "ef14bba0a6f3836d41d75863e6516d21aef0e936", "node_id": "C_kwDOANBUbNoAKGVmMTRiYmEwYTZmMzgzNmQ0MWQ3NTg2M2U2NTE2ZDIxYWVmMGU5MzY", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-12-15T09:54:23Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-05-11T09:03:18Z"}, "message": "i386: simplify cpu_feature handling\n\nThe patch removes unneeded loops for cpu_features2 and CONVERT_EXPR\nthat can be simplified with NOP_EXPR.\n\ngcc/ChangeLog:\n\n\t* common/config/i386/cpuinfo.h (has_cpu_feature): Directly\n\tcompute index in cpu_features2.\n\t(set_cpu_feature): Likewise.\n\t* config/i386/i386-builtins.cc (fold_builtin_cpu): Also remove\n\tloop for cpu_features2 and use NOP_EXPRs.", "tree": {"sha": "83486d168a2b552a62e57d24a8d897b716d37094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83486d168a2b552a62e57d24a8d897b716d37094"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef14bba0a6f3836d41d75863e6516d21aef0e936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef14bba0a6f3836d41d75863e6516d21aef0e936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef14bba0a6f3836d41d75863e6516d21aef0e936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef14bba0a6f3836d41d75863e6516d21aef0e936/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0fd3e3120e83bcd783d5c2443bade7cef20814a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fd3e3120e83bcd783d5c2443bade7cef20814a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0fd3e3120e83bcd783d5c2443bade7cef20814a"}], "stats": {"total": 129, "additions": 67, "deletions": 62}, "files": [{"sha": "6d6171f45553567c4d518cc862df8c08a99c6ac4", "filename": "gcc/common/config/i386/cpuinfo.h", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef14bba0a6f3836d41d75863e6516d21aef0e936/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef14bba0a6f3836d41d75863e6516d21aef0e936/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fi386%2Fcpuinfo.h?ref=ef14bba0a6f3836d41d75863e6516d21aef0e936", "patch": "@@ -55,43 +55,49 @@ struct __processor_model2\n static inline int\n has_cpu_feature (struct __processor_model *cpu_model,\n \t\t unsigned int *cpu_features2,\n-\t\t enum processor_features f)\n+\t\t enum processor_features feature)\n {\n-  unsigned int i;\n+  unsigned index, offset;\n+  unsigned f = feature;\n+\n   if (f < 32)\n     {\n       /* The first 32 features.  */\n-      return cpu_model->__cpu_features[0] & (1U << (f & 31));\n+      return cpu_model->__cpu_features[0] & (1U << f);\n+    }\n+  else\n+    {\n+      /* The rest of features.  cpu_features2[i] contains features from\n+\t (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n+      f -= 32;\n+      index = f / 32;\n+      offset = f % 32;\n+      return cpu_features2[index] & (1U << offset);\n     }\n-  /* The rest of features.  cpu_features2[i] contains features from\n-     (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n-  for (i = 0; i < SIZE_OF_CPU_FEATURES; i++)\n-    if (f < (32 + 32 + i * 32))\n-    return cpu_features2[i] & (1U << ((f - (32 + i * 32)) & 31));\n-  gcc_unreachable ();\n }\n \n static inline void\n set_cpu_feature (struct __processor_model *cpu_model,\n \t\t unsigned int *cpu_features2,\n-\t\t enum processor_features f)\n+\t\t enum processor_features feature)\n {\n-  unsigned int i;\n+  unsigned index, offset;\n+  unsigned f = feature;\n+\n   if (f < 32)\n     {\n       /* The first 32 features.  */\n-      cpu_model->__cpu_features[0] |= (1U << (f & 31));\n-      return;\n+      cpu_model->__cpu_features[0] |= (1U << f);\n+    }\n+  else\n+    {\n+      /* The rest of features.  cpu_features2[i] contains features from\n+\t (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n+      f -= 32;\n+      index = f / 32;\n+      offset = f % 32;\n+      cpu_features2[index] |= (1U << offset);\n     }\n-  /* The rest of features.  cpu_features2[i] contains features from\n-     (32 + i * 32) to (31 + 32 + i * 32), inclusively.  */\n-  for (i = 0; i < SIZE_OF_CPU_FEATURES; i++)\n-    if (f < (32 + 32 + i * 32))\n-      {\n-\tcpu_features2[i] |= (1U << ((f - (32 + i * 32)) & 31));\n-\treturn;\n-      }\n-  gcc_unreachable ();\n }\n \n /* Get the specific type of AMD CPU and return AMD CPU name.  Return"}, {"sha": "59c7da25a14dd42d866df3645f216707c6683ad3", "filename": "gcc/config/i386/i386-builtins.cc", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef14bba0a6f3836d41d75863e6516d21aef0e936/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef14bba0a6f3836d41d75863e6516d21aef0e936/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc?ref=ef14bba0a6f3836d41d75863e6516d21aef0e936", "patch": "@@ -2280,7 +2280,7 @@ fold_builtin_cpu (tree fndecl, tree *args)\n       /* Check the value.  */\n       final = build2 (EQ_EXPR, unsigned_type_node, ref,\n \t\t      build_int_cstu (unsigned_type_node, field_val));\n-      return build1 (CONVERT_EXPR, integer_type_node, final);\n+      return build1 (NOP_EXPR, integer_type_node, final);\n     }\n   else if (fn_code == IX86_BUILTIN_CPU_SUPPORTS)\n     {\n@@ -2305,7 +2305,8 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \t  return integer_zero_node;\n \t}\n \n-      if (isa_names_table[i].feature >= 32)\n+      unsigned feature = isa_names_table[i].feature;\n+      if (feature >= INT_TYPE_SIZE)\n \t{\n \t  if (ix86_cpu_features2_var == nullptr)\n \t    {\n@@ -2323,46 +2324,44 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \t      varpool_node::add (ix86_cpu_features2_var);\n \t    }\n \n-\t  for (unsigned int j = 0; j < SIZE_OF_CPU_FEATURES; j++)\n-\t    if (isa_names_table[i].feature < (32 + 32 + j * 32))\n-\t      {\n-\t\tfield_val = (1U << (isa_names_table[i].feature\n-\t\t\t\t    - (32 + j * 32)));\n-\t\ttree index = size_int (j);\n-\t\tarray_elt = build4 (ARRAY_REF, unsigned_type_node,\n-\t\t\t\t    ix86_cpu_features2_var,\n-\t\t\t\t    index, NULL_TREE, NULL_TREE);\n-\t\t/* Return __cpu_features2[index] & field_val  */\n-\t\tfinal = build2 (BIT_AND_EXPR, unsigned_type_node,\n-\t\t\t\tarray_elt,\n-\t\t\t\tbuild_int_cstu (unsigned_type_node,\n-\t\t\t\t\t\tfield_val));\n-\t\treturn build1 (CONVERT_EXPR, integer_type_node, final);\n-\t      }\n+\t  feature -= INT_TYPE_SIZE;\n+\t  field_val = 1U << (feature % INT_TYPE_SIZE);\n+\t  tree index = size_int (feature / INT_TYPE_SIZE);\n+\t  array_elt = build4 (ARRAY_REF, unsigned_type_node,\n+\t\t\t      ix86_cpu_features2_var,\n+\t\t\t      index, NULL_TREE, NULL_TREE);\n+\t  /* Return __cpu_features2[index] & field_val  */\n+\t  final = build2 (BIT_AND_EXPR, unsigned_type_node,\n+\t\t\t  array_elt,\n+\t\t\t  build_int_cstu (unsigned_type_node,\n+\t\t\t\t\t  field_val));\n+\t  return build1 (NOP_EXPR, integer_type_node, final);\n \t}\n-\n-      field = TYPE_FIELDS (ix86_cpu_model_type_node);\n-      /* Get the last field, which is __cpu_features.  */\n-      while (DECL_CHAIN (field))\n-        field = DECL_CHAIN (field);\n-\n-      /* Get the appropriate field: __cpu_model.__cpu_features  */\n-      ref = build3 (COMPONENT_REF, TREE_TYPE (field), ix86_cpu_model_var,\n-\t\t    field, NULL_TREE);\n-\n-      /* Access the 0th element of __cpu_features array.  */\n-      array_elt = build4 (ARRAY_REF, unsigned_type_node, ref,\n-\t\t\t  integer_zero_node, NULL_TREE, NULL_TREE);\n-\n-      field_val = (1U << isa_names_table[i].feature);\n-      /* Return __cpu_model.__cpu_features[0] & field_val  */\n-      final = build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,\n-\t\t      build_int_cstu (unsigned_type_node, field_val));\n-      if (isa_names_table[i].feature == (INT_TYPE_SIZE - 1))\n-\treturn build2 (NE_EXPR, integer_type_node, final,\n-\t\t       build_int_cst (unsigned_type_node, 0));\n       else\n-\treturn build1 (CONVERT_EXPR, integer_type_node, final);\n+\t{\n+\t  field = TYPE_FIELDS (ix86_cpu_model_type_node);\n+\t  /* Get the last field, which is __cpu_features.  */\n+\t  while (DECL_CHAIN (field))\n+\t    field = DECL_CHAIN (field);\n+\n+\t  /* Get the appropriate field: __cpu_model.__cpu_features  */\n+\t  ref = build3 (COMPONENT_REF, TREE_TYPE (field), ix86_cpu_model_var,\n+\t\t\tfield, NULL_TREE);\n+\n+\t  /* Access the 0th element of __cpu_features array.  */\n+\t  array_elt = build4 (ARRAY_REF, unsigned_type_node, ref,\n+\t\t\t      integer_zero_node, NULL_TREE, NULL_TREE);\n+\n+\t  field_val = (1U << feature);\n+\t  /* Return __cpu_model.__cpu_features[0] & field_val  */\n+\t  final = build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,\n+\t\t\t  build_int_cstu (unsigned_type_node, field_val));\n+\t  if (feature == (INT_TYPE_SIZE - 1))\n+\t    return build2 (NE_EXPR, integer_type_node, final,\n+\t\t\t   build_int_cst (unsigned_type_node, 0));\n+\t  else\n+\t    return build1 (NOP_EXPR, integer_type_node, final);\n+\t}\n     }\n   gcc_unreachable ();\n }"}]}