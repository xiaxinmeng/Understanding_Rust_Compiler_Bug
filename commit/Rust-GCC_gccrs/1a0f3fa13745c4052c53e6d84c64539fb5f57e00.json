{"sha": "1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEwZjNmYTEzNzQ1YzQwNTJjNTNlNmQ4NGM2NDUzOWZiNWY1N2UwMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-22T15:51:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-22T15:51:15Z"}, "message": "df-problems.c (df_rd_confluence_n, [...]): Return true if something changed.\n\n\t* df-problems.c (df_rd_confluence_n, df_lr_confluence_n, df_live_confluence_n,\n\tdf_byte_lr_confluence_n, df_md_confluence_n): Return true if something changed.\n\t* df.h (df_confluence_function_n): Return bool.\n\t* df-core.c (df_worklist_propagate_forward, df_worklist_propagate_backward):\n\ttrack changes and ages.\n\t(df_worklist_dataflow_doublequeue): Use bitmap iterator for main walk;\n\ttrack ages.\n\t* dse.c (dse_confluence_n): Return always true.\n\nFrom-SVN: r161197", "tree": {"sha": "414cbb0375d4502b16087709583f96f31163e6fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/414cbb0375d4502b16087709583f96f31163e6fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/comments", "author": null, "committer": null, "parents": [{"sha": "4c484f40927f5b3727b12a7cd07d6ad2475ce390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c484f40927f5b3727b12a7cd07d6ad2475ce390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c484f40927f5b3727b12a7cd07d6ad2475ce390"}], "stats": {"total": 156, "additions": 105, "deletions": 51}, "files": [{"sha": "fdd72da1c602191b7221cc8b40576cb358266fa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "patch": "@@ -1,4 +1,15 @@\n-2010-06-22  Uros Bizjak  <ubizjak@gmail.com>\n+2010-06-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* df-problems.c (df_rd_confluence_n, df_lr_confluence_n, df_live_confluence_n,\n+\tdf_byte_lr_confluence_n, df_md_confluence_n): Return true if something changed.\n+\t* df.h (df_confluence_function_n): Return bool.\n+\t* df-core.c (df_worklist_propagate_forward, df_worklist_propagate_backward):\n+\ttrack changes and ages.\n+\t(df_worklist_dataflow_doublequeue): Use bitmap iterator for main walk;\n+\ttrack ages.\n+\t* dse.c (dse_confluence_n): Return always true.\n+\n+2010-06-22  Jan Hubicka  <jh@suse.cz>\n \n \t* bitmap.c (bitmap_clear_bit): Micro optimize.\n "}, {"sha": "814eaf41ccf0294b0cab3b60fca214da5ad20d08", "filename": "gcc/df-core.c", "status": "modified", "additions": 67, "deletions": 29, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "patch": "@@ -858,28 +858,35 @@ struct rtl_opt_pass pass_df_finish =\n    and set bits on for successors in PENDING\n    if the out set of the dataflow has changed. */\n \n-static void\n+static bool\n df_worklist_propagate_forward (struct dataflow *dataflow,\n                                unsigned bb_index,\n                                unsigned *bbindex_to_postorder,\n                                bitmap pending,\n-                               sbitmap considered)\n+                               sbitmap considered,\n+\t\t\t       size_t age)\n {\n   edge e;\n   edge_iterator ei;\n   basic_block bb = BASIC_BLOCK (bb_index);\n+  bool changed = !age;\n \n   /*  Calculate <conf_op> of incoming edges.  */\n   if (EDGE_COUNT (bb->preds) > 0)\n     FOR_EACH_EDGE (e, ei, bb->preds)\n       {\n-        if (TEST_BIT (considered, e->src->index))\n-          dataflow->problem->con_fun_n (e);\n+        if ((age <= (size_t)e->src->aux)\n+\t     && TEST_BIT (considered, e->src->index))\n+          changed |= dataflow->problem->con_fun_n (e);\n       }\n   else if (dataflow->problem->con_fun_0)\n-    dataflow->problem->con_fun_0 (bb);\n+    {\n+      dataflow->problem->con_fun_0 (bb);\n+      changed = true;\n+    }\n \n-  if (dataflow->problem->trans_fun (bb_index))\n+  if (changed\n+      && dataflow->problem->trans_fun (bb_index))\n     {\n       /* The out set of this block has changed.\n          Propagate to the outgoing blocks.  */\n@@ -890,35 +897,44 @@ df_worklist_propagate_forward (struct dataflow *dataflow,\n           if (TEST_BIT (considered, ob_index))\n             bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n         }\n+      return true;\n     }\n+  return false;\n }\n \n \n /* Helper function for df_worklist_dataflow.\n    Propagate the dataflow backward.  */\n \n-static void\n+static bool\n df_worklist_propagate_backward (struct dataflow *dataflow,\n                                 unsigned bb_index,\n                                 unsigned *bbindex_to_postorder,\n                                 bitmap pending,\n-                                sbitmap considered)\n+                                sbitmap considered,\n+\t\t\t        size_t age)\n {\n   edge e;\n   edge_iterator ei;\n   basic_block bb = BASIC_BLOCK (bb_index);\n+  bool changed = !age;\n \n   /*  Calculate <conf_op> of incoming edges.  */\n   if (EDGE_COUNT (bb->succs) > 0)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       {\n-        if (TEST_BIT (considered, e->dest->index))\n-          dataflow->problem->con_fun_n (e);\n+        if ((age <= (size_t)e->dest->aux)\n+\t     && TEST_BIT (considered, e->dest->index))\n+          changed |= dataflow->problem->con_fun_n (e);\n       }\n   else if (dataflow->problem->con_fun_0)\n-    dataflow->problem->con_fun_0 (bb);\n+    {\n+      dataflow->problem->con_fun_0 (bb);\n+      changed = true;\n+    }\n \n-  if (dataflow->problem->trans_fun (bb_index))\n+  if (changed\n+      && dataflow->problem->trans_fun (bb_index))\n     {\n       /* The out set of this block has changed.\n          Propagate to the outgoing blocks.  */\n@@ -929,10 +945,13 @@ df_worklist_propagate_backward (struct dataflow *dataflow,\n           if (TEST_BIT (considered, ob_index))\n             bitmap_set_bit (pending, bbindex_to_postorder[ob_index]);\n         }\n+      return true;\n     }\n+  return false;\n }\n \n-\n+DEF_VEC_I(size_t);\n+DEF_VEC_ALLOC_I(size_t,heap);\n \n /* This will free \"pending\". */\n \n@@ -941,46 +960,65 @@ df_worklist_dataflow_doublequeue (struct dataflow *dataflow,\n \t\t\t  \t  bitmap pending,\n                                   sbitmap considered,\n                                   int *blocks_in_postorder,\n-\t\t\t\t  unsigned *bbindex_to_postorder)\n+\t\t\t\t  unsigned *bbindex_to_postorder,\n+\t\t\t\t  int n_blocks)\n {\n   enum df_flow_dir dir = dataflow->problem->dir;\n   int dcount = 0;\n   bitmap worklist = BITMAP_ALLOC (&df_bitmap_obstack);\n+  size_t age = 0;\n+  bool changed;\n+  VEC(size_t, heap) *last_age = NULL;\n+  size_t prev_age;\n+  basic_block bb;\n+  int i;\n+\n+  VEC_safe_grow_cleared (size_t, heap, last_age, n_blocks);\n \n   /* Double-queueing. Worklist is for the current iteration,\n      and pending is for the next. */\n   while (!bitmap_empty_p (pending))\n     {\n+      bitmap_iterator bi;\n+      unsigned int index;\n+\n       /* Swap pending and worklist. */\n       bitmap temp = worklist;\n       worklist = pending;\n       pending = temp;\n \n-      do\n+      EXECUTE_IF_SET_IN_BITMAP (worklist, 0, index, bi)\n \t{\n-\t  int index;\n \t  unsigned bb_index;\n \t  dcount++;\n \n-\t  index = bitmap_first_set_bit (worklist);\n-\t  bitmap_clear_bit (worklist, index);\n-\n \t  bb_index = blocks_in_postorder[index];\n-\n+\t  bb = BASIC_BLOCK (bb_index);\n+\t  prev_age = VEC_index (size_t, last_age, index);\n \t  if (dir == DF_FORWARD)\n-\t    df_worklist_propagate_forward (dataflow, bb_index,\n-\t\t\t\t\t   bbindex_to_postorder,\n-\t\t\t\t\t   pending, considered);\n+\t    changed = df_worklist_propagate_forward (dataflow, bb_index,\n+\t\t\t\t\t\t     bbindex_to_postorder,\n+\t\t\t\t\t\t     pending, considered,\n+\t\t\t\t\t\t     prev_age);\n \t  else\n-\t    df_worklist_propagate_backward (dataflow, bb_index,\n-\t\t\t\t\t    bbindex_to_postorder,\n-\t\t\t\t\t    pending, considered);\n+\t    changed = df_worklist_propagate_backward (dataflow, bb_index,\n+\t\t\t\t\t\t      bbindex_to_postorder,\n+\t\t\t\t\t\t      pending, considered,\n+\t\t\t\t\t\t      prev_age);\n+\t  age++;\n+\t  if (changed)\n+\t    bb->aux = (void *)age;\n+\t  VEC_replace (size_t, last_age, index, age);\n+\t  age++;\n \t}\n-      while (!bitmap_empty_p (worklist));\n+      bitmap_clear (worklist);\n     }\n+  for (i = 0; i < n_blocks; i++)\n+    BASIC_BLOCK (blocks_in_postorder[i])->aux = NULL;\n \n   BITMAP_FREE (worklist);\n   BITMAP_FREE (pending);\n+  VEC_free (size_t, heap, last_age);\n \n   /* Dump statistics. */\n   if (dump_file)\n@@ -1044,8 +1082,8 @@ df_worklist_dataflow (struct dataflow *dataflow,\n   /* Solve it.  */\n   df_worklist_dataflow_doublequeue (dataflow, pending, considered,\n \t\t\t\t    blocks_in_postorder,\n-\t\t\t\t    bbindex_to_postorder);\n-\n+\t\t\t\t    bbindex_to_postorder,\n+\t\t\t\t    n_blocks);\n   sbitmap_free (considered);\n   free (bbindex_to_postorder);\n }"}, {"sha": "431027a41e0f750bd370b45338976c780cd0f37e", "filename": "gcc/df-problems.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "patch": "@@ -479,14 +479,15 @@ df_rd_init_solution (bitmap all_blocks)\n \n /* In of target gets or of out of source.  */\n \n-static void\n+static bool\n df_rd_confluence_n (edge e)\n {\n   bitmap op1 = &df_rd_get_bb_info (e->dest->index)->in;\n   bitmap op2 = &df_rd_get_bb_info (e->src->index)->out;\n+  bool changed = false;\n \n   if (e->flags & EDGE_FAKE)\n-    return;\n+    return false;\n \n   if (e->flags & EDGE_EH)\n     {\n@@ -508,11 +509,12 @@ df_rd_confluence_n (edge e)\n  \t\t\t      DF_DEFS_BEGIN (regno),\n  \t\t\t      DF_DEFS_COUNT (regno));\n \t}\n-      bitmap_ior_into (op1, &tmp);\n+      changed |= bitmap_ior_into (op1, &tmp);\n       bitmap_clear (&tmp);\n+      return changed;\n     }\n   else\n-    bitmap_ior_into (op1, op2);\n+    return bitmap_ior_into (op1, op2);\n }\n \n \n@@ -966,21 +968,22 @@ df_lr_confluence_0 (basic_block bb)\n \n /* Confluence function that ignores fake edges.  */\n \n-static void\n+static bool\n df_lr_confluence_n (edge e)\n {\n   bitmap op1 = &df_lr_get_bb_info (e->src->index)->out;\n   bitmap op2 = &df_lr_get_bb_info (e->dest->index)->in;\n+  bool changed = false;\n \n   /* Call-clobbered registers die across exception and call edges.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n   if (e->flags & EDGE_EH)\n-    bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n+    changed = bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n   else\n-    bitmap_ior_into (op1, op2);\n+    changed = bitmap_ior_into (op1, op2);\n \n-  bitmap_ior_into (op1, &df->hardware_regs_used);\n+  return bitmap_ior_into (op1, &df->hardware_regs_used) || changed;\n }\n \n \n@@ -1503,16 +1506,16 @@ df_live_init (bitmap all_blocks)\n \n /* Forward confluence function that ignores fake edges.  */\n \n-static void\n+static bool\n df_live_confluence_n (edge e)\n {\n   bitmap op1 = &df_live_get_bb_info (e->dest->index)->in;\n   bitmap op2 = &df_live_get_bb_info (e->src->index)->out;\n \n   if (e->flags & EDGE_FAKE)\n-    return;\n+    return false;\n \n-  bitmap_ior_into (op1, op2);\n+  return bitmap_ior_into (op1, op2);\n }\n \n \n@@ -2710,23 +2713,24 @@ df_byte_lr_confluence_0 (basic_block bb)\n \n /* Confluence function that ignores fake edges.  */\n \n-static void\n+static bool\n df_byte_lr_confluence_n (edge e)\n {\n   struct df_byte_lr_problem_data *problem_data\n     = (struct df_byte_lr_problem_data *)df_byte_lr->problem_data;\n   bitmap op1 = &df_byte_lr_get_bb_info (e->src->index)->out;\n   bitmap op2 = &df_byte_lr_get_bb_info (e->dest->index)->in;\n+  bool changed = false;\n \n   /* Call-clobbered registers die across exception and call edges.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n   if (e->flags & EDGE_EH)\n-    bitmap_ior_and_compl_into (op1, op2, &problem_data->invalidated_by_call);\n+    changed = bitmap_ior_and_compl_into (op1, op2, &problem_data->invalidated_by_call);\n   else\n-    bitmap_ior_into (op1, op2);\n+    changed = bitmap_ior_into (op1, op2);\n \n-  bitmap_ior_into (op1, &problem_data->hardware_regs_used);\n+  return bitmap_ior_into (op1, &problem_data->hardware_regs_used) || changed;\n }\n \n \n@@ -4426,19 +4430,19 @@ df_md_confluence_0 (basic_block bb)\n \n /* In of target gets or of out of source.  */\n \n-static void\n+static bool\n df_md_confluence_n (edge e)\n {\n   bitmap op1 = &df_md_get_bb_info (e->dest->index)->in;\n   bitmap op2 = &df_md_get_bb_info (e->src->index)->out;\n \n   if (e->flags & EDGE_FAKE)\n-    return;\n+    return false;\n \n   if (e->flags & EDGE_EH)\n-    bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n+    return bitmap_ior_and_compl_into (op1, op2, regs_invalidated_by_call_regset);\n   else\n-    bitmap_ior_into (op1, op2);\n+    return bitmap_ior_into (op1, op2);\n }\n \n /* Free all storage associated with the problem.  */"}, {"sha": "b778c0f060c4c1430add2cc7632ffa393c0ab693", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "patch": "@@ -223,7 +223,7 @@ typedef void (*df_dataflow_function) (struct dataflow *, bitmap, int *, int);\n typedef void (*df_confluence_function_0) (basic_block);\n \n /* Confluence operator for blocks with 1 or more out (or in) edges.  */\n-typedef void (*df_confluence_function_n) (edge);\n+typedef bool (*df_confluence_function_n) (edge);\n \n /* Transfer function for blocks.  */\n typedef bool (*df_transfer_function) (int);"}, {"sha": "5cb467c934d1429f0ad98633a56aa7626dfeff85", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a0f3fa13745c4052c53e6d84c64539fb5f57e00/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=1a0f3fa13745c4052c53e6d84c64539fb5f57e00", "patch": "@@ -3396,7 +3396,7 @@ dse_confluence_0 (basic_block bb)\n    out set of the src of E.  If the various in or out sets are not\n    there, that means they are all ones.  */\n \n-static void\n+static bool\n dse_confluence_n (edge e)\n {\n   bb_info_t src_info = bb_table[e->src->index];\n@@ -3412,6 +3412,7 @@ dse_confluence_n (edge e)\n \t  bitmap_copy (src_info->out, dest_info->in);\n \t}\n     }\n+  return true;\n }\n \n "}]}