{"sha": "a7df97e69d2ec38647ca8eac2126062603a908ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdkZjk3ZTY5ZDJlYzM4NjQ3Y2E4ZWFjMjEyNjA2MjYwM2E5MDhhYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-06-29T11:28:52Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-06-29T11:28:52Z"}, "message": "Fix int<->floating point conversion routines\n\nFrom-SVN: r12379", "tree": {"sha": "08c4935b72fb208113c177b163878a4c53cf967c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08c4935b72fb208113c177b163878a4c53cf967c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7df97e69d2ec38647ca8eac2126062603a908ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7df97e69d2ec38647ca8eac2126062603a908ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7df97e69d2ec38647ca8eac2126062603a908ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7df97e69d2ec38647ca8eac2126062603a908ab/comments", "author": null, "committer": null, "parents": [{"sha": "60725c7844275e5a9aa1460053852003e9e6a6ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60725c7844275e5a9aa1460053852003e9e6a6ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60725c7844275e5a9aa1460053852003e9e6a6ea"}], "stats": {"total": 355, "additions": 249, "deletions": 106}, "files": [{"sha": "ea35f4c59fec816b47085b319631d722caf72907", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 101, "deletions": 47, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7df97e69d2ec38647ca8eac2126062603a908ab/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7df97e69d2ec38647ca8eac2126062603a908ab/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a7df97e69d2ec38647ca8eac2126062603a908ab", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"obstack.h\"\n #include \"tree.h\"\n+#include \"function.h\"\n \n #ifndef TARGET_NO_PROTOTYPE\n #define TARGET_NO_PROTOTYPE 0\n@@ -2083,6 +2084,66 @@ rs6000_finalize_pic ()\n     }\n }\n \n+\f\n+/* Define the structure for the machine field in struct function.  */\n+struct machine_function\n+{\n+  int sysv_varargs_p;\n+  int save_toc_p;\n+  int fpmem_size;\n+  int fpmem_offset;\n+};\n+\n+/* Functions to save and restore rs6000_fpmem_size.\n+   These will be called, via pointer variables,\n+   from push_function_context and pop_function_context.  */\n+\n+void\n+rs6000_save_machine_status (p)\n+     struct function *p;\n+{\n+  struct machine_function *machine =\n+    (struct machine_function *) xmalloc (sizeof (struct machine_function));\n+\n+  p->machine = machine;\n+  machine->sysv_varargs_p = rs6000_sysv_varargs_p;\n+  machine->save_toc_p     = rs6000_save_toc_p;\n+  machine->fpmem_size     = rs6000_fpmem_size;\n+  machine->fpmem_offset   = rs6000_fpmem_offset;\n+}\n+\n+void\n+rs6000_restore_machine_status (p)\n+     struct function *p;\n+{\n+  struct machine_function *machine = p->machine;\n+\n+  rs6000_sysv_varargs_p = machine->sysv_varargs_p;\n+  rs6000_save_toc_p     = machine->save_toc_p;\n+  rs6000_fpmem_size     = machine->fpmem_size;\n+  rs6000_fpmem_offset   = machine->fpmem_offset;\n+\n+  free (machine);\n+  p->machine = (struct machine_function *)0;\n+}\n+\n+/* Do anything needed before RTL is emitted for each function.  */\n+\n+void\n+rs6000_init_expanders ()\n+{\n+  /* Reset varargs and save TOC indicator */\n+  rs6000_sysv_varargs_p = 0;\n+  rs6000_save_toc_p = 0;\n+  rs6000_fpmem_size = 0;\n+  rs6000_fpmem_offset = 0;\n+  pic_offset_table_rtx = (rtx)0;\n+\n+  /* Arrange to save and restore machine status around nested functions.  */\n+  save_machine_status = rs6000_save_machine_status;\n+  restore_machine_status = rs6000_restore_machine_status;\n+}\n+\n \f\n /* Print an operand.  Recognize special options, documented below.  */\n \n@@ -2720,15 +2781,15 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \t\t| Parameter save area (P)\t\t| 24\n \t\t+---------------------------------------+\n-\t\t| Float/int conversion temporary (X)\t| 24+P\n+\t\t| Alloca space (A)\t\t\t| 24+P\n \t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 24+P+X\n+\t\t| Local variable space (L)\t\t| 24+P+A\n \t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t| 24+P+X+A\n+\t\t| Float/int conversion temporary (X)\t| 24+P+A+L\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 24+P+X+A+L\n+\t\t| Save area for GP registers (G)\t| 24+P+A+X+L\n \t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 24+P+X+A+L+G\n+\t\t| Save area for FP registers (F)\t| 24+P+A+X+L+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -2742,19 +2803,19 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \t\t| Parameter save area (P)\t\t| 8\n \t\t+---------------------------------------+\n-\t\t| Float/int conversion temporary (X)\t| 8+P\n-\t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 8+P+X\n-\t\t+---------------------------------------+\n-\t\t| Varargs save area (V)\t\t\t| 8+P+X+A\n-\t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t| 8+P+X+A+V\n+\t\t| Alloca space (A)\t\t\t| 8+P\n+\t\t+---------------------------------------+    \n+\t\t| Varargs save area (V)\t\t\t| 8+P+A\n+\t\t+---------------------------------------+    \n+\t\t| Local variable space (L)\t\t| 8+P+A+V\n+\t\t+---------------------------------------+    \n+\t\t| Float/int conversion temporary (X)\t| 8+P+A+V+L\n \t\t+---------------------------------------+\n-\t\t| saved CR (C)\t\t\t\t| 8+P+X+A+V+L\n-\t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 8+P+X+A+V+L+C\n-\t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 8+P+X+A+V+L+C+G\n+\t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L+X\n+\t\t+---------------------------------------+    \n+\t\t| Save area for GP registers (G)\t| 8+P+A+V+L+X+C\n+\t\t+---------------------------------------+    \n+\t\t| Save area for FP registers (F)\t| 8+P+A+V+L+X+C+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -2777,23 +2838,23 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \t\t| Parameter save area (P)\t\t| 24\n \t\t+---------------------------------------+\n-\t\t| Float/int conversion temporary (X)\t| 24+P\n-\t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 24+P+X\n-\t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t| 24+P+X+A\n-\t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 24+P+X+A+L\n-\t\t+---------------------------------------+\n-\t\t| Possible alignment area (X)\t\t| 24+P+X+A+L+F\n+\t\t| Alloca space (A)\t\t\t| 24+P\n+\t\t+---------------------------------------+     \n+\t\t| Local variable space (L)\t\t| 24+P+A\n+\t\t+---------------------------------------+     \n+\t\t| Float/int conversion temporary (X)\t| 24+P+A+L\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 24+P+X+A+L+F+X\n-\t\t+---------------------------------------+\n-\t\t| Save area for CR (C)\t\t\t| 24+P+X+A+L+F+X+G\n-\t\t+---------------------------------------+\n-\t\t| Save area for TOC (T)\t\t\t| 24+P+X+A+L+F+X+G+C\n-\t\t+---------------------------------------+\n-\t\t| Save area for LR (R)\t\t\t| 24+P+X+A+L+F+X+G+C+T\n+\t\t| Save area for FP registers (F)\t| 24+P+A+L+X\n+\t\t+---------------------------------------+     \n+\t\t| Possible alignment area (Y)\t\t| 24+P+A+L+X+F\n+\t\t+---------------------------------------+     \n+\t\t| Save area for GP registers (G)\t| 24+P+A+L+X+F+Y\n+\t\t+---------------------------------------+     \n+\t\t| Save area for CR (C)\t\t\t| 24+P+A+L+X+F+Y+G\n+\t\t+---------------------------------------+     \n+\t\t| Save area for TOC (T)\t\t\t| 24+P+A+L+X+F+Y+G+C\n+\t\t+---------------------------------------+     \n+\t\t| Save area for LR (R)\t\t\t| 24+P+A+L+X+F+Y+G+C+T\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -2941,7 +3002,6 @@ rs6000_stack_info ()\n \t\t\t|| info_ptr->total_size > 220);\n \n   /* Calculate the offsets */\n-  info_ptr->fpmem_offset = info_ptr->total_size - info_ptr->parm_size;\n   switch (abi)\n     {\n     case ABI_NONE:\n@@ -2961,9 +3021,9 @@ rs6000_stack_info ()\n     case ABI_SOLARIS:\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n-      info_ptr->cr_save_offset   = info_ptr->gp_save_offset - reg_size;\n-      info_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->cr_size;\n-      info_ptr->main_save_offset = info_ptr->toc_save_offset - info_ptr->toc_size;\n+      info_ptr->cr_save_offset   = info_ptr->gp_save_offset - info_ptr->cr_size;\n+      info_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->toc_size;\n+      info_ptr->main_save_offset = info_ptr->toc_save_offset - info_ptr->main_size;\n       info_ptr->lr_save_offset   = reg_size;\n       break;\n \n@@ -2980,6 +3040,9 @@ rs6000_stack_info ()\n       break;\n     }\n \n+  if (info_ptr->fpmem_p)\n+    info_ptr->fpmem_offset = STARTING_FRAME_OFFSET - info_ptr->total_size + info_ptr->vars_size;\n+\n   /* Zero offsets if we're not saving those registers */\n   if (!info_ptr->fp_size)\n     info_ptr->fp_save_offset = 0;\n@@ -3004,9 +3067,7 @@ rs6000_stack_info ()\n   else\n     {\n       rs6000_fpmem_size   = info_ptr->fpmem_size;\n-      rs6000_fpmem_offset = STACK_DYNAMIC_OFFSET (current_function_decl) - info_ptr->fpmem_size;\n-      if (rs6000_fpmem_offset > 32767)\n-\tabort ();\n+      rs6000_fpmem_offset = info_ptr->total_size + info_ptr->fpmem_offset;\n     }\n \n   return info_ptr;\n@@ -3792,13 +3853,6 @@ output_epilog (file, size)\n \tfputs (\"\\t.byte 31\\n\", file);\n     }\n \n-  /* Reset varargs and save TOC indicator */\n-  rs6000_sysv_varargs_p = 0;\n-  rs6000_save_toc_p = 0;\n-  rs6000_fpmem_size = 0;\n-  rs6000_fpmem_offset = 0;\n-  pic_offset_table_rtx = (rtx)0;\n-\n   if (DEFAULT_ABI == ABI_NT)\n     {\n       RS6000_OUTPUT_BASENAME (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));"}, {"sha": "7626eff03c5ac0caa11c90bf53a3f120ae862255", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7df97e69d2ec38647ca8eac2126062603a908ab/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7df97e69d2ec38647ca8eac2126062603a908ab/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a7df97e69d2ec38647ca8eac2126062603a908ab", "patch": "@@ -1190,14 +1190,17 @@ extern int rs6000_sysv_varargs_p;\n /* Align an address */\n #define ALIGN(n,a) (((n) + (a) - 1) & ~((a) - 1))\n \n+/* Initialize data used by insn expanders.  This is called from\n+   init_emit, once for each function, before code is generated. */\n+#define INIT_EXPANDERS rs6000_init_expanders ()\n+\n /* Size of V.4 varargs area in bytes */\n #define RS6000_VARARGS_SIZE \\\n   ((GP_ARG_NUM_REG * (TARGET_32BIT ? 4 : 8)) + (FP_ARG_NUM_REG * 8) + 8)\n \n /* Offset of V.4 varargs area */\n #define RS6000_VARARGS_OFFSET\t\t\t\t\t\t\\\n   (ALIGN (current_function_outgoing_args_size, 8)\t\t\t\\\n-   + ALIGN (rs6000_fpmem_size, 8)\t\t\t\t\t\\\n    + RS6000_SAVE_AREA)\n \n /* Offset within stack frame to start allocating local variables at.\n@@ -1211,7 +1214,6 @@ extern int rs6000_sysv_varargs_p;\n \n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n   (ALIGN (current_function_outgoing_args_size, 8)\t\t\t\\\n-   + ALIGN (rs6000_fpmem_size, 8)\t\t\t\t\t\\\n    + RS6000_VARARGS_AREA\t\t\t\t\t\t\\\n    + RS6000_SAVE_AREA)\n \n@@ -1223,7 +1225,6 @@ extern int rs6000_sysv_varargs_p;\n    machines.  See `function.c' for details.  */\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n   (ALIGN (current_function_outgoing_args_size, 8)\t\t\t\\\n-   + ALIGN (rs6000_fpmem_size, 8)\t\t\t\t\t\\\n    + (STACK_POINTER_OFFSET))\n \n /* If we generate an insn to push BYTES bytes,\n@@ -3009,6 +3010,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n extern int flag_pic;\n extern int optimize;\n extern int flag_expensive_optimizations;\n+extern int frame_pointer_needed;\n \n /* Declare functions in rs6000.c */\n extern void output_options ();\n@@ -3071,6 +3073,9 @@ extern int addrs_ok_for_quad_peep ();\n extern enum reg_class secondary_reload_class ();\n extern int ccr_bit ();\n extern void rs6000_finalize_pic ();\n+extern void rs6000_save_machine_status ();\n+extern void rs6000_restore_machine_status ();\n+extern void rs6000_init_expanders ();\n extern void print_operand ();\n extern void print_operand_address ();\n extern int first_reg_to_save ();"}, {"sha": "c015c3dfcf76e01a0632e2d315e4238cff10bf74", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 140, "deletions": 56, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7df97e69d2ec38647ca8eac2126062603a908ab/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7df97e69d2ec38647ca8eac2126062603a908ab/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a7df97e69d2ec38647ca8eac2126062603a908ab", "patch": "@@ -3550,13 +3550,15 @@\n \t      (use (match_dup 2))\n \t      (use (match_dup 3))\n \t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n \t      (clobber (reg:DF 76))])]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n   operands[3] = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n   operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (Pmode);\n }\")\n \n (define_insn \"*floatsidf2_internal\"\n@@ -3565,145 +3567,203 @@\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n+   (clobber (match_operand:SI 5 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DF 76))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"#\"\n-  [(set_attr \"length\" \"20\")])\n+  [(set_attr \"length\" \"24\")])\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 5 \"gpc_reg_operand\" \"\"))\n    (clobber (reg:DF 76))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   [(set (match_dup 4)\n \t(xor:SI (match_dup 1)\n-\t\t(match_dup 5)))\n-   (set (match_dup 6)\n-\t(unspec [(match_dup 4)\t\t;; low word\n-\t\t (reg:SI 1)] 11))\n-   (set (match_dup 6)\n-\t(unspec [(match_dup 2)\t\t;; high word\n-\t\t (reg:SI 1)\n-\t\t (match_dup 6)] 12))\n+\t\t(match_dup 6)))\n+   (set (match_dup 5)\n+\t(unspec [(const_int 0)] 11))\n+   (set (match_dup 7)\n+\t(unspec [(match_dup 4)\n+\t\t (match_dup 5)] 12))\t;; low word\n+   (set (match_dup 7)\n+\t(unspec [(match_dup 2)\n+\t\t (match_dup 5)\n+\t\t (match_dup 7)] 13))\t;; high word\n    (set (match_dup 0)\n-\t(unspec [(match_dup 6)\n-\t\t (reg:SI 1)] 13))\n+\t(unspec [(match_dup 7)\n+\t\t (match_dup 5)] 14))\n    (set (match_dup 0)\n \t(minus:DF (match_dup 0)\n \t\t  (match_dup 3)))]\n   \"\n {\n-  operands[5] = GEN_INT (0x80000000);\n-  operands[6] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\n+  operands[6] = GEN_INT (0x80000000);\n+  operands[7] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\n }\")\n \n (define_expand \"floatunssidf2\"\n   [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t\t   (unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n \t      (use (match_dup 2))\n \t      (use (match_dup 3))\n+\t      (clobber (match_dup 4))\n \t      (clobber (reg:DF 76))])]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n   operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n   operands[3] = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n+  operands[4] = gen_reg_rtx (Pmode);\n }\")\n \n (define_insn \"*floatunssidf2_internal\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=&f\")\n \t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))\n+   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DF 76))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"#\"\n-  [(set_attr \"length\" \"16\")])\n+  [(set_attr \"length\" \"20\")])\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n    (use (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n    (use (match_operand:DF 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DF 76))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   [(set (match_dup 4)\n-\t(unspec [(match_dup 1)\t\t;; low word\n-\t\t (reg:SI 1)] 11))\n-   (set (match_dup 4)\n-\t(unspec [(match_dup 2)\t\t;; high word\n-\t\t (reg:SI 1)\n-\t\t (reg:DF 76)] 12))\n+\t(unspec [(const_int 0)] 11))\n+   (set (match_dup 5)\n+\t(unspec [(match_dup 1)\n+\t\t (match_dup 4)] 12))\t;; low word\n+   (set (match_dup 5)\n+\t(unspec [(match_dup 2)\n+\t\t (match_dup 4)\n+\t\t (match_dup 5)] 13))\t;; high word\n    (set (match_dup 0)\n-\t(unspec [(match_dup 4)\n-\t\t (reg:SI 1)] 13))\n+\t(unspec [(match_dup 5)\n+\t\t (reg:SI 1)] 14))\n    (set (match_dup 0)\n \t(minus:DF (match_dup 0)\n \t\t  (match_dup 3)))]\n-  \"operands[4] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\")\n+  \"operands[5] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\")\n+\n+;; Load up scratch register with base address + offset if needed\n+(define_insn \"*floatsidf2_loadaddr\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=b\")\n+\t(unspec [(const_int 0)] 11))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  if (rs6000_fpmem_offset > 32760)\n+    {\n+      rtx xop[3];\n \n-;; Note, we list r1 in the unspec, so that the optimizer is not tempted to optimize\n-;; around an alloca call (the memory address is constructed directly from r1).\n+      xop[0] = operands[0];\n+      xop[1] = (frame_pointer_needed) ? frame_pointer_rtx : stack_pointer_rtx;\n+      xop[2] = GEN_INT ((rs6000_fpmem_offset >> 16) & 0xffff);\n+      output_asm_insn (\\\"{cau %0,%2(%1)|addis %0,%1,%2}\\\", xop);\n+    }\n+  else if (rs6000_fpmem_offset < 0)\n+    abort ();\n+\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")])\n \n (define_insn \"*floatsidf2_store1\"\n   [(set (reg:DF 76)\n \t(unspec [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n-\t\t (reg:SI 1)] 11))]\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")] 12))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"*\n {\n-  operands[1] = gen_rtx (MEM, SImode,\n+  rtx indx;\n+\n+  if (rs6000_fpmem_offset > 32760)\n+    indx = operands[1];\n+  else if (frame_pointer_needed)\n+    indx = frame_pointer_rtx;\n+  else\n+    indx = stack_pointer_rtx;\n+\n+  operands[2] = gen_rtx (MEM, SImode,\n \t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (rs6000_fpmem_offset\n+\t\t\t\t  indx,\n+\t\t\t\t  GEN_INT ((rs6000_fpmem_offset & 0xffff)\n \t\t\t\t\t   + ((WORDS_BIG_ENDIAN != 0) * 4))));\n \n-  return \\\"{st|stw} %0,%1\\\";\n+  return \\\"{st|stw} %0,%2\\\";\n }\"\n   [(set_attr \"type\" \"store\")])\n \n (define_insn \"*floatsidf2_store2\"\n   [(set (reg:DF 76)\n \t(unspec [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n-\t\t (reg:SI 1)\n-\t\t (reg:DF 76)] 12))]\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t (reg:DF 76)] 13))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"*\n {\n-  operands[1] = gen_rtx (MEM, SImode,\n+  rtx indx;\n+\n+  if (rs6000_fpmem_offset > 32760)\n+    indx = operands[1];\n+  else if (frame_pointer_needed)\n+    indx = frame_pointer_rtx;\n+  else\n+    indx = stack_pointer_rtx;\n+\n+  operands[2] = gen_rtx (MEM, SImode,\n \t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (rs6000_fpmem_offset\n+\t\t\t\t  indx,\n+\t\t\t\t  GEN_INT ((rs6000_fpmem_offset & 0xffff)\n \t\t\t\t\t   + ((WORDS_BIG_ENDIAN == 0) * 4))));\n \n-  return \\\"{st|stw} %0,%1\\\";\n+  return \\\"{st|stw} %0,%2\\\";\n }\"\n   [(set_attr \"type\" \"store\")])\n \n (define_insn \"*floatsidf2_load\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(unspec [(reg:DF 76)\n-\t\t (reg:SI 1)] 13))]\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"b\")] 14))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"*\n {\n-  operands[1] = gen_rtx (MEM, SImode,\n+  rtx indx;\n+\n+  if (rs6000_fpmem_offset > 32760)\n+    indx = operands[1];\n+  else if (frame_pointer_needed)\n+    indx = frame_pointer_rtx;\n+  else\n+    indx = stack_pointer_rtx;\n+\n+  operands[2] = gen_rtx (MEM, SImode,\n \t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  indx,\n \t\t\t\t  GEN_INT (rs6000_fpmem_offset)));\n \n-  return \\\"lfd %0,%1\\\";\n+  return \\\"lfd %0,%2\\\";\n }\"\n   [(set_attr \"type\" \"fpload\")])\n \n (define_expand \"fix_truncdfsi2\"\n   [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t\t   (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))\n \t      (clobber (match_dup 2))\n-\t      (clobber (match_dup 3))])]\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))])]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n@@ -3715,13 +3775,15 @@\n     }\n \n   operands[2] = gen_reg_rtx (DImode);\n-  operands[3] = gen_rtx (REG, DImode, FPMEM_REGNUM);\n+  operands[3] = gen_reg_rtx (Pmode);\n+  operands[4] = gen_rtx (REG, DImode, FPMEM_REGNUM);\n }\")\n \n (define_insn \"*fix_truncdfsi2_internal\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=f\"))\n+   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"=b\"))\n    (clobber (reg:DI 76))]\n   \"TARGET_HARD_FLOAT\"\n   \"#\"\n@@ -3731,17 +3793,20 @@\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))\n    (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n+   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"\"))\n    (clobber (reg:DI 76))]\n   \"TARGET_HARD_FLOAT\"\n   [(set (match_dup 2)\n \t(sign_extend:DI (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\"))))\n    (set (match_dup 3)\n+\t(unspec [(const_int 0)] 11))\n+   (set (match_dup 4)\n \t(unspec [(match_dup 2)\n-\t\t (reg:SI 1)] 14))\n+\t\t (match_dup 3)] 15))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(unspec [(match_dup 3)\n-\t\t (reg:SI 1)] 15))]\n-  \"operands[3] = gen_rtx (REG, DImode, FPMEM_REGNUM);\")\n+\t(unspec [(match_dup 4)\n+\t\t (match_dup 3)] 16))]\n+  \"operands[4] = gen_rtx (REG, DImode, FPMEM_REGNUM);\")\n \n (define_insn \"*fctiwz\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n@@ -3753,32 +3818,51 @@\n (define_insn \"*fix_truncdfsi2_store\"\n   [(set (reg:DI 76)\n \t(unspec [(match_operand:DI 0 \"gpc_reg_operand\" \"f\")\n-\t\t (reg:SI 1)] 14))]\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"b\")] 15))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n   \"*\n {\n-  operands[1] = gen_rtx (MEM, DFmode,\n+  rtx indx;\n+\n+  if (rs6000_fpmem_offset > 32760)\n+    indx = operands[1];\n+  else if (frame_pointer_needed)\n+    indx = frame_pointer_rtx;\n+  else\n+    indx = stack_pointer_rtx;\n+\n+  operands[2] = gen_rtx (MEM, DFmode,\n \t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (rs6000_fpmem_offset)));\n+\t\t\t\t  indx,\n+\t\t\t\t  GEN_INT ((rs6000_fpmem_offset & 0xffff))));\n \n-  return \\\"stfd %0,%1\\\";\n+  return \\\"stfd %0,%2\\\";\n }\"\n   [(set_attr \"type\" \"fpstore\")])\n \n (define_insn \"*fix_truncdfsi2_load\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec [(reg:DI 76)\n-\t\t (reg:SI 1)] 15))]\n+\t\t (match_operand:SI 1 \"gpc_reg_operand\" \"b\")] 16))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n   \"*\n {\n-  operands[1] = gen_rtx (MEM, DFmode,\n+  rtx indx;\n+\n+  if (rs6000_fpmem_offset > 32760)\n+    indx = operands[1];\n+  else if (frame_pointer_needed)\n+    indx = frame_pointer_rtx;\n+  else\n+    indx = stack_pointer_rtx;\n+\n+  operands[2] = gen_rtx (MEM, DFmode,\n \t\t\t gen_rtx (PLUS, Pmode,\n-\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (rs6000_fpmem_offset + ((WORDS_BIG_ENDIAN) ? 4 : 0))));\n+\t\t\t\t  indx,\n+\t\t\t\t  GEN_INT ((rs6000_fpmem_offset & 0xffff)\n+\t\t\t\t\t   + ((WORDS_BIG_ENDIAN) ? 4 : 0))));\n \n-  return \\\"{l|lwz} %0,%1\\\";\n+  return \\\"{l|lwz} %0,%2\\\";\n }\"\n   [(set_attr \"type\" \"load\")])\n "}]}