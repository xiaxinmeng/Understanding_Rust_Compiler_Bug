{"sha": "c40c6a50fd4da342c87a715ae83927a37797e094", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQwYzZhNTBmZDRkYTM0MmM4N2E3MTVhZTgzOTI3YTM3Nzk3ZTA5NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-10T09:22:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-10T09:22:33Z"}, "message": "openmp: Add support for declare simd and declare variant in a attribute syntax\n\nThis patch adds support for declare simd and declare variant in attribute\nsyntax.  Either in attribute-specifier-seq at the start of declaration, in\nthat case it has similar restriction to pragma-syntax, that there is a single\nfunction declaration/definition in the declaration, rather than variable\ndeclaration or more than one function declarations or mix of function and\nvariable declarations.  Or after the declarator id, in that case it applies\njust to the single function declaration and the same declaration can have\nmultiple such attributes.  Or both.\n\nFurthermore, cp_parser_statement has been adjusted so that it doesn't\naccept [[omp::directive (parallel)]] etc. before statements that don't\ntake attributes at all, or where those attributes don't appertain to\nthe statement but something else (e.g. to label, using directive,\ndeclaration, etc.).\n\n2021-08-10  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/cp/\n\t* parser.h (struct cp_omp_declare_simd_data): Remove\n\tin_omp_attribute_pragma and clauses members, add loc and attribs.\n\t(struct cp_oacc_routine_data): Remove loc member, add clauses\n\tmember.\n\t* parser.c (cp_finalize_omp_declare_simd): New function.\n\t(cp_parser_handle_statement_omp_attributes): Mention in\n\tfunction comment the function is used also for\n\tattribute-declaration.\n\t(cp_parser_handle_directive_omp_attributes): New function.\n\t(cp_parser_statement): Don't call\n\tcp_parser_handle_statement_omp_attributes if statement doesn't\n\thave attribute-specifier-seq at the beginning at all or if\n\tif those attributes don't appertain to the statement.\n\t(cp_parser_simple_declaration): Call\n\tcp_parser_handle_directive_omp_attributes and\n\tcp_finalize_omp_declare_simd.\n\t(cp_parser_explicit_instantiation): Likewise.\n\t(cp_parser_init_declarator): Initialize prefix_attributes\n\tonly after parsing declarators.\n\t(cp_parser_direct_declarator): Call\n\tcp_parser_handle_directive_omp_attributes and\n\tcp_finalize_omp_declare_simd.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_single_declaration): Likewise.\n\t(cp_parser_omp_declare_simd): Don't initialize\n\tdata.in_omp_attribute_pragma, instead initialize\n\tdata.attribs[0] and data.attribs[1].\n\t(cp_finish_omp_declare_variant): Remove\n\tin_omp_attribute_pragma argument, instead use\n\tparser->lexer->in_omp_attribute_pragma.\n\t(cp_parser_late_parsing_omp_declare_simd): Adjust\n\tcp_finish_omp_declare_variant caller.  Handle attribute-syntax\n\tdeclare simd/variant.\ngcc/testsuite/\n\t* g++.dg/gomp/attrs-1.C (bar): Add missing semicolon after\n\t[[omp::directive (threadprivate (t2))]].  Add tests with\n\tif/while/switch after parallel in attribute syntax.\n\t(corge): Add missing omp:: before directive.\n\t* g++.dg/gomp/attrs-2.C (bar): Add missing semicolon after\n\t[[omp::directive (threadprivate (t2))]].\n\t* g++.dg/gomp/attrs-10.C: New test.\n\t* g++.dg/gomp/attrs-11.C: New test.", "tree": {"sha": "a86711ef18c76c4e627b1a20fbe5b7a8cee20b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86711ef18c76c4e627b1a20fbe5b7a8cee20b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c40c6a50fd4da342c87a715ae83927a37797e094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c40c6a50fd4da342c87a715ae83927a37797e094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c40c6a50fd4da342c87a715ae83927a37797e094", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c40c6a50fd4da342c87a715ae83927a37797e094/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c318f8e42b3f90bed5a0648e42c0182a497566b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c318f8e42b3f90bed5a0648e42c0182a497566b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c318f8e42b3f90bed5a0648e42c0182a497566b7"}], "stats": {"total": 754, "additions": 726, "deletions": 28}, "files": [{"sha": "34be15e9189c0cc7698c799b7b849f6d7773e1a3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 398, "deletions": 21, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c40c6a50fd4da342c87a715ae83927a37797e094", "patch": "@@ -1440,6 +1440,24 @@ cp_finalize_omp_declare_simd (cp_parser *parser, tree fndecl)\n     }\n }\n \n+/* Similarly, but for use in declaration parsing functions\n+   which call cp_parser_handle_directive_omp_attributes.  */\n+\n+static inline void\n+cp_finalize_omp_declare_simd (cp_parser *parser, cp_omp_declare_simd_data *data)\n+{\n+  if (parser->omp_declare_simd != data)\n+    return;\n+\n+  if (!parser->omp_declare_simd->error_seen\n+      && !parser->omp_declare_simd->fndecl_seen)\n+    error_at (parser->omp_declare_simd->loc,\n+\t      \"%<declare %s%> directive not immediately followed by \"\n+\t      \"function declaration or definition\",\n+\t      parser->omp_declare_simd->variant_p ? \"variant\" : \"simd\");\n+  parser->omp_declare_simd = NULL;\n+}\n+\n /* Diagnose if #pragma acc routine isn't followed immediately by function\n    declaration or definition.  */\n \n@@ -11661,7 +11679,7 @@ struct cp_omp_attribute_data\n };\n \n /* Handle omp::directive and omp::sequence attributes in ATTRS\n-   (if any) at the start of a statement.  */\n+   (if any) at the start of a statement or in attribute-declaration.  */\n \n static tree\n cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n@@ -11858,6 +11876,98 @@ cp_parser_handle_statement_omp_attributes (cp_parser *parser, tree attrs)\n   return attrs;\n }\n \n+/* Handle omp::directive and omp::sequence attributes in *PATTRS\n+   (if any) at the start or after declaration-id of a declaration.  */\n+\n+static void\n+cp_parser_handle_directive_omp_attributes (cp_parser *parser, tree *pattrs,\n+\t\t\t\t\t   cp_omp_declare_simd_data *data,\n+\t\t\t\t\t   bool start)\n+{\n+  if (!flag_openmp && !flag_openmp_simd)\n+    return;\n+\n+  int cnt = 0;\n+  bool bad = false;\n+  bool variant_p = false;\n+  location_t loc = UNKNOWN_LOCATION;\n+  for (tree pa = *pattrs; pa; pa = TREE_CHAIN (pa))\n+    if (get_attribute_namespace (pa) == omp_identifier\n+\t&& is_attribute_p (\"directive\", get_attribute_name (pa)))\n+      {\n+\tfor (tree a = TREE_VALUE (pa); a; a = TREE_CHAIN (a))\n+\t  {\n+\t    tree d = TREE_VALUE (a);\n+\t    gcc_assert (TREE_CODE (d) == DEFERRED_PARSE);\n+\t    cp_token *first = DEFPARSE_TOKENS (d)->first;\n+\t    cp_token *last = DEFPARSE_TOKENS (d)->last;\n+\t    const char *directive[3] = {};\n+\t    for (int i = 0; i < 3; i++)\n+\t      {\n+\t\ttree id = NULL_TREE;\n+\t\tif (first + i == last)\n+\t\t  break;\n+\t\tif (first[i].type == CPP_NAME)\n+\t\t  id = first[i].u.value;\n+\t\telse if (first[i].type == CPP_KEYWORD)\n+\t\t  id = ridpointers[(int) first[i].keyword];\n+\t\telse\n+\t\t  break;\n+\t\tdirective[i] = IDENTIFIER_POINTER (id);\n+\t      }\n+\t    const c_omp_directive *dir = NULL;\n+\t    if (directive[0])\n+\t      dir = c_omp_categorize_directive (directive[0], directive[1],\n+\t\t\t\t\t\tdirective[2]);\n+\t    if (dir == NULL)\n+\t      continue;\n+\t    if (dir->id == PRAGMA_OMP_DECLARE\n+\t\t&& (strcmp (directive[1], \"simd\") == 0\n+\t\t    || strcmp (directive[1], \"variant\") == 0))\n+\t      {\n+\t\tif (cnt++ == 0)\n+\t\t  {\n+\t\t    variant_p = strcmp (directive[1], \"variant\") == 0;\n+\t\t    loc = first->location;\n+\t\t  }\n+\t\tif (start && parser->omp_declare_simd && !bad)\n+\t\t  {\n+\t\t    error_at (first->location,\n+\t\t\t      \"mixing OpenMP directives with attribute and \"\n+\t\t\t      \"pragma syntax on the same declaration\");\n+\t\t    bad = true;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+  if (bad)\n+    {\n+      for (tree *pa = pattrs; *pa; )\n+\tif (get_attribute_namespace (*pa) == omp_identifier\n+\t    && is_attribute_p (\"directive\", get_attribute_name (*pa)))\n+\t  *pa = TREE_CHAIN (*pa);\n+\telse\n+\t  pa = &TREE_CHAIN (*pa);\n+      return;\n+    }\n+  if (cnt == 0)\n+    return;\n+\n+  if (parser->omp_declare_simd == NULL)\n+    {\n+      data->error_seen = false;\n+      data->fndecl_seen = false;\n+      data->variant_p = variant_p;\n+      data->loc = loc;\n+      data->tokens = vNULL;\n+      data->attribs[0] = NULL;\n+      data->attribs[1] = NULL;\n+      parser->omp_declare_simd = data;\n+    }\n+  parser->omp_declare_simd->attribs[!start] = pattrs;\n+}\n+\n /* Parse a statement.\n \n    statement:\n@@ -11935,12 +12045,57 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n     }\n   has_std_attrs = cp_lexer_peek_token (parser->lexer) != token;\n \n+  /* Peek at the next token.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+  bool omp_attrs_forbidden_p;\n+  omp_attrs_forbidden_p = parser->omp_attrs_forbidden_p;\n+\n   if (std_attrs && (flag_openmp || flag_openmp_simd))\n-    std_attrs = cp_parser_handle_statement_omp_attributes (parser, std_attrs);\n+    {\n+      bool handle_omp_attribs = false;\n+      if (token->type == CPP_KEYWORD)\n+\tswitch (token->keyword)\n+\t  {\n+\t  case RID_IF:\n+\t  case RID_SWITCH:\n+\t  case RID_WHILE:\n+\t  case RID_DO:\n+\t  case RID_FOR:\n+\t  case RID_BREAK:\n+\t  case RID_CONTINUE:\n+\t  case RID_RETURN:\n+\t  case RID_CO_RETURN:\n+\t  case RID_GOTO:\n+\t  case RID_AT_TRY:\n+\t  case RID_AT_CATCH:\n+\t  case RID_AT_FINALLY:\n+\t  case RID_AT_SYNCHRONIZED:\n+\t  case RID_AT_THROW:\n+\t  case RID_TRY:\n+\t  case RID_TRANSACTION_ATOMIC:\n+\t  case RID_TRANSACTION_RELAXED:\n+\t  case RID_SYNCHRONIZED:\n+\t  case RID_ATOMIC_NOEXCEPT:\n+\t  case RID_ATOMIC_CANCEL:\n+\t  case RID_TRANSACTION_CANCEL:\n+\t    handle_omp_attribs = true;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+      else if (token->type == CPP_SEMICOLON\n+\t       || token->type == CPP_OPEN_BRACE\n+\t       || token->type == CPP_PRAGMA)\n+\thandle_omp_attribs = true;\n+      if (handle_omp_attribs)\n+\t{\n+\t  std_attrs = cp_parser_handle_statement_omp_attributes (parser,\n+\t\t\t\t\t\t\t\t std_attrs);\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t}\n+    }\n   parser->omp_attrs_forbidden_p = false;\n \n-  /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n   /* Remember the location of the first token in the statement.  */\n   cp_token *statement_token = token;\n   statement_location = token->location;\n@@ -12058,6 +12213,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n      a statement all its own.  */\n   else if (token->type == CPP_PRAGMA)\n     {\n+     do_pragma:;\n       cp_lexer *lexer = parser->lexer;\n       bool do_restart = false;\n       /* Only certain OpenMP pragmas are attached to statements, and thus\n@@ -12120,7 +12276,46 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t    return;\n \t  /* It didn't work, restore the post-attribute position.  */\n \t  if (has_std_attrs)\n-\t    cp_lexer_set_token_position (parser->lexer, statement_token);\n+\t    {\n+\t      cp_lexer_set_token_position (parser->lexer, statement_token);\n+\t      if (flag_openmp || flag_openmp_simd)\n+\t\t{\n+\t\t  size_t i = 1;\n+\t\t  bool handle_omp_attribs = true;\n+\t\t  while (cp_lexer_peek_nth_token (parser->lexer, i)->keyword\n+\t\t\t == RID_EXTENSION)\n+\t\t    i++;\n+\t\t  switch (cp_lexer_peek_nth_token (parser->lexer, i)->keyword)\n+\t\t    {\n+\t\t    case RID_ASM:\n+\t\t    case RID_NAMESPACE:\n+\t\t    case RID_USING:\n+\t\t    case RID_LABEL:\n+\t\t    case RID_STATIC_ASSERT:\n+\t\t      /* Don't handle OpenMP attribs on keywords that\n+\t\t\t always start a declaration statement but don't\n+\t\t\t accept attribute before it and therefore\n+\t\t\t the tentative cp_parser_declaration_statement\n+\t\t\t fails to parse because of that.  */\n+\t\t      handle_omp_attribs = false;\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  if (handle_omp_attribs)\n+\t\t    {\n+\t\t      parser->omp_attrs_forbidden_p = omp_attrs_forbidden_p;\n+\t\t      std_attrs\n+\t\t\t= cp_parser_handle_statement_omp_attributes\n+\t\t\t\t\t(parser, std_attrs);\n+\t\t      parser->omp_attrs_forbidden_p = false;\n+\t\t      token = cp_lexer_peek_token (parser->lexer);\n+\t\t      if (token->type == CPP_PRAGMA)\n+\t\t\tgoto do_pragma;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n       /* All preceding labels have been parsed at this point.  */\n       if (loc_after_labels != NULL)\n@@ -14770,6 +14965,12 @@ cp_parser_simple_declaration (cp_parser* parser,\n   /* We no longer need to defer access checks.  */\n   stop_deferring_access_checks ();\n \n+  cp_omp_declare_simd_data odsd;\n+  if (decl_specifiers.attributes && (flag_openmp || flag_openmp_simd))\n+    cp_parser_handle_directive_omp_attributes (parser,\n+\t\t\t\t\t       &decl_specifiers.attributes,\n+\t\t\t\t\t       &odsd, true);\n+\n   /* In a block scope, a valid declaration must always have a\n      decl-specifier-seq.  By not trying to parse declarators, we can\n      resolve the declaration/expression ambiguity more quickly.  */\n@@ -14962,6 +15163,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t  else\n \t    {\n \t      pop_deferring_access_checks ();\n+\t      cp_finalize_omp_declare_simd (parser, &odsd);\n \t      return;\n \t    }\n \t}\n@@ -15042,6 +15244,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n  done:\n   pop_deferring_access_checks ();\n+  cp_finalize_omp_declare_simd (parser, &odsd);\n }\n \n /* Helper of cp_parser_simple_declaration, parse a decomposition declaration.\n@@ -18659,6 +18862,13 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t&decl_specifiers,\n \t\t\t\t&declares_class_or_enum);\n+\n+  cp_omp_declare_simd_data odsd;\n+  if (decl_specifiers.attributes && (flag_openmp || flag_openmp_simd))\n+    cp_parser_handle_directive_omp_attributes (parser,\n+\t\t\t\t\t       &decl_specifiers.attributes,\n+\t\t\t\t\t       &odsd, true);\n+\n   /* If there was exactly one decl-specifier, and it declared a class,\n      and there's no declarator, then we have an explicit type\n      instantiation.  */\n@@ -18727,6 +18937,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n   timevar_pop (TV_TEMPLATE_INST);\n+\n+  cp_finalize_omp_declare_simd (parser, &odsd);\n }\n \n /* Parse an explicit-specialization.\n@@ -21964,10 +22176,6 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (decl_spec_seq_has_spec_p (decl_specifiers, ds_consteval))\n     flags |= CP_PARSER_FLAGS_CONSTEVAL;\n \n-  /* Gather the attributes that were provided with the\n-     decl-specifiers.  */\n-  prefix_attributes = decl_specifiers->attributes;\n-\n   /* Assume that this is not the declarator for a function\n      definition.  */\n   if (function_definition_p)\n@@ -22031,6 +22239,10 @@ cp_parser_init_declarator (cp_parser* parser,\n   else\n     asm_specification = NULL_TREE;\n \n+  /* Gather the attributes that were provided with the\n+     decl-specifiers.  */\n+  prefix_attributes = decl_specifiers->attributes;\n+\n   /* Look for attributes.  */\n   attributes_start_token = cp_lexer_peek_token (parser->lexer);\n   attributes = cp_parser_attributes_opt (parser);\n@@ -22679,13 +22891,27 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t\t  attrs = cp_parser_std_attribute_spec_seq (parser);\n \n+\t\t  cp_omp_declare_simd_data odsd;\n+\t\t  if ((flag_openmp || flag_openmp_simd)\n+\t\t      && declarator\n+\t\t      && declarator->std_attributes\n+\t\t      && declarator->kind == cdk_id)\n+\t\t    {\n+\t\t      tree *pa = &declarator->std_attributes;\n+\t\t      cp_parser_handle_directive_omp_attributes (parser, pa,\n+\t\t\t\t\t\t\t\t &odsd, false);\n+\t\t    }\n+\n \t\t  /* In here, we handle cases where attribute is used after\n \t\t     the function declaration.  For example:\n \t\t     void func (int x) __attribute__((vector(..)));  */\n \t\t  tree gnu_attrs = NULL_TREE;\n \t\t  tree requires_clause = NULL_TREE;\n-\t\t  late_return = (cp_parser_late_return_type_opt\n-\t\t\t\t (parser, declarator, requires_clause));\n+\t\t  late_return\n+\t\t    = cp_parser_late_return_type_opt (parser, declarator,\n+\t\t\t\t\t\t      requires_clause);\n+\n+\t\t  cp_finalize_omp_declare_simd (parser, &odsd);\n \n \t\t  /* Parse the virt-specifier-seq.  */\n \t\t  virt_specifiers = cp_parser_virt_specifier_seq_opt (parser);\n@@ -26435,6 +26661,13 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t | CP_PARSER_FLAGS_TYPENAME_OPTIONAL),\n \t\t\t\t&decl_specifiers,\n \t\t\t\t&declares_class_or_enum);\n+\n+  cp_omp_declare_simd_data odsd;\n+  if (decl_specifiers.attributes && (flag_openmp || flag_openmp_simd))\n+    cp_parser_handle_directive_omp_attributes (parser,\n+\t\t\t\t\t       &decl_specifiers.attributes,\n+\t\t\t\t\t       &odsd, true);\n+\n   /* Check for an invalid type-name.  */\n   if (!decl_specifiers.any_type_specifiers_p\n       && cp_parser_parse_and_diagnose_invalid_type_name (parser))\n@@ -26554,6 +26787,10 @@ cp_parser_member_declaration (cp_parser* parser)\n \t being declared.  */\n       prefix_attributes = decl_specifiers.attributes;\n       decl_specifiers.attributes = NULL_TREE;\n+      if (parser->omp_declare_simd\n+\t  && (parser->omp_declare_simd->attribs[0]\n+\t      == &decl_specifiers.attributes))\n+\tparser->omp_declare_simd->attribs[0] = &prefix_attributes;\n \n       /* See if these declarations will be friends.  */\n       friend_p = cp_parser_friend_p (&decl_specifiers);\n@@ -26942,6 +27179,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n  out:\n   parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+  cp_finalize_omp_declare_simd (parser, &odsd);\n }\n \n /* Parse a pure-specifier.\n@@ -31067,6 +31305,13 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t\t | CP_PARSER_FLAGS_TYPENAME_OPTIONAL),\n \t\t\t\t&decl_specifiers,\n \t\t\t\t&declares_class_or_enum);\n+\n+  cp_omp_declare_simd_data odsd;\n+  if (decl_specifiers.attributes && (flag_openmp || flag_openmp_simd))\n+    cp_parser_handle_directive_omp_attributes (parser,\n+\t\t\t\t\t       &decl_specifiers.attributes,\n+\t\t\t\t\t       &odsd, true);\n+\n   if (friend_p)\n     *friend_p = cp_parser_friend_p (&decl_specifiers);\n \n@@ -31195,6 +31440,8 @@ cp_parser_single_declaration (cp_parser* parser,\n   parser->qualifying_scope = NULL_TREE;\n   parser->object_scope = NULL_TREE;\n \n+  cp_finalize_omp_declare_simd (parser, &odsd);\n+\n   return decl;\n }\n \n@@ -43546,9 +43793,10 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n       data.error_seen = false;\n       data.fndecl_seen = false;\n       data.variant_p = variant_p;\n-      data.in_omp_attribute_pragma = parser->lexer->in_omp_attribute_pragma;\n       data.tokens = vNULL;\n-      data.clauses = NULL_TREE;\n+      data.attribs[0] = NULL;\n+      data.attribs[1] = NULL;\n+      data.loc = UNKNOWN_LOCATION;\n       /* It is safe to take the address of a local variable; it will only be\n \t used while this scope is live.  */\n       parser->omp_declare_simd = &data;\n@@ -43985,7 +44233,7 @@ cp_parser_omp_context_selector_specification (cp_parser *parser,\n \n static tree\n cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n-\t\t\t       tree attrs, bool in_omp_attribute_pragma)\n+\t\t\t       tree attrs)\n {\n   matching_parens parens;\n   if (!parens.require_open (parser))\n@@ -44044,7 +44292,7 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n   location_t varid_loc = make_location (caret_loc, start_loc, finish_loc);\n \n   /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-  if (in_omp_attribute_pragma\n+  if (parser->lexer->in_omp_attribute_pragma\n       && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n       && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n     cp_lexer_consume_token (parser->lexer);\n@@ -44121,11 +44369,10 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n       cp_lexer_consume_token (parser->lexer);\n       if (strcmp (kind, \"simd\") == 0)\n \t{\n-\t  /* For now only in C++ attributes, do it always for OpenMP 5.1.  */\n-\t  if (data->in_omp_attribute_pragma\n-\t      && cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t  /* For now only in C++ attributes, do it always for OpenMP 5.1.\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n \t      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n-\t    cp_lexer_consume_token (parser->lexer);\n+\t    cp_lexer_consume_token (parser->lexer);  */\n \n \t  cl = cp_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n \t\t\t\t\t  \"#pragma omp declare simd\",\n@@ -44142,12 +44389,142 @@ cp_parser_late_parsing_omp_declare_simd (cp_parser *parser, tree attrs)\n \t{\n \t  gcc_assert (strcmp (kind, \"variant\") == 0);\n \t  attrs\n-\t    = cp_finish_omp_declare_variant (parser, pragma_tok, attrs,\n-\t\t\t\t\t     data->in_omp_attribute_pragma);\n+\t    = cp_finish_omp_declare_variant (parser, pragma_tok, attrs);\n \t}\n       cp_parser_pop_lexer (parser);\n     }\n \n+  cp_lexer *lexer = NULL;\n+  for (int i = 0; i < 2; i++)\n+    {\n+      if (data->attribs[i] == NULL)\n+\tcontinue;\n+      for (tree *pa = data->attribs[i]; *pa; )\n+\tif (get_attribute_namespace (*pa) == omp_identifier\n+\t    && is_attribute_p (\"directive\", get_attribute_name (*pa)))\n+\t  {\n+\t    for (tree a = TREE_VALUE (*pa); a; a = TREE_CHAIN (a))\n+\t      {\n+\t\ttree d = TREE_VALUE (a);\n+\t\tgcc_assert (TREE_CODE (d) == DEFERRED_PARSE);\n+\t\tcp_token *first = DEFPARSE_TOKENS (d)->first;\n+\t\tcp_token *last = DEFPARSE_TOKENS (d)->last;\n+\t\tconst char *directive[3] = {};\n+\t\tfor (int j = 0; j < 3; j++)\n+\t\t  {\n+\t\t    tree id = NULL_TREE;\n+\t\t    if (first + j == last)\n+\t\t      break;\n+\t\t    if (first[j].type == CPP_NAME)\n+\t\t      id = first[j].u.value;\n+\t\t    else if (first[j].type == CPP_KEYWORD)\n+\t\t      id = ridpointers[(int) first[j].keyword];\n+\t\t    else\n+\t\t      break;\n+\t\t    directive[j] = IDENTIFIER_POINTER (id);\n+\t\t  }\n+\t\tconst c_omp_directive *dir = NULL;\n+\t\tif (directive[0])\n+\t\t  dir = c_omp_categorize_directive (directive[0], directive[1],\n+\t\t\t\t\t\t    directive[2]);\n+\t\tif (dir == NULL)\n+\t\t  {\n+\t\t    error_at (first->location,\n+\t\t\t      \"unknown OpenMP directive name in \"\n+\t\t\t      \"%<omp::directive%> attribute argument\");\n+\t\t    continue;\n+\t\t  }\n+\t\tif (dir->id != PRAGMA_OMP_DECLARE\n+\t\t    || (strcmp (directive[1], \"simd\") != 0\n+\t\t\t&& strcmp (directive[1], \"variant\") != 0))\n+\t\t  {\n+\t\t    error_at (first->location,\n+\t\t\t      \"OpenMP directive other than %<declare simd%> \"\n+\t\t\t      \"or %<declare variant%> appertains to a \"\n+\t\t\t      \"declaration\");\n+\t\t    continue;\n+\t\t  }\n+\n+\t\tif (!flag_openmp && strcmp (directive[1], \"simd\") != 0)\n+\t\t  continue;\n+\t\tif (lexer == NULL)\n+\t\t  {\n+\t\t    lexer = cp_lexer_alloc ();\n+\t\t    lexer->debugging_p = parser->lexer->debugging_p;\n+\t\t  }\n+\t\tvec_safe_reserve (lexer->buffer, (last - first) + 2);\n+\t\tcp_token tok = {};\n+\t\ttok.type = CPP_PRAGMA;\n+\t\ttok.keyword = RID_MAX;\n+\t\ttok.u.value = build_int_cst (NULL, PRAGMA_OMP_DECLARE);\n+\t\ttok.location = first->location;\n+\t\tlexer->buffer->quick_push (tok);\n+\t\twhile (++first < last)\n+\t\t  lexer->buffer->quick_push (*first);\n+\t\ttok = {};\n+\t\ttok.type = CPP_PRAGMA_EOL;\n+\t\ttok.keyword = RID_MAX;\n+\t\ttok.location = last->location;\n+\t\tlexer->buffer->quick_push (tok);\n+\t\ttok = {};\n+\t\ttok.type = CPP_EOF;\n+\t\ttok.keyword = RID_MAX;\n+\t\ttok.location = last->location;\n+\t\tlexer->buffer->quick_push (tok);\n+\t\tlexer->next = parser->lexer;\n+\t\tlexer->next_token = lexer->buffer->address ();\n+\t\tlexer->last_token = lexer->next_token\n+\t\t\t\t    + lexer->buffer->length ()\n+\t\t      - 1;\n+\t\tlexer->in_omp_attribute_pragma = true;\n+\t\tparser->lexer = lexer;\n+\t\t/* Move the current source position to that of the first token\n+\t\t   in the new lexer.  */\n+\t\tcp_lexer_set_source_position_from_token (lexer->next_token);\n+\n+\t\tcp_token *pragma_tok = cp_lexer_consume_token (parser->lexer);\n+\t\ttree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\tconst char *kind = IDENTIFIER_POINTER (id);\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\n+\t\ttree c, cl;\n+\t\tif (strcmp (kind, \"simd\") == 0)\n+\t\t  {\n+\t\t    if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA)\n+\t\t\t&& cp_lexer_nth_token_is (parser->lexer, 2, CPP_NAME))\n+\t\t      cp_lexer_consume_token (parser->lexer);\n+\n+\t\t    omp_clause_mask mask = OMP_DECLARE_SIMD_CLAUSE_MASK;\n+\t\t    cl = cp_parser_omp_all_clauses (parser, mask,\n+\t\t\t\t\t\t    \"#pragma omp declare simd\",\n+\t\t\t\t\t\t    pragma_tok);\n+\t\t    if (cl)\n+\t\t      cl = tree_cons (NULL_TREE, cl, NULL_TREE);\n+\t\t    c = build_tree_list (get_identifier (\"omp declare simd\"),\n+\t\t\t\t\t cl);\n+\t\t    TREE_CHAIN (c) = attrs;\n+\t\t    if (processing_template_decl)\n+\t\t      ATTR_IS_DEPENDENT (c) = 1;\n+\t\t    attrs = c;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    gcc_assert (strcmp (kind, \"variant\") == 0);\n+\t\t    attrs\n+\t\t      = cp_finish_omp_declare_variant (parser, pragma_tok,\n+\t\t\t\t\t\t       attrs);\n+\t\t  }\n+\t\tgcc_assert (parser->lexer != lexer);\n+\t\tvec_safe_truncate (lexer->buffer, 0);\n+\t      }\n+\t    *pa = TREE_CHAIN (*pa);\n+\t  }\n+\telse\n+\t  pa = &TREE_CHAIN (*pa);\n+    }\n+  if (lexer)\n+    cp_lexer_destroy (lexer);\n+\n   data->fndecl_seen = true;\n   return attrs;\n }"}, {"sha": "3669587cebdffd6a8101b90664f6587363c2813b", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=c40c6a50fd4da342c87a715ae83927a37797e094", "patch": "@@ -216,15 +216,14 @@ struct cp_omp_declare_simd_data {\n   bool error_seen; /* Set if error has been reported.  */\n   bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n   bool variant_p; /* Set for #pragma omp declare variant.  */\n-  bool in_omp_attribute_pragma; /* True if declare simd/variant comes from\n-\t\t\t\t   C++11 attribute rather than pragma.  */\n+  location_t loc;\n   vec<cp_token_cache_ptr> tokens;\n-  tree clauses;\n+  tree *attribs[2];\n };\n \n /* Helper data structure for parsing #pragma acc routine.  */\n struct cp_oacc_routine_data : cp_omp_declare_simd_data {\n-  location_t loc;\n+  tree clauses;\n };\n \n /* The cp_parser structure represents the C++ parser.  */"}, {"sha": "5c7007be8a63a0dd19c782b97834c1a10095ae4c", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=c40c6a50fd4da342c87a715ae83927a37797e094", "patch": "@@ -501,10 +501,18 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     }\n   }\n   extern int t2;\n-  [[omp::directive (threadprivate (t2))]]\n+  [[omp::directive (threadprivate (t2))]];\n   extern int t2;\n   [[omp::directive (declare reduction (dr: int: omp_out += omp_in) initializer (omp_priv = 0))]]\n   ;\n+  [[omp::directive (parallel)]]\n+  if (0)\n+    ;\n+  [[omp::directive (parallel)]]\n+  while (0)\n+    ;\n+  [[omp::directive (parallel)]]\n+  switch (0) { case 1: break; default: break; }\n }\n \n void corge1 ();\n@@ -521,7 +529,7 @@ corge ()\n     omp::directive (declare simd simdlen(8) notinbranch)]]\n   extern int corge3 (int l, int *p);\n   [[omp::directive (declare simd simdlen(4) linear(l) aligned(p:4) uniform(p) inbranch),\n-    directive (declare simd simdlen(8) notinbranch)]]\n+    omp::directive (declare simd simdlen(8) notinbranch)]]\n   extern int corge4 (int l, int *p);\n   [[omp::sequence (directive (declare simd simdlen(4) linear(l) aligned(p:4) uniform(p) inbranch),\n     omp::directive (declare simd simdlen(8) notinbranch))]]"}, {"sha": "a78f892c237382d3d8e0aa767c2c17c90e47b78d", "filename": "gcc/testsuite/g++.dg/gomp/attrs-10.C", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-10.C?ref=c40c6a50fd4da342c87a715ae83927a37797e094", "patch": "@@ -0,0 +1,240 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fopenmp -ffat-lto-objects -fdump-tree-gimple\" }\n+\n+extern \"C\" void abort ();\n+\n+[[omp::directive (declare simd, linear (l))]] extern int f1 (int l);\n+extern int f2 (int), f3 [[omp::directive (declare simd, uniform (m))]] (int m), f4 (int), z;\n+[[omp::directive (declare simd, linear (l), simdlen(4))]] extern int f5 [[omp::directive (declare simd uniform (l) simdlen (8) notinbranch)]] (int l);\n+\n+int\n+f1 (int l)\n+{\n+  return l;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM16l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN16l__Z2f1i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f2 (int l)\n+{\n+  return l + 1;\n+}\n+\n+// { dg-final { scan-assembler-not \"_ZGV\\[a-zA-Z0-9]__Z2f2i:\" { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f3 (int l)\n+{\n+  return l + 2;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM16u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN16u__Z2f3i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f4 (int l)\n+{\n+  return l + 3;\n+}\n+\n+// { dg-final { scan-assembler-not \"_ZGV\\[a-zA-Z0-9]__Z2f4i:\" { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f5 (int l)\n+{\t// { dg-warning \"GCC does not currently support mixed size types for 'simd' functions\" \"\" { target aarch64*-*-* } .-1 }\n+  return l + 4;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN4l__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN8u__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8u__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8u__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN8u__Z2f5i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-not \"_ZGV\\[bcde]M8u__Z2f5i:\" { target { i?86-*-* x86_64-*-* } } } }\n+\n+[[omp::directive (declare simd, linear (l), simdlen(4), notinbranch),\n+  omp::directive (declare simd, uniform (l), simdlen(4), inbranch)]]\n+int\n+f6 [[omp::sequence (directive (declare simd uniform (l) simdlen (8), notinbranch),\n+\t\t    omp::directive (declare simd linear (l) simdlen (8) inbranch))]] (int l)\n+{\t// { dg-warning \"GCC does not currently support mixed size types for 'simd' functions\" \"\" { target aarch64*-*-* } .-2 }\n+  return l + 5;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbM8l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN8u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM8l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM4u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN4l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM4u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN4l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM8l__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN8u__Z2f6i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-not \"_ZGV\\[bcde]M4l__Z2f6i:\" { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-not \"_ZGV\\[bcde]N4u__Z2f6i:\" { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-not \"_ZGV\\[bcde]M8u__Z2f6i:\" { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-not \"_ZGV\\[bcde]N8l__Z2f6i:\" { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f7 (int l)\n+{\n+  return l + 6;\n+}\n+\n+// { dg-final { scan-assembler-not \"_ZGV\\[a-zA-Z0-9]__Z2f7i:\" { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f8 (int l)\n+{\n+  return l + 7;\n+}\n+\n+// { dg-final { scan-assembler-not \"_ZGV\\[a-zA-Z0-9]__Z2f8i:\" { target { i?86-*-* x86_64-*-* } } } }\n+\n+[[omp::sequence (omp::directive (declare variant (f7), match (construct={parallel})),\n+\t\t directive (declare simd uniform (l), simdlen(4)))]]\n+int\n+f9 [[omp::directive (declare simd uniform (l) simdlen (8)),\n+     omp::directive (declare variant (f8) match (construct={parallel,for}))]] (int l)\n+{\t// { dg-warning \"GCC does not currently support mixed size types for 'simd' functions\" \"\" { target aarch64*-*-* } .-2 }\n+  return l + 8;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN4u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbM8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVbN8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN8u__Z2f9i:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+int z;\n+\n+void\n+test ()\n+{\n+  [[omp::directive (parallel)]]\n+  if (f9 (3) != 9)\n+    abort ();\n+  [[omp::directive (parallel for)]]\n+  for (int i = 0; i < 1; i++)\n+    if (f9 (4) != 11)\n+      abort ();\n+  if (f9 (5) != 13)\n+    abort ();\n+}\n+\n+// { dg-final { scan-tree-dump-times \" = f7 \\\\\\(3\\\\\\);\" 1 \"gimple\" } }\n+// { dg-final { scan-tree-dump-times \" = f8 \\\\\\(4\\\\\\);\" 1 \"gimple\" } }\n+// { dg-final { scan-tree-dump-times \" = f9 \\\\\\(5\\\\\\);\" 1 \"gimple\" } }\n+\n+template <int N>\n+int\n+f10 (int x)\n+{\n+  return x + N;\n+}\n+\n+template [[omp::directive (declare simd, notinbranch)]] int f10<0> (int);\n+\n+// { dg-final { scan-assembler-times \"_ZGVbN4v__Z3f10ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4v__Z3f10ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8v__Z3f10ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN16v__Z3f10ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+template  int f10<1> [[omp::directive (declare simd inbranch linear(x))]] (int x);\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4l__Z3f10ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4l__Z3f10ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8l__Z3f10ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM16l__Z3f10ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+template <int N>\n+int f11 (int);\n+\n+template <> [[omp::directive (declare simd, inbranch)]] int\n+f11<0> (int x)\n+{\n+  return x;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4v__Z3f11ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4v__Z3f11ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8v__Z3f11ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM16v__Z3f11ILi0EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+template <> int\n+f11<1> [[omp::directive (declare simd, notinbranch, linear (y))]] (int y)\n+{\n+  return y;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbN4l__Z3f11ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4l__Z3f11ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8l__Z3f11ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN16l__Z3f11ILi1EEii:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+struct S\n+{\n+  [[omp::sequence (directive (declare simd, inbranch, uniform (this)))]] int f12 (int x);\n+  int f13 [[gnu::noinline, omp::directive (declare simd notinbranch uniform (this) linear (y))]] (int y) { return y; }\n+};\n+\n+int\n+S::f12 (int x)\n+{\n+  return x;\n+}\n+\n+// { dg-final { scan-assembler-times \"_ZGVbM4uv__ZN1S3f12Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcM4uv__ZN1S3f12Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdM8uv__ZN1S3f12Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeM16uv__ZN1S3f12Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+// { dg-final { scan-assembler-times \"_ZGVbN4ul__ZN1S3f13Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVcN4ul__ZN1S3f13Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVdN8ul__ZN1S3f13Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler-times \"_ZGVeN16ul__ZN1S3f13Ei:\" 1 { target { i?86-*-* x86_64-*-* } } } }\n+\n+int\n+f14 (S &p, int x)\n+{\n+  return p.f13 (x);\n+}"}, {"sha": "a8e27b74df5014908245d1428b985df39c4898bf", "filename": "gcc/testsuite/g++.dg/gomp/attrs-11.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-11.C?ref=c40c6a50fd4da342c87a715ae83927a37797e094", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fopenmp -Wno-attributes\" }\n+\n+namespace N {}\n+namespace O { typedef int T; };\n+\n+void\n+foo ()\n+{\n+  [[omp::directive (parallel)]] asm (\"\");\t\t\t// { dg-error \"expected\" }\n+  [[omp::directive (parallel)]] __extension__ asm (\"\");\t\t// { dg-error \"expected\" }\n+  __extension__ [[omp::directive (parallel)]] asm (\"\");\t\t// { dg-error \"expected\" }\n+  [[omp::directive (parallel)]] namespace M = ::N;\t\t// { dg-error \"expected\" }\n+  [[omp::directive (parallel)]] using namespace N;\t\t// { dg-bogus \"expected\" \"\" { xfail *-*-* } }\n+  [[omp::directive (parallel)]] using O::T;\t\t\t// { dg-error \"expected\" }\n+  [[omp::directive (parallel)]] __label__ foo;\t\t\t// { dg-error \"expected\" }\n+  [[omp::directive (parallel)]] static_assert (true, \"\");\t// { dg-error \"expected\" }\n+  [[omp::directive (parallel)]] int a = 5;\t\t\t// { dg-error \"not allowed to be specified in this context\" }\n+  int b = 0;\n+  [[omp::directive (parallel)]] l: b++;\t\t\t\t// { dg-error \"not allowed to be specified in this context\" }\n+  switch (0)\n+    {\n+      [[omp::directive (parallel)]] case 6: break;\t\t// { dg-error \"not allowed to be specified in this context\" }\n+      [[omp::directive (parallel)]] default: break;\t\t// { dg-error \"not allowed to be specified in this context\" }\n+    }\n+}\n+\n+void\n+bar ()\n+{\n+  [[omp::directive (declare simd)]] int a;\t\t// { dg-error \"not allowed to be specified in this context|not immediately followed by function declaration or definition\" }\n+  [[omp::directive (declare simd)]] int b, f1 (int);\t// { dg-error \"not allowed to be specified in this context|not immediately followed by function declaration or definition\" }\n+  [[omp::directive (declare simd)]] int f2 (int), c;\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+  int d [[omp::directive (declare simd)]];\t\t// { dg-error \"not allowed to be specified in this context\" }\n+  int f3 [[omp::directive (declare simd)]] (int), f4 [[omp::directive (declare simd)]] (int);\n+  __extension__ [[omp::directive (declare simd)]] int f5 (int);\n+  __extension__ int f6 [[omp::directive (declare simd, notinbranch)]] (int);\n+  #pragma omp declare simd notinbranch\n+  [[omp::directive (declare simd inbranch)]] int f7 (int);\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same declaration\" }\n+  [[omp::directive (declare simd notinbranch)]]\n+  #pragma omp declare simd inbranch\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same statement\" }\n+  int f8 (int);\n+  static int t1, t2, t3, t4;\n+  [[omp::directive (declare simd), omp::directive (foobar)]] int f9 (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+  [[omp::directive (foobar), omp::directive (declare simd)]] int f10 (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+  [[omp::directive (threadprivate (t1)), omp::directive (declare simd)]] int f10 (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+  [[omp::directive (declare simd), omp::directive (threadprivate (t2))]] int f11 (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+  int f12 [[omp::directive (declare simd), omp::directive (foobar)]] (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+  int f13 [[omp::directive (foobar), omp::directive (declare simd)]] (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+  int f14 [[omp::directive (threadprivate (t3)), omp::directive (declare simd)]] (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+  int f15 [[omp::directive (declare simd), omp::directive (threadprivate (t4))]] (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+}\n+\n+[[omp::directive (declare simd)]] int a;\t\t// { dg-error \"not allowed to be specified in this context|not immediately followed by function declaration or definition\" }\n+[[omp::directive (declare simd)]] int b, f16 (int);\t// { dg-error \"not allowed to be specified in this context|not immediately followed by function declaration or definition\" }\n+[[omp::directive (declare simd)]] int f17 (int), c;\t// { dg-error \"not immediately followed by function declaration or definition\" }\n+int d [[omp::directive (declare simd)]];\t\t// { dg-error \"not allowed to be specified in this context\" }\n+int f18 [[omp::directive (declare simd)]] (int), f19 [[omp::directive (declare simd)]] (int);\n+__extension__ [[omp::directive (declare simd)]] int f20 (int);\n+__extension__ int f21 [[omp::directive (declare simd, notinbranch)]] (int);\n+#pragma omp declare simd notinbranch\n+[[omp::directive (declare simd inbranch)]] int f22 (int);\t// { dg-error \"mixing OpenMP directives with attribute and pragma syntax on the same declaration\" }\n+[[omp::directive (declare simd notinbranch)]]\t\t// { dg-error \"'declare simd' directive not immediately followed by function declaration or definition\" }\n+#pragma omp declare simd inbranch\t// { dg-error \"'#pragma' is not allowed here\" }\n+int f23 (int);\n+int t5, t6, t7, t8;\n+[[omp::directive (declare simd), omp::directive (foobar)]] int f24 (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+[[omp::directive (foobar), omp::directive (declare simd)]] int f25 (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+[[omp::directive (threadprivate (t5)), omp::directive (declare simd)]] int f26 (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+[[omp::directive (declare simd), omp::directive (threadprivate (t6))]] int f27 (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+int f28 [[omp::directive (declare simd), omp::directive (foobar)]] (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+int f29 [[omp::directive (foobar), omp::directive (declare simd)]] (int);\t// { dg-error \"unknown OpenMP directive name\" }\n+int f30 [[omp::directive (threadprivate (t7)), omp::directive (declare simd)]] (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }\n+int f31 [[omp::directive (declare simd), omp::directive (threadprivate (t8))]] (int);\t// { dg-error \"OpenMP directive other than 'declare simd' or 'declare variant' appertains to a declaration\" }"}, {"sha": "1b59abdbd1e17a6b96e78619f040fd8f20adb1db", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c40c6a50fd4da342c87a715ae83927a37797e094/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=c40c6a50fd4da342c87a715ae83927a37797e094", "patch": "@@ -501,7 +501,7 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     }\n   }\n   extern int t2;\n-  [[omp::directive (threadprivate (t2))]]\n+  [[omp::directive (threadprivate (t2))]];\n   extern int t2;\n   [[omp::directive (declare reduction (dr: int: omp_out += omp_in),initializer (omp_priv = 0))]]\n   ;"}]}