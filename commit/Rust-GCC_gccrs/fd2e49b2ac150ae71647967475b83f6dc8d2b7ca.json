{"sha": "fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQyZTQ5YjJhYzE1MGFlNzE2NDc5Njc0NzViODNmNmRjOGQyYjdjYQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2003-01-28T15:54:28Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2003-01-28T15:54:28Z"}, "message": "ffi.h.in: Enable FFI_CLOSURES for x86_64.\n\n2003-01-28  Andrew Haley  <aph@redhat.com>\n\n        * include/ffi.h.in: Enable FFI_CLOSURES for x86_64.\n        * src/x86/ffi64.c (ffi_prep_closure): New.\n        (ffi_closure_UNIX64_inner): New.\n        * src/x86/unix64.S (ffi_closure_UNIX64): New.\n\nFrom-SVN: r61978", "tree": {"sha": "4358058cbc23b14ef6f68da5f957507281355c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4358058cbc23b14ef6f68da5f957507281355c64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "447ff38fbaa1664a013c39335c63681083f400df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447ff38fbaa1664a013c39335c63681083f400df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447ff38fbaa1664a013c39335c63681083f400df"}], "stats": {"total": 241, "additions": 240, "deletions": 1}, "files": [{"sha": "17ed41118d47d42d6391f6253be147d6ad6fdc9f", "filename": "libffi/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "patch": "@@ -1,3 +1,10 @@\n+2003-01-28  Andrew Haley  <aph@redhat.com>\n+\n+\t* include/ffi.h.in: Enable FFI_CLOSURES for x86_64.\n+\t* src/x86/ffi64.c (ffi_prep_closure): New.\n+\t(ffi_closure_UNIX64_inner): New.\n+\t* src/x86/unix64.S (ffi_closure_UNIX64): New.\n+\n 2003-01-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* configure.in (toolexecdir, toolexeclibdir): Set and AC_SUBST."}, {"sha": "02853846c9fd4ea718621db408915f252b55271c", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "patch": "@@ -471,6 +471,12 @@ struct ffi_ia64_trampoline_struct {\n #define FFI_TRAMPOLINE_SIZE 16\n #define FFI_NATIVE_RAW_API 0\n \n+#elif defined(__x86_64__)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 24\n+#define FFI_NATIVE_RAW_API 0\n+\n #else \n \n #define FFI_CLOSURES 0"}, {"sha": "9427a37c8b59a94445b83ef94401b0916e579c6c", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "patch": "@@ -27,6 +27,7 @@\n #include <ffi_common.h>\n \n #include <stdlib.h>\n+#include <stdarg.h>\n \n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n@@ -571,4 +572,135 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n     }\n }\n \n+extern void ffi_closure_UNIX64(void);\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t  void *user_data)\n+{\n+  volatile unsigned short *tramp;\n+\n+  /* FFI_ASSERT (cif->abi == FFI_OSF);  */\n+\n+  tramp = (volatile unsigned short *) &closure->tramp[0];\n+  tramp[0] = 0xbb49;\t\t/* mov <code>, %r11\t*/\n+  tramp[5] = 0xba49;\t\t/* mov <data>, %r10\t*/\n+  tramp[10] = 0xff49;\t\t/* jmp *%r11\t*/\n+  tramp[11] = 0x00e3;\n+  *(void * volatile *) &tramp[1] = ffi_closure_UNIX64;\n+  *(void * volatile *) &tramp[6] = closure;\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  return FFI_OK;\n+}\n+\n+int\n+ffi_closure_UNIX64_inner(ffi_closure *closure, va_list l, void *rp)\n+{\n+  ffi_cif *cif;\n+  void **avalue;\n+  ffi_type **arg_types;\n+  long i, avn, argn;\n+\n+  cif = closure->cif;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  argn = 0;\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+  \n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n+    {\n+      switch (arg_types[i]->type)\n+\t{\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT64:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_POINTER:\n+\t  {\n+\t    if (l->gp_offset > 48-8)\n+\t      {\n+\t\tavalue[i] = l->overflow_arg_area;\n+\t\tl->overflow_arg_area = (char *)l->overflow_arg_area + 8;\n+\t      }\n+\t    else\n+\t      {\n+\t\tavalue[i] = (char *)l->reg_save_area + l->gp_offset;\n+\t\tl->gp_offset += 8;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  /* FIXME  */\n+\t  FFI_ASSERT(0);\n+\t  break;\n+\n+\tcase FFI_TYPE_DOUBLE:\n+\t  {\n+\t    if (l->fp_offset > 176-16)\n+\t      {\n+\t\tavalue[i] = l->overflow_arg_area;\n+\t\tl->overflow_arg_area = (char *)l->overflow_arg_area + 8;\n+\t      }\n+\t    else\n+\t      {\n+\t\tavalue[i] = (char *)l->reg_save_area + l->fp_offset;\n+\t\tl->fp_offset += 16;\n+\t      }\n+\t  }\n+#if DEBUG_FFI\n+\t  fprintf (stderr, \"double arg %d = %g\\n\", i, *(double *)avalue[i]);\n+#endif\n+\t  break;\n+\t  \n+\tcase FFI_TYPE_FLOAT:\n+\t  {\n+\t    if (l->fp_offset > 176-16)\n+\t      {\n+\t\tavalue[i] = l->overflow_arg_area;\n+\t\tl->overflow_arg_area = (char *)l->overflow_arg_area + 8;\n+\t      }\n+\t    else\n+\t      {\n+\t\tavalue[i] = (char *)l->reg_save_area + l->fp_offset;\n+\t\tl->fp_offset += 16;\n+\t      }\n+\t  }\n+#if DEBUG_FFI\n+\t  fprintf (stderr, \"float arg %d = %g\\n\", i, *(float *)avalue[i]);\n+#endif\n+\t  break;\n+\t  \n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n+\n+      argn += ALIGN(arg_types[i]->size, SIZEOF_ARG) / SIZEOF_ARG;\n+      i++;\n+    }\n+\n+  /* Invoke the closure.  */\n+  (closure->fun) (cif, rp, avalue, closure->user_data);\n+\n+  /* FIXME: Structs not supported.  */\n+  FFI_ASSERT(cif->rtype->type != FFI_TYPE_STRUCT);\n+\n+  /* Tell ffi_closure_UNIX64 how to perform return type promotions.  */\n+\n+  return cif->rtype->type;\n+}\n #endif /* ifndef __x86_64__ */"}, {"sha": "f0cd3c9c0c9e7b83bf6ebc0c9faa040774897757", "filename": "libffi/src/x86/unix64.S", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2Fsrc%2Fx86%2Funix64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2e49b2ac150ae71647967475b83f6dc8d2b7ca/libffi%2Fsrc%2Fx86%2Funix64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Funix64.S?ref=fd2e49b2ac150ae71647967475b83f6dc8d2b7ca", "patch": "@@ -162,7 +162,81 @@ sse2floatfloat:\n \tmovaps\t(%rdi), %xmm0\n \tmovq\t%xmm0, (%rsi)\n \tret\n-\t\n+\n+\t.align\t2\n+.globl ffi_closure_UNIX64\n+        .type\tffi_closure_UNIX64,@function\n+\n+ffi_closure_UNIX64:\n+.LFB2:\n+        pushq   %rbp\n+.LCFI10:\n+        movq    %rsp, %rbp\n+.LCFI11:\n+        subq    $240, %rsp\n+.LCFI12:\n+\tmovq\t%rdi, -176(%rbp)\n+        movq    %rsi, -168(%rbp)\n+        movq    %rdx, -160(%rbp)\n+        movq    %rcx, -152(%rbp)\n+        movq    %r8, -144(%rbp)\n+        movq    %r9, -136(%rbp)\n+        /* FIXME: We can avoid all this stashing of XMM registers by\n+\t   (in ffi_prep_closure) computing the number of\n+\t   floating-point args and moving it into %rax before calling\n+\t   this function.  Once this is done, uncomment the next few\n+\t   lines and only the essential XMM registers will be written\n+\t   to memory.  This is a significant saving.  */\n+/*         movzbl  %al, %eax  */\n+/*         movq    %rax, %rdx */\n+/*         leaq    0(,%rdx,4), %rax */\n+/*         leaq    2f(%rip), %rdx */\n+/*         subq    %rax, %rdx */\n+        leaq    -1(%rbp), %rax\n+/*         jmp     *%rdx */\n+        movaps  %xmm7, -15(%rax)\n+        movaps  %xmm6, -31(%rax)\n+        movaps  %xmm5, -47(%rax)\n+        movaps  %xmm4, -63(%rax)\n+        movaps  %xmm3, -79(%rax)\n+        movaps  %xmm2, -95(%rax)\n+        movaps  %xmm1, -111(%rax)\n+        movaps  %xmm0, -127(%rax)\n+2:\n+        movl    %edi, -180(%rbp)\n+        movl    $0, -224(%rbp)\n+        movl    $48, -220(%rbp)\n+        leaq    16(%rbp), %rax\n+        movq    %rax, -216(%rbp)\n+        leaq    -176(%rbp), %rdx\n+        movq    %rdx, -208(%rbp)\n+        leaq    -224(%rbp), %rsi\n+\tmovq\t%r10, %rdi\n+\tmovq\t%rsp, %rdx\n+        call    ffi_closure_UNIX64_inner@PLT\n+\n+\tcmpl\t$FFI_TYPE_FLOAT, %eax\n+\tje\t1f\n+\tcmpl\t$FFI_TYPE_DOUBLE, %eax\n+\tje\t2f\n+\tcmpl\t$FFI_TYPE_LONGDOUBLE, %eax\n+\tje\t3f\n+\tcmpl\t$FFI_TYPE_STRUCT, %eax\n+\tje\t4f\n+\tpopq\t%rax\n+        leave\n+        ret\n+1:\n+2:\n+3:\t\n+\tmovaps\t-240(%rbp), %xmm0\n+        leave\n+        ret\n+4:\n+\tleave\n+\tret\n+.LFE2:\t\n+\t\t\n         .section        .eh_frame,\"a\",@progbits\n .Lframe0:\n         .long   .LECIE1-.LSCIE1\n@@ -204,5 +278,25 @@ sse2floatfloat:\n         .uleb128 0x6\n \t.align 8\n .LEFDE1:\n+.LSFDE3:\n+        .long   .LEFDE3-.LASFDE3        # FDE Length\n+.LASFDE3:\n+        .long   .LASFDE3-.Lframe0       # FDE CIE offset\n+\n+        .long   .LFB2-. # FDE initial location\n+        .long   .LFE2-.LFB2     # FDE address range\n+        .uleb128 0x0    # Augmentation size\n+        .byte   0x4     # DW_CFA_advance_loc4\n+        .long   .LCFI10-.LFB2\n+        .byte   0xe     # DW_CFA_def_cfa_offset\n+        .uleb128 0x10\n+        .byte   0x86    # DW_CFA_offset, column 0x6\n+        .uleb128 0x2\n+        .byte   0x4     # DW_CFA_advance_loc4\n+        .long   .LCFI11-.LCFI10\n+        .byte   0xd     # DW_CFA_def_cfa_register\n+        .uleb128 0x6\n+        .align 8\n+.LEFDE3:\n \n #endif /* __x86_64__  */"}]}