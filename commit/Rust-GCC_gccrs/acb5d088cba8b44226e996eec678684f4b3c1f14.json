{"sha": "acb5d088cba8b44226e996eec678684f4b3c1f14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNiNWQwODhjYmE4YjQ0MjI2ZTk5NmVlYzY3ODY4NGY0YjNjMWYxNA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2002-09-23T12:17:53Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-09-23T12:17:53Z"}, "message": "extend.texi (Extended Asm): Clarify that overlap between asm-declared register variables used in an asm and...\n\n\t* doc/extend.texi (Extended Asm): Clarify that overlap between\n\tasm-declared register variables used in an asm and the asm clobber\n\tlist is not allowed.\n\t* stmt.c (decl_conflicts_with_clobbers_p): New function.\n\t(expand_asm_operands): Keep track of clobbered registers.  Call\n\tdecl_conflicts_with_clobbers_p for each input and output operand.\n\tIf no conflicts found before, also do conflict sanity check when\n\temitting clobbers.\n\nFrom-SVN: r57437", "tree": {"sha": "56ebdba2b6bc8f32c6001ce4d254da31225d2b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56ebdba2b6bc8f32c6001ce4d254da31225d2b75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acb5d088cba8b44226e996eec678684f4b3c1f14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb5d088cba8b44226e996eec678684f4b3c1f14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb5d088cba8b44226e996eec678684f4b3c1f14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb5d088cba8b44226e996eec678684f4b3c1f14/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ddf0fc72240ce2a18b80e1f957fc5fb6826cca65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddf0fc72240ce2a18b80e1f957fc5fb6826cca65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddf0fc72240ce2a18b80e1f957fc5fb6826cca65"}], "stats": {"total": 90, "additions": 88, "deletions": 2}, "files": [{"sha": "103a62b2b103699b37a92b2af87dafcc16341844", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb5d088cba8b44226e996eec678684f4b3c1f14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb5d088cba8b44226e996eec678684f4b3c1f14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acb5d088cba8b44226e996eec678684f4b3c1f14", "patch": "@@ -1,3 +1,14 @@\n+2002-09-23  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* doc/extend.texi (Extended Asm): Clarify that overlap between\n+\tasm-declared register variables used in an asm and the asm clobber\n+\tlist is not allowed.\n+\t* stmt.c (decl_conflicts_with_clobbers_p): New function.\n+\t(expand_asm_operands): Keep track of clobbered registers.  Call\n+\tdecl_conflicts_with_clobbers_p for each input and output operand.\n+\tIf no conflicts found before, also do conflict sanity check when\n+\temitting clobbers.\n+\n 2002-09-23  Richard Henderson  <rth@redhat.com>\n \n \t* c-common.c (cpp_define_data_format): Remove."}, {"sha": "9e121e4fc0962d86cba02172a94df3035d0c43f5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb5d088cba8b44226e996eec678684f4b3c1f14/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb5d088cba8b44226e996eec678684f4b3c1f14/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=acb5d088cba8b44226e996eec678684f4b3c1f14", "patch": "@@ -3700,7 +3700,10 @@ asm volatile (\"movc3 %0,%1,%2\"\n You may not write a clobber description in a way that overlaps with an\n input or output operand.  For example, you may not have an operand\n describing a register class with one member if you mention that register\n-in the clobber list.  There is no way for you to specify that an input\n+in the clobber list.  Variables declared to live in specific registers\n+(@pxref{Explicit Reg Vars}), and used as asm input or output operands must\n+have no part mentioned in the clobber description.\n+There is no way for you to specify that an input\n operand is modified without also specifying it as an output\n operand.  Note that if all the output operands you specify are for this\n purpose (and hence unused), you will then also need to specify"}, {"sha": "ff27484a55aa6b81d0e5631535610b05b4ff5b2b", "filename": "gcc/stmt.c", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acb5d088cba8b44226e996eec678684f4b3c1f14/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acb5d088cba8b44226e996eec678684f4b3c1f14/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=acb5d088cba8b44226e996eec678684f4b3c1f14", "patch": "@@ -398,6 +398,7 @@ static int n_occurrences\t\tPARAMS ((int, const char *));\n static bool parse_input_constraint\tPARAMS ((const char **, int, int, int,\n \t\t\t\t\t\t int, const char * const *,\n \t\t\t\t\t\t bool *, bool *));\n+static bool decl_conflicts_with_clobbers_p PARAMS ((tree, const HARD_REG_SET));\n static void expand_goto_internal\tPARAMS ((tree, rtx, rtx));\n static int expand_fixup\t\t\tPARAMS ((tree, rtx, rtx));\n static rtx expand_nl_handler_label\tPARAMS ((rtx, rtx));\n@@ -1400,6 +1401,42 @@ parse_input_constraint (constraint_p, input_num, ninputs, noutputs, ninout,\n   return true;\n }\n \n+/* Check for overlap between registers marked in CLOBBERED_REGS and\n+   anything inappropriate in DECL.  Emit error and return TRUE for error,\n+   FALSE for ok.  */\n+\n+static bool\n+decl_conflicts_with_clobbers_p (decl, clobbered_regs)\n+     tree decl;\n+     const HARD_REG_SET clobbered_regs;\n+{\n+  /* Conflicts between asm-declared register variables and the clobber\n+     list are not allowed.  */\n+  if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+      && DECL_REGISTER (decl)\n+      && REGNO (DECL_RTL (decl)) < FIRST_PSEUDO_REGISTER)\n+    {\n+      rtx reg = DECL_RTL (decl);\n+      unsigned int regno;\n+\n+      for (regno = REGNO (reg);\n+\t   regno < (REGNO (reg)\n+\t\t    + HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)));\n+\t   regno++)\n+\tif (TEST_HARD_REG_BIT (clobbered_regs, regno))\n+\t  {\n+\t    error (\"asm-specifier for variable `%s' conflicts with asm clobber list\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\n+\t    /* Reset registerness to stop multiple errors emitted for a\n+\t       single variable.  */\n+\t    DECL_REGISTER (decl) = 0;\n+\t    return true;\n+\t  }\n+    }\n+  return false;\n+}\n+\n /* Generate RTL for an asm statement with arguments.\n    STRING is the instruction template.\n    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n@@ -1430,6 +1467,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   int noutputs = list_length (outputs);\n   int ninout;\n   int nclobbers;\n+  HARD_REG_SET clobbered_regs;\n+  int clobber_conflict_found = 0;\n   tree tail;\n   int i;\n   /* Vector of RTX's of evaluated output operands.  */\n@@ -1467,6 +1506,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   /* Count the number of meaningful clobbered registers, ignoring what\n      we would ignore later.  */\n   nclobbers = 0;\n+  CLEAR_HARD_REG_SET (clobbered_regs);\n   for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n     {\n       const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n@@ -1476,6 +1516,10 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t++nclobbers;\n       else if (i == -2)\n \terror (\"unknown register name `%s' in `asm'\", regname);\n+\n+      /* Mark clobbered registers.  */\n+      if (i >= 0)\n+\tSET_HARD_REG_BIT (clobbered_regs, i);\n     }\n \n   clear_last_expr ();\n@@ -1601,6 +1645,9 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  inout_mode[ninout] = TYPE_MODE (type);\n \t  inout_opnum[ninout++] = i;\n \t}\n+\n+      if (decl_conflicts_with_clobbers_p (val, clobbered_regs))\n+\tclobber_conflict_found = 1;\n     }\n \n   /* Make vectors for the expression-rtx, constraint strings,\n@@ -1685,6 +1732,9 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n \t= gen_rtx_ASM_INPUT (TYPE_MODE (type), constraints[i + noutputs]);\n+\n+      if (decl_conflicts_with_clobbers_p (val, clobbered_regs))\n+\tclobber_conflict_found = 1;\n     }\n \n   /* Protect all the operands from the queue now that they have all been\n@@ -1769,6 +1819,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t{\n \t  const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n \t  int j = decode_reg_name (regname);\n+\t  rtx clobbered_reg;\n \n \t  if (j < 0)\n \t    {\n@@ -1790,8 +1841,29 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t    }\n \n \t  /* Use QImode since that's guaranteed to clobber just one reg.  */\n+\t  clobbered_reg = gen_rtx_REG (QImode, j);\n+\n+\t  /* Do sanity check for overlap between clobbers and respectively\n+\t     input and outputs that hasn't been handled.  Such overlap\n+\t     should have been detected and reported above.  */\n+\t  if (!clobber_conflict_found)\n+\t    {\n+\t      int opno;\n+\n+\t      /* We test the old body (obody) contents to avoid tripping\n+\t\t over the under-construction body.  */\n+\t      for (opno = 0; opno < noutputs; opno++)\n+\t\tif (reg_overlap_mentioned_p (clobbered_reg, output_rtx[opno]))\n+\t\t  internal_error (\"asm clobber conflict with output operand\");\n+\n+\t      for (opno = 0; opno < ninputs - ninout; opno++)\n+\t\tif (reg_overlap_mentioned_p (clobbered_reg,\n+\t\t\t\t\t     ASM_OPERANDS_INPUT (obody, opno)))\n+\t\t  internal_error (\"asm clobber conflict with input operand\");\n+\t    }\n+\n \t  XVECEXP (body, 0, i++)\n-\t    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (QImode, j));\n+\t    = gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n \t}\n \n       insn = emit_insn (body);"}]}