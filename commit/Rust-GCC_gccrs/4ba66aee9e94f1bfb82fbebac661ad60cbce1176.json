{"sha": "4ba66aee9e94f1bfb82fbebac661ad60cbce1176", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJhNjZhZWU5ZTk0ZjFiZmI4MmZiZWJhYzY2MWFkNjBjYmNlMTE3Ng==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-06-01T11:30:36Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-06-01T11:30:36Z"}, "message": "S/390: Don't fetch the return address early with ooo\n\nWe used to load the return address slot some time in advance.  This\nhelped on older machines to resolve the data dependencies in time.\nHowever, it is pointless on out of order CPUs.  Disabled with that\npatch.\n\ngcc/ChangeLog:\n\n2017-06-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390.c (s390_emit_epilogue): Disable early return\n\taddress fetch for z10 or later.\n\nFrom-SVN: r248789", "tree": {"sha": "920f8201c4998b83ba0902c07bf6f8b77588fb31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/920f8201c4998b83ba0902c07bf6f8b77588fb31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ba66aee9e94f1bfb82fbebac661ad60cbce1176", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba66aee9e94f1bfb82fbebac661ad60cbce1176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba66aee9e94f1bfb82fbebac661ad60cbce1176", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba66aee9e94f1bfb82fbebac661ad60cbce1176/comments", "author": null, "committer": null, "parents": [{"sha": "e257141f075b6764ea5a1c1d7b1f2d364bf241a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e257141f075b6764ea5a1c1d7b1f2d364bf241a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e257141f075b6764ea5a1c1d7b1f2d364bf241a2"}], "stats": {"total": 68, "additions": 37, "deletions": 31}, "files": [{"sha": "9cfcfad9090f1279c0babd9aa582667d242ef5e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba66aee9e94f1bfb82fbebac661ad60cbce1176/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba66aee9e94f1bfb82fbebac661ad60cbce1176/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ba66aee9e94f1bfb82fbebac661ad60cbce1176", "patch": "@@ -1,3 +1,8 @@\n+2017-06-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390.c (s390_emit_epilogue): Disable early return\n+\taddress fetch for z10 or later.\n+\n 2017-06-01  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.md (tst_movb): Add guard when splitting."}, {"sha": "eb94237d96992ccc0f65678e22e09d551589b023", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba66aee9e94f1bfb82fbebac661ad60cbce1176/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba66aee9e94f1bfb82fbebac661ad60cbce1176/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4ba66aee9e94f1bfb82fbebac661ad60cbce1176", "patch": "@@ -11410,38 +11410,39 @@ s390_emit_epilogue (bool sibcall)\n \t\t\t\tgen_rtx_REG (Pmode, i), cfa_restores);\n \t}\n \n-      if (! sibcall)\n-\t{\n-\t  /* Fetch return address from stack before load multiple,\n-\t     this will do good for scheduling.\n-\n-\t     Only do this if we already decided that r14 needs to be\n-\t     saved to a stack slot. (And not just because r14 happens to\n-\t     be in between two GPRs which need saving.)  Otherwise it\n-\t     would be difficult to take that decision back in\n-\t     s390_optimize_prologue.  */\n-\t  if (cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK)\n-\t    {\n-\t      int return_regnum = find_unused_clobbered_reg();\n-\t      if (!return_regnum)\n-\t\treturn_regnum = 4;\n-\t      return_reg = gen_rtx_REG (Pmode, return_regnum);\n-\n-\t      addr = plus_constant (Pmode, frame_pointer,\n-\t\t\t\t    offset + cfun_frame_layout.gprs_offset\n-\t\t\t\t    + (RETURN_REGNUM\n-\t\t\t\t       - cfun_frame_layout.first_save_gpr_slot)\n-\t\t\t\t    * UNITS_PER_LONG);\n-\t      addr = gen_rtx_MEM (Pmode, addr);\n-\t      set_mem_alias_set (addr, get_frame_alias_set ());\n-\t      emit_move_insn (return_reg, addr);\n+      /* Fetch return address from stack before load multiple,\n+\t this will do good for scheduling.\n+\n+\t Only do this if we already decided that r14 needs to be\n+\t saved to a stack slot. (And not just because r14 happens to\n+\t be in between two GPRs which need saving.)  Otherwise it\n+\t would be difficult to take that decision back in\n+\t s390_optimize_prologue.\n+\n+\t This optimization is only helpful on in-order machines.  */\n+      if (! sibcall\n+\t  && cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK\n+\t  && s390_tune <= PROCESSOR_2097_Z10)\n+\t{\n+\t  int return_regnum = find_unused_clobbered_reg();\n+\t  if (!return_regnum)\n+\t    return_regnum = 4;\n+\t  return_reg = gen_rtx_REG (Pmode, return_regnum);\n+\n+\t  addr = plus_constant (Pmode, frame_pointer,\n+\t\t\t\toffset + cfun_frame_layout.gprs_offset\n+\t\t\t\t+ (RETURN_REGNUM\n+\t\t\t\t   - cfun_frame_layout.first_save_gpr_slot)\n+\t\t\t\t* UNITS_PER_LONG);\n+\t  addr = gen_rtx_MEM (Pmode, addr);\n+\t  set_mem_alias_set (addr, get_frame_alias_set ());\n+\t  emit_move_insn (return_reg, addr);\n \n-\t      /* Once we did that optimization we have to make sure\n-\t\t s390_optimize_prologue does not try to remove the\n-\t\t store of r14 since we will not be able to find the\n-\t\t load issued here.  */\n-\t      cfun_frame_layout.save_return_addr_p = true;\n-\t    }\n+\t  /* Once we did that optimization we have to make sure\n+\t     s390_optimize_prologue does not try to remove the store\n+\t     of r14 since we will not be able to find the load issued\n+\t     here.  */\n+\t  cfun_frame_layout.save_return_addr_p = true;\n \t}\n \n       insn = restore_gprs (frame_pointer,"}]}