{"sha": "a837268b2b7f2b2623392c376144c5f343f23011", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgzNzI2OGIyYjdmMmIyNjIzMzkyYzM3NjE0NGM1ZjM0M2YyMzAxMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-20T14:49:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-20T14:49:18Z"}, "message": "cgraph.c (cgraph_remove_node): Kill bodies in other partitoin.\n\n\n\t* cgraph.c (cgraph_remove_node): Kill bodies in other partitoin.\n\t(dump_cgraph_node): Dump new flags.\n\t* cgraph.h (struct cgraph_node): Add flags reachable_from_other_partition\n\tand in_other_partition.\n\t(cgraph_can_remove_if_no_direct_calls_p): Functions used by other partition\n\tcan not be removed.\n\t* cgraphunit.c (cgraph_mark_functions_to_output): Functions used by the other\n\tpartition must be output; silence sanity checking on leaking functions\n\tbodies from other paritition.\n\t* lto-cgraph.c (reachable_from_other_partition_p): New function.\n\t(lto_output_node): Output new flags; do not sanity check that inline\n\tclones are output; drop lto_forced_extern_inline_p code; do not mock\n\tvisibility flags at partition boundaries.\n\t(add_node_to): New function.\n\t(output_cgraph): Use it to sort functions so masters appear before\n\tclones.\n\t(input_overwrite_node): Input new flags.\n\t* passes.c (ipa_write_summaries): Do not call\n\tlto_new_extern_inline_states.\n\t* lto-section-out.c (forced_extern_inline, lto_new_extern_inline_states,\n\tlto_delete_extern_inline_states, lto_force_functions_extern_inline,\n\tlto_forced_extern_inline_p): Kill.\n\t* lto-streamer.h (lto_new_extern_inline_states,\n\t* lto_delete_extern_inline_states, lto_force_functions_extern_inline,\n\tlto_forced_extern_inline_p): Kill.\n\n\t* lto.c (lto_add_inline_clones): Do not track inlined_decls.\n\t(lto_add_all_inlinees): Likewise.\n\t(lto_wpa_write_files): Likewise.\n\nFrom-SVN: r158563", "tree": {"sha": "177a4ee0cf4fce5cf2f9b7eda71d28eb9db862e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/177a4ee0cf4fce5cf2f9b7eda71d28eb9db862e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a837268b2b7f2b2623392c376144c5f343f23011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a837268b2b7f2b2623392c376144c5f343f23011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a837268b2b7f2b2623392c376144c5f343f23011", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a837268b2b7f2b2623392c376144c5f343f23011/comments", "author": null, "committer": null, "parents": [{"sha": "48e5069861a635af72d47f8975d177ed36f7e6e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e5069861a635af72d47f8975d177ed36f7e6e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e5069861a635af72d47f8975d177ed36f7e6e5"}], "stats": {"total": 213, "additions": 116, "deletions": 97}, "files": [{"sha": "cd74f02a250711969f7b698833df98b481a6e35c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -1,3 +1,31 @@\n+2010-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_remove_node): Kill bodies in other partitoin.\n+\t(dump_cgraph_node): Dump new flags.\n+\t* cgraph.h (struct cgraph_node): Add flags reachable_from_other_partition\n+\tand in_other_partition.\n+\t(cgraph_can_remove_if_no_direct_calls_p): Functions used by other partition\n+\tcan not be removed.\n+\t* cgraphunit.c (cgraph_mark_functions_to_output): Functions used by the other\n+\tpartition must be output; silence sanity checking on leaking functions\n+\tbodies from other paritition.\n+\t* lto-cgraph.c (reachable_from_other_partition_p): New function.\n+\t(lto_output_node): Output new flags; do not sanity check that inline\n+\tclones are output; drop lto_forced_extern_inline_p code; do not mock\n+\tvisibility flags at partition boundaries.\n+\t(add_node_to): New function.\n+\t(output_cgraph): Use it to sort functions so masters appear before\n+\tclones.\n+\t(input_overwrite_node): Input new flags.\n+\t* passes.c (ipa_write_summaries): Do not call\n+\tlto_new_extern_inline_states.\n+\t* lto-section-out.c (forced_extern_inline, lto_new_extern_inline_states,\n+\tlto_delete_extern_inline_states, lto_force_functions_extern_inline,\n+\tlto_forced_extern_inline_p): Kill.\n+\t* lto-streamer.h (lto_new_extern_inline_states,\n+\t* lto_delete_extern_inline_states, lto_force_functions_extern_inline,\n+\tlto_forced_extern_inline_p): Kill.\n+\n 2010-04-20  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (do_sd_constraint): Add edges only"}, {"sha": "682c3fb53054e6b93c2b67574d3c8f043df1c3dc", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -1467,7 +1467,8 @@ cgraph_remove_node (struct cgraph_node *node)\n       struct cgraph_node *n = (struct cgraph_node *) *slot;\n       if (!n->clones && !n->clone_of && !n->global.inlined_to\n \t  && (cgraph_global_info_ready\n-\t      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl))))\n+\t      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl)\n+\t\t  || n->in_other_partition)))\n \tkill_body = true;\n     }\n   if (assembler_name_hash)\n@@ -1639,6 +1640,10 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (cgraph_function_flags_ready)\n     fprintf (f, \" availability:%s\",\n \t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n+  if (node->analyzed)\n+    fprintf (f, \" analyzed\");\n+  if (node->in_other_partition)\n+    fprintf (f, \" in_other_partition\");\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n@@ -1666,6 +1671,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" address_taken\");\n   else if (node->reachable)\n     fprintf (f, \" reachable\");\n+  else if (node->reachable_from_other_partition)\n+    fprintf (f, \" reachable_from_other_partition\");\n   if (gimple_has_body_p (node->decl))\n     fprintf (f, \" body\");\n   if (node->process)"}, {"sha": "6bc565a2d174b99513b2c335bac1e5dd4b6fe66c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -249,11 +249,15 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n      cgraph_remove_unreachable_nodes cgraph still can contain unreachable\n      nodes when they are needed for virtual clone instantiation.  */\n   unsigned reachable : 1;\n+  /* Set when function is reachable by call from other LTRANS partition.  */\n+  unsigned reachable_from_other_partition : 1;\n   /* Set once the function is lowered (i.e. its CFG is built).  */\n   unsigned lowered : 1;\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n+  /* Set when function is available in the other LTO partition.  */\n+  unsigned in_other_partition : 1;\n   /* Set when function is scheduled to be processed by local passes.  */\n   unsigned process : 1;\n   /* Set for aliases once they got through assemble_alias.  */\n@@ -723,7 +727,7 @@ cgraph_only_called_directly_p (struct cgraph_node *node)\n static inline bool\n cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n {\n-  return (!node->needed\n+  return (!node->needed && !node->reachable_from_other_partition\n   \t  && (DECL_COMDAT (node->decl) || !node->local.externally_visible));\n }\n "}, {"sha": "7d65b0476efb9601eac63852d8d8ecf41051df7e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -1130,7 +1130,7 @@ cgraph_mark_functions_to_output (void)\n \t outside the current compilation unit.  */\n       if (node->analyzed\n \t  && !node->global.inlined_to\n-\t  && (node->needed\n+\t  && (node->needed || node->reachable_from_other_partition\n \t      || (e && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n@@ -1157,6 +1157,10 @@ cgraph_mark_functions_to_output (void)\n #ifdef ENABLE_CHECKING\n \t  if (!node->global.inlined_to\n \t      && gimple_has_body_p (decl)\n+\t      /* FIXME: in ltrans unit when offline copy is outside partition but inline copies\n+\t\t are inside partition, we can end up not removing the body since we no longer\n+\t\t have analyzed node pointing to it.  */\n+\t      && !node->in_other_partition\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n@@ -1165,6 +1169,7 @@ cgraph_mark_functions_to_output (void)\n #endif\n \t  gcc_assert (node->global.inlined_to\n \t\t      || !gimple_has_body_p (decl)\n+\t\t      || node->in_other_partition\n \t\t      || DECL_EXTERNAL (decl));\n \n \t}\n@@ -1178,6 +1183,10 @@ cgraph_mark_functions_to_output (void)\n \t  tree decl = node->decl;\n \t  if (!node->global.inlined_to\n \t      && gimple_has_body_p (decl)\n+\t      /* FIXME: in ltrans unit when offline copy is outside partition but inline copies\n+\t\t are inside partition, we can end up not removing the body since we no longer\n+\t\t have analyzed node pointing to it.  */\n+\t      && !node->in_other_partition\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);"}, {"sha": "309db7f36cdb060d203d418e0283d2bec7d565dd", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -164,6 +164,23 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bitpack_delete (bp);\n }\n \n+/* Return true when node is reachable from other partition.  */\n+\n+static bool\n+reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n+{\n+  struct cgraph_edge *e;\n+  if (node->needed)\n+    return true;\n+  if (!node->analyzed)\n+    return false;\n+  if (node->global.inlined_to)\n+    return false;\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (!cgraph_node_in_set_p (e->caller, set))\n+      return true;\n+  return false;\n+}\n \n /* Output the cgraph NODE to OB.  ENCODER is used to find the\n    reference number of NODE->inlined_to.  SET is the set of nodes we\n@@ -183,6 +200,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   unsigned local, externally_visible, inlinable, analyzed;\n   bool boundary_p, wrote_decl_p;\n   intptr_t ref;\n+  bool in_other_partition = false;\n \n   boundary_p = !cgraph_node_in_set_p (node, set);\n   wrote_decl_p = bitmap_bit_p (written_decls, DECL_UID (node->decl));\n@@ -228,19 +246,17 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      local static nodes to prevent clashes with other local statics.  */\n   if (boundary_p)\n     {\n-      /* Inline clones can not be part of boundary.  */\n-      gcc_assert (!node->global.inlined_to);\n-      local = 0;\n-      externally_visible = 1;\n-      inlinable = 0;\n+      /* Inline clones can not be part of boundary.  \n+         gcc_assert (!node->global.inlined_to);  \n+\n+\t FIXME: At the moment they can be, when partition contains an inline\n+\t clone that is clone of inline clone from outside partition.  We can\n+\t reshape the clone tree and make other tree to be the root, but it\n+\t needs a bit extra work and will be promplty done by cgraph_remove_node\n+\t after reading back.  */\n+      in_other_partition = 1;\n       analyzed = 0;\n     }\n-  else if (lto_forced_extern_inline_p (node->decl))\n-    {\n-      local = 1;\n-      externally_visible = 0;\n-      inlinable = 1;\n-    }\n \n   lto_output_uleb128_stream (ob->main_stream, wrote_decl_p);\n \n@@ -263,8 +279,10 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (bp, node->address_taken, 1);\n   bp_pack_value (bp, node->abstract_and_needed, 1);\n   bp_pack_value (bp, node->reachable, 1);\n+  bp_pack_value (bp, analyzed && reachable_from_other_partition_p (node, set), 1);\n   bp_pack_value (bp, node->lowered, 1);\n   bp_pack_value (bp, analyzed, 1);\n+  bp_pack_value (bp, in_other_partition, 1);\n   bp_pack_value (bp, node->process, 1);\n   bp_pack_value (bp, node->alias, 1);\n   bp_pack_value (bp, node->finalized_by_frontend, 1);\n@@ -371,6 +389,15 @@ output_profile_summary (struct lto_simple_output_block *ob)\n     lto_output_uleb128_stream (ob->main_stream, 0);\n }\n \n+/* Add NODE into encoder as well as nodes it is cloned from.\n+   Do it in a way so clones appear first.  */\n+static void\n+add_node_to (lto_cgraph_encoder_t encoder, struct cgraph_node *node)\n+{\n+  if (node->clone_of)\n+    add_node_to (encoder, node->clone_of);\n+  lto_cgraph_encoder_encode (encoder, node);\n+}\n \n /* Output the part of the cgraph in SET.  */\n \n@@ -404,7 +431,7 @@ output_cgraph (cgraph_node_set set)\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      lto_cgraph_encoder_encode (encoder, node);\n+      add_node_to (encoder, node);\n     }\n \n   /* Go over all the nodes again to include callees that are not in\n@@ -419,7 +446,7 @@ output_cgraph (cgraph_node_set set)\n \t    {\n \t      /* We should have moved all the inlines.  */\n \t      gcc_assert (!callee->global.inlined_to);\n-\t      lto_cgraph_encoder_encode (encoder, callee);\n+\t      add_node_to (encoder, callee);\n \t      /* Also with each included function include all other functions\n \t\t in the same comdat group.  */\n \t      if (callee->same_comdat_group)\n@@ -429,7 +456,7 @@ output_cgraph (cgraph_node_set set)\n \t\t       next != callee;\n \t\t       next = next->same_comdat_group)\n \t\t    if (!cgraph_node_in_set_p (next, set))\n-\t\t      lto_cgraph_encoder_encode (encoder, next);\n+\t\t      add_node_to (encoder, next);\n \t\t}\n \t    }\n \t}\n@@ -442,11 +469,13 @@ output_cgraph (cgraph_node_set set)\n \t       next != node;\n \t       next = next->same_comdat_group)\n \t    if (!cgraph_node_in_set_p (next, set))\n-\t      lto_cgraph_encoder_encode (encoder, next);\n+\t      add_node_to (encoder, next);\n \t}\n     }\n \n-  /* Write out the nodes.  */\n+  /* Write out the nodes.  We must first output a node and then its clones,\n+     otherwise at a time reading back the node there would be nothing to clone\n+     from.  */\n   n_nodes = lto_cgraph_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n     {\n@@ -530,8 +559,10 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->address_taken = bp_unpack_value (bp, 1);\n   node->abstract_and_needed = bp_unpack_value (bp, 1);\n   node->reachable = bp_unpack_value (bp, 1);\n+  node->reachable_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n   node->analyzed = bp_unpack_value (bp, 1);\n+  node->in_other_partition = bp_unpack_value (bp, 1);\n   node->process = bp_unpack_value (bp, 1);\n   node->alias = bp_unpack_value (bp, 1);\n   node->finalized_by_frontend = bp_unpack_value (bp, 1);"}, {"sha": "d603c069ed437156db89c01dad1fedf8ea68a06c", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -50,48 +50,6 @@ static VEC(lto_out_decl_state_ptr, heap) *decl_state_stack;\n    generate the decl directory later. */\n \n VEC(lto_out_decl_state_ptr, heap) *lto_function_decl_states;\n-\n-/* Bitmap indexed by DECL_UID to indicate if a function needs to be\n-   forced extern inline. */\n-static bitmap forced_extern_inline;\n-\n-/* Initialize states for determining which function decls to be ouput\n-   as extern inline, regardless of the decls' own attributes.  */\n-\n-void\n-lto_new_extern_inline_states (void)\n-{\n-  forced_extern_inline = lto_bitmap_alloc ();\n-}\n-\n-/* Releasing resources use for states to determine which function decls\n-   to be ouput as extern inline */\n-\n-void\n-lto_delete_extern_inline_states (void)\n-{\n-  lto_bitmap_free (forced_extern_inline);\n-  forced_extern_inline = NULL;\n-}\n-\n-/* Force all the functions in DECLS to be output as extern inline.\n-   DECLS is a bitmap indexed by DECL_UID. */\n-\n-void\n-lto_force_functions_extern_inline (bitmap decls)\n-{\n-  bitmap_ior_into (forced_extern_inline, decls);\n-}\n-\n-/* Return true if FN_DECL is a function which should be emitted as\n-   extern inline.  */\n-\n-bool\n-lto_forced_extern_inline_p (tree fn_decl)\n-{\n-  return bitmap_bit_p (forced_extern_inline, DECL_UID (fn_decl));\n-}\n-\n /* Returns a hash code for P.  */\n \n hashval_t"}, {"sha": "a9544b5642a90739ad39b811802dd3ddabb9be88", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -770,10 +770,6 @@ extern void lto_push_out_decl_state (struct lto_out_decl_state *);\n extern struct lto_out_decl_state *lto_pop_out_decl_state (void);\n extern void lto_record_function_out_decl_state (tree,\n \t\t\t\t\t\tstruct lto_out_decl_state *);\n-extern void lto_new_extern_inline_states (void);\n-extern void lto_delete_extern_inline_states (void);\n-extern void lto_force_functions_extern_inline (bitmap decls);\n-extern bool lto_forced_extern_inline_p (tree fn_decl);\n \n \n /* In lto-streamer.c.  */"}, {"sha": "9118e0045ea7eda189b52603468bac5e0bed6b87", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -1,3 +1,9 @@\n+2010-04-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_add_inline_clones): Do not track inlined_decls.\n+\t(lto_add_all_inlinees): Likewise.\n+\t(lto_wpa_write_files): Likewise.\n+\n 2010-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* lto-lang.c (lto_init): Remove second argument in call to"}, {"sha": "1544f05ab4fc381e58af99964b1d66d6ae6de320", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -593,37 +593,33 @@ lto_1_to_1_map (void)\n \n static void\n lto_add_inline_clones (cgraph_node_set set, struct cgraph_node *node,\n-\t\t       bitmap original_decls, bitmap inlined_decls)\n+\t\t       bitmap original_decls)\n {\n    struct cgraph_node *callee;\n    struct cgraph_edge *edge;\n \n    cgraph_node_set_add (set, node);\n \n-   if (!bitmap_bit_p (original_decls, DECL_UID (node->decl)))\n-     bitmap_set_bit (inlined_decls, DECL_UID (node->decl));\n-\n    /* Check to see if NODE has any inlined callee.  */\n    for (edge = node->callees; edge != NULL; edge = edge->next_callee)\n      {\n \tcallee = edge->callee;\n \tif (callee->global.inlined_to != NULL)\n-\t  lto_add_inline_clones (set, callee, original_decls, inlined_decls);\n+\t  lto_add_inline_clones (set, callee, original_decls);\n      }\n }\n \n /* Compute the transitive closure of inlining of SET based on the\n    information in the callgraph.  Returns a bitmap of decls that have\n    been inlined into SET indexed by UID.  */\n \n-static bitmap\n+static void\n lto_add_all_inlinees (cgraph_node_set set)\n {\n   cgraph_node_set_iterator csi;\n   struct cgraph_node *node;\n   bitmap original_nodes = lto_bitmap_alloc ();\n   bitmap original_decls = lto_bitmap_alloc ();\n-  bitmap inlined_decls = lto_bitmap_alloc ();\n   bool changed;\n \n   /* We are going to iterate SET while adding to it, mark all original\n@@ -663,19 +659,17 @@ lto_add_all_inlinees (cgraph_node_set set)\n     }\n   while (changed);\n \n-  /* Transitively add to SET all the inline clones for every node that\n-     has been inlined.  */\n-  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n-    {\n-      node = csi_node (csi);\n-      if (bitmap_bit_p (original_nodes, node->uid))\n-\tlto_add_inline_clones (set, node, original_decls, inlined_decls);\n-    }\n+ /* Transitively add to SET all the inline clones for every node that\n+    has been inlined.  */\n+ for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+   {\n+     node = csi_node (csi);\n+     if (bitmap_bit_p (original_nodes, node->uid))\n+      lto_add_inline_clones (set, node, original_decls);\n+   }\n \n   lto_bitmap_free (original_nodes);\n   lto_bitmap_free (original_decls);\n-\n-  return inlined_decls;\n }\n \n /* Owing to inlining, we may need to promote a file-scope variable\n@@ -1004,8 +998,6 @@ lto_wpa_write_files (void)\n   unsigned i, n_sets, last_out_file_ix, num_out_files;\n   lto_file *file;\n   cgraph_node_set set;\n-  bitmap decls;\n-  VEC(bitmap,heap) *inlined_decls = NULL;\n \n   timevar_push (TV_WHOPR_WPA);\n \n@@ -1015,8 +1007,7 @@ lto_wpa_write_files (void)\n      compiled by LTRANS.  */\n   for (i = 0; VEC_iterate (cgraph_node_set, lto_cgraph_node_sets, i, set); i++)\n     {\n-      decls = lto_add_all_inlinees (set);\n-      VEC_safe_push (bitmap, heap, inlined_decls, decls);\n+      lto_add_all_inlinees (set);\n       lto_stats.num_output_cgraph_nodes += VEC_length (cgraph_node_ptr,\n \t\t\t\t\t\t       set->nodes);\n     }\n@@ -1053,13 +1044,8 @@ lto_wpa_write_files (void)\n \t    fatal_error (\"lto_elf_file_open() failed\");\n \n \t  lto_set_current_out_file (file);\n-\t  lto_new_extern_inline_states ();\n-\n-\t  decls = VEC_index (bitmap, inlined_decls, i);\n-\t  lto_force_functions_extern_inline (decls);\n \n \t  ipa_write_summaries_of_cgraph_node_set (set);\n-\t  lto_delete_extern_inline_states ();\n \n \t  lto_set_current_out_file (NULL);\n \t  lto_elf_file_close (file);\n@@ -1072,10 +1058,6 @@ lto_wpa_write_files (void)\n \n   output_files[last_out_file_ix] = NULL;\n \n-  for (i = 0; VEC_iterate (bitmap, inlined_decls, i, decls); i++)\n-    lto_bitmap_free (decls);\n-  VEC_free (bitmap, heap, inlined_decls);\n-\n   timevar_pop (TV_WHOPR_WPA_IO);\n \n   return output_files;"}, {"sha": "6437ab751da84f4dbbd208a4ae1391b4f4dca145", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a837268b2b7f2b2623392c376144c5f343f23011/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a837268b2b7f2b2623392c376144c5f343f23011", "patch": "@@ -1695,7 +1695,6 @@ ipa_write_summaries (void)\n   if (!flag_generate_lto || errorcount || sorrycount)\n     return;\n \n-  lto_new_extern_inline_states ();\n   set = cgraph_node_set_new ();\n \n   /* Create the callgraph set in the same order used in\n@@ -1726,7 +1725,6 @@ ipa_write_summaries (void)\n     }\n \n   ipa_write_summaries_1 (set);\n-  lto_delete_extern_inline_states ();\n \n   free (order);\n   ggc_free (set);"}]}