{"sha": "630c9a4d54de7c084e146afe82c6e89a9f2cf3d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwYzlhNGQ1NGRlN2MwODRlMTQ2YWZlODJjNmU4OWE5ZjJjZjNkNw==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:25Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:25Z"}, "message": "jump: Also handle jumps wrapped in UNSPEC or UNSPEC_VOLATILE\n\nVAX has interlocked branch instructions used for atomic operations and\nwe want to have them wrapped in UNSPEC_VOLATILE so as not to have code\ncarried across.  This however breaks with jump optimization and leads\nto an ICE in the build of libbacktrace like:\n\n.../libbacktrace/mmap.c:190:1: internal compiler error: in fixup_reorder_chain, at cfgrtl.c:3934\n  190 | }\n      | ^\n0x1087d46b fixup_reorder_chain\n\t.../gcc/cfgrtl.c:3934\n0x1087f29f cfg_layout_finalize()\n\t.../gcc/cfgrtl.c:4447\n0x1087c74f execute\n\t.../gcc/cfgrtl.c:3662\n\non RTL like:\n\n(jump_insn 18 17 150 4 (unspec_volatile [\n            (set (pc)\n                (if_then_else (eq (zero_extract:SI (mem/v:SI (reg/f:SI 23 [ _2 ]) [-1  S4 A32])\n                            (const_int 1 [0x1])\n                            (const_int 0 [0]))\n                        (const_int 1 [0x1]))\n                    (label_ref 20)\n                    (pc)))\n            (set (zero_extract:SI (mem/v:SI (reg/f:SI 23 [ _2 ]) [-1  S4 A32])\n                    (const_int 1 [0x1])\n                    (const_int 0 [0]))\n                (const_int 1 [0x1]))\n        ] 101) \".../libbacktrace/mmap.c\":135:14 158 {jbbssisi}\n     (nil)\n -> 20)\n\nwhen those branches are enabled with a follow-up change.  Also showing\nwith:\n\nFAIL: gcc.dg/pr61756.c (internal compiler error)\n\nHandle branches wrapped in UNSPEC_VOLATILE then and, for consistency,\nalso in UNSPEC.  The presence of UNSPEC_VOLATILE will prevent such\nbranches from being removed as they won't be accepted by `onlyjump_p',\nwe just need to let them through.\n\n\tgcc/\n\t* jump.c (pc_set): Also accept a jump wrapped in UNSPEC or\n\tUNSPEC_VOLATILE.\n\t(any_uncondjump_p, any_condjump_p): Update comment accordingly.", "tree": {"sha": "a116e8f75d2741dc913f823edfd571f8f7abf8cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a116e8f75d2741dc913f823edfd571f8f7abf8cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/630c9a4d54de7c084e146afe82c6e89a9f2cf3d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630c9a4d54de7c084e146afe82c6e89a9f2cf3d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630c9a4d54de7c084e146afe82c6e89a9f2cf3d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630c9a4d54de7c084e146afe82c6e89a9f2cf3d7/comments", "author": null, "committer": null, "parents": [{"sha": "4b70b2e07a589c4d50e14fa597eb164375a10a20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b70b2e07a589c4d50e14fa597eb164375a10a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b70b2e07a589c4d50e14fa597eb164375a10a20"}], "stats": {"total": 24, "additions": 17, "deletions": 7}, "files": [{"sha": "c508467c696e6b24dd278b6ceedc12ae8ec2ba9f", "filename": "gcc/jump.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/630c9a4d54de7c084e146afe82c6e89a9f2cf3d7/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/630c9a4d54de7c084e146afe82c6e89a9f2cf3d7/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=630c9a4d54de7c084e146afe82c6e89a9f2cf3d7", "patch": "@@ -850,17 +850,27 @@ pc_set (const rtx_insn *insn)\n   pat = PATTERN (insn);\n \n   /* The set is allowed to appear either as the insn pattern or\n-     the first set in a PARALLEL.  */\n-  if (GET_CODE (pat) == PARALLEL)\n-    pat = XVECEXP (pat, 0, 0);\n+     the first set in a PARALLEL, UNSPEC or UNSPEC_VOLATILE.  */\n+  switch (GET_CODE (pat))\n+    {\n+    case PARALLEL:\n+    case UNSPEC:\n+    case UNSPEC_VOLATILE:\n+      pat = XVECEXP (pat, 0, 0);\n+      break;\n+    default:\n+      break;\n+    }\n   if (GET_CODE (pat) == SET && GET_CODE (SET_DEST (pat)) == PC)\n     return pat;\n \n   return NULL_RTX;\n }\n \n /* Return true when insn is an unconditional direct jump,\n-   possibly bundled inside a PARALLEL.  */\n+   possibly bundled inside a PARALLEL, UNSPEC or UNSPEC_VOLATILE.\n+   The instruction may have various other effects so before removing the jump\n+   you must verify onlyjump_p.  */\n \n int\n any_uncondjump_p (const rtx_insn *insn)\n@@ -876,9 +886,9 @@ any_uncondjump_p (const rtx_insn *insn)\n }\n \n /* Return true when insn is a conditional jump.  This function works for\n-   instructions containing PC sets in PARALLELs.  The instruction may have\n-   various other effects so before removing the jump you must verify\n-   onlyjump_p.\n+   instructions containing PC sets in PARALLELs, UNSPECs or UNSPEC_VOLATILEs.\n+   The instruction may have various other effects so before removing the jump\n+   you must verify onlyjump_p.\n \n    Note that unlike condjump_p it returns false for unconditional jumps.  */\n "}]}