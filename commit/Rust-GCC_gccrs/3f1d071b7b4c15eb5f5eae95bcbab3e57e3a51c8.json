{"sha": "3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YxZDA3MWI3YjRjMTVlYjVmNWVhZTk1YmNiYWIzZTU3ZTNhNTFjOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-08-01T12:07:41Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-08-01T12:07:41Z"}, "message": "Backport of GC branch patches part 2: kill stmt status saving.\n\nFrom-SVN: r28374", "tree": {"sha": "af637eac1ac4aabf616ef5567e5e369c9bde6124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af637eac1ac4aabf616ef5567e5e369c9bde6124"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/comments", "author": null, "committer": null, "parents": [{"sha": "695f7f32ab903598ecb5de68f7f3564d65298ad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/695f7f32ab903598ecb5de68f7f3564d65298ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/695f7f32ab903598ecb5de68f7f3564d65298ad4"}], "stats": {"total": 288, "additions": 158, "deletions": 130}, "files": [{"sha": "66da0db726fa742b5a64a85b2e144298fd1aa3ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -1,3 +1,48 @@\n+Sun Aug  1 12:55:31 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* stmt.c (emit_filename, emit_lineno, expr_stmts_for_value,\n+\tlast_expr_type, last_expr_value, block_start_count, block_stack,\n+\tstack_block_stack, cond_stack, loop_stack, case_stack, nesting_stack,\n+\tnesting_depth, goto_fixup_chain): Delete global\tvars; now allocated\n+\tdynamically in stmt elt of struct function for each function.\n+\t(struct nesting): Rename function_call_count elt to n_function_calls,\n+\ttarget_temp_slot_level to block_target_temp_slot_level.  All users\n+\tchanged.\n+\t(struct stmt_status): New structure definition.\n+\tAdd many accessor macros for stmt_status elements which previously\n+\twere global variables.\n+\t(init_stmt_for_function): Allocate stmt elt for current_function.\n+\tReflect that block_start_count was renamed to\n+\tcurrent_block_start_count.\n+\t(save_stmt_status, restore_stmt_status): Delete functions.\n+\t(preserve_subexpressions_p): Don't access loop_stack when outside\n+\ta function.\n+\t(expand_start_bindings): Reflect that block_start_count was renamed to\n+\tcurrent_block_start_count.\n+\t(expand_fixup): Likewise.\n+\t(expand_decl): Don't access block_stack when outside a function.\n+\t(expand_decl_cleanup): Likewise.\n+\t(expand_dcc_cleanup): Likewise.\n+\t(expand_dhc_cleanup): Likewise.\n+\t(expand_anon_union_decl): Likewise.\n+\t(set_file_and_line_for_stmt): New function.\n+\t(in_control_zone_p): New function.\n+\n+\t* function.h (struct function): Add new elt stmt.\n+\tDelete elts block_stack, stack_block_stack, cond_stack, loop_stack,\n+\tcase_stack, nesting_stack, nesting_depth, block_start_count,\n+\tlast_expr_type, last_expr_value, expr_stmts_for_value, emit_filename,\n+\temit_lineno, goto_fixup_chain.\n+\t(save_eh_status, restore_eh_status, save_stmt_status,\n+\trestore_stmt_status): Delete declarations.\n+\t* function.c (push_function_context_to): Don't call save_stmt_status.\n+\t(pop_function_context_to): Don't call restore_stmt_status.\n+\t* tree.h (in_control_zone_p): Declare.\n+\t* rtl.h (set_file_and_line_for_stmt): Declare.\n+\n+\t* emit-rtl.c (emit_line_note): Don't set emit_filename/emit_lineno;\n+\tcall set_file_and_line_for_stmt.\n+\n Thu Jul 31 12:34:45 1999  Joe Buck  <jbuck@synopsys.com>\n \n \t* gcc.texi: Use terms \"GNU Compiler Collection\" and \"GCC\"."}, {"sha": "b70b803e9f5e0cff52873a3807ff886a6da39519", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -1,3 +1,9 @@\n+1999-08-01  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* decl.c (finish_stmt): Don't declare and test cond_stack, loop_stack,\n+\tcase_stack; use in_control_zone_p.\n+\t* typeck.c (c_expand_return): Likewise.\n+\n 1999-07-31  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* except.c (catch_clauses): Delete declaration."}, {"sha": "bbbf7be89e181e67e2c97a618c00242ca7419ecf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -14509,17 +14509,14 @@ cplus_expand_expr_stmt (exp)\n void\n finish_stmt ()\n {\n-  extern struct nesting *cond_stack, *loop_stack, *case_stack;\n-\n-  \n   if (current_function_assigns_this\n       || ! current_function_just_assigned_this)\n     return;\n   if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n       /* Constructors must wait until we are out of control\n \t zones before calling base constructors.  */\n-      if (cond_stack || loop_stack || case_stack)\n+      if (in_control_zone_p ())\n \treturn;\n       expand_expr_stmt (base_init_expr);\n       check_base_init (current_class_type);"}, {"sha": "cd0652f7529aebe12cb916f71f9a1d04e8ede457", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -6735,7 +6735,6 @@ void\n c_expand_return (retval)\n      tree retval;\n {\n-  extern struct nesting *cond_stack, *loop_stack, *case_stack;\n   extern tree dtor_label, ctor_label;\n   tree result = DECL_RESULT (current_function_decl);\n   tree valtype = TREE_TYPE (result);\n@@ -6925,7 +6924,7 @@ c_expand_return (retval)\n \n   if (retval != NULL_TREE\n       && TREE_CODE_CLASS (TREE_CODE (retval)) == 'd'\n-      && cond_stack == 0 && loop_stack == 0 && case_stack == 0)\n+      && ! in_control_zone_p ())\n     current_function_return_value = retval;\n \n   if (ctor_label && TREE_CODE (ctor_label) != ERROR_MARK)"}, {"sha": "3c0e08c5e838287756459727a17483614131bffd", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -3167,8 +3167,7 @@ emit_line_note (file, line)\n      char *file;\n      int line;\n {\n-  emit_filename = file;\n-  emit_lineno = line;\n+  set_file_and_line_for_stmt (file, line);\n \n #if 0\n   if (no_line_numbers)"}, {"sha": "3467de0c708bad406d8c1c9070c5f34e55820c36", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -626,7 +626,6 @@ push_function_context_to (context)\n   save_storage_status (p);\n   save_emit_status (p);\n   save_expr_status (p);\n-  save_stmt_status (p);\n   save_varasm_status (p, context);\n   if (save_machine_status)\n     (*save_machine_status) (p);\n@@ -715,7 +714,6 @@ pop_function_context_from (context)\n   restore_storage_status (p);\n   restore_expr_status (p);\n   restore_emit_status (p);\n-  restore_stmt_status (p);\n   restore_varasm_status (p);\n \n   if (restore_machine_status)"}, {"sha": "3d3943a4c428326d44622083013d12328056c439", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -68,6 +68,7 @@ struct function\n   struct function *next;\n \n   struct eh_status *eh;\n+  struct stmt_status *stmt;\n \n   /* For function.c.  */\n   char *name;\n@@ -124,22 +125,6 @@ struct function\n   struct var_refs_queue *fixup_var_refs_queue;\n   CUMULATIVE_ARGS args_info;\n \n-  /* For stmt.c  */\n-  struct nesting *block_stack;\n-  struct nesting *stack_block_stack;\n-  struct nesting *cond_stack;\n-  struct nesting *loop_stack;\n-  struct nesting *case_stack;\n-  struct nesting *nesting_stack;\n-  int nesting_depth;\n-  int block_start_count;\n-  tree last_expr_type;\n-  rtx last_expr_value;\n-  int expr_stmts_for_value;\n-  char *emit_filename;\n-  int emit_lineno;\n-  struct goto_fixup *goto_fixup_chain;\n-\n   /* For expr.c.  */\n   rtx pending_chain;\n   int pending_stack_adjust;\n@@ -278,10 +263,6 @@ extern void save_tree_status\t\tPROTO((struct function *, tree));\n extern void restore_tree_status\t\tPROTO((struct function *, tree));\n extern void save_varasm_status\t\tPROTO((struct function *, tree));\n extern void restore_varasm_status\tPROTO((struct function *));\n-extern void save_eh_status\t\tPROTO((struct function *));\n-extern void restore_eh_status\t\tPROTO((struct function *));\n-extern void save_stmt_status\t\tPROTO((struct function *));\n-extern void restore_stmt_status\t\tPROTO((struct function *));\n extern void save_expr_status\t\tPROTO((struct function *));\n extern void restore_expr_status\t\tPROTO((struct function *));\n extern void save_emit_status\t\tPROTO((struct function *));"}, {"sha": "9b86a84e75b01d68e5302d4877c458654da3a7b7", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -1464,6 +1464,7 @@ extern int operands_match_p\t\tPROTO ((rtx, rtx));\n extern int safe_from_earlyclobber\tPROTO ((rtx, rtx));\n \n /* In stmt.c */\n+extern void set_file_and_line_for_stmt\tPROTO ((char *, int));\n extern void expand_null_return\t\tPROTO((void));\n extern void emit_jump\t\t\tPROTO ((rtx));\n extern int preserve_subexpressions_p\tPROTO ((void));"}, {"sha": "62cfee0daf96276ec6c4d3865f3b076239d58742", "filename": "gcc/stmt.c", "status": "modified", "additions": 101, "deletions": 100, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -62,32 +62,12 @@ struct obstack stmt_obstack;\n #define CASE_VECTOR_PC_RELATIVE 0\n #endif\n \n-/* Filename and line number of last line-number note,\n-   whether we actually emitted it or not.  */\n-char *emit_filename;\n-int emit_lineno;\n-\n-/* Nonzero if within a ({...}) grouping, in which case we must\n-   always compute a value for each expr-stmt in case it is the last one.  */\n-\n-int expr_stmts_for_value;\n-\n-/* Each time we expand an expression-statement,\n-   record the expr's type and its RTL value here.  */\n-\n-static tree last_expr_type;\n-static rtx last_expr_value;\n-\n /* Each time we expand the end of a binding contour (in `expand_end_bindings')\n    and we emit a new NOTE_INSN_BLOCK_END note, we save a pointer to it here.\n    This is used by the `remember_end_note' function to record the endpoint\n    of each generated block in its associated BLOCK node.  */\n \n static rtx last_block_end_note;\n-\n-/* Number of binding contours started so far in this function.  */\n-\n-int block_start_count;\n \f\n /* Functions and data structures for expanding case statements.  */\n \n@@ -223,15 +203,15 @@ struct nesting\n \t     For contours that have stack levels or cleanups.  */\n \t  struct label_chain *label_chain;\n \t  /* Number of function calls seen, as of start of this block.  */\n-\t  int function_call_count;\n+\t  int n_function_calls;\n \t  /* Nonzero if this is associated with a EH region.  */\n \t  int exception_region;\n \t  /* The saved target_temp_slot_level from our outer block.\n \t     We may reset target_temp_slot_level to be the level of\n \t     this block, if that is done, target_temp_slot_level\n \t     reverts to the saved target_temp_slot_level at the very\n \t     end of the block.  */\n-\t  int target_temp_slot_level;\n+\t  int block_target_temp_slot_level;\n \t  /* True if we are currently emitting insns in an area of\n \t     output code that is controlled by a conditional\n \t     expression.  This is used by the cleanup handling code to\n@@ -276,31 +256,6 @@ struct nesting\n     } data;\n };\n \n-/* Chain of all pending binding contours.  */\n-struct nesting *block_stack;\n-\n-/* If any new stacks are added here, add them to POPSTACKS too.  */\n-\n-/* Chain of all pending binding contours that restore stack levels\n-   or have cleanups.  */\n-struct nesting *stack_block_stack;\n-\n-/* Chain of all pending conditional statements.  */\n-struct nesting *cond_stack;\n-\n-/* Chain of all pending loops.  */\n-struct nesting *loop_stack;\n-\n-/* Chain of all pending case or switch statements.  */\n-struct nesting *case_stack;\n-\n-/* Separate chain including all of the above,\n-   chained through the `all' field.  */\n-struct nesting *nesting_stack;\n-\n-/* Number of entries on nesting_stack now.  */\n-int nesting_depth;\n-\n /* Allocate and return a new `struct nesting'.  */\n \n #define ALLOC_NESTING() \\\n@@ -369,8 +324,6 @@ struct goto_fixup\n   tree cleanup_list_list;\n };\n \n-static struct goto_fixup *goto_fixup_chain;\n-\n /* Within any binding contour that must restore a stack level,\n    all labels are recorded with a chain of these structures.  */\n \n@@ -381,6 +334,67 @@ struct label_chain\n   tree label;\n };\n \n+struct stmt_status\n+{\n+  /* Chain of all pending binding contours.  */\n+  struct nesting *x_block_stack;\n+\n+  /* If any new stacks are added here, add them to POPSTACKS too.  */\n+\n+  /* Chain of all pending binding contours that restore stack levels\n+     or have cleanups.  */\n+  struct nesting *x_stack_block_stack;\n+\n+  /* Chain of all pending conditional statements.  */\n+  struct nesting *x_cond_stack;\n+\n+  /* Chain of all pending loops.  */\n+  struct nesting *x_loop_stack;\n+\n+  /* Chain of all pending case or switch statements.  */\n+  struct nesting *x_case_stack;\n+\n+  /* Separate chain including all of the above,\n+     chained through the `all' field.  */\n+  struct nesting *x_nesting_stack;\n+\n+  /* Number of entries on nesting_stack now.  */\n+  int x_nesting_depth;\n+\n+  /* Number of binding contours started so far in this function.  */\n+  int x_block_start_count;\n+\n+  /* Each time we expand an expression-statement,\n+     record the expr's type and its RTL value here.  */\n+  tree x_last_expr_type;\n+  rtx x_last_expr_value;\n+\n+  /* Nonzero if within a ({...}) grouping, in which case we must\n+     always compute a value for each expr-stmt in case it is the last one.  */\n+  int x_expr_stmts_for_value;\n+\n+  /* Filename and line number of last line-number note,\n+     whether we actually emitted it or not.  */\n+  char *x_emit_filename;\n+  int x_emit_lineno;\n+\n+  struct goto_fixup *x_goto_fixup_chain;\n+};\n+\n+#define block_stack (current_function->stmt->x_block_stack)\n+#define stack_block_stack (current_function->stmt->x_stack_block_stack)\n+#define cond_stack (current_function->stmt->x_cond_stack)\n+#define loop_stack (current_function->stmt->x_loop_stack)\n+#define case_stack (current_function->stmt->x_case_stack)\n+#define nesting_stack (current_function->stmt->x_nesting_stack)\n+#define nesting_depth (current_function->stmt->x_nesting_depth)\n+#define current_block_start_count (current_function->stmt->x_block_start_count)\n+#define last_expr_type (current_function->stmt->x_last_expr_type)\n+#define last_expr_value (current_function->stmt->x_last_expr_value)\n+#define expr_stmts_for_value (current_function->stmt->x_expr_stmts_for_value)\n+#define emit_filename (current_function->stmt->x_emit_filename)\n+#define emit_lineno (current_function->stmt->x_emit_lineno)\n+#define goto_fixup_chain (current_function->stmt->x_goto_fixup_chain)\n \n /* Non-zero if we are using EH to handle cleanus.  */\n static int using_eh_for_cleanups_p = 0;\n@@ -428,6 +442,9 @@ init_stmt ()\n void\n init_stmt_for_function ()\n {\n+  current_function->stmt\n+    = (struct stmt_status *) xmalloc (sizeof (struct stmt_status));\n+\n   /* We are not currently within any block, conditional, loop or case.  */\n   block_stack = 0;\n   stack_block_stack = 0;\n@@ -437,7 +454,7 @@ init_stmt_for_function ()\n   nesting_stack = 0;\n   nesting_depth = 0;\n \n-  block_start_count = 0;\n+  current_block_start_count = 0;\n \n   /* No gotos have been expanded yet.  */\n   goto_fixup_chain = 0;\n@@ -448,47 +465,25 @@ init_stmt_for_function ()\n \n   init_eh_for_function ();\n }\n-\n-void\n-save_stmt_status (p)\n-     struct function *p;\n+\f\n+/* Return nonzero if anything is pushed on the loop, condition, or case\n+   stack.  */\n+int\n+in_control_zone_p ()\n {\n-  p->block_stack = block_stack;\n-  p->stack_block_stack = stack_block_stack;\n-  p->cond_stack = cond_stack;\n-  p->loop_stack = loop_stack;\n-  p->case_stack = case_stack;\n-  p->nesting_stack = nesting_stack;\n-  p->nesting_depth = nesting_depth;\n-  p->block_start_count = block_start_count;\n-  p->last_expr_type = last_expr_type;\n-  p->last_expr_value = last_expr_value;\n-  p->expr_stmts_for_value = expr_stmts_for_value;\n-  p->emit_filename = emit_filename;\n-  p->emit_lineno = emit_lineno;\n-  p->goto_fixup_chain = goto_fixup_chain;\n+  return cond_stack || loop_stack || case_stack;\n }\n \n+/* Record the current file and line.  Called from emit_line_note.  */\n void\n-restore_stmt_status (p)\n-     struct function *p;\n+set_file_and_line_for_stmt (file, line)\n+     char *file;\n+     int line;\n {\n-  block_stack = p->block_stack;\n-  stack_block_stack = p->stack_block_stack;\n-  cond_stack = p->cond_stack;\n-  loop_stack = p->loop_stack;\n-  case_stack = p->case_stack;\n-  nesting_stack = p->nesting_stack;\n-  nesting_depth = p->nesting_depth;\n-  block_start_count = p->block_start_count;\n-  last_expr_type = p->last_expr_type;\n-  last_expr_value = p->last_expr_value;\n-  expr_stmts_for_value = p->expr_stmts_for_value;\n-  emit_filename = p->emit_filename;\n-  emit_lineno = p->emit_lineno;\n-  goto_fixup_chain = p->goto_fixup_chain;\n+  emit_filename = file;\n+  emit_lineno = line;\n }\n-\f\n+\n /* Emit a no-op instruction.  */\n \n void\n@@ -878,7 +873,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n         emit_insns_after (start, original_before_jump);\n       }\n \n-      fixup->block_start_count = block_start_count;\n+      fixup->block_start_count = current_block_start_count;\n       fixup->stack_level = 0;\n       fixup->cleanup_list_list\n \t= ((block->data.block.outer_cleanups\n@@ -2437,7 +2432,7 @@ preserve_subexpressions_p ()\n   if (flag_expensive_optimizations)\n     return 1;\n \n-  if (optimize == 0 || loop_stack == 0)\n+  if (optimize == 0 || current_function == 0 || loop_stack == 0)\n     return 0;\n \n   insn = get_last_insn_anywhere ();\n@@ -3019,9 +3014,9 @@ expand_start_bindings (exit_flag)\n   thisblock->depth = ++nesting_depth;\n   thisblock->data.block.stack_level = 0;\n   thisblock->data.block.cleanups = 0;\n-  thisblock->data.block.function_call_count = 0;\n+  thisblock->data.block.n_function_calls = 0;\n   thisblock->data.block.exception_region = 0;\n-  thisblock->data.block.target_temp_slot_level = target_temp_slot_level;\n+  thisblock->data.block.block_target_temp_slot_level = target_temp_slot_level;\n \n   thisblock->data.block.conditional_code = 0;\n   thisblock->data.block.last_unconditional_cleanup = note;\n@@ -3038,7 +3033,7 @@ expand_start_bindings (exit_flag)\n   thisblock->data.block.label_chain = 0;\n   thisblock->data.block.innermost_stack_block = stack_block_stack;\n   thisblock->data.block.first_insn = note;\n-  thisblock->data.block.block_start_count = ++block_start_count;\n+  thisblock->data.block.block_start_count = ++current_block_start_count;\n   thisblock->exit_label = exit_flag ? gen_label_rtx () : 0;\n   block_stack = thisblock;\n   nesting_stack = thisblock;\n@@ -3365,7 +3360,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \n   /* If necessary, make handlers for nonlocal gotos taking\n      place in the function calls in this block.  */\n-  if (function_call_count != thisblock->data.block.function_call_count\n+  if (function_call_count != thisblock->data.block.n_function_calls\n       && nonlocal_labels\n       /* Make handler for outermost block\n \t if there were any nonlocal gotos to this function.  */\n@@ -3462,7 +3457,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \tuse_variable (DECL_RTL (decl));\n \n   /* Restore the temporary level of TARGET_EXPRs.  */\n-  target_temp_slot_level = thisblock->data.block.target_temp_slot_level;\n+  target_temp_slot_level = thisblock->data.block.block_target_temp_slot_level;\n \n   /* Restore block_stack level for containing block.  */\n \n@@ -3480,7 +3475,7 @@ void\n expand_decl (decl)\n      register tree decl;\n {\n-  struct nesting *thisblock = block_stack;\n+  struct nesting *thisblock;\n   tree type;\n \n   type = TREE_TYPE (decl);\n@@ -3496,6 +3491,8 @@ expand_decl (decl)\n   if (TREE_STATIC (decl) || DECL_EXTERNAL (decl))\n     return;\n \n+  thisblock = block_stack;\n+\n   /* Create the RTL representation for the variable.  */\n \n   if (type == error_mark_node)\n@@ -3722,12 +3719,14 @@ int\n expand_decl_cleanup (decl, cleanup)\n      tree decl, cleanup;\n {\n-  struct nesting *thisblock = block_stack;\n+  struct nesting *thisblock;\n \n   /* Error if we are not in any block.  */\n-  if (thisblock == 0)\n+  if (current_function == 0 || block_stack == 0)\n     return 0;\n \n+  thisblock = block_stack;\n+\n   /* Record the cleanup if there is one.  */\n \n   if (cleanup != 0)\n@@ -3851,12 +3850,13 @@ int\n expand_dcc_cleanup (decl)\n      tree decl;\n {\n-  struct nesting *thisblock = block_stack;\n+  struct nesting *thisblock;\n   tree cleanup;\n \n   /* Error if we are not in any block.  */\n-  if (thisblock == 0)\n+  if (current_function == 0 || block_stack == 0)\n     return 0;\n+  thisblock = block_stack;\n \n   /* Record the cleanup for the dynamic handler chain.  */\n \n@@ -3892,12 +3892,13 @@ int\n expand_dhc_cleanup (decl)\n      tree decl;\n {\n-  struct nesting *thisblock = block_stack;\n+  struct nesting *thisblock;\n   tree cleanup;\n \n   /* Error if we are not in any block.  */\n-  if (thisblock == 0)\n+  if (current_function == 0 || block_stack == 0)\n     return 0;\n+  thisblock = block_stack;\n \n   /* Record the cleanup for the dynamic handler chain.  */\n \n@@ -3924,7 +3925,7 @@ void\n expand_anon_union_decl (decl, cleanup, decl_elts)\n      tree decl, cleanup, decl_elts;\n {\n-  struct nesting *thisblock = block_stack;\n+  struct nesting *thisblock = current_function == 0 ? 0 : block_stack;\n   rtx x;\n \n   expand_decl (decl);"}, {"sha": "7047f1d56549333330d918dd669870c5896dd3f7", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "patch": "@@ -1929,6 +1929,7 @@ extern int (*lang_get_alias_set)                PROTO((tree));\n \f\n /* In stmt.c */\n \n+extern int in_control_zone_p\t\t\tPROTO((void));\n extern void expand_fixups\t\t\tPROTO((struct rtx_def *));\n extern tree expand_start_stmt_expr\t\tPROTO((void));\n extern tree expand_end_stmt_expr\t\tPROTO((tree));"}]}