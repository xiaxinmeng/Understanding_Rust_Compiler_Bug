{"sha": "eea58adb130013762b585f149c2dfaddb2072818", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVhNThhZGIxMzAwMTM3NjJiNTg1ZjE0OWMyZGZhZGRiMjA3MjgxOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-05-30T06:26:09Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-05-30T06:26:09Z"}, "message": "decl.c: Fix comment typos.\n\n2012-05-30  Tobias Burnus  <burnus@net-b.de>\n\n        * decl.c: Fix comment typos.\n        * expr.c: Ditto.\n        * frontend-passes.c: Ditto.\n        * match.c: Ditto.\n        * resolve.c: Ditto.\n        * trans-array.c: Ditto.\n        * trans-common.c: Ditto.\n        * trans-intrinsic.c: Ditto.\n        * trans-types.c: Ditto.\n\n2012-05-30  Tobias Burnus  <burnus@net-b.de>\n\n        * io/io.h: Fix comment typos.\n        * io/list_read.c: Ditto.\n\nFrom-SVN: r188000", "tree": {"sha": "9bfa6519970c4abc5a0985c4591c2340cd3eb151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bfa6519970c4abc5a0985c4591c2340cd3eb151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eea58adb130013762b585f149c2dfaddb2072818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea58adb130013762b585f149c2dfaddb2072818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea58adb130013762b585f149c2dfaddb2072818", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea58adb130013762b585f149c2dfaddb2072818/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa95aa254783764ed1969f1ea937ddb198bb360f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa95aa254783764ed1969f1ea937ddb198bb360f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa95aa254783764ed1969f1ea937ddb198bb360f"}], "stats": {"total": 101, "additions": 59, "deletions": 42}, "files": [{"sha": "e8f5c53f0e3fec1f71698924efafc827c1542492", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -1,3 +1,15 @@\n+2012-05-30  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* decl.c: Fix comment typos.\n+\t* expr.c: Ditto.\n+\t* frontend-passes.c: Ditto.\n+\t* match.c: Ditto.\n+\t* resolve.c: Ditto.\n+\t* trans-array.c: Ditto.\n+\t* trans-common.c: Ditto.\n+\t* trans-intrinsic.c: Ditto.\n+\t* trans-types.c: Ditto.\n+\n 2012-05-23  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51055"}, {"sha": "58263aa24c3b92d66d142ba68db19990d65e7186", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -586,7 +586,7 @@ gfc_match_data (void)\n /************************ Declaration statements *********************/\n \n \n-/* Auxilliary function to merge DIMENSION and CODIMENSION array specs.  */\n+/* Auxiliary function to merge DIMENSION and CODIMENSION array specs.  */\n \n static void\n merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n@@ -1715,7 +1715,7 @@ match_pointer_init (gfc_expr **init, int procptr)\n       return MATCH_ERROR;\n     }\n \n-  /* Match NULL() initilization.  */\n+  /* Match NULL() initialization.  */\n   m = gfc_match_null (init);\n   if (m != MATCH_NO)\n     return m;\n@@ -2235,7 +2235,7 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n      C interoperable kind (and store the fact).\t */\n   if (e->ts.is_c_interop == 1)\n     {\n-      /* Mark this as c interoperable if being declared with one\n+      /* Mark this as C interoperable if being declared with one\n \t of the named constants from iso_c_binding.  */\n       ts->is_c_interop = e->ts.is_iso_c;\n       ts->f90_type = e->ts.f90_type;\n@@ -2533,10 +2533,10 @@ gfc_match_char_spec (gfc_typespec *ts)\n   ts->kind = kind == 0 ? gfc_default_character_kind : kind;\n   ts->deferred = deferred;\n \n-  /* We have to know if it was a c interoperable kind so we can\n+  /* We have to know if it was a C interoperable kind so we can\n      do accurate type checking of bind(c) procs, etc.  */\n   if (kind != 0)\n-    /* Mark this as c interoperable if being declared with one\n+    /* Mark this as C interoperable if being declared with one\n        of the named constants from iso_c_binding.  */\n     ts->is_c_interop = is_iso_c;\n   else if (len != NULL)\n@@ -2766,7 +2766,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n   /* Search for the name but allow the components to be defined later.  If\n      type = -1, this typespec has been seen in a function declaration but\n      the type could not be accessed at that point.  The actual derived type is\n-     stored in a symtree with the first letter of the name captialized; the\n+     stored in a symtree with the first letter of the name capitalized; the\n      symtree with the all lower-case name contains the associated\n      generic function.  */\n   dt_name = gfc_get_string (\"%c%s\",\n@@ -3200,7 +3200,7 @@ gfc_match_import (void)\n \t  if (sym->attr.generic && (sym = gfc_find_dt_in_generic (sym)))\n \t    {\n \t      /* The actual derived type is stored in a symtree with the first\n-\t\t letter of the name captialized; the symtree with the all\n+\t\t letter of the name capitalized; the symtree with the all\n \t\t lower-case name contains the associated generic function. */\n \t      st = gfc_new_symtree (&gfc_current_ns->sym_root,\n \t\t\tgfc_get_string (\"%c%s\",\n@@ -3844,7 +3844,7 @@ set_binding_label (const char **dest_label, const char *sym_name,\n     }\n \n   if (curr_binding_label)\n-    /* Binding label given; store in temp holder til have sym.  */\n+    /* Binding label given; store in temp holder till have sym.  */\n     *dest_label = curr_binding_label;\n   else\n     {\n@@ -7864,7 +7864,7 @@ match_binding_attributes (gfc_typebound_proc* ba, bool generic, bool ppc)\n   bool seen_ptr = false;\n   match m = MATCH_YES;\n \n-  /* Intialize to defaults.  Do so even before the MATCH_NO check so that in\n+  /* Initialize to defaults.  Do so even before the MATCH_NO check so that in\n      this case the defaults are in there.  */\n   ba->access = ACCESS_UNKNOWN;\n   ba->pass_arg = NULL;"}, {"sha": "bde62d5874184aed3b45d16f953329113595a60b", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -711,7 +711,7 @@ gfc_copy_shape (mpz_t *shape, int rank)\n \n \n /* Copy a shape array excluding dimension N, where N is an integer\n-   constant expression.  Dimensions are numbered in fortran style --\n+   constant expression.  Dimensions are numbered in Fortran style --\n    starting with ONE.\n \n    So, if the original shape array contains R elements\n@@ -4405,7 +4405,7 @@ gfc_has_ultimate_pointer (gfc_expr *e)\n \n /* Check whether an expression is \"simply contiguous\", cf. F2008, 6.5.4.\n    Note: A scalar is not regarded as \"simply contiguous\" by the standard.\n-   if bool is not strict, some futher checks are done - for instance,\n+   if bool is not strict, some further checks are done - for instance,\n    a \"(::1)\" is accepted.  */\n \n bool\n@@ -4482,7 +4482,7 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n \treturn false;\n \n       /* Following the standard, \"(::1)\" or - if known at compile time -\n-\t \"(lbound:ubound)\" are not simply contigous; if strict\n+\t \"(lbound:ubound)\" are not simply contiguous; if strict\n \t is false, they are regarded as simply contiguous.  */\n       if (ar->stride[i] && (strict || ar->stride[i]->expr_type != EXPR_CONSTANT\n \t\t\t    || ar->stride[i]->ts.type != BT_INTEGER"}, {"sha": "40ca0745a1f153a110b93c4b40ac2a6338fcae4a", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -243,7 +243,7 @@ cfe_register_funcs (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n }\n \n /* Returns a new expression (a variable) to be used in place of the old one,\n-   with an an assignment statement before the current statement to set\n+   with an assignment statement before the current statement to set\n    the value of the variable. Creates a new BLOCK for the statement if\n    that hasn't already been done and puts the statement, plus the\n    newly created variables, in that block.  */\n@@ -806,7 +806,7 @@ optimize_op (gfc_expr *e)\n {\n   gfc_intrinsic_op op = e->value.op.op;\n \n-  /* Only use new-style comparisions.  */\n+  /* Only use new-style comparisons.  */\n   switch(op)\n     {\n     case INTRINSIC_EQ_OS:\n@@ -931,7 +931,7 @@ optimize_comparison (gfc_expr *e, gfc_intrinsic_op op)\n     }\n   else if (e->expr_type == EXPR_FUNCTION)\n     {\n-      /* One of the lexical comparision functions.  */\n+      /* One of the lexical comparison functions.  */\n       firstarg = e->value.function.actual;\n       secondarg = firstarg->next;\n       op1 = firstarg->expr;"}, {"sha": "29b6428ab9208e9351431bbf5bdb5ca495323333", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -597,7 +597,7 @@ gfc_match_name_C (const char **buffer)\n   c = gfc_next_char_literal (INSTRING_WARN);\n \n   /* If the user put nothing expect spaces between the quotes, it is valid\n-     and simply means there is no name= specifier and the name is the fortran\n+     and simply means there is no name= specifier and the name is the Fortran\n      symbol name, all lowercase.  */\n   if (c == '\"' || c == '\\'')\n     {\n@@ -5366,7 +5366,7 @@ gfc_match_select_type (void)\n      array, which can have a reference, from other expressions that\n      have references, such as derived type components, and are not\n      allowed by the standard.\n-     TODO; see is it is sufficent to exclude component and substring\n+     TODO; see is it is sufficient to exclude component and substring\n      references.  */\n   class_array = expr1->expr_type == EXPR_VARIABLE\n \t\t  && expr1->ts.type != BT_UNKNOWN"}, {"sha": "3627b714a07a69abdf2b17afabbebac11834a526", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -1401,7 +1401,7 @@ count_specific_procs (gfc_expr *e)\n \n \n /* See if a call to sym could possibly be a not allowed RECURSION because of\n-   a missing RECURIVE declaration.  This means that either sym is the current\n+   a missing RECURSIVE declaration.  This means that either sym is the current\n    context itself, or sym is the parent of a contained procedure calling its\n    non-RECURSIVE containing procedure.\n    This also works if sym is an ENTRY.  */\n@@ -5684,7 +5684,7 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n       derived = e->value.compcall.base_object->ts.u.derived;\n       st = NULL;\n \n-      /* If necessary, go throught the inheritance chain.  */\n+      /* If necessary, go through the inheritance chain.  */\n       while (!st && derived)\n \t{\n \t  /* Look for the typebound procedure 'name'.  */\n@@ -6879,7 +6879,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   gfc_component *c;\n   gfc_try t;\n \n-  /* Mark the ultimost array component as being in allocate to allow DIMEN_STAR\n+  /* Mark the utmost array component as being in allocate to allow DIMEN_STAR\n      checking of coarrays.  */\n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->next == NULL)\n@@ -7130,7 +7130,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   if (dimension == 0 && codimension == 0)\n     goto success;\n \n-  /* Make sure the last reference node is an array specifiction.  */\n+  /* Make sure the last reference node is an array specification.  */\n \n   if (!ref2 || ref2->type != REF_ARRAY || ref2->u.ar.type == AR_FULL\n       || (dimension && ref2->u.ar.dimen == 0))\n@@ -8200,7 +8200,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \n       /* Chain in the new list only if it is marked as dangling.  Otherwise\n \t there is a CASE label overlap and this is already used.  Just ignore,\n-\t the error is diagonsed elsewhere.  */\n+\t the error is diagnosed elsewhere.  */\n       if (st->n.sym->assoc->dangling)\n \t{\n \t  new_st->ext.block.assoc = st->n.sym->assoc;\n@@ -9366,7 +9366,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    case EXEC_OMP_WORKSHARE:\n \t      omp_workshare_save = omp_workshare_flag;\n \t      omp_workshare_flag = 1;\n-\t      /* FALLTHROUGH */\n+\t      /* FALL THROUGH */\n \t    default:\n \t      gfc_resolve_blocks (code->block, ns);\n \t      break;"}, {"sha": "253446215d39f36a6272f04630b99807fa46acd0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -37,7 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n    descriptors and data pointers are also translated.\n \n    If the expression is an assignment, we must then resolve any dependencies.\n-   In fortran all the rhs values of an assignment must be evaluated before\n+   In Fortran all the rhs values of an assignment must be evaluated before\n    any assignments take place.  This can require a temporary array to store the\n    values.  We also require a temporary when we are passing array expressions\n    or vector subscripts as procedure parameters.\n@@ -973,7 +973,7 @@ get_array_ref_dim_for_loop_dim (gfc_ss *ss, int loop_dim)\n \n    'eltype' == NULL signals that the temporary should be a class object.\n    The 'initial' expression is used to obtain the size of the dynamic\n-   type; otehrwise the allocation and initialisation proceeds as for any\n+   type; otherwise the allocation and initialisation proceeds as for any\n    other expression\n \n    PRE, POST, INITIAL, DYNAMIC and DEALLOC are as for\n@@ -1754,7 +1754,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  tmp = build1_v (LABEL_EXPR, exit_label);\n \t  gfc_add_expr_to_block (&implied_do_block, tmp);\n \n-\t  /* Finishe the implied-do loop.  */\n+\t  /* Finish the implied-do loop.  */\n \t  tmp = gfc_finish_block(&implied_do_block);\n \t  gfc_add_expr_to_block(pblock, tmp);\n \n@@ -1765,7 +1765,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n }\n \n \n-/* A catch-all to obtain the string length for anything that is not a\n+/* A catch-all to obtain the string length for anything that is not\n    a substring of non-constant length, a constant, array or variable.  */\n \n static void\n@@ -4323,7 +4323,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \n /* Browse through each array's information from the scalarizer and set the loop\n    bounds according to the \"best\" one (per dimension), i.e. the one which\n-   provides the most information (constant bounds, shape, etc).  */\n+   provides the most information (constant bounds, shape, etc.).  */\n \n static void\n set_loop_bounds (gfc_loopinfo *loop)\n@@ -4367,7 +4367,7 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t    }\n \t  else\n \t    {\n-\t      /* Silence unitialized warnings.  */\n+\t      /* Silence uninitialized warnings.  */\n \t      specinfo = NULL;\n \t      spec_dim = 0;\n \t    }\n@@ -4906,7 +4906,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n     }\n \n   /* The stride is the number of elements in the array, so multiply by the\n-     size of an element to get the total size.  Obviously, if there ia a\n+     size of an element to get the total size.  Obviously, if there is a\n      SOURCE expression (expr3) we must use its element size.  */\n   if (expr3_elem_size != NULL_TREE)\n     tmp = expr3_elem_size;\n@@ -6382,7 +6382,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       /* A transformational function return value will be a temporary\n \t array descriptor.  We still need to go through the scalarizer\n-\t to create the descriptor.  Elemental functions ar handled as\n+\t to create the descriptor.  Elemental functions are handled as\n \t arbitrary expressions, i.e. copy to a temporary.  */\n \n       if (se->direct_byref)\n@@ -7423,7 +7423,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \tcase DEALLOCATE_ALLOC_COMP:\n \n \t  /* gfc_deallocate_scalar_with_status calls gfc_deallocate_alloc_comp\n-\t     (ie. this function) so generate all the calls and suppress the\n+\t     (i.e. this function) so generate all the calls and suppress the\n \t     recursion from here, if necessary.  */\n \t  called_dealloc_with_status = false;\n \t  gfc_init_block (&tmpblock);\n@@ -8455,7 +8455,7 @@ gfc_reverse_ss (gfc_ss * ss)\n }\n \n \n-/* Given an expression refering to a procedure, return the symbol of its\n+/* Given an expression referring to a procedure, return the symbol of its\n    interface.  We can't get the procedure symbol directly as we have to handle\n    the case of (deferred) type-bound procedures.  */\n "}, {"sha": "695c4f52356d3f14d05e03648b631b68da7cf550", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -86,7 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n    Each segment is described by a chain of segment_info structures.  Each\n    segment_info structure describes the extents of a single variable within\n    the segment.  This list is maintained in the order the elements are\n-   positioned withing the segment.  If two elements have the same starting\n+   positioned within the segment.  If two elements have the same starting\n    offset the smaller will come first.  If they also have the same size their\n    ordering is undefined. \n    "}, {"sha": "04d6caab183c72704957c077a67c924ed84bc7f6", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */\n #include \"trans-stmt.h\"\n \n-/* This maps fortran intrinsic math functions to external library or GCC\n+/* This maps Fortran intrinsic math functions to external library or GCC\n    builtin functions.  */\n typedef struct GTY(()) gfc_intrinsic_map_t {\n   /* The explicit enum is required to work around inadequacies in the\n@@ -1579,7 +1579,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \t}\n \n \n-      /* Substract 1 to get to zero based and add dimensions.  */\n+      /* Subtract 1 to get to zero based and add dimensions.  */\n       switch (arg->expr->rank)\n \t{\n \tcase 0:"}, {"sha": "aa50e3d0b211623f0253ec39ab9bf722364276cf", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -1957,7 +1957,7 @@ gfc_nonrestricted_type (tree t)\n {\n   tree ret = t;\n \n-  /* If the type isn't layed out yet, don't copy it.  If something\n+  /* If the type isn't laid out yet, don't copy it.  If something\n      needs it for real it should wait until the type got finished.  */\n   if (!TYPE_SIZE (t))\n     return t;"}, {"sha": "547ed714f8112c5e7dfd4aad9aacb0bca69e67f0", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -1,3 +1,8 @@\n+2012-05-30  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* io/io.h: Fix comment typos.\n+\t* io/list_read.c: Ditto.\n+\n 2012-05-27  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* intrinsics/time_1.h (gf_cputime): Don't reevaluate HZ expression"}, {"sha": "3b4b34a16f805ee7198ce17bfedab2f9b2658335", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -1,10 +1,10 @@\n /* Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011\n+   2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n    F2003 I/O support contributed by Jerry DeLisle\n \n-This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+This file is part of the GNU Fortran runtime library (libgfortran).\n \n Libgfortran is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -72,7 +72,7 @@ typedef struct array_loop_spec\n }\n array_loop_spec;\n \n-/* A stucture to build a hash table for format data.  */\n+/* A structure to build a hash table for format data.  */\n \n #define FORMAT_HASH_SIZE 16\n \n@@ -400,7 +400,7 @@ typedef struct st_parameter_dt\n \t  unsigned at_eol : 1;\n \t  unsigned comma_flag : 1;\n \t  /* A namelist specific flag used in the list directed library\n-\t     to flag that calls are being made from namelist read (eg. to\n+\t     to flag that calls are being made from namelist read (e.g. to\n \t     ignore comments or to treat '/' as a terminator)  */\n \t  unsigned namelist_mode : 1;\n \t  /* A namelist specific flag used in the list directed library"}, {"sha": "6155d974e8be94ea7e644c4bf3733822b54ec786", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea58adb130013762b585f149c2dfaddb2072818/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea58adb130013762b585f149c2dfaddb2072818/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=eea58adb130013762b585f149c2dfaddb2072818", "patch": "@@ -3074,7 +3074,7 @@ namelist_read (st_parameter_dt *dtp)\n   if (dtp->u.p.nml_read_error)\n     goto find_nml_name;\n \n-  /* A trailing space is required, we give a little lattitude here, 10.9.1.  */ \n+  /* A trailing space is required, we give a little latitude here, 10.9.1.  */ \n   c = next_char (dtp);\n   if (!is_separator(c) && c != '!')\n     {"}]}