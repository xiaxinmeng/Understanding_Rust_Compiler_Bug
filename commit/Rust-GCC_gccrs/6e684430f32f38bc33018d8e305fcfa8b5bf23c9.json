{"sha": "6e684430f32f38bc33018d8e305fcfa8b5bf23c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2ODQ0MzBmMzJmMzhiYzMzMDE4ZDhlMzA1ZmNmYThiNWJmMjNjOQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-05-19T09:23:21Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-05-19T09:23:21Z"}, "message": "reload1.c (reload_reg_free_for_value_p): New function.\n\n\t* reload1.c (reload_reg_free_for_value_p): New function.\n\t(allocate_reload_reg, choose_reload_regs): Use it.\n\nFrom-SVN: r19869", "tree": {"sha": "0c7c5a02adc4a0d157ad11c9e746c4331147214c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c7c5a02adc4a0d157ad11c9e746c4331147214c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e684430f32f38bc33018d8e305fcfa8b5bf23c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e684430f32f38bc33018d8e305fcfa8b5bf23c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e684430f32f38bc33018d8e305fcfa8b5bf23c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e684430f32f38bc33018d8e305fcfa8b5bf23c9/comments", "author": null, "committer": null, "parents": [{"sha": "7ecb5d27dcb3fd4bfff5988647d99fc7797655d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ecb5d27dcb3fd4bfff5988647d99fc7797655d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ecb5d27dcb3fd4bfff5988647d99fc7797655d2"}], "stats": {"total": 141, "additions": 130, "deletions": 11}, "files": [{"sha": "f47ddfdcde068fdc28481d9a4a191f9294b687d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e684430f32f38bc33018d8e305fcfa8b5bf23c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e684430f32f38bc33018d8e305fcfa8b5bf23c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e684430f32f38bc33018d8e305fcfa8b5bf23c9", "patch": "@@ -1,3 +1,8 @@\n+Tue May 19 17:19:16 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload1.c (reload_reg_free_for_value_p): New function.\n+\t(allocate_reload_reg, choose_reload_regs): Use it.\n+\n Tue May 19 11:51:00 EDT 1998  Andrew MacLeod  (amacleod@cygnus.com)\n \n \t* except.c (expand_start_catch): Correct logic for when to"}, {"sha": "e3bc950c08f2c78ebed1a7eb8a982f7012002ff3", "filename": "gcc/reload1.c", "status": "modified", "additions": 125, "deletions": 11, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e684430f32f38bc33018d8e305fcfa8b5bf23c9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e684430f32f38bc33018d8e305fcfa8b5bf23c9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6e684430f32f38bc33018d8e305fcfa8b5bf23c9", "patch": "@@ -378,6 +378,7 @@ static void clear_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n \t\t\t\t\t       enum machine_mode));\n static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type));\n+static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx));\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n static int allocate_reload_reg\t\tPROTO((int, rtx, int, int));\n static void choose_reload_regs\t\tPROTO((rtx, rtx));\n@@ -4979,6 +4980,100 @@ rtx reload_override_in[MAX_RELOADS];\n    or -1 if we did not need a register for this reload.  */\n int reload_spill_index[MAX_RELOADS];\n \n+/* Return 1 if the value in reload reg REGNO, as used by a reload\n+   needed for the part of the insn specified by OPNUM and TYPE,\n+   may be used to load VALUE into it.\n+   Other read-only reloads with the same value do not conflict.\n+   The caller has to make sure that there is no conflict with the return\n+   register.  */\n+static int\n+reload_reg_free_for_value_p (regno, opnum, type, value)\n+     int regno;\n+     int opnum;\n+     enum reload_type type;\n+     rtx value;\n+{\n+  int time1;\n+  int i;\n+\n+  /* We use some pseudo 'time' value to check if the lifetimes of the\n+     new register use would overlap with the one of a previous reload\n+     that is not read-only or uses a different value.\n+     The 'time' used doesn't have to be linear in any shape or form, just\n+     monotonic.\n+     Some reload types use different 'buckets' for each operand.\n+     So there are MAX_RECOG_OPERANDS different time values for each\n+     such reload type.  */\n+  switch (type)\n+    {\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      time1 = 0;\n+      break;\n+    /* For each input, we might have a sequence of RELOAD_FOR_INPADDR_ADDRESS,\n+       RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 ,\n+       respectively, to the time values for these, we get distinct time\n+       values.  To get distinct time values for each operand, we have to\n+       multiply opnum by at least three.  We round that up to four because\n+       multiply by four is often cheaper.  */\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n+      time1 = opnum * 4 + 1;\n+      break;\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      time1 = opnum * 4 + 2;\n+      break;\n+    case RELOAD_FOR_INPUT:\n+      time1 = opnum * 4 + 3;\n+      break;\n+    /* opnum * 4 + 3 < opnum * 4 + 4\n+       <= (MAX_RECOG_OPERAND - 1) * 4 + 4 == MAX_RECOG_OPERAND * 4 */\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      time1 = MAX_RECOG_OPERANDS * 4 + opnum;\n+      break;\n+    default:\n+      time1 = MAX_RECOG_OPERANDS * 5;\n+    }\n+\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      rtx reg = reload_reg_rtx[i];\n+      if (reg && GET_CODE (reg) == REG\n+\t  && ((unsigned) regno - true_regnum (reg)\n+\t      <= HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)) - 1U)\n+\t  && (! reload_in[i] || ! rtx_equal_p (reload_in[i], value)\n+\t      || reload_out[i]))\n+\t{\n+\t  int time2;\n+\t  switch (reload_when_needed[i])\n+\t    {\n+\t    case RELOAD_FOR_OTHER_ADDRESS:\n+\t      time2 = 0;\n+\t      break;\n+\t    case RELOAD_FOR_INPADDR_ADDRESS:\n+\t      time2 = reload_opnum[i] * 4 + 1;\n+\t      break;\n+\t    case RELOAD_FOR_INPUT_ADDRESS:\n+\t      time2 = reload_opnum[i] * 4 + 2;\n+\t      break;\n+\t    case RELOAD_FOR_INPUT:\n+\t      time2 = reload_opnum[i] * 4 + 3;\n+\t      break;\n+\t    /* RELOAD_FOR_OUTPUT and RELOAD_FOR_OUTPUT_ADDRESS reloads\n+\t       for identical operand number conflict with each other, so\n+\t       assign them the same time value.  */\n+\t    case RELOAD_FOR_OUTPUT:\n+\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n+\t      time2 = MAX_RECOG_OPERANDS * 4 + reload_opnum[i];\n+\t      break;\n+\t    default:\n+\t      time2 = 0;\n+\t    }\n+\t  if (time1 >= time2)\n+\t    return 0;\n+\t}\n+    }\n+  return 1;\n+}\n+\n /* Find a spill register to use as a reload register for reload R.\n    LAST_RELOAD is non-zero if this is the last reload for the insn being\n    processed.\n@@ -5051,8 +5146,16 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \n \t  i = (i + 1) % n_spills;\n \n-\t  if (reload_reg_free_p (spill_regs[i], reload_opnum[r],\n-\t\t\t\t reload_when_needed[r])\n+\t  if ((reload_reg_free_p (spill_regs[i], reload_opnum[r],\n+\t\t\t\t  reload_when_needed[r])\n+\t       || (reload_in[r] && ! reload_out[r]\n+\t\t      /* We check reload_reg_used to make sure we\n+\t\t\t don't clobber the return register.  */\n+\t\t   && ! TEST_HARD_REG_BIT (reload_reg_used, spill_regs[i])\n+\t\t   && reload_reg_free_for_value_p (spill_regs[i],\n+\t\t\t\t\t\t  reload_opnum[r],\n+\t\t\t\t\t\t  reload_when_needed[r],\n+\t\t\t\t\t\t  reload_in[r])))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], spill_regs[i])\n \t      && HARD_REGNO_MODE_OK (spill_regs[i], reload_mode[r])\n \t      /* Look first for regs to share, then for unshared.  But\n@@ -5513,10 +5616,13 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t      && (reload_nregs[r] == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n-\t\t      && reload_reg_free_p (i, reload_opnum[r],\n-\t\t\t\t\t    reload_when_needed[r])\n-\t\t      && reload_reg_free_before_p (i, reload_opnum[r],\n-\t\t\t\t\t\t   reload_when_needed[r]))\n+\t\t      && ((reload_reg_free_p (i, reload_opnum[r],\n+\t\t\t\t\t      reload_when_needed[r])\n+\t\t\t   && reload_reg_free_before_p (i, reload_opnum[r],\n+\t\t\t\t\t\t\treload_when_needed[r]))\n+\t\t\t  || reload_reg_free_for_value_p (i, reload_opnum[r],\n+\t\t\t\t\t\t\t  reload_when_needed[r],\n+\t\t\t\t\t\t\t  reload_in[r])))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n@@ -5618,8 +5724,12 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t and of the desired class.  */\n \t      if (equiv != 0\n \t\t  && ((spill_reg_order[regno] >= 0\n-\t\t       && ! reload_reg_free_before_p (regno, reload_opnum[r],\n-\t\t\t\t\t\t      reload_when_needed[r]))\n+\t\t       && ! (reload_reg_free_before_p (regno, reload_opnum[r],\n+\t\t\t\t\t\t       reload_when_needed[r])\n+\t\t\t     || reload_reg_free_for_value_p (regno,\n+\t\t\t\t\t\t\t     reload_opnum[r],\n+\t\t\t\t\t\t\t     reload_when_needed[r],\n+\t\t\t\t\t\t\t     reload_in[r])))\n \t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n@@ -5796,9 +5906,13 @@ choose_reload_regs (insn, avoid_return_reg)\n       register int r = reload_order[j];\n \n       if (reload_inherited[r] && reload_reg_rtx[r] != 0\n-\t  && ! reload_reg_free_before_p (true_regnum (reload_reg_rtx[r]),\n-\t\t\t\t\t reload_opnum[r],\n-\t\t\t\t\t reload_when_needed[r]))\n+\t  && ! (reload_reg_free_before_p (true_regnum (reload_reg_rtx[r]),\n+\t\t\t\t\t  reload_opnum[r],\n+\t\t\t\t\t  reload_when_needed[r])\n+\t\t|| reload_reg_free_for_value_p (true_regnum (reload_reg_rtx[r]),\n+\t\t\t\t\t\treload_opnum[r],\n+\t\t\t\t\t\treload_when_needed[r],\n+\t\t\t\t\t\treload_in[r])))\n \treload_inherited[r] = 0;\n       /* If we can inherit a RELOAD_FOR_INPUT, then we do not need its related\n \t RELOAD_FOR_INPUT_ADDRESS / RELOAD_FOR_INPADDR_ADDRESS reloads."}]}