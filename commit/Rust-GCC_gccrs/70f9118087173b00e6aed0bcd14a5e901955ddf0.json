{"sha": "70f9118087173b00e6aed0bcd14a5e901955ddf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBmOTExODA4NzE3M2IwMGU2YWVkMGJjZDE0YTVlOTAxOTU1ZGRmMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-04-08T06:50:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:50:21Z"}, "message": "s-rident.ads: Add No_Default_Initialization restriction\n\n2008-04-08  Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* s-rident.ads: Add No_Default_Initialization restriction\n\n\t* exp_tss.adb: \n\t(Has_Non_Null_Base_Init_Proc): Handle No_Default_Initialization case\n\t(Set_TSS): Handle No_Default_Initialization case\n\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): Handle restriction\n\tNo_Default_Initialization\n\t(Expand_N_Subprogram_Body): Remove redundant initialization of out\n\tparameters when Normalize_Scalars is active.\n\t(Add_Final_List_Actual_To_Build_In_Place_Call): Add formal Sel_Comp\n\tFix casing error in formal parameter name in call\n\t(Register_Predefined_DT_Entry): Replace occurrences of RE_Address by\n\t(Expand_Call, Propagate_Tag): Call Kill_Current_Values when processing a\n\tdispatching call on VM targets.\n\nFrom-SVN: r134028", "tree": {"sha": "e4dc71d176952be31d0565bf2722e563d06d5207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4dc71d176952be31d0565bf2722e563d06d5207"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70f9118087173b00e6aed0bcd14a5e901955ddf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f9118087173b00e6aed0bcd14a5e901955ddf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f9118087173b00e6aed0bcd14a5e901955ddf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f9118087173b00e6aed0bcd14a5e901955ddf0/comments", "author": null, "committer": null, "parents": [{"sha": "45fc7ddb495d04c3170109f9717e927d73f18e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45fc7ddb495d04c3170109f9717e927d73f18e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45fc7ddb495d04c3170109f9717e927d73f18e2b"}], "stats": {"total": 307, "additions": 142, "deletions": 165}, "files": [{"sha": "a8470b6f2c5a796ee0f6bf8d3a84b0277cf3a448", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 74, "deletions": 120, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f9118087173b00e6aed0bcd14a5e901955ddf0/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f9118087173b00e6aed0bcd14a5e901955ddf0/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=70f9118087173b00e6aed0bcd14a5e901955ddf0", "patch": "@@ -1,4 +1,4 @@\n-------------------------------------------------------------------------------\n+-----------------------------------------------------------------------------\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n@@ -110,13 +110,16 @@ package body Exp_Ch6 is\n    procedure Add_Final_List_Actual_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n-      Acc_Type      : Entity_Id);\n+      Acc_Type      : Entity_Id;\n+      Sel_Comp      : Node_Id := Empty);\n    --  Ada 2005 (AI-318-02): For a build-in-place call, if the result type has\n    --  controlled parts, add an actual parameter that is a pointer to\n    --  appropriate finalization list. The finalization list is that of the\n    --  current scope, except for \"new Acc'(F(...))\" in which case it's the\n    --  finalization list of the access type returned by the allocator. Acc_Type\n-   --  is that type in the allocator case; Empty otherwise.\n+   --  is that type in the allocator case; Empty otherwise. If Sel_Comp is\n+   --  not Empty, then it denotes a selected component and the finalization\n+   --  list is obtained from the _controller list of the prefix object.\n \n    procedure Add_Task_Actuals_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n@@ -379,12 +382,16 @@ package body Exp_Ch6 is\n    procedure Add_Final_List_Actual_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n-      Acc_Type      : Entity_Id)\n+      Acc_Type      : Entity_Id;\n+      Sel_Comp      : Node_Id := Empty)\n    is\n       Loc               : constant Source_Ptr := Sloc (Function_Call);\n       Final_List        : Node_Id;\n       Final_List_Actual : Node_Id;\n       Final_List_Formal : Node_Id;\n+      Is_Ctrl_Result    : constant Boolean :=\n+                            Controlled_Type\n+                              (Underlying_Type (Etype (Function_Id)));\n \n    begin\n       --  No such extra parameter is needed if there are no controlled parts.\n@@ -395,7 +402,7 @@ package body Exp_Ch6 is\n       --  must be treated the same as a call to class-wide functions. Both of\n       --  these situations require that a finalization list be passed.\n \n-      if not Controlled_Type (Underlying_Type (Etype (Function_Id)))\n+      if not Is_Ctrl_Result\n         and then not Is_Tagged_Type (Underlying_Type (Etype (Function_Id)))\n       then\n          return;\n@@ -416,6 +423,14 @@ package body Exp_Ch6 is\n                      Present (Associated_Final_Chain (Base_Type (Acc_Type))))\n       then\n          Final_List := Find_Final_List (Acc_Type);\n+\n+      --  If Sel_Comp is present and the function result is controlled, then\n+      --  the finalization list will be obtained from the _controller list of\n+      --  the selected component's prefix object.\n+\n+      elsif Present (Sel_Comp) and then Is_Ctrl_Result then\n+         Final_List := Find_Final_List (Current_Scope, Sel_Comp);\n+\n       else\n          Final_List := Find_Final_List (Current_Scope);\n       end if;\n@@ -1016,7 +1031,7 @@ package body Exp_Ch6 is\n                            Low_Bound  =>\n                              Make_Attribute_Reference (Loc,\n                                Prefix => New_Occurrence_Of (Var, Loc),\n-                               Attribute_name => Name_First),\n+                               Attribute_Name => Name_First),\n                            High_Bound =>\n                              Make_Attribute_Reference (Loc,\n                                Prefix => New_Occurrence_Of (Var, Loc),\n@@ -1541,8 +1556,7 @@ package body Exp_Ch6 is\n             --  formal subtype are not the same, requiring a check.\n \n             --  It is necessary to exclude tagged types because of \"downward\n-            --  conversion\" errors and a strange assertion error in namet\n-            --  from gnatf in bug 1215-001 ???\n+            --  conversion\" errors.\n \n             elsif Is_Access_Type (E_Formal)\n               and then not Same_Type (E_Formal, Etype (Actual))\n@@ -1662,9 +1676,9 @@ package body Exp_Ch6 is\n \n    --  This procedure handles expansion of function calls and procedure call\n    --  statements (i.e. it serves as the body for Expand_N_Function_Call and\n-   --  Expand_N_Procedure_Call_Statement. Processing for calls includes:\n+   --  Expand_N_Procedure_Call_Statement). Processing for calls includes:\n \n-   --    Replace call to Raise_Exception by Raise_Exception always if possible\n+   --    Replace call to Raise_Exception by Raise_Exception_Always if possible\n    --    Provide values of actuals for all formals in Extra_Formals list\n    --    Replace \"call\" to enumeration literal function by literal itself\n    --    Rewrite call to predefined operator as operator\n@@ -1694,12 +1708,12 @@ package body Exp_Ch6 is\n \n       function Inherited_From_Formal (S : Entity_Id) return Entity_Id;\n       --  Within an instance, a type derived from a non-tagged formal derived\n-      --  type inherits from the original parent, not from the actual. This is\n-      --  tested in 4723-003. The current derivation mechanism has the derived\n-      --  type inherit from the actual, which is only correct outside of the\n-      --  instance. If the subprogram is inherited, we test for this particular\n-      --  case through a convoluted tree traversal before setting the proper\n-      --  subprogram to be called.\n+      --  type inherits from the original parent, not from the actual. The\n+      --  current derivation mechanism has the derived type inherit from the\n+      --  actual, which is only correct outside of the instance. If the\n+      --  subprogram is inherited, we test for this particular case through a\n+      --  convoluted tree traversal before setting the proper subprogram to be\n+      --  called.\n \n       --------------------------\n       -- Add_Actual_Parameter --\n@@ -1919,11 +1933,11 @@ package body Exp_Ch6 is\n \n          --  Replace call to Raise_Exception by call to Raise_Exception_Always\n          --  if we can tell that the first parameter cannot possibly be null.\n-         --  This helps optimization and also generation of warnings.\n+         --  This improves efficiency by avoiding a run-time test.\n \n          --  We do not do this if Raise_Exception_Always does not exist, which\n          --  can happen in configurable run time profiles which provide only a\n-         --  Raise_Exception, which is in fact an unconditional raise anyway.\n+         --  Raise_Exception.\n \n          if Is_RTE (Subp, RE_Raise_Exception)\n            and then RTE_Available (RE_Raise_Exception_Always)\n@@ -2547,21 +2561,31 @@ package body Exp_Ch6 is\n \n       if Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement)\n         and then Present (Controlling_Argument (N))\n-        and then VM_Target = No_VM\n       then\n-         Expand_Dispatching_Call (N);\n+         if VM_Target = No_VM then\n+            Expand_Dispatching_Call (N);\n \n-         --  The following return is worrisome. Is it really OK to\n-         --  skip all remaining processing in this procedure ???\n+            --  The following return is worrisome. Is it really OK to\n+            --  skip all remaining processing in this procedure ???\n \n-         return;\n+            return;\n+\n+         --  Expansion of a dispatching call results in an indirect call, which\n+         --  in turn causes current values to be killed (see Resolve_Call), so\n+         --  on VM targets we do the call here to ensure consistent warnings\n+         --  between VM and non-VM targets.\n+\n+         else\n+            Kill_Current_Values;\n+         end if;\n+      end if;\n \n       --  Similarly, expand calls to RCI subprograms on which pragma\n       --  All_Calls_Remote applies. The rewriting will be reanalyzed\n       --  later. Do this only when the call comes from source since we do\n       --  not want such a rewriting to occur in expanded code.\n \n-      elsif Is_All_Remote_Call (N) then\n+      if Is_All_Remote_Call (N) then\n          Expand_All_Calls_Remote_Subprogram_Call (N);\n \n       --  Similarly, do not add extra actuals for an entry call whose entity\n@@ -3110,34 +3134,6 @@ package body Exp_Ch6 is\n             end if;\n          end;\n       end if;\n-\n-      --  Special processing for Ada 2005 AI-329, which requires a call to\n-      --  Raise_Exception to raise Constraint_Error if the Exception_Id is\n-      --  null. Note that we never need to do this in GNAT mode, or if the\n-      --  parameter to Raise_Exception is a use of Identity, since in these\n-      --  cases we know that the parameter is never null.\n-\n-      --  Note: We must check that the node has not been inlined. This is\n-      --  required because under zfp the Raise_Exception subprogram has the\n-      --  pragma inline_always (and hence the call has been expanded above\n-      --  into a block containing the code of the subprogram).\n-\n-      if Ada_Version >= Ada_05\n-        and then not GNAT_Mode\n-        and then Is_RTE (Subp, RE_Raise_Exception)\n-        and then Nkind (N) = N_Procedure_Call_Statement\n-        and then (Nkind (First_Actual (N)) /= N_Attribute_Reference\n-                   or else Attribute_Name (First_Actual (N)) /= Name_Identity)\n-      then\n-         declare\n-            RCE : constant Node_Id :=\n-                    Make_Raise_Constraint_Error (Loc,\n-                      Reason => CE_Null_Exception_Id);\n-         begin\n-            Insert_After (N, RCE);\n-            Analyze (RCE);\n-         end;\n-      end if;\n    end Expand_Call;\n \n    --------------------------\n@@ -3978,12 +3974,9 @@ package body Exp_Ch6 is\n       Loc      : constant Source_Ptr := Sloc (N);\n       H        : constant Node_Id    := Handled_Statement_Sequence (N);\n       Body_Id  : Entity_Id;\n-      Spec_Id  : Entity_Id;\n       Except_H : Node_Id;\n-      Scop     : Entity_Id;\n-      Dec      : Node_Id;\n-      Next_Op  : Node_Id;\n       L        : List_Id;\n+      Spec_Id  : Entity_Id;\n \n       procedure Add_Return (S : List_Id);\n       --  Append a return statement to the statement sequence S if the last\n@@ -4165,14 +4158,16 @@ package body Exp_Ch6 is\n                if Is_Scalar_Type (Etype (F))\n                  and then Ekind (F) = E_Out_Parameter\n                then\n+                  Check_Restriction (No_Default_Initialization, F);\n+\n                   --  Insert the initialization. We turn off validity checks\n                   --  for this assignment, since we do not want any check on\n                   --  the initial value itself (which may well be invalid).\n \n                   Insert_Before_And_Analyze (First (L),\n                     Make_Assignment_Statement (Loc,\n                       Name       => New_Occurrence_Of (F, Loc),\n-                      Expression => Get_Simple_Init_Val (Etype (F), Loc)),\n+                      Expression => Get_Simple_Init_Val (Etype (F), N)),\n                     Suppress => Validity_Check);\n                end if;\n \n@@ -4181,34 +4176,6 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n-      Scop := Scope (Spec_Id);\n-\n-      --  Add discriminal renamings to protected subprograms. Install new\n-      --  discriminals for expansion of the next subprogram of this protected\n-      --  type, if any.\n-\n-      if Is_List_Member (N)\n-        and then Present (Parent (List_Containing (N)))\n-        and then Nkind (Parent (List_Containing (N))) = N_Protected_Body\n-      then\n-         Add_Discriminal_Declarations\n-           (Declarations (N), Scop, Name_uObject, Loc);\n-         Add_Private_Declarations\n-           (Declarations (N), Scop, Name_uObject, Loc);\n-\n-         --  Associate privals and discriminals with the next protected\n-         --  operation body to be expanded. These are used to expand references\n-         --  to private data objects and discriminants, respectively.\n-\n-         Next_Op := Next_Protected_Operation (N);\n-\n-         if Present (Next_Op) then\n-            Dec := Parent (Base_Type (Scop));\n-            Set_Privals (Dec, Next_Op, Loc);\n-            Set_Discriminals (Dec);\n-         end if;\n-      end if;\n-\n       --  Clear out statement list for stubbed procedure\n \n       if Present (Corresponding_Spec (N)) then\n@@ -4226,6 +4193,16 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n+      --  Create a set of discriminals for the next protected subprogram body\n+\n+      if Is_List_Member (N)\n+        and then Present (Parent (List_Containing (N)))\n+        and then Nkind (Parent (List_Containing (N))) = N_Protected_Body\n+        and then Present (Next_Protected_Operation (N))\n+      then\n+         Set_Discriminals (Parent (Base_Type (Scope (Spec_Id))));\n+      end if;\n+\n       --  Returns_By_Ref flag is normally set when the subprogram is frozen\n       --  but subprograms with no specs are not frozen.\n \n@@ -4324,37 +4301,6 @@ package body Exp_Ch6 is\n          Detect_Infinite_Recursion (N, Spec_Id);\n       end if;\n \n-      --  Finally, if we are in Normalize_Scalars mode, then any scalar out\n-      --  parameters must be initialized to the appropriate default value.\n-\n-      if Ekind (Spec_Id) = E_Procedure and then Normalize_Scalars then\n-         declare\n-            Floc   : Source_Ptr;\n-            Formal : Entity_Id;\n-            Stm    : Node_Id;\n-\n-         begin\n-            Formal := First_Formal (Spec_Id);\n-            while Present (Formal) loop\n-               Floc := Sloc (Formal);\n-\n-               if Ekind (Formal) = E_Out_Parameter\n-                 and then Is_Scalar_Type (Etype (Formal))\n-               then\n-                  Stm :=\n-                    Make_Assignment_Statement (Floc,\n-                      Name => New_Occurrence_Of (Formal, Floc),\n-                      Expression =>\n-                        Get_Simple_Init_Val (Etype (Formal), Floc));\n-                  Prepend (Stm, Declarations (N));\n-                  Analyze (Stm);\n-               end if;\n-\n-               Next_Formal (Formal);\n-            end loop;\n-         end;\n-      end if;\n-\n       --  Set to encode entity names in package body before gigi is called\n \n       Qualify_Entity_Names (N);\n@@ -4780,7 +4726,7 @@ package body Exp_Ch6 is\n                      New_Reference_To (Node (Next_Elmt (Iface_DT_Ptr)), Loc),\n                    Position => DT_Position (Prim),\n                    Address_Node =>\n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Reference_To (Thunk_Id, Loc),\n                          Attribute_Name => Name_Unrestricted_Access))),\n@@ -4792,7 +4738,7 @@ package body Exp_Ch6 is\n                        Loc),\n                    Position => DT_Position (Prim),\n                    Address_Node =>\n-                     Unchecked_Convert_To (RTE (RE_Address),\n+                     Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Reference_To (Prim, Loc),\n                          Attribute_Name => Name_Unrestricted_Access)))));\n@@ -5250,8 +5196,16 @@ package body Exp_Ch6 is\n       Add_Alloc_Form_Actual_To_Build_In_Place_Call\n         (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-      Add_Final_List_Actual_To_Build_In_Place_Call\n-        (Func_Call, Function_Id, Acc_Type => Empty);\n+      --  If Lhs is a selected component, then pass it along so that its prefix\n+      --  object will be used as the source of the finalization list.\n+\n+      if Nkind (Lhs) = N_Selected_Component then\n+         Add_Final_List_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Acc_Type => Empty, Sel_Comp => Lhs);\n+      else\n+         Add_Final_List_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Acc_Type => Empty);\n+      end if;\n \n       Add_Task_Actuals_To_Build_In_Place_Call\n         (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));"}, {"sha": "f9b9e33374eda905154004de4b7f9d73ea60fd6c", "filename": "gcc/ada/exp_tss.adb", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f9118087173b00e6aed0bcd14a5e901955ddf0/gcc%2Fada%2Fexp_tss.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f9118087173b00e6aed0bcd14a5e901955ddf0/gcc%2Fada%2Fexp_tss.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_tss.adb?ref=70f9118087173b00e6aed0bcd14a5e901955ddf0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -28,6 +28,8 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Lib;      use Lib;\n+with Restrict; use Restrict;\n+with Rident;   use Rident;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n \n@@ -159,11 +161,16 @@ package body Exp_Tss is\n    -- Has_Non_Null_Base_Init_Proc --\n    ---------------------------------\n \n+   --  Note: if a base Init_Proc is present, and No_Default_Initialization is\n+   --  present, then we must avoid testing for a null init proc, since there\n+   --  is no init proc present in this case.\n+\n    function Has_Non_Null_Base_Init_Proc (Typ : Entity_Id) return Boolean is\n       BIP : constant Entity_Id := Base_Init_Proc (Typ);\n-\n    begin\n-      return Present (BIP) and then not Is_Null_Init_Proc (BIP);\n+      return Present (BIP)\n+        and then (Restriction_Active (No_Default_Initialization)\n+                    or else not Is_Null_Init_Proc (BIP));\n    end Has_Non_Null_Base_Init_Proc;\n \n    ---------------\n@@ -306,20 +313,31 @@ package body Exp_Tss is\n    -------------\n \n    procedure Set_TSS (Typ : Entity_Id; TSS : Entity_Id) is\n-      Subprog_Body : constant Node_Id := Unit_Declaration_Node (TSS);\n-\n    begin\n-      --  Case of insertion location is in unit defining the type\n+      --  Make sure body of subprogram is frozen\n \n-      if In_Same_Code_Unit (Typ, TSS) then\n-         Append_Freeze_Action (Typ, Subprog_Body);\n+      --  Skip this for Init_Proc with No_Default_Initialization, since the\n+      --  Init proc is a dummy void entity in this case to be ignored.\n \n-      --  Otherwise, we are using an already existing TSS in another unit\n+      if Is_Init_Proc (TSS)\n+        and then Restriction_Active (No_Default_Initialization)\n+      then\n+         null;\n \n-      else\n+      --  Skip this if not in the same code unit (since it means we are using\n+      --  an already existing TSS in another unit)\n+\n+      elsif not In_Same_Code_Unit (Typ, TSS) then\n          null;\n+\n+      --  Otherwise make sure body is frozen\n+\n+      else\n+         Append_Freeze_Action (Typ, Unit_Declaration_Node (TSS));\n       end if;\n \n+      --  Set TSS entry\n+\n       Copy_TSS (TSS, Typ);\n    end Set_TSS;\n "}, {"sha": "68a5197266fae45f795bf82bab88557c87938fa6", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f9118087173b00e6aed0bcd14a5e901955ddf0/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f9118087173b00e6aed0bcd14a5e901955ddf0/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=70f9118087173b00e6aed0bcd14a5e901955ddf0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,7 +56,9 @@ package System.Rident is\n \n    type Restriction_Id is\n \n-      --  The following cases are checked for consistency in the binder\n+      --  The following cases are checked for consistency in the binder. The\n+      --  binder will check that every unit either has the restriction set, or\n+      --  does not violate the restriction.\n \n      (Simple_Barriers,                         -- GNAT (Ravenscar)\n       No_Abort_Statements,                     -- (RM D.7(5), H.4(3))\n@@ -111,7 +113,12 @@ package System.Rident is\n       Static_Priorities,                       -- GNAT\n       Static_Storage_Size,                     -- GNAT\n \n-      --  The following cases do not require partition-wide checks\n+      --  The following require consistency checking with special rules. See\n+      --  individual routines in unit Bcheck for details of what is required.\n+\n+      No_Default_Initialization,               -- GNAT\n+\n+      --  The following cases do not require consistency checking\n \n       Immediate_Reclamation,                   -- (RM H.4(10))\n       No_Implementation_Attributes,            -- Ada 2005 AI-257\n@@ -123,29 +130,28 @@ package System.Rident is\n \n       --  The following cases require a parameter value\n \n-      --  The following entries are fully checked at compile/bind time,\n-      --  which means that the compiler can in general tell the minimum\n-      --  value which could be used with a restrictions pragma. The binder\n-      --  can deduce the appropriate minimum value for the partition by\n-      --  taking the maximum value required by any unit.\n+      --  The following entries are fully checked at compile/bind time, which\n+      --  means that the compiler can in general tell the minimum value which\n+      --  could be used with a restrictions pragma. The binder can deduce the\n+      --  appropriate minimum value for the partition by taking the maximum\n+      --  value required by any unit.\n \n       Max_Protected_Entries,                   -- (RM D.7(14))\n       Max_Select_Alternatives,                 -- (RM D.7(12))\n       Max_Task_Entries,                        -- (RM D.7(13), H.4(3))\n \n-      --  The following entries are also fully checked at compile/bind\n-      --  time, and the compiler can also at least in some cases tell\n-      --  the minimum value which could be used with a restriction pragma.\n-      --  The difference is that the contributions are additive, so the\n-      --  binder deduces this value by adding the unit contributions.\n+      --  The following entries are also fully checked at compile/bind time,\n+      --  and the compiler can also at least in some cases tell the minimum\n+      --  value which could be used with a restriction pragma. The difference\n+      --  is that the contributions are additive, so the binder deduces this\n+      --  value by adding the unit contributions.\n \n       Max_Tasks,                               -- (RM D.7(19), H.4(3))\n \n-      --  The following entries are checked at compile time only for\n-      --  zero/nonzero entries. This means that the compiler can tell\n-      --  at compile time if a restriction value of zero is (would be)\n-      --  violated, but that is all. The compiler cannot distinguish\n-      --  between different non-zero values.\n+      --  The following entries are checked at compile time only for zero/\n+      --  nonzero entries. This means that the compiler can tell at compile\n+      --  time if a restriction value of zero is (would be) violated, but that\n+      --  the compiler cannot distinguish between different non-zero values.\n \n       Max_Asynchronous_Select_Nesting,         -- (RM D.7(18), H.4(3))\n       Max_Entry_Queue_Length,                  -- GNAT\n@@ -237,21 +243,20 @@ package System.Rident is\n    -- Restriction Status Declarations --\n    -------------------------------------\n \n-   --  The following declarations are used to record the current status\n-   --  or restrictions (for the current unit, or related units, at compile\n-   --  time, and for all units in a partition at bind time or run time).\n+   --  The following declarations are used to record the current status or\n+   --  restrictions (for the current unit, or related units, at compile time,\n+   --  and for all units in a partition at bind time or run time).\n \n    type Restriction_Flags  is array (All_Restrictions)           of Boolean;\n    type Restriction_Values is array (All_Parameter_Restrictions) of Natural;\n    type Parameter_Flags    is array (All_Parameter_Restrictions) of Boolean;\n \n    type Restrictions_Info is record\n       Set : Restriction_Flags;\n-      --  An entry is True in the Set array if a restrictions pragma has\n-      --  been encountered for the given restriction. If the value is\n-      --  True for a parameter restriction, then the corresponding entry\n-      --  in the Value array gives the minimum value encountered for any\n-      --  such restriction.\n+      --  An entry is True in the Set array if a restrictions pragma has been\n+      --  encountered for the given restriction. If the value is True for a\n+      --  parameter restriction, then the corresponding entry in the Value\n+      --  array gives the minimum value encountered for any such restriction.\n \n       Value : Restriction_Values;\n       --  If the entry for a parameter restriction in Set is True (i.e. a\n@@ -261,23 +266,23 @@ package System.Rident is\n       --  pragma specifying a value greater than Int'Last is simply ignored.\n \n       Violated : Restriction_Flags;\n-      --  An entry is True in the violations array if the compiler has\n-      --  detected a violation of the restriction. For a parameter\n-      --  restriction, the Count and Unknown arrays have additional\n-      --  information.\n+      --  An entry is True in the violations array if the compiler has detected\n+      --  a violation of the restriction. For a parameter restriction, the\n+      --  Count and Unknown arrays have additional information.\n \n       Count : Restriction_Values;\n-      --  If an entry for a parameter restriction is True in Violated,\n-      --  the corresponding entry in the Count array may record additional\n+      --  If an entry for a parameter restriction is True in Violated, the\n+      --  corresponding entry in the Count array may record additional\n       --  information. If the actual minimum count is known (by taking\n       --  maximums, or sums, depending on the restriction), it will be\n       --  recorded in this array. If not, then the value will remain zero.\n+      --  The value is also zero for a non-violated restriction.\n \n       Unknown : Parameter_Flags;\n-      --  If an entry for a parameter restriction is True in Violated,\n-      --  the corresponding entry in the Unknown array may record additional\n+      --  If an entry for a parameter restriction is True in Violated, the\n+      --  corresponding entry in the Unknown array may record additional\n       --  information. If the actual count is not known by the compiler (but\n-      --  is known to be non-zero), then the entry in Unknown will be True.\n+      --  is nown to be non-zero), then the entry in Unknown will be True.\n       --  This indicates that the value in Count is not known to be exact,\n       --  and the actual violation count may be higher.\n "}]}