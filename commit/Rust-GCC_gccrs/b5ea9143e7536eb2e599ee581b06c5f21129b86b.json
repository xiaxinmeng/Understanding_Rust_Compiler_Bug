{"sha": "b5ea9143e7536eb2e599ee581b06c5f21129b86b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlYTkxNDNlNzUzNmViMmU1OTllZTU4MWIwNmM1ZjIxMTI5Yjg2Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:56:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:56:17Z"}, "message": "[multiple changes]\n\n2011-08-03  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* inline.adb: Revert previous change.\n\n2011-08-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_cat.adb (Validate_RCI_Subprogram_Declaration): Reject a remote\n\tsubprogram with a limited formal that does not support external\n\tstreaming.\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* get_alfa.adb (Get_ALFA): add missing Skip_Spaces at start of\n\tcontinuation line\n\t* lib-xref-alfa.adb (Add_ALFA_File): split removal of scopes that are\n\tnot from current unit in two phases, because it is not possible to\n\tchange the table while iterating over its content.\n\t* put_alfa.adb (Put_ALFA): reset current file/scope at each new entity\n\n2011-08-03  Sergey Rybin  <rybin@adacore.com>\n\n\t* vms_data.ads: Add qualifier for gnatmetric --no-static-loop option\n\t* gnat_ugn.texi: Update description of complexity metrics (gnatmetric)\n\nFrom-SVN: r177255", "tree": {"sha": "e29cb543e455987bc4968bd9f8bc0c196a53d0f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e29cb543e455987bc4968bd9f8bc0c196a53d0f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ea9143e7536eb2e599ee581b06c5f21129b86b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ea9143e7536eb2e599ee581b06c5f21129b86b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ea9143e7536eb2e599ee581b06c5f21129b86b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ea9143e7536eb2e599ee581b06c5f21129b86b/comments", "author": null, "committer": null, "parents": [{"sha": "668a19bcfe171969271ab6a2702d42b83ca32f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/668a19bcfe171969271ab6a2702d42b83ca32f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/668a19bcfe171969271ab6a2702d42b83ca32f5b"}], "stats": {"total": 662, "additions": 351, "deletions": 311}, "files": [{"sha": "90df61211d48df86e94370f9978f873a5f9b5881", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -1,3 +1,23 @@\n+2011-08-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_cat.adb (Validate_RCI_Subprogram_Declaration): Reject a remote\n+\tsubprogram with a limited formal that does not support external\n+\tstreaming.\n+\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* get_alfa.adb (Get_ALFA): add missing Skip_Spaces at start of\n+\tcontinuation line\n+\t* lib-xref-alfa.adb (Add_ALFA_File): split removal of scopes that are\n+\tnot from current unit in two phases, because it is not possible to\n+\tchange the table while iterating over its content.\n+\t* put_alfa.adb (Put_ALFA): reset current file/scope at each new entity\n+\n+2011-08-03  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* vms_data.ads: Add qualifier for gnatmetric --no-static-loop option\n+\t* gnat_ugn.texi: Update description of complexity metrics (gnatmetric)\n+\n 2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Resolve_Op_Concat_Arg): if the argument is an aggregate\n@@ -22,7 +42,6 @@\n \tdiscriminants.\n \t* sem_type.adb (Disambiguate): an immediately visible operator hides a\n \tuser-defined function that is only use-visible.\n-\t* inline.adb: init procs are inlineable.\n \n 2011-08-03  Robert Dewar  <dewar@adacore.com>\n "}, {"sha": "94d5d9f4680b34831545ac7f141551bd64804326", "filename": "gcc/ada/get_alfa.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fget_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fget_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_alfa.adb?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -393,6 +393,7 @@ begin\n                         Skip_EOL;\n                         exit when Nextc /= '.';\n                         Skipc;\n+                        Skip_Spaces;\n                      end if;\n \n                      if Nextc = '.' then"}, {"sha": "862278cb679d80e0d66a119885869fb67c9e4265", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -14360,12 +14360,14 @@ McCabe cyclomatic complexity;\n McCabe essential complexity;\n \n @item\n-maximal loop nesting level\n+maximal loop nesting level;\n \n+@item\n+extra exit points (for subprograms);\n @end itemize\n \n @noindent\n-The McCabe complexity metrics are defined\n+The McCabe cyclomatic complexity metric is defined\n in @url{http://www.mccabe.com/pdf/mccabe-nist235r.pdf}\n \n According to McCabe, both control statements and short-circuit control forms\n@@ -14386,6 +14388,34 @@ cyclomatic complexity, which is the sum of these two values.\n @end itemize\n \n @noindent\n+\n+The origin of cyclomatic complexity metric is the need to estimate the number\n+of independent paths in the control flow graph that in turn gives the number\n+of tests needed to satisfy paths coverage testing completeness criterion.\n+Considered from the testing point of view, a static Ada @code{loop} (that is,\n+the @code{loop} statement having static subtype in loop parameter\n+specification) does not add to cyclomatic complexity. By providing\n+@option{^--no-static-loop^NO_STATIC_LOOP^} option a user\n+may specify that such loops should not be counted when computing the\n+cyclomatic complexity metric\n+\n+The Ada essential complexity metric is a McCabe cyclomatic complexity metric\n+counted for the code that is reduced by excluding all the pure structural Ada\n+control statements. An compound statement is considered as a non-structural\n+if it contains a @code{raise} or @code{return} statement as it subcomponent,\n+or if it contains a @code{goto} statement that transfers the control outside\n+the operator. A selective accept statement with @code{terminate} alternative\n+is considered as non-structural statement. When computing this metric,\n+@code{exit} statements are treated in the same way as @code{goto}\n+statements unless @option{^-ne^NO_EXITS_AS_GOTOS^} option is specified.\n+\n+The Ada essential complexity metric defined here is intended to quantify\n+the extent to which the software is unstructured. It is adapted from\n+the McCabe essential complexity metric defined in\n+http://www.mccabe.com/pdf/nist235r.pdf but is modified to be more\n+suitable for typical Ada usage. For example, short circuit forms\n+are not penalized as unstructured in the Ada essential complexity metric.\n+\n When computing cyclomatic and essential complexity, @command{gnatmetric} skips\n the code in the exception handlers and in all the nested program units.\n \n@@ -14439,6 +14469,10 @@ bodies, task bodies, entry bodies and statement sequences in package bodies\n Do not consider @code{exit} statements as @code{goto}s when\n computing Essential Complexity\n \n+@cindex @option{^--no-static-loop^/NO_STATIC_LOOP^} (@command{gnatmetric})\n+@item ^--no-static-loop^/NO_STATIC_LOOP^\n+Do not consider static loops when computing cyclomatic complexity\n+\n @item ^--extra-exit-points^/EXTRA_EXIT_POINTS^\n Report the extra exit points for subprogram bodies. As an exit point, this\n metric counts @code{return} statements and raise statements in case when the"}, {"sha": "d85e0866a48bda7796e3f4a9b47a8556d16d7900", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -349,12 +349,6 @@ package body Inline is\n                   Set_Is_Inlined (Pack);\n                   Inlined_Bodies.Increment_Last;\n                   Inlined_Bodies.Table (Inlined_Bodies.Last) := Pack;\n-\n-               --  an initialization procedure should be inlined, but it does\n-               --  not require the body of the package.\n-\n-               elsif Is_Init_Proc (E) then\n-                  Set_Is_Inlined (Pack);\n                end if;\n             end if;\n          end;"}, {"sha": "5e0edbc3e48dee66c9ee3267fcb16cfafa25380f", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -224,25 +224,47 @@ package body ALFA is\n \n       --  Update scope numbers\n \n-      for S in From .. ALFA_Scope_Table.Last loop\n-         declare\n-            E : Entity_Id renames ALFA_Scope_Table.Table (S).Scope_Entity;\n-         begin\n-            if Lib.Get_Source_Unit (E) = U then\n-               ALFA_Scope_Table.Table (S).Scope_Num := Int (S - From) + 1;\n-               ALFA_Scope_Table.Table (S).File_Num  := D;\n+      declare\n+         Count : Nat;\n \n-            else\n-               --  Remove scope S which is not located in unit U, for example\n-               --  for scope inside generics that get instantiated.\n+      begin\n+         Count := 1;\n+         for S in From .. ALFA_Scope_Table.Last loop\n+            declare\n+               E : Entity_Id renames ALFA_Scope_Table.Table (S).Scope_Entity;\n+            begin\n+               if Lib.Get_Source_Unit (E) = U then\n+                  ALFA_Scope_Table.Table (S).Scope_Num := Count;\n+                  ALFA_Scope_Table.Table (S).File_Num  := D;\n+                  Count                                := Count + 1;\n \n-               for J in S .. ALFA_Scope_Table.Last - 1 loop\n-                  ALFA_Scope_Table.Table (J) := ALFA_Scope_Table.Table (J + 1);\n-               end loop;\n-               ALFA_Scope_Table.Set_Last (ALFA_Scope_Table.Last - 1);\n+               else\n+                  --  Mark for removal a scope S which is not located in unit\n+                  --  U, for example for scope inside generics that get\n+                  --  instantiated.\n+\n+                  ALFA_Scope_Table.Table (S).Scope_Num := 0;\n+               end if;\n+            end;\n+         end loop;\n+      end;\n+\n+      declare\n+         Snew : Scope_Index;\n+\n+      begin\n+         Snew := From;\n+         for S in From .. ALFA_Scope_Table.Last loop\n+            --  Remove those scopes previously marked for removal\n+\n+            if ALFA_Scope_Table.Table (S).Scope_Num /= 0 then\n+               ALFA_Scope_Table.Table (Snew) := ALFA_Scope_Table.Table (S);\n+               Snew := Snew + 1;\n             end if;\n-         end;\n-      end loop;\n+         end loop;\n+\n+         ALFA_Scope_Table.Set_Last (Snew - 1);\n+      end;\n \n       --  Make entry for new file in file table\n "}, {"sha": "d8819200e21c152fddce8a9787c2b902992754a8", "filename": "gcc/ada/put_alfa.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fput_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fput_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_alfa.adb?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -141,8 +141,6 @@ begin\n                   Write_Info_Char (S.Scope_Name (N));\n                end loop;\n \n-               File        := F.File_Num;\n-               Scope       := S.Scope_Num;\n                Entity_Line := 0;\n                Entity_Col  := 0;\n \n@@ -175,6 +173,8 @@ begin\n \n                         Entity_Line := R.Entity_Line;\n                         Entity_Col  := R.Entity_Col;\n+                        File        := F.File_Num;\n+                        Scope       := S.Scope_Num;\n                      end if;\n \n                      if Write_Info_Col > 72 then"}, {"sha": "80f017b5938e704d4957193dc95ac993463ea47d", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 244, "deletions": 283, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Sem;      use Sem;\n+with Sem_Attr; use Sem_Attr;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n@@ -68,13 +69,21 @@ package body Sem_Cat is\n    --  that no component is declared with a nonstatic default value.\n    --  If a nonstatic default exists, report an error on Obj_Decl.\n \n-   --  Iterate through the component list of a record definition, check\n-   --  that no component is declared with a non-static default value.\n+   function Has_Read_Write_Attributes (E : Entity_Id) return Boolean;\n+   --  Return True if entity has attribute definition clauses for Read and\n+   --  Write attributes that are visible at some place.\n+\n+   function Is_Non_Remote_Access_Type (E : Entity_Id) return Boolean;\n+   --  Returns true if the entity is a type whose full view is a non-remote\n+   --  access type, for the purpose of enforcing E.2.2(8) rules.\n+\n+   function Has_Non_Remote_Access (Typ : Entity_Id) return Boolean;\n+   --  Return true if Typ or the type of any of its subcomponents is a non\n+   --  remote access type and doesn't have user-defined stream attributes.\n \n-   function Missing_Read_Write_Attributes (E : Entity_Id) return Boolean;\n-   --  Return True if the entity or one of its subcomponents is of an access\n-   --  type that does not have user-defined Read and Write attributes visible\n-   --  at any place.\n+   function No_External_Streaming (E : Entity_Id) return Boolean;\n+   --  Return True if the entity or one of its subcomponents does not support\n+   --  external streaming.\n \n    function In_RCI_Declaration (N : Node_Id) return Boolean;\n    --  Determines if a declaration is  within the visible part of a Remote\n@@ -85,10 +94,6 @@ package body Sem_Cat is\n    --  Determines if current scope is within the declaration of a Remote Types\n    --  unit, for semantic checking purposes.\n \n-   function Is_Non_Remote_Access_Type (E : Entity_Id) return Boolean;\n-   --  Returns true if the entity is a type whose full view is a non-remote\n-   --  access type, for the purpose of enforcing E.2.2(8) rules.\n-\n    function In_Shared_Passive_Unit return Boolean;\n    --  Determines if current scope is within a Shared Passive compilation unit\n \n@@ -104,6 +109,12 @@ package body Sem_Cat is\n    --  also constraints about the primitive subprograms of the class-wide type.\n    --  RM E.2 (9, 13, 14)\n \n+   procedure Validate_RACW_Primitive\n+     (Subp : Entity_Id;\n+      RACW : Entity_Id);\n+   --  Check legality of the declaration of primitive Subp of the designated\n+   --  type of the given RACW type.\n+\n    ---------------------------------------\n    -- Check_Categorization_Dependencies --\n    ---------------------------------------\n@@ -346,6 +357,62 @@ package body Sem_Cat is\n       end loop;\n    end Check_Non_Static_Default_Expr;\n \n+   ---------------------------\n+   -- Has_Non_Remote_Access --\n+   ---------------------------\n+\n+   function Has_Non_Remote_Access (Typ : Entity_Id) return Boolean is\n+      Component : Entity_Id;\n+      Comp_Type : Entity_Id;\n+      U_Typ     : constant Entity_Id := Underlying_Type (Typ);\n+   begin\n+      if No (U_Typ) then\n+         return False;\n+\n+      elsif Has_Read_Write_Attributes (Typ)\n+        or else Has_Read_Write_Attributes (U_Typ)\n+      then\n+         return False;\n+\n+      elsif Is_Non_Remote_Access_Type (U_Typ) then\n+         return True;\n+      end if;\n+\n+      if Is_Record_Type (U_Typ) then\n+         Component := First_Entity (U_Typ);\n+         while Present (Component) loop\n+            if not Is_Tag (Component) then\n+               Comp_Type := Etype (Component);\n+\n+               if Has_Non_Remote_Access (Comp_Type) then\n+                  return True;\n+               end if;\n+            end if;\n+\n+            Next_Entity (Component);\n+         end loop;\n+\n+      elsif Is_Array_Type (U_Typ) then\n+         return Has_Non_Remote_Access (Component_Type (U_Typ));\n+\n+      end if;\n+\n+      return False;\n+   end Has_Non_Remote_Access;\n+\n+   -------------------------------\n+   -- Has_Read_Write_Attributes --\n+   -------------------------------\n+\n+   function Has_Read_Write_Attributes (E : Entity_Id) return Boolean is\n+   begin\n+      return True\n+        and then Has_Stream_Attribute_Definition (E,\n+                   TSS_Stream_Read,  At_Any_Place => True)\n+        and then Has_Stream_Attribute_Definition (E,\n+                   TSS_Stream_Write, At_Any_Place => True);\n+   end Has_Read_Write_Attributes;\n+\n    -------------------------------------\n    -- Has_Stream_Attribute_Definition --\n    -------------------------------------\n@@ -555,64 +622,29 @@ package body Sem_Cat is\n         and then not Is_Remote_Access_To_Subprogram_Type (U_E);\n    end Is_Non_Remote_Access_Type;\n \n-   ----------------------------------\n-   -- Missing_Read_Write_Attribute --\n-   ----------------------------------\n-\n-   function Missing_Read_Write_Attributes (E : Entity_Id) return Boolean is\n-      Component      : Entity_Id;\n-      Component_Type : Entity_Id;\n-      U_E            : constant Entity_Id := Underlying_Type (E);\n-\n-      function Has_Read_Write_Attributes (E : Entity_Id) return Boolean;\n-      --  Return True if entity has attribute definition clauses for Read and\n-      --  Write attributes that are visible at some place.\n-\n-      -------------------------------\n-      -- Has_Read_Write_Attributes --\n-      -------------------------------\n-\n-      function Has_Read_Write_Attributes (E : Entity_Id) return Boolean is\n-      begin\n-         return True\n-           and then Has_Stream_Attribute_Definition (E,\n-                      TSS_Stream_Read,  At_Any_Place => True)\n-           and then Has_Stream_Attribute_Definition (E,\n-                      TSS_Stream_Write, At_Any_Place => True);\n-      end Has_Read_Write_Attributes;\n-\n-   --  Start of processing for Missing_Read_Write_Attributes\n+   ---------------------------\n+   -- No_External_Streaming --\n+   ---------------------------\n \n+   function No_External_Streaming (E : Entity_Id) return Boolean is\n+      U_E : constant Entity_Id := Underlying_Type (E);\n    begin\n       if No (U_E) then\n          return False;\n \n-      elsif Has_Read_Write_Attributes (E)\n-        or else Has_Read_Write_Attributes (U_E)\n-      then\n+      elsif Has_Read_Write_Attributes (E) then\n+         --  Note: availability of stream attributes is tested on E, not U_E.\n+         --  There may be stream attributes defined on U_E that are not visible\n+         --  at the place where support of external streaming is tested.\n+\n          return False;\n \n-      elsif Is_Non_Remote_Access_Type (U_E) then\n+      elsif Has_Non_Remote_Access (U_E) then\n          return True;\n       end if;\n \n-      if Is_Record_Type (U_E) then\n-         Component := First_Entity (U_E);\n-         while Present (Component) loop\n-            if not Is_Tag (Component) then\n-               Component_Type := Etype (Component);\n-\n-               if Missing_Read_Write_Attributes (Component_Type) then\n-                  return True;\n-               end if;\n-            end if;\n-\n-            Next_Entity (Component);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Missing_Read_Write_Attributes;\n+      return Is_Limited_Type (E);\n+   end No_External_Streaming;\n \n    -------------------------------------\n    -- Set_Categorization_From_Pragmas --\n@@ -1311,156 +1343,155 @@ package body Sem_Cat is\n \n    end Validate_Object_Declaration;\n \n-   ------------------------------\n-   -- Validate_RACW_Primitives --\n-   ------------------------------\n+   -----------------------------\n+   -- Validate_RACW_Primitive --\n+   -----------------------------\n \n-   procedure Validate_RACW_Primitives (T : Entity_Id) is\n-      Desig_Type             : Entity_Id;\n-      Primitive_Subprograms  : Elist_Id;\n-      Subprogram_Elmt        : Elmt_Id;\n-      Subprogram             : Entity_Id;\n-      Param_Spec             : Node_Id;\n-      Param                  : Entity_Id;\n-      Param_Type             : Entity_Id;\n-      Rtyp                   : Node_Id;\n+   procedure Validate_RACW_Primitive\n+     (Subp : Entity_Id;\n+      RACW : Entity_Id)\n+   is\n+      procedure Illegal_Remote_Subp (Msg : String; N : Node_Id);\n+      --  Diagnose illegality on N. If RACW is present, report the error on it\n+      --  rather than on N.\n \n-      procedure Illegal_RACW (Msg : String; N : Node_Id);\n-      --  Diagnose that T is illegal because of the given reason, associated\n-      --  with the location of node N.\n+      -------------------------\n+      -- Illegal_Remote_Subp --\n+      -------------------------\n \n-      Illegal_RACW_Message_Issued : Boolean := False;\n-      --  Set True once Illegal_RACW has been called\n+      procedure Illegal_Remote_Subp (Msg : String; N : Node_Id) is\n+      begin\n+         if Present (RACW) then\n+            if not Error_Posted (RACW) then\n+               Error_Msg_N\n+                 (\"illegal remote access to class-wide type&\", RACW);\n+            end if;\n \n-      ------------------\n-      -- Illegal_RACW --\n-      ------------------\n+            Error_Msg_Sloc := Sloc (N);\n+            Error_Msg_NE (\"\\\\\" & Msg & \" in primitive& #\", RACW, Subp);\n \n-      procedure Illegal_RACW (Msg : String; N : Node_Id) is\n-      begin\n-         if not Illegal_RACW_Message_Issued then\n-            Error_Msg_N\n-              (\"illegal remote access to class-wide type&\", T);\n-            Illegal_RACW_Message_Issued := True;\n+         else\n+            Error_Msg_NE (Msg & \" in remote subprogram&\", N, Subp);\n          end if;\n+      end Illegal_Remote_Subp;\n \n-         Error_Msg_Sloc := Sloc (N);\n-         Error_Msg_N (\"\\\\\" & Msg & \" in primitive#\", T);\n-      end Illegal_RACW;\n+      Rtyp       : Entity_Id;\n+      Param      : Node_Id;\n+      Param_Spec : Node_Id;\n+      Param_Type : Entity_Id;\n \n-   --  Start of processing for Validate_RACW_Primitives\n+   --  Start of processing for Validate_RACW_Primitive\n \n    begin\n-      Desig_Type := Etype (Designated_Type (T));\n+      --  Check return type\n \n-      --  No action needed for concurrent types\n+      if Ekind (Subp) = E_Function then\n+         Rtyp := Etype (Subp);\n \n-      if Is_Concurrent_Type (Desig_Type) then\n-         return;\n-      end if;\n-\n-      Primitive_Subprograms := Primitive_Operations (Desig_Type);\n+         if Has_Controlling_Result (Subp) then\n+            null;\n \n-      Subprogram_Elmt := First_Elmt (Primitive_Subprograms);\n-      while Subprogram_Elmt /= No_Elmt loop\n-         Subprogram := Node (Subprogram_Elmt);\n+         elsif Ekind (Rtyp) = E_Anonymous_Access_Type then\n+            Illegal_Remote_Subp (\"anonymous access result\", Rtyp);\n \n-         if Is_Predefined_Dispatching_Operation (Subprogram)\n-           or else Is_Hidden (Subprogram)\n-         then\n-            goto Next_Subprogram;\n+         elsif Is_Limited_Type (Rtyp) then\n+            if No (TSS (Rtyp, TSS_Stream_Read))\n+                 or else\n+               No (TSS (Rtyp, TSS_Stream_Write))\n+            then\n+               Illegal_Remote_Subp\n+                 (\"limited return type must have Read and Write attributes\",\n+                     Parent (Subp));\n+               Explain_Limited_Type (Rtyp, Parent (Subp));\n+\n+            --  Check that the return type supports external streaming.\n+            --  Note that the language of the standard (E.2.2(14)) does not\n+            --  explicitly mention that case, but it really does not make\n+            --  sense to return a value containing a local access type.\n+\n+            elsif No_External_Streaming (Rtyp)\n+                    and then not Error_Posted (Rtyp)\n+            then\n+               Illegal_Remote_Subp (\"return type containing non-remote access \"\n+                 & \"must have Read and Write attributes\",\n+                 Parent (Subp));\n+            end if;\n          end if;\n+      end if;\n \n-         --  Check return type\n+      Param := First_Formal (Subp);\n+      while Present (Param) loop\n \n-         if Ekind (Subprogram) = E_Function then\n-            Rtyp := Etype (Subprogram);\n+         --  Now find out if this parameter is a controlling parameter\n \n-            if Has_Controlling_Result (Subprogram) then\n-               null;\n+         Param_Spec := Parent (Param);\n+         Param_Type := Etype (Param);\n \n-            elsif Ekind (Rtyp) = E_Anonymous_Access_Type then\n-               Illegal_RACW (\"anonymous access result\", Rtyp);\n+         if Is_Controlling_Formal (Param) then\n \n-            elsif Is_Limited_Type (Rtyp) then\n-               if No (TSS (Rtyp, TSS_Stream_Read))\n-                    or else\n-                  No (TSS (Rtyp, TSS_Stream_Write))\n-               then\n-                  Illegal_RACW\n-                    (\"limited return type must have Read and Write attributes\",\n-                     Parent (Subprogram));\n-                  Explain_Limited_Type (Rtyp, Parent (Subprogram));\n-\n-               --  Check that the return type supports external streaming.\n-               --  Note that the language of the standard (E.2.2(14)) does not\n-               --  explicitly mention that case, but it really does not make\n-               --  sense to return a value containing a local access type.\n-\n-               elsif Missing_Read_Write_Attributes (Rtyp)\n-                       and then not Error_Posted (Rtyp)\n-               then\n-                  Illegal_RACW (\"return type containing non-remote access \"\n-                    & \"must have Read and Write attributes\",\n-                    Parent (Subprogram));\n-               end if;\n+            --  It is a controlling parameter, so specific checks below do not\n+            --  apply.\n \n-            end if;\n-         end if;\n+            null;\n \n-         Param := First_Formal (Subprogram);\n-         while Present (Param) loop\n+         elsif Ekind_In (Param_Type, E_Anonymous_Access_Type,\n+                                     E_Anonymous_Access_Subprogram_Type)\n+         then\n+            --  From RM E.2.2(14), no anonymous access parameter other than\n+            --  controlling ones may be used (because an anonymous access\n+            --  type never supports external streaming).\n \n-            --  Now find out if this parameter is a controlling parameter\n+            Illegal_Remote_Subp\n+              (\"non-controlling access parameter\", Param_Spec);\n \n-            Param_Spec := Parent (Param);\n-            Param_Type := Etype (Param);\n+         elsif No_External_Streaming (Param_Type)\n+            and then not Error_Posted (Param_Type)\n+         then\n+            Illegal_Remote_Subp (\"formal parameter in remote subprogram must \"\n+              & \"support external streaming\", Param_Spec);\n+         end if;\n \n-            if Is_Controlling_Formal (Param) then\n+         --  Check next parameter in this subprogram\n \n-               --  It is a controlling parameter, so specific checks below\n-               --  do not apply.\n+         Next_Formal (Param);\n+      end loop;\n+   end Validate_RACW_Primitive;\n \n-               null;\n+   ------------------------------\n+   -- Validate_RACW_Primitives --\n+   ------------------------------\n \n-            elsif Ekind_In (Param_Type, E_Anonymous_Access_Type,\n-                                        E_Anonymous_Access_Subprogram_Type)\n-            then\n-               --  From RM E.2.2(14), no anonymous access parameter other than\n-               --  controlling ones may be used (because an anonymous access\n-               --  type never supports external streaming).\n+   procedure Validate_RACW_Primitives (T : Entity_Id) is\n+      Desig_Type             : Entity_Id;\n+      Primitive_Subprograms  : Elist_Id;\n+      Subprogram_Elmt        : Elmt_Id;\n+      Subprogram             : Entity_Id;\n \n-               Illegal_RACW (\"non-controlling access parameter\", Param_Spec);\n+   begin\n+      Desig_Type := Etype (Designated_Type (T));\n \n-            elsif Is_Limited_Type (Param_Type) then\n+      --  No action needed for concurrent types\n \n-               --  Not a controlling parameter, so type must have Read and\n-               --  Write attributes.\n+      if Is_Concurrent_Type (Desig_Type) then\n+         return;\n+      end if;\n \n-               if No (TSS (Param_Type, TSS_Stream_Read))\n-                    or else\n-                  No (TSS (Param_Type, TSS_Stream_Write))\n-               then\n-                  Illegal_RACW\n-                    (\"limited formal must have Read and Write attributes\",\n-                     Param_Spec);\n-                  Explain_Limited_Type (Param_Type, Param_Spec);\n-               end if;\n+      Primitive_Subprograms := Primitive_Operations (Desig_Type);\n \n-            elsif Missing_Read_Write_Attributes (Param_Type)\n-               and then not Error_Posted (Param_Type)\n-            then\n-               Illegal_RACW (\"parameter containing non-remote access \"\n-                 & \"must have Read and Write attributes\", Param_Spec);\n-            end if;\n+      Subprogram_Elmt := First_Elmt (Primitive_Subprograms);\n+      while Subprogram_Elmt /= No_Elmt loop\n+         Subprogram := Node (Subprogram_Elmt);\n \n-            --  Check next parameter in this subprogram\n+         if Is_Predefined_Dispatching_Operation (Subprogram)\n+           or else Is_Hidden (Subprogram)\n+         then\n+            goto Next_Subprogram;\n+         end if;\n \n-            Next_Formal (Param);\n-         end loop;\n+         Validate_RACW_Primitive (Subp => Subprogram, RACW => T);\n \n-         <<Next_Subprogram>>\n-            Next_Elmt (Subprogram_Elmt);\n+      <<Next_Subprogram>>\n+         Next_Elmt (Subprogram_Elmt);\n       end loop;\n    end Validate_RACW_Primitives;\n \n@@ -1487,8 +1518,7 @@ package body Sem_Cat is\n                Error_Msg_N (\"generic declaration not allowed in rci unit\",\n                  Parent (E));\n \n-            elsif (Ekind (E) = E_Function\n-                    or else Ekind (E) = E_Procedure)\n+            elsif (Ekind (E) = E_Function or else Ekind (E) = E_Procedure)\n               and then Has_Pragma_Inline (E)\n             then\n                Error_Msg_N\n@@ -1527,9 +1557,6 @@ package body Sem_Cat is\n       Id              : Node_Id;\n       Param_Spec      : Node_Id;\n       Param_Type      : Entity_Id;\n-      Base_Param_Type : Entity_Id;\n-      Base_Under_Type : Entity_Id;\n-      Type_Decl       : Node_Id;\n       Error_Node      : Node_Id := N;\n \n    begin\n@@ -1545,6 +1572,7 @@ package body Sem_Cat is\n       end if;\n \n       if K = N_Subprogram_Declaration then\n+         Id := Defining_Unit_Name (Specification (N));\n          Profile := Parameter_Specifications (Specification (N));\n \n       else pragma Assert (K = N_Object_Declaration);\n@@ -1574,7 +1602,6 @@ package body Sem_Cat is\n          Param_Spec := First (Profile);\n          while Present (Param_Spec) loop\n             Param_Type := Etype (Defining_Identifier (Param_Spec));\n-            Type_Decl  := Parent (Param_Type);\n \n             if Ekind (Param_Type) = E_Anonymous_Access_Type then\n                if K = N_Subprogram_Declaration then\n@@ -1595,115 +1622,20 @@ package body Sem_Cat is\n             --  declaration and ignore full type declaration, unless this is\n             --  the only declaration for the type, e.g., as a limited record.\n \n-            elsif Is_Limited_Type (Param_Type)\n-              and then (Nkind (Type_Decl) = N_Private_Type_Declaration\n-                         or else\n-                        (Nkind (Type_Decl) = N_Full_Type_Declaration\n-                          and then not (Has_Private_Declaration (Param_Type))\n-                          and then Comes_From_Source (N)))\n-            then\n-               --  A limited parameter is legal only if user-specified Read and\n-               --  Write attributes exist for it. Second part of RM E.2.3 (14).\n-\n-               if No (Full_View (Param_Type))\n-                 and then Ekind (Param_Type) /= E_Record_Type\n-               then\n-                  --  Type does not have completion yet, so if declared in\n-                  --  the current RCI scope it is illegal, and will be flagged\n-                  --  subsequently.\n-\n-                  return;\n-               end if;\n-\n-               --  In Ada 95 the rules permit using a limited type that has\n-               --  user-specified Read and Write attributes that are specified\n-               --  in the private part of the package, whereas Ada 2005\n-               --  (AI-240) revises this to require the attributes to be\n-               --  \"available\" (implying that the attribute clauses must be\n-               --  visible to the RCI client). The Ada 95 rules violate the\n-               --  contract model for privacy, but we support both semantics\n-               --  for now for compatibility (note that ACATS test BXE2009\n-               --  checks a case that conforms to the Ada 95 rules but is\n-               --  illegal in Ada 2005). In the Ada 2005 case we check for the\n-               --  possibilities of visible TSS stream subprograms or explicit\n-               --  stream attribute definitions because the TSS subprograms\n-               --  can be hidden in the private part while the attribute\n-               --  definitions are still be available from the visible part.\n-\n-               Base_Param_Type := Base_Type (Param_Type);\n-               Base_Under_Type := Base_Type (Underlying_Type\n-                                              (Base_Param_Type));\n-\n-               if (Ada_Version < Ada_2005\n-                     and then\n-                       (No (TSS (Base_Param_Type, TSS_Stream_Read))\n-                          or else\n-                        No (TSS (Base_Param_Type, TSS_Stream_Write)))\n-                     and then\n-                       (No (TSS (Base_Under_Type, TSS_Stream_Read))\n-                          or else\n-                        No (TSS (Base_Under_Type, TSS_Stream_Write))))\n-                 or else\n-                   (Ada_Version >= Ada_2005\n-                      and then\n-                        (No (TSS (Base_Param_Type, TSS_Stream_Read))\n-                           or else\n-                         No (TSS (Base_Param_Type, TSS_Stream_Write))\n-                           or else\n-                         Is_Hidden (TSS (Base_Param_Type, TSS_Stream_Read))\n-                           or else\n-                         Is_Hidden (TSS (Base_Param_Type, TSS_Stream_Write)))\n-                      and then\n-                        (not Has_Stream_Attribute_Definition\n-                               (Base_Param_Type, TSS_Stream_Read)\n-                           or else\n-                         not Has_Stream_Attribute_Definition\n-                               (Base_Param_Type, TSS_Stream_Write)))\n-               then\n-                  if K = N_Subprogram_Declaration then\n-                     Error_Node := Param_Spec;\n-                  end if;\n-\n-                  if Ada_Version >= Ada_2005 then\n-                     Error_Msg_N\n-                       (\"limited parameter in 'R'C'I unit \"\n-                          & \"must have visible read/write attributes \",\n-                        Error_Node);\n-                  else\n-                     Error_Msg_N\n-                       (\"limited parameter in 'R'C'I unit \"\n-                          & \"must have read/write attributes \",\n-                        Error_Node);\n-                  end if;\n-                  Explain_Limited_Type (Param_Type, Error_Node);\n-               end if;\n-\n-            --  In Ada 95, any non-remote access type (or any type with a\n-            --  component of a non-remote access type) that is visible in an\n-            --  RCI unit comes from a Remote_Types or Remote_Call_Interface\n-            --  unit, and thus is already guaranteed to support external\n-            --  streaming. However in Ada 2005 we have to account for the case\n-            --  of named access types from declared pure units as well, which\n-            --  may or may not support external streaming, and so we need to\n-            --  perform a specific check for E.2.3(14/2) here.\n-\n-            --  Note that if the declaration of the type itself is illegal, we\n-            --  do not perform this check since it might be a cascaded error.\n-\n-            else\n+            elsif No_External_Streaming (Param_Type) then\n                if K = N_Subprogram_Declaration then\n                   Error_Node := Param_Spec;\n                end if;\n \n-               if Missing_Read_Write_Attributes (Param_Type)\n-                    and then not Error_Posted (Param_Type)\n-               then\n-                  Error_Msg_N\n-                    (\"parameter containing non-remote access in 'R'C'I \"\n-                     & \"subprogram must have visible \"\n-                     & \"Read and Write attributes\", Error_Node);\n+               Error_Msg_NE\n+                 (\"formal of remote subprogram& \"\n+                  & \"must support external streaming\",\n+                  Error_Node, Id);\n+               if Is_Limited_Type (Param_Type) then\n+                  Explain_Limited_Type (Param_Type, Error_Node);\n                end if;\n             end if;\n+\n             Next (Param_Spec);\n          end loop;\n \n@@ -2005,6 +1937,27 @@ package body Sem_Cat is\n       U_Typ          : Entity_Id;\n       First_Priv_Ent : constant Entity_Id := First_Private_Entity (Name_U);\n \n+      function Stream_Attributes_Available (Typ : Entity_Id) return Boolean;\n+      --  True if any stream attribute is available for Typ\n+\n+      ---------------------------------\n+      -- Stream_Attributes_Available --\n+      ---------------------------------\n+\n+      function Stream_Attributes_Available (Typ : Entity_Id) return Boolean\n+      is\n+      begin\n+         return Stream_Attribute_Available (Typ, TSS_Stream_Read)\n+                  or else\n+                Stream_Attribute_Available (Typ, TSS_Stream_Write)\n+                  or else\n+                Stream_Attribute_Available (Typ, TSS_Stream_Input)\n+                  or else\n+                Stream_Attribute_Available (Typ, TSS_Stream_Output);\n+      end Stream_Attributes_Available;\n+\n+   --  Start of processing for Validate_RT_RAT_Component\n+\n    begin\n       if not Is_Remote_Types (Name_U) then\n          return;\n@@ -2019,7 +1972,15 @@ package body Sem_Cat is\n          end if;\n \n          if Comes_From_Source (Typ) and then Is_Type (Typ) then\n-            if Missing_Read_Write_Attributes (Typ) then\n+\n+            --  Check that the type can be meaningfully transmitted to another\n+            --  partition (E.2.2(8)).\n+\n+            if (Ada_Version < Ada_2005 and then Has_Non_Remote_Access (U_Typ))\n+                 or else\n+               (Stream_Attributes_Available (Typ)\n+                  and then No_External_Streaming (U_Typ))\n+            then\n                if Is_Non_Remote_Access_Type (Typ) then\n                   Error_Msg_N (\"error in non-remote access type\", U_Typ);\n                else"}, {"sha": "75fd41485d31f1b1f95fed941df86bcae9ff1754", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ea9143e7536eb2e599ee581b06c5f21129b86b/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=b5ea9143e7536eb2e599ee581b06c5f21129b86b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -5456,6 +5456,14 @@ package VMS_Data is\n    --   Do not count EXIT statements as GOTOs when computing the Essential\n    --   Complexity.\n \n+   S_Metric_No_Static_Loop : aliased constant S := \"/NO_STATIC_LOOP \" &\n+                                                   \"--no-static-loop\";\n+   --        /STATIC_LOOP (D)\n+   --        /NO_STATIC_LOOP\n+   --\n+   --   Do not count static FOR loop statements when computing the Cyclomatic\n+   --   Complexity.\n+\n    S_Metric_Mess    : aliased constant S := \"/MESSAGES_PROJECT_FILE=\"      &\n                                              \"DEFAULT \"                    &\n                                                 \"-vP0 \"                    &\n@@ -5554,6 +5562,7 @@ package VMS_Data is\n                         S_Metric_Mess             'Access,\n                         S_Metric_No_Exits_As_Gotos'Access,\n                         S_Metric_No_Local         'Access,\n+                        S_Metric_No_Static_Loop   'Access,\n                         S_Metric_Project          'Access,\n                         S_Metric_Quiet            'Access,\n                         S_Metric_Suffix           'Access,"}]}