{"sha": "15e693cc593824fa56a2e52b756e1e2e4bad2a27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlNjkzY2M1OTM4MjRmYTU2YTJlNTJiNzU2ZTFlMmU0YmFkMmEyNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-21T14:09:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-21T14:09:15Z"}, "message": "re PR tree-optimization/59058 (wrong code at -O3 on x86_64-linux-gnu (affecting gcc 4.6 to trunk))\n\n2013-11-21  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/59058\n\t* tree-scalar-evolution.h (number_of_exit_cond_executions): Remove.\n\t* tree-scalar-evolution.c (number_of_exit_cond_executions): Likewise.\n\t* tree-vectorizer.h (LOOP_PEELING_FOR_ALIGNMENT): Rename to ...\n\t(LOOP_VINFO_PEELING_FOR_ALIGNMENT): ... this.\n\t(NITERS_KNOWN_P): Fold into ...\n\t(LOOP_VINFO_NITERS_KNOWN_P): ... this.\n\t(LOOP_VINFO_PEELING_FOR_NITER): Add.\n\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop):\n\tUse LOOP_VINFO_PEELING_FOR_ALIGNMENT.\n\t(vect_do_peeling_for_alignment): Re-use precomputed niter\n\tinstead of re-emitting it.\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n\tUse LOOP_VINFO_PEELING_FOR_ALIGNMENT.\n\t* tree-vect-loop.c (vect_get_loop_niters): Use\n\tnumber_of_latch_executions.\n\t(new_loop_vec_info): Initialize LOOP_VINFO_PEELING_FOR_NITER.\n\t(vect_analyze_loop_form): Simplify.\n\t(vect_analyze_loop_operations): Move epilogue peeling code ...\n\t(vect_analyze_loop_2): ... here and adjust it to compute\n\tLOOP_VINFO_PEELING_FOR_NITER.\n\t(vect_estimate_min_profitable_iters): Use\n\tLOOP_VINFO_PEELING_FOR_ALIGNMENT.\n\t(vect_build_loop_niters): Emit on the preheader.\n\t(vect_generate_tmps_on_preheader): Likewise.\n\t(vect_transform_loop): Use LOOP_VINFO_PEELING_FOR_NITER instead\n\tof recomputing it.  Adjust.\n\nFrom-SVN: r205217", "tree": {"sha": "0586a0be8d7ce253c92bf4eab57e92b0dd307936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0586a0be8d7ce253c92bf4eab57e92b0dd307936"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e693cc593824fa56a2e52b756e1e2e4bad2a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e693cc593824fa56a2e52b756e1e2e4bad2a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e693cc593824fa56a2e52b756e1e2e4bad2a27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e693cc593824fa56a2e52b756e1e2e4bad2a27/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b05e02332f86e3168b96708263a88ec8f07c5e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b05e02332f86e3168b96708263a88ec8f07c5e5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b05e02332f86e3168b96708263a88ec8f07c5e5a"}], "stats": {"total": 304, "additions": 152, "deletions": 152}, "files": [{"sha": "7472098bbe5f98755855bb3d22ed00346171feb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -1,3 +1,33 @@\n+2013-11-21  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/59058\n+\t* tree-scalar-evolution.h (number_of_exit_cond_executions): Remove.\n+\t* tree-scalar-evolution.c (number_of_exit_cond_executions): Likewise.\n+\t* tree-vectorizer.h (LOOP_PEELING_FOR_ALIGNMENT): Rename to ...\n+\t(LOOP_VINFO_PEELING_FOR_ALIGNMENT): ... this.\n+\t(NITERS_KNOWN_P): Fold into ...\n+\t(LOOP_VINFO_NITERS_KNOWN_P): ... this.\n+\t(LOOP_VINFO_PEELING_FOR_NITER): Add.\n+\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop):\n+\tUse LOOP_VINFO_PEELING_FOR_ALIGNMENT.\n+\t(vect_do_peeling_for_alignment): Re-use precomputed niter\n+\tinstead of re-emitting it.\n+\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n+\tUse LOOP_VINFO_PEELING_FOR_ALIGNMENT.\n+\t* tree-vect-loop.c (vect_get_loop_niters): Use\n+\tnumber_of_latch_executions.\n+\t(new_loop_vec_info): Initialize LOOP_VINFO_PEELING_FOR_NITER.\n+\t(vect_analyze_loop_form): Simplify.\n+\t(vect_analyze_loop_operations): Move epilogue peeling code ...\n+\t(vect_analyze_loop_2): ... here and adjust it to compute\n+\tLOOP_VINFO_PEELING_FOR_NITER.\n+\t(vect_estimate_min_profitable_iters): Use\n+\tLOOP_VINFO_PEELING_FOR_ALIGNMENT.\n+\t(vect_build_loop_niters): Emit on the preheader.\n+\t(vect_generate_tmps_on_preheader): Likewise.\n+\t(vect_transform_loop): Use LOOP_VINFO_PEELING_FOR_NITER instead\n+\tof recomputing it.  Adjust.\n+\n 2013-11-21  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vectorizer.h (LOC, UNKNOWN_LOC, EXPR_LOC, LOC_FILE,"}, {"sha": "de05f644b0ec6cb9f35bfd241213d357ffdc60a0", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -2910,34 +2910,6 @@ number_of_latch_executions (struct loop *loop)\n   loop->nb_iterations = res;\n   return res;\n }\n-\n-/* Returns the number of executions of the exit condition of LOOP,\n-   i.e., the number by one higher than number_of_latch_executions.\n-   Note that unlike number_of_latch_executions, this number does\n-   not necessarily fit in the unsigned variant of the type of\n-   the control variable -- if the number of iterations is a constant,\n-   we return chrec_dont_know if adding one to number_of_latch_executions\n-   overflows; however, in case the number of iterations is symbolic\n-   expression, the caller is responsible for dealing with this\n-   the possible overflow.  */\n-\n-tree\n-number_of_exit_cond_executions (struct loop *loop)\n-{\n-  tree ret = number_of_latch_executions (loop);\n-  tree type = chrec_type (ret);\n-\n-  if (chrec_contains_undetermined (ret))\n-    return ret;\n-\n-  ret = chrec_fold_plus (type, ret, build_int_cst (type, 1));\n-  if (TREE_CODE (ret) == INTEGER_CST\n-      && TREE_OVERFLOW (ret))\n-    return chrec_dont_know;\n-\n-  return ret;\n-}\n-\n \f\n \n /* Counters for the stats.  */"}, {"sha": "3a656911ac70da915356c8648dd43ec69ed43fb9", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -22,7 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SCALAR_EVOLUTION_H\n \n extern tree number_of_latch_executions (struct loop *);\n-extern tree number_of_exit_cond_executions (struct loop *);\n extern gimple get_loop_exit_condition (const struct loop *);\n \n extern void scev_initialize (void);"}, {"sha": "c1eb455ae8b9d9bfe173458565662ee0f7304811", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -1735,9 +1735,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n           LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n           if (npeel)\n-            LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = npeel;\n+            LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) = npeel;\n           else\n-            LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n+            LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+\t      = DR_MISALIGNMENT (dr0);\n \t  SET_DR_MISALIGNMENT (dr0, 0);\n \t  if (dump_enabled_p ())\n             {"}, {"sha": "289e852ef8de2b1d200049699460640519c2b378", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -1736,16 +1736,16 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n \n   pe = loop_preheader_edge (loop);\n \n-  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n+  if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n-      int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+      int npeel = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"known peeling = %d.\\n\", npeel);\n \n       iters = build_int_cst (niters_type, npeel);\n-      *bound = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+      *bound = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n     }\n   else\n     {\n@@ -1876,7 +1876,6 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree niters_of_prolog_loop;\n-  tree n_iters;\n   tree wide_prolog_niters;\n   struct loop *new_loop;\n   int max_iter;\n@@ -1918,9 +1917,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n                \"loop to %d\\n\", max_iter);\n \n   /* Update number of times loop executes.  */\n-  n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n   LOOP_VINFO_NITERS (loop_vinfo) = fold_build2 (MINUS_EXPR,\n-\t\tTREE_TYPE (n_iters), n_iters, niters_of_prolog_loop);\n+\t\tTREE_TYPE (ni_name), ni_name, niters_of_prolog_loop);\n \n   if (types_compatible_p (sizetype, TREE_TYPE (niters_of_prolog_loop)))\n     wide_prolog_niters = niters_of_prolog_loop;"}, {"sha": "02aa090b51a9614d7585821b026ff587d7415907", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 110, "deletions": 107, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -771,11 +771,12 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n     vect_analyze_scalar_cycles_1 (loop_vinfo, loop->inner);\n }\n \n+\n /* Function vect_get_loop_niters.\n \n-   Determine how many iterations the loop is executed.\n-   If an expression that represents the number of iterations\n-   can be constructed, place it in NUMBER_OF_ITERATIONS.\n+   Determine how many iterations the loop is executed and place it\n+   in NUMBER_OF_ITERATIONS.\n+\n    Return the loop exit condition.  */\n \n static gimple\n@@ -786,20 +787,16 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== get_loop_niters ===\\n\");\n-  niters = number_of_exit_cond_executions (loop);\n \n-  if (niters != NULL_TREE\n-      && niters != chrec_dont_know)\n-    {\n-      *number_of_iterations = niters;\n-\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location, \"==> get_loop_niters:\");\n-          dump_generic_expr (MSG_NOTE, TDF_SLIM, *number_of_iterations);\n-          dump_printf (MSG_NOTE, \"\\n\");\n-        }\n-    }\n+  niters = number_of_latch_executions (loop);\n+  /* We want the number of loop header executions which is the number\n+     of latch executions plus one.\n+     ???  For UINT_MAX latch executions this number overflows to zero\n+     for loops like do { n++; } while (n != 0);  */\n+  if (niters && !chrec_contains_undetermined (niters))\n+    niters = fold_build2 (PLUS_EXPR, TREE_TYPE (niters), niters,\n+\t\t\t  build_int_cst (TREE_TYPE (niters), 1));\n+  *number_of_iterations = niters;\n \n   return get_loop_exit_condition (loop);\n }\n@@ -907,7 +904,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_NITERS_UNCHANGED (res) = NULL;\n   LOOP_VINFO_COST_MODEL_MIN_ITERS (res) = 0;\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n-  LOOP_PEELING_FOR_ALIGNMENT (res) = 0;\n+  LOOP_VINFO_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n   LOOP_VINFO_LOOP_NEST (res).create (3);\n   LOOP_VINFO_DATAREFS (res).create (10);\n@@ -924,6 +921,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n   LOOP_VINFO_TARGET_COST_DATA (res) = init_cost (loop);\n   LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n+  LOOP_VINFO_PEELING_FOR_NITER (res) = false;\n   LOOP_VINFO_OPERANDS_SWAPPED (res) = false;\n \n   return res;\n@@ -1091,12 +1089,12 @@ vect_analyze_loop_form (struct loop *loop)\n         }\n \n       if (empty_block_p (loop->header))\n-    {\n-          if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: empty loop.\\n\");\n-      return NULL;\n-    }\n+\t  return NULL;\n+\t}\n     }\n   else\n     {\n@@ -1243,7 +1241,8 @@ vect_analyze_loop_form (struct loop *loop)\n       return NULL;\n     }\n \n-  if (!number_of_iterations)\n+  if (!number_of_iterations\n+      || chrec_contains_undetermined (number_of_iterations))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1254,17 +1253,21 @@ vect_analyze_loop_form (struct loop *loop)\n       return NULL;\n     }\n \n-  if (chrec_contains_undetermined (number_of_iterations))\n+  if (integer_zerop (number_of_iterations))\n     {\n       if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Infinite number of iterations.\\n\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: number of iterations = 0.\\n\");\n       if (inner_loop_vinfo)\n-\tdestroy_loop_vec_info (inner_loop_vinfo, true);\n+        destroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n     }\n \n-  if (!NITERS_KNOWN_P (number_of_iterations))\n+  loop_vinfo = new_loop_vec_info (loop);\n+  LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n+  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n       if (dump_enabled_p ())\n         {\n@@ -1274,19 +1277,6 @@ vect_analyze_loop_form (struct loop *loop)\n           dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n-  else if (TREE_INT_CST_LOW (number_of_iterations) == 0)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: number of iterations = 0.\\n\");\n-      if (inner_loop_vinfo)\n-        destroy_loop_vec_info (inner_loop_vinfo, true);\n-      return NULL;\n-    }\n-\n-  loop_vinfo = new_loop_vec_info (loop);\n-  LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n-  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n \n   STMT_VINFO_TYPE (vinfo_for_stmt (loop_cond)) = loop_exit_ctrl_vec_info_type;\n \n@@ -1588,23 +1578,6 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       return false;\n     }\n \n-  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n-      || ((int) tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n-\t  < exact_log2 (vectorization_factor)))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required\\n\");\n-      if (!vect_can_advance_ivs_p (loop_vinfo)\n-\t  || !slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: can't create required \"\n-\t\t\t     \"epilog loop\\n\");\n-          return false;\n-        }\n-    }\n-\n   return true;\n }\n \n@@ -1760,6 +1733,40 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* Decide whether we need to create an epilogue loop to handle\n+     remaining scalar iterations.  */\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n+    {\n+      if (ctz_hwi (LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t\t   - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+\t  < exact_log2 (LOOP_VINFO_VECT_FACTOR (loop_vinfo)))\n+\tLOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n+    }\n+  else if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo)\n+\t   || (tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n+\t       < (unsigned)exact_log2 (LOOP_VINFO_VECT_FACTOR (loop_vinfo))))\n+    LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = true;\n+\n+  /* If an epilogue loop is required make sure we can create one.  */\n+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n+      || LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo))\n+    {\n+      if (dump_enabled_p ())\n+        dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required\\n\");\n+      if (!vect_can_advance_ivs_p (loop_vinfo)\n+\t  || !slpeel_can_duplicate_loop_p (LOOP_VINFO_LOOP (loop_vinfo),\n+\t\t\t\t\t   single_exit (LOOP_VINFO_LOOP\n+\t\t\t\t\t\t\t (loop_vinfo))))\n+        {\n+          if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: can't create required \"\n+\t\t\t     \"epilog loop\\n\");\n+          return false;\n+        }\n+    }\n+\n   return true;\n }\n \n@@ -2689,7 +2696,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   int scalar_single_iter_cost = 0;\n   int scalar_outside_cost = 0;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+  int npeel = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n   /* Cost model disabled.  */\n@@ -2880,7 +2887,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       else\n \t{\n \t  /* Cost model check occurs at prologue generation.  */\n-\t  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n+\t  if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n \t    scalar_outside_cost += 2 * vect_get_stmt_cost (cond_branch_taken)\n \t      + vect_get_stmt_cost (cond_branch_not_taken); \n \t  /* Cost model check occurs at epilogue generation.  */\n@@ -5574,47 +5581,51 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple stmt)\n \n \n /* This function builds ni_name = number of iterations.  Statements\n-   are queued onto SEQ.  */\n+   are emitted on the loop preheader edge.  */\n \n static tree\n-vect_build_loop_niters (loop_vec_info loop_vinfo, gimple_seq *seq)\n+vect_build_loop_niters (loop_vec_info loop_vinfo)\n {\n-  tree ni_name, var;\n-  gimple_seq stmts = NULL;\n   tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n+  if (TREE_CODE (ni) == INTEGER_CST)\n+    return ni;\n+  else\n+    {\n+      tree ni_name, var;\n+      gimple_seq stmts = NULL;\n+      edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n \n-  var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n-  ni_name = force_gimple_operand (ni, &stmts, false, var);\n-\n-  if (stmts)\n-    gimple_seq_add_seq (seq, stmts);\n+      var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n+      ni_name = force_gimple_operand (ni, &stmts, false, var);\n+      if (stmts)\n+\tgsi_insert_seq_on_edge_immediate (pe, stmts);\n \n-  return ni_name;\n+      return ni_name;\n+    }\n }\n \n \n /* This function generates the following statements:\n \n- ni_name = number of iterations loop executes\n- ratio = ni_name / vf\n- ratio_mult_vf_name = ratio * vf\n+   ni_name = number of iterations loop executes\n+   ratio = ni_name / vf\n+   ratio_mult_vf_name = ratio * vf\n \n- and places them in COND_EXPR_STMT_LIST.  */\n+   and places them on the loop preheader edge.  */\n \n static void\n vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n \t\t\t\t tree ni_name,\n \t\t\t\t tree *ratio_mult_vf_name_ptr,\n-\t\t\t\t tree *ratio_name_ptr,\n-\t\t\t\t gimple_seq *cond_expr_stmt_list)\n+\t\t\t\t tree *ratio_name_ptr)\n {\n-  gimple_seq stmts;\n   tree ni_minus_gap_name;\n   tree var;\n   tree ratio_name;\n   tree ratio_mult_vf_name;\n   tree ni = LOOP_VINFO_NITERS (loop_vinfo);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n   tree log_vf;\n \n   log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n@@ -5630,11 +5641,10 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n       if (!is_gimple_val (ni_minus_gap_name))\n \t{\n \t  var = create_tmp_var (TREE_TYPE (ni), \"ni_gap\");\n-\n-          stmts = NULL;\n+          gimple stmts = NULL;\n           ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,\n \t\t\t\t\t\t    true, var);\n-\t  gimple_seq_add_seq (cond_expr_stmt_list, stmts);\n+\t  gsi_insert_seq_on_edge_immediate (pe, stmts);\n         }\n     }\n   else\n@@ -5647,10 +5657,9 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n   if (!is_gimple_val (ratio_name))\n     {\n       var = create_tmp_var (TREE_TYPE (ni), \"bnd\");\n-\n-      stmts = NULL;\n+      gimple stmts = NULL;\n       ratio_name = force_gimple_operand (ratio_name, &stmts, true, var);\n-      gimple_seq_add_seq (cond_expr_stmt_list, stmts);\n+      gsi_insert_seq_on_edge_immediate (pe, stmts);\n     }\n   *ratio_name_ptr = ratio_name;\n \n@@ -5663,11 +5672,10 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n       if (!is_gimple_val (ratio_mult_vf_name))\n \t{\n \t  var = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n-\n-\t  stmts = NULL;\n+\t  gimple stmts = NULL;\n \t  ratio_mult_vf_name = force_gimple_operand (ratio_mult_vf_name, &stmts,\n \t\t\t\t\t\t     true, var);\n-\t  gimple_seq_add_seq (cond_expr_stmt_list, stmts);\n+\t  gsi_insert_seq_on_edge_immediate (pe, stmts);\n \t}\n       *ratio_mult_vf_name_ptr = ratio_mult_vf_name;\n     }\n@@ -5739,20 +5747,20 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n       check_profitability = false;\n     }\n \n+  tree ni_name = vect_build_loop_niters (loop_vinfo);\n+  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = ni_name;\n+\n   /* Peel the loop if there are data refs with unknown alignment.\n-     Only one data ref with unknown store is allowed.\n-     This clobbers LOOP_VINFO_NITERS but retains the original\n-     in LOOP_VINFO_NITERS_UNCHANGED.  So we cannot avoid re-computing\n-     niters.  */\n+     Only one data ref with unknown store is allowed.  */\n \n-  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n+  if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n-      gimple_seq stmts = NULL;\n-      tree ni_name = vect_build_loop_niters (loop_vinfo, &stmts);\n-      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n       vect_do_peeling_for_alignment (loop_vinfo, ni_name,\n \t\t\t\t     th, check_profitability);\n       check_profitability = false;\n+      /* The above adjusts LOOP_VINFO_NITERS, so cause ni_name to\n+\t be re-computed.  */\n+      ni_name = NULL_TREE;\n     }\n \n   /* If the loop has a symbolic number of iterations 'n' (i.e. it's not a\n@@ -5763,16 +5771,14 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      will remain scalar and will compute the remaining (n%VF) iterations.\n      (VF is the vectorization factor).  */\n \n-  if ((int) tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n-      < exact_log2 (vectorization_factor)\n+  if (LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)\n       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n     {\n-      tree ni_name, ratio_mult_vf;\n-      gimple_seq stmts = NULL;\n-      ni_name = vect_build_loop_niters (loop_vinfo, &stmts);\n+      tree ratio_mult_vf;\n+      if (!ni_name)\n+\tni_name = vect_build_loop_niters (loop_vinfo);\n       vect_generate_tmps_on_preheader (loop_vinfo, ni_name, &ratio_mult_vf,\n-\t\t\t\t       &ratio, &stmts);\n-      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+\t\t\t\t       &ratio);\n       vect_do_peeling_for_loop_bound (loop_vinfo, ni_name, ratio_mult_vf,\n \t\t\t\t      th, check_profitability);\n     }\n@@ -5781,12 +5787,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);\n   else\n     {\n-      tree ni_name;\n-      gimple_seq stmts = NULL;\n-      ni_name = vect_build_loop_niters (loop_vinfo, &stmts);\n-      vect_generate_tmps_on_preheader (loop_vinfo, ni_name, NULL,\n-\t\t\t\t       &ratio, &stmts);\n-      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+      if (!ni_name)\n+\tni_name = vect_build_loop_niters (loop_vinfo);\n+      vect_generate_tmps_on_preheader (loop_vinfo, ni_name, NULL, &ratio);\n     }\n \n   /* 1) Make sure the loop header has exactly two entries"}, {"sha": "58884f8550262a58b306a0e48780afd3f8fbdb4a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e693cc593824fa56a2e52b756e1e2e4bad2a27/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=15e693cc593824fa56a2e52b756e1e2e4bad2a27", "patch": "@@ -361,7 +361,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_DATAREFS(L)             (L)->datarefs\n #define LOOP_VINFO_DDRS(L)                 (L)->ddrs\n #define LOOP_VINFO_INT_NITERS(L)           (TREE_INT_CST_LOW ((L)->num_iters))\n-#define LOOP_PEELING_FOR_ALIGNMENT(L)      (L)->peeling_for_alignment\n+#define LOOP_VINFO_PEELING_FOR_ALIGNMENT(L) (L)->peeling_for_alignment\n #define LOOP_VINFO_UNALIGNED_DR(L)         (L)->unaligned_dr\n #define LOOP_VINFO_MAY_MISALIGN_STMTS(L)   (L)->may_misalign_stmts\n #define LOOP_VINFO_MAY_ALIAS_DDRS(L)       (L)->may_alias_ddrs\n@@ -375,18 +375,15 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_TARGET_COST_DATA(L)     (L)->target_cost_data\n #define LOOP_VINFO_PEELING_FOR_GAPS(L)     (L)->peeling_for_gaps\n #define LOOP_VINFO_OPERANDS_SWAPPED(L)     (L)->operands_swapped\n+#define LOOP_VINFO_PEELING_FOR_NITER(L)    (L)->peeling_for_niter\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\\n-(L)->may_misalign_stmts.length () > 0\n+  (L)->may_misalign_stmts.length () > 0\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)     \\\n-(L)->may_alias_ddrs.length () > 0\n-\n-#define NITERS_KNOWN_P(n)                     \\\n-(tree_fits_shwi_p ((n))                        \\\n-&& tree_to_shwi ((n)) > 0)\n+  (L)->may_alias_ddrs.length () > 0\n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)          \\\n-NITERS_KNOWN_P ((L)->num_iters)\n+  (tree_fits_shwi_p ((L)->num_iters) && tree_to_shwi ((L)->num_iters) > 0)\n \n static inline loop_vec_info\n loop_vec_info_for_loop (struct loop *loop)"}]}