{"sha": "6bec9271941b9b72ad47b3b357a243ed0690baa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlYzkyNzE5NDFiOWI3MmFkNDdiM2IzNTdhMjQzZWQwNjkwYmFhNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-12-15T10:34:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-12-15T10:34:44Z"}, "message": "tree-flow.h (okay_component_ref_for_subvars): Remove.\n\n2005-12-15  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (okay_component_ref_for_subvars): Remove.\n\t(get_ref_base_and_extent): Declare.\n\t* tree-dfa.c (okay_component_ref_for_subvars): Remove.\n\t(get_ref_base_and_extent): New function.\n\t* tree-ssa-alias.c (find_used_portions): Use it.\n\t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n\tLikewise.\n\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n\nFrom-SVN: r108568", "tree": {"sha": "37e6c4df71824b584a70181905ff6a757f809b5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37e6c4df71824b584a70181905ff6a757f809b5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bec9271941b9b72ad47b3b357a243ed0690baa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bec9271941b9b72ad47b3b357a243ed0690baa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bec9271941b9b72ad47b3b357a243ed0690baa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bec9271941b9b72ad47b3b357a243ed0690baa7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd6dba21ac4803bde1b149365d543dd81500ded5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd6dba21ac4803bde1b149365d543dd81500ded5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd6dba21ac4803bde1b149365d543dd81500ded5"}], "stats": {"total": 265, "additions": 182, "deletions": 83}, "files": [{"sha": "dd6bda66ceaae93fbaaa2380a8a1c11887e522e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bec9271941b9b72ad47b3b357a243ed0690baa7", "patch": "@@ -1,3 +1,14 @@\n+2005-12-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (okay_component_ref_for_subvars): Remove.\n+\t(get_ref_base_and_extent): Declare.\n+\t* tree-dfa.c (okay_component_ref_for_subvars): Remove.\n+\t(get_ref_base_and_extent): New function.\n+\t* tree-ssa-alias.c (find_used_portions): Use it.\n+\t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n+\tLikewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\n 2005-12-15  Paolo Bonzini  <bonzini@gnu.org>\n \n         * combine.c: Remove force_to_mode's fourth parameter."}, {"sha": "771c9f8d4abcf521fa7cfc23b5827c2a753d3c7c", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 146, "deletions": 34, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=6bec9271941b9b72ad47b3b357a243ed0690baa7", "patch": "@@ -792,45 +792,157 @@ find_new_referenced_vars (tree *stmt_p)\n }\n \n \n-/* If REF is a COMPONENT_REF for a structure that can have sub-variables, and\n-   we know where REF is accessing, return the variable in REF that has the\n-   sub-variables.  If the return value is not NULL, POFFSET will be the\n-   offset, in bits, of REF inside the return value, and PSIZE will be the\n-   size, in bits, of REF inside the return value.  */\n+/* If REF is a handled component reference for a structure, return the\n+   base variable.  The access range is delimited by bit positions *POFFSET and\n+   *POFFSET + *PMAX_SIZE.  The access size is *PSIZE bits.  If either\n+   *PSIZE or *PMAX_SIZE is -1, they could not be determined.  If *PSIZE\n+   and *PMAX_SIZE are equal, the access is non-variable.  */\n \n tree\n-okay_component_ref_for_subvars (tree ref, unsigned HOST_WIDE_INT *poffset,\n-\t\t\t\tunsigned HOST_WIDE_INT *psize)\n+get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n+\t\t\t HOST_WIDE_INT *psize,\n+\t\t\t HOST_WIDE_INT *pmax_size)\n {\n-  tree result = NULL;\n-  HOST_WIDE_INT bitsize;\n-  HOST_WIDE_INT bitpos;\n-  tree offset;\n-  enum machine_mode mode;\n-  int unsignedp;\n-  int volatilep;\n-\n-  gcc_assert (!SSA_VAR_P (ref));\n-  *poffset = 0;  \n-  *psize = (unsigned int) -1;\n-  \n-  if (ref_contains_array_ref (ref))\n-    return result;\n-  ref = get_inner_reference (ref, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t     &unsignedp, &volatilep, false);\n-  if (TREE_CODE (ref) == INDIRECT_REF)\n-    return result;\n-  else if (offset == NULL && bitsize != -1 && SSA_VAR_P (ref))\n+  HOST_WIDE_INT bitsize = -1;\n+  HOST_WIDE_INT maxsize = -1;\n+  tree size_tree = NULL_TREE;\n+  tree bit_offset = bitsize_zero_node;\n+\n+  gcc_assert (!SSA_VAR_P (exp));\n+\n+  /* First get the final access size from just the outermost expression.  */\n+  if (TREE_CODE (exp) == COMPONENT_REF)\n+    size_tree = DECL_SIZE (TREE_OPERAND (exp, 1));\n+  else if (TREE_CODE (exp) == BIT_FIELD_REF)\n+    size_tree = TREE_OPERAND (exp, 1);\n+  else\n     {\n-      *poffset = bitpos;      \n-      *psize = bitsize;\n-      if (get_subvars_for_var (ref) != NULL)\n-\treturn ref;\n+      enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+      if (mode == BLKmode)\n+\tsize_tree = TYPE_SIZE (TREE_TYPE (exp));\n+      else\n+\tbitsize = GET_MODE_BITSIZE (mode);\n     }\n-  else if (SSA_VAR_P (ref))\n+  if (size_tree != NULL_TREE)\n     {\n-      if (get_subvars_for_var (ref) != NULL)\n-\treturn ref;\n+      if (! host_integerp (size_tree, 1))\n+\tbitsize = -1;\n+      else\n+\tbitsize = TREE_INT_CST_LOW (size_tree);\n     }\n-  return NULL_TREE;\n+\n+  /* Initially, maxsize is the same as the accessed element size.\n+     In the following it will only grow (or become -1).  */\n+  maxsize = bitsize;\n+\n+  /* Compute cumulative bit-offset for nested component-refs and array-refs,\n+     and find the ultimate containing object.  */\n+  while (1)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase BIT_FIELD_REF:\n+\t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n+\t\t\t\t   TREE_OPERAND (exp, 2));\n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  {\n+\t    tree field = TREE_OPERAND (exp, 1);\n+\t    tree this_offset = component_ref_field_offset (exp);\n+\n+\t    if (this_offset && TREE_CODE (this_offset) == INTEGER_CST)\n+\t      {\n+\t\tthis_offset = size_binop (MULT_EXPR,\n+\t\t\t\t\t  fold_convert (bitsizetype,\n+\t\t\t\t\t\t\tthis_offset),\n+\t\t\t\t\t  bitsize_unit_node);\n+\t\tbit_offset = size_binop (PLUS_EXPR,\n+\t\t\t\t         bit_offset, this_offset);\n+\t\tbit_offset = size_binop (PLUS_EXPR, bit_offset,\n+\t\t\t\t\t DECL_FIELD_BIT_OFFSET (field));\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree csize = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t\t/* We need to adjust maxsize to the whole structure bitsize.\n+\t\t   But we can subtract any constant offset seen sofar,\n+\t\t   because that would get us out of the structure otherwise.  */\n+\t\tif (maxsize != -1\n+\t\t    && csize && host_integerp (csize, 1))\n+\t\t  {\n+\t\t    maxsize = (TREE_INT_CST_LOW (csize)\n+\t\t\t       - TREE_INT_CST_LOW (bit_offset));\n+\t\t  }\n+\t\telse\n+\t\t  maxsize = -1;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  {\n+\t    tree index = TREE_OPERAND (exp, 1);\n+\t    tree low_bound = array_ref_low_bound (exp);\n+\t    tree unit_size = array_ref_element_size (exp);\n+\n+\t    if (! integer_zerop (low_bound))\n+\t      index = fold_build2 (MINUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t   index, low_bound);\n+\t    index = size_binop (MULT_EXPR,\n+\t\t\t\tfold_convert (sizetype, index), unit_size);\n+\t    if (TREE_CODE (index) == INTEGER_CST)\n+\t      {\n+\t\tindex = size_binop (MULT_EXPR,\n+\t\t\t\t    fold_convert (bitsizetype, index),\n+\t\t\t\t    bitsize_unit_node);\n+\t\tbit_offset = size_binop (PLUS_EXPR, bit_offset, index);\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree asize = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t\t/* We need to adjust maxsize to the whole array bitsize.\n+\t\t   But we can subtract any constant offset seen sofar,\n+\t\t   because that would get us outside of the array otherwise.  */\n+\t\tif (maxsize != -1\n+\t\t    && asize && host_integerp (asize, 1))\n+\t\t  {\n+\t\t    maxsize = (TREE_INT_CST_LOW (asize)\n+\t\t\t       - TREE_INT_CST_LOW (bit_offset));\n+\t\t  }\n+\t\telse\n+\t\t  maxsize = -1;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase REALPART_EXPR:\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n+\t\t\t\t   bitsize_int (bitsize));\n+\t  break;\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  /* ???  We probably should give up here and bail out.  */\n+\t  break;\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n+\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+ done:\n+\n+  /* ???  Due to negative offsets in ARRAY_REF we can end up with\n+     negative bit_offset here.  We might want to store a zero offset\n+     in this case.  */\n+  *poffset = TREE_INT_CST_LOW (bit_offset);\n+  *psize = bitsize;\n+  *pmax_size = maxsize;\n+\n+  return exp;\n }"}, {"sha": "9ebfeb8bc0e1ba49ec7f61652969b0c21714dbe1", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6bec9271941b9b72ad47b3b357a243ed0690baa7", "patch": "@@ -592,8 +592,8 @@ static inline subvar_t get_subvars_for_var (tree);\n static inline tree get_subvar_at (tree, unsigned HOST_WIDE_INT);\n static inline bool ref_contains_array_ref (tree);\n static inline bool array_ref_contains_indirect_ref (tree);\n-extern tree okay_component_ref_for_subvars (tree, unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t    unsigned HOST_WIDE_INT *);\n+extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n+\t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n static inline bool var_can_have_subvars (tree);\n static inline bool overlap_subvar (unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,"}, {"sha": "d7d11c11278c953c823e2069276d308935cf4e51", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=6bec9271941b9b72ad47b3b357a243ed0690baa7", "patch": "@@ -2695,54 +2695,33 @@ find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case COMPONENT_REF:\n       {\n \tHOST_WIDE_INT bitsize;\n+\tHOST_WIDE_INT bitmaxsize;\n \tHOST_WIDE_INT bitpos;\n-\ttree offset;\n-\tenum machine_mode mode;\n-\tint unsignedp;\n-\tint volatilep;\t\n \ttree ref;\n-\tref = get_inner_reference (*tp, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t   &unsignedp, &volatilep, false);\n-\tif (DECL_P (ref) && offset == NULL && bitsize != -1)\n-\t  {\t    \n+\tref = get_ref_base_and_extent (*tp, &bitpos, &bitsize, &bitmaxsize);\n+\tif (DECL_P (ref)\n+\t    && var_can_have_subvars (ref)\n+\t    && bitmaxsize != -1)\n+\t  {\n \t    size_t uid = DECL_UID (ref);\n \t    used_part_t up;\n \n \t    up = get_or_create_used_part_for (uid);\t    \n \n \t    if (bitpos <= up->minused)\n \t      up->minused = bitpos;\n-\t    if ((bitpos + bitsize >= up->maxused))\n-\t      up->maxused = bitpos + bitsize;\t    \n+\t    if ((bitpos + bitmaxsize >= up->maxused))\n+\t      up->maxused = bitpos + bitmaxsize;\n \n-\t    up->explicit_uses = true;\n+\t    if (bitsize == bitmaxsize)\n+\t      up->explicit_uses = true;\n+\t    else\n+\t      up->implicit_uses = true;\n \t    up_insert (uid, up);\n \n \t    *walk_subtrees = 0;\n \t    return NULL_TREE;\n \t  }\n-\telse if (DECL_P (ref))\n-\t  {\n-\t    if (DECL_SIZE (ref)\n-\t\t&& var_can_have_subvars (ref)\n-\t\t&& TREE_CODE (DECL_SIZE (ref)) == INTEGER_CST)\n-\t      {\n-\t\tused_part_t up;\n-\t\tsize_t uid = DECL_UID (ref);\n-\n-\t\tup = get_or_create_used_part_for (uid);\n-\n-\t\tup->minused = 0;\n-\t\tup->maxused = TREE_INT_CST_LOW (DECL_SIZE (ref));\n-\n-\t\tup->implicit_uses = true;\n-\n-\t\tup_insert (uid, up);\n-\n-\t\t*walk_subtrees = 0;\n-\t\treturn NULL_TREE;\n-\t      }\n-\t  }\n       }\n       break;\n       /* This is here to make sure we mark the entire base variable as used"}, {"sha": "0e0f3650ddcab4db94dad47640d301a6f9768096", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6bec9271941b9b72ad47b3b357a243ed0690baa7", "patch": "@@ -1133,25 +1133,26 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case IMAGPART_EXPR:\n       {\n \ttree ref;\n-\tunsigned HOST_WIDE_INT offset, size;\n+\tHOST_WIDE_INT offset, size, maxsize;\n  \t/* This component ref becomes an access to all of the subvariables\n \t   it can touch,  if we can determine that, but *NOT* the real one.\n \t   If we can't determine which fields we could touch, the recursion\n \t   will eventually get to a variable and add *all* of its subvars, or\n \t   whatever is the minimum correct subset.  */\n \n-\tref = okay_component_ref_for_subvars (expr, &offset, &size);\n-\tif (ref)\n+\tref = get_ref_base_and_extent (expr, &offset, &size, &maxsize);\n+\tif (SSA_VAR_P (ref) && get_subvars_for_var (ref))\n \t  {\t  \n \t    subvar_t svars = get_subvars_for_var (ref);\n \t    subvar_t sv;\n \t    for (sv = svars; sv; sv = sv->next)\n \t      {\n \t\tbool exact;\t\t\n-\t\tif (overlap_subvar (offset, size, sv, &exact))\n+\t\tif (overlap_subvar (offset, maxsize, sv, &exact))\n \t\t  {\n \t            int subvar_flags = flags;\n-\t\t    if (!exact)\n+\t\t    if (!exact\n+\t\t\t|| size != maxsize)\n \t\t      subvar_flags &= ~opf_kill_def;\n \t\t    add_stmt_operand (&sv->var, s_ann, subvar_flags);\n \t\t  }"}, {"sha": "9ed4d78f7c468f5c2f3de7f8ccd7d0e466b734cd", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec9271941b9b72ad47b3b357a243ed0690baa7/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=6bec9271941b9b72ad47b3b357a243ed0690baa7", "patch": "@@ -2348,11 +2348,8 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n {\n   tree orig_t = t;\n   HOST_WIDE_INT bitsize = -1;\n+  HOST_WIDE_INT bitmaxsize = -1;\n   HOST_WIDE_INT bitpos;\n-  tree offset = NULL_TREE;\n-  enum machine_mode mode;\n-  int unsignedp;\n-  int volatilep;\n   tree forzero;\n   struct constraint_expr *result;\n   unsigned int beforelength = VEC_length (ce_s, *results);\n@@ -2374,8 +2371,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n       return;\n     }\n  \n-  t = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t   &unsignedp, &volatilep, false);\n+  t = get_ref_base_and_extent (t, &bitpos, &bitsize, &bitmaxsize);\n   get_constraint_for (t, results, anyoffset);\n   result = VEC_last (ce_s, *results);\n \n@@ -2386,11 +2382,11 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n     result->type = SCALAR;\n   \n   /* If we know where this goes, then yay. Otherwise, booo. */\n-\n-  if (offset == NULL && bitsize != -1)\n+  if (bitmaxsize != -1\n+      && bitsize == bitmaxsize)\n     {\n       result->offset = bitpos;\n-    }\t\n+    }\n   /* FIXME: Handle the DEREF case.  */\n   else if (anyoffset && result->type != DEREF)\n     {"}]}