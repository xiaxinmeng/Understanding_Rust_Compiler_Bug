{"sha": "5e96277660887473bdc8b1953fcc35aedd092e3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU5NjI3NzY2MDg4NzQ3M2JkYzhiMTk1M2ZjYzM1YWVkZDA5MmUzYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-06-20T21:31:32Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-06-20T21:31:32Z"}, "message": "loop-invariant.c: New file.\n\n\t* loop-invariant.c: New file.\n\t* Makefile.in (loop-invariant.o): New.\n\t* cfgloop.h (global_cost_for_size, init_set_costs,\n\tmove_loop_invariants): Declare.\n\t* cfgloopanal.c (seq_cost, init_set_costs, global_cost_for_size): New\n\tfunctions.\n\t(avail_regs, res_regs, small_cost, pres_cost, spill_cost): New\n\tvariables.\n\t* common.opt (floop-optimize2, fmove-loop-invariants): New options.\n\t* loop-init.c (loop_optimizer_init): Call init_set_costs.\n\t* passes.c (rest_of_handle_loop2): Call move_loop_invariants.\n\t(rest_of_compilation): Check flag_loop_optimize2.\n\t* toplev.c (process_options): Handle flag_loop_optimize2.\n\t* doc/invoke.texi (-floop-optimize2, -fmove-loop-invariants): Document.\n\t* doc/passes.texi (loop-invariant.c): Document.\n\nFrom-SVN: r83419", "tree": {"sha": "ba006d95fa2c6cd2214ff0411ebeceffe1b217d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba006d95fa2c6cd2214ff0411ebeceffe1b217d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e96277660887473bdc8b1953fcc35aedd092e3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e96277660887473bdc8b1953fcc35aedd092e3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e96277660887473bdc8b1953fcc35aedd092e3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e96277660887473bdc8b1953fcc35aedd092e3a/comments", "author": null, "committer": null, "parents": [{"sha": "2e24fa83ab8d4c5c532e98f0fd005e4f20c833fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e24fa83ab8d4c5c532e98f0fd005e4f20c833fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e24fa83ab8d4c5c532e98f0fd005e4f20c833fc"}], "stats": {"total": 1105, "additions": 1101, "deletions": 4}, "files": [{"sha": "3b897aeb177030c0fb52a65817cd431b12e941c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -1,3 +1,21 @@\n+2004-06-20  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* loop-invariant.c: New file.\n+\t* Makefile.in (loop-invariant.o): New.\n+\t* cfgloop.h (global_cost_for_size, init_set_costs,\n+\tmove_loop_invariants): Declare.\n+\t* cfgloopanal.c (seq_cost, init_set_costs, global_cost_for_size): New\n+\tfunctions.\n+\t(avail_regs, res_regs, small_cost, pres_cost, spill_cost): New\n+\tvariables.\n+\t* common.opt (floop-optimize2, fmove-loop-invariants): New options.\n+\t* loop-init.c (loop_optimizer_init): Call init_set_costs.\n+\t* passes.c (rest_of_handle_loop2): Call move_loop_invariants.\n+\t(rest_of_compilation): Check flag_loop_optimize2.\n+\t* toplev.c (process_options): Handle flag_loop_optimize2.\n+\t* doc/invoke.texi (-floop-optimize2, -fmove-loop-invariants): Document.\n+\t* doc/passes.texi (loop-invariant.c): Document.\n+\n 2004-06-20  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* tree-ssa-pre.c (compute_antic): Keep BB_VISITED flag zeroed."}, {"sha": "020f4bcd16599418482e67040916a71ede4fd42a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -897,7 +897,7 @@ OBJS-common = \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n- dbxout.o ddg.o\t\t\t\t\t\t\t\t   \\\n+ dbxout.o ddg.o loop-invariant.o\t\t\t\t\t   \\\n  debug.o df.o diagnostic.o dojump.o dominance.o loop-doloop.o\t\t   \\\n  dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o\t\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n@@ -1952,6 +1952,9 @@ cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H)\n+loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h cfgloop.h $(EXPR_H) coretypes.h $(TM_H) \\\n+   function.h flags.h df.h\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) output.h coretypes.h $(TM_H)\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\"}, {"sha": "d73c99b240c22dde20b0b90ad99f7dcd5d602b3d", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -411,6 +411,11 @@ simple_loop_desc (struct loop *loop)\n   return loop->aux;\n }\n \n+/* Register pressure estimation for induction variable optimizations & loop\n+   invariant motion.  */\n+extern unsigned global_cost_for_size (unsigned, unsigned, unsigned);\n+extern void init_set_costs (void);\n+\n /* Loop optimizer initialization.  */\n extern struct loops *loop_optimizer_init (FILE *);\n extern void loop_optimizer_finalize (struct loops *, FILE *);\n@@ -427,5 +432,6 @@ enum\n \n extern void unroll_and_peel_loops (struct loops *, int);\n extern void doloop_optimize_loops (struct loops *);\n+extern void move_loop_invariants (struct loops *);\n \n #endif /* GCC_CFGLOOP_H */"}, {"sha": "074574fc029044080692740c205d092d0eb21f76", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -474,3 +474,92 @@ get_loop_level (const struct loop *loop)\n     }\n   return mx;\n }\n+\n+/* Returns estimate on cost of computing SEQ.  */\n+\n+static unsigned\n+seq_cost (rtx seq)\n+{\n+  unsigned cost = 0;\n+  rtx set;\n+\n+  for (; seq; seq = NEXT_INSN (seq))\n+    {\n+      set = single_set (seq);\n+      if (set)\n+\tcost += rtx_cost (set, SET);\n+      else\n+\tcost++;\n+    }\n+\n+  return cost;\n+}\n+\n+/* The properties of the target.  */\n+\n+static unsigned avail_regs;\t/* Number of available registers.  */\n+static unsigned res_regs;\t/* Number of reserved registers.  */\n+static unsigned small_cost;\t/* The cost for register when there is a free one.  */\n+static unsigned pres_cost;\t/* The cost for register when there are not too many\n+\t\t\t\t   free ones.  */\n+static unsigned spill_cost;\t/* The cost for register when we need to spill.  */\n+\n+/* Initialize the constants for computing set costs.  */\n+\n+void\n+init_set_costs (void)\n+{\n+  rtx seq;\n+  rtx reg1 = gen_raw_REG (SImode, FIRST_PSEUDO_REGISTER);\n+  rtx reg2 = gen_raw_REG (SImode, FIRST_PSEUDO_REGISTER + 1);\n+  rtx addr = gen_raw_REG (Pmode, FIRST_PSEUDO_REGISTER + 2);\n+  rtx mem = validize_mem (gen_rtx_MEM (SImode, addr));\n+  unsigned i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], i)\n+\t&& !fixed_regs[i])\n+      avail_regs++;\n+\n+  res_regs = 3;\n+\n+  /* These are really just heuristic values.  */\n+  \n+  start_sequence ();\n+  emit_move_insn (reg1, reg2);\n+  seq = get_insns ();\n+  end_sequence ();\n+  small_cost = seq_cost (seq);\n+  pres_cost = 2 * small_cost;\n+\n+  start_sequence ();\n+  emit_move_insn (mem, reg1);\n+  emit_move_insn (reg2, mem);\n+  seq = get_insns ();\n+  end_sequence ();\n+  spill_cost = seq_cost (seq);\n+}\n+\n+/* Calculates cost for having SIZE new loop global variables.  REGS_USED is the\n+   number of global registers used in loop.  N_USES is the number of relevant\n+   variable uses.  */\n+\n+unsigned\n+global_cost_for_size (unsigned size, unsigned regs_used, unsigned n_uses)\n+{\n+  unsigned regs_needed = regs_used + size;\n+  unsigned cost = 0;\n+\n+  if (regs_needed + res_regs <= avail_regs)\n+    cost += small_cost * size;\n+  else if (regs_needed <= avail_regs)\n+    cost += pres_cost * size;\n+  else\n+    {\n+      cost += pres_cost * size;\n+      cost += spill_cost * n_uses * (regs_needed - avail_regs) / regs_needed;\n+    }\n+\n+  return cost;\n+}\n+"}, {"sha": "14e29e0a22296188994687d4199f85d170ba665d", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -447,6 +447,10 @@ floop-optimize\n Common Report Var(flag_loop_optimize)\n Perform loop optimizations\n \n+floop-optimize2\n+Common Report Var(flag_loop_optimize2)\n+Perform loop optimizations using the new loop optimizer\n+\n fmath-errno\n Common Report Var(flag_errno_math) Init(1)\n Set errno after built-in math functions\n@@ -475,6 +479,10 @@ fmove-all-movables\n Common Report Var(flag_move_all_movables)\n Force all loop invariant computations out of loops\n \n+fmove-loop-invariants\n+Common Report Var(flag_move_loop_invariants)\n+Move loop invariant computations out of loops\n+\n fmudflap\n Common RejectNegative Report Var(flag_mudflap)\n Add mudflap bounds-checking instrumentation for single-threaded program."}, {"sha": "2dd2b8239d754c0c075fe16a6a8c391a989eeedc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -290,7 +290,7 @@ in the following sections.\n -finline-functions  -finline-limit=@var{n}  -fkeep-inline-functions @gol\n -fkeep-static-consts  -fmerge-constants  -fmerge-all-constants @gol\n -fmodulo-sched -fmove-all-movables  -fnew-ra  -fno-branch-count-reg @gol\n--fno-default-inline  -fno-defer-pop @gol\n+-fno-default-inline  -fno-defer-pop -floop-optimize2 -fmove-loop-invariants @gol\n -fno-function-cse  -fno-guess-branch-probability @gol\n -fno-inline  -fno-math-errno  -fno-peephole  -fno-peephole2 @gol\n -funsafe-math-optimizations  -ffinite-math-only @gol\n@@ -4191,6 +4191,12 @@ well.\n \n Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -floop-optimize2\n+@opindex floop-optimize2\n+Perform loop optimizations using the new loop optimizer.  The optimizations\n+(loop unrolling, peeling and unswitching, loop invariant motion) are enabled\n+by separate flags.\n+\n @item -fcrossjumping\n @opindex crossjumping\n Perform cross-jumping transformation. This transformation unifies equivalent code and save code size. The\n@@ -4922,6 +4928,11 @@ roll much (from profile feedback).  It also turns on complete loop peeling\n \n Enabled with @option{-fprofile-use}.\n \n+@item -fmove-loop-invariants\n+@opindex fmove-loop-invariants\n+Enables the loop invariant motion pass in the new loop optimizer.  Enabled\n+at level @option{-O1}\n+\n @item -funswitch-loops\n @opindex funswitch-loops\n Move branches with loop invariant conditions out of the loop, with duplicates"}, {"sha": "94b9ae5b23a8a8484c78071aea08085f886157b9", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -520,13 +520,17 @@ Its source files are @file{loop.c} and @file{unroll.c}, plus the header\n @file{loop.h} used for communication between them.  Loop unrolling uses\n some functions in @file{integrate.c} and the header @file{integrate.h}.\n Loop dependency analysis routines are contained in @file{dependence.c}.\n+This pass is seriously out-of-date and is supposed to be replaced by\n+a new one described below in near future.\n \n A second loop optimization pass takes care of basic block level\n optimizations---unrolling, peeling and unswitching loops. The source\n files are @file{cfgloopanal.c} and @file{cfgloopmanip.c} containing\n generic loop analysis and manipulation code, @file{loop-init.c} with\n initialization and finalization code, @file{loop-unswitch.c} for loop\n unswitching and @file{loop-unroll.c} for loop unrolling and peeling.\n+It also contains a separate loop invariant motion pass implemented in\n+@file{loop-invariant.c}.\n \n @item Jump bypassing\n "}, {"sha": "ff441e8c56d2091b36cf21e2e9386a53963b7a02", "filename": "gcc/loop-init.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -35,6 +35,13 @@ loop_optimizer_init (FILE *dumpfile)\n {\n   struct loops *loops = xcalloc (1, sizeof (struct loops));\n   edge e;\n+  static bool first_time = true;\n+\n+  if (first_time)\n+    {\n+      first_time = false;\n+      init_set_costs ();\n+    }\n \n   /* Avoid annoying special cases of edges going to exit\n      block.  */"}, {"sha": "f839ae5163550735174d41677a261cb82271f9da", "filename": "gcc/loop-invariant.c", "status": "added", "additions": 933, "deletions": 0, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -0,0 +1,933 @@\n+/* Rtl-level loop invariant motion.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This implements the loop invariant motion pass.  It is very simple\n+   (no calls, libcalls, etc.).  This should be sufficient to cleanup things like\n+   address arithmetics -- other more complicated invariants should be\n+   eliminated on tree level either in tree-ssa-loop-im.c or in tree-ssa-pre.c.\n+   \n+   We proceed loop by loop -- it is simpler than trying to handle things\n+   globally and should not lose much.  First we inspect all sets inside loop\n+   and create a dependency graph on insns (saying \"to move this insn, you must\n+   also move the following insns\").\n+\n+   We then need to determine what to move.  We estimate the number of registers\n+   used and move as many invariants as possible while we still have enough free\n+   registers.  We prefer the expensive invariants.\n+   \n+   Then we move the selected invariants out of the loop, creating a new\n+   temporaries for them if necessary.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"cfgloop.h\"\n+#include \"expr.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"flags.h\"\n+#include \"df.h\"\n+\n+/* The data stored for the loop.  */\n+\n+struct loop_data\n+{\n+  struct loop *outermost_exit;\t/* The outermost exit of the loop.  */\n+  bool has_call;\t\t/* True if the loop contains a call.  */\n+};\n+\n+#define LOOP_DATA(LOOP) ((struct loop_data *) (LOOP)->aux)\n+\n+/* The description of an use.  */\n+\n+struct use\n+{\n+  rtx *pos;\t\t\t/* Position of the use.  */\n+  rtx insn;\t\t\t/* The insn in that the use occurs.  */\n+\n+  struct use *next;\t\t/* Next use in the list.  */\n+};\n+\n+/* The description of a def.  */\n+\n+struct def\n+{\n+  struct use *uses;\t\t/* The list of uses that are uniquely reached\n+\t\t\t\t   by it.  */\n+  unsigned n_uses;\t\t/* Number of such uses.  */\n+  unsigned invno;\t\t/* The corresponding invariant.  */\n+};\n+\n+/* The data stored for each invariant.  */\n+\n+struct invariant\n+{\n+  /* The number of the invariant.  */\n+  unsigned invno;\n+\n+  /* Whether we already processed the invariant.  */\n+  bool processed;\n+\n+  /* The definition of the invariant.  */\n+  struct def *def;\n+\n+  /* The insn in that it is defined.  */\n+  rtx insn;\n+\n+  /* Whether it is always executed.  */\n+  bool always_executed;\n+\n+  /* Whether to move the invariant.  */\n+  bool move;\n+\n+  /* Cost if the invariant.  */\n+  unsigned cost;\n+\n+  /* The invariants it depends on.  */\n+  bitmap depends_on;\n+\n+  /* Used for detecting already visited invariants during determining\n+     costs of movements.  */\n+  unsigned stamp;\n+};\n+\n+/* The actual stamp for marking already visited invariants during determining\n+   costs of movements.  */\n+\n+static unsigned actual_stamp;\n+\n+/* The invariants.  */\n+\n+static varray_type invariants;\n+\n+/* Test for possibility of invariantness of X.  */\n+\n+static bool\n+check_maybe_invariant (rtx x)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  const char *fmt;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CONST:\n+    case LABEL_REF:\n+      return true;\n+\n+    case PC:\n+    case CC0:\n+    case UNSPEC_VOLATILE:\n+    case CALL:\n+      return false;\n+\n+    case REG:\n+      return true;\n+\n+    case MEM:\n+      /* Load/store motion is done elsewhere.  ??? Perhaps also add it here?\n+\t It should not be hard, and might be faster than \"elsewhere\".  */\n+\n+      /* Just handle the most trivial case where we load from an unchanging\n+\t location (most importantly, pic tables).  */\n+      if (RTX_UNCHANGING_P (x))\n+\tbreak;\n+\n+      return false;\n+\n+    case ASM_OPERANDS:\n+      /* Don't mess with insns declared volatile.  */\n+      if (MEM_VOLATILE_P (x))\n+\treturn false;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (!check_maybe_invariant (XEXP (x, i)))\n+\t    return false;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (!check_maybe_invariant (XVECEXP (x, i, j)))\n+\t      return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Determines the basic blocks inside LOOP that are always executed and\n+   stores their bitmap to ALWAYS_REACHED.  MAY_EXIT is a bitmap of\n+   basic blocks that may either exit the loop, or contain the call that\n+   does not have to return.  BODY is body of the loop obtained by\n+   get_loop_body_in_dom_order.  */\n+\n+static void\n+compute_always_reached (struct loop *loop, basic_block *body,\n+\t\t\tbitmap may_exit, bitmap always_reached)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      if (dominated_by_p (CDI_DOMINATORS, loop->latch, body[i]))\n+\tbitmap_set_bit (always_reached, i);\n+\n+      if (bitmap_bit_p (may_exit, i))\n+\treturn;\n+    }\n+}\n+\n+/* Finds exits out of the LOOP with body BODY.  Marks blocks in that we may\n+   exit the loop by cfg edge to HAS_EXIT and MAY_EXIT.  In MAY_EXIT\n+   additionally mark blocks that may exit due to a call.  */\n+\n+static void\n+find_exits (struct loop *loop, basic_block *body,\n+\t    bitmap may_exit, bitmap has_exit)\n+{\n+  unsigned i;\n+  edge e;\n+  struct loop *outermost_exit = loop, *aexit;\n+  bool has_call = false;\n+  rtx insn;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      if (body[i]->loop_father == loop)\n+\t{\n+\t  FOR_BB_INSNS (body[i], insn)\n+\t    {\n+\t      if (GET_CODE (insn) == CALL_INSN\n+\t\t  && !CONST_OR_PURE_CALL_P (insn))\n+\t\t{\n+\t\t  has_call = true;\n+\t\t  bitmap_set_bit (may_exit, i);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  for (e = body[i]->succ; e; e = e->succ_next)\n+\t    {\n+\t      if (flow_bb_inside_loop_p (loop, e->dest))\n+\t\tcontinue;\n+\n+\t      bitmap_set_bit (may_exit, i);\n+\t      bitmap_set_bit (has_exit, i);\n+\t      outermost_exit = find_common_loop (outermost_exit,\n+\t\t\t\t\t\t e->dest->loop_father);\n+\t    }\n+\t  continue;\n+\t}\n+     \n+      /* Use the data stored for the subloop to decide whether we may exit\n+\t through it.  It is sufficient to do this for header of the loop,\n+\t as other basic blocks inside it must be dominated by it.  */\n+      if (body[i]->loop_father->header != body[i])\n+\tcontinue;\n+\n+      if (LOOP_DATA (body[i]->loop_father)->has_call)\n+\t{\n+\t  has_call = true;\n+\t  bitmap_set_bit (may_exit, i);\n+\t}\n+      aexit = LOOP_DATA (body[i]->loop_father)->outermost_exit;\n+      if (aexit != loop)\n+\t{\n+\t  bitmap_set_bit (may_exit, i);\n+\t  bitmap_set_bit (has_exit, i);\n+\n+\t  if (flow_loop_nested_p (aexit, outermost_exit))\n+\t    outermost_exit = aexit;\n+\t}\n+    }\n+\n+  loop->aux = xcalloc (1, sizeof (struct loop_data));\n+  LOOP_DATA (loop)->outermost_exit = outermost_exit;\n+  LOOP_DATA (loop)->has_call = has_call;\n+}\n+\n+/* Check whether we may assign a value to X from a register.  */\n+\n+static bool\n+may_assign_reg_p (rtx x)\n+{\n+  return can_copy_p (GET_MODE (x));\n+}\n+\n+/* Finds definitions that may correspond to invariants in LOOP with body BODY.\n+   DF is the dataflow object.  */\n+\n+static void\n+find_defs (struct loop *loop, basic_block *body, struct df *df)\n+{\n+  unsigned i;\n+  bitmap blocks = BITMAP_XMALLOC ();\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    bitmap_set_bit (blocks, body[i]->index);\n+\n+  df_analyze_subcfg (df, blocks, DF_UD_CHAIN | DF_HARD_REGS | DF_EQUIV_NOTES);\n+  BITMAP_XFREE (blocks);\n+}\n+\n+/* Creates a new invariant for definition DEF in INSN, depending on invariants\n+   in DEPENDS_ON.  ALWAYS_EXECUTED is true if the insn is always executed,\n+   unless the program ends due to a function call.  */\n+\n+static void\n+create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n+\t\t      bool always_executed)\n+{\n+  struct invariant *inv = xmalloc (sizeof (struct invariant));\n+  rtx set = single_set (insn);\n+\n+  inv->def = def;\n+  inv->always_executed = always_executed;\n+  inv->depends_on = depends_on;\n+\n+  /* If the set is simple, usually by moving it we move the whole store out of\n+     the loop.  Otherwise we save only cost of the computation.  */\n+  if (def)\n+    inv->cost = rtx_cost (set, SET);\n+  else\n+    inv->cost = rtx_cost (SET_SRC (set), SET);\n+\n+  inv->move = false;\n+  inv->processed = false;\n+  inv->stamp = 0;\n+  inv->insn = insn;\n+\n+  inv->invno = VARRAY_ACTIVE_SIZE (invariants);\n+  if (def)\n+    def->invno = inv->invno;\n+  VARRAY_PUSH_GENERIC_PTR_NOGC (invariants, inv);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"Set in insn %d is invariant (%d), cost %d, depends on \",\n+\t       INSN_UID (insn), inv->invno, inv->cost);\n+      dump_bitmap (dump_file, inv->depends_on);\n+    }\n+}\n+\n+/* Record USE at DEF.  */\n+\n+static void\n+record_use (struct def *def, rtx *use, rtx insn)\n+{\n+  struct use *u = xmalloc (sizeof (struct use));\n+\n+  if (GET_CODE (*use) == SUBREG)\n+    use = &SUBREG_REG (*use);\n+  if (!REG_P (*use))\n+    abort ();\n+\n+  u->pos = use;\n+  u->insn = insn;\n+  u->next = def->uses;\n+  def->uses = u;\n+  def->n_uses++;\n+}\n+\n+/* Finds the invariants INSN depends on and store them to the DEPENDS_ON\n+   bitmap.  DF is the dataflow object.  */\n+\n+static bool\n+check_dependencies (rtx insn, struct df *df, bitmap depends_on)\n+{\n+  struct df_link *uses, *defs;\n+  struct ref *use, *def;\n+  basic_block bb = BLOCK_FOR_INSN (insn), def_bb;\n+  struct def *def_data;\n+  \n+  for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n+    {\n+      use = uses->ref;\n+\n+      defs = DF_REF_CHAIN (use);\n+      if (!defs)\n+\tcontinue;\n+\n+      if (defs->next)\n+\treturn false;\n+\n+      def = defs->ref;\n+      def_data = DF_REF_DATA (def);\n+      if (!def_data)\n+\treturn false;\n+\n+      def_bb = DF_REF_BB (def);\n+      if (!dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n+\treturn false;\n+\n+      bitmap_set_bit (depends_on, def_data->invno);\n+    }\n+\n+  return true;\n+}\n+\n+/* Finds invariant in INSN.  ALWAYS_REACHED is true if the insn is always\n+   executed.  ALWAYS_EXECUTED is true if the insn is always executed,\n+   unless the program ends due to a function call.  DF is the dataflow\n+   object.  */\n+\n+static void\n+find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n+\t\t     struct df *df)\n+{\n+  struct ref *ref;\n+  struct def *def;\n+  bitmap depends_on;\n+  rtx set, dest;\n+  bool simple = true;\n+\n+  /* Until we get rid of LIBCALLS.  */\n+  if (find_reg_note (insn, REG_RETVAL, NULL_RTX)\n+      || find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n+      || find_reg_note (insn, REG_NO_CONFLICT, NULL_RTX))\n+    return;\n+      \n+  set = single_set (insn);\n+  if (!set)\n+    return;\n+  dest = SET_DEST (set);\n+\n+  if (GET_CODE (dest) != REG\n+      || HARD_REGISTER_P (dest))\n+    simple = false;\n+\n+  if (!check_maybe_invariant (SET_SRC (set))\n+      || !may_assign_reg_p (SET_DEST (set)))\n+    return;\n+\n+  if (may_trap_p (PATTERN (insn)))\n+    {\n+      if (!always_reached)\n+\treturn;\n+\n+      /* Unless the exceptions are handled, the behavior is undefined\n+ \t if the trap occurs.  */\n+      if (flag_non_call_exceptions)\n+\treturn;\n+    }\n+\n+  depends_on = BITMAP_XMALLOC ();\n+  if (!check_dependencies (insn, df, depends_on))\n+    {\n+      BITMAP_XFREE (depends_on);\n+      return;\n+    }\n+\n+  if (simple)\n+    {\n+      ref = df_find_def (df, insn, dest);\n+      def = xcalloc (1, sizeof (struct def));\n+      DF_REF_DATA (ref) = def;\n+    }\n+  else\n+    def = NULL;\n+\n+  create_new_invariant (def, insn, depends_on, always_executed);\n+}\n+\n+/* Record registers used in INSN that have an unique invariant definition.\n+   DF is the dataflow object.  */\n+\n+static void\n+record_uses (rtx insn, struct df *df)\n+{\n+  struct df_link *uses, *defs;\n+  struct ref *use, *def;\n+  basic_block bb = BLOCK_FOR_INSN (insn), def_bb;\n+  \n+  for (uses = DF_INSN_USES (df, insn); uses; uses = uses->next)\n+    {\n+      use = uses->ref;\n+\n+      defs = DF_REF_CHAIN (use);\n+      if (!defs || defs->next)\n+\tcontinue;\n+      def = defs->ref;\n+      if (!DF_REF_DATA (def))\n+\tcontinue;\n+\n+      def_bb = DF_REF_BB (def);\n+      if (!dominated_by_p (CDI_DOMINATORS, bb, def_bb))\n+\tcontinue;\n+\n+      record_use (DF_REF_DATA (def), DF_REF_LOC (use), DF_REF_INSN (use));\n+    }\n+}\n+\n+/* Finds invariants in INSN.  ALWAYS_REACHED is true if the insn is always\n+   executed.  ALWAYS_EXECUTED is true if the insn is always executed,\n+   unless the program ends due to a function call.  DF is the dataflow\n+   object.  */\n+\n+static void\n+find_invariants_insn (rtx insn, bool always_reached, bool always_executed,\n+\t\t      struct df *df)\n+{\n+  find_invariant_insn (insn, always_reached, always_executed, df);\n+  record_uses (insn, df);\n+}\n+\n+/* Finds invariants in basic block BB.  ALWAYS_REACHED is true if the\n+   basic block is always executed.  ALWAYS_EXECUTED is true if the basic\n+   block is always executed, unless the program ends due to a function\n+   call.  DF is the dataflow object.  */\n+\n+static void\n+find_invariants_bb (basic_block bb, bool always_reached, bool always_executed,\n+\t\t    struct df *df)\n+{\n+  rtx insn;\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      find_invariants_insn (insn, always_reached, always_executed, df);\n+\n+      if (always_reached\n+\t  && GET_CODE (insn) == CALL_INSN\n+\t  && !CONST_OR_PURE_CALL_P (insn))\n+\talways_reached = false;\n+    }\n+}\n+\n+/* Finds invariants in LOOP with body BODY.  ALWAYS_REACHED is the bitmap of\n+   basic blocks in BODY that are always executed.  ALWAYS_EXECUTED is the\n+   bitmap of basic blocks in BODY that are always executed unless the program\n+   ends due to a function call.  DF is the dataflow object.  */\n+\n+static void\n+find_invariants_body (struct loop *loop, basic_block *body,\n+\t\t      bitmap always_reached, bitmap always_executed,\n+\t\t      struct df *df)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    find_invariants_bb (body[i],\n+\t\t\tbitmap_bit_p (always_reached, i),\n+\t\t\tbitmap_bit_p (always_executed, i),\n+\t\t\tdf);\n+}\n+\n+/* Finds invariants in LOOP.  DF is the dataflow object.  */\n+\n+static void\n+find_invariants (struct loop *loop, struct df *df)\n+{\n+  bitmap may_exit = BITMAP_XMALLOC ();\n+  bitmap always_reached = BITMAP_XMALLOC ();\n+  bitmap has_exit = BITMAP_XMALLOC ();\n+  bitmap always_executed = BITMAP_XMALLOC ();\n+  basic_block *body = get_loop_body_in_dom_order (loop);\n+\n+  find_exits (loop, body, may_exit, has_exit);\n+  compute_always_reached (loop, body, may_exit, always_reached);\n+  compute_always_reached (loop, body, has_exit, always_executed);\n+\n+  find_defs (loop, body, df);\n+  find_invariants_body (loop, body, always_reached, always_executed, df);\n+\n+  BITMAP_XFREE (always_reached);\n+  BITMAP_XFREE (always_executed);\n+  BITMAP_XFREE (may_exit);\n+  BITMAP_XFREE (has_exit);\n+  free (body);\n+}\n+\n+/* Frees a list of uses USE.  */\n+\n+static void\n+free_use_list (struct use *use)\n+{\n+  struct use *next;\n+\n+  for (; use; use = next)\n+    {\n+      next = use->next;\n+      free (use);\n+    }\n+}\n+\n+/* Calculates cost and number of registers needed for moving invariant INV\n+   out of the loop and stores them to *COST and *REGS_NEEDED.  */\n+\n+static void\n+get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n+{\n+  int acomp_cost;\n+  unsigned aregs_needed;\n+  unsigned depno;\n+  struct invariant *dep;\n+\n+  *comp_cost = 0;\n+  *regs_needed = 0;\n+  if (inv->move\n+      || inv->stamp == actual_stamp)\n+    return;\n+  inv->stamp = actual_stamp;\n+\n+  (*regs_needed)++;\n+  (*comp_cost) += inv->cost;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno,\n+    {\n+      dep = VARRAY_GENERIC_PTR_NOGC (invariants, depno);\n+\n+      get_inv_cost (dep, &acomp_cost, &aregs_needed);\n+\n+      if (aregs_needed\n+\t  /* We need to check always_executed, since if the original value of\n+\t     the invariant may be preserved, we may need to keep it in a\n+\t     separate register.  TODO check whether the register has an\n+\t     use outside of the loop.  */\n+\t  && dep->always_executed\n+\t  && !dep->def->uses->next)\n+\t{\n+\t  /* If this is a single use, after moving the dependency we will not\n+\t     need a new register.  */\n+\t  aregs_needed--;\n+\t}\n+\n+      (*regs_needed) += aregs_needed;\n+      (*comp_cost) += acomp_cost;\n+    });\n+}\n+\n+/* Calculates gain for eliminating invariant INV.  REGS_USED is the number\n+   of registers used in the loop, N_INV_USES is the number of uses of\n+   invariants, NEW_REGS is the number of new variables already added due to\n+   the invariant motion.  The number of registers needed for it is stored in\n+   *REGS_NEEDED.  */\n+\n+static int\n+gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n+\t\t    unsigned new_regs, unsigned regs_used, unsigned n_inv_uses)\n+{\n+  int comp_cost, size_cost;\n+\n+  get_inv_cost (inv, &comp_cost, regs_needed);\n+  actual_stamp++;\n+\n+  size_cost = (global_cost_for_size (new_regs + *regs_needed,\n+\t\t\t\t     regs_used, n_inv_uses)\n+\t       - global_cost_for_size (new_regs, regs_used, n_inv_uses));\n+\n+  return comp_cost - size_cost;\n+}\n+\n+/* Finds invariant with best gain for moving.  Returns the gain, stores\n+   the invariant in *BEST and number of registers needed for it to\n+   *REGS_NEEDED.  REGS_USED is the number of registers used in\n+   the loop, N_INV_USES is the number of uses of invariants.  NEW_REGS\n+   is the number of new variables already added due to invariant motion.  */\n+\n+static int\n+best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n+\t\t\t unsigned new_regs, unsigned regs_used,\n+\t\t\t unsigned n_inv_uses)\n+{\n+  struct invariant *inv;\n+  int gain = 0, again;\n+  unsigned aregs_needed, invno;\n+\n+  for (invno = 0; invno < VARRAY_ACTIVE_SIZE (invariants); invno++)\n+    {\n+      inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n+      if (inv->move)\n+\tcontinue;\n+\n+      again = gain_for_invariant (inv, &aregs_needed,\n+\t\t\t\t  new_regs, regs_used, n_inv_uses);\n+      if (again > gain)\n+\t{\n+\t  gain = again;\n+\t  *best = inv;\n+\t  *regs_needed = aregs_needed;\n+\t}\n+    }\n+\n+  return gain;\n+}\n+\n+/* Marks invariant INVNO and all its dependencies for moving.  */\n+\n+static void\n+set_move_mark (unsigned invno)\n+{\n+  struct invariant *inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n+\n+  if (inv->move)\n+    return;\n+  inv->move = true;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Decided to move invariant %d\\n\", invno);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, invno, set_move_mark (invno));\n+}\n+\n+/* Determines which invariants to move.  DF is the dataflow object.  */\n+\n+static void\n+find_invariants_to_move (struct df *df)\n+{\n+  unsigned i, regs_used, n_inv_uses, regs_needed = 0, new_regs;\n+  struct invariant *inv = NULL;\n+\n+  if (flag_move_all_movables)\n+    {\n+      /* This is easy & stupid.  */\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+\t{\n+\t  inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n+\t  inv->move = true;\n+\t}\n+      return;\n+    }\n+\n+  if (!VARRAY_ACTIVE_SIZE (invariants))\n+    return;\n+\n+  /* Now something slightly more involved.  First estimate the number of used\n+     registers.  */\n+  n_inv_uses = 0;\n+\n+  /* We do not really do a good job in this estimation; put some initial bound\n+     here to stand for induction variables etc. that we do not detect.  */\n+  regs_used = 2;\n+\n+  for (i = 0; i < df->n_regs; i++)\n+    {\n+      if (!DF_REGNO_FIRST_DEF (df, i) && DF_REGNO_LAST_USE (df, i))\n+\t{\n+\t  /* This is a value that is used but not changed inside loop.  */\n+\t  regs_used++;\n+\t}\n+    }\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+    {\n+      inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n+      if (inv->def)\n+\tn_inv_uses += inv->def->n_uses;\n+    }\n+\n+  new_regs = 0;\n+  while (best_gain_for_invariant (&inv, &regs_needed,\n+\t\t\t\t  new_regs, regs_used, n_inv_uses) > 0)\n+    {\n+      set_move_mark (inv->invno);\n+      new_regs += regs_needed;\n+    }\n+}\n+\n+/* Move invariant INVNO out of the LOOP.  DF is the dataflow object.  */\n+\n+static void\n+move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n+{\n+  struct invariant *inv = VARRAY_GENERIC_PTR_NOGC (invariants, invno);\n+  unsigned i;\n+  basic_block preheader = loop_preheader_edge (loop)->src;\n+  rtx reg, set;\n+  struct use *use;\n+\n+  if (inv->processed)\n+    return;\n+  inv->processed = true;\n+\n+  if (inv->depends_on)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i,\n+\t{\n+\t  move_invariant_reg (loop, i, df);\n+\t});\n+    }\n+\n+  /* Move the set out of the loop.  If the set is always executed (we could\n+     omit this condition if we know that the register is unused outside of the\n+     loop, but it does not seem worth finding out) and it has no uses that\n+     would not be dominated by it, we may just move it (TODO).  Otherwise we\n+     need to create a temporary register.  */\n+  set = single_set (inv->insn);\n+  reg = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n+  df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n+\t\t\t BLOCK_FOR_INSN (inv->insn), inv->insn);\n+  SET_DEST (set) = reg;\n+  reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n+  df_insn_modify (df, preheader, inv->insn);\n+\n+  /* Replace the uses we know to be dominated.  It saves work for copy\n+     propagation, and also it is necessary so that dependent invariants\n+     are computed right.  */\n+  if (inv->def)\n+    {\n+      for (use = inv->def->uses; use; use = use->next)\n+\t{\n+\t  *use->pos = reg;\n+\t  df_insn_modify (df, BLOCK_FOR_INSN (use->insn), use->insn);\n+\t}\n+    }\n+}\n+\n+/* Move selected invariant out of the LOOP.  Newly created regs are marked\n+   in TEMPORARY_REGS.  DF is the dataflow object.  */\n+\n+static void\n+move_invariants (struct loop *loop, struct df *df)\n+{\n+  struct invariant *inv;\n+  unsigned i;\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+    {\n+      inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n+      if (inv->move)\n+\tmove_invariant_reg (loop, i, df);\n+    }\n+}\n+\n+/* Initializes invariant motion data.  */\n+\n+static void\n+init_inv_motion_data (void)\n+{\n+  actual_stamp = 1;\n+\n+  if (!invariants)\n+    VARRAY_GENERIC_PTR_NOGC_INIT (invariants, 100, \"invariants\");\n+}\n+\n+/* Frees the data allocated by invariant motion.  DF is the dataflow\n+   object.  */\n+\n+static void\n+free_inv_motion_data (struct df *df)\n+{\n+  unsigned i;\n+  struct def *def;\n+  struct invariant *inv;\n+\n+  for (i = 0; i < df->n_defs; i++)\n+    {\n+      if (!df->defs[i])\n+\tcontinue;\n+\n+      def = DF_REF_DATA (df->defs[i]);\n+      if (!def)\n+\tcontinue;\n+\n+      free_use_list (def->uses);\n+      free (def);\n+      DF_REF_DATA (df->defs[i]) = NULL;\n+    }\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (invariants); i++)\n+    {\n+      inv = VARRAY_GENERIC_PTR_NOGC (invariants, i);\n+      BITMAP_XFREE (inv->depends_on);\n+      free (inv);\n+    }\n+  VARRAY_POP_ALL (invariants);\n+}\n+\n+/* Move the invariants out of the LOOP.  DF is the dataflow object.  */\n+\n+static void\n+move_single_loop_invariants (struct loop *loop, struct df *df)\n+{\n+  init_inv_motion_data ();\n+\n+  find_invariants (loop, df);\n+  find_invariants_to_move (df);\n+  move_invariants (loop, df);\n+\n+  free_inv_motion_data (df);\n+}\n+\n+/* Releases the auxiliary data for LOOP.  */\n+\n+static void\n+free_loop_data (struct loop *loop)\n+{\n+  struct loop_data *data = LOOP_DATA (loop);\n+\n+  free (data);\n+  loop->aux = NULL;\n+}\n+\n+/* Move the invariants out of the LOOPS.  */\n+\n+void\n+move_loop_invariants (struct loops *loops)\n+{\n+  struct loop *loop;\n+  unsigned i;\n+  struct df *df = df_init ();\n+\n+  /* Process the loops, innermost first.  */\n+  loop = loops->tree_root;\n+  while (loop->inner)\n+    loop = loop->inner;\n+\n+  while (loop != loops->tree_root)\n+    {\n+      move_single_loop_invariants (loop, df);\n+\n+      if (loop->next)\n+\t{\n+\t  loop = loop->next;\n+\t  while (loop->inner)\n+\t    loop = loop->inner;\n+\t}\n+      else\n+\tloop = loop->outer;\n+    }\n+\n+  for (i = 1; i < loops->num; i++)\n+    if (loops->parray[i])\n+      free_loop_data (loops->parray[i]);\n+\n+  df_finish (df);\n+}"}, {"sha": "678dd7dd7447e8495e607fdf51ce0527c096b05e", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -1290,7 +1290,8 @@ rest_of_handle_loop2 (void)\n   struct loops *loops;\n   basic_block bb;\n \n-  if (!flag_unswitch_loops\n+  if (!flag_move_loop_invariants\n+      && !flag_unswitch_loops\n       && !flag_peel_loops\n       && !flag_unroll_loops\n       && !flag_branch_on_count_reg)\n@@ -1309,6 +1310,9 @@ rest_of_handle_loop2 (void)\n   if (loops)\n     {\n       /* The optimizations:  */\n+      if (flag_move_loop_invariants)\n+\tmove_loop_invariants (loops);\n+\n       if (flag_unswitch_loops)\n \tunswitch_loops (loops);\n \n@@ -1598,7 +1602,8 @@ rest_of_compilation (void)\n   if (flag_tracer)\n     rest_of_handle_tracer ();\n \n-  if (optimize > 0)\n+  if (optimize > 0\n+      && flag_loop_optimize2)\n     rest_of_handle_loop2 ();\n \n   if (flag_web)"}, {"sha": "1ce344cac9c15a64063105da22472cf3052302cd", "filename": "gcc/toplev.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e96277660887473bdc8b1953fcc35aedd092e3a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5e96277660887473bdc8b1953fcc35aedd092e3a", "patch": "@@ -1673,6 +1673,19 @@ process_options (void)\n   if (flag_unroll_loops || flag_peel_loops)\n     flag_rerun_cse_after_loop = 1;\n \n+  /* If explicitly asked to run new loop optimizer, switch off the old\n+     one.  */\n+  if (flag_loop_optimize2)\n+    flag_loop_optimize = 0;\n+\n+  /* Enable new loop optimizer pass if any of its optimizations is called.  */\n+  if (flag_move_loop_invariants\n+      || flag_unswitch_loops\n+      || flag_peel_loops\n+      || flag_unroll_loops\n+      || flag_branch_on_count_reg)\n+    flag_loop_optimize2 = 1;\n+\n   if (flag_non_call_exceptions)\n     flag_asynchronous_unwind_tables = 1;\n   if (flag_asynchronous_unwind_tables)"}]}