{"sha": "c6b84edb6110dd2b4fb654c53c0a9979e0532ffe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZiODRlZGI2MTEwZGQyYjRmYjY1NGM1M2MwYTk5NzllMDUzMmZmZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-05-20T12:01:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-05-20T12:01:40Z"}, "message": "tree-ssa-alias.c (compare_sizes): New function.\n\n\n\t* tree-ssa-alias.c (compare_sizes): New function.\n\t(sompare_type_sizes): New function\n\t(aliasing_component_refs_p): Use it.\n\t(indirect_ref_may_alias_decl_p): Likewise.\n\nFrom-SVN: r271413", "tree": {"sha": "42b513fce8418518fef5f4127c94b9d058cccc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42b513fce8418518fef5f4127c94b9d058cccc76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe/comments", "author": null, "committer": null, "parents": [{"sha": "58487c21b6a47c3fff6c6958684de866216a5593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58487c21b6a47c3fff6c6958684de866216a5593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58487c21b6a47c3fff6c6958684de866216a5593"}], "stats": {"total": 192, "additions": 135, "deletions": 57}, "files": [{"sha": "d0232f2cd6a996dde3d3e6072e54cd6f0ff44677", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6b84edb6110dd2b4fb654c53c0a9979e0532ffe", "patch": "@@ -1,3 +1,10 @@\n+2019-05-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (compare_sizes): New function.\n+\t(sompare_type_sizes): New function\n+\t(aliasing_component_refs_p): Use it.\n+\t(indirect_ref_may_alias_decl_p): Likewise.\n+\n 2019-05-20  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/i386/sol2.h (CC1_SPEC): Reject -mx32."}, {"sha": "0fa413ad5cad27ffa0375a0574fbc0dca2eb7174", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 128, "deletions": 57, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b84edb6110dd2b4fb654c53c0a9979e0532ffe/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c6b84edb6110dd2b4fb654c53c0a9979e0532ffe", "patch": "@@ -735,6 +735,48 @@ ao_ref_init_from_ptr_and_size (ao_ref *ref, tree ptr, tree size)\n   ref->volatile_p = false;\n }\n \n+/* S1 and S2 are TYPE_SIZE or DECL_SIZE.  Compare them:\n+   Return -1 if S1 < S2\n+   Return 1 if S1 > S2\n+   Return 0 if equal or incomparable.  */\n+\n+static int\n+compare_sizes (tree s1, tree s2)\n+{\n+  if (!s1 || !s2)\n+    return 0;\n+\n+  poly_uint64 size1 = poly_int_tree_p (s1, &size1);\n+  poly_uint64 size2 = poly_int_tree_p (s2, &size2);\n+\n+  if (!poly_int_tree_p (s1, &size1) || !poly_int_tree_p (s2, &size2))\n+    return 0;\n+  if (known_lt (size1, size2))\n+    return -1;\n+  if (known_lt (size2, size1))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Compare TYPE1 and TYPE2 by its size.\n+   Return -1 if size of TYPE1 < size of TYPE2\n+   Return 1 if size of TYPE1 > size of TYPE2\n+   Return 0 if types are of equal sizes or we can not compare them.  */\n+\n+static int\n+compare_type_sizes (tree type1, tree type2)\n+{\n+  /* Be conservative for arrays and vectors.  We want to support partial\n+     overlap on int[3] and int[3] as tested in gcc.dg/torture/alias-2.c.  */\n+  while (TREE_CODE (type1) == ARRAY_TYPE\n+\t || TREE_CODE (type1) == VECTOR_TYPE)\n+    type1 = TREE_TYPE (type1);\n+  while (TREE_CODE (type2) == ARRAY_TYPE\n+\t || TREE_CODE (type2) == VECTOR_TYPE)\n+    type2 = TREE_TYPE (type2);\n+  return compare_sizes (TYPE_SIZE (type1), TYPE_SIZE (type2));\n+}\n+\n /* Return 1 if TYPE1 and TYPE2 are to be considered equivalent for the\n    purpose of TBAA.  Return 0 if they are distinct and -1 if we cannot\n    decide.  */\n@@ -803,7 +845,7 @@ aliasing_component_refs_p (tree ref1,\n   tree base1, base2;\n   tree type1, type2;\n   tree *refp;\n-  int same_p, same_p2;\n+  int same_p1 = 0, same_p2 = 0;\n \n   /* Choose bases and base types to search for.  */\n   base1 = ref1;\n@@ -816,82 +858,114 @@ aliasing_component_refs_p (tree ref1,\n   type2 = TREE_TYPE (base2);\n \n   /* Now search for the type1 in the access path of ref2.  This\n-     would be a common base for doing offset based disambiguation on.  */\n-  refp = &ref2;\n-  while (handled_component_p (*refp)\n-\t && same_type_for_tbaa (TREE_TYPE (*refp), type1) == 0)\n-    refp = &TREE_OPERAND (*refp, 0);\n-  same_p = same_type_for_tbaa (TREE_TYPE (*refp), type1);\n-  if (same_p == 1)\n+     would be a common base for doing offset based disambiguation on.\n+     This however only makes sense if type2 is big enough to hold type1.  */\n+  int cmp_outer = compare_type_sizes (type2, type1);\n+  if (cmp_outer >= 0)\n     {\n-      poly_int64 offadj, sztmp, msztmp;\n-      bool reverse;\n-      get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n-      offset2 -= offadj;\n-      get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n-      offset1 -= offadj;\n-      if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+      refp = &ref2;\n+      while (true)\n \t{\n-\t  ++alias_stats.aliasing_component_refs_p_may_alias;\n-\t  return true;\n+\t  /* We walk from inner type to the outer types. If type we see is\n+\t     already too large to be part of type1, terminate the search.  */\n+\t  int cmp = compare_type_sizes (type1, TREE_TYPE (*refp));\n+\t  if (cmp < 0)\n+\t    break;\n+\t  /* If types may be of same size, see if we can decide about their\n+\t     equality.  */\n+\t  if (cmp >= 0)\n+\t    {\n+\t      same_p2 = same_type_for_tbaa (TREE_TYPE (*refp), type1);\n+\t      if (same_p2 != 0)\n+\t\tbreak;\n+\t    }\n+\t  if (!handled_component_p (*refp))\n+\t    break;\n+\t  refp = &TREE_OPERAND (*refp, 0);\n \t}\n-      else\n+      if (same_p2 == 1)\n \t{\n-\t  ++alias_stats.aliasing_component_refs_p_no_alias;\n-\t  return false;\n+\t  poly_int64 offadj, sztmp, msztmp;\n+\t  bool reverse;\n+\t  get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n+\t  offset2 -= offadj;\n+\t  get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n+\t  offset1 -= offadj;\n+\t  if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+\t    {\n+\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      ++alias_stats.aliasing_component_refs_p_no_alias;\n+\t      return false;\n+\t    }\n \t}\n     }\n \n   /* If we didn't find a common base, try the other way around.  */\n-  refp = &ref1;\n-  while (handled_component_p (*refp)\n-\t && same_type_for_tbaa (TREE_TYPE (*refp), type2) == 0)\n-    refp = &TREE_OPERAND (*refp, 0);\n-  same_p2 = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n-  if (same_p2 == 1)\n+  if (cmp_outer <= 0)\n     {\n-      poly_int64 offadj, sztmp, msztmp;\n-      bool reverse;\n-\n-      get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n-      offset1 -= offadj;\n-      get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n-      offset2 -= offadj;\n-      if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+      refp = &ref1;\n+      while (true)\n \t{\n-\t  ++alias_stats.aliasing_component_refs_p_may_alias;\n-\t  return true;\n+\t  int cmp = compare_type_sizes (type2, TREE_TYPE (*refp));\n+\t  if (cmp < 0)\n+\t    break;\n+\t  /* If types may be of same size, see if we can decide about their\n+\t     equality.  */\n+\t  if (cmp >= 0)\n+\t    {\n+\t      same_p1 = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n+\t      if (same_p1 != 0)\n+\t\tbreak;\n+\t    }\n+\t  if (!handled_component_p (*refp))\n+\t    break;\n+\t  refp = &TREE_OPERAND (*refp, 0);\n \t}\n-      else\n+      if (same_p1 == 1)\n \t{\n-\t  ++alias_stats.aliasing_component_refs_p_no_alias;\n-\t  return false;\n+\t  poly_int64 offadj, sztmp, msztmp;\n+\t  bool reverse;\n+\n+\t  get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n+\t  offset1 -= offadj;\n+\t  get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n+\t  offset2 -= offadj;\n+\t  if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+\t    {\n+\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      ++alias_stats.aliasing_component_refs_p_no_alias;\n+\t      return false;\n+\t    }\n \t}\n     }\n \n-  /* In the remaining test we assume that there is no overlapping type\n-     at all.  So if we are unsure, we need to give up.  */\n-  if (same_p == -1 || same_p2 == -1)\n-    {\n-      ++alias_stats.aliasing_component_refs_p_may_alias;\n-      return true;\n-    }\n-\n   /* If we have two type access paths B1.path1 and B2.path2 they may\n      only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n      But we can still have a path that goes B1.path1...B2.path2 with\n      a part that we do not see.  So we can only disambiguate now\n      if there is no B2 in the tail of path1 and no B1 on the\n      tail of path2.  */\n-  if (base1_alias_set == ref2_alias_set\n-      || alias_set_subset_of (base1_alias_set, ref2_alias_set))\n+  if (compare_type_sizes (TREE_TYPE (ref2), type1) >= 0\n+      && (same_p2 == -1\n+          || base1_alias_set == ref2_alias_set\n+          || alias_set_subset_of (base1_alias_set, ref2_alias_set)))\n     {\n       ++alias_stats.aliasing_component_refs_p_may_alias;\n       return true;\n     }\n   /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n   if (!ref2_is_decl\n-      && (base2_alias_set == ref1_alias_set\n+      && compare_type_sizes (TREE_TYPE (ref1), type2) >= 0\n+      && (same_p1 == -1\n+\t  || base2_alias_set == ref1_alias_set\n \t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n     {\n       ++alias_stats.aliasing_component_refs_p_may_alias;\n@@ -1221,16 +1295,13 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   /* If the size of the access relevant for TBAA through the pointer\n      is bigger than the size of the decl we can't possibly access the\n      decl via that pointer.  */\n-  if (DECL_SIZE (base2) && COMPLETE_TYPE_P (TREE_TYPE (ptrtype1))\n-      && poly_int_tree_p (DECL_SIZE (base2))\n-      && poly_int_tree_p (TYPE_SIZE (TREE_TYPE (ptrtype1)))\n-      /* ???  This in turn may run afoul when a decl of type T which is\n+  if (/* ???  This in turn may run afoul when a decl of type T which is\n \t a member of union type U is accessed through a pointer to\n \t type U and sizeof T is smaller than sizeof U.  */\n-      && TREE_CODE (TREE_TYPE (ptrtype1)) != UNION_TYPE\n+      TREE_CODE (TREE_TYPE (ptrtype1)) != UNION_TYPE\n       && TREE_CODE (TREE_TYPE (ptrtype1)) != QUAL_UNION_TYPE\n-      && known_lt (wi::to_poly_widest (DECL_SIZE (base2)),\n-\t\t   wi::to_poly_widest (TYPE_SIZE (TREE_TYPE (ptrtype1)))))\n+      && compare_sizes (DECL_SIZE (base2),\n+\t\t        TYPE_SIZE (TREE_TYPE (ptrtype1))) < 0)\n     return false;\n \n   if (!ref2)"}]}