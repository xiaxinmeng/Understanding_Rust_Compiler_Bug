{"sha": "64b8935d4809f32734fa7abe9353fc159adacbfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRiODkzNWQ0ODA5ZjMyNzM0ZmE3YWJlOTM1M2ZjMTU5YWRhY2JmZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-30T13:02:36Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-30T13:02:36Z"}, "message": "combine.c: Include \"output.h\" to define dump_file.\n\n\n\t* combine.c: Include \"output.h\" to define dump_file.\n\t(uid_insn_cost, last_insn_cost): New global variables.\n\t(combine_insn_cost): New function to estimate cost of an insn.\n\t(combine_validate_cost): New function to determine whether a\n\ttry_combine replacement sequence is cheaper than the original.\n\t(combine_instructions): Allocate and populate uid_insn_cost\n\tarray at the start of the combine pass, and deallocate it after.\n\t(try_combine): Check combine_validate_cost to determine whether\n\ta \"recombination\" should be rejected as being more expensive.\n\t* Makefile.in (combine.o): Add dependency upon output.h.\n\nFrom-SVN: r83908", "tree": {"sha": "64ab0426be79b2945213d9e8b897ba885a6fec73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64ab0426be79b2945213d9e8b897ba885a6fec73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64b8935d4809f32734fa7abe9353fc159adacbfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b8935d4809f32734fa7abe9353fc159adacbfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b8935d4809f32734fa7abe9353fc159adacbfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b8935d4809f32734fa7abe9353fc159adacbfd/comments", "author": null, "committer": null, "parents": [{"sha": "e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e"}], "stats": {"total": 179, "additions": 176, "deletions": 3}, "files": [{"sha": "86bb7fa288353b880ca51f8706423e0306737c48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b8935d4809f32734fa7abe9353fc159adacbfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b8935d4809f32734fa7abe9353fc159adacbfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64b8935d4809f32734fa7abe9353fc159adacbfd", "patch": "@@ -1,3 +1,16 @@\n+2004-06-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* combine.c: Include \"output.h\" to define dump_file.\n+\t(uid_insn_cost, last_insn_cost): New global variables.\n+\t(combine_insn_cost): New function to estimate cost of an insn.\n+\t(combine_validate_cost): New function to determine whether a\n+\ttry_combine replacement sequence is cheaper than the original.\n+\t(combine_instructions): Allocate and populate uid_insn_cost\n+\tarray at the start of the combine pass, and deallocate it after.\n+\t(try_combine): Check combine_validate_cost to determine whether\n+\ta \"recombination\" should be rejected as being more expensive.\n+\t* Makefile.in (combine.o): Add dependency upon output.h.\n+\n 2004-06-30  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/rs6000/rs6000.c (rs6000_rtx_costs) <MINUS_EXPR>: Handle"}, {"sha": "35dcb4fed5f11b76fc1c744e89bccb24a63523f6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b8935d4809f32734fa7abe9353fc159adacbfd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b8935d4809f32734fa7abe9353fc159adacbfd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=64b8935d4809f32734fa7abe9353fc159adacbfd", "patch": "@@ -1973,9 +1973,10 @@ loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h\n-combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n-   function.h insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) rtlhooks-def.h \\\n-   $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H) $(TREE_H) $(TARGET_H)\n+combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(FLAGS_H) function.h insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n+   rtlhooks-def.h $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h \\\n+   toplev.h $(TM_P_H) $(TREE_H) $(TARGET_H) output.h\n regclass.o : regclass.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(RECOG_H) reload.h \\\n    real.h toplev.h function.h output.h $(GGC_H) $(TM_P_H) $(EXPR_H) $(TIMEVAR_H)"}, {"sha": "52c500ae7f1ad51b3143f7b42778e9d4d50e6baf", "filename": "gcc/combine.c", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64b8935d4809f32734fa7abe9353fc159adacbfd/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64b8935d4809f32734fa7abe9353fc159adacbfd/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=64b8935d4809f32734fa7abe9353fc159adacbfd", "patch": "@@ -91,6 +91,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"target.h\"\n #include \"rtlhooks-def.h\"\n+/* Include output.h for dump_file.  */\n+#include \"output.h\"\n \n /* Number of attempts to combine instructions in this function.  */\n \n@@ -282,6 +284,15 @@ static basic_block this_basic_block;\n    those blocks as starting points.  */\n static sbitmap refresh_blocks;\n \f\n+/* The following array records the combine_insn_cost for every insn\n+   in the instruction stream.  */\n+\n+static int *uid_insn_cost;\n+\n+/* Length of the currently allocated uid_insn_cost array.  */\n+\n+static int last_insn_cost;\n+\n /* Incremented for each label.  */\n \n static int label_tick;\n@@ -504,6 +515,135 @@ do_SUBST_INT (int *into, int newval)\n \n #define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n \f\n+/* Calculate the rtx_cost of a single instruction.  A return value of zero\n+   indicates an instruction without a known cost.  */\n+\n+static int\n+combine_insn_cost (rtx pat)\n+{\n+  int i, cost;\n+  rtx set;\n+\n+  /* Extract the single set rtx from the instruction pattern.\n+     We can't use single_set since we only have the pattern.  */\n+  if (GET_CODE (pat) == SET)\n+    set = pat;\n+  else if (GET_CODE (pat) == PARALLEL)\n+    {\n+      set = NULL_RTX;\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx x = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (x) == SET)\n+\t    {\n+\t      if (set)\n+\t\treturn 0;\n+\t      set = x;\n+\t    }\n+\t}\n+      if (!set)\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  cost = rtx_cost (SET_SRC (set), SET);\n+  return cost > 0 ? cost : COSTS_N_INSNS (1);\n+}\n+\n+/* Subroutine of try_combine.  Determine whether the combine replacement\n+   patterns NEWPAT and NEWI2PAT are cheaper according to combine_insn_cost\n+   that the original instruction sequence I1, I2 and I3.  Note that I1\n+   and/or NEWI2PAT may be NULL_RTX.  This function returns false, if the\n+   costs of all instructions can be estimated, and the replacements are\n+   more expensive than the original sequence.  */\n+\n+static bool\n+combine_validate_cost (rtx i1, rtx i2, rtx i3, rtx newpat, rtx newi2pat)\n+{\n+  int i1_cost, i2_cost, i3_cost;\n+  int new_i2_cost, new_i3_cost;\n+  int old_cost, new_cost;\n+\n+  /* Lookup the original combine_insn_costs.  */\n+  i2_cost = INSN_UID (i2) <= last_insn_cost\n+\t    ? uid_insn_cost[INSN_UID (i2)] : 0;\n+  i3_cost = INSN_UID (i3) <= last_insn_cost\n+\t    ? uid_insn_cost[INSN_UID (i3)] : 0;\n+\n+  if (i1)\n+    {\n+      i1_cost = INSN_UID (i1) <= last_insn_cost\n+\t\t? uid_insn_cost[INSN_UID (i1)] : 0;\n+      old_cost = (i1_cost > 0 && i2_cost > 0 && i3_cost > 0)\n+\t\t ? i1_cost + i2_cost + i3_cost : 0;\n+    }\n+  else\n+    {\n+      old_cost = (i2_cost > 0 && i3_cost > 0) ? i2_cost + i3_cost : 0;\n+      i1_cost = 0;\n+    }\n+\n+  /* Calculate the replacement combine_insn_costs.  */\n+  new_i3_cost = combine_insn_cost (newpat);\n+  if (newi2pat)\n+    {\n+      new_i2_cost = combine_insn_cost (newi2pat);\n+      new_cost = (new_i2_cost > 0 && new_i3_cost > 0)\n+\t\t ? new_i2_cost + new_i3_cost : 0;\n+    }\n+  else\n+    {\n+      new_cost = new_i3_cost;\n+      new_i2_cost = 0;\n+    }\n+\n+  /* Disallow this recombination if both new_cost and old_cost are\n+     greater than zero, and new_cost is greater than old cost.  */\n+  if (!undobuf.other_insn\n+      && old_cost > 0\n+      && new_cost > old_cost)\n+    {\n+      if (dump_file)\n+\t{\n+\t  if (i1)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"rejecting combination of insns %d, %d and %d\\n\",\n+\t\t       INSN_UID (i1), INSN_UID (i2), INSN_UID (i3));\n+\t      fprintf (dump_file, \"original costs %d + %d + %d = %d\\n\",\n+\t\t       i1_cost, i2_cost, i3_cost, old_cost);\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"rejecting combination of insns %d and %d\\n\",\n+\t\t       INSN_UID (i2), INSN_UID (i3));\n+\t      fprintf (dump_file, \"original costs %d + %d = %d\\n\",\n+\t\t       i2_cost, i3_cost, old_cost);\n+\t    }\n+\n+\t  if (newi2pat)\n+\t    {\n+\t      fprintf (dump_file, \"replacement costs %d + %d = %d\\n\",\n+\t\t       new_i2_cost, new_i3_cost, new_cost);\n+\t    }\n+\t  else\n+\t    fprintf (dump_file, \"replacement cost %d\\n\", new_cost);\n+\t}\n+\n+      return false;\n+    }\n+\n+  /* Update the uid_insn_cost array with the replacement costs.  */\n+  uid_insn_cost[INSN_UID (i2)] = new_i2_cost;\n+  uid_insn_cost[INSN_UID (i3)] = new_i3_cost;\n+  if (i1)\n+    uid_insn_cost[INSN_UID (i1)] = 0;\n+\n+  return true;\n+}\n+\f\n /* Main entry point for combiner.  F is the first insn of the function.\n    NREGS is the first unused pseudo-reg number.\n \n@@ -568,6 +708,10 @@ combine_instructions (rtx f, unsigned int nregs)\n   refresh_blocks = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (refresh_blocks);\n \n+  /* Allocate array of current combine_insn_costs.  */\n+  uid_insn_cost = xcalloc (max_uid_cuid + 1, sizeof (int));\n+  last_insn_cost = max_uid_cuid;\n+\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       uid_cuid[INSN_UID (insn)] = ++i;\n@@ -586,6 +730,12 @@ combine_instructions (rtx f, unsigned int nregs)\n \t      set_nonzero_bits_and_sign_copies (XEXP (links, 0), NULL_RTX,\n \t\t\t\t\t\tNULL);\n #endif\n+\n+\t  /* Record the current combine_insn_cost of this instruction.  */\n+\t  uid_insn_cost[INSN_UID (insn)] = combine_insn_cost (PATTERN (insn));\n+\t  if (dump_file)\n+\t    fprintf(dump_file, \"insn_cost %d: %d\\n\",\n+\t\t    INSN_UID (insn), uid_insn_cost[INSN_UID (insn)]);\n \t}\n \n       if (GET_CODE (insn) == CODE_LABEL)\n@@ -762,6 +912,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   /* Clean up.  */\n   sbitmap_free (refresh_blocks);\n+  free (uid_insn_cost);\n   free (reg_stat);\n   free (uid_cuid);\n \n@@ -2504,6 +2655,14 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n   }\n #endif\n \n+  /* Only allow this combination if combine_insn_costs reports that the\n+     replacement instructions are cheaper than the originals.  */\n+  if (!combine_validate_cost (i1, i2, i3, newpat, newi2pat))\n+    {\n+      undo_all ();\n+      return 0;\n+    }\n+\n   /* We now know that we can do this combination.  Merge the insns and\n      update the status of registers and LOG_LINKS.  */\n "}]}