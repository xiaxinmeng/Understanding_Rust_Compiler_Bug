{"sha": "af166e5d276114872596002803f7c300fc41a511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxNjZlNWQyNzYxMTQ4NzI1OTYwMDI4MDNmN2MzMDBmYzQxYTUxMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-06-26T07:52:10Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-06-26T07:52:10Z"}, "message": "value-prof.c: New.\n\n\t* value-prof.c: New.\n\t* value-prof.h: New.\n\t* Makefile.in (value-prof.o): New.\n\t(LIBGCOV): Add _gcov_merge_single and _gcov_merge_delta\n\t(profile.o): Add value-prof.h and tree.h dependency.\n\t* flags.h (flag_profile_values): Declare.\n\t* gcov-io.h (GCOV_COUNTERS, GCOV_COUNTER_NAMES, GCOV_MERGE_FUNCTIONS):\n\tAdd new counters.\n\t(GCOV_COUNTER_V_INTERVAL, GCOV_COUNTER_V_POW2, GCOV_COUNTER_V_SINGLE,\n\tGCOV_COUNTER_V_DELTA): New counter sections.\n\t(__gcov_merge_single, __gcov_merge_delta): Declare.\n\t* flow.c (mark_used_regs): Set subregs_of_mode only when the\n\tstructure is initialized.\n\t* libgcov.c (__gcov_merge_single, __gcov_merge_delta): New functions.\n\t* profile.c: Include value-prof.h and tree.h.\n\t(gen_interval_profiler, gen_pow2_profiler, gen_one_value_profiler,\n\tgen_const_delta_profiler, instrument_values): New static functions.\n\t(get_exec_counts): Fix comment.\n\t(branch_prob): Invoke instrument_values.\n\t* toplev.c (flag_profile_values): New flag.\n\t* doc/invoke.texi (-fprofile-values): Document.\n\nFrom-SVN: r68519", "tree": {"sha": "705173673c74024b0bd270eb542967036fde5a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/705173673c74024b0bd270eb542967036fde5a26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af166e5d276114872596002803f7c300fc41a511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af166e5d276114872596002803f7c300fc41a511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af166e5d276114872596002803f7c300fc41a511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af166e5d276114872596002803f7c300fc41a511/comments", "author": null, "committer": null, "parents": [{"sha": "ff25ef99762093b40198f4560cfd78a0e6e61ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff25ef99762093b40198f4560cfd78a0e6e61ffb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff25ef99762093b40198f4560cfd78a0e6e61ffb"}], "stats": {"total": 559, "additions": 543, "deletions": 16}, "files": [{"sha": "5c3911b60f52b81f7899c450f2297f32ae22a8c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -1,4 +1,28 @@\n-2003-06-24  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+2003-06-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* value-prof.c: New.\n+\t* value-prof.h: New.\n+\t* Makefile.in (value-prof.o): New.\n+\t(LIBGCOV): Add _gcov_merge_single and _gcov_merge_delta\n+\t(profile.o): Add value-prof.h and tree.h dependency.\n+\t* flags.h (flag_profile_values): Declare.\n+\t* gcov-io.h (GCOV_COUNTERS, GCOV_COUNTER_NAMES, GCOV_MERGE_FUNCTIONS):\n+\tAdd new counters.\n+\t(GCOV_COUNTER_V_INTERVAL, GCOV_COUNTER_V_POW2, GCOV_COUNTER_V_SINGLE,\n+\tGCOV_COUNTER_V_DELTA): New counter sections.\n+\t(__gcov_merge_single, __gcov_merge_delta): Declare.\n+\t* flow.c (mark_used_regs): Set subregs_of_mode only when the\n+\tstructure is initialized.\n+\t* libgcov.c (__gcov_merge_single, __gcov_merge_delta): New functions.\n+\t* profile.c: Include value-prof.h and tree.h.\n+\t(gen_interval_profiler, gen_pow2_profiler, gen_one_value_profiler,\n+\tgen_const_delta_profiler, instrument_values): New static functions.\n+\t(get_exec_counts): Fix comment.\n+\t(branch_prob): Invoke instrument_values.\n+\t* toplev.c (flag_profile_values): New flag.\n+\t* doc/invoke.texi (-fprofile-values): Document.\n+\n+2003-06-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* Makefile.in (cfgrtl.o): Add expr.h dependency.\n \t* cfgrtl.c: Include expr.h."}, {"sha": "c6c32ae4ab003b507039027b3ea95e380182cb4b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -814,7 +814,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t   \\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n  loop.o mbchar.o optabs.o options.o opts.o params.o predict.o\t\t   \\\n- print-rtl.o print-tree.o\t\t\t\t\t\t   \\\n+ print-rtl.o print-tree.o value-prof.o\t\t\t\t\t   \\\n  profile.o ra.o ra-build.o ra-colorize.o ra-debug.o ra-rewrite.o\t   \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n@@ -854,7 +854,7 @@ STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n LIB2FUNCS_ST = _eprintf __gcc_bcmp\n \n # Defined in libgcov.c, included only in gcov library\n-LIBGCOV = _gcov _gcov_merge_add\n+LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n@@ -1636,7 +1636,10 @@ conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H)\n    $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n-   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H)\n+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_H) value-prof.h\n+value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h flags.h \\\n+   $(RECOG_H) insn-config.h $(OPTABS_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h cfgloop.h \\"}, {"sha": "e7a3ea830fcdc918ab657c281e7dcae472981a29", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -191,6 +191,10 @@ extern int profile_flag;\n \n extern int profile_arc_flag;\n \n+/* Nonzero if value profile should be measured.  */\n+\n+extern int flag_profile_values;\n+\n /* Nonzero if generating info for gcov to calculate line test coverage.  */\n \n extern int flag_test_coverage;"}, {"sha": "b08a6e8e3318e9b56eb66a48c8a1d88ba859188d", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -3842,7 +3842,8 @@ mark_used_regs (pbi, x, cond, insn)\n \n     case SUBREG:\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n+      if ((flags & PROP_REG_INFO)\n+\t  && GET_CODE (SUBREG_REG (x)) == REG\n \t  && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n \tbitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (x))\n \t\t\t\t\t  * MAX_MACHINE_MODE\n@@ -3891,7 +3892,8 @@ mark_used_regs (pbi, x, cond, insn)\n \t       || GET_CODE (testreg) == SUBREG)\n \t  {\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t    if (GET_CODE (testreg) == SUBREG\n+\t    if ((flags & PROP_REG_INFO)\n+\t\t&& GET_CODE (testreg) == SUBREG\n \t\t&& GET_CODE (SUBREG_REG (testreg)) == REG\n \t\t&& REGNO (SUBREG_REG (testreg)) >= FIRST_PSEUDO_REGISTER)\n \t      bitmap_set_bit (&subregs_of_mode, REGNO (SUBREG_REG (testreg))"}, {"sha": "769fd8a276f30cf581da3a9a27c98a92e03d31ca", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -269,14 +269,24 @@ typedef HOST_WIDEST_INT gcov_type;\n #define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n #define GCOV_COUNTERS_SUMMABLE\t1  /* Counters which can be\n \t\t\t\t      summaried.  */\n-#define GCOV_COUNTERS\t\t1\n-\n-/* A list of human readable names of the counters */\n-#define GCOV_COUNTER_NAMES\t{\"arcs\"}\n-\n-/* Names of merge functions for counters.  */\n-#define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\"}\n-\n+#define GCOV_COUNTER_V_INTERVAL\t1  /* Histogram of value inside an interval.  */\n+#define GCOV_COUNTER_V_POW2\t2  /* Histogram of exact power2 logarithm\n+\t\t\t\t      of a value.  */\n+#define GCOV_COUNTER_V_SINGLE\t3  /* The most common value of expression.  */\n+#define GCOV_COUNTER_V_DELTA\t4  /* The most common difference between\n+\t\t\t\t      consecutive values of expression.  */\n+#define GCOV_COUNTERS\t\t5\n+  \n+  /* A list of human readable names of the counters */\n+#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \"delta\"}\n+  \n+  /* Names of merge functions for counters.  */\n+#define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n+\t\t\t\t \"__gcov_merge_add\",\t\\\n+\t\t\t\t \"__gcov_merge_add\",\t\\\n+\t\t\t\t \"__gcov_merge_single\",\t\\\n+\t\t\t\t \"__gcov_merge_delta\"}\n+  \n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))\n@@ -380,6 +390,13 @@ extern void __gcov_flush (void);\n \n /* The merge function that just sums the counters.  */\n extern void __gcov_merge_add (gcov_type *, unsigned);\n+\n+/* The merge function to choose the most often value.  */\n+extern void __gcov_merge_single (gcov_type *, unsigned);\n+\n+/* The merge function to choose the most often difference between consecutive\n+   values.  */\n+extern void __gcov_merge_delta (gcov_type *, unsigned);\n #endif /* IN_LIBGCOV */\n \n #if IN_LIBGCOV >= 0"}, {"sha": "5396c395bf2a99cd6048c4d6ffa0f25d40630041", "filename": "gcc/libgcov.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -63,6 +63,16 @@ void __gcov_merge_add (gcov_type *counters  __attribute__ ((unused)),\n \t\t       unsigned n_counters __attribute__ ((unused))) {}\n #endif\n \n+#ifdef L_gcov_merge_single\n+void __gcov_merge_single (gcov_type *counters  __attribute__ ((unused)),\n+\t\t\t  unsigned n_counters __attribute__ ((unused))) {}\n+#endif\n+\n+#ifdef L_gcov_merge_delta\n+void __gcov_merge_delta (gcov_type *counters  __attribute__ ((unused)),\n+\t\t\t unsigned n_counters __attribute__ ((unused))) {}\n+#endif\n+\n #else\n \n #include <string.h>\n@@ -466,4 +476,83 @@ __gcov_merge_add (gcov_type *counters, unsigned n_counters)\n }\n #endif /* L_gcov_merge_add */\n \n+#ifdef L_gcov_merge_single\n+/* The profile merging function for choosing the most common value.  It is given\n+   an array COUNTERS of N_COUNTERS old counters and it reads the same number\n+   of counters from the gcov file.  The counters are split into 3-tuples\n+   where the members of the tuple have meanings:\n+   -- the stored candidate on the most common value of the measured entity\n+   -- counter\n+   -- total number of evaluations of the value  */\n+void\n+__gcov_merge_single (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned i, n_measures;\n+  gcov_type value, counter, all;\n+\n+  if (n_counters % 3)\n+    abort ();\n+\n+  n_measures = n_counters / 3;\n+  for (i = 0; i < n_measures; i++, counters += 3)\n+    {\n+      value = gcov_read_counter ();\n+      counter = gcov_read_counter ();\n+      all = gcov_read_counter ();\n+\n+      if (counters[0] == value)\n+\tcounters[1] += counter;\n+      else if (counter > counters[1])\n+\t{\n+\t  counters[0] = value;\n+\t  counters[1] = counter - counters[1];\n+\t}\n+      else\n+\tcounters[1] -= counter;\n+      counters[2] += all;\n+    }\n+}\n+#endif /* L_gcov_merge_single */\n+\n+#ifdef L_gcov_merge_delta\n+/* The profile merging function for choosing the most common difference between\n+   two consecutive evaluations of the value.  It is given an array COUNTERS of\n+   N_COUNTERS old counters and it reads the same number of counters from the\n+   gcov file.  The counters are split into 4-tuples where the members of the\n+   tuple have meanings:\n+   -- the last value of the measured entity\n+   -- the stored candidate on the most common difference\n+   -- counter\n+   -- total number of evaluations of the value  */\n+void\n+__gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned i, n_measures;\n+  gcov_type last, value, counter, all;\n+\n+  if (n_counters % 4)\n+    abort ();\n+\n+  n_measures = n_counters / 4;\n+  for (i = 0; i < n_measures; i++, counters += 4)\n+    {\n+      last = gcov_read_counter ();\n+      value = gcov_read_counter ();\n+      counter = gcov_read_counter ();\n+      all = gcov_read_counter ();\n+\n+      if (counters[1] == value)\n+\tcounters[2] += counter;\n+      else if (counter > counters[2])\n+\t{\n+\t  counters[1] = value;\n+\t  counters[2] = counter - counters[2];\n+\t}\n+      else\n+\tcounters[2] -= counter;\n+      counters[3] += all;\n+    }\n+}\n+#endif /* L_gcov_merge_delta */\n+\n #endif /* inhibit_libc */"}, {"sha": "2140a0fed30fc6871a13c92ff6697f78066537c1", "filename": "gcc/profile.c", "status": "modified", "additions": 384, "deletions": 2, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -60,6 +60,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"coverage.h\"\n+#include \"value-prof.h\"\n+#include \"tree.h\"\n \n /* Additional information about the edges we need.  */\n struct edge_info {\n@@ -105,7 +107,12 @@ static int total_num_branches;\n /* Forward declarations.  */\n static void find_spanning_tree PARAMS ((struct edge_list *));\n static rtx gen_edge_profiler PARAMS ((int));\n+static rtx gen_interval_profiler (struct histogram_value *, unsigned, unsigned);\n+static rtx gen_pow2_profiler (struct histogram_value *, unsigned, unsigned);\n+static rtx gen_one_value_profiler (struct histogram_value *, unsigned, unsigned);\n+static rtx gen_const_delta_profiler (struct histogram_value *, unsigned, unsigned);\n static unsigned instrument_edges PARAMS ((struct edge_list *));\n+static void instrument_values (unsigned, struct histogram_value *);\n static void compute_branch_probabilities PARAMS ((void));\n static gcov_type * get_exec_counts PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n@@ -157,10 +164,73 @@ instrument_edges (el)\n     fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n   return num_instr_edges;\n }\n+\n+/* Add code to measure histograms list of VALUES of length N_VALUES.  */\n+static void\n+instrument_values (unsigned n_values, struct histogram_value *values)\n+{\n+  rtx sequence;\n+  unsigned i, t;\n+  edge e;\n+ \n+  /* Emit code to generate the histograms before the insns.  */\n+\n+  for (i = 0; i < n_values; i++)\n+    {\n+      e = split_block (BLOCK_FOR_INSN (values[i].insn),\n+\t\t       PREV_INSN (values[i].insn));\n+      switch (values[i].type)\n+\t{\n+\tcase HIST_TYPE_INTERVAL:\n+\t  t = GCOV_COUNTER_V_INTERVAL;\n+\t  break;\n+\n+\tcase HIST_TYPE_POW2:\n+\t  t = GCOV_COUNTER_V_POW2;\n+\t  break;\n+\n+\tcase HIST_TYPE_SINGLE_VALUE:\n+\t  t = GCOV_COUNTER_V_SINGLE;\n+\t  break;\n+\n+\tcase HIST_TYPE_CONST_DELTA:\n+\t  t = GCOV_COUNTER_V_DELTA;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      if (!coverage_counter_alloc (t, values[i].n_counters))\n+\tcontinue;\n+\n+      switch (values[i].type)\n+\t{\n+\tcase HIST_TYPE_INTERVAL:\n+\t  sequence = gen_interval_profiler (values + i, t, 0);\n+\t  break;\n+\n+\tcase HIST_TYPE_POW2:\n+\t  sequence = gen_pow2_profiler (values + i, t, 0);\n+\t  break;\n+\n+\tcase HIST_TYPE_SINGLE_VALUE:\n+\t  sequence = gen_one_value_profiler (values + i, t, 0);\n+\t  break;\n+\n+\tcase HIST_TYPE_CONST_DELTA:\n+\t  sequence = gen_const_delta_profiler (values + i, t, 0);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      safe_insert_insn_on_edge (sequence, e);\n+    }\n+}\n \f\n \n-/* Computes hybrid profile for all matching entries in da_file.\n-   Sets max_counter_in_program as a side effect.  */\n+/* Computes hybrid profile for all matching entries in da_file.  */\n \n static gcov_type *\n get_exec_counts ()\n@@ -553,6 +623,8 @@ branch_prob ()\n   unsigned num_edges, ignored_edges;\n   unsigned num_instrumented;\n   struct edge_list *el;\n+  unsigned n_values = 0;\n+  struct histogram_value *values = NULL;\n \n   total_num_times_called++;\n \n@@ -804,6 +876,13 @@ branch_prob ()\n   EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n #undef BB_TO_GCOV_INDEX\n \n+  if (flag_profile_values)\n+    {\n+      life_analysis (get_insns (), NULL, PROP_DEATH_NOTES);\n+      find_values_to_profile (&n_values, &values);\n+      allocate_reg_info (max_reg_num (), FALSE, FALSE);\n+    }\n+\n   if (flag_branch_probabilities)\n     compute_branch_probabilities ();\n \n@@ -816,11 +895,16 @@ branch_prob ()\n       if (n_instrumented != num_instrumented)\n \tabort ();\n \n+      if (flag_profile_values)\n+\tinstrument_values (n_values, values);\n+\n       /* Commit changes done by instrumentation.  */\n       commit_edge_insertions_watch_calls ();\n       allocate_reg_info (max_reg_num (), FALSE, FALSE);\n     }\n \n+  if (flag_profile_values)\n+    count_or_remove_death_notes (NULL, 1);\n   remove_fake_edges ();\n   free_aux_for_edges ();\n   /* Re-merge split basic blocks and the mess introduced by\n@@ -1029,3 +1113,301 @@ gen_edge_profiler (edgeno)\n   end_sequence ();\n   return sequence;\n }\n+\n+/* Output instructions as RTL to increment the interval histogram counter.\n+   VALUE is the expression whose value is profiled.  TAG is the tag of the\n+   section for counters, BASE is offset of the counter position.  */\n+\n+static rtx\n+gen_interval_profiler (struct histogram_value *value,\n+\t\t       unsigned tag, unsigned base)\n+{\n+  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n+  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n+  rtx mem_ref, tmp, tmp1, mr, val;\n+  rtx sequence;\n+  rtx more_label = gen_label_rtx ();\n+  rtx less_label = gen_label_rtx ();\n+  rtx end_of_code_label = gen_label_rtx ();\n+  int per_counter = gcov_size / BITS_PER_UNIT;\n+\n+  start_sequence ();\n+\n+  if (value->seq)\n+    emit_insn (value->seq);\n+\n+  mr = gen_reg_rtx (Pmode);\n+\n+  tmp = coverage_counter_ref (tag, base);\n+  tmp = force_reg (Pmode, XEXP (tmp, 0));\n+\n+  val = expand_simple_binop (value->mode, MINUS,\n+\t\t\t     copy_rtx (value->value),\n+\t\t\t     GEN_INT (value->hdata.intvl.int_start),\n+\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n+\n+  if (value->hdata.intvl.may_be_more)\n+    do_compare_rtx_and_jump (copy_rtx (val), GEN_INT (value->hdata.intvl.steps),\n+\t\t\t     GE, 0, value->mode, NULL_RTX, NULL_RTX, more_label);\n+  if (value->hdata.intvl.may_be_less)\n+    do_compare_rtx_and_jump (copy_rtx (val), const0_rtx, LT, 0, value->mode,\n+\t\t\t     NULL_RTX, NULL_RTX, less_label);\n+\n+  /* We are in range.  */\n+  tmp1 = expand_simple_binop (value->mode, MULT,\n+\t\t\t      copy_rtx (val), GEN_INT (per_counter),\n+\t\t\t      NULL_RTX, 0, OPTAB_WIDEN);\n+  tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp), tmp1, mr,\n+\t\t\t      0, OPTAB_WIDEN);\n+  if (tmp1 != mr)\n+    emit_move_insn (copy_rtx (mr), tmp1);\n+\n+  if (value->hdata.intvl.may_be_more\n+      || value->hdata.intvl.may_be_less)\n+    {\n+      emit_jump_insn (gen_jump (end_of_code_label));\n+      emit_barrier ();\n+    }\n+\n+  /* Above the interval.  */\n+  if (value->hdata.intvl.may_be_more)\n+    {\n+      emit_label (more_label);\n+      tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n+\t\t\t\t  GEN_INT (per_counter * value->hdata.intvl.steps),\n+    \t\t\t\t  mr, 0, OPTAB_WIDEN);\n+      if (tmp1 != mr)\n+\temit_move_insn (copy_rtx (mr), tmp1);\n+      if (value->hdata.intvl.may_be_less)\n+\t{\n+\t  emit_jump_insn (gen_jump (end_of_code_label));\n+\t  emit_barrier ();\n+\t}\n+    }\n+\n+  /* Below the interval.  */\n+  if (value->hdata.intvl.may_be_less)\n+    {\n+      emit_label (less_label);\n+      tmp1 = expand_simple_binop (Pmode, PLUS, copy_rtx (tmp),\n+\t\tGEN_INT (per_counter * (value->hdata.intvl.steps\n+\t\t\t\t\t+ (value->hdata.intvl.may_be_more ? 1 : 0))),\n+\t\tmr, 0, OPTAB_WIDEN);\n+      if (tmp1 != mr)\n+\temit_move_insn (copy_rtx (mr), tmp1);\n+    }\n+\n+  if (value->hdata.intvl.may_be_more\n+      || value->hdata.intvl.may_be_less)\n+    emit_label (end_of_code_label);\n+\n+  mem_ref = validize_mem (gen_rtx_MEM (mode, mr));\n+\n+  tmp = expand_simple_binop (mode, PLUS, copy_rtx (mem_ref), const1_rtx,\n+\t\t\t     mem_ref, 0, OPTAB_WIDEN);\n+\n+  if (tmp != mem_ref)\n+    emit_move_insn (copy_rtx (mem_ref), tmp);\n+\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}\n+\n+/* Output instructions as RTL to increment the power of two histogram counter.\n+   VALUE is the expression whose value is profiled.  TAG is the tag of the\n+   section for counters, BASE is offset of the counter position.  */\n+\n+static rtx\n+gen_pow2_profiler (struct histogram_value *value,\n+\t\t   unsigned tag, unsigned base)\n+{\n+  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n+  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n+  rtx mem_ref, tmp, mr, uval;\n+  rtx sequence;\n+  rtx end_of_code_label = gen_label_rtx ();\n+  rtx loop_label = gen_label_rtx ();\n+  int per_counter = gcov_size / BITS_PER_UNIT;\n+\n+  start_sequence ();\n+\n+  if (value->seq)\n+    emit_insn (value->seq);\n+\n+  mr = gen_reg_rtx (Pmode);\n+  tmp = coverage_counter_ref (tag, base);\n+  tmp = force_reg (Pmode, XEXP (tmp, 0));\n+  emit_move_insn (mr, tmp);\n+\n+  uval = gen_reg_rtx (value->mode);\n+  emit_move_insn (uval, copy_rtx (value->value));\n+\n+  /* Check for non-power of 2.  */\n+  if (value->hdata.pow2.may_be_other)\n+    {\n+      do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, LE, 0, value->mode,\n+\t\t\t       NULL_RTX, NULL_RTX, end_of_code_label);\n+      tmp = expand_simple_binop (value->mode, PLUS, copy_rtx (uval),\n+\t\t\t\t constm1_rtx, NULL_RTX, 0, OPTAB_WIDEN);\n+      tmp = expand_simple_binop (value->mode, AND, copy_rtx (uval), tmp,\n+\t\t\t\t NULL_RTX, 0, OPTAB_WIDEN);\n+      do_compare_rtx_and_jump (tmp, const0_rtx, NE, 0, value->mode, NULL_RTX,\n+    \t\t\t       NULL_RTX, end_of_code_label);\n+    }\n+\n+  /* Count log_2(value).  */\n+  emit_label (loop_label);\n+\n+  tmp = expand_simple_binop (Pmode, PLUS, copy_rtx (mr), GEN_INT (per_counter), mr, 0, OPTAB_WIDEN);\n+  if (tmp != mr)\n+    emit_move_insn (copy_rtx (mr), tmp);\n+\n+  tmp = expand_simple_binop (value->mode, ASHIFTRT, copy_rtx (uval), const1_rtx,\n+\t\t\t     uval, 0, OPTAB_WIDEN);\n+  if (tmp != uval)\n+    emit_move_insn (copy_rtx (uval), tmp);\n+\n+  do_compare_rtx_and_jump (copy_rtx (uval), const0_rtx, NE, 0, value->mode,\n+\t\t\t   NULL_RTX, NULL_RTX, loop_label);\n+\n+  /* Increase the counter.  */\n+  emit_label (end_of_code_label);\n+\n+  mem_ref = validize_mem (gen_rtx_MEM (mode, mr));\n+\n+  tmp = expand_simple_binop (mode, PLUS, copy_rtx (mem_ref), const1_rtx,\n+\t\t\t     mem_ref, 0, OPTAB_WIDEN);\n+\n+  if (tmp != mem_ref)\n+    emit_move_insn (copy_rtx (mem_ref), tmp);\n+\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}\n+\n+/* Output instructions as RTL for code to find the most common value.\n+   VALUE is the expression whose value is profiled.  TAG is the tag of the\n+   section for counters, BASE is offset of the counter position.  */\n+\n+static rtx\n+gen_one_value_profiler (struct histogram_value *value,\n+\t\t\tunsigned tag, unsigned base)\n+{\n+  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n+  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n+  rtx stored_value_ref, counter_ref, all_ref, stored_value, counter, all;\n+  rtx tmp, uval;\n+  rtx sequence;\n+  rtx same_label = gen_label_rtx ();\n+  rtx zero_label = gen_label_rtx ();\n+  rtx end_of_code_label = gen_label_rtx ();\n+\n+  start_sequence ();\n+\n+  if (value->seq)\n+    emit_insn (value->seq);\n+\n+  stored_value_ref = coverage_counter_ref (tag, base);\n+  counter_ref = coverage_counter_ref (tag, base + 1);\n+  all_ref = coverage_counter_ref (tag, base + 2);\n+  stored_value = validize_mem (stored_value_ref);\n+  counter = validize_mem (counter_ref);\n+  all = validize_mem (all_ref);\n+\n+  uval = gen_reg_rtx (mode);\n+  convert_move (uval, copy_rtx (value->value), 0);\n+\n+  /* Check if the stored value matches.  */\n+  do_compare_rtx_and_jump (copy_rtx (uval), copy_rtx (stored_value), EQ,\n+\t\t\t   0, mode, NULL_RTX, NULL_RTX, same_label);\n+  \n+  /* Does not match; check whether the counter is zero.  */\n+  do_compare_rtx_and_jump (copy_rtx (counter), const0_rtx, EQ, 0, mode,\n+\t\t\t   NULL_RTX, NULL_RTX, zero_label);\n+\n+  /* The counter is not zero yet.  */\n+  tmp = expand_simple_binop (mode, PLUS, copy_rtx (counter), constm1_rtx,\n+\t\t\t     counter, 0, OPTAB_WIDEN);\n+\n+  if (tmp != counter)\n+    emit_move_insn (copy_rtx (counter), tmp);\n+\n+  emit_jump_insn (gen_jump (end_of_code_label));\n+  emit_barrier ();\n+ \n+  emit_label (zero_label);\n+  /* Set new value.  */\n+  emit_move_insn (copy_rtx (stored_value), copy_rtx (uval));\n+\n+  emit_label (same_label);\n+  /* Increase the counter.  */\n+  tmp = expand_simple_binop (mode, PLUS, copy_rtx (counter), const1_rtx,\n+\t\t\t     counter, 0, OPTAB_WIDEN);\n+\n+  if (tmp != counter)\n+    emit_move_insn (copy_rtx (counter), tmp);\n+  \n+  emit_label (end_of_code_label);\n+\n+  /* Increase the counter of all executions; this seems redundant given\n+     that ve have counts for edges in cfg, but it may happen that some\n+     optimization will change the counts for the block (either because\n+     it is unable to update them correctly, or because it will duplicate\n+     the block or its part).  */\n+  tmp = expand_simple_binop (mode, PLUS, copy_rtx (all), const1_rtx,\n+\t\t\t     all, 0, OPTAB_WIDEN);\n+\n+  if (tmp != all)\n+    emit_move_insn (copy_rtx (all), tmp);\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}\n+\n+/* Output instructions as RTL for code to find the most common value of\n+   a difference between two evaluations of an expression.\n+   VALUE is the expression whose value is profiled.  TAG is the tag of the\n+   section for counters, BASE is offset of the counter position.  */\n+\n+static rtx\n+gen_const_delta_profiler (struct histogram_value *value,\n+\t\t\t  unsigned tag, unsigned base)\n+{\n+  struct histogram_value one_value_delta;\n+  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n+  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n+  rtx stored_value_ref, stored_value, tmp, uval;\n+  rtx sequence;\n+\n+  start_sequence ();\n+\n+  if (value->seq)\n+    emit_insn (value->seq);\n+\n+  stored_value_ref = coverage_counter_ref (tag, base);\n+  stored_value = validize_mem (stored_value_ref);\n+\n+  uval = gen_reg_rtx (mode);\n+  convert_move (uval, copy_rtx (value->value), 0);\n+  tmp = expand_simple_binop (mode, MINUS,\n+\t\t\t     copy_rtx (uval), copy_rtx (stored_value),\n+\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n+\n+  one_value_delta.value = tmp;\n+  one_value_delta.mode = mode;\n+  one_value_delta.seq = NULL_RTX;\n+  one_value_delta.insn = value->insn;\n+  one_value_delta.type = HIST_TYPE_SINGLE_VALUE;\n+  emit_insn (gen_one_value_profiler (&one_value_delta, tag, base + 1));\n+\n+  emit_move_insn (copy_rtx (stored_value), uval);\n+  sequence = get_insns ();\n+  end_sequence ();\n+  rebuild_jump_labels (sequence);\n+  return sequence;\n+}"}, {"sha": "6d1dd44f11985c8318e5c8ee734d9a7a4d3287d9", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af166e5d276114872596002803f7c300fc41a511/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af166e5d276114872596002803f7c300fc41a511/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=af166e5d276114872596002803f7c300fc41a511", "patch": "@@ -410,6 +410,10 @@ int profile_flag = 0;\n \n int profile_arc_flag = 0;\n \n+/* Nonzero if value histograms should be measured.  */\n+\n+int flag_profile_values = 0;\n+\n /* Nonzero if generating info for gcov to calculate line test coverage.  */\n \n int flag_test_coverage = 0;\n@@ -1184,6 +1188,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Create data files needed by gcov\") },\n   {\"branch-probabilities\", &flag_dummy, 1,\n    N_(\"Use profiling information for branch probabilities\") },\n+  {\"profile-values\", &flag_profile_values, 1,\n+   N_(\"Insert code to profile values of expressions\") },\n   {\"profile\", &flag_dummy, 1,\n    N_(\"Enable basic program profiling code\") },\n   {\"reorder-blocks\", &flag_dummy, 1,"}]}