{"sha": "3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QxNDJiZTIzYjliMWNlNmE0NzlhOWM0ZWY4MzZhM2E3OWQ2YTY1MA==", "commit": {"author": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-09-20T23:05:40Z"}, "committer": {"name": "Giovanni Bajo", "email": "giovannibajo@gcc.gnu.org", "date": "2004-09-20T23:05:40Z"}, "message": "re PR c++/14179 (out of memory while parsing array with many initializers)\n\n\tPR c++/14179\n\t* decl.c (reshape_init): Extract array handling into...\n\t(reshape_init_array): New function. Use integers instead of trees\n\tfor indices. Handle out-of-range designated initializers.\n\nFrom-SVN: r87777", "tree": {"sha": "53a7abf22815133d05ec46e39d738987dca3e92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53a7abf22815133d05ec46e39d738987dca3e92f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650/comments", "author": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rasky", "id": 1014109, "node_id": "MDQ6VXNlcjEwMTQxMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1014109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasky", "html_url": "https://github.com/rasky", "followers_url": "https://api.github.com/users/rasky/followers", "following_url": "https://api.github.com/users/rasky/following{/other_user}", "gists_url": "https://api.github.com/users/rasky/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasky/subscriptions", "organizations_url": "https://api.github.com/users/rasky/orgs", "repos_url": "https://api.github.com/users/rasky/repos", "events_url": "https://api.github.com/users/rasky/events{/privacy}", "received_events_url": "https://api.github.com/users/rasky/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c82eecc7896f50079c2e333fa1d0f76afdbfabf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c82eecc7896f50079c2e333fa1d0f76afdbfabf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c82eecc7896f50079c2e333fa1d0f76afdbfabf"}], "stats": {"total": 136, "additions": 91, "deletions": 45}, "files": [{"sha": "b989792b87d4ad58f0bc7a2fc60d5dfb14ee212d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "patch": "@@ -1,3 +1,10 @@\n+2004-09-20  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/14179\n+\t* decl.c (reshape_init): Extract array handling into...\n+\t(reshape_init_array): New function. Use integers instead of trees\n+\tfor indices. Handle out-of-range designated initializers.\n+\n 2004-09-20  Steven Bosscher  <stevenb@suse.de>\n \n \t* lex.c (cxx_init): Don't set the ridpointer for RID_NULL"}, {"sha": "3098cfdbc1950ec8298450ab7ffd1639cd80a4b7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 84, "deletions": 45, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d142be23b9b1ce6a479a9c4ef836a3a79d6a650/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3d142be23b9b1ce6a479a9c4ef836a3a79d6a650", "patch": "@@ -4146,6 +4146,69 @@ next_initializable_field (tree field)\n   return field;\n }\n \n+/* Subroutine of reshape_init. Reshape the constructor for an array. INITP\n+   is the pointer to the old constructor list (to the CONSTRUCTOR_ELTS of\n+   the CONSTRUCTOR we are processing), while NEW_INIT is the CONSTRUCTOR we\n+   are building.\n+   ELT_TYPE is the element type of the array. MAX_INDEX is an INTEGER_CST\n+   representing the size of the array minus one (the maximum index), or\n+   NULL_TREE if the array was declared without specifying the size.  */\n+\n+static bool\n+reshape_init_array (tree elt_type, tree max_index,\n+\t\t    tree *initp, tree new_init)\n+{\n+  bool sized_array_p = (max_index != NULL_TREE);\n+  HOST_WIDE_INT max_index_cst;\n+  HOST_WIDE_INT index;\n+\n+  if (sized_array_p)\n+    /* HWI is either 32bit or 64bit, so it must be enough to represent the\n+\tarray size.  */\n+    max_index_cst = tree_low_cst (max_index, 1);\n+\n+  /* Loop until there are no more initializers.  */\n+  for (index = 0;\n+       *initp && (!sized_array_p || index <= max_index_cst);\n+       ++index)\n+    {\n+      tree element_init;\n+      tree designated_index;\n+\n+      element_init = reshape_init (elt_type, initp);\n+      if (element_init == error_mark_node)\n+\treturn false;\n+      TREE_CHAIN (element_init) = CONSTRUCTOR_ELTS (new_init);\n+      CONSTRUCTOR_ELTS (new_init) = element_init;\n+      designated_index = TREE_PURPOSE (element_init);\n+      if (designated_index)\n+      {\n+\t  /* Handle array designated initializers (GNU extension).  */\n+\t  if (TREE_CODE (designated_index) == IDENTIFIER_NODE)\n+\t    {\n+\t      error (\"name `%D' used in a GNU-style designated \"\n+\t\t    \"initializer for an array\", designated_index);\n+\t      TREE_PURPOSE (element_init) = NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_assert (TREE_CODE (designated_index) == INTEGER_CST);\n+\t      if (sized_array_p\n+\t\t  && tree_int_cst_lt (max_index, designated_index))\n+\t\t{\n+\t\t  error (\"Designated initializer `%E' larger than array \"\n+\t\t\t \"size\", designated_index);\n+\t\t  TREE_PURPOSE (element_init) = NULL_TREE;\n+\t\t}\n+\t      else\n+\t\tindex = tree_low_cst (designated_index, 1);\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Undo the brace-elision allowed by [dcl.init.aggr] in a\n    brace-enclosed aggregate initializer.\n \n@@ -4313,52 +4376,28 @@ reshape_init (tree type, tree *initp)\n       else if (TREE_CODE (type) == ARRAY_TYPE\n \t       || TREE_CODE (type) == VECTOR_TYPE)\n \t{\n-\t  tree index;\n-\t  tree max_index;\n-\n-\t  /* If the bound of the array is known, take no more initializers\n-\t     than are allowed.  */\n-\t  max_index = NULL_TREE;\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    {\n-\t      if (TYPE_DOMAIN (type))\n-\t\tmax_index = array_type_nelts (type);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* For a vector, the representation type is a struct\n-\t\t containing a single member which is an array of the\n-\t\t appropriate size.  */\n-\t      tree rtype = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n-\t      if (rtype && TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (rtype))))\n-\t\tmax_index = array_type_nelts (TREE_TYPE (TYPE_FIELDS (rtype)));\n-\t    }\n+\t    /* If the bound of the array is known, take no more initializers\n+\t      than are allowed.  */\n+\t    tree max_index = NULL_TREE;\n+\t    if (TREE_CODE (type) == ARRAY_TYPE)\n+\t      {\n+\t\tif (TYPE_DOMAIN (type))\n+\t\t  max_index = array_type_nelts (type);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* For a vector, the representation type is a struct\n+\t\t  containing a single member which is an array of the\n+\t\t  appropriate size.  */\n+\t\ttree rtype = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n+\t\tif (rtype && TYPE_DOMAIN (TREE_TYPE (TYPE_FIELDS (rtype))))\n+\t\t  max_index = array_type_nelts (TREE_TYPE (TYPE_FIELDS\n+\t\t\t\t\t\t\t   (rtype)));\n+\t      }\n \n-\t  /* Loop through the array elements, gathering initializers.  */\n-\t  for (index = size_zero_node;\n-\t       *initp && (!max_index || !tree_int_cst_lt (max_index, index));\n-\t       index = size_binop (PLUS_EXPR, index, size_one_node))\n-\t    {\n-\t      tree element_init;\n-\n-\t      element_init = reshape_init (TREE_TYPE (type), initp);\n-\t      if (element_init == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      TREE_CHAIN (element_init) = CONSTRUCTOR_ELTS (new_init);\n-\t      CONSTRUCTOR_ELTS (new_init) = element_init;\n-\t      if (TREE_PURPOSE (element_init))\n-\t\t{\n-\t\t  tree next_index = TREE_PURPOSE (element_init);\n-\t\t  if (TREE_CODE (next_index) == IDENTIFIER_NODE)\n-\t\t    {\n-\t\t      error (\"name `%D' used in a GNU-style designated \"\n-\t\t\t     \"initializer for an array\", next_index);\n-\t\t      TREE_PURPOSE (element_init) = NULL_TREE;\n-\t\t    }\n-\t\t  else\n-\t\t    index = next_index;\n-\t\t}\n-\t    }\n+\t  if (!reshape_init_array (TREE_TYPE (type), max_index,\n+\t\t\t\t   initp, new_init))\n+\t    return error_mark_node;\n \t}\n       else\n \tgcc_unreachable ();"}]}