{"sha": "fd4a760e5e1c85e7ca49a1afe604059cd4e228e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ0YTc2MGU1ZTFjODVlN2NhNDlhMWFmZTYwNDA1OWNkNGUyMjhlOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-17T09:55:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-17T09:55:04Z"}, "message": "tree-ssa-dom.c (struct edge_info): Use a VEC for the list of conditional equivalences.\n\n2010-08-17  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-dom.c (struct edge_info): Use a VEC for the\n\tlist of conditional equivalences.\n\t(free_all_edge_infos): Adjust.\n\t(record_equivalences_from_incoming_edge): Likewise.\n\t(record_cond): Likewise.\n\t(build_and_record_new_cond): Likewise.\n\t(record_conditions): Likewise.\n\t(dom_opt_leave_block): Likewise.\n\nFrom-SVN: r163302", "tree": {"sha": "0ae0b19d23b413b2cdeb9815b92c61ac32d9a21d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae0b19d23b413b2cdeb9815b92c61ac32d9a21d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b17b584fe1e8b269ae9f2d4ab9908deac20c965b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17b584fe1e8b269ae9f2d4ab9908deac20c965b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b17b584fe1e8b269ae9f2d4ab9908deac20c965b"}], "stats": {"total": 147, "additions": 66, "deletions": 81}, "files": [{"sha": "73462ffc54a6cc3a21db53d4c6e577929847417a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd4a760e5e1c85e7ca49a1afe604059cd4e228e9", "patch": "@@ -1,3 +1,14 @@\n+2010-08-17  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-dom.c (struct edge_info): Use a VEC for the\n+\tlist of conditional equivalences.\n+\t(free_all_edge_infos): Adjust.\n+\t(record_equivalences_from_incoming_edge): Likewise.\n+\t(record_cond): Likewise.\n+\t(build_and_record_new_cond): Likewise.\n+\t(record_conditions): Likewise.\n+\t(dom_opt_leave_block): Likewise.\n+\n 2010-08-17  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* doc/invoke.texi (ms-extension): Add documentation."}, {"sha": "c1abb40c529c70c314a1da89bccda86946abf282", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 55, "deletions": 81, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd4a760e5e1c85e7ca49a1afe604059cd4e228e9/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=fd4a760e5e1c85e7ca49a1afe604059cd4e228e9", "patch": "@@ -71,11 +71,14 @@ struct hashable_expr\n /* Structure for recording known values of a conditional expression\n    at the exits from its block.  */\n \n-struct cond_equivalence\n+typedef struct cond_equivalence_s\n {\n   struct hashable_expr cond;\n   tree value;\n-};\n+} cond_equivalence;\n+\n+DEF_VEC_O(cond_equivalence);\n+DEF_VEC_ALLOC_O(cond_equivalence,heap);\n \n /* Structure for recording edge equivalences as well as any pending\n    edge redirections during the dominator optimizer.\n@@ -99,11 +102,8 @@ struct edge_info\n   tree rhs;\n \n   /* Traversing an edge may also indicate one or more particular conditions\n-     are true or false.  The number of recorded conditions can vary, but\n-     can be determined by the condition's code.  So we have an array\n-     and its maximum index rather than use a varray.  */\n-  struct cond_equivalence *cond_equivalences;\n-  unsigned int max_cond_equivalences;\n+     are true or false.  */\n+  VEC(cond_equivalence, heap) *cond_equivalences;\n };\n \n /* Hash table with expressions made available during the renaming process.\n@@ -179,7 +179,7 @@ static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n static void htab_statistics (FILE *, htab_t);\n-static void record_cond (struct cond_equivalence *);\n+static void record_cond (cond_equivalence *);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n static void record_equivalences_from_phis (basic_block);\n@@ -636,7 +636,7 @@ free_all_edge_infos (void)\n \t  if (edge_info)\n \t    {\n \t      if (edge_info->cond_equivalences)\n-\t\tfree (edge_info->cond_equivalences);\n+\t\tVEC_free (cond_equivalence, heap, edge_info->cond_equivalences);\n \t      free (edge_info);\n \t      e->aux = NULL;\n \t    }\n@@ -1059,14 +1059,14 @@ record_equivalences_from_incoming_edge (basic_block bb)\n \t{\n \t  tree lhs = edge_info->lhs;\n \t  tree rhs = edge_info->rhs;\n-\t  struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n+\t  cond_equivalence *eq;\n \n \t  if (lhs)\n \t    record_equality (lhs, rhs);\n \n-\t  if (cond_equivalences)\n-            for (i = 0; i < edge_info->max_cond_equivalences; i++)\n-              record_cond (&cond_equivalences[i]);\n+\t  for (i = 0; VEC_iterate (cond_equivalence,\n+\t\t\t\t   edge_info->cond_equivalences, i, eq); ++i)\n+\t    record_cond (eq);\n \t}\n     }\n }\n@@ -1114,7 +1114,7 @@ htab_statistics (FILE *file, htab_t htab)\n    boolean value.  */\n \n static void\n-record_cond (struct cond_equivalence *p)\n+record_cond (cond_equivalence *p)\n {\n   struct expr_hash_elt *element = XCNEW (struct expr_hash_elt);\n   void **slot;\n@@ -1140,14 +1140,15 @@ record_cond (struct cond_equivalence *p)\n }\n \n /* Build a cond_equivalence record indicating that the comparison\n-   CODE holds between operands OP0 and OP1.  */\n+   CODE holds between operands OP0 and OP1 and push it to **P.  */\n \n static void\n build_and_record_new_cond (enum tree_code code,\n                            tree op0, tree op1,\n-                           struct cond_equivalence *p)\n+                           VEC(cond_equivalence, heap) **p)\n {\n-  struct hashable_expr *cond = &p->cond;\n+  cond_equivalence c;\n+  struct hashable_expr *cond = &c.cond;\n \n   gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n \n@@ -1157,7 +1158,8 @@ build_and_record_new_cond (enum tree_code code,\n   cond->ops.binary.opnd0 = op0;\n   cond->ops.binary.opnd1 = op1;\n \n-  p->value = boolean_true_node;\n+  c.value = boolean_true_node;\n+  VEC_safe_push (cond_equivalence, heap, *p, &c);\n }\n \n /* Record that COND is true and INVERTED is false into the edge information\n@@ -1170,6 +1172,7 @@ static void\n record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n {\n   tree op0, op1;\n+  cond_equivalence c;\n \n   if (!COMPARISON_CLASS_P (cond))\n     return;\n@@ -1183,125 +1186,96 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n     case GT_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n \t{\n-\t  edge_info->max_cond_equivalences = 6;\n-\t  edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 6);\n \t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences[4]);\n+\t\t\t\t     &edge_info->cond_equivalences);\n \t  build_and_record_new_cond (LTGT_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences[5]);\n-\t}\n-      else\n-        {\n-          edge_info->max_cond_equivalences = 4;\n-\t  edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 4);\n+\t\t\t\t     &edge_info->cond_equivalences);\n \t}\n \n       build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n \t\t\t\t  ? LE_EXPR : GE_EXPR),\n-\t\t\t\t op0, op1, &edge_info->cond_equivalences[2]);\n+\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n       build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[3]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       break;\n \n     case GE_EXPR:\n     case LE_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n \t{\n-\t  edge_info->max_cond_equivalences = 3;\n-\t  edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 3);\n \t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences[2]);\n-\t}\n-      else\n-\t{\n-\t  edge_info->max_cond_equivalences = 2;\n-\t  edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 2);\n+\t\t\t\t     &edge_info->cond_equivalences);\n \t}\n       break;\n \n     case EQ_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (op0)))\n \t{\n-\t  edge_info->max_cond_equivalences = 5;\n-\t  edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 5);\n \t  build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t     &edge_info->cond_equivalences[4]);\n-\t}\n-      else\n-\t{\n-\t  edge_info->max_cond_equivalences = 4;\n-\t  edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 4);\n+\t\t\t\t     &edge_info->cond_equivalences);\n \t}\n       build_and_record_new_cond (LE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[2]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (GE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[3]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       break;\n \n     case UNORDERED_EXPR:\n-      edge_info->max_cond_equivalences = 8;\n-      edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 8);\n       build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[2]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (UNLE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[3]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (UNGE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[4]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (UNEQ_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[5]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (UNLT_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[6]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (UNGT_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[7]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       break;\n \n     case UNLT_EXPR:\n     case UNGT_EXPR:\n-      edge_info->max_cond_equivalences = 4;\n-      edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 4);\n       build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n \t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n-\t\t\t\t op0, op1, &edge_info->cond_equivalences[2]);\n+\t\t\t\t op0, op1, &edge_info->cond_equivalences);\n       build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[3]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       break;\n \n     case UNEQ_EXPR:\n-      edge_info->max_cond_equivalences = 4;\n-      edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 4);\n       build_and_record_new_cond (UNLE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[2]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (UNGE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[3]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       break;\n \n     case LTGT_EXPR:\n-      edge_info->max_cond_equivalences = 4;\n-      edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 4);\n       build_and_record_new_cond (NE_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[2]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n-\t\t\t\t &edge_info->cond_equivalences[3]);\n+\t\t\t\t &edge_info->cond_equivalences);\n       break;\n \n     default:\n-      edge_info->max_cond_equivalences = 2;\n-      edge_info->cond_equivalences = XNEWVEC (struct cond_equivalence, 2);\n       break;\n     }\n \n   /* Now store the original true and false conditions into the first\n      two slots.  */\n-  initialize_expr_from_cond (cond, &edge_info->cond_equivalences[0].cond);\n-  edge_info->cond_equivalences[0].value = boolean_true_node;\n+  initialize_expr_from_cond (cond, &c.cond);\n+  c.value = boolean_true_node;\n+  VEC_safe_push (cond_equivalence, heap, edge_info->cond_equivalences, &c);\n \n   /* It is possible for INVERTED to be the negation of a comparison,\n      and not a valid RHS or GIMPLE_COND condition.  This happens because\n      invert_truthvalue may return such an expression when asked to invert\n      a floating-point comparison.  These comparisons are not assumed to\n      obey the trichotomy law.  */\n-  initialize_expr_from_cond (inverted, &edge_info->cond_equivalences[1].cond);\n-  edge_info->cond_equivalences[1].value = boolean_false_node;\n+  initialize_expr_from_cond (inverted, &c.cond);\n+  c.value = boolean_false_node;\n+  VEC_safe_push (cond_equivalence, heap, edge_info->cond_equivalences, &c);\n }\n \n /* A helper function for record_const_or_copy and record_equality.\n@@ -1749,7 +1723,7 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \t     our equivalence tables.  */\n \t  if (edge_info)\n \t    {\n-\t      struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n+\t      cond_equivalence *eq;\n \t      tree lhs = edge_info->lhs;\n \t      tree rhs = edge_info->rhs;\n \n@@ -1759,9 +1733,9 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \n \t      /* If we have 0 = COND or 1 = COND equivalences, record them\n \t\t into our expression hash tables.  */\n-\t      if (cond_equivalences)\n-\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i++)\n-                  record_cond (&cond_equivalences[i]);\n+\t      for (i = 0; VEC_iterate (cond_equivalence,\n+\t\t\t\t       edge_info->cond_equivalences, i, eq); ++i)\n+\t\trecord_cond (eq);\n \t    }\n \n \t  dom_thread_across_edge (walk_data, true_edge);\n@@ -1784,7 +1758,7 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \t     our equivalence tables.  */\n \t  if (edge_info)\n \t    {\n-\t      struct cond_equivalence *cond_equivalences = edge_info->cond_equivalences;\n+\t      cond_equivalence *eq;\n \t      tree lhs = edge_info->lhs;\n \t      tree rhs = edge_info->rhs;\n \n@@ -1794,9 +1768,9 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \n \t      /* If we have 0 = COND or 1 = COND equivalences, record them\n \t\t into our expression hash tables.  */\n-\t      if (cond_equivalences)\n-\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i++)\n-                  record_cond (&cond_equivalences[i]);\n+\t      for (i = 0; VEC_iterate (cond_equivalence,\n+\t\t\t\t       edge_info->cond_equivalences, i, eq); ++i)\n+\t\trecord_cond (eq);\n \t    }\n \n \t  /* Now thread the edge.  */"}]}