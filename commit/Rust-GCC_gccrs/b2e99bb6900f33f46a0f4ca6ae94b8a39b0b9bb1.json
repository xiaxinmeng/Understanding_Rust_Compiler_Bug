{"sha": "b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1", "node_id": "C_kwDOANBUbNoAKGIyZTk5YmI2OTAwZjMzZjQ2YTBmNGNhNmFlOTRiOGEzOWIwYjliYjE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-22T07:57:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-22T08:06:59Z"}, "message": "tree-optimization/106397 - array prefetch and LC SSA\n\nThe following fixes maintaining LC SSA when array prefetch inserts\nmfence instructions on loop exits that do not use memory.  It also\nfixes the latent issue that it might split exit edges for this\nwhich will break LC SSA for non-virtuals as well.  It should also\nmake the process cheaper by accumulating the required (LC) SSA\nupdate until the end of the pass.\n\n\tPR tree-optimization/106397\n\t* tree-ssa-loop-prefetch.cc (emit_mfence_after_loop): Do\n\tnot update SSA form here.\n\t(mark_nontemporal_stores): Return whether we marked any\n\tnon-temporal stores and inserted mfence.\n\t(loop_prefetch_arrays): Note when we need to update SSA.\n\t(tree_ssa_prefetch_arrays): Perform required (LC) SSA update\n\tat the end of the pass.\n\n\t* gcc.dg/pr106397.c: New testcase.", "tree": {"sha": "a895d7c63a41513adb9c1aa3ae84a7205a9a4302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a895d7c63a41513adb9c1aa3ae84a7205a9a4302"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c4af0f0549a07799d76e9e48d3d3bd85197b92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c4af0f0549a07799d76e9e48d3d3bd85197b92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c4af0f0549a07799d76e9e48d3d3bd85197b92a"}], "stats": {"total": 44, "additions": 34, "deletions": 10}, "files": [{"sha": "a6b2e91334680d3aa4306cd2a213839023310107", "filename": "gcc/testsuite/gcc.dg/pr106397.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr106397.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr106397.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr106397.c?ref=b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fprefetch-loop-arrays --param l2-cache-size=0 --param prefetch-latency=3 -fprefetch-loop-arrays\" } */\n+\n+int\n+bar (void)\n+{\n+  /* No return statement. */\n+}\n+\n+__attribute__ ((simd)) int\n+foo (void)\n+{\n+  if (bar ())\n+    return 0;\n+\n+  __builtin_unreachable ();\n+}"}, {"sha": "b6690b0e80592f5e29010e339a48c27a3b4c375f", "filename": "gcc/tree-ssa-loop-prefetch.cc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1/gcc%2Ftree-ssa-loop-prefetch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1/gcc%2Ftree-ssa-loop-prefetch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.cc?ref=b2e99bb6900f33f46a0f4ca6ae94b8a39b0b9bb1", "patch": "@@ -1308,8 +1308,6 @@ emit_mfence_after_loop (class loop *loop)\n \n       gsi_insert_before (&bsi, call, GSI_NEW_STMT);\n     }\n-\n-  update_ssa (TODO_update_ssa_only_virtuals);\n }\n \n /* Returns true if we can use storent in loop, false otherwise.  */\n@@ -1340,23 +1338,27 @@ may_use_storent_in_loop_p (class loop *loop)\n }\n \n /* Marks nontemporal stores in LOOP.  GROUPS contains the description of memory\n-   references in the loop.  */\n+   references in the loop.  Returns whether we inserted any mfence call.  */\n \n-static void\n+static bool\n mark_nontemporal_stores (class loop *loop, struct mem_ref_group *groups)\n {\n   struct mem_ref *ref;\n   bool any = false;\n \n   if (!may_use_storent_in_loop_p (loop))\n-    return;\n+    return false;\n \n   for (; groups; groups = groups->next)\n     for (ref = groups->refs; ref; ref = ref->next)\n       any |= mark_nontemporal_store (ref);\n \n   if (any && FENCE_FOLLOWING_MOVNT != NULL_TREE)\n-    emit_mfence_after_loop (loop);\n+    {\n+      emit_mfence_after_loop (loop);\n+      return true;\n+    }\n+  return false;\n }\n \n /* Determines whether we can profitably unroll LOOP FACTOR times, and if\n@@ -1874,10 +1876,11 @@ insn_to_prefetch_ratio_too_small_p (unsigned ninsns, unsigned prefetch_count,\n \n \n /* Issue prefetch instructions for array references in LOOP.  Returns\n-   true if the LOOP was unrolled.  */\n+   true if the LOOP was unrolled and updates NEED_LC_SSA_UPDATE if we need\n+   to update SSA for virtual operands and LC SSA for a split edge.  */\n \n static bool\n-loop_prefetch_arrays (class loop *loop)\n+loop_prefetch_arrays (class loop *loop, bool &need_lc_ssa_update)\n {\n   struct mem_ref_group *refs;\n   unsigned ahead, ninsns, time, unroll_factor;\n@@ -1952,7 +1955,7 @@ loop_prefetch_arrays (class loop *loop)\n \t\t\t\t\t  unroll_factor))\n     goto fail;\n \n-  mark_nontemporal_stores (loop, refs);\n+  need_lc_ssa_update |= mark_nontemporal_stores (loop, refs);\n \n   /* Step 4: what to prefetch?  */\n   if (!schedule_prefetches (refs, unroll_factor, ahead))\n@@ -1980,6 +1983,7 @@ unsigned int\n tree_ssa_prefetch_arrays (void)\n {\n   bool unrolled = false;\n+  bool need_lc_ssa_update = false;\n   int todo_flags = 0;\n \n   if (!targetm.have_prefetch ()\n@@ -2028,12 +2032,15 @@ tree_ssa_prefetch_arrays (void)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Processing loop %d:\\n\", loop->num);\n \n-      unrolled |= loop_prefetch_arrays (loop);\n+      unrolled |= loop_prefetch_arrays (loop, need_lc_ssa_update);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"\\n\\n\");\n     }\n \n+  if (need_lc_ssa_update)\n+    rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_only_virtuals);\n+\n   if (unrolled)\n     {\n       scev_reset ();"}]}