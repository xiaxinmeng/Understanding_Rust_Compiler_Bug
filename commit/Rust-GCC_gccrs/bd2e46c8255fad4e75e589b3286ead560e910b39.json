{"sha": "bd2e46c8255fad4e75e589b3286ead560e910b39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQyZTQ2YzgyNTVmYWQ0ZTc1ZTU4OWIzMjg2ZWFkNTYwZTkxMGIzOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-03T05:27:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-10-03T05:27:36Z"}, "message": "libgo: Update to Go 1.0.3.\n\nFrom-SVN: r192025", "tree": {"sha": "4f194bdb2e9edcc69ef2ab0dfb4aab15ca259267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f194bdb2e9edcc69ef2ab0dfb4aab15ca259267"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd2e46c8255fad4e75e589b3286ead560e910b39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2e46c8255fad4e75e589b3286ead560e910b39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd2e46c8255fad4e75e589b3286ead560e910b39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2e46c8255fad4e75e589b3286ead560e910b39/comments", "author": null, "committer": null, "parents": [{"sha": "bed6238ce677ba18a672a58bc077cec6de47f8d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed6238ce677ba18a672a58bc077cec6de47f8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed6238ce677ba18a672a58bc077cec6de47f8d3"}], "stats": {"total": 2541, "additions": 2060, "deletions": 481}, "files": [{"sha": "89116d1feef3d0e2797606c86933a3ddb649282a", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -1,4 +1,4 @@\n-5e806355a9e1\n+2d8bc3c94ecb\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "b2eb39e5972b5dbd0a83b1f495cbcc7f76f0d7d8", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -743,6 +743,7 @@ go_net_files = \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n+\tgo/net/net_posix.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\"}, {"sha": "597056429265e92f8e87de806e2c8d1d462f36b2", "filename": "libgo/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -1000,6 +1000,7 @@ go_net_files = \\\n \tgo/net/lookup_unix.go \\\n \tgo/net/mac.go \\\n \tgo/net/net.go \\\n+\tgo/net/net_posix.go \\\n \tgo/net/parse.go \\\n \tgo/net/pipe.go \\\n \tgo/net/port.go \\"}, {"sha": "0e284825bd05532e68c3cf7ed536721564cdd1c6", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -272,6 +272,9 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err error) {\n \tpanic(\"not reached\")\n }\n \n+// ReadLine is a low-level line-reading primitive. Most callers should use\n+// ReadBytes('\\n') or ReadString('\\n') instead.\n+//\n // ReadLine tries to return a single line, not including the end-of-line bytes.\n // If the line was too long for the buffer then isPrefix is set and the\n // beginning of the line is returned. The rest of the line will be returned"}, {"sha": "a30943b894f13a18f602077412520dcee741ea54", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -81,9 +81,8 @@ type uintptr uintptr\n // integer values.\n type byte byte\n \n-// rune is an alias for int and is equivalent to int in all ways. It is\n+// rune is an alias for int32 and is equivalent to int32 in all ways. It is\n // used, by convention, to distinguish character values from integer values.\n-// In a future version of Go, it will change to an alias of int32.\n type rune rune\n \n // Type is here for the purposes of documentation only. It is a stand-in"}, {"sha": "09b3c1a2705500d79d8096fc41fd4156a33116e6", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -415,7 +415,7 @@ func Repeat(b []byte, count int) []byte {\n // ToUpper returns a copy of the byte array s with all Unicode letters mapped to their upper case.\n func ToUpper(s []byte) []byte { return Map(unicode.ToUpper, s) }\n \n-// ToUpper returns a copy of the byte array s with all Unicode letters mapped to their lower case.\n+// ToLower returns a copy of the byte array s with all Unicode letters mapped to their lower case.\n func ToLower(s []byte) []byte { return Map(unicode.ToLower, s) }\n \n // ToTitle returns a copy of the byte array s with all Unicode letters mapped to their title case."}, {"sha": "394c32fa3a6a5e30265a8a51e1276df192e33ada", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -16,9 +16,10 @@ import (\n const (\n \tmaxCodeLen = 16    // max length of Huffman code\n \tmaxHist    = 32768 // max history required\n-\tmaxLit     = 286\n-\tmaxDist    = 32\n-\tnumCodes   = 19 // number of codes in Huffman meta-code\n+\t// The next three numbers come from the RFC, section 3.2.7.\n+\tmaxLit   = 286\n+\tmaxDist  = 32\n+\tnumCodes = 19 // number of codes in Huffman meta-code\n )\n \n // A CorruptInputError reports the presence of corrupt input at a given offset.\n@@ -306,10 +307,15 @@ func (f *decompressor) readHuffman() error {\n \t\t}\n \t}\n \tnlit := int(f.b&0x1F) + 257\n+\tif nlit > maxLit {\n+\t\treturn CorruptInputError(f.roffset)\n+\t}\n \tf.b >>= 5\n \tndist := int(f.b&0x1F) + 1\n+\t// maxDist is 32, so ndist is always valid.\n \tf.b >>= 5\n \tnclen := int(f.b&0xF) + 4\n+\t// numCodes is 19, so nclen is always valid.\n \tf.b >>= 4\n \tf.nb -= 5 + 5 + 4\n "}, {"sha": "54ed788dbd3e50f3a13fbc353ca66dbc2ba8ffe7", "filename": "libgo/go/compress/flate/reader_test.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Freader_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package flate\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestNlitOutOfRange(t *testing.T) {\n+\t// Trying to decode this bogus flate data, which has a Huffman table\n+\t// with nlit=288, should not panic.\n+\tio.Copy(ioutil.Discard, NewReader(strings.NewReader(\n+\t\t\"\\xfc\\xfe\\x36\\xe7\\x5e\\x1c\\xef\\xb3\\x55\\x58\\x77\\xb6\\x56\\xb5\\x43\\xf4\"+\n+\t\t\t\"\\x6f\\xf2\\xd2\\xe6\\x3d\\x99\\xa0\\x85\\x8c\\x48\\xeb\\xf8\\xda\\x83\\x04\\x2a\"+\n+\t\t\t\"\\x75\\xc4\\xf8\\x0f\\x12\\x11\\xb9\\xb4\\x4b\\x09\\xa0\\xbe\\x8b\\x91\\x4c\")))\n+}\n+\n+const (\n+\tdigits = iota\n+\ttwain\n+)\n+\n+var testfiles = []string{\n+\t// Digits is the digits of the irrational number e. Its decimal representation\n+\t// does not repeat, but there are only 10 posible digits, so it should be\n+\t// reasonably compressible.\n+\tdigits: \"../testdata/e.txt\",\n+\t// Twain is Project Gutenberg's edition of Mark Twain's classic English novel.\n+\ttwain: \"../testdata/Mark.Twain-Tom.Sawyer.txt\",\n+}\n+\n+func benchmarkDecode(b *testing.B, testfile, level, n int) {\n+\tb.StopTimer()\n+\tb.SetBytes(int64(n))\n+\tbuf0, err := ioutil.ReadFile(testfiles[testfile])\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tif len(buf0) == 0 {\n+\t\tb.Fatalf(\"test file %q has no data\", testfiles[testfile])\n+\t}\n+\tcompressed := new(bytes.Buffer)\n+\tw, err := NewWriter(compressed, level)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tfor i := 0; i < n; i += len(buf0) {\n+\t\tif len(buf0) > n-i {\n+\t\t\tbuf0 = buf0[:n-i]\n+\t\t}\n+\t\tio.Copy(w, bytes.NewBuffer(buf0))\n+\t}\n+\tw.Close()\n+\tbuf1 := compressed.Bytes()\n+\tbuf0, compressed, w = nil, nil, nil\n+\truntime.GC()\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tio.Copy(ioutil.Discard, NewReader(bytes.NewBuffer(buf1)))\n+\t}\n+}\n+\n+// These short names are so that gofmt doesn't break the BenchmarkXxx function\n+// bodies below over multiple lines.\n+const (\n+\tspeed    = BestSpeed\n+\tdefault_ = DefaultCompression\n+\tcompress = BestCompression\n+)\n+\n+func BenchmarkDecodeDigitsSpeed1e4(b *testing.B)    { benchmarkDecode(b, digits, speed, 1e4) }\n+func BenchmarkDecodeDigitsSpeed1e5(b *testing.B)    { benchmarkDecode(b, digits, speed, 1e5) }\n+func BenchmarkDecodeDigitsSpeed1e6(b *testing.B)    { benchmarkDecode(b, digits, speed, 1e6) }\n+func BenchmarkDecodeDigitsDefault1e4(b *testing.B)  { benchmarkDecode(b, digits, default_, 1e4) }\n+func BenchmarkDecodeDigitsDefault1e5(b *testing.B)  { benchmarkDecode(b, digits, default_, 1e5) }\n+func BenchmarkDecodeDigitsDefault1e6(b *testing.B)  { benchmarkDecode(b, digits, default_, 1e6) }\n+func BenchmarkDecodeDigitsCompress1e4(b *testing.B) { benchmarkDecode(b, digits, compress, 1e4) }\n+func BenchmarkDecodeDigitsCompress1e5(b *testing.B) { benchmarkDecode(b, digits, compress, 1e5) }\n+func BenchmarkDecodeDigitsCompress1e6(b *testing.B) { benchmarkDecode(b, digits, compress, 1e6) }\n+func BenchmarkDecodeTwainSpeed1e4(b *testing.B)     { benchmarkDecode(b, twain, speed, 1e4) }\n+func BenchmarkDecodeTwainSpeed1e5(b *testing.B)     { benchmarkDecode(b, twain, speed, 1e5) }\n+func BenchmarkDecodeTwainSpeed1e6(b *testing.B)     { benchmarkDecode(b, twain, speed, 1e6) }\n+func BenchmarkDecodeTwainDefault1e4(b *testing.B)   { benchmarkDecode(b, twain, default_, 1e4) }\n+func BenchmarkDecodeTwainDefault1e5(b *testing.B)   { benchmarkDecode(b, twain, default_, 1e5) }\n+func BenchmarkDecodeTwainDefault1e6(b *testing.B)   { benchmarkDecode(b, twain, default_, 1e6) }\n+func BenchmarkDecodeTwainCompress1e4(b *testing.B)  { benchmarkDecode(b, twain, compress, 1e4) }\n+func BenchmarkDecodeTwainCompress1e5(b *testing.B)  { benchmarkDecode(b, twain, compress, 1e5) }\n+func BenchmarkDecodeTwainCompress1e6(b *testing.B)  { benchmarkDecode(b, twain, compress, 1e6) }"}, {"sha": "a3990891be353c5a4d0fa482d3fb191b3bfc5174", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -370,7 +370,7 @@ func P384() Curve {\n \treturn p384\n }\n \n-// P256 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n+// P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n func P521() Curve {\n \tinitonce.Do(initAll)\n \treturn p521"}, {"sha": "e46e61d374acb0ca2a4fdb79367752aa205ca900", "filename": "libgo/go/crypto/rand/rand_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -30,3 +30,14 @@ func TestRead(t *testing.T) {\n \t\tt.Fatalf(\"Compressed %d -> %d\", len(b), z.Len())\n \t}\n }\n+\n+func TestReadEmpty(t *testing.T) {\n+\tn, err := Reader.Read(make([]byte, 0))\n+\tif n != 0 || err != nil {\n+\t\tt.Fatalf(\"Read(make([]byte, 0)) = %d, %v\", n, err)\n+\t}\n+\tn, err = Reader.Read(nil)\n+\tif n != 0 || err != nil {\n+\t\tt.Fatalf(\"Read(nil) = %d, %v\", n, err)\n+\t}\n+}"}, {"sha": "82b39b64a3c352e5f26e4d2bdc6e034a7b823a16", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -35,6 +35,10 @@ func (r *rngReader) Read(b []byte) (n int, err error) {\n \t\t}\n \t}\n \tr.mu.Unlock()\n+\n+\tif len(b) == 0 {\n+\t\treturn 0, nil\n+\t}\n \terr = syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])\n \tif err != nil {\n \t\treturn 0, os.NewSyscallError(\"CryptGenRandom\", err)"}, {"sha": "f39a48a6af6ad0d75fcefc97aac119735775b599", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -25,10 +25,10 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n \t\treturn\n \t}\n \n-\t// EM = 0x02 || PS || 0x00 || M\n-\tem := make([]byte, k-1)\n-\tem[0] = 2\n-\tps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):]\n+\t// EM = 0x00 || 0x02 || PS || 0x00 || M\n+\tem := make([]byte, k)\n+\tem[1] = 2\n+\tps, mm := em[2:len(em)-len(msg)-1], em[len(em)-len(msg):]\n \terr = nonZeroRandomBytes(ps, rand)\n \tif err != nil {\n \t\treturn\n@@ -38,7 +38,9 @@ func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, er\n \n \tm := new(big.Int).SetBytes(em)\n \tc := encrypt(new(big.Int), pub, m)\n-\tout = c.Bytes()\n+\n+\tcopyWithLeftPad(em, c.Bytes())\n+\tout = em\n \treturn\n }\n \n@@ -185,9 +187,12 @@ func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []b\n \n \tm := new(big.Int).SetBytes(em)\n \tc, err := decrypt(rand, priv, m)\n-\tif err == nil {\n-\t\ts = c.Bytes()\n+\tif err != nil {\n+\t\treturn\n \t}\n+\n+\tcopyWithLeftPad(em, c.Bytes())\n+\ts = em\n \treturn\n }\n \n@@ -241,3 +246,13 @@ func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte,\n \t}\n \treturn\n }\n+\n+// copyWithLeftPad copies src to the end of dest, padding with zero bytes as\n+// needed.\n+func copyWithLeftPad(dest, src []byte) {\n+\tnumPaddingBytes := len(dest) - len(src)\n+\tfor i := 0; i < numPaddingBytes; i++ {\n+\t\tdest[i] = 0\n+\t}\n+\tcopy(dest[numPaddingBytes:], src)\n+}"}, {"sha": "455910af41503575b69aa7aaca266fe763efe5e0", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -487,6 +487,16 @@ Again:\n \t\treturn err\n \t}\n \ttyp := recordType(b.data[0])\n+\n+\t// No valid TLS record has a type of 0x80, however SSLv2 handshakes\n+\t// start with a uint16 length where the MSB is set and the first record\n+\t// is always < 256 bytes long. Therefore typ == 0x80 strongly suggests\n+\t// an SSLv2 client.\n+\tif want == recordTypeHandshake && typ == 0x80 {\n+\t\tc.sendAlert(alertProtocolVersion)\n+\t\treturn errors.New(\"tls: unsupported SSLv2 handshake received\")\n+\t}\n+\n \tvers := uint16(b.data[1])<<8 | uint16(b.data[2])\n \tn := int(b.data[3])<<8 | int(b.data[4])\n \tif c.haveVers && vers != c.vers {"}, {"sha": "28814539d134e5c28edbb67a8a4d9492151cfc11", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -39,7 +39,7 @@ type CertificateInvalidError struct {\n func (e CertificateInvalidError) Error() string {\n \tswitch e.Reason {\n \tcase NotAuthorizedToSign:\n-\t\treturn \"x509: certificate is not authorized to sign other other certificates\"\n+\t\treturn \"x509: certificate is not authorized to sign other certificates\"\n \tcase Expired:\n \t\treturn \"x509: certificate has expired or is not yet valid\"\n \tcase CANotAuthorizedForThisName:"}, {"sha": "e6b0c58eef5a71c62f494a19b99c84098aef6998", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -344,6 +344,55 @@ func (c *Certificate) Equal(other *Certificate) bool {\n \treturn bytes.Equal(c.Raw, other.Raw)\n }\n \n+// Entrust have a broken root certificate (CN=Entrust.net Certification\n+// Authority (2048)) which isn't marked as a CA certificate and is thus invalid\n+// according to PKIX.\n+// We recognise this certificate by its SubjectPublicKeyInfo and exempt it\n+// from the Basic Constraints requirement.\n+// See http://www.entrust.net/knowledge-base/technote.cfm?tn=7869\n+//\n+// TODO(agl): remove this hack once their reissued root is sufficiently\n+// widespread.\n+var entrustBrokenSPKI = []byte{\n+\t0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,\n+\t0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,\n+\t0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,\n+\t0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,\n+\t0x00, 0x97, 0xa3, 0x2d, 0x3c, 0x9e, 0xde, 0x05,\n+\t0xda, 0x13, 0xc2, 0x11, 0x8d, 0x9d, 0x8e, 0xe3,\n+\t0x7f, 0xc7, 0x4b, 0x7e, 0x5a, 0x9f, 0xb3, 0xff,\n+\t0x62, 0xab, 0x73, 0xc8, 0x28, 0x6b, 0xba, 0x10,\n+\t0x64, 0x82, 0x87, 0x13, 0xcd, 0x57, 0x18, 0xff,\n+\t0x28, 0xce, 0xc0, 0xe6, 0x0e, 0x06, 0x91, 0x50,\n+\t0x29, 0x83, 0xd1, 0xf2, 0xc3, 0x2a, 0xdb, 0xd8,\n+\t0xdb, 0x4e, 0x04, 0xcc, 0x00, 0xeb, 0x8b, 0xb6,\n+\t0x96, 0xdc, 0xbc, 0xaa, 0xfa, 0x52, 0x77, 0x04,\n+\t0xc1, 0xdb, 0x19, 0xe4, 0xae, 0x9c, 0xfd, 0x3c,\n+\t0x8b, 0x03, 0xef, 0x4d, 0xbc, 0x1a, 0x03, 0x65,\n+\t0xf9, 0xc1, 0xb1, 0x3f, 0x72, 0x86, 0xf2, 0x38,\n+\t0xaa, 0x19, 0xae, 0x10, 0x88, 0x78, 0x28, 0xda,\n+\t0x75, 0xc3, 0x3d, 0x02, 0x82, 0x02, 0x9c, 0xb9,\n+\t0xc1, 0x65, 0x77, 0x76, 0x24, 0x4c, 0x98, 0xf7,\n+\t0x6d, 0x31, 0x38, 0xfb, 0xdb, 0xfe, 0xdb, 0x37,\n+\t0x02, 0x76, 0xa1, 0x18, 0x97, 0xa6, 0xcc, 0xde,\n+\t0x20, 0x09, 0x49, 0x36, 0x24, 0x69, 0x42, 0xf6,\n+\t0xe4, 0x37, 0x62, 0xf1, 0x59, 0x6d, 0xa9, 0x3c,\n+\t0xed, 0x34, 0x9c, 0xa3, 0x8e, 0xdb, 0xdc, 0x3a,\n+\t0xd7, 0xf7, 0x0a, 0x6f, 0xef, 0x2e, 0xd8, 0xd5,\n+\t0x93, 0x5a, 0x7a, 0xed, 0x08, 0x49, 0x68, 0xe2,\n+\t0x41, 0xe3, 0x5a, 0x90, 0xc1, 0x86, 0x55, 0xfc,\n+\t0x51, 0x43, 0x9d, 0xe0, 0xb2, 0xc4, 0x67, 0xb4,\n+\t0xcb, 0x32, 0x31, 0x25, 0xf0, 0x54, 0x9f, 0x4b,\n+\t0xd1, 0x6f, 0xdb, 0xd4, 0xdd, 0xfc, 0xaf, 0x5e,\n+\t0x6c, 0x78, 0x90, 0x95, 0xde, 0xca, 0x3a, 0x48,\n+\t0xb9, 0x79, 0x3c, 0x9b, 0x19, 0xd6, 0x75, 0x05,\n+\t0xa0, 0xf9, 0x88, 0xd7, 0xc1, 0xe8, 0xa5, 0x09,\n+\t0xe4, 0x1a, 0x15, 0xdc, 0x87, 0x23, 0xaa, 0xb2,\n+\t0x75, 0x8c, 0x63, 0x25, 0x87, 0xd8, 0xf8, 0x3d,\n+\t0xa6, 0xc2, 0xcc, 0x66, 0xff, 0xa5, 0x66, 0x68,\n+\t0x55, 0x02, 0x03, 0x01, 0x00, 0x01,\n+}\n+\n // CheckSignatureFrom verifies that the signature on c is a valid signature\n // from parent.\n func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error) {\n@@ -352,8 +401,10 @@ func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error) {\n \t// certificate, or the extension is present but the cA boolean is not\n \t// asserted, then the certified public key MUST NOT be used to verify\n \t// certificate signatures.\"\n-\tif parent.Version == 3 && !parent.BasicConstraintsValid ||\n-\t\tparent.BasicConstraintsValid && !parent.IsCA {\n+\t// (except for Entrust, see comment above entrustBrokenSPKI)\n+\tif (parent.Version == 3 && !parent.BasicConstraintsValid ||\n+\t\tparent.BasicConstraintsValid && !parent.IsCA) &&\n+\t\t!bytes.Equal(c.RawSubjectPublicKeyInfo, entrustBrokenSPKI) {\n \t\treturn ConstraintViolationError{}\n \t}\n "}, {"sha": "a11fb788ef780cf22738d752763c5734e6af303d", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -31,7 +31,7 @@ var _ = log.Printf\n //   INSERT|<tablename>|col=val,col2=val2,col3=?\n //   SELECT|<tablename>|projectcol1,projectcol2|filtercol=?,filtercol2=?\n //\n-// When opening a a fakeDriver's database, it starts empty with no\n+// When opening a fakeDriver's database, it starts empty with no\n // tables.  All tables and data are stored in memory only.\n type fakeDriver struct {\n \tmu        sync.Mutex\n@@ -234,7 +234,7 @@ func checkSubsetTypes(args []driver.Value) error {\n \n func (c *fakeConn) Exec(query string, args []driver.Value) (driver.Result, error) {\n \t// This is an optional interface, but it's implemented here\n-\t// just to check that all the args of of the proper types.\n+\t// just to check that all the args are of the proper types.\n \t// ErrSkip is returned so the caller acts as if we didn't\n \t// implement this at all.\n \terr := checkSubsetTypes(args)\n@@ -249,7 +249,7 @@ func errf(msg string, args ...interface{}) error {\n }\n \n // parts are table|selectCol1,selectCol2|whereCol=?,whereCol2=?\n-// (note that where where columns must always contain ? marks,\n+// (note that where columns must always contain ? marks,\n //  just a limitation for fakedb)\n func (c *fakeConn) prepareSelect(stmt *fakeStmt, parts []string) (driver.Stmt, error) {\n \tif len(parts) != 3 {"}, {"sha": "d557fc8303451e039a9e78df0079ad1e77502181", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -311,7 +311,10 @@ func (db *DB) prepare(query string) (stmt *Stmt, err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer db.putConn(ci, err)\n+\tdefer func() {\n+\t\tdb.putConn(ci, err)\n+\t}()\n+\n \tsi, err := ci.Prepare(query)\n \tif err != nil {\n \t\treturn nil, err\n@@ -345,7 +348,9 @@ func (db *DB) exec(query string, sargs []driver.Value) (res Result, err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer db.putConn(ci, err)\n+\tdefer func() {\n+\t\tdb.putConn(ci, err)\n+\t}()\n \n \tif execer, ok := ci.(driver.Execer); ok {\n \t\tresi, err := execer.Exec(query, sargs)"}, {"sha": "719018b6033a83a657d599447f0b66a592e2c210", "filename": "libgo/go/encoding/binary/varint.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -123,7 +123,7 @@ func ReadUvarint(r io.ByteReader) (uint64, error) {\n \tpanic(\"unreachable\")\n }\n \n-// ReadVarint reads an encoded unsigned integer from r and returns it as a uint64.\n+// ReadVarint reads an encoded unsigned integer from r and returns it as an int64.\n func ReadVarint(r io.ByteReader) (int64, error) {\n \tux, err := ReadUvarint(r) // ok to continue in presence of error\n \tx := int64(ux >> 1)"}, {"sha": "8690b35d71481082e0ef8d8b6aebe641e9a759cc", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -562,6 +562,9 @@ func (dec *Decoder) ignoreSingle(engine *decEngine) {\n func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl error) {\n \tinstr := &decInstr{elemOp, 0, elemIndir, 0, ovfl}\n \tfor i := 0; i < length; i++ {\n+\t\tif state.b.Len() == 0 {\n+\t\t\terrorf(\"decoding array or slice: length exceeds input size (%d elements)\", length)\n+\t\t}\n \t\tup := unsafe.Pointer(p)\n \t\tif elemIndir > 1 {\n \t\t\tup = decIndirect(up, elemIndir)\n@@ -652,9 +655,6 @@ func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n // Slices are encoded as an unsigned length followed by the elements.\n func (dec *Decoder) decodeSlice(atyp reflect.Type, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl error) {\n \tnr := state.decodeUint()\n-\tif nr > uint64(state.b.Len()) {\n-\t\terrorf(\"length of slice exceeds input size (%d elements)\", nr)\n-\t}\n \tn := int(nr)\n \tif indir > 0 {\n \t\tup := unsafe.Pointer(p)"}, {"sha": "6d77c171f412739f599ddbb73df3f804f01e7558", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -118,7 +118,7 @@ elements using the standard gob encoding for their type, recursively.\n \n Maps are sent as an unsigned count followed by that many key, element\n pairs. Empty but non-nil maps are sent, so if the sender has allocated\n-a map, the receiver will allocate a map even no elements are\n+a map, the receiver will allocate a map even if no elements are\n transmitted.\n \n Structs are sent as a sequence of (field number, field value) pairs.  The field"}, {"sha": "db824d99917ddf319b6494f6645273df7c1519f3", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -736,3 +736,32 @@ func TestPtrToMapOfMap(t *testing.T) {\n \t\tt.Fatalf(\"expected %v got %v\", data, newData)\n \t}\n }\n+\n+// There was an error check comparing the length of the input with the\n+// length of the slice being decoded. It was wrong because the next\n+// thing in the input might be a type definition, which would lead to\n+// an incorrect length check.  This test reproduces the corner case.\n+\n+type Z struct {\n+}\n+\n+func Test29ElementSlice(t *testing.T) {\n+\tRegister(Z{})\n+\tsrc := make([]interface{}, 100) // Size needs to be bigger than size of type definition.\n+\tfor i := range src {\n+\t\tsrc[i] = Z{}\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\terr := NewEncoder(buf).Encode(src)\n+\tif err != nil {\n+\t\tt.Fatalf(\"encode: %v\", err)\n+\t\treturn\n+\t}\n+\n+\tvar dst []interface{}\n+\terr = NewDecoder(buf).Decode(&dst)\n+\tif err != nil {\n+\t\tt.Errorf(\"decode: %v\", err)\n+\t\treturn\n+\t}\n+}"}, {"sha": "a8ee2fa4a5a474697b036c5cf52def4e3d019363", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -749,12 +749,28 @@ func Register(value interface{}) {\n \trt := reflect.TypeOf(value)\n \tname := rt.String()\n \n-\t// But for named types (or pointers to them), qualify with import path.\n+\t// But for named types (or pointers to them), qualify with import path (but see inner comment).\n \t// Dereference one pointer looking for a named type.\n \tstar := \"\"\n \tif rt.Name() == \"\" {\n \t\tif pt := rt; pt.Kind() == reflect.Ptr {\n \t\t\tstar = \"*\"\n+\t\t\t// NOTE: The following line should be rt = pt.Elem() to implement\n+\t\t\t// what the comment above claims, but fixing it would break compatibility\n+\t\t\t// with existing gobs.\n+\t\t\t//\n+\t\t\t// Given package p imported as \"full/p\" with these definitions:\n+\t\t\t//     package p\n+\t\t\t//     type T1 struct { ... }\n+\t\t\t// this table shows the intended and actual strings used by gob to\n+\t\t\t// name the types:\n+\t\t\t//\n+\t\t\t// Type      Correct string     Actual string\n+\t\t\t//\n+\t\t\t// T1        full/p.T1          full/p.T1\n+\t\t\t// *T1       *full/p.T1         *p.T1\n+\t\t\t//\n+\t\t\t// The missing full path cannot be fixed without breaking existing gob decoders.\n \t\t\trt = pt\n \t\t}\n \t}"}, {"sha": "d2c1c4424c713e76a66d41927de368dcd2e85e3b", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -55,7 +55,7 @@ import (\n // nil pointer or interface value, and any array, slice, map, or string of\n // length zero. The object's default key string is the struct field name\n // but can be specified in the struct field's tag value. The \"json\" key in\n-// struct field's tag value is the key name, followed by an optional comma\n+// the struct field's tag value is the key name, followed by an optional comma\n // and options. Examples:\n //\n //   // Field is ignored by this package."}, {"sha": "bbabd88c8ca394b8b3da43e74f8478a6fb2da896", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -33,7 +33,7 @@\n \n \tAfter parsing, the arguments after the flag are available as the\n \tslice flag.Args() or individually as flag.Arg(i).\n-\tThe arguments are indexed from 0 up to flag.NArg().\n+\tThe arguments are indexed from 0 through flag.NArg()-1.\n \n \tCommand line flag syntax:\n \t\t-flag\n@@ -707,7 +707,7 @@ func (f *FlagSet) parseOne() (bool, error) {\n \tif fv, ok := flag.Value.(*boolValue); ok { // special case: doesn't need an arg\n \t\tif has_value {\n \t\t\tif err := fv.Set(value); err != nil {\n-\t\t\t\tf.failf(\"invalid boolean value %q for  -%s: %v\", value, name, err)\n+\t\t\t\treturn false, f.failf(\"invalid boolean value %q for  -%s: %v\", value, name, err)\n \t\t\t}\n \t\t} else {\n \t\t\tfv.Set(\"true\")"}, {"sha": "98ebfb74161f2c0bb06a37488af1272f94fbdda8", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -844,3 +844,15 @@ func TestIsSpace(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestNilDoesNotBecomeTyped(t *testing.T) {\n+\ttype A struct{}\n+\ttype B struct{}\n+\tvar a *A = nil\n+\tvar b B = B{}\n+\tgot := Sprintf(\"%s %s %s %s %s\", nil, a, nil, b, nil)\n+\tconst expect = \"%!s(<nil>) %!s(*fmt_test.A=<nil>) %!s(<nil>) {} %!s(<nil>)\"\n+\tif got != expect {\n+\t\tt.Errorf(\"expected:\\n\\t%q\\ngot:\\n\\t%q\", expect, got)\n+\t}\n+}"}, {"sha": "f29e8c8e9f138bd033025ed7347695120ed7e518", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -712,6 +712,9 @@ func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString\n }\n \n func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n+\tp.field = field\n+\tp.value = reflect.Value{}\n+\n \tif field == nil {\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.buf.Write(nilAngleBytes)\n@@ -721,8 +724,6 @@ func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth\n \t\treturn false\n \t}\n \n-\tp.field = field\n-\tp.value = reflect.Value{}\n \t// Special processing considerations.\n \t// %T (the value's type) and %p (its address) are special; we always do them first.\n \tswitch verb {"}, {"sha": "2de9af299e5cd811a60354dc99a8244b4bda94a4", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -34,7 +34,8 @@ func NotNilFilter(_ string, v reflect.Value) bool {\n //\n // A non-nil FieldFilter f may be provided to control the output:\n // struct fields for which f(fieldname, fieldvalue) is true are\n-// are printed; all others are filtered from the output.\n+// are printed; all others are filtered from the output. Unexported\n+// struct fields are never printed.\n //\n func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (err error) {\n \t// setup printer\n@@ -145,15 +146,18 @@ func (p *printer) print(x reflect.Value) {\n \t\tp.print(x.Elem())\n \n \tcase reflect.Map:\n-\t\tp.printf(\"%s (len = %d) {\\n\", x.Type(), x.Len())\n-\t\tp.indent++\n-\t\tfor _, key := range x.MapKeys() {\n-\t\t\tp.print(key)\n-\t\t\tp.printf(\": \")\n-\t\t\tp.print(x.MapIndex(key))\n+\t\tp.printf(\"%s (len = %d) {\", x.Type(), x.Len())\n+\t\tif x.Len() > 0 {\n+\t\t\tp.indent++\n \t\t\tp.printf(\"\\n\")\n+\t\t\tfor _, key := range x.MapKeys() {\n+\t\t\t\tp.print(key)\n+\t\t\t\tp.printf(\": \")\n+\t\t\t\tp.print(x.MapIndex(key))\n+\t\t\t\tp.printf(\"\\n\")\n+\t\t\t}\n+\t\t\tp.indent--\n \t\t}\n-\t\tp.indent--\n \t\tp.printf(\"}\")\n \n \tcase reflect.Ptr:\n@@ -169,32 +173,57 @@ func (p *printer) print(x reflect.Value) {\n \t\t\tp.print(x.Elem())\n \t\t}\n \n+\tcase reflect.Array:\n+\t\tp.printf(\"%s {\", x.Type())\n+\t\tif x.Len() > 0 {\n+\t\t\tp.indent++\n+\t\t\tp.printf(\"\\n\")\n+\t\t\tfor i, n := 0, x.Len(); i < n; i++ {\n+\t\t\t\tp.printf(\"%d: \", i)\n+\t\t\t\tp.print(x.Index(i))\n+\t\t\t\tp.printf(\"\\n\")\n+\t\t\t}\n+\t\t\tp.indent--\n+\t\t}\n+\t\tp.printf(\"}\")\n+\n \tcase reflect.Slice:\n \t\tif s, ok := x.Interface().([]byte); ok {\n \t\t\tp.printf(\"%#q\", s)\n \t\t\treturn\n \t\t}\n-\t\tp.printf(\"%s (len = %d) {\\n\", x.Type(), x.Len())\n-\t\tp.indent++\n-\t\tfor i, n := 0, x.Len(); i < n; i++ {\n-\t\t\tp.printf(\"%d: \", i)\n-\t\t\tp.print(x.Index(i))\n+\t\tp.printf(\"%s (len = %d) {\", x.Type(), x.Len())\n+\t\tif x.Len() > 0 {\n+\t\t\tp.indent++\n \t\t\tp.printf(\"\\n\")\n+\t\t\tfor i, n := 0, x.Len(); i < n; i++ {\n+\t\t\t\tp.printf(\"%d: \", i)\n+\t\t\t\tp.print(x.Index(i))\n+\t\t\t\tp.printf(\"\\n\")\n+\t\t\t}\n+\t\t\tp.indent--\n \t\t}\n-\t\tp.indent--\n \t\tp.printf(\"}\")\n \n \tcase reflect.Struct:\n-\t\tp.printf(\"%s {\\n\", x.Type())\n-\t\tp.indent++\n \t\tt := x.Type()\n+\t\tp.printf(\"%s {\", t)\n+\t\tp.indent++\n+\t\tfirst := true\n \t\tfor i, n := 0, t.NumField(); i < n; i++ {\n-\t\t\tname := t.Field(i).Name\n-\t\t\tvalue := x.Field(i)\n-\t\t\tif p.filter == nil || p.filter(name, value) {\n-\t\t\t\tp.printf(\"%s: \", name)\n-\t\t\t\tp.print(value)\n-\t\t\t\tp.printf(\"\\n\")\n+\t\t\t// exclude non-exported fields because their\n+\t\t\t// values cannot be accessed via reflection\n+\t\t\tif name := t.Field(i).Name; IsExported(name) {\n+\t\t\t\tvalue := x.Field(i)\n+\t\t\t\tif p.filter == nil || p.filter(name, value) {\n+\t\t\t\t\tif first {\n+\t\t\t\t\t\tp.printf(\"\\n\")\n+\t\t\t\t\t\tfirst = false\n+\t\t\t\t\t}\n+\t\t\t\t\tp.printf(\"%s: \", name)\n+\t\t\t\t\tp.print(value)\n+\t\t\t\t\tp.printf(\"\\n\")\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tp.indent--"}, {"sha": "210f1643010c716bae62b262a9797baaf94045a0", "filename": "libgo/go/go/ast/print_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -23,6 +23,7 @@ var tests = []struct {\n \t{\"foobar\", \"0  \\\"foobar\\\"\"},\n \n \t// maps\n+\t{map[Expr]string{}, `0  map[ast.Expr]string (len = 0) {}`},\n \t{map[string]int{\"a\": 1},\n \t\t`0  map[string]int (len = 1) {\n \t\t1  .  \"a\": 1\n@@ -31,7 +32,21 @@ var tests = []struct {\n \t// pointers\n \t{new(int), \"0  *0\"},\n \n+\t// arrays\n+\t{[0]int{}, `0  [0]int {}`},\n+\t{[3]int{1, 2, 3},\n+\t\t`0  [3]int {\n+\t\t1  .  0: 1\n+\t\t2  .  1: 2\n+\t\t3  .  2: 3\n+\t\t4  }`},\n+\t{[...]int{42},\n+\t\t`0  [1]int {\n+\t\t1  .  0: 42\n+\t\t2  }`},\n+\n \t// slices\n+\t{[]int{}, `0  []int (len = 0) {}`},\n \t{[]int{1, 2, 3},\n \t\t`0  []int (len = 3) {\n \t\t1  .  0: 1\n@@ -40,6 +55,12 @@ var tests = []struct {\n \t\t4  }`},\n \n \t// structs\n+\t{struct{}{}, `0  struct {} {}`},\n+\t{struct{ x int }{007}, `0  struct { x int } {}`},\n+\t{struct{ X, y int }{42, 991},\n+\t\t`0  struct { X int; y int } {\n+\t\t1  .  X: 42\n+\t\t2  }`},\n \t{struct{ X, Y int }{42, 991},\n \t\t`0  struct { X int; Y int } {\n \t\t1  .  X: 42"}, {"sha": "54b5d73252d1b8d417e21bf37aedb9c66e831b23", "filename": "libgo/go/go/ast/resolve.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fresolve.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -136,7 +136,7 @@ func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer,\n \t\t\t\tfor _, obj := range pkg.Data.(*Scope).Objects {\n \t\t\t\t\tp.declare(fileScope, pkgScope, obj)\n \t\t\t\t}\n-\t\t\t} else {\n+\t\t\t} else if name != \"_\" {\n \t\t\t\t// declare imported package object in file scope\n \t\t\t\t// (do not re-use pkg in the file scope but create\n \t\t\t\t// a new object instead; the Decl field is different"}, {"sha": "66b1dc2499b986d54684428e47db256a00288ac9", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -344,9 +344,6 @@ func Walk(v Visitor, node Node) {\n \t\t}\n \t\tWalk(v, n.Name)\n \t\twalkDeclList(v, n.Decls)\n-\t\tfor _, g := range n.Comments {\n-\t\t\tWalk(v, g)\n-\t\t}\n \t\t// don't walk n.Comments - they have been\n \t\t// visited already through the individual\n \t\t// nodes"}, {"sha": "67e73c5e4a4e5d172b026f818e708be7bce1bcae", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -536,7 +536,7 @@ Found:\n \t\t\treturn p, err\n \t\t}\n \n-\t\tpkg := string(pf.Name.Name)\n+\t\tpkg := pf.Name.Name\n \t\tif pkg == \"documentation\" {\n \t\t\tcontinue\n \t\t}\n@@ -570,7 +570,7 @@ Found:\n \t\t\t\tif !ok {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tquoted := string(spec.Path.Value)\n+\t\t\t\tquoted := spec.Path.Value\n \t\t\t\tpath, err := strconv.Unquote(quoted)\n \t\t\t\tif err != nil {\n \t\t\t\t\tlog.Panicf(\"%s: parser returned invalid quoted string: <%s>\", filename, quoted)\n@@ -678,7 +678,7 @@ func (ctxt *Context) shouldBuild(content []byte) bool {\n \t\t}\n \t\tline = bytes.TrimSpace(line)\n \t\tif len(line) == 0 { // Blank line\n-\t\t\tend = cap(content) - cap(line) // &line[0] - &content[0]\n+\t\t\tend = len(content) - len(p)\n \t\t\tcontinue\n \t\t}\n \t\tif !bytes.HasPrefix(line, slashslash) { // Not comment line"}, {"sha": "caa4f26f332e696ceaa78ad523056b6376f1fda2", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -75,3 +75,32 @@ func TestLocalDirectory(t *testing.T) {\n \t\tt.Fatalf(\"ImportPath=%q, want %q\", p.ImportPath, \"go/build\")\n \t}\n }\n+\n+func TestShouldBuild(t *testing.T) {\n+\tconst file1 = \"// +build tag1\\n\\n\" +\n+\t\t\"package main\\n\"\n+\n+\tconst file2 = \"// +build cgo\\n\\n\" +\n+\t\t\"// This package implements parsing of tags like\\n\" +\n+\t\t\"// +build tag1\\n\" +\n+\t\t\"package build\"\n+\n+\tconst file3 = \"// Copyright The Go Authors.\\n\\n\" +\n+\t\t\"package build\\n\\n\" +\n+\t\t\"// shouldBuild checks tags given by lines of the form\\n\" +\n+\t\t\"// +build tag\\n\" +\n+\t\t\"func shouldBuild(content []byte)\\n\"\n+\n+\tctx := &Context{BuildTags: []string{\"tag1\"}}\n+\tif !ctx.shouldBuild([]byte(file1)) {\n+\t\tt.Errorf(\"should not build file1, expected the contrary\")\n+\t}\n+\tif ctx.shouldBuild([]byte(file2)) {\n+\t\tt.Errorf(\"should build file2, expected the contrary\")\n+\t}\n+\n+\tctx = &Context{BuildTags: nil}\n+\tif !ctx.shouldBuild([]byte(file3)) {\n+\t\tt.Errorf(\"should not build file3, expected the contrary\")\n+\t}\n+}"}, {"sha": "9b7a946f2b8455090eb7e55dfc04684b68ee9df3", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -60,7 +60,7 @@\n // A build constraint is a line comment beginning with the directive +build\n // that lists the conditions under which a file should be included in the package.\n // Constraints may appear in any kind of source file (not just Go), but\n-// they must be appear near the top of the file, preceded\n+// they must appear near the top of the file, preceded\n // only by blank lines and other line comments.\n //\n // A build constraint is evaluated as the OR of space-separated options;"}, {"sha": "60b174fecd822cfeb7e8fe4b3cb7f40f313de271", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -494,7 +494,7 @@ func (r *reader) readPackage(pkg *ast.Package, mode Mode) {\n \tr.funcs = make(methodSet)\n \n \t// sort package files before reading them so that the\n-\t// result result does not depend on map iteration order\n+\t// result does not depend on map iteration order\n \ti := 0\n \tfor filename := range pkg.Files {\n \t\tr.filenames[i] = filename"}, {"sha": "dbcc1b03e7891b7b03aa78d4fdffa03246244407", "filename": "libgo/go/go/doc/testdata/error2.1.golden", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.1.golden?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -10,7 +10,7 @@ FILENAMES\n TYPES\n \t// \n \ttype I0 interface {\n-\t\t// When embedded, the the locally declared error interface\n+\t\t// When embedded, the locally-declared error interface\n \t\t// is only visible if all declarations are shown.\n \t\terror\n \t}"}, {"sha": "6ee96c2450bce190e0ca75264689d04cd230f122", "filename": "libgo/go/go/doc/testdata/error2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ferror2.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -5,7 +5,7 @@\n package error2\n \n type I0 interface {\n-\t// When embedded, the the locally declared error interface\n+\t// When embedded, the locally-declared error interface\n \t// is only visible if all declarations are shown.\n \terror\n }"}, {"sha": "e346b93643b19b984963a999a72e1d231c722e33", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -325,9 +325,14 @@ func (p *printer) parameters(fields *ast.FieldList) {\n }\n \n func (p *printer) signature(params, result *ast.FieldList) {\n-\tp.parameters(params)\n+\tif params != nil {\n+\t\tp.parameters(params)\n+\t} else {\n+\t\tp.print(token.LPAREN, token.RPAREN)\n+\t}\n \tn := result.NumFields()\n \tif n > 0 {\n+\t\t// result != nil\n \t\tp.print(blank)\n \t\tif n == 1 && result.List[0].Names == nil {\n \t\t\t// single anonymous result; no ()'s"}, {"sha": "ab9e9b2ec8cefc02f0f74bbb1d43dbba86fa8216", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -385,6 +385,35 @@ func (t *t) foo(a, b, c int) int {\n \t}\n }\n \n+// TestFuncType tests that an ast.FuncType with a nil Params field\n+// can be printed (per go/ast specification). Test case for issue 3870.\n+func TestFuncType(t *testing.T) {\n+\tsrc := &ast.File{\n+\t\tName: &ast.Ident{Name: \"p\"},\n+\t\tDecls: []ast.Decl{\n+\t\t\t&ast.FuncDecl{\n+\t\t\t\tName: &ast.Ident{Name: \"f\"},\n+\t\t\t\tType: &ast.FuncType{},\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\tif err := Fprint(&buf, fset, src); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tgot := buf.String()\n+\n+\tconst want = `package p\n+\n+func f()\n+`\n+\n+\tif got != want {\n+\t\tt.Fatalf(\"got:\\n%s\\nwant:\\n%s\\n\", got, want)\n+\t}\n+}\n+\n // TextX is a skeleton test that can be filled in for debugging one-off cases.\n // Do not remove.\n func TestX(t *testing.T) {"}, {"sha": "22de69c3c1c824a7d773b4fdfe700fa43172da08", "filename": "libgo/go/go/scanner/errors.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -120,7 +120,7 @@ func PrintError(w io.Writer, err error) {\n \t\tfor _, e := range list {\n \t\t\tfmt.Fprintf(w, \"%s\\n\", e)\n \t\t}\n-\t} else {\n+\t} else if err != nil {\n \t\tfmt.Fprintf(w, \"%s\\n\", err)\n \t}\n }"}, {"sha": "6ef3e14d0bd350ab605f22fc7a08c7a0d5a8a887", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -81,7 +81,7 @@ func (s *Scanner) next() {\n \t}\n }\n \n-// A mode value is set of flags (or 0).\n+// A mode value is a set of flags (or 0).\n // They control scanner behavior.\n //\n type Mode uint"}, {"sha": "42ea7930f07f93e83b122a8596f3585dbf5ddcd3", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -47,7 +47,7 @@ type (\n \t// JSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not.\n \tJSStr string\n \n-\t// URL encapsulates a known safe URL as defined in RFC 3896.\n+\t// URL encapsulates a known safe URL or URL substring (see RFC 3986).\n \t// A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()`\n \t// from a trusted source should go in the page, but by default dynamic\n \t// `javascript:` URLs are filtered out since they are a frequently"}, {"sha": "2ca76bf389fd332781cef026d7311c80e0ac3520", "filename": "libgo/go/html/template/url.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Furl.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -60,7 +60,7 @@ func urlProcessor(norm bool, args ...interface{}) string {\n \t\tc := s[i]\n \t\tswitch c {\n \t\t// Single quote and parens are sub-delims in RFC 3986, but we\n-\t\t// escape them so the output can be embedded in in single\n+\t\t// escape them so the output can be embedded in single\n \t\t// quoted attributes and unquoted CSS url(...) constructs.\n \t\t// Single quotes are reserved in URLs, but are only used in\n \t\t// the obsolete \"mark\" rule in an appendix in RFC 3986"}, {"sha": "8da3611919e28291d11821fccc8924ba17a3d77f", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -74,7 +74,9 @@ const (\n \tcomMarker   = 0xfe // COMment.\n )\n \n-// Maps from the zig-zag ordering to the natural ordering.\n+// unzig maps from the zig-zag ordering to the natural ordering. For example,\n+// unzig[3] is the column and row of the fourth element in zig-zag order. The\n+// value is 16, which means first column (16%8 == 0) and third row (16/8 == 2).\n var unzig = [blockSize]int{\n \t0, 1, 8, 16, 9, 2, 3, 10,\n \t17, 24, 32, 25, 18, 11, 4, 5,\n@@ -101,7 +103,7 @@ type decoder struct {\n \tnComp         int\n \tcomp          [nColorComponent]component\n \thuff          [maxTc + 1][maxTh + 1]huffman\n-\tquant         [maxTq + 1]block\n+\tquant         [maxTq + 1]block // Quantization tables, in zig-zag order.\n \tb             bits\n \ttmp           [1024]byte\n }\n@@ -264,6 +266,7 @@ func (d *decoder) processSOS(n int) error {\n \t\t\t\tfor j := 0; j < d.comp[i].h*d.comp[i].v; j++ {\n \t\t\t\t\t// TODO(nigeltao): make this a \"var b block\" once the compiler's escape\n \t\t\t\t\t// analysis is good enough to allocate it on the stack, not the heap.\n+\t\t\t\t\t// b is in natural (not zig-zag) order.\n \t\t\t\t\tb = block{}\n \n \t\t\t\t\t// Decode the DC coefficient, as specified in section F.2.2.1.\n@@ -282,28 +285,28 @@ func (d *decoder) processSOS(n int) error {\n \t\t\t\t\tb[0] = dc[i] * qt[0]\n \n \t\t\t\t\t// Decode the AC coefficients, as specified in section F.2.2.2.\n-\t\t\t\t\tfor k := 1; k < blockSize; k++ {\n+\t\t\t\t\tfor zig := 1; zig < blockSize; zig++ {\n \t\t\t\t\t\tvalue, err := d.decodeHuffman(&d.huff[acTable][scan[i].ta])\n \t\t\t\t\t\tif err != nil {\n \t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t}\n \t\t\t\t\t\tval0 := value >> 4\n \t\t\t\t\t\tval1 := value & 0x0f\n \t\t\t\t\t\tif val1 != 0 {\n-\t\t\t\t\t\t\tk += int(val0)\n-\t\t\t\t\t\t\tif k > blockSize {\n+\t\t\t\t\t\t\tzig += int(val0)\n+\t\t\t\t\t\t\tif zig > blockSize {\n \t\t\t\t\t\t\t\treturn FormatError(\"bad DCT index\")\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tac, err := d.receiveExtend(val1)\n \t\t\t\t\t\t\tif err != nil {\n \t\t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tb[unzig[k]] = ac * qt[k]\n+\t\t\t\t\t\t\tb[unzig[zig]] = ac * qt[zig]\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tif val0 != 0x0f {\n \t\t\t\t\t\t\t\tbreak\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tk += 0x0f\n+\t\t\t\t\t\t\tzig += 0x0f\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n@@ -393,6 +396,15 @@ func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\n \t\tif marker == eoiMarker { // End Of Image.\n \t\t\tbreak\n \t\t}\n+\t\tif rst0Marker <= marker && marker <= rst7Marker {\n+\t\t\t// Figures B.2 and B.16 of the specification suggest that restart markers should\n+\t\t\t// only occur between Entropy Coded Segments and not after the final ECS.\n+\t\t\t// However, some encoders may generate incorrect JPEGs with a final restart\n+\t\t\t// marker. That restart marker will be seen here instead of inside the processSOS\n+\t\t\t// method, and is ignored as a harmless error. Restart markers have no extra data,\n+\t\t\t// so we check for this before we read the 16-bit length of the segment.\n+\t\t\tcontinue\n+\t\t}\n \n \t\t// Read the 16-bit length of the segment. The value includes the 2 bytes for the\n \t\t// length itself, so we subtract 2 to get the number of remaining bytes.\n@@ -421,7 +433,7 @@ func (d *decoder) decode(r io.Reader, configOnly bool) (image.Image, error) {\n \t\t\terr = d.processSOS(n)\n \t\tcase marker == driMarker: // Define Restart Interval.\n \t\t\terr = d.processDRI(n)\n-\t\tcase marker >= app0Marker && marker <= app15Marker || marker == comMarker: // APPlication specific, or COMment.\n+\t\tcase app0Marker <= marker && marker <= app15Marker || marker == comMarker: // APPlication specific, or COMment.\n \t\t\terr = d.ignore(n)\n \t\tdefault:\n \t\t\terr = UnsupportedError(\"unknown marker\")"}, {"sha": "099298e462ec72838529d692c265f850bbfc5fe2", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -56,26 +56,28 @@ const (\n \tnQuantIndex\n )\n \n-// unscaledQuant are the unscaled quantization tables. Each encoder copies and\n-// scales the tables according to its quality parameter.\n+// unscaledQuant are the unscaled quantization tables in zig-zag order. Each\n+// encoder copies and scales the tables according to its quality parameter.\n+// The values are derived from section K.1 after converting from natural to\n+// zig-zag order.\n var unscaledQuant = [nQuantIndex][blockSize]byte{\n \t// Luminance.\n \t{\n-\t\t16, 11, 10, 16, 24, 40, 51, 61,\n-\t\t12, 12, 14, 19, 26, 58, 60, 55,\n-\t\t14, 13, 16, 24, 40, 57, 69, 56,\n-\t\t14, 17, 22, 29, 51, 87, 80, 62,\n-\t\t18, 22, 37, 56, 68, 109, 103, 77,\n-\t\t24, 35, 55, 64, 81, 104, 113, 92,\n-\t\t49, 64, 78, 87, 103, 121, 120, 101,\n-\t\t72, 92, 95, 98, 112, 100, 103, 99,\n+\t\t16, 11, 12, 14, 12, 10, 16, 14,\n+\t\t13, 14, 18, 17, 16, 19, 24, 40,\n+\t\t26, 24, 22, 22, 24, 49, 35, 37,\n+\t\t29, 40, 58, 51, 61, 60, 57, 51,\n+\t\t56, 55, 64, 72, 92, 78, 64, 68,\n+\t\t87, 69, 55, 56, 80, 109, 81, 87,\n+\t\t95, 98, 103, 104, 103, 62, 77, 113,\n+\t\t121, 112, 100, 120, 92, 101, 103, 99,\n \t},\n \t// Chrominance.\n \t{\n-\t\t17, 18, 24, 47, 99, 99, 99, 99,\n-\t\t18, 21, 26, 66, 99, 99, 99, 99,\n-\t\t24, 26, 56, 99, 99, 99, 99, 99,\n-\t\t47, 66, 99, 99, 99, 99, 99, 99,\n+\t\t17, 18, 18, 24, 21, 24, 47, 26,\n+\t\t26, 47, 99, 66, 56, 66, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n \t\t99, 99, 99, 99, 99, 99, 99, 99,\n \t\t99, 99, 99, 99, 99, 99, 99, 99,\n \t\t99, 99, 99, 99, 99, 99, 99, 99,\n@@ -222,7 +224,7 @@ type encoder struct {\n \tbuf [16]byte\n \t// bits and nBits are accumulated bits to write to w.\n \tbits, nBits uint32\n-\t// quant is the scaled quantization tables.\n+\t// quant is the scaled quantization tables, in zig-zag order.\n \tquant [nQuantIndex][blockSize]byte\n }\n \n@@ -301,7 +303,7 @@ func (e *encoder) writeMarkerHeader(marker uint8, markerlen int) {\n \n // writeDQT writes the Define Quantization Table marker.\n func (e *encoder) writeDQT() {\n-\tmarkerlen := 2 + int(nQuantIndex)*(1+blockSize)\n+\tconst markerlen = 2 + int(nQuantIndex)*(1+blockSize)\n \te.writeMarkerHeader(dqtMarker, markerlen)\n \tfor i := range e.quant {\n \t\te.writeByte(uint8(i))\n@@ -311,7 +313,7 @@ func (e *encoder) writeDQT() {\n \n // writeSOF0 writes the Start Of Frame (Baseline) marker.\n func (e *encoder) writeSOF0(size image.Point) {\n-\tmarkerlen := 8 + 3*nColorComponent\n+\tconst markerlen = 8 + 3*nColorComponent\n \te.writeMarkerHeader(sof0Marker, markerlen)\n \te.buf[0] = 8 // 8-bit color.\n \te.buf[1] = uint8(size.Y >> 8)\n@@ -344,15 +346,16 @@ func (e *encoder) writeDHT() {\n \n // writeBlock writes a block of pixel data using the given quantization table,\n // returning the post-quantized DC value of the DCT-transformed block.\n+// b is in natural (not zig-zag) order.\n func (e *encoder) writeBlock(b *block, q quantIndex, prevDC int) int {\n \tfdct(b)\n \t// Emit the DC delta.\n \tdc := div(b[0], (8 * int(e.quant[q][0])))\n \te.emitHuffRLE(huffIndex(2*q+0), 0, dc-prevDC)\n \t// Emit the AC components.\n \th, runLength := huffIndex(2*q+1), 0\n-\tfor k := 1; k < blockSize; k++ {\n-\t\tac := div(b[unzig[k]], (8 * int(e.quant[q][k])))\n+\tfor zig := 1; zig < blockSize; zig++ {\n+\t\tac := div(b[unzig[zig]], (8 * int(e.quant[q][zig])))\n \t\tif ac == 0 {\n \t\t\trunLength++\n \t\t} else {\n@@ -433,17 +436,20 @@ func scale(dst *block, src *[4]block) {\n //\t- component 1 uses DC table 0 and AC table 0 \"\\x01\\x00\",\n //\t- component 2 uses DC table 1 and AC table 1 \"\\x02\\x11\",\n //\t- component 3 uses DC table 1 and AC table 1 \"\\x03\\x11\",\n-//\t- padding \"\\x00\\x00\\x00\".\n+//\t- the bytes \"\\x00\\x3f\\x00\". Section B.2.3 of the spec says that for\n+//\t  sequential DCTs, those bytes (8-bit Ss, 8-bit Se, 4-bit Ah, 4-bit Al)\n+//\t  should be 0x00, 0x3f, 0x00<<4 | 0x00.\n var sosHeader = []byte{\n \t0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02,\n-\t0x11, 0x03, 0x11, 0x00, 0x00, 0x00,\n+\t0x11, 0x03, 0x11, 0x00, 0x3f, 0x00,\n }\n \n // writeSOS writes the StartOfScan marker.\n func (e *encoder) writeSOS(m image.Image) {\n \te.write(sosHeader)\n \tvar (\n \t\t// Scratch buffers to hold the YCbCr values.\n+\t\t// The blocks are in natural (not zig-zag) order.\n \t\tyBlock  block\n \t\tcbBlock [4]block\n \t\tcrBlock [4]block"}, {"sha": "8732df8459a07821590c3d1bb7850fdea5d1bc2e", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -6,6 +6,7 @@ package jpeg\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"image\"\n \t\"image/color\"\n \t\"image/png\"\n@@ -15,6 +16,87 @@ import (\n \t\"testing\"\n )\n \n+// zigzag maps from the natural ordering to the zig-zag ordering. For example,\n+// zigzag[0*8 + 3] is the zig-zag sequence number of the element in the fourth\n+// column and first row.\n+var zigzag = [blockSize]int{\n+\t0, 1, 5, 6, 14, 15, 27, 28,\n+\t2, 4, 7, 13, 16, 26, 29, 42,\n+\t3, 8, 12, 17, 25, 30, 41, 43,\n+\t9, 11, 18, 24, 31, 40, 44, 53,\n+\t10, 19, 23, 32, 39, 45, 52, 54,\n+\t20, 22, 33, 38, 46, 51, 55, 60,\n+\t21, 34, 37, 47, 50, 56, 59, 61,\n+\t35, 36, 48, 49, 57, 58, 62, 63,\n+}\n+\n+func TestZigUnzig(t *testing.T) {\n+\tfor i := 0; i < blockSize; i++ {\n+\t\tif unzig[zigzag[i]] != i {\n+\t\t\tt.Errorf(\"unzig[zigzag[%d]] == %d\", i, unzig[zigzag[i]])\n+\t\t}\n+\t\tif zigzag[unzig[i]] != i {\n+\t\t\tt.Errorf(\"zigzag[unzig[%d]] == %d\", i, zigzag[unzig[i]])\n+\t\t}\n+\t}\n+}\n+\n+// unscaledQuantInNaturalOrder are the unscaled quantization tables in\n+// natural (not zig-zag) order, as specified in section K.1.\n+var unscaledQuantInNaturalOrder = [nQuantIndex][blockSize]byte{\n+\t// Luminance.\n+\t{\n+\t\t16, 11, 10, 16, 24, 40, 51, 61,\n+\t\t12, 12, 14, 19, 26, 58, 60, 55,\n+\t\t14, 13, 16, 24, 40, 57, 69, 56,\n+\t\t14, 17, 22, 29, 51, 87, 80, 62,\n+\t\t18, 22, 37, 56, 68, 109, 103, 77,\n+\t\t24, 35, 55, 64, 81, 104, 113, 92,\n+\t\t49, 64, 78, 87, 103, 121, 120, 101,\n+\t\t72, 92, 95, 98, 112, 100, 103, 99,\n+\t},\n+\t// Chrominance.\n+\t{\n+\t\t17, 18, 24, 47, 99, 99, 99, 99,\n+\t\t18, 21, 26, 66, 99, 99, 99, 99,\n+\t\t24, 26, 56, 99, 99, 99, 99, 99,\n+\t\t47, 66, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t\t99, 99, 99, 99, 99, 99, 99, 99,\n+\t},\n+}\n+\n+func TestUnscaledQuant(t *testing.T) {\n+\tbad := false\n+\tfor i := quantIndex(0); i < nQuantIndex; i++ {\n+\t\tfor zig := 0; zig < blockSize; zig++ {\n+\t\t\tgot := unscaledQuant[i][zig]\n+\t\t\twant := unscaledQuantInNaturalOrder[i][unzig[zig]]\n+\t\t\tif got != want {\n+\t\t\t\tt.Errorf(\"i=%d, zig=%d: got %d, want %d\", i, zig, got, want)\n+\t\t\t\tbad = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif bad {\n+\t\tnames := [nQuantIndex]string{\"Luminance\", \"Chrominance\"}\n+\t\tbuf := &bytes.Buffer{}\n+\t\tfor i, name := range names {\n+\t\t\tfmt.Fprintf(buf, \"// %s.\\n{\\n\", name)\n+\t\t\tfor zig := 0; zig < blockSize; zig++ {\n+\t\t\t\tfmt.Fprintf(buf, \"%d, \", unscaledQuantInNaturalOrder[i][unzig[zig]])\n+\t\t\t\tif zig%8 == 7 {\n+\t\t\t\t\tbuf.WriteString(\"\\n\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbuf.WriteString(\"},\\n\")\n+\t\t}\n+\t\tt.Logf(\"expected unscaledQuant values:\\n%s\", buf.String())\n+\t}\n+}\n+\n var testCase = []struct {\n \tfilename  string\n \tquality   int"}, {"sha": "04ee2cfb47c55ec5efe03861eb22dc47e5ecb3e0", "filename": "libgo/go/image/names.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fnames.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fimage%2Fnames.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fnames.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -20,7 +20,7 @@ var (\n )\n \n // Uniform is an infinite-sized Image of uniform color.\n-// It implements the color.Color, color.ColorModel, and Image interfaces.\n+// It implements the color.Color, color.Model, and Image interfaces.\n type Uniform struct {\n \tC color.Color\n }"}, {"sha": "5187eff70a9c5d36480f734c3336e767b4dc71be", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -130,11 +130,23 @@ type ReadWriteSeeker interface {\n }\n \n // ReaderFrom is the interface that wraps the ReadFrom method.\n+//\n+// ReadFrom reads data from r until EOF or error.\n+// The return value n is the number of bytes read.\n+// Any error except io.EOF encountered during the read is also returned.\n+//\n+// The Copy function uses ReaderFrom if available.\n type ReaderFrom interface {\n \tReadFrom(r Reader) (n int64, err error)\n }\n \n // WriterTo is the interface that wraps the WriteTo method.\n+//\n+// WriteTo writes data to w until there's no more data to write or\n+// when an error occurs. The return value n is the number of bytes\n+// written. Any error encountered during the write is also returned.\n+//\n+// The Copy function uses WriterTo if available.\n type WriterTo interface {\n \tWriteTo(w Writer) (n int64, err error)\n }"}, {"sha": "e5620e1aa2a27296792381896be77d32e34ea354", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -138,15 +138,23 @@ func (w *Writer) Debug(m string) (err error) {\n }\n \n func (n netConn) writeBytes(p Priority, prefix string, b []byte) (int, error) {\n-\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s\\n\", p, prefix, b)\n+\tnl := \"\"\n+\tif len(b) == 0 || b[len(b)-1] != '\\n' {\n+\t\tnl = \"\\n\"\n+\t}\n+\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s%s\", p, prefix, b, nl)\n \tif err != nil {\n \t\treturn 0, err\n \t}\n \treturn len(b), nil\n }\n \n func (n netConn) writeString(p Priority, prefix string, s string) (int, error) {\n-\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s\\n\", p, prefix, s)\n+\tnl := \"\"\n+\tif len(s) == 0 || s[len(s)-1] != '\\n' {\n+\t\tnl = \"\\n\"\n+\t}\n+\t_, err := fmt.Fprintf(n.conn, \"<%d>%s: %s%s\", p, prefix, s, nl)\n \tif err != nil {\n \t\treturn 0, err\n \t}"}, {"sha": "b7579c363d32d8c8b10731384b83d09b49bd8af7", "filename": "libgo/go/log/syslog/syslog_test.go", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -98,20 +98,32 @@ func TestUDPDial(t *testing.T) {\n }\n \n func TestWrite(t *testing.T) {\n-\tdone := make(chan string)\n-\tstartServer(done)\n-\tl, err := Dial(\"udp\", serverAddr, LOG_ERR, \"syslog_test\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"syslog.Dial() failed: %s\", err)\n+\ttests := []struct {\n+\t\tpri Priority\n+\t\tpre string\n+\t\tmsg string\n+\t\texp string\n+\t}{\n+\t\t{LOG_ERR, \"syslog_test\", \"\", \"<3>syslog_test: \\n\"},\n+\t\t{LOG_ERR, \"syslog_test\", \"write test\", \"<3>syslog_test: write test\\n\"},\n+\t\t// Write should not add \\n if there already is one\n+\t\t{LOG_ERR, \"syslog_test\", \"write test 2\\n\", \"<3>syslog_test: write test 2\\n\"},\n \t}\n-\tmsg := \"write test\"\n-\t_, err = io.WriteString(l, msg)\n-\tif err != nil {\n-\t\tt.Fatalf(\"WriteString() failed: %s\", err)\n-\t}\n-\texpected := \"<3>syslog_test: write test\\n\"\n-\trcvd := <-done\n-\tif rcvd != expected {\n-\t\tt.Fatalf(\"s.Info() = '%q', but wanted '%q'\", rcvd, expected)\n+\n+\tfor _, test := range tests {\n+\t\tdone := make(chan string)\n+\t\tstartServer(done)\n+\t\tl, err := Dial(\"udp\", serverAddr, test.pri, test.pre)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"syslog.Dial() failed: %s\", err)\n+\t\t}\n+\t\t_, err = io.WriteString(l, test.msg)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"WriteString() failed: %s\", err)\n+\t\t}\n+\t\trcvd := <-done\n+\t\tif rcvd != test.exp {\n+\t\t\tt.Fatalf(\"s.Info() = '%q', but wanted '%q'\", rcvd, test.exp)\n+\t\t}\n \t}\n }"}, {"sha": "35c33ce38596f83f5070096b3a1685834dd4bbce", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -1693,6 +1693,17 @@ func alike(a, b float64) bool {\n \treturn false\n }\n \n+func TestNaN(t *testing.T) {\n+\tf64 := NaN()\n+\tif f64 == f64 {\n+\t\tt.Fatalf(\"NaN() returns %g, expected NaN\", f64)\n+\t}\n+\tf32 := float32(f64)\n+\tif f32 == f32 {\n+\t\tt.Fatalf(\"float32(NaN()) is %g, expected NaN\", f32)\n+\t}\n+}\n+\n func TestAcos(t *testing.T) {\n \tfor i := 0; i < len(vf); i++ {\n \t\ta := vf[i] / 10"}, {"sha": "6d81823bb4a503fc174e5cd618ebd373bdd2b2b7", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -396,7 +396,7 @@ func (z nat) mul(x, y nat) nat {\n \t}\n \n \t// use basic multiplication if the numbers are small\n-\tif n < karatsubaThreshold || n < 2 {\n+\tif n < karatsubaThreshold {\n \t\tz = z.make(m + n)\n \t\tbasicMul(z, x, y)\n \t\treturn z.norm()"}, {"sha": "0df0b1cc9f124b4078491d02fc547bc7f2aed951", "filename": "libgo/go/math/bits.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fbits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fbits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbits.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -5,7 +5,7 @@\n package math\n \n const (\n-\tuvnan    = 0x7FF0000000000001\n+\tuvnan    = 0x7FF8000000000001\n \tuvinf    = 0x7FF0000000000000\n \tuvneginf = 0xFFF0000000000000\n \tmask     = 0x7FF"}, {"sha": "98bb04dc794411be75d804fd29497e98890a5269", "filename": "libgo/go/math/remainder.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fremainder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmath%2Fremainder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fremainder.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -4,7 +4,7 @@\n \n package math\n \n-// The original C code and the the comment below are from\n+// The original C code and the comment below are from\n // FreeBSD's /usr/src/lib/msun/src/e_remainder.c and came\n // with this notice.  The go code is a simplified version of\n // the original C."}, {"sha": "09e941e3ec0ddbf17c1929e6ce74770fc1123ef9", "filename": "libgo/go/mime/grammar.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmime%2Fgrammar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmime%2Fgrammar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fgrammar.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -22,7 +22,7 @@ func isTokenChar(r rune) bool {\n \treturn r > 0x20 && r < 0x7f && !isTSpecial(r)\n }\n \n-// isToken returns true if s is a 'token' as as defined by RFC 1521\n+// isToken returns true if s is a 'token' as defined by RFC 1521\n // and RFC 2045.\n func isToken(s string) bool {\n \tif s == \"\" {"}, {"sha": "fb07e1a56d52985ede360e57750cbc9e8e6f23c8", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -71,7 +71,7 @@ func (p *Part) parseContentDisposition() {\n \t}\n }\n \n-// NewReader creates a new multipart Reader reading from r using the\n+// NewReader creates a new multipart Reader reading from reader using the\n // given MIME boundary.\n func NewReader(reader io.Reader, boundary string) *Reader {\n \tb := []byte(\"\\r\\n--\" + boundary + \"--\")"}, {"sha": "51912397a4633c58e7f8dc8b7b020ee4ca61e432", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -173,7 +173,7 @@ func (a stringAddr) String() string  { return a.addr }\n \n // Listen announces on the local network address laddr.\n // The network string net must be a stream-oriented network:\n-// \"tcp\", \"tcp4\", \"tcp6\", or \"unix\", or \"unixpacket\".\n+// \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n func Listen(net, laddr string) (Listener, error) {\n \tafnet, a, err := resolveNetAddr(\"listen\", net, laddr)\n \tif err != nil {"}, {"sha": "ff4f4f899e54129a008bfb4d8e6eb55b70ab74b3", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -645,10 +645,14 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err e\n }\n \n func (fd *netFD) dup() (f *os.File, err error) {\n+\tsyscall.ForkLock.RLock()\n \tns, err := syscall.Dup(fd.sysfd)\n \tif err != nil {\n+\t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, &OpError{\"dup\", fd.net, fd.laddr, err}\n \t}\n+\tsyscall.CloseOnExec(ns)\n+\tsyscall.ForkLock.RUnlock()\n \n \t// We want blocking mode for the new fd, hence the double negative.\n \tif err = syscall.SetNonblock(ns, false); err != nil {"}, {"sha": "837326e12e6b490e8c45ec0af133ade3c42b8069", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -12,13 +12,18 @@ import (\n )\n \n func newFileFD(f *os.File) (*netFD, error) {\n+\tsyscall.ForkLock.RLock()\n \tfd, err := syscall.Dup(int(f.Fd()))\n \tif err != nil {\n+\t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, os.NewSyscallError(\"dup\", err)\n \t}\n+\tsyscall.CloseOnExec(fd)\n+\tsyscall.ForkLock.RUnlock()\n \n-\tproto, err := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n+\tsotype, err := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n \tif err != nil {\n+\t\tclosesocket(fd)\n \t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \n@@ -31,33 +36,34 @@ func newFileFD(f *os.File) (*netFD, error) {\n \t\treturn nil, syscall.EINVAL\n \tcase *syscall.SockaddrInet4:\n \t\tfamily = syscall.AF_INET\n-\t\tif proto == syscall.SOCK_DGRAM {\n+\t\tif sotype == syscall.SOCK_DGRAM {\n \t\t\ttoAddr = sockaddrToUDP\n-\t\t} else if proto == syscall.SOCK_RAW {\n+\t\t} else if sotype == syscall.SOCK_RAW {\n \t\t\ttoAddr = sockaddrToIP\n \t\t}\n \tcase *syscall.SockaddrInet6:\n \t\tfamily = syscall.AF_INET6\n-\t\tif proto == syscall.SOCK_DGRAM {\n+\t\tif sotype == syscall.SOCK_DGRAM {\n \t\t\ttoAddr = sockaddrToUDP\n-\t\t} else if proto == syscall.SOCK_RAW {\n+\t\t} else if sotype == syscall.SOCK_RAW {\n \t\t\ttoAddr = sockaddrToIP\n \t\t}\n \tcase *syscall.SockaddrUnix:\n \t\tfamily = syscall.AF_UNIX\n \t\ttoAddr = sockaddrToUnix\n-\t\tif proto == syscall.SOCK_DGRAM {\n+\t\tif sotype == syscall.SOCK_DGRAM {\n \t\t\ttoAddr = sockaddrToUnixgram\n-\t\t} else if proto == syscall.SOCK_SEQPACKET {\n+\t\t} else if sotype == syscall.SOCK_SEQPACKET {\n \t\t\ttoAddr = sockaddrToUnixpacket\n \t\t}\n \t}\n \tladdr := toAddr(sa)\n \tsa, _ = syscall.Getpeername(fd)\n \traddr := toAddr(sa)\n \n-\tnetfd, err := newFD(fd, family, proto, laddr.Network())\n+\tnetfd, err := newFD(fd, family, sotype, laddr.Network())\n \tif err != nil {\n+\t\tclosesocket(fd)\n \t\treturn nil, err\n \t}\n \tnetfd.setAddr(laddr, raddr)"}, {"sha": "89441424e1d8829dbeb757a1afbc4d81bdfd12ed", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"log\"\n \t\"net/url\"\n \t\"strings\"\n )\n@@ -35,7 +36,8 @@ type Client struct {\n \t// following an HTTP redirect. The arguments req and via\n \t// are the upcoming request and the requests made already,\n \t// oldest first. If CheckRedirect returns an error, the client\n-\t// returns that error instead of issue the Request req.\n+\t// returns that error (wrapped in a url.Error) instead of\n+\t// issuing the Request req.\n \t//\n \t// If CheckRedirect is nil, the Client uses its default policy,\n \t// which is to stop after 10 consecutive requests.\n@@ -87,9 +89,13 @@ type readClose struct {\n // Do sends an HTTP request and returns an HTTP response, following\n // policy (e.g. redirects, cookies, auth) as configured on the client.\n //\n-// A non-nil response always contains a non-nil resp.Body.\n+// An error is returned if caused by client policy (such as\n+// CheckRedirect), or if there was an HTTP protocol error.\n+// A non-2xx response doesn't cause an error.\n //\n-// Callers should close resp.Body when done reading from it. If\n+// When err is nil, resp always contains a non-nil resp.Body.\n+//\n+// Callers should close res.Body when done reading from it. If\n // resp.Body is not closed, the Client's underlying RoundTripper\n // (typically Transport) may not be able to re-use a persistent TCP\n // connection to the server for a subsequent \"keep-alive\" request.\n@@ -102,7 +108,8 @@ func (c *Client) Do(req *Request) (resp *Response, err error) {\n \treturn send(req, c.Transport)\n }\n \n-// send issues an HTTP request.  Caller should close resp.Body when done reading from it.\n+// send issues an HTTP request.\n+// Caller should close resp.Body when done reading from it.\n func send(req *Request, t RoundTripper) (resp *Response, err error) {\n \tif t == nil {\n \t\tt = DefaultTransport\n@@ -130,7 +137,14 @@ func send(req *Request, t RoundTripper) (resp *Response, err error) {\n \tif u := req.URL.User; u != nil {\n \t\treq.Header.Set(\"Authorization\", \"Basic \"+base64.URLEncoding.EncodeToString([]byte(u.String())))\n \t}\n-\treturn t.RoundTrip(req)\n+\tresp, err = t.RoundTrip(req)\n+\tif err != nil {\n+\t\tif resp != nil {\n+\t\t\tlog.Printf(\"RoundTripper returned a response & error; ignoring response\")\n+\t\t}\n+\t\treturn nil, err\n+\t}\n+\treturn resp, nil\n }\n \n // True if the specified HTTP status code is one for which the Get utility should\n@@ -151,10 +165,15 @@ func shouldRedirect(statusCode int) bool {\n //    303 (See Other)\n //    307 (Temporary Redirect)\n //\n-// Caller should close r.Body when done reading from it.\n+// An error is returned if there were too many redirects or if there\n+// was an HTTP protocol error. A non-2xx response doesn't cause an\n+// error.\n+//\n+// When err is nil, resp always contains a non-nil resp.Body.\n+// Caller should close resp.Body when done reading from it.\n //\n // Get is a wrapper around DefaultClient.Get.\n-func Get(url string) (r *Response, err error) {\n+func Get(url string) (resp *Response, err error) {\n \treturn DefaultClient.Get(url)\n }\n \n@@ -167,16 +186,21 @@ func Get(url string) (r *Response, err error) {\n //    303 (See Other)\n //    307 (Temporary Redirect)\n //\n-// Caller should close r.Body when done reading from it.\n-func (c *Client) Get(url string) (r *Response, err error) {\n+// An error is returned if the Client's CheckRedirect function fails\n+// or if there was an HTTP protocol error. A non-2xx response doesn't\n+// cause an error.\n+//\n+// When err is nil, resp always contains a non-nil resp.Body.\n+// Caller should close resp.Body when done reading from it.\n+func (c *Client) Get(url string) (resp *Response, err error) {\n \treq, err := NewRequest(\"GET\", url, nil)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn c.doFollowingRedirects(req)\n }\n \n-func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n+func (c *Client) doFollowingRedirects(ireq *Request) (resp *Response, err error) {\n \t// TODO: if/when we add cookie support, the redirected request shouldn't\n \t// necessarily supply the same cookies as the original.\n \tvar base *url.URL\n@@ -224,17 +248,17 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t\t\treq.AddCookie(cookie)\n \t\t}\n \t\turlStr = req.URL.String()\n-\t\tif r, err = send(req, c.Transport); err != nil {\n+\t\tif resp, err = send(req, c.Transport); err != nil {\n \t\t\tbreak\n \t\t}\n-\t\tif c := r.Cookies(); len(c) > 0 {\n+\t\tif c := resp.Cookies(); len(c) > 0 {\n \t\t\tjar.SetCookies(req.URL, c)\n \t\t}\n \n-\t\tif shouldRedirect(r.StatusCode) {\n-\t\t\tr.Body.Close()\n-\t\t\tif urlStr = r.Header.Get(\"Location\"); urlStr == \"\" {\n-\t\t\t\terr = errors.New(fmt.Sprintf(\"%d response missing Location header\", r.StatusCode))\n+\t\tif shouldRedirect(resp.StatusCode) {\n+\t\t\tresp.Body.Close()\n+\t\t\tif urlStr = resp.Header.Get(\"Location\"); urlStr == \"\" {\n+\t\t\t\terr = errors.New(fmt.Sprintf(\"%d response missing Location header\", resp.StatusCode))\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tbase = req.URL\n@@ -244,13 +268,16 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t\treturn\n \t}\n \n+\tif resp != nil {\n+\t\tresp.Body.Close()\n+\t}\n+\n \tmethod := ireq.Method\n-\terr = &url.Error{\n+\treturn nil, &url.Error{\n \t\tOp:  method[0:1] + strings.ToLower(method[1:]),\n \t\tURL: urlStr,\n \t\tErr: err,\n \t}\n-\treturn\n }\n \n func defaultCheckRedirect(req *Request, via []*Request) error {\n@@ -262,17 +289,17 @@ func defaultCheckRedirect(req *Request, via []*Request) error {\n \n // Post issues a POST to the specified URL.\n //\n-// Caller should close r.Body when done reading from it.\n+// Caller should close resp.Body when done reading from it.\n //\n // Post is a wrapper around DefaultClient.Post\n-func Post(url string, bodyType string, body io.Reader) (r *Response, err error) {\n+func Post(url string, bodyType string, body io.Reader) (resp *Response, err error) {\n \treturn DefaultClient.Post(url, bodyType, body)\n }\n \n // Post issues a POST to the specified URL.\n //\n-// Caller should close r.Body when done reading from it.\n-func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err error) {\n+// Caller should close resp.Body when done reading from it.\n+func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error) {\n \treq, err := NewRequest(\"POST\", url, body)\n \tif err != nil {\n \t\treturn nil, err\n@@ -283,28 +310,30 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response,\n \t\t\treq.AddCookie(cookie)\n \t\t}\n \t}\n-\tr, err = send(req, c.Transport)\n+\tresp, err = send(req, c.Transport)\n \tif err == nil && c.Jar != nil {\n-\t\tc.Jar.SetCookies(req.URL, r.Cookies())\n+\t\tc.Jar.SetCookies(req.URL, resp.Cookies())\n \t}\n-\treturn r, err\n+\treturn\n }\n \n-// PostForm issues a POST to the specified URL, \n-// with data's keys and values urlencoded as the request body.\n+// PostForm issues a POST to the specified URL, with data's keys and\n+// values URL-encoded as the request body.\n //\n-// Caller should close r.Body when done reading from it.\n+// When err is nil, resp always contains a non-nil resp.Body.\n+// Caller should close resp.Body when done reading from it.\n //\n // PostForm is a wrapper around DefaultClient.PostForm\n-func PostForm(url string, data url.Values) (r *Response, err error) {\n+func PostForm(url string, data url.Values) (resp *Response, err error) {\n \treturn DefaultClient.PostForm(url, data)\n }\n \n // PostForm issues a POST to the specified URL, \n // with data's keys and values urlencoded as the request body.\n //\n-// Caller should close r.Body when done reading from it.\n-func (c *Client) PostForm(url string, data url.Values) (r *Response, err error) {\n+// When err is nil, resp always contains a non-nil resp.Body.\n+// Caller should close resp.Body when done reading from it.\n+func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error) {\n \treturn c.Post(url, \"application/x-www-form-urlencoded\", strings.NewReader(data.Encode()))\n }\n \n@@ -318,7 +347,7 @@ func (c *Client) PostForm(url string, data url.Values) (r *Response, err error)\n //    307 (Temporary Redirect)\n //\n // Head is a wrapper around DefaultClient.Head\n-func Head(url string) (r *Response, err error) {\n+func Head(url string) (resp *Response, err error) {\n \treturn DefaultClient.Head(url)\n }\n \n@@ -330,7 +359,7 @@ func Head(url string) (r *Response, err error) {\n //    302 (Found)\n //    303 (See Other)\n //    307 (Temporary Redirect)\n-func (c *Client) Head(url string) (r *Response, err error) {\n+func (c *Client) Head(url string) (resp *Response, err error) {\n \treq, err := NewRequest(\"HEAD\", url, nil)\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "09fcc1c0b40abba1d8eb5a88c25d8816f48f2f13", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -8,6 +8,7 @@ package http_test\n \n import (\n \t\"crypto/tls\"\n+\t\"crypto/x509\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -231,9 +232,8 @@ func TestRedirects(t *testing.T) {\n \n \tcheckErr = errors.New(\"no redirects allowed\")\n \tres, err = c.Get(ts.URL)\n-\tfinalUrl = res.Request.URL.String()\n-\tif e, g := \"Get /?n=1: no redirects allowed\", fmt.Sprintf(\"%v\", err); e != g {\n-\t\tt.Errorf(\"with redirects forbidden, expected error %q, got %q\", e, g)\n+\tif urlError, ok := err.(*url.Error); !ok || urlError.Err != checkErr {\n+\t\tt.Errorf(\"with redirects forbidden, expected a *url.Error with our 'no redirects allowed' error inside; got %#v (%q)\", err, err)\n \t}\n }\n \n@@ -465,3 +465,49 @@ func TestClientErrorWithRequestURI(t *testing.T) {\n \t\tt.Errorf(\"wanted error mentioning RequestURI; got error: %v\", err)\n \t}\n }\n+\n+func newTLSTransport(t *testing.T, ts *httptest.Server) *Transport {\n+\tcerts := x509.NewCertPool()\n+\tfor _, c := range ts.TLS.Certificates {\n+\t\troots, err := x509.ParseCertificates(c.Certificate[len(c.Certificate)-1])\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error parsing server's root cert: %v\", err)\n+\t\t}\n+\t\tfor _, root := range roots {\n+\t\t\tcerts.AddCert(root)\n+\t\t}\n+\t}\n+\treturn &Transport{\n+\t\tTLSClientConfig: &tls.Config{RootCAs: certs},\n+\t}\n+}\n+\n+func TestClientWithCorrectTLSServerName(t *testing.T) {\n+\tts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif r.TLS.ServerName != \"127.0.0.1\" {\n+\t\t\tt.Errorf(\"expected client to set ServerName 127.0.0.1, got: %q\", r.TLS.ServerName)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\n+\tc := &Client{Transport: newTLSTransport(t, ts)}\n+\tif _, err := c.Get(ts.URL); err != nil {\n+\t\tt.Fatalf(\"expected successful TLS connection, got error: %v\", err)\n+\t}\n+}\n+\n+func TestClientWithIncorrectTLSServerName(t *testing.T) {\n+\tts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {}))\n+\tdefer ts.Close()\n+\n+\ttrans := newTLSTransport(t, ts)\n+\ttrans.TLSClientConfig.ServerName = \"badserver\"\n+\tc := &Client{Transport: trans}\n+\t_, err := c.Get(ts.URL)\n+\tif err == nil {\n+\t\tt.Fatalf(\"expected an error\")\n+\t}\n+\tif !strings.Contains(err.Error(), \"127.0.0.1\") || !strings.Contains(err.Error(), \"badserver\") {\n+\t\tt.Errorf(\"wanted error mentioning 127.0.0.1 and badserver; got error: %v\", err)\n+\t}\n+}"}, {"sha": "22073eaf7aa88fba065e64f96d4bfcfdd17adcec", "filename": "libgo/go/net/http/example_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexample_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -43,10 +43,10 @@ func ExampleGet() {\n \t\tlog.Fatal(err)\n \t}\n \trobots, err := ioutil.ReadAll(res.Body)\n+\tres.Body.Close()\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n-\tres.Body.Close()\n \tfmt.Printf(\"%s\", robots)\n }\n "}, {"sha": "313c6af7a8258c84fced2e274a7ecbc8a84b4607", "filename": "libgo/go/net/http/export_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fexport_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -11,8 +11,8 @@ import \"time\"\n \n func (t *Transport) IdleConnKeysForTesting() (keys []string) {\n \tkeys = make([]string, 0)\n-\tt.lk.Lock()\n-\tdefer t.lk.Unlock()\n+\tt.idleLk.Lock()\n+\tdefer t.idleLk.Unlock()\n \tif t.idleConn == nil {\n \t\treturn\n \t}\n@@ -23,8 +23,8 @@ func (t *Transport) IdleConnKeysForTesting() (keys []string) {\n }\n \n func (t *Transport) IdleConnCountForTesting(cacheKey string) int {\n-\tt.lk.Lock()\n-\tdefer t.lk.Unlock()\n+\tt.idleLk.Lock()\n+\tdefer t.idleLk.Unlock()\n \tif t.idleConn == nil {\n \t\treturn 0\n \t}"}, {"sha": "208d6cabb2cdcb11473deb89638d16c594bac64c", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 114, "deletions": 18, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -11,6 +11,8 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"mime\"\n+\t\"mime/multipart\"\n+\t\"net/textproto\"\n \t\"os\"\n \t\"path\"\n \t\"path/filepath\"\n@@ -26,7 +28,8 @@ import (\n type Dir string\n \n func (d Dir) Open(name string) (File, error) {\n-\tif filepath.Separator != '/' && strings.IndexRune(name, filepath.Separator) >= 0 {\n+\tif filepath.Separator != '/' && strings.IndexRune(name, filepath.Separator) >= 0 ||\n+\t\tstrings.Contains(name, \"\\x00\") {\n \t\treturn nil, errors.New(\"http: invalid character in file path\")\n \t}\n \tdir := string(d)\n@@ -123,8 +126,9 @@ func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time,\n \tcode := StatusOK\n \n \t// If Content-Type isn't set, use the file's extension to find it.\n-\tif w.Header().Get(\"Content-Type\") == \"\" {\n-\t\tctype := mime.TypeByExtension(filepath.Ext(name))\n+\tctype := w.Header().Get(\"Content-Type\")\n+\tif ctype == \"\" {\n+\t\tctype = mime.TypeByExtension(filepath.Ext(name))\n \t\tif ctype == \"\" {\n \t\t\t// read a chunk to decide between utf-8 text and binary\n \t\t\tvar buf [1024]byte\n@@ -141,26 +145,76 @@ func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time,\n \t}\n \n \t// handle Content-Range header.\n-\t// TODO(adg): handle multiple ranges\n \tsendSize := size\n+\tvar sendContent io.Reader = content\n \tif size >= 0 {\n \t\tranges, err := parseRange(r.Header.Get(\"Range\"), size)\n-\t\tif err == nil && len(ranges) > 1 {\n-\t\t\terr = errors.New(\"multiple ranges not supported\")\n-\t\t}\n \t\tif err != nil {\n \t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n \t\t\treturn\n \t\t}\n-\t\tif len(ranges) == 1 {\n+\t\tif sumRangesSize(ranges) >= size {\n+\t\t\t// The total number of bytes in all the ranges\n+\t\t\t// is larger than the size of the file by\n+\t\t\t// itself, so this is probably an attack, or a\n+\t\t\t// dumb client.  Ignore the range request.\n+\t\t\tranges = nil\n+\t\t}\n+\t\tswitch {\n+\t\tcase len(ranges) == 1:\n+\t\t\t// RFC 2616, Section 14.16:\n+\t\t\t// \"When an HTTP message includes the content of a single\n+\t\t\t// range (for example, a response to a request for a\n+\t\t\t// single range, or to a request for a set of ranges\n+\t\t\t// that overlap without any holes), this content is\n+\t\t\t// transmitted with a Content-Range header, and a\n+\t\t\t// Content-Length header showing the number of bytes\n+\t\t\t// actually transferred.\n+\t\t\t// ...\n+\t\t\t// A response to a request for a single range MUST NOT\n+\t\t\t// be sent using the multipart/byteranges media type.\"\n \t\t\tra := ranges[0]\n \t\t\tif _, err := content.Seek(ra.start, os.SEEK_SET); err != nil {\n \t\t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tsendSize = ra.length\n \t\t\tcode = StatusPartialContent\n-\t\t\tw.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, size))\n+\t\t\tw.Header().Set(\"Content-Range\", ra.contentRange(size))\n+\t\tcase len(ranges) > 1:\n+\t\t\tfor _, ra := range ranges {\n+\t\t\t\tif ra.start > size {\n+\t\t\t\t\tError(w, err.Error(), StatusRequestedRangeNotSatisfiable)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tsendSize = rangesMIMESize(ranges, ctype, size)\n+\t\t\tcode = StatusPartialContent\n+\n+\t\t\tpr, pw := io.Pipe()\n+\t\t\tmw := multipart.NewWriter(pw)\n+\t\t\tw.Header().Set(\"Content-Type\", \"multipart/byteranges; boundary=\"+mw.Boundary())\n+\t\t\tsendContent = pr\n+\t\t\tdefer pr.Close() // cause writing goroutine to fail and exit if CopyN doesn't finish.\n+\t\t\tgo func() {\n+\t\t\t\tfor _, ra := range ranges {\n+\t\t\t\t\tpart, err := mw.CreatePart(ra.mimeHeader(ctype, size))\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tpw.CloseWithError(err)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tif _, err := content.Seek(ra.start, os.SEEK_SET); err != nil {\n+\t\t\t\t\t\tpw.CloseWithError(err)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tif _, err := io.CopyN(part, content, ra.length); err != nil {\n+\t\t\t\t\t\tpw.CloseWithError(err)\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tmw.Close()\n+\t\t\t\tpw.Close()\n+\t\t\t}()\n \t\t}\n \n \t\tw.Header().Set(\"Accept-Ranges\", \"bytes\")\n@@ -172,11 +226,7 @@ func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time,\n \tw.WriteHeader(code)\n \n \tif r.Method != \"HEAD\" {\n-\t\tif sendSize == -1 {\n-\t\t\tio.Copy(w, content)\n-\t\t} else {\n-\t\t\tio.CopyN(w, content, sendSize)\n-\t\t}\n+\t\tio.CopyN(w, sendContent, sendSize)\n \t}\n }\n \n@@ -243,9 +293,6 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \n \t// use contents of index.html for directory, if present\n \tif d.IsDir() {\n-\t\tif checkLastModified(w, r, d.ModTime()) {\n-\t\t\treturn\n-\t\t}\n \t\tindex := name + indexPage\n \t\tff, err := fs.Open(index)\n \t\tif err == nil {\n@@ -259,11 +306,16 @@ func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirec\n \t\t}\n \t}\n \n+\t// Still a directory? (we didn't find an index.html file)\n \tif d.IsDir() {\n+\t\tif checkLastModified(w, r, d.ModTime()) {\n+\t\t\treturn\n+\t\t}\n \t\tdirList(w, f)\n \t\treturn\n \t}\n \n+\t// serverContent will check modification time\n \tserveContent(w, r, d.Name(), d.ModTime(), d.Size(), f)\n }\n \n@@ -312,6 +364,17 @@ type httpRange struct {\n \tstart, length int64\n }\n \n+func (r httpRange) contentRange(size int64) string {\n+\treturn fmt.Sprintf(\"bytes %d-%d/%d\", r.start, r.start+r.length-1, size)\n+}\n+\n+func (r httpRange) mimeHeader(contentType string, size int64) textproto.MIMEHeader {\n+\treturn textproto.MIMEHeader{\n+\t\t\"Content-Range\": {r.contentRange(size)},\n+\t\t\"Content-Type\":  {contentType},\n+\t}\n+}\n+\n // parseRange parses a Range header string as per RFC 2616.\n func parseRange(s string, size int64) ([]httpRange, error) {\n \tif s == \"\" {\n@@ -323,11 +386,15 @@ func parseRange(s string, size int64) ([]httpRange, error) {\n \t}\n \tvar ranges []httpRange\n \tfor _, ra := range strings.Split(s[len(b):], \",\") {\n+\t\tra = strings.TrimSpace(ra)\n+\t\tif ra == \"\" {\n+\t\t\tcontinue\n+\t\t}\n \t\ti := strings.Index(ra, \"-\")\n \t\tif i < 0 {\n \t\t\treturn nil, errors.New(\"invalid range\")\n \t\t}\n-\t\tstart, end := ra[:i], ra[i+1:]\n+\t\tstart, end := strings.TrimSpace(ra[:i]), strings.TrimSpace(ra[i+1:])\n \t\tvar r httpRange\n \t\tif start == \"\" {\n \t\t\t// If no start is specified, end specifies the\n@@ -365,3 +432,32 @@ func parseRange(s string, size int64) ([]httpRange, error) {\n \t}\n \treturn ranges, nil\n }\n+\n+// countingWriter counts how many bytes have been written to it.\n+type countingWriter int64\n+\n+func (w *countingWriter) Write(p []byte) (n int, err error) {\n+\t*w += countingWriter(len(p))\n+\treturn len(p), nil\n+}\n+\n+// rangesMIMESize returns the nunber of bytes it takes to encode the\n+// provided ranges as a multipart response.\n+func rangesMIMESize(ranges []httpRange, contentType string, contentSize int64) (encSize int64) {\n+\tvar w countingWriter\n+\tmw := multipart.NewWriter(&w)\n+\tfor _, ra := range ranges {\n+\t\tmw.CreatePart(ra.mimeHeader(contentType, contentSize))\n+\t\tencSize += ra.length\n+\t}\n+\tmw.Close()\n+\tencSize += int64(w)\n+\treturn\n+}\n+\n+func sumRangesSize(ranges []httpRange) (size int64) {\n+\tfor _, ra := range ranges {\n+\t\tsize += ra.length\n+\t}\n+\treturn\n+}"}, {"sha": "17329fbd59a4d2083ddb2ccc7c1dfba7d4bb0d80", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 224, "deletions": 39, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -10,12 +10,15 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"mime\"\n+\t\"mime/multipart\"\n \t\"net\"\n \t. \"net/http\"\n \t\"net/http/httptest\"\n \t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"path\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"runtime\"\n@@ -25,21 +28,29 @@ import (\n )\n \n const (\n-\ttestFile       = \"testdata/file\"\n-\ttestFileLength = 11\n+\ttestFile    = \"testdata/file\"\n+\ttestFileLen = 11\n )\n \n+type wantRange struct {\n+\tstart, end int64 // range [start,end)\n+}\n+\n var ServeFileRangeTests = []struct {\n-\tstart, end int\n-\tr          string\n-\tcode       int\n+\tr      string\n+\tcode   int\n+\tranges []wantRange\n }{\n-\t{0, testFileLength, \"\", StatusOK},\n-\t{0, 5, \"0-4\", StatusPartialContent},\n-\t{2, testFileLength, \"2-\", StatusPartialContent},\n-\t{testFileLength - 5, testFileLength, \"-5\", StatusPartialContent},\n-\t{3, 8, \"3-7\", StatusPartialContent},\n-\t{0, 0, \"20-\", StatusRequestedRangeNotSatisfiable},\n+\t{r: \"\", code: StatusOK},\n+\t{r: \"bytes=0-4\", code: StatusPartialContent, ranges: []wantRange{{0, 5}}},\n+\t{r: \"bytes=2-\", code: StatusPartialContent, ranges: []wantRange{{2, testFileLen}}},\n+\t{r: \"bytes=-5\", code: StatusPartialContent, ranges: []wantRange{{testFileLen - 5, testFileLen}}},\n+\t{r: \"bytes=3-7\", code: StatusPartialContent, ranges: []wantRange{{3, 8}}},\n+\t{r: \"bytes=20-\", code: StatusRequestedRangeNotSatisfiable},\n+\t{r: \"bytes=0-0,-2\", code: StatusPartialContent, ranges: []wantRange{{0, 1}, {testFileLen - 2, testFileLen}}},\n+\t{r: \"bytes=0-1,5-8\", code: StatusPartialContent, ranges: []wantRange{{0, 2}, {5, 9}}},\n+\t{r: \"bytes=0-1,5-\", code: StatusPartialContent, ranges: []wantRange{{0, 2}, {5, testFileLen}}},\n+\t{r: \"bytes=0-,1-,2-,3-,4-\", code: StatusOK}, // ignore wasteful range request\n }\n \n func TestServeFile(t *testing.T) {\n@@ -65,33 +76,81 @@ func TestServeFile(t *testing.T) {\n \n \t// straight GET\n \t_, body := getBody(t, \"straight get\", req)\n-\tif !equal(body, file) {\n+\tif !bytes.Equal(body, file) {\n \t\tt.Fatalf(\"body mismatch: got %q, want %q\", body, file)\n \t}\n \n \t// Range tests\n-\tfor i, rt := range ServeFileRangeTests {\n-\t\treq.Header.Set(\"Range\", \"bytes=\"+rt.r)\n-\t\tif rt.r == \"\" {\n-\t\t\treq.Header[\"Range\"] = nil\n+\tfor _, rt := range ServeFileRangeTests {\n+\t\tif rt.r != \"\" {\n+\t\t\treq.Header.Set(\"Range\", rt.r)\n \t\t}\n-\t\tr, body := getBody(t, fmt.Sprintf(\"test %d\", i), req)\n-\t\tif r.StatusCode != rt.code {\n-\t\t\tt.Errorf(\"range=%q: StatusCode=%d, want %d\", rt.r, r.StatusCode, rt.code)\n+\t\tresp, body := getBody(t, fmt.Sprintf(\"range test %q\", rt.r), req)\n+\t\tif resp.StatusCode != rt.code {\n+\t\t\tt.Errorf(\"range=%q: StatusCode=%d, want %d\", rt.r, resp.StatusCode, rt.code)\n \t\t}\n \t\tif rt.code == StatusRequestedRangeNotSatisfiable {\n \t\t\tcontinue\n \t\t}\n-\t\th := fmt.Sprintf(\"bytes %d-%d/%d\", rt.start, rt.end-1, testFileLength)\n-\t\tif rt.r == \"\" {\n-\t\t\th = \"\"\n+\t\twantContentRange := \"\"\n+\t\tif len(rt.ranges) == 1 {\n+\t\t\trng := rt.ranges[0]\n+\t\t\twantContentRange = fmt.Sprintf(\"bytes %d-%d/%d\", rng.start, rng.end-1, testFileLen)\n+\t\t}\n+\t\tcr := resp.Header.Get(\"Content-Range\")\n+\t\tif cr != wantContentRange {\n+\t\t\tt.Errorf(\"range=%q: Content-Range = %q, want %q\", rt.r, cr, wantContentRange)\n \t\t}\n-\t\tcr := r.Header.Get(\"Content-Range\")\n-\t\tif cr != h {\n-\t\t\tt.Errorf(\"header mismatch: range=%q: got %q, want %q\", rt.r, cr, h)\n+\t\tct := resp.Header.Get(\"Content-Type\")\n+\t\tif len(rt.ranges) == 1 {\n+\t\t\trng := rt.ranges[0]\n+\t\t\twantBody := file[rng.start:rng.end]\n+\t\t\tif !bytes.Equal(body, wantBody) {\n+\t\t\t\tt.Errorf(\"range=%q: body = %q, want %q\", rt.r, body, wantBody)\n+\t\t\t}\n+\t\t\tif strings.HasPrefix(ct, \"multipart/byteranges\") {\n+\t\t\t\tt.Errorf(\"range=%q content-type = %q; unexpected multipart/byteranges\", rt.r)\n+\t\t\t}\n \t\t}\n-\t\tif !equal(body, file[rt.start:rt.end]) {\n-\t\t\tt.Errorf(\"body mismatch: range=%q: got %q, want %q\", rt.r, body, file[rt.start:rt.end])\n+\t\tif len(rt.ranges) > 1 {\n+\t\t\ttyp, params, err := mime.ParseMediaType(ct)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"range=%q content-type = %q; %v\", rt.r, ct, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif typ != \"multipart/byteranges\" {\n+\t\t\t\tt.Errorf(\"range=%q content-type = %q; want multipart/byteranges\", rt.r)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif params[\"boundary\"] == \"\" {\n+\t\t\t\tt.Errorf(\"range=%q content-type = %q; lacks boundary\", rt.r, ct)\n+\t\t\t}\n+\t\t\tif g, w := resp.ContentLength, int64(len(body)); g != w {\n+\t\t\t\tt.Errorf(\"range=%q Content-Length = %d; want %d\", rt.r, g, w)\n+\t\t\t}\n+\t\t\tmr := multipart.NewReader(bytes.NewReader(body), params[\"boundary\"])\n+\t\t\tfor ri, rng := range rt.ranges {\n+\t\t\t\tpart, err := mr.NextPart()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"range=%q, reading part index %d: %v\", rt.r, ri, err)\n+\t\t\t\t}\n+\t\t\t\tbody, err := ioutil.ReadAll(part)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"range=%q, reading part index %d body: %v\", rt.r, ri, err)\n+\t\t\t\t}\n+\t\t\t\twantContentRange = fmt.Sprintf(\"bytes %d-%d/%d\", rng.start, rng.end-1, testFileLen)\n+\t\t\t\twantBody := file[rng.start:rng.end]\n+\t\t\t\tif !bytes.Equal(body, wantBody) {\n+\t\t\t\t\tt.Errorf(\"range=%q: body = %q, want %q\", rt.r, body, wantBody)\n+\t\t\t\t}\n+\t\t\t\tif g, w := part.Header.Get(\"Content-Range\"), wantContentRange; g != w {\n+\t\t\t\t\tt.Errorf(\"range=%q: part Content-Range = %q; want %q\", rt.r, g, w)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t_, err = mr.NextPart()\n+\t\t\tif err != io.EOF {\n+\t\t\t\tt.Errorf(\"range=%q; expected final error io.EOF; got %v\", err)\n+\t\t\t}\n \t\t}\n \t}\n }\n@@ -276,6 +335,11 @@ func TestServeFileMimeType(t *testing.T) {\n }\n \n func TestServeFileFromCWD(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// TODO(brainman): find out why this test is broken\n+\t\tt.Logf(\"Temporarily skipping test on Windows; see http://golang.org/issue/3917\")\n+\t\treturn\n+\t}\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tServeFile(w, r, \"fs_test.go\")\n \t}))\n@@ -325,6 +389,139 @@ func TestServeIndexHtml(t *testing.T) {\n \t}\n }\n \n+func TestFileServerZeroByte(t *testing.T) {\n+\tts := httptest.NewServer(FileServer(Dir(\".\")))\n+\tdefer ts.Close()\n+\n+\tres, err := Get(ts.URL + \"/..\\x00\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tb, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatal(\"reading Body:\", err)\n+\t}\n+\tif res.StatusCode == 200 {\n+\t\tt.Errorf(\"got status 200; want an error. Body is:\\n%s\", string(b))\n+\t}\n+}\n+\n+type fakeFileInfo struct {\n+\tdir      bool\n+\tbasename string\n+\tmodtime  time.Time\n+\tents     []*fakeFileInfo\n+\tcontents string\n+}\n+\n+func (f *fakeFileInfo) Name() string       { return f.basename }\n+func (f *fakeFileInfo) Sys() interface{}   { return nil }\n+func (f *fakeFileInfo) ModTime() time.Time { return f.modtime }\n+func (f *fakeFileInfo) IsDir() bool        { return f.dir }\n+func (f *fakeFileInfo) Size() int64        { return int64(len(f.contents)) }\n+func (f *fakeFileInfo) Mode() os.FileMode {\n+\tif f.dir {\n+\t\treturn 0755 | os.ModeDir\n+\t}\n+\treturn 0644\n+}\n+\n+type fakeFile struct {\n+\tio.ReadSeeker\n+\tfi   *fakeFileInfo\n+\tpath string // as opened\n+}\n+\n+func (f *fakeFile) Close() error               { return nil }\n+func (f *fakeFile) Stat() (os.FileInfo, error) { return f.fi, nil }\n+func (f *fakeFile) Readdir(count int) ([]os.FileInfo, error) {\n+\tif !f.fi.dir {\n+\t\treturn nil, os.ErrInvalid\n+\t}\n+\tvar fis []os.FileInfo\n+\tfor _, fi := range f.fi.ents {\n+\t\tfis = append(fis, fi)\n+\t}\n+\treturn fis, nil\n+}\n+\n+type fakeFS map[string]*fakeFileInfo\n+\n+func (fs fakeFS) Open(name string) (File, error) {\n+\tname = path.Clean(name)\n+\tf, ok := fs[name]\n+\tif !ok {\n+\t\tprintln(\"fake filesystem didn't find file\", name)\n+\t\treturn nil, os.ErrNotExist\n+\t}\n+\treturn &fakeFile{ReadSeeker: strings.NewReader(f.contents), fi: f, path: name}, nil\n+}\n+\n+func TestDirectoryIfNotModified(t *testing.T) {\n+\tconst indexContents = \"I am a fake index.html file\"\n+\tfileMod := time.Unix(1000000000, 0).UTC()\n+\tfileModStr := fileMod.Format(TimeFormat)\n+\tdirMod := time.Unix(123, 0).UTC()\n+\tindexFile := &fakeFileInfo{\n+\t\tbasename: \"index.html\",\n+\t\tmodtime:  fileMod,\n+\t\tcontents: indexContents,\n+\t}\n+\tfs := fakeFS{\n+\t\t\"/\": &fakeFileInfo{\n+\t\t\tdir:     true,\n+\t\t\tmodtime: dirMod,\n+\t\t\tents:    []*fakeFileInfo{indexFile},\n+\t\t},\n+\t\t\"/index.html\": indexFile,\n+\t}\n+\n+\tts := httptest.NewServer(FileServer(fs))\n+\tdefer ts.Close()\n+\n+\tres, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tb, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(b) != indexContents {\n+\t\tt.Fatalf(\"Got body %q; want %q\", b, indexContents)\n+\t}\n+\tres.Body.Close()\n+\n+\tlastMod := res.Header.Get(\"Last-Modified\")\n+\tif lastMod != fileModStr {\n+\t\tt.Fatalf(\"initial Last-Modified = %q; want %q\", lastMod, fileModStr)\n+\t}\n+\n+\treq, _ := NewRequest(\"GET\", ts.URL, nil)\n+\treq.Header.Set(\"If-Modified-Since\", lastMod)\n+\n+\tres, err = DefaultClient.Do(req)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif res.StatusCode != 304 {\n+\t\tt.Fatalf(\"Code after If-Modified-Since request = %v; want 304\", res.StatusCode)\n+\t}\n+\tres.Body.Close()\n+\n+\t// Advance the index.html file's modtime, but not the directory's.\n+\tindexFile.modtime = indexFile.modtime.Add(1 * time.Hour)\n+\n+\tres, err = DefaultClient.Do(req)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif res.StatusCode != 200 {\n+\t\tt.Fatalf(\"Code after second If-Modified-Since request = %v; want 200; res is %#v\", res.StatusCode, res)\n+\t}\n+\tres.Body.Close()\n+}\n+\n func TestServeContent(t *testing.T) {\n \ttype req struct {\n \t\tname    string\n@@ -464,15 +661,3 @@ func TestLinuxSendfileChild(*testing.T) {\n \t\tpanic(err)\n \t}\n }\n-\n-func equal(a, b []byte) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i := range a {\n-\t\tif a[i] != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}"}, {"sha": "6be94f98e7469798ca2f81fab09b2011065cb27c", "filename": "libgo/go/net/http/header.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fheader.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -76,3 +76,43 @@ func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error {\n // the rest are converted to lowercase.  For example, the\n // canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n func CanonicalHeaderKey(s string) string { return textproto.CanonicalMIMEHeaderKey(s) }\n+\n+// hasToken returns whether token appears with v, ASCII\n+// case-insensitive, with space or comma boundaries.\n+// token must be all lowercase.\n+// v may contain mixed cased.\n+func hasToken(v, token string) bool {\n+\tif len(token) > len(v) || token == \"\" {\n+\t\treturn false\n+\t}\n+\tif v == token {\n+\t\treturn true\n+\t}\n+\tfor sp := 0; sp <= len(v)-len(token); sp++ {\n+\t\t// Check that first character is good.\n+\t\t// The token is ASCII, so checking only a single byte\n+\t\t// is sufficient.  We skip this potential starting\n+\t\t// position if both the first byte and its potential\n+\t\t// ASCII uppercase equivalent (b|0x20) don't match.\n+\t\t// False positives ('^' => '~') are caught by EqualFold.\n+\t\tif b := v[sp]; b != token[0] && b|0x20 != token[0] {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Check that start pos is on a valid token boundary.\n+\t\tif sp > 0 && !isTokenBoundary(v[sp-1]) {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Check that end pos is on a valid token boundary.\n+\t\tif endPos := sp + len(token); endPos != len(v) && !isTokenBoundary(v[endPos]) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.EqualFold(v[sp:sp+len(token)], token) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func isTokenBoundary(b byte) bool {\n+\treturn b == ' ' || b == ',' || b == '\\t'\n+}"}, {"sha": "165600e52beba14cb12610f98ba73538d5bb0f02", "filename": "libgo/go/net/http/httptest/server.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -184,15 +184,15 @@ func (h *waitGroupHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n // \"127.0.0.1\" and \"[::1]\", expiring at the last second of 2049 (the end\n // of ASN.1 time).\n var localhostCert = []byte(`-----BEGIN CERTIFICATE-----\n-MIIBOTCB5qADAgECAgEAMAsGCSqGSIb3DQEBBTAAMB4XDTcwMDEwMTAwMDAwMFoX\n+MIIBTTCB+qADAgECAgEAMAsGCSqGSIb3DQEBBTAAMB4XDTcwMDEwMTAwMDAwMFoX\n DTQ5MTIzMTIzNTk1OVowADBaMAsGCSqGSIb3DQEBAQNLADBIAkEAsuA5mAFMj6Q7\n qoBzcvKzIq4kzuT5epSp2AkcQfyBHm7K13Ws7u+0b5Vb9gqTf5cAiIKcrtrXVqkL\n-8i1UQF6AzwIDAQABo08wTTAOBgNVHQ8BAf8EBAMCACQwDQYDVR0OBAYEBAECAwQw\n-DwYDVR0jBAgwBoAEAQIDBDAbBgNVHREEFDASggkxMjcuMC4wLjGCBVs6OjFdMAsG\n-CSqGSIb3DQEBBQNBAJH30zjLWRztrWpOCgJL8RQWLaKzhK79pVhAx6q/3NrF16C7\n-+l1BRZstTwIGdoGId8BRpErK1TXkniFb95ZMynM=\n------END CERTIFICATE-----\n-`)\n+8i1UQF6AzwIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCACQwEgYDVR0TAQH/BAgwBgEB\n+/wIBATANBgNVHQ4EBgQEAQIDBDAPBgNVHSMECDAGgAQBAgMEMBsGA1UdEQQUMBKC\n+CTEyNy4wLjAuMYIFWzo6MV0wCwYJKoZIhvcNAQEFA0EAj1Jsn/h2KHy7dgqutZNB\n+nCGlNN+8vw263Bax9MklR85Ti6a0VWSvp/fDQZUADvmFTDkcXeA24pqmdUxeQDWw\n+Pg==\n+-----END CERTIFICATE-----`)\n \n // localhostKey is the private key for localhostCert.\n var localhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----"}, {"sha": "0fb2eeb8c003f63c549fff4626a26b013c474ba1", "filename": "libgo/go/net/http/httputil/dump.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -89,7 +89,7 @@ func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n \n \tt := &http.Transport{\n \t\tDial: func(net, addr string) (net.Conn, error) {\n-\t\t\treturn &dumpConn{io.MultiWriter(pw, &buf), dr}, nil\n+\t\t\treturn &dumpConn{io.MultiWriter(&buf, pw), dr}, nil\n \t\t},\n \t}\n "}, {"sha": "7a9f465c4776093f4c88f6a16a860e47775233be", "filename": "libgo/go/net/http/pprof/pprof.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fpprof%2Fpprof.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -14,6 +14,14 @@\n // To use pprof, link this package into your program:\n //\timport _ \"net/http/pprof\"\n //\n+// If your application is not already running an http server, you\n+// need to start one.  Add \"net/http\" and \"log\" to your imports and\n+// the following code to your main function:\n+//\n+// \tgo func() {\n+// \t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n+// \t}()\n+//\n // Then use the pprof tool to look at the heap profile:\n //\n //\tgo tool pprof http://localhost:6060/debug/pprof/heap"}, {"sha": "ef911af7b089cf692726b3edbb254b3d5c52009b", "filename": "libgo/go/net/http/range_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Frange_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Frange_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frange_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -14,15 +14,34 @@ var ParseRangeTests = []struct {\n \tr      []httpRange\n }{\n \t{\"\", 0, nil},\n+\t{\"\", 1000, nil},\n \t{\"foo\", 0, nil},\n \t{\"bytes=\", 0, nil},\n+\t{\"bytes=7\", 10, nil},\n+\t{\"bytes= 7 \", 10, nil},\n+\t{\"bytes=1-\", 0, nil},\n \t{\"bytes=5-4\", 10, nil},\n \t{\"bytes=0-2,5-4\", 10, nil},\n+\t{\"bytes=2-5,4-3\", 10, nil},\n+\t{\"bytes=--5,4--3\", 10, nil},\n+\t{\"bytes=A-\", 10, nil},\n+\t{\"bytes=A- \", 10, nil},\n+\t{\"bytes=A-Z\", 10, nil},\n+\t{\"bytes= -Z\", 10, nil},\n+\t{\"bytes=5-Z\", 10, nil},\n+\t{\"bytes=Ran-dom, garbage\", 10, nil},\n+\t{\"bytes=0x01-0x02\", 10, nil},\n+\t{\"bytes=         \", 10, nil},\n+\t{\"bytes= , , ,   \", 10, nil},\n+\n \t{\"bytes=0-9\", 10, []httpRange{{0, 10}}},\n \t{\"bytes=0-\", 10, []httpRange{{0, 10}}},\n \t{\"bytes=5-\", 10, []httpRange{{5, 5}}},\n \t{\"bytes=0-20\", 10, []httpRange{{0, 10}}},\n \t{\"bytes=15-,0-5\", 10, nil},\n+\t{\"bytes=1-2,5-\", 10, []httpRange{{1, 2}, {5, 5}}},\n+\t{\"bytes=-2 , 7-\", 11, []httpRange{{9, 2}, {7, 4}}},\n+\t{\"bytes=0-0 ,2-2, 7-\", 11, []httpRange{{0, 1}, {2, 1}, {7, 4}}},\n \t{\"bytes=-5\", 10, []httpRange{{5, 5}}},\n \t{\"bytes=-15\", 10, []httpRange{{0, 10}}},\n \t{\"bytes=0-499\", 10000, []httpRange{{0, 500}}},\n@@ -32,6 +51,9 @@ var ParseRangeTests = []struct {\n \t{\"bytes=0-0,-1\", 10000, []httpRange{{0, 1}, {9999, 1}}},\n \t{\"bytes=500-600,601-999\", 10000, []httpRange{{500, 101}, {601, 399}}},\n \t{\"bytes=500-700,601-999\", 10000, []httpRange{{500, 201}, {601, 399}}},\n+\n+\t// Match Apache laxity:\n+\t{\"bytes=   1 -2   ,  4- 5, 7 - 8 , ,,\", 11, []httpRange{{1, 2}, {4, 2}, {7, 2}}},\n }\n \n func TestParseRange(t *testing.T) {"}, {"sha": "c9d73932bb96e0c8b5b876919d3d79a4ca39f750", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -386,26 +386,30 @@ func testTcpConnectionCloses(t *testing.T, req string, h Handler) {\n \t}\n \n \tr := bufio.NewReader(conn)\n-\t_, err = ReadResponse(r, &Request{Method: \"GET\"})\n+\tres, err := ReadResponse(r, &Request{Method: \"GET\"})\n \tif err != nil {\n \t\tt.Fatal(\"ReadResponse error:\", err)\n \t}\n \n-\tsuccess := make(chan bool)\n+\tdidReadAll := make(chan bool, 1)\n \tgo func() {\n \t\tselect {\n \t\tcase <-time.After(5 * time.Second):\n-\t\t\tt.Fatal(\"body not closed after 5s\")\n-\t\tcase <-success:\n+\t\t\tt.Error(\"body not closed after 5s\")\n+\t\t\treturn\n+\t\tcase <-didReadAll:\n \t\t}\n \t}()\n \n \t_, err = ioutil.ReadAll(r)\n \tif err != nil {\n \t\tt.Fatal(\"read error:\", err)\n \t}\n+\tdidReadAll <- true\n \n-\tsuccess <- true\n+\tif !res.Close {\n+\t\tt.Errorf(\"Response.Close = false; want true\")\n+\t}\n }\n \n // TestServeHTTP10Close verifies that HTTP/1.0 requests won't be kept alive.\n@@ -1108,6 +1112,38 @@ func TestServerBufferedChunking(t *testing.T) {\n \t}\n }\n \n+// TestContentLengthZero tests that for both an HTTP/1.0 and HTTP/1.1\n+// request (both keep-alive), when a Handler never writes any\n+// response, the net/http package adds a \"Content-Length: 0\" response\n+// header.\n+func TestContentLengthZero(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(rw ResponseWriter, req *Request) {}))\n+\tdefer ts.Close()\n+\n+\tfor _, version := range []string{\"HTTP/1.0\", \"HTTP/1.1\"} {\n+\t\tconn, err := net.Dial(\"tcp\", ts.Listener.Addr().String())\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error dialing: %v\", err)\n+\t\t}\n+\t\t_, err = fmt.Fprintf(conn, \"GET / %v\\r\\nConnection: keep-alive\\r\\nHost: foo\\r\\n\\r\\n\", version)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error writing: %v\", err)\n+\t\t}\n+\t\treq, _ := NewRequest(\"GET\", \"/\", nil)\n+\t\tres, err := ReadResponse(bufio.NewReader(conn), req)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error reading response: %v\", err)\n+\t\t}\n+\t\tif te := res.TransferEncoding; len(te) > 0 {\n+\t\t\tt.Errorf(\"For version %q, Transfer-Encoding = %q; want none\", version, te)\n+\t\t}\n+\t\tif cl := res.ContentLength; cl != 0 {\n+\t\t\tt.Errorf(\"For version %q, Content-Length = %v; want 0\", version, cl)\n+\t\t}\n+\t\tconn.Close()\n+\t}\n+}\n+\n // goTimeout runs f, failing t if f takes more than ns to complete.\n func goTimeout(t *testing.T, d time.Duration, f func()) {\n \tch := make(chan bool, 2)"}, {"sha": "b74b7629809815c284dd8826257cd2db2be5b1bd", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -390,6 +390,11 @@ func (w *response) WriteHeader(code int) {\n \tif !w.req.ProtoAtLeast(1, 0) {\n \t\treturn\n \t}\n+\n+\tif w.closeAfterReply && !hasToken(w.header.Get(\"Connection\"), \"close\") {\n+\t\tw.header.Set(\"Connection\", \"close\")\n+\t}\n+\n \tproto := \"HTTP/1.0\"\n \tif w.req.ProtoAtLeast(1, 1) {\n \t\tproto = \"HTTP/1.1\"\n@@ -508,8 +513,16 @@ func (w *response) Write(data []byte) (n int, err error) {\n }\n \n func (w *response) finishRequest() {\n-\t// If this was an HTTP/1.0 request with keep-alive and we sent a Content-Length\n-\t// back, we can make this a keep-alive response ...\n+\t// If the handler never wrote any bytes and never sent a Content-Length\n+\t// response header, set the length explicitly to zero. This helps\n+\t// HTTP/1.0 clients keep their \"keep-alive\" connections alive, and for\n+\t// HTTP/1.1 clients is just as good as the alternative: sending a\n+\t// chunked response and immediately sending the zero-length EOF chunk.\n+\tif w.written == 0 && w.header.Get(\"Content-Length\") == \"\" {\n+\t\tw.header.Set(\"Content-Length\", \"0\")\n+\t}\n+\t// If this was an HTTP/1.0 request with keep-alive and we sent a\n+\t// Content-Length back, we can make this a keep-alive response ...\n \tif w.req.wantsHttp10KeepAlive() {\n \t\tsentLength := w.header.Get(\"Content-Length\") != \"\"\n \t\tif sentLength && w.header.Get(\"Connection\") == \"keep-alive\" {\n@@ -817,13 +830,13 @@ func RedirectHandler(url string, code int) Handler {\n // patterns and calls the handler for the pattern that\n // most closely matches the URL.\n //\n-// Patterns named fixed, rooted paths, like \"/favicon.ico\",\n+// Patterns name fixed, rooted paths, like \"/favicon.ico\",\n // or rooted subtrees, like \"/images/\" (note the trailing slash).\n // Longer patterns take precedence over shorter ones, so that\n // if there are handlers registered for both \"/images/\"\n // and \"/images/thumbnails/\", the latter handler will be\n // called for paths beginning \"/images/thumbnails/\" and the\n-// former will receiver requests for any other paths in the\n+// former will receive requests for any other paths in the\n // \"/images/\" subtree.\n //\n // Patterns may optionally begin with a host name, restricting matches to\n@@ -917,11 +930,13 @@ func (mux *ServeMux) handler(r *Request) Handler {\n // ServeHTTP dispatches the request to the handler whose\n // pattern most closely matches the request URL.\n func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n-\t// Clean path to canonical form and redirect.\n-\tif p := cleanPath(r.URL.Path); p != r.URL.Path {\n-\t\tw.Header().Set(\"Location\", p)\n-\t\tw.WriteHeader(StatusMovedPermanently)\n-\t\treturn\n+\tif r.Method != \"CONNECT\" {\n+\t\t// Clean path to canonical form and redirect.\n+\t\tif p := cleanPath(r.URL.Path); p != r.URL.Path {\n+\t\t\tw.Header().Set(\"Location\", p)\n+\t\t\tw.WriteHeader(StatusMovedPermanently)\n+\t\t\treturn\n+\t\t}\n \t}\n \tmux.handler(r).ServeHTTP(w, r)\n }"}, {"sha": "6131d0d1ee1ac2d269c5611e03c77f420b795098", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 70, "deletions": 41, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -41,8 +41,9 @@ const DefaultMaxIdleConnsPerHost = 2\n // https, and http proxies (for either http or https with CONNECT).\n // Transport can also cache connections for future re-use.\n type Transport struct {\n-\tlk       sync.Mutex\n+\tidleLk   sync.Mutex\n \tidleConn map[string][]*persistConn\n+\taltLk    sync.RWMutex\n \taltProto map[string]RoundTripper // nil or map of URI scheme => RoundTripper\n \n \t// TODO: tunable on global max cached connections\n@@ -131,12 +132,12 @@ func (t *Transport) RoundTrip(req *Request) (resp *Response, err error) {\n \t\treturn nil, errors.New(\"http: nil Request.Header\")\n \t}\n \tif req.URL.Scheme != \"http\" && req.URL.Scheme != \"https\" {\n-\t\tt.lk.Lock()\n+\t\tt.altLk.RLock()\n \t\tvar rt RoundTripper\n \t\tif t.altProto != nil {\n \t\t\trt = t.altProto[req.URL.Scheme]\n \t\t}\n-\t\tt.lk.Unlock()\n+\t\tt.altLk.RUnlock()\n \t\tif rt == nil {\n \t\t\treturn nil, &badStringError{\"unsupported protocol scheme\", req.URL.Scheme}\n \t\t}\n@@ -170,8 +171,8 @@ func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper) {\n \tif scheme == \"http\" || scheme == \"https\" {\n \t\tpanic(\"protocol \" + scheme + \" already registered\")\n \t}\n-\tt.lk.Lock()\n-\tdefer t.lk.Unlock()\n+\tt.altLk.Lock()\n+\tdefer t.altLk.Unlock()\n \tif t.altProto == nil {\n \t\tt.altProto = make(map[string]RoundTripper)\n \t}\n@@ -186,17 +187,18 @@ func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper) {\n // a \"keep-alive\" state. It does not interrupt any connections currently\n // in use.\n func (t *Transport) CloseIdleConnections() {\n-\tt.lk.Lock()\n-\tdefer t.lk.Unlock()\n-\tif t.idleConn == nil {\n+\tt.idleLk.Lock()\n+\tm := t.idleConn\n+\tt.idleConn = nil\n+\tt.idleLk.Unlock()\n+\tif m == nil {\n \t\treturn\n \t}\n-\tfor _, conns := range t.idleConn {\n+\tfor _, conns := range m {\n \t\tfor _, pconn := range conns {\n \t\t\tpconn.close()\n \t\t}\n \t}\n-\tt.idleConn = make(map[string][]*persistConn)\n }\n \n //\n@@ -242,8 +244,6 @@ func (cm *connectMethod) proxyAuth() string {\n // If pconn is no longer needed or not in a good state, putIdleConn\n // returns false.\n func (t *Transport) putIdleConn(pconn *persistConn) bool {\n-\tt.lk.Lock()\n-\tdefer t.lk.Unlock()\n \tif t.DisableKeepAlives || t.MaxIdleConnsPerHost < 0 {\n \t\tpconn.close()\n \t\treturn false\n@@ -256,21 +256,27 @@ func (t *Transport) putIdleConn(pconn *persistConn) bool {\n \tif max == 0 {\n \t\tmax = DefaultMaxIdleConnsPerHost\n \t}\n+\tt.idleLk.Lock()\n+\tif t.idleConn == nil {\n+\t\tt.idleConn = make(map[string][]*persistConn)\n+\t}\n \tif len(t.idleConn[key]) >= max {\n+\t\tt.idleLk.Unlock()\n \t\tpconn.close()\n \t\treturn false\n \t}\n \tt.idleConn[key] = append(t.idleConn[key], pconn)\n+\tt.idleLk.Unlock()\n \treturn true\n }\n \n func (t *Transport) getIdleConn(cm *connectMethod) (pconn *persistConn) {\n-\tt.lk.Lock()\n-\tdefer t.lk.Unlock()\n+\tkey := cm.String()\n+\tt.idleLk.Lock()\n+\tdefer t.idleLk.Unlock()\n \tif t.idleConn == nil {\n-\t\tt.idleConn = make(map[string][]*persistConn)\n+\t\treturn nil\n \t}\n-\tkey := cm.String()\n \tfor {\n \t\tpconns, ok := t.idleConn[key]\n \t\tif !ok {\n@@ -365,7 +371,18 @@ func (t *Transport) getConn(cm *connectMethod) (*persistConn, error) {\n \n \tif cm.targetScheme == \"https\" {\n \t\t// Initiate TLS and check remote host name against certificate.\n-\t\tconn = tls.Client(conn, t.TLSClientConfig)\n+\t\tcfg := t.TLSClientConfig\n+\t\tif cfg == nil || cfg.ServerName == \"\" {\n+\t\t\thost, _, _ := net.SplitHostPort(cm.addr())\n+\t\t\tif cfg == nil {\n+\t\t\t\tcfg = &tls.Config{ServerName: host}\n+\t\t\t} else {\n+\t\t\t\tclone := *cfg // shallow clone\n+\t\t\t\tclone.ServerName = host\n+\t\t\t\tcfg = &clone\n+\t\t\t}\n+\t\t}\n+\t\tconn = tls.Client(conn, cfg)\n \t\tif err = conn.(*tls.Conn).Handshake(); err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -484,6 +501,7 @@ type persistConn struct {\n \tt        *Transport\n \tcacheKey string // its connectMethod.String()\n \tconn     net.Conn\n+\tclosed   bool                // whether conn has been closed\n \tbr       *bufio.Reader       // from conn\n \tbw       *bufio.Writer       // to conn\n \treqch    chan requestAndChan // written by roundTrip(); read by readLoop()\n@@ -501,8 +519,9 @@ type persistConn struct {\n \n func (pc *persistConn) isBroken() bool {\n \tpc.lk.Lock()\n-\tdefer pc.lk.Unlock()\n-\treturn pc.broken\n+\tb := pc.broken\n+\tpc.lk.Unlock()\n+\treturn b\n }\n \n var remoteSideClosedFunc func(error) bool // or nil to use default\n@@ -571,29 +590,32 @@ func (pc *persistConn) readLoop() {\n \n \t\thasBody := resp != nil && resp.ContentLength != 0\n \t\tvar waitForBodyRead chan bool\n-\t\tif alive {\n-\t\t\tif hasBody {\n-\t\t\t\tlastbody = resp.Body\n-\t\t\t\twaitForBodyRead = make(chan bool)\n-\t\t\t\tresp.Body.(*bodyEOFSignal).fn = func() {\n-\t\t\t\t\tif !pc.t.putIdleConn(pc) {\n-\t\t\t\t\t\talive = false\n-\t\t\t\t\t}\n-\t\t\t\t\twaitForBodyRead <- true\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// When there's no response body, we immediately\n-\t\t\t\t// reuse the TCP connection (putIdleConn), but\n-\t\t\t\t// we need to prevent ClientConn.Read from\n-\t\t\t\t// closing the Response.Body on the next\n-\t\t\t\t// loop, otherwise it might close the body\n-\t\t\t\t// before the client code has had a chance to\n-\t\t\t\t// read it (even though it'll just be 0, EOF).\n-\t\t\t\tlastbody = nil\n-\n-\t\t\t\tif !pc.t.putIdleConn(pc) {\n+\t\tif hasBody {\n+\t\t\tlastbody = resp.Body\n+\t\t\twaitForBodyRead = make(chan bool)\n+\t\t\tresp.Body.(*bodyEOFSignal).fn = func() {\n+\t\t\t\tif alive && !pc.t.putIdleConn(pc) {\n \t\t\t\t\talive = false\n \t\t\t\t}\n+\t\t\t\tif !alive {\n+\t\t\t\t\tpc.close()\n+\t\t\t\t}\n+\t\t\t\twaitForBodyRead <- true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif alive && !hasBody {\n+\t\t\t// When there's no response body, we immediately\n+\t\t\t// reuse the TCP connection (putIdleConn), but\n+\t\t\t// we need to prevent ClientConn.Read from\n+\t\t\t// closing the Response.Body on the next\n+\t\t\t// loop, otherwise it might close the body\n+\t\t\t// before the client code has had a chance to\n+\t\t\t// read it (even though it'll just be 0, EOF).\n+\t\t\tlastbody = nil\n+\n+\t\t\tif !pc.t.putIdleConn(pc) {\n+\t\t\t\talive = false\n \t\t\t}\n \t\t}\n \n@@ -604,6 +626,10 @@ func (pc *persistConn) readLoop() {\n \t\tif waitForBodyRead != nil {\n \t\t\t<-waitForBodyRead\n \t\t}\n+\n+\t\tif !alive {\n+\t\t\tpc.close()\n+\t\t}\n \t}\n }\n \n@@ -669,7 +695,10 @@ func (pc *persistConn) close() {\n \n func (pc *persistConn) closeLocked() {\n \tpc.broken = true\n-\tpc.conn.Close()\n+\tif !pc.closed {\n+\t\tpc.conn.Close()\n+\t\tpc.closed = true\n+\t}\n \tpc.mutateHeaderFunc = nil\n }\n "}, {"sha": "e676bf6db397eea8122fd1f118e6f8ec9554a2f6", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -13,13 +13,15 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"net\"\n \t. \"net/http\"\n \t\"net/http/httptest\"\n \t\"net/url\"\n \t\"os\"\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -35,6 +37,68 @@ var hostPortHandler = HandlerFunc(func(w ResponseWriter, r *Request) {\n \tw.Write([]byte(r.RemoteAddr))\n })\n \n+// testCloseConn is a net.Conn tracked by a testConnSet.\n+type testCloseConn struct {\n+\tnet.Conn\n+\tset *testConnSet\n+}\n+\n+func (c *testCloseConn) Close() error {\n+\tc.set.remove(c)\n+\treturn c.Conn.Close()\n+}\n+\n+// testConnSet tracks a set of TCP connections and whether they've\n+// been closed.\n+type testConnSet struct {\n+\tt      *testing.T\n+\tclosed map[net.Conn]bool\n+\tlist   []net.Conn // in order created\n+\tmutex  sync.Mutex\n+}\n+\n+func (tcs *testConnSet) insert(c net.Conn) {\n+\ttcs.mutex.Lock()\n+\tdefer tcs.mutex.Unlock()\n+\ttcs.closed[c] = false\n+\ttcs.list = append(tcs.list, c)\n+}\n+\n+func (tcs *testConnSet) remove(c net.Conn) {\n+\ttcs.mutex.Lock()\n+\tdefer tcs.mutex.Unlock()\n+\ttcs.closed[c] = true\n+}\n+\n+// some tests use this to manage raw tcp connections for later inspection\n+func makeTestDial(t *testing.T) (*testConnSet, func(n, addr string) (net.Conn, error)) {\n+\tconnSet := &testConnSet{\n+\t\tt:      t,\n+\t\tclosed: make(map[net.Conn]bool),\n+\t}\n+\tdial := func(n, addr string) (net.Conn, error) {\n+\t\tc, err := net.Dial(n, addr)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttc := &testCloseConn{c, connSet}\n+\t\tconnSet.insert(tc)\n+\t\treturn tc, nil\n+\t}\n+\treturn connSet, dial\n+}\n+\n+func (tcs *testConnSet) check(t *testing.T) {\n+\ttcs.mutex.Lock()\n+\tdefer tcs.mutex.Unlock()\n+\n+\tfor i, c := range tcs.list {\n+\t\tif !tcs.closed[c] {\n+\t\t\tt.Errorf(\"TCP connection #%d, %p (of %d total) was not closed\", i+1, c, len(tcs.list))\n+\t\t}\n+\t}\n+}\n+\n // Two subsequent requests and verify their response is the same.\n // The response from the server is our own IP:port\n func TestTransportKeepAlives(t *testing.T) {\n@@ -72,8 +136,12 @@ func TestTransportConnectionCloseOnResponse(t *testing.T) {\n \tts := httptest.NewServer(hostPortHandler)\n \tdefer ts.Close()\n \n+\tconnSet, testDial := makeTestDial(t)\n+\n \tfor _, connectionClose := range []bool{false, true} {\n-\t\ttr := &Transport{}\n+\t\ttr := &Transport{\n+\t\t\tDial: testDial,\n+\t\t}\n \t\tc := &Client{Transport: tr}\n \n \t\tfetch := func(n int) string {\n@@ -92,8 +160,8 @@ func TestTransportConnectionCloseOnResponse(t *testing.T) {\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, Do: %v\", connectionClose, n, err)\n \t\t\t}\n-\t\t\tbody, err := ioutil.ReadAll(res.Body)\n \t\t\tdefer res.Body.Close()\n+\t\t\tbody, err := ioutil.ReadAll(res.Body)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, ReadAll: %v\", connectionClose, n, err)\n \t\t\t}\n@@ -107,15 +175,23 @@ func TestTransportConnectionCloseOnResponse(t *testing.T) {\n \t\t\tt.Errorf(\"error in connectionClose=%v. unexpected bodiesDiffer=%v; body1=%q; body2=%q\",\n \t\t\t\tconnectionClose, bodiesDiffer, body1, body2)\n \t\t}\n+\n+\t\ttr.CloseIdleConnections()\n \t}\n+\n+\tconnSet.check(t)\n }\n \n func TestTransportConnectionCloseOnRequest(t *testing.T) {\n \tts := httptest.NewServer(hostPortHandler)\n \tdefer ts.Close()\n \n+\tconnSet, testDial := makeTestDial(t)\n+\n \tfor _, connectionClose := range []bool{false, true} {\n-\t\ttr := &Transport{}\n+\t\ttr := &Transport{\n+\t\t\tDial: testDial,\n+\t\t}\n \t\tc := &Client{Transport: tr}\n \n \t\tfetch := func(n int) string {\n@@ -149,7 +225,11 @@ func TestTransportConnectionCloseOnRequest(t *testing.T) {\n \t\t\tt.Errorf(\"error in connectionClose=%v. unexpected bodiesDiffer=%v; body1=%q; body2=%q\",\n \t\t\t\tconnectionClose, bodiesDiffer, body1, body2)\n \t\t}\n+\n+\t\ttr.CloseIdleConnections()\n \t}\n+\n+\tconnSet.check(t)\n }\n \n func TestTransportIdleCacheKeys(t *testing.T) {\n@@ -724,6 +804,35 @@ func TestTransportIdleConnCrash(t *testing.T) {\n \t<-didreq\n }\n \n+// Test that the transport doesn't close the TCP connection early,\n+// before the response body has been read.  This was a regression\n+// which sadly lacked a triggering test.  The large response body made\n+// the old race easier to trigger.\n+func TestIssue3644(t *testing.T) {\n+\tconst numFoos = 5000\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tw.Header().Set(\"Connection\", \"close\")\n+\t\tfor i := 0; i < numFoos; i++ {\n+\t\t\tw.Write([]byte(\"foo \"))\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\ttr := &Transport{}\n+\tc := &Client{Transport: tr}\n+\tres, err := c.Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer res.Body.Close()\n+\tbs, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif len(bs) != numFoos*len(\"foo \") {\n+\t\tt.Errorf(\"unexpected response length\")\n+\t}\n+}\n+\n type fooProto struct{}\n \n func (fooProto) RoundTrip(req *Request) (*Response, error) {"}, {"sha": "ae21b3c3dde0f551b1b65b5018052ca7626ecec3", "filename": "libgo/go/net/iprawsock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fiprawsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fiprawsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -6,7 +6,7 @@\n \n package net\n \n-// IPAddr represents the address of a IP end point.\n+// IPAddr represents the address of an IP end point.\n type IPAddr struct {\n \tIP IP\n }\n@@ -21,7 +21,7 @@ func (a *IPAddr) String() string {\n \treturn a.IP.String()\n }\n \n-// ResolveIPAddr parses addr as a IP address and resolves domain\n+// ResolveIPAddr parses addr as an IP address and resolves domain\n // names to numeric addresses on the network net, which must be\n // \"ip\", \"ip4\" or \"ip6\".  A literal IPv6 host address must be\n // enclosed in square brackets, as in \"[::]\"."}, {"sha": "ea3321b7e2fa039eb511fca1b8d4a2a1eec3df76", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -59,7 +59,7 @@ func (c *IPConn) RemoteAddr() Addr {\n \n // IP-specific methods.\n \n-// ReadFromIP reads a IP packet from c, copying the payload into b.\n+// ReadFromIP reads an IP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet.\n //\n@@ -75,7 +75,7 @@ func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n \treturn 0, nil, syscall.EPLAN9\n }\n \n-// WriteToIP writes a IP packet to addr via c, copying the payload from b.\n+// WriteToIP writes an IP packet to addr via c, copying the payload from b.\n //\n // WriteToIP can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;"}, {"sha": "dda81ddf8816a2721c475b05e5de890b4871cc1f", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -146,7 +146,7 @@ func (c *IPConn) SetWriteBuffer(bytes int) error {\n \n // IP-specific methods.\n \n-// ReadFromIP reads a IP packet from c, copying the payload into b.\n+// ReadFromIP reads an IP packet from c, copying the payload into b.\n // It returns the number of bytes copied into b and the return address\n // that was on the packet.\n //\n@@ -184,7 +184,7 @@ func (c *IPConn) ReadFrom(b []byte) (int, Addr, error) {\n \treturn n, uaddr.toAddr(), err\n }\n \n-// WriteToIP writes a IP packet to addr via c, copying the payload from b.\n+// WriteToIP writes an IP packet to addr via c, copying the payload from b.\n //\n // WriteToIP can be made to time out and return\n // an error with Timeout() == true after a fixed time limit;"}, {"sha": "93cc4d1edd48ecb266e94600a945b4f976902525", "filename": "libgo/go/net/mail/message.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmail%2Fmessage.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -47,7 +47,8 @@ type Message struct {\n }\n \n // ReadMessage reads a message from r.\n-// The headers are parsed, and the body of the message will be reading from r.\n+// The headers are parsed, and the body of the message will be available\n+// for reading from r.\n func ReadMessage(r io.Reader) (msg *Message, err error) {\n \ttp := textproto.NewReader(bufio.NewReader(r))\n "}, {"sha": "3bcc54fe53a81bb775ba2aa928a7db29b2f5b488", "filename": "libgo/go/net/net_posix.go", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fnet_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fnet_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_posix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd windows\n+\n+// Base posix socket functions.\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+type conn struct {\n+\tfd *netFD\n+}\n+\n+func (c *conn) ok() bool { return c != nil && c.fd != nil }\n+\n+// Implementation of the Conn interface - see Conn for documentation.\n+\n+// Read implements the Conn Read method.\n+func (c *conn) Read(b []byte) (int, error) {\n+\tif !c.ok() {\n+\t\treturn 0, syscall.EINVAL\n+\t}\n+\treturn c.fd.Read(b)\n+}\n+\n+// Write implements the Conn Write method.\n+func (c *conn) Write(b []byte) (int, error) {\n+\tif !c.ok() {\n+\t\treturn 0, syscall.EINVAL\n+\t}\n+\treturn c.fd.Write(b)\n+}\n+\n+// LocalAddr returns the local network address.\n+func (c *conn) LocalAddr() Addr {\n+\tif !c.ok() {\n+\t\treturn nil\n+\t}\n+\treturn c.fd.laddr\n+}\n+\n+// RemoteAddr returns the remote network address.\n+func (c *conn) RemoteAddr() Addr {\n+\tif !c.ok() {\n+\t\treturn nil\n+\t}\n+\treturn c.fd.raddr\n+}\n+\n+// SetDeadline implements the Conn SetDeadline method.\n+func (c *conn) SetDeadline(t time.Time) error {\n+\tif !c.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn setDeadline(c.fd, t)\n+}\n+\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n+func (c *conn) SetReadDeadline(t time.Time) error {\n+\tif !c.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn setReadDeadline(c.fd, t)\n+}\n+\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n+func (c *conn) SetWriteDeadline(t time.Time) error {\n+\tif !c.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn setWriteDeadline(c.fd, t)\n+}\n+\n+// SetReadBuffer sets the size of the operating system's\n+// receive buffer associated with the connection.\n+func (c *conn) SetReadBuffer(bytes int) error {\n+\tif !c.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn setReadBuffer(c.fd, bytes)\n+}\n+\n+// SetWriteBuffer sets the size of the operating system's\n+// transmit buffer associated with the connection.\n+func (c *conn) SetWriteBuffer(bytes int) error {\n+\tif !c.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn setWriteBuffer(c.fd, bytes)\n+}\n+\n+// File returns a copy of the underlying os.File, set to blocking mode.\n+// It is the caller's responsibility to close f when finished.\n+// Closing c does not affect f, and closing f does not affect c.\n+func (c *conn) File() (f *os.File, err error) { return c.fd.dup() }\n+\n+// Close closes the connection.\n+func (c *conn) Close() error {\n+\tif !c.ok() {\n+\t\treturn syscall.EINVAL\n+\t}\n+\treturn c.fd.Close()\n+}"}, {"sha": "adc29d5a1b3fc9cfe07b8eb4bee1f2bb6d5542a8", "filename": "libgo/go/net/rpc/jsonrpc/all_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Frpc%2Fjsonrpc%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Frpc%2Fjsonrpc%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fjsonrpc%2Fall_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -108,7 +108,7 @@ func TestClient(t *testing.T) {\n \t\tt.Errorf(\"Add: expected no error but got string %q\", err.Error())\n \t}\n \tif reply.C != args.A+args.B {\n-\t\tt.Errorf(\"Add: expected %d got %d\", reply.C, args.A+args.B)\n+\t\tt.Errorf(\"Add: got %d expected %d\", reply.C, args.A+args.B)\n \t}\n \n \targs = &Args{7, 8}\n@@ -118,7 +118,7 @@ func TestClient(t *testing.T) {\n \t\tt.Errorf(\"Mul: expected no error but got string %q\", err.Error())\n \t}\n \tif reply.C != args.A*args.B {\n-\t\tt.Errorf(\"Mul: expected %d got %d\", reply.C, args.A*args.B)\n+\t\tt.Errorf(\"Mul: got %d expected %d\", reply.C, args.A*args.B)\n \t}\n \n \t// Out of order.\n@@ -133,15 +133,15 @@ func TestClient(t *testing.T) {\n \t\tt.Errorf(\"Add: expected no error but got string %q\", addCall.Error.Error())\n \t}\n \tif addReply.C != args.A+args.B {\n-\t\tt.Errorf(\"Add: expected %d got %d\", addReply.C, args.A+args.B)\n+\t\tt.Errorf(\"Add: got %d expected %d\", addReply.C, args.A+args.B)\n \t}\n \n \tmulCall = <-mulCall.Done\n \tif mulCall.Error != nil {\n \t\tt.Errorf(\"Mul: expected no error but got string %q\", mulCall.Error.Error())\n \t}\n \tif mulReply.C != args.A*args.B {\n-\t\tt.Errorf(\"Mul: expected %d got %d\", mulReply.C, args.A*args.B)\n+\t\tt.Errorf(\"Mul: got %d expected %d\", mulReply.C, args.A*args.B)\n \t}\n \n \t// Error test"}, {"sha": "e5282202c3d5e2cf78c55f115a016ee0b43cbbf8", "filename": "libgo/go/net/rpc/server.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -24,12 +24,13 @@\n \n \twhere T, T1 and T2 can be marshaled by encoding/gob.\n \tThese requirements apply even if a different codec is used.\n-\t(In future, these requirements may soften for custom codecs.)\n+\t(In the future, these requirements may soften for custom codecs.)\n \n \tThe method's first argument represents the arguments provided by the caller; the\n \tsecond argument represents the result parameters to be returned to the caller.\n \tThe method's return value, if non-nil, is passed back as a string that the client\n-\tsees as if created by errors.New.\n+\tsees as if created by errors.New.  If an error is returned, the reply parameter\n+\twill not be sent back to the client.\n \n \tThe server may handle requests on a single connection by calling ServeConn.  More\n \ttypically it will create a network listener and call Accept or, for an HTTP\n@@ -181,7 +182,7 @@ type Response struct {\n \n // Server represents an RPC Server.\n type Server struct {\n-\tmu         sync.Mutex // protects the serviceMap\n+\tmu         sync.RWMutex // protects the serviceMap\n \tserviceMap map[string]*service\n \treqLock    sync.Mutex // protects freeReq\n \tfreeReq    *Request\n@@ -538,9 +539,9 @@ func (server *Server) readRequestHeader(codec ServerCodec) (service *service, mt\n \t\treturn\n \t}\n \t// Look up the request.\n-\tserver.mu.Lock()\n+\tserver.mu.RLock()\n \tservice = server.serviceMap[serviceMethod[0]]\n-\tserver.mu.Unlock()\n+\tserver.mu.RUnlock()\n \tif service == nil {\n \t\terr = errors.New(\"rpc: can't find service \" + req.ServiceMethod)\n \t\treturn"}, {"sha": "b139c427654f65d47e2f7c08adb6c30c6515db9f", "filename": "libgo/go/net/sockopt.go", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -144,22 +144,6 @@ func setDeadline(fd *netFD, t time.Time) error {\n \treturn setWriteDeadline(fd, t)\n }\n \n-func setReuseAddr(fd *netFD, reuse bool) error {\n-\tif err := fd.incref(false); err != nil {\n-\t\treturn err\n-\t}\n-\tdefer fd.decref()\n-\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse)))\n-}\n-\n-func setDontRoute(fd *netFD, dontroute bool) error {\n-\tif err := fd.incref(false); err != nil {\n-\t\treturn err\n-\t}\n-\tdefer fd.decref()\n-\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute)))\n-}\n-\n func setKeepAlive(fd *netFD, keepalive bool) error {\n \tif err := fd.incref(false); err != nil {\n \t\treturn err"}, {"sha": "85260c82aeab651d07222c5b16390d655e1d869a", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -5,21 +5,36 @@\n package os\n \n func isExist(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn contains(err.Error(), \" exists\")\n }\n \n func isNotExist(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn contains(err.Error(), \"does not exist\")\n }\n \n func isPermission(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn contains(err.Error(), \"permission denied\")"}, {"sha": "81b626aecb28e1ddebfd01dcaad285fc976b616b", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -9,21 +9,36 @@ package os\n import \"syscall\"\n \n func isExist(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.EEXIST || err == ErrExist\n }\n \n func isNotExist(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.ENOENT || err == ErrNotExist\n }\n \n func isPermission(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.EACCES || err == syscall.EPERM || err == ErrPermission"}, {"sha": "054bb3fcbcc0d2b2d4beb255f017659826e723e9", "filename": "libgo/go/os/error_test.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -79,3 +79,30 @@ func checkErrorPredicate(predName string, pred func(error) bool, err error) stri\n \t}\n \treturn \"\"\n }\n+\n+var isExistTests = []struct {\n+\terr   error\n+\tis    bool\n+\tisnot bool\n+}{\n+\t{&os.PathError{Err: os.ErrInvalid}, false, false},\n+\t{&os.PathError{Err: os.ErrPermission}, false, false},\n+\t{&os.PathError{Err: os.ErrExist}, true, false},\n+\t{&os.PathError{Err: os.ErrNotExist}, false, true},\n+\t{&os.LinkError{Err: os.ErrInvalid}, false, false},\n+\t{&os.LinkError{Err: os.ErrPermission}, false, false},\n+\t{&os.LinkError{Err: os.ErrExist}, true, false},\n+\t{&os.LinkError{Err: os.ErrNotExist}, false, true},\n+\t{nil, false, false},\n+}\n+\n+func TestIsExist(t *testing.T) {\n+\tfor _, tt := range isExistTests {\n+\t\tif is := os.IsExist(tt.err); is != tt.is {\n+\t\t\tt.Errorf(\"os.IsExist(%T %v) = %v, want %v\", tt.err, tt.err, is, tt.is)\n+\t\t}\n+\t\tif isnot := os.IsNotExist(tt.err); isnot != tt.isnot {\n+\t\t\tt.Errorf(\"os.IsNotExist(%T %v) = %v, want %v\", tt.err, tt.err, isnot, tt.isnot)\n+\t\t}\n+\t}\n+}"}, {"sha": "83db6c07845333266d5c5ffabb3d05a9436056f7", "filename": "libgo/go/os/error_windows.go", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ferror_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_windows.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -7,23 +7,38 @@ package os\n import \"syscall\"\n \n func isExist(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.ERROR_ALREADY_EXISTS ||\n \t\terr == syscall.ERROR_FILE_EXISTS || err == ErrExist\n }\n \n func isNotExist(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.ERROR_FILE_NOT_FOUND ||\n \t\terr == syscall.ERROR_PATH_NOT_FOUND || err == ErrNotExist\n }\n \n func isPermission(err error) bool {\n-\tif pe, ok := err.(*PathError); ok {\n+\tswitch pe := err.(type) {\n+\tcase nil:\n+\t\treturn false\n+\tcase *PathError:\n+\t\terr = pe.Err\n+\tcase *LinkError:\n \t\terr = pe.Err\n \t}\n \treturn err == syscall.ERROR_ACCESS_DENIED || err == ErrPermission"}, {"sha": "6681acfd43bf911ab06217d147d2f668affb7a72", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -6,14 +6,15 @@ package os\n \n import (\n \t\"runtime\"\n+\t\"sync/atomic\"\n \t\"syscall\"\n )\n \n // Process stores the information about a process created by StartProcess.\n type Process struct {\n \tPid    int\n \thandle uintptr\n-\tdone   bool // process has been successfully waited on\n+\tisdone uint32 // process has been successfully waited on, non zero if true\n }\n \n func newProcess(pid int, handle uintptr) *Process {\n@@ -22,6 +23,14 @@ func newProcess(pid int, handle uintptr) *Process {\n \treturn p\n }\n \n+func (p *Process) setDone() {\n+\tatomic.StoreUint32(&p.isdone, 1)\n+}\n+\n+func (p *Process) done() bool {\n+\treturn atomic.LoadUint32(&p.isdone) > 0\n+}\n+\n // ProcAttr holds the attributes that will be applied to a new process\n // started by StartProcess.\n type ProcAttr struct {"}, {"sha": "c4907cd7d7b519846e82f75a0d1f29b80e527dc8", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -16,7 +16,7 @@ import (\n \t\"syscall\"\n )\n \n-// Error records the name of a binary that failed to be be executed\n+// Error records the name of a binary that failed to be executed\n // and the reason it failed.\n type Error struct {\n \tName string\n@@ -143,6 +143,9 @@ func (c *Cmd) argv() []string {\n func (c *Cmd) stdin() (f *os.File, err error) {\n \tif c.Stdin == nil {\n \t\tf, err = os.Open(os.DevNull)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n \t\tc.closeAfterStart = append(c.closeAfterStart, f)\n \t\treturn\n \t}\n@@ -182,6 +185,9 @@ func (c *Cmd) stderr() (f *os.File, err error) {\n func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {\n \tif w == nil {\n \t\tf, err = os.OpenFile(os.DevNull, os.O_WRONLY, 0)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n \t\tc.closeAfterStart = append(c.closeAfterStart, f)\n \t\treturn\n \t}"}, {"sha": "27ebb60d3d0789ef53bddb5f02f2903b0ea240f4", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -167,6 +167,18 @@ func TestExtraFiles(t *testing.T) {\n \t}\n \tdefer ln.Close()\n \n+\t// Make sure duplicated fds don't leak to the child.\n+\tf, err := ln.(*net.TCPListener).File()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\tln2, err := net.FileListener(f)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer ln2.Close()\n+\n \t// Force TLS root certs to be loaded (which might involve\n \t// cgo), to make sure none of that potential C code leaks fds.\n \tts := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n@@ -203,6 +215,56 @@ func TestExtraFiles(t *testing.T) {\n \t}\n }\n \n+func TestExtraFilesRace(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Logf(\"no operating system support; skipping\")\n+\t\treturn\n+\t}\n+\tlisten := func() net.Listener {\n+\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn ln\n+\t}\n+\tlistenerFile := func(ln net.Listener) *os.File {\n+\t\tf, err := ln.(*net.TCPListener).File()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn f\n+\t}\n+\trunCommand := func(c *Cmd, out chan<- string) {\n+\t\tbout, err := c.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tout <- \"ERROR:\" + err.Error()\n+\t\t} else {\n+\t\t\tout <- string(bout)\n+\t\t}\n+\t}\n+\n+\tfor i := 0; i < 10; i++ {\n+\t\tla := listen()\n+\t\tca := helperCommand(\"describefiles\")\n+\t\tca.ExtraFiles = []*os.File{listenerFile(la)}\n+\t\tlb := listen()\n+\t\tcb := helperCommand(\"describefiles\")\n+\t\tcb.ExtraFiles = []*os.File{listenerFile(lb)}\n+\t\tares := make(chan string)\n+\t\tbres := make(chan string)\n+\t\tgo runCommand(ca, ares)\n+\t\tgo runCommand(cb, bres)\n+\t\tif got, want := <-ares, fmt.Sprintf(\"fd3: listener %s\\n\", la.Addr()); got != want {\n+\t\t\tt.Errorf(\"iteration %d, process A got:\\n%s\\nwant:\\n%s\\n\", i, got, want)\n+\t\t}\n+\t\tif got, want := <-bres, fmt.Sprintf(\"fd3: listener %s\\n\", lb.Addr()); got != want {\n+\t\t\tt.Errorf(\"iteration %d, process B got:\\n%s\\nwant:\\n%s\\n\", i, got, want)\n+\t\t}\n+\t\tla.Close()\n+\t\tlb.Close()\n+\t}\n+}\n+\n // TestHelperProcess isn't a real test. It's used as a helper process\n // for TestParameterRun.\n func TestHelperProcess(*testing.T) {\n@@ -318,6 +380,16 @@ func TestHelperProcess(*testing.T) {\n \tcase \"exit\":\n \t\tn, _ := strconv.Atoi(args[0])\n \t\tos.Exit(n)\n+\tcase \"describefiles\":\n+\t\tfor fd := uintptr(3); fd < 25; fd++ {\n+\t\t\tf := os.NewFile(fd, fmt.Sprintf(\"fd-%d\", fd))\n+\t\t\tln, err := net.FileListener(f)\n+\t\t\tif err == nil {\n+\t\t\t\tfmt.Printf(\"fd%d: listener %s\\n\", fd, ln.Addr())\n+\t\t\t\tln.Close()\n+\t\t\t}\n+\t\t}\n+\t\tos.Exit(0)\n \tdefault:\n \t\tfmt.Fprintf(os.Stderr, \"Unknown command %q\\n\", cmd)\n \t\tos.Exit(2)"}, {"sha": "01f06e2cf93190089433a39be886ee71434add36", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -38,7 +38,7 @@ func (note Plan9Note) String() string {\n }\n \n func (p *Process) signal(sig Signal) error {\n-\tif p.done {\n+\tif p.done() {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n \n@@ -76,7 +76,7 @@ func (p *Process) wait() (ps *ProcessState, err error) {\n \t\t}\n \n \t\tif waitmsg.Pid == p.Pid {\n-\t\t\tp.done = true\n+\t\t\tp.setDone()\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "40fd0fd0ee6b27e0bbf6d08d537eda5709ac3abb", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -11,9 +11,10 @@ import (\n )\n \n func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error) {\n-\t// Double-check existence of the directory we want\n+\t// If there is no SysProcAttr (ie. no Chroot or changed\n+\t// UID/GID), double-check existence of the directory we want\n \t// to chdir into.  We can make the error clearer this way.\n-\tif attr != nil && attr.Dir != \"\" {\n+\tif attr != nil && attr.Sys == nil && attr.Dir != \"\" {\n \t\tif _, err := Stat(attr.Dir); err != nil {\n \t\t\tpe := err.(*PathError)\n \t\t\tpe.Op = \"chdir\""}, {"sha": "fa3ba8a19e4e13a081760e019eabb3a3ee48ee79", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -24,7 +24,7 @@ func (p *Process) wait() (ps *ProcessState, err error) {\n \t\treturn nil, NewSyscallError(\"wait\", e)\n \t}\n \tif pid1 != 0 {\n-\t\tp.done = true\n+\t\tp.setDone()\n \t}\n \tps = &ProcessState{\n \t\tpid:    pid1,\n@@ -35,7 +35,7 @@ func (p *Process) wait() (ps *ProcessState, err error) {\n }\n \n func (p *Process) signal(sig Signal) error {\n-\tif p.done {\n+\tif p.done() {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n \ts, ok := sig.(syscall.Signal)"}, {"sha": "4aa2ade631ed7b151ec831aaf3a083681f6923af", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -32,7 +32,7 @@ func (p *Process) wait() (ps *ProcessState, err error) {\n \tif e != nil {\n \t\treturn nil, NewSyscallError(\"GetProcessTimes\", e)\n \t}\n-\tp.done = true\n+\tp.setDone()\n \t// NOTE(brainman): It seems that sometimes process is not dead\n \t// when WaitForSingleObject returns. But we do not know any\n \t// other way to wait for it. Sleeping for a while seems to do\n@@ -43,7 +43,7 @@ func (p *Process) wait() (ps *ProcessState, err error) {\n }\n \n func (p *Process) signal(sig Signal) error {\n-\tif p.done {\n+\tif p.done() {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n \tif sig == Kill {"}, {"sha": "1ba32931541efa8a01b919f4ae77700babe7d17d", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -13,17 +13,6 @@ import (\n \n func sigpipe() // implemented in package runtime\n \n-func epipecheck(file *File, e error) {\n-\tif e == syscall.EPIPE {\n-\t\tfile.nepipe++\n-\t\tif file.nepipe >= 10 {\n-\t\t\tsigpipe()\n-\t\t}\n-\t} else {\n-\t\tfile.nepipe = 0\n-\t}\n-}\n-\n // Link creates newname as a hard link to the oldname file.\n // If there is an error, it will be of type *LinkError.\n func Link(oldname, newname string) error {"}, {"sha": "f677dbb986ad775bc4b6d898bb884f8393a08814", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -8,6 +8,7 @@ package os\n \n import (\n \t\"runtime\"\n+\t\"sync/atomic\"\n \t\"syscall\"\n )\n \n@@ -24,7 +25,7 @@ type file struct {\n \tfd      int\n \tname    string\n \tdirinfo *dirInfo // nil unless directory being read\n-\tnepipe  int      // number of consecutive EPIPE in Write\n+\tnepipe  int32    // number of consecutive EPIPE in Write\n }\n \n // Fd returns the integer Unix file descriptor referencing the open file.\n@@ -52,6 +53,16 @@ type dirInfo struct {\n \tdir *syscall.DIR // from opendir\n }\n \n+func epipecheck(file *File, e error) {\n+\tif e == syscall.EPIPE {\n+\t\tif atomic.AddInt32(&file.nepipe, 1) >= 10 {\n+\t\t\tsigpipe()\n+\t\t}\n+\t} else {\n+\t\tatomic.StoreInt32(&file.nepipe, 0)\n+\t}\n+}\n+\n // DevNull is the name of the operating system's ``null device.''\n // On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\".\n const DevNull = \"/dev/null\""}, {"sha": "5046e60af439b0bf3ea30862ab4457216f12b2da", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -67,10 +67,10 @@ var sysdir = func() (sd *sysDir) {\n \n func size(name string, t *testing.T) int64 {\n \tfile, err := Open(name)\n-\tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatal(\"open failed:\", err)\n \t}\n+\tdefer file.Close()\n \tvar buf [100]byte\n \tlen := 0\n \tfor {\n@@ -132,10 +132,10 @@ func TestStat(t *testing.T) {\n func TestFstat(t *testing.T) {\n \tpath := sfdir + \"/\" + sfname\n \tfile, err1 := Open(path)\n-\tdefer file.Close()\n \tif err1 != nil {\n \t\tt.Fatal(\"open failed:\", err1)\n \t}\n+\tdefer file.Close()\n \tdir, err2 := file.Stat()\n \tif err2 != nil {\n \t\tt.Fatal(\"fstat failed:\", err2)\n@@ -187,10 +187,10 @@ func TestRead0(t *testing.T) {\n \n func testReaddirnames(dir string, contents []string, t *testing.T) {\n \tfile, err := Open(dir)\n-\tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err)\n \t}\n+\tdefer file.Close()\n \ts, err2 := file.Readdirnames(-1)\n \tif err2 != nil {\n \t\tt.Fatalf(\"readdirnames %q failed: %v\", dir, err2)\n@@ -216,10 +216,10 @@ func testReaddirnames(dir string, contents []string, t *testing.T) {\n \n func testReaddir(dir string, contents []string, t *testing.T) {\n \tfile, err := Open(dir)\n-\tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err)\n \t}\n+\tdefer file.Close()\n \ts, err2 := file.Readdir(-1)\n \tif err2 != nil {\n \t\tt.Fatalf(\"readdir %q failed: %v\", dir, err2)\n@@ -283,10 +283,10 @@ func TestReaddirnamesOneAtATime(t *testing.T) {\n \t\tdir = \"/bin\"\n \t}\n \tfile, err := Open(dir)\n-\tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err)\n \t}\n+\tdefer file.Close()\n \tall, err1 := file.Readdirnames(-1)\n \tif err1 != nil {\n \t\tt.Fatalf(\"readdirnames %q failed: %v\", dir, err1)"}, {"sha": "ecb57872d52ff1036ce08ba645363f9b86725890", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -12,7 +12,7 @@ import (\n // Getpagesize returns the underlying system's memory page size.\n func Getpagesize() int { return syscall.Getpagesize() }\n \n-// A FileInfo describes a file and is returned by Stat and Lstat\n+// A FileInfo describes a file and is returned by Stat and Lstat.\n type FileInfo interface {\n \tName() string       // base name of the file\n \tSize() int64        // length in bytes for regular files; system-dependent for others"}, {"sha": "b07534b36f44540160631b313527dade5639446f", "filename": "libgo/go/path/path.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fpath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fpath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -166,7 +166,8 @@ func IsAbs(path string) bool {\n }\n \n // Dir returns all but the last element of path, typically the path's directory.\n-// The path is Cleaned and trailing slashes are removed before processing.\n+// After dropping the final element using Split, the path is Cleaned and trailing\n+// slashes are removed.\n // If the path is empty, Dir returns \".\".\n // If the path consists entirely of slashes followed by non-slash bytes, Dir\n // returns a single slash. In any other case, the returned path does not end in a"}, {"sha": "65be55060423de96fafdcf953bfb308e3fb3592f", "filename": "libgo/go/path/path_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fpath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fpath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -181,6 +181,7 @@ var dirtests = []PathTest{\n \t{\"x/\", \"x\"},\n \t{\"abc\", \".\"},\n \t{\"abc/def\", \"abc\"},\n+\t{\"abc////def\", \"abc\"},\n \t{\"a/b/.x\", \"a/b\"},\n \t{\"a/b/c.\", \"a/b\"},\n \t{\"a/b/c.x\", \"a/b\"},"}, {"sha": "56ba8a824c2c10201217ecab1f5e0e9db27e0bf8", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -1384,7 +1384,30 @@ func TestImportPath(t *testing.T) {\n \t\tpath string\n \t}{\n \t\t{TypeOf(&base64.Encoding{}).Elem(), \"encoding/base64\"},\n+\t\t{TypeOf(int(0)), \"\"},\n+\t\t{TypeOf(int8(0)), \"\"},\n+\t\t{TypeOf(int16(0)), \"\"},\n+\t\t{TypeOf(int32(0)), \"\"},\n+\t\t{TypeOf(int64(0)), \"\"},\n \t\t{TypeOf(uint(0)), \"\"},\n+\t\t{TypeOf(uint8(0)), \"\"},\n+\t\t{TypeOf(uint16(0)), \"\"},\n+\t\t{TypeOf(uint32(0)), \"\"},\n+\t\t{TypeOf(uint64(0)), \"\"},\n+\t\t{TypeOf(uintptr(0)), \"\"},\n+\t\t{TypeOf(float32(0)), \"\"},\n+\t\t{TypeOf(float64(0)), \"\"},\n+\t\t{TypeOf(complex64(0)), \"\"},\n+\t\t{TypeOf(complex128(0)), \"\"},\n+\t\t{TypeOf(byte(0)), \"\"},\n+\t\t{TypeOf(rune(0)), \"\"},\n+\t\t{TypeOf([]byte(nil)), \"\"},\n+\t\t{TypeOf([]rune(nil)), \"\"},\n+\t\t{TypeOf(string(\"\")), \"\"},\n+\t\t{TypeOf((*interface{})(nil)).Elem(), \"\"},\n+\t\t{TypeOf((*byte)(nil)), \"\"},\n+\t\t{TypeOf((*rune)(nil)), \"\"},\n+\t\t{TypeOf((*int64)(nil)), \"\"},\n \t\t{TypeOf(map[string]int{}), \"\"},\n \t\t{TypeOf((*error)(nil)).Elem(), \"\"},\n \t}"}, {"sha": "b25e5c73d1a989d9d5d59bb8c88894da9268f5a2", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -1705,10 +1705,11 @@ func ValueOf(i interface{}) Value {\n \treturn Value{typ, unsafe.Pointer(eface.word), fl}\n }\n \n-// Zero returns a Value representing a zero value for the specified type.\n+// Zero returns a Value representing the zero value for the specified type.\n // The result is different from the zero value of the Value struct,\n // which represents no value at all.\n // For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\n+// The returned value is neither addressable nor settable.\n func Zero(typ Type) Value {\n \tif typ == nil {\n \t\tpanic(\"reflect: Zero(nil)\")"}, {"sha": "e4896a1c0503ed7ea9e30f53c7dc0ccb01c0d21a", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -441,7 +441,7 @@ func (re *Regexp) ReplaceAllLiteralString(src, repl string) string {\n }\n \n // ReplaceAllStringFunc returns a copy of src in which all matches of the\n-// Regexp have been replaced by the return value of of function repl applied\n+// Regexp have been replaced by the return value of function repl applied\n // to the matched substring.  The replacement returned by repl is substituted\n // directly, without using Expand.\n func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string {\n@@ -539,7 +539,7 @@ func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte {\n }\n \n // ReplaceAllFunc returns a copy of src in which all matches of the\n-// Regexp have been replaced by the return value of of function repl applied\n+// Regexp have been replaced by the return value of function repl applied\n // to the matched byte slice.  The replacement returned by repl is substituted\n // directly, without using Expand.\n func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {\n@@ -686,8 +686,9 @@ func (re *Regexp) FindStringIndex(s string) (loc []int) {\n \n // FindReaderIndex returns a two-element slice of integers defining the\n // location of the leftmost match of the regular expression in text read from\n-// the RuneReader.  The match itself is at s[loc[0]:loc[1]].  A return\n-// value of nil indicates no match.\n+// the RuneReader.  The match text was found in the input stream at\n+// byte offset loc[0] through loc[1]-1.\n+// A return value of nil indicates no match.\n func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int) {\n \ta := re.doExecute(r, nil, \"\", 0, 2)\n \tif a == nil {"}, {"sha": "8cc15390c14403f4b91d9be47c577edaba2d4087", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -356,7 +356,7 @@ func countHeap() int {\n \treturn n\n }\n \n-// writeHeapProfile writes the current runtime heap profile to w.\n+// writeHeap writes the current runtime heap profile to w.\n func writeHeap(w io.Writer, debug int) error {\n \t// Find out how many records there are (MemProfile(nil, false)),\n \t// allocate that many records, and get the data."}, {"sha": "474011523e3751658611a408ba545ed964f063f6", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -6,6 +6,7 @@ package pprof_test\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"hash/crc32\"\n \t\"os/exec\"\n \t\"runtime\"\n@@ -49,19 +50,27 @@ func TestCPUProfile(t *testing.T) {\n \n \t// Convert []byte to []uintptr.\n \tbytes := prof.Bytes()\n+\tl := len(bytes) / int(unsafe.Sizeof(uintptr(0)))\n \tval := *(*[]uintptr)(unsafe.Pointer(&bytes))\n-\tval = val[:len(bytes)/int(unsafe.Sizeof(uintptr(0)))]\n+\tval = val[:l]\n \n-\tif len(val) < 10 {\n+\tif l < 13 {\n \t\tt.Fatalf(\"profile too short: %#x\", val)\n \t}\n-\tif val[0] != 0 || val[1] != 3 || val[2] != 0 || val[3] != 1e6/100 || val[4] != 0 {\n-\t\tt.Fatalf(\"unexpected header %#x\", val[:5])\n+\n+\tfmt.Println(val, l)\n+\thd, val, tl := val[:5], val[5:l-3], val[l-3:]\n+\tfmt.Println(hd, val, tl)\n+\tif hd[0] != 0 || hd[1] != 3 || hd[2] != 0 || hd[3] != 1e6/100 || hd[4] != 0 {\n+\t\tt.Fatalf(\"unexpected header %#x\", hd)\n+\t}\n+\n+\tif tl[0] != 0 || tl[1] != 1 || tl[2] != 0 {\n+\t\tt.Fatalf(\"malformed end-of-data marker %#x\", tl)\n \t}\n \n \t// Check that profile is well formed and contains ChecksumIEEE.\n \tfound := false\n-\tval = val[5:]\n \tfor len(val) > 0 {\n \t\tif len(val) < 2 || val[0] < 1 || val[1] < 1 || uintptr(len(val)) < 2+val[1] {\n \t\t\tt.Fatalf(\"malformed profile.  leftover: %#x\", val)"}, {"sha": "bdd5d71f875d425b2b602db8d942dcbf8b518917", "filename": "libgo/go/strconv/atoi.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fstrconv%2Fatoi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fstrconv%2Fatoi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatoi.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -44,7 +44,7 @@ func cutoff64(base int) uint64 {\n }\n \n // ParseUint is like ParseInt but for unsigned numbers.\n-func ParseUint(s string, b int, bitSize int) (n uint64, err error) {\n+func ParseUint(s string, base int, bitSize int) (n uint64, err error) {\n \tvar cutoff, maxVal uint64\n \n \tif bitSize == 0 {\n@@ -57,32 +57,32 @@ func ParseUint(s string, b int, bitSize int) (n uint64, err error) {\n \t\terr = ErrSyntax\n \t\tgoto Error\n \n-\tcase 2 <= b && b <= 36:\n+\tcase 2 <= base && base <= 36:\n \t\t// valid base; nothing to do\n \n-\tcase b == 0:\n+\tcase base == 0:\n \t\t// Look for octal, hex prefix.\n \t\tswitch {\n \t\tcase s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):\n-\t\t\tb = 16\n+\t\t\tbase = 16\n \t\t\ts = s[2:]\n \t\t\tif len(s) < 1 {\n \t\t\t\terr = ErrSyntax\n \t\t\t\tgoto Error\n \t\t\t}\n \t\tcase s[0] == '0':\n-\t\t\tb = 8\n+\t\t\tbase = 8\n \t\tdefault:\n-\t\t\tb = 10\n+\t\t\tbase = 10\n \t\t}\n \n \tdefault:\n-\t\terr = errors.New(\"invalid base \" + Itoa(b))\n+\t\terr = errors.New(\"invalid base \" + Itoa(base))\n \t\tgoto Error\n \t}\n \n \tn = 0\n-\tcutoff = cutoff64(b)\n+\tcutoff = cutoff64(base)\n \tmaxVal = 1<<uint(bitSize) - 1\n \n \tfor i := 0; i < len(s); i++ {\n@@ -100,19 +100,19 @@ func ParseUint(s string, b int, bitSize int) (n uint64, err error) {\n \t\t\terr = ErrSyntax\n \t\t\tgoto Error\n \t\t}\n-\t\tif int(v) >= b {\n+\t\tif int(v) >= base {\n \t\t\tn = 0\n \t\t\terr = ErrSyntax\n \t\t\tgoto Error\n \t\t}\n \n \t\tif n >= cutoff {\n-\t\t\t// n*b overflows\n+\t\t\t// n*base overflows\n \t\t\tn = 1<<64 - 1\n \t\t\terr = ErrRange\n \t\t\tgoto Error\n \t\t}\n-\t\tn *= uint64(b)\n+\t\tn *= uint64(base)\n \n \t\tn1 := n + uint64(v)\n \t\tif n1 < n || n1 > maxVal {"}, {"sha": "bc9e738e784ce31593574b00755a72bd9b58a6df", "filename": "libgo/go/sync/waitgroup.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -32,10 +32,11 @@ type WaitGroup struct {\n \n // Add adds delta, which may be negative, to the WaitGroup counter.\n // If the counter becomes zero, all goroutines blocked on Wait() are released.\n+// If the counter goes negative, Add panics.\n func (wg *WaitGroup) Add(delta int) {\n \tv := atomic.AddInt32(&wg.counter, int32(delta))\n \tif v < 0 {\n-\t\tpanic(\"sync: negative WaitGroup count\")\n+\t\tpanic(\"sync: negative WaitGroup counter\")\n \t}\n \tif v > 0 || atomic.LoadInt32(&wg.waiters) == 0 {\n \t\treturn"}, {"sha": "84c4cfc37a34a43bf2dc13d40263efbae5ff7789", "filename": "libgo/go/sync/waitgroup_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -50,7 +50,7 @@ func TestWaitGroup(t *testing.T) {\n func TestWaitGroupMisuse(t *testing.T) {\n \tdefer func() {\n \t\terr := recover()\n-\t\tif err != \"sync: negative WaitGroup count\" {\n+\t\tif err != \"sync: negative WaitGroup counter\" {\n \t\t\tt.Fatalf(\"Unexpected panic: %#v\", err)\n \t\t}\n \t}()"}, {"sha": "3107ae5f4158554fc3fb2dbfe373b8d3df5a075a", "filename": "libgo/go/syscall/env_windows.go", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fenv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fenv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_windows.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -12,14 +12,18 @@ import (\n )\n \n func Getenv(key string) (value string, found bool) {\n+\tkeyp, err := utf16PtrFromString(key)\n+\tif err != nil {\n+\t\treturn \"\", false\n+\t}\n \tb := make([]uint16, 100)\n-\tn, e := GetEnvironmentVariable(StringToUTF16Ptr(key), &b[0], uint32(len(b)))\n+\tn, e := GetEnvironmentVariable(keyp, &b[0], uint32(len(b)))\n \tif n == 0 && e == ERROR_ENVVAR_NOT_FOUND {\n \t\treturn \"\", false\n \t}\n \tif n > uint32(len(b)) {\n \t\tb = make([]uint16, n)\n-\t\tn, e = GetEnvironmentVariable(StringToUTF16Ptr(key), &b[0], uint32(len(b)))\n+\t\tn, e = GetEnvironmentVariable(keyp, &b[0], uint32(len(b)))\n \t\tif n > uint32(len(b)) {\n \t\t\tn = 0\n \t\t}\n@@ -32,10 +36,18 @@ func Getenv(key string) (value string, found bool) {\n \n func Setenv(key, value string) error {\n \tvar v *uint16\n+\tvar err error\n \tif len(value) > 0 {\n-\t\tv = StringToUTF16Ptr(value)\n+\t\tv, err = utf16PtrFromString(value)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tkeyp, err := utf16PtrFromString(key)\n+\tif err != nil {\n+\t\treturn err\n \t}\n-\te := SetEnvironmentVariable(StringToUTF16Ptr(key), v)\n+\te := SetEnvironmentVariable(keyp, v)\n \tif e != nil {\n \t\treturn e\n \t}"}, {"sha": "b34ee1bf8821d9b3a9c62be5a4a3dd5a35be321f", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -103,8 +103,9 @@ import (\n \n var ForkLock sync.RWMutex\n \n-// Convert array of string to array\n-// of NUL-terminated byte pointer.\n+// Convert array of string to array of NUL-terminated byte pointer.\n+// If any string contains a NUL byte this function panics instead\n+// of returning an error.\n func StringSlicePtr(ss []string) []*byte {\n \tbb := make([]*byte, len(ss)+1)\n \tfor i := 0; i < len(ss); i++ {\n@@ -114,6 +115,22 @@ func StringSlicePtr(ss []string) []*byte {\n \treturn bb\n }\n \n+// slicePtrFromStrings converts a slice of strings to a slice of\n+// pointers to NUL-terminated byte slices. If any string contains\n+// a NUL byte, it returns (nil, EINVAL).\n+func slicePtrFromStrings(ss []string) ([]*byte, error) {\n+\tvar err error\n+\tbb := make([]*byte, len(ss)+1)\n+\tfor i := 0; i < len(ss); i++ {\n+\t\tbb[i], err = bytePtrFromString(ss[i])\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tbb[len(ss)] = nil\n+\treturn bb, nil\n+}\n+\n func CloseOnExec(fd int) { fcntl(fd, F_SETFD, FD_CLOEXEC) }\n \n func SetNonblock(fd int, nonblocking bool) (err error) {\n@@ -168,21 +185,36 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)\n \tp[1] = -1\n \n \t// Convert args to C form.\n-\targv0p := StringBytePtr(argv0)\n-\targvp := StringSlicePtr(argv)\n-\tenvvp := StringSlicePtr(attr.Env)\n+\targv0p, err := bytePtrFromString(argv0)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\targvp, err := slicePtrFromStrings(argv)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\tenvvp, err := slicePtrFromStrings(attr.Env)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n \n \tif runtime.GOOS == \"freebsd\" && len(argv[0]) > len(argv0) {\n \t\targvp[0] = argv0p\n \t}\n \n \tvar chroot *byte\n \tif sys.Chroot != \"\" {\n-\t\tchroot = StringBytePtr(sys.Chroot)\n+\t\tchroot, err = bytePtrFromString(sys.Chroot)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n \t}\n \tvar dir *byte\n \tif attr.Dir != \"\" {\n-\t\tdir = StringBytePtr(attr.Dir)\n+\t\tdir, err = bytePtrFromString(attr.Dir)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n \t}\n \n \t// Acquire the fork lock so that no other threads\n@@ -254,8 +286,18 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle\n \n // Ordinary exec.\n func Exec(argv0 string, argv []string, envv []string) (err error) {\n-\terr1 := raw_execve(StringBytePtr(argv0),\n-\t\t&StringSlicePtr(argv)[0],\n-\t\t&StringSlicePtr(envv)[0])\n+\targv0p, err := bytePtrFromString(argv0)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\targvp, err := slicePtrFromStrings(argv)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tenvvp, err := slicePtrFromStrings(envv)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr1 := raw_execve(argv0p, &argvp[0], &envvp[0])\n \treturn Errno(err1)\n }"}, {"sha": "68779c461a02420de416b41fa20fbcefd18f2cf3", "filename": "libgo/go/syscall/exec_windows.go", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_windows.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -132,7 +132,10 @@ func SetNonblock(fd Handle, nonblocking bool) (err error) {\n // getFullPath retrieves the full path of the specified file.\n // Just a wrapper for Windows GetFullPathName api.\n func getFullPath(name string) (path string, err error) {\n-\tp := StringToUTF16Ptr(name)\n+\tp, err := utf16PtrFromString(name)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n \tbuf := make([]uint16, 100)\n \tn, err := GetFullPathName(p, uint32(len(buf)), &buf[0], nil)\n \tif err != nil {\n@@ -261,7 +264,10 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle\n \t\t\treturn 0, 0, err\n \t\t}\n \t}\n-\targv0p := StringToUTF16Ptr(argv0)\n+\targv0p, err := utf16PtrFromString(argv0)\n+\tif err != nil {\n+\t\treturn 0, 0, err\n+\t}\n \n \tvar cmdline string\n \t// Windows CreateProcess takes the command line as a single string:\n@@ -275,12 +281,18 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle\n \n \tvar argvp *uint16\n \tif len(cmdline) != 0 {\n-\t\targvp = StringToUTF16Ptr(cmdline)\n+\t\targvp, err = utf16PtrFromString(cmdline)\n+\t\tif err != nil {\n+\t\t\treturn 0, 0, err\n+\t\t}\n \t}\n \n \tvar dirp *uint16\n \tif len(attr.Dir) != 0 {\n-\t\tdirp = StringToUTF16Ptr(attr.Dir)\n+\t\tdirp, err = utf16PtrFromString(attr.Dir)\n+\t\tif err != nil {\n+\t\t\treturn 0, 0, err\n+\t\t}\n \t}\n \n \t// Acquire the fork lock so that no other threads"}, {"sha": "4353af4fb909f215bfceb9fabda870afb2722642", "filename": "libgo/go/syscall/security_windows.go", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -37,10 +37,13 @@ const (\n // TranslateAccountName converts a directory service\n // object name from one format to another.\n func TranslateAccountName(username string, from, to uint32, initSize int) (string, error) {\n-\tu := StringToUTF16Ptr(username)\n+\tu, e := utf16PtrFromString(username)\n+\tif e != nil {\n+\t\treturn \"\", e\n+\t}\n \tb := make([]uint16, 50)\n \tn := uint32(len(b))\n-\te := TranslateName(u, from, to, &b[0], &n)\n+\te = TranslateName(u, from, to, &b[0], &n)\n \tif e != nil {\n \t\tif e != ERROR_INSUFFICIENT_BUFFER {\n \t\t\treturn \"\", e\n@@ -94,7 +97,11 @@ type SID struct{}\n // sid into a valid, functional sid.\n func StringToSid(s string) (*SID, error) {\n \tvar sid *SID\n-\te := ConvertStringSidToSid(StringToUTF16Ptr(s), &sid)\n+\tp, e := utf16PtrFromString(s)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\te = ConvertStringSidToSid(p, &sid)\n \tif e != nil {\n \t\treturn nil, e\n \t}\n@@ -109,17 +116,23 @@ func LookupSID(system, account string) (sid *SID, domain string, accType uint32,\n \tif len(account) == 0 {\n \t\treturn nil, \"\", 0, EINVAL\n \t}\n-\tacc := StringToUTF16Ptr(account)\n+\tacc, e := utf16PtrFromString(account)\n+\tif e != nil {\n+\t\treturn nil, \"\", 0, e\n+\t}\n \tvar sys *uint16\n \tif len(system) > 0 {\n-\t\tsys = StringToUTF16Ptr(system)\n+\t\tsys, e = utf16PtrFromString(system)\n+\t\tif e != nil {\n+\t\t\treturn nil, \"\", 0, e\n+\t\t}\n \t}\n \tdb := make([]uint16, 50)\n \tdn := uint32(len(db))\n \tb := make([]byte, 50)\n \tn := uint32(len(b))\n \tsid = (*SID)(unsafe.Pointer(&b[0]))\n-\te := LookupAccountName(sys, acc, sid, &n, &db[0], &dn, &accType)\n+\te = LookupAccountName(sys, acc, sid, &n, &db[0], &dn, &accType)\n \tif e != nil {\n \t\tif e != ERROR_INSUFFICIENT_BUFFER {\n \t\t\treturn nil, \"\", 0, e\n@@ -170,7 +183,10 @@ func (sid *SID) Copy() (*SID, error) {\n func (sid *SID) LookupAccount(system string) (account, domain string, accType uint32, err error) {\n \tvar sys *uint16\n \tif len(system) > 0 {\n-\t\tsys = StringToUTF16Ptr(system)\n+\t\tsys, err = utf16PtrFromString(system)\n+\t\tif err != nil {\n+\t\t\treturn \"\", \"\", 0, err\n+\t\t}\n \t}\n \tb := make([]uint16, 50)\n \tn := uint32(len(b))"}, {"sha": "3090a5ec6971e5b313bd92a008e2b1b8ae400fc0", "filename": "libgo/go/syscall/syscall.go", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -16,18 +16,47 @@ package syscall\n \n import \"unsafe\"\n \n-// StringByteSlice returns a NUL-terminated slice of bytes\n-// containing the text of s.\n+// StringByteSlice returns a NUL-terminated slice of bytes containing the text of s.\n+// If s contains a NUL byte this function panics instead of\n+// returning an error.\n func StringByteSlice(s string) []byte {\n+\ta, err := byteSliceFromString(s)\n+\tif err != nil {\n+\t\tpanic(\"syscall: string with NUL passed to StringByteSlice\")\n+\t}\n+\treturn a\n+}\n+\n+// byteSliceFromString returns a NUL-terminated slice of bytes\n+// containing the text of s. If s contains a NUL byte at any\n+// location, it returns (nil, EINVAL).\n+func byteSliceFromString(s string) ([]byte, error) {\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == 0 {\n+\t\t\treturn nil, EINVAL\n+\t\t}\n+\t}\n \ta := make([]byte, len(s)+1)\n \tcopy(a, s)\n-\treturn a\n+\treturn a, nil\n }\n \n-// StringBytePtr returns a pointer to a NUL-terminated array of bytes\n-// containing the text of s.\n+// StringBytePtr returns a pointer to a NUL-terminated array of bytes containing the text of s.\n+// If s contains a NUL byte this function panics instead of\n+// returning an error.\n func StringBytePtr(s string) *byte { return &StringByteSlice(s)[0] }\n \n+// bytePtrFromString returns a pointer to a NUL-terminated array of\n+// bytes containing the text of s. If s contains a NUL byte at any\n+// location, it returns (nil, EINVAL).\n+func bytePtrFromString(s string) (*byte, error) {\n+\ta, err := byteSliceFromString(s)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &a[0], nil\n+}\n+\n // Single-word zero for use when we need a valid pointer to 0 bytes.\n // See mksyscall.pl.\n var _zero uintptr"}, {"sha": "08422def37591c499b05b5fbbf9d0e31b6ea3a25", "filename": "libgo/go/syscall/syscall_linux_386.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_386.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -8,13 +8,9 @@ package syscall\n \n import \"unsafe\"\n \n-func (r *PtraceRegs) PC() uint64 {\n-\treturn uint64(uint32(r.Eip))\n-}\n+func (r *PtraceRegs) PC() uint64 { return uint64(uint32(r.Eip)) }\n \n-func (r *PtraceRegs) SetPC(pc uint64) {\n-\tr.Eip = int32(pc)\n-}\n+func (r *PtraceRegs) SetPC(pc uint64) { r.Eip = int32(pc) }\n \n func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {\n \treturn ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))"}, {"sha": "e56b77c9c7778249560733d605020ea5e8f4f5e1", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -79,13 +79,15 @@\n package testing\n \n import (\n+\t\"bytes\"\n \t\"flag\"\n \t\"fmt\"\n \t\"os\"\n \t\"runtime\"\n \t\"runtime/pprof\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"sync\"\n \t\"time\"\n )\n \n@@ -115,8 +117,10 @@ var (\n // common holds the elements common between T and B and\n // captures common methods such as Errorf.\n type common struct {\n-\toutput   []byte    // Output generated by test or benchmark.\n-\tfailed   bool      // Test or benchmark has failed.\n+\tmu     sync.RWMutex // guards output and failed\n+\toutput []byte       // Output generated by test or benchmark.\n+\tfailed bool         // Test or benchmark has failed.\n+\n \tstart    time.Time // Time test or benchmark started\n \tduration time.Duration\n \tself     interface{}      // To be sent on signal channel when done.\n@@ -128,37 +132,42 @@ func Short() bool {\n \treturn *short\n }\n \n-// decorate inserts the final newline if needed and indentation tabs for formatting.\n-// If addFileLine is true, it also prefixes the string with the file and line of the call site.\n-func decorate(s string, addFileLine bool) string {\n-\tif addFileLine {\n-\t\t_, file, line, ok := runtime.Caller(3) // decorate + log + public function.\n-\t\tif ok {\n-\t\t\t// Truncate file name at last file name separator.\n-\t\t\tif index := strings.LastIndex(file, \"/\"); index >= 0 {\n-\t\t\t\tfile = file[index+1:]\n-\t\t\t} else if index = strings.LastIndex(file, \"\\\\\"); index >= 0 {\n-\t\t\t\tfile = file[index+1:]\n-\t\t\t}\n-\t\t} else {\n-\t\t\tfile = \"???\"\n-\t\t\tline = 1\n+// decorate prefixes the string with the file and line of the call site\n+// and inserts the final newline if needed and indentation tabs for formatting.\n+func decorate(s string) string {\n+\t_, file, line, ok := runtime.Caller(3) // decorate + log + public function.\n+\tif ok {\n+\t\t// Truncate file name at last file name separator.\n+\t\tif index := strings.LastIndex(file, \"/\"); index >= 0 {\n+\t\t\tfile = file[index+1:]\n+\t\t} else if index = strings.LastIndex(file, \"\\\\\"); index >= 0 {\n+\t\t\tfile = file[index+1:]\n \t\t}\n-\t\ts = fmt.Sprintf(\"%s:%d: %s\", file, line, s)\n-\t}\n-\ts = \"\\t\" + s // Every line is indented at least one tab.\n-\tn := len(s)\n-\tif n > 0 && s[n-1] != '\\n' {\n-\t\ts += \"\\n\"\n-\t\tn++\n+\t} else {\n+\t\tfile = \"???\"\n+\t\tline = 1\n \t}\n-\tfor i := 0; i < n-1; i++ { // -1 to avoid final newline\n-\t\tif s[i] == '\\n' {\n+\tbuf := new(bytes.Buffer)\n+\tfmt.Fprintf(buf, \"%s:%d: \", file, line)\n+\n+\tlines := strings.Split(s, \"\\n\")\n+\tfor i, line := range lines {\n+\t\tif i > 0 {\n+\t\t\tbuf.WriteByte('\\n')\n+\t\t}\n+\t\t// Every line is indented at least one tab.\n+\t\tbuf.WriteByte('\\t')\n+\t\tif i > 0 {\n \t\t\t// Second and subsequent lines are indented an extra tab.\n-\t\t\treturn s[0:i+1] + \"\\t\" + decorate(s[i+1:n], false)\n+\t\t\tbuf.WriteByte('\\t')\n \t\t}\n+\t\tbuf.WriteString(line)\n+\t}\n+\tif l := len(s); l > 0 && s[len(s)-1] != '\\n' {\n+\t\t// Add final new line if needed.\n+\t\tbuf.WriteByte('\\n')\n \t}\n-\treturn s\n+\treturn buf.String()\n }\n \n // T is a type passed to Test functions to manage test state and support formatted test logs.\n@@ -170,10 +179,18 @@ type T struct {\n }\n \n // Fail marks the function as having failed but continues execution.\n-func (c *common) Fail() { c.failed = true }\n+func (c *common) Fail() {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.failed = true\n+}\n \n // Failed returns whether the function has failed.\n-func (c *common) Failed() bool { return c.failed }\n+func (c *common) Failed() bool {\n+\tc.mu.RLock()\n+\tdefer c.mu.RUnlock()\n+\treturn c.failed\n+}\n \n // FailNow marks the function as having failed and stops its execution.\n // Execution will continue at the next test or benchmark.\n@@ -204,7 +221,9 @@ func (c *common) FailNow() {\n \n // log generates the output. It's always at the same stack depth.\n func (c *common) log(s string) {\n-\tc.output = append(c.output, decorate(s, true)...)\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\tc.output = append(c.output, decorate(s)...)\n }\n \n // Log formats its arguments using default formatting, analogous to Println(),\n@@ -297,7 +316,7 @@ func Main(matchString func(pat, str string) (bool, error), tests []InternalTest,\n func (t *T) report() {\n \ttstr := fmt.Sprintf(\"(%.2f seconds)\", t.duration.Seconds())\n \tformat := \"--- %s: %s %s\\n%s\"\n-\tif t.failed {\n+\tif t.Failed() {\n \t\tfmt.Printf(format, \"FAIL\", t.name, tstr, t.output)\n \t} else if *chatty {\n \t\tfmt.Printf(format, \"PASS\", t.name, tstr, t.output)\n@@ -356,7 +375,7 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tt.report()\n-\t\t\tok = ok && !out.failed\n+\t\t\tok = ok && !out.Failed()\n \t\t}\n \n \t\trunning := 0\n@@ -369,7 +388,7 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\t\t}\n \t\t\tt := (<-collector).(*T)\n \t\t\tt.report()\n-\t\t\tok = ok && !t.failed\n+\t\t\tok = ok && !t.Failed()\n \t\t\trunning--\n \t\t}\n \t}"}, {"sha": "722ac8d877a7fecb5ce30ddc7088137daafc3809", "filename": "libgo/go/text/tabwriter/tabwriter.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -547,7 +547,7 @@ func (b *Writer) Write(buf []byte) (n int, err error) {\n }\n \n // NewWriter allocates and initializes a new tabwriter.Writer.\n-// The parameters are the same as for the the Init function.\n+// The parameters are the same as for the Init function.\n //\n func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer {\n \treturn new(Writer).Init(output, minwidth, tabwidth, padding, padchar, flags)"}, {"sha": "4a1682d97a347a184ef44ae7cb5e3eabca9d912e", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -198,7 +198,7 @@ If a \"range\" action initializes a variable, the variable is set to the\n successive elements of the iteration.  Also, a \"range\" may declare two\n variables, separated by a comma:\n \n-\t$index, $element := pipeline\n+\trange $index, $element := pipeline\n \n in which case $index and $element are set to the successive values of the\n array/slice index or map key and element, respectively.  Note that if there is"}, {"sha": "64149533b3e9939f90ee83cc778ef285ec3962e1", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -387,7 +387,7 @@ var execTests = []execTest{\n \t{\"slice[WRONG]\", \"{{index .SI `hello`}}\", \"\", tVal, false},\n \t{\"map[one]\", \"{{index .MSI `one`}}\", \"1\", tVal, true},\n \t{\"map[two]\", \"{{index .MSI `two`}}\", \"2\", tVal, true},\n-\t{\"map[NO]\", \"{{index .MSI `XXX`}}\", \"\", tVal, true},\n+\t{\"map[NO]\", \"{{index .MSI `XXX`}}\", \"0\", tVal, true},\n \t{\"map[WRONG]\", \"{{index .MSI 10}}\", \"\", tVal, false},\n \t{\"double index\", \"{{index .SMSI 1 `eleven`}}\", \"11\", tVal, true},\n "}, {"sha": "e6fa0fb5f2a24f00836c15ef697fb2beef147dbf", "filename": "libgo/go/text/template/funcs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -128,7 +128,7 @@ func index(item interface{}, indices ...interface{}) (interface{}, error) {\n \t\t\tif x := v.MapIndex(index); x.IsValid() {\n \t\t\t\tv = x\n \t\t\t} else {\n-\t\t\t\tv = reflect.Zero(v.Type().Key())\n+\t\t\t\tv = reflect.Zero(v.Type().Elem())\n \t\t\t}\n \t\tdefault:\n \t\t\treturn nil, fmt.Errorf(\"can't index item of type %s\", index.Type())\n@@ -154,7 +154,7 @@ func length(item interface{}) (int, error) {\n \n // Function invocation\n \n-// call returns the result of evaluating the the first argument as a function.\n+// call returns the result of evaluating the first argument as a function.\n // The function must return 1 result, or 2 results, the second of which is an error.\n func call(fn interface{}, args ...interface{}) (interface{}, error) {\n \tv := reflect.ValueOf(fn)"}, {"sha": "c4e1a56a8d41789fb46cc997f187011a3ebf1855", "filename": "libgo/go/text/template/parse/lex.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -257,16 +257,17 @@ func lexText(l *lexer) stateFn {\n \n // lexLeftDelim scans the left delimiter, which is known to be present.\n func lexLeftDelim(l *lexer) stateFn {\n-\tif strings.HasPrefix(l.input[l.pos:], l.leftDelim+leftComment) {\n+\tl.pos += len(l.leftDelim)\n+\tif strings.HasPrefix(l.input[l.pos:], leftComment) {\n \t\treturn lexComment\n \t}\n-\tl.pos += len(l.leftDelim)\n \tl.emit(itemLeftDelim)\n \treturn lexInsideAction\n }\n \n // lexComment scans a comment. The left comment marker is known to be present.\n func lexComment(l *lexer) stateFn {\n+\tl.pos += len(leftComment)\n \ti := strings.Index(l.input[l.pos:], rightComment+l.rightDelim)\n \tif i < 0 {\n \t\treturn l.errorf(\"unclosed comment\")"}, {"sha": "f3b23c91e43a7384547d94b21e0f6a777790cc41", "filename": "libgo/go/text/template/parse/lex_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex_test.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -198,6 +198,10 @@ var lexTests = []lexTest{\n \t\ttRight,\n \t\ttEOF,\n \t}},\n+\t{\"text with bad comment\", \"hello-{{/*/}}-world\", []item{\n+\t\t{itemText, \"hello-\"},\n+\t\t{itemError, `unclosed comment`},\n+\t}},\n }\n \n // collect gathers the emitted items into a slice."}, {"sha": "d48ca0c269e0815ab7e984f133f1b76be4c44265", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -241,10 +241,10 @@ func (t Time) IsZero() bool {\n // It is called when computing a presentation property like Month or Hour.\n func (t Time) abs() uint64 {\n \tl := t.loc\n-\tif l == nil {\n-\t\tl = &utcLoc\n+\t// Avoid function calls when possible.\n+\tif l == nil || l == &localLoc {\n+\t\tl = l.get()\n \t}\n-\t// Avoid function call if we hit the local time cache.\n \tsec := t.sec + internalToUnix\n \tif l != &utcLoc {\n \t\tif l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {"}, {"sha": "1e389a218de04c70097ecf0e654dd275bb8943b4", "filename": "libgo/runtime/chan.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fchan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fchan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.c?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -87,7 +87,7 @@ runtime_makechan_c(ChanType *t, int64 hint)\n \tHchan *c;\n \tint32 n;\n \tconst Type *elem;\n-\t\n+\n \telem = t->__element_type;\n \n \tif(hint < 0 || (int32)hint != hint || (elem->__size > 0 && (uintptr)hint > MaxMem / elem->__size))\n@@ -191,7 +191,7 @@ runtime_chansend(ChanType *t, Hchan *c, byte *ep, bool *pres)\n \tsg = dequeue(&c->recvq);\n \tif(sg != nil) {\n \t\truntime_unlock(c);\n-\t\t\n+\n \t\tgp = sg->g;\n \t\tgp->param = sg;\n \t\tif(sg->elem != nil)\n@@ -530,7 +530,7 @@ runtime_selectnbrecv(ChanType *t, byte *v, Hchan *c)\n \n \truntime_chanrecv(t, c, v, &selected, nil);\n \treturn selected;\n-}\t\n+}\n \n // func selectnbrecv2(elem *any, ok *bool, c chan any) bool\n //\n@@ -562,7 +562,7 @@ runtime_selectnbrecv2(ChanType *t, byte *v, _Bool *received, Hchan *c)\n \tif(received != nil)\n \t\t*received = r;\n \treturn selected;\n-}\t\n+}\n \n // For reflect:\n //\tfunc chansend(c chan, val iword, nb bool) (selected bool)\n@@ -578,7 +578,7 @@ reflect_chansend(ChanType *t, Hchan *c, uintptr val, _Bool nb)\n \tbool selected;\n \tbool *sp;\n \tbyte *vp;\n-\t\n+\n \tif(nb) {\n \t\tselected = false;\n \t\tsp = (bool*)&selected;\n@@ -697,7 +697,7 @@ runtime_selectsend(Select *sel, Hchan *c, void *elem, int index)\n \t// nil cases do not compete\n \tif(c == nil)\n \t\treturn;\n-\t\n+\n \tselectsend(sel, c, index, elem);\n }\n \n@@ -706,7 +706,7 @@ selectsend(Select *sel, Hchan *c, int index, void *elem)\n {\n \tint32 i;\n \tScase *cas;\n-\t\n+\n \ti = sel->ncase;\n \tif(i >= sel->tcase)\n \t\truntime_throw(\"selectsend: too many cases\");\n@@ -977,7 +977,7 @@ selectgo(Select **selp)\n \t\tcase CaseRecv:\n \t\t\tenqueue(&c->recvq, sg);\n \t\t\tbreak;\n-\t\t\n+\n \t\tcase CaseSend:\n \t\t\tenqueue(&c->sendq, sg);\n \t\t\tbreak;"}, {"sha": "9bf5d11e687f6c770ef769aa7e416be6ffa369f3", "filename": "libgo/runtime/cpuprof.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fcpuprof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fcpuprof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fcpuprof.c?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -105,6 +105,7 @@ struct Profile {\n \tuint32 wtoggle;\n \tbool wholding;\t// holding & need to release a log half\n \tbool flushing;\t// flushing hash table - profile is over\n+\tbool eod_sent;  // special end-of-data record sent; => flushing\n };\n \n static Lock lk;\n@@ -115,6 +116,8 @@ static void add(Profile*, uintptr*, int32);\n static bool evict(Profile*, Entry*);\n static bool flushlog(Profile*);\n \n+static uintptr eod[3] = {0, 1, 0};\n+\n // LostProfileData is a no-op function used in profiles\n // to mark the number of profiling stack traces that were\n // discarded due to slow data writers.\n@@ -168,6 +171,7 @@ runtime_SetCPUProfileRate(int32 hz)\n \t\tprof->wholding = false;\n \t\tprof->wtoggle = 0;\n \t\tprof->flushing = false;\n+\t\tprof->eod_sent = false;\n \t\truntime_noteclear(&prof->wait);\n \n \t\truntime_setcpuprofilerate(tick, hz);\n@@ -414,6 +418,16 @@ getprofile(Profile *p)\n \t}\n \n \t// Made it through the table without finding anything to log.\n+\tif(!p->eod_sent) {\n+\t\t// We may not have space to append this to the partial log buf,\n+\t\t// so we always return a new slice for the end-of-data marker.\n+\t\tp->eod_sent = true;\n+\t\tret.array = (byte*)eod;\n+\t\tret.len = sizeof eod;\n+\t\tret.cap = ret.len;\n+\t\treturn ret;\n+\t}\n+\n \t// Finally done.  Clean up and return nil.\n \tp->flushing = false;\n \tif(!runtime_cas(&p->handoff, p->handoff, 0))"}, {"sha": "5a8e47e5373c199f5e6c5aa29536a188376ecfcb", "filename": "libgo/runtime/print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fprint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fprint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fprint.c?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -20,10 +20,10 @@ gwrite(const void *v, int32 n)\n \t\truntime_write(2, v, n);\n \t\treturn;\n \t}\n-\t\n+\n \tif(g->writenbuf == 0)\n \t\treturn;\n-\t\n+\n \tif(n > g->writenbuf)\n \t\tn = g->writenbuf;\n \truntime_memmove(g->writebuf, v, n);"}, {"sha": "e0a7925aed1157758d0e14760817be6a36e6da36", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2e46c8255fad4e75e589b3286ead560e910b39/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=bd2e46c8255fad4e75e589b3286ead560e910b39", "patch": "@@ -106,11 +106,15 @@ static byte**\targv;\n extern Slice os_Args asm (\"os.Args\");\n extern Slice syscall_Envs asm (\"syscall.Envs\");\n \n+void (*runtime_sysargs)(int32, uint8**);\n+\n void\n runtime_args(int32 c, byte **v)\n {\n \targc = c;\n \targv = v;\n+\tif(runtime_sysargs != nil)\n+\t\truntime_sysargs(c, v);\n }\n \n void\n@@ -234,7 +238,7 @@ runtime_showframe(const unsigned char *s)\n \t\n \tif(traceback < 0)\n \t\ttraceback = runtime_gotraceback();\n-\treturn traceback > 1 || (__builtin_strchr((const char*)s, '.') != nil && __builtin_memcmp(s, \"runtime.\", 7) != 0);\n+\treturn traceback > 1 || (s != nil && __builtin_strchr((const char*)s, '.') != nil && __builtin_memcmp(s, \"runtime.\", 7) != 0);\n }\n \n bool"}]}