{"sha": "e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFlNGNkYzQyYzhiMjgyMzVhYjYzN2RjNWRmMmI0ZWYxNTljNWI5OA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-20T03:46:09Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-20T03:46:09Z"}, "message": "collect2.c (main, [...]): Fix for -Wc++-compat.\n\n\t* collect2.c (main, add_to_list): Fix for -Wc++-compat.\n\t* gcc.c (translate_options, init_spec, store_arg, read_specs,\n\tadd_to_obstack, file_at_path, find_a_file, execute,\n\tadd_preprocessor_option, add_assembler_option, add_linker_option,\n\tprocess_command, insert_wrapper, do_option_spec, do_self_spec,\n\tspec_path, do_spec_1, is_directory, main, used_arg,\n\tgetenv_spec_function): Likewise.\n\t* tlink.c (symbol_hash_lookup, file_hash_lookup,\n\tdemangled_hash_lookup, symbol_push, file_push, frob_extension):\n\tLikewise.\n\t\njava:\n\t* class.c (ident_subst, mangled_classname, unmangle_classname,\n\tgen_indirect_dispatch_tables, add_method_1,\n\tbuild_fieldref_cache_entry, make_local_function_alias,\n\tlayout_class, java_treetreehash_find, java_treetreehash_new,\n\tsplit_qualified_name): Fix for -Wc++-compat.\n\t* constants.c (set_constant_entry, cpool_for_class): Likewise.\n\t* decl.c (make_binding_level, java_dup_lang_specific_decl,\n\tstart_java_method): Likewise.\n\t* except.c (prepare_eh_table_type): Likewise.\n\t* expr.c (type_assertion_hash, note_instructions): Likewise.\n\t* java-tree.h (MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC,\n\tMAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC): Likewise.\n\t* jcf-io.c (jcf_filbuf_from_stdio, opendir_in_zip, find_class):\n\tLikewise.\n\t* jcf-parse.c (reverse, java_read_sourcefilenames,\n\tannotation_grow, rewrite_reflection_indexes, java_parse_file,\n\tprocess_zip_dir): Likewise.\n\t* jcf-path.c (add_entry, add_path, jcf_path_init,\n\tjcf_path_extdirs_arg): Likewise.\n\t* jcf-reader.c (jcf_parse_constant_pool): Likewise.\n\t* jvgenmain.c (do_mangle_classname): Likewise.\n\t* lang.c (put_decl_string): Likewise.\n\t* verify-impl.c (make_state_copy, make_state, add_new_state):\n\tLikewise.\n\nobjc:\n\t* objc-act.c (setup_string_decl, objc_build_string_object,\n\thash_interface, eq_interface, objc_begin_try_stmt,\n\tencode_method_prototype, build_ivar_list_initializer,\n\tobjc_build_encode_expr): Fix for -Wc++-compat.\n\nFrom-SVN: r136980", "tree": {"sha": "a9a495581b5ae5ebeabcad170ec8ae93f77566c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9a495581b5ae5ebeabcad170ec8ae93f77566c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/comments", "author": null, "committer": null, "parents": [{"sha": "54e998b2f10c2f2f4fcbf9f40ebcb926ac125d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e998b2f10c2f2f4fcbf9f40ebcb926ac125d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e998b2f10c2f2f4fcbf9f40ebcb926ac125d33"}], "stats": {"total": 287, "additions": 165, "deletions": 122}, "files": [{"sha": "f36890c7895410d70c51bb63cce079f535b21858", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -1,3 +1,16 @@\n+2008-06-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* collect2.c (main, add_to_list): Fix for -Wc++-compat.\n+\t* gcc.c (translate_options, init_spec, store_arg, read_specs,\n+\tadd_to_obstack, file_at_path, find_a_file, execute,\n+\tadd_preprocessor_option, add_assembler_option, add_linker_option,\n+\tprocess_command, insert_wrapper, do_option_spec, do_self_spec,\n+\tspec_path, do_spec_1, is_directory, main, used_arg,\n+\tgetenv_spec_function): Likewise.\n+\t* tlink.c (symbol_hash_lookup, file_hash_lookup,\n+\tdemangled_hash_lookup, symbol_push, file_push, frob_extension):\n+\tLikewise.\n+\n 2008-06-19  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \t* doc/rtl.texi: Updated subreg section."}, {"sha": "dbd580606d43c08a44af41549635787e5cf3a267", "filename": "gcc/collect2.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -846,9 +846,9 @@ main (int argc, char **argv)\n   /* Do not invoke xcalloc before this point, since locale needs to be\n      set first, in case a diagnostic is issued.  */\n \n-  ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+4));\n-  ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+11));\n-  object = (const char **)(object_lst = xcalloc(sizeof (char *), argc));\n+  ld1 = (const char **)(ld1_argv = XCNEWVEC (char *, argc+4));\n+  ld2 = (const char **)(ld2_argv = XCNEWVEC (char *, argc+11));\n+  object = (const char **)(object_lst = XCNEWVEC (char *, argc));\n \n #ifdef DEBUG\n   debug = 1;\n@@ -875,7 +875,7 @@ main (int argc, char **argv)\n #endif\n \n   obstack_begin (&temporary_obstack, 0);\n-  temporary_firstobj = obstack_alloc (&temporary_obstack, 0);\n+  temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n \n #ifndef HAVE_LD_DEMANGLE\n   current_demangling_style = auto_demangling;\n@@ -893,7 +893,7 @@ main (int argc, char **argv)\n      -fno-exceptions -w */\n   num_c_args += 5;\n \n-  c_ptr = (const char **) (c_argv = xcalloc (sizeof (char *), num_c_args));\n+  c_ptr = (const char **) (c_argv = XCNEWVEC (char *, num_c_args));\n \n   if (argc < 2)\n     fatal (\"no arguments\");\n@@ -1676,7 +1676,8 @@ static long sequence_number = 0;\n static void\n add_to_list (struct head *head_ptr, const char *name)\n {\n-  struct id *newid = xcalloc (sizeof (struct id) + strlen (name), 1);\n+  struct id *newid\n+    = (struct id *) xcalloc (sizeof (struct id) + strlen (name), 1);\n   struct id *p;\n   strcpy (newid->name, name);\n "}, {"sha": "7c23b98e12f3102a0ac0938e10507c2aaa29bbd5", "filename": "gcc/gcc.c", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -1212,7 +1212,7 @@ translate_options (int *argcp, const char *const **argvp)\n   int argc = *argcp;\n   const char *const *argv = *argvp;\n   int newvsize = (argc + 2) * 2 * sizeof (const char *);\n-  const char **newv = xmalloc (newvsize);\n+  const char **newv = XNEWVAR (const char *, newvsize);\n   int newindex = 0;\n \n   i = 0;\n@@ -1716,8 +1716,7 @@ init_spec (void)\n     notice (\"Using built-in specs.\\n\");\n \n #ifdef EXTRA_SPECS\n-  extra_specs = xcalloc (sizeof (struct spec_list),\n-\t\t\t ARRAY_SIZE (extra_specs_1));\n+  extra_specs = XCNEWVEC (struct spec_list, ARRAY_SIZE (extra_specs_1));\n \n   for (i = ARRAY_SIZE (extra_specs_1) - 1; i >= 0; i--)\n     {\n@@ -1980,7 +1979,7 @@ static void\n store_arg (const char *arg, int delete_always, int delete_failure)\n {\n   if (argbuf_index + 1 == argbuf_length)\n-    argbuf = xrealloc (argbuf, (argbuf_length *= 2) * sizeof (const char *));\n+    argbuf = XRESIZEVEC (const char *, argbuf, (argbuf_length *= 2));\n \n   argbuf[argbuf_index++] = arg;\n   argbuf[argbuf_index] = 0;\n@@ -2272,8 +2271,7 @@ read_specs (const char *filename, int main_p)\n \t{\n \t  /* Add this pair to the vector.  */\n \t  compilers\n-\t    = xrealloc (compilers,\n-\t\t\t(n_compilers + 2) * sizeof (struct compiler));\n+\t    = XRESIZEVEC (struct compiler, compilers, n_compilers + 2);\n \n \t  compilers[n_compilers].suffix = suffix;\n \t  compilers[n_compilers].spec = spec;\n@@ -2594,7 +2592,7 @@ struct add_to_obstack_info {\n static void *\n add_to_obstack (char *path, void *data)\n {\n-  struct add_to_obstack_info *info = data;\n+  struct add_to_obstack_info *info = (struct add_to_obstack_info *) data;\n \n   if (info->check_dir && !is_directory (path, false))\n     return NULL;\n@@ -2688,7 +2686,7 @@ struct file_at_path_info {\n static void *\n file_at_path (char *path, void *data)\n {\n-  struct file_at_path_info *info = data;\n+  struct file_at_path_info *info = (struct file_at_path_info *) data;\n   size_t len = strlen (path);\n \n   memcpy (path + len, info->name, info->name_len);\n@@ -2747,8 +2745,9 @@ find_a_file (const struct path_prefix *pprefix, const char *name, int mode,\n   info.suffix_len = strlen (info.suffix);\n   info.mode = mode;\n \n-  return for_each_path (pprefix, do_multi, info.name_len + info.suffix_len,\n-\t\t\tfile_at_path, &info);\n+  return (char*) for_each_path (pprefix, do_multi,\n+\t\t\t\tinfo.name_len + info.suffix_len,\n+\t\t\t\tfile_at_path, &info);\n }\n \n /* Ranking of prefixes in the sort list. -B prefixes are put before\n@@ -2867,7 +2866,7 @@ execute (void)\n       n_commands++;\n \n   /* Get storage for each command.  */\n-  commands = alloca (n_commands * sizeof (struct command));\n+  commands = (struct command *) alloca (n_commands * sizeof (struct command));\n \n   /* Split argbuf into its separate piped processes,\n      and record info about each one.\n@@ -3029,13 +3028,13 @@ execute (void)\n     struct pex_time *times = NULL;\n     int ret_code = 0;\n \n-    statuses = alloca (n_commands * sizeof (int));\n+    statuses = (int *) alloca (n_commands * sizeof (int));\n     if (!pex_get_status (pex, n_commands, statuses))\n       pfatal_with_name (_(\"failed to get exit status\"));\n \n     if (report_times)\n       {\n-\ttimes = alloca (n_commands * sizeof (struct pex_time));\n+\ttimes = (struct pex_time *) alloca (n_commands * sizeof (struct pex_time));\n \tif (!pex_get_times (pex, n_commands, times))\n \t  pfatal_with_name (_(\"failed to get process times\"));\n       }\n@@ -3295,8 +3294,8 @@ add_preprocessor_option (const char *option, int len)\n   if (! preprocessor_options)\n     preprocessor_options = XNEWVEC (char *, n_preprocessor_options);\n   else\n-    preprocessor_options = xrealloc (preprocessor_options,\n-\t\t\t\t     n_preprocessor_options * sizeof (char *));\n+    preprocessor_options = XRESIZEVEC (char *, preprocessor_options,\n+\t\t\t\t       n_preprocessor_options);\n \n   preprocessor_options [n_preprocessor_options - 1] =\n     save_string (option, len);\n@@ -3310,8 +3309,8 @@ add_assembler_option (const char *option, int len)\n   if (! assembler_options)\n     assembler_options = XNEWVEC (char *, n_assembler_options);\n   else\n-    assembler_options = xrealloc (assembler_options,\n-\t\t\t\t  n_assembler_options * sizeof (char *));\n+    assembler_options = XRESIZEVEC (char *, assembler_options,\n+\t\t\t\t    n_assembler_options);\n \n   assembler_options [n_assembler_options - 1] = save_string (option, len);\n }\n@@ -3324,8 +3323,7 @@ add_linker_option (const char *option, int len)\n   if (! linker_options)\n     linker_options = XNEWVEC (char *, n_linker_options);\n   else\n-    linker_options = xrealloc (linker_options,\n-\t\t\t       n_linker_options * sizeof (char *));\n+    linker_options = XRESIZEVEC (char *, linker_options, n_linker_options);  \n \n   linker_options [n_linker_options - 1] = save_string (option, len);\n }\n@@ -3411,14 +3409,14 @@ process_command (int argc, const char **argv)\n       for (baselen = strlen (progname); baselen > 0; baselen--)\n \tif (IS_DIR_SEPARATOR (progname[baselen-1]))\n \t  break;\n-      new_argv0 = xmemdup (progname, baselen,\n+      new_argv0 = (char *) xmemdup (progname, baselen,\n \t\t\t   baselen + concat_length (new_version, new_machine,\n \t\t\t\t\t\t    \"-gcc-\", NULL) + 1);\n       strcpy (new_argv0 + baselen, new_machine);\n       strcat (new_argv0, \"-gcc-\");\n       strcat (new_argv0, new_version);\n \n-      new_argv = xmemdup (argv, (argc + 1) * sizeof (argv[0]),\n+      new_argv = (char **) xmemdup (argv, (argc + 1) * sizeof (argv[0]),\n \t\t\t  (argc + 1) * sizeof (argv[0]));\n       new_argv[0] = new_argv0;\n \n@@ -3494,7 +3492,7 @@ process_command (int argc, const char **argv)\n   if (temp)\n     {\n       const char *startp, *endp;\n-      char *nstore = alloca (strlen (temp) + 3);\n+      char *nstore = (char *) alloca (strlen (temp) + 3);\n \n       startp = endp = temp;\n       while (1)\n@@ -3528,7 +3526,7 @@ process_command (int argc, const char **argv)\n   if (temp && *cross_compile == '0')\n     {\n       const char *startp, *endp;\n-      char *nstore = alloca (strlen (temp) + 3);\n+      char *nstore = (char *) alloca (strlen (temp) + 3);\n \n       startp = endp = temp;\n       while (1)\n@@ -3561,7 +3559,7 @@ process_command (int argc, const char **argv)\n   if (temp && *cross_compile == '0')\n     {\n       const char *startp, *endp;\n-      char *nstore = alloca (strlen (temp) + 3);\n+      char *nstore = (char *) alloca (strlen (temp) + 3);\n \n       startp = endp = temp;\n       while (1)\n@@ -4468,7 +4466,7 @@ insert_wrapper (const char *wrapper)\n       argbuf_length = argbuf_length * 2;\n       while (argbuf_length < argbuf_index + n)\n \targbuf_length *= 2;\n-      argbuf = xrealloc (argbuf, argbuf_length * sizeof (const char *));\n+      argbuf = XRESIZEVEC (const char *, argbuf, argbuf_length);\n     }\n   for (i = argbuf_index - 1; i >= 0; i--)\n     argbuf[i + n] = argbuf[i];\n@@ -4568,7 +4566,7 @@ do_option_spec (const char *name, const char *spec)\n     }\n \n   /* Replace each %(VALUE) by the specified value.  */\n-  tmp_spec = alloca (strlen (spec) + 1\n+  tmp_spec = (char *) alloca (strlen (spec) + 1\n \t\t     + value_count * (value_len - strlen (\"%(VALUE)\")));\n   tmp_spec_p = tmp_spec;\n   q = spec;\n@@ -4600,8 +4598,7 @@ do_self_spec (const char *spec)\n \n       first = n_switches;\n       n_switches += argbuf_index;\n-      switches = xrealloc (switches,\n-\t\t\t   sizeof (struct switchstr) * (n_switches + 1));\n+      switches = XRESIZEVEC (struct switchstr, switches, n_switches + 1);\n \n       switches[n_switches] = switches[first];\n       for (i = 0; i < argbuf_index; i++)\n@@ -4635,7 +4632,7 @@ struct spec_path_info {\n static void *\n spec_path (char *path, void *data)\n {\n-  struct spec_path_info *info = data;\n+  struct spec_path_info *info = (struct spec_path_info *) data;\n   size_t len = 0;\n   char save = 0;\n \n@@ -4803,7 +4800,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      char *buf;\n \t      while (*p != 0 && *p != '\\n')\n \t\tp++;\n-\t      buf = alloca (p - q + 1);\n+\t      buf = (char *) alloca (p - q + 1);\n \t      strncpy (buf, q, p - q);\n \t      buf[p - q] = 0;\n \t      error (\"%s\", buf);\n@@ -4817,7 +4814,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      char *buf;\n \t      while (*p != 0 && *p != '\\n')\n \t\tp++;\n-\t      buf = alloca (p - q + 1);\n+\t      buf = (char *) alloca (p - q + 1);\n \t      strncpy (buf, q, p - q);\n \t      buf[p - q] = 0;\n \t      notice (\"%s\\n\", buf);\n@@ -4921,7 +4918,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    char *tmp;\n \t\t    \n \t\t    temp_filename_length = basename_length + suffix_length;\n-\t\t    tmp = alloca (temp_filename_length + 1);\n+\t\t    tmp = (char *) alloca (temp_filename_length + 1);\n \t\t    strncpy (tmp, input_basename, basename_length);\n \t\t    strncpy (tmp + basename_length, suffix, suffix_length);\n \t\t    tmp[temp_filename_length] = '\\0';\n@@ -4982,7 +4979,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t  {\n \t\t    if (t == 0)\n \t\t      {\n-\t\t\tt = xmalloc (sizeof (struct temp_name));\n+\t\t\tt = XNEW (struct temp_name);\n \t\t\tt->next = temp_names;\n \t\t\ttemp_names = t;\n \t\t      }\n@@ -5108,7 +5105,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n                   for (n_files = 0, i = 0; i < max; i++)\n                     n_files += outfiles[i] != NULL;\n \n-                  argv = alloca (sizeof (char *) * (n_files + 1));\n+                  argv = (char **) alloca (sizeof (char *) * (n_files + 1));\n \n                   /* Copy the strings over.  */\n                   for (i = 0, j = 0; i < max; i++)\n@@ -5426,7 +5423,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      char *x = alloca (strlen (name) * 2 + 1);\n+\t\t      char *x = (char *) alloca (strlen (name) * 2 + 1);\n \t\t      char *buf = x;\n \t\t      const char *y = name;\n \t\t      int flag = 0;\n@@ -6114,7 +6111,7 @@ is_directory (const char *path1, bool linker)\n   /* Ensure the string ends with \"/.\".  The resulting path will be a\n      directory even if the given path is a symbolic link.  */\n   len1 = strlen (path1);\n-  path = alloca (3 + len1);\n+  path = (char *) alloca (3 + len1);\n   memcpy (path, path1, len1);\n   cp = path + len1;\n   if (!IS_DIR_SEPARATOR (cp[-1]))\n@@ -6323,7 +6320,7 @@ main (int argc, char **argv)\n   /* Initialize the vector of specs to just the default.\n      This means one element containing 0s, as a terminator.  */\n \n-  compilers = xmalloc (sizeof default_compilers);\n+  compilers = XNEWVAR (struct compiler, sizeof default_compilers);\n   memcpy (compilers, default_compilers, sizeof default_compilers);\n   n_compilers = n_default_compilers;\n \n@@ -6342,7 +6339,7 @@ main (int argc, char **argv)\n \n   /* We need to check standard_exec_prefix/just_machine_suffix/specs\n      for any override of as, ld and libraries.  */\n-  specs_file = alloca (strlen (standard_exec_prefix)\n+  specs_file = (char *) alloca (strlen (standard_exec_prefix)\n \t\t       + strlen (just_machine_suffix) + sizeof (\"specs\"));\n \n   strcpy (specs_file, standard_exec_prefix);\n@@ -7175,7 +7172,8 @@ used_arg (const char *p, int len)\n \tif (*q == ';')\n \t  cnt++;\n \n-      matches = alloca ((sizeof (struct mswitchstr)) * cnt);\n+      matches\n+\t= (struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt);\n       i = 0;\n       q = multilib_matches;\n       while (*q != '\\0')\n@@ -7827,7 +7825,7 @@ getenv_spec_function (int argc, const char **argv)\n      particularly painful case is when we are reading a variable\n      holding a windows path complete with \\ separators.  */\n   len = strlen (value) * 2 + strlen (argv[1]) + 1;\n-  result = xmalloc (len);\n+  result = XNEWVAR (char, len);\n   for (ptr = result; *value; ptr += 2)\n     {\n       ptr[0] = '\\\\';"}, {"sha": "775b82b5fd737e0eb7ff1125bc60d3f06fb47787", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -1,3 +1,30 @@\n+2008-06-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* class.c (ident_subst, mangled_classname, unmangle_classname,\n+\tgen_indirect_dispatch_tables, add_method_1,\n+\tbuild_fieldref_cache_entry, make_local_function_alias,\n+\tlayout_class, java_treetreehash_find, java_treetreehash_new,\n+\tsplit_qualified_name): Fix for -Wc++-compat.\n+\t* constants.c (set_constant_entry, cpool_for_class): Likewise.\n+\t* decl.c (make_binding_level, java_dup_lang_specific_decl,\n+\tstart_java_method): Likewise.\n+\t* except.c (prepare_eh_table_type): Likewise.\n+\t* expr.c (type_assertion_hash, note_instructions): Likewise.\n+\t* java-tree.h (MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC,\n+\tMAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC): Likewise.\n+\t* jcf-io.c (jcf_filbuf_from_stdio, opendir_in_zip, find_class):\n+\tLikewise.\n+\t* jcf-parse.c (reverse, java_read_sourcefilenames,\n+\tannotation_grow, rewrite_reflection_indexes, java_parse_file,\n+\tprocess_zip_dir): Likewise.\n+\t* jcf-path.c (add_entry, add_path, jcf_path_init,\n+\tjcf_path_extdirs_arg): Likewise.\n+\t* jcf-reader.c (jcf_parse_constant_pool): Likewise.\n+\t* jvgenmain.c (do_mangle_classname): Likewise.\n+\t* lang.c (put_decl_string): Likewise.\n+\t* verify-impl.c (make_state_copy, make_state, add_new_state):\n+\tLikewise.\n+\n 2008-06-15  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* gcj.texi: Expand TABs, remove whitespace from blank lines."}, {"sha": "bf53b4755bedeee76ef1f8988a077be3f9236310", "filename": "gcc/java/class.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -279,7 +279,7 @@ ident_subst (const char* old_name,\n   int prefix_len = strlen (prefix);\n   int suffix_len = strlen (suffix);\n   int i = prefix_len + old_length + suffix_len + 1;\n-  char *buffer = alloca (i);\n+  char *buffer = (char *) alloca (i);\n \n   strcpy (buffer, prefix);\n   for (i = 0; i < old_length; i++)\n@@ -349,7 +349,7 @@ mangled_classname (const char *prefix, tree type)\n        rewriting.  */\n     if (illegal_chars != 0)\n       {\n-\tchar *buffer = alloca (illegal_chars * 4 + len + 1);\n+\tchar *buffer = (char *) alloca (illegal_chars * 4 + len + 1);\n \tint j;\n \n \tfor (i = 0, j = 0; i < len; i++)\n@@ -413,7 +413,7 @@ unmangle_classname (const char *name, int name_length)\n do\t\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   const char *typename = IDENTIFIER_POINTER (mangled_classname (\"\", TYPE)); \\\n-  char *buf = alloca (strlen (typename) + strlen (#NAME \"_syms_\") + 1);\t\\\n+  char *buf = (char *) alloca (strlen (typename) + strlen (#NAME \"_syms_\") + 1); \\\n   tree decl;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   sprintf (buf, #NAME \"_%s\", typename);\t\t\t\t\t\\\n@@ -445,7 +445,7 @@ gen_indirect_dispatch_tables (tree type)\n   const char *typename = IDENTIFIER_POINTER (mangled_classname (\"\", type));\n   {  \n     tree field = NULL;\n-    char *buf = alloca (strlen (typename) + strlen (\"_catch_classes_\") + 1);\n+    char *buf = (char *) alloca (strlen (typename) + strlen (\"_catch_classes_\") + 1);\n     tree catch_class_type = make_node (RECORD_TYPE);\n \n     sprintf (buf, \"_catch_classes_%s\", typename);\n@@ -759,7 +759,7 @@ add_method_1 (tree this_class, int access_flags, tree name, tree function_type)\n   DECL_CONTEXT (fndecl) = this_class;\n \n   DECL_LANG_SPECIFIC (fndecl)\n-    = ggc_alloc_cleared (sizeof (struct lang_decl));\n+    = GGC_CNEW (struct lang_decl);\n   DECL_LANG_SPECIFIC (fndecl)->desc = LANG_DECL_FUNC;\n \n   /* Initialize the static initializer test table.  */\n@@ -1192,7 +1192,7 @@ build_fieldref_cache_entry (int index, tree fdecl ATTRIBUTE_UNUSED)\n {\n   tree decl, decl_name;\n   const char *name = IDENTIFIER_POINTER (mangled_classname (\"_cpool_\", output_class));\n-  char *buf = alloca (strlen (name) + 20);\n+  char *buf = (char *) alloca (strlen (name) + 20);\n   sprintf (buf, \"%s_%d_ref\", name, index);\n   decl_name = get_identifier (buf);\n   decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n@@ -1367,8 +1367,8 @@ make_local_function_alias (tree method)\n   tree alias;\n   \n   const char *method_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (method));\n-  char *name = alloca (strlen (method_name) + 2);\n-  char *buf = alloca (strlen (method_name) + 128);\n+  char *name = (char *) alloca (strlen (method_name) + 2);\n+  char *buf = (char *) alloca (strlen (method_name) + 128);\n \n   /* Only create aliases for local functions.  */\n   if (DECL_EXTERNAL (method))\n@@ -2421,7 +2421,7 @@ layout_class (tree this_class)\n \t  obstack_grow (&temporary_obstack, buffer, strlen (buffer));\n \t}\n       obstack_1grow (&temporary_obstack, '\\0');\n-      report = obstack_finish (&temporary_obstack);\n+      report = XOBFINISH (&temporary_obstack, char *);\n       cyclic_inheritance_report = ggc_strdup (report);\n       obstack_free (&temporary_obstack, report);\n       TYPE_SIZE (this_class) = error_mark_node;\n@@ -3088,7 +3088,7 @@ java_treetreehash_find (htab_t ht, tree t)\n {\n   struct treetreehash_entry *e;\n   hashval_t hv = JAVA_TREEHASHHASH_H (t);\n-  e = htab_find_with_hash (ht, t, hv);\n+  e = (struct treetreehash_entry *) htab_find_with_hash (ht, t, hv);\n   if (e == NULL)\n     return NULL;\n   else\n@@ -3105,7 +3105,7 @@ java_treetreehash_new (htab_t ht, tree t)\n   e = htab_find_slot_with_hash (ht, t, hv, INSERT);\n   if (*e == NULL)\n     {\n-      tthe = (*ht->alloc_f) (1, sizeof (*tthe));\n+      tthe = (struct treetreehash_entry *) (*ht->alloc_f) (1, sizeof (*tthe));\n       tthe->key = t;\n       *e = tthe;\n     }\n@@ -3135,7 +3135,7 @@ split_qualified_name (tree *left, tree *right, tree source)\n   char *p, *base;\n   int l = IDENTIFIER_LENGTH (source);\n \n-  base = alloca (l + 1);\n+  base = (char *) alloca (l + 1);\n   memcpy (base, IDENTIFIER_POINTER (source), l + 1);\n \n   /* Breakdown NAME into REMAINDER . IDENTIFIER.  */"}, {"sha": "f3436cf08bf6307c98e66e085369133ba4618149", "filename": "gcc/java/constants.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -44,9 +44,8 @@ set_constant_entry (CPool *cpool, int index, int tag, jword value)\n   if (cpool->data == NULL)\n     {\n       cpool->capacity = 100;\n-      cpool->tags = ggc_alloc_cleared (sizeof(uint8) * cpool->capacity);\n-      cpool->data = ggc_alloc_cleared (sizeof(union cpool_entry)\n-\t\t\t\t       * cpool->capacity);\n+      cpool->tags = GGC_CNEWVEC (uint8, cpool->capacity);\n+      cpool->data = GGC_CNEWVEC (union cpool_entry, cpool->capacity);\n       cpool->count = 1;\n     }\n   if (index >= cpool->capacity)\n@@ -55,10 +54,9 @@ set_constant_entry (CPool *cpool, int index, int tag, jword value)\n       cpool->capacity *= 2;\n       if (index >= cpool->capacity)\n \tcpool->capacity = index + 10;\n-      cpool->tags = ggc_realloc (cpool->tags, \n-\t\t\t\t sizeof(uint8) * cpool->capacity);\n-      cpool->data = ggc_realloc (cpool->data,\n-\t\t\t\t sizeof(union cpool_entry) * cpool->capacity);\n+      cpool->tags = GGC_RESIZEVEC (uint8, cpool->tags, cpool->capacity);\n+      cpool->data = GGC_RESIZEVEC (union cpool_entry, cpool->data,\n+\t\t\t\t   cpool->capacity);\n \n       /* Make sure GC never sees uninitialized tag values.  */\n       memset (cpool->tags + old_cap, 0, cpool->capacity - old_cap);\n@@ -335,7 +333,7 @@ cpool_for_class (tree class)\n \n   if (cpool == NULL)\n     {\n-      cpool = ggc_alloc_cleared (sizeof (struct CPool));\n+      cpool = GGC_CNEW (struct CPool);\n       TYPE_CPOOL (class) = cpool;\n     }\n   return cpool;"}, {"sha": "8ed8926ec77a882c852201fb8c6837fb33d209dc", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -1254,7 +1254,7 @@ static struct binding_level *\n make_binding_level (void)\n {\n   /* NOSTRICT */\n-  return ggc_alloc_cleared (sizeof (struct binding_level));\n+  return GGC_CNEW (struct binding_level);\n }\n \n void\n@@ -1593,7 +1593,7 @@ java_dup_lang_specific_decl (tree node)\n     return;\n \n   lang_decl_size = sizeof (struct lang_decl);\n-  x = ggc_alloc (lang_decl_size);\n+  x = GGC_NEW (struct lang_decl);\n   memcpy (x, DECL_LANG_SPECIFIC (node), lang_decl_size);\n   DECL_LANG_SPECIFIC (node) = x;\n }\n@@ -1720,7 +1720,7 @@ start_java_method (tree fndecl)\n   i = DECL_MAX_LOCALS(fndecl) + DECL_MAX_STACK(fndecl);\n   decl_map = make_tree_vec (i);\n   base_decl_map = make_tree_vec (i);\n-  type_map = xrealloc (type_map, i * sizeof (tree));\n+  type_map = XRESIZEVEC (tree, type_map, i);\n \n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n   fprintf (stderr, \"%s:\\n\", lang_printable_name (fndecl, 2));"}, {"sha": "01e2fbedc38e72d85a995981d2d811df98fcaa59", "filename": "gcc/java/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -391,7 +391,7 @@ prepare_eh_table_type (tree type)\n   if (is_compiled_class (type) && !flag_indirect_dispatch)\n     {\n       name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-      buf = alloca (strlen (name) + 5);\n+      buf = (char *) alloca (strlen (name) + 5);\n       sprintf (buf, \"%s_ref\", name);\n       decl = build_decl (VAR_DECL, get_identifier (buf), ptr_type_node);\n       TREE_STATIC (decl) = 1;\n@@ -408,7 +408,7 @@ prepare_eh_table_type (tree type)\n     {\n       utf8_ref = build_utf8_ref (DECL_NAME (TYPE_NAME (type)));\n       name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (utf8_ref, 0)));\n-      buf = alloca (strlen (name) + 5);\n+      buf = (char *) alloca (strlen (name) + 5);\n       sprintf (buf, \"%s_ref\", name);\n       decl = build_decl (VAR_DECL, get_identifier (buf), utf8const_ptr_type);\n       TREE_STATIC (decl) = 1;"}, {"sha": "654a25ebc36f438e7bbd7a942c2de42a00745f26", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -430,7 +430,7 @@ type_assertion_eq (const void * k1_p, const void * k2_p)\n static hashval_t\n type_assertion_hash (const void *p)\n {\n-  const type_assertion *k_p = p;\n+  const type_assertion *k_p = (const type_assertion *) p;\n   hashval_t hash = iterative_hash (&k_p->assertion_code, sizeof\n \t\t\t\t   k_p->assertion_code, 0);\n \n@@ -3009,7 +3009,7 @@ note_instructions (JCF *jcf, tree method)\n \n   JCF_SEEK (jcf, DECL_CODE_OFFSET (method));\n   byte_ops = jcf->read_ptr;\n-  instruction_bits = xrealloc (instruction_bits, length + 1);\n+  instruction_bits = XRESIZEVAR (char, instruction_bits, length + 1);\n   memset (instruction_bits, 0, length + 1);\n   type_states = VEC_alloc (tree, gc, length + 1);\n   VEC_safe_grow_cleared (tree, gc, type_states, length + 1);"}, {"sha": "65a758946a1e4e65f2ab9f06976b28dc532356fd", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -769,8 +769,7 @@ union lang_tree_node\n #define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n   if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      DECL_LANG_SPECIFIC ((T))\t\t\t\t\t\\\n-\t= ggc_alloc_cleared (sizeof (struct lang_decl));\t\\\n+      DECL_LANG_SPECIFIC ((T)) = GGC_CNEW (struct lang_decl);\t\\\n       DECL_LANG_SPECIFIC (T)->desc = LANG_DECL_VAR;\t\t\\\n     }\n \n@@ -900,7 +899,7 @@ struct lang_decl GTY(())\n #define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T) \\\n   if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\\\n      TYPE_LANG_SPECIFIC ((T))\t\t\t\\\n-     = ggc_alloc_cleared (sizeof (struct lang_type));\n+     = GGC_CNEW (struct lang_type);\n \n #define TYPE_DUMMY(T)\t\t(TYPE_LANG_SPECIFIC(T)->dummy_class)\n "}, {"sha": "fb8f756ee1620f1778a88ce71b75713d3cb19387", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -78,8 +78,9 @@ jcf_filbuf_from_stdio (JCF *jcf, int count)\n       JCF_u4 old_read_end = jcf->read_end - jcf->buffer;\n       JCF_u4 old_size = jcf->buffer_end - jcf->buffer;\n       JCF_u4 new_size = (old_size == 0 ? 2000 : 2 * old_size) + count;\n-      unsigned char *new_buffer = jcf->buffer == NULL ? ALLOC (new_size)\n-\t: REALLOC (jcf->buffer, new_size);\n+      unsigned char *new_buffer\n+\t= jcf->buffer == NULL ? XNEWVAR (unsigned char, new_size)\n+\t: XRESIZEVAR (unsigned char, jcf->buffer, new_size);\n       jcf->buffer = new_buffer;\n       jcf->buffer_end = new_buffer + new_size;\n       jcf->read_ptr = new_buffer + old_read_ptr;\n@@ -115,7 +116,7 @@ opendir_in_zip (const char *zipfile, int is_system)\n \treturn zipf;\n     }\n \n-  zipf = ALLOC (sizeof (struct ZipFile) + strlen (zipfile) + 1);\n+  zipf = XNEWVAR (struct ZipFile, sizeof (struct ZipFile) + strlen (zipfile) + 1);\n   zipf->next = SeenZipFiles;\n   zipf->name = (char*)(zipf+1);\n   strcpy (zipf->name, zipfile);\n@@ -471,7 +472,7 @@ find_class (const char *classname, int classname_length, JCF *jcf)\n   /* Allocate and zero out the buffer, since we don't explicitly put a\n      null pointer when we're copying it below.  */\n   buflen = jcf_path_max_len () + classname_length + 10;\n-  buffer = ALLOC (buflen);\n+  buffer = XNEWVAR (char, buflen);\n   memset (buffer, 0, buflen);\n \n   for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))"}, {"sha": "c53e871c6b30b2cfe53ae9ee1906b1c7d8fa7ec5", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -145,7 +145,7 @@ reverse (const char *s)\n   else\n     {\n       int len = strlen (s);\n-      char *d = xmalloc (len + 1);\n+      char *d = XNEWVAR (char, len + 1);\n       const char *sp;\n       char *dp;\n       \n@@ -213,11 +213,11 @@ java_read_sourcefilenames (const char *fsource_filename)\n       /* Read the filenames.  Put a pointer to each filename into the\n \t array FILENAMES.  */\n       {\n-\tchar *linebuf = alloca (longest_line + 1);\n+\tchar *linebuf = (char *) alloca (longest_line + 1);\n \tint i = 0;\n \tint charpos;\n \n-\tfilenames = xmalloc (num_files * sizeof (char*));\n+\tfilenames = XNEWVEC (char *, num_files);\n \n \tcharpos = 0;\n \tfor (;;)\n@@ -249,7 +249,7 @@ java_read_sourcefilenames (const char *fsource_filename)\n     }\n   else\n     {\n-      filenames = xmalloc (sizeof (char*));      \n+      filenames = XNEWVEC (char *, 1);      \n       filenames[0] = reverse (fsource_filename);\n       num_files = 1;\n     }\n@@ -391,13 +391,13 @@ annotation_grow (int delta)\n \n   if (*data == NULL)\n     {\n-      *data = xmalloc (delta);\n+      *data = XNEWVAR (unsigned char, delta);\n     }\n   else\n     {\n       int newlen = *datasize + delta;\n       if (floor_log2 (newlen) != floor_log2 (*datasize))\n-\t*data = xrealloc (*data,  2 << (floor_log2 (newlen)));\n+\t*data = XRESIZEVAR (unsigned char, *data,  2 << (floor_log2 (newlen)));\n     }\n   *datasize += delta;\n   return *data + len;\n@@ -746,7 +746,7 @@ rewrite_reflection_indexes (void *arg)\n {\n   bitmap_iterator bi;\n   unsigned int offset;\n-  VEC(int, heap) *map = arg;\n+  VEC(int, heap) *map = (VEC(int, heap) *) arg;\n   unsigned char *data = TYPE_REFLECTION_DATA (current_class);\n \n   if (map)\n@@ -1731,7 +1731,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t    {\n \t      count = next - list;\n \t      avail = 2 * (count + avail);\n-\t      list = xrealloc (list, avail);\n+\t      list = XRESIZEVEC (char, list, avail);\n \t      next = list + count;\n \t      avail = avail - count;\n \t    }\n@@ -1877,7 +1877,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       if (magic == 0xcafebabe)\n \t{\n \t  CLASS_FILE_P (node) = 1;\n-\t  current_jcf = ggc_alloc (sizeof (JCF));\n+\t  current_jcf = GGC_NEW (JCF);\n \t  JCF_ZERO (current_jcf);\n \t  current_jcf->read_state = finput;\n \t  current_jcf->filbuf = jcf_filbuf_from_stdio;\n@@ -1895,7 +1895,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t}\n       else if (magic == (JCF_u4)ZIPMAGIC)\n \t{\n-\t  main_jcf = ggc_alloc (sizeof (JCF));\n+\t  main_jcf = GGC_NEW (JCF);\n \t  JCF_ZERO (main_jcf);\n \t  main_jcf->read_state = finput;\n \t  main_jcf->filbuf = jcf_filbuf_from_stdio;\n@@ -1905,7 +1905,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t    fatal_error (\"bad zip/jar file %s\", filename);\n \t  localToFile = SeenZipFiles;\n \t  /* Register all the classes defined there.  */\n-\t  process_zip_dir (main_jcf->read_state);\n+\t  process_zip_dir ((FILE *) main_jcf->read_state);\n \t  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n \t  parse_zip_file_entries ();\n \t}\n@@ -2157,7 +2157,7 @@ process_zip_dir (FILE *finput)\n \n       class_name = compute_class_name (zdir);\n       file_name  = XNEWVEC (char, zdir->filename_length+1);\n-      jcf = ggc_alloc (sizeof (JCF));\n+      jcf = GGC_NEW (JCF);\n       JCF_ZERO (jcf);\n \n       strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);"}, {"sha": "ca7875ce30f42fcbe877fcb7dba2f685c2e74b33", "filename": "gcc/java/jcf-path.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -154,7 +154,7 @@ add_entry (struct entry **entp, const char *filename, int is_system)\n      work more easily.  Eww.  */\n   if (! IS_DIR_SEPARATOR (filename[len - 1]))\n     {\n-      char *f2 = alloca (len + 2);\n+      char *f2 = (char *) alloca (len + 2);\n       strcpy (f2, filename);\n       f2[len] = DIR_SEPARATOR;\n       f2[len + 1] = '\\0';\n@@ -177,7 +177,7 @@ add_path (struct entry **entp, const char *cp, int is_system)\n \n   if (cp)\n     {\n-      char *buf = alloca (strlen (cp) + 3);\n+      char *buf = (char *) alloca (strlen (cp) + 3);\n       startp = endp = cp;\n       while (1)\n \t{\n@@ -227,7 +227,7 @@ jcf_path_init (void)\n   GET_ENVIRONMENT (cp, \"GCC_EXEC_PREFIX\");\n   if (cp)\n     {\n-      try = alloca (strlen (cp) + 50);\n+      try = (char *) alloca (strlen (cp) + 50);\n       /* The exec prefix can be something like\n \t /usr/local/bin/../lib/gcc-lib/.  We want to change this\n \t into a pointer to the share/java directory.  We support two\n@@ -285,7 +285,7 @@ jcf_path_init (void)\n       /* Desperation: use the installed one.  */\n       char *extdirs;\n       add_entry (&sys_dirs, LIBGCJ_ZIP_FILE, 1);\n-      extdirs = alloca (strlen (LIBGCJ_ZIP_FILE) + 1);\n+      extdirs = (char *) alloca (strlen (LIBGCJ_ZIP_FILE) + 1);\n       strcpy (extdirs, LIBGCJ_ZIP_FILE);\n       strcpy (&extdirs[strlen (LIBGCJ_ZIP_FILE)\n \t\t      - strlen (\"libgcj-\" DEFAULT_TARGET_VERSION \".jar\")],\n@@ -329,7 +329,7 @@ jcf_path_extdirs_arg (const char *cp)\n \n   if (cp)\n     {\n-      char *buf = alloca (strlen (cp) + 3);\n+      char *buf = (char *) alloca (strlen (cp) + 3);\n       startp = endp = cp;\n       while (1)\n \t{\n@@ -358,7 +358,7 @@ jcf_path_extdirs_arg (const char *cp)\n \t\t    \n \t\t    if (direntp->d_name[0] != '.')\n \t\t      {\n-\t\t\tchar *name = alloca (dirname_length\n+\t\t\tchar *name = (char *) alloca (dirname_length\n \t\t\t\t\t     + strlen (direntp->d_name) + 2);\n \t\t\tstrcpy (name, buf);\n \t\t\tif (! IS_DIR_SEPARATOR (name[dirname_length-1]))"}, {"sha": "c437d168af78252071b4c7da4abfd2520bb126d2", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -330,8 +330,8 @@ jcf_parse_constant_pool (JCF* jcf)\n {\n   int i, n;\n   JPOOL_SIZE (jcf) = (JCF_FILL (jcf, 2), JCF_readu2 (jcf));\n-  jcf->cpool.tags = ggc_alloc (JPOOL_SIZE (jcf));\n-  jcf->cpool.data = ggc_alloc (sizeof (jword) * JPOOL_SIZE (jcf));\n+  jcf->cpool.tags = GGC_NEWVAR (uint8, JPOOL_SIZE (jcf));\n+  jcf->cpool.data = GGC_NEWVAR (union cpool_entry, sizeof (jword) * JPOOL_SIZE (jcf));\n   jcf->cpool.tags[0] = 0;\n #ifdef HANDLE_START_CONSTANT_POOL\n   HANDLE_START_CONSTANT_POOL (JPOOL_SIZE (jcf));"}, {"sha": "6b7fa4c255217f6b68163e695ca999804b0eeac2", "filename": "gcc/java/jvgenmain.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -177,5 +177,5 @@ do_mangle_classname (const char *string)\n   append_gpp_mangled_name (&ptr [-count], count);\n   obstack_grow (mangle_obstack, \"6class$E\", strlen (\"6class$E\"));\n   obstack_1grow (mangle_obstack, '\\0');\n-  return obstack_finish (mangle_obstack);\n+  return XOBFINISH (mangle_obstack, char *);\n }"}, {"sha": "71f2478912366179df51f1776f300933cbcd4d46", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -389,7 +389,7 @@ put_decl_string (const char *str, int len)\n       else\n \t{\n \t  decl_buflen *= 2;\n-\t  decl_buf = xrealloc (decl_buf, decl_buflen);\n+\t  decl_buf = XRESIZEVAR (char, decl_buf, decl_buflen);\n \t}\n     }\n   strcpy (decl_buf + decl_bufpos, str);"}, {"sha": "69fb031022b1cf1df8d6cb4b3569a178860a8013", "filename": "gcc/java/verify-impl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fverify-impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fjava%2Fverify-impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-impl.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -983,15 +983,15 @@ copy_state_with_stack (state *s, state *orig, int max_stack, int max_locals)\n static state *\n make_state_copy (state *orig, int max_stack, int max_locals)\n {\n-  state *s = vfy_alloc (sizeof (state));\n+  state *s = (state *) vfy_alloc (sizeof (state));\n   copy_state_with_stack (s, orig, max_stack, max_locals);\n   return s;\n }\n \n static state *\n make_state (int max_stack, int max_locals)\n {\n-  state *s = vfy_alloc (sizeof (state));\n+  state *s = (state *) vfy_alloc (sizeof (state));\n   init_state_with_stack (s, max_stack, max_locals);\n   return s;\n }\n@@ -1385,7 +1385,7 @@ add_new_state (int npc, state *old_state)\n   debug_print_state (new_state, \"New\", npc, current_method->max_stack,\n \t\t    current_method->max_locals);\n \n-  nlink = vfy_alloc (sizeof (state_list));\n+  nlink = (state_list *) vfy_alloc (sizeof (state_list));\n   nlink->val = new_state;\n   nlink->next = vfr->states[npc];\n   vfr->states[npc] = nlink;"}, {"sha": "f5869b3bca97c13672eaf21b3ec3e7db65424ba1", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -1,3 +1,10 @@\n+2008-06-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* objc-act.c (setup_string_decl, objc_build_string_object,\n+\thash_interface, eq_interface, objc_begin_try_stmt,\n+\tencode_method_prototype, build_ivar_list_initializer,\n+\tobjc_build_encode_expr): Fix for -Wc++-compat.\n+\n 2008-05-12  Tomas Bily  <tbily@suse.cz>\n \n         * objc-act.c (objc_generate_write_barrier, objc_finish_message_expr):"}, {"sha": "4aef9a02017ef50f6ef63a0a3dfe17d48d745abb", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -1500,7 +1500,7 @@ setup_string_decl (void)\n   /* %s in format will provide room for terminating null */\n   length = strlen (STRING_OBJECT_GLOBAL_FORMAT)\n \t   + strlen (constant_string_class_name);\n-  name = xmalloc (length);\n+  name = XNEWVEC (char, length);\n   sprintf (name, STRING_OBJECT_GLOBAL_FORMAT,\n \t   constant_string_class_name);\n   constant_string_global_id = get_identifier (name);\n@@ -1929,12 +1929,12 @@ objc_build_string_object (tree string)\n   /* Perhaps we already constructed a constant string just like this one? */\n   key.literal = string;\n   loc = htab_find_slot (string_htab, &key, INSERT);\n-  desc = *loc;\n+  desc = (struct string_descriptor *) *loc;\n \n   if (!desc)\n     {\n       tree var;\n-      *loc = desc = ggc_alloc (sizeof (*desc));\n+      *loc = desc = GGC_NEW (struct string_descriptor);\n       desc->literal = string;\n \n       /* GNU:    (NXConstantString *) & ((__builtin_ObjCString) { NULL, string, length })  */\n@@ -3290,14 +3290,14 @@ static GTY ((param_is (struct interface_tuple))) htab_t interface_htab;\n static hashval_t\n hash_interface (const void *p)\n {\n-  const struct interface_tuple *d = p;\n+  const struct interface_tuple *d = (const struct interface_tuple *) p;\n   return IDENTIFIER_HASH_VALUE (d->id);\n }\n \n static int\n eq_interface (const void *p1, const void *p2)\n {\n-  const struct interface_tuple *d = p1;\n+  const struct interface_tuple *d = (const struct interface_tuple *) p1;\n   return d->id == p2;\n }\n \n@@ -3751,7 +3751,7 @@ next_sjlj_build_try_catch_finally (void)\n void\n objc_begin_try_stmt (location_t try_locus, tree body)\n {\n-  struct objc_try_context *c = xcalloc (1, sizeof (*c));\n+  struct objc_try_context *c = XCNEW (struct objc_try_context);\n   c->outer = cur_try_context;\n   c->try_body = body;\n   c->try_locus = try_locus;\n@@ -4348,7 +4348,7 @@ encode_method_prototype (tree method_decl)\n \n   finish_encoding:\n   obstack_1grow (&util_obstack, '\\0');\n-  result = get_identifier (obstack_finish (&util_obstack));\n+  result = get_identifier (XOBFINISH (&util_obstack, char *));\n   obstack_free (&util_obstack, util_firstobj);\n   return result;\n }\n@@ -5160,7 +5160,7 @@ build_ivar_list_initializer (tree type, tree field_decl)\n       ivar\n \t= tree_cons\n \t  (NULL_TREE,\n-\t   add_objc_string (get_identifier (obstack_finish (&util_obstack)),\n+\t   add_objc_string (get_identifier (XOBFINISH (&util_obstack, char *)),\n \t\t\t    meth_var_types),\n \t   ivar);\n       obstack_free (&util_obstack, util_firstobj);\n@@ -6690,7 +6690,7 @@ objc_build_encode_expr (tree type)\n   encode_type (type, obstack_object_size (&util_obstack),\n \t       OBJC_ENCODE_INLINE_DEFS);\n   obstack_1grow (&util_obstack, 0);    /* null terminate string */\n-  string = obstack_finish (&util_obstack);\n+  string = XOBFINISH (&util_obstack, const char *);\n \n   /* Synthesize a string that represents the encoded struct/union.  */\n   result = my_build_string (strlen (string) + 1, string);"}, {"sha": "51f371715ff93e1d3407017c18a468dd3ec25811", "filename": "gcc/tlink.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=e1e4cdc42c8b28235ab637dc5df2b4ef159c5b98", "patch": "@@ -127,7 +127,7 @@ symbol_hash_lookup (const char *string, int create)\n       *e = v = XCNEW (struct symbol_hash_entry);\n       v->key = xstrdup (string);\n     }\n-  return *e;\n+  return (struct symbol_hash_entry *) *e;\n }\n \n static htab_t file_table;\n@@ -147,7 +147,7 @@ file_hash_lookup (const char *string)\n       *e = v = XCNEW (struct file_hash_entry);\n       v->key = xstrdup (string);\n     }\n-  return *e;\n+  return (struct file_hash_entry *) *e;\n }\n \n static htab_t demangled_table;\n@@ -169,7 +169,7 @@ demangled_hash_lookup (const char *string, int create)\n       *e = v = XCNEW (struct demangled_hash_entry);\n       v->key = xstrdup (string);\n     }\n-  return *e;\n+  return (struct demangled_hash_entry *) *e;\n }\n \f\n /* Stack code.  */\n@@ -193,8 +193,8 @@ struct file_stack_entry *file_stack;\n static void\n symbol_push (symbol *p)\n {\n-  struct symbol_stack_entry *ep = obstack_alloc\n-    (&symbol_stack_obstack, sizeof (struct symbol_stack_entry));\n+  struct symbol_stack_entry *ep\n+    = XOBNEW (&symbol_stack_obstack, struct symbol_stack_entry);\n   ep->value = p;\n   ep->next = symbol_stack;\n   symbol_stack = ep;\n@@ -221,8 +221,7 @@ file_push (file *p)\n   if (p->tweaking)\n     return;\n \n-  ep = obstack_alloc\n-    (&file_stack_obstack, sizeof (struct file_stack_entry));\n+  ep = XOBNEW (&file_stack_obstack, struct file_stack_entry);\n   ep->value = p;\n   ep->next = file_stack;\n   file_stack = ep;\n@@ -298,7 +297,7 @@ frob_extension (const char *s, const char *ext)\n     p = s + strlen (s);\n \n   obstack_grow (&temporary_obstack, s, p - s);\n-  return obstack_copy0 (&temporary_obstack, ext, strlen (ext));\n+  return (char *) obstack_copy0 (&temporary_obstack, ext, strlen (ext));\n }\n \n static char *"}]}