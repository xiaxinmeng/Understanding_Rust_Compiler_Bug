{"sha": "8656214b84c3e789deffe8f7b465bd1c886b2a03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1NjIxNGI4NGMzZTc4OWRlZmZlOGY3YjQ2NWJkMWM4ODZiMmEwMw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-16T16:30:03Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-16T16:30:03Z"}, "message": "[multiple changes]\n\n2005-11-15  Jeroen Frijters  <jeroen@frijters.net>\n\n       * java/io/ObjectInputStream.java\n       (parseContent): Removed bogus println and fixed bug #24422.\n\n2005-11-15  Mark Wielaard  <mark@klomp.org>\n\n       * java/io/ObjectStreamClass.java: Removed, fully merged now.\n       * sources.am: Regenerated.\n       * Makefile.in: Regenerated.\n\n2005-11-15  Wolfgang Baer  <WBaer@gmx.de>\n\n       * java/io/ObjectInputStream.java\n       (processResolution): Pass Error, RuntimeException and\n       ObjectStreamException through to the caller.\n       (readObject): Documentation update.\n\nFrom-SVN: r107088", "tree": {"sha": "0fda62a6586bb15fee6065d0863f3e58790cd0b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fda62a6586bb15fee6065d0863f3e58790cd0b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8656214b84c3e789deffe8f7b465bd1c886b2a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8656214b84c3e789deffe8f7b465bd1c886b2a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8656214b84c3e789deffe8f7b465bd1c886b2a03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8656214b84c3e789deffe8f7b465bd1c886b2a03/comments", "author": null, "committer": null, "parents": [{"sha": "0678ec6bf847a3faa46aa204332e221f70c10292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0678ec6bf847a3faa46aa204332e221f70c10292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0678ec6bf847a3faa46aa204332e221f70c10292"}], "stats": {"total": 1029, "additions": 47, "deletions": 982}, "files": [{"sha": "86042d8eadcc13ec5f296f25d99cd11ed58b1d89", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8656214b84c3e789deffe8f7b465bd1c886b2a03", "patch": "@@ -1,3 +1,21 @@\n+2005-11-15  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(parseContent): Removed bogus println and fixed bug #24422.\n+\t\t\n+2005-11-15  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/io/ObjectStreamClass.java: Removed, fully merged now.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n+2005-11-15  Wolfgang Baer  <WBaer@gmx.de>\n+\n+\t* java/io/ObjectInputStream.java\n+\t(processResolution): Pass Error, RuntimeException and\n+\tObjectStreamException through to the caller.\n+\t(readObject): Documentation update.\n+\n 2005-11-15  Mark Wielaard  <mark@klomp.org>\n \n \tImported GNU Classpath 0.19 + gcj-import-20051115."}, {"sha": "22287d09ef43961f6b9e549d39501ebc945f7b4d", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8656214b84c3e789deffe8f7b465bd1c886b2a03", "patch": "@@ -2612,7 +2612,7 @@ java/io/ObjectInputStream.java \\\n classpath/java/io/ObjectInputValidation.java \\\n classpath/java/io/ObjectOutput.java \\\n classpath/java/io/ObjectOutputStream.java \\\n-java/io/ObjectStreamClass.java \\\n+classpath/java/io/ObjectStreamClass.java \\\n classpath/java/io/ObjectStreamConstants.java \\\n classpath/java/io/ObjectStreamException.java \\\n classpath/java/io/ObjectStreamField.java \\"}, {"sha": "54661a9bc53272d7342254b7f737bd072a735868", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=8656214b84c3e789deffe8f7b465bd1c886b2a03", "patch": "@@ -113,7 +113,10 @@ else if (dump == true && (val == null || val.equals(\"\")))\n    * <code>private void readObject (ObjectInputStream)</code>.\n    *\n    * If an exception is thrown from this method, the stream is left in\n-   * an undefined state.\n+   * an undefined state. This method can also throw Errors and \n+   * RuntimeExceptions if caused by existing readResolve() user code.\n+   * \n+   * @return The object read from the underlying stream.\n    *\n    * @exception ClassNotFoundException The class that an object being\n    * read in belongs to cannot be found.\n@@ -199,14 +202,28 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t      for (int i = 0; i < n_intf; i++)\n \t\t{\n \t\t  intfs[i] = this.realInputStream.readUTF();\n-\t\t  System.out.println(intfs[i]);\n \t\t}\n \t      \n \t      boolean oldmode = setBlockDataMode(true);\n \t      Class cl = resolveProxyClass(intfs);\n \t      setBlockDataMode(oldmode);\n \t      \n \t      ObjectStreamClass osc = lookupClass(cl);\n+\t      if (osc.firstNonSerializableParentConstructor == null)\n+\t\t{\n+\t\t  osc.realClassIsSerializable = true;\n+\t\t  osc.fields = osc.fieldMapping = new ObjectStreamField[0];\n+\t\t  try\n+\t\t    {\n+\t\t      osc.firstNonSerializableParentConstructor =\n+\t\t        Object.class.getConstructor(new Class[0]);\n+\t\t    }\n+\t\t  catch (NoSuchMethodException x)\n+\t\t    {\n+\t\t      throw (InternalError)\n+\t\t\tnew InternalError(\"Object ctor missing\").initCause(x);\n+\t\t    }\n+\t\t}\n \t      assignNewHandle(osc);\n \t      \n \t      if (!is_consumed)\n@@ -1558,8 +1575,15 @@ private Object processResolution(ObjectStreamClass osc, Object obj, int handle)\n \tcatch (IllegalAccessException ignore)\n \t  {\n \t  }\n-\tcatch (InvocationTargetException ignore)\n+\tcatch (InvocationTargetException exception)\n \t  {\n+\t    Throwable cause = exception.getCause();\n+\t    if (cause instanceof ObjectStreamException)\n+\t      throw (ObjectStreamException) cause;\n+\t    else if (cause instanceof RuntimeException)\n+\t      throw (RuntimeException) cause;\n+\t    else if (cause instanceof Error)\n+\t      throw (Error) cause;\n \t  }\n       }\n "}, {"sha": "975dbfc66d00d7c4517204f0c59c47193435c28d", "filename": "libjava/java/io/ObjectStreamClass.java", "status": "removed", "additions": 0, "deletions": 977, "changes": 977, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0678ec6bf847a3faa46aa204332e221f70c10292/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0678ec6bf847a3faa46aa204332e221f70c10292/libjava%2Fjava%2Fio%2FObjectStreamClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectStreamClass.java?ref=0678ec6bf847a3faa46aa204332e221f70c10292", "patch": "@@ -1,977 +0,0 @@\n-/* ObjectStreamClass.java -- Class used to write class information\n-   about serialized objects.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n- \n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.io;\n-\n-import gnu.java.io.NullOutputStream;\n-import gnu.java.lang.reflect.TypeSignature;\n-import gnu.java.security.action.SetAccessibleAction;\n-import gnu.java.security.provider.Gnu;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Member;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Proxy;\n-import java.security.AccessController;\n-import java.security.DigestOutputStream;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.PrivilegedAction;\n-import java.security.Security;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.Hashtable;\n-import java.util.Vector;\n-\n-public class ObjectStreamClass implements Serializable\n-{\n-  /**\n-   * Returns the <code>ObjectStreamClass</code> for <code>cl</code>.\n-   * If <code>cl</code> is null, or is not <code>Serializable</code>,\n-   * null is returned.  <code>ObjectStreamClass</code>'s are memorized;\n-   * later calls to this method with the same class will return the\n-   * same <code>ObjectStreamClass</code> object and no recalculation\n-   * will be done.\n-   *\n-   * @see java.io.Serializable\n-   */\n-  public static ObjectStreamClass lookup(Class cl)\n-  {\n-    if (cl == null)\n-      return null;\n-    if (! (Serializable.class).isAssignableFrom(cl))\n-      return null;\n-\n-    return lookupForClassObject(cl);\n-  }\n-\n-  /**\n-   * This lookup for internal use by ObjectOutputStream.  Suppose\n-   * we have a java.lang.Class object C for class A, though A is not\n-   * serializable, but it's okay to serialize C.\n-   */\n-  static ObjectStreamClass lookupForClassObject(Class cl)\n-  {\n-    if (cl == null)\n-      return null;\n-\n-    ObjectStreamClass osc = (ObjectStreamClass) classLookupTable.get(cl);\n-\n-    if (osc != null)\n-      return osc;\n-    else\n-      {\n-\tosc = new ObjectStreamClass(cl);\n-\tclassLookupTable.put(cl, osc);\n-\treturn osc;\n-      }\n-  }\n-\n-  /**\n-   * Returns the name of the class that this\n-   * <code>ObjectStreamClass</code> represents.\n-   *\n-   * @return the name of the class.\n-   */\n-  public String getName()\n-  {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the class that this <code>ObjectStreamClass</code>\n-   * represents.  Null could be returned if this\n-   * <code>ObjectStreamClass</code> was read from an\n-   * <code>ObjectInputStream</code> and the class it represents cannot\n-   * be found or loaded.\n-   *\n-   * @see java.io.ObjectInputStream\n-   */\n-  public Class forClass()\n-  {\n-    return clazz;\n-  }\n-\n-  /**\n-   * Returns the serial version stream-unique identifier for the class\n-   * represented by this <code>ObjectStreamClass</code>.  This SUID is\n-   * either defined by the class as <code>static final long\n-   * serialVersionUID</code> or is calculated as specified in\n-   * Javasoft's \"Object Serialization Specification\" XXX: add reference\n-   *\n-   * @return the serial version UID.\n-   */\n-  public long getSerialVersionUID()\n-  {\n-    return uid;\n-  }\n-\n-  /**\n-   * Returns the serializable (non-static and non-transient) Fields\n-   * of the class represented by this ObjectStreamClass.  The Fields\n-   * are sorted by name.\n-   *\n-   * @return the fields.\n-   */\n-  public ObjectStreamField[] getFields()\n-  {\n-    ObjectStreamField[] copy = new ObjectStreamField[ fields.length ];\n-    System.arraycopy(fields, 0, copy, 0, fields.length);\n-    return copy;\n-  }\n-\n-  // XXX doc\n-  // Can't do binary search since fields is sorted by name and\n-  // primitiveness.\n-  public ObjectStreamField getField (String name)\n-  {\n-    for (int i = 0; i < fields.length; i++)\n-      if (fields[i].getName().equals(name))\n-\treturn fields[i];\n-    return null;\n-  }\n-\n-  /**\n-   * Returns a textual representation of this\n-   * <code>ObjectStreamClass</code> object including the name of the\n-   * class it represents as well as that class's serial version\n-   * stream-unique identifier.\n-   *\n-   * @see #getSerialVersionUID()\n-   * @see #getName()\n-   */\n-  public String toString()\n-  {\n-    return \"java.io.ObjectStreamClass< \" + name + \", \" + uid + \" >\";\n-  }\n-\n-  // Returns true iff the class that this ObjectStreamClass represents\n-  // has the following method:\n-  //\n-  // private void writeObject (ObjectOutputStream)\n-  //\n-  // This method is used by the class to override default\n-  // serialization behavior.\n-  boolean hasWriteMethod()\n-  {\n-    return (flags & ObjectStreamConstants.SC_WRITE_METHOD) != 0;\n-  }\n-\n-  // Returns true iff the class that this ObjectStreamClass represents\n-  // implements Serializable but does *not* implement Externalizable.\n-  boolean isSerializable()\n-  {\n-    return (flags & ObjectStreamConstants.SC_SERIALIZABLE) != 0;\n-  }\n-\n-\n-  // Returns true iff the class that this ObjectStreamClass represents\n-  // implements Externalizable.\n-  boolean isExternalizable()\n-  {\n-    return (flags & ObjectStreamConstants.SC_EXTERNALIZABLE) != 0;\n-  }\n-\n-\n-  // Returns the <code>ObjectStreamClass</code> that represents the\n-  // class that is the superclass of the class this\n-  // <code>ObjectStreamClass</code> represents.  If the superclass is\n-  // not Serializable, null is returned.\n-  ObjectStreamClass getSuper()\n-  {\n-    return superClass;\n-  }\n-\n-\n-  // returns an array of ObjectStreamClasses that represent the super\n-  // classes of CLAZZ and CLAZZ itself in order from most super to\n-  // CLAZZ.  ObjectStreamClass[0] is the highest superclass of CLAZZ\n-  // that is serializable.\n-  static ObjectStreamClass[] getObjectStreamClasses(Class clazz)\n-  {\n-    ObjectStreamClass osc = ObjectStreamClass.lookup(clazz);\n-\n-    if (osc == null)\n-      return new ObjectStreamClass[0];\n-    else\n-      {\n-\tVector oscs = new Vector();\n-\n-\twhile (osc != null)\n-\t  {\n-\t    oscs.addElement (osc);\n-\t    osc = osc.getSuper();\n-\t  }\n-\n-\tint count = oscs.size();\n-\tObjectStreamClass[] sorted_oscs = new ObjectStreamClass[ count ];\n-\n-\tfor (int i = count - 1; i >= 0; i--)\n-\t  sorted_oscs[ count - i - 1 ] = (ObjectStreamClass) oscs.elementAt(i);\n-\n-\treturn sorted_oscs;\n-      }\n-  }\n-\n-\n-  // Returns an integer that consists of bit-flags that indicate\n-  // properties of the class represented by this ObjectStreamClass.\n-  // The bit-flags that could be present are those defined in\n-  // ObjectStreamConstants that begin with `SC_'\n-  int getFlags()\n-  {\n-    return flags;\n-  }\n-\n-\n-  ObjectStreamClass(String name, long uid, byte flags,\n-\t\t    ObjectStreamField[] fields)\n-  {\n-    this.name = name;\n-    this.uid = uid;\n-    this.flags = flags;\n-    this.fields = fields;\n-  }\n-\n-  /**\n-   * This method builds the internal description corresponding to a Java Class.\n-   * As the constructor only assign a name to the current ObjectStreamClass instance,\n-   * that method sets the serial UID, chose the fields which will be serialized,\n-   * and compute the position of the fields in the serialized stream.\n-   *\n-   * @param cl The Java class which is used as a reference for building the descriptor.\n-   * @param superClass The descriptor of the super class for this class descriptor.\n-   * @throws InvalidClassException if an incompatibility between computed UID and\n-   * already set UID is found.\n-   */\n-  void setClass(Class cl, ObjectStreamClass superClass) throws InvalidClassException\n-  {\n-    this.clazz = cl;\n-\n-    cacheMethods();\n-\n-    long class_uid = getClassUID(cl);\n-    if (uid == 0)\n-      uid = class_uid;\n-    else\n-      {\n-\t// Check that the actual UID of the resolved class matches the UID from \n-\t// the stream.    \n-\tif (uid != class_uid)\n-\t  {\n-\t    String msg = cl + \n-\t      \": Local class not compatible: stream serialVersionUID=\"\n-\t      + uid + \", local serialVersionUID=\" + class_uid;\n-\t    throw new InvalidClassException (msg);\n-\t  }\n-      }\n-\n-    isProxyClass = clazz != null && Proxy.isProxyClass(clazz);\n-    this.superClass = superClass;\n-    calculateOffsets();\n-    \n-    try\n-      {\n-\tObjectStreamField[] exportedFields = getSerialPersistentFields (clazz);  \n-\n-\tif (exportedFields == null)\n-\t  return;\n-\n-\tObjectStreamField[] newFieldList = new ObjectStreamField[exportedFields.length + fields.length];\n-\tint i, j, k;\n-\n-\t/* We now check the import fields against the exported fields.\n-\t * There should not be contradiction (e.g. int x and String x)\n-\t * but extra virtual fields can be added to the class.\n-\t */\n-\n-\tArrays.sort(exportedFields);\n-\n-\ti = 0; j = 0; k = 0;\n-\twhile (i < fields.length && j < exportedFields.length)\n-\t  {\n-\t    int comp = fields[i].compareTo(exportedFields[j]);\n-\n-\t    if (comp < 0)\n-\t      {\n-\t\tnewFieldList[k] = fields[i];\n-\t\tfields[i].setPersistent(false);\n-\t\tfields[i].setToSet(false);\n-\t\ti++;\n-\t      }\n-\t    else if (comp > 0)\n-\t      {\n-\t\t/* field not found in imported fields. We add it\n-\t\t * in the list of supported fields.\n-\t\t */\n-\t\tnewFieldList[k] = exportedFields[j];\n-\t\tnewFieldList[k].setPersistent(true);\n-\t\tnewFieldList[k].setToSet(false);\n-\t\ttry\n-\t\t  {\n-\t\t    newFieldList[k].lookupField(clazz);\n-\t\t    newFieldList[k].checkFieldType();\n-\t\t  }\n-\t\tcatch (NoSuchFieldException _)\n-\t\t  {\n-\t\t  }\n-\t\tj++;\n-\t      }\n-\t    else\n-\t      {\n-\t\ttry\n-\t\t  {\n-\t\t    exportedFields[j].lookupField(clazz);\n-\t\t    exportedFields[j].checkFieldType();\n-\t\t  }\n-\t\tcatch (NoSuchFieldException _)\n-\t\t  {\n-\t\t  }\n-\n-\t\tif (!fields[i].getType().equals(exportedFields[j].getType()))\n-\t\t  throw new InvalidClassException\n-\t\t    (\"serialPersistentFields must be compatible with\" +\n-\t\t     \" imported fields (about \" + fields[i].getName() + \")\");\n-\t\tnewFieldList[k] = fields[i];\n-\t\tfields[i].setPersistent(true);\n-\t\ti++;\n-\t\tj++;\n-\t      }\n-\t    k++;\n-\t  }\n-\n-\tif (i < fields.length)\n-\t  for (;i<fields.length;i++,k++)\n-\t    {\n-\t      fields[i].setPersistent(false);\n-\t      fields[i].setToSet(false);\n-\t      newFieldList[k] = fields[i];\n-\t    }\n-\telse\n-\t  if (j < exportedFields.length)\n-\t    for (;j<exportedFields.length;j++,k++)\n-\t      {\n-\t\texportedFields[j].setPersistent(true);\n-\t\texportedFields[j].setToSet(false);\n-\t\tnewFieldList[k] = exportedFields[j];\n-\t      }\n-\t\n-\tfields = new ObjectStreamField[k];\n-\tSystem.arraycopy(newFieldList, 0, fields, 0, k);\n-      }\n-    catch (NoSuchFieldException ignore)\n-      {\n-\treturn;\n-      }\n-    catch (IllegalAccessException ignore)\n-      {\n-\treturn;\n-      }\n-  }\n-\n-  void setSuperclass (ObjectStreamClass osc)\n-  {\n-    superClass = osc;\n-  }\n-\n-  void calculateOffsets()\n-  {\n-    int i;\n-    ObjectStreamField field;\n-    primFieldSize = 0;\n-    int fcount = fields.length;\n-    for (i = 0; i < fcount; ++ i)\n-      {\n-\tfield = fields[i];\n-\n-\tif (! field.isPrimitive())\n-\t  break;\n-\n-\tfield.setOffset(primFieldSize);\n-\tswitch (field.getTypeCode())\n-\t  {\n-\t  case 'B':\n-\t  case 'Z':\n-\t    ++ primFieldSize;\n-\t    break;\n-\t  case 'C':\n-\t  case 'S':\n-\t    primFieldSize += 2;\n-\t    break;\n-\t  case 'I':\n-\t  case 'F':\n-\t    primFieldSize += 4;\n-\t    break;\n-\t  case 'D':\n-\t  case 'J':\n-\t    primFieldSize += 8;\n-\t    break;\n-\t  }\n-      }\n-\n-    for (objectFieldCount = 0; i < fcount; ++ i)\n-      fields[i].setOffset(objectFieldCount++);\n-  }\n-\n-  private Method findMethod(Method[] methods, String name, Class[] params,\n-\t\t\t    Class returnType, boolean mustBePrivate)\n-  {\n-outer:\n-    for (int i = 0; i < methods.length; i++)\n-    {\n-\tfinal Method m = methods[i];\n-        int mods = m.getModifiers();\n-        if (Modifier.isStatic(mods)\n-            || (mustBePrivate && !Modifier.isPrivate(mods)))\n-        {\n-            continue;\n-        }\n-\n-\tif (m.getName().equals(name)\n-\t   && m.getReturnType() == returnType)\n-\t{\n-\t    Class[] mp = m.getParameterTypes();\n-\t    if (mp.length == params.length)\n-\t    {\n-\t\tfor (int j = 0; j < mp.length; j++)\n-\t\t{\n-\t\t    if (mp[j] != params[j])\n-\t\t    {\n-\t\t\tcontinue outer;\n-\t\t    }\n-\t\t}\n-\t\tAccessController.doPrivileged(new SetAccessibleAction(m));\n-\t\treturn m;\n-\t    }\n-\t}\n-    }\n-    return null;\n-  }\n-\n-  private static boolean inSamePackage(Class c1, Class c2)\n-  {\n-    String name1 = c1.getName();\n-    String name2 = c2.getName();\n-\n-    int id1 = name1.lastIndexOf('.');\n-    int id2 = name2.lastIndexOf('.');\n-\n-    // Handle the default package\n-    if (id1 == -1 || id2 == -1)\n-      return id1 == id2;\n-\n-    String package1 = name1.substring(0, id1);\n-    String package2 = name2.substring(0, id2);\n-\n-    return package1.equals(package2);\n-  }\n-\n-  final static Class[] noArgs = new Class[0];\n-\n-  private static Method findAccessibleMethod(String name, Class from)\n-  {\n-    for (Class c = from; c != null; c = c.getSuperclass())\n-      {\n-\ttry\n-\t  {\n-\t    Method res = c.getDeclaredMethod(name, noArgs);\n-\t    int mods = res.getModifiers();\n-\t    \n-\t    if (c == from  \n-\t\t|| Modifier.isProtected(mods)\n-\t\t|| Modifier.isPublic(mods)\n-\t\t|| (! Modifier.isPrivate(mods) && inSamePackage(c, from)))\n-\t      {\n-\t\tAccessController.doPrivileged(new SetAccessibleAction(res));\n-\t\treturn res;\n-\t      }\n-\t  }\n-\tcatch (NoSuchMethodException e)\n-\t  {\n-\t  }\n-      }\n-\n-    return null;\n-  }\n-\n-  private void cacheMethods()\n-  {\n-    Method[] methods = forClass().getDeclaredMethods();\n-\n-    readObjectMethod = findMethod(methods, \"readObject\",\n-\t\t\t\t  new Class[] { ObjectInputStream.class },\n-\t\t\t\t  Void.TYPE, true);\n-    writeObjectMethod = findMethod(methods, \"writeObject\",\n-                                   new Class[] { ObjectOutputStream.class },\n-                                   Void.TYPE, true);\n-\n-    // readResolve and writeReplace can be in parent classes, as long as they\n-    // are accessible from this class.\n-    readResolveMethod = findAccessibleMethod(\"readResolve\", forClass());\n-    writeReplaceMethod = findAccessibleMethod(\"writeReplace\", forClass());\n-  }\n-\n-  private ObjectStreamClass(Class cl)\n-  {\n-    uid = 0;\n-    flags = 0;\n-    isProxyClass = Proxy.isProxyClass(cl);\n-\n-    clazz = cl;\n-    cacheMethods();\n-    name = cl.getName();\n-    setFlags(cl);\n-    setFields(cl);\n-    // to those class nonserializable, its uid field is 0\n-    if ( (Serializable.class).isAssignableFrom(cl) && !isProxyClass)\n-      uid = getClassUID(cl);\n-    superClass = lookup(cl.getSuperclass());\n-  }\n-\n-\n-  // Sets bits in flags according to features of CL.\n-  private void setFlags(Class cl)\n-  {\n-    if ((java.io.Externalizable.class).isAssignableFrom(cl))\n-      flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;\n-    else if ((java.io.Serializable.class).isAssignableFrom(cl))\n-      // only set this bit if CL is NOT Externalizable\n-      flags |= ObjectStreamConstants.SC_SERIALIZABLE;\n-\n-    if (writeObjectMethod != null)\n-      flags |= ObjectStreamConstants.SC_WRITE_METHOD;\n-  }\n-\n-\n-  // Sets fields to be a sorted array of the serializable fields of\n-  // clazz.\n-  private void setFields(Class cl)\n-  {\n-    SetAccessibleAction setAccessible = new SetAccessibleAction();\n-\n-    if (!isSerializable() || isExternalizable())\n-      {\n-\tfields = NO_FIELDS;\n-\treturn;\n-      }\n-\n-    try\n-      {\n-\tfinal Field f =\n-\t  cl.getDeclaredField(\"serialPersistentFields\");\n-\tsetAccessible.setMember(f);\n-\tAccessController.doPrivileged(setAccessible);\n-\tint modifiers = f.getModifiers();\n-\n-\tif (Modifier.isStatic(modifiers)\n-\t    && Modifier.isFinal(modifiers)\n-\t    && Modifier.isPrivate(modifiers))\n-\t  {\n-\t    fields = getSerialPersistentFields(cl);\n-\t    if (fields != null)\n-\t      {\n-\t\tArrays.sort (fields);\n-\t\t// Retrieve field reference.\n-\t\tfor (int i=0; i < fields.length; i++)\n-\t\t  {\n-\t\t    try\n-\t\t      {\n-\t\t\tfields[i].lookupField(cl);\n-\t\t      }\n-\t\t    catch (NoSuchFieldException _)\n-\t\t      {\n-\t\t\tfields[i].setToSet(false);\n-\t\t      }\n-\t\t  }\n-\t\t\n-\t\tcalculateOffsets();\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n-    catch (NoSuchFieldException ignore)\n-      {\n-      }\n-    catch (IllegalAccessException ignore)\n-      {\n-      }\n-\n-    int num_good_fields = 0;\n-    Field[] all_fields = cl.getDeclaredFields();\n-\n-    int modifiers;\n-    // set non-serializable fields to null in all_fields\n-    for (int i = 0; i < all_fields.length; i++)\n-      {\n-\tmodifiers = all_fields[i].getModifiers();\n-\tif (Modifier.isTransient(modifiers)\n-\t    || Modifier.isStatic(modifiers))\n-\t  all_fields[i] = null;\n-\telse\n-\t  num_good_fields++;\n-      }\n-\n-    // make a copy of serializable (non-null) fields\n-    fields = new ObjectStreamField[ num_good_fields ];\n-    for (int from = 0, to = 0; from < all_fields.length; from++)\n-      if (all_fields[from] != null)\n-\t{\n-\t  final Field f = all_fields[from];\n-\t  setAccessible.setMember(f);\n-\t  AccessController.doPrivileged(setAccessible);\n-\t  fields[to] = new ObjectStreamField(all_fields[from]);\n-\t  to++;\n-\t}\n-\n-    Arrays.sort(fields);\n-    // Make sure we don't have any duplicate field names\n-    // (Sun JDK 1.4.1. throws an Internal Error as well)\n-    for (int i = 1; i < fields.length; i++)\n-      {\n-\tif(fields[i - 1].getName().equals(fields[i].getName()))\n-\t    throw new InternalError(\"Duplicate field \" + \n-\t\t\tfields[i].getName() + \" in class \" + cl.getName());\n-      }\n-    calculateOffsets();\n-  }\n-\n-  // Returns the serial version UID defined by class, or if that\n-  // isn't present, calculates value of serial version UID.\n-  private long getClassUID(Class cl)\n-  {\n-    try\n-      {\n-\t// Use getDeclaredField rather than getField, since serialVersionUID\n-\t// may not be public AND we only want the serialVersionUID of this\n-\t// class, not a superclass or interface.\n-\tfinal Field suid = cl.getDeclaredField(\"serialVersionUID\");\n-\tSetAccessibleAction setAccessible = new SetAccessibleAction(suid);\n-\tAccessController.doPrivileged(setAccessible);\n-\tint modifiers = suid.getModifiers();\n-\n-\tif (Modifier.isStatic(modifiers)\n-\t    && Modifier.isFinal(modifiers)\n-\t    && suid.getType() == Long.TYPE)\n-\t  return suid.getLong(null);\n-      }\n-    catch (NoSuchFieldException ignore)\n-      {\n-      }\n-    catch (IllegalAccessException ignore)\n-      {\n-      }\n-\n-    // cl didn't define serialVersionUID, so we have to compute it\n-    try\n-      {\n-\tMessageDigest md;\n-\ttry \n-\t  {\n-\t    md = MessageDigest.getInstance(\"SHA\");\n-\t  }\n-\tcatch (NoSuchAlgorithmException e)\n-\t  {\n-\t    // If a provider already provides SHA, use it; otherwise, use this.\n-\t    Gnu gnuProvider = new Gnu();\n-\t    Security.addProvider(gnuProvider);\n-\t    md = MessageDigest.getInstance(\"SHA\");\n-\t  }\n-\n-\tDigestOutputStream digest_out =\n-\t  new DigestOutputStream(nullOutputStream, md);\n-\tDataOutputStream data_out = new DataOutputStream(digest_out);\n-\n-\tdata_out.writeUTF(cl.getName());\n-\n-\tint modifiers = cl.getModifiers();\n-\t// just look at interesting bits\n-\tmodifiers = modifiers & (Modifier.ABSTRACT | Modifier.FINAL\n-\t\t\t\t | Modifier.INTERFACE | Modifier.PUBLIC);\n-\tdata_out.writeInt(modifiers);\n-\n-\t// Pretend that an array has no interfaces, because when array\n-\t// serialization was defined (JDK 1.1), arrays didn't have it.\n-\tif (! cl.isArray())\n-\t  {\n-\t    Class[] interfaces = cl.getInterfaces();\n-\t    Arrays.sort(interfaces, interfaceComparator);\n-\t    for (int i = 0; i < interfaces.length; i++)\n-\t      data_out.writeUTF(interfaces[i].getName());\n-\t  }\n-\n-\tField field;\n-\tField[] fields = cl.getDeclaredFields();\n-\tArrays.sort(fields, memberComparator);\n-\tfor (int i = 0; i < fields.length; i++)\n-\t  {\n-\t    field = fields[i];\n-\t    modifiers = field.getModifiers();\n-\t    if (Modifier.isPrivate(modifiers)\n-\t\t&& (Modifier.isStatic(modifiers)\n-\t\t    || Modifier.isTransient(modifiers)))\n-\t      continue;\n-\n-\t    data_out.writeUTF(field.getName());\n-\t    data_out.writeInt(modifiers);\n-\t    data_out.writeUTF(TypeSignature.getEncodingOfClass (field.getType()));\n-\t  }\n-\n-\t// write class initializer method if present\n-\tif (VMObjectStreamClass.hasClassInitializer(cl))\n-\t  {\n-\t    data_out.writeUTF(\"<clinit>\");\n-\t    data_out.writeInt(Modifier.STATIC);\n-\t    data_out.writeUTF(\"()V\");\n-\t  }\n-\n-\tConstructor constructor;\n-\tConstructor[] constructors = cl.getDeclaredConstructors();\n-\tArrays.sort (constructors, memberComparator);\n-\tfor (int i = 0; i < constructors.length; i++)\n-\t  {\n-\t    constructor = constructors[i];\n-\t    modifiers = constructor.getModifiers();\n-\t    if (Modifier.isPrivate(modifiers))\n-\t      continue;\n-\n-\t    data_out.writeUTF(\"<init>\");\n-\t    data_out.writeInt(modifiers);\n-\n-\t    // the replacement of '/' with '.' was needed to make computed\n-\t    // SUID's agree with those computed by JDK\n-\t    data_out.writeUTF \n-\t      (TypeSignature.getEncodingOfConstructor(constructor).replace('/','.'));\n-\t  }\n-\n-\tMethod method;\n-\tMethod[] methods = cl.getDeclaredMethods();\n-\tArrays.sort(methods, memberComparator);\n-\tfor (int i = 0; i < methods.length; i++)\n-\t  {\n-\t    method = methods[i];\n-\t    modifiers = method.getModifiers();\n-\t    if (Modifier.isPrivate(modifiers))\n-\t      continue;\n-\n-\t    data_out.writeUTF(method.getName());\n-\t    data_out.writeInt(modifiers);\n-\n-\t    // the replacement of '/' with '.' was needed to make computed\n-\t    // SUID's agree with those computed by JDK\n-\t    data_out.writeUTF\n-\t      (TypeSignature.getEncodingOfMethod(method).replace('/', '.'));\n-\t  }\n-\n-\tdata_out.close();\n-\tbyte[] sha = md.digest();\n-\tlong result = 0;\n-\tint len = sha.length < 8 ? sha.length : 8;\n-\tfor (int i = 0; i < len; i++)\n-\t  result += (long) (sha[i] & 0xFF) << (8 * i);\n-\n-\treturn result;\n-      }\n-    catch (NoSuchAlgorithmException e)\n-      {\n-\tthrow new RuntimeException\n-\t  (\"The SHA algorithm was not found to use in computing the Serial Version UID for class \"\n-\t   + cl.getName(), e);\n-      }\n-    catch (IOException ioe)\n-      {\n-\tthrow new RuntimeException(ioe);\n-      }\n-  }\n-\n-  /**\n-   * Returns the value of CLAZZ's private static final field named\n-   * `serialPersistentFields'. It performs some sanity checks before\n-   * returning the real array. Besides, the returned array is a clean\n-   * copy of the original. So it can be modified.\n-   *\n-   * @param clazz Class to retrieve 'serialPersistentFields' from.\n-   * @return The content of 'serialPersistentFields'.\n-   */\n-  private ObjectStreamField[] getSerialPersistentFields(Class clazz) \n-    throws NoSuchFieldException, IllegalAccessException\n-  {\n-    ObjectStreamField[] fieldsArray = null;\n-    ObjectStreamField[] o;\n-\n-    // Use getDeclaredField rather than getField for the same reason\n-    // as above in getDefinedSUID.\n-    Field f = clazz.getDeclaredField(\"serialPersistentFields\");\n-    f.setAccessible(true);\n-\n-    int modifiers = f.getModifiers();\n-    if (!(Modifier.isStatic(modifiers) &&\n-\t  Modifier.isFinal(modifiers) &&\n-\t  Modifier.isPrivate(modifiers)))\n-      return null;\n-    \n-    o = (ObjectStreamField[]) f.get(null);\n-    \n-    if (o == null)\n-      return null;\n-\n-    fieldsArray = new ObjectStreamField[ o.length ];\n-    System.arraycopy(o, 0, fieldsArray, 0, o.length);\n-\n-    return fieldsArray;\n-  }\n-\n-  /**\n-   * Returns a new instance of the Class this ObjectStreamClass corresponds\n-   * to.\n-   * Note that this should only be used for Externalizable classes.\n-   *\n-   * @return A new instance.\n-   */\n-  Externalizable newInstance() throws InvalidClassException\n-  {\n-    synchronized(this)\n-    {\n-\tif (constructor == null)\n-\t{\n-\t    try\n-\t    {\n-\t\tfinal Constructor c = clazz.getConstructor(new Class[0]);\n-\n-\t\tAccessController.doPrivileged(new PrivilegedAction()\n-\t\t{\n-\t\t    public Object run()\n-\t\t    {\n-\t\t\tc.setAccessible(true);\n-\t\t\treturn null;\n-\t\t    }\n-\t\t});\n-\n-\t\tconstructor = c;\n-\t    }\n-\t    catch(NoSuchMethodException x)\n-\t    {\n-\t\tthrow new InvalidClassException(clazz.getName(),\n-\t\t    \"No public zero-argument constructor\");\n-\t    }\n-\t}\n-    }\n-\n-    try\n-    {\n-\treturn (Externalizable)constructor.newInstance(null);\n-    }\n-    catch(Exception x)\n-    {\n-\tthrow (InvalidClassException)\n-\t    new InvalidClassException(clazz.getName(),\n-\t\t     \"Unable to instantiate\").initCause(x);\n-    }\n-  }\n-\n-  public static final ObjectStreamField[] NO_FIELDS = {};\n-\n-  private static Hashtable classLookupTable = new Hashtable();\n-  private static final NullOutputStream nullOutputStream = new NullOutputStream();\n-  private static final Comparator interfaceComparator = new InterfaceComparator();\n-  private static final Comparator memberComparator = new MemberComparator();\n-  private static final\n-    Class[] writeMethodArgTypes = { java.io.ObjectOutputStream.class };\n-\n-  private ObjectStreamClass superClass;\n-  private Class clazz;\n-  private String name;\n-  private long uid;\n-  private byte flags;\n-\n-  // this field is package protected so that ObjectInputStream and\n-  // ObjectOutputStream can access it directly\n-  ObjectStreamField[] fields;\n-\n-  // these are accessed by ObjectIn/OutputStream\n-  int primFieldSize = -1;  // -1 if not yet calculated\n-  int objectFieldCount;\n-\n-  Method readObjectMethod;\n-  Method readResolveMethod;\n-  Method writeReplaceMethod;\n-  Method writeObjectMethod;\n-  boolean realClassIsSerializable;\n-  boolean realClassIsExternalizable;\n-  ObjectStreamField[] fieldMapping;\n-  Constructor firstNonSerializableParentConstructor;\n-  private Constructor constructor;  // default constructor for Externalizable\n-\n-  boolean isProxyClass = false;\n-\n-  // This is probably not necessary because this class is special cased already\n-  // but it will avoid showing up as a discrepancy when comparing SUIDs.\n-  private static final long serialVersionUID = -6120832682080437368L;\n-\n-\n-  // interfaces are compared only by name\n-  private static final class InterfaceComparator implements Comparator\n-  {\n-    public int compare(Object o1, Object o2)\n-    {\n-      return ((Class) o1).getName().compareTo(((Class) o2).getName());\n-    }\n-  }\n-\n-\n-  // Members (Methods and Constructors) are compared first by name,\n-  // conflicts are resolved by comparing type signatures\n-  private static final class MemberComparator implements Comparator\n-  {\n-    public int compare(Object o1, Object o2)\n-    {\n-      Member m1 = (Member) o1;\n-      Member m2 = (Member) o2;\n-\n-      int comp = m1.getName().compareTo(m2.getName());\n-\n-      if (comp == 0)\n-        return TypeSignature.getEncodingOfMember(m1).\n-\t  compareTo(TypeSignature.getEncodingOfMember(m2));\n-      else\n-        return comp;\n-    }\n-  }\n-}"}, {"sha": "146c67e2120bf8b5c6f70e88fbc7d7c8fea4291c", "filename": "libjava/sources.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8656214b84c3e789deffe8f7b465bd1c886b2a03/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=8656214b84c3e789deffe8f7b465bd1c886b2a03", "patch": "@@ -2748,7 +2748,7 @@ java/io/ObjectInputStream.java \\\n classpath/java/io/ObjectInputValidation.java \\\n classpath/java/io/ObjectOutput.java \\\n classpath/java/io/ObjectOutputStream.java \\\n-java/io/ObjectStreamClass.java \\\n+classpath/java/io/ObjectStreamClass.java \\\n classpath/java/io/ObjectStreamConstants.java \\\n classpath/java/io/ObjectStreamException.java \\\n classpath/java/io/ObjectStreamField.java \\"}]}