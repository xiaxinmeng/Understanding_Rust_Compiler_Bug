{"sha": "7e2e8179ee0887e17549cde85e47b92d1164d6eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyZTgxNzllZTA4ODdlMTc1NDljZGU4NWU0N2I5MmQxMTY0ZDZlYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-08-04T06:32:01Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-04T06:32:01Z"}, "message": "re PR c++/13596 (value of __cplusplus)\n\n\tPR 13596\n\t* dbxout.c (dbx_output_lbrac, dbx_output_rbrac): New\n\tfunctions, broken out of dbxout_block.\n\t(dbxout_block): The block at depth 0 should get LBRAC/RBRAC\n\tstabs too, if it contains symbols.  Use the begin_label and\n\tthe Lscope label (emitted by dbxout_function_end) for the\n\trange of this block.\n\nFrom-SVN: r85544", "tree": {"sha": "3dd52337f3606374aad08d77be51f3f0a3275268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd52337f3606374aad08d77be51f3f0a3275268"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e2e8179ee0887e17549cde85e47b92d1164d6eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2e8179ee0887e17549cde85e47b92d1164d6eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2e8179ee0887e17549cde85e47b92d1164d6eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2e8179ee0887e17549cde85e47b92d1164d6eb/comments", "author": null, "committer": null, "parents": [{"sha": "73a8adb62e1609c94e21903fe9c261b6d30a8415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a8adb62e1609c94e21903fe9c261b6d30a8415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a8adb62e1609c94e21903fe9c261b6d30a8415"}], "stats": {"total": 110, "additions": 76, "deletions": 34}, "files": [{"sha": "d4dde176ac56ded54489b1c0c2243113cc384edc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2e8179ee0887e17549cde85e47b92d1164d6eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2e8179ee0887e17549cde85e47b92d1164d6eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e2e8179ee0887e17549cde85e47b92d1164d6eb", "patch": "@@ -1,3 +1,13 @@\n+2004-08-03  Zack Weinberg  <zack@codesourcery.com>\n+\n+\tPR 13596\n+\t* dbxout.c (dbx_output_lbrac, dbx_output_rbrac): New\n+\tfunctions, broken out of dbxout_block.\n+\t(dbxout_block): The block at depth 0 should get LBRAC/RBRAC\n+\tstabs too, if it contains symbols.  Use the begin_label and\n+\tthe Lscope label (emitted by dbxout_function_end) for the\n+\trange of this block.\n+\n 2004-08-03  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* doc/install.texi: Update autoconf version requirements."}, {"sha": "81717577973c211f6bfefa81133c6e259b5eb73b", "filename": "gcc/dbxout.c", "status": "modified", "additions": 66, "deletions": 34, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2e8179ee0887e17549cde85e47b92d1164d6eb/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2e8179ee0887e17549cde85e47b92d1164d6eb/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=7e2e8179ee0887e17549cde85e47b92d1164d6eb", "patch": "@@ -3089,6 +3089,46 @@ dbxout_args (tree args)\n     }\n }\n \f\n+/* Subroutine of dbxout_block.  Emit an N_LBRAC stab referencing LABEL.\n+   BEGIN_LABEL is the name of the beginning of the function, which may\n+   be required.  */\n+static void\n+dbx_output_lbrac (const char *label,\n+\t\t  const char *begin_label ATTRIBUTE_UNUSED)\n+{\n+#ifdef DBX_OUTPUT_LBRAC\n+  DBX_OUTPUT_LBRAC (asmfile, label);\n+#else\n+  fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_LBRAC);\n+  assemble_name (asmfile, label);\n+#if DBX_BLOCKS_FUNCTION_RELATIVE\n+  putc ('-', asmfile);\n+  assemble_name (asmfile, begin_label);\n+#endif\n+  fprintf (asmfile, \"\\n\");\n+#endif\n+}\n+\n+/* Subroutine of dbxout_block.  Emit an N_RBRAC stab referencing LABEL.\n+   BEGIN_LABEL is the name of the beginning of the function, which may\n+   be required.  */\n+static void\n+dbx_output_rbrac (const char *label,\n+\t\t  const char *begin_label ATTRIBUTE_UNUSED)\n+{\n+#ifdef DBX_OUTPUT_RBRAC\n+  DBX_OUTPUT_RBRAC (asmfile, label);\n+#else\n+  fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_RBRAC);\n+  assemble_name (asmfile, label);\n+#if DBX_BLOCKS_FUNCTION_RELATIVE\n+  putc ('-', asmfile);\n+  assemble_name (asmfile, begin_label);\n+#endif\n+  fprintf (asmfile, \"\\n\");\n+#endif\n+}\n+\n /* Output everything about a symbol block (a BLOCK node\n    that represents a scope level),\n    including recursive output of contained blocks.\n@@ -3109,22 +3149,19 @@ dbxout_args (tree args)\n static void\n dbxout_block (tree block, int depth, tree args)\n {\n-  int blocknum = -1;\n-\n-#if DBX_BLOCKS_FUNCTION_RELATIVE\n   const char *begin_label;\n   if (current_function_func_begin_label != NULL_TREE)\n     begin_label = IDENTIFIER_POINTER (current_function_func_begin_label);\n   else\n     begin_label = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-#endif\n \n   while (block)\n     {\n       /* Ignore blocks never expanded or otherwise marked as real.  */\n       if (TREE_USED (block) && TREE_ASM_WRITTEN (block))\n \t{\n \t  int did_output;\n+\t  int blocknum = BLOCK_NUMBER (block);\n \n \t  /* In dbx format, the syms of a block come before the N_LBRAC.\n \t     If nothing is output, we don't need the N_LBRAC, either.  */\n@@ -3138,11 +3175,20 @@ dbxout_block (tree block, int depth, tree args)\n \t     the block.  Use the block's tree-walk order to generate\n \t     the assembler symbols LBBn and LBEn\n \t     that final will define around the code in this block.  */\n-\t  if (depth > 0 && did_output)\n+\t  if (did_output)\n \t    {\n \t      char buf[20];\n-\t      blocknum = BLOCK_NUMBER (block);\n-\t      ASM_GENERATE_INTERNAL_LABEL (buf, \"LBB\", blocknum);\n+\t      const char *scope_start;\n+\n+\t      if (depth == 0)\n+\t\t/* The outermost block doesn't get LBB labels; use\n+\t\t   the function symbol.  */\n+\t\tscope_start = begin_label;\n+\t      else\n+\t\t{\n+\t\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LBB\", blocknum);\n+\t\t  scope_start = buf;\n+\t\t}\n \n \t      if (BLOCK_HANDLER_BLOCK (block))\n \t\t{\n@@ -3152,44 +3198,30 @@ dbxout_block (tree block, int depth, tree args)\n \t\t    {\n \t\t      fprintf (asmfile, \"%s\\\"%s:C1\\\",%d,0,0,\", ASM_STABS_OP,\n \t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)), N_CATCH);\n-\t\t      assemble_name (asmfile, buf);\n+\t\t      assemble_name (asmfile, scope_start);\n \t\t      fprintf (asmfile, \"\\n\");\n \t\t      decl = TREE_CHAIN (decl);\n \t\t    }\n \t\t}\n-\n-#ifdef DBX_OUTPUT_LBRAC\n-\t      DBX_OUTPUT_LBRAC (asmfile, buf);\n-#else\n-\t      fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_LBRAC);\n-\t      assemble_name (asmfile, buf);\n-#if DBX_BLOCKS_FUNCTION_RELATIVE\n-\t      putc ('-', asmfile);\n-\t      assemble_name (asmfile, begin_label);\n-#endif\n-\t      fprintf (asmfile, \"\\n\");\n-#endif\n+\t      dbx_output_lbrac (scope_start, begin_label);\n \t    }\n \n \t  /* Output the subblocks.  */\n \t  dbxout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE);\n \n \t  /* Refer to the marker for the end of the block.  */\n-\t  if (depth > 0 && did_output)\n+\t  if (did_output)\n \t    {\n-\t      char buf[20];\n-\t      ASM_GENERATE_INTERNAL_LABEL (buf, \"LBE\", blocknum);\n-#ifdef DBX_OUTPUT_RBRAC\n-\t      DBX_OUTPUT_RBRAC (asmfile, buf);\n-#else\n-\t      fprintf (asmfile, \"%s%d,0,0,\", ASM_STABN_OP, N_RBRAC);\n-\t      assemble_name (asmfile, buf);\n-#if DBX_BLOCKS_FUNCTION_RELATIVE\n-\t      putc ('-', asmfile);\n-\t      assemble_name (asmfile, begin_label);\n-#endif\n-\t      fprintf (asmfile, \"\\n\");\n-#endif\n+\t      char buf[100];\n+\t      if (depth == 0)\n+\t\t/* The outermost block doesn't get LBE labels;\n+\t\t   use the \"scope\" label which will be emitted\n+\t\t   by dbxout_function_end.  */\n+\t\tASM_GENERATE_INTERNAL_LABEL (buf, \"Lscope\", scope_labelno);\n+\t      else\n+\t\tASM_GENERATE_INTERNAL_LABEL (buf, \"LBE\", blocknum);\n+\n+\t      dbx_output_rbrac (buf, begin_label);\n \t    }\n \t}\n       block = BLOCK_CHAIN (block);"}]}