{"sha": "7a2faca1c536095a4e3ae8053037fe16ac0e7a1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EyZmFjYTFjNTM2MDk1YTRlM2FlODA1MzAzN2ZlMTZhYzBlN2ExZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-05-29T19:25:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-05-29T19:25:04Z"}, "message": "tree-ssa-loop-ivopts.c (strip_offset_1): New case.\n\n\t* tree-ssa-loop-ivopts.c (strip_offset_1) <MULT_EXPR>: New case.\n\t(force_expr_to_var_cost) <NEGATE_EXPR>: Likewise.\n\t(ptr_difference_cost): Use affine combinations to compute it.\n\t(difference_cost): Likewise.\n\t(get_computation_cost_at): Compute more accurate cost for addresses\n\tif the ratio is a multiplier allowed in addresses.\n\tFor non-addresses, consider that an additional offset or symbol is\n\tadded only once.\n\nFrom-SVN: r147983", "tree": {"sha": "2496740da7e93cadcd742ae6fd22de5ca45680d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2496740da7e93cadcd742ae6fd22de5ca45680d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f/comments", "author": null, "committer": null, "parents": [{"sha": "a0987204c590c4ae170268eb4e17c07925bb456c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0987204c590c4ae170268eb4e17c07925bb456c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0987204c590c4ae170268eb4e17c07925bb456c"}], "stats": {"total": 132, "additions": 97, "deletions": 35}, "files": [{"sha": "8315daca48be14e55b9b7beb77501d24e91debad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a2faca1c536095a4e3ae8053037fe16ac0e7a1f", "patch": "@@ -1,3 +1,14 @@\n+2009-05-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-ssa-loop-ivopts.c (strip_offset_1) <MULT_EXPR>: New case.\n+\t(force_expr_to_var_cost) <NEGATE_EXPR>: Likewise.\n+\t(ptr_difference_cost): Use affine combinations to compute it.\n+\t(difference_cost): Likewise.\n+\t(get_computation_cost_at): Compute more accurate cost for addresses\n+\tif the ratio is a multiplier allowed in addresses.\n+\tFor non-addresses, consider that an additional offset or symbol is\n+\tadded only once.\n+\n 2009-05-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_decompose_address): Avoid useless"}, {"sha": "00cc18fd15977ecb71d3a0c4885d30f76dbd21be", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 86, "deletions": 35, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a2faca1c536095a4e3ae8053037fe16ac0e7a1f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=7a2faca1c536095a4e3ae8053037fe16ac0e7a1f", "patch": "@@ -1922,6 +1922,24 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n \n       return fold_convert (orig_type, expr);\n \n+    case MULT_EXPR:\n+      op1 = TREE_OPERAND (expr, 1);\n+      if (!cst_and_fits_in_hwi (op1))\n+\treturn orig_expr;\n+\n+      op0 = TREE_OPERAND (expr, 0);\n+      op0 = strip_offset_1 (op0, false, false, &off0);\n+      if (op0 == TREE_OPERAND (expr, 0))\n+\treturn orig_expr;\n+\n+      *offset = off0 * int_cst_value (op1);\n+      if (integer_zerop (op0))\n+\texpr = op0;\n+      else\n+\texpr = fold_build2 (MULT_EXPR, type, op0, op1);\n+\n+      return fold_convert (orig_type, expr);\n+\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n       if (!inside_addr)\n@@ -3302,6 +3320,19 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n       break;\n \n+    case NEGATE_EXPR:\n+      op0 = TREE_OPERAND (expr, 0);\n+      STRIP_NOPS (op0);\n+      op1 = NULL_TREE;\n+\n+      if (is_gimple_val (op0))\n+\tcost0 = zero_cost;\n+      else\n+\tcost0 = force_expr_to_var_cost (op0, speed);\n+\n+      cost1 = zero_cost;\n+      break;\n+\n     default:\n       /* Just an arbitrary value, FIXME.  */\n       return new_cost (target_spill_cost[speed], 0);\n@@ -3313,6 +3344,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n+    case NEGATE_EXPR:\n       cost = new_cost (add_cost (mode, speed), 0);\n       break;\n \n@@ -3415,8 +3447,8 @@ ptr_difference_cost (struct ivopts_data *data,\n \t\t     unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n {\n   HOST_WIDE_INT diff = 0;\n-  comp_cost cost;\n-  bool speed = optimize_loop_for_speed_p (data->current_loop);\n+  aff_tree aff_e1, aff_e2;\n+  tree type;\n \n   gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n \n@@ -3434,12 +3466,14 @@ ptr_difference_cost (struct ivopts_data *data,\n \n   *symbol_present = false;\n   *var_present = true;\n-  \n-  cost = force_var_cost (data, e1, depends_on);\n-  cost = add_costs (cost, force_var_cost (data, e2, depends_on));\n-  cost.cost += add_cost (Pmode, speed);\n \n-  return cost;\n+  type = signed_type_for (TREE_TYPE (e1));\n+  tree_to_aff_combination (e1, type, &aff_e1);\n+  tree_to_aff_combination (e2, type, &aff_e2);\n+  aff_combination_scale (&aff_e2, double_int_minus_one);\n+  aff_combination_add (&aff_e1, &aff_e2);\n+\n+  return force_var_cost (data, aff_combination_to_tree (&aff_e1), depends_on);\n }\n \n /* Estimates cost of expressing difference E1 - E2 as\n@@ -3453,9 +3487,10 @@ difference_cost (struct ivopts_data *data,\n \t\t tree e1, tree e2, bool *symbol_present, bool *var_present,\n \t\t unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n {\n-  comp_cost cost;\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (e1));\n   unsigned HOST_WIDE_INT off1, off2;\n+  aff_tree aff_e1, aff_e2;\n+  tree type;\n \n   e1 = strip_offset (e1, &off1);\n   e2 = strip_offset (e2, &off2);\n@@ -3465,32 +3500,35 @@ difference_cost (struct ivopts_data *data,\n   STRIP_NOPS (e2);\n \n   if (TREE_CODE (e1) == ADDR_EXPR)\n-    return ptr_difference_cost (data, e1, e2, symbol_present, var_present, offset,\n-\t\t\t\tdepends_on);\n+    return ptr_difference_cost (data, e1, e2, symbol_present, var_present,\n+\t\t\t\toffset, depends_on);\n   *symbol_present = false;\n \n   if (operand_equal_p (e1, e2, 0))\n     {\n       *var_present = false;\n       return zero_cost;\n     }\n+\n   *var_present = true;\n+\n   if (integer_zerop (e2))\n     return force_var_cost (data, e1, depends_on);\n \n   if (integer_zerop (e1))\n     {\n-      cost = force_var_cost (data, e2, depends_on);\n+      comp_cost cost = force_var_cost (data, e2, depends_on);\n       cost.cost += multiply_by_cost (-1, mode, data->speed);\n-\n       return cost;\n     }\n \n-  cost = force_var_cost (data, e1, depends_on);\n-  cost = add_costs (cost, force_var_cost (data, e2, depends_on));\n-  cost.cost += add_cost (mode, data->speed);\n+  type = signed_type_for (TREE_TYPE (e1));\n+  tree_to_aff_combination (e1, type, &aff_e1);\n+  tree_to_aff_combination (e2, type, &aff_e2);\n+  aff_combination_scale (&aff_e2, double_int_minus_one);\n+  aff_combination_add (&aff_e1, &aff_e2);\n \n-  return cost;\n+  return force_var_cost (data, aff_combination_to_tree (&aff_e1), depends_on);\n }\n \n /* Determines the cost of the computation by that USE is expressed\n@@ -3511,7 +3549,6 @@ get_computation_cost_at (struct ivopts_data *data,\n   HOST_WIDE_INT ratio, aratio;\n   bool var_present, symbol_present;\n   comp_cost cost;\n-  unsigned n_sums;\n   double_int rat;\n   bool speed = optimize_bb_for_speed_p (gimple_bb (at));\n \n@@ -3544,7 +3581,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \treturn infinite_cost;\n     }\n \n-  if (TYPE_PRECISION (utype) != TYPE_PRECISION (ctype))\n+  if (TYPE_PRECISION (utype) < TYPE_PRECISION (ctype))\n     {\n       /* TODO -- add direct handling of this case.  */\n       goto fallback;\n@@ -3569,6 +3606,9 @@ get_computation_cost_at (struct ivopts_data *data,\n   else\n     return infinite_cost;\n \n+  STRIP_NOPS (cbase);\n+  ctype = TREE_TYPE (cbase);\n+\n   /* use = ubase + ratio * (var - cbase).  If either cbase is a constant\n      or ratio == 1, it is better to handle this like\n      \n@@ -3591,6 +3631,18 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n     }\n+  else if (address_p\n+\t   && !POINTER_TYPE_P (ctype)\n+\t   && multiplier_allowed_in_address_p (ratio,\n+\t\t\t\t\t       TYPE_MODE (TREE_TYPE (utype))))\n+    {\n+      cbase\n+\t= fold_build2 (MULT_EXPR, ctype, cbase, build_int_cst (ctype, ratio));\n+      cost = difference_cost (data,\n+\t\t\t      ubase, cbase,\n+\t\t\t      &symbol_present, &var_present, &offset,\n+\t\t\t      depends_on);\n+    }\n   else\n     {\n       cost = force_var_cost (data, cbase, depends_on);\n@@ -3608,39 +3660,38 @@ get_computation_cost_at (struct ivopts_data *data,\n     offset -= ratio * cstepi;\n \n   /* Now the computation is in shape symbol + var1 + const + ratio * var2.\n-     (symbol/var/const parts may be omitted).  If we are looking for an address,\n-     find the cost of addressing this.  */\n+     (symbol/var1/const parts may be omitted).  If we are looking for an\n+     address, find the cost of addressing this.  */\n   if (address_p)\n-    return add_costs (cost, get_address_cost (symbol_present, var_present,\n-\t\t\t\toffset, ratio,\n-\t\t\t\tTYPE_MODE (TREE_TYPE (*use->op_p)), speed));\n+    return add_costs (cost,\n+\t\t      get_address_cost (symbol_present, var_present,\n+\t\t\t\t\toffset, ratio,\n+\t\t\t\t\tTYPE_MODE (TREE_TYPE (utype)), speed));\n \n   /* Otherwise estimate the costs for computing the expression.  */\n-  aratio = ratio > 0 ? ratio : -ratio;\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n \tcost.cost += multiply_by_cost (ratio, TYPE_MODE (ctype), speed);\n-\n       return cost;\n     }\n \n-  if (aratio != 1)\n-    cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype), speed);\n-\n-  n_sums = 1;\n-  if (var_present\n-      /* Symbol + offset should be compile-time computable.  */\n-      && (symbol_present || offset))\n-    n_sums++;\n+  /* Symbol + offset should be compile-time computable so consider that they\n+      are added once to the variable, if present.  */\n+  if (var_present && (symbol_present || offset))\n+    cost.cost += add_cost (TYPE_MODE (ctype), speed)\n+\t\t / AVG_LOOP_NITER (data->current_loop);\n \n   /* Having offset does not affect runtime cost in case it is added to\n      symbol, but it increases complexity.  */\n   if (offset)\n     cost.complexity++;\n \n-  cost.cost += n_sums * add_cost (TYPE_MODE (ctype), speed);\n-  return cost;\n+  cost.cost += add_cost (TYPE_MODE (ctype), speed);\n+\n+  aratio = ratio > 0 ? ratio : -ratio;\n+  if (aratio != 1)\n+    cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype), speed);\n \n fallback:\n   {"}]}