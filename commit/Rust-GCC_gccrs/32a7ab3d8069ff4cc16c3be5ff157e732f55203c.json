{"sha": "32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhN2FiM2Q4MDY5ZmY0Y2MxNmMzYmU1ZmYxNTdlNzMyZjU1MjAzYw==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-06-08T06:59:55Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-06-08T06:59:55Z"}, "message": "constraints.md: New file.\n\n\t* config/sh/constraints.md: New file.\n\t* config/sh/sh.c: Include tm-constrs.h.\n\t(reg_class_from_letter): Remove.\n\t(prepare_cbranch_operands): Use satisfies_constraint_*\n\tfunction instead of macro.\n\t(andcosts, broken_move, sh_secondary_reload): Likewise.\n\t* config/sh/predicates.md (trapping_target_operand): Likewise.\n\t(and_operand, arith_operand, arith_reg_or_0_operand,\n\tcmp_operand, logical_operand, target_operand,\n\tua_address_operand, ua_offset, xor_operand): Likewise.\n\t* config/sh/sh.md: Include constraints.md.\n\t(*movsicc_t_false): Use satisfies_constraint_* function\n\tinstead of macro.\n\t(*movsicc_t_true, ashlsi3_std, ashlhi3_k, lshrsi3_m,\n\tlshrsi3_k, movsi_const_16bit+2, *movhi_media+1,\n\tmovdi_const_16bit+1, beq, bne, *ptb): Likewise.\n\t* config/sh/sh.h (reg_class_from_letter): Remove prototype.\n\t(OVERRIDE_OPTIONS): Don't modify reg_class_from_letter.\n\t(REG_CLASS_FROM_CONSTRAINT): Remove.\n\t(CONSTRAINT_LEN, CONST_OK_FOR_I20, CONST_OK_FOR_I,\n\tCONST_OK_FOR_J, CONST_OK_FOR_K16, CONST_OK_FOR_K,\n\tCONST_OK_FOR_P27, CONST_OK_FOR_P, CONST_OK_FOR_M,\n\tCONST_OK_FOR_N, CONST_OK_FOR_CONSTRAINT_P,\n\tCONST_DOUBLE_OK_FOR_LETTER_P): Likewise.\n\t(SECONDARY_INOUT_RELOAD_CLASS): Use satisfies_constraint_*\n\tfunction instead of macro.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Likewise.\n\t(EXTRA_CONSTRAINT_Q, EXTRA_CONSTRAINT_A,\n\tEXTRA_CONSTRAINT_Bsc, EXTRA_CONSTRAINT_B,\n\tEXTRA_CONSTRAINT_Css, EXTRA_CONSTRAINT_Csu): Remove.\n\t(IS_PC_RELATIVE_LOAD_ADDR_P): New macro.\n\t(IS_LITERAL_OR_SYMBOLIC_S16_P): Likewise.\n\t(IS_LITERAL_OR_SYMBOLIC_U16_P): Likewise.\n\t(IS_NON_EXPLICIT_CONSTANT_P): Likewise.\n\t(EXTRA_CONSTRAINT_Csy, EXTRA_CONSTRAINT_Z, EXTRA_CONSTRAINT_W,\n\tEXTRA_CONSTRAINT_Cpg, EXTRA_CONSTRAINT_C,\n\tEXTRA_MEMORY_CONSTRAINT, EXTRA_CONSTRAINT_Sr0,\n\tEXTRA_CONSTRAINT_Sua, EXTRA_CONSTRAINT_S,\n\tEXTRA_CONSTRAINT_STR): Likewise.\n\t(GO_IF_LEGITIMATE_INDEX): Fix indentation.\n\nFrom-SVN: r125561", "tree": {"sha": "0fc73f60f46085b4ba8622b8fb6cb6fc7d5e1254", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fc73f60f46085b4ba8622b8fb6cb6fc7d5e1254"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/comments", "author": null, "committer": null, "parents": [{"sha": "a88a266ccad495e5bb45d510076eea36fe3feaa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a88a266ccad495e5bb45d510076eea36fe3feaa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a88a266ccad495e5bb45d510076eea36fe3feaa1"}], "stats": {"total": 612, "additions": 339, "deletions": 273}, "files": [{"sha": "ccf4318a3933506cef3e8b81efadac7e080ba543", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "patch": "@@ -1,3 +1,46 @@\n+2007-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/constraints.md: New file.\n+\t* config/sh/sh.c: Include tm-constrs.h.\n+\t(reg_class_from_letter): Remove.\n+\t(prepare_cbranch_operands): Use satisfies_constraint_*\n+\tfunction instead of macro.\n+\t(andcosts, broken_move, sh_secondary_reload): Likewise.\n+\t* config/sh/predicates.md (trapping_target_operand): Likewise.\n+\t(and_operand, arith_operand, arith_reg_or_0_operand,\n+\tcmp_operand, logical_operand, target_operand,\n+\tua_address_operand, ua_offset, xor_operand): Likewise.\n+\t* config/sh/sh.md: Include constraints.md.\n+\t(*movsicc_t_false): Use satisfies_constraint_* function\n+\tinstead of macro.\n+\t(*movsicc_t_true, ashlsi3_std, ashlhi3_k, lshrsi3_m,\n+\tlshrsi3_k, movsi_const_16bit+2, *movhi_media+1,\n+\tmovdi_const_16bit+1, beq, bne, *ptb): Likewise.\n+\t* config/sh/sh.h (reg_class_from_letter): Remove prototype.\n+\t(OVERRIDE_OPTIONS): Don't modify reg_class_from_letter.\n+\t(REG_CLASS_FROM_CONSTRAINT): Remove.\n+\t(CONSTRAINT_LEN, CONST_OK_FOR_I20, CONST_OK_FOR_I,\n+\tCONST_OK_FOR_J, CONST_OK_FOR_K16, CONST_OK_FOR_K,\n+\tCONST_OK_FOR_P27, CONST_OK_FOR_P, CONST_OK_FOR_M,\n+\tCONST_OK_FOR_N, CONST_OK_FOR_CONSTRAINT_P,\n+\tCONST_DOUBLE_OK_FOR_LETTER_P): Likewise.\n+\t(SECONDARY_INOUT_RELOAD_CLASS): Use satisfies_constraint_*\n+\tfunction instead of macro.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Likewise.\n+\t(EXTRA_CONSTRAINT_Q, EXTRA_CONSTRAINT_A,\n+\tEXTRA_CONSTRAINT_Bsc, EXTRA_CONSTRAINT_B,\n+\tEXTRA_CONSTRAINT_Css, EXTRA_CONSTRAINT_Csu): Remove.\n+\t(IS_PC_RELATIVE_LOAD_ADDR_P): New macro.\n+\t(IS_LITERAL_OR_SYMBOLIC_S16_P): Likewise.\n+\t(IS_LITERAL_OR_SYMBOLIC_U16_P): Likewise.\n+\t(IS_NON_EXPLICIT_CONSTANT_P): Likewise.\n+\t(EXTRA_CONSTRAINT_Csy, EXTRA_CONSTRAINT_Z, EXTRA_CONSTRAINT_W,\n+\tEXTRA_CONSTRAINT_Cpg, EXTRA_CONSTRAINT_C,\n+\tEXTRA_MEMORY_CONSTRAINT, EXTRA_CONSTRAINT_Sr0,\n+\tEXTRA_CONSTRAINT_Sua, EXTRA_CONSTRAINT_S,\n+\tEXTRA_CONSTRAINT_STR): Likewise.\n+\t(GO_IF_LEGITIMATE_INDEX): Fix indentation.\n+\n 2007-06-07  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/i386/darwin.h (STACK_BOUNDARY): Define."}, {"sha": "69c4f1f7f2ba1da917c9d083fc6e52bd384b3d76", "filename": "gcc/config/sh/constraints.md", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "patch": "@@ -0,0 +1,210 @@\n+;; Constraint definitions for Renesas / SuperH SH.\n+;; Copyright (C) 2007 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;; Overview of uppercase letter constraints:\n+;; Bxx: miscellaneous constraints\n+;;  Bsc: SCRATCH - for the scratch register in movsi_ie in the\n+;;       fldi0 / fldi0 cases\n+;; Cxx: Constants other than only CONST_INT\n+;;  Css: signed 16-bit constant, literal or symbolic\n+;;  Csu: unsigned 16-bit constant, literal or symbolic\n+;;  Csy: label or symbol\n+;;  Cpg: non-explicit constants that can be directly loaded into a general\n+;;       purpose register in PIC code.  like 's' except we don't allow\n+;;       PIC_DIRECT_ADDR_P\n+;; IJKLMNOP: CONT_INT constants\n+;;  Ixx: signed xx bit\n+;;  J16: 0xffffffff00000000 | 0x00000000ffffffff\n+;;  Kxx: unsigned xx bit\n+;;  M: 1\n+;;  N: 0\n+;;  P27: 1 | 2 | 8 | 16\n+;; Q: pc relative load operand\n+;; Rxx: reserved for exotic register classes.\n+;; Sxx: extra memory (storage) constraints\n+;;  Sua: unaligned memory operations\n+;; W: vector\n+;; Z: zero in any mode\n+;;\n+;; unused CONST_INT constraint letters: LO\n+;; unused EXTRA_CONSTRAINT letters: D T U Y\n+\n+;; Register constraints\n+(define_register_constraint \"a\" \"ALL_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"b\" \"TARGET_REGS\"\n+  \"Branch target registers.\")\n+\n+(define_register_constraint \"c\" \"FPSCR_REGS\"\n+  \"Floating-point status register.\")\n+\n+(define_register_constraint \"d\" \"DF_REGS\"\n+  \"Double precision floating-point register.\")\n+\n+(define_register_constraint \"e\" \"TARGET_FMOVD ? NO_REGS : FP_REGS\"\n+  \"Floating-point register.\")\n+\n+(define_register_constraint \"f\" \"FP_REGS\"\n+  \"Floating-point register.\")\n+\n+(define_register_constraint \"k\" \"SIBCALL_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"l\" \"PR_REGS\"\n+  \"PR register.\")\n+\n+(define_register_constraint \"t\" \"T_REGS\"\n+  \"T register.\")\n+\n+(define_register_constraint \"w\" \"FP0_REGS\"\n+  \"Floating-point register 0.\")\n+\n+(define_register_constraint \"x\" \"MAC_REGS\"\n+  \"MACH and MACL registers.\")\n+\n+(define_register_constraint \"y\" \"FPUL_REGS\"\n+  \"FPUL register.\")\n+\n+(define_register_constraint \"z\" \"R0_REGS\"\n+  \"R0 register.\")\n+\n+;; Integer constraints\n+(define_constraint \"I06\"\n+  \"A signed 6-bit constant, as used in SHmedia beqi, bnei and xori.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32 && ival <= 31\")))\n+\n+(define_constraint \"I08\"\n+  \"A signed 8-bit constant, as used in add, sub, etc.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -128 && ival <= 127\")))\n+\n+(define_constraint \"I10\"\n+  \"A signed 10-bit constant, as used in in SHmedia andi, ori.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -512 && ival <= 511\")))\n+\n+(define_constraint \"I16\"\n+  \"A signed 16-bit constant, as used in SHmedia movi.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -32768 && ival <= 32767\")))\n+\n+(define_constraint \"I20\"\n+  \"A signed 20-bit constant, as used in SH2A movi20.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -524288 && ival <= 524287\")\n+       (match_test \"TARGET_SH2A\")))\n+\n+(define_constraint \"J16\"\n+  \"0xffffffff00000000 or 0x00000000ffffffff.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_J16 (ival)\")))\n+\n+(define_constraint \"K08\"\n+  \"An unsigned 8-bit constant, as used in and, or, etc.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 255\")))\n+ \n+(define_constraint \"K16\"\n+  \"An unsigned 16-bit constant, as used in SHmedia shori.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 65535\")))\n+ \n+(define_constraint \"P27\"\n+  \"A constant for shift operand 1,2,8 or 16.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1 || ival == 2 || ival == 8 || ival == 16\")))\n+\n+(define_constraint \"M\"\n+  \"Integer constant 1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1\")))\n+\n+(define_constraint \"N\"\n+  \"Integer constant 0.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+;; Floating-point constraints\n+(define_constraint \"G\"\n+  \"Double constant 0.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"fp_zero_operand (op) && fldi_ok ()\")))\n+\n+(define_constraint \"H\"\n+  \"Double constant 1.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"fp_one_operand (op) && fldi_ok ()\")))\n+\n+;; Extra constraints\n+(define_constraint \"Q\"\n+  \"A pc relative load operand.\"\n+  (and (match_code \"mem\")\n+       (match_test \"IS_PC_RELATIVE_LOAD_ADDR_P (XEXP (op, 0))\")))\n+\n+(define_constraint \"Bsc\"\n+  \"Constraint for selecting FLDI0 or FLDI1 instruction.  If the clobber\n+   operand is not SCRATCH (i.e. REG) then R0 is probably being used,\n+   hence mova is being used, hence do not select this pattern.\"\n+  (match_code \"scratch\"))\n+\n+(define_constraint \"Css\"\n+  \"A signed 16-bit constant, literal or symbolic.\"\n+  (and (match_code \"const\")\n+       (match_test \"IS_LITERAL_OR_SYMBOLIC_S16_P (XEXP (op, 0))\")))\n+\n+(define_constraint \"Csu\"\n+  \"An unsigned 16-bit constant, literal or symbolic.\"\n+  (and (match_code \"const\")\n+       (match_test \"IS_LITERAL_OR_SYMBOLIC_U16_P (XEXP (op, 0))\")))\n+\n+(define_constraint \"Csy\"\n+  \"A label or a symbol.\"\n+  (ior (match_test \"NON_PIC_REFERENCE_P (op)\")\n+       (match_test \"PIC_DIRECT_ADDR_P (op)\")))\n+\n+(define_constraint \"Z\"\n+  \"A zero in any shape or form.\"\n+  (match_test \"op == CONST0_RTX (GET_MODE (op))\"))\n+\n+(define_constraint \"W\"\n+  \"Any vector constant we can handle.\"\n+  (and (match_code \"const_vector\")\n+       (ior (match_test \"sh_rep_vec (op, VOIDmode)\")\n+\t    (match_test \"HOST_BITS_PER_WIDE_INT >= 64\n+\t\t\t ? sh_const_vec (op, VOIDmode)\n+\t\t\t : sh_1el_vec (op, VOIDmode)\"))))\n+\n+(define_constraint \"Cpg\"\n+  \"A non-explicit constant that can be loaded directly into a general\n+   purpose register.  This is like 's' except we don't allow\n+   PIC_DIRECT_ADDR_P.\"\n+  (match_test \"IS_NON_EXPLICIT_CONSTANT_P (op)\"))\n+\n+(define_memory_constraint \"Sr0\"\n+  \"@internal\"\n+  (and (match_test \"memory_operand (op, GET_MODE (op))\")\n+       (match_test \"!refers_to_regno_p (R0_REG, R0_REG + 1, op, (rtx *) 0)\")))\n+\n+(define_memory_constraint \"Sua\"\n+  \"@internal\"\n+  (and (match_test \"memory_operand (op, GET_MODE (op))\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) != PLUS\")))"}, {"sha": "069bea46b6822678d690d79e60fc73a82d922708", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for Renesas / SuperH SH.\n-;; Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -40,13 +40,13 @@\n   if (GET_CODE (cond) == CONST)\n     {\n       cond = XEXP (cond, 0);\n-      if (!EXTRA_CONSTRAINT_Csy (tar))\n+      if (!satisfies_constraint_Csy (tar))\n \treturn 0;\n       if (GET_CODE (tar) == CONST)\n \ttar = XEXP (tar, 0);\n     }\n   else if (!arith_reg_operand (tar, VOIDmode)\n-\t   && ! EXTRA_CONSTRAINT_Csy (tar))\n+\t   && ! satisfies_constraint_Csy (tar))\n     return 0;\n   if (GET_CODE (cond) != EQ)\n     return 0;\n@@ -70,8 +70,7 @@\n   /* Check mshflo.l / mshflhi.l opportunities.  */\n   if (TARGET_SHMEDIA\n       && mode == DImode\n-      && GET_CODE (op) == CONST_INT\n-      && CONST_OK_FOR_J16 (INTVAL (op)))\n+      && satisfies_constraint_J16 (op))\n     return 1;\n \n   return 0;\n@@ -106,12 +105,12 @@\n   if (TARGET_SHMEDIA)\n     {\n       /* FIXME: We should be checking whether the CONST_INT fits in a\n-\t CONST_OK_FOR_I16 here, but this causes reload_cse to crash when\n+\t signed 16-bit here, but this causes reload_cse to crash when\n \t attempting to transform a sequence of two 64-bit sets of the\n \t same register from literal constants into a set and an add,\n \t when the difference is too wide for an add.  */\n       if (GET_CODE (op) == CONST_INT\n-\t  || EXTRA_CONSTRAINT_Css (op))\n+\t  || satisfies_constraint_Css (op))\n \treturn 1;\n       else if (GET_CODE (op) == TRUNCATE\n \t       && ! system_reg_operand (XEXP (op, 0), VOIDmode)\n@@ -124,7 +123,7 @@\n       else\n \treturn 0;\n     }\n-  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I08 (INTVAL (op)))\n+  else if (satisfies_constraint_I08 (op))\n     return 1;\n \n   return 0;\n@@ -198,7 +197,7 @@\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (EXTRA_CONSTRAINT_Z (op))\n+  if (satisfies_constraint_Z (op))\n     return 1;\n \n   return 0;\n@@ -240,7 +239,7 @@\n (define_predicate \"cmp_operand\"\n   (match_code \"subreg,reg,const_int\")\n {\n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_N (INTVAL (op)))\n+  if (satisfies_constraint_N (op))\n     return 1;\n   if (TARGET_SHMEDIA\n       && mode != DImode && GET_CODE (op) == SUBREG\n@@ -502,12 +501,12 @@\n \n   if (TARGET_SHMEDIA)\n     {\n-      if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I10 (INTVAL (op)))\n+      if (satisfies_constraint_I10 (op))\n \treturn 1;\n       else\n \treturn 0;\n     }\n-  else if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_K08 (INTVAL (op)))\n+  else if (satisfies_constraint_K08 (op))\n     return 1;\n \n   return 0;\n@@ -705,7 +704,7 @@\n     return 0;\n \n   if ((GET_MODE (op) == Pmode || GET_MODE (op) == VOIDmode)\n-      && EXTRA_CONSTRAINT_Csy (op))\n+      && satisfies_constraint_Csy (op))\n     return ! reload_completed;\n \n   return target_reg_operand (op, mode);\n@@ -756,8 +755,7 @@\n   (match_code \"subreg,reg,plus\")\n {\n   if (GET_CODE (op) == PLUS\n-      && (GET_CODE (XEXP (op, 1)) != CONST_INT\n-\t  || ! CONST_OK_FOR_I06 (INTVAL (XEXP (op, 1)))))\n+      && (! satisfies_constraint_I06 (XEXP (op, 1))))\n     return 0;\n   return address_operand (op, QImode);\n })\n@@ -767,7 +765,7 @@\n (define_predicate \"ua_offset\"\n   (match_code \"const_int\")\n {\n-  return GET_CODE (op) == CONST_INT && CONST_OK_FOR_I06 (INTVAL (op));\n+  return satisfies_constraint_I06 (op);\n })\n \n ;; TODO: Add a comment here.\n@@ -783,9 +781,9 @@\n {\n   if (GET_CODE (op) == CONST_INT)\n     return (TARGET_SHMEDIA\n-\t    ? (CONST_OK_FOR_I06 (INTVAL (op))\n+\t    ? (satisfies_constraint_I06 (op)\n \t       || (no_new_pseudos && INTVAL (op) == 0xff))\n-\t    : CONST_OK_FOR_K08 (INTVAL (op)));\n+\t    : satisfies_constraint_K08 (op));\n   if (TARGET_SHMEDIA\n       && mode != DImode && GET_CODE (op) == SUBREG\n       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) > 4)"}, {"sha": "d8825d05ce6c60aa9583924a81c2663ff3dbe68a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-gimple.h\"\n #include \"cfgloop.h\"\n #include \"alloc-pool.h\"\n+#include \"tm-constrs.h\"\n \n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n@@ -153,21 +154,6 @@ char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   [MAX_ADDITIONAL_REGISTER_NAME_LENGTH + 1]\n   = SH_ADDITIONAL_REGISTER_NAMES_INITIALIZER;\n \n-/* Provide reg_class from a letter such as appears in the machine\n-   description.  *: target independently reserved letter.\n-   reg_class_from_letter['e' - 'a'] is set to NO_REGS for TARGET_FMOVD.  */\n-\n-enum reg_class reg_class_from_letter[] =\n-{\n-  /* a */ ALL_REGS,  /* b */ TARGET_REGS, /* c */ FPSCR_REGS, /* d */ DF_REGS,\n-  /* e */ FP_REGS,   /* f */ FP_REGS,  /* g **/ NO_REGS,     /* h */ NO_REGS,\n-  /* i **/ NO_REGS,  /* j */ NO_REGS,  /* k */ SIBCALL_REGS, /* l */ PR_REGS,\n-  /* m **/ NO_REGS,  /* n **/ NO_REGS, /* o **/ NO_REGS,     /* p **/ NO_REGS,\n-  /* q */ NO_REGS,   /* r **/ NO_REGS, /* s **/ NO_REGS,     /* t */ T_REGS,\n-  /* u */ NO_REGS,   /* v */ NO_REGS,  /* w */ FP0_REGS,     /* x */ MAC_REGS,\n-  /* y */ FPUL_REGS, /* z */ R0_REGS\n-};\n-\n int assembler_dialect;\n \n static bool shmedia_space_reserved_for_target_registers;\n@@ -1414,7 +1400,7 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n \t  || (mode == SImode && operands[2] != CONST0_RTX (SImode)\n \t      && ((comparison != EQ && comparison != NE)\n \t\t  || (REG_P (op1) && REGNO (op1) != R0_REG)\n-\t\t  || !CONST_OK_FOR_I08 (INTVAL (operands[2]))))))\n+\t\t  || !satisfies_constraint_I08 (operands[2])))))\n     {\n       if (scratch && GET_MODE (scratch) == mode)\n \t{\n@@ -2281,9 +2267,8 @@ andcosts (rtx x)\n \n   if (TARGET_SHMEDIA)\n     {\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && (CONST_OK_FOR_I10 (INTVAL (XEXP (x, 1)))\n-\t      || CONST_OK_FOR_J16 (INTVAL (XEXP (x, 1)))))\n+      if (satisfies_constraint_I10 (XEXP (x, 1))\n+\t  || satisfies_constraint_J16 (XEXP (x, 1)))\n \treturn 1;\n       else\n \treturn 1 + rtx_cost (XEXP (x, 1), AND);\n@@ -3719,10 +3704,8 @@ broken_move (rtx insn)\n \t\t&& FP_REGISTER_P (REGNO (SET_DEST (pat))))\n \t  && ! (TARGET_SH2A\n \t\t&& GET_MODE (SET_DEST (pat)) == SImode\n-\t\t&& GET_CODE (SET_SRC (pat)) == CONST_INT\n-\t\t&& CONST_OK_FOR_I20 (INTVAL (SET_SRC (pat))))\n-\t  && (GET_CODE (SET_SRC (pat)) != CONST_INT\n-\t      || ! CONST_OK_FOR_I08 (INTVAL (SET_SRC (pat)))))\n+\t\t&& satisfies_constraint_I20 (SET_SRC (pat)))\n+\t  && ! satisfies_constraint_I08 (SET_SRC (pat)))\n \treturn 1;\n     }\n \n@@ -10930,7 +10913,7 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n         return GENERAL_REGS;\n       if (class == FPUL_REGS && immediate_operand (x, mode))\n \t{\n-\t  if (GET_CODE (x) == CONST_INT && CONST_OK_FOR_I08 (INTVAL (x)))\n+\t  if (satisfies_constraint_I08 (x))\n \t    return GENERAL_REGS;\n \t  sri->icode = CODE_FOR_reload_insi__i_fpul;\n \t  return NO_REGS;\n@@ -10983,7 +10966,7 @@ sh_secondary_reload (bool in_p, rtx x, enum reg_class class,\n     }\n   if ((class == TARGET_REGS\n        || (TARGET_SHMEDIA && class == SIBCALL_REGS))\n-      && !EXTRA_CONSTRAINT_Csy (x)\n+      && !satisfies_constraint_Csy (x)\n       && (GET_CODE (x) != REG || ! GENERAL_REGISTER_P (REGNO (x))))\n     return GENERAL_REGS;\n   if ((class == MAC_REGS || class == PR_REGS)"}, {"sha": "91a56119c6388b75f2183dcbd35fab9328baad02", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 47, "deletions": 213, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -686,8 +686,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   if (sh_branch_cost == -1)\t\t\t\t\t\t\\\n     sh_branch_cost\t\t\t\t\t\t\t\\\n       = TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1;\t\\\n-  if (TARGET_FMOVD)\t\t\t\t\t\t\t\\\n-    reg_class_from_letter['e' - 'a'] = NO_REGS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n     if (! VALID_REGISTER_P (regno))\t\t\t\t\t\\\n@@ -1538,67 +1536,8 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define INDEX_REG_CLASS \\\n   (!ALLOW_INDEXED_ADDRESS ? NO_REGS : TARGET_SHMEDIA ? GENERAL_REGS : R0_REGS)\n #define BASE_REG_CLASS\t GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine\n-   description.  */\n-extern enum reg_class reg_class_from_letter[];\n-\n-/* We might use 'Rxx' constraints in the future for exotic reg classes.*/\n-#define REG_CLASS_FROM_CONSTRAINT(C, STR) \\\n-  (ISLOWER (C) ? reg_class_from_letter[(C)-'a'] : NO_REGS )\n \f\n-/* Overview of uppercase letter constraints:\n-   A: Addresses (constraint len == 3)\n-    Ac4: sh4 cache operations\n-    Ac5: sh5 cache operations\n-   Bxx: miscellaneous constraints\n-    Bsc: SCRATCH - for the scratch register in movsi_ie in the\n-\t fldi0 / fldi0 cases\n-   C: Constants other than only CONST_INT (constraint len == 3)\n-    Css: signed 16-bit constant, literal or symbolic\n-    Csu: unsigned 16-bit constant, literal or symbolic\n-    Csy: label or symbol\n-    Cpg: non-explicit constants that can be directly loaded into a general\n-\t purpose register in PIC code.  like 's' except we don't allow\n-\t PIC_DIRECT_ADDR_P\n-   IJKLMNOP: CONT_INT constants\n-    Ixx: signed xx bit\n-    J16: 0xffffffff00000000 | 0x00000000ffffffff\n-    Kxx: unsigned xx bit\n-    M: 1\n-    N: 0\n-    P27: 1 | 2 | 8 | 16\n-   Q: pc relative load operand\n-   Rxx: reserved for exotic register classes.\n-   S: extra memory (storage) constraints (constraint len == 3)\n-    Sua: unaligned memory operations\n-   W: vector\n-   Z: zero in any mode\n-\n-   unused CONST_INT constraint letters: LO\n-   unused EXTRA_CONSTRAINT letters: D T U Y */\n-\n-#define CONSTRAINT_LEN(C,STR) \\\n-  (((C) == 'A' || (C) == 'B' || (C) == 'C' \\\n-    || (C) == 'I' || (C) == 'J' || (C) == 'K' || (C) == 'P' \\\n-    || (C) == 'R' || (C) == 'S') \\\n-   ? 3 : DEFAULT_CONSTRAINT_LEN ((C), (STR)))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\tI08: arithmetic operand -127..128, as used in add, sub, etc\n-\tI16: arithmetic operand -32768..32767, as used in SHmedia movi\n-\tK16: arithmetic operand 0..65535, as used in SHmedia shori\n-\tP27: shift operand 1,2,8 or 16\n-\tK08: logical operand 0..255, as used in and, or, etc.\n-\tM: constant 1\n-\tN: constant 0\n-\tI06: arithmetic operand -32..31, as used in SHmedia beqi, bnei and xori\n-\tI10: arithmetic operand -512..511, as used in SHmedia andi, ori\n-*/\n+/* Defines for sh.md and constraints.md.  */\n \n #define CONST_OK_FOR_I06(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -32 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 31)\n@@ -1608,55 +1547,13 @@ extern enum reg_class reg_class_from_letter[];\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 511)\n #define CONST_OK_FOR_I16(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -32768 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 32767)\n-#define CONST_OK_FOR_I20(VALUE) (((HOST_WIDE_INT)(VALUE)) >= -524288 \\\n-\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 524287 \\\n-\t\t\t\t && TARGET_SH2A)\n-#define CONST_OK_FOR_I(VALUE, STR) \\\n-  ((STR)[1] == '0' && (STR)[2] == '6' ? CONST_OK_FOR_I06 (VALUE) \\\n-   : (STR)[1] == '0' && (STR)[2] == '8' ? CONST_OK_FOR_I08 (VALUE) \\\n-   : (STR)[1] == '1' && (STR)[2] == '0' ? CONST_OK_FOR_I10 (VALUE) \\\n-   : (STR)[1] == '1' && (STR)[2] == '6' ? CONST_OK_FOR_I16 (VALUE) \\\n-   : (STR)[1] == '2' && (STR)[2] == '0' ? CONST_OK_FOR_I20 (VALUE) \\\n-   : 0)\n \n #define CONST_OK_FOR_J16(VALUE) \\\n   ((HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) 0xffffffff) \\\n    || (HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) -1 << 32))\n-#define CONST_OK_FOR_J(VALUE, STR) \\\n-  ((STR)[1] == '1' && (STR)[2] == '6' ? CONST_OK_FOR_J16 (VALUE) \\\n-   : 0)\n \n #define CONST_OK_FOR_K08(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 255)\n-#define CONST_OK_FOR_K16(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n-\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 65535)\n-#define CONST_OK_FOR_K(VALUE, STR) \\\n-  ((STR)[1] == '0' && (STR)[2] == '8' ? CONST_OK_FOR_K08 (VALUE) \\\n-   : (STR)[1] == '1' && (STR)[2] == '6' ? CONST_OK_FOR_K16 (VALUE)\t\\\n-   : 0)\n-#define CONST_OK_FOR_P27(VALUE) \\\n-  ((VALUE)==1||(VALUE)==2||(VALUE)==8||(VALUE)==16)\n-#define CONST_OK_FOR_P(VALUE, STR) \\\n-  ((STR)[1] == '2' && (STR)[2] == '7' ? CONST_OK_FOR_P27 (VALUE) \\\n-   : 0)\n-#define CONST_OK_FOR_M(VALUE) ((VALUE)==1)\n-#define CONST_OK_FOR_N(VALUE) ((VALUE)==0)\n-#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)\t\\\n-     ((C) == 'I' ? CONST_OK_FOR_I ((VALUE), (STR))\t\\\n-    : (C) == 'J' ? CONST_OK_FOR_J ((VALUE), (STR))\t\\\n-    : (C) == 'K' ? CONST_OK_FOR_K ((VALUE), (STR))\t\\\n-    : (C) == 'M' ? CONST_OK_FOR_M (VALUE)\t\t\\\n-    : (C) == 'N' ? CONST_OK_FOR_N (VALUE)\t\t\\\n-    : (C) == 'P' ? CONST_OK_FOR_P ((VALUE), (STR))\t\\\n-    : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n-((C) == 'G' ? (fp_zero_operand (VALUE) && fldi_ok ())\t\\\n- : (C) == 'H' ? (fp_one_operand (VALUE) && fldi_ok ())\t\\\n- : (C) == 'F')\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n@@ -1695,7 +1592,7 @@ extern enum reg_class reg_class_from_letter[];\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (((CLASS) == TARGET_REGS\t\t\t\t\t\t\\\n        || (TARGET_SHMEDIA && (CLASS) == SIBCALL_REGS))\t\t\t\\\n-      && !EXTRA_CONSTRAINT_Csy (X)\t\t\t\t\t\\\n+      && !satisfies_constraint_Csy (X)\t\t\t\t\t\\\n       && (GET_CODE (X) != REG || ! GENERAL_REGISTER_P (REGNO (X))))\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (((CLASS) == MAC_REGS || (CLASS) == PR_REGS)\t\t\t\\\n@@ -1723,7 +1620,7 @@ extern enum reg_class reg_class_from_letter[];\n \t  || GET_CODE (X) == PLUS))\t\t\t\t\t\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (CLASS) == FPUL_REGS && immediate_operand ((X), (MODE))\t\t\\\n-   ? (GET_CODE (X) == CONST_INT && CONST_OK_FOR_I08 (INTVAL (X))\t\\\n+   ? (satisfies_constraint_I08 (X)\t\t\t\t\t\\\n       ? GENERAL_REGS\t\t\t\t\t\t\t\\\n       : R0_REGS)\t\t\t\t\t\t\t\\\n    : ((CLASS) == FPSCR_REGS\t\t\t\t\t\t\\\n@@ -2360,55 +2257,47 @@ struct sh_args {\n \n #endif\n \n-/* The 'Q' constraint is a pc relative load operand.  */\n-#define EXTRA_CONSTRAINT_Q(OP)                          \t\t\\\n-  (GET_CODE (OP) == MEM \t\t\t\t\t\t\\\n-   && ((GET_CODE (XEXP ((OP), 0)) == LABEL_REF)\t\t\t\t\\\n-       || (GET_CODE (XEXP ((OP), 0)) == CONST                \t\t\\\n-\t   && GET_CODE (XEXP (XEXP ((OP), 0), 0)) == PLUS\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) == LABEL_REF \\\n-\t   && GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 1)) == CONST_INT)))\n+/* Macros for extra constraints.  */\n \n-/* Extra address constraints.  */\n-#define EXTRA_CONSTRAINT_A(OP, STR) 0\n+#define IS_PC_RELATIVE_LOAD_ADDR_P(OP)                          \t\\\n+  ((GET_CODE ((OP)) == LABEL_REF)\t\t\t\t\t\\\n+   || (GET_CODE ((OP)) == CONST\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP ((OP), 0)) == PLUS\t\t\t\t\\\n+       && GET_CODE (XEXP (XEXP ((OP), 0), 0)) == LABEL_REF\t\t\\\n+       && GET_CODE (XEXP (XEXP ((OP), 0), 1)) == CONST_INT))\n \n-/* Constraint for selecting FLDI0 or FLDI1 instruction. If the clobber\n-   operand is not SCRATCH (i.e. REG) then R0 is probably being\n-   used, hence mova is being used, hence do not select this pattern */\n-#define EXTRA_CONSTRAINT_Bsc(OP)    (GET_CODE(OP) == SCRATCH)\n-#define EXTRA_CONSTRAINT_B(OP, STR) \\\n-  ((STR)[1] == 's' && (STR)[2] == 'c' ? EXTRA_CONSTRAINT_Bsc (OP) \\\n-   : 0)\n+#define IS_LITERAL_OR_SYMBOLIC_S16_P(OP)\t\t\t\t\\\n+  (GET_CODE ((OP)) == SIGN_EXTEND\t\t\t\t\t\\\n+   && (GET_MODE ((OP)) == DImode\t\t\t\t\t\\\n+       || GET_MODE ((OP)) == SImode)\t\t\t\t\t\\\n+   && GET_CODE (XEXP ((OP), 0)) == TRUNCATE\t\t\t\t\\\n+   && GET_MODE (XEXP ((OP), 0)) == HImode\t\t\t\t\\\n+   && (MOVI_SHORI_BASE_OPERAND_P (XEXP (XEXP ((OP), 0), 0))\t\t\\\n+       || (GET_CODE (XEXP (XEXP ((OP), 0), 0)) == ASHIFTRT\t\t\\\n+\t   && (MOVI_SHORI_BASE_OPERAND_P\t\t\t\t\\\n+\t       (XEXP (XEXP (XEXP ((OP), 0), 0), 0)))\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 1)) == CONST_INT)))\n \n-/* The `Css' constraint is a signed 16-bit constant, literal or symbolic.  */\n-#define EXTRA_CONSTRAINT_Css(OP) \\\n-  (GET_CODE (OP) == CONST \\\n-   && GET_CODE (XEXP ((OP), 0)) == SIGN_EXTEND \\\n-   && (GET_MODE (XEXP ((OP), 0)) == DImode \\\n-       || GET_MODE (XEXP ((OP), 0)) == SImode) \\\n-   && GET_CODE (XEXP (XEXP ((OP), 0), 0)) == TRUNCATE \\\n-   && GET_MODE (XEXP (XEXP ((OP), 0), 0)) == HImode \\\n-   && (MOVI_SHORI_BASE_OPERAND_P (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) \\\n-       || (GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) == ASHIFTRT \\\n-\t   && (MOVI_SHORI_BASE_OPERAND_P \\\n-\t       (XEXP (XEXP (XEXP (XEXP ((OP), 0), 0), 0), 0))) \\\n-\t   && GET_CODE (XEXP (XEXP (XEXP (XEXP ((OP), 0), 0), 0), \\\n-\t\t\t      1)) == CONST_INT)))\n-\n-/* The `Csu' constraint is an unsigned 16-bit constant, literal or symbolic.  */\n-#define EXTRA_CONSTRAINT_Csu(OP) \\\n-  (GET_CODE (OP) == CONST \\\n-   && GET_CODE (XEXP ((OP), 0)) == ZERO_EXTEND \\\n-   && (GET_MODE (XEXP ((OP), 0)) == DImode \\\n-       || GET_MODE (XEXP ((OP), 0)) == SImode) \\\n-   && GET_CODE (XEXP (XEXP ((OP), 0), 0)) == TRUNCATE \\\n-   && GET_MODE (XEXP (XEXP ((OP), 0), 0)) == HImode \\\n-   && (MOVI_SHORI_BASE_OPERAND_P (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) \\\n-       || (GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 0)) == ASHIFTRT \\\n-\t   && (MOVI_SHORI_BASE_OPERAND_P \\\n-\t       (XEXP (XEXP (XEXP (XEXP ((OP), 0), 0), 0), 0))) \\\n-\t   && GET_CODE (XEXP (XEXP (XEXP (XEXP ((OP), 0), 0), 0), \\\n-\t\t\t      1)) == CONST_INT)))\n+#define IS_LITERAL_OR_SYMBOLIC_U16_P(OP)\t\t\t\t\\\n+  (GET_CODE ((OP)) == ZERO_EXTEND\t\t\t\t\t\\\n+   && (GET_MODE ((OP)) == DImode\t\t\t\t\t\\\n+       || GET_MODE ((OP)) == SImode)\t\t\t\t\t\\\n+   && GET_CODE (XEXP ((OP), 0)) == TRUNCATE\t\t\t\t\\\n+   && GET_MODE (XEXP ((OP), 0)) == HImode\t\t\t\t\\\n+   && (MOVI_SHORI_BASE_OPERAND_P (XEXP (XEXP ((OP), 0), 0))\t\t\\\n+       || (GET_CODE (XEXP (XEXP ((OP), 0), 0)) == ASHIFTRT\t\t\\\n+\t   && (MOVI_SHORI_BASE_OPERAND_P\t\t\t\t\\\n+\t       (XEXP (XEXP (XEXP ((OP), 0), 0), 0)))\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (XEXP ((OP), 0), 0), 1)) == CONST_INT)))\n+\n+#define IS_NON_EXPLICIT_CONSTANT_P(OP)\t\t\t\t\t\\\n+  (CONSTANT_P (OP)\t\t\t\t\t\t\t\\\n+   && GET_CODE (OP) != CONST_INT\t\t\t\t\t\\\n+   && GET_CODE (OP) != CONST_DOUBLE\t\t\t\t\t\\\n+   && (!flag_pic\t\t\t\t\t\t\t\\\n+       || (LEGITIMATE_PIC_OPERAND_P (OP)\t\t\t\t\\\n+\t   && (! PIC_ADDR_P (OP) || PIC_OFFSET_P (OP))\t\t\t\\\n+\t   && GET_CODE (OP) != LABEL_REF)))\n \n /* Check whether OP is a datalabel unspec.  */\n #define DATALABEL_REF_NO_CONST_P(OP) \\\n@@ -2468,61 +2357,6 @@ struct sh_args {\n    ? (GOT_ENTRY_P (OP) || GOTPLT_ENTRY_P (OP)  || GOTOFF_P (OP) \\\n       || PIC_OFFSET_P (OP)) \\\n    : NON_PIC_REFERENCE_P (OP))\n-\n-/* The `Csy' constraint is a label or a symbol.  */\n-#define EXTRA_CONSTRAINT_Csy(OP) \\\n-  (NON_PIC_REFERENCE_P (OP) || PIC_DIRECT_ADDR_P (OP))\n-\n-/* A zero in any shape or form.  */\n-#define EXTRA_CONSTRAINT_Z(OP) \\\n-  ((OP) == CONST0_RTX (GET_MODE (OP)))\n-\n-/* Any vector constant we can handle.  */\n-#define EXTRA_CONSTRAINT_W(OP) \\\n-  (GET_CODE (OP) == CONST_VECTOR \\\n-   && (sh_rep_vec ((OP), VOIDmode) \\\n-       || (HOST_BITS_PER_WIDE_INT >= 64 \\\n-\t   ? sh_const_vec ((OP), VOIDmode) \\\n-\t   : sh_1el_vec ((OP), VOIDmode))))\n-\n-/* A non-explicit constant that can be loaded directly into a general purpose\n-   register.  This is like 's' except we don't allow PIC_DIRECT_ADDR_P.  */\n-#define EXTRA_CONSTRAINT_Cpg(OP) \\\n-  (CONSTANT_P (OP) \\\n-   && GET_CODE (OP) != CONST_INT \\\n-   && GET_CODE (OP) != CONST_DOUBLE \\\n-   && (!flag_pic \\\n-       || (LEGITIMATE_PIC_OPERAND_P (OP) \\\n-        && (! PIC_ADDR_P (OP) || PIC_OFFSET_P (OP)) \\\n-        && GET_CODE (OP) != LABEL_REF)))\n-#define EXTRA_CONSTRAINT_C(OP, STR) \\\n-  ((STR)[1] == 's' && (STR)[2] == 's' ? EXTRA_CONSTRAINT_Css (OP) \\\n-   : (STR)[1] == 's' && (STR)[2] == 'u' ? EXTRA_CONSTRAINT_Csu (OP) \\\n-   : (STR)[1] == 's' && (STR)[2] == 'y' ? EXTRA_CONSTRAINT_Csy (OP) \\\n-   : (STR)[1] == 'p' && (STR)[2] == 'g' ? EXTRA_CONSTRAINT_Cpg (OP) \\\n-   : 0)\n-\n-#define EXTRA_MEMORY_CONSTRAINT(C,STR) ((C) == 'S')\n-#define EXTRA_CONSTRAINT_Sr0(OP) \\\n-  (memory_operand((OP), GET_MODE (OP)) \\\n-   && ! refers_to_regno_p (R0_REG, R0_REG + 1, OP, (rtx *)0))\n-#define EXTRA_CONSTRAINT_Sua(OP) \\\n-  (memory_operand((OP), GET_MODE (OP)) \\\n-   && GET_CODE (XEXP (OP, 0)) != PLUS)\n-#define EXTRA_CONSTRAINT_S(OP, STR) \\\n-  ((STR)[1] == 'r' && (STR)[2] == '0' ? EXTRA_CONSTRAINT_Sr0 (OP) \\\n-   : (STR)[1] == 'u' && (STR)[2] == 'a' ? EXTRA_CONSTRAINT_Sua (OP) \\\n-   : 0)\n-\n-#define EXTRA_CONSTRAINT_STR(OP, C, STR)\t\t\\\n-  ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)\t\\\n-   : (C) == 'A' ? EXTRA_CONSTRAINT_A ((OP), (STR)) \\\n-   : (C) == 'B' ? EXTRA_CONSTRAINT_B ((OP), (STR)) \\\n-   : (C) == 'C' ? EXTRA_CONSTRAINT_C ((OP), (STR)) \\\n-   : (C) == 'S' ? EXTRA_CONSTRAINT_S ((OP), (STR)) \\\n-   : (C) == 'W' ? EXTRA_CONSTRAINT_W (OP) \\\n-   : (C) == 'Z' ? EXTRA_CONSTRAINT_Z (OP) \\\n-   : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -2601,11 +2435,11 @@ struct sh_args {\n \t    int MODE_SIZE;\t\t\t\t\t\t\\\n \t    /* Check if this the address of an unaligned load / store.  */\\\n \t    if ((MODE) == VOIDmode)\t\t\t\t\t\\\n-\t     {\t\t\t\t\t\t\t\t\\\n-\t      if (CONST_OK_FOR_I06 (INTVAL (OP)))\t\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t     }\t\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tif (CONST_OK_FOR_I06 (INTVAL (OP)))\t\t\t\\\n+\t\t  goto LABEL;\t\t\t\t\t\t\\\n+\t\tbreak;\t\t\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n \t    MODE_SIZE = GET_MODE_SIZE (MODE);\t\t\t\t\\\n \t    if (! (INTVAL (OP) & (MODE_SIZE - 1))\t\t\t\\\n \t\t&& INTVAL (OP) >= -512 * MODE_SIZE\t\t\t\\"}, {"sha": "c4f6257500eebea7bb922e5e050fa6d06aed5fcd", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32a7ab3d8069ff4cc16c3be5ff157e732f55203c/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=32a7ab3d8069ff4cc16c3be5ff157e732f55203c", "patch": "@@ -457,6 +457,7 @@\n (include \"sh4.md\")\n \n (include \"predicates.md\")\n+(include \"constraints.md\")\n \n ;; Definitions for filling delay slots\n \n@@ -1219,7 +1220,7 @@\n   \"TARGET_PRETEND_CMOVE\n    && (arith_reg_operand (operands[1], SImode)\n        || (immediate_operand (operands[1], SImode)\n-\t   && CONST_OK_FOR_I08 (INTVAL (operands[1]))))\"\n+\t   && satisfies_constraint_I08 (operands[1])))\"\n   \"bt 0f\\;mov %1,%0\\\\n0:\"\n   [(set_attr \"type\" \"mt_group,arith\") ;; poor approximation\n    (set_attr \"length\" \"4\")])\n@@ -1232,7 +1233,7 @@\n   \"TARGET_PRETEND_CMOVE\n    && (arith_reg_operand (operands[1], SImode)\n        || (immediate_operand (operands[1], SImode)\n-\t   && CONST_OK_FOR_I08 (INTVAL (operands[1]))))\"\n+\t   && satisfies_constraint_I08 (operands[1])))\"\n   \"bf 0f\\;mov %1,%0\\\\n0:\"\n   [(set_attr \"type\" \"mt_group,arith\") ;; poor approximation\n    (set_attr \"length\" \"4\")])\n@@ -3547,8 +3548,7 @@ label:\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,M,P27,?ri\")))\n    (clobber (match_scratch:SI 3 \"=X,X,X,&r\"))]\n   \"TARGET_SH3\n-   || (TARGET_SH1 && GET_CODE (operands[2]) == CONST_INT\n-       && CONST_OK_FOR_P27 (INTVAL (operands[2])))\"\n+   || (TARGET_SH1 && satisfies_constraint_P27 (operands[2]))\"\n   \"@\n    shld\t%2,%0\n    add\t%0,%0\n@@ -3557,7 +3557,7 @@ label:\n   \"TARGET_SH3\n    && reload_completed\n    && GET_CODE (operands[2]) == CONST_INT\n-   && ! CONST_OK_FOR_P27 (INTVAL (operands[2]))\"\n+   && ! satisfies_constraint_P27 (operands[2])\"\n   [(set (match_dup 3) (match_dup 2))\n    (parallel\n     [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 3)))\n@@ -3570,7 +3570,7 @@ label:\n   [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r,r\")\n \t(ashift:HI (match_operand:HI 1 \"arith_reg_operand\" \"0,0\")\n \t\t   (match_operand:HI 2 \"const_int_operand\" \"M,P27\")))]\n-  \"TARGET_SH1 && CONST_OK_FOR_P27 (INTVAL (operands[2]))\"\n+  \"TARGET_SH1 && satisfies_constraint_P27 (operands[2])\"\n   \"@\n \tadd\t%0,%0\n \tshll%O2\t%0\"\n@@ -3865,16 +3865,16 @@ label:\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"M\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1 && CONST_OK_FOR_M (INTVAL (operands[2]))\"\n+  \"TARGET_SH1 && satisfies_constraint_M (operands[2])\"\n   \"shlr\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n (define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"P27\")))]\n-  \"TARGET_SH1 && CONST_OK_FOR_P27 (INTVAL (operands[2]))\n-   && ! CONST_OK_FOR_M (INTVAL (operands[2]))\"\n+  \"TARGET_SH1 && satisfies_constraint_P27 (operands[2])\n+   && ! satisfies_constraint_M (operands[2])\"\n   \"shlr%O2\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n@@ -5154,7 +5154,7 @@ label:\n \t(match_operand:SI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n    && ((GET_CODE (operands[1]) == CONST_INT\n-\t&& ! CONST_OK_FOR_I16 (INTVAL (operands[1])))\n+\t&& ! satisfies_constraint_I16 (operands[1]))\n        || GET_CODE (operands[1]) == CONST_DOUBLE)\"\n   [(set (subreg:DI (match_dup 0) 0) (match_dup 1))])\n \n@@ -5366,7 +5366,7 @@ label:\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n \t(match_operand:HI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n-   && ! CONST_OK_FOR_I16 (INTVAL (operands[1]))\"\n+   && ! satisfies_constraint_I16 (operands[1])\"\n   [(set (subreg:DI (match_dup 0) 0) (match_dup 1))])\n \n (define_expand \"movhi\"\n@@ -5602,7 +5602,7 @@ label:\n \t(match_operand:DI 1 \"immediate_operand\" \"\"))]\n   \"TARGET_SHMEDIA && reload_completed\n    && GET_CODE (operands[1]) == CONST_INT\n-   && ! CONST_OK_FOR_I16 (INTVAL (operands[1]))\"\n+   && ! satisfies_constraint_I16 (operands[1])\"\n   [(set (match_dup 0) (match_dup 2))\n    (match_dup 1)]\n   \"\n@@ -6981,8 +6981,7 @@ label:\n \n       sh_compare_op0 = force_reg (mode, sh_compare_op0);\n       if (CONSTANT_P (sh_compare_op1)\n-\t  && (GET_CODE (sh_compare_op1) != CONST_INT\n-\t      || ! CONST_OK_FOR_I06 (INTVAL (sh_compare_op1))))\n+\t  && (! satisfies_constraint_I06 (sh_compare_op1)))\n \tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n       emit_jump_insn (gen_beq_media (operands[0],\n \t\t\t\t     sh_compare_op0, sh_compare_op1));\n@@ -7015,8 +7014,7 @@ label:\n \n       sh_compare_op0 = force_reg (mode, sh_compare_op0);\n       if (CONSTANT_P (sh_compare_op1)\n-\t  && (GET_CODE (sh_compare_op1) != CONST_INT\n-\t      || ! CONST_OK_FOR_I06 (INTVAL (sh_compare_op1))))\n+\t  && (! satisfies_constraint_I06 (sh_compare_op1)))\n \tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n       emit_jump_insn (gen_bne_media (operands[0],\n \t\t\t\t     sh_compare_op0, sh_compare_op1));\n@@ -8411,7 +8409,7 @@ label:\n \t(const (unspec [(match_operand 1 \"\" \"Csy\")]\n \t\t\t     UNSPEC_DATALABEL)))]\n   \"TARGET_SHMEDIA && flag_pic\n-   && EXTRA_CONSTRAINT_Csy (operands[1])\"\n+   && satisfies_constraint_Csy (operands[1])\"\n   \"ptb/u\tdatalabel %1, %0\"\n   [(set_attr \"type\" \"ptabs_media\")\n    (set_attr \"length\" \"*\")])"}]}