{"sha": "f74eeed4436adab2c50bec4f941cb940489aed3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc0ZWVlZDQ0MzZhZGFiMmM1MGJlYzRmOTQxY2I5NDA0ODlhZWQzZQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2007-09-07T16:54:38Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2007-09-07T16:54:38Z"}, "message": "re PR target/33286 (All exception related tests fail)\n\n\tPR target/33286\n\t* gthr-posix.h (__gthread_active_p): Add implementation for hppa-hpux.\n\t(__gthread_active,__gthread_start, __gthread_active_init): New.\n\t* gthr-posix95.h: Likewise.\n\nFrom-SVN: r128249", "tree": {"sha": "cde3f92be3a3e77776c4609fa446ca7fc6970639", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cde3f92be3a3e77776c4609fa446ca7fc6970639"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f74eeed4436adab2c50bec4f941cb940489aed3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f74eeed4436adab2c50bec4f941cb940489aed3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f74eeed4436adab2c50bec4f941cb940489aed3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f74eeed4436adab2c50bec4f941cb940489aed3e/comments", "author": null, "committer": null, "parents": [{"sha": "215161e20f2d87926fe0778cea032de8dee3c6bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/215161e20f2d87926fe0778cea032de8dee3c6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/215161e20f2d87926fe0778cea032de8dee3c6bd"}], "stats": {"total": 147, "additions": 146, "deletions": 1}, "files": [{"sha": "7d2b14ed7177e820e85782c61153af79455e019a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f74eeed4436adab2c50bec4f941cb940489aed3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f74eeed4436adab2c50bec4f941cb940489aed3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f74eeed4436adab2c50bec4f941cb940489aed3e", "patch": "@@ -1,3 +1,10 @@\n+2007-09-07  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/33286\n+\t* gthr-posix.h (__gthread_active_p): Add implementation for hppa-hpux.\n+\t(__gthread_active,__gthread_start, __gthread_active_init): New.\n+\t* gthr-posix95.h: Likewise.\n+\n 2007-09-07  Roman Zippel <zippel@linux-m68k.org>\n \n \t* function.h (struct function): Rename calls_unwind_init"}, {"sha": "a290b6aab7c3647df4a0b21d388a3f17a0e64f2c", "filename": "gcc/gthr-posix.h", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f74eeed4436adab2c50bec4f941cb940489aed3e/gcc%2Fgthr-posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f74eeed4436adab2c50bec4f941cb940489aed3e/gcc%2Fgthr-posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix.h?ref=f74eeed4436adab2c50bec4f941cb940489aed3e", "patch": "@@ -211,12 +211,81 @@ __gthread_active_p (void)\n \n #else /* not SUPPORTS_WEAK */\n \n+/* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread\n+   calls in shared flavors of the HP-UX C library.  Most of the stubs\n+   have no functionality.  The details are described in the \"libc cumulative\n+   patch\" for each subversion of HP-UX 11.  There are two special interfaces\n+   provided for checking whether an application is linked to a pthread\n+   library or not.  However, these interfaces aren't available in early\n+   libc versions.  We also can't use pthread_once as some libc versions\n+   call the init function.  So, we use pthread_create to check whether it\n+   is possible to create a thread or not.  The stub implementation returns\n+   the error number ENOSYS.  */\n+\n+#if defined(__hppa__) && defined(__hpux__)\n+\n+#include <errno.h>\n+\n+static volatile int __gthread_active = -1;\n+\n+static void *\n+__gthread_start (void *arg __attribute__((unused)))\n+{\n+  return NULL;\n+}\n+\n+static void __gthread_active_init (void) __attribute__((noinline));\n+static void\n+__gthread_active_init (void)\n+{\n+  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;\n+  pthread_t t;\n+  int result;\n+\n+  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);\n+  if (__gthread_active < 0)\n+    {\n+      result = __gthrw_(pthread_create) (&t, NULL, __gthread_start, NULL);\n+      if (result != ENOSYS)\n+\t{\n+\t  __gthread_active = 1;\n+\t  if (!result)\n+\t    __gthrw_(pthread_join) (t, NULL);\n+\t}\n+      else\n+\t__gthread_active = 0;\n+    }\n+  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);\n+}\n+\n+static inline int\n+__gthread_active_p (void)\n+{\n+  /* Avoid reading __gthread_active twice on the main code path.  */\n+  int __gthread_active_latest_value = __gthread_active;\n+\n+  /* This test is not protected to avoid taking a lock on the main code\n+     path so every update of __gthread_active in a threaded program must\n+     be atomic with regard to the result of the test.  */\n+  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n+    {\n+      __gthread_active_init ();\n+      __gthread_active_latest_value = __gthread_active;\n+    }\n+\n+  return __gthread_active_latest_value != 0;\n+}\n+\n+#else /* not hppa-hpux */\n+\n static inline int\n __gthread_active_p (void)\n {\n   return 1;\n }\n \n+#endif /* hppa-hpux */\n+\n #endif /* SUPPORTS_WEAK */\n \n #ifdef _LIBOBJC"}, {"sha": "f0d1553193e8f4f5aed6adcde975c0307af4b43f", "filename": "gcc/gthr-posix95.h", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f74eeed4436adab2c50bec4f941cb940489aed3e/gcc%2Fgthr-posix95.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f74eeed4436adab2c50bec4f941cb940489aed3e/gcc%2Fgthr-posix95.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-posix95.h?ref=f74eeed4436adab2c50bec4f941cb940489aed3e", "patch": "@@ -1,6 +1,6 @@\n /* Threads compatibility routines for libgcc2 and libobjc.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -174,12 +174,81 @@ __gthread_active_p (void)\n \n #else /* not SUPPORTS_WEAK */\n \n+/* Similar to Solaris, HP-UX 11 for PA-RISC provides stubs for pthread\n+   calls in shared flavors of the HP-UX C library.  Most of the stubs\n+   have no functionality.  The details are described in the \"libc cumulative\n+   patch\" for each subversion of HP-UX 11.  There are two special interfaces\n+   provided for checking whether an application is linked to a pthread\n+   library or not.  However, these interfaces aren't available in early\n+   libc versions.  We also can't use pthread_once as some libc versions\n+   call the init function.  So, we use pthread_create to check whether it\n+   is possible to create a thread or not.  The stub implementation returns\n+   the error number ENOSYS.  */\n+\n+#if defined(__hppa__) && defined(__hpux__)\n+\n+#include <errno.h>\n+\n+static volatile int __gthread_active = -1;\n+\n+static void *\n+__gthread_start (void *arg __attribute__((unused)))\n+{\n+  return NULL;\n+}\n+\n+static void __gthread_active_init (void) __attribute__((noinline));\n+static void\n+__gthread_active_init (void)\n+{\n+  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;\n+  pthread_t t;\n+  int result;\n+\n+  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);\n+  if (__gthread_active < 0)\n+    {\n+      result = __gthrw_(pthread_create) (&t, NULL, __gthread_start, NULL);\n+      if (result != ENOSYS)\n+\t{\n+\t  __gthread_active = 1;\n+\t  if (!result)\n+\t    __gthrw_(pthread_join) (t, NULL);\n+\t}\n+      else\n+\t__gthread_active = 0;\n+    }\n+  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);\n+}\n+\n+static inline int\n+__gthread_active_p (void)\n+{\n+  /* Avoid reading __gthread_active twice on the main code path.  */\n+  int __gthread_active_latest_value = __gthread_active;\n+\n+  /* This test is not protected to avoid taking a lock on the main code\n+     path so every update of __gthread_active in a threaded program must\n+     be atomic with regard to the result of the test.  */\n+  if (__builtin_expect (__gthread_active_latest_value < 0, 0))\n+    {\n+      __gthread_active_init ();\n+      __gthread_active_latest_value = __gthread_active;\n+    }\n+\n+  return __gthread_active_latest_value != 0;\n+}\n+\n+#else /* not hppa-hpux */\n+\n static inline int\n __gthread_active_p (void)\n {\n   return 1;\n }\n \n+#endif /* hppa-hpux */\n+\n #endif /* SUPPORTS_WEAK */\n \n #ifdef _LIBOBJC"}]}