{"sha": "c08de514880f6cc238123da828eca9122dbf74bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA4ZGU1MTQ4ODBmNmNjMjM4MTIzZGE4MjhlY2E5MTIyZGJmNzRiZA==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2015-11-11T13:31:46Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2015-11-11T13:31:46Z"}, "message": "Fix whitespace+typo from \"Share code from fold_array_ctor_reference with fold.\"\n\n\t* fold-const.c (get_array_ctor_element_at_index): Fix whitespace, typo.\n\nFrom-SVN: r230159", "tree": {"sha": "5cc32ee418a57514060dace0bf1a95778ad0172b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cc32ee418a57514060dace0bf1a95778ad0172b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c08de514880f6cc238123da828eca9122dbf74bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c08de514880f6cc238123da828eca9122dbf74bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c08de514880f6cc238123da828eca9122dbf74bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c08de514880f6cc238123da828eca9122dbf74bd/comments", "author": null, "committer": null, "parents": [{"sha": "03f3914528a0974319b4d38249e94a36208a4c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03f3914528a0974319b4d38249e94a36208a4c9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03f3914528a0974319b4d38249e94a36208a4c9b"}], "stats": {"total": 62, "additions": 33, "deletions": 29}, "files": [{"sha": "546cad83b2da79ac1f0f0be9bbb7d3d0d5196fc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c08de514880f6cc238123da828eca9122dbf74bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c08de514880f6cc238123da828eca9122dbf74bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c08de514880f6cc238123da828eca9122dbf74bd", "patch": "@@ -1,3 +1,7 @@\n+2015-11-11  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* fold-const.c (get_array_ctor_element_at_index): Fix whitespace, typo.\n+\n 2015-11-11  Jiong Wang  <jiong.wang@arm.com>\n \t    Jim Wilson  <wilson@gcc.gnu.org>\n "}, {"sha": "8dc849c3606306bd8d6ec265ed467622961440ec", "filename": "gcc/fold-const.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c08de514880f6cc238123da828eca9122dbf74bd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c08de514880f6cc238123da828eca9122dbf74bd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c08de514880f6cc238123da828eca9122dbf74bd", "patch": "@@ -11887,16 +11887,16 @@ get_array_ctor_element_at_index (tree ctor, offset_int access_index)\n   offset_int low_bound = 0;\n \n   if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE)\n-  {\n-    tree domain_type = TYPE_DOMAIN (TREE_TYPE (ctor));\n-    if (domain_type && TYPE_MIN_VALUE (domain_type))\n     {\n-      /* Static constructors for variably sized objects makes no sense.  */\n-      gcc_assert (TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST);\n-      index_type = TREE_TYPE (TYPE_MIN_VALUE (domain_type));\n-      low_bound = wi::to_offset (TYPE_MIN_VALUE (domain_type));\n+      tree domain_type = TYPE_DOMAIN (TREE_TYPE (ctor));\n+      if (domain_type && TYPE_MIN_VALUE (domain_type))\n+\t{\n+\t  /* Static constructors for variably sized objects makes no sense.  */\n+\t  gcc_assert (TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST);\n+\t  index_type = TREE_TYPE (TYPE_MIN_VALUE (domain_type));\n+\t  low_bound = wi::to_offset (TYPE_MIN_VALUE (domain_type));\n+\t}\n     }\n-  }\n \n   if (index_type)\n     access_index = wi::ext (access_index, TYPE_PRECISION (index_type),\n@@ -11912,29 +11912,29 @@ get_array_ctor_element_at_index (tree ctor, offset_int access_index)\n   tree cfield, cval;\n \n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n-  {\n-    /* Array constructor might explicitely set index, or specify range\n-     * or leave index NULL meaning that it is next index after previous\n-     * one.  */\n-    if (cfield)\n     {\n-      if (TREE_CODE (cfield) == INTEGER_CST)\n-\tmax_index = index = wi::to_offset (cfield);\n+      /* Array constructor might explicitly set index, or specify a range,\n+\t or leave index NULL meaning that it is next index after previous\n+\t one.  */\n+      if (cfield)\n+\t{\n+\t  if (TREE_CODE (cfield) == INTEGER_CST)\n+\t    max_index = index = wi::to_offset (cfield);\n+\t  else\n+\t    {\n+\t      gcc_assert (TREE_CODE (cfield) == RANGE_EXPR);\n+\t      index = wi::to_offset (TREE_OPERAND (cfield, 0));\n+\t      max_index = wi::to_offset (TREE_OPERAND (cfield, 1));\n+\t    }\n+\t}\n       else\n-      {\n-\tgcc_assert (TREE_CODE (cfield) == RANGE_EXPR);\n-\tindex = wi::to_offset (TREE_OPERAND (cfield, 0));\n-\tmax_index = wi::to_offset (TREE_OPERAND (cfield, 1));\n-      }\n-    }\n-    else\n-    {\n-      index += 1;\n-      if (index_type)\n-\tindex = wi::ext (index, TYPE_PRECISION (index_type),\n-\t\t\t TYPE_SIGN (index_type));\n-\tmax_index = index;\n-    }\n+\t{\n+\t  index += 1;\n+\t  if (index_type)\n+\t    index = wi::ext (index, TYPE_PRECISION (index_type),\n+\t\t\t     TYPE_SIGN (index_type));\n+\t  max_index = index;\n+\t}\n \n     /* Do we have match?  */\n     if (wi::cmpu (access_index, index) >= 0"}]}