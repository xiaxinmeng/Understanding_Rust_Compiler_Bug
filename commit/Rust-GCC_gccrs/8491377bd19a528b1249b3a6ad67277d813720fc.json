{"sha": "8491377bd19a528b1249b3a6ad67277d813720fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5MTM3N2JkMTlhNTI4YjEyNDliM2E2YWQ2NzI3N2Q4MTM3MjBmYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-22T20:43:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-22T20:43:15Z"}, "message": "This commit was generated by cvs2svn to compensate for changes in r18765,\n\nwhich included commits to RCS files with non-trunk default branches.\n\nFrom-SVN: r18766", "tree": {"sha": "4ef3666114905be6c619e972c6a78cc06a2f2d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef3666114905be6c619e972c6a78cc06a2f2d12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8491377bd19a528b1249b3a6ad67277d813720fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8491377bd19a528b1249b3a6ad67277d813720fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8491377bd19a528b1249b3a6ad67277d813720fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8491377bd19a528b1249b3a6ad67277d813720fc/comments", "author": null, "committer": null, "parents": [{"sha": "7e98cc1669aa89f173041d8be8156db0f7bcdaec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e98cc1669aa89f173041d8be8156db0f7bcdaec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e98cc1669aa89f173041d8be8156db0f7bcdaec"}], "stats": {"total": 13731, "additions": 7533, "deletions": 6198}, "files": [{"sha": "968184177ff6e194c7ae12d9a204bbdf6c77536f", "filename": "texinfo/NEWS", "status": "modified", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2FNEWS?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,5 +1,39 @@\n This file records noteworthy changes.\n \n+3.11 (31 July 1997)\n+* New commands:\n+  - @uref to make a reference to a url; @url now only indicates such.\n+  - @image to include graphics (epsf for TeX).\n+  - @deftypemethod and @deftypemethodx to document methods in strongly\n+    typed object-oriented languages, such as C++.\n+  - @html for raw HTML.\n+  - @ifnothtml @ifnotinfo @ifnottex for more precise conditionals.\n+  - @kbdinputstyle to control when @kbd uses the slanted typewriter font.\n+  - @email takes second optional argument.\n+* texinfo.tex reads texinfo.cnf (if present) for site-wide TeX\n+  configuration; for example, A4 paper sizes.\n+* info:\n+  - arrow keys supported.\n+  - trailing : in INFOPATH appends default path.\n+  - new option --index-search for online help support.\n+* makeinfo:\n+  - output files removed if errors unless (new option) --force.\n+  - new option -P to prepend to search path.\n+  - macro expansion file can be standard output.\n+* install-info creates a new dir file if necessary.\n+* update-info script to create a dir file from all info files.\n+* Elisp: texnfo-tex.el and detexinfo.el removed from the distribution;\n+  - texnfo-tex features are now part of standard TeX & Texinfo packages;\n+  - makeinfo --no-headers does a better job than detexinfo.el.\n+* Documentation:\n+  - Updates, revisions, corrections in the manual.\n+  - makeinfo.texi removed, as it was a copy of what was in texinfo.texi.\n+* gettext support in sources, French and German translations included.\n+* info man page removed; use the Texinfo manual.\n+* Automake used, other portability fixes.\n+\n+3.10 (nonexistent)\n+\n 3.9 (4 October 1996)\n * makeinfo:\n   - Give a suppressible (with --no-validate) error for references\n@@ -91,3 +125,205 @@ This file records noteworthy changes.\n Just bug fixes, see ChangeLog for full details. \n \n texinfo-3.0: first release of Texinfo version 2, with many new commands.\n+\n+\n+Here is the separate NEWS for old releases of Info:\n+\n+Version 2.11,     Sat Apr  1 09:15:21 1995\n+\n+Changes since 2.7 beta:\n+\n+Although the basic code remains the same, there are numerous nits\n+fixed, including some display bugs, and a memory leak.  Some changes\n+that have taken place with larger impact include the way in which the\n+(dir) node is built; I have added in support for \"localdir\"\n+directories among other things.  Info files may be stored in\n+compressed formats, and in their own subdirectories; menu items which\n+do not explicitly name the node to which they are attached have the\n+menu item name looked up as an Info file if it is not found within the\n+current document.  This means that the menu item:\n+\n+* Info::\t\tThe Info documentation reader.\n+\n+in (dir) refers to the info node \"(info)Top\".\n+\n+Please see the ChangeLog and documentation for details on other\n+changes.\n+\n+Version 2.7 beta, Wed Dec 30 02:02:38 1992\n+Version 2.6 beta, Tue Dec 22 03:58:07 1992\n+Version 2.5 beta, Tue Dec  8 14:50:35 1992\n+Version 2.4 beta, Sat Nov 28 14:34:02 1992\n+Version 2.3 beta, Fri Nov 27 01:04:13 1992\n+Version 2.2 beta, Tue Nov 24 09:36:08 1992\n+Version 2.1 beta, Tue Nov 17 23:29:36 1992\n+\n+Changes since 2.5 beta:\n+\n+Note that versions 2.6 and 2.7 Beta were only released to a select group.\n+\n+* \"info-\" removed from the front of M-x commands.\n+\n+* Automatic footnote display.  When you enter a node which contains\n+  footnotes, and the variable \"automatic-footnotes\" is \"On\", Info pops\n+  up a window containing the footnotes.  Likewise, when you leave that\n+  node, the window containing the footnotes goes away.\n+\n+* Cleaner built in documentation, and documentation functions.\n+\n+  Use:\n+    o `M-x describe-variable' to read a variable's documenation\n+    o `M-x describe-key' to find out what a particular keystroke does.\n+    o `M-x describe-function' to read a function's documentation.\n+    o `M-x where-is' to find out what keys invoke a particular function.\n+\n+* Info can \"tile\" the displayed windows (via \"M-x tile-windows\").  If\n+  the variable \"automatic-tiling\" is \"On\", then splitting a window or\n+  deleting a window causes the remaining windows to be retiled.\n+\n+* You can save every keystroke you type in a \"dribble file\" by using the\n+  `--dribble FILENAME' option.  You can initially read keystrokes from an\n+  alternate input stream with `--restore FILENAME', or by redirecting\n+  input on the command line `info < old-dribble'.\n+\n+* New behaviour of menu items.  If the label is the same as the\n+  target node name, and the node couldn't be found in the current file,\n+  treat the label as a file name.  For example, a menu entry in \"DIR\"\n+  might contain:\n+\n+    * Emacs::\t\tCool text-editor.\n+\n+  Info would not find the node \"(dir)Emacs\", so just plain \"(emacs)\"\n+  would be tried.\n+\n+* New variable \"ISO-Latin\" allows you to use European machines with\n+  8-bit character sets.\n+\n+* Cleanups in echo area reading, and redisplay.  Cleanups in handling the\n+  window which shows possible completions.\n+\n+* Info can now read files that have been compressed.  An array in filesys.c\n+  maps extensions to programs that can decompress stdin, and write the results\n+  to stdout.  Currently, \".Z\"/uncompress, \".z\"/gunzip, and \".Y\"/unyabba are\n+  supported.  The modeline for a compressed file shows \"zz\" in it.\n+\n+* There is a new variable \"gc-compressed-files\" which, if non-zero, says\n+  it is okay to reclaim the file buffer space allocated to a file which\n+  was compressed, if, and only if, that file's contents do not appear in\n+  any history node.\n+\n+* New file `nodemenu.c' implements a few functions for manipulating\n+  previously visited nodes.  `C-x C-b' (list-visited-nodes) produces a\n+  menu of the nodes that could be reached by info-history-node in some\n+  window.  `C-x b' (select-visited-node) is similar, but reads one of\n+  the node names with completion.\n+\n+* Keystroke `M-r' (move_to_screen_line) allows the user to place the cursor at\n+  the start of a specific screen line.  Without a numeric argument, place the\n+  cursor on the center line; with an arg, place the cursor on that line.\n+\n+* Interruptible display implemented.  Basic display speedups and hacks.\n+* The message \"*** Tags Out of Date ***\" now means what it says.\n+* Index searching with `,' (info-index-next) has been improved.\n+* When scrolling with C-v, C-M-v, or M-v, only \"Page Only\" scrolling\n+  will happen.\n+\n+* Continous scrolling (along with `]' (info-global-next) and `['\n+  (info-global-prev) works better.  `]' and `[' accept numeric\n+  arguments, moving that many nodes in that case.\n+\n+* `C-x w' (info-toggle-wrap) controls how lines wider than the width\n+  of the screen are displayed.  If a line is too long, a `$' is\n+  displayed in the rightmost column of the window.\n+\n+* There are some new variables for controlling the behaviour of Info\n+  interactively.  The current list of variables is as follows:\n+\n+  Variable Name      Default Value  Description\n+  -------------      -------------  -----------\n+  `automatic-footnotes' On\t    When \"On\", footnotes appear and\n+\t\t\t\t    disappear automatically.\n+\n+  `automatic-tiling'    Off\t    When \"On\", creating of deleting a\n+\t\t\t\t    window resizes other windows.\n+\n+  `visible-bell'        Off\t    If non-zero, try to use a visible bell.\n+\n+  `errors-ring-bell'    On\t    If non-zero, errors cause a ring.\n+\n+  `show-index-match'    On\t    If non-zero, the portion of the string\n+\t\t\t\t    matched is highlighted by changing its\n+\t\t\t\t    case.\n+\n+  `scroll-behaviour'    Continuous  One of \"Continuous\", \"Next Only\", or\n+\t\t\t\t    \"Page Only\".  \"Page Only\" prevents you from\n+\t\t\t\t    scrolling past the bottom or top of a node.\n+\t\t\t\t    \"Next Only\" causes the Next or Prev node to\n+\t\t\t\t    be selected when you scroll past the bottom\n+\t\t\t\t    or top of a node.  \"Continous\" moves\n+\t\t\t\t    linearly through the files hierchichal\n+\t\t\t\t    structure.\n+\n+  `scroll-step'\t        0\t    Controls how scrolling is done for you when\n+\t\t\t\t    the cursor moves out of the current window.\n+\t\t\t\t    Non-zero means it is the number of lines\n+\t\t\t\t    you would like the screen to shift.  A\n+\t\t\t\t    value of 0 means to center the line\n+\t\t\t\t    containing the cursor in the window.\n+\n+  `gc-compressed-files' Off\t    If non-zero means it is okay to reclaim the\n+\t\t\t\t    file buffer space allocated to a file which\n+\t\t\t\t    was compressed, if, and only if, that\n+\t\t\t\t    file's contents do not appear in the node\n+\t\t\t\t    list of any window.\n+\n+  `ISO-Latin'\t        Off\t    Non-zero means that you are using an ISO\n+\t\t\t\t    Latin character set.  By default, standard\n+\t\t\t\t    ASCII characters are assumed.\n+________________________________________\n+This release of Info is version 2.5 beta.\n+\n+Changes since 2.4 beta:\n+\n+* Index (i) and (,) commands fully implemented.\n+* \"configure\" script now shipped with Info.\n+* New function \"set-variable\" allows users to set various variables.\n+* User-settable behaviour on end or beginning of node scrolling.  This\n+  supercedes the SPC and DEL changes in 2.3 beta.\n+\n+________________________________________\n+This release of Info is version 2.4 beta.\n+\n+Changes since 2.3 beta:\n+\n+* info-last-node now means move to the last node of this info file.\n+* info-history-node means move backwards through this window's node history.\n+* info-first-node moves to the first node in the Info file.  This node is\n+  not necessarily \"Top\"!\n+* SPC and DEL can select the Next or Prev node after printing an informative\n+  message when pressed at the end/beg of a node.\n+\n+----------------------------------------\n+This release of Info is version 2.3 beta.\n+\n+Changes since 2.2 beta:\n+\n+* M-x command lines if NAMED_COMMANDS is #defined.  Variable in Makefile.\n+* Screen height changes made quite robust.\n+* Interactive function \"set-screen-height\" implements user height changes.\n+* Scrolling on some terminals is faster now.\n+* C-l with numeric arguement is fixed.\n+\n+----------------------------------------\n+This release of Info is version 2.2 beta.\n+\n+Changes since 2.0:\n+\n+* C-g can now interrupt multi-file searches.\n+* Incremental search is fully implemented.\n+* Loading large tag tables is much faster now.\n+* makedoc.c replaces shell script, speeding incremental builds.\n+* Scrolling in redisplay is implemented.\n+* Recursive uses of the echo area made more robust.\n+* Garbage collection of unreferenced nodes.\n+"}, {"sha": "0312f85e6f651931cccbdbeb8d45b62774b66498", "filename": "texinfo/README", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2FREADME?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,23 +1,38 @@\n-Texinfo, Version 3\n-==================\n+This is the README file for the GNU Texinfo distribution.\n+\n+Please email bugs or suggestions to bug-texinfo@prep.ai.mit.edu.\n \n-This is the README file for version 3 of the Texinfo distribution.\n Files within this distribution have their own version and edition\n-numbers.  When you refer to a file, please mention its own number, as\n+numbers.  When you refer to a file, please mention its own version, as\n well as the version number of the Texinfo distribution.\n \n-PLEASE REPORT BUGS TO: bug-texinfo@prep.ai.mit.edu\n+For instructions on compiling and installing info, makeinfo, texi2dvi,\n+and texindex, please read the file `INSTALL'.  Also:\n+\n+    * The Emacs Lisp files are not compiled or installed by default; to\n+      install them, use `make install' in the `emacs' subdirectory.  See\n+      ./emacs/README for some considerations.\n+\n+    * The Info tree uses a file `dir' as its root node; the `dir-example'\n+      file in this distribution is included for informative purposes.\n+      Use it or not as you like.\n+\n+    * You can create a file texinfo.cnf to be read by TeX when\n+      processing Texinfo manuals.  For example, it might contain the\n+      command @afourpaper.  See the `Preparing for TeX' node in\n+      texinfo.texi for more details.\n+\n \n Texinfo is a documentation system that uses a single source file to\n-produce both on-line information and printed output.  This means that\n-instead of writing two different documents, one for the on-line help\n-or other on-line information and the other for a typeset manual or\n-other printed work, you need write only one document.  When the work\n-is revised, you need revise only one document.  You can read the\n-on-line information, known as an \"Info file\", with an Info\n-documentation-reading program.  By convention, Texinfo source file\n-names end with a `.texi' or `.texinfo' extension.  Texinfo is\n-described in the Texinfo manual (the file ./texinfo.texi).\n+produce both online information and printed output.  This means that\n+instead of writing two different documents, one for the online help or\n+other online information and the other for a typeset manual or other\n+printed work, you need write only one document.  When the work is\n+revised, you need revise only one document.  You can read the online\n+information, known as an \"Info file\", with an Info documentation-reading\n+program.  By convention, Texinfo source file names end with a `.texi' or\n+`.texinfo' extension.  Texinfo is described in the Texinfo manual (the\n+file ./doc/texinfo.texi).\n \n You can write and format Texinfo files into Info files within GNU Emacs,\n and read them using the Emacs Info reader.  If you do not have Emacs,\n@@ -26,22 +41,15 @@ them using `info'.  Use TeX, which is not included in this package (see\n `How to Obtain TeX' in the Texinfo manual for information), to typeset\n Texinfo files for printing.\n \n-For instructions on compiling and installing info, makeinfo, texi2dvi,\n-and texindex, please read the file `INSTALL'.  The Emacs Lisp files are\n-not installed by default; to install them, use `make install' in the\n-`emacs' subdirectory.  The Info tree uses a file `dir' as its root node;\n-a sample `dir' file is included in the distribution, but not installed\n-anywhere. Use it or not as you like.\n \n This distribution includes (but is not limited to) the following files:\n \n     README                      This file.\n-\n     INTRODUCTION                This file tells you how to create\n                                 readable files from the Texinfo source\n                                 files in this distribution.\n \n-Texinfo source files:\n+Texinfo source files (in ./doc):\n \n     texinfo.texi                This manual describes Texinfo.  It\n                                 tells how to use Texinfo to write\n@@ -61,15 +69,8 @@ Texinfo source files:\n \n     info-stnd.texi              This manual tells you how to use\n                                 the standalone GNU Info reader that is\n-                                included in this distribution as a C\n-                                source file, `info.c'.\n-\n-    makeinfo.texi               This manual tells you how to use\n-                                makeinfo.  The same information is\n-                                contained in a chapter of the Texinfo\n-                                manual; it has been extracted here for\n-                                your convenience.\n-\n+                                included in this distribution as C\n+                                source (./info).\n \n Printing related files:\n \n@@ -78,18 +79,18 @@ Printing related files:\n                                 Texinfo file into a DVI file ready for\n                                 printing.\n \n-    texindex.c                  This file contains the source for\n+    util/texindex.c             This file contains the source for\n                                 the `texindex' program that generates\n                                 sorted indices used by TeX when\n                                 typesetting a file for printing.\n \n-    texi2dvi                    This is a shell script for\n+    util/texi2dvi               This is a shell script for\n                                 producing an indexed DVI file using\n                                 TeX and texindex. Must be used if the\n                                 source document uses Texinfo @macros.\n \n \n-GNU Emacs related files:\n+GNU Emacs related files (in ./emacs):\n \n     texinfmt.el                 This Emacs Lisp file provides the\n                                 functions that GNU Emacs uses to\n@@ -100,19 +101,15 @@ GNU Emacs related files:\n                                 for GNU Emacs.\n \n     texnfo-upd.el               These files provides commands to\n-    texnfo-tex.el               help you write Texinfo files\n-    makeinfo.el                 using GNU Emacs Texinfo mode.\n-\n-    detexinfo.el                This extra utility file contains functions \n-                                to remove Texinfo commands from a\n-                                Texinfo source file.\n+    makeinfo.el                 help you write Texinfo files\n+                                using GNU Emacs Texinfo mode.\n \n     info.el                     These are the standard GNU Emacs\n     informat.el                 Info reading and support files,\n                                 included here for your convenience.\n  \n \n-Source files for standalone C programs:\n+Source files for standalone C programs (./lib, ./makeinfo, ./info):\n \n     makeinfo.c                  This file contains the source for\n                                 the `makeinfo' program that you can\n@@ -128,18 +125,22 @@ Source files for standalone C programs:\n     getopt.h\n \n \n-C Installation files:\n+Installation files:\n \n     configure                   This file creates creates a Makefile \n                                 which in turn creates an `info' or\n                                 `makeinfo' executable, or a C sources\n                                 distribution.\n \n     configure.in                This is a template for creating \n-                                `configure' using m4 macros.\n+                                `configure' using Autoconf.\n \n     Makefile.in                 This is a template for `configure' \n-                                to use to make a Makefile.\n+                                to use to make a Makefile.  Created by\n+                                Automake.\n+                               \n+    Makefile.am                 This is a template for Automake\n+                                to use to make a Makefile.in.\n                                \n \n Other files:\n@@ -148,10 +149,6 @@ Other files:\n                                 features since the first edition \n                                 of Texinfo.\n \n-    info.1                      This is a `man' page that briefly \n-                                describes the standalone `info'\n-                                program.\n-\n     fixfonts                    This is a shell script to install the \n                                 `lcircle10' TeX fonts as an alias for\n                                 the `circle10' fonts.  In some older"}, {"sha": "7a7eb858e8c211ad7b835b7fafe17b24763c2b48", "filename": "texinfo/TODO", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2FTODO?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,35 +1,78 @@\n If you are interested in working on any of these,\n email bug-texinfo@prep.ai.mit.edu.\n \n-* Use Automake.\n+* Makeinfo:\n+  - HTML output.\n+  - A detexinfo program, like detex or delatex.  This command would\n+    strip all the texinfo commands out, and would be used as a filter on\n+    the way to a speller.  An option would be to NOT strip comments out.\n+    makeinfo --no-headers comes close.\n+  - If node name contains an @ command, complain explicitly.\n+  - Better ASCII output: convert menus to single table of contents,\n+    enumerate chapters and sections, convert cross-refs and indices to\n+    chapter/section references.  See:\n+       ftp://ftp.simtel.net/pub/simtelnet/gnu/djgpp/v2/faq201s.zip\n \n-* Use a config header file instead of @DEFS@.\n+n* TeX:\n+  - Use @ as the escape character, and Texinfo syntax generally, in the\n+    table of contents, aux, and index files.  Eliminate all the crazy\n+    multiple redefinitions of every Texinfo command in different contexts.\n+  - Handle @hsep and @vsep in @multitables.\n \n-* A detexinfo program, like detex or delatex.  This command would\n-  strip all the texinfo commands out, and would be used as a filter on\n-  the way to a speller.  An option would be to NOT strip comments out.\n-  makeinfo --no-headers come close.\n+* General:\n+  - Better i18n support, including support for 8-bit input characters,\n+    and 8-bit output in info.  Perhaps have to use the ec fonts.\n+  - Support compressed image files, automatic generation of .txt\n+    or .jpg from .eps by Ghostscript.\n+  - Repeat TeX run until cross-references stabilize, not just twice.\n+    (Document this in manual and fix texi2dvi.)\n+  - Handle reference card creation, perhaps by only paying attention to\n+    sectioning and @def... commands.\n+  - Allow : in node names for info files, for names like `class::method'.\n+  - Get Info declared as a MIME Content-Type.\n \n-* Change bars.  This is difficult or impossible in TeX,\n-  unfortunately.  To do it right requires device driver support.\n+* Language:\n+  - @figure:\n+@figure [xref-label]\n+@figureinclude <filename>, [<height>], [<width>]\n+@figurehsize <dimen>\n+@figurevsize <dimen>\n+@caption ... @end caption\n+<arbitrary Texinfo commands>\n+@end figure\n+  - @flushboth to combine @flushleft and @flushright, for RFC's.\n+  - @part sectioning command.\n+  - Anchors a la HTML?\n+  - Allow subitems and `see' and `see also' in indices.\n+  - @exercise/@answer command for, e.g., gawk.\n+  - Allow @hsep/@vsep at @item, instead of just in template.\n+  - The dark corner symbol for the gawk manual.\n+  - Change bars.  This is difficult or impossible in TeX,\n+    unfortunately.  To do it right requires device driver support.\n \n-* The dark corner symbol for the gawk manual.\n+* Doc:\n+  - Include a complete functional summary, as in a reference card, in\n+    the manual.\n+  - Improve the manuals for makeinfo, standalone info, etc.\n+  - Page 39, need a new section on doing dedication pages. See gawk.texi\n+    for an example of doing it in both the tex and info versions.\n \n-* Better i18n support, including support for 8-bit input\n-  characters.  Requires fonts, and the DC fonts are not (as of this\n-  writing) free.\n+* Info:\n+  - Search all nodes of dir file at startup, then can have\n+    INFO-DIR-SEPARATE-GROUPS and other such.\n+  - Better dir file merging.\n+  - Steal interface ideas from Lynx: TAB for navigating to next link\n+    within a page, number links, etc.\n+  - q within help should quit help like C-x 0.\n+  - Full-text search on all available info files.\n+  - Incorporate an X-based viewer, perhaps tkinfo:\n+    http://www.math.ucsb.edu/~boldt/tkinfo/.\n+  - Perhaps process Texinfo files directly instead of converting to Info:\n+    ftp://ftp.cs.berkeley.edu/ucb/people/phelps/tcltk/tkman.tar.Z\n+    + ftp://ftp.cs.berkeley.edu/ucb/people/phelps/tcltk/rman.tar.Z\n+    + Tcl/Tk 8.0 from ftp.smli.com in the /pub/tcl directory.\n+    From: phelps@ecstasy.CS.Berkeley.EDU (Tom Phelps)\n \n-* @exercise/@answer command for, e.g., gawk.\n-\n-* @figure.\n-\n-* HTML output in makeinfo.\n-\n-* Include a complete functional summary, a la a reference card, in the manual.\n-\n-* Use @ as the escape character, and Texinfo syntax generally, in the\n-  table of contents, aux, and index files.  Eliminate all the crazy\n-  redefinitions of every Texinfo command (which lists always seem to be\n-  incomplete).\n-\n-* Improve the manuals for makeinfo, standalone info, etc.\n+* Install-info:\n+  - be able to copy the info file to compile-time $(infodir), to\n+    simplify by-hand installation."}, {"sha": "d6f8d500764440ec0813ff2e1cb55921713f092a", "filename": "texinfo/dir-example", "status": "modified", "additions": 197, "deletions": 185, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fdir-example", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fdir-example", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Fdir-example?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -3,7 +3,7 @@ topmost node of the Info hierarchy.  This file is merely made available\n for your hacking pleasure, not official or standard in any way.\n If it doesn't make sense to you, or you don't like it, ignore it.\n \n-$Id: dir-example,v 1.1 1997/08/21 22:57:52 jason Exp $\n+$Id: dir,v 1.23 1997/07/25 18:05:32 karl Exp $\n \u001f\n File: dir\tNode: Top\tThis is the top of the INFO tree.\n \n@@ -17,293 +17,305 @@ This node gives a menu of the major topics accessible through Info.\n * Menu:\n \n GNU packages\n-* Bash: (bash).                 Bourne again shell.\n-* Cpio: (cpio).                 Cpio archiver.\n-* DC: (dc).                     Postfix arbitrary expression calculator.\n-* Diff: (diff).                 Comparing and merging programs.\n-* Ed: (ed).                     Line editor.\n-* Emacs: (emacs).               Extensible self-documenting text editor.\n+* Bash: (bash).\t\t\tBourne again shell.\n+* Cpio: (cpio).\t\t\tCpio archiver.\n+* DC: (dc).\t\t\tPostfix arbitrary expression calculator.\n+* Diff: (diff).\t\t\tComparing and merging programs.\n+* Ed: (ed).\t\t\tLine editor.\n+* Emacs: (emacs).\t\tExtensible self-documenting text editor.\n * File utilities: (fileutils).  GNU file utilities.\n-* Finding files: (find).        Operating on files matching certain criteria.\n-* Font utilities: (fontu).      Programs for font manipulation.\n-* Gawk: (gawk).                 A text processing and scanning language.\n-* Gzip: (gzip).                 General (de)compression.\n-* Identifier DB: (id-utils).    Identifier database utilities.\n-* Ispell: (ispell).             Interactive spelling corrector.\n-* M4: (m4).                     Macro processor.\n-* Make: (make).                 Remake files automatically.\n-* Ptx: (ptx).                   Permuted index generator.\n-* Shar: (sharutils).            Shell archiver, uudecode/uuencode.\n+* Finding files: (find).\tOperating on files matching certain criteria.\n+* Font utilities: (fontu).\tPrograms for font manipulation.\n+* Gawk: (gawk.info).            A text scanning and processing language.\n+* Gzip: (gzip).\t\t\tGeneral (de)compression.\n+* Identifier DB: (id-utils).\tIdentifier database utilities.\n+* Ispell: (ispell).\t\tInteractive spelling corrector.\n+* M4: (m4).\t\t\tMacro processor.\n+* Make: (make).\t\t\tRemake files automatically.\n+* Ptx: (ptx).\t\t\tPermuted index generator.\n+* Shar: (sharutils).\t\tShell archiver, uudecode/uuencode.\n * Shell utilities: (sh-utils).  GNU shell utilities.\n-* Tar: (tar).                   ``Tape'' archiver.\n+* tar: (tar).\t\t\tMaking tape (or disk) archives.\n * Text utilities: (textutils).  GNU text utilities.\n-* Time: (time).                 Measuring program resource usage.\n-* UUCP: (uucp).                 Copying between machines, offline.\n-* Wdiff: (wdiff).               Word-by-word comparison.\n+* Time: (time).\t\t\tMeasuring program resource usage.\n+* UUCP: (uucp).\t\t\tCopying between machines, offline.\n+* Wdiff: (wdiff).\t\tWord-by-word comparison.\n+* Wget: (wget).                 URL download.\n \n GNU programming tools\n-* As: (as).                     Assembler.\n-* Binutils: (binutils).         ar/copy/objdump/nm/size/strip/ranlib.\n-* Bison: (bison).               LALR(1) parser generator.\n-* CPP: (cpp).                   C preprocessor.\n-* CVS: (cvs).                   Concurrent versions system for source control.\n-* DejaGnu: (dejagnu).           Testing framework.\n-* Flex: (flex).                 A fast scanner generator.\n-* Gasp: (gasp).                 GNU Assembler preprocessor.\n-* Libtool: (libtool).           Generic library support script.\n-* GCC: (gcc).                   C compiler.\n-* GDB: (gdb).                   Source-level debugger for C and C++.\n-* Gperf: (gperf).               Perfect hash function generator.\n-* Gprof: (gprof).               Profiler.\n-* Indent: (indent).             Prettyprinter for programs.\n-* Ld: (ld).                     Linker.\n+* As: (as).\t\t\tAssembler.\n+* Binutils: (binutils).\t\tar/copy/objdump/nm/size/strip/ranlib.\n+* Bison: (bison).\t\tLALR(1) parser generator.\n+* CPP: (cpp).\t\t\tC preprocessor.\n+* CVS: (cvs).\t\t\tConcurrent versions system for source control.\n+* DejaGnu: (dejagnu).\t\tTesting framework.\n+* Flex: (flex).\t\t\tA fast scanner generator.\n+* Gasp: (gasp).\t\t\tGNU Assembler preprocessor.\n+* Libtool: (libtool).\t\tGeneric library support script.\n+* GCC: (gcc).\t\t\tC compiler.\n+* GDB: (gdb).\t\t\tSource-level debugger for C and C++.\n+* Gettext Utilities: (gettext).\tGNU gettext utilities.\n+* Gperf: (gperf).\t\tPerfect hash function generator.\n+* Gprof: (gprof).\t\tProfiler.\n+* Indent: (indent).\t\tPrettyprinter for programs.\n+* Ld: (ld).\t\t\tLinker.\n \n Texinfo documentation system\n * Info: (info).                 Documentation browsing system.\n * Texinfo: (texinfo).           The GNU documentation format.\n+* info program: (info-stnd).\tStandalone Info-reading program.\n * install-info: (texinfo)Invoking install-info. Updating info/dir entries.\n * texi2dvi: (texinfo)Format with texi2dvi.      Printing Texinfo documentation.\n * texindex: (texinfo)Format with tex/texindex.  Sorting Texinfo index files.\n-* info program: (info-stnd).    Standalone Info-reading program.\n-* makeinfo: (makeinfo).         Convert Texinfo source to Info or plain ASCII.\n+* makeinfo: (texinfo)makeinfo preferred.        Translate Texinfo source.\n \n GNU Emacs Lisp\n-* Elisp: (elisp).               GNU Emacs Lisp reference manual.\n+* Elisp: (elisp).\t\tGNU Emacs Lisp reference manual.\n * Intro Elisp: (emacs-lisp-intro). Introduction to Elisp programming.\n \n-* Calc: (calc).                 Calculator and more.\n-* CC-mode: (ccmode).            Editing C, C++, and Objective C.\n-* Common Lisp: (cl).            Partial Common Lisp support for Emacs Lisp.\n-* Dired-x: (dired-x).           Extra directory editor features.\n-* Edebug: (edebug).             Source-level debugger for Emacs Lisp.\n-* Ediff: (ediff).               Comprehensive visual interface to diff & patch.\n-* EDB: (edb).                   Database for Emacs.\n-* Forms: (forms).               Fill-in-the-form data entry.\n-* Gmhist: (gmhist).             Generic minibuffer history.\n-* GNUS: (gnus).                 Netnews reading and posting.\n-* Mailcrypt: (mailcrypt).       Use PGP in Emacs.\n-* MH-E: (mh-e).                 Emacs interface to the MH mail system.\n-* PCL-CVS: (pcl-cvs).           Emacs front end to CVS.\n-* Supercite: (sc).              Supercite for including other people's words.\n-* VIP: (vip).                   vi emulation.\n-* VIPER: (viper).               The new VI-emulation mode in Emacs-19.29.\n-* VM: (vm).                     Mail reader.\n-* W3: (w3).                     WWW browser.\n+* Calc: (calc).\t\t\tCalculator and more.\n+* CC-mode: (ccmode).\t\tEditing C, C++, and Objective C.\n+* Common Lisp: (cl).\t\tPartial Common Lisp support for Emacs Lisp.\n+* Dired-x: (dired-x).\t\tExtra directory editor features.\n+* Edebug: (edebug).\t\tSource-level debugger for Emacs Lisp.\n+* Ediff: (ediff).\t\tComprehensive visual interface to diff & patch.\n+* EDB: (edb).\t\t\tDatabase for Emacs.\n+* Forms: (forms).\t\tFill-in-the-form data entry.\n+* Gmhist: (gmhist).\t\tGeneric minibuffer history.\n+* GNUS: (gnus).\t\t\tNetnews reading and posting.\n+* Mailcrypt: (mailcrypt).\tUse PGP in Emacs.\n+* MH-E: (mh-e).\t\t\tEmacs interface to the MH mail system.\n+* PCL-CVS: (pcl-cvs).\t\tEmacs front end to CVS.\n+* Supercite: (sc).\t\tSupercite for including other people's words.\n+* VIP: (vip).\t\t\tvi emulation.\n+* VIPER: (viper).\t\tThe new VI-emulation mode in Emacs-19.29.\n+* VM: (vm).\t\t\tMail reader.\n+* W3: (w3).\t\t\tWWW browser.\n \n-GNU admin\n-* Autoconf: (autoconf).         Automatic generation of package configuration.\n-* Automake: (automake).         Making Makefile.in's.\n-* Configure: (configure).       Cygnus configure.\n-* Gettext: (gettext).           Internationalization.\n-* Gnats: (gnats).               Cygnus bug tracking system.\n-* Maintaining: (maintain).      Maintaining GNU software.\n-* Remsync: (remsync).           Remote synchronization of directory trees.\n-* Send PR: (send-pr).           Cygnus bug reporting for Gnats.\n-* Source config: (cfg-paper).   Some theory on configuring source packages.\n-* Standards: (standards).       GNU coding standards.\n+GNU programming support\n+* Autoconf: (autoconf).\t\tAutomatic generation of package configuration.\n+* Configure: (configure).\tCygnus configure.\n+* Gnats: (gnats).\t\tCygnus bug tracking system.\n+* Remsync: (remsync).\t\tRemote synchronization of directory trees.\n+* Send PR: (send-pr).\t\tCygnus bug reporting for Gnats.\n \n GNU libraries\n-* Annotate: (annotate).         High-level GDB to GUI's.\n-* BFD: (bfd).                   Binary file descriptors for object file IO.\n-* GDB library: (libgdb).        Application programming interface to GDB.\n-* GDBM: (gdbm).                 Hashed databases.\n-* History: (history).           Recall previous lines of input.\n-* Iostream: (iostream).         C++ input/output.\n-* Libc: (libc).                 C library.\n-* Libg++: (libg++).             C++ classes.\n-* Mmalloc: (mmalloc).           Memory-mapped malloc.\n-* Readline: (readline).         General command-line interface.\n-* Regex: (regex).               Regular expressions.\n-* Termcap: (termcap).           All about /etc/termcap.\n+* Annotate: (annotate).\t\tHigh-level GDB to GUI's.\n+* BFD: (bfd).\t\t\tBinary file descriptors for object file IO.\n+* GDB library: (libgdb).\tApplication programming interface to GDB.\n+* GDBM: (gdbm).\t\t\tHashed databases.\n+* History: (history).\t\tRecall previous lines of input.\n+* Iostream: (iostream).\t\tC++ input/output.\n+* Libc: (libc).\t\t\tC library.\n+* Libg++: (libg++).\t\tC++ classes.\n+* Mmalloc: (mmalloc).\t\tMemory-mapped malloc.\n+* Readline: (readline).\t\tGeneral command-line interface.\n+* Regex: (regex).\t\tRegular expressions.\n+* Termcap: (termcap).\t\tAll about /etc/termcap.\n \n GNU programming documentation\n-* GDB internals: (gdbint).      Debugger internals.\n-* Ld internals: (ldint).        GNU linker internals.\n-* Stabs: (stabs).               Symbol table debugging information format.\n+* GDB internals: (gdbint).\tDebugger internals.\n+* Ld internals: (ldint).\tGNU linker internals.\n+* Maintaining: (maintain).\tMaintaining GNU software.\n+* Source config: (cfg-paper).\tSome theory on configuring source packages.\n+* Stabs: (stabs).\t\tSymbol table debugging information format.\n+* Standards: (standards).\tGNU coding standards.\n \n DOS\n-* Demacs: (demacs).             GNU Emacs for DOS.\n-* GNUish: (gnuish).             GNU utilities for DOS.\n+* Demacs: (demacs).\t\tGNU Emacs for DOS.\n+* GNUish: (gnuish).\t\tGNU utilities for DOS.\n \n TeX things\n * Afm2tfm: (dvips)Invoking afm2tfm.  Making Type 1 fonts available to TeX.\n-* Dvips: (dvips).               DVI-to-PostScript translator.\n-* Eplain: (eplain).             Expanding on plain TeX.\n-* Kpathsearch: (kpathsea).      File lookup along search paths.\n-* LaTeX: (latex).               LaTeX.\n-* MakeIndex: (makeindex).       Index creation for TeX.\n-* Naming fonts: (fontname).     Filenames for TeX fonts.\n-* TeXDraw: (texdraw).           Drawing PostScript diagrams within TeX.\n-* Web2c: (web2c).               TeX, Metafont, and their companion programs.\n+* Dvips: (dvips).\t\tDVI-to-PostScript translator.\n+* Eplain: (eplain).\t\tExpanding on plain TeX.\n+* Kpathsearch: (kpathsea).\tFile lookup along search paths.\n+* LaTeX: (latex).\t\tLaTeX.\n+* MakeIndex: (makeindex).\tIndex creation for TeX.\n+* Naming fonts: (fontname).\tFilenames for TeX fonts.\n+* TDS: (tds).\t\t\tStandard TeX directory structure.\n+* TeXDraw: (texdraw).\t\tDrawing PostScript diagrams within TeX.\n+* Web2c: (web2c).\t\tTeX, Metafont, and their companion programs.\n \n Other things\n-* Amd: (amdref).                Filesystem automounter.\n-* CMUCL: (cmu-user).            CMU Common Lisp.\n-* File headers: (filehdr).      Bibliographic information for computer files.\n-* HTML: (snafu).                Hypertext Markup Language 2.0 specification.\n-* Jargon: (jargon).             The jargon file.\n-* Perl: (perl).                 Practical extraction and report language.\n+* Amd: (amdref).\t\tFilesystem automounter.\n+* CMUCL: (cmu-user).\t\tCMU Common Lisp.\n+* File headers: (filehdr).\tBibliographic information for computer files.\n+* GCP: (gcp).\t\t\tGame club protocol.\n+* HTML: (snafu).\t\tHypertext Markup Language 2.0 specification.\n+* Jargon: (jargon).\t\tThe jargon file.\n+* Perl: (perl).\t\t\tPractical extraction and report language.\n * PRCS: (prcs).\t\t\tProject revision control system.\n-* Screen: (screen).             Virtual screen manager.\n-* UMB C.S. Dept.: (csinfo).     UMass/Boston Computer Science Dept. info.\n+* Screen: (screen).\t\tVirtual screen manager.\n+* UMB C.S. Dept.: (csinfo).\tUMass/Boston Computer Science Dept. info.\n \n Individual utilities\n-* aid: (id-utils)aid invocation.                Matching strings.\n-* ar: (binutils)ar.                             Create/modify/extract archives.\n-* at-pr: (gnats)at-pr.                          Bug report timely reminders.\n-* autoreconf: (autoconf)Invoking autoreconf.    Remake multiple configure's.\n-* autoscan: (autoconf)Invoking autoscan.        Automate initial configure.in.\n-* awk: (Gawk)Invoking gawk.                     Text processing and scanning.\n+* aclocal: (automake)Invoking aclocal.          Generating aclocal.m4.\n+* aid: (id-utils)aid invocation.\t\tMatching strings.\n+* ar: (binutils)ar.\t\t\t\tCreate/modify/extract archives.\n+* at-pr: (gnats)at-pr.\t\t\t\tBug report timely reminders.\n+* automake: (automake).\t\t                Making Makefile.in's.\n+* autoreconf: (autoconf)Invoking autoreconf.\tRemake multiple configure's.\n+* autoscan: (autoconf)Invoking autoscan.\tAutomate initial configure.in.\n+* awk: (gawk)Invoking gawk.\t\t\tText processing and scanning.\n * basename: (sh-utils)basename invocation.      Strip directory and suffix.\n-* bibtex: (web2c)BibTeX invocation.             Maintaining bibliographies.\n-* c++filt: (binutils)c++filt.                   Demangle C++ symbols.\n+* bibtex: (web2c)BibTeX invocation.\t\tMaintaining bibliographies.\n+* c++filt: (binutils)c++filt.\t\t\tDemangle C++ symbols.\n * cat: (textutils)cat invocation.               Concatenate and write files.\n * chgrp: (fileutils)chgrp invocation.           Change file groups.\n * chmod: (fileutils)chmod invocation.           Change file permissions.\n * chown: (fileutils)chown invocation.           Change file owners/groups.\n * chroot: (sh-utils)chroot invocation.          Specify the root directory.\n * cksum: (textutils)cksum invocation.           Print POSIX CRC checksum.\n-* cmp: (diff)Invoking cmp.                      Character-by-character diff.\n+* cmp: (diff)Invoking cmp.\t\t\tCharacter-by-character diff.\n * comm: (textutils)comm invocation.             Compare sorted files by line.\n * cp: (fileutils)cp invocation.                 Copy files.\n * csplit: (textutils)csplit invocation.         Split by context.\n * cut: (textutils)cut invocation.               Print selected parts of lines.\n * date: (sh-utils)date invocation.              Print/set system date and time.\n * dd: (fileutils)dd invocation.                 Copy and convert a file.\n-* df: (fileutils)df invocation.                 Report filesystems' disk usage.\n-* diff3: (diff)Invoking diff3.                  Three-way diff.\n+* df: (fileutils)df invocation.                 Report filesystem disk usage.\n+* diff3: (diff)Invoking diff3.\t\t\tThree-way diff.\n * dir: (fileutils)dir invocation.               List directories briefly.\n+* dircolors: (fileutils)dircolors invocation.   Color setup for ls.\n * dirname: (sh-utils)dirname invocation.        Strip non-directory suffix.\n-* dmp: (web2c)Dmp invocation.                   Troff->MPX (MetaPost pictures).\n+* dmp: (web2c)Dmp invocation.\t\t\tTroff->MPX (MetaPost pictures).\n * du: (fileutils)du invocation.                 Report on disk usage.\n-* dvicopy: (web2c)DVIcopy invocation.           Virtual font expansion\n-* dvitomp: (web2c)DVItoMP invocation.           DVI to MPX (MetaPost pictures).\n-* dvitype: (web2c)DVItype invocation.           DVI to human-readable text.\n+* dvicopy: (web2c)DVIcopy invocation.\t\tVirtual font expansion\n+* dvitomp: (web2c)DVItoMP invocation.\t\tDVI to MPX (MetaPost pictures).\n+* dvitype: (web2c)DVItype invocation.\t\tDVI to human-readable text.\n * echo: (sh-utils)echo invocation.              Print a line of text.\n-* edit-pr: (gnats)Invoking edit-pr.             Changing bugs.\n-* eid: (id-utils)eid invocation.                Invoking an editor on matches.\n+* edit-pr: (gnats)Invoking edit-pr.\t\tChanging bugs.\n+* eid: (id-utils)eid invocation.\t\tInvoking an editor on matches.\n * emacsclient: (emacs)Emacs Server.\t\tConnecting to a running Emacs.\n * emacsserver: (emacs)Emacs Server.\t\tConnecting to a running Emacs.\n * env: (sh-utils)env invocation.                Modify the environment.\n * etags: (emacs)Create Tags Table.\t\tCreating a TAGS table.\n * expand: (textutils)expand invocation.         Convert tabs to spaces.\n * expr: (sh-utils)expr invocation.              Evaluate expressions.\n+* factor: (sh-utils)factor invocation.          Print prime factors\n * false: (sh-utils)false invocation.            Do nothing, unsuccessfully.\n-* fid: (id-utils)fid invocation.                Listing a file's identifiers.\n-* file-pr: (gnats)file-pr.                      Processing incoming traffic.\n-* find: (find)Invoking find.                    Finding and acting on files.\n+* fid: (id-utils)fid invocation.\t\tListing a file's identifiers.\n+* file-pr: (gnats)file-pr.\t\t\tProcessing incoming traffic.\n+* find: (find)Invoking find.\t\t\tFinding and acting on files.\n * fmt: (textutils)fmt invocation.               Reformat paragraph text.\n * fold: (textutils)fold invocation.             Wrap long input lines.\n-* g++: (gcc)Invoking G++.                       The GNU C++ compiler.\n-* gftodvi: (web2c)GFtoDVI invocation.           Generic font proofsheets.\n-* gftopk: (web2c)GFtoPK invocation.             Generic to packed fonts.\n-* gftype: (web2c)GFtype invocation.             GF to human-readable text.\n-* gid: (id-utils)gid invocation.                Listing all matching lines.\n+* g++: (gcc)Invoking G++.\t\t\tThe GNU C++ compiler.\n+* gettextize: (gettext)gettextize Invocation.\tPrepare a package for gettext.\n+* gftodvi: (web2c)GFtoDVI invocation.\t\tGeneric font proofsheets.\n+* gftopk: (web2c)GFtoPK invocation.\t\tGeneric to packed fonts.\n+* gftype: (web2c)GFtype invocation.\t\tGF to human-readable text.\n+* gid: (id-utils)gid invocation.\t\tListing all matching lines.\n * groups: (sh-utils)groups invocation.          Print group names a user is in.\n-* gunzip: (gzip)Overview.                       Decompression.\n+* gunzip: (gzip)Overview.\t\t\tDecompression.\n * head: (textutils)head invocation.             Output the first part of files.\n * hostname: (sh-utils)hostname invocation.      Print or set system name.\n * id: (sh-utils)id invocation.                  Print real/effective uid/gid.\n-* idx: (id-utils)idx invocation.                Testing mkid scanners.\n-* ifnames: (autoconf)Invoking ifnames.          List conditionals in source.\n-* iid: (id-utils)iid invocation.                Interactive complex queries.\n-* inimf: (web2c)inimf invocation.               Initial Metafont.\n-* inimp: (web2c)inimp invocation.               Initial MetaPost.\n-* initex: (web2c)initex invocation.             Initial TeX.\n+* idx: (id-utils)idx invocation.\t\tTesting mkid scanners.\n+* ifnames: (autoconf)Invoking ifnames.\t\tList conditionals in source.\n+* iid: (id-utils)iid invocation.\t\tInteractive complex queries.\n+* inimf: (web2c)inimf invocation.\t\tInitial Metafont.\n+* inimp: (web2c)inimp invocation.\t\tInitial MetaPost.\n+* initex: (web2c)initex invocation.\t\tInitial TeX.\n * install: (fileutils)install invocation.       Copy and change attributes.\n * join: (textutils)join invocation.             Join lines on a common field.\n-* kpsewhich: (kpathsea)Invoking kpsewhich.      TeX file searching.\n-* lid: (id-utils)lid invocation.                Matching identifier patterns.\n+* kpsewhich: (kpathsea)Invoking kpsewhich.\tTeX file searching.\n+* lid: (id-utils)lid invocation.\t\tMatching identifier patterns.\n * ln: (fileutils)ln invocation.                 Make links between files.\n-* locate: (find)Invoking locate.                Finding files in a database.\n+* locate: (find)Invoking locate.\t\tFinding files in a database.\n * logname: (sh-utils)logname invocation.        Print current login name.\n * ls: (fileutils)ls invocation.                 List directory contents.\n-* makempx: (web2c)MakeMPX invocation.           MetaPost label typesetting.\n-* maketexmf: (kpathsea)MakeTeX scripts.         MF source generation.\n-* maketexpk: (kpathsea)MakeTeX scripts.         PK bitmap generation.\n-* maketextex: (kpathsea)MakeTeX scripts.        TeX source generation.\n-* maketextfm: (kpathsea)MakeTeX scripts.        TeX font metric generation.\n-* mf: (web2c)mf invocation.                     Creating typeface families.\n-* mft: (web2c)MFT invocation.                   Prettyprinting Metafont source.\n+* makempx: (web2c)MakeMPX invocation.\t\tMetaPost label typesetting.\n+* maketexmf: (kpathsea)MakeTeX scripts.\t\tMF source generation.\n+* maketexpk: (kpathsea)MakeTeX scripts.\t\tPK bitmap generation.\n+* maketextex: (kpathsea)MakeTeX scripts.\tTeX source generation.\n+* maketextfm: (kpathsea)MakeTeX scripts.\tTeX font metric generation.\n+* md5sum: (textutils)md5sum invocation.         Print or check message-digests.\n+* mf: (web2c)mf invocation.\t\t\tCreating typeface families.\n+* mft: (web2c)MFT invocation.\t\t\tPrettyprinting Metafont source.\n * mkdir: (fileutils)mkdir invocation.           Create directories.\n * mkfifo: (fileutils)mkfifo invocation.         Create FIFOs: (named pipes).\n-* mkid: (id-utils)mkid invocation.              Creating an ID database.\n+* mkid: (id-utils)mkid invocation.\t\tCreating an ID database.\n * mknod: (fileutils)mknod invocation.           Create special files.\n-* mp: (web2c)mp invocation.                     Creating technical diagrams.\n-* mpto: (web2c)MPto invocation.                 MetaPost label extraction.\n+* mp: (web2c)mp invocation.\t\t\tCreating technical diagrams.\n+* mpto: (web2c)MPto invocation.\t\t\tMetaPost label extraction.\n+* msgfmt: (gettext)msgfmt Invocation.\t\tMake MO files out of PO files.\n+* msgmerge: (gettext)msgmerge Invocation.\tUpdate two PO files into one.\n * mv: (fileutils)mv invocation.                 Rename files.\n-* newer: (web2c)Newer invocation.               Compare modification times.\n+* newer: (web2c)Newer invocation.\t\tCompare modification times.\n * nice: (sh-utils)nice invocation.              Modify scheduling priority.\n * nl: (textutils)nl invocation.                 Number lines and write files.\n-* nlmconv: (binutils)nlmconv.                   Convert object to NetWare LM.\n-* nm: (binutils)nm.                             List symbols in object files.\n+* nlmconv: (binutils)nlmconv.\t\t\tConvert object to NetWare LM.\n+* nm: (binutils)nm.\t\t\t\tList symbols in object files.\n * nohup: (sh-utils)nohup invocation.            Immunize to hangups.\n-* objcopy: (binutils)objcopy.                   Copy/translate object files.\n-* objdump: (binutils)objdump.                   Display info from object files.\n+* objcopy: (binutils)objcopy.\t\t\tCopy/translate object files.\n+* objdump: (binutils)objdump.\t\t\tDisplay info from object files.\n * od: (textutils)od invocation.                 Dump files in octal, etc.\n * paste: (textutils)paste invocation.           Merge lines of files.\n-* patch: (diff)Invoking patch.                  Automatically applying diffs.\n-* patgen: (web2c)Patgen invocation.             Creating hyphenation patterns.\n+* patch: (diff)Invoking patch.\t\t\tAutomatically applying diffs.\n+* patgen: (web2c)Patgen invocation.\t\tCreating hyphenation patterns.\n * pathchk: (sh-utils)pathchk invocation.        Check file name portability.\n-* pid: (id-utils)pid invocation.                Looking up filenames.\n-* pktogf: (web2c)PKtoGF invocation.             Packed to generic fonts.\n-* pktype: (web2c)PKtype invocation.             PK to human-readable text.\n-* pltotf: (web2c)PLtoTF invocation.             Property list to TFM.\n-* pooltype: (web2c)Pooltype invocation.         Display WEB pool files.\n-* pr-addr: (gnats)pr-addr.                      Bug report address retrieval.\n-* pr-edit: (gnats)pr-edit.                      The edit-pr driver.\n+* pid: (id-utils)pid invocation.\t\tLooking up filenames.\n+* pktogf: (web2c)PKtoGF invocation.\t\tPacked to generic fonts.\n+* pktype: (web2c)PKtype invocation.\t\tPK to human-readable text.\n+* pltotf: (web2c)PLtoTF invocation.\t\tProperty list to TFM.\n+* pooltype: (web2c)Pooltype invocation.\t\tDisplay WEB pool files.\n+* pr-addr: (gnats)pr-addr.\t\t\tBug report address retrieval.\n+* pr-edit: (gnats)pr-edit.\t\t\tThe edit-pr driver.\n * pr: (textutils)pr invocation.                 Paginate or columnate files.\n * printenv: (sh-utils)printenv invocation.      Print environment variables.\n * printf: (sh-utils)printf invocation.          Format and print data.\n * pwd: (sh-utils)pwd invocation.                Print working directory.\n-* query-pr: (gnats)Invoking query-pr.           Bug searching/reporting.\n-* queue-pr: (gnats)queue-pr.                    Handling incoming traffic.\n-* ranlib: (binutils)ranlib.                     Index archive file contents.\n+* query-pr: (gnats)Invoking query-pr.\t\tBug searching/reporting.\n+* queue-pr: (gnats)queue-pr.\t\t\tHandling incoming traffic.\n+* ranlib: (binutils)ranlib.\t\t\tIndex archive file contents.\n * rm: (fileutils)rm invocation.                 Remove files.\n * rmdir: (fileutils)rmdir invocation.           Remove empty directories.\n-* sdiff: (diff)Invoking sdiff.                  Interactively merge files.\n-* send-pr: (gnats)Invoking send-pr.             Submitting bugs.\n-* shar: (sharutils)shar invocation.             Create shell archive.\n-* size: (binutils)size.                         List object file section sizes.\n+* sdiff: (diff)Invoking sdiff.\t\t\tInteractively merge files.\n+* send-pr: (gnats)Invoking send-pr.\t\tSubmitting bugs.\n+* seq: (sh-utils)seq invocation.                Print numeric sequences\n+* shar: (sharutils)shar invocation.\t\tCreate shell archive.\n+* size: (binutils)size.\t\t\t\tList object file section sizes.\n * sleep: (sh-utils)sleep invocation.            Delay for a specified time.\n * sort: (textutils)sort invocation.             Sort text files.\n * split: (textutils)split invocation.           Split into fixed-size pieces.\n-* strings: (binutils)strings.                   List printable strings.\n-* strip: (binutils)strip.                       Discard symbols.\n+* strings: (binutils)strings.\t\t\tList printable strings.\n+* strip: (binutils)strip.\t\t\tDiscard symbols.\n * stty: (sh-utils)stty invocation.              Print/change terminal settings.\n * su: (sh-utils)su invocation.                  Modify user and group id.\n * sum: (textutils)sum invocation.               Print traditional checksum.\n * sync: (fileutils)sync invocation.             Synchronize memory and disk.\n-* tabs: (tput)Invoking tabs.                    Tab settings.\n+* tabs: (tput)Invoking tabs.\t\t\tTab settings.\n * tac: (textutils)tac invocation.               Reverse files.\n * tail: (textutils)tail invocation.             Output the last part of files.\n-* tangle: (web2c)Tangle invocation.             WEB to Pascal.\n+* tangle: (web2c)Tangle invocation.\t\tWEB to Pascal.\n * tee: (sh-utils)tee invocation.                Redirect to multiple files.\n * test: (sh-utils)test invocation.              File/string tests.\n-* tex: (web2c)tex invocation.                   Typesetting.\n-* tftopl: (web2c)TFtoPL invocation.             TFM -> property list.\n+* tex: (web2c)tex invocation.\t\t\tTypesetting.\n+* tftopl: (web2c)TFtoPL invocation.\t\tTFM -> property list.\n * touch: (fileutils)touch invocation.           Change file timestamps.\n-* tput: (tput)Invoking tput.                    Termcap in shell scripts.\n+* tput: (tput)Invoking tput.\t\t\tTermcap in shell scripts.\n * tr: (textutils)tr invocation.                 Translate characters.\n * true: (sh-utils)true invocation.              Do nothing, successfully.\n * tty: (sh-utils)tty invocation.                Print terminal name.\n * uname: (sh-utils)uname invocation.            Print system information.\n * unexpand: (textutils)unexpand invocation.     Convert spaces to tabs.\n * uniq: (textutils)uniq invocation.             Uniqify files.\n-* unshar: (sharutils)unshar invocation.         Extract from shell archive.\n-* updatedb: (find)Invoking updatedb.            Building the locate database.\n+* unshar: (sharutils)unshar invocation.\t\tExtract from shell archive.\n+* updatedb: (find)Invoking updatedb.\t\tBuilding the locate database.\n * users: (sh-utils)users invocation.            Print current user names.\n * vdir: (fileutils)vdir invocation.             List directories verbosely.\n-* vftovp: (web2c)VFtoVP invocation.             Virtual font -> virtual pl.\n-* view-pr: (gnats)Invoking view-pr.             Showing bug reports.\n-* virmf: (web2c)virmf invocation.               Virgin Metafont.\n-* virmp: (web2c)virmp invocation.               Virgin MetaPost.\n-* virtex: (web2c)virtex invocation.             Virgin TeX.\n-* vptovf: (web2c)VPtoVF invocation.             Virtual pl -> virtual font.\n+* vftovp: (web2c)VFtoVP invocation.\t\tVirtual font -> virtual pl.\n+* view-pr: (gnats)Invoking view-pr.\t\tShowing bug reports.\n+* virmf: (web2c)virmf invocation.\t\tVirgin Metafont.\n+* virmp: (web2c)virmp invocation.\t\tVirgin MetaPost.\n+* virtex: (web2c)virtex invocation.\t\tVirgin TeX.\n+* vptovf: (web2c)VPtoVF invocation.\t\tVirtual pl -> virtual font.\n * wc: (textutils)wc invocation.                 Byte, word, and line counts.\n-* weave: (web2c)Weave invocation.               WEB to TeX.\n+* weave: (web2c)Weave invocation.\t\tWEB to TeX.\n * who: (sh-utils)who invocation.                Print who is logged in.\n * whoami: (sh-utils)whoami invocation.          Print effective user id.\n-* xargs: (find)Invoking xargs.                  Operating on many files.\n+* xargs: (find)Invoking xargs.\t\t\tOperating on many files.\n+* xgettext: (gettext)xgettext Invocation.\tExtract strings into a PO file.\n * yes: (sh-utils)yes invocation.                Print a string indefinitely.\n-* zcat: (gzip)Overview.                         Decompression to stdout.\n+* zcat: (gzip)Overview.\t\t\t\tDecompression to stdout."}, {"sha": "f200fa5934d8e8de633b558799f4191a05ba6b01", "filename": "texinfo/emacs/Makefile.in", "status": "modified", "additions": 193, "deletions": 80, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2FMakefile.in?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,91 +1,204 @@\n-# Makefile for Texinfo/emacs.\n-# Copyright (C) 1995, 96 Free Software Foundation, Inc.\n-# $Id: Makefile.in,v 1.1 1997/08/21 22:57:56 jason Exp $\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-#\n-# Author: Brian J. Fox (bfox@ai.mit.edu)\n-#\n+# Makefile.in generated automatically by automake 1.2 from Makefile.am\n \n-srcdir = @srcdir@\n-VPATH = @srcdir@\n-SHELL = /bin/sh\n-RM = rm -f\n+# Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy, distribute and modify it.\n \n+# Do not byte compile our Elisp files by default.\n \n-ELISP_SRCS = info.el makeinfo.el texinfo.el texnfo-upd.el \\\n-\t      texnfo-tex.el texinfmt.el informat.el detexinfo.el\n-ELISP_OBJS = info.elc makeinfo.elc texinfo.elc texnfo-upd.elc \\\n-\t      texnfo-tex.elc texinfmt.elc informat.elc detexinfo.elc\n \n-.SUFFIXES: .el .elc\n+SHELL = /bin/sh\n \n-.el.elc:\n-\t$(srcdir)/elisp-comp $<\n+srcdir = @srcdir@\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n+\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n+\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+\n+top_builddir = ..\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n+\n+INSTALL = @INSTALL@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+transform = @program_transform_name@\n+\n+NORMAL_INSTALL = true\n+PRE_INSTALL = true\n+POST_INSTALL = true\n+NORMAL_UNINSTALL = true\n+PRE_UNINSTALL = true\n+POST_UNINSTALL = true\n+CATALOGS = @CATALOGS@\n+CATOBJEXT = @CATOBJEXT@\n+CC = @CC@\n+DATADIRNAME = @DATADIRNAME@\n+EXEEXT = @EXEEXT@\n+GENCAT = @GENCAT@\n+GMOFILES = @GMOFILES@\n+GMSGFMT = @GMSGFMT@\n+GT_NO = @GT_NO@\n+GT_YES = @GT_YES@\n+INSTOBJEXT = @INSTOBJEXT@\n+INTLDEPS = @INTLDEPS@\n+INTLLIBS = @INTLLIBS@\n+INTLOBJS = @INTLOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKINSTALLDIRS = @MKINSTALLDIRS@\n+MSGFMT = @MSGFMT@\n+PACKAGE = @PACKAGE@\n+POFILES = @POFILES@\n+POSUB = @POSUB@\n+RANLIB = @RANLIB@\n+TERMLIBS = @TERMLIBS@\n+TEXCONFIG = @TEXCONFIG@\n+TEXMF = @TEXMF@\n+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@\n+USE_NLS = @USE_NLS@\n+VERSION = @VERSION@\n+l = @l@\n+\n+ELCFILES =\n+\n+# Do not install our Elisp files by default, either.\n+noinst_LISP = info.el informat.el makeinfo.el \\\n+              texinfmt.el texinfo.el texnfo-upd.el\n+\n+EXTRA_DIST = README elisp-comp new-useful-setqs $(noinst_LISP)\n+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n+CONFIG_HEADER = ../config.h\n+CONFIG_CLEAN_FILES = \n+LISP =  $(noinst_LISP)\n+\n+lispdir = @lispdir@\n+EMACS = @EMACS@\n+DIST_COMMON =  README Makefile.am Makefile.in elisp-comp\n+\n+\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n+\n+TAR = tar\n+GZIP = --best\n+default: all\n+\n+.SUFFIXES:\n+.SUFFIXES: .el .elc\n+$(srcdir)/Makefile.in: @MAINT@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus emacs/Makefile\n \n-all:\n-sub-all: all\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n \n+.el.elc:\n+\t@echo 'WARNING: Warnings can be ignored. :-)'\n+\tif test $(EMACS) != no; then \\\n+\t  EMACS=$(EMACS) $(SHELL) $(srcdir)/elisp-comp $<; \\\n+\tfi\n+tags: TAGS\n+TAGS:\n+\n+\n+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n+\n+subdir = emacs\n+\n+distdir: $(DISTFILES)\n+\t@for file in $(DISTFILES); do \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  test -f $(distdir)/$$file \\\n+\t  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t  || cp -p $$d/$$file $(distdir)/$$file; \\\n+\tdone\n+info:\n dvi:\n+check: all\n+\t$(MAKE)\n+installcheck:\n install-info:\n+install-exec: \n+\t@$(NORMAL_INSTALL)\n+\n+install-data: install-data-local\n+\t@$(NORMAL_INSTALL)\n+\n+install: install-exec install-data all\n+\t@:\n+\n+uninstall: \n+\n+all: Makefile $(LISP) $(ELCFILES)\n+\n+install-strip:\n+\t$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install\n+installdirs:\n+\n+\n+mostlyclean-generic:\n+\ttest -z \"$(MOSTLYCLEANFILES)\" || rm -f $(MOSTLYCLEANFILES)\n+\n+clean-generic:\n+\ttest -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\trm -f Makefile $(DISTCLEANFILES)\n+\trm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\ttest -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\n+maintainer-clean-generic:\n+\ttest -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n+\ttest -z \"$(BUILT_SOURCES)\" || rm -f $(BUILT_SOURCES)\n+mostlyclean:  mostlyclean-lisp mostlyclean-generic\n+\n+clean:  clean-lisp clean-generic mostlyclean\n+\n+distclean:  distclean-lisp distclean-generic clean\n+\trm -f config.status\n+\n+maintainer-clean:  maintainer-clean-lisp maintainer-clean-generic \\\n+\t\tdistclean\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\n+.PHONY: default mostlyclean-lisp distclean-lisp clean-lisp \\\n+maintainer-clean-lisp tags distdir info dvi installcheck install-info \\\n+install-exec install-data install uninstall all installdirs \\\n+mostlyclean-generic distclean-generic clean-generic \\\n+maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n+\n+\n+install-data-local:\n+\t@echo \"WARNING: You must (compile and) install the Emacs Lisp files\"\n+\t@echo \"WARNING: manually.  See ./emacs/README for some considerations.\"\n \n-elisp: $(ELISP_OBJS)\n-.PHONY: elisp\n-\n-# Nobody likes any of these install targets.  Fine.  Install it\n-# manually, then.\n-install:\n-\t@echo Please install the Emacs Lisp files manually.\n-\n-uninstall:\n-\t@echo Please uninstall the Emacs Lisp files manually.\n-\n-# install: $(ELISP_OBJS)\n-# \t @(echo \"(print (car load-path))\" >/tmp/elc.$$$$; \\\n-# \t   lispdir=`emacs -batch -q -l /tmp/elc.$$$$ -nw | grep site-lisp`; \\\n-# \t   rm /tmp/elc.$$$$; \\\n-# \t   if [ \"$$lispdir\" != \"\" ]; then \\\n-# \t     lispdir=`echo $$lispdir | sed -e 's/\"//g'`; \\\n-# \t     echo \"Installing .elc files in $$lispdir.\"; \\\n-# \t     $(CP) $(ELISP_OBJS) $$lispdir; \\\n-# \t   else \\\n-# \t     echo \"To install the elisp files, please copy *.elc to the\"; \\\n-# \t     echo \"emacs site-lisp directory.\"; \\\n-# \t   fi)\n-#\n-# install: $(ELISP_OBJS)\n-# \t for file in $(ELISP_OBJS); do \\\n-# \t   $(INSTALL_DATA) $$file $(lispdir); \\\n-#\t done\n-#\n-# uninstall: $(ELISP_OBJS)\n-# \tcd $(lispdir) && rm -f $(ELISP_OBJS)\n-#\n-informat.elc: info.elc\n-makeinfo.elc: texinfo.elc\n-texinfmt.elc: texinfo.elc\n-texinfmt.elc: texnfo-upd.elc\n-\n-Makefile: $(srcdir)/Makefile.in ../config.status\n-\tcd .. && sh config.status\n-\n-realclean distclean: clean\n-\t$(RM) Makefile *.log\n-\n-clean: FORCE\n-\t$(RM) *.elc\n-\n-FORCE:\n+# For some reason these do not get defined.\n+distclean-lisp:\n+clean-lisp:\n+mostlyclean-lisp:\n \n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "ec21f5b9ff92fbcc8cdd2381af7d31467f6e7218", "filename": "texinfo/emacs/info.el", "status": "modified", "additions": 294, "deletions": 108, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Finfo.el", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Finfo.el", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2Finfo.el?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,6 +1,7 @@\n ;;; info.el --- info package for Emacs.\n \n-;; Copyright (C) 1985, 1986, 1992, 1993, 1994 Free Software Foundation, Inc.\n+;; Copyright (C) 1985, 86, 92, 93, 94, 95, 96, 97 Free Software\n+;; Foundation, Inc.\n \n ;; Maintainer: FSF\n ;; Keywords: help\n@@ -28,27 +29,39 @@\n \n ;;; Code:\n \n+(defgroup info nil\n+  \"Info subsystem\"\n+  :group 'help\n+  :group 'docs)\n+\n+\n (defvar Info-history nil\n   \"List of info nodes user has visited.\n Each element of list is a list (FILENAME NODENAME BUFFERPOS).\")\n \n-(defvar Info-enable-edit nil\n+(defcustom Info-enable-edit nil\n   \"*Non-nil means the \\\\<Info-mode-map>\\\\[Info-edit] command in Info can edit the current node.\n This is convenient if you want to write info files by hand.\n However, we recommend that you not do this.\n It is better to write a Texinfo file and generate the Info file from that,\n-because that gives you a printed manual as well.\")\n+because that gives you a printed manual as well.\"\n+  :type 'boolean\n+  :group 'info)\n \n (defvar Info-enable-active-nodes nil\n   \"Non-nil allows Info to execute Lisp code associated with nodes.\n The Lisp code is executed when the node is selected.\")\n (put 'Info-enable-active-nodes 'risky-local-variable t)\n \n-(defvar Info-fontify t\n-  \"*Non-nil enables highlighting and fonts in Info nodes.\")\n+(defcustom Info-fontify t\n+  \"*Non-nil enables highlighting and fonts in Info nodes.\"\n+  :type 'boolean\n+  :group 'info)\n \n-(defvar Info-fontify-maximum-menu-size 30000\n-  \"*Maximum size of menu to fontify if `Info-fontify' is non-nil.\")\n+(defcustom Info-fontify-maximum-menu-size 30000\n+  \"*Maximum size of menu to fontify if `Info-fontify' is non-nil.\"\n+  :type 'integer\n+  :group 'info)\n \n (defvar Info-directory-list\n   (let ((path (getenv \"INFOPATH\"))\n@@ -98,9 +111,11 @@ source tree, the `info' directory in the source tree is used as the last\n element, in place of the installation Info directory.  This is useful\n when you run a version of Emacs without installing it.\")\n \n-(defvar Info-additional-directory-list nil\n+(defcustom Info-additional-directory-list nil\n   \"List of additional directories to search for Info documentation files.\n-These directories are not searched for merging the `dir' file.\")\n+These directories are not searched for merging the `dir' file.\"\n+  :type '(repeat directory)\n+  :group 'info)\n \n (defvar Info-current-file nil\n   \"Info file that Info is now looking at, or nil.\n@@ -114,10 +129,13 @@ or nil if current info file is not split into subfiles.\")\n (defvar Info-current-node nil\n   \"Name of node that Info is now looking at, or nil.\")\n \n-(defvar Info-tag-table-marker (make-marker)\n+(defvar Info-tag-table-marker nil\n   \"Marker pointing at beginning of current Info file's tag table.\n Marker points nowhere if file has no tag table.\")\n \n+(defvar Info-tag-table-buffer nil\n+  \"Buffer used for indirect tag tables.\")\n+\n (defvar Info-current-file-completions nil\n   \"Cached completion list for current Info file.\")\n \n@@ -133,16 +151,26 @@ Marker points nowhere if file has no tag table.\")\n \t (\".z\"       . \"gunzip\")\n \t (\".inf\"     . nil)\n \t (\"\"         . nil))\n-    '( (\".info.Z\"  . \"uncompress\")\n-       (\".info.Y\"  . \"unyabba\")\n-       (\".info.gz\" . \"gunzip\")\n-       (\".info.z\"  . \"gunzip\")\n-       (\".info\"    . nil)\n-       (\".Z\"       . \"uncompress\")\n-       (\".Y\"       . \"unyabba\")\n-       (\".gz\"      . \"gunzip\")\n-       (\".z\"       . \"gunzip\")\n-       (\"\"         . nil)))\n+    '( (\".info.Z\".    \"uncompress\")\n+       (\".info.Y\".    \"unyabba\")\n+       (\".info.gz\".   \"gunzip\")\n+       (\".info.z\".    \"gunzip\")\n+       (\".info\".      nil)\n+       (\"-info.Z\".   \"uncompress\")\n+       (\"-info.Y\".   \"unyabba\")\n+       (\"-info.gz\".  \"gunzip\")\n+       (\"-info.z\".   \"gunzip\")\n+       (\"-info\".     nil)\n+       (\"/index.Z\".   \"uncompress\")\n+       (\"/index.Y\".   \"unyabba\")\n+       (\"/index.gz\".  \"gunzip\")\n+       (\"/index.z\".   \"gunzip\")\n+       (\"/index\".     nil)\n+       (\".Z\".         \"uncompress\")\n+       (\".Y\".         \"unyabba\")\n+       (\".gz\".        \"gunzip\")\n+       (\".z\".         \"gunzip\")\n+       (\"\".           nil)))\n   \"List of file name suffixes and associated decoding commands.\n Each entry should be (SUFFIX . STRING); the file is given to\n the command as standard input.  If STRING is nil, no decoding is done.\n@@ -301,7 +329,7 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t    (cons (list Info-current-file Info-current-node (point))\n \t\t  Info-history)))\n   ;; Go into info buffer.\n-  (switch-to-buffer \"*info*\")\n+  (or (eq major-mode 'Info-mode) (pop-to-buffer \"*info*\"))\n   (buffer-disable-undo (current-buffer))\n   (or (eq major-mode 'Info-mode)\n       (Info-mode))\n@@ -316,7 +344,6 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t      (setq Info-current-file nil\n \t\t    Info-current-subfile nil\n \t\t    Info-current-file-completions nil\n-\t\t    Info-index-alternatives nil\n \t\t    buffer-file-name nil)\n \t      (erase-buffer)\n \t      (if (eq filename t)\n@@ -325,12 +352,12 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t\t(setq default-directory (file-name-directory filename)))\n \t      (set-buffer-modified-p nil)\n \t      ;; See whether file has a tag table.  Record the location if yes.\n-\t      (set-marker Info-tag-table-marker nil)\n \t      (goto-char (point-max))\n \t      (forward-line -8)\n \t      ;; Use string-equal, not equal, to ignore text props.\n-\t      (or (string-equal nodename \"*\")\n-\t\t  (not (search-forward \"\\^_\\nEnd tag table\\n\" nil t))\n+\t      (if (not (or (string-equal nodename \"*\")\n+\t\t\t   (not\n+\t\t\t    (search-forward \"\\^_\\nEnd tag table\\n\" nil t))))\n \t\t  (let (pos)\n \t\t    ;; We have a tag table.  Find its beginning.\n \t\t    ;; Is this an indirect file?\n@@ -341,16 +368,21 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t\t\t  (looking-at \"(Indirect)\\n\"))\n \t\t\t;; It is indirect.  Copy it to another buffer\n \t\t\t;; and record that the tag table is in that buffer.\n-\t\t\t(save-excursion\n-\t\t\t  (let ((buf (current-buffer)))\n-\t\t\t    (set-buffer (get-buffer-create \" *info tag table*\"))\n+\t\t\t(let ((buf (current-buffer))\n+\t\t\t      (tagbuf\n+\t\t\t       (or Info-tag-table-buffer\n+\t\t\t\t   (generate-new-buffer \" *info tag table*\"))))\n+\t\t\t  (setq Info-tag-table-buffer tagbuf)\n+\t\t\t  (save-excursion\n+\t\t\t    (set-buffer tagbuf)\n                             (buffer-disable-undo (current-buffer))\n \t\t\t    (setq case-fold-search t)\n \t\t\t    (erase-buffer)\n-\t\t\t    (insert-buffer-substring buf)\n-\t\t\t    (set-marker Info-tag-table-marker\n-\t\t\t\t\t(match-end 0))))\n-\t\t      (set-marker Info-tag-table-marker pos))))\n+\t\t\t    (insert-buffer-substring buf))\n+\t\t\t  (set-marker Info-tag-table-marker\n+\t\t\t\t      (match-end 0) tagbuf))\n+\t\t      (set-marker Info-tag-table-marker pos)))\n+\t\t(set-marker Info-tag-table-marker nil))\n \t      (setq Info-current-file\n \t\t    (if (eq filename t) \"dir\" filename))))\n \t;; Use string-equal, not equal, to ignore text props.\n@@ -365,18 +397,28 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t    ;; read the proper subfile into this buffer.\n \t    (if (marker-position Info-tag-table-marker)\n \t\t(save-excursion\n-\t\t  (set-buffer (marker-buffer Info-tag-table-marker))\n-\t\t  (goto-char Info-tag-table-marker)\n-\t\t  (if (re-search-forward regexp nil t)\n-\t\t      (progn\n-\t\t\t(setq guesspos (read (current-buffer)))\n-\t\t\t;; If this is an indirect file,\n-\t\t\t;; determine which file really holds this node\n-\t\t\t;; and read it in.\n-\t\t\t(if (not (eq (current-buffer) (get-buffer \"*info*\")))\n-\t\t\t    (setq guesspos\n-\t\t\t\t  (Info-read-subfile guesspos))))\n-\t\t    (error \"No such node: %s\" nodename))))\n+\t\t  (let ((m Info-tag-table-marker)\n+\t\t\tfound found-mode)\n+\t\t    (save-excursion\n+\t\t      (set-buffer (marker-buffer m))\n+\t\t      (goto-char m)\n+\t\t      (beginning-of-line) ;so re-search will work.\n+\t\t      (setq found (re-search-forward regexp nil t))\n+\t\t      (if found\n+\t\t\t  (setq guesspos (read (current-buffer))))\n+\t\t      (setq found-mode major-mode))\n+\t\t    (if found\n+\t\t\t(progn\n+\t\t\t  ;; If this is an indirect file, determine\n+\t\t\t  ;; which file really holds this node and\n+\t\t\t  ;; read it in.\n+\t\t\t  (if (not (eq found-mode 'Info-mode))\n+\t\t\t      ;; Note that the current buffer must be\n+\t\t\t      ;; the *info* buffer on entry to\n+\t\t\t      ;; Info-read-subfile.  Thus the hackery\n+\t\t\t      ;; above.\n+\t\t\t      (setq guesspos (Info-read-subfile guesspos))))\n+\t\t      (error \"No such node: %s\" nodename)))))\n \t    (goto-char (max (point-min) (- guesspos 1000)))\n \t    ;; Now search from our advised position (or from beg of buffer)\n \t    ;; to find the actual node.\n@@ -464,7 +506,8 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t\t\t    Info-dir-file-attributes\n \t\t\t    (cons (cons file attrs)\n \t\t\t\t  Info-dir-file-attributes))))))\n-\t  (or (cdr dirs) (setq Info-dir-contents-directory (car dirs)))\n+\t  (or (cdr dirs) (setq Info-dir-contents-directory\n+\t\t\t       (file-name-as-directory (car dirs))))\n \t  (setq dirs (cdr dirs))))\n       \n       (or buffers\n@@ -548,30 +591,39 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n     (setq Info-dir-contents (buffer-string)))\n   (setq default-directory Info-dir-contents-directory))\n \n+;; Note that on entry to this function the current-buffer must be the\n+;; *info* buffer; not the info tags buffer.\n (defun Info-read-subfile (nodepos)\n-  (set-buffer (marker-buffer Info-tag-table-marker))\n-  (goto-char (point-min))\n-  (search-forward \"\\n\\^_\")\n+  ;; NODEPOS is either a position (in the Info file as a whole,\n+  ;; not relative to a subfile) or the name of a subfile.\n   (let (lastfilepos\n \tlastfilename)\n-    (forward-line 2)\n-    (catch 'foo\n-      (while (not (looking-at \"\\^_\"))\n-\t(if (not (eolp))\n-\t    (let ((beg (point))\n-\t\t  thisfilepos thisfilename)\n-\t      (search-forward \": \")\n-\t      (setq thisfilename  (buffer-substring beg (- (point) 2)))\n-\t      (setq thisfilepos (read (current-buffer)))\n-\t      ;; read in version 19 stops at the end of number.\n-\t      ;; Advance to the next line.\n-\t      (forward-line 1)\n-\t      (if (> thisfilepos nodepos)\n-\t\t  (throw 'foo t))\n-\t      (setq lastfilename thisfilename)\n-\t      (setq lastfilepos thisfilepos))\n-\t  (forward-line 1))))\n-    (set-buffer (get-buffer \"*info*\"))\n+    (if (numberp nodepos)\n+\t(save-excursion\n+\t  (set-buffer (marker-buffer Info-tag-table-marker))\n+\t  (goto-char (point-min))\n+\t  (search-forward \"\\n\\^_\")\n+\t  (forward-line 2)\n+\t  (catch 'foo\n+\t    (while (not (looking-at \"\\^_\"))\n+\t      (if (not (eolp))\n+\t\t  (let ((beg (point))\n+\t\t\tthisfilepos thisfilename)\n+\t\t    (search-forward \": \")\n+\t\t    (setq thisfilename  (buffer-substring beg (- (point) 2)))\n+\t\t    (setq thisfilepos (read (current-buffer)))\n+\t\t    ;; read in version 19 stops at the end of number.\n+\t\t    ;; Advance to the next line.\n+\t\t    (forward-line 1)\n+\t\t    (if (> thisfilepos nodepos)\n+\t\t\t(throw 'foo t))\n+\t\t    (setq lastfilename thisfilename)\n+\t\t    (setq lastfilepos thisfilepos))\n+\t\t(forward-line 1)))))\n+      (setq lastfilename nodepos)\n+      (setq lastfilepos 0))\n+    ;; Assume previous buffer is in Info-mode.\n+    ;; (set-buffer (get-buffer \"*info*\"))\n     (or (equal Info-current-subfile lastfilename)\n \t(let ((buffer-read-only nil))\n \t  (setq buffer-file-name nil)\n@@ -582,7 +634,8 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t  (setq Info-current-subfile lastfilename)))\n     (goto-char (point-min))\n     (search-forward \"\\n\\^_\")\n-    (+ (- nodepos lastfilepos) (point))))\n+    (if (numberp nodepos)\n+\t(+ (- nodepos lastfilepos) (point)))))\n \n ;; Select the info node that point is in.\n (defun Info-select-node ()\n@@ -618,7 +671,7 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n (defun Info-set-mode-line ()\n   (setq mode-line-buffer-identification\n \t(concat\n-\t \"Info:  (\"\n+\t \"  Info:  (\"\n \t (if Info-current-file\n \t     (file-name-nondirectory Info-current-file)\n \t   \"\")\n@@ -667,7 +720,7 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n (defun Info-read-node-name (prompt &optional default)\n   (let* ((completion-ignore-case t)\n \t (completion-table (Info-build-node-completions))\n-\t (nodename (completing-read prompt 'Info-read-node-name-1)))\n+\t (nodename (completing-read prompt 'Info-read-node-name-1 nil t)))\n     (if (equal nodename \"\")\n \t(or default\n \t    (Info-read-node-name prompt))\n@@ -679,10 +732,10 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t(save-excursion\n \t  (save-restriction\n \t    (if (marker-buffer Info-tag-table-marker)\n-\t\t(progn\n-\t\t  (set-buffer (marker-buffer Info-tag-table-marker))\n+\t\t(let ((marker Info-tag-table-marker))\n+\t\t  (set-buffer (marker-buffer marker))\n \t\t  (widen)\n-\t\t  (goto-char Info-tag-table-marker)\n+\t\t  (goto-char marker)\n \t\t  (while (re-search-forward \"\\nNode: \\\\(.*\\\\)\\177\" nil t)\n \t\t    (setq compl\n \t\t\t  (cons (list (buffer-substring (match-beginning 1)\n@@ -727,6 +780,7 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t(onode Info-current-node)\n \t(ofile Info-current-file)\n \t(opoint (point))\n+\t(ostart (window-start))\n \t(osubfile Info-current-subfile))\n     (save-excursion\n       (save-restriction\n@@ -739,27 +793,28 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n     (if (not found) ;can only happen in subfile case -- else would have erred\n \t(unwind-protect\n \t    (let ((list ()))\n-\t      (set-buffer (marker-buffer Info-tag-table-marker))\n-\t      (goto-char (point-min))\n-\t      (search-forward \"\\n\\^_\\nIndirect:\")\n-\t      (save-restriction\n-\t\t(narrow-to-region (point)\n-\t\t\t\t  (progn (search-forward \"\\n\\^_\")\n-\t\t\t\t\t (1- (point))))\n+\t      (save-excursion\n+\t\t(set-buffer (marker-buffer Info-tag-table-marker))\n \t\t(goto-char (point-min))\n-\t\t(search-forward (concat \"\\n\" osubfile \": \"))\n-\t\t(beginning-of-line)\n-\t\t(while (not (eobp))\n-\t\t  (re-search-forward \"\\\\(^.*\\\\): [0-9]+$\")\n-\t\t  (goto-char (+ (match-end 1) 2))\n-\t\t  (setq list (cons (cons (read (current-buffer))\n-\t\t\t\t\t (buffer-substring (match-beginning 1)\n-\t\t\t\t\t\t\t   (match-end 1)))\n-\t\t\t\t   list))\n-\t\t  (goto-char (1+ (match-end 0))))\n-\t\t(setq list (nreverse list)\n-\t\t      current (car (car list))\n-\t\t      list (cdr list)))\n+\t\t(search-forward \"\\n\\^_\\nIndirect:\")\n+\t\t(save-restriction\n+\t\t  (narrow-to-region (point)\n+\t\t\t\t    (progn (search-forward \"\\n\\^_\")\n+\t\t\t\t\t   (1- (point))))\n+\t\t  (goto-char (point-min))\n+\t\t  (search-forward (concat \"\\n\" osubfile \": \"))\n+\t\t  (beginning-of-line)\n+\t\t  (while (not (eobp))\n+\t\t    (re-search-forward \"\\\\(^.*\\\\): [0-9]+$\")\n+\t\t    (goto-char (+ (match-end 1) 2))\n+\t\t    (setq list (cons (cons (read (current-buffer))\n+\t\t\t\t\t   (buffer-substring\n+\t\t\t\t\t    (match-beginning 1) (match-end 1)))\n+\t\t\t\t     list))\n+\t\t    (goto-char (1+ (match-end 0))))\n+\t\t  (setq list (nreverse list)\n+\t\t\tcurrent (car (car list))\n+\t\t\tlist (cdr list))))\n \t      (while list\n \t\t(message \"Searching subfile %s...\" (cdr (car list)))\n \t\t(Info-read-subfile (car (car list)))\n@@ -771,9 +826,10 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \t\t  (message \"\")\n \t\t(signal 'search-failed (list regexp))))\n \t  (if (not found)\n-\t      (progn (Info-read-subfile opoint)\n+\t      (progn (Info-read-subfile osubfile)\n \t\t     (goto-char opoint)\n-\t\t     (Info-select-node)))))\n+\t\t     (Info-select-node)\n+\t\t     (set-window-start (selected-window) ostart)))))\n     (widen)\n     (goto-char found)\n     (Info-select-node)\n@@ -800,7 +856,7 @@ In standalone mode, \\\\<Info-mode-map>\\\\[Info-exit] exits Emacs itself.\"\n \n ;; Return the node name in the buffer following point.\n ;; ALLOWEDCHARS, if non-nil, goes within [...] to make a regexp\n-;; saying which chas may appear in the node name.\n+;; saying which chars may appear in the node name.\n (defun Info-following-node-name (&optional allowedchars)\n   (skip-chars-forward \" \\t\")\n   (buffer-substring-no-properties\n@@ -884,9 +940,18 @@ NAME may be an abbreviation of the reference name.\"\n \t ;; Record as a completion and perhaps as default.\n \t (if (eq default t) (setq default str))\n \t (if (eq alt-default t) (setq alt-default str))\n-\t (setq completions\n-\t       (cons (cons str nil)\n-\t\t     completions))))\n+\t ;; Don't add this string if it's a duplicate.\n+\t ;; We use a loop instead of \"(assoc str completions)\" because\n+\t ;; we want to do a case-insensitive compare.\n+\t (let ((tail completions)\n+\t       (tem (downcase str)))\n+\t   (while (and tail\n+\t\t       (not (string-equal tem (downcase (car (car tail))))))\n+\t     (setq tail (cdr tail)))\n+\t   (or tail\n+\t       (setq completions\n+\t\t     (cons (cons str nil)\n+\t\t\t   completions))))))\n      ;; If no good default was found, try an alternate.\n      (or default\n \t (setq default alt-default))\n@@ -1148,8 +1213,7 @@ N is the digit argument used to invoke this command.\"\n   (interactive)\n   (if Info-standalone\n       (save-buffers-kill-emacs)\n-    (switch-to-buffer (prog1 (other-buffer (current-buffer))\n-\t\t\t(bury-buffer (current-buffer))))))\n+    (bury-buffer)))\n \n (defun Info-next-menu-item ()\n   (interactive)\n@@ -1222,9 +1286,15 @@ N is the digit argument used to invoke this command.\"\n \n (defun Info-scroll-up ()\n   \"Scroll one screenful forward in Info, considering all nodes as one sequence.\n-Once you scroll far enough in a node that its menu appears on the screen,\n-the next scroll moves into its first subnode.  When you scroll past\n-the end of a node, that goes to the next node or back up to the parent node.\"\n+Once you scroll far enough in a node that its menu appears on the screen\n+but after point, the next scroll moves into its first subnode.\n+\n+When you scroll past the end of a node, that goes to the next node; if\n+this node has no successor, it moves to the parent node's successor,\n+and so on.  If point is inside the menu of a node, it moves to\n+subnode indicated by the following menu item.  (That case won't\n+normally result from this command, but can happen in other ways.)\"\n+\n   (interactive)\n   (if (or (< (window-start) (point-min))\n \t  (> (window-start) (point-max)))\n@@ -1363,7 +1433,7 @@ Give a blank topic name to go to the Index node itself.\"\n   \"Go to the next matching index item from the last `i' command.\"\n   (interactive \"p\")\n   (or Info-index-alternatives\n-      (error \"No previous `i' command in this file\"))\n+      (error \"No previous `i' command\"))\n   (while (< num 0)\n     (setq num (+ num (length Info-index-alternatives))))\n   (while (> num 0)\n@@ -1446,7 +1516,16 @@ SIG optional fourth argument, controls action on no match\n     a string: signal an error, using that string.\"\n   (save-excursion\n     (goto-char pos)\n-    (re-search-backward start (max (point-min) (- pos 200)) 'yes)\n+    ;; First look for a match for START that goes across POS.\n+    (while (and (not (bobp)) (> (point) (- pos (length start)))\n+\t\t(not (looking-at start)))\n+      (forward-char -1))\n+    ;; If we did not find one, search back for START\n+    ;; (this finds only matches that end at or before POS).\n+    (or (looking-at start)\n+\t(progn\n+\t  (goto-char pos)\n+\t  (re-search-backward start (max (point-min) (- pos 200)) 'yes)))\n     (let (found)\n       (while (and (re-search-forward all (min (point-max) (+ pos 200)) 'yes)\n \t\t  (not (setq found (and (<= (match-beginning 0) pos)\n@@ -1553,6 +1632,92 @@ If no reference to follow, moves to the next node, or up if none.\"\n   (define-key Info-mode-map \"\\177\" 'Info-scroll-down)\n   (define-key Info-mode-map [mouse-2] 'Info-mouse-follow-nearest-node)\n   )\n+\n+(defun Info-check-pointer (item)\n+  ;; Non-nil if ITEM is present in this node.\n+  (condition-case nil\n+      (Info-extract-pointer item)\n+    (error nil)))\n+\n+(easy-menu-define Info-mode-menu Info-mode-map\n+  \"Menu for info files.\"\n+  '(\"Info\"\n+    [\"Up\" Info-up (Info-check-pointer \"up\")]\n+    [\"Next\" Info-next (Info-check-pointer \"next\")]\n+    [\"Previous\" Info-prev (Info-check-pointer \"prev[ious]*\")]\n+    (\"Menu item\" [\"You should never see this\" report-emacs-bug t])\n+    (\"Reference\" [\"You should never see this\" report-emacs-bug t])\n+    [\"Search...\" Info-search t]\n+    [\"Goto node...\" Info-goto-node t]\n+    [\"Last\" Info-last Info-history]\n+    [\"Exit\" Info-exit t]))\n+\n+(defvar Info-menu-last-node nil)\n+;; Last node the menu was created for.\n+\n+(defun Info-menu-update ()\n+  ;; Update the Info menu for the current node.\n+  (condition-case nil\n+      (if (or (not (eq major-mode 'Info-mode))\n+\t      (eq Info-current-node Info-menu-last-node))\n+\t  ()\n+\t;; Update menu menu.\n+\t(let* ((Info-complete-menu-buffer (current-buffer))\n+\t       (items (nreverse (condition-case nil\n+\t\t\t\t    (Info-complete-menu-item\n+\t\t\t\t     \"\" (lambda (e) t) t)\n+\t\t\t\t  (error nil))))\n+\t       entries current \n+\t       (number 0))\n+\t  (while (and items (< number 9))\n+\t    (setq current (car items)\n+\t\t  items (cdr items)\n+\t\t  number (1+ number))\n+\t    (setq entries (cons `[,current \n+\t\t\t\t  (Info-menu ,current)\n+\t\t\t\t  :keys ,(format \"%d\" number)]\n+\t\t\t\tentries)))\n+\t  (if items\n+\t      (setq entries (cons [\"Other...\" Info-menu t] entries)))\n+\t  (or entries\n+\t      (setq entries (list [\"No menu\" nil nil])))\n+\t  (easy-menu-change '(\"Info\") \"Menu item\" (nreverse entries)))\n+\t;; Update reference menu.  Code stolen from `Info-follow-reference'.\n+\t(let ((items nil)\n+\t      str i entries current \n+\t      (number 0))\n+\t  (save-excursion\n+\t    (goto-char (point-min))\n+\t    (while (re-search-forward \"\\\\*note[ \\n\\t]*\\\\([^:]*\\\\):\" nil t)\n+\t      (setq str (buffer-substring\n+\t\t\t (match-beginning 1)\n+\t\t\t (1- (point))))\n+\t      (setq i 0)\n+\t      (while (setq i (string-match \"[ \\n\\t]+\" str i))\n+\t\t(setq str (concat (substring str 0 i) \" \"\n+\t\t\t\t  (substring str (match-end 0))))\n+\t\t(setq i (1+ i)))\n+\t      (setq items\n+\t\t    (cons str items))))\n+\t  (while (and items (< number 9))\n+\t    (setq current (car items)\n+\t\t  items (cdr items)\n+\t\t  number (1+ number))\n+\t    (setq entries (cons `[,current \n+\t\t\t\t  (Info-follow-reference ,current)\n+\t\t\t\t  t]\n+\t\t\t\tentries)))\n+\t  (if items\n+\t      (setq entries (cons [\"Other...\" Info-follow-reference t]\n+\t\t\t\t  entries)))\n+\t  (or entries\n+\t      (setq entries (list [\"No references\" nil nil])))\n+\t  (easy-menu-change '(\"Info\") \"Reference\" (nreverse entries)))\n+\t;; Update last seen node.\n+\t(setq Info-menu-last-node (current-buffer)))\n+    ;; Try to avoid entering infinite beep mode in case of errors.\n+    (error (ding))))\n+\n \f\n ;; Info mode is suitable only for specially formatted data.\n (put 'info-mode 'mode-class 'special)\n@@ -1604,7 +1769,10 @@ Advanced commands:\n   (kill-all-local-variables)\n   (setq major-mode 'Info-mode)\n   (setq mode-name \"Info\")\n+  (setq tab-width 8)\n   (use-local-map Info-mode-map)\n+  (make-local-hook 'activate-menubar-hook)\n+  (add-hook 'activate-menubar-hook 'Info-menu-update nil t)\n   (set-syntax-table text-mode-syntax-table)\n   (setq local-abbrev-table text-mode-abbrev-table)\n   (setq case-fold-search t)\n@@ -1613,9 +1781,12 @@ Advanced commands:\n   (make-local-variable 'Info-current-subfile)\n   (make-local-variable 'Info-current-node)\n   (make-local-variable 'Info-tag-table-marker)\n+  (setq Info-tag-table-marker (make-marker))\n+  (make-local-variable 'Info-tag-table-buffer)\n+  (setq Info-tag-table-buffer nil)\n   (make-local-variable 'Info-history)\n   (make-local-variable 'Info-index-alternatives)\n-  (if (memq (framep (selected-frame)) '(x pc))\n+  (if (memq (framep (selected-frame)) '(x pc w32))\n       (progn\n \t(make-face 'info-node)\n \t(make-face 'info-menu-5)\n@@ -1752,6 +1923,8 @@ the variable `Info-file-list-for-emacs'.\"\n \t  ;; Get Info running, and pop to it in another window.\n \t  (save-window-excursion\n \t    (info))\n+\t  ;; FIXME It would be cool if this could use a buffer other\n+\t  ;; than *info*.\n \t  (pop-to-buffer \"*info*\")\n \t  (Info-find-node (car (car where))\n \t\t\t  (car (cdr (car where))))\n@@ -1786,12 +1959,14 @@ the variable `Info-file-list-for-emacs'.\"\n \t  (t\n \t   (Info-goto-emacs-command-node command)))))\n \f\n-(defvar Info-title-face-alist\n+(defcustom Info-title-face-alist\n   '((?* bold underline)\n     (?= bold-italic underline)\n     (?- italic underline))\n   \"*Alist of face or list of faces to use for pseudo-underlined titles.\n-The alist key is the character the title is underlined with (?*, ?= or ?-).\")\n+The alist key is the character the title is underlined with (?*, ?= or ?-).\"\n+  :type '(repeat (list character face face))\n+  :group 'info)\n \n (defun Info-fontify-node ()\n   (save-excursion\n@@ -1840,6 +2015,17 @@ The alist key is the character the title is underlined with (?*, ?= or ?-).\")\n \t      (put-text-property (match-beginning 1) (match-end 1)\n \t\t\t\t 'mouse-face 'highlight))))\n       (set-buffer-modified-p nil))))\n+\f\n+\n+;; When an Info buffer is killed, make sure the associated tags buffer\n+;; is killed too.\n+(defun Info-kill-buffer ()\n+  (and (eq major-mode 'Info-mode)\n+       Info-tag-table-buffer\n+       (kill-buffer Info-tag-table-buffer)))\n+\n+(add-hook 'kill-buffer-hook 'Info-kill-buffer)\n+  \n \n (provide 'info)\n "}, {"sha": "36f0c560675c9390ad6f927bdb806d7534302809", "filename": "texinfo/emacs/informat.el", "status": "modified", "additions": 70, "deletions": 61, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Finformat.el", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Finformat.el", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2Finformat.el?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -71,7 +71,8 @@\n \t\t      (delete-region (point) end)))\n \t\t(goto-char (point-max))\n \t\t(insert \"\\^_\\f\\nTag table:\\n\")\n-\t\t(move-marker Info-tag-table-marker (point))\n+\t\t(if (eq major-mode 'info-mode)\n+\t\t    (move-marker Info-tag-table-marker (point)))\n \t\t(setq list (nreverse list))\n \t\t(while list\n \t\t  (insert \"Node: \" (car (car list)) ?\\177)\n@@ -152,6 +153,10 @@ contains just the tag table and a directory of subfiles.\"\n     (search-forward \"\\nTag Table:\\n\")\n     (insert \"(Indirect)\\n\")))\n \f\n+(defvar Info-validate-allnodes)\n+(defvar Info-validate-thisnode)\n+(defvar Info-validate-lossages)\n+\n ;;;###autoload\n (defun Info-validate ()\n   \"Check current buffer for validity as an Info file.\n@@ -165,76 +170,77 @@ Check that every node pointer points to an existing node.\"\n \t  (error \"Don't yet know how to validate indirect info files: \\\"%s\\\"\"\n \t\t (buffer-name (current-buffer))))\n       (goto-char (point-min))\n-      (let ((allnodes '((\"*\")))\n+      (let ((Info-validate-allnodes '((\"*\")))\n \t    (regexp \"Node:[ \\t]*\\\\([^,\\n\\t]*\\\\)[,\\t\\n]\")\n \t    (case-fold-search t)\n \t    (tags-losing nil)\n-\t    (lossages ()))\n+\t    (Info-validate-lossages ()))\n \t(while (search-forward \"\\n\\^_\" nil t)\n \t  (forward-line 1)\n \t  (let ((beg (point)))\n \t    (forward-line 1)\n \t    (if (re-search-backward regexp beg t)\n \t\t(let ((name (downcase\n-\t\t\t      (buffer-substring-no-properties\n-\t\t\t        (match-beginning 1)\n-\t\t\t\t(progn\n-\t\t\t\t  (goto-char (match-end 1))\n-\t\t\t\t  (skip-chars-backward \" \\t\")\n-\t\t\t\t  (point))))))\n-\t\t  (if (assoc name allnodes)\n-\t\t      (setq lossages\n+\t\t\t     (buffer-substring-no-properties\n+\t\t\t      (match-beginning 1)\n+\t\t\t      (progn\n+\t\t\t\t(goto-char (match-end 1))\n+\t\t\t\t(skip-chars-backward \" \\t\")\n+\t\t\t\t(point))))))\n+\t\t  (if (assoc name Info-validate-allnodes)\n+\t\t      (setq Info-validate-lossages\n \t\t\t    (cons (list name \"Duplicate node-name\" nil)\n-\t\t\t\t  lossages))\n-\t\t      (setq allnodes\n-\t\t\t    (cons (list name\n-\t\t\t\t\t(progn\n-\t\t\t\t\t  (end-of-line)\n-\t\t\t\t\t  (and (re-search-backward\n-\t\t\t\t\t\t\"prev[ious]*:\" beg t)\n-\t\t\t\t\t       (progn\n-\t\t\t\t\t\t (goto-char (match-end 0))\n-\t\t\t\t\t\t (downcase\n-\t\t\t\t\t\t   (Info-following-node-name)))))\n-\t\t\t\t\tbeg)\n-\t\t\t\t  allnodes)))))))\n+\t\t\t\t  Info-validate-lossages))\n+\t\t    (setq Info-validate-allnodes\n+\t\t\t  (cons (list name\n+\t\t\t\t      (progn\n+\t\t\t\t\t(end-of-line)\n+\t\t\t\t\t(and (re-search-backward\n+\t\t\t\t\t      \"prev[ious]*:\" beg t)\n+\t\t\t\t\t     (progn\n+\t\t\t\t\t       (goto-char (match-end 0))\n+\t\t\t\t\t       (downcase\n+\t\t\t\t\t\t(Info-following-node-name)))))\n+\t\t\t\t      beg)\n+\t\t\t\tInfo-validate-allnodes)))))))\n \t(goto-char (point-min))\n \t(while (search-forward \"\\n\\^_\" nil t)\n \t  (forward-line 1)\n \t  (let ((beg (point))\n-\t\tthisnode next)\n+\t\tInfo-validate-thisnode next)\n \t    (forward-line 1)\n \t    (if (re-search-backward regexp beg t)\n \t\t(save-restriction\n \t\t  (search-forward \"\\n\\^_\" nil 'move)\n \t\t  (narrow-to-region beg (point))\n-\t\t  (setq thisnode (downcase\n-\t\t\t\t   (buffer-substring-no-properties\n-\t\t\t\t     (match-beginning 1)\n-\t\t\t\t     (progn\n-\t\t\t\t       (goto-char (match-end 1))\n-\t\t\t\t       (skip-chars-backward \" \\t\")\n-\t\t\t\t       (point)))))\n+\t\t  (setq Info-validate-thisnode (downcase\n+\t\t\t\t\t\t(buffer-substring-no-properties\n+\t\t\t\t\t\t (match-beginning 1)\n+\t\t\t\t\t\t (progn\n+\t\t\t\t\t\t   (goto-char (match-end 1))\n+\t\t\t\t\t\t   (skip-chars-backward \" \\t\")\n+\t\t\t\t\t\t   (point)))))\n \t\t  (end-of-line)\n \t\t  (and (search-backward \"next:\" nil t)\n \t\t       (setq next (Info-validate-node-name \"invalid Next\"))\n-\t\t       (assoc next allnodes)\n-\t\t       (if (equal (car (cdr (assoc next allnodes)))\n-\t\t\t\t  thisnode)\n+\t\t       (assoc next Info-validate-allnodes)\n+\t\t       (if (equal (car (cdr (assoc next Info-validate-allnodes)))\n+\t\t\t\t  Info-validate-thisnode)\n \t\t\t   ;; allow multiple `next' pointers to one node\n-\t\t\t   (let ((tem lossages))\n+\t\t\t   (let ((tem Info-validate-lossages))\n \t\t\t     (while tem\n \t\t\t       (if (and (equal (car (cdr (car tem)))\n \t\t\t\t\t       \"should have Previous\")\n \t\t\t\t\t(equal (car (car tem))\n \t\t\t\t\t       next))\n-\t\t\t\t   (setq lossages (delq (car tem) lossages)))\n+\t\t\t\t   (setq Info-validate-lossages\n+\t\t\t\t\t (delq (car tem) Info-validate-lossages)))\n \t\t\t       (setq tem (cdr tem))))\n-\t\t\t (setq lossages\n+\t\t\t (setq Info-validate-lossages\n \t\t\t       (cons (list next\n \t\t\t\t\t   \"should have Previous\"\n-\t\t\t\t\t   thisnode)\n-\t\t\t\t     lossages))))\n+\t\t\t\t\t   Info-validate-thisnode)\n+\t\t\t\t     Info-validate-lossages))))\n \t\t  (end-of-line)\n \t\t  (if (re-search-backward \"prev[ious]*:\" nil t)\n \t\t      (Info-validate-node-name \"invalid Previous\"))\n@@ -244,12 +250,12 @@ Check that every node pointer points to an existing node.\"\n \t\t  (if (re-search-forward \"\\n* Menu:\" nil t)\n \t\t      (while (re-search-forward \"\\n\\\\* \" nil t)\n \t\t\t(Info-validate-node-name\n-\t\t\t  (concat \"invalid menu item \"\n-\t\t\t\t  (buffer-substring (point)\n-\t\t\t\t\t\t    (save-excursion\n-\t\t\t\t\t\t      (skip-chars-forward \"^:\")\n-\t\t\t\t\t\t      (point))))\n-\t\t\t  (Info-extract-menu-node-name))))\n+\t\t\t (concat \"invalid menu item \"\n+\t\t\t\t (buffer-substring (point)\n+\t\t\t\t\t\t   (save-excursion\n+\t\t\t\t\t\t     (skip-chars-forward \"^:\")\n+\t\t\t\t\t\t     (point))))\n+\t\t\t (Info-extract-menu-node-name))))\n \t\t  (goto-char (point-min))\n \t\t  (while (re-search-forward \"\\\\*note[ \\n]*[^:\\t]*:\" nil t)\n \t\t    (goto-char (+ (match-beginning 0) 5))\n@@ -262,29 +268,29 @@ Check that every node pointer points to an existing node.\"\n \t\t\t\t\t\t (point))))\n \t\t     (Info-extract-menu-node-name \"Bad format cross-reference\")))))))\n \t(setq tags-losing (not (Info-validate-tags-table)))\n-\t(if (or lossages tags-losing)\n+\t(if (or Info-validate-lossages tags-losing)\n \t    (with-output-to-temp-buffer \" *problems in info file*\"\n-\t      (while lossages\n+\t      (while Info-validate-lossages\n \t\t(princ \"In node \\\"\")\n-\t\t(princ (car (car lossages)))\n+\t\t(princ (car (car Info-validate-lossages)))\n \t\t(princ \"\\\", \")\n-\t\t(let ((tem (nth 1 (car lossages))))\n+\t\t(let ((tem (nth 1 (car Info-validate-lossages))))\n \t\t  (cond ((string-match \"\\n\" tem)\n \t\t\t (princ (substring tem 0 (match-beginning 0)))\n \t\t\t (princ \"...\"))\n \t\t\t(t\n \t\t\t (princ tem))))\n-\t\t(if (nth 2 (car lossages))\n+\t\t(if (nth 2 (car Info-validate-lossages))\n \t\t    (progn\n \t\t      (princ \": \")\n-\t\t      (let ((tem (nth 2 (car lossages))))\n+\t\t      (let ((tem (nth 2 (car Info-validate-lossages))))\n \t\t\t(cond ((string-match \"\\n\" tem)\n \t\t\t       (princ (substring tem 0 (match-beginning 0)))\n \t\t\t       (princ \"...\"))\n \t\t\t      (t\n \t\t\t       (princ tem))))))\n \t\t(terpri)\n-\t\t(setq lossages (cdr lossages)))\n+\t\t(setq Info-validate-lossages (cdr Info-validate-lossages)))\n \t      (if tags-losing (princ \"\\nTags table must be recomputed\\n\")))\n \t  ;; Here if info file is valid.\n \t  ;; If we already made a list of problems, clear it out.\n@@ -306,16 +312,17 @@ Check that every node pointer points to an existing node.\"\n \t    (buffer-substring-no-properties\n \t     (point)\n \t     (progn\n-\t      (skip-chars-forward \"^,\\t\\n\")\n-\t      (skip-chars-backward \" \")\n-\t      (point))))))\n+\t       (skip-chars-forward \"^,\\t\\n\")\n+\t       (skip-chars-backward \" \")\n+\t       (point))))))\n   (if (null name)\n       nil\n     (setq name (downcase name))\n     (or (and (> (length name) 0) (= (aref name 0) ?\\())\n-\t(assoc name allnodes)\n-\t(setq lossages\n-\t      (cons (list thisnode kind name) lossages))))\n+\t(assoc name Info-validate-allnodes)\n+\t(setq Info-validate-lossages\n+\t      (cons (list Info-validate-thisnode kind name)\n+\t\t    Info-validate-lossages))))\n   name)\n \n (defun Info-validate-tags-table ()\n@@ -327,7 +334,7 @@ Check that every node pointer points to an existing node.\"\n \t\t  (start (progn (search-backward \"\\nTag table:\\n\")\n \t\t\t\t(1- (match-end 0))))\n \t\t  tem)\n-\t     (setq tem allnodes)\n+\t     (setq tem Info-validate-allnodes)\n \t     (while tem\n \t       (goto-char start)\n \t       (or (equal (car (car tem)) \"*\")\n@@ -342,7 +349,7 @@ Check that every node pointer points to an existing node.\"\n \t       (setq tem (downcase (buffer-substring-no-properties\n \t\t\t\t     (match-beginning 1)\n \t\t\t\t     (match-end 1))))\n-\t       (setq tem (assoc tem allnodes))\n+\t       (setq tem (assoc tem Info-validate-allnodes))\n \t       (if (or (not tem)\n \t\t       (< 1000 (progn\n \t\t\t\t (goto-char (match-beginning 2))\n@@ -426,4 +433,6 @@ For example, invoke \\\"emacs -batch -f batch-info-validate $info/ ~/*.info\\\"\"\n \t    (error (message \">> Error: %s\" (prin1-to-string err))))))\n       (kill-emacs error))))\n \n+(provide 'informat)\n+\n ;;; informat.el ends here"}, {"sha": "d6ee7bbb1c05f75bdc81b3b74a61ad000fdfe0de", "filename": "texinfo/emacs/makeinfo.el", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Fmakeinfo.el", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Fmakeinfo.el", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2Fmakeinfo.el?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -47,15 +47,24 @@\n \n (require 'compile)\n \n-(defvar makeinfo-run-command \"makeinfo\"\n+(defgroup makeinfo nil\n+  \"Run makeinfo conveniently\"\n+  :group 'docs)\n+\n+\n+(defcustom makeinfo-run-command \"makeinfo\"\n   \"*Command used to run `makeinfo' subjob.\n-The name of the file is appended to this string, separated by a space.\")\n+The name of the file is appended to this string, separated by a space.\"\n+  :type 'string\n+  :group 'makeinfo)\n \n-(defvar makeinfo-options \"--fill-column=70\"\n+(defcustom makeinfo-options \"--fill-column=70\"\n   \"*String containing options for running `makeinfo'.  \n Do not include `--footnote-style' or `--paragraph-indent';\n the proper way to specify those is with the Texinfo commands\n-`@footnotestyle` and `@paragraphindent'.\")\n+`@footnotestyle` and `@paragraphindent'.\"\n+  :type 'string\n+  :group 'makeinfo)\n \n (require 'texinfo)\n "}, {"sha": "ffc8b1fb1e6ba20be1f3f2b8419a2c24950d56cf", "filename": "texinfo/emacs/texinfmt.el", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Ftexinfmt.el", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Ftexinfmt.el", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2Ftexinfmt.el?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,10 +1,8 @@\n ;;; texinfmt.el --- format Texinfo files into Info files.\n \n-;; Copyright (C) 1985, 1986, 1988, 1990, 1991,\n-;;               1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+;; Copyright (C) 1985, 1986, 1988, 1990, 1991, 1992, 1993, \n+;;               1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n \n-;; Author: Robert J. Chassell      \n-;; Date:   10 Sep 1996\n ;; Maintainer: Robert J. Chassell <bug-texinfo@prep.ai.mit.edu>\n ;; Keywords: maint, tex, docs\n \n@@ -29,7 +27,7 @@\n \n ;;; Emacs lisp functions to convert Texinfo files to Info files.\n \n-(defvar texinfmt-version \"2.35 of 10 September 1996\")\n+(defvar texinfmt-version \"2.37 of 24 May 1997\")\n \n (defun texinfmt-version (&optional here)\n   \"Show the version of texinfmt.el in the minibuffer.\n@@ -101,7 +99,7 @@ If optional argument HERE is non-nil, insert info at point.\"\n (defun texinfo-format-buffer (&optional notagify)\n   \"Process the current buffer as texinfo code, into an Info file.\n The Info file output is generated in a buffer visiting the Info file\n-names specified in the @setfilename command.\n+name specified in the @setfilename command.\n \n Non-nil argument (prefix, if interactive) means don't make tag table\n and don't split the file if large.  You can use Info-tagify and\n@@ -299,6 +297,33 @@ converted to Info is stored in a temporary buffer.\"\n     \n     (message \"Done.\")))\n \n+;;;###autoload\n+(defun texi2info (&optional notagify)\n+  \"Convert the current buffer (written in Texinfo code) into an Info file.\n+The Info file output is generated in a buffer visiting the Info file\n+names specified in the @setfilename command.\n+\n+This function automatically updates all node pointers and menus, and\n+creates a master menu.  This work is done on a temporary buffer that\n+is automatically removed when the Info file is created.  The original\n+Texinfo source buffer is not changed.\n+\n+Non-nil argument (prefix, if interactive) means don't make tag table\n+and don't split the file if large.  You can use Info-tagify and\n+Info-split to do these manually.\"\n+  (interactive \"P\")\n+  (let ((temp-buffer (concat  \"*--\" (buffer-name) \"--temporary-buffer*\" )))\n+    (message \"First updating nodes and menus, then creating Info file.\")\n+    ;;  (sit-for 2)\n+    (copy-to-buffer temp-buffer (point-min) (point-max))\n+    (switch-to-buffer temp-buffer)\n+    (texinfo-master-menu t)\n+    (message \"Now creating Info file.\")\n+    (sit-for 2)\n+    (texinfo-format-buffer notagify)\n+    (save-buffer)\n+    (kill-buffer temp-buffer)))\n+\n \f\n ;;; Primary internal formatting function for the whole buffer.\n \n@@ -476,6 +501,7 @@ converted to Info is stored in a temporary buffer.\"\n    \"bullet{\\\\|\"\n    \"cite{\\\\|\"\n    \"code{\\\\|\"\n+   \"email{\\\\|\"\n    \"emph{\\\\|\"\n    \"equiv{\\\\|\"\n    \"error{\\\\|\"\n@@ -486,7 +512,6 @@ converted to Info is stored in a temporary buffer.\"\n    \"kbd{\\\\|\"\n    \"key{\\\\|\"\n    \"lisp{\\\\|\"\n-   \"email{\\\\|\"\n    \"minus{\\\\|\"\n    \"point{\\\\|\"\n    \"print{\\\\|\"\n@@ -1049,12 +1074,10 @@ Leave point after argument.\"\n           (file-name-nondirectory (expand-file-name arg)))\n     (insert \"Info file: \"\n             texinfo-format-filename \",    -*-Text-*-\\n\"\n-            ;; Date string removed so that regression testing is easier.\n-            ;; \"produced on \"\n-            ;; (substring (current-time-string) 8 10) \" \"\n-            ;; (substring (current-time-string) 4 7) \" \"\n-            ;; (substring (current-time-string) -4)  \" \"\n             \"produced by `texinfo-format-buffer'\\n\"\n+            ;; Date string removed so that regression testing is easier.\n+            ;; \"on \"\n+            ;; (insert (format-time-string \"%e %b %Y\")) \" \"\n             \"from file\"\n             (if (buffer-file-name input-buffer)\n                 (concat \" `\"\n@@ -1714,7 +1737,7 @@ Used by @refill indenting command to avoid indenting within lists, etc.\")\n ;;\n ;; Using the Emacs Lisp formatter, texinfmt.el, \n ;; the whitespace between columns can be increased by setting\n-;; `extra-inter-column-width' to a value greater than 0.  By default,\n+;; `texinfo-extra-inter-column-width' to a value greater than 0.  By default,\n ;; there is at least one blank space between columns.\n ;;\n ;; The Emacs Lisp formatter, texinfmt.el, ignores the following four\n@@ -1764,12 +1787,11 @@ Used by @refill indenting command to avoid indenting within lists, etc.\")\n ;; Note that @tab, the cell separators, are not treated as independent\n ;; Texinfo commands.\n \n-(defvar extra-inter-column-width 0\n-\"*Insert NUMBER of additional columns of whitespace between entries of\n-a multi-column table.\")\n+(defvar texinfo-extra-inter-column-width 0\n+  \"*Number of extra spaces between entries (columns) in @multitable.\")\n \n-(defvar multitable-temp-buffer-name \"*multitable-temporary-buffer*\")\n-(defvar multitable-temp-rectangle-name \"texinfo-multitable-temp-\")\n+(defvar texinfo-multitable-buffer-name \"*multitable-temporary-buffer*\")\n+(defvar texinfo-multitable-rectangle-name \"texinfo-multitable-temp-\")\n \n ;; These commands are defined in texinfo.tex for printed output.\n (put 'multitableparskip 'texinfo-format 'texinfo-discard-line-with-args)\n@@ -1778,6 +1800,7 @@ a multi-column table.\")\n (put 'multitablelinespace 'texinfo-format 'texinfo-discard-line-with-args)\n \n (put 'multitable 'texinfo-format 'texinfo-multitable)\n+\n (defun texinfo-multitable ()\n   \"Produce multi-column tables.\n \n@@ -1806,7 +1829,7 @@ Long lines of text are filled within columns.\n \n Using the Emacs Lisp formatter, texinfmt.el, \n the whitespace between columns can be increased by setting\n-`extra-inter-column-width' to a value greater than 0.  By default,\n+`texinfo-extra-inter-column-width' to a value greater than 0.  By default,\n there is at least one blank space between columns.\n \n The Emacs Lisp formatter, texinfmt.el, ignores the following four\n@@ -1895,7 +1918,7 @@ commands that are defined in texinfo.tex for printed output.\n             ;; between column spaces\n             (length texinfo-multitable-width-list)\n             ;; additional between column spaces, if any\n-            extra-inter-column-width\n+            texinfo-extra-inter-column-width\n             ;; sum of spaces for each entry\n             (apply '+ texinfo-multitable-width-list))))\n       (if (> desired-columns fill-column)\n@@ -1941,7 +1964,7 @@ This command is executed when texinfmt sees @item inside @multitable.\"\n         ;; extract-row command deletes the source line in the table.\n         (unformated-row (texinfo-multitable-extract-row)))\n     ;; Use a temporary buffer\n-    (set-buffer (get-buffer-create multitable-temp-buffer-name))\n+    (set-buffer (get-buffer-create texinfo-multitable-buffer-name))\n     (delete-region (point-min) (point-max))\n     (insert unformated-row)\n     (goto-char (point-min))\n@@ -1968,7 +1991,7 @@ This command is executed when texinfmt sees @item inside @multitable.\"\n                   (point)))\n       ;; Set fill-column *wider* than needed to produce inter-column space\n       (setq fill-column (+ 1\n-                           extra-inter-column-width\n+                           texinfo-extra-inter-column-width\n                            (nth table-column table-widths)))\n       (narrow-to-region start end)\n       ;; Remove whitespace before and after entry.\n@@ -2000,7 +2023,7 @@ This command is executed when texinfmt sees @item inside @multitable.\"\n                  (if (> needed-whitespace 0) needed-whitespace 1)\n                  ? )))\n       ;; now, put formatted cell into a rectangle\n-      (set (intern (concat multitable-temp-rectangle-name\n+      (set (intern (concat texinfo-multitable-rectangle-name\n                            (int-to-string table-column)))\n            (extract-rectangle (point-min) (point)))\n       (delete-region (point-min) (point))\n@@ -2023,12 +2046,12 @@ This command is executed when texinfmt sees @item inside @multitable.\"\n         (setq here (point))\n         (insert-rectangle\n          (eval (intern\n-                (concat multitable-temp-rectangle-name\n+                (concat texinfo-multitable-rectangle-name\n                         (int-to-string column-number)))))\n         (goto-char here)\n         (end-of-line)\n         (setq column-number (1+ column-number))))\n-    (kill-buffer multitable-temp-buffer-name)\n+    (kill-buffer texinfo-multitable-buffer-name)\n     (setq fill-column existing-fill-column)))\n \n \f\n@@ -2091,10 +2114,21 @@ This command is executed when texinfmt sees @item inside @multitable.\"\n ;; The `@today{}' command requires a pair of braces, like `@dots{}'.\n (defun texinfo-format-today ()\n   (texinfo-parse-arg-discard)\n-  (insert (format \"%s %s %s\"\n-          (substring (current-time-string) 8 10)\n-          (substring (current-time-string) 4 7)\n-          (substring (current-time-string) -4))))\n+  (insert (format-time-string \"%e %b %Y\")))\n+\n+\f\n+;;; @timestamp{}\n+;; Produce `Day Month Year Hour:Min' style of output.  \n+;; eg `1 Jan 1900 13:52'\n+\n+(put 'timestamp 'texinfo-format 'texinfo-format-timestamp)\n+\n+;; The `@timestamp{}' command requires a pair of braces, like `@dots{}'.\n+(defun texinfo-format-timestamp ()\n+  \"Insert the current local time and date.\"\n+  (texinfo-parse-arg-discard)\n+  ;; For seconds and time zone, replace format string with  \"%e %b %Y %T %Z\"\n+  (insert (format-time-string \"%e %b %Y %R\")))\n \n \f\n ;;; @ignore\n@@ -2217,8 +2251,9 @@ This command is executed when texinfmt sees @item inside @multitable.\"\n \n (put 'email 'texinfo-format 'texinfo-format-key)\n (put 'key 'texinfo-format 'texinfo-format-key)\n+;; I've decided not want to have angle brackets around these -- rms.\n (defun texinfo-format-key ()\n-  (insert \"<\" (texinfo-parse-arg-discard) \">\")\n+  (insert (texinfo-parse-arg-discard))\n   (goto-char texinfo-command-start))\n \n (put 'bullet 'texinfo-format 'texinfo-format-bullet)\n@@ -3705,13 +3740,12 @@ The command  `@value{foo}'  expands to the value.\"\n       ;; In this case flag is neither set nor cleared.  \n       ;; Act as if clear, i.e. do nothing.\n       ()))))\n-\n \f\n ;;; @ifeq\n \n (put 'ifeq 'texinfo-format 'texinfo-format-ifeq)\n (defun texinfo-format-ifeq ()\n-  \"If ARG1 and ARG2 caselessly string compare to same string, performs COMMAND.\n+  \"If ARG1 and ARG2 caselessly string compare to same string, perform COMMAND.\n Otherwise produces no output.\n \n Thus:"}, {"sha": "9e1099f4b88daef4cac35f607e3ef81195d53e59", "filename": "texinfo/emacs/texinfo.el", "status": "modified", "additions": 98, "deletions": 156, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Ftexinfo.el", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Ftexinfo.el", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2Ftexinfo.el?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,10 +1,10 @@\n-;;; texinfo.el--major mode for editing Texinfo files.\n+;;; texinfo.el --- major mode for editing Texinfo files\n \n ;; Copyright (C) 1985, '88, '89, '90, '91,\n-;;                '92, '93, '96 Free Software Foundation, Inc.\n+;;                '92, '93, '96, '97 Free Software Foundation, Inc.\n \n-;; Author: Robert J. Chassell          \n-;; Date:   6 Sep 1996\n+;; Author: Robert J. Chassell\n+;; Date:   [Set date below for texinfo-version]\n ;; Maintainer: bug-texinfo@prep.ai.mit.edu\n ;; Keywords: maint, tex, docs\n \n@@ -25,6 +25,26 @@\n ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n+;;; Code:\n+\n+(defgroup texinfo nil\n+  \"Texinfo Mode\"\n+  :group 'docs)\n+\n+(defvar texinfo-version \"2.37 of 24 May 1997\")\n+\n+(defun texinfo-version (&optional here)\n+  \"Show the version of texinfo.el in the minibuffer.\n+If optional argument HERE is non-nil, insert info at point.\"\n+  (interactive \"P\")\n+  (let ((version-string \n+         (format \"Version of \\`texinfo.el\\': %s\" texinfo-version)))\n+    (if here \n+        (insert version-string)\n+      (if (interactive-p)\n+          (message \"%s\" version-string)\n+        version-string))))\n+\n \f\n ;;; Autoloads:\n \n@@ -41,7 +61,7 @@ command to gain use of `next-error'.\"\n   \"makeinfo\"\n   \"Make Info file from current buffer.\n \n-Use the \\\\[next-error] command to move to the next error \n+Use the \\\\[next-error] command to move to the next error\n \\(if there are errors\\).\"\n   t nil)\n \n@@ -164,7 +184,7 @@ title of the section containing the menu.\"\n \n (autoload 'texinfo-indent-menu-description\n   \"texnfo-upd\"\n-  \"Indent every description in menu following point to COLUMN.  \n+  \"Indent every description in menu following point to COLUMN.\n Non-nil argument (prefix, if interactive) means indent every\n description in every menu in the region.  Does not indent second and\n subsequent lines of a multi-line description.\"\n@@ -180,7 +200,7 @@ node names in pre-existing @node lines that lack names.\"\n \n (autoload 'texinfo-start-menu-description\n   \"texnfo-upd\"\n-  \"In this menu entry, insert the node's section title as a description. \n+  \"In this menu entry, insert the node's section title as a description.\n Position point at beginning of description ready for editing.\n Do not insert a title if the line contains an existing description.\n \n@@ -191,7 +211,7 @@ complements the node name rather than repeats it as a title does.\"\n (autoload 'texinfo-multiple-files-update\n   \"texnfo-upd\"\n   \"Update first node pointers in each file included in OUTER-FILE;\n-create or update main menu in the outer file that refers to such nodes. \n+create or update main menu in the outer file that refers to such nodes.\n This does not create or update menus or pointers within the included files.\n \n With optional MAKE-MASTER-MENU argument (prefix arg, if interactive),\n@@ -205,7 +225,7 @@ a master menu in OUTER-FILE.\n \n The command also updates the `Top' level node pointers of OUTER-FILE.\n \n-Notes: \n+Notes:\n \n   * this command does NOT save any files--you must save the\n     outer file and any modified, included files.\n@@ -217,7 +237,7 @@ Notes:\n Requirements:\n \n   * each of the included files must contain exactly one highest\n-    hierarchical level node, \n+    hierarchical level node,\n   * this highest node must be the first node in the included file,\n   * each highest hierarchical level node must be of the same type.\n \n@@ -261,11 +281,11 @@ chapter.\"\n     ;; It didn't seem to be any better, and it's slower--simon.\n     (\"^\\\\(@c\\\\|@comment\\\\)\\\\>.*\" . font-lock-comment-face) ;comments\n     ;; Robert J. Chassell <bob@gnu.ai.mit.edu> says remove this line.\n-                                        ;(\"\\\\$\\\\([^$]*\\\\)\\\\$\" 1 font-lock-string-face t)\n+    ;;(\"\\\\$\\\\([^$]*\\\\)\\\\$\" 1 font-lock-string-face t)\n     (\"@\\\\([a-zA-Z]+\\\\|[^ \\t\\n]\\\\)\" 1 font-lock-keyword-face) ;commands\n     (\"^\\\\*\\\\(.*\\\\)[\\t ]*$\" 1 font-lock-function-name-face t) ;menu items\n     (\"@\\\\(emph\\\\|strong\\\\|b\\\\|i\\\\){\\\\([^}]+\\\\)\" 2 font-lock-comment-face)\n-    (\"@\\\\(file\\\\|kbd\\\\|key\\\\){\\\\([^}]+\\\\)\" 2 font-lock-string-face)\n+    (\"@\\\\(file\\\\|kbd\\\\|key\\\\|url\\\\|email\\\\){\\\\([^}]+\\\\)\" 2 font-lock-string-face)\n     (\"@\\\\(samp\\\\|code\\\\|var\\\\|math\\\\){\\\\([^}]+\\\\)\"\n      2 font-lock-variable-name-face)\n     (\"@\\\\(cite\\\\|xref\\\\|pxref\\\\){\\\\([^}]+\\\\)\" 2 font-lock-reference-face)\n@@ -300,7 +320,7 @@ chapter.\"\n     (if (bobp)\n         0\n       (forward-char 1)\n-      (let* ((word (buffer-substring-no-properties \n+      (let* ((word (buffer-substring-no-properties\n                     (point) (progn (forward-word 1) (point))))\n              (entry (assoc word texinfo-section-list)))\n         (if entry\n@@ -321,12 +341,13 @@ chapter.\"\n   (define-key keymap \"\\C-c\\C-t\\C-d\"    'texinfo-delete-from-print-queue)\n   (define-key keymap \"\\C-c\\C-t\\C-q\"    'tex-show-print-queue)\n   (define-key keymap \"\\C-c\\C-t\\C-p\"    'texinfo-tex-print)\n+  (define-key keymap \"\\C-c\\C-t\\C-v\"    'texinfo-tex-view)\n   (define-key keymap \"\\C-c\\C-t\\C-i\"    'texinfo-texindex)\n \n   (define-key keymap \"\\C-c\\C-t\\C-r\"    'texinfo-tex-region)\n   (define-key keymap \"\\C-c\\C-t\\C-b\"    'texinfo-tex-buffer))\n \n-;; Mode documentation displays commands in reverse order \n+;; Mode documentation displays commands in reverse order\n ;; from how they are listed in the texinfo-mode-map.\n \n (if texinfo-mode-map\n@@ -338,7 +359,7 @@ chapter.\"\n \n   ;; bindings for `makeinfo.el'\n   (define-key texinfo-mode-map \"\\C-c\\C-m\\C-k\" 'kill-compilation)\n-  (define-key texinfo-mode-map \"\\C-c\\C-m\\C-l\" \n+  (define-key texinfo-mode-map \"\\C-c\\C-m\\C-l\"\n     'makeinfo-recenter-compilation-buffer)\n   (define-key texinfo-mode-map \"\\C-c\\C-m\\C-r\" 'makeinfo-region)\n   (define-key texinfo-mode-map \"\\C-c\\C-m\\C-b\" 'makeinfo-buffer)\n@@ -382,7 +403,7 @@ chapter.\"\n \f\n ;;; Texinfo mode\n \n-(defvar texinfo-chapter-level-regexp \n+(defvar texinfo-chapter-level-regexp\n   \"chapter\\\\|unnumbered \\\\|appendix \\\\|majorheading\\\\|chapheading\"\n   \"Regular expression matching Texinfo chapter-level headings.\n This does not match `@node' and does not match the `@top' command.\")\n@@ -429,7 +450,7 @@ Here are the functions:\n \n     texinfo-update-node                \\\\[texinfo-update-node]\n     texinfo-every-node-update          \\\\[texinfo-every-node-update]\n-    texinfo-sequential-node-update \n+    texinfo-sequential-node-update\n \n     texinfo-make-menu                  \\\\[texinfo-make-menu]\n     texinfo-all-menus-update           \\\\[texinfo-all-menus-update]\n@@ -438,7 +459,7 @@ Here are the functions:\n     texinfo-indent-menu-description (column &optional region-p)\n \n The `texinfo-column-for-description' variable specifies the column to\n-which menu descriptions are indented. \n+which menu descriptions are indented.\n \n Passed an argument (a prefix argument, if interactive), the\n `texinfo-update-node' and `texinfo-make-menu' functions do their jobs\n@@ -461,19 +482,20 @@ value of texinfo-mode-hook.\"\n   (use-local-map texinfo-mode-map)\n   (set-syntax-table texinfo-mode-syntax-table)\n   (make-local-variable 'page-delimiter)\n-  (setq page-delimiter \n-        (concat \n-         \"^@node [ \\t]*[Tt]op\\\\|^@\\\\(\" \n-         texinfo-chapter-level-regexp \n+  (setq page-delimiter\n+        (concat\n+         \"^@node [ \\t]*[Tt]op\\\\|^@\\\\(\"\n+         texinfo-chapter-level-regexp\n          \"\\\\)\"))\n   (make-local-variable 'require-final-newline)\n   (setq require-final-newline t)\n   (make-local-variable 'indent-tabs-mode)\n   (setq indent-tabs-mode nil)\n   (make-local-variable 'paragraph-separate)\n-  (setq paragraph-separate (concat \"^\\b\\\\|^@[a-zA-Z]*[ \\n]\\\\|\" paragraph-separate))\n+  (setq paragraph-separate\n+\t(concat \"\\b\\\\|@[a-zA-Z]*[ \\n]\\\\|\" paragraph-separate))\n   (make-local-variable 'paragraph-start)\n-  (setq paragraph-start (concat \"^\\b\\\\|^@[a-zA-Z]*[ \\n]\\\\|\" paragraph-start))\n+  (setq paragraph-start (concat \"\\b\\\\|@[a-zA-Z]*[ \\n]\\\\|\" paragraph-start))\n   (make-local-variable 'fill-column)\n   (setq fill-column 72)\n   (make-local-variable 'comment-start)\n@@ -487,16 +509,20 @@ value of texinfo-mode-hook.\"\n   (make-local-variable 'font-lock-defaults)\n   (setq font-lock-defaults '(texinfo-font-lock-keywords t))\n   (make-local-variable 'outline-regexp)\n-  (setq outline-regexp \n+  (setq outline-regexp\n         (concat \"@\\\\(\"\n                 (mapconcat 'car texinfo-section-list \"\\\\>\\\\|\")\n                 \"\\\\>\\\\)\"))\n   (make-local-variable 'outline-level)\n   (setq outline-level 'texinfo-outline-level)\n   (make-local-variable 'tex-start-of-header)\n-  (setq tex-start-of-header \"%**start\")\n+  (setq tex-start-of-header \"%\\\\*\\\\*start\")\n   (make-local-variable 'tex-end-of-header)\n-  (setq tex-end-of-header \"%**end\")\n+  (setq tex-end-of-header \"%\\\\*\\\\*end\")\n+  (make-local-variable 'tex-first-line-header-regexp)\n+  (setq tex-first-line-header-regexp \"^\\\\\\\\input\")\n+  (make-local-variable 'tex-trailer)\n+  (setq tex-trailer \"@bye\\n\")\n   (run-hooks 'text-mode-hook 'texinfo-mode-hook))\n \n \f\n@@ -543,10 +569,10 @@ value of texinfo-mode-hook.\"\n   (let ((depth 1) string)\n     (save-excursion\n       (while (and (> depth 0)\n-                  (re-search-backward texinfo-environment-regexp nil t)\n-                  (if (looking-at \"@end\")\n-                      (setq depth (1+ depth))\n-                    (setq depth (1- depth)))))\n+                  (re-search-backward texinfo-environment-regexp nil t))\n+\t(if (looking-at \"@end\")\n+\t    (setq depth (1+ depth))\n+\t  (setq depth (1- depth))))\n       (looking-at texinfo-environment-regexp)\n       (if (zerop depth)\n           (setq string\n@@ -564,7 +590,7 @@ value of texinfo-mode-hook.\"\n \n ;; These commands use texinfo-insert-@-with-arg\n (defun texinfo-insert-@-with-arg (string &optional arg)\n-  (if arg \n+  (if arg\n       (progn\n         (setq arg (prefix-numeric-value arg))\n         (if (< arg 0)\n@@ -662,14 +688,13 @@ The default is not to surround any existing words with the braces.\"\n \f\n ;;; Texinfo file structure\n \n-;; These are defined in texnfo-upd.el.\n-;; texinfo-section-types-regexp\n-;; texinfo-section-level-regexp\n-;; texinfo-subsection-level-regexp\n-;; texinfo-subsubsection-level-regexp\n+;; These are defined in texnfo-upd.el.  defvars here avoid warnings.\n+(defvar texinfo-section-types-regexp)\n+(defvar texinfo-section-level-regexp)\n+(defvar texinfo-subsection-level-regexp)\n+(defvar texinfo-subsubsection-level-regexp)\n \n-;; `texinfo-show-structure' requires texnfo-upd.el\n-(defun texinfo-show-structure (&optional nodes-too) \n+(defun texinfo-show-structure (&optional nodes-too)\n   \"Show the structure of a Texinfo file.\n List the lines in the file that begin with the @-sign commands for\n @chapter, @section, and the like.\n@@ -680,12 +705,12 @@ with @-sign commands for @chapter, @section, and the like, and list\n \n Lines with structuring commands beginning in them are displayed in\n another buffer named `*Occur*'.  In that buffer, you can move point to\n-one of those lines and then use \\\\<occur-mode-map>\\\\[occur-mode-goto-occurrence], \n+one of those lines and then use \\\\<occur-mode-map>\\\\[occur-mode-goto-occurrence],\n to jump to the corresponding spot in the Texinfo source file.\"\n \n   (interactive \"P\")\n   (require 'texnfo-upd)\n-  (save-excursion \n+  (save-excursion\n     (goto-char (point-min))\n     (if nodes-too\n         (occur (concat \"\\\\(^@node\\\\)\\\\|\" texinfo-section-types-regexp))\n@@ -716,14 +741,14 @@ to jump to the corresponding spot in the Texinfo source file.\"\n              ;; ((looking-at \"@appendixsec \") 9)\n              ;; ((looking-at \"@heading \") 9)\n \n-             ((looking-at \n+             ((looking-at\n                (concat \"@\\\\(\" texinfo-subsection-level-regexp \"\\\\)\")) 13)\n              ;; ((looking-at \"@subsection \") 13)\n              ;; ((looking-at \"@unnumberedsubsec \") 13)\n              ;; ((looking-at \"@appendixsubsec \") 13)\n              ;; ((looking-at \"@subheading \") 13)\n \n-             ((looking-at \n+             ((looking-at\n                (concat \"@\\\\(\" texinfo-subsubsection-level-regexp \"\\\\)\")) 17)\n              ;; ((looking-at \"@subsubsection \") 17)\n              ;; ((looking-at \"@unnumberedsubsubsec \") 17)\n@@ -735,20 +760,28 @@ to jump to the corresponding spot in the Texinfo source file.\"\n \f\n ;;; The  tex  and  print  function definitions:\n \n-(defvar texinfo-texi2dvi-command \"texi2dvi\"\n-  \"*Command used by `texinfo-tex-buffer' to run TeX and texindex on a buffer.\")\n+(defcustom texinfo-texi2dvi-command \"texi2dvi\"\n+  \"*Command used by `texinfo-tex-buffer' to run TeX and texindex on a buffer.\"\n+  :type 'string\n+  :group 'texinfo)\n \n-(defvar texinfo-tex-command \"tex\"\n-  \"*Command used by `texinfo-tex-region' to run TeX on a region.\")\n+(defcustom texinfo-tex-command \"tex\"\n+  \"*Command used by `texinfo-tex-region' to run TeX on a region.\"\n+  :type 'string\n+  :group 'texinfo)\n \n-(defvar texinfo-texindex-command \"texindex\"\n-  \"*Command used by `texinfo-texindex' to sort unsorted index files.\")\n+(defcustom texinfo-texindex-command \"texindex\"\n+  \"*Command used by `texinfo-texindex' to sort unsorted index files.\"\n+  :type 'string\n+  :group 'texinfo)\n \n-(defvar texinfo-delete-from-print-queue-command \"lprm\"\n+(defcustom texinfo-delete-from-print-queue-command \"lprm\"\n   \"*Command string used to delete a job from the line printer queue.\n Command is used by \\\\[texinfo-delete-from-print-queue] based on\n number provided by a previous \\\\[tex-show-print-queue]\n-command.\")\n+command.\"\n+  :type 'string\n+  :group 'texinfo)\n \n (defvar texinfo-tex-trailer \"@bye\"\n   \"String appended after a region sent to TeX by `texinfo-tex-region'.\")\n@@ -767,109 +800,16 @@ inclusive.  The header must start in the first 100 lines.\n The value of `texinfo-tex-trailer' is appended to the temporary file after the region.\"\n   (interactive \"r\")\n   (require 'tex-mode)\n-  (if (get-buffer \"*tex-shell*\")\n-      (tex-kill-job)\n-    (tex-start-shell))\n-  (or tex-zap-file (setq tex-zap-file (make-temp-name \"#tz\")))\n-  (let ((tex-out-file (concat tex-zap-file \".tex\"))\n-        (temp-buffer (get-buffer-create \" tex-Output-Buffer\"))\n-        (zap-directory\n-         (file-name-as-directory (expand-file-name tex-directory))))\n-    (save-excursion\n-      (save-restriction\n-        (widen)\n-        (goto-char (point-min))\n-        (forward-line 100)\n-        (let ((search-end (point))\n-              (hbeg (point-min)) (hend (point-min))\n-              (default-directory zap-directory))\n-          (goto-char (point-min))\n-          \n-          ;; Copy first line, the `\\input texinfo' line, to temp file\n-          (write-region (point) \n-                        (save-excursion (end-of-line) (point))\n-                        tex-out-file nil nil)\n-          \n-          ;; Don't copy first line twice if region includes it.\n-          (forward-line 1)\n-          (if (< beg (point)) (setq beg (point)))\n-          \n-          ;; Initialize the temp file with either the header or nothing\n-          (if (search-forward tex-start-of-header search-end t)\n-              (progn\n-                (beginning-of-line)\n-                (setq hbeg (point))     ; Mark beginning of header.\n-                (if (search-forward tex-end-of-header nil t)\n-                    (progn (beginning-of-line)\n-                           (setq hend (point))) ; Mark end of header.\n-                  (setq hbeg (point-min))))) ; Else no header.\n-          \n-          ;; Copy  header  to temp file.\n-          (write-region (min hbeg beg) hend tex-out-file t nil)\n-          \n-          ;; Copy  region  to temp file.\n-          (write-region (max beg hend) end tex-out-file t nil))\n-        \n-        ;; This is  a kludge to insert the tex-trailer into the tex-out-file.\n-        ;;  We have to create a special buffer in which to insert\n-        ;;  the tex-trailer first because there is no function with\n-        ;;  which to append a literal string directly to a file.\n-        (let ((local-tex-trailer texinfo-tex-trailer))\n-          (set-buffer temp-buffer)\n-          (erase-buffer)\n-          ;; make sure trailer isn't hidden by a comment\n-          (insert-string \"\\n\")\n-          (if local-tex-trailer (insert-string local-tex-trailer))\n-          (tex-set-buffer-directory temp-buffer zap-directory)\n-          (write-region (point-min) (point-max) tex-out-file t nil))\n-\n-;;; The following is sufficient in Emacs 19.\n-;;;     (write-region (concat \"\\n\" texinfo-tex-trailer) nil\n-;;;                   tex-out-file t nil)\n-        ))\n-    \n-    (tex-set-buffer-directory \"*tex-shell*\" zap-directory)\n-    (tex-send-command tex-shell-cd-command zap-directory)\n-    (tex-send-command texinfo-tex-command tex-out-file)\n-    ;; alternatively:\n-    ;;    (send-string \"tex-shell\" (concat tex-shell-cd-command \" \"\n-    ;;                                     zap-directory \"\\n\"))\n-    ;;    (send-string \"tex-shell\" (concat texinfo-tex-command \" \"\n-    ;;                                     tex-out-file \"\\n\"))\n-    (tex-recenter-output-buffer 0)))\n+  (let ((tex-command texinfo-tex-command)\n+\t(tex-trailer \"@bye\\n\"))\n+    (tex-region beg end)))\n \n (defun texinfo-tex-buffer ()\n   \"Run TeX on visited file, once or twice, to make a correct `.dvi' file.\"\n   (interactive)\n-\n-  ;; Make sure TeX shell is running.\n   (require 'tex-mode)\n-  (if (get-buffer \"*tex-shell*\")\n-      (quit-process (get-process \"tex-shell\") t)\n-    (tex-start-shell))\n-\n-  (cond ((null buffer-file-name)\n-         (error \"Buffer not visiting any file!\"))\n-        ((buffer-modified-p)\n-         (error \"Buffer has been modified since last saved!\")))\n-\n-  (setq tex-zap-file buffer-file-name)\n-\n-  (tex-send-command tex-shell-cd-command (file-name-directory tex-zap-file))\n-  \n-  (tex-send-command texinfo-texi2dvi-command tex-zap-file)\n-\n-  ;; alternatively:\n-  ;;  (send-string \"tex-shell\"\n-  ;;               (concat tex-shell-cd-command \n-  ;;                   \" \" (file-name-directory tex-zap-file) \"\\n\"))\n-  ;;  )\n-  ;;\n-  ;;  (send-string \"tex-shell\"\n-  ;;           (concat texinfo-texi2dvi-command \" \" tex-zap-file \"\\n\"))\n-\n-\n-  (tex-recenter-output-buffer 0))\n+  (let ((tex-command texinfo-texi2dvi-command))\n+    (tex-buffer)))\n \n (defun texinfo-texindex ()\n   \"Run `texindex' on unsorted index files.\n@@ -889,12 +829,14 @@ This runs the shell command defined by `texinfo-texindex-command'.\"\n This runs the shell command defined by `tex-dvi-print-command'.\"\n   (interactive)\n   (require 'tex-mode)\n-  (tex-send-command tex-dvi-print-command (concat tex-zap-file \".dvi\"))\n-  ;; alternatively:\n-  ;; (send-string \"tex-shell\"\n-  ;;             (concat tex-dvi-print-command\n-  ;;                     \" \" tex-zap-file \".dvi\" \"\\n\"))\n-  (tex-recenter-output-buffer nil))\n+  (tex-print))\n+\n+(defun texinfo-tex-view ()\n+  \"View `.dvi' file made by \\\\[texinfo-tex-region] or \\\\[texinfo-tex-buffer].\n+This runs the shell command defined by `tex-dvi-view-command'.\"\n+  (interactive)\n+  (require 'tex-mode)\n+  (tex-view))\n \n (defun texinfo-quit-job ()\n   \"Quit currently running TeX job, by sending an `x' to it.\"\n@@ -921,7 +863,7 @@ You are prompted for the job number (use a number shown by a previous\n   (tex-send-command texinfo-delete-from-print-queue-command job-number)\n   ;; alternatively\n   ;; (send-string \"tex-shell\"\n-  ;;              (concat \n+  ;;              (concat\n   ;;               texinfo-delete-from-print-queue-command\n   ;;               \" \"\n   ;;               job-number\"\\n\"))"}, {"sha": "516c1a6130b8a856f070f91a1b41d7a8854e0bb3", "filename": "texinfo/emacs/texnfo-upd.el", "status": "modified", "additions": 154, "deletions": 150, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Ftexnfo-upd.el", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Femacs%2Ftexnfo-upd.el", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Femacs%2Ftexnfo-upd.el?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,10 +1,9 @@\n ;;; texnfo-upd.el --- utilities for updating nodes and menus in Texinfo files\n \n-;; Copyright 1989, 1990, 1991, 1992, 1996 Free Software Foundation, Inc.\n+;; Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.\n \n ;; Author: Robert J. Chassell      \n-;; Date:   12 Sep 1996\n-;; Maintainer: Robert J. Chassell <bug-texinfo@prep.ai.mit.edu>\n+;; Maintainer: bug-texinfo@prep.ai.mit.edu\n ;; Keywords: maint, tex, docs\n \n ;; This file is part of GNU Emacs.\n@@ -37,16 +36,16 @@\n ;;   * insert or update the menu for a section, \n ;;   * create a master menu for a Texinfo source file.\n ;;\n-;; Passed an argument, the `texinfo-update-node' and\n+;; With a prefix argument, the `texinfo-update-node' and\n ;; `texinfo-make-menu' functions do their jobs in the region.\n ;;\n ;; In brief, the functions for creating or updating nodes and menus, are:\n ;; \n-;;     texinfo-update-node (&optional region-p)            \n+;;     texinfo-update-node (&optional beginning end)            \n ;;     texinfo-every-node-update ()                        \n ;;     texinfo-sequential-node-update (&optional region-p)\n ;; \n-;;     texinfo-make-menu (&optional region-p)              \n+;;     texinfo-make-menu (&optional beginning end)              \n ;;     texinfo-all-menus-update ()                         \n ;;     texinfo-master-menu ()\n ;;\n@@ -81,11 +80,11 @@\n \f\n ;;; The update node functions described in detail\n \n-;; The `texinfo-update-node' function without an argument inserts\n+;; The `texinfo-update-node' command with no prefix argument inserts\n ;; the correct next, previous and up pointers for the node in which\n ;; point is located (i.e., for the node preceding point).\n \n-;; With an argument, the `texinfo-update-node' function inserts the\n+;; With prefix argument, the `texinfo-update-node' function inserts the\n ;; correct next, previous and up pointers for the nodes inside the\n ;; region.\n \n@@ -150,39 +149,41 @@\n \f \n ;;; Code:\n \n-;;; The menu making functions\n+(defvar texinfo-master-menu-header\n+  \" --- The Detailed Node Listing ---\\n\"\n+  \"String inserted before lower level entries in Texinfo master menu.\n+It comes after the chapter-level menu entries.\")\n \n-(defun texinfo-make-menu (&optional region-p)\n+(defun texinfo-make-menu (&optional beginning end)\n   \"Without any prefix argument, make or update a menu.\n Make the menu for the section enclosing the node found following point.\n \n-Non-nil argument (prefix, if interactive) means make or update menus\n+A prefix argument means make or update menus\n for nodes within or part of the marked region.\n \n Whenever a menu exists, and is being updated, the descriptions that\n are associated with node names in the pre-existing menu are\n incorporated into the new menu.  Otherwise, the nodes' section titles\n are inserted as descriptions.\"\n   \n-  (interactive \"P\")\n-  (if (not region-p)\n+  (interactive\n+   (if prefix-arg\n+       (list (point) (mark))))\n+  (if (null beginning)\n       (let ((level (texinfo-hierarchic-level)))\n         (texinfo-make-one-menu level)\n-        (message \"Done...updated the menu.  You may save the buffer.\"))\n+        (message \"Menu updated\"))\n     ;; else\n     (message \"Making or updating menus in %s... \" (buffer-name))\n-    (let ((beginning (region-beginning))\n-          (region-end (region-end))\n-          (level (progn         ; find section type following point\n-                   (goto-char (region-beginning))\n-                   (texinfo-hierarchic-level))))\n-      (if (= region-end beginning)\n-          (error \"Please mark a region!\"))\n-      (save-excursion\n+    (save-excursion\n+      (goto-char (min beginning end))\n+      ;; find section type following point\n+      (let ((level (texinfo-hierarchic-level))\n+\t    (region-end (max beginning end)))\n         (save-restriction\n           (widen)\n           \n-          (while  (texinfo-find-lower-level-node level region-end)\n+          (while (texinfo-find-lower-level-node level region-end)\n             (setq level (texinfo-hierarchic-level)) ; new, lower level\n             (texinfo-make-one-menu level))\n           \n@@ -192,7 +193,7 @@ are inserted as descriptions.\"\n             (while (texinfo-find-lower-level-node level region-end)\n               (setq level (texinfo-hierarchic-level)) ; new, lower level\n               (texinfo-make-one-menu level))))))\n-    (message \"Done...updated menus.  You may save the buffer.\")))\n+    (message \"Making or updating menus in %s...done\" (buffer-name))))\n \n (defun texinfo-make-one-menu (level)\n   \"Make a menu of all the appropriate nodes in this section.\n@@ -201,10 +202,10 @@ at the level specified by LEVEL.  Point is left at the end of menu.\"\n   (let*\n       ((case-fold-search t)\n        (beginning\n-        (save-excursion\n-          (goto-char (texinfo-update-menu-region-beginning level))\n-          (end-of-line)\n-          (point)))\n+\t(save-excursion\n+\t  (goto-char (texinfo-update-menu-region-beginning level))\n+\t  (end-of-line)\n+\t  (point)))\n        (end (texinfo-update-menu-region-end level))\n        (first (texinfo-menu-first-node beginning end))\n        (node-name (progn\n@@ -233,9 +234,14 @@ nodes in the buffer before updating the menus.\"\n       (goto-char (point-min))\n       (message \"Checking for a master menu in %s ... \"(buffer-name))\n       (save-excursion\n-        (if (re-search-forward texinfo-master-menu-header nil t)\n-            ;; Remove detailed master menu listing\n+        (if (search-forward texinfo-master-menu-header nil t)\n             (progn\n+              ;; Check if @detailmenu kludge is used;\n+              ;; if so, leave point before @detailmenu.\n+              (search-backward \"\\n@detailmenu\" \n+\t\t\t       (save-excursion (forward-line -3) (point))\n+\t\t\t       t)\n+\t      ;; Remove detailed master menu listing\n               (setq master-menu-p t)\n               (goto-char (match-beginning 0))\n               (let ((end-of-detailed-menu-descriptions\n@@ -249,21 +255,11 @@ nodes in the buffer before updating the menus.\"\n           (progn\n             (message \"Updating all nodes in %s ... \" (buffer-name))\n             (sleep-for 2)\n-            (push-mark (point-max) t)\n-            (goto-char (point-min))\n-            ;; Using the mark to pass bounds this way\n-            ;; is kludgy, but it's not worth fixing. -- rms.\n-            (let ((mark-active t))\n-              (texinfo-update-node t))))\n+\t    (texinfo-update-node (point-min) (point-max))))\n       \n       (message \"Updating all menus in %s ... \" (buffer-name))        \n       (sleep-for 2)\n-      (push-mark (point-max) t)\n-      (goto-char (point-min))\n-      ;; Using the mark to pass bounds this way\n-      ;; is kludgy, but it's not worth fixing. -- rms.\n-      (let ((mark-active t))\n-        (texinfo-make-menu t))\n+      (texinfo-make-menu (point-max) (point-min))\n       \n       (if master-menu-p\n           (progn\n@@ -438,7 +434,7 @@ old description into the new entry.\n For this function, the new menu is a list made up of lists of dotted\n pairs in which the first element of the pair is the node name and the\n second element the description.  The new menu is changed destructively.\n-The old menu is the menu as it appears in the texinfo file.\"\n+The old menu is the menu as it appears in the Texinfo file.\"\n   \n   (let ((new-menu-list-pointer new-menu-list)\n         (end-of-menu (texinfo-menu-end)))\n@@ -452,9 +448,9 @@ The old menu is the menu as it appears in the texinfo file.\"\n              ;; \n              ;; Recognize both when looking for the description.\n              (concat \"\\\\* \\\\(\"              ; so only menu entries are found\n-                     (car (car new-menu-list)) \"::\"\n+                     (regexp-quote (car (car new-menu-list))) \"::\"\n                      \"\\\\|\"\n-                     \".*: \" (car (car new-menu-list)) \"[.,\\t\\n]\"\n+                     \".*: \" (regexp-quote (car (car new-menu-list))) \"[.,\\t\\n]\"\n                      \"\\\\)\"\n                      )               ; so only complete entries are found\n              end-of-menu\n@@ -525,7 +521,7 @@ Single argument, END-OF-MENU, is position limiting search.\"\n     \"\"))\n \n (defun texinfo-menu-end ()\n-  \"Return position of end of menu. Does not change location of point.\n+  \"Return position of end of menu, but don't move point.\n Signal an error if not end of menu.\"\n   (save-excursion\n     (if (re-search-forward \"^@end menu\" nil t)\n@@ -784,9 +780,14 @@ title of the section containing the menu.\"\n              (or (re-search-forward \"^@node\" nil t)\n                  (error \"Too few nodes for a master menu!\"))\n              (point))))\n-      (if (re-search-forward texinfo-master-menu-header first-chapter t)\n-          ;; Remove detailed master menu listing\n+      (if (search-forward texinfo-master-menu-header first-chapter t)\n           (progn\n+            ;; Check if @detailmenu kludge is used;\n+            ;; if so, leave point before @detailmenu.\n+            (search-backward \"\\n@detailmenu\" \n+\t\t\t     (save-excursion (forward-line -3) (point))\n+\t\t\t     t)\n+\t    ;; Remove detailed master menu listing\n             (goto-char (match-beginning 0))\n             (let ((end-of-detailed-menu-descriptions\n                    (save-excursion     ; beginning of end menu line\n@@ -800,15 +801,11 @@ title of the section containing the menu.\"\n           (message \"Making a master menu in %s ...first updating all nodes... \"\n                    (buffer-name))\n           (sleep-for 2)\n-          (push-mark (point-max) t)\n-          (goto-char (point-min))\n-          (texinfo-update-node t)\n+          (texinfo-update-node (point-min) (point-max))\n           \n           (message \"Updating all menus in %s ... \" (buffer-name))        \n           (sleep-for 2)\n-          (push-mark (point-max) t)\n-          (goto-char (point-min))\n-          (texinfo-make-menu t)))\n+          (texinfo-make-menu (point-min) (point-max))))\n     \n     (message \"Now making the master menu in %s... \" (buffer-name))\n     (sleep-for 2)\n@@ -822,9 +819,14 @@ title of the section containing the menu.\"\n     (save-excursion\n       (goto-char (point-min))\n       \n-      (if (re-search-forward texinfo-master-menu-header nil t)\n+      (if (search-forward texinfo-master-menu-header nil t)\n           (progn\n             (goto-char (match-beginning 0))\n+            ;; Check if @detailmenu kludge is used;\n+            ;; if so, leave point before @detailmenu.\n+            (search-backward \"\\n@detailmenu\" \n+\t\t\t     (save-excursion (forward-line -3) (point))\n+\t\t\t     t)\n             (insert \"\\n\")\n             (delete-blank-lines)\n             (goto-char (point-min))))\n@@ -880,59 +882,63 @@ However, there does not need to be a title field.\"\n    (point)   \n    (save-excursion (re-search-forward \"^@end menu\") (point)))\n   \n-  (save-excursion                       ; leave point at beginning of menu\n-    ;; Handle top of menu\n-    (insert \"\\n@menu\\n\")\n-    ;; Insert chapter menu entries\n-    (setq this-very-menu-list (reverse (car (car master-menu-list))))\n-    ;; Tell user what is going on.\n-    (message \"Inserting chapter menu entry: %s ... \" this-very-menu-list)\n-    (while this-very-menu-list\n-      (insert \"* \" (car this-very-menu-list) \"\\n\")\n-      (setq this-very-menu-list (cdr this-very-menu-list)))\n-    \n-    (setq master-menu-list (cdr master-menu-list))\n+  (save-excursion \n+    ;; `master-menu-inserted-p' is a kludge to tell \n+    ;; whether to insert @end detailmenu (see bleow)\n+    (let (master-menu-inserted-p)\n+      ;; Handle top of menu\n+      (insert \"\\n@menu\\n\")\n+      ;; Insert chapter menu entries\n+      (setq this-very-menu-list (reverse (car (car master-menu-list))))\n+      ;; Tell user what is going on.\n+      (message \"Inserting chapter menu entry: %s ... \" this-very-menu-list)\n+      (while this-very-menu-list\n+        (insert \"* \" (car this-very-menu-list) \"\\n\")\n+        (setq this-very-menu-list (cdr this-very-menu-list)))\n     \n-    ;; Only insert detailed master menu if there is one....\n-    (if (car (car master-menu-list))\n-;; @detailmenu added 5 Sept 1996 at Karl Berry's request to avert a\n-;; bug in `makeinfo'; all agree this is a bad kluge and should\n-;; eventually be removed.  @detailmenu ... @end detailmenu is a noop\n-;; in `texinfmt.el'  See @end detailmenu below\n-;; also see `texinfo-all-menus-update' above, `texinfo-master-menu',\n-;; `texinfo-multiple-files-update'\n-          (insert texinfo-master-menu-header))\n+      (setq master-menu-list (cdr master-menu-list))\n     \n-    ;; Now, insert all the other menus\n+      ;; Only insert detailed master menu if there is one....\n+      (if (car (car master-menu-list))\n+          (progn (setq master-menu-inserted-p t)\n+                 (insert (concat \"\\n@detailmenu\" texinfo-master-menu-header))))\n+\n+      ;; @detailmenu added 5 Sept 1996 to `texinfo-master-menu-header'\n+      ;; at Karl Berry's request to avert a bug in `makeinfo';\n+      ;; all agree this is a bad kludge and should eventually be removed.\n+      ;; @detailmenu ... @end detailmenu is a noop in `texinfmt.el'.\n+      ;; See @end detailmenu below;\n+      ;; also see `texinfo-all-menus-update' above, `texinfo-master-menu',\n+      ;; `texinfo-multiple-files-update'.\n+\n+      ;; Now, insert all the other menus\n     \n-    ;; The menu master-menu-list has a form like this:\n-    ;; (((\"beta\"  \"alpha\") \"title-A\")\n-    ;;  ((\"delta\" \"gamma\") \"title-B\"))\n+      ;; The menu master-menu-list has a form like this:\n+      ;; (((\"beta\"  \"alpha\") \"title-A\")\n+      ;;  ((\"delta\" \"gamma\") \"title-B\"))\n     \n-    (while master-menu-list\n+      (while master-menu-list\n       \n-      (message\n-       \"Inserting menu for %s .... \" (car (cdr (car master-menu-list))))\n-      ;; insert title of menu section\n-      (insert \"\\n\" (car (cdr (car master-menu-list))) \"\\n\\n\")\n+        (message\n+         \"Inserting menu for %s .... \" (car (cdr (car master-menu-list))))\n+        ;; insert title of menu section\n+        (insert \"\\n\" (car (cdr (car master-menu-list))) \"\\n\\n\")\n       \n-      ;; insert each menu entry\n-      (setq this-very-menu-list (reverse (car (car master-menu-list))))\n-      (while this-very-menu-list\n-        (insert \"* \" (car this-very-menu-list) \"\\n\")\n-        (setq this-very-menu-list (cdr this-very-menu-list)))\n+        ;; insert each menu entry\n+        (setq this-very-menu-list (reverse (car (car master-menu-list))))\n+        (while this-very-menu-list\n+          (insert \"* \" (car this-very-menu-list) \"\\n\")\n+          (setq this-very-menu-list (cdr this-very-menu-list)))\n       \n-      (setq master-menu-list (cdr master-menu-list)))\n+        (setq master-menu-list (cdr master-menu-list)))\n     \n-    ;; Finish menu\n-;; @detailmenu (see note above)\n-    (insert \"\\n@end detailmenu\")\n-    (insert \"\\n@end menu\\n\\n\")))\n+      ;; Finish menu\n \n-(defvar texinfo-master-menu-header\n-  \"\\n@detailmenu\\n --- The Detailed Node Listing ---\\n\"\n-  \"String inserted before lower level entries in Texinfo master menu.\n-It comes after the chapter-level menu entries.\")\n+      ;; @detailmenu (see note above)\n+      ;; Only insert @end detailmenu if a master menu was inserted.\n+      (if master-menu-inserted-p\n+          (insert \"\\n@end detailmenu\"))\n+      (insert \"\\n@end menu\\n\\n\"))))\n \n (defun texinfo-locate-menu-p ()\n   \"Find the next menu in the texinfo file.\n@@ -1005,18 +1011,18 @@ error if the node is not the top node and a section is not found.\"\n       (cond\n        ((re-search-forward \"^@node [ \\t]*top[ \\t]*\\\\(,\\\\|$\\\\)\"\n ;;; Following search limit by cph but causes a bug\n-;;;                      (save-excursion\n-;;;                        (end-of-line)\n-;;;                        (point))\n+;;;\t\t\t (save-excursion\n+;;;\t\t\t   (end-of-line)\n+;;;\t\t\t   (point))\n                            nil\n                            t)\n         \"top\")\n        ((re-search-forward texinfo-section-types-regexp nil t)\n         (buffer-substring-no-properties\n-         (progn (beginning-of-line)     ; copy its name\n-                (1+ (point)))\n-         (progn (forward-word 1)\n-                (point))))\n+\t (progn (beginning-of-line) ; copy its name\n+\t\t(1+ (point)))\n+\t (progn (forward-word 1)\n+\t\t(point))))\n        (t\n         (error\n          \"texinfo-specific-section-type: Chapter or section not found.\"))))))\n@@ -1236,15 +1242,14 @@ document; the values are regular expressions.\")\n ;;; Updating a node\n \n ;;;###autoload\n-(defun texinfo-update-node (&optional region-p)\n+(defun texinfo-update-node (&optional beginning end)\n   \"Without any prefix argument, update the node in which point is located.\n-Non-nil argument (prefix, if interactive) means update the nodes in the\n-marked region.\n+Interactively, a prefix argument means to operate on the region.\n \n The functions for creating or updating nodes and menus, and their\n keybindings, are:\n \n-    texinfo-update-node (&optional region-p)    \\\\[texinfo-update-node]\n+    texinfo-update-node (&optional beginning end)    \\\\[texinfo-update-node]\n     texinfo-every-node-update ()                \\\\[texinfo-every-node-update]\n     texinfo-sequential-node-update (&optional region-p)\n \n@@ -1257,41 +1262,35 @@ keybindings, are:\n The `texinfo-column-for-description' variable specifies the column to\n which menu descriptions are indented. Its default value is 32.\"\n   \n-  (interactive \"P\")\n-  (if (not region-p)\n-      ;; update a single node\n+  (interactive\n+   (if prefix-arg\n+       (list (point) (mark))))\n+  (if (null beginning)\n+      ;; Update a single node.\n       (let ((auto-fill-function nil) (auto-fill-hook nil))\n         (if (not (re-search-backward \"^@node\" (point-min) t))\n-            (error \"Node line not found before this position.\"))\n+            (error \"Node line not found before this position\"))\n         (texinfo-update-the-node)\n         (message \"Done...updated the node.  You may save the buffer.\"))\n     ;; else\n     (let ((auto-fill-function nil)\n-          (auto-fill-hook nil)\n-          (beginning (region-beginning))\n-          (end (region-end)))\n-      (if (= end beginning)\n-          (error \"Please mark a region!\"))\n-      (save-restriction\n-        (narrow-to-region beginning end)\n-        (goto-char beginning)\n-        (push-mark (point) t)\n-        (while (re-search-forward \"^@node\" (point-max) t)\n-          (beginning-of-line)            \n-          (texinfo-update-the-node))\n-        (message \"Done...updated nodes in region.  You may save the buffer.\")))))\n+\t  (auto-fill-hook nil))\n+      (save-excursion\n+\t(save-restriction\n+\t  (narrow-to-region beginning end)\n+\t  (goto-char (point-min))\n+\t  (while (re-search-forward \"^@node\" (point-max) t)\n+\t    (beginning-of-line)            \n+\t    (texinfo-update-the-node))\n+\t  (goto-char (point-max))\n+\t  (message \"Done...nodes updated in region.  You may save the buffer.\"))))))\n \n ;;;###autoload\n (defun texinfo-every-node-update ()\n   \"Update every node in a Texinfo file.\"\n   (interactive)\n   (save-excursion\n-    (push-mark (point-max) t)\n-    (goto-char (point-min))\n-    ;; Using the mark to pass bounds this way\n-    ;; is kludgy, but it's not worth fixing. -- rms.\n-    (let ((mark-active t))\n-      (texinfo-update-node t))\n+    (texinfo-update-node (point-min) (point-max))\n     (message \"Done...updated every node.       You may save the buffer.\")))\n \n (defun texinfo-update-the-node ()\n@@ -1366,7 +1365,7 @@ line, including the comma.  Leaves point at beginning of line.\"\n \n (defun texinfo-find-pointer (beginning end level direction)\n   \"Move point to section associated with next, previous, or up pointer.\n-Return type of pointer (either 'normal or 'no-pointer).\n+Return type of pointer (either `normal' or `no-pointer').\n \n The first and second arguments bound the search for a pointer to the\n beginning and end, respectively, of the enclosing higher level\n@@ -1447,7 +1446,7 @@ will be at some level higher in the Texinfo file.  The fourth argument\n \n (defun texinfo-pointer-name (kind)\n   \"Return the node name preceding the section command.\n-The argument is the kind of section, either normal or no-pointer.\"\n+The argument is the kind of section, either `normal' or `no-pointer'.\"\n   (let (name)\n     (cond ((eq kind 'normal)\n            (end-of-line)                ; this handles prev node top case\n@@ -1456,8 +1455,10 @@ The argument is the kind of section, either normal or no-pointer.\"\n             (save-excursion (forward-line -3))\n             t)\n            (setq name (texinfo-copy-node-name)))\n-          ((eq kind 'no-pointer)\n-           (setq name \" \")))    ; put a blank in the pointer slot\n+\t  ((eq kind 'no-pointer)\n+           ;; Don't need to put a blank in the pointer slot,\n+           ;; since insert \"' \" always has a space\n+\t   (setq name \" \")))\t; put a blank in the pointer slot\n     name))\n \n (defun texinfo-insert-pointer (beginning end level direction)\n@@ -1468,8 +1469,7 @@ The first and second arguments bound the search for a pointer to the\n beginning and end, respectively, of the enclosing higher level\n section.  The third argument is the hierarchical level of the Texinfo\n file, a string such as \\\"section\\\".  The fourth argument is direction\n-towards which the pointer is directed, one of `next, `previous, or\n-'up.\"\n+towards which the pointer is directed, one of `next', `previous', or `up'.\"\n \n   (end-of-line)\n   (insert\n@@ -1523,7 +1523,7 @@ Info `g*' command is inadequate.\"\n          \"Done...sequentially updated the node .  You may save the buffer.\"))\n     ;; else\n     (let ((auto-fill-function nil)\n-          (auto-fill-hook nil)\n+\t  (auto-fill-hook nil)\n           (beginning (region-beginning))\n           (end (region-end)))\n       (if (= end beginning)\n@@ -1565,13 +1565,13 @@ regardless of its hierarchical level.\"\n Move point to section associated with the pointer.  Find point even if\n it is in a different section.\n \n-Return type of pointer (either 'normal or 'no-pointer).\n+Return type of pointer (either `normal' or `no-pointer').\n \n The first argument is a string specifying the general kind of section\n such as \\\"chapter\\\" or \\\"section\\\".  The section found will be at the\n same hierarchical level in the Texinfo file, or, in the case of the up\n-pointer, some level higher.  The second argument (one of 'next,\n-'previous, or 'up) specifies whether to find the `Next', `Previous',\n+pointer, some level higher.  The second argument (one of `next',\n+`previous', or `up') specifies whether to find the `Next', `Previous',\n or `Up' pointer.\"\n   (let ((case-fold-search t))  \n     (cond ((eq direction 'next)\n@@ -1605,7 +1605,7 @@ Move point forward.\n \n The first argument is the hierarchical level of the Texinfo file, a\n string such as \\\"section\\\".  The second argument is direction, one of\n-`next, `previous, or 'up.\"\n+`next', `previous', or `up'.\"\n \n   (end-of-line)\n   (insert\n@@ -1624,7 +1624,7 @@ string such as \\\"section\\\".  The second argument is direction, one of\n   \"Insert missing `@node' lines in region of Texinfo file.\n Non-nil argument (prefix, if interactive) means also to insert the\n section titles as node names; and also to insert the section titles as\n-node names in pre-existing @node lines that lack names.\"\n+node names in pre-existing `@node' lines that lack names.\"\n   (interactive \"r\\nP\")\n \n   ;; Use marker; after inserting node lines, leave point at end of\n@@ -1785,8 +1785,7 @@ Requirements:\n   * this node must be the first node in the included file,\n   * each highest hierarchical level node must be of the same type.\n \n-Thus, normally, each included file contains one, and only one,\n-chapter.\"\n+Thus, normally, each included file contains one, and only one, chapter.\"\n \n ;; The menu-list has the form:\n ;; \n@@ -1879,7 +1878,7 @@ chapter.\"\n (defun texinfo-multi-files-insert-main-menu (menu-list)\n   \"Insert formatted main menu at point.\n Indents the first line of the description, if any, to the value of\n-texinfo-column-for-description.\"\n+`texinfo-column-for-description'.\"\n \n   (insert \"@menu\\n\")\n   (while menu-list\n@@ -2019,10 +2018,15 @@ chapter.\"\n       (progn\n         ;; First, removing detailed part of any pre-existing master menu\n         (goto-char (point-min))\n-        (if (re-search-forward texinfo-master-menu-header nil t)\n-            ;; Remove detailed master menu listing\n+        (if (search-forward texinfo-master-menu-header nil t)\n             (progn\n               (goto-char (match-beginning 0))\n+\t      ;; Check if @detailmenu kludge is used;\n+\t      ;; if so, leave point before @detailmenu.\n+\t      (search-backward \"\\n@detailmenu\" \n+\t\t\t       (save-excursion (forward-line -3) (point))\n+\t\t\t       t)\n+\t      ;; Remove detailed master menu listing\n               (let ((end-of-detailed-menu-descriptions\n                      (save-excursion     ; beginning of end menu line\n                        (goto-char (texinfo-menu-end))"}, {"sha": "24c555e3459837571ecf03bc9a83517061d27b7e", "filename": "texinfo/info/Makefile.in", "status": "modified", "additions": 273, "deletions": 178, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2FMakefile.in?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,232 +1,327 @@\n-# Makefile for texinfo/info.\t-*- Indented-Text -*-\n-# $Id: Makefile.in,v 1.1 1997/08/21 22:57:59 jason Exp $\n-# \n-# Copyright (C) 1993,96 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n+# Makefile.in generated automatically by automake 1.2 from Makefile.am\n \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+# Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy, distribute and modify it.\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n-#### Start of system configuration section. ####\n+SHELL = /bin/sh\n \n srcdir = @srcdir@\n-VPATH  = $(srcdir):$(common)\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n \n-common = $(srcdir)/../libtxi\n-util   = $(srcdir)/../util\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n \n-EXEEXT = @EXEEXT@\n-CC = @CC@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+\n+top_builddir = ..\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n \n INSTALL = @INSTALL@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+\n+NORMAL_INSTALL = true\n+PRE_INSTALL = true\n+POST_INSTALL = true\n+NORMAL_UNINSTALL = true\n+PRE_UNINSTALL = true\n+POST_UNINSTALL = true\n+CATALOGS = @CATALOGS@\n+CATOBJEXT = @CATOBJEXT@\n+CC = @CC@\n+DATADIRNAME = @DATADIRNAME@\n+EXEEXT = @EXEEXT@\n+GENCAT = @GENCAT@\n+GMOFILES = @GMOFILES@\n+GMSGFMT = @GMSGFMT@\n+GT_NO = @GT_NO@\n+GT_YES = @GT_YES@\n+INSTOBJEXT = @INSTOBJEXT@\n+INTLDEPS = @INTLDEPS@\n+INTLLIBS = @INTLLIBS@\n+INTLOBJS = @INTLOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKINSTALLDIRS = @MKINSTALLDIRS@\n+MSGFMT = @MSGFMT@\n+PACKAGE = @PACKAGE@\n+POFILES = @POFILES@\n+POSUB = @POSUB@\n+RANLIB = @RANLIB@\n+TERMLIBS = @TERMLIBS@\n+TEXCONFIG = @TEXCONFIG@\n+TEXMF = @TEXMF@\n+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@\n+USE_NLS = @USE_NLS@\n+VERSION = @VERSION@\n+l = @l@\n+\n+noinst_PROGRAMS = makedoc\n+\n+# Use `ginfo' for building to avoid confusion with the standard `info'\n+# target.  The install rule removes the `g' before applying any\n+# user-specified name transformations.\n+bin_PROGRAMS = ginfo\n+transform = s/ginfo/info/; @program_transform_name@\n+\n+localedir = $(datadir)/locale\n+\n+# -I. for funs.h.\n+INCLUDES = -I. -I$(top_srcdir)/lib -I../intl -DLOCALEDIR=\\\"$(localedir)\\\"\n+LDADD = ../lib/libtxi.a @TERMLIBS@ @INTLLIBS@\n+\n+makedoc_SOURCES = makedoc.c\n+ginfo_SOURCES = dir.c display.c display.h doc.c doc.h dribble.c dribble.h \\\n+  echo-area.c echo-area.h \\\n+  filesys.c filesys.h footnotes.c footnotes.h funs.h gc.c gc.h \\\n+  indices.c indices.h info-utils.c info-utils.h info.c info.h infodoc.c \\\n+  infomap.c infomap.h m-x.c man.c man.h nodemenu.c nodes.c nodes.h \\\n+  search.c search.h session.c session.h signals.c signals.h \\\n+  termdep.h terminal.c terminal.h tilde.c tilde.h \\\n+  variables.c variables.h window.c window.h\n+\n+EXTRA_DIST = README\n+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n+CONFIG_HEADER = ../config.h\n+CONFIG_CLEAN_FILES = \n+bin_PROGRAMS =  ginfo$(EXEEXT)\n+noinst_PROGRAMS =  makedoc$(EXEEXT)\n+PROGRAMS =  $(bin_PROGRAMS) $(noinst_PROGRAMS)\n+\n+\n+DEFS = @DEFS@ -I. -I$(srcdir) -I..\n+CPPFLAGS = @CPPFLAGS@\n+LDFLAGS = @LDFLAGS@\n+LIBS = @LIBS@\n+ginfo_OBJECTS =  dir.o display.o doc.o dribble.o echo-area.o filesys.o \\\n+footnotes.o gc.o indices.o info-utils.o info.o infodoc.o infomap.o \\\n+m-x.o man.o nodemenu.o nodes.o search.o session.o signals.o terminal.o \\\n+tilde.o variables.o window.o\n+ginfo_LDADD = $(LDADD)\n+ginfo_DEPENDENCIES =  ../lib/libtxi.a\n+ginfo_LDFLAGS = \n+makedoc_OBJECTS =  makedoc.o\n+makedoc_LDADD = $(LDADD)\n+makedoc_DEPENDENCIES =  ../lib/libtxi.a\n+makedoc_LDFLAGS = \n+CFLAGS = @CFLAGS@\n+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)\n+LINK = $(CC) $(CFLAGS) $(LDFLAGS) -o $@\n+DIST_COMMON =  README Makefile.am Makefile.in\n \n-LN\t= ln\n-RM\t= rm -f\n-MKDIR\t= mkdir\n-MAKEINFO= ../makeinfo/makeinfo$(EXEEXT)\n \n-DEFS = @DEFS@\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-LDEFS = -DHANDLE_MAN_PAGES -DNAMED_FUNCTIONS=1 -DDEFAULT_INFOPATH='\"$(DEFAULT_INFOPATH)\"'\n+TAR = tar\n+GZIP = --best\n+SOURCES = $(ginfo_SOURCES) $(makedoc_SOURCES)\n+OBJECTS = $(ginfo_OBJECTS) $(makedoc_OBJECTS)\n \n-TERMLIBS = @TERMLIBS@\n-LIBS = $(TERMLIBS) -L../libtxi -ltxi @LIBS@\n-LOADLIBES = $(LIBS)\n+default: all\n \n-SHELL = /bin/sh\n+.SUFFIXES:\n+.SUFFIXES: .c .o\n+$(srcdir)/Makefile.in: @MAINT@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus info/Makefile\n \n-CFLAGS = @CFLAGS@\n-LDFLAGS = @LDFLAGS@\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n \n-prefix = @prefix@\n-exec_prefix = @exec_prefix@\n-bindir = @bindir@\n-# Prefix for each installed program, normally empty or `g'.\n-binprefix = \n-# Prefix for each installed man page, normally empty or `g'.\n-manprefix = \n-mandir = @mandir@/man1\n-manext = 1\n-infodir = @infodir@\n-DEFAULT_INFOPATH= $(infodir):.\n \n-#### End of system configuration section. ####\n+mostlyclean-binPROGRAMS:\n+\n+clean-binPROGRAMS:\n+\ttest -z \"$(bin_PROGRAMS)\" || rm -f $(bin_PROGRAMS)\n \n-SRCS =\tdir.c\t\tdisplay.c\techo_area.c\tfilesys.c \\\n-\tinfo-utils.c\tinfo.c\t\tinfodoc.c\tinfomap.c \\\n-\tm-x.c\t\tnodes.c\t\tsearch.c\tsession.c \\\n-\tsignals.c\tterminal.c\ttilde.c\t\twindow.c \\\n-\txmalloc.c\tindices.c\tmakedoc.c\tnodemenu.c \\\n-\tfootnotes.c\tdribble.c\tvariables.c\tgc.c man.c \\\n-\tclib.c\n+distclean-binPROGRAMS:\n \n-HDRS =\tdisplay.h\tdoc.h\t\techo_area.h\tfilesys.h \\\n-\tgeneral.h\tgetopt.h\tinfo-utils.h\tinfo.h \\\n-\tinfomap.h\tnodes.h\t\tsearch.h \tsession.h \\\n-\tsignals.h\ttermdep.h\tterminal.h\ttilde.h \\\n-\tindices.h\twindow.h\tfootnotes.h\tdribble.h \\\n-\tvariables.h\tgc.h\t\tclib.h\n+maintainer-clean-binPROGRAMS:\n \n-OBJS =\tdir.o display.o doc.o echo_area.o filesys.o info-utils.o info.o \\\n-\tinfodoc.o infomap.o m-x.o nodes.o search.o session.o signals.o \\\n-\tterminal.o tilde.o window.o indices.o xmalloc.o nodemenu.o \\\n-\tfootnotes.o dribble.o variables.o gc.o man.o clib.o\n+install-binPROGRAMS: $(bin_PROGRAMS)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(bindir)\n+\t@list='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \"  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`\"; \\\n+\t     $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\t  else :; fi; \\\n+\tdone\n \n-# The names of files which declare info commands.\n-CMDFILES = $(srcdir)/session.c $(srcdir)/echo_area.c $(srcdir)/infodoc.c \\\n-\t   $(srcdir)/m-x.c $(srcdir)/indices.c $(srcdir)/nodemenu.c \\\n-\t   $(srcdir)/footnotes.c $(srcdir)/variables.c\n+uninstall-binPROGRAMS:\n+\t$(NORMAL_UNINSTALL)\n+\tlist='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\tdone\n \n-# The name of the program which builds documentation structure from CMDFILES.\n-MAKEDOC_OBJECTS = makedoc.o clib.o xmalloc.o\n-MAKEDOC_SOURCE = makedoc.c clib.c xmalloc.c\n+mostlyclean-noinstPROGRAMS:\n \n-infofiles = info.info info-stnd.info\n+clean-noinstPROGRAMS:\n+\ttest -z \"$(noinst_PROGRAMS)\" || rm -f $(noinst_PROGRAMS)\n+\n+distclean-noinstPROGRAMS:\n+\n+maintainer-clean-noinstPROGRAMS:\n \n .c.o:\n-\t$(CC) -c $(CPPFLAGS) $(LDEFS) $(DEFS) -I. -I$(srcdir) -I$(common) $(CFLAGS) $<\n+\t$(COMPILE) -c $<\n+\n+mostlyclean-compile:\n+\trm -f *.o core\n+\n+clean-compile:\n+\n+distclean-compile:\n+\trm -f *.tab.c\n \n-all: info$(EXEEXT) $(infofiles)\n-sub-all: all\n+maintainer-clean-compile:\n \n-dvi: all-dvi\n+ginfo$(EXEEXT): $(ginfo_OBJECTS) $(ginfo_DEPENDENCIES)\n+\t@rm -f ginfo$(EXEEXT)\n+\t$(LINK) $(ginfo_LDFLAGS) $(ginfo_OBJECTS) $(ginfo_LDADD) $(LIBS)\n \n-install: all\n-\t$(INSTALL_PROGRAM) info$(EXEEXT) $(bindir)/$(binprefix)info$(EXEEXT)\n-\t-$(INSTALL_DATA) $(srcdir)/info.1 $(mandir)/$(manprefix)info.$(manext)\n-\t$(POST_INSTALL)\n+makedoc$(EXEEXT): $(makedoc_OBJECTS) $(makedoc_DEPENDENCIES)\n+\t@rm -f makedoc$(EXEEXT)\n+\t$(LINK) $(makedoc_LDFLAGS) $(makedoc_OBJECTS) $(makedoc_LDADD) $(LIBS)\n \n-install-info: \n-\t-d=$(srcdir); test -f ./info.info && d=.; $(INSTALL_DATA) $$d/info.info $(infodir)/info.info\n-\t-d=$(srcdir); test -f ./info-stnd.info && d=.; $(INSTALL_DATA) $$d/info-stnd.info $(infodir)/info-stnd.info\n-\t../util/install-info --info-dir=$(infodir) $(infodir)/info.info\n-\t../util/install-info --info-dir=$(infodir) $(infodir)/info-stnd.info\n+tags: TAGS\n \n-uninstall:\n-\t$(RM) $(bindir)/info$(EXEEXT)\n-\t$(RM) $(infodir)/info.info\n-\t$(RM) $(infodir)/info-stnd.info\n-\t$(RM) $(mandir)/$(manprefix)info.$(manext)\n+ID: $(HEADERS) $(SOURCES)\n+\there=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)\n \n-info$(EXEEXT): $(OBJS) ../libtxi/libtxi.a\n-\t$(CC) $(LDFLAGS) -o $@ $(OBJS) $(LOADLIBES)\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\ttest -z \"$(ETAGS_ARGS)$(SOURCES)$(HEADERS)$$tags\" \\\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $(SOURCES) $(HEADERS) -o $$here/TAGS)\n \n-all-info: info.info info-stnd.info\n+mostlyclean-tags:\n \n-info.info: info.texi\n-\t$(MAKEINFO) --no-split -I$(srcdir) info.texi\n+clean-tags:\n \n-info-stnd.info: info-stnd.texi\n-\t$(MAKEINFO) --no-split -I$(srcdir) info-stnd.texi\n+distclean-tags:\n+\trm -f TAGS ID\n \n-dvi all-dvi: info.dvi info-stnd.dvi\n-info.dvi: info.texi\n-\tPATH=\"$(util):$${PATH}\" TEXINPUTS=\"$(srcdir):$(common):$${TEXINPUTS}\" texi2dvi $(srcdir)/info.texi\n+maintainer-clean-tags:\n \n-info-stnd.dvi: info-stnd.texi\n-\tPATH=\"$(util):$${PATH}\" TEXINPUTS=\"$(srcdir):$(common):$${TEXINPUTS}\" texi2dvi $(srcdir)/info-stnd.texi\n+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n \n-makedoc$(EXEEXT): $(MAKEDOC_OBJECTS) ../libtxi/libtxi.a\n-\t$(CC) $(LDFLAGS) -o $@ $(MAKEDOC_OBJECTS) $(LOADLIBES)\n+subdir = info\n \n-Makefile: $(srcdir)/Makefile.in ../config.status\n-\tcd ..; $(SHELL) config.status\n+distdir: $(DISTFILES)\n+\t@for file in $(DISTFILES); do \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  test -f $(distdir)/$$file \\\n+\t  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t  || cp -p $$d/$$file $(distdir)/$$file; \\\n+\tdone\n+info:\n+dvi:\n+check: all\n+\t$(MAKE)\n+installcheck:\n+install-info:\n+install-exec: install-binPROGRAMS\n+\t@$(NORMAL_INSTALL)\n \n-clean:\n-\t$(RM) info$(EXEEXT) funs.h doc.c makedoc$(EXEEXT) $(OBJS) $(MAKEDOC_OBJECTS)\n+install-data: \n+\t@$(NORMAL_INSTALL)\n \n-distclean: clean texclean\n-\t$(RM) Makefile config.status config.cache *~ core core.* *.core\n-\t$(RM) *.BAK makedoc-TAGS TAGS \\#* *.info*\n+install: install-exec install-data all\n+\t@:\n \n-mostlyclean: clean\n+uninstall: uninstall-binPROGRAMS\n \n-realclean: distclean\n-\t$(RM) info.info info-stnd.info\n+all: Makefile $(PROGRAMS)\n \n-TAGS: $(SRCS) makedoc-TAGS\n-\tetags $(SRCS)\n-\tcat makedoc-TAGS >>TAGS && $(RM) makedoc-TAGS\n+install-strip:\n+\t$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install\n+installdirs:\n+\t$(mkinstalldirs)  $(bindir)\n \n-makedoc-TAGS: $(CMDFILES)\n-\t./makedoc -tags $(CMDFILES) >makedoc-TAGS\n \n-texclean:\n-\t$(RM) *.toc *.aux *.log *.cp *.fn *.tp *.vr *.pg *.ky *.cps\n-\t$(RM) *.tps *.fns *.kys *.pgs *.vrs\n+mostlyclean-generic:\n+\ttest -z \"$(MOSTLYCLEANFILES)\" || rm -f $(MOSTLYCLEANFILES)\n+\n+clean-generic:\n+\ttest -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\trm -f Makefile $(DISTCLEANFILES)\n+\trm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\ttest -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\n+maintainer-clean-generic:\n+\ttest -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n+\ttest -z \"$(BUILT_SOURCES)\" || rm -f $(BUILT_SOURCES)\n+mostlyclean:  mostlyclean-binPROGRAMS mostlyclean-noinstPROGRAMS \\\n+\t\tmostlyclean-compile mostlyclean-tags \\\n+\t\tmostlyclean-generic\n+\n+clean:  clean-binPROGRAMS clean-noinstPROGRAMS clean-compile clean-tags \\\n+\t\tclean-generic mostlyclean\n+\n+distclean:  distclean-binPROGRAMS distclean-noinstPROGRAMS \\\n+\t\tdistclean-compile distclean-tags distclean-generic \\\n+\t\tclean\n+\trm -f config.status\n+\n+maintainer-clean:  maintainer-clean-binPROGRAMS \\\n+\t\tmaintainer-clean-noinstPROGRAMS \\\n+\t\tmaintainer-clean-compile maintainer-clean-tags \\\n+\t\tmaintainer-clean-generic distclean\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\n+.PHONY: default mostlyclean-binPROGRAMS distclean-binPROGRAMS \\\n+clean-binPROGRAMS maintainer-clean-binPROGRAMS uninstall-binPROGRAMS \\\n+install-binPROGRAMS mostlyclean-noinstPROGRAMS distclean-noinstPROGRAMS \\\n+clean-noinstPROGRAMS maintainer-clean-noinstPROGRAMS \\\n+mostlyclean-compile distclean-compile clean-compile \\\n+maintainer-clean-compile tags mostlyclean-tags distclean-tags \\\n+clean-tags maintainer-clean-tags distdir info dvi installcheck \\\n+install-info install-exec install-data install uninstall all \\\n+installdirs mostlyclean-generic distclean-generic clean-generic \\\n+maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n-check: info\n \n # The files `doc.c' and `funs.h' are created by ./makedoc run over the source\n # files which contain DECLARE_INFO_COMMAND.  `funs.h' is a header file\n # listing the functions found.  `doc.c' is a structure containing pointers\n # to those functions along with completable names and documentation strings.\n-funs.h: makedoc$(EXEEXT) $(CMDFILES)\n-\t-@if test -f funs.h; then mv -f funs.h old-funs.h; fi; :\n-\t-@if test -f doc.c; then mv -f doc.c old-doc.c; fi; :\n-\t./makedoc$(EXEEXT) $(CMDFILES)\n-\t-@if cmp -s old-funs.h funs.h; then mv old-funs.h funs.h; \\\n-\t  else $(RM) old-funs.h; fi; :\n-\t-@if cmp -s old-doc.c doc.c; then mv old-doc.c doc.c; \\\n-\t  else $(RM) old-doc.c; fi; :\n-\n-doc.c: \t\tfuns.h\n-dribble.o:\tdribble.c dribble.h\n-display.o:\tdisplay.c\n-echo_area.o:\techo_area.c\n-filesys.o:\tfilesys.c\n-info-utils.o:\tinfo-utils.c\n-info.o:\t\tinfo.c filesys.h\n-infodoc.o:\tinfodoc.c\n-infomap.o:\tinfomap.c\n-m-x.o:\t\tm-x.c\n-nodes.o:\tnodes.c\n-search.o:\tsearch.c\n-session.o:\tsession.c\n-signals.o:\tsignals.c\n-terminal.o:\tterminal.c\n-tilde.o:\ttilde.c\n-window.o:\twindow.c\n-xmalloc.o:\txmalloc.c\n-indices.o:\tindices.c\n-makedoc.o:\tmakedoc.c\n-\n-dir.o: \t\tdir.c\n-display.o: \tnodes.h info-utils.h search.h\n-display.o: \tterminal.h window.h display.h\n-echo_area.o: \tinfo.h\n-filesys.o: \tgeneral.h tilde.h filesys.h\n-footnotes.o: \tfootnotes.h\n-info-utils.o: \tinfo-utils.h nodes.h search.h\n-info.o: \tinfo.h $(common)/getopt.h\n-infodoc.o: \tinfo.h doc.h\n-infomap.o: \tinfomap.h funs.h\n-gc.o:\t\tinfo.h\n-m-x.o: \t\tinfo.h\n-nodes.o: \tsearch.h filesys.h\n-nodes.o: \tnodes.h info-utils.h\n-search.o: \tgeneral.h search.h nodes.h\n-session.o: \tinfo.h\n-signals.o: \tinfo.h signals.h\n-terminal.o: \tterminal.h termdep.h\n-tilde.o: \ttilde.h\n-variables.c: \tvariables.h\n-window.o: \tnodes.h window.h display.h\n-window.o: \tinfo-utils.h search.h infomap.h\n-\n-# Prevent GNU make v3 from overflowing arg limit on SysV.\n+# \n+# I do not know how to get this right.\n+# BUILT_SOURCES = doc.c funs.h\n+#\n+#cmd_sources = $(srcdir)/session.c $(srcdir)/echo-area.c $(srcdir)/infodoc.c \\\n+#  $(srcdir)/m-x.c $(srcdir)/indices.c $(srcdir)/nodemenu.c \\\n+#  $(srcdir)/footnotes.c $(srcdir)/variables.c\n+#\n+#$(BUILTSOURCES): makedoc $(cmd_sources)\n+#\t./makedoc $(cmd_sources)\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:\n-\n-# eof"}, {"sha": "90d3e2cd5221880f33d38f447bf5f35ae218f2ba", "filename": "texinfo/info/README", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2FREADME?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,3 @@\n-The file NEWS contains information about what has changed since the last\n-release.\n-\n-The file ../INSTALL contains instructions on how to install Info.\n-\n-\f\n Info 2.0 is a complete rewrite of the original standalone Info I wrote in\n 1987, the first program I wrote for rms.  That program was something like\n my second Unix program ever, and my die-hard machine language coding habits"}, {"sha": "651e48a6e368572e0b26b0ef60b159d81c166c01", "filename": "texinfo/info/dir.c", "status": "modified", "additions": 105, "deletions": 85, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fdir.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* dir.c -- How to build a special \"dir\" node from \"localdir\" files. */\n+/* dir.c -- How to build a special \"dir\" node from \"localdir\" files.\n+   $Id: dir.c,v 1.6 1997/07/27 21:09:20 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,13 +19,7 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#if defined (HAVE_SYS_FILE_H)\n-#include <sys/file.h>\n-#endif /* HAVE_SYS_FILE_H */\n-#include <sys/errno.h>\n+#include \"info.h\"\n #include \"info-utils.h\"\n #include \"filesys.h\"\n #include \"tilde.h\"\n@@ -37,23 +29,53 @@\n    dirs_to_add which are found in INFOPATH. */\n \n static void add_menu_to_file_buffer (), insert_text_into_fb_at_binding ();\n-static void build_dir_node_internal ();\n \n static char *dirs_to_add[] = {\n   \"dir\", \"localdir\", (char *)NULL\n };\n \n+\n+/* Return zero if the file represented in the stat structure TEST has\n+   already been seen, nonzero else.  */\n+\n+typedef struct\n+{\n+  unsigned long device;\n+  unsigned long inode;\n+} dir_file_list_entry_type;\n+\n+static int\n+new_dir_file_p (test)\n+    struct stat *test;\n+{\n+  static unsigned dir_file_list_len = 0;\n+  static dir_file_list_entry_type *dir_file_list = NULL;\n+  unsigned i;\n+  \n+  for (i = 0; i < dir_file_list_len; i++)\n+    {\n+      dir_file_list_entry_type entry;\n+      entry = dir_file_list[i];\n+      if (entry.device == test->st_dev && entry.inode == test->st_ino)\n+        return 0;\n+    }\n+  \n+  dir_file_list_len++;\n+  dir_file_list = xrealloc (dir_file_list, \n+                        dir_file_list_len * sizeof (dir_file_list_entry_type));\n+  dir_file_list[dir_file_list_len - 1].device = test->st_dev;\n+  dir_file_list[dir_file_list_len - 1].inode = test->st_ino;\n+  return 1;\n+}\n+\n+\n void\n maybe_build_dir_node (dirname)\n      char *dirname;\n {\n-  FILE_BUFFER *dir_buffer;\n   int path_index, update_tags;\n   char *this_dir;\n-\n-  /* Check to see if the file has already been built.  If so, then\n-     do not build it again. */\n-  dir_buffer = info_find_file (dirname);\n+  FILE_BUFFER *dir_buffer = info_find_file (dirname);\n \n   /* If there is no \"dir\" in the current info path, we cannot build one\n      from nothing. */\n@@ -64,69 +86,67 @@ maybe_build_dir_node (dirname)\n   if (dir_buffer->flags & N_CannotGC)\n     return;\n \n+  /* Initialize the list we use to avoid reading the same dir file twice\n+     with the dir file just found.  */\n+  new_dir_file_p (&dir_buffer->finfo);\n+  \n   path_index = update_tags = 0;\n \n   /* Using each element of the path, check for one of the files in\n      DIRS_TO_ADD.  Do not check for \"localdir.info.Z\" or anything else.\n      Only files explictly named are eligible.  This is a design decision.\n      There can be an info file name \"localdir.info\" which contains\n      information on the setting up of \"localdir\" files. */\n-  while (this_dir = extract_colon_unit (infopath, &path_index))\n+  while ((this_dir = extract_colon_unit (infopath, &path_index)))\n     {\n       register int da_index;\n       char *from_file;\n \n       /* Expand a leading tilde if one is present. */\n       if (*this_dir == '~')\n-\t{\n-\t  char *tilde_expanded_dirname;\n-\n-\t  tilde_expanded_dirname = tilde_expand_word (this_dir);\n-\t  if (tilde_expanded_dirname != this_dir)\n-\t    {\n-\t      free (this_dir);\n-\t      this_dir = tilde_expanded_dirname;\n-\t    }\n-\t}\n-\n-      /* For every file named in DIRS_TO_ADD found in the search path,\n-\t add the contents of that file's menu to our \"dir\" node. */\n-      for (da_index = 0; from_file = dirs_to_add[da_index]; da_index++)\n-\t{\n-\t  struct stat finfo;\n-\t  char *fullpath;\n-\t  int namelen, statable;\n-\n-\t  namelen = strlen (from_file);\n-\n-\t  fullpath = (char *)xmalloc (3 + strlen (this_dir) + namelen);\n-\t  strcpy (fullpath, this_dir);\n-\t  if (fullpath[strlen (fullpath) - 1] != '/')\n-\t    strcat (fullpath, \"/\");\n-\t  strcat (fullpath, from_file);\n-\n-\t  statable = (stat (fullpath, &finfo) == 0);\n-\n-\t  /* Only add the contents of this file if it is not identical to the\n-\t     file of the DIR buffer. */\n-\t  if ((statable && S_ISREG (finfo.st_mode)) &&\n-\t      (strcmp (dir_buffer->fullpath, fullpath) != 0))\n-\t    {\n-\t      long filesize;\n-\t      char *contents;\n-\n-\t      contents = filesys_read_info_file (fullpath, &filesize, &finfo);\n-\n-\t      if (contents)\n-\t\t{\n-\t\t  update_tags++;\n-\t\t  add_menu_to_file_buffer (contents, filesize, dir_buffer);\n-\t\t  free (contents);\n-\t\t}\n-\t    }\n-\n-\t  free (fullpath);\n-\t}\n+        {\n+          char *tilde_expanded_dirname;\n+\n+          tilde_expanded_dirname = tilde_expand_word (this_dir);\n+          if (tilde_expanded_dirname != this_dir)\n+            {\n+              free (this_dir);\n+              this_dir = tilde_expanded_dirname;\n+            }\n+        }\n+\n+      /* For every different file named in DIRS_TO_ADD found in the\n+         search path, add that file's menu to our \"dir\" node. */\n+      for (da_index = 0; (from_file = dirs_to_add[da_index]); da_index++)\n+        {\n+          struct stat finfo;\n+          int statable;\n+          int namelen = strlen (from_file);\n+          char *fullpath = xmalloc (3 + strlen (this_dir) + namelen);\n+          \n+          strcpy (fullpath, this_dir);\n+          if (fullpath[strlen (fullpath) - 1] != '/')\n+            strcat (fullpath, \"/\");\n+          strcat (fullpath, from_file);\n+\n+          statable = (stat (fullpath, &finfo) == 0);\n+\n+          /* Only add this file if we have not seen it before.  */\n+          if (statable && S_ISREG (finfo.st_mode) && new_dir_file_p (&finfo))\n+            {\n+              long filesize;\n+              char *contents = filesys_read_info_file (fullpath, &filesize,\n+                                                       &finfo);\n+              if (contents)\n+                {\n+                  update_tags++;\n+                  add_menu_to_file_buffer (contents, filesize, dir_buffer);\n+                  free (contents);\n+                }\n+            }\n+\n+          free (fullpath);\n+        }\n       free (this_dir);\n     }\n \n@@ -176,37 +196,37 @@ add_menu_to_file_buffer (contents, size, fb)\n   if (fb_offset == -1)\n     {\n       /* Find the start of the second node in this file buffer.  If there\n-\t is only one node, we will be adding the contents to the end of\n-\t this node. */\n+         is only one node, we will be adding the contents to the end of\n+         this node. */\n       fb_offset = find_node_separator (&fb_binding);\n \n       /* If not even a single node separator, give up. */\n       if (fb_offset == -1)\n-\treturn;\n+        return;\n \n       fb_binding.start = fb_offset;\n       fb_binding.start +=\n-\tskip_node_separator (fb_binding.buffer + fb_binding.start);\n+        skip_node_separator (fb_binding.buffer + fb_binding.start);\n \n       /* Try to find the next node separator. */\n       fb_offset = find_node_separator (&fb_binding);\n \n       /* If found one, consider that the start of the menu.  Otherwise, the\n-\t start of this menu is the end of the file buffer (i.e., fb->size). */\n+         start of this menu is the end of the file buffer (i.e., fb->size). */\n       if (fb_offset != -1)\n-\tfb_binding.start = fb_offset;\n+        fb_binding.start = fb_offset;\n       else\n-\tfb_binding.start = fb_binding.end;\n+        fb_binding.start = fb_binding.end;\n \n       insert_text_into_fb_at_binding\n-\t(fb, &fb_binding, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL));\n+        (fb, &fb_binding, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL));\n \n       fb_binding.buffer = fb->contents;\n       fb_binding.start = 0;\n       fb_binding.end = fb->filesize;\n       fb_offset = search_forward (INFO_MENU_LABEL, &fb_binding);\n       if (fb_offset == -1)\n-\tabort ();\n+        abort ();\n     }\n \n   /* CONTENTS_OFFSET and FB_OFFSET point to the starts of the menus that\n@@ -224,23 +244,23 @@ add_menu_to_file_buffer (contents, size, fb)\n     int num_found = 0;\n \n     while ((fb_binding.start > 0) &&\n-\t   (whitespace_or_newline (fb_binding.buffer[fb_binding.start - 1])))\n+           (whitespace_or_newline (fb_binding.buffer[fb_binding.start - 1])))\n       {\n-\tnum_found++;\n-\tfb_binding.start--;\n+        num_found++;\n+        fb_binding.start--;\n       }\n \n     /* Optimize if possible. */\n     if (num_found >= 2)\n       {\n-\tfb_binding.buffer[fb_binding.start++] = '\\n';\n-\tfb_binding.buffer[fb_binding.start++] = '\\n';\n+        fb_binding.buffer[fb_binding.start++] = '\\n';\n+        fb_binding.buffer[fb_binding.start++] = '\\n';\n       }\n     else\n       {\n-\t/* Do it the hard way. */\n-\tinsert_text_into_fb_at_binding (fb, &fb_binding, \"\\n\\n\", 2);\n-\tfb_binding.start += 2;\n+        /* Do it the hard way. */\n+        insert_text_into_fb_at_binding (fb, &fb_binding, \"\\n\\n\", 2);\n+        fb_binding.start += 2;\n       }\n   }\n "}, {"sha": "3f2abe34cb15890b5d7e02fb2dc3d87bbb7e86f6", "filename": "texinfo/info/display.c", "status": "modified", "additions": 249, "deletions": 253, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdisplay.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdisplay.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fdisplay.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* display.c -- How to display Info windows. */\n+/* display.c -- How to display Info windows.\n+   $Id: display.c,v 1.6 1997/07/24 21:13:27 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,10 +19,7 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n+#include \"info.h\"\n #include \"display.h\"\n \n extern int info_any_buffered_input_p (); /* Found in session.c. */\n@@ -57,7 +52,7 @@ display_clear_display (display)\n   register int i;\n   register DISPLAY_LINE *display_line;\n \n-  for (i = 0; display_line = display[i]; i++)\n+  for (i = 0; (display_line = display[i]); i++)\n     {\n       display[i]->text[0] = '\\0';\n       display[i]->textlen = 0;\n@@ -83,13 +78,13 @@ display_update_display (window)\n     {\n       /* Only re-display visible windows which need updating. */\n       if (((win->flags & W_WindowVisible) == 0) ||\n-\t  ((win->flags & W_UpdateWindow) == 0) ||\n-\t  (win->height == 0))\n-\tcontinue;\n+          ((win->flags & W_UpdateWindow) == 0) ||\n+          (win->height == 0))\n+        continue;\n \n       display_update_one_window (win);\n       if (display_was_interrupted_p)\n-\tbreak;\n+        break;\n     }\n \n   /* Always update the echo area. */\n@@ -102,12 +97,12 @@ void\n display_update_one_window (win)\n      WINDOW *win;\n {\n-  register char *nodetext;\t/* Current character to display. */\n+  register char *nodetext;      /* Current character to display. */\n   register char *last_node_char; /* Position of the last character in node. */\n-  register int i;\t\t/* General use index. */\n-  char *printed_line;\t\t/* Buffer for a printed line. */\n-  int pl_index = 0;\t\t/* Index into PRINTED_LINE. */\n-  int line_index = 0;\t\t/* Number of lines done so far. */\n+  register int i;               /* General use index. */\n+  char *printed_line;           /* Buffer for a printed line. */\n+  int pl_index = 0;             /* Index into PRINTED_LINE. */\n+  int line_index = 0;           /* Number of lines done so far. */\n   DISPLAY_LINE **display = the_display;\n \n   /* If display is inhibited, that counts as an interrupted display. */\n@@ -142,165 +137,165 @@ display_update_one_window (win)\n       int replen;\n \n       if (isprint (*nodetext))\n-\t{\n-\t  rep_temp[0] = *nodetext;\n-\t  replen = 1;\n-\t  rep_temp[1] = '\\0';\n-\t  rep = rep_temp;\n-\t}\n+        {\n+          rep_temp[0] = *nodetext;\n+          replen = 1;\n+          rep_temp[1] = '\\0';\n+          rep = rep_temp;\n+        }\n       else\n-\t{\n-\t  if (*nodetext == '\\r' || *nodetext == '\\n')\n-\t    {\n-\t      replen = win->width - pl_index;\n-\t    }\n-\t  else\n-\t    {\n-\t      rep = printed_representation (*nodetext, pl_index);\n-\t      replen = strlen (rep);\n-\t    }\n-\t}\n+        {\n+          if (*nodetext == '\\r' || *nodetext == '\\n')\n+            {\n+              replen = win->width - pl_index;\n+            }\n+          else\n+            {\n+              rep = printed_representation (*nodetext, pl_index);\n+              replen = strlen (rep);\n+            }\n+        }\n \n       /* If this character can be printed without passing the width of\n-\t the line, then stuff it into the line. */\n+         the line, then stuff it into the line. */\n       if (replen + pl_index < win->width)\n-\t{\n-\t  /* Optimize if possible. */\n-\t  if (replen == 1)\n-\t    {\n-\t      printed_line[pl_index++] = *rep;\n-\t    }\n-\t  else\n-\t    {\n-\t      for (i = 0; i < replen; i++)\n-\t\tprinted_line[pl_index++] = rep[i];\n-\t    }\n-\t}\n+        {\n+          /* Optimize if possible. */\n+          if (replen == 1)\n+            {\n+              printed_line[pl_index++] = *rep;\n+            }\n+          else\n+            {\n+              for (i = 0; i < replen; i++)\n+                printed_line[pl_index++] = rep[i];\n+            }\n+        }\n       else\n-\t{\n-\t  DISPLAY_LINE *entry;\n-\n-\t  /* If this character cannot be printed in this line, we have\n-\t     found the end of this line as it would appear on the screen.\n-\t     Carefully print the end of the line, and then compare. */\n-\t  if (*nodetext == '\\n' || *nodetext == '\\r' || *nodetext == '\\t')\n-\t    {\n-\t      printed_line[pl_index] = '\\0';\n-\t      rep_carried_over = (char *)NULL;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The printed representation of this character extends into\n-\t\t the next line.  Remember the offset of the last character\n-\t\t printed out of REP so that we can carry the character over\n-\t\t to the next line. */\n-\t      for (i = 0; pl_index < (win->width - 1);)\n-\t\tprinted_line[pl_index++] = rep[i++];\n-\t      \n-\t      rep_carried_over = rep + i;\n-\n-\t      /* If printing the last character in this window couldn't\n-\t\t possibly cause the screen to scroll, place a backslash\n-\t\t in the rightmost column. */\n-\t      if (1 + line_index + win->first_row < the_screen->height)\n-\t\t{\n-\t\t  if (win->flags & W_NoWrap)\n-\t\t    printed_line[pl_index++] = '$';\n-\t\t  else\n-\t\t    printed_line[pl_index++] = '\\\\';\n-\t\t}\n-\t      printed_line[pl_index] = '\\0';\n-\t    }\n-\n-\t  /* We have the exact line as it should appear on the screen.\n-\t     Check to see if this line matches the one already appearing\n-\t     on the screen. */\n-\t  entry = display[line_index + win->first_row];\n-\n-\t  /* If the screen line is inversed, then we have to clear\n-\t     the line from the screen first.  Why, I don't know. */\n-\t  if (entry->inverse)\n-\t    {\n-\t      terminal_goto_xy (0, line_index + win->first_row);\n-\t      terminal_clear_to_eol ();\n-\t      entry->inverse = 0;\n-\t      entry->text[0] = '\\0';\n-\t      entry->textlen = 0;\n-\t    }\n-\n-\t  /* Find the offset where these lines differ. */\n-\t  for (i = 0; i < pl_index; i++)\n-\t    if (printed_line[i] != entry->text[i])\n-\t      break;\n-\n-\t  /* If the lines are not the same length, or if they differed\n-\t     at all, we must do some redrawing. */\n-\t  if ((i != pl_index) || (pl_index != entry->textlen))\n-\t    {\n-\t      /* Move to the proper point on the terminal. */\n-\t      terminal_goto_xy (i, line_index + win->first_row);\n-\n-\t      /* If there is any text to print, print it. */\n-\t      if (i != pl_index)\n-\t\tterminal_put_text (printed_line + i);\n-\n-\t      /* If the printed text didn't extend all the way to the edge\n-\t\t of the window, and text was appearing between here and the\n-\t\t edge of the window, clear from here to the end of the line. */\n-\t      if ((pl_index < win->width && pl_index < entry->textlen) ||\n-\t\t  (entry->inverse))\n-\t\tterminal_clear_to_eol ();\n-\n-\t      fflush (stdout);\n-\n-\t      /* Update the display text buffer. */\n-\t      strcpy (entry->text + i, printed_line + i);\n-\t      entry->textlen = pl_index;\n-\n-\t      /* Lines showing node text are not in inverse.  Only modelines\n-\t\t have that distinction. */\n-\t      entry->inverse = 0;\n-\t    }\n-\n-\t  /* We have done at least one line.  Increment our screen line\n-\t     index, and check against the bottom of the window. */\n-\t  if (++line_index == win->height)\n-\t    break;\n-\n-\t  /* A line has been displayed, and the screen reflects that state.\n-\t     If there is typeahead pending, then let that typeahead be read\n-\t     now, instead of continuing with the display. */\n-\t  if (info_any_buffered_input_p ())\n-\t    {\n-\t      free (printed_line);\n-\t      display_was_interrupted_p = 1;\n-\t      return;\n-\t    }\n-\n-\t  /* Reset PL_INDEX to the start of the line. */\n-\t  pl_index = 0;\n-\n-\t  /* If there are characters from REP left to print, stuff them\n-\t     into the buffer now. */\n-\t  if (rep_carried_over)\n-\t    for (; rep[pl_index]; pl_index++)\n-\t      printed_line[pl_index] = rep[pl_index];\n-\n-\t  /* If this window has chosen not to wrap lines, skip to the end\n-\t     of the physical line in the buffer, and start a new line here. */\n-\t  if (pl_index && (win->flags & W_NoWrap))\n-\t    {\n-\t      char *begin;\n-\n-\t      pl_index = 0;\n-\t      printed_line[0] = '\\0';\n-\n-\t      begin = nodetext;\n-\t      \n-\t      while ((nodetext < last_node_char) && (*nodetext != '\\n'))\n-\t\tnodetext++;\n-\t    }\n-\t}\n+        {\n+          DISPLAY_LINE *entry;\n+\n+          /* If this character cannot be printed in this line, we have\n+             found the end of this line as it would appear on the screen.\n+             Carefully print the end of the line, and then compare. */\n+          if (*nodetext == '\\n' || *nodetext == '\\r' || *nodetext == '\\t')\n+            {\n+              printed_line[pl_index] = '\\0';\n+              rep_carried_over = (char *)NULL;\n+            }\n+          else\n+            {\n+              /* The printed representation of this character extends into\n+                 the next line.  Remember the offset of the last character\n+                 printed out of REP so that we can carry the character over\n+                 to the next line. */\n+              for (i = 0; pl_index < (win->width - 1);)\n+                printed_line[pl_index++] = rep[i++];\n+              \n+              rep_carried_over = rep + i;\n+\n+              /* If printing the last character in this window couldn't\n+                 possibly cause the screen to scroll, place a backslash\n+                 in the rightmost column. */\n+              if (1 + line_index + win->first_row < the_screen->height)\n+                {\n+                  if (win->flags & W_NoWrap)\n+                    printed_line[pl_index++] = '$';\n+                  else\n+                    printed_line[pl_index++] = '\\\\';\n+                }\n+              printed_line[pl_index] = '\\0';\n+            }\n+\n+          /* We have the exact line as it should appear on the screen.\n+             Check to see if this line matches the one already appearing\n+             on the screen. */\n+          entry = display[line_index + win->first_row];\n+\n+          /* If the screen line is inversed, then we have to clear\n+             the line from the screen first.  Why, I don't know. */\n+          if (entry->inverse)\n+            {\n+              terminal_goto_xy (0, line_index + win->first_row);\n+              terminal_clear_to_eol ();\n+              entry->inverse = 0;\n+              entry->text[0] = '\\0';\n+              entry->textlen = 0;\n+            }\n+\n+          /* Find the offset where these lines differ. */\n+          for (i = 0; i < pl_index; i++)\n+            if (printed_line[i] != entry->text[i])\n+              break;\n+\n+          /* If the lines are not the same length, or if they differed\n+             at all, we must do some redrawing. */\n+          if ((i != pl_index) || (pl_index != entry->textlen))\n+            {\n+              /* Move to the proper point on the terminal. */\n+              terminal_goto_xy (i, line_index + win->first_row);\n+\n+              /* If there is any text to print, print it. */\n+              if (i != pl_index)\n+                terminal_put_text (printed_line + i);\n+\n+              /* If the printed text didn't extend all the way to the edge\n+                 of the window, and text was appearing between here and the\n+                 edge of the window, clear from here to the end of the line. */\n+              if ((pl_index < win->width && pl_index < entry->textlen) ||\n+                  (entry->inverse))\n+                terminal_clear_to_eol ();\n+\n+              fflush (stdout);\n+\n+              /* Update the display text buffer. */\n+              strcpy (entry->text + i, printed_line + i);\n+              entry->textlen = pl_index;\n+\n+              /* Lines showing node text are not in inverse.  Only modelines\n+                 have that distinction. */\n+              entry->inverse = 0;\n+            }\n+\n+          /* We have done at least one line.  Increment our screen line\n+             index, and check against the bottom of the window. */\n+          if (++line_index == win->height)\n+            break;\n+\n+          /* A line has been displayed, and the screen reflects that state.\n+             If there is typeahead pending, then let that typeahead be read\n+             now, instead of continuing with the display. */\n+          if (info_any_buffered_input_p ())\n+            {\n+              free (printed_line);\n+              display_was_interrupted_p = 1;\n+              return;\n+            }\n+\n+          /* Reset PL_INDEX to the start of the line. */\n+          pl_index = 0;\n+\n+          /* If there are characters from REP left to print, stuff them\n+             into the buffer now. */\n+          if (rep_carried_over)\n+            for (; rep[pl_index]; pl_index++)\n+              printed_line[pl_index] = rep[pl_index];\n+\n+          /* If this window has chosen not to wrap lines, skip to the end\n+             of the physical line in the buffer, and start a new line here. */\n+          if (pl_index && (win->flags & W_NoWrap))\n+            {\n+              char *begin;\n+\n+              pl_index = 0;\n+              printed_line[0] = '\\0';\n+\n+              begin = nodetext;\n+              \n+              while ((nodetext < last_node_char) && (*nodetext != '\\n'))\n+                nodetext++;\n+            }\n+        }\n     }\n \n  done_with_node_display:\n@@ -313,13 +308,13 @@ display_update_one_window (win)\n \n       /* If this line has text on it then make it go away. */\n       if (entry && entry->textlen)\n-\t{\n-\t  entry->textlen = 0;\n-\t  entry->text[0] = '\\0';\n+        {\n+          entry->textlen = 0;\n+          entry->text[0] = '\\0';\n \n-\t  terminal_goto_xy (0, line_index + win->first_row);\n-\t  terminal_clear_to_eol ();\n-\t}\n+          terminal_goto_xy (0, line_index + win->first_row);\n+          terminal_clear_to_eol ();\n+        }\n     }\n \n   /* Finally, if this window has a modeline it might need to be redisplayed.\n@@ -331,19 +326,19 @@ display_update_one_window (win)\n       line_index = win->first_row + win->height;\n \n       /* This display line must both be in inverse, and have the same\n-\t contents. */\n+         contents. */\n       if ((!display[line_index]->inverse) ||\n-\t  (strcmp (display[line_index]->text, win->modeline) != 0))\n-\t{\n-\t  terminal_goto_xy (0, line_index);\n-\t  terminal_begin_inverse ();\n-\t  terminal_put_text (win->modeline);\n-\t  terminal_end_inverse ();\n-\t  strcpy (display[line_index]->text, win->modeline);\n-\t  display[line_index]->inverse = 1;\n-\t  display[line_index]->textlen = strlen (win->modeline);\n-\t  fflush (stdout);\n-\t}\n+          (strcmp (display[line_index]->text, win->modeline) != 0))\n+        {\n+          terminal_goto_xy (0, line_index);\n+          terminal_begin_inverse ();\n+          terminal_put_text (win->modeline);\n+          terminal_end_inverse ();\n+          strcpy (display[line_index]->text, win->modeline);\n+          display[line_index]->inverse = 1;\n+          display[line_index]->textlen = strlen (win->modeline);\n+          fflush (stdout);\n+        }\n     }\n \n   /* Okay, this window doesn't need updating anymore. */\n@@ -387,40 +382,40 @@ display_scroll_display (start, end, amount)\n \n       /* Shift the lines to scroll right into place. */\n       for (i = 0; i < (end - start); i++)\n-\t{\n-\t  temp = the_display[last - i];\n-\t  the_display[last - i] = the_display[end - i];\n-\t  the_display[end - i] = temp;\n-\t}\n+        {\n+          temp = the_display[last - i];\n+          the_display[last - i] = the_display[end - i];\n+          the_display[end - i] = temp;\n+        }\n \n       /* The lines have been shifted down in the buffer.  Clear all of the\n-\t lines that were vacated. */\n+         lines that were vacated. */\n       for (i = start; i != (start + amount); i++)\n-\t{\n-\t  the_display[i]->text[0] = '\\0';\n-\t  the_display[i]->textlen = 0;\n-\t  the_display[i]->inverse = 0;\n-\t}\n+        {\n+          the_display[i]->text[0] = '\\0';\n+          the_display[i]->textlen = 0;\n+          the_display[i]->inverse = 0;\n+        }\n     }\n \n   if (amount < 0)\n     {\n       last = start + amount;\n       for (i = 0; i < (end - start); i++)\n-\t{\n-\t  temp = the_display[last + i];\n-\t  the_display[last + i] = the_display[start + i];\n-\t  the_display[start + i] = temp;\n-\t}\n+        {\n+          temp = the_display[last + i];\n+          the_display[last + i] = the_display[start + i];\n+          the_display[start + i] = temp;\n+        }\n \n       /* The lines have been shifted up in the buffer.  Clear all of the\n-\t lines that are left over. */\n+         lines that are left over. */\n       for (i = end + amount; i != end; i++)\n-\t{\n-\t  the_display[i]->text[0] = '\\0';\n-\t  the_display[i]->textlen = 0;\n-\t  the_display[i]->inverse = 0;\n-\t}\n+        {\n+          the_display[i]->text[0] = '\\0';\n+          the_display[i]->textlen = 0;\n+          the_display[i]->inverse = 0;\n+        }\n     }\n }\n \n@@ -434,9 +429,9 @@ display_scroll_line_starts (window, old_pagetop, old_starts, old_count)\n      int old_pagetop, old_count;\n      char **old_starts;\n {\n-  register int i, old, new;\t/* Indices into the line starts arrays. */\n-  int last_new, last_old;\t/* Index of the last visible line. */\n-  int old_first, new_first;\t/* Index of the first changed line. */\n+  register int i, old, new;     /* Indices into the line starts arrays. */\n+  int last_new, last_old;       /* Index of the last visible line. */\n+  int old_first, new_first;     /* Index of the first changed line. */\n   int unchanged_at_top = 0;\n   int already_scrolled = 0;\n \n@@ -466,39 +461,39 @@ display_scroll_line_starts (window, old_pagetop, old_starts, old_count)\n   for (old = old_first + unchanged_at_top; old < last_old; old++)\n     {\n       for (new = new_first; new < last_new; new++)\n-\tif (old_starts[old] == window->line_starts[new])\n-\t  {\n-\t    /* Find the extent of the matching lines. */\n-\t    for (i = 0; (old + i) < last_old; i++)\n-\t      if (old_starts[old + i] != window->line_starts[new + i])\n-\t\tbreak;\n-\n-\t    /* Scroll these lines if there are enough of them. */\n-\t    {\n-\t      int start, end, amount;\n-\n-\t      start = (window->first_row\n-\t\t       + ((old + already_scrolled) - old_pagetop));\n-\t      amount = new - (old + already_scrolled);\n-\t      end = window->first_row + window->height;\n-\n-\t      /* If we are shifting the block of lines down, then the last\n-\t\t AMOUNT lines will become invisible.  Thus, don't bother\n-\t\t scrolling them. */\n-\t      if (amount > 0)\n-\t\tend -= amount;\n-\n-\t      if ((end - start) > 0)\n-\t\t{\n-\t\t  display_scroll_display (start, end, amount);\n-\n-\t\t  /* Some lines have been scrolled.  Simulate the scrolling\n-\t\t     by offsetting the value of the old index. */\n-\t\t  old += i;\n-\t\t  already_scrolled += amount;\n-\t\t}\n-\t    }\n-\t  }\n+        if (old_starts[old] == window->line_starts[new])\n+          {\n+            /* Find the extent of the matching lines. */\n+            for (i = 0; (old + i) < last_old; i++)\n+              if (old_starts[old + i] != window->line_starts[new + i])\n+                break;\n+\n+            /* Scroll these lines if there are enough of them. */\n+            {\n+              int start, end, amount;\n+\n+              start = (window->first_row\n+                       + ((old + already_scrolled) - old_pagetop));\n+              amount = new - (old + already_scrolled);\n+              end = window->first_row + window->height;\n+\n+              /* If we are shifting the block of lines down, then the last\n+                 AMOUNT lines will become invisible.  Thus, don't bother\n+                 scrolling them. */\n+              if (amount > 0)\n+                end -= amount;\n+\n+              if ((end - start) > 0)\n+                {\n+                  display_scroll_display (start, end, amount);\n+\n+                  /* Some lines have been scrolled.  Simulate the scrolling\n+                     by offsetting the value of the old index. */\n+                  old += i;\n+                  already_scrolled += amount;\n+                }\n+            }\n+          }\n     }\n }\n \n@@ -512,12 +507,13 @@ display_cursor_at_point (window)\n   vpos = window_line_of_point (window) - window->pagetop + window->first_row;\n   hpos = window_get_cursor_column (window);\n   terminal_goto_xy (hpos, vpos);\n+  fflush (stdout);\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t     Functions Static to this File\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                   Functions Static to this File                  */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Make a DISPLAY_LINE ** with width and height. */\n@@ -552,7 +548,7 @@ free_display (display)\n   if (!display)\n     return;\n \n-  for (i = 0; display_line = display[i]; i++)\n+  for (i = 0; (display_line = display[i]); i++)\n     {\n       free (display_line->text);\n       free (display_line);"}, {"sha": "439813576e21c29a7acb3eaba418a18d46a5d76f", "filename": "texinfo/info/display.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdisplay.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdisplay.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fdisplay.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* display.h -- How the display in Info is done. */\n+/* display.h -- How the display in Info is done.\n+   $Id: display.h,v 1.2 1997/07/15 18:37:29 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_DISPLAY_H_)\n-#define _DISPLAY_H_\n+#ifndef INFO_DISPLAY_H\n+#define INFO_DISPLAY_H\n \n #include \"info-utils.h\"\n #include \"terminal.h\"\n@@ -73,4 +74,4 @@ extern void display_scroll_display ();\n    that appear in the OLD_STARTS array. */\n extern void display_scroll_line_starts ();\n \n-#endif /* !_DISPLAY_H_ */\n+#endif /* not INFO_DISPLAY_H */"}, {"sha": "423998e37c881d012de0ef1778d350d0bdf75319", "filename": "texinfo/info/doc.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdoc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdoc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fdoc.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -21,18 +21,10 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_DOC_H_)\n-#define _DOC_H_\n+#if !defined (DOC_H)\n+#define DOC_H\n \n-#if !defined (NULL)\n-#  define NULL 0x0\n-#endif /* !NULL */\n-\n-#if !defined (__FUNCTION_DEF)\n-#  define __FUNCTION_DEF\n-typedef int Function ();\n-typedef void VFunction ();\n-#endif /* _FUNCTION_DEF */\n+#include \"info.h\" /* for NAMED_FUNCTIONS, VFunction, etc.  */\n \n typedef struct {\n   VFunction *func;\n@@ -55,4 +47,4 @@ extern void dump_map_to_message_buffer ();\n extern char *function_name ();\n extern VFunction *named_function ();\n #endif /* NAMED_FUNCTIONS */\n-#endif /* !_DOC_H_ */\n+#endif /* !DOC_H */"}, {"sha": "d1d584865606bf09163c068bddbb9e7dcbf76026", "filename": "texinfo/info/dribble.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdribble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fdribble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fdribble.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -21,7 +21,7 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\n+#include \"info.h\"\n #include \"dribble.h\"\n \n /* When non-zero, it is a stream to write all input characters to for the"}, {"sha": "24d1d75071b2925420817ac12ddfc808feb249bf", "filename": "texinfo/info/filesys.c", "status": "modified", "additions": 137, "deletions": 171, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffilesys.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffilesys.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Ffilesys.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* filesys.c -- File system specific functions for hacking this system. */\n+/* filesys.c -- File system specific functions for hacking this system.\n+   $Id: filesys.c,v 1.4 1997/07/24 21:23:07 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,49 +19,17 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#if defined (HAVE_SYS_FILE_H)\n-#include <sys/file.h>\n-#endif /* HAVE_SYS_FILE_H */\n-#include <sys/errno.h>\n-#include \"general.h\"\n+#include \"info.h\"\n+\n #include \"tilde.h\"\n #include \"filesys.h\"\n \n-#if !defined (O_RDONLY)\n-#if defined (HAVE_SYS_FCNTL_H)\n-#include <sys/fcntl.h>\n-#else /* !HAVE_SYS_FCNTL_H */\n-#include <fcntl.h>\n-#endif /* !HAVE_SYS_FCNTL_H */\n-#endif /* !O_RDONLY */\n-\n-#if !defined (errno)\n-extern int errno;\n-#endif /* !errno */\n-\n-/* Found in info-utils.c. */\n-extern char *filename_non_directory ();\n-\n-#if !defined (BUILDING_LIBRARY)\n-/* Found in session.c */\n-extern int info_windows_initialized_p;\n-\n-/* Found in window.c. */\n-extern void message_in_echo_area (), unmessage_in_echo_area ();\n-#endif /* !BUILDING_LIBRARY */\n-\n /* Local to this file. */\n static char *info_file_in_path (), *lookup_info_filename ();\n static void remember_info_filename (), maybe_initialize_infopath ();\n \n-#if !defined (NULL)\n-#  define NULL 0x0\n-#endif /* !NULL */\n-\n-typedef struct {\n+typedef struct\n+{\n   char *suffix;\n   char *decompressor;\n } COMPRESSION_ALIST;\n@@ -114,58 +80,58 @@ info_find_fullpath (partial)\n       expansion = lookup_info_filename (partial);\n \n       if (expansion)\n-\treturn (expansion);\n+        return (expansion);\n \n       /* If we have the full path to this file, we still may have to add\n-\t various extensions to it.  I guess we have to stat this file\n-\t after all. */\n+         various extensions to it.  I guess we have to stat this file\n+         after all. */\n       if (initial_character == '/')\n-\ttemp = info_file_in_path (partial + 1, \"/\");\n+        temp = info_file_in_path (partial + 1, \"/\");\n       else if (initial_character == '~')\n-\t{\n-\t  expansion = tilde_expand_word (partial);\n-\t  if (*expansion == '/')\n-\t    {\n-\t      temp = info_file_in_path (expansion + 1, \"/\");\n-\t      free (expansion);\n-\t    }\n-\t  else\n-\t    temp = expansion;\n-\t}\n+        {\n+          expansion = tilde_expand_word (partial);\n+          if (*expansion == '/')\n+            {\n+              temp = info_file_in_path (expansion + 1, \"/\");\n+              free (expansion);\n+            }\n+          else\n+            temp = expansion;\n+        }\n       else if (initial_character == '.' &&\n-\t       (partial[1] == '/' || (partial[1] == '.' && partial[2] == '/')))\n-\t{\n-\t  if (local_temp_filename_size < 1024)\n-\t    local_temp_filename = (char *)xrealloc\n-\t      (local_temp_filename, (local_temp_filename_size = 1024));\n+               (partial[1] == '/' || (partial[1] == '.' && partial[2] == '/')))\n+        {\n+          if (local_temp_filename_size < 1024)\n+            local_temp_filename = (char *)xrealloc\n+              (local_temp_filename, (local_temp_filename_size = 1024));\n #if defined (HAVE_GETCWD)\n-\t  if (!getcwd (local_temp_filename, local_temp_filename_size))\n+          if (!getcwd (local_temp_filename, local_temp_filename_size))\n #else /*  !HAVE_GETCWD */\n-\t  if (!getwd (local_temp_filename))\n+          if (!getwd (local_temp_filename))\n #endif /* !HAVE_GETCWD */\n-\t    {\n-\t      filesys_error_number = errno;\n-\t      return (partial);\n-\t    }\n-\n-\t  strcat (local_temp_filename, \"/\");\n-\t  strcat (local_temp_filename, partial);\n-\t  return (local_temp_filename);\n-\t}\n+            {\n+              filesys_error_number = errno;\n+              return (partial);\n+            }\n+\n+          strcat (local_temp_filename, \"/\");\n+          strcat (local_temp_filename, partial);\n+          return (local_temp_filename);\n+        }\n       else\n-\ttemp = info_file_in_path (partial, infopath);\n+        temp = info_file_in_path (partial, infopath);\n \n       if (temp)\n-\t{\n-\t  remember_info_filename (partial, temp);\n-\t  if (strlen (temp) > local_temp_filename_size)\n-\t    local_temp_filename = (char *) xrealloc\n-\t      (local_temp_filename,\n-\t       (local_temp_filename_size = (50 + strlen (temp))));\n-\t  strcpy (local_temp_filename, temp);\n-\t  free (temp);\n-\t  return (local_temp_filename);\n-\t}\n+        {\n+          remember_info_filename (partial, temp);\n+          if (strlen (temp) > local_temp_filename_size)\n+            local_temp_filename = (char *) xrealloc\n+              (local_temp_filename,\n+               (local_temp_filename_size = (50 + strlen (temp))));\n+          strcpy (local_temp_filename, temp);\n+          free (temp);\n+          return (local_temp_filename);\n+        }\n     }\n   return (partial);\n }\n@@ -183,80 +149,80 @@ info_file_in_path (filename, path)\n \n   dirname_index = 0;\n \n-  while (temp_dirname = extract_colon_unit (path, &dirname_index))\n+  while ((temp_dirname = extract_colon_unit (path, &dirname_index)))\n     {\n       register int i, pre_suffix_length;\n       char *temp;\n \n       /* Expand a leading tilde if one is present. */\n       if (*temp_dirname == '~')\n-\t{\n-\t  char *expanded_dirname;\n+        {\n+          char *expanded_dirname;\n \n-\t  expanded_dirname = tilde_expand_word (temp_dirname);\n-\t  free (temp_dirname);\n-\t  temp_dirname = expanded_dirname;\n-\t}\n+          expanded_dirname = tilde_expand_word (temp_dirname);\n+          free (temp_dirname);\n+          temp_dirname = expanded_dirname;\n+        }\n \n       temp = (char *)xmalloc (30 + strlen (temp_dirname) + strlen (filename));\n       strcpy (temp, temp_dirname);\n       if (temp[(strlen (temp)) - 1] != '/')\n-\tstrcat (temp, \"/\");\n+        strcat (temp, \"/\");\n       strcat (temp, filename);\n \n       pre_suffix_length = strlen (temp);\n \n       free (temp_dirname);\n \n       for (i = 0; info_suffixes[i]; i++)\n-\t{\n-\t  strcpy (temp + pre_suffix_length, info_suffixes[i]);\n-\n-\t  statable = (stat (temp, &finfo) == 0);\n-\n-\t  /* If we have found a regular file, then use that.  Else, if we\n-\t     have found a directory, look in that directory for this file. */\n-\t  if (statable)\n-\t    {\n-\t      if (S_ISREG (finfo.st_mode))\n-\t\t{\n-\t\t  return (temp);\n-\t\t}\n-\t      else if (S_ISDIR (finfo.st_mode))\n-\t\t{\n-\t\t  char *newpath, *filename_only, *newtemp;\n-\n-\t\t  newpath = strdup (temp);\n-\t\t  filename_only = filename_non_directory (filename);\n-\t\t  newtemp = info_file_in_path (filename_only, newpath);\n-\n-\t\t  free (newpath);\n-\t\t  if (newtemp)\n-\t\t    {\n-\t\t      free (temp);\n-\t\t      return (newtemp);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Add various compression suffixes to the name to see if\n-\t\t the file is present in compressed format. */\n-\t      register int j, pre_compress_suffix_length;\n-\n-\t      pre_compress_suffix_length = strlen (temp);\n-\n-\t      for (j = 0; compress_suffixes[j].suffix; j++)\n-\t\t{\n-\t\t  strcpy (temp + pre_compress_suffix_length,\n-\t\t\t  compress_suffixes[j].suffix);\n-\n-\t\t  statable = (stat (temp, &finfo) == 0);\n-\t\t  if (statable && (S_ISREG (finfo.st_mode)))\n-\t\t    return (temp);\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          strcpy (temp + pre_suffix_length, info_suffixes[i]);\n+\n+          statable = (stat (temp, &finfo) == 0);\n+\n+          /* If we have found a regular file, then use that.  Else, if we\n+             have found a directory, look in that directory for this file. */\n+          if (statable)\n+            {\n+              if (S_ISREG (finfo.st_mode))\n+                {\n+                  return (temp);\n+                }\n+              else if (S_ISDIR (finfo.st_mode))\n+                {\n+                  char *newpath, *filename_only, *newtemp;\n+\n+                  newpath = xstrdup (temp);\n+                  filename_only = filename_non_directory (filename);\n+                  newtemp = info_file_in_path (filename_only, newpath);\n+\n+                  free (newpath);\n+                  if (newtemp)\n+                    {\n+                      free (temp);\n+                      return (newtemp);\n+                    }\n+                }\n+            }\n+          else\n+            {\n+              /* Add various compression suffixes to the name to see if\n+                 the file is present in compressed format. */\n+              register int j, pre_compress_suffix_length;\n+\n+              pre_compress_suffix_length = strlen (temp);\n+\n+              for (j = 0; compress_suffixes[j].suffix; j++)\n+                {\n+                  strcpy (temp + pre_compress_suffix_length,\n+                          compress_suffixes[j].suffix);\n+\n+                  statable = (stat (temp, &finfo) == 0);\n+                  if (statable && (S_ISREG (finfo.st_mode)))\n+                    return (temp);\n+                }\n+            }\n+        }\n       free (temp);\n     }\n   return ((char *)NULL);\n@@ -290,7 +256,7 @@ extract_colon_unit (string, idx)\n       strncpy (value, &string[start], (i - start));\n       value[i - start] = '\\0';\n       if (string[i])\n-\t++i;\n+        ++i;\n       *idx = i;\n       return (value);\n     }\n@@ -317,10 +283,10 @@ lookup_info_filename (filename)\n     {\n       register int i;\n       for (i = 0; names_and_files[i]; i++)\n-\t{\n-\t  if (strcmp (names_and_files[i]->filename, filename) == 0)\n-\t    return (names_and_files[i]->expansion);\n-\t}\n+        {\n+          if (strcmp (names_and_files[i]->filename, filename) == 0)\n+            return (names_and_files[i]->expansion);\n+        }\n     }\n   return (char *)NULL;;\n }\n@@ -340,12 +306,12 @@ remember_info_filename (filename, expansion)\n       alloc_size = names_and_files_slots * sizeof (FILENAME_LIST *);\n \n       names_and_files =\n-\t(FILENAME_LIST **) xrealloc (names_and_files, alloc_size);\n+        (FILENAME_LIST **) xrealloc (names_and_files, alloc_size);\n     }\n \n   new = (FILENAME_LIST *)xmalloc (sizeof (FILENAME_LIST));\n-  new->filename = strdup (filename);\n-  new->expansion = expansion ? strdup (expansion) : (char *)NULL;\n+  new->filename = xstrdup (filename);\n+  new->expansion = expansion ? xstrdup (expansion) : (char *)NULL;\n \n   names_and_files[names_and_files_index++] = new;\n   names_and_files[names_and_files_index] = (FILENAME_LIST *)NULL;\n@@ -357,7 +323,7 @@ maybe_initialize_infopath ()\n   if (!infopath_size)\n     {\n       infopath = (char *)\n-\txmalloc (infopath_size = (1 + strlen (DEFAULT_INFOPATH)));\n+        xmalloc (infopath_size = (1 + strlen (DEFAULT_INFOPATH)));\n \n       strcpy (infopath, DEFAULT_INFOPATH);\n     }\n@@ -392,7 +358,7 @@ info_add_path (path, where)\n     }\n   else if (where == INFOPATH_PREPEND)\n     {\n-      char *temp = strdup (infopath);\n+      char *temp = xstrdup (infopath);\n       strcpy (infopath, path);\n       strcat (infopath, \":\");\n       strcat (infopath, temp);\n@@ -436,21 +402,21 @@ filesys_read_info_file (pathname, filesize, finfo)\n \n       /* If the file couldn't be opened, give up. */\n       if (descriptor < 0)\n-\t{\n-\t  filesys_error_number = errno;\n-\t  return ((char *)NULL);\n-\t}\n+        {\n+          filesys_error_number = errno;\n+          return ((char *)NULL);\n+        }\n \n       /* Try to read the contents of this file. */\n       st_size = (long) finfo->st_size;\n       contents = (char *)xmalloc (1 + st_size);\n       if ((read (descriptor, contents, st_size)) != st_size)\n-\t{\n-\t  filesys_error_number = errno;\n-\t  close (descriptor);\n-\t  free (contents);\n-\t  return ((char *)NULL);\n-\t}\n+        {\n+          filesys_error_number = errno;\n+          close (descriptor);\n+          free (contents);\n+          return ((char *)NULL);\n+        }\n \n       close (descriptor);\n \n@@ -510,20 +476,20 @@ filesys_read_compressed (pathname, filesize, finfo)\n       chunk = (char *)xmalloc (FILESYS_PIPE_BUFFER_SIZE);\n \n       while (1)\n-\t{\n-\t  int bytes_read;\n+        {\n+          int bytes_read;\n \n-\t  bytes_read = fread (chunk, 1, FILESYS_PIPE_BUFFER_SIZE, stream);\n+          bytes_read = fread (chunk, 1, FILESYS_PIPE_BUFFER_SIZE, stream);\n \n-\t  if (bytes_read + offset >= size)\n-\t    contents = (char *)xrealloc\n-\t      (contents, size += (2 * FILESYS_PIPE_BUFFER_SIZE));\n+          if (bytes_read + offset >= size)\n+            contents = (char *)xrealloc\n+              (contents, size += (2 * FILESYS_PIPE_BUFFER_SIZE));\n \n-\t  memcpy (contents + offset, chunk, bytes_read);\n-\t  offset += bytes_read;\n-\t  if (bytes_read != FILESYS_PIPE_BUFFER_SIZE)\n-\t    break;\n-\t}\n+          memcpy (contents + offset, chunk, bytes_read);\n+          offset += bytes_read;\n+          if (bytes_read != FILESYS_PIPE_BUFFER_SIZE)\n+            break;\n+        }\n \n       free (chunk);\n       pclose (stream);\n@@ -572,8 +538,8 @@ filesys_decompressor_for_file (filename)\n   for (i = strlen (filename) - 1; i > 0; i--)\n     if (filename[i] == '.')\n       {\n-\textension = filename + i;\n-\tbreak;\n+        extension = filename + i;\n+        break;\n       }\n \n   if (!extension)"}, {"sha": "440eb9b281b56461a337797b9fb44ec8bd0d72c7", "filename": "texinfo/info/filesys.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffilesys.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffilesys.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Ffilesys.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* filesys.h -- External declarations of functions and vars in filesys.c. */\n+/* filesys.h -- External declarations of functions and vars in filesys.c.\n+   $Id: filesys.h,v 1.3 1997/07/15 18:39:08 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_FILESYS_H_)\n-#define _FILESYS_H_\n+#ifndef INFO_FILESYS_H\n+#define INFO_FILESYS_H\n \n /* The path on which we look for info files.  You can initialize this\n    from the environment variable INFOPATH if there is one, or you can\n@@ -70,7 +71,7 @@ extern char *extract_colon_unit ();\n \n /* The default value of INFOPATH. */\n #if !defined (DEFAULT_INFOPATH)\n-! #  define DEFAULT_INFOPATH \"/usr/local/info:/usr/info:/usr/local/lib/info:/usr/lib/info:/usr/local/gnu/info:/usr/local/gnu/lib/info:/usr/gnu/info:/usr/gnu/lib/info:/opt/gnu/info:/usr/share/info:/usr/share/lib/info:/usr/local/share/info:/usr/local/share/lib/info:/usr/gnu/lib/emacs/info:/usr/local/gnu/lib/emacs/info:/usr/local/lib/emacs/info:/usr/local/emacs/info:.\"\n+#  define DEFAULT_INFOPATH \"/usr/local/info:/usr/info:/usr/local/lib/info:/usr/lib/info:/usr/local/gnu/info:/usr/local/gnu/lib/info:/usr/gnu/info:/usr/gnu/lib/info:/opt/gnu/info:/usr/share/info:/usr/share/lib/info:/usr/local/share/info:/usr/local/share/lib/info:/usr/gnu/lib/emacs/info:/usr/local/gnu/lib/emacs/info:/usr/local/lib/emacs/info:/usr/local/emacs/info:.\"\n #endif /* !DEFAULT_INFOPATH */\n \n #if !defined (S_ISREG) && defined (S_IFREG)\n@@ -81,4 +82,4 @@ extern char *extract_colon_unit ();\n #  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n #endif /* !S_ISDIR && S_IFDIR */\n \n-#endif /* !_FILESYS_H_ */\n+#endif /* not INFO_FILESYS_H */"}, {"sha": "b6467431b64eaccc80df64f6020f69a6712adabe", "filename": "texinfo/info/footnotes.c", "status": "modified", "additions": 55, "deletions": 59, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffootnotes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffootnotes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Ffootnotes.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* footnotes.c -- Some functions for manipulating footnotes. */\n+/* footnotes.c -- Some functions for manipulating footnotes.\n+   $Id: footnotes.c,v 1.4 1997/07/24 21:23:33 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -40,7 +38,7 @@ find_footnotes_window ()\n   /* Try to find an existing window first. */\n   for (win = windows; win; win = win->next)\n     if (internal_info_node_p (win->node) &&\n-\t(strcmp (win->node->nodename, footnote_nodename) == 0))\n+        (strcmp (win->node->nodename, footnote_nodename) == 0))\n       break;\n \n   return (win);\n@@ -72,37 +70,37 @@ make_footnotes_node (node)\n       refs = info_xrefs_of_node (node);\n \n       if (refs)\n-\t{\n-\t  register int i;\n-\t  char *refname;\n+        {\n+          register int i;\n+          char *refname;\n \n-\t  refname = (char *)xmalloc\n-\t    (1 + strlen (\"-Footnotes\") + strlen (node->nodename));\n+          refname = (char *)xmalloc\n+            (1 + strlen (\"-Footnotes\") + strlen (node->nodename));\n \n-\t  strcpy (refname, node->nodename);\n-\t  strcat (refname, \"-Footnotes\");\n+          strcpy (refname, node->nodename);\n+          strcat (refname, \"-Footnotes\");\n \n-\t  for (i = 0; refs[i]; i++)\n-\t    if ((refs[i]->nodename != (char *)NULL) &&\n-\t\t(strcmp (refs[i]->nodename, refname) == 0))\n-\t      {\n-\t\tchar *filename;\n+          for (i = 0; refs[i]; i++)\n+            if ((refs[i]->nodename != (char *)NULL) &&\n+                (strcmp (refs[i]->nodename, refname) == 0))\n+              {\n+                char *filename;\n \n-\t\tfilename = node->parent;\n-\t\tif (!filename)\n-\t\t  filename = node->filename;\n+                filename = node->parent;\n+                if (!filename)\n+                  filename = node->filename;\n \n-\t\tfn_node = info_get_node (filename, refname);\n+                fn_node = info_get_node (filename, refname);\n \n-\t\tif (fn_node)\n-\t\t  fn_start = 0;\n+                if (fn_node)\n+                  fn_start = 0;\n \n-\t\tbreak;\n-\t      }\n+                break;\n+              }\n \n-\t  free (refname);\n-\t  info_free_references (refs);\n-\t}\n+          free (refname);\n+          info_free_references (refs);\n+        }\n     }\n \n   /* If we never found the start of a footnotes area, quit now. */\n@@ -126,15 +124,15 @@ make_footnotes_node (node)\n        This effectively skips either \"---- footno...\", or \"File: foo...\". */\n     while (text_start < fn_node->nodelen)\n       if (fn_node->contents[text_start++] == '\\n')\n-\tbreak;\n+        break;\n   \n     result->nodelen = strlen (header) + fn_node->nodelen - text_start;\n \n     /* Set the contents of this node. */\n     result->contents = (char *)xmalloc (1 + result->nodelen);\n     sprintf (result->contents, \"%s\", header);\n     memcpy (result->contents + strlen (header),\n-\t    fn_node->contents + text_start, fn_node->nodelen - text_start);\n+            fn_node->contents + text_start, fn_node->nodelen - text_start);\n \n     name_internal_node (result, footnote_nodename);\n     free (header);\n@@ -176,7 +174,7 @@ info_get_or_remove_footnotes (window)\n   if (fn_win && !new_footnotes)\n     {\n       if (windows->next)\n-\tinfo_delete_window_internal (fn_win);\n+        info_delete_window_internal (fn_win);\n     }\n \n   /* If there are footnotes for this window's node, but no window around\n@@ -187,27 +185,27 @@ info_get_or_remove_footnotes (window)\n       WINDOW *last, *win;\n \n       /* Always make this window be the last one appearing in the list.  Find\n-\t the last window in the chain. */\n+         the last window in the chain. */\n       for (win = windows, last = windows; win; last = win, win = win->next);\n \n       /* Try to split this window, and make the split window the one to\n-\t contain the footnotes. */\n+         contain the footnotes. */\n       old_active = active_window;\n       active_window = last;\n       fn_win = window_make_window (new_footnotes);\n       active_window = old_active;\n \n       if (!fn_win)\n-\t{\n-\t  free (new_footnotes->contents);\n-\t  free (new_footnotes);\n-\n-\t  /* If we are hacking automatic footnotes, and there are footnotes\n-\t     but we couldn't display them, print a message to that effect. */\n-\t  if (auto_footnotes_p)\n-\t    inform_in_echo_area (\"Footnotes could not be displayed\");\n-\t  return (FN_UNABLE);\n-\t}\n+        {\n+          free (new_footnotes->contents);\n+          free (new_footnotes);\n+\n+          /* If we are hacking automatic footnotes, and there are footnotes\n+             but we couldn't display them, print a message to that effect. */\n+          if (auto_footnotes_p)\n+            inform_in_echo_area (_(\"Footnotes could not be displayed\"));\n+          return (FN_UNABLE);\n+        }\n     }\n \n   /* If there are footnotes, and there is a window to display them,\n@@ -217,7 +215,7 @@ info_get_or_remove_footnotes (window)\n       window_set_node_of_window (fn_win, new_footnotes);\n \n       window_change_window_height\n-\t(fn_win, fn_win->line_count - fn_win->height);\n+        (fn_win, fn_win->line_count - fn_win->height);\n \n       remember_window_and_node (fn_win, new_footnotes);\n       add_gcable_pointer (new_footnotes->contents);\n@@ -231,19 +229,17 @@ info_get_or_remove_footnotes (window)\n \n /* Show the footnotes associated with this node in another window. */\n DECLARE_INFO_COMMAND (info_show_footnotes,\n-   \"Show the footnotes associated with this node in another window\")\n+   _(\"Show the footnotes associated with this node in another window\"))\n {\n-  int result;\n-\n   /* A negative argument means just make the window go away. */\n   if (count < 0)\n     {\n       WINDOW *fn_win = find_footnotes_window ();\n \n       /* If there is an old footnotes window, and it isn't the only window\n-\t on the screen, delete it. */\n+         on the screen, delete it. */\n       if (fn_win && windows->next)\n-\tinfo_delete_window_internal (fn_win);\n+        info_delete_window_internal (fn_win);\n     }\n   else\n     {\n@@ -252,14 +248,14 @@ DECLARE_INFO_COMMAND (info_show_footnotes,\n       result = info_get_or_remove_footnotes (window);\n \n       switch (result)\n-\t{\n-\tcase FN_UNFOUND:\n-\t  info_error (NO_FOOT_NODE);\n-\t  break;\n-\n-\tcase FN_UNABLE:\n-\t  info_error (WIN_TOO_SMALL);\n-\t  break;\n-\t}\n+        {\n+        case FN_UNFOUND:\n+          info_error (NO_FOOT_NODE);\n+          break;\n+\n+        case FN_UNABLE:\n+          info_error (WIN_TOO_SMALL);\n+          break;\n+        }\n     }\n }"}, {"sha": "3406bcb67be13e987e8c2a63cb7e7eeb1fd7d53d", "filename": "texinfo/info/footnotes.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffootnotes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ffootnotes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Ffootnotes.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* footnotes.h -- Some functions for manipulating footnotes. */\n+/* footnotes.h -- Some functions for manipulating footnotes.\n+   $Id: footnotes.h,v 1.3 1997/07/15 18:40:27 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,11 +22,11 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_FOOTNOTES_H_)\n-#define _FOOTNOTES_H_\n+#ifndef INFO_FOOTNOTES_H\n+#define INFO_FOOTNOTES_H\n \n /* Magic string which indicates following text is footnotes. */\n-#define FOOTNOTE_LABEL \"---------- Footnotes ----------\"\n+#define FOOTNOTE_LABEL _(\"---------- Footnotes ----------\")\n \n #define FN_FOUND   0\n #define FN_UNFOUND 1\n@@ -42,5 +43,4 @@ extern int info_get_or_remove_footnotes ();\n /* Non-zero means attempt to show footnotes when displaying a new window. */\n extern int auto_footnotes_p;\n \n-#endif /* !_FOOTNOTES_H_ */\n-\n+#endif /* not INFO_FOOTNOTES_H */"}, {"sha": "1c868ba3284f5bbc7e1229f26cce2e0b96ea1398", "filename": "texinfo/info/gc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fgc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fgc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fgc.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -56,7 +56,7 @@ gc_pointers ()\n   if (!info_windows || !gcable_pointers_index)\n     return;\n \n-  for (i = 0; iw = info_windows[i]; i++)\n+  for (i = 0; (iw = info_windows[i]); i++)\n     {\n       for (j = 0; j < iw->nodes_index; j++)\n \t{"}, {"sha": "b4d993af4f8c65c8ec13e39fef563a7c8f4875c1", "filename": "texinfo/info/gc.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fgc.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* gc.h -- Functions for garbage collecting unused node contents. */\n+/* gc.h -- Functions for garbage collecting unused node contents.\n+   $Id: gc.h,v 1.2 1997/07/15 18:41:53 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_GC_H_)\n-#define _GC_H_\n+#ifndef INFO_GC_H\n+#define INFO_GC_H\n \n /* Add POINTER to the list of garbage collectible pointers.  A pointer\n    is not actually garbage collected until no info window contains a node\n@@ -33,4 +34,4 @@ extern void add_gcable_pointer ();\n    node->contents which are collectible, and free them. */\n extern void gc_pointers ();\n \n-#endif /* !_GC_H_ */\n+#endif /* not INFO_GC_H */"}, {"sha": "37e9b037762b33b1112947919333eac359211cbd", "filename": "texinfo/info/indices.c", "status": "modified", "additions": 291, "deletions": 231, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Findices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Findices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Findices.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* indices.c -- Commands for dealing with an Info file Index. */\n+/* indices.c -- Commands for dealing with an Info file Index.\n+   $Id: indices.c,v 1.6 1997/07/24 21:25:53 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -43,9 +41,9 @@ static char *initial_index_nodename = (char *)NULL;\n \n /* A structure associating index names with index offset ranges. */\n typedef struct {\n-  char *name;\t\t\t/* The nodename of this index. */\n-  int first;\t\t\t/* The index in our list of the first entry. */\n-  int last;\t\t\t/* The index in our list of the last entry. */\n+  char *name;                   /* The nodename of this index. */\n+  int first;                    /* The index in our list of the first entry. */\n+  int last;                     /* The index in our list of the last entry. */\n } INDEX_NAME_ASSOC;\n \n /* An array associating index nodenames with index offset ranges. */\n@@ -65,7 +63,7 @@ add_index_to_index_nodenames (array, node)\n \n   for (last = 0; array[last]; last++);\n   assoc = (INDEX_NAME_ASSOC *)xmalloc (sizeof (INDEX_NAME_ASSOC));\n-  assoc->name = strdup (node->nodename);\n+  assoc->name = xstrdup (node->nodename);\n \n   if (!index_nodenames_index)\n     {\n@@ -119,10 +117,10 @@ info_indices_of_file_buffer (file_buffer)\n   if (index_nodenames)\n     {\n       for (i = 0; index_nodenames[i]; i++)\n-\t{\n-\t  free (index_nodenames[i]->name);\n-\t  free (index_nodenames[i]);\n-\t}\n+        {\n+          free (index_nodenames[i]->name);\n+          free (index_nodenames[i]);\n+        }\n \n       index_nodenames_index = 0;\n       index_nodenames[0] = (INDEX_NAME_ASSOC *)NULL;\n@@ -133,48 +131,59 @@ info_indices_of_file_buffer (file_buffer)\n     {\n       TAG *tag;\n \n-      for (i = 0; tag = file_buffer->tags[i]; i++)\n-\t{\n-\t  if (string_in_line (\"Index\", tag->nodename) != -1)\n-\t    {\n-\t      NODE *node;\n-\t      REFERENCE **menu;\n-\n-\t      /* Found one.  Get its menu. */\n-\t      node = info_get_node (tag->filename, tag->nodename);\n-\t      if (!node)\n-\t\tcontinue;\n-\n-\t      /* Remember the filename and nodename of this index. */\n-\t      initial_index_filename = strdup (file_buffer->filename);\n-\t      initial_index_nodename = strdup (tag->nodename);\n-\n-\t      menu = info_menu_of_node (node);\n-\n-\t      /* If we have a menu, add this index's nodename and range\n-\t\t to our list of index_nodenames. */\n-\t      if (menu)\n-\t\t{\n-\t\t  add_index_to_index_nodenames (menu, node);\n-\n-\t\t  /* Concatenate the references found so far. */\n-\t\t  result = info_concatenate_references (result, menu);\n-\t\t}\n-\t      free (node);\n-\t    }\n-\t}\n+      for (i = 0; (tag = file_buffer->tags[i]); i++)\n+        {\n+          if (string_in_line (\"Index\", tag->nodename) != -1)\n+            {\n+              NODE *node;\n+              REFERENCE **menu;\n+\n+              /* Found one.  Get its menu. */\n+              node = info_get_node (tag->filename, tag->nodename);\n+              if (!node)\n+                continue;\n+\n+              /* Remember the filename and nodename of this index. */\n+              initial_index_filename = xstrdup (file_buffer->filename);\n+              initial_index_nodename = xstrdup (tag->nodename);\n+\n+              menu = info_menu_of_node (node);\n+\n+              /* If we have a menu, add this index's nodename and range\n+                 to our list of index_nodenames. */\n+              if (menu)\n+                {\n+                  add_index_to_index_nodenames (menu, node);\n+\n+                  /* Concatenate the references found so far. */\n+                  result = info_concatenate_references (result, menu);\n+                }\n+              free (node);\n+            }\n+        }\n     }\n \n   /* If there is a result, clean it up so that every entry has a filename. */\n   for (i = 0; result && result[i]; i++)\n     if (!result[i]->filename)\n-      result[i]->filename = strdup (file_buffer->filename);\n+      result[i]->filename = xstrdup (file_buffer->filename);\n \n   return (result);\n }\n \n DECLARE_INFO_COMMAND (info_index_search,\n-   \"Look up a string in the index for this file\")\n+   _(\"Look up a string in the index for this file\"))\n+{\n+  do_info_index_search (window, count, 0);\n+}\n+\n+/* Look up SEARCH_STRING in the index for this file.  If SEARCH_STRING\n+   is NULL, prompt user for input.  */ \n+void\n+do_info_index_search (window, count, search_string)\n+     WINDOW *window;\n+     int count;\n+     char *search_string;\n {\n   FILE_BUFFER *fb;\n   char *line;\n@@ -193,47 +202,52 @@ DECLARE_INFO_COMMAND (info_index_search,\n       (strcmp (initial_index_filename, fb->filename) != 0))\n     {\n       info_free_references (index_index);\n-      window_message_in_echo_area (\"Finding index entries...\");\n+      window_message_in_echo_area (_(\"Finding index entries...\"));\n       index_index = info_indices_of_file_buffer (fb);\n     }\n \n   /* If there is no index, quit now. */\n   if (!index_index)\n     {\n-      info_error (\"No indices found.\");\n-      return;\n-    }\n-\n-  /* Okay, there is an index.  Let the user select one of the members of it. */\n-  line =\n-    info_read_maybe_completing (window, \"Index entry: \", index_index);\n-\n-  window = active_window;\n-\n-  /* User aborted? */\n-  if (!line)\n-    {\n-      info_abort_key (active_window, 1, 0);\n+      info_error (_(\"No indices found.\"));\n       return;\n     }\n \n-  /* Empty line means move to the Index node. */\n-  if (!*line)\n+  /* Okay, there is an index.  Look for SEARCH_STRING, or, if it is\n+     empty, prompt for one.  */\n+  if (search_string && *search_string)\n+    line = xstrdup (search_string);\n+  else\n     {\n-      free (line);\n-\n-      if (initial_index_filename && initial_index_nodename)\n-\t{\n-\t  NODE *node;\n-\n-\t  node =\n-\t    info_get_node (initial_index_filename, initial_index_nodename);\n-\t  set_remembered_pagetop_and_point (window);\n-\t  window_set_node_of_window (window, node);\n-\t  remember_window_and_node (window, node);\n-\t  window_clear_echo_area ();\n-\t  return;\n-\t}\n+      line = info_read_maybe_completing (window, _(\"Index entry: \"),\n+                                         index_index);\n+      window = active_window;\n+\n+      /* User aborted? */\n+      if (!line)\n+        {\n+          info_abort_key (active_window, 1, 0);\n+          return;\n+        }\n+\n+      /* Empty line means move to the Index node. */\n+      if (!*line)\n+        {\n+          free (line);\n+\n+          if (initial_index_filename && initial_index_nodename)\n+            {\n+              NODE *node;\n+\n+              node = info_get_node (initial_index_filename,\n+                                    initial_index_nodename);\n+              set_remembered_pagetop_and_point (window);\n+              window_set_node_of_window (window, node);\n+              remember_window_and_node (window, node);\n+              window_clear_echo_area ();\n+              return;\n+            }\n+        }\n     }\n \n   /* The user typed either a completed index label, or a partial string.\n@@ -246,9 +260,9 @@ DECLARE_INFO_COMMAND (info_index_search,\n     /* Start the search right after/before this index. */\n     if (count < 0)\n       {\n-\tregister int i;\n-\tfor (i = 0; index_index[i]; i++);\n-\tindex_offset = i;\n+        register int i;\n+        for (i = 0; index_index[i]; i++);\n+        index_offset = i;\n       }\n     else\n       index_offset = -1;\n@@ -267,8 +281,55 @@ DECLARE_INFO_COMMAND (info_index_search,\n   }\n }\n \n+int\n+index_entry_exists (window, string)\n+     WINDOW *window;\n+     char *string;\n+{\n+  register int i;\n+  FILE_BUFFER *fb;\n+\n+  /* If there is no previous search string, the user hasn't built an index\n+     yet. */\n+  if (!string)\n+    return 0;\n+\n+  fb = file_buffer_of_window (window);\n+  if (!initial_index_filename\n+      || (strcmp (initial_index_filename, fb->filename) != 0))\n+    {\n+      info_free_references (index_index);\n+      index_index = info_indices_of_file_buffer (fb);\n+    }\n+\n+  /* If there is no index, that is an error. */\n+  if (!index_index)\n+    return 0;\n+\n+  for (i = 0; (i > -1) && (index_index[i]); i++)\n+    if (strcmp (string, index_index[i]->label) == 0)\n+      break;\n+\n+  /* If that failed, look for the next substring match. */\n+  if ((i < 0) || (!index_index[i]))\n+    {\n+      for (i = 0; (i > -1) && (index_index[i]); i++)\n+        if (string_in_line (string, index_index[i]->label) != -1)\n+          break;\n+\n+      if ((i > -1) && (index_index[i]))\n+        string_in_line (string, index_index[i]->label);\n+    }\n+\n+  /* If that failed, return 0. */\n+  if ((i < 0) || (!index_index[i]))\n+    return 0;\n+\n+  return 1;\n+}\n+\n DECLARE_INFO_COMMAND (info_next_index_match,\n- \"Go to the next matching index item from the last `\\\\[index-search]' command\")\n+ _(\"Go to the next matching index item from the last `\\\\[index-search]' command\"))\n {\n   register int i;\n   int partial, dir;\n@@ -278,14 +339,14 @@ DECLARE_INFO_COMMAND (info_next_index_match,\n      yet. */\n   if (!index_search)\n     {\n-      info_error (\"No previous index search string.\");\n+      info_error (_(\"No previous index search string.\"));\n       return;\n     }\n \n   /* If there is no index, that is an error. */\n   if (!index_index)\n     {\n-      info_error (\"No index entries.\");\n+      info_error (_(\"No index entries.\"));\n       return;\n     }\n \n@@ -308,18 +369,18 @@ DECLARE_INFO_COMMAND (info_next_index_match,\n   if ((i < 0) || (!index_index[i]))\n     {\n       for (i = index_offset + dir; (i > -1) && (index_index[i]); i += dir)\n-\tif (string_in_line (index_search, index_index[i]->label) != -1)\n-\t  break;\n+        if (string_in_line (index_search, index_index[i]->label) != -1)\n+          break;\n \n       if ((i > -1) && (index_index[i]))\n-\tpartial = string_in_line (index_search, index_index[i]->label);\n+        partial = string_in_line (index_search, index_index[i]->label);\n     }\n \n   /* If that failed, print an error. */\n   if ((i < 0) || (!index_index[i]))\n     {\n-      info_error (\"No %sindex entries containing \\\"%s\\\".\",\n-\t\t  index_offset > 0 ? \"more \" : \"\", index_search);\n+      info_error (_(\"No %sindex entries containing \\\"%s\\\".\"),\n+                  index_offset > 0 ? _(\"more \") : \"\", index_search);\n       return;\n     }\n \n@@ -329,43 +390,43 @@ DECLARE_INFO_COMMAND (info_next_index_match,\n   /* Report to the user on what we have found. */\n   {\n     register int j;\n-    char *name = \"CAN'T SEE THIS\";\n+    char *name = _(\"CAN'T SEE THIS\");\n     char *match;\n \n     for (j = 0; index_nodenames[j]; j++)\n       {\n-\tif ((i >= index_nodenames[j]->first) &&\n-\t    (i <= index_nodenames[j]->last))\n-\t  {\n-\t    name = index_nodenames[j]->name;\n-\t    break;\n-\t  }\n+        if ((i >= index_nodenames[j]->first) &&\n+            (i <= index_nodenames[j]->last))\n+          {\n+            name = index_nodenames[j]->name;\n+            break;\n+          }\n       }\n \n     /* If we had a partial match, indicate to the user which part of the\n        string matched. */\n-    match = strdup (index_index[i]->label);\n+    match = xstrdup (index_index[i]->label);\n \n     if (partial && show_index_match)\n       {\n-\tint j, ls, start, upper;\n+        int j, ls, start, upper;\n \n-\tls = strlen (index_search);\n-\tstart = partial - ls;\n-\tupper = isupper (match[start]) ? 1 : 0;\n+        ls = strlen (index_search);\n+        start = partial - ls;\n+        upper = isupper (match[start]) ? 1 : 0;\n \n-\tfor (j = 0; j < ls; j++)\n-\t  if (upper)\n-\t    match[j + start] = info_tolower (match[j + start]);\n-\t  else\n-\t    match[j + start] = info_toupper (match[j + start]);\n+        for (j = 0; j < ls; j++)\n+          if (upper)\n+            match[j + start] = info_tolower (match[j + start]);\n+          else\n+            match[j + start] = info_toupper (match[j + start]);\n       }\n \n     {\n       char *format;\n \n       format = replace_in_documentation\n-\t(\"Found \\\"%s\\\" in %s. (`\\\\[next-index-match]' tries to find next.)\");\n+        (_(\"Found \\\"%s\\\" in %s. (`\\\\[next-index-match]' tries to find next.)\"));\n \n       window_message_in_echo_area (format, match, name);\n     }\n@@ -379,7 +440,7 @@ DECLARE_INFO_COMMAND (info_next_index_match,\n   if (!node)\n     {\n       info_error (CANT_FILE_NODE,\n-\t\t  index_index[i]->filename, index_index[i]->nodename);\n+                  index_index[i]->filename, index_index[i]->nodename);\n       return;\n     }\n \n@@ -397,16 +458,16 @@ DECLARE_INFO_COMMAND (info_next_index_match,\n \n     if (loc != -1)\n       {\n-\twindow->point = loc;\n-\twindow_adjust_pagetop (window);\n+        window->point = loc;\n+        window_adjust_pagetop (window);\n       }\n   }\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t   Info APROPOS: Search every known index.\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                 Info APROPOS: Search every known index.          */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* For every menu item in DIR, search the indices of that file for\n@@ -420,14 +481,13 @@ apropos_in_all_indices (search_string, inform)\n   REFERENCE **all_indices = (REFERENCE **)NULL;\n   REFERENCE **dir_menu = (REFERENCE **)NULL;\n   NODE *dir_node;\n-  int printed = 0;\n \n   dir_node = info_get_node (\"dir\", \"Top\");\n   if (dir_node)\n     dir_menu = info_menu_of_node (dir_node);\n \n   if (!dir_menu)\n-    return;\n+    return NULL;\n \n   /* For every menu item in DIR, get the associated node's file buffer and\n      read the indices of that file buffer.  Gather all of the indices into\n@@ -441,54 +501,54 @@ apropos_in_all_indices (search_string, inform)\n       this_item = dir_menu[dir_index];\n \n       if (!this_item->filename)\n-\t{\n-\t  if (dir_node->parent)\n-\t    this_item->filename = strdup (dir_node->parent);\n-\t  else\n-\t    this_item->filename = strdup (dir_node->filename);\n-\t}\n+        {\n+          if (dir_node->parent)\n+            this_item->filename = xstrdup (dir_node->parent);\n+          else\n+            this_item->filename = xstrdup (dir_node->filename);\n+        }\n \n       /* Find this node.  If we cannot find it, try using the label of the\n-\t entry as a file (i.e., \"(LABEL)Top\"). */\n+         entry as a file (i.e., \"(LABEL)Top\"). */\n       this_node = info_get_node (this_item->filename, this_item->nodename);\n \n       if (!this_node && this_item->nodename &&\n-\t  (strcmp (this_item->label, this_item->nodename) == 0))\n-\tthis_node = info_get_node (this_item->label, \"Top\");\n+          (strcmp (this_item->label, this_item->nodename) == 0))\n+        this_node = info_get_node (this_item->label, \"Top\");\n \n       if (!this_node)\n-\tcontinue;\n+        continue;\n \n       /* Get the file buffer associated with this node. */\n       {\n-\tchar *files_name;\n+        char *files_name;\n \n-\tfiles_name = this_node->parent;\n-\tif (!files_name)\n-\t  files_name = this_node->filename;\n+        files_name = this_node->parent;\n+        if (!files_name)\n+          files_name = this_node->filename;\n \n-\tthis_fb = info_find_file (files_name);\n+        this_fb = info_find_file (files_name);\n \n-\tif (this_fb && inform)\n-\t  message_in_echo_area (\"Scanning indices of \\\"%s\\\"...\", files_name);\n+        if (this_fb && inform)\n+          message_in_echo_area (_(\"Scanning indices of \\\"%s\\\"...\"), files_name);\n \n-\tthis_index = info_indices_of_file_buffer (this_fb);\n-\tfree (this_node);\n+        this_index = info_indices_of_file_buffer (this_fb);\n+        free (this_node);\n \n-\tif (this_fb && inform)\n-\t  unmessage_in_echo_area ();\n+        if (this_fb && inform)\n+          unmessage_in_echo_area ();\n       }\n \n       if (this_index)\n-\t{\n-\t  /* Remember the filename which contains this set of references. */\n-\t  for (i = 0; this_index && this_index[i]; i++)\n-\t    if (!this_index[i]->filename)\n-\t      this_index[i]->filename = strdup (this_fb->filename);\n-\n-\t  /* Concatenate with the other indices.  */\n-\t  all_indices = info_concatenate_references (all_indices, this_index);\n-\t}\n+        {\n+          /* Remember the filename which contains this set of references. */\n+          for (i = 0; this_index && this_index[i]; i++)\n+            if (!this_index[i]->filename)\n+              this_index[i]->filename = xstrdup (this_fb->filename);\n+\n+          /* Concatenate with the other indices.  */\n+          all_indices = info_concatenate_references (all_indices, this_index);\n+        }\n     }\n \n   info_free_references (dir_menu);\n@@ -501,21 +561,21 @@ apropos_in_all_indices (search_string, inform)\n       int apropos_list_slots = 0;\n \n       for (i = 0; (entry = all_indices[i]); i++)\n-\t{\n-\t  if (string_in_line (search_string, entry->label) != -1)\n-\t    {\n-\t      add_pointer_to_array\n-\t\t(entry, apropos_list_index, apropos_list, apropos_list_slots,\n-\t\t 100, REFERENCE *);\n-\t    }\n-\t  else\n-\t    {\n-\t      maybe_free (entry->label);\n-\t      maybe_free (entry->filename);\n-\t      maybe_free (entry->nodename);\n-\t      free (entry);\n-\t    }\n-\t}\n+        {\n+          if (string_in_line (search_string, entry->label) != -1)\n+            {\n+              add_pointer_to_array\n+                (entry, apropos_list_index, apropos_list, apropos_list_slots,\n+                 100, REFERENCE *);\n+            }\n+          else\n+            {\n+              maybe_free (entry->label);\n+              maybe_free (entry->filename);\n+              maybe_free (entry->nodename);\n+              free (entry);\n+            }\n+        }\n \n       free (all_indices);\n       all_indices = apropos_list;\n@@ -524,7 +584,7 @@ apropos_in_all_indices (search_string, inform)\n }\n \n #define APROPOS_NONE \\\n-   \"No available info files reference \\\"%s\\\" in their indices.\"\n+   _(\"No available info files reference \\\"%s\\\" in their indices.\")\n \n void\n info_apropos (string)\n@@ -544,20 +604,20 @@ info_apropos (string)\n       REFERENCE *entry;\n \n       for (i = 0; (entry = apropos_list[i]); i++)\n-\tfprintf (stderr, \"\\\"(%s)%s\\\" -- %s\\n\",\n-\t\t entry->filename, entry->nodename, entry->label);\n+        fprintf (stderr, \"\\\"(%s)%s\\\" -- %s\\n\",\n+                 entry->filename, entry->nodename, entry->label);\n     }\n   info_free_references (apropos_list);\n }\n \n static char *apropos_list_nodename = \"*Apropos*\";\n \n DECLARE_INFO_COMMAND (info_index_apropos,\n-   \"Grovel all known info file's indices for a string and build a menu\")\n+   _(\"Grovel all known info file's indices for a string and build a menu\"))\n {\n   char *line;\n \n-  line = info_read_in_echo_area (window, \"Index apropos: \");\n+  line = info_read_in_echo_area (window, _(\"Index apropos: \"));\n \n   window = active_window;\n \n@@ -577,85 +637,85 @@ DECLARE_INFO_COMMAND (info_index_apropos,\n       apropos_list = apropos_in_all_indices (line, 1);\n \n       if (!apropos_list)\n-\t{\n-\t  info_error (APROPOS_NONE, line);\n-\t}\n+        {\n+          info_error (APROPOS_NONE, line);\n+        }\n       else\n-\t{\n-\t  register int i;\n-\t  char *line_buffer;\n-\n-\t  initialize_message_buffer ();\n-\t  printf_to_message_buffer\n-\t    (\"\\n* Menu: Nodes whoses indices contain \\\"%s\\\":\\n\", line);\n-\t  line_buffer = (char *)xmalloc (500);\n-\n-\t  for (i = 0; apropos_list[i]; i++)\n-\t    {\n-\t      int len;\n-\t      sprintf (line_buffer, \"* (%s)%s::\",\n-\t\t       apropos_list[i]->filename, apropos_list[i]->nodename);\n-\t      len = pad_to (36, line_buffer);\n-\t      sprintf (line_buffer + len, \"%s\", apropos_list[i]->label);\n-\t      printf_to_message_buffer (\"%s\\n\", line_buffer);\n-\t    }\n-\t  free (line_buffer);\n-\t}\n+        {\n+          register int i;\n+          char *line_buffer;\n+\n+          initialize_message_buffer ();\n+          printf_to_message_buffer\n+            (_(\"\\n* Menu: Nodes whoses indices contain \\\"%s\\\":\\n\"), line);\n+          line_buffer = (char *)xmalloc (500);\n+\n+          for (i = 0; apropos_list[i]; i++)\n+            {\n+              int len;\n+              sprintf (line_buffer, \"* (%s)%s::\",\n+                       apropos_list[i]->filename, apropos_list[i]->nodename);\n+              len = pad_to (36, line_buffer);\n+              sprintf (line_buffer + len, \"%s\", apropos_list[i]->label);\n+              printf_to_message_buffer (\"%s\\n\", line_buffer);\n+            }\n+          free (line_buffer);\n+        }\n \n       apropos_node = message_buffer_to_node ();\n       add_gcable_pointer (apropos_node->contents);\n       name_internal_node (apropos_node, apropos_list_nodename);\n \n       /* Even though this is an internal node, we don't want the window\n-\t system to treat it specially.  So we turn off the internalness\n-\t of it here. */\n+         system to treat it specially.  So we turn off the internalness\n+         of it here. */\n       apropos_node->flags &= ~N_IsInternal;\n \n       /* Find/Create a window to contain this node. */\n       {\n-\tWINDOW *new;\n-\tNODE *node;\n-\n-\tset_remembered_pagetop_and_point (window);\n-\n-\t/* If a window is visible and showing an apropos list already,\n-\t   re-use it. */\n-\tfor (new = windows; new; new = new->next)\n-\t  {\n-\t    node = new->node;\n-\n-\t    if (internal_info_node_p (node) &&\n-\t\t(strcmp (node->nodename, apropos_list_nodename) == 0))\n-\t      break;\n-\t  }\n-\n-\t/* If we couldn't find an existing window, try to use the next window\n-\t   in the chain. */\n-\tif (!new && window->next)\n-\t  new = window->next;\n-\n-\t/* If we still don't have a window, make a new one to contain\n-\t   the list. */\n-\tif (!new)\n-\t  {\n-\t    WINDOW *old_active;\n-\n-\t    old_active = active_window;\n-\t    active_window = window;\n-\t    new = window_make_window ((NODE *)NULL);\n-\t    active_window = old_active;\n-\t  }\n-\n-\t/* If we couldn't make a new window, use this one. */\n-\tif (!new)\n-\t  new = window;\n-\n-\t/* Lines do not wrap in this window. */\n-\tnew->flags |= W_NoWrap;\n-\n-\twindow_set_node_of_window (new, apropos_node);\n-\tremember_window_and_node (new, apropos_node);\n-\tactive_window = new;\n+        WINDOW *new;\n+        NODE *node;\n+\n+        set_remembered_pagetop_and_point (window);\n+\n+        /* If a window is visible and showing an apropos list already,\n+           re-use it. */\n+        for (new = windows; new; new = new->next)\n+          {\n+            node = new->node;\n+\n+            if (internal_info_node_p (node) &&\n+                (strcmp (node->nodename, apropos_list_nodename) == 0))\n+              break;\n+          }\n+\n+        /* If we couldn't find an existing window, try to use the next window\n+           in the chain. */\n+        if (!new && window->next)\n+          new = window->next;\n+\n+        /* If we still don't have a window, make a new one to contain\n+           the list. */\n+        if (!new)\n+          {\n+            WINDOW *old_active;\n+\n+            old_active = active_window;\n+            active_window = window;\n+            new = window_make_window ((NODE *)NULL);\n+            active_window = old_active;\n+          }\n+\n+        /* If we couldn't make a new window, use this one. */\n+        if (!new)\n+          new = window;\n+\n+        /* Lines do not wrap in this window. */\n+        new->flags |= W_NoWrap;\n+\n+        window_set_node_of_window (new, apropos_node);\n+        remember_window_and_node (new, apropos_node);\n+        active_window = new;\n       }\n       info_free_references (apropos_list);\n     }"}, {"sha": "8b8a7070c0b17d7e3ddc460c94e6bd3b0f3eb57c", "filename": "texinfo/info/indices.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Findices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Findices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Findices.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* indices.h -- Functions defined in indices.c. */\n+/* indices.h -- Functions defined in indices.c.\n+   $Id: indices.h,v 1.2 1997/07/06 20:50:29 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_INDICES_H_)\n-#define _INDICES_H_\n+#ifndef INFO_INDICES_H\n+#define INFO_INDICES_H\n \n /* User-visible variable controls the output of info-index-next. */\n extern int show_index_match;\n@@ -35,5 +36,7 @@ REFERENCE **apropos_in_all_indices ();\n \n /* User visible functions declared in indices.c. */\n extern void info_index_search (), info_next_index_match ();\n+extern void do_info_index_search ();\n+extern int index_intry_exists ();\n \n-#endif /* !_INDICES_H_ */\n+#endif /* not INFO_INDICES_H */"}, {"sha": "d9ab9a0634b319313ce8d62fadfaa61a96afc9d9", "filename": "texinfo/info/info-utils.c", "status": "modified", "additions": 95, "deletions": 102, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfo-utils.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -21,15 +21,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\t\t/* For \"NULL\".  Yechhh! */\n-#include <ctype.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#if defined (HAVE_STRING_H)\n-#  include <string.h>\n-#endif /* HAVE_STRING_H */\n+#include \"info.h\"\n #include \"info-utils.h\"\n-\n #if defined (HANDLE_MAN_PAGES)\n #  include \"man.h\"\n #endif /* HANDLE_MAN_PAGES */\n@@ -84,7 +77,7 @@ info_parse_node (string, newlines_okay)\n \n       /* Find the closing paren. */\n       while (string[i] && string[i] != ')')\n-\ti++;\n+        i++;\n \n       /* Remember parsed filename. */\n       saven_filename (string, i);\n@@ -93,7 +86,7 @@ info_parse_node (string, newlines_okay)\n       string += i;\n \n       if (*string)\n-\tstring++;\n+        string++;\n     }\n \n   /* Parse out nodename. */\n@@ -136,9 +129,9 @@ info_parse_label (label, node)\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t    Finding and Building Menus\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                  Finding and Building Menus                      */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Return a NULL terminated array of REFERENCE * which represents the menu\n@@ -246,23 +239,23 @@ info_references_internal (label, binding)\n       offset = string_in_line (\":\", refdef);\n \n       /* When searching for menu items, if no colon, there is no\n-\t menu item on this line. */\n+         menu item on this line. */\n       if (offset == -1)\n-\t{\n-\t  if (searching_for_menu_items)\n-\t    continue;\n-\t  else\n-\t    {\n-\t      int temp;\n-\n-\t      temp = skip_line (refdef);\n-\t      offset = string_in_line (\":\", refdef + temp);\n-\t      if (offset == -1)\n-\t\tcontinue;\t/* Give up? */\n-\t      else\n-\t\toffset += temp;\n-\t    }\n-\t}\n+        {\n+          if (searching_for_menu_items)\n+            continue;\n+          else\n+            {\n+              int temp;\n+\n+              temp = skip_line (refdef);\n+              offset = string_in_line (\":\", refdef + temp);\n+              if (offset == -1)\n+                continue;       /* Give up? */\n+              else\n+                offset += temp;\n+            }\n+        }\n \n       entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));\n       entry->filename = (char *)NULL;\n@@ -277,32 +270,32 @@ info_references_internal (label, binding)\n       entry->end = refdef - binding->buffer;\n \n       /* If this reference entry continues with another ':' then the\n-\t nodename is the same as the label. */\n+         nodename is the same as the label. */\n       if (*refdef == ':')\n-\t{\n-\t  entry->nodename = strdup (entry->label);\n-\t}\n+        {\n+          entry->nodename = xstrdup (entry->label);\n+        }\n       else\n-\t{\n-\t  /* This entry continues with a specific nodename.  Parse the\n-\t     nodename from the specification. */\n+        {\n+          /* This entry continues with a specific nodename.  Parse the\n+             nodename from the specification. */\n \n-\t  refdef += skip_whitespace_and_newlines (refdef);\n+          refdef += skip_whitespace_and_newlines (refdef);\n \n-\t  if (searching_for_menu_items)\n-\t    info_parse_node (refdef, DONT_SKIP_NEWLINES);\n-\t  else\n-\t    info_parse_node (refdef, SKIP_NEWLINES);\n+          if (searching_for_menu_items)\n+            info_parse_node (refdef, DONT_SKIP_NEWLINES);\n+          else\n+            info_parse_node (refdef, SKIP_NEWLINES);\n \n-\t  if (info_parsed_filename)\n-\t    entry->filename = strdup (info_parsed_filename);\n+          if (info_parsed_filename)\n+            entry->filename = xstrdup (info_parsed_filename);\n \n-\t  if (info_parsed_nodename)\n-\t    entry->nodename = strdup (info_parsed_nodename);\n-\t}\n+          if (info_parsed_nodename)\n+            entry->nodename = xstrdup (info_parsed_nodename);\n+        }\n \n       add_pointer_to_array\n-\t(entry, refs_index, refs, refs_slots, 50, REFERENCE *);\n+        (entry, refs_index, refs, refs_slots, 50, REFERENCE *);\n     }\n   return (refs);\n }\n@@ -320,7 +313,7 @@ info_get_labeled_reference (label, references)\n   for (i = 0; references && (entry = references[i]); i++)\n     {\n       if (strcmp (label, entry->label) == 0)\n-\treturn (entry);\n+        return (entry);\n     }\n   return ((REFERENCE *)NULL);\n }\n@@ -375,13 +368,13 @@ info_free_references (references)\n   if (references)\n     {\n       for (i = 0; references && (entry = references[i]); i++)\n-\t{\n-\t  maybe_free (entry->label);\n-\t  maybe_free (entry->filename);\n-\t  maybe_free (entry->nodename);\n+        {\n+          maybe_free (entry->label);\n+          maybe_free (entry->filename);\n+          maybe_free (entry->nodename);\n \n-\t  free (entry);\n-\t}\n+          free (entry);\n+        }\n \n       free (references);\n     }\n@@ -411,24 +404,24 @@ canonicalize_whitespace (string)\n   for (i = 0, j = 0; string[i]; i++)\n     {\n       if (whitespace_or_newline (string[i]))\n-\t{\n-\t  whitespace_found++;\n-\t  whitespace_loc = i;\n-\t  continue;\n-\t}\n+        {\n+          whitespace_found++;\n+          whitespace_loc = i;\n+          continue;\n+        }\n       else\n-\t{\n-\t  if (whitespace_found && whitespace_loc)\n-\t    {\n-\t      whitespace_found = 0;\n-\n-\t      /* Suppress whitespace at start of string. */\n-\t      if (j)\n-\t\ttemp[j++] = ' ';\n-\t    }\n-\n-\t  temp[j++] = string[i];\n-\t}\n+        {\n+          if (whitespace_found && whitespace_loc)\n+            {\n+              whitespace_found = 0;\n+\n+              /* Suppress whitespace at start of string. */\n+              if (j)\n+                temp[j++] = ' ';\n+            }\n+\n+          temp[j++] = string[i];\n+        }\n     }\n \n   /* Kill trailing whitespace. */\n@@ -466,26 +459,26 @@ printed_representation (character, hpos)\n   else if (iscntrl (character))\n     {\n       switch (character)\n-\t{\n-\tcase '\\r':\n-\tcase '\\n':\n-\t  the_rep[i++] = character;\n-\t  break;\n-\n-\tcase '\\t':\n-\t  {\n-\t    int tw;\n-\n-\t    tw = ((hpos + 8) & 0xf8) - hpos;\n-\t    while (i < tw)\n-\t      the_rep[i++] = ' ';\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  the_rep[i++] = '^';\n-\t  the_rep[i++] = (character | 0x40);\n-\t}\n+        {\n+        case '\\r':\n+        case '\\n':\n+          the_rep[i++] = character;\n+          break;\n+\n+        case '\\t':\n+          {\n+            int tw;\n+\n+            tw = ((hpos + 8) & 0xf8) - hpos;\n+            while (i < tw)\n+              the_rep[i++] = ' ';\n+          }\n+          break;\n+\n+        default:\n+          the_rep[i++] = '^';\n+          the_rep[i++] = (character | 0x40);\n+        }\n     }\n   else if (character > printable_limit)\n     {\n@@ -502,9 +495,9 @@ printed_representation (character, hpos)\n \n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t    Functions Static To This File\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                  Functions Static To This File                   */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Amount of space allocated to INFO_PARSED_FILENAME via xmalloc (). */\n@@ -531,7 +524,7 @@ saven_filename (filename, len)\n      int len;\n {\n   saven_string (filename, len,\n-\t\t&info_parsed_filename, &parsed_filename_size);\n+                &info_parsed_filename, &parsed_filename_size);\n }\n \n /* Remember NODENAME in PARSED_NODENAME.  An empty NODENAME is translated\n@@ -550,7 +543,7 @@ saven_nodename (nodename, len)\n      int len;\n {\n   saven_string (nodename, len,\n-\t\t&info_parsed_nodename, &parsed_nodename_size);\n+                &info_parsed_nodename, &parsed_nodename_size);\n }\n \n /* Remember STRING in STRING_P.  STRING_P should currently have STRING_SIZE_P\n@@ -565,16 +558,16 @@ save_string (string, string_p, string_size_p)\n   if (!string || !*string)\n     {\n       if (*string_p)\n-\tfree (*string_p);\n+        free (*string_p);\n \n       *string_p = (char *)NULL;\n       *string_size_p = 0;\n     }\n   else\n     {\n       if (strlen (string) >= *string_size_p)\n-\t*string_p = (char *)xrealloc\n-\t  (*string_p, (*string_size_p = 1 + strlen (string)));\n+        *string_p = (char *)xrealloc\n+          (*string_p, (*string_size_p = 1 + strlen (string)));\n \n       strcpy (*string_p, string);\n     }\n@@ -591,15 +584,15 @@ saven_string (string, len, string_p, string_size_p)\n   if (!string)\n     {\n       if (*string_p)\n-\tfree (*string_p);\n+        free (*string_p);\n \n       *string_p = (char *)NULL;\n       *string_size_p = 0;\n     }\n   else\n     {\n       if (len >= *string_size_p)\n-\t*string_p = (char *)xrealloc (*string_p, (*string_size_p = 1 + len));\n+        *string_p = (char *)xrealloc (*string_p, (*string_size_p = 1 + len));\n \n       strncpy (*string_p, string, len);\n       (*string_p)[len] = '\\0';\n@@ -665,7 +658,7 @@ get_internal_info_window (name)\n \n   for (win = windows; win; win = win->next)\n     if (internal_info_node_p (win->node) &&\n-\t(strcmp (win->node->nodename, name) == 0))\n+        (strcmp (win->node->nodename, name) == 0))\n       break;\n \n   return (win);"}, {"sha": "879587c484437f77d3275bd5e81a60fa3fe8a8c7", "filename": "texinfo/info/info-utils.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfo-utils.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,5 +1,5 @@\n /* info-utils.h -- Exported functions and variables from info-util.c.\n-   $Id: info-utils.h,v 1.1 1997/08/21 22:58:02 jason Exp $   \n+   $Id: info-utils.h,v 1.3 1997/07/15 18:42:20 karl Exp $   \n \n    This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n@@ -22,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_INFO_UTILS_H_)\n-#define _INFO_UTILS_H_\n+#ifndef INFO_UTILS_H\n+#define INFO_UTILS_H\n \n #if !defined (HAVE_STRCHR)\n #  undef strchr\n@@ -40,10 +40,10 @@\n    cross reference.  Arrays of such references can be built by calling\n    info_menus_of_node () or info_xrefs_of_node (). */\n typedef struct {\n-  char *label;\t\t/* User Label. */\n-  char *filename;\t/* File where this node can be found. */\n-  char *nodename;\t/* Name of the node. */\n-  int start, end;\t/* Offsets within the containing node of LABEL. */\n+  char *label;          /* User Label. */\n+  char *filename;       /* File where this node can be found. */\n+  char *nodename;       /* Name of the node. */\n+  int start, end;       /* Offsets within the containing node of LABEL. */\n } REFERENCE;\n \n /* When non-zero, various display and input functions handle ISO Latin\n@@ -137,4 +137,4 @@ extern void info_parse_label (/* label, node */);\n       info_parse_label (INFO_ALTPREV_LABEL, n); \\\n   } while (0)\n \n-#endif /* !_INFO_UTILS_H_ */\n+#endif /* not INFO_UTILS_H */"}, {"sha": "9b46edfcfc05503f65ce9b02e0a38f28c5262e58", "filename": "texinfo/info/info.c", "status": "modified", "additions": 289, "deletions": 225, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfo.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* info.c -- Display nodes of Info files in multiple windows. */\n+/* info.c -- Display nodes of Info files in multiple windows.\n+   $Id: info.c,v 1.10 1997/07/30 15:21:44 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993, 96 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 96, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -22,6 +20,7 @@\n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n #include \"info.h\"\n+#include \"indices.h\"\n #include \"dribble.h\"\n #include \"getopt.h\"\n #if defined (HANDLE_MAN_PAGES)\n@@ -30,7 +29,7 @@\n \n /* The version numbers of this version of Info. */\n int info_major_version = 2;\n-int info_minor_version = 16;\n+int info_minor_version = 17;\n int info_patch_level = 0;\n \n /* Non-zero means search all indices for APROPOS_SEARCH_STRING. */\n@@ -39,6 +38,14 @@ static int apropos_p = 0;\n /* Variable containing the string to search for when apropos_p is non-zero. */\n static char *apropos_search_string = (char *)NULL;\n \n+/* Non-zero means search all indices for INDEX_SEARCH_STRING.  Unlike\n+   apropos, this puts the user at the node, running info. */\n+static int index_search_p = 0;\n+\n+/* Variable containing the string to search for when index_search_p is\n+   non-zero. */ \n+static char *index_search_string = (char *)NULL;\n+\n /* Non-zero means print version info only. */\n static int print_version_p = 0;\n \n@@ -70,6 +77,7 @@ int dump_subnodes = 0;\n #define APROPOS_OPTION 1\n #define DRIBBLE_OPTION 2\n #define RESTORE_OPTION 3\n+#define IDXSRCH_OPTION 4\n static struct option long_options[] = {\n   { \"apropos\", 1, 0, APROPOS_OPTION },\n   { \"directory\", 1, 0, 'd' },\n@@ -81,6 +89,7 @@ static struct option long_options[] = {\n   { \"version\", 0, &print_version_p, 1 },\n   { \"dribble\", 1, 0, DRIBBLE_OPTION },\n   { \"restore\", 1, 0, RESTORE_OPTION },\n+  { \"index-search\", 1, 0, IDXSRCH_OPTION },\n   {NULL, 0, NULL, 0}\n };\n \n@@ -95,111 +104,127 @@ static void usage (), info_short_help (), remember_info_program_name ();\n \n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t  Main Entry Point to the Info Program\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                Main Entry Point to the Info Program              */\n+/*                                                                  */\n /* **************************************************************** */\n \n int\n main (argc, argv)\n      int argc;\n      char **argv;\n {\n-  int getopt_long_index;\t/* Index returned by getopt_long (). */\n-  NODE *initial_node;\t\t/* First node loaded by Info. */\n+  int getopt_long_index;        /* Index returned by getopt_long (). */\n+  NODE *initial_node;           /* First node loaded by Info. */\n \n   remember_info_program_name (argv[0]);\n \n+#ifdef HAVE_SETLOCALE\n+  /* Set locale via LC_ALL.  */\n+  setlocale (LC_ALL, \"\");\n+#endif\n+\n+  /* Set the text message domain.  */\n+  bindtextdomain (PACKAGE, LOCALEDIR);\n+  textdomain (PACKAGE);\n+\n   while (1)\n     {\n       int option_character;\n \n       option_character = getopt_long\n-\t(argc, argv, short_options, long_options, &getopt_long_index);\n+        (argc, argv, short_options, long_options, &getopt_long_index);\n \n       /* getopt_long () returns EOF when there are no more long options. */\n       if (option_character == EOF)\n-\tbreak;\n+        break;\n \n       /* If this is a long option, then get the short version of it. */\n       if (option_character == 0 && long_options[getopt_long_index].flag == 0)\n-\toption_character = long_options[getopt_long_index].val;\n+        option_character = long_options[getopt_long_index].val;\n \n       /* Case on the option that we have received. */\n       switch (option_character)\n-\t{\n-\tcase 0:\n-\t  break;\n-\n-\t  /* User wants to add a directory. */\n-\tcase 'd':\n-\t  info_add_path (optarg, INFOPATH_PREPEND);\n-\t  break;\n-\n-\t  /* User is specifying a particular node. */\n-\tcase 'n':\n-\t  add_pointer_to_array (optarg, user_nodenames_index, user_nodenames,\n-\t\t\t\tuser_nodenames_slots, 10, char *);\n-\t  break;\n-\n-\t  /* User is specifying a particular Info file. */\n-\tcase 'f':\n-\t  if (user_filename)\n-\t    free (user_filename);\n-\n-\t  user_filename = strdup (optarg);\n-\t  break;\n-\n-\t  /* User is specifying the name of a file to output to. */\n-\tcase 'o':\n-\t  if (user_output_filename)\n-\t    free (user_output_filename);\n-\t  user_output_filename = strdup (optarg);\n-\t  break;\n-\n-\t  /* User is specifying that she wishes to dump the subnodes of\n-\t     the node that she is dumping. */\n-\tcase 's':\n-\t  dump_subnodes = 1;\n-\t  break;\n-\n-\t  /* User has specified a string to search all indices for. */\n-\tcase APROPOS_OPTION:\n-\t  apropos_p = 1;\n-\t  maybe_free (apropos_search_string);\n-\t  apropos_search_string = strdup (optarg);\n-\t  break;\n-\n-\t  /* User has specified a dribble file to receive keystrokes. */\n-\tcase DRIBBLE_OPTION:\n-\t  close_dribble_file ();\n-\t  open_dribble_file (optarg);\n-\t  break;\n-\n-\t  /* User has specified an alternate input stream. */\n-\tcase RESTORE_OPTION:\n-\t  info_set_input_from_file (optarg);\n-\t  break;\n-\n-\tdefault:\n-\t  usage ();\n-\t}\n+        {\n+        case 0:\n+          break;\n+\n+          /* User wants to add a directory. */\n+        case 'd':\n+          info_add_path (optarg, INFOPATH_PREPEND);\n+          break;\n+\n+          /* User is specifying a particular node. */\n+        case 'n':\n+          add_pointer_to_array (optarg, user_nodenames_index, user_nodenames,\n+                                user_nodenames_slots, 10, char *);\n+          break;\n+\n+          /* User is specifying a particular Info file. */\n+        case 'f':\n+          if (user_filename)\n+            free (user_filename);\n+\n+          user_filename = xstrdup (optarg);\n+          break;\n+\n+          /* User is specifying the name of a file to output to. */\n+        case 'o':\n+          if (user_output_filename)\n+            free (user_output_filename);\n+          user_output_filename = xstrdup (optarg);\n+          break;\n+\n+          /* User is specifying that she wishes to dump the subnodes of\n+             the node that she is dumping. */\n+        case 's':\n+          dump_subnodes = 1;\n+          break;\n+\n+          /* User has specified a string to search all indices for. */\n+        case APROPOS_OPTION:\n+          apropos_p = 1;\n+          maybe_free (apropos_search_string);\n+          apropos_search_string = xstrdup (optarg);\n+          break;\n+\n+          /* User has specified a dribble file to receive keystrokes. */\n+        case DRIBBLE_OPTION:\n+          close_dribble_file ();\n+          open_dribble_file (optarg);\n+          break;\n+\n+          /* User has specified an alternate input stream. */\n+        case RESTORE_OPTION:\n+          info_set_input_from_file (optarg);\n+          break;\n+\n+          /* User has specified a string to search all indices for. */\n+        case IDXSRCH_OPTION:\n+          index_search_p = 1;\n+          maybe_free (index_search_string);\n+          index_search_string = xstrdup (optarg);\n+          break;\n+\n+        default:\n+          usage ();\n+        }\n     }\n \n   /* If the output device is not a terminal, and no output filename has been\n      specified, make user_output_filename be \"-\", so that the info is written\n      to stdout, and turn on the dumping of subnodes. */\n   if ((!isatty (fileno (stdout))) && (user_output_filename == (char *)NULL))\n     {\n-      user_output_filename = strdup (\"-\");\n+      user_output_filename = xstrdup (\"-\");\n       dump_subnodes = 1;\n     }\n \n   /* If the user specified --version, then show the version and exit. */\n   if (print_version_p)\n     {\n-      printf (\"GNU Info (Texinfo 3.9) %s\\n\", version_string ());\n-      puts (\"Copyright (C) 1996 Free Software Foundation, Inc.\\n\\\n+      printf (\"info (GNU %s %s) %s\\n\", PACKAGE, VERSION, version_string ());\n+      puts (\"Copyright (C) 1997 Free Software Foundation, Inc.\\n\\\n There is NO warranty.  You may redistribute this software\\n\\\n under the terms of the GNU General Public License.\\n\\\n For more information about these matters, see the files named COPYING.\");\n@@ -213,34 +238,38 @@ For more information about these matters, see the files named COPYING.\");\n       exit (0);\n     }\n   \n-  /* If the user hasn't specified a path for Info files, default that path\n-     now. */\n+  /* If the user hasn't specified a path for Info files, default it.  */\n   if (!infopath)\n     {\n-      char *path_from_env, *getenv ();\n-\n-      path_from_env = getenv (\"INFOPATH\");\n+      char *path_from_env = getenv (\"INFOPATH\");\n \n       if (path_from_env)\n-\tinfo_add_path (path_from_env, INFOPATH_PREPEND);\n+        {\n+          unsigned len = strlen (path_from_env);\n+          /* Trailing : on INFOPATH means insert the default path.  */\n+          if (len && path_from_env[len - 1] == ':')\n+            {\n+              path_from_env[len - 1] = 0;\n+              info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);\n+            }\n+          info_add_path (path_from_env, INFOPATH_PREPEND);\n+        }\n       else\n-\tinfo_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);\n+        info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);\n     }\n \n   /* If the user specified a particular filename, add the path of that\n      file to the contents of INFOPATH. */\n   if (user_filename)\n     {\n-      char *directory_name, *temp;\n-\n-      directory_name = strdup (user_filename);\n-      temp = filename_non_directory (directory_name);\n+      char *directory_name = xstrdup (user_filename);\n+      char *temp = filename_non_directory (directory_name);\n \n       if (temp != directory_name)\n-\t{\n-\t  *temp = 0;\n-\t  info_add_path (directory_name, INFOPATH_PREPEND);\n-\t}\n+        {\n+          *temp = 0;\n+          info_add_path (directory_name, INFOPATH_PREPEND);\n+        }\n \n       free (directory_name);\n     }\n@@ -255,39 +284,74 @@ For more information about these matters, see the files named COPYING.\");\n \n   /* Get the initial Info node.  It is either \"(dir)Top\", or what the user\n      specifed with values in user_filename and user_nodenames. */\n-  if (user_nodenames)\n-    initial_node = info_get_node (user_filename, user_nodenames[0]);\n-  else\n-    initial_node = info_get_node (user_filename, (char *)NULL);\n+  initial_node = info_get_node (user_filename,\n+                                user_nodenames ? user_nodenames[0] : NULL);\n \n   /* If we couldn't get the initial node, this user is in trouble. */\n   if (!initial_node)\n     {\n       if (info_recent_file_error)\n-\tinfo_error (info_recent_file_error);\n+        info_error (info_recent_file_error);\n       else\n-\tinfo_error\n-\t  (CANT_FIND_NODE, user_nodenames ? user_nodenames[0] : \"Top\");\n+        info_error\n+          (CANT_FIND_NODE, user_nodenames ? user_nodenames[0] : \"Top\");\n       exit (1);\n     }\n \n-  /* Special cases for when the user specifies multiple nodes.  If we are\n-     dumping to an output file, dump all of the nodes specified.  Otherwise,\n-     attempt to create enough windows to handle the nodes that this user wants\n-     displayed. */\n+  /* Special cases for when the user specifies multiple nodes.  If we\n+     are dumping to an output file, dump all of the nodes specified.\n+     Otherwise, attempt to create enough windows to handle the nodes\n+     that this user wants displayed. */\n   if (user_nodenames_index > 1)\n     {\n       free (initial_node);\n \n       if (user_output_filename)\n-\tdump_nodes_to_file\n-\t  (user_filename, user_nodenames, user_output_filename, dump_subnodes);\n+        dump_nodes_to_file\n+          (user_filename, user_nodenames, user_output_filename, dump_subnodes);\n       else\n-\tbegin_multiple_window_info_session (user_filename, user_nodenames);\n+        begin_multiple_window_info_session (user_filename, user_nodenames);\n \n       exit (0);\n     }\n \n+  /* If the user specified `--index-search=STRING', start the info\n+     session in the node corresponding to the first match. */\n+  if (index_search_p)\n+    {\n+      int status = 0;\n+\n+      initialize_info_session (initial_node, 0);\n+\n+      if (index_entry_exists (windows, index_search_string))\n+        {\n+          terminal_clear_screen ();\n+          terminal_prep_terminal ();\n+          display_update_display (windows);\n+          info_last_executed_command = (VFunction *)NULL;\n+\n+          do_info_index_search (windows, 0, index_search_string);\n+\n+          info_read_and_dispatch ();\n+\n+          terminal_unprep_terminal ();\n+\n+          /* On program exit, leave the cursor at the bottom of the\n+             window, and restore the terminal IO. */\n+          terminal_goto_xy (0, screenheight - 1);\n+          terminal_clear_to_eol ();\n+          fflush (stdout);\n+        }\n+      else\n+        {\n+          fputs (_(\"no entries found\\n\"), stderr);\n+          status = 2;\n+        }\n+\n+      close_dribble_file (); \n+      exit (status);\n+    }\n+\n   /* If there are arguments remaining, they are the names of menu items\n      in sequential info files starting from the first one loaded.  That\n      file name is either \"dir\", or the contents of user_filename if one\n@@ -303,134 +367,134 @@ For more information about these matters, see the files named COPYING.\");\n       /* Remember the name of the menu entry we want. */\n       arg = argv[optind++];\n \n-      if (first_arg == (char *)NULL)\n-\tfirst_arg = arg;\n+      if (!first_arg)\n+        first_arg = arg;\n \n       /* Build and return a list of the menu items in this node. */\n       menu = info_menu_of_node (initial_node);\n \n       /* If there wasn't a menu item in this node, stop here, but let\n-\t the user continue to use Info.  Perhaps they wanted this node\n-\t and didn't realize it. */\n+         the user continue to use Info.  Perhaps they wanted this node\n+         and didn't realize it. */\n       if (!menu)\n-\t{\n+        {\n #if defined (HANDLE_MAN_PAGES)\n-\t  if (first_arg == arg)\n-\t    {\n-\t      node = make_manpage_node (first_arg);\n-\t      if (node)\n-\t\tgoto maybe_got_node;\n-\t    }\n+          if (first_arg == arg)\n+            {\n+              node = make_manpage_node (first_arg);\n+              if (node)\n+                goto maybe_got_node;\n+            }\n #endif /* HANDLE_MAN_PAGES */\n-\t  begin_info_session_with_error\n-\t    (initial_node, \"There is no menu in this node.\");\n-\t  exit (0);\n-\t}\n+          begin_info_session_with_error\n+            (initial_node, _(\"There is no menu in this node.\"));\n+          exit (0);\n+        }\n \n       /* Find the specified menu item. */\n       entry = info_get_labeled_reference (arg, menu);\n \n       /* If the item wasn't found, search the list sloppily.  Perhaps this\n-\t user typed \"buffer\" when they really meant \"Buffers\". */\n+         user typed \"buffer\" when they really meant \"Buffers\". */\n       if (!entry)\n-\t{\n-\t  register int i;\n-\t  int best_guess = -1;\n-\n-\t  for (i = 0; entry = menu[i]; i++)\n-\t    {\n-\t      if (strcasecmp (entry->label, arg) == 0)\n-\t\tbreak;\n-\t      else\n-\t\tif (strncasecmp (entry->label, arg, strlen (arg)) == 0)\n-\t\t  best_guess = i;\n-\t    }\n-\n-\t  if (!entry && best_guess != -1)\n-\t    entry = menu[best_guess];\n-\t}\n+        {\n+          register int i;\n+          int best_guess = -1;\n+\n+          for (i = 0; (entry = menu[i]); i++)\n+            {\n+              if (strcasecmp (entry->label, arg) == 0)\n+                break;\n+              else\n+                if (strncasecmp (entry->label, arg, strlen (arg)) == 0)\n+                  best_guess = i;\n+            }\n+\n+          if (!entry && best_guess != -1)\n+            entry = menu[best_guess];\n+        }\n \n       /* If we failed to find the reference, start Info with the current\n-\t node anyway.  It is probably a misspelling. */\n+         node anyway.  It is probably a misspelling. */\n       if (!entry)\n-\t{\n-\t  char *error_message = \"There is no menu item \\\"%s\\\" in this node.\";\n+        {\n+          char *error_message = _(\"There is no menu item \\\"%s\\\" in this node.\");\n \n #if defined (HANDLE_MAN_PAGES)\n-\t  if (first_arg == arg)\n-\t    {\n-\t      node = make_manpage_node (first_arg);\n-\t      if (node)\n-\t\tgoto maybe_got_node;\n-\t    }\n+          if (first_arg == arg)\n+            {\n+              node = make_manpage_node (first_arg);\n+              if (node)\n+                goto maybe_got_node;\n+            }\n #endif /* HANDLE_MAN_PAGES */\n \n-\t  info_free_references (menu);\n+          info_free_references (menu);\n \n-\t  /* If we were supposed to dump this node, complain. */\n-\t  if (user_output_filename)\n-\t    info_error (error_message, arg);\n-\t  else\n-\t    begin_info_session_with_error (initial_node, error_message, arg);\n+          /* If we were supposed to dump this node, complain. */\n+          if (user_output_filename)\n+            info_error (error_message, arg);\n+          else\n+            begin_info_session_with_error (initial_node, error_message, arg);\n \n-\t  exit (0);\n-\t}\n+          exit (0);\n+        }\n \n       /* We have found the reference that the user specified.  Clean it\n-\t up a little bit. */\n+         up a little bit. */\n       if (!entry->filename)\n-\t{\n-\t  if (initial_node->parent)\n-\t    entry->filename = strdup (initial_node->parent);\n-\t  else\n-\t    entry->filename = strdup (initial_node->filename);\n-\t}\n+        {\n+          if (initial_node->parent)\n+            entry->filename = xstrdup (initial_node->parent);\n+          else\n+            entry->filename = xstrdup (initial_node->filename);\n+        }\n \n       /* Find this node.  If we can find it, then turn the initial_node\n-\t into this one.  If we cannot find it, try using the label of the\n-\t entry as a file (i.e., \"(LABEL)Top\").  Otherwise the Info file is\n-\t malformed in some way, and we will just use the current value of\n-\t initial node. */\n+         into this one.  If we cannot find it, try using the label of the\n+         entry as a file (i.e., \"(LABEL)Top\").  Otherwise the Info file is\n+         malformed in some way, and we will just use the current value of\n+         initial node. */\n       node = info_get_node (entry->filename, entry->nodename);\n \n #if defined (HANDLE_MAN_PAGES)\n-\t  if ((first_arg == arg) && !node)\n-\t    {\n-\t      node = make_manpage_node (first_arg);\n-\t      if (node)\n-\t\tgoto maybe_got_node;\n-\t    }\n+          if ((first_arg == arg) && !node)\n+            {\n+              node = make_manpage_node (first_arg);\n+              if (node)\n+                goto maybe_got_node;\n+            }\n #endif /* HANDLE_MAN_PAGES */\n \n       if (!node && entry->nodename &&\n-\t  (strcmp (entry->label, entry->nodename) == 0))\n-\tnode = info_get_node (entry->label, \"Top\");\n+          (strcmp (entry->label, entry->nodename) == 0))\n+        node = info_get_node (entry->label, \"Top\");\n \n     maybe_got_node:\n       if (node)\n-\t{\n-\t  free (initial_node);\n-\t  initial_node = node;\n-\t  info_free_references (menu);\n-\t}\n+        {\n+          free (initial_node);\n+          initial_node = node;\n+          info_free_references (menu);\n+        }\n       else\n-\t{\n-\t  char *temp = strdup (entry->label);\n-\t  char *error_message;\n+        {\n+          char *temp = xstrdup (entry->label);\n+          char *error_message;\n \n-\t  error_message = \"Unable to find the node referenced by \\\"%s\\\".\";\n+          error_message = _(\"Unable to find the node referenced by \\\"%s\\\".\");\n \n-\t  info_free_references (menu);\n+          info_free_references (menu);\n \n-\t  /* If we were trying to dump the node, then give up.  Otherwise,\n-\t     start the session with an error message. */\n-\t  if (user_output_filename)\n-\t    info_error (error_message, temp);\n-\t  else\n-\t    begin_info_session_with_error (initial_node, error_message, temp);\n+          /* If we were trying to dump the node, then give up.  Otherwise,\n+             start the session with an error message. */\n+          if (user_output_filename)\n+            info_error (error_message, temp);\n+          else\n+            begin_info_session_with_error (initial_node, error_message, temp);\n \n-\t  exit (0);\n-\t}\n+          exit (0);\n+        }\n     }\n \n   /* If the user specified that this node should be output, then do that\n@@ -454,15 +518,15 @@ version_string ()\n       vstring = (char *)xmalloc (50);\n       sprintf (vstring, \"%d.%d\", info_major_version, info_minor_version);\n       if (info_patch_level)\n-\tsprintf (vstring + strlen (vstring), \"-p%d\", info_patch_level);\n+        sprintf (vstring + strlen (vstring), \"-p%d\", info_patch_level);\n     }\n   return (vstring);\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t   Error Handling for Info\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                 Error Handling for Info                          */\n+/*                                                                  */\n /* **************************************************************** */\n \n static char *program_name = (char *)NULL;\n@@ -474,7 +538,7 @@ remember_info_program_name (fullpath)\n   char *filename;\n \n   filename = filename_non_directory (fullpath);\n-  program_name = strdup (filename);\n+  program_name = xstrdup (filename);\n }\n \n /* Non-zero if an error has been signalled. */\n@@ -503,22 +567,22 @@ info_error (format, arg1, arg2)\n   else\n     {\n       if (!echo_area_is_active)\n-\t{\n-\t  if (info_error_rings_bell_p)\n-\t    terminal_ring_bell ();\n-\t  window_message_in_echo_area (format, arg1, arg2);\n-\t}\n+        {\n+          if (info_error_rings_bell_p)\n+            terminal_ring_bell ();\n+          window_message_in_echo_area (format, arg1, arg2);\n+        }\n       else\n-\t{\n-\t  NODE *temp;\n-\n-\t  temp = build_message_node (format, arg1, arg2);\n-\t  if (info_error_rings_bell_p)\n-\t    terminal_ring_bell ();\n-\t  inform_in_echo_area (temp->contents);\n-\t  free (temp->contents);\n-\t  free (temp);\n-\t}\n+        {\n+          NODE *temp;\n+\n+          temp = build_message_node (format, arg1, arg2);\n+          if (info_error_rings_bell_p)\n+            terminal_ring_bell ();\n+          inform_in_echo_area (temp->contents);\n+          free (temp->contents);\n+          free (temp);\n+        }\n     }\n }\n \n@@ -528,38 +592,38 @@ static void\n usage ()\n {\n   fprintf (stderr,\"%s\\n%s\\n%s\\n%s\\n%s\\n\",\n-\"Usage: info [-d dir-path] [-f info-file] [-o output-file] [-n node-name]...\",\n-\"            [--directory dir-path] [--file info-file] [--node node-name]...\",\n-\"            [--help] [--output output-file] [--subnodes] [--version]\",\n-\"            [--dribble dribble-file] [--restore from-file]\",\n-\"            [menu-selection ...]\");\n+_(\"Usage: info [-d dir-path] [-f info-file] [-o output-file] [-n node-name]...\"),\n+_(\"            [--directory dir-path] [--file info-file] [--node node-name]...\"),\n+_(\"            [--help] [--output output-file] [--subnodes] [--version]\"),\n+_(\"            [--dribble dribble-file] [--restore from-file]\"),\n+_(\"            [menu-selection ...]\"));\n   exit (1);\n }\n \n /* Produce a scaled down description of the available options to Info. */\n static void\n info_short_help ()\n {\n-  puts (\"\\\n+  puts (_(\"\\\n Here is a quick description of Info's options.  For a more complete\\n\\\n description of how to use Info, type `info info options'.\\n\\\n \\n\\\n-   --directory DIR\t\tAdd DIR to INFOPATH.\\n\\\n-   --dribble FILENAME\t\tRemember user keystrokes in FILENAME.\\n\\\n-   --file FILENAME\t\tSpecify Info file to visit.\\n\\\n-   --node NODENAME\t\tSpecify nodes in first visited Info file.\\n\\\n-   --output FILENAME\t\tOutput selected nodes to FILENAME.\\n\\\n-   --restore FILENAME\t\tRead initial keystrokes from FILENAME.\\n\\\n-   --subnodes\t\t\tRecursively output menu items.\\n\\\n-   --help\t\t\tGet this help message.\\n\\\n-   --version\t\t\tDisplay Info's version information.\\n\\\n+   --directory DIR              Add DIR to INFOPATH.\\n\\\n+   --dribble FILENAME           Remember user keystrokes in FILENAME.\\n\\\n+   --file FILENAME              Specify Info file to visit.\\n\\\n+   --node NODENAME              Specify nodes in first visited Info file.\\n\\\n+   --output FILENAME            Output selected nodes to FILENAME.\\n\\\n+   --restore FILENAME           Read initial keystrokes from FILENAME.\\n\\\n+   --subnodes                   Recursively output menu items.\\n\\\n+   --help                       Get this help message.\\n\\\n+   --version                    Display Info's version information.\\n\\\n \\n\\\n Remaining arguments to Info are treated as the names of menu\\n\\\n items in the initial node visited.  You can easily move to the\\n\\\n node of your choice by specifying the menu names which describe\\n\\\n the path to that node.  For example, `info emacs buffers'.\\n\\\n \\n\\\n-Email bug reports to bug-texinfo@prep.ai.mit.edu.\");\n+Email bug reports to bug-texinfo@prep.ai.mit.edu.\"));\n \n   exit (0);\n }"}, {"sha": "e8be98ed42f592eb04be88373bc6a6773682601b", "filename": "texinfo/info/info.h", "status": "modified", "additions": 104, "deletions": 39, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfo.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* info.h -- Header file which includes all of the other headers. */\n+/* info.h -- Header file which includes all of the other headers.\n+   $Id: info.h,v 1.6 1997/07/15 18:34:15 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,33 +22,86 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_INFO_H_)\n-#define _INFO_H_\n+#if !defined (INFO_H)\n+#define INFO_H\n+\n+/* We always want these, so why clutter up the compile command?  */\n+#define HANDLE_MAN_PAGES\n+#define NAMED_FUNCTIONS\n+\n+/* System dependencies.  */\n+#include \"system.h\"\n+\n+/* Some of our other include files use these.  */\n+typedef int Function ();\n+typedef void VFunction ();\n+typedef char *CFunction ();\n+\n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#if defined (HAVE_STRING_H)\n-#include <string.h>\n-#endif /* HAVE_STRING_H */\n #include \"filesys.h\"\n #include \"display.h\"\n #include \"session.h\"\n-#include \"echo_area.h\"\n+#include \"echo-area.h\"\n #include \"doc.h\"\n #include \"footnotes.h\"\n #include \"gc.h\"\n \n+#define info_toupper(x) (islower (x) ? toupper (x) : x)\n+#define info_tolower(x) (isupper (x) ? tolower (x) : x)\n+\n+#if !defined (whitespace)\n+#  define whitespace(c) ((c == ' ') || (c == '\\t'))\n+#endif /* !whitespace */\n+\n+#if !defined (whitespace_or_newline)\n+#  define whitespace_or_newline(c) (whitespace (c) || (c == '\\n'))\n+#endif /* !whitespace_or_newline */\n+\n+/* Add POINTER to the list of pointers found in ARRAY.  SLOTS is the number\n+   of slots that have already been allocated.  INDEX is the index into the\n+   array where POINTER should be added.  GROW is the number of slots to grow\n+   ARRAY by, in the case that it needs growing.  TYPE is a cast of the type\n+   of object stored in ARRAY (e.g., NODE_ENTRY *. */\n+#define add_pointer_to_array(pointer, idx, array, slots, grow, type) \\\n+  do { \\\n+    if (idx + 2 >= slots) \\\n+      array = (type *)(xrealloc (array, (slots += grow) * sizeof (type))); \\\n+    array[idx++] = (type)pointer; \\\n+    array[idx] = (type)NULL; \\\n+  } while (0)\n+\n+#define maybe_free(x) do { if (x) free (x); } while (0)\n+\n+#if !defined (zero_mem) && defined (HAVE_MEMSET)\n+#  define zero_mem(mem, length) memset (mem, 0, length)\n+#endif /* !zero_mem && HAVE_MEMSET */\n+\n+#if !defined (zero_mem) && defined (HAVE_BZERO)\n+#  define zero_mem(mem, length) bzero (mem, length)\n+#endif /* !zero_mem && HAVE_BZERO */\n+\n+#if !defined (zero_mem)\n+#  define zero_mem(mem, length) \\\n+  do {                                  \\\n+        register int zi;                \\\n+        register unsigned char *place;  \\\n+                                        \\\n+        place = (unsigned char *)mem;   \\\n+        for (zi = 0; zi < length; zi++) \\\n+          place[zi] = 0;                \\\n+      } while (0)\n+#endif /* !zero_mem */\n+\n+\f\n /* A structure associating the nodes visited in a particular window. */\n typedef struct {\n-  WINDOW *window;\t\t/* The window that this list is attached to. */\n-  NODE **nodes;\t\t\t/* Array of nodes visited in this window. */\n-  int *pagetops;\t\t/* For each node in NODES, the pagetop. */\n-  long *points;\t\t\t/* For each node in NODES, the point. */\n-  int current;\t\t\t/* Index in NODES of the current node. */\n-  int nodes_index;\t\t/* Index where to add the next node. */\n-  int nodes_slots;\t\t/* Number of slots allocated to NODES. */\n+  WINDOW *window;               /* The window that this list is attached to. */\n+  NODE **nodes;                 /* Array of nodes visited in this window. */\n+  int *pagetops;                /* For each node in NODES, the pagetop. */\n+  long *points;                 /* For each node in NODES, the point. */\n+  int current;                  /* Index in NODES of the current node. */\n+  int nodes_index;              /* Index where to add the next node. */\n+  int nodes_slots;              /* Number of slots allocated to NODES. */\n } INFO_WINDOW;\n \n /* Array of structures describing for each window which nodes have been\n@@ -78,23 +132,34 @@ extern int info_major_version, info_minor_version, info_patch_level;\n extern char *version_string ();\n \n /* Error message defines. */\n-#define CANT_FIND_NODE\t\"Cannot find the node \\\"%s\\\".\"\n-#define CANT_FILE_NODE\t\"Cannot find the node \\\"(%s)%s\\\".\"\n-#define CANT_FIND_WIND\t\"Cannot find a window!\"\n-#define CANT_FIND_POINT\t\"Point doesn't appear within this window's node!\"\n-#define CANT_KILL_LAST\t\"Cannot delete the last window.\"\n-#define NO_MENU_NODE\t\"No menu in this node.\"\n-#define NO_FOOT_NODE\t\"No footnotes in this node.\"\n-#define NO_XREF_NODE\t\"No cross references in this node.\"\n-#define NO_POINTER\t\"No \\\"%s\\\" pointer for this node.\"\n-#define UNKNOWN_COMMAND\t\"Unknown Info command `%c'.  `?' for help.\"\n-#define TERM_TOO_DUMB\t\"Terminal type \\\"%s\\\" is not smart enough to run Info.\"\n-#define AT_NODE_BOTTOM\t\"You are already at the last page of this node.\"\n-#define AT_NODE_TOP\t\"You are already at the first page of this node.\"\n-#define ONE_WINDOW\t\"Only one window.\"\n-#define WIN_TOO_SMALL\t\"Resulting window would be too small.\"\n-#define CANT_MAKE_HELP\t\\\n-\"There isn't enough room to make a help window.  Please delete a window.\"\n-\n-#endif /* !_INFO_H_ */\n+#define CANT_FIND_NODE  _(\"Cannot find the node \\\"%s\\\".\")\n+#define CANT_FILE_NODE  _(\"Cannot find the node \\\"(%s)%s\\\".\")\n+#define CANT_FIND_WIND  _(\"Cannot find a window!\")\n+#define CANT_FIND_POINT _(\"Point doesn't appear within this window's node!\")\n+#define CANT_KILL_LAST  _(\"Cannot delete the last window.\")\n+#define NO_MENU_NODE    _(\"No menu in this node.\")\n+#define NO_FOOT_NODE    _(\"No footnotes in this node.\")\n+#define NO_XREF_NODE    _(\"No cross references in this node.\")\n+#define NO_POINTER      _(\"No \\\"%s\\\" pointer for this node.\")\n+#define UNKNOWN_COMMAND _(\"Unknown Info command `%c'.  `?' for help.\")\n+#define TERM_TOO_DUMB   _(\"Terminal type \\\"%s\\\" is not smart enough to run Info.\")\n+#define AT_NODE_BOTTOM  _(\"You are already at the last page of this node.\")\n+#define AT_NODE_TOP     _(\"You are already at the first page of this node.\")\n+#define ONE_WINDOW      _(\"Only one window.\")\n+#define WIN_TOO_SMALL   _(\"Resulting window would be too small.\")\n+#define CANT_MAKE_HELP  \\\n+_(\"There isn't enough room to make a help window.  Please delete a window.\")\n+\n+\f\n+/* Found in info-utils.c. */\n+extern char *filename_non_directory ();\n+\n+#if !defined (BUILDING_LIBRARY)\n+/* Found in session.c */\n+extern int info_windows_initialized_p;\n+\n+/* Found in window.c. */\n+extern void message_in_echo_area (), unmessage_in_echo_area ();\n+#endif /* !BUILDING_LIBRARY */\n \n+#endif /* !INFO_H */"}, {"sha": "4fc0419c5f90eaea392481239e8a786db2d9f91d", "filename": "texinfo/info/infodoc.c", "status": "modified", "additions": 263, "deletions": 264, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfodoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfodoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfodoc.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* infodoc.c -- Functions which build documentation nodes. */\n+/* infodoc.c -- Functions which build documentation nodes.\n+   $Id: infodoc.c,v 1.4 1997/07/25 21:08:40 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -33,9 +31,9 @@\n /* #define HELP_NODE_GETS_REGENERATED 1 */\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t\t  Info Help Windows\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                        Info Help Windows                         */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* The name of the node used in the help window. */\n@@ -49,10 +47,12 @@ static char *internal_info_help_node_contents = (char *)NULL;\n \n /* The static text which appears in the internal info help node. */\n static char *info_internal_help_text[] = {\n-  \"Basic Commands in Info Windows\",\n+  N_ (\"Basic Commands in Info Windows\"),\n   \"******************************\",\n   \"\",\n-  \"  h   Invoke the Info tutorial.\",\n+  \"  h          Invoke the Info tutorial.\",\n+  \"  CTRL-x 0   Quit this help.\",\n+  \"  q          Quit Info altogether.\",\n   \"\",\n   \"Selecting other nodes:\",\n   \"----------------------\",\n@@ -72,17 +72,16 @@ static char *info_internal_help_text[] = {\n   \"  b   Go to the beginning of this node.\",\n   \"  e   Go to the end of this node.\",\n   \"\",\n-  \"\\\"Advanced\\\" commands:\",\n+  \"Other commands:\",\n   \"--------------------\",\n-  \"  q   Quit Info.\",\n   \"  1   Pick first item in node's menu.\",\n   \"  2-9 Pick second ... ninth item in node's menu.\",\n   \"  0   Pick last item in node's menu.\",\n   \"  g   Move to node specified by name.\",\n   \"      You may include a filename as well, as in (FILENAME)NODENAME.\",\n   \"  s   Search through this Info file for a specified string,\",\n   \"      and select the node in which the next occurrence is found.\",\n-  (char *)NULL\n+  NULL\n };\n \n static char *where_is (), *where_is_internal ();\n@@ -97,70 +96,70 @@ dump_map_to_message_buffer (prefix, map)\n   for (i = 0; i < 256; i++)\n     {\n       if (map[i].type == ISKMAP)\n-\t{\n-\t  char *new_prefix, *keyname;\n+        {\n+          char *new_prefix, *keyname;\n \n-\t  keyname = pretty_keyname (i);\n-\t  new_prefix = (char *)\n-\t    xmalloc (3 + strlen (prefix) + strlen (keyname));\n-\t  sprintf (new_prefix, \"%s%s%s \", prefix, *prefix ? \" \" : \"\", keyname);\n+          keyname = pretty_keyname (i);\n+          new_prefix = (char *)\n+            xmalloc (3 + strlen (prefix) + strlen (keyname));\n+          sprintf (new_prefix, \"%s%s%s \", prefix, *prefix ? \" \" : \"\", keyname);\n \n-\t  dump_map_to_message_buffer (new_prefix, (Keymap)map[i].function);\n-\t  free (new_prefix);\n-\t}\n+          dump_map_to_message_buffer (new_prefix, (Keymap)map[i].function);\n+          free (new_prefix);\n+        }\n       else if (map[i].function)\n-\t{\n-\t  register int last;\n-\t  char *doc, *name;\n-\n-\t  doc = function_documentation (map[i].function);\n-\t  name = function_name (map[i].function);\n-\n-\t  if (!*doc)\n-\t    continue;\n-\n-\t  /* Find out if there is a series of identical functions, as in\n-\t     ea_insert (). */\n-\t  for (last = i + 1; last < 256; last++)\n-\t    if ((map[last].type != ISFUNC) ||\n-\t\t(map[last].function != map[i].function))\n-\t      break;\n-\n-\t  if (last - 1 != i)\n-\t    {\n-\t      printf_to_message_buffer\n-\t\t(\"%s%s .. \", prefix, pretty_keyname (i));\n-\t      printf_to_message_buffer\n-\t\t(\"%s%s\\t\", prefix, pretty_keyname (last - 1));\n-\t      i = last - 1;\n-\t    }\n-\t  else\n-\t    printf_to_message_buffer (\"%s%s\\t\", prefix, pretty_keyname (i));\n+        {\n+          register int last;\n+          char *doc, *name;\n+\n+          doc = function_documentation (map[i].function);\n+          name = function_name (map[i].function);\n+\n+          if (!*doc)\n+            continue;\n+\n+          /* Find out if there is a series of identical functions, as in\n+             ea_insert (). */\n+          for (last = i + 1; last < 256; last++)\n+            if ((map[last].type != ISFUNC) ||\n+                (map[last].function != map[i].function))\n+              break;\n+\n+          if (last - 1 != i)\n+            {\n+              printf_to_message_buffer\n+                (\"%s%s .. \", prefix, pretty_keyname (i));\n+              printf_to_message_buffer\n+                (\"%s%s\\t\", prefix, pretty_keyname (last - 1));\n+              i = last - 1;\n+            }\n+          else\n+            printf_to_message_buffer (\"%s%s\\t\", prefix, pretty_keyname (i));\n \n #if defined (NAMED_FUNCTIONS)\n-\t  /* Print the name of the function, and some padding before the\n-\t     documentation string is printed. */\n-\t  {\n-\t    int length_so_far;\n-\t    int desired_doc_start = 40;\t/* Must be multiple of 8. */\n-\n-\t    printf_to_message_buffer (\"(%s)\", name);\n-\t    length_so_far = message_buffer_length_this_line ();\n-\n-\t    if ((desired_doc_start + strlen (doc)) >= the_screen->width)\n-\t      printf_to_message_buffer (\"\\n     \");\n-\t    else\n-\t      {\n-\t\twhile (length_so_far < desired_doc_start)\n-\t\t  {\n-\t\t    printf_to_message_buffer (\"\\t\");\n-\t\t    length_so_far += character_width ('\\t', length_so_far);\n-\t\t  }\n-\t      }\n-\t  }\n+          /* Print the name of the function, and some padding before the\n+             documentation string is printed. */\n+          {\n+            int length_so_far;\n+            int desired_doc_start = 40; /* Must be multiple of 8. */\n+\n+            printf_to_message_buffer (\"(%s)\", name);\n+            length_so_far = message_buffer_length_this_line ();\n+\n+            if ((desired_doc_start + strlen (doc)) >= the_screen->width)\n+              printf_to_message_buffer (\"\\n     \");\n+            else\n+              {\n+                while (length_so_far < desired_doc_start)\n+                  {\n+                    printf_to_message_buffer (\"\\t\");\n+                    length_so_far += character_width ('\\t', length_so_far);\n+                  }\n+              }\n+          }\n #endif /* NAMED_FUNCTIONS */\n-\t  printf_to_message_buffer (\"%s\\n\", doc);\n-\t}\n+          printf_to_message_buffer (\"%s\\n\", doc);\n+        }\n     }\n }\n \n@@ -184,7 +183,7 @@ create_internal_info_help_node ()\n       initialize_message_buffer ();\n \n       for (i = 0; info_internal_help_text[i]; i++)\n-\tprintf_to_message_buffer (\"%s\\n\", info_internal_help_text[i]);\n+        printf_to_message_buffer (\"%s\\n\", info_internal_help_text[i]);\n \n       printf_to_message_buffer (\"---------------------\\n\\n\");\n       printf_to_message_buffer (\"The current search path is:\\n\");\n@@ -199,34 +198,34 @@ create_internal_info_help_node ()\n #if defined (NAMED_FUNCTIONS)\n       /* Get a list of the M-x commands which have no keystroke equivs. */\n       for (i = 0; function_doc_array[i].func; i++)\n-\t{\n-\t  VFunction *func = function_doc_array[i].func;\n-\n-\t  if ((!where_is_internal (info_keymap, func)) &&\n-\t      (!where_is_internal (echo_area_keymap, func)))\n-\t    {\n-\t      if (!printed_one_mx)\n-\t\t{\n-\t\t  printf_to_message_buffer (\"---------------------\\n\\n\");\n-\t\t  printf_to_message_buffer\n-\t\t    (\"The following commands can only be invoked via M-x:\\n\\n\");\n-\t\t  printed_one_mx = 1;\n-\t\t}\n-\n-\t      printf_to_message_buffer\n-\t\t(\"M-x %s\\n     %s\\n\",\n-\t\t function_doc_array[i].func_name,\n-\t\t replace_in_documentation (function_doc_array[i].doc));\n-\t    }\n-\t}\n+        {\n+          VFunction *func = function_doc_array[i].func;\n+\n+          if ((!where_is_internal (info_keymap, func)) &&\n+              (!where_is_internal (echo_area_keymap, func)))\n+            {\n+              if (!printed_one_mx)\n+                {\n+                  printf_to_message_buffer (\"---------------------\\n\\n\");\n+                  printf_to_message_buffer\n+                    (_(\"The following commands can only be invoked via M-x:\\n\\n\"));\n+                  printed_one_mx = 1;\n+                }\n+\n+              printf_to_message_buffer\n+                (\"M-x %s\\n     %s\\n\",\n+                 function_doc_array[i].func_name,\n+                 replace_in_documentation (function_doc_array[i].doc));\n+            }\n+        }\n \n       if (printed_one_mx)\n-\tprintf_to_message_buffer (\"\\n\");\n+        printf_to_message_buffer (\"\\n\");\n #endif /* NAMED_FUNCTIONS */\n \n       printf_to_message_buffer\n-\t(\"%s\", replace_in_documentation\n-\t (\"--- Use `\\\\[history-node]' or `\\\\[kill-node]' to exit ---\\n\"));\n+        (\"%s\", replace_in_documentation\n+         (_(\"--- Use `\\\\[history-node]' or `\\\\[kill-node]' to exit ---\\n\")));\n       node = message_buffer_to_node ();\n       internal_info_help_node_contents = node->contents;\n     }\n@@ -273,16 +272,16 @@ info_find_or_create_help_window ()\n       int max = 0;\n \n       for (window = windows; window; window = window->next)\n-\t{\n-\t  if (window->height > max)\n-\t    {\n-\t      max = window->height;\n-\t      eligible = window;\n-\t    }\n-\t}\n+        {\n+          if (window->height > max)\n+            {\n+              max = window->height;\n+              eligible = window;\n+            }\n+        }\n \n       if (!eligible)\n-\treturn ((WINDOW *)NULL);\n+        return ((WINDOW *)NULL);\n     }\n #if !defined (HELP_NODE_GETS_REGENERATED)\n   else\n@@ -297,36 +296,36 @@ info_find_or_create_help_window ()\n   if (!help_window)\n     {\n       /* Split the largest window into 2 windows, and show the help text\n-\t in that window. */\n+         in that window. */\n       if (eligible->height > 30)\n-\t{\n-\t  active_window = eligible;\n-\t  help_window = window_make_window (internal_info_help_node);\n-\t}\n+        {\n+          active_window = eligible;\n+          help_window = window_make_window (internal_info_help_node);\n+        }\n       else\n-\t{\n-\t  set_remembered_pagetop_and_point (active_window);\n-\t  window_set_node_of_window (active_window, internal_info_help_node);\n-\t  help_window = active_window;\n-\t}\n+        {\n+          set_remembered_pagetop_and_point (active_window);\n+          window_set_node_of_window (active_window, internal_info_help_node);\n+          help_window = active_window;\n+        }\n     }\n   else\n     {\n       /* Case where help node always gets regenerated, and we have an\n-\t existing window in which to place the node. */\n+         existing window in which to place the node. */\n       if (active_window != help_window)\n-\t{\n-\t  set_remembered_pagetop_and_point (active_window);\n-\t  active_window = help_window;\n-\t}\n+        {\n+          set_remembered_pagetop_and_point (active_window);\n+          active_window = help_window;\n+        }\n       window_set_node_of_window (active_window, internal_info_help_node);\n     }\n   remember_window_and_node (help_window, help_window->node);\n   return (help_window);\n }\n \n /* Create or move to the help window. */\n-DECLARE_INFO_COMMAND (info_get_help_window, \"Display help message\")\n+DECLARE_INFO_COMMAND (info_get_help_window, _(\"Display help message\"))\n {\n   WINDOW *help_window;\n \n@@ -344,7 +343,7 @@ DECLARE_INFO_COMMAND (info_get_help_window, \"Display help message\")\n \n /* Show the Info help node.  This means that the \"info\" file is installed\n    where it can easily be found on your system. */\n-DECLARE_INFO_COMMAND (info_get_info_help_node, \"Visit Info node `(info)Help'\")\n+DECLARE_INFO_COMMAND (info_get_info_help_node, _(\"Visit Info node `(info)Help'\"))\n {\n   NODE *node;\n   char *nodename;\n@@ -356,15 +355,15 @@ DECLARE_INFO_COMMAND (info_get_info_help_node, \"Visit Info node `(info)Help'\")\n \n     for (win = windows; win; win = win->next)\n       {\n-\tif (win->node && win->node->filename &&\n-\t    (strcasecmp\n-\t     (filename_non_directory (win->node->filename), \"info\") == 0) &&\n-\t    ((strcmp (win->node->nodename, \"Help\") == 0) ||\n-\t     (strcmp (win->node->nodename, \"Help-Small-Screen\") == 0)))\n-\t  {\n-\t    active_window = win;\n-\t    return;\n-\t  }\n+        if (win->node && win->node->filename &&\n+            (strcasecmp\n+             (filename_non_directory (win->node->filename), \"info\") == 0) &&\n+            ((strcmp (win->node->nodename, \"Help\") == 0) ||\n+             (strcmp (win->node->nodename, \"Help-Small-Screen\") == 0)))\n+          {\n+            active_window = win;\n+            return;\n+          }\n       }\n   }\n \n@@ -380,32 +379,32 @@ DECLARE_INFO_COMMAND (info_get_info_help_node, \"Visit Info node `(info)Help'\")\n   if (!node)\n     {\n       if (info_recent_file_error)\n-\tinfo_error (info_recent_file_error);\n+        info_error (info_recent_file_error);\n       else\n-\tinfo_error (CANT_FILE_NODE, \"Info\", nodename);\n+        info_error (CANT_FILE_NODE, \"Info\", nodename);\n     }\n   else\n     {\n       /* If the current window is very large (greater than 45 lines),\n-\t then split it and show the help node in another window.\n-\t Otherwise, use the current window. */\n+         then split it and show the help node in another window.\n+         Otherwise, use the current window. */\n \n       if (active_window->height > 45)\n-\tactive_window = window_make_window (node);\n+        active_window = window_make_window (node);\n       else\n-\t{\n-\t  set_remembered_pagetop_and_point (active_window);\n-\t  window_set_node_of_window (active_window, node);\n-\t}\n+        {\n+          set_remembered_pagetop_and_point (active_window);\n+          window_set_node_of_window (active_window, node);\n+        }\n \n       remember_window_and_node (active_window, node);\n     }\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t     Groveling Info Keymaps and Docs\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                   Groveling Info Keymaps and Docs                */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Return the documentation associated with the Info command FUNCTION. */\n@@ -468,7 +467,7 @@ key_documentation (key, map)\n     return ((char *)NULL);\n }\n \n-DECLARE_INFO_COMMAND (describe_key, \"Print documentation for KEY\")\n+DECLARE_INFO_COMMAND (describe_key, _(\"Print documentation for KEY\"))\n {\n   char keyname[50];\n   int keyname_index = 0;\n@@ -481,65 +480,65 @@ DECLARE_INFO_COMMAND (describe_key, \"Print documentation for KEY\")\n \n   while (1)\n     {\n-      message_in_echo_area (\"Describe key: %s\", keyname);\n+      message_in_echo_area (_(\"Describe key: %s\"), keyname);\n       keystroke = info_get_input_char ();\n       unmessage_in_echo_area ();\n \n       if (Meta_p (keystroke) && (!ISO_Latin_p || key < 160))\n-\t{\n-\t  if (map[ESC].type != ISKMAP)\n-\t    {\n-\t      window_message_in_echo_area\n-\t\t(\"ESC %s is undefined.\", pretty_keyname (UnMeta (keystroke)));\n-\t      return;\n-\t    }\n-\n-\t  strcpy (keyname + keyname_index, \"ESC \");\n-\t  keyname_index = strlen (keyname);\n-\t  keystroke = UnMeta (keystroke);\n-\t  map = (Keymap)map[ESC].function;\n-\t}\n+        {\n+          if (map[ESC].type != ISKMAP)\n+            {\n+              window_message_in_echo_area\n+                (_(\"ESC %s is undefined.\"), pretty_keyname (UnMeta (keystroke)));\n+              return;\n+            }\n+\n+          strcpy (keyname + keyname_index, \"ESC \");\n+          keyname_index = strlen (keyname);\n+          keystroke = UnMeta (keystroke);\n+          map = (Keymap)map[ESC].function;\n+        }\n \n       /* Add the printed representation of KEYSTROKE to our keyname. */\n       rep = pretty_keyname (keystroke);\n       strcpy (keyname + keyname_index, rep);\n       keyname_index = strlen (keyname);\n \n       if (map[keystroke].function == (VFunction *)NULL)\n-\t{\n-\t  message_in_echo_area (\"%s is undefined.\", keyname);\n-\t  return;\n-\t}\n+        {\n+          message_in_echo_area (_(\"%s is undefined.\"), keyname);\n+          return;\n+        }\n       else if (map[keystroke].type == ISKMAP)\n-\t{\n-\t  map = (Keymap)map[keystroke].function;\n-\t  strcat (keyname, \" \");\n-\t  keyname_index = strlen (keyname);\n-\t  continue;\n-\t}\n+        {\n+          map = (Keymap)map[keystroke].function;\n+          strcat (keyname, \" \");\n+          keyname_index = strlen (keyname);\n+          continue;\n+        }\n       else\n-\t{\n-\t  char *message, *fundoc, *funname = \"\";\n+        {\n+          char *message, *fundoc, *funname = \"\";\n \n #if defined (NAMED_FUNCTIONS)\n-\t  funname = function_name (map[keystroke].function);\n+          funname = function_name (map[keystroke].function);\n #endif /* NAMED_FUNCTIONS */\n \n-\t  fundoc = function_documentation (map[keystroke].function);\n+          fundoc = function_documentation (map[keystroke].function);\n \n-\t  message = (char *)xmalloc\n-\t    (10 + strlen (keyname) + strlen (fundoc) + strlen (funname));\n+          message = (char *)xmalloc\n+            (10 + strlen (keyname) + strlen (fundoc) + strlen (funname));\n \n #if defined (NAMED_FUNCTIONS)\n-\t  sprintf (message, \"%s (%s): %s.\", keyname, funname, fundoc);\n+          sprintf (message, \"%s (%s): %s.\", keyname, funname, fundoc);\n #else\n-\t  sprintf (message, \"%s is defined to %s.\", keyname, fundoc);\n+          sprintf (message, _(\"%s is defined to %s.\"), keyname, fundoc);\n #endif /* !NAMED_FUNCTIONS */\n \n-\t  window_message_in_echo_area (\"%s\", message);\n-\t  free (message);\n-\t  break;\n-\t}\n+          window_message_in_echo_area (\"%s\", message);\n+          free (message);\n+          break;\n+        }\n     }\n }\n \n@@ -565,28 +564,28 @@ pretty_keyname (key)\n   else if (Control_p (key))\n     {\n       switch (key)\n-\t{\n-\tcase '\\n': rep = \"LFD\"; break;\n-\tcase '\\t': rep = \"TAB\"; break;\n-\tcase '\\r': rep = \"RET\"; break;\n-\tcase ESC:  rep = \"ESC\"; break;\n-\n-\tdefault:\n-\t  sprintf (rep_buffer, \"C-%c\", UnControl (key));\n-\t  rep = rep_buffer;\n-\t}\n+        {\n+        case '\\n': rep = \"LFD\"; break;\n+        case '\\t': rep = \"TAB\"; break;\n+        case '\\r': rep = \"RET\"; break;\n+        case ESC:  rep = \"ESC\"; break;\n+\n+        default:\n+          sprintf (rep_buffer, \"C-%c\", UnControl (key));\n+          rep = rep_buffer;\n+        }\n     }\n   else\n     {\n       switch (key)\n-\t{\n-\tcase ' ': rep = \"SPC\"; break;\n-\tcase DEL: rep = \"DEL\"; break;\n-\tdefault:\n-\t  rep_buffer[0] = key;\n-\t  rep_buffer[1] = '\\0';\n-\t  rep = rep_buffer;\n-\t}\n+        {\n+        case ' ': rep = \"SPC\"; break;\n+        case DEL: rep = \"DEL\"; break;\n+        default:\n+          rep_buffer[0] = key;\n+          rep_buffer[1] = '\\0';\n+          rep = rep_buffer;\n+        }\n     }\n   return (rep);\n }\n@@ -609,39 +608,39 @@ replace_in_documentation (string)\n     {\n       /* Is this the start of a replaceable function name? */\n       if (string[i] == '\\\\' && string[i + 1] == '[')\n-\t{\n-\t  char *fun_name, *rep;\n-\t  VFunction *function;\n-\n-\t  /* Copy in the old text. */\n-\t  strncpy (result + next, string + start, i - start);\n-\t  next += (i - start);\n-\t  start = i + 2;\n-\n-\t  /* Move to the end of the function name. */\n-\t  for (i = start; string[i] && (string[i] != ']'); i++);\n-\n-\t  fun_name = (char *)xmalloc (1 + i - start);\n-\t  strncpy (fun_name, string + start, i - start);\n-\t  fun_name[i - start] = '\\0';\n-\n-\t  /* Find a key which invokes this function in the info_keymap. */\n-\t  function = named_function (fun_name);\n-\n-\t  /* If the internal documentation string fails, there is a \n-\t     serious problem with the associated command's documentation.\n-\t     We croak so that it can be fixed immediately. */\n-\t  if (!function)\n-\t    abort ();\n-\n-\t  rep = where_is (info_keymap, function);\n-\t  strcpy (result + next, rep);\n-\t  next = strlen (result);\n-\n-\t  start = i;\n-\t  if (string[i])\n-\t    start++;\n-\t}\n+        {\n+          char *fun_name, *rep;\n+          VFunction *function;\n+\n+          /* Copy in the old text. */\n+          strncpy (result + next, string + start, i - start);\n+          next += (i - start);\n+          start = i + 2;\n+\n+          /* Move to the end of the function name. */\n+          for (i = start; string[i] && (string[i] != ']'); i++);\n+\n+          fun_name = (char *)xmalloc (1 + i - start);\n+          strncpy (fun_name, string + start, i - start);\n+          fun_name[i - start] = '\\0';\n+\n+          /* Find a key which invokes this function in the info_keymap. */\n+          function = named_function (fun_name);\n+\n+          /* If the internal documentation string fails, there is a \n+             serious problem with the associated command's documentation.\n+             We croak so that it can be fixed immediately. */\n+          if (!function)\n+            abort ();\n+\n+          rep = where_is (info_keymap, function);\n+          strcpy (result + next, rep);\n+          next = strlen (result);\n+\n+          start = i;\n+          if (string[i])\n+            start++;\n+        }\n     }\n   strcpy (result + next, string + start);\n   return (result);\n@@ -674,7 +673,7 @@ where_is (map, function)\n       name = function_name (function);\n \n       if (name)\n-\tsprintf (where_is_rep, \"M-x %s\", name);\n+        sprintf (where_is_rep, \"M-x %s\", name);\n \n       rep = where_is_rep;\n     }\n@@ -694,29 +693,29 @@ where_is_internal (map, function)\n   for (i = 0; i < 256; i++)\n     if ((map[i].type == ISFUNC) && map[i].function == function)\n       {\n-\tsprintf (where_is_rep + where_is_rep_index, \"%s\", pretty_keyname (i));\n-\treturn (where_is_rep);\n+        sprintf (where_is_rep + where_is_rep_index, \"%s\", pretty_keyname (i));\n+        return (where_is_rep);\n       }\n \n   /* Okay, search subsequent maps for this function. */\n   for (i = 0; i < 256; i++)\n     {\n       if (map[i].type == ISKMAP)\n-\t{\n-\t  int saved_index = where_is_rep_index;\n-\t  char *rep;\n+        {\n+          int saved_index = where_is_rep_index;\n+          char *rep;\n \n-\t  sprintf (where_is_rep + where_is_rep_index, \"%s \",\n-\t\t   pretty_keyname (i));\n+          sprintf (where_is_rep + where_is_rep_index, \"%s \",\n+                   pretty_keyname (i));\n \n-\t  where_is_rep_index = strlen (where_is_rep);\n-\t  rep = where_is_internal ((Keymap)map[i].function, function);\n+          where_is_rep_index = strlen (where_is_rep);\n+          rep = where_is_internal ((Keymap)map[i].function, function);\n \n-\t  if (rep)\n-\t    return (where_is_rep);\n+          if (rep)\n+            return (where_is_rep);\n \n-\t  where_is_rep_index = saved_index;\n-\t}\n+          where_is_rep_index = saved_index;\n+        }\n     }\n \n   return ((char *)NULL);\n@@ -729,7 +728,7 @@ DECLARE_INFO_COMMAND (info_where_is,\n {\n   char *command_name;\n \n-  command_name = read_function_name (\"Where is command: \", window);\n+  command_name = read_function_name (_(\"Where is command: \"), window);\n \n   if (!command_name)\n     {\n@@ -744,27 +743,27 @@ DECLARE_INFO_COMMAND (info_where_is,\n       function = named_function (command_name);\n \n       if (function)\n-\t{\n-\t  char *location;\n-\n-\t  location = where_is (active_window->keymap, function);\n-\n-\t  if (!location)\n-\t    {\n-\t      info_error (\"`%s' is not on any keys\", command_name);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (strncmp (location, \"M-x \", 4) == 0)\n-\t\twindow_message_in_echo_area\n-\t\t  (\"%s can only be invoked via %s.\", command_name, location);\n-\t      else\n-\t\twindow_message_in_echo_area\n-\t\t  (\"%s can be invoked via %s.\", command_name, location);\n-\t    }\n-\t}\n+        {\n+          char *location;\n+\n+          location = where_is (active_window->keymap, function);\n+\n+          if (!location)\n+            {\n+              info_error (_(\"`%s' is not on any keys\"), command_name);\n+            }\n+          else\n+            {\n+              if (strncmp (location, \"M-x \", 4) == 0)\n+                window_message_in_echo_area\n+                  (_(\"%s can only be invoked via %s.\"), command_name, location);\n+              else\n+                window_message_in_echo_area\n+                  (_(\"%s can be invoked via %s.\"), command_name, location);\n+            }\n+        }\n       else\n-\tinfo_error (\"There is no function named `%s'\", command_name);\n+        info_error (_(\"There is no function named `%s'\"), command_name);\n     }\n \n   free (command_name);"}, {"sha": "7591283dc5923e04be64a1c701c46d605cfcf0f0", "filename": "texinfo/info/infomap.c", "status": "modified", "additions": 117, "deletions": 23, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfomap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfomap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfomap.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* infomap.c -- Keymaps for Info. */\n+/* infomap.c -- Keymaps for Info.\n+   $Id: infomap.c,v 1.7 1997/07/31 20:37:32 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,10 +19,10 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include \"stdio.h\"\n-#include \"ctype.h\"\n+#include \"info.h\"\n #include \"infomap.h\"\n #include \"funs.h\"\n+#include \"terminal.h\"\n \n /* Return a new keymap which has all the uppercase letters mapped to run\n    the function info_do_lowercase_version (). */\n@@ -82,16 +80,63 @@ keymap_discard_keymap (map)\n   for (i = 0; i < 256; i++)\n     {\n       switch (map[i].type)\n-\t{\n-\tcase ISFUNC:\n-\t  break;\n+        {\n+        case ISFUNC:\n+          break;\n \n-\tcase ISKMAP:\n-\t  keymap_discard_keymap ((Keymap)map[i].function);\n-\t  break;\n+        case ISKMAP:\n+          keymap_discard_keymap ((Keymap)map[i].function);\n+          break;\n \n-\t}\n+        }\n+    }\n+}\n+\n+/* Conditionally bind key sequence. */\n+int\n+keymap_bind_keyseq (map, keyseq, keyentry)\n+     Keymap map;\n+     const unsigned char *keyseq;\n+     KEYMAP_ENTRY *keyentry;\n+{\n+  register Keymap m = map;\n+  register const unsigned char *s = keyseq;\n+  register int c;\n+\n+  if (s == NULL || *s == '\\0') return 0;\n+\n+  while ((c = *s++) != '\\0')\n+    {\n+      switch (m[c].type)\n+        {\n+        case ISFUNC:\n+          if (!(m[c].function == NULL ||\n+                (m != map && m[c].function == info_do_lowercase_version)))\n+            return 0;\n+\n+          if (*s != '\\0')\n+            {\n+              m[c].type = ISKMAP;\n+              m[c].function = (VFunction *)keymap_make_keymap ();\n+            }\n+          break;\n+\n+        case ISKMAP:\n+          if (*s == '\\0')\n+            return 0;\n+          break;\n+        }\n+      if (*s != '\\0')\n+        {\n+          m = (Keymap)m[c].function;\n+        }\n+      else\n+        {\n+          m[c] = *keyentry;\n+        }\n     }\n+\n+  return 1;\n }\n \n /* Initialize the standard info keymaps. */\n@@ -117,15 +162,15 @@ initialize_info_keymaps ()\n       echo_area_keymap[ESC].function = (VFunction *)keymap_make_keymap ();\n       echo_area_keymap[Control ('x')].type = ISKMAP;\n       echo_area_keymap[Control ('x')].function =\n-\t(VFunction *)keymap_make_keymap ();\n+        (VFunction *)keymap_make_keymap ();\n     }\n \n   /* Bind numeric arg functions for both echo area and info window maps. */\n   for (i = '0'; i < '9' + 1; i++)\n     {\n       ((Keymap) info_keymap[ESC].function)[i].function =\n-\t((Keymap) echo_area_keymap[ESC].function)[i].function =\n-\t  info_add_digit_to_numeric_arg;\n+        ((Keymap) echo_area_keymap[ESC].function)[i].function =\n+          info_add_digit_to_numeric_arg;\n     }\n   ((Keymap) info_keymap[ESC].function)['-'].function =\n     ((Keymap) echo_area_keymap[ESC].function)['-'].function =\n@@ -182,6 +227,31 @@ initialize_info_keymaps ()\n   map['o'].function = info_next_window;\n   map[DEL].function = ea_backward_kill_line;\n \n+  /* Arrow key bindings for echo area keymaps.  It seems that some\n+     terminals do not match their termcap entries, so it's best to just\n+     define everything with both of the usual prefixes.  */\n+  map = echo_area_keymap;\n+  keymap_bind_keyseq (map, term_ku, &map[Control ('p')]); /* up */\n+  keymap_bind_keyseq (map, \"\\033OA\", &map[Control ('p')]);\n+  keymap_bind_keyseq (map, \"\\033[A\", &map[Control ('p')]);\n+  keymap_bind_keyseq (map, term_kd, &map[Control ('n')]); /* down */\n+  keymap_bind_keyseq (map, \"\\033OB\", &map[Control ('n')]);\n+  keymap_bind_keyseq (map, \"\\033[B\", &map[Control ('n')]);\n+  keymap_bind_keyseq (map, term_kr, &map[Control ('f')]); /* right */\n+  keymap_bind_keyseq (map, \"\\033OC\", &map[Control ('f')]);\n+  keymap_bind_keyseq (map, \"\\033[C\", &map[Control ('f')]);\n+  keymap_bind_keyseq (map, term_kl, &map[Control ('b')]); /* left */\n+  keymap_bind_keyseq (map, \"\\033OD\", &map[Control ('b')]);\n+  keymap_bind_keyseq (map, \"\\033[D\", &map[Control ('b')]);\n+\n+  map = (Keymap)echo_area_keymap[ESC].function;\n+  keymap_bind_keyseq (map, term_kl, &map['b']); /* left */\n+  keymap_bind_keyseq (map, \"\\033OA\", &map['b']);\n+  keymap_bind_keyseq (map, \"\\033[A\", &map['b']);\n+  keymap_bind_keyseq (map, term_kr, &map['f']); /* right */\n+  keymap_bind_keyseq (map, \"\\033OB\", &map['f']);\n+  keymap_bind_keyseq (map, \"\\033[B\", &map['f']);\n+\n   /* Bind commands for Info window keymaps. */\n   map = info_keymap;\n   map[TAB].function = info_move_to_next_xref;\n@@ -264,11 +334,35 @@ initialize_info_keymaps ()\n   map['o'].function = info_next_window;\n   map['t'].function = info_tile_windows;\n   map['w'].function = info_toggle_wrap;\n-}\n \n-/* Strings which represent the sequence of characters that the arrow keys\n-   produce.  If these keys begin with ESC, and the second character of the\n-   sequence does not conflict with an existing binding in the Meta keymap,\n-   then bind the keys to do what C-p, C-n, C-f, and C-b do. */\n-extern char *term_ku, *term_kd, *term_kr, *term_kl;\n+  /* Arrow key bindings for Info windows keymap. */\n+  map = info_keymap;\n+  keymap_bind_keyseq (map, term_kN, &map[Control ('v')]); /* pagedown */\n+  keymap_bind_keyseq (map, term_ku, &map[Control ('p')]); /* up */\n+  keymap_bind_keyseq (map, \"\\033OA\", &map[Control ('p')]);\n+  keymap_bind_keyseq (map, \"\\033[A\", &map[Control ('p')]);\n+  keymap_bind_keyseq (map, term_kd, &map[Control ('n')]); /* down */\n+  keymap_bind_keyseq (map, \"\\033OB\", &map[Control ('n')]);\n+  keymap_bind_keyseq (map, \"\\033[B\", &map[Control ('n')]);\n+  keymap_bind_keyseq (map, term_kr, &map[Control ('f')]); /* right */\n+  keymap_bind_keyseq (map, \"\\033OC\", &map[Control ('f')]);\n+  keymap_bind_keyseq (map, \"\\033[C\", &map[Control ('f')]);\n+  keymap_bind_keyseq (map, term_kl, &map[Control ('b')]); /* left */\n+  keymap_bind_keyseq (map, \"\\033OD\", &map[Control ('b')]);\n+  keymap_bind_keyseq (map, \"\\033[D\", &map[Control ('b')]);\n \n+  map = (Keymap)info_keymap[ESC].function;\n+  keymap_bind_keyseq (map, term_kl, &map['b']); /* left */\n+  keymap_bind_keyseq (map, \"\\033OA\", &map['b']);\n+  keymap_bind_keyseq (map, \"\\033[A\", &map['b']);\n+  keymap_bind_keyseq (map, term_kr, &map['f']); /* right */\n+  keymap_bind_keyseq (map, \"\\033OB\", &map['f']);\n+  keymap_bind_keyseq (map, \"\\033[B\", &map['f']);\n+  keymap_bind_keyseq (map, term_kN, &map[Control ('v')]); /* pagedown */\n+\n+  /* The alternative to this definition of a `main map' key in the\n+     `ESC map' section, is something like:\n+    keymap_bind_keyseq (map, term_kP, &((KeyMap)map[ESC].function).map['v']);\n+  */\n+  keymap_bind_keyseq (info_keymap/*sic*/, term_kP, &map['v']); /* pageup */\n+}"}, {"sha": "65968cbdff471786146cec47409e2fe21c729afe", "filename": "texinfo/info/infomap.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfomap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Finfomap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Finfomap.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -21,14 +21,14 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_INFOMAP_H_)\n-#define _INFOMAP_H_\n+#ifndef INFOMAP_H\n+#define INFOMAP_H\n \n-#include \"general.h\"\n+#include \"info.h\"\n \n #define ESC '\\033'\n #define DEL '\\177'\n-#define TAB '\\011'\t\n+#define TAB '\\011'      \n #define RET '\\r'\n #define LFD '\\n'\n #define SPC ' '\n@@ -79,4 +79,4 @@ extern void keymap_discard_keymap ();\n /* Initialize the info keymaps. */\n extern void initialize_info_keymaps ();\n \n-#endif /* !_INFOMAP_H_ */\n+#endif /* not INFOMAP_H */"}, {"sha": "28b8e80e730b400cb11c1e746d48c1e15b63ab34", "filename": "texinfo/info/m-x.c", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fm-x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fm-x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fm-x.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* m-x.c -- Meta-X minibuffer reader. */\n+/* m-x.c -- Meta-X minibuffer reader.\n+   $Id: m-x.c,v 1.5 1997/07/24 21:28:00 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -24,9 +22,9 @@\n #include \"info.h\"\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t       Reading Named Commands\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                     Reading Named Commands                       */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Read the name of an Info function in the echo area and return the\n@@ -49,12 +47,12 @@ read_function_name (prompt, window)\n       REFERENCE *entry;\n \n       entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));\n-      entry->label = strdup (function_doc_array[i].func_name);\n+      entry->label = xstrdup (function_doc_array[i].func_name);\n       entry->nodename = (char *)NULL;\n       entry->filename = (char *)NULL;\n \n       add_pointer_to_array\n-\t(entry, array_index, array, array_slots, 200, REFERENCE *);\n+        (entry, array_index, array, array_slots, 200, REFERENCE *);\n     }\n \n   line = info_read_completing_in_echo_area (window, prompt, array);\n@@ -68,11 +66,11 @@ read_function_name (prompt, window)\n }\n \n DECLARE_INFO_COMMAND (describe_command,\n-   \"Read the name of an Info command and describe it\")\n+   _(\"Read the name of an Info command and describe it\"))\n {\n   char *line;\n \n-  line = read_function_name (\"Describe command: \", window);\n+  line = read_function_name (_(\"Describe command: \"), window);\n \n   if (!line)\n     {\n@@ -83,22 +81,19 @@ DECLARE_INFO_COMMAND (describe_command,\n   /* Describe the function named in \"LINE\". */\n   if (*line)\n     {\n-      char *fundoc;\n-      VFunction *fun;\n-\n-      fun = named_function (line);\n+      VFunction *fun = named_function (line);\n \n       if (!fun)\n-\treturn;\n+        return;\n \n       window_message_in_echo_area (\"%s: %s.\",\n-\t\t\t\t   line, function_documentation (fun));\n+                                   line, function_documentation (fun));\n     }\n   free (line);\n }\n \n DECLARE_INFO_COMMAND (info_execute_command,\n-   \"Read a command name in the echo area and execute it\")\n+   _(\"Read a command name in the echo area and execute it\"))\n {\n   char *line;\n \n@@ -133,11 +128,11 @@ DECLARE_INFO_COMMAND (info_execute_command,\n     VFunction *function;\n \n     if ((active_window != the_echo_area) &&\n-\t(strncmp (line, \"echo-area-\", 10) == 0))\n+        (strncmp (line, \"echo-area-\", 10) == 0))\n       {\n-\tfree (line);\n-\tinfo_error (\"Cannot execute an `echo-area' command here.\");\n-\treturn;\n+        free (line);\n+        info_error (_(\"Cannot execute an `echo-area' command here.\"));\n+        return;\n       }\n \n     function = named_function (line);\n@@ -152,7 +147,7 @@ DECLARE_INFO_COMMAND (info_execute_command,\n \n /* Okay, now that we have M-x, let the user set the screen height. */\n DECLARE_INFO_COMMAND (set_screen_height,\n-  \"Set the height of the displayed window\")\n+  _(\"Set the height of the displayed window\"))\n {\n   int new_height;\n \n@@ -165,24 +160,24 @@ DECLARE_INFO_COMMAND (set_screen_height,\n \n       new_height = screenheight;\n \n-      sprintf (prompt, \"Set screen height to (%d): \", new_height);\n+      sprintf (prompt, _(\"Set screen height to (%d): \"), new_height);\n \n       line = info_read_in_echo_area (window, prompt);\n \n       /* If the user aborted, do that now. */\n       if (!line)\n-\t{\n-\t  info_abort_key (active_window, count, 0);\n-\t  return;\n-\t}\n+        {\n+          info_abort_key (active_window, count, 0);\n+          return;\n+        }\n \n       /* Find out what the new height is supposed to be. */\n       if (*line)\n-\tnew_height = atoi (line);\n+        new_height = atoi (line);\n \n       /* Clear the echo area if it isn't active. */\n       if (!echo_area_is_active)\n-\twindow_clear_echo_area ();\n+        window_clear_echo_area ();\n \n       free (line);\n     }"}, {"sha": "c88663fcddf1239105ba2fb581736fa614be16da", "filename": "texinfo/info/makedoc.c", "status": "modified", "additions": 124, "deletions": 139, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fmakedoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fmakedoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fmakedoc.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* makedoc.c -- Make DOC.C and FUNS.H from input files. */\n+/* makedoc.c -- Make doc.c and funs.h from input files.\n+   $Id: makedoc.c,v 1.4 1997/07/15 18:35:59 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -26,24 +27,8 @@\n    a header file which describes the contents.  This only does the functions\n    declared with DECLARE_INFO_COMMAND. */\n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <sys/types.h>\n-#if defined (HAVE_SYS_FILE_H)\n-#include <sys/file.h>\n-#endif /* HAVE_SYS_FILE_H */\n-#include <sys/stat.h>\n-#include \"general.h\"\n-\n-#if !defined (O_RDONLY)\n-#if defined (HAVE_SYS_FCNTL_H)\n-#include <sys/fcntl.h>\n-#else /* !HAVE_SYS_FCNTL_H */\n-#include <fcntl.h>\n-#endif /* !HAVE_SYS_FCNTL_H */\n-#endif /* !O_RDONLY */\n-\n-extern void *xmalloc (), *xrealloc ();\n+#include \"info.h\"\n+\n static void fatal_file_error ();\n \n /* Name of the header file which receives the declarations of functions. */\n@@ -79,15 +64,15 @@ static char *doc_header_1[] = {\n /* How to remember the locations of the functions found so that Emacs\n    can use the information in a tag table. */\n typedef struct {\n-  char *name;\t\t\t/* Name of the tag. */\n-  int line;\t\t\t/* Line number at which it appears. */\n-  long char_offset;\t\t/* Character offset at which it appears. */\n+  char *name;                   /* Name of the tag. */\n+  int line;                     /* Line number at which it appears. */\n+  long char_offset;             /* Character offset at which it appears. */\n } EMACS_TAG;\n \n typedef struct {\n-  char *filename;\t\t/* Name of the file containing entries. */\n-  long entrylen;\t\t/* Total number of characters in tag block. */\n-  EMACS_TAG **entries;\t\t/* Entries found in FILENAME. */\n+  char *filename;               /* Name of the file containing entries. */\n+  long entrylen;                /* Total number of characters in tag block. */\n+  EMACS_TAG **entries;          /* Entries found in FILENAME. */\n   int entries_index;\n   int entries_slots;\n } EMACS_TAG_BLOCK;\n@@ -114,8 +99,8 @@ main (argc, argv)\n   for (i = 1; i < argc; i++)\n     if (strcmp (argv[i], \"-tags\") == 0)\n       {\n-\ttags_only++;\n-\tbreak;\n+        tags_only++;\n+        break;\n       }\n \n   if (tags_only)\n@@ -128,8 +113,8 @@ main (argc, argv)\n   doc_stream = must_fopen (doc_filename, \"w\");\n \n   fprintf (funs_stream,\n-\t   \"/* %s -- Generated declarations for Info commands. */\\n\",\n-\t   funs_filename);\n+           \"/* %s -- Generated declarations for Info commands. */\\n\",\n+           funs_filename);\n \n   for (i = 0; doc_header[i]; i++)\n     {\n@@ -138,7 +123,7 @@ main (argc, argv)\n     }\n \n   fprintf (doc_stream,\n-\t   \"   Source files groveled to make this file include:\\n\\n\");\n+           _(\"   Source files groveled to make this file include:\\n\\n\"));\n \n   for (i = 1; i < argc; i++)\n     fprintf (doc_stream, \"\\t%s\\n\", argv[i]);\n@@ -155,17 +140,17 @@ main (argc, argv)\n       curfile = argv[i];\n \n       if (*curfile == '-')\n-\tcontinue;\n+        continue;\n \n       fprintf (doc_stream, \"/* Commands found in \\\"%s\\\". */\\n\", curfile);\n       fprintf (funs_stream, \"\\n/* Functions declared in \\\"%s\\\". */\\n\",\n-\t       curfile);\n+               curfile);\n \n       process_one_file (curfile, doc_stream, funs_stream);\n     }\n \n   fprintf (doc_stream,\n-\t   \"   { (VFunction *)NULL, (char *)NULL, (char *)NULL }\\n};\\n\");\n+           \"   { (VFunction *)NULL, (char *)NULL, (char *)NULL }\\n};\\n\");\n \n   fclose (funs_stream);\n   fclose (doc_stream);\n@@ -195,25 +180,25 @@ maybe_dump_tags (stream)\n \n       /* Calculate the length of the dumped block first. */\n       for (j = 0; j < block->entries_index; j++)\n-\t{\n-\t  char digits[30];\n-\t  etag = block->entries[j];\n-\t  block_len += 3 + strlen (etag->name);\n-\t  sprintf (digits, \"%d,%d\", etag->line, etag->char_offset);\n-\t  block_len += strlen (digits);\n-\t}\n+        {\n+          char digits[30];\n+          etag = block->entries[j];\n+          block_len += 3 + strlen (etag->name);\n+          sprintf (digits, \"%d,%ld\", etag->line, etag->char_offset);\n+          block_len += strlen (digits);\n+        }\n \n       /* Print out the defining line. */\n-      fprintf (stream, \"\\f\\n%s,%d\\n\", block->filename, block_len);\n+      fprintf (stream, \"\\f\\n%s,%ld\\n\", block->filename, block_len);\n \n       /* Print out the individual tags. */\n       for (j = 0; j < block->entries_index; j++)\n-\t{\n-\t  etag = block->entries[j];\n+        {\n+          etag = block->entries[j];\n \n-\t  fprintf (stream, \"%s,\\177%d,%d\\n\",\n-\t\t   etag->name, etag->line, etag->char_offset);\n-\t}\n+          fprintf (stream, \"%s,\\177%d,%ld\\n\",\n+                   etag->name, etag->line, etag->char_offset);\n+        }\n     }\n }\n \n@@ -226,7 +211,7 @@ make_emacs_tag_block (filename)\n   EMACS_TAG_BLOCK *block;\n \n   block = (EMACS_TAG_BLOCK *)xmalloc (sizeof (EMACS_TAG_BLOCK));\n-  block->filename = strdup (filename);\n+  block->filename = xstrdup (filename);\n   block->entrylen = 0;\n   block->entries = (EMACS_TAG **)NULL;\n   block->entries_index = 0;\n@@ -248,7 +233,7 @@ add_tag_to_block (block, name, line, char_offset)\n   tag->line = line;\n   tag->char_offset = char_offset;\n   add_pointer_to_array (tag, block->entries_index, block->entries,\n-\t\t\tblock->entries_slots, 50, EMACS_TAG *);\n+                        block->entries_slots, 50, EMACS_TAG *);\n }\n \n /* Read the file represented by FILENAME into core, and search it for Info\n@@ -297,51 +282,51 @@ process_one_file (filename, doc_stream, funs_stream)\n #endif /* NAMED_FUNCTIONS */\n \n       for (; offset < (file_size - decl_len); offset++)\n-\t{\n-\t  if (buffer[offset] == '\\n')\n-\t    {\n-\t      line_number++;\n-\t      line_start = offset + 1;\n-\t    }\n-\n-\t  if (strncmp (buffer + offset, decl_str, decl_len) == 0)\n-\t    {\n-\t      offset += decl_len;\n-\t      point = offset;\n-\t      break;\n-\t    }\n-\t}\n+        {\n+          if (buffer[offset] == '\\n')\n+            {\n+              line_number++;\n+              line_start = offset + 1;\n+            }\n+\n+          if (strncmp (buffer + offset, decl_str, decl_len) == 0)\n+            {\n+              offset += decl_len;\n+              point = offset;\n+              break;\n+            }\n+        }\n \n       if (!point)\n-\tbreak;\n+        break;\n \n       /* Skip forward until we find the open paren. */\n       while (point < file_size)\n-\t{\n-\t  if (buffer[point] == '\\n')\n-\t    {\n-\t      line_number++;\n-\t      line_start = point + 1;\n-\t    }\n-\t  else if (buffer[point] == '(')\n-\t    break;\n-\n-\t  point++;\n-\t}\n+        {\n+          if (buffer[point] == '\\n')\n+            {\n+              line_number++;\n+              line_start = point + 1;\n+            }\n+          else if (buffer[point] == '(')\n+            break;\n+\n+          point++;\n+        }\n \n       while (point++ < file_size)\n-\t{\n-\t  if (!whitespace_or_newline (buffer[point]))\n-\t    break;\n-\t  else if (buffer[point] == '\\n')\n-\t    {\n-\t      line_number++;\n-\t      line_start = point + 1;\n-\t    }\n-\t}\n+        {\n+          if (!whitespace_or_newline (buffer[point]))\n+            break;\n+          else if (buffer[point] == '\\n')\n+            {\n+              line_number++;\n+              line_start = point + 1;\n+            }\n+        }\n \n       if (point >= file_size)\n-\tbreak;\n+        break;\n \n       /* Now looking at name of function.  Get it. */\n       for (offset = point; buffer[offset] != ','; offset++);\n@@ -351,83 +336,83 @@ process_one_file (filename, doc_stream, funs_stream)\n \n       /* Remember this tag in the current block. */\n       {\n-\tchar *tag_name;\n+        char *tag_name;\n \n-\ttag_name = (char *)xmalloc (1 + (offset - line_start));\n-\tstrncpy (tag_name, buffer + line_start, offset - line_start);\n-\ttag_name[offset - line_start] = '\\0';\n-\tadd_tag_to_block (block, tag_name, line_number, point);\n+        tag_name = (char *)xmalloc (1 + (offset - line_start));\n+        strncpy (tag_name, buffer + line_start, offset - line_start);\n+        tag_name[offset - line_start] = '\\0';\n+        add_tag_to_block (block, tag_name, line_number, point);\n       }\n \n #if defined (NAMED_FUNCTIONS)\n       /* Generate the user-visible function name from the function's name. */\n       {\n-\tregister int i;\n-\tchar *name_start;\n+        register int i;\n+        char *name_start;\n \n-\tname_start = func;\n+        name_start = func;\n \n-\tif (strncmp (name_start, \"info_\", 5) == 0)\n-\t  name_start += 5;\n+        if (strncmp (name_start, \"info_\", 5) == 0)\n+          name_start += 5;\n \n-\tfunc_name = strdup (name_start);\n+        func_name = xstrdup (name_start);\n \n-\t/* Fix up \"ea\" commands. */\n-\tif (strncmp (func_name, \"ea_\", 3) == 0)\n-\t  {\n-\t    char *temp_func_name;\n+        /* Fix up \"ea\" commands. */\n+        if (strncmp (func_name, \"ea_\", 3) == 0)\n+          {\n+            char *temp_func_name;\n \n-\t    temp_func_name = (char *)xmalloc (10 + strlen (func_name));\n-\t    strcpy (temp_func_name, \"echo_area_\");\n-\t    strcat (temp_func_name, func_name + 3);\n-\t    free (func_name);\n-\t    func_name = temp_func_name;\n-\t  }\n+            temp_func_name = (char *)xmalloc (10 + strlen (func_name));\n+            strcpy (temp_func_name, \"echo_area_\");\n+            strcat (temp_func_name, func_name + 3);\n+            free (func_name);\n+            func_name = temp_func_name;\n+          }\n \n-\tfor (i = 0; func_name[i]; i++)\n-\t  if (func_name[i] == '_')\n-\t    func_name[i] = '-';\n+        for (i = 0; func_name[i]; i++)\n+          if (func_name[i] == '_')\n+            func_name[i] = '-';\n       }\n #endif /* NAMED_FUNCTIONS */\n \n       /* Find doc string. */\n       point = offset + 1;\n \n       while (point < file_size)\n-\t{\n-\t  if (buffer[point] == '\\n')\n-\t    {\n-\t      line_number++;\n-\t      line_start = point + 1;\n-\t    }\n-\n-\t  if (buffer[point] == '\"')\n-\t    break;\n-\t  else\n-\t    point++;\n-\t}\n+        {\n+          if (buffer[point] == '\\n')\n+            {\n+              line_number++;\n+              line_start = point + 1;\n+            }\n+\n+          if (buffer[point] == '\"')\n+            break;\n+          else\n+            point++;\n+        }\n \n       offset = point + 1;\n \n       while (offset < file_size)\n-\t{\n-\t  if (buffer[offset] == '\\n')\n-\t    {\n-\t      line_number++;\n-\t      line_start = offset + 1;\n-\t    }\n-\n-\t  if (buffer[offset] == '\\\\')\n-\t    offset += 2;\n-\t  else if (buffer[offset] == '\"')\n-\t    break;\n-\t  else\n-\t    offset++;\n-\t}\n+        {\n+          if (buffer[offset] == '\\n')\n+            {\n+              line_number++;\n+              line_start = offset + 1;\n+            }\n+\n+          if (buffer[offset] == '\\\\')\n+            offset += 2;\n+          else if (buffer[offset] == '\"')\n+            break;\n+          else\n+            offset++;\n+        }\n \n       offset++;\n       if (offset >= file_size)\n-\tbreak;\n+        break;\n \n       doc = (char *)xmalloc (1 + (offset - point));\n       strncpy (doc, buffer + point, offset - point);\n@@ -450,7 +435,7 @@ process_one_file (filename, doc_stream, funs_stream)\n      free the memory already allocated to it. */\n   if (block->entries)\n     add_pointer_to_array (block, emacs_tags_index, emacs_tags,\n-\t\t\t  emacs_tags_slots, 10, EMACS_TAG_BLOCK *);\n+                          emacs_tags_slots, 10, EMACS_TAG_BLOCK *);\n   else\n     {\n       free (block->filename);\n@@ -462,7 +447,7 @@ static void\n fatal_file_error (filename)\n      char *filename;\n {\n-  fprintf (stderr, \"Couldn't manipulate the file %s.\\n\", filename);\n+  fprintf (stderr, _(\"Couldn't manipulate the file %s.\\n\"), filename);\n   exit (2);\n }\n "}, {"sha": "3cf4b162a503a96e50387f2827519572b7e4c1c7", "filename": "texinfo/info/man.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fman.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/*  man.h: Defines and external function declarations for man.c */\n+/* man.h: Defines and external function declarations for man.c.\n+   $Id: man.h,v 1.2 1997/07/15 18:42:56 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Author: Brian J. Fox (bfox@ai.mit.edu) Sat May  6 16:19:13 1995. */\n \n-#if !defined (_MAN_H_)\n-#define _MAN_H_\n+#ifndef INFO_MAN_H\n+#define INFO_MAN_H\n \n #define MANPAGE_FILE_BUFFER_NAME \"*manpages*\"\n \n@@ -33,4 +34,4 @@ extern long locate_manpage_xref (/* NODE *node, long start, int dir */);\n extern REFERENCE **xrefs_of_manpage (/* NODE *node */);\n extern REFERENCE **manpage_xrefs_in_binding (/* NODE *node, SEARCH_BINDING *binding */);\n \n-#endif /* !_MAN_H_ */\n+#endif /* INFO_MAN_H */"}, {"sha": "263265747427d85a74c4de00653b163eabf2f20b", "filename": "texinfo/info/nodemenu.c", "status": "modified", "additions": 68, "deletions": 58, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fnodemenu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fnodemenu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fnodemenu.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,7 @@\n-/* nodemenu.c -- Produce a menu of all visited nodes. */\n+/* nodemenu.c -- Produce a menu of all visited nodes.\n+   $Id: nodemenu.c,v 1.7 1997/07/24 21:30:30 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n-   stored in Info format.\n-\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -27,10 +25,10 @@\n static char *\n nodemenu_format_info ()\n {\n-  return (\"\\n\\\n+  return (_(\"\\n\\\n * Menu:\\n\\\n   (File)Node                        Lines   Size   Containing File\\n\\\n-  ----------                        -----   ----   ---------------\");\n+  ----------                        -----   ----   ---------------\"));\n }\n \n /* Produce a formatted line of information about NODE.  Here is what we want\n@@ -41,7 +39,7 @@ nodemenu_format_info ()\n   ----------                        -----   ----   ---------------\n * (emacs)Buffers::                  48      2230   /usr/gnu/info/emacs/emacs-1\n * (autoconf)Writing configure.in::  123     58789  /usr/gnu/info/autoconf/autoconf-1\n-* (dir)Top::\t\t\t    40      589    /usr/gnu/info/dir\n+* (dir)Top::                        40      589    /usr/gnu/info/dir\n */\n static char *\n format_node_info (node)\n@@ -58,7 +56,7 @@ format_node_info (node)\n     {\n       parent = filename_non_directory (node->parent);\n       if (!parent)\n-\tparent = node->parent;\n+        parent = node->parent;\n     }\n   else\n     parent = (char *)NULL;\n@@ -72,15 +70,15 @@ format_node_info (node)\n       char *file = (char *)NULL;\n \n       if (parent)\n-\tfile = parent;\n+        file = parent;\n       else\n-\tfile = filename_non_directory (containing_file);\n+        file = filename_non_directory (containing_file);\n \n       if (!file)\n-\tfile = containing_file;\n+        file = containing_file;\n \n       if (!*file)\n-\tfile = \"dir\";\n+        file = \"dir\";\n \n       sprintf (line_buffer, \"* (%s)%s::\", file, node->nodename);\n     }\n@@ -92,21 +90,21 @@ format_node_info (node)\n \n     for (i = 0; i < node->nodelen; i++)\n       if (node->contents[i] == '\\n')\n-\tlines++;\n+        lines++;\n \n     sprintf (line_buffer + len, \"%d\", lines);\n   }\n \n   len = pad_to (44, line_buffer);\n-  sprintf (line_buffer + len, \"%d\", node->nodelen);\n+  sprintf (line_buffer + len, \"%ld\", node->nodelen);\n \n   if (node->filename && *(node->filename))\n     {\n       len = pad_to (51, line_buffer);\n       sprintf (line_buffer + len, node->filename);\n     }\n \n-  return (strdup (line_buffer));\n+  return xstrdup (line_buffer);\n }\n \n /* Little string comparison routine for qsort (). */\n@@ -137,26 +135,26 @@ get_visited_nodes (filter_func)\n   if (!info_windows)\n     return ((NODE *)NULL);\n \n-  for (iw_index = 0; info_win = info_windows[iw_index]; iw_index++)\n+  for (iw_index = 0; (info_win = info_windows[iw_index]); iw_index++)\n     {\n       for (i = 0; i < info_win->nodes_index; i++)\n-\t{\n-\t  node = info_win->nodes[i];\n-\n-\t  /* We skip mentioning \"*Node Menu*\" nodes. */\n-\t  if (internal_info_node_p (node) &&\n-\t      (strcmp (node->nodename, nodemenu_nodename) == 0))\n-\t    continue;\n-\n-\t  if (node && (!filter_func || (*filter_func) (node)))\n-\t    {\n-\t      char *line;\n-\n-\t      line = format_node_info (node);\n-\t      add_pointer_to_array\n-\t\t(line, lines_index, lines, lines_slots, 20, char *);\n-\t    }\n-\t}\n+        {\n+          node = info_win->nodes[i];\n+\n+          /* We skip mentioning \"*Node Menu*\" nodes. */\n+          if (internal_info_node_p (node) &&\n+              (strcmp (node->nodename, nodemenu_nodename) == 0))\n+            continue;\n+\n+          if (node && (!filter_func || (*filter_func) (node)))\n+            {\n+              char *line;\n+\n+              line = format_node_info (node);\n+              add_pointer_to_array\n+                (line, lines_index, lines, lines_slots, 20, char *);\n+            }\n+        }\n     }\n \n   /* Sort the array of information lines, if there are any. */\n@@ -169,22 +167,22 @@ get_visited_nodes (filter_func)\n \n       /* Delete duplicates. */\n       for (i = 0, newlen = 1; i < lines_index - 1; i++)\n-\t{\n-\t  if (strcmp (lines[i], lines[i + 1]) == 0)\n-\t    {\n-\t      free (lines[i]);\n-\t      lines[i] = (char *)NULL;\n-\t    }\n-\t  else\n-\t    newlen++;\n-\t}\n+        {\n+          if (strcmp (lines[i], lines[i + 1]) == 0)\n+            {\n+              free (lines[i]);\n+              lines[i] = (char *)NULL;\n+            }\n+          else\n+            newlen++;\n+        }\n \n       /* We have free ()'d and marked all of the duplicate slots.\n-\t Copy the live slots rather than pruning the dead slots. */\n+         Copy the live slots rather than pruning the dead slots. */\n       temp = (char **)xmalloc ((1 + newlen) * sizeof (char *));\n       for (i = 0, j = 0; i < lines_index; i++)\n-\tif (lines[i])\n-\t  temp[j++] = lines[i];\n+        if (lines[i])\n+          temp[j++] = lines[i];\n \n       temp[j] = (char *)NULL;\n       free (lines);\n@@ -196,8 +194,8 @@ get_visited_nodes (filter_func)\n \n   printf_to_message_buffer\n     (\"%s\", replace_in_documentation\n-     (\"Here is the menu of nodes you have recently visited.\\n\\\n-Select one from this menu, or use `\\\\[history-node]' in another window.\\n\"));\n+     (_(\"Here is the menu of nodes you have recently visited.\\n\\\n+Select one from this menu, or use `\\\\[history-node]' in another window.\\n\")));\n \n   printf_to_message_buffer (\"%s\\n\", nodemenu_format_info ());\n \n@@ -216,7 +214,7 @@ Select one from this menu, or use `\\\\[history-node]' in another window.\\n\"));\n }\n \n DECLARE_INFO_COMMAND (list_visited_nodes,\n-   \"Make a window containing a menu of all of the currently visited nodes\")\n+   _(\"Make a window containing a menu of all of the currently visited nodes\"))\n {\n   WINDOW *new;\n   NODE *node;\n@@ -229,14 +227,20 @@ DECLARE_INFO_COMMAND (list_visited_nodes,\n       node = new->node;\n \n       if (internal_info_node_p (node) &&\n-\t  (strcmp (node->nodename, nodemenu_nodename) == 0))\n-\tbreak;\n+          (strcmp (node->nodename, nodemenu_nodename) == 0))\n+        break;\n     }\n \n   /* If we couldn't find an existing window, try to use the next window\n      in the chain. */\n-  if (!new && window->next)\n-    new = window->next;\n+  if (!new)\n+    {\n+      if (window->next)\n+        new = window->next;\n+      /* If there is more than one window, wrap around. */\n+      else if (window != windows)\n+        new = windows;\n+    }\n \n   /* If we still don't have a window, make a new one to contain the list. */\n   if (!new)\n@@ -258,10 +262,16 @@ DECLARE_INFO_COMMAND (list_visited_nodes,\n   node = get_visited_nodes ((Function *)NULL);\n   name_internal_node (node, nodemenu_nodename);\n \n+#if 0\n   /* Even if this is an internal node, we don't want the window\n      system to treat it specially.  So we turn off the internalness\n      of it here. */\n+  /* Why?  We depend on internal_info_node_p returning true, so we must\n+     not remove the flag.  Otherwise, the *Node Menu* nodes themselves\n+     appear in the node menu.  --Andreas Schwab\n+     <schwab@issan.informatik.uni-dortmund.de>.  */\n   node->flags &= ~N_IsInternal;\n+#endif\n \n   /* If this window is already showing a node menu, reuse the existing node\n      slot. */\n@@ -270,7 +280,7 @@ DECLARE_INFO_COMMAND (list_visited_nodes,\n \n #if defined (NOTDEF)\n     if (internal_info_node_p (new->node) &&\n-\t(strcmp (new->node->nodename, nodemenu_nodename) == 0))\n+        (strcmp (new->node->nodename, nodemenu_nodename) == 0))\n       remember_me = 0;\n #endif /* NOTDEF */\n \n@@ -284,7 +294,7 @@ DECLARE_INFO_COMMAND (list_visited_nodes,\n }\n \n DECLARE_INFO_COMMAND (select_visited_node,\n-      \"Select a node which has been previously visited in a visible window\")\n+      _(\"Select a node which has been previously visited in a visible window\"))\n {\n   char *line;\n   NODE *node;\n@@ -296,7 +306,7 @@ DECLARE_INFO_COMMAND (select_visited_node,\n   free (node);\n \n   line =\n-    info_read_completing_in_echo_area (window, \"Select visited node: \", menu);\n+    info_read_completing_in_echo_area (window, _(\"Select visited node: \"), menu);\n \n   window = active_window;\n \n@@ -316,9 +326,9 @@ DECLARE_INFO_COMMAND (select_visited_node,\n       entry = info_get_labeled_reference (line, menu);\n \n       if (!entry)\n-\tinfo_error (\"The reference disappeared! (%s).\", line);\n+        info_error (_(\"The reference disappeared! (%s).\"), line);\n       else\n-\tinfo_select_reference (window, entry);\n+        info_select_reference (window, entry);\n     }\n \n   free (line);"}, {"sha": "f2737e7b354c38dfe86bf9ccb218f7487efa1ecf", "filename": "texinfo/info/nodes.c", "status": "modified", "additions": 387, "deletions": 409, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fnodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fnodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fnodes.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -21,17 +21,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <sys/types.h>\n-#if defined (HAVE_SYS_FILE_H)\n-#include <sys/file.h>\n-#endif /* HAVE_SYS_FILE_H */\n-#include <sys/errno.h>\n-#include <sys/stat.h>\n-#if defined (HAVE_STRING_H)\n-#include <string.h>\n-#endif /* HAVE_STRING_H */\n+#include \"info.h\"\n+\n #include \"nodes.h\"\n #include \"search.h\"\n #include \"filesys.h\"\n@@ -41,22 +32,10 @@\n #  include \"man.h\"\n #endif /* HANDLE_MAN_PAGES */\n \n-#if !defined (O_RDONLY)\n-#if defined (HAVE_SYS_FCNTL_H)\n-#include <sys/fcntl.h>\n-#else /* !HAVE_SYS_FCNTL_H */\n-#include <fcntl.h>\n-#endif /* !HAVE_SYS_FCNTL_H */\n-#endif /* !O_RDONLY */\n-\n-#if !defined (errno)\n-extern int errno;\n-#endif /* !errno */\n-\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t     Functions Static to this File\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                   Functions Static to this File                  */\n+/*                                                                  */\n /* **************************************************************** */\n \n static void forget_info_file (), remember_info_file ();\n@@ -81,9 +60,9 @@ static long get_node_length ();\n #define INFO_GET_TAGS 1\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t\t Global Variables\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                       Global Variables                           */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* When non-zero, this is a string describing the recent file error. */\n@@ -96,9 +75,9 @@ FILE_BUFFER **info_loaded_files = (FILE_BUFFER **)NULL;\n int info_loaded_files_slots = 0;\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t Public Functions for Node Manipulation\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*               Public Functions for Node Manipulation             */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Used to build \"dir\" menu from \"localdir\" files found in INFOPATH. */\n@@ -142,8 +121,8 @@ info_get_node (filename, nodename)\n   if (!file_buffer)\n     {\n       if (filesys_error_number)\n-\tinfo_recent_file_error =\n-\t  filesys_error_string (filename, filesys_error_number);\n+        info_recent_file_error =\n+          filesys_error_string (filename, filesys_error_number);\n       return ((NODE *)NULL);\n     }\n \n@@ -154,9 +133,9 @@ info_get_node (filename, nodename)\n     {\n       node = info_get_node_of_file_buffer (\"Top\", file_buffer);\n       if (!node)\n-\tnode = info_get_node_of_file_buffer (\"top\", file_buffer);\n+        node = info_get_node_of_file_buffer (\"top\", file_buffer);\n       if (!node)\n-\tnode = info_get_node_of_file_buffer (\"TOP\", file_buffer);\n+        node = info_get_node_of_file_buffer (\"TOP\", file_buffer);\n     }\n   return (node);\n }\n@@ -193,7 +172,7 @@ info_get_node_of_file_buffer (nodename, file_buffer)\n       node = (NODE *)xmalloc (sizeof (NODE));\n       node->filename = file_buffer->fullpath;\n       node->parent   = (char *)NULL;\n-      node->nodename = strdup (\"*\");\n+      node->nodename = xstrdup (\"*\");\n       node->contents = file_buffer->contents;\n       node->nodelen = file_buffer->filesize;\n       node->flags = 0;\n@@ -203,7 +182,7 @@ info_get_node_of_file_buffer (nodename, file_buffer)\n      the manpage node finding function instead. */\n   else if (file_buffer->flags & N_IsManPage)\n     {\n-\tnode = get_manpage_node (file_buffer, nodename);\n+        node = get_manpage_node (file_buffer, nodename);\n     }\n #endif /* HANDLE_MAN_PAGES */\n   /* If this is the \"main\" info file, it might contain a tags table.  Search\n@@ -242,9 +221,9 @@ info_load_file (filename)\n \n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t    Private Functions Implementation\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                  Private Functions Implementation                */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* The workhorse for info_find_file ().  Non-zero 2nd argument says to\n@@ -263,58 +242,58 @@ info_find_file_internal (filename, get_tags)\n   /* First try to find the file in our list of already loaded files. */\n   if (info_loaded_files)\n     {\n-      for (i = 0; file_buffer = info_loaded_files[i]; i++)\n-\tif ((strcmp (filename, file_buffer->filename) == 0) ||\n-\t    (strcmp (filename, file_buffer->fullpath) == 0) ||\n-\t    ((*filename != '/') &&\n-\t     strcmp (filename,\n-\t\t     filename_non_directory (file_buffer->fullpath)) == 0))\n-\t  {\n-\t    struct stat new_info, *old_info;\n-\n-\t    /* This file is loaded.  If the filename that we want is\n-\t       specifically \"dir\", then simply return the file buffer. */\n-\t    if (strcasecmp (filename_non_directory (filename), \"dir\") == 0)\n-\t      return (file_buffer);\n+      for (i = 0; (file_buffer = info_loaded_files[i]); i++)\n+        if ((strcmp (filename, file_buffer->filename) == 0) ||\n+            (strcmp (filename, file_buffer->fullpath) == 0) ||\n+            ((*filename != '/') &&\n+             strcmp (filename,\n+                     filename_non_directory (file_buffer->fullpath)) == 0))\n+          {\n+            struct stat new_info, *old_info;\n+\n+            /* This file is loaded.  If the filename that we want is\n+               specifically \"dir\", then simply return the file buffer. */\n+            if (strcasecmp (filename_non_directory (filename), \"dir\") == 0)\n+              return (file_buffer);\n \n #if defined (HANDLE_MAN_PAGES)\n-\t    /* Do the same for the magic MANPAGE file. */\n-\t    if (file_buffer->flags & N_IsManPage)\n-\t      return (file_buffer);\n+            /* Do the same for the magic MANPAGE file. */\n+            if (file_buffer->flags & N_IsManPage)\n+              return (file_buffer);\n #endif /* HANDLE_MAN_PAGES */\n \n-\t    /* The file appears to be already loaded, and it is not \"dir\".\n-\t       Check to see if it has changed since the last time it was\n-\t       loaded. */\n-\t    if (stat (file_buffer->fullpath, &new_info) == -1)\n-\t      {\n-\t\tfilesys_error_number = errno;\n-\t\treturn ((FILE_BUFFER *)NULL);\n-\t      }\n-\n-\t    old_info = &file_buffer->finfo;\n-\n-\t    if ((new_info.st_size != old_info->st_size) ||\n-\t\t(new_info.st_mtime != old_info->st_mtime))\n-\t      {\n-\t\t/* The file has changed.  Forget that we ever had loaded it\n-\t\t   in the first place. */\n-\t\tforget_info_file (filename);\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* The info file exists, and has not changed since the last\n-\t\t   time it was loaded.  If the caller requested a nodes list\n-\t\t   for this file, and there isn't one here, build the nodes\n-\t\t   for this file_buffer.  In any case, return the file_buffer\n-\t\t   object. */\n-\t\tif (get_tags && !file_buffer->tags)\n-\t\t  build_tags_and_nodes (file_buffer);\n-\n-\t\treturn (file_buffer);\n-\t      }\n-\t  }\n+            /* The file appears to be already loaded, and it is not \"dir\".\n+               Check to see if it has changed since the last time it was\n+               loaded. */\n+            if (stat (file_buffer->fullpath, &new_info) == -1)\n+              {\n+                filesys_error_number = errno;\n+                return ((FILE_BUFFER *)NULL);\n+              }\n+\n+            old_info = &file_buffer->finfo;\n+\n+            if ((new_info.st_size != old_info->st_size) ||\n+                (new_info.st_mtime != old_info->st_mtime))\n+              {\n+                /* The file has changed.  Forget that we ever had loaded it\n+                   in the first place. */\n+                forget_info_file (filename);\n+                break;\n+              }\n+            else\n+              {\n+                /* The info file exists, and has not changed since the last\n+                   time it was loaded.  If the caller requested a nodes list\n+                   for this file, and there isn't one here, build the nodes\n+                   for this file_buffer.  In any case, return the file_buffer\n+                   object. */\n+                if (get_tags && !file_buffer->tags)\n+                  build_tags_and_nodes (file_buffer);\n+\n+                return (file_buffer);\n+              }\n+          }\n     }\n \n   /* The file wasn't loaded.  Try to load it now. */\n@@ -364,21 +343,21 @@ info_load_file_internal (filename, get_tags)\n       char *lowered_name;\n       char *basename;\n \n-      lowered_name = strdup (filename);\n+      lowered_name = xstrdup (filename);\n       basename = (char *) strrchr (lowered_name, '/');\n \n       if (basename)\n-\tbasename++;\n+        basename++;\n       else\n-\tbasename = lowered_name;\n+        basename = lowered_name;\n \n       while (*basename)\n-\t{\n-\t  if (isupper (*basename))\n-\t    *basename = tolower (*basename);\n+        {\n+          if (isupper (*basename))\n+            *basename = tolower (*basename);\n \n-\t  basename++;\n-\t}\n+          basename++;\n+        }\n \n       fullpath = info_find_fullpath (lowered_name);\n       free (lowered_name);\n@@ -402,8 +381,8 @@ info_load_file_internal (filename, get_tags)\n   /* The file was found, and can be read.  Allocate FILE_BUFFER and fill\n      in the various members. */\n   file_buffer = make_file_buffer ();\n-  file_buffer->filename = strdup (filename);\n-  file_buffer->fullpath = strdup (fullpath);\n+  file_buffer->filename = xstrdup (filename);\n+  file_buffer->fullpath = xstrdup (fullpath);\n   file_buffer->finfo = finfo;\n   file_buffer->filesize = filesize;\n   file_buffer->contents = contents;\n@@ -444,81 +423,81 @@ build_tags_and_nodes (file_buffer)\n   if (position != -1)\n     while (1)\n       {\n-\tlong tags_table_begin, tags_table_end;\n-\n-\tbinding.end = position;\n-\tbinding.start = binding.end - 5 - strlen (TAGS_TABLE_END_LABEL);\n-\tif (binding.start < 0)\n-\t  binding.start = 0;\n-\n-\tposition = find_node_separator (&binding);\n-\n-\t/* For this test, (and all others here) failure indicates a bogus\n-\t   tags table.  Grovel the file. */\n-\tif (position == -1)\n-\t  break;\n-\n-\t/* Remember the end of the tags table. */\n-\tbinding.start = position;\n-\ttags_table_end = binding.start;\n-\tbinding.end = 0;\n-\n-\t/* Locate the start of the tags table. */\n-\tposition = search_backward (TAGS_TABLE_BEG_LABEL, &binding);\n-\n-\tif (position == -1)\n-\t  break;\n-\n-\tbinding.end = position;\n-\tbinding.start = binding.end - 5 - strlen (TAGS_TABLE_BEG_LABEL);\n-\tposition = find_node_separator (&binding);\n-\n-\tif (position == -1)\n-\t  break;\n-\n-\t/* The file contains a valid tags table.  Fill the FILE_BUFFER's\n-\t   tags member. */\n-\tfile_buffer->flags |= N_HasTagsTable;\n-\ttags_table_begin = position;\n-\n-\t/* If this isn't an indirect tags table, just remember the nodes\n-\t   described locally in this tags table.  Note that binding.end\n-\t   is pointing to just after the beginning label. */\n-\tbinding.start = binding.end;\n-\tbinding.end = file_buffer->filesize;\n-\n-\tif (!looking_at (TAGS_TABLE_IS_INDIRECT_LABEL, &binding))\n-\t  {\n-\t    binding.start = tags_table_begin;\n-\t    binding.end = tags_table_end;\n-\t    get_nodes_of_tags_table (file_buffer, &binding);\n-\t    return;\n-\t  }\n-\telse\n-\t  {\n-\t    /* This is an indirect tags table.  Build TAGS member. */\n-\t    SEARCH_BINDING indirect;\n-\n-\t    indirect.start = tags_table_begin;\n-\t    indirect.end = 0;\n-\t    indirect.buffer = binding.buffer;\n-\t    indirect.flags = S_FoldCase;\n-\n-\t    position = search_backward (INDIRECT_TAGS_TABLE_LABEL, &indirect);\n-\n-\t    if (position == -1)\n-\t      {\n-\t\t/* This file is malformed.  Give up. */\n-\t\treturn;\n-\t      }\n-\n-\t    indirect.start = position;\n-\t    indirect.end = tags_table_begin;\n-\t    binding.start = tags_table_begin;\n-\t    binding.end = tags_table_end;\n-\t    get_tags_of_indirect_tags_table (file_buffer, &indirect, &binding);\n-\t    return;\n-\t  }\n+        long tags_table_begin, tags_table_end;\n+\n+        binding.end = position;\n+        binding.start = binding.end - 5 - strlen (TAGS_TABLE_END_LABEL);\n+        if (binding.start < 0)\n+          binding.start = 0;\n+\n+        position = find_node_separator (&binding);\n+\n+        /* For this test, (and all others here) failure indicates a bogus\n+           tags table.  Grovel the file. */\n+        if (position == -1)\n+          break;\n+\n+        /* Remember the end of the tags table. */\n+        binding.start = position;\n+        tags_table_end = binding.start;\n+        binding.end = 0;\n+\n+        /* Locate the start of the tags table. */\n+        position = search_backward (TAGS_TABLE_BEG_LABEL, &binding);\n+\n+        if (position == -1)\n+          break;\n+\n+        binding.end = position;\n+        binding.start = binding.end - 5 - strlen (TAGS_TABLE_BEG_LABEL);\n+        position = find_node_separator (&binding);\n+\n+        if (position == -1)\n+          break;\n+\n+        /* The file contains a valid tags table.  Fill the FILE_BUFFER's\n+           tags member. */\n+        file_buffer->flags |= N_HasTagsTable;\n+        tags_table_begin = position;\n+\n+        /* If this isn't an indirect tags table, just remember the nodes\n+           described locally in this tags table.  Note that binding.end\n+           is pointing to just after the beginning label. */\n+        binding.start = binding.end;\n+        binding.end = file_buffer->filesize;\n+\n+        if (!looking_at (TAGS_TABLE_IS_INDIRECT_LABEL, &binding))\n+          {\n+            binding.start = tags_table_begin;\n+            binding.end = tags_table_end;\n+            get_nodes_of_tags_table (file_buffer, &binding);\n+            return;\n+          }\n+        else\n+          {\n+            /* This is an indirect tags table.  Build TAGS member. */\n+            SEARCH_BINDING indirect;\n+\n+            indirect.start = tags_table_begin;\n+            indirect.end = 0;\n+            indirect.buffer = binding.buffer;\n+            indirect.flags = S_FoldCase;\n+\n+            position = search_backward (INDIRECT_TAGS_TABLE_LABEL, &indirect);\n+\n+            if (position == -1)\n+              {\n+                /* This file is malformed.  Give up. */\n+                return;\n+              }\n+\n+            indirect.start = position;\n+            indirect.end = tags_table_begin;\n+            binding.start = tags_table_begin;\n+            binding.end = tags_table_end;\n+            get_tags_of_indirect_tags_table (file_buffer, &indirect, &binding);\n+            return;\n+          }\n       }\n \n   /* This file doesn't contain any kind of tags table.  Grovel the\n@@ -561,37 +540,37 @@ get_nodes_of_info_file (file_buffer)\n \n       /* If not there, this is not the start of a node. */\n       if (start == -1)\n-\tcontinue;\n+        continue;\n \n       /* Find the start of the nodename. */\n       start += skip_whitespace (nodeline + start);\n \n       /* Find the end of the nodename. */\n       end = start +\n-\tskip_node_characters (nodeline + start, DONT_SKIP_NEWLINES);\n+        skip_node_characters (nodeline + start, DONT_SKIP_NEWLINES);\n \n       /* Okay, we have isolated the node name, and we know where the\n-\t node starts.  Remember this information in a NODE structure. */\n+         node starts.  Remember this information in a NODE structure. */\n       entry = (TAG *)xmalloc (sizeof (TAG));\n       entry->nodename = (char *)xmalloc (1 + (end - start));\n       strncpy (entry->nodename, nodeline + start, end - start);\n       entry->nodename[end - start] = '\\0';\n       entry->nodestart = nodestart;\n       {\n-\tSEARCH_BINDING node_body;\n+        SEARCH_BINDING node_body;\n \n-\tnode_body.buffer = binding.buffer + binding.start;\n-\tnode_body.start = 0;\n-\tnode_body.end = binding.end - binding.start;\n-\tnode_body.flags = S_FoldCase;\n-\tentry->nodelen = get_node_length (&node_body);\n+        node_body.buffer = binding.buffer + binding.start;\n+        node_body.start = 0;\n+        node_body.end = binding.end - binding.start;\n+        node_body.flags = S_FoldCase;\n+        entry->nodelen = get_node_length (&node_body);\n       }\n \n       entry->filename = file_buffer->fullpath;\n \n       /* Add this tag to the array of tag structures in this FILE_BUFFER. */\n       add_pointer_to_array (entry, tags_index, file_buffer->tags,\n-\t\t\t    file_buffer->tags_slots, 100, TAG *);\n+                            file_buffer->tags_slots, 100, TAG *);\n     }\n }\n \n@@ -608,7 +587,7 @@ get_node_length (binding)\n   for (i = binding->start, body = binding->buffer; i < binding->end; i++)\n     {\n       if (body[i] == INFO_FF || body[i] == INFO_COOKIE)\n-\tbreak;\n+        break;\n     }\n   return ((long) i - binding->start);\n }\n@@ -652,16 +631,16 @@ get_nodes_of_tags_table (file_buffer, buffer_binding)\n \n       /* Skip past informative \"(Indirect)\" tags table line. */\n       if (!tags_index && looking_at (TAGS_TABLE_IS_INDIRECT_LABEL, search))\n-\tcontinue;\n+        continue;\n \n       /* Find the label preceding the node name. */\n       offset =\n-\tstring_in_line (INFO_NODE_LABEL, search->buffer + search->start);\n+        string_in_line (INFO_NODE_LABEL, search->buffer + search->start);\n \n       /* If not there, not a defining line, so we must be out of the\n-\t tags table. */\n+         tags table. */\n       if (offset == -1)\n-\tbreak;\n+        break;\n \n       /* Point to the beginning of the node definition. */\n       search->start += offset;\n@@ -670,11 +649,11 @@ get_nodes_of_tags_table (file_buffer, buffer_binding)\n \n       /* Move past the node's name. */\n       for (offset = 0;\n-\t   (nodedef[offset]) && (nodedef[offset] != INFO_TAGSEP);\n-\t   offset++);\n+           (nodedef[offset]) && (nodedef[offset] != INFO_TAGSEP);\n+           offset++);\n \n       if (nodedef[offset] != INFO_TAGSEP)\n-\tcontinue;\n+        continue;\n \n       entry = (TAG *)xmalloc (sizeof (TAG));\n       entry->nodename = (char *)xmalloc (1 + offset);\n@@ -687,13 +666,13 @@ get_nodes_of_tags_table (file_buffer, buffer_binding)\n       entry->nodelen = -1;\n \n       /* The filename of this node is currently known as the same as the\n-\t name of this file. */\n+         name of this file. */\n       entry->filename = file_buffer->fullpath;\n \n       /* Add this node structure to the array of node structures in this\n-\t FILE_BUFFER. */\n+         FILE_BUFFER. */\n       add_pointer_to_array (entry, tags_index, file_buffer->tags,\n-\t\t\t    file_buffer->tags_slots, 100, TAG *);\n+                            file_buffer->tags_slots, 100, TAG *);\n     }\n   free (search);\n }\n@@ -734,23 +713,23 @@ get_tags_of_indirect_tags_table (file_buffer, indirect_binding, tags_binding)\n \n     while (line < end)\n       {\n-\tint colon;\n+        int colon;\n \n-\tcolon = string_in_line (\":\", line);\n+        colon = string_in_line (\":\", line);\n \n-\tif (colon == -1)\n-\t  break;\n+        if (colon == -1)\n+          break;\n \n-\tsubfile = (SUBFILE *)xmalloc (sizeof (SUBFILE));\n-\tsubfile->filename = (char *)xmalloc (colon);\n-\tstrncpy (subfile->filename, line, colon - 1);\n-\tsubfile->filename[colon - 1] = '\\0';\n-\tsubfile->first_byte = (long) atol (line + colon);\n+        subfile = (SUBFILE *)xmalloc (sizeof (SUBFILE));\n+        subfile->filename = (char *)xmalloc (colon);\n+        strncpy (subfile->filename, line, colon - 1);\n+        subfile->filename[colon - 1] = '\\0';\n+        subfile->first_byte = (long) atol (line + colon);\n \n-\tadd_pointer_to_array\n-\t  (subfile, subfiles_index, subfiles, subfiles_slots, 10, SUBFILE *);\n+        add_pointer_to_array\n+          (subfile, subfiles_index, subfiles, subfiles_slots, 10, SUBFILE *);\n \n-\twhile (*line++ != '\\n');\n+        while (*line++ != '\\n');\n       }\n   }\n \n@@ -768,92 +747,91 @@ get_tags_of_indirect_tags_table (file_buffer, indirect_binding, tags_binding)\n       SEARCH_BINDING binding;\n \n       /* Find the length of the header of the file containing the indirect\n-\t tags table.  This header appears at the start of every file.  We\n-\t want the absolute position of each node within each subfile, so\n-\t we subtract the start of the containing subfile from the logical\n-\t position of the node, and then add the length of the header in. */\n+         tags table.  This header appears at the start of every file.  We\n+         want the absolute position of each node within each subfile, so\n+         we subtract the start of the containing subfile from the logical\n+         position of the node, and then add the length of the header in. */\n       binding.buffer = file_buffer->contents;\n       binding.start = 0;\n       binding.end = file_buffer->filesize;\n       binding.flags = S_FoldCase;\n \n       header_length = find_node_separator (&binding);\n       if (header_length == -1)\n-\theader_length = 0;\n+        header_length = 0;\n \n       /* Build the file buffer's list of subfiles. */\n       {\n-\tchar *containing_dir, *temp;\n-\tint len_containing_dir;\n+        char *containing_dir, *temp;\n+        int len_containing_dir;\n \n-\tcontaining_dir = strdup (file_buffer->fullpath);\n-\ttemp = (char *) strrchr (containing_dir, '/');\n+        containing_dir = xstrdup (file_buffer->fullpath);\n+        temp = (char *) strrchr (containing_dir, '/');\n \n-\tif (temp)\n-\t  *temp = '\\0';\n+        if (temp)\n+          *temp = '\\0';\n \n-\tlen_containing_dir = strlen (containing_dir);\n+        len_containing_dir = strlen (containing_dir);\n \n-\tfor (i = 0; subfiles[i]; i++);\n+        for (i = 0; subfiles[i]; i++);\n \n-\tfile_buffer->subfiles = (char **) xmalloc ((1 + i) * sizeof (char *));\n+        file_buffer->subfiles = (char **) xmalloc ((1 + i) * sizeof (char *));\n \n-\tfor (i = 0; subfiles[i]; i++)\n-\t  {\n-\t    char *fullpath;\n+        for (i = 0; subfiles[i]; i++)\n+          {\n+            char *fullpath;\n \n-\t    fullpath = (char *) xmalloc\n-\t      (2 + strlen (subfiles[i]->filename) + len_containing_dir);\n+            fullpath = (char *) xmalloc\n+              (2 + strlen (subfiles[i]->filename) + len_containing_dir);\n \n-\t    sprintf (fullpath, \"%s/%s\",\n-\t\t     containing_dir, subfiles[i]->filename);\n+            sprintf (fullpath, \"%s/%s\",\n+                     containing_dir, subfiles[i]->filename);\n \n-\t    file_buffer->subfiles[i] = fullpath;\n-\t  }\n-\tfile_buffer->subfiles[i] = (char *)NULL;\n-\tfree (containing_dir);\n+            file_buffer->subfiles[i] = fullpath;\n+          }\n+        file_buffer->subfiles[i] = (char *)NULL;\n+        free (containing_dir);\n       }\n \n       /* For each node in the file's tags table, remember the starting\n-\t position. */\n-      for (tags_index = 0;\n-\t   entry = file_buffer->tags[tags_index];\n-\t   tags_index++)\n-\t{\n-\t  for (i = 0;\n-\t       subfiles[i] && entry->nodestart >= subfiles[i]->first_byte;\n-\t       i++);\n-\n-\t  /* If the Info file containing the indirect tags table is\n-\t     malformed, then give up. */\n-\t  if (!i)\n-\t    {\n-\t      /* The Info file containing the indirect tags table is\n-\t\t malformed.  Give up. */\n-\t      for (i = 0; subfiles[i]; i++)\n-\t\t{\n-\t\t  free (subfiles[i]->filename);\n-\t\t  free (subfiles[i]);\n-\t\t  free (file_buffer->subfiles[i]);\n-\t\t}\n-\t      file_buffer->subfiles = (char **)NULL;\n-\t      free_file_buffer_tags (file_buffer);\n-\t      return;\n-\t    }\n-\n-\t  /* SUBFILES[i] is the index of the first subfile whose logical\n-\t     first byte is greater than the logical offset of this node's\n-\t     starting position.  This means that the subfile directly\n-\t     preceding this one is the one containing the node. */\n-\n-\t  entry->filename = file_buffer->subfiles[i - 1];\n-\t  entry->nodestart -= subfiles[i -1]->first_byte;\n-\t  entry->nodestart += header_length;\n-\t  entry->nodelen = -1;\n-\t}\n+         position. */\n+      for (tags_index = 0; (entry = file_buffer->tags[tags_index]);\n+           tags_index++)\n+        {\n+          for (i = 0;\n+               subfiles[i] && entry->nodestart >= subfiles[i]->first_byte;\n+               i++);\n+\n+          /* If the Info file containing the indirect tags table is\n+             malformed, then give up. */\n+          if (!i)\n+            {\n+              /* The Info file containing the indirect tags table is\n+                 malformed.  Give up. */\n+              for (i = 0; subfiles[i]; i++)\n+                {\n+                  free (subfiles[i]->filename);\n+                  free (subfiles[i]);\n+                  free (file_buffer->subfiles[i]);\n+                }\n+              file_buffer->subfiles = (char **)NULL;\n+              free_file_buffer_tags (file_buffer);\n+              return;\n+            }\n+\n+          /* SUBFILES[i] is the index of the first subfile whose logical\n+             first byte is greater than the logical offset of this node's\n+             starting position.  This means that the subfile directly\n+             preceding this one is the one containing the node. */\n+\n+          entry->filename = file_buffer->subfiles[i - 1];\n+          entry->nodestart -= subfiles[i -1]->first_byte;\n+          entry->nodestart += header_length;\n+          entry->nodelen = -1;\n+        }\n \n       /* We have successfully built the tags table.  Remember that it\n-\t was indirect. */\n+         was indirect. */\n       file_buffer->flags |= N_TagsIndirect;\n     }\n \n@@ -878,105 +856,105 @@ info_node_of_file_buffer_tags (file_buffer, nodename)\n   register int i;\n   TAG *tag;\n \n-  for (i = 0; tag = file_buffer->tags[i]; i++)\n+  for (i = 0; (tag = file_buffer->tags[i]); i++)\n     if (strcmp (nodename, tag->nodename) == 0)\n       {\n-\tFILE_BUFFER *subfile;\n-\n-\tsubfile = info_find_file_internal (tag->filename, INFO_NO_TAGS);\n-\n-\tif (!subfile)\n-\t  return ((NODE *)NULL);\n-\n-\tif (!subfile->contents)\n-\t  {\n-\t    info_reload_file_buffer_contents (subfile);\n-\n-\t    if (!subfile->contents)\n-\t      return ((NODE *)NULL);\n-\t  }\n-\n-\t/* If we were able to find this file and load it, then return\n-\t   the node within it. */\n-\t{\n-\t  NODE *node;\n-\n-\t  node = (NODE *)xmalloc (sizeof (NODE));\n-\t  node->filename = (subfile->fullpath);\n-\t  node->nodename = tag->nodename;\n-\t  node->contents = subfile->contents + tag->nodestart;\n-\t  node->flags\t = 0;\n-\t  node->parent\t = (char *)NULL;\n-\n-\t  if (file_buffer->flags & N_HasTagsTable)\n-\t    {\n-\t      node->flags |= N_HasTagsTable;\n-\n-\t      if (file_buffer->flags & N_TagsIndirect)\n-\t\t{\n-\t\t  node->flags |= N_TagsIndirect;\n-\t\t  node->parent = file_buffer->fullpath;\n-\t\t}\n-\t    }\n-\n-\t  if (subfile->flags & N_IsCompressed)\n-\t    node->flags |= N_IsCompressed;\n-\n-\t  /* If TAG->nodelen hasn't been calculated yet, then we aren't\n-\t     in a position to trust the entry pointer.  Adjust things so\n-\t     that ENTRY->nodestart gets the exact address of the start of\n-\t     the node separator which starts this node, and NODE->contents\n-\t     gets the address of the line defining this node.  If we cannot\n-\t     do that, the node isn't really here. */\n-\t  if (tag->nodelen == -1)\n-\t    {\n-\t      int min, max;\n-\t      char *node_sep;\n-\t      SEARCH_BINDING node_body;\n-\t      char *buff_end;\n-\n-\t      min = max = DEFAULT_INFO_FUDGE;\n-\n-\t      if (tag->nodestart < DEFAULT_INFO_FUDGE)\n-\t\tmin = tag->nodestart;\n-\n-\t      if (DEFAULT_INFO_FUDGE >\n-\t\t  (subfile->filesize - tag->nodestart))\n-\t\tmax = subfile->filesize - tag->nodestart;\n-\n-\t      /* NODE_SEP gets the address of the separator which defines\n-\t\t this node, or (char *)NULL if the node wasn't found.\n-\t\t NODE->contents is side-effected to point to right after\n-\t\t the separator. */\n-\t      node_sep = adjust_nodestart (node, min, max);\n-\t      if (node_sep == (char *)NULL)\n-\t\t{\n-\t\t  free (node);\n-\t\t  return ((NODE *)NULL);\n-\t\t}\n-\t      /* Readjust tag->nodestart. */\n-\t      tag->nodestart = node_sep - subfile->contents;\n-\n-\t      /* Calculate the length of the current node. */\n-\t      buff_end = subfile->contents + subfile->filesize;\n-\n-\t      node_body.buffer = node->contents;\n-\t      node_body.start = 0;\n-\t      node_body.end = buff_end - node_body.buffer;\n-\t      node_body.flags = 0;\n-\t      tag->nodelen = get_node_length (&node_body);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Since we know the length of this node, we have already\n-\t\t adjusted tag->nodestart to point to the exact start of\n-\t\t it.  Simply skip the node separator. */\n-\t      node->contents += skip_node_separator (node->contents);\n-\t    }\n-\n-\t  node->nodelen = tag->nodelen;\n-\t  return (node);\n-\t}\n+        FILE_BUFFER *subfile;\n+\n+        subfile = info_find_file_internal (tag->filename, INFO_NO_TAGS);\n+\n+        if (!subfile)\n+          return ((NODE *)NULL);\n+\n+        if (!subfile->contents)\n+          {\n+            info_reload_file_buffer_contents (subfile);\n+\n+            if (!subfile->contents)\n+              return ((NODE *)NULL);\n+          }\n+\n+        /* If we were able to find this file and load it, then return\n+           the node within it. */\n+        {\n+          NODE *node;\n+\n+          node = (NODE *)xmalloc (sizeof (NODE));\n+          node->filename = (subfile->fullpath);\n+          node->nodename = tag->nodename;\n+          node->contents = subfile->contents + tag->nodestart;\n+          node->flags    = 0;\n+          node->parent   = (char *)NULL;\n+\n+          if (file_buffer->flags & N_HasTagsTable)\n+            {\n+              node->flags |= N_HasTagsTable;\n+\n+              if (file_buffer->flags & N_TagsIndirect)\n+                {\n+                  node->flags |= N_TagsIndirect;\n+                  node->parent = file_buffer->fullpath;\n+                }\n+            }\n+\n+          if (subfile->flags & N_IsCompressed)\n+            node->flags |= N_IsCompressed;\n+\n+          /* If TAG->nodelen hasn't been calculated yet, then we aren't\n+             in a position to trust the entry pointer.  Adjust things so\n+             that ENTRY->nodestart gets the exact address of the start of\n+             the node separator which starts this node, and NODE->contents\n+             gets the address of the line defining this node.  If we cannot\n+             do that, the node isn't really here. */\n+          if (tag->nodelen == -1)\n+            {\n+              int min, max;\n+              char *node_sep;\n+              SEARCH_BINDING node_body;\n+              char *buff_end;\n+\n+              min = max = DEFAULT_INFO_FUDGE;\n+\n+              if (tag->nodestart < DEFAULT_INFO_FUDGE)\n+                min = tag->nodestart;\n+\n+              if (DEFAULT_INFO_FUDGE >\n+                  (subfile->filesize - tag->nodestart))\n+                max = subfile->filesize - tag->nodestart;\n+\n+              /* NODE_SEP gets the address of the separator which defines\n+                 this node, or (char *)NULL if the node wasn't found.\n+                 NODE->contents is side-effected to point to right after\n+                 the separator. */\n+              node_sep = adjust_nodestart (node, min, max);\n+              if (node_sep == (char *)NULL)\n+                {\n+                  free (node);\n+                  return ((NODE *)NULL);\n+                }\n+              /* Readjust tag->nodestart. */\n+              tag->nodestart = node_sep - subfile->contents;\n+\n+              /* Calculate the length of the current node. */\n+              buff_end = subfile->contents + subfile->filesize;\n+\n+              node_body.buffer = node->contents;\n+              node_body.start = 0;\n+              node_body.end = buff_end - node_body.buffer;\n+              node_body.flags = 0;\n+              tag->nodelen = get_node_length (&node_body);\n+            }\n+          else\n+            {\n+              /* Since we know the length of this node, we have already\n+                 adjusted tag->nodestart to point to the exact start of\n+                 it.  Simply skip the node separator. */\n+              node->contents += skip_node_separator (node->contents);\n+            }\n+\n+          node->nodelen = tag->nodelen;\n+          return (node);\n+        }\n       }\n \n   /* There was a tag table for this file, and the node wasn't found.\n@@ -985,9 +963,9 @@ info_node_of_file_buffer_tags (file_buffer, nodename)\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\tManaging file_buffers, nodes, and tags.\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*              Managing file_buffers, nodes, and tags.             */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Create a new, empty file buffer. */\n@@ -1018,7 +996,7 @@ remember_info_file (file_buffer)\n     ;\n \n   add_pointer_to_array (file_buffer, i, info_loaded_files,\n-\t\t\tinfo_loaded_files_slots, 10, FILE_BUFFER *);\n+                        info_loaded_files_slots, 10, FILE_BUFFER *);\n }\n \n /* Forget the contents, tags table, nodes list, and names of FILENAME. */\n@@ -1032,25 +1010,25 @@ forget_info_file (filename)\n   if (!info_loaded_files)\n     return;\n \n-  for (i = 0; file_buffer = info_loaded_files[i]; i++)\n+  for (i = 0; (file_buffer = info_loaded_files[i]); i++)\n     if ((strcmp (filename, file_buffer->filename) == 0) ||\n-\t(strcmp (filename, file_buffer->fullpath) == 0))\n+        (strcmp (filename, file_buffer->fullpath) == 0))\n       {\n-\tfree (file_buffer->filename);\n-\tfree (file_buffer->fullpath);\n+        free (file_buffer->filename);\n+        free (file_buffer->fullpath);\n \n-\tif (file_buffer->contents)\n-\t  free (file_buffer->contents);\n-\t\n-\t/* Note that free_file_buffer_tags () also kills the subfiles\n-\t   list, since the subfiles list is only of use in conjunction\n-\t   with tags. */\n-\tfree_file_buffer_tags (file_buffer);\n+        if (file_buffer->contents)\n+          free (file_buffer->contents);\n+        \n+        /* Note that free_file_buffer_tags () also kills the subfiles\n+           list, since the subfiles list is only of use in conjunction\n+           with tags. */\n+        free_file_buffer_tags (file_buffer);\n \n-\twhile (info_loaded_files[i] = info_loaded_files[++i])\n-\t  ;\n+        while ((info_loaded_files[i] = info_loaded_files[++i]))\n+          ;\n \n-\tbreak;\n+        break;\n       }\n }\n \n@@ -1065,8 +1043,8 @@ free_file_buffer_tags (file_buffer)\n     {\n       register TAG *tag;\n \n-      for (i = 0; tag = file_buffer->tags[i]; i++)\n-\tfree_info_tag (tag);\n+      for (i = 0; (tag = file_buffer->tags[i]); i++)\n+        free_info_tag (tag);\n \n       free (file_buffer->tags);\n       file_buffer->tags = (TAG **)NULL;\n@@ -1076,7 +1054,7 @@ free_file_buffer_tags (file_buffer)\n   if (file_buffer->subfiles)\n     {\n       for (i = 0; file_buffer->subfiles[i]; i++)\n-\tfree (file_buffer->subfiles[i]);\n+        free (file_buffer->subfiles[i]);\n \n       free (file_buffer->subfiles);\n       file_buffer->subfiles = (char **)NULL;\n@@ -1160,29 +1138,29 @@ adjust_nodestart (node, min, max)\n       sep_len = skip_node_separator (node->contents);\n \n       /* If we managed to skip a node separator, then check for this node\n-\t being the right one. */\n+         being the right one. */\n       if (sep_len != 0)\n-\t{\n-\t  char *nodedef, *nodestart;\n-\t  int offset;\n-\n-\t  nodestart = node_body.buffer + position + sep_len;\n-\t  nodedef = nodestart;\n-\t  offset = string_in_line (INFO_NODE_LABEL, nodedef);\n-\n-\t  if (offset != -1)\n-\t    {\n-\t      nodedef += offset;\n-\t      nodedef += skip_whitespace (nodedef);\n-\t      offset = skip_node_characters (nodedef, DONT_SKIP_NEWLINES);\n-\t      if ((offset == strlen (node->nodename)) &&\n-\t\t  (strncmp (node->nodename, nodedef, offset) == 0))\n-\t\t{\n-\t\t  node->contents = nodestart;\n-\t\t  return (node_body.buffer + position);\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          char *nodedef, *nodestart;\n+          int offset;\n+\n+          nodestart = node_body.buffer + position + sep_len;\n+          nodedef = nodestart;\n+          offset = string_in_line (INFO_NODE_LABEL, nodedef);\n+\n+          if (offset != -1)\n+            {\n+              nodedef += offset;\n+              nodedef += skip_whitespace (nodedef);\n+              offset = skip_node_characters (nodedef, DONT_SKIP_NEWLINES);\n+              if ((offset == strlen (node->nodename)) &&\n+                  (strncmp (node->nodename, nodedef, offset) == 0))\n+                {\n+                  node->contents = nodestart;\n+                  return (node_body.buffer + position);\n+                }\n+            }\n+        }\n     }\n \n   /* Oh well, I guess we have to try to find it in a larger area. */"}, {"sha": "a96c07c8a6e3304a2f256c0c2d43ee71f2fe88df", "filename": "texinfo/info/nodes.h", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fnodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fnodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fnodes.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* nodes.h -- How we represent nodes internally. */\n+/* nodes.h -- How we represent nodes internally.\n+   $Id: nodes.h,v 1.5 1997/07/18 14:33:44 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,15 +22,15 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_NODES_H_)\n-#define _NODES_H_\n+#if !defined (NODES_H)\n+#define NODES_H\n \n-#include \"general.h\"\n+#include \"info.h\"\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t      User Code Interface\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                    User Code Interface                           */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Callers generally only want the node itself.  This structure is used\n@@ -41,45 +42,45 @@\n    paths, so you might have: node->filename = \"/usr/gnu/info/emacs-1\",\n    with node->parent = \"/usr/gnu/info/emacs\". */\n typedef struct {\n-  char *filename;\t\t/* The physical file containing this node. */\n-  char *parent;\t\t\t/* Non-null is the logical file name. */\n-  char *nodename;\t\t/* The name of this node. */\n-  char *contents;\t\t/* Characters appearing in this node. */\n-  long nodelen;\t\t\t/* The length of the CONTENTS member. */\n-  int flags;\t\t\t/* See immediately below. */\n+  char *filename;               /* The physical file containing this node. */\n+  char *parent;                 /* Non-null is the logical file name. */\n+  char *nodename;               /* The name of this node. */\n+  char *contents;               /* Characters appearing in this node. */\n+  long nodelen;                 /* The length of the CONTENTS member. */\n+  int flags;                    /* See immediately below. */\n } NODE;\n \n /* Defines that can appear in NODE->flags.  All informative. */\n-#define N_HasTagsTable 0x01\t/* This node was found through a tags table. */\n-#define N_TagsIndirect 0x02\t/* The tags table was an indirect one. */\n-#define N_UpdateTags   0x04\t/* The tags table is out of date. */\n-#define N_IsCompressed 0x08\t/* The file is compressed on disk. */\n-#define N_IsInternal   0x10\t/* This node was made by Info. */\n-#define N_CannotGC     0x20\t/* File buffer cannot be gc'ed. */\n-#define N_IsManPage    0x40\t/* This node is a Un*x manpage. */\n+#define N_HasTagsTable 0x01     /* This node was found through a tags table. */\n+#define N_TagsIndirect 0x02     /* The tags table was an indirect one. */\n+#define N_UpdateTags   0x04     /* The tags table is out of date. */\n+#define N_IsCompressed 0x08     /* The file is compressed on disk. */\n+#define N_IsInternal   0x10     /* This node was made by Info. */\n+#define N_CannotGC     0x20     /* File buffer cannot be gc'ed. */\n+#define N_IsManPage    0x40     /* This node is a Un*x manpage. */\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t       Internal Data Structures\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                     Internal Data Structures                     */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Some defines describing details about Info file contents. */\n \n /* String Constants. */\n-#define INFO_FILE_LABEL\t\t\t\"File:\"\n-#define INFO_NODE_LABEL\t\t\t\"Node:\"\n-#define INFO_PREV_LABEL\t\t\t\"Prev:\"\n-#define INFO_ALTPREV_LABEL\t\t\"Previous:\"\n-#define INFO_NEXT_LABEL\t\t\t\"Next:\"\n-#define INFO_UP_LABEL\t\t\t\"Up:\"\n-#define INFO_MENU_LABEL\t\t\t\"\\n* Menu:\"\n-#define INFO_MENU_ENTRY_LABEL\t\t\"\\n* \"\n-#define INFO_XREF_LABEL\t\t\t\"*Note\"\n-#define TAGS_TABLE_END_LABEL\t\t\"\\nEnd Tag Table\"\n-#define TAGS_TABLE_BEG_LABEL\t\t\"Tag Table:\\n\"\n-#define INDIRECT_TAGS_TABLE_LABEL\t\"Indirect:\\n\"\n-#define TAGS_TABLE_IS_INDIRECT_LABEL\t\"(Indirect)\"\n+#define INFO_FILE_LABEL                 \"File:\"\n+#define INFO_NODE_LABEL                 \"Node:\"\n+#define INFO_PREV_LABEL                 \"Prev:\"\n+#define INFO_ALTPREV_LABEL              \"Previous:\"\n+#define INFO_NEXT_LABEL                 \"Next:\"\n+#define INFO_UP_LABEL                   \"Up:\"\n+#define INFO_MENU_LABEL                 \"\\n* Menu:\"\n+#define INFO_MENU_ENTRY_LABEL           \"\\n* \"\n+#define INFO_XREF_LABEL                 \"*Note\"\n+#define TAGS_TABLE_END_LABEL            \"\\nEnd Tag Table\"\n+#define TAGS_TABLE_BEG_LABEL            \"Tag Table:\\n\"\n+#define INDIRECT_TAGS_TABLE_LABEL       \"Indirect:\\n\"\n+#define TAGS_TABLE_IS_INDIRECT_LABEL    \"(Indirect)\"\n \n /* Character Constants. */\n #define INFO_COOKIE '\\037'\n@@ -94,10 +95,10 @@ typedef struct {\n    member in the structure below simply contains the name of the current\n    file.  The following structure describes a single node within a file. */\n typedef struct {\n-  char *filename;\t\t/* The file where this node can be found. */\n-  char *nodename;\t\t/* The node pointed to by this tag. */\n-  long nodestart;\t\t/* The offset of the start of this node. */\n-  long nodelen;\t\t\t/* The length of this node. */\n+  char *filename;               /* The file where this node can be found. */\n+  char *nodename;               /* The node pointed to by this tag. */\n+  long nodestart;               /* The offset of the start of this node. */\n+  long nodelen;                 /* The length of this node. */\n } TAG;\n \n /* The following structure is used to remember information about the contents\n@@ -108,21 +109,21 @@ typedef struct {\n    corresponding SLOTS member which says how many slots have been allocated\n    (with malloc ()) for this array. */\n typedef struct {\n-  char *filename;\t\t/* The filename used to find this file. */\n-  char *fullpath;\t\t/* The full pathname of this info file. */\n-  struct stat finfo;\t\t/* Information about this file. */\n-  char *contents;\t\t/* The contents of this particular file. */\n-  long filesize;\t\t/* The number of bytes this file expands to. */\n-  char **subfiles;\t\t/* If non-null, the list of subfiles. */\n-  TAG **tags;\t\t\t/* If non-null, the indirect tags table. */\n-  int tags_slots;\t\t/* Number of slots allocated for TAGS. */\n-  int flags;\t\t\t/* Various flags.  Mimics of N_* flags. */\n+  char *filename;               /* The filename used to find this file. */\n+  char *fullpath;               /* The full pathname of this info file. */\n+  struct stat finfo;            /* Information about this file. */\n+  char *contents;               /* The contents of this particular file. */\n+  long filesize;                /* The number of bytes this file expands to. */\n+  char **subfiles;              /* If non-null, the list of subfiles. */\n+  TAG **tags;                   /* If non-null, the indirect tags table. */\n+  int tags_slots;               /* Number of slots allocated for TAGS. */\n+  int flags;                    /* Various flags.  Mimics of N_* flags. */\n } FILE_BUFFER;\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t    Externally Visible Functions\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                  Externally Visible Functions                    */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Array of FILE_BUFFER * which represents the currently loaded info files. */\n@@ -165,4 +166,4 @@ extern char *info_recent_file_error;\n /* Create a new, empty file buffer. */\n extern FILE_BUFFER *make_file_buffer ();\n \n-#endif /* !_NODES_H_ */\n+#endif /* !NODES_H */"}, {"sha": "0e8e619256a182309ce3e9065757b252e1f9a4ed", "filename": "texinfo/info/search.c", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fsearch.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -3,7 +3,7 @@\n /* This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,17 +21,11 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <ctype.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include \"general.h\"\n+#include \"info.h\"\n+\n #include \"search.h\"\n #include \"nodes.h\"\n \n-#if !defined (NULL)\n-#  define NULL 0x0\n-#endif /* !NULL */\n-\n /* The search functions take two arguments:\n \n      1) a string to search for, and\n@@ -73,9 +67,9 @@ copy_binding (binding)\n \n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t   The Actual Searching Functions\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                 The Actual Searching Functions                   */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Search forwards or backwards for the text delimited by BINDING.\n@@ -115,15 +109,15 @@ search_forward (string, binding)\n \n   if (binding->flags & S_FoldCase)\n     {\n-      alternate = strdup (string);\n+      alternate = xstrdup (string);\n \n       for (i = 0; i < len; i++)\n-\t{\n-\t  if (islower (alternate[i]))\n-\t    alternate[i] = toupper (alternate[i]);\n-\t  else if (isupper (alternate[i]))\n-\t    alternate[i] = tolower (alternate[i]);\n-\t}\n+        {\n+          if (islower (alternate[i]))\n+            alternate[i] = toupper (alternate[i]);\n+          else if (isupper (alternate[i]))\n+            alternate[i] = tolower (alternate[i]);\n+        }\n     }\n \n   buff = binding->buffer + binding->start;\n@@ -132,21 +126,21 @@ search_forward (string, binding)\n   while (buff < (end - len))\n     {\n       for (i = 0; i < len; i++)\n-\t{\n-\t  c = buff[i];\n+        {\n+          c = buff[i];\n \n-\t  if ((c != string[i]) && (!alternate || c != alternate[i]))\n-\t    break;\n-\t}\n+          if ((c != string[i]) && (!alternate || c != alternate[i]))\n+            break;\n+        }\n \n       if (!string[i])\n-\t{\n-\t  if (alternate)\n-\t    free (alternate);\n-\t  if (binding->flags & S_SkipDest)\n-\t    buff += len;\n-\t  return ((long) (buff - binding->buffer));\n-\t}\n+        {\n+          if (alternate)\n+            free (alternate);\n+          if (binding->flags & S_SkipDest)\n+            buff += len;\n+          return ((long) (buff - binding->buffer));\n+        }\n \n       buff++;\n     }\n@@ -184,15 +178,15 @@ search_backward (input_string, binding)\n \n   if (binding->flags & S_FoldCase)\n     {\n-      alternate = strdup (string);\n+      alternate = xstrdup (string);\n \n       for (i = 0; i < len; i++)\n-\t{\n-\t  if (islower (alternate[i]))\n-\t    alternate[i] = toupper (alternate[i]);\n-\t  else if (isupper (alternate[i]))\n-\t    alternate[i] = tolower (alternate[i]);\n-\t}\n+        {\n+          if (islower (alternate[i]))\n+            alternate[i] = toupper (alternate[i]);\n+          else if (isupper (alternate[i]))\n+            alternate[i] = tolower (alternate[i]);\n+        }\n     }\n \n   buff = binding->buffer + binding->start - 1;\n@@ -201,23 +195,23 @@ search_backward (input_string, binding)\n   while (buff > (end + len))\n     {\n       for (i = 0; i < len; i++)\n-\t{\n-\t  c = *(buff - i);\n+        {\n+          c = *(buff - i);\n \n-\t  if (c != string[i] && (alternate && c != alternate[i]))\n-\t    break;\n-\t}\n+          if (c != string[i] && (alternate && c != alternate[i]))\n+            break;\n+        }\n \n       if (!string[i])\n-\t{\n-\t  free (string);\n-\t  if (alternate)\n-\t    free (alternate);\n+        {\n+          free (string);\n+          if (alternate)\n+            free (alternate);\n \n-\t  if (binding->flags & S_SkipDest)\n-\t    buff -= len;\n-\t  return ((long) (1 + (buff - binding->buffer)));\n-\t}\n+          if (binding->flags & S_SkipDest)\n+            buff -= len;\n+          return ((long) (1 + (buff - binding->buffer)));\n+        }\n \n       buff--;\n     }\n@@ -268,9 +262,9 @@ looking_at (string, binding)\n }\n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t      Small String Searches\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                    Small String Searches                         */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Function names that start with \"skip\" are passed a string, and return\n@@ -346,37 +340,43 @@ skip_node_characters (string, newlines_okay)\n   for (; string && (c = string[i]); i++)\n     {\n       if (paren)\n-\t{\n-\t  if (c == '(')\n-\t    paren++;\n-\t  else if (c == ')')\n-\t    paren--;\n-\n-\t  continue;\n-\t}\n+        {\n+          if (c == '(')\n+            paren++;\n+          else if (c == ')')\n+            paren--;\n+\n+          continue;\n+        }\n       \n       /* If the character following the close paren is a space or period,\n-\t then this node name has no more characters associated with it. */\n+         then this node name has no more characters associated with it. */\n       if (c == '\\t' ||\n-\t  c == ','  ||\n-\t  c == INFO_TAGSEP ||\n-\t  ((!newlines_okay) && (c == '\\n')) ||\n-\t  ((paren_seen && string[i - 1] == ')') &&\n-\t   (c == ' ' || c == '.')) ||\n-\t  (c == '.' &&\n-\t   ((!string[i + 1]) ||\n-\t    (whitespace_or_newline (string[i + 1])) ||\n-\t    (string[i + 1] == ')'))))\n-\tbreak;\n+          c == ','  ||\n+          c == INFO_TAGSEP ||\n+          ((!newlines_okay) && (c == '\\n')) ||\n+          ((paren_seen && string[i - 1] == ')') &&\n+           (c == ' ' || c == '.')) ||\n+          (c == '.' &&\n+           (\n+#if 0\n+/* This test causes a node name ending in a period, like `This.', not to\n+   be found.  The trailing . is stripped.  This occurs in the jargon\n+   file (`I see no X here.' is a node name).  */\n+           (!string[i + 1]) ||\n+#endif\n+            (whitespace_or_newline (string[i + 1])) ||\n+            (string[i + 1] == ')'))))\n+        break;\n     }\n   return (i);\n }\n \n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t     Searching FILE_BUFFER's\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                   Searching FILE_BUFFER's                        */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Return the absolute position of the first occurence of a node separator in\n@@ -397,11 +397,11 @@ find_node_separator (binding)\n      table (if present) and the indirect tags table (if present). */\n   for (i = binding->start; i < binding->end - 1; i++)\n     if (((body[i] == INFO_FF && body[i + 1] == INFO_COOKIE) &&\n-\t (body[i + 2] == '\\n' ||\n-\t  (body[i + 2] == INFO_FF && body[i + 3] == '\\n'))) ||\n-\t((body[i] == INFO_COOKIE) &&\n-\t (body[i + 1] == '\\n' ||\n-\t  (body[i + 1] == INFO_FF && body[i + 2] == '\\n'))))\n+         (body[i + 2] == '\\n' ||\n+          (body[i + 2] == INFO_FF && body[i + 3] == '\\n'))) ||\n+        ((body[i] == INFO_COOKIE) &&\n+         (body[i + 1] == '\\n' ||\n+          (body[i + 1] == INFO_FF && body[i + 2] == '\\n'))))\n       return (i);\n   return (-1);\n }\n@@ -467,7 +467,7 @@ find_tags_table (binding)\n       search.start += skip_node_separator (search.buffer + search.start);\n \n       if (looking_at (TAGS_TABLE_BEG_LABEL, &search))\n-\treturn (position);\n+        return (position);\n     }\n   return (-1);\n }\n@@ -482,8 +482,8 @@ find_node_in_binding (nodename, binding)\n      char *nodename;\n      SEARCH_BINDING *binding;\n {\n-  register long position;\n-  register int offset, namelen;\n+  long position;\n+  int offset, namelen;\n   SEARCH_BINDING search;\n \n   namelen = strlen (nodename);\n@@ -501,19 +501,19 @@ find_node_in_binding (nodename, binding)\n       offset = string_in_line (INFO_NODE_LABEL, search.buffer + search.start);\n \n       if (offset == -1)\n-\tcontinue;\n+        continue;\n \n       search.start += offset;\n       search.start += skip_whitespace (search.buffer + search.start);\n       offset = skip_node_characters\n-\t(search.buffer + search.start, DONT_SKIP_NEWLINES);\n+        (search.buffer + search.start, DONT_SKIP_NEWLINES);\n \n       /* Notice that this is an exact match.  You cannot grovel through\n-\t the buffer with this function looking for random nodes. */\n+         the buffer with this function looking for random nodes. */\n        if ((offset == namelen) &&\n-\t   (search.buffer[search.start] == nodename[0]) &&\n-\t   (strncmp (search.buffer + search.start, nodename, offset) == 0))\n-\t return (position);\n+           (search.buffer[search.start] == nodename[0]) &&\n+           (strncmp (search.buffer + search.start, nodename, offset) == 0))\n+         return (position);\n     }\n   return (-1);\n }"}, {"sha": "6425536f1724b646ae3f0b1e29c75792af05bbfa", "filename": "texinfo/info/search.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fsearch.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* search.h -- Structure used to search large bodies of text, with bounds. */\n+/* search.h -- Structure used to search large bodies of text, with bounds.\n+   $Id: search.h,v 1.3 1997/07/15 18:43:49 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -31,18 +32,18 @@\n    They return a long, which is the offset from the start of the buffer\n    at which the match was found.  An offset of -1 indicates failure. */\n \n-#if !defined (_SEARCH_H_)\n-#define _SEARCH_H_\n+#ifndef INFO_SEARCH_H\n+#define INFO_SEARCH_H\n \n typedef struct {\n-  char *buffer;\t\t\t/* The buffer of text to search. */\n-  long start;\t\t\t/* Offset of the start of the search. */\n-  long end;\t\t\t/* Offset of the end of the searh. */\n-  int flags;\t\t\t/* Flags controlling the type of search. */\n+  char *buffer;                 /* The buffer of text to search. */\n+  long start;                   /* Offset of the start of the search. */\n+  long end;                     /* Offset of the end of the searh. */\n+  int flags;                    /* Flags controlling the type of search. */\n } SEARCH_BINDING;\n \n-#define S_FoldCase\t0x01\t/* Set means fold case in searches. */\n-#define S_SkipDest\t0x02\t/* Set means return pointing after the dest. */\n+#define S_FoldCase      0x01    /* Set means fold case in searches. */\n+#define S_SkipDest      0x02    /* Set means return pointing after the dest. */\n \n SEARCH_BINDING *make_binding (), *copy_binding ();\n extern long search_forward (), search_backward (), search ();\n@@ -71,5 +72,4 @@ extern int skip_node_characters (), skip_node_separator ();\n extern long find_node_separator (), find_tags_table ();\n extern long find_node_in_binding ();\n \n-#endif /* !_SEARCH_H_ */\n-\n+#endif /* not INFO_SEARCH_H */"}, {"sha": "a30bbfe6d746aa1480e83ae91862275f37fa8e44", "filename": "texinfo/info/session.c", "status": "modified", "additions": 1431, "deletions": 1455, "changes": 2886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsession.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsession.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fsession.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc"}, {"sha": "f1e5b23be8a01b3ae0fecb8ba15a96b45f2fb675", "filename": "texinfo/info/session.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsession.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsession.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fsession.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -21,10 +21,10 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_SESSION_H_)\n-#define _SESSION_H_\n+#if !defined (SESSION_H)\n+#define SESSION_H\n \n-#include \"general.h\"\n+#include \"info.h\"\n #include \"dribble.h\"\n \n /* All commands that can be invoked from within info_session () receive\n@@ -55,11 +55,11 @@ extern int info_scroll_behaviour;\n extern char *info_scroll_choices[];\n \n /* Values for info_scroll_behaviour. */\n-#define IS_Continuous 0\t/* Try to get first menu item, or failing that, the\n-\t\t\t   \"Next:\" pointer, or failing that, the \"Up:\" and\n-\t\t\t   \"Next:\" of the up. */\n+#define IS_Continuous 0 /* Try to get first menu item, or failing that, the\n+                           \"Next:\" pointer, or failing that, the \"Up:\" and\n+                           \"Next:\" of the up. */\n #define IS_NextOnly   1 /* Try to get \"Next:\" menu item. */\n-#define IS_PageOnly   2\t/* Simply give up at the bottom of a node. */\n+#define IS_PageOnly   2 /* Simply give up at the bottom of a node. */\n \n /* Utility functions found in session.c */\n extern void info_dispatch_on_key ();\n@@ -143,4 +143,4 @@ extern void info_print_node ();\n /* Miscellaneous commands. */\n extern void info_abort_key (), info_quit (), info_do_lowercase_version ();\n \n-#endif /* _SESSION_H_ */\n+#endif /* SESSION_H */"}, {"sha": "b93a585f567751e7c97b63408614da753128a912", "filename": "texinfo/info/signals.c", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsignals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsignals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fsignals.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -25,9 +25,9 @@\n #include \"signals.h\"\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\tPretending That We Have POSIX Signals\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*              Pretending That We Have POSIX Signals               */\n+/*                                                                  */\n /* **************************************************************** */\n \n #if !defined (HAVE_SIGPROCMASK) && defined (HAVE_SIGSETMASK)\n@@ -57,33 +57,32 @@ sigprocmask (operation, newset, oldset)\n #endif /* !HAVE_SIGPROCMASK && HAVE_SIGSETMASK */\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t    Signal Handling for Info\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                  Signal Handling for Info                        */\n+/*                                                                  */\n /* **************************************************************** */\n \n-typedef void SigHandlerType;\n-typedef SigHandlerType SigHandler ();\n+typedef RETSIGTYPE signal_handler ();\n \n-static SigHandlerType info_signal_handler ();\n-static SigHandler *old_TSTP, *old_TTOU, *old_TTIN;\n-static SigHandler *old_WINCH, *old_INT;\n+static RETSIGTYPE info_signal_handler ();\n+static signal_handler *old_TSTP, *old_TTOU, *old_TTIN;\n+static signal_handler *old_WINCH, *old_INT;\n \n void\n initialize_info_signal_handler ()\n {\n #if defined (SIGTSTP)\n-  old_TSTP = (SigHandler *) signal (SIGTSTP, info_signal_handler);\n-  old_TTOU = (SigHandler *) signal (SIGTTOU, info_signal_handler);\n-  old_TTIN = (SigHandler *) signal (SIGTTIN, info_signal_handler);\n+  old_TSTP = (signal_handler *) signal (SIGTSTP, info_signal_handler);\n+  old_TTOU = (signal_handler *) signal (SIGTTOU, info_signal_handler);\n+  old_TTIN = (signal_handler *) signal (SIGTTIN, info_signal_handler);\n #endif /* SIGTSTP */\n \n #if defined (SIGWINCH)\n-  old_WINCH = (SigHandler *) signal (SIGWINCH, info_signal_handler);\n+  old_WINCH = (signal_handler *) signal (SIGWINCH, info_signal_handler);\n #endif\n \n #if defined (SIGINT)\n-  old_INT = (SigHandler *) signal (SIGINT, info_signal_handler);\n+  old_INT = (signal_handler *) signal (SIGINT, info_signal_handler);\n #endif\n }\n \n@@ -98,11 +97,11 @@ redisplay_after_signal ()\n   fflush (stdout);\n }\n \n-static SigHandlerType\n+static RETSIGTYPE\n info_signal_handler (sig)\n      int sig;\n {\n-  SigHandler **old_signal_handler;\n+  signal_handler **old_signal_handler;\n \n   switch (sig)\n     {\n@@ -116,56 +115,56 @@ info_signal_handler (sig)\n #endif\n       {\n #if defined (SIGTSTP)\n-\tif (sig == SIGTSTP)\n-\t  old_signal_handler = &old_TSTP;\n-\tif (sig == SIGTTOU)\n-\t  old_signal_handler = &old_TTOU;\n-\tif (sig == SIGTTIN)\n-\t  old_signal_handler = &old_TTIN;\n+        if (sig == SIGTSTP)\n+          old_signal_handler = &old_TSTP;\n+        if (sig == SIGTTOU)\n+          old_signal_handler = &old_TTOU;\n+        if (sig == SIGTTIN)\n+          old_signal_handler = &old_TTIN;\n #endif /* SIGTSTP */\n-\tif (sig == SIGINT)\n-\t  old_signal_handler = &old_INT;\n-\n-\t/* For stop signals, restore the terminal IO, leave the cursor\n-\t   at the bottom of the window, and stop us. */\n-\tterminal_goto_xy (0, screenheight - 1);\n-\tterminal_clear_to_eol ();\n-\tfflush (stdout);\n-\tterminal_unprep_terminal ();\n-\tsignal (sig, *old_signal_handler);\n- \tUNBLOCK_SIGNAL (sig);\n-\tkill (getpid (), sig);\n-\n-\t/* The program is returning now.  Restore our signal handler,\n-\t   turn on terminal handling, redraw the screen, and place the\n-\t   cursor where it belongs. */\n-\tterminal_prep_terminal ();\n-\t*old_signal_handler = (SigHandler *) signal (sig, info_signal_handler);\n-\tredisplay_after_signal ();\n-\tfflush (stdout);\n+        if (sig == SIGINT)\n+          old_signal_handler = &old_INT;\n+\n+        /* For stop signals, restore the terminal IO, leave the cursor\n+           at the bottom of the window, and stop us. */\n+        terminal_goto_xy (0, screenheight - 1);\n+        terminal_clear_to_eol ();\n+        fflush (stdout);\n+        terminal_unprep_terminal ();\n+        signal (sig, *old_signal_handler);\n+        UNBLOCK_SIGNAL (sig);\n+        kill (getpid (), sig);\n+\n+        /* The program is returning now.  Restore our signal handler,\n+           turn on terminal handling, redraw the screen, and place the\n+           cursor where it belongs. */\n+        terminal_prep_terminal ();\n+        *old_signal_handler = (signal_handler *) signal (sig, info_signal_handler);\n+        redisplay_after_signal ();\n+        fflush (stdout);\n       }\n       break;\n \n #if defined (SIGWINCH)\n     case SIGWINCH:\n       {\n-\t/* Turn off terminal IO, tell our parent that the window has changed,\n-\t   then reinitialize the terminal and rebuild our windows. */\n-\told_signal_handler = &old_WINCH;\n-\tterminal_goto_xy (0, 0);\n-\tfflush (stdout);\n-\tterminal_unprep_terminal ();\n-\tsignal (sig, *old_signal_handler);\n- \tUNBLOCK_SIGNAL (sig);\n-\tkill (getpid (), sig);\n-\n-\t/* After our old signal handler returns... */\n-\tterminal_get_screen_size ();\n-\tterminal_prep_terminal ();\n-\tdisplay_initialize_display (screenwidth, screenheight);\n-\twindow_new_screen_size (screenwidth, screenheight, (VFunction *)NULL);\n-\t*old_signal_handler = (SigHandler *) signal (sig, info_signal_handler);\n-\tredisplay_after_signal ();\n+        /* Turn off terminal IO, tell our parent that the window has changed,\n+           then reinitialize the terminal and rebuild our windows. */\n+        old_signal_handler = &old_WINCH;\n+        terminal_goto_xy (0, 0);\n+        fflush (stdout);\n+        terminal_unprep_terminal ();\n+        signal (sig, *old_signal_handler);\n+        UNBLOCK_SIGNAL (sig);\n+        kill (getpid (), sig);\n+\n+        /* After our old signal handler returns... */\n+        terminal_get_screen_size ();\n+        terminal_prep_terminal ();\n+        display_initialize_display (screenwidth, screenheight);\n+        window_new_screen_size (screenwidth, screenheight, (VFunction *)NULL);\n+        *old_signal_handler = (signal_handler *) signal (sig, info_signal_handler);\n+        redisplay_after_signal ();\n       }\n       break;\n #endif /* SIGWINCH */"}, {"sha": "3a45925a1831d8a65afaa4e5d765664958a41772", "filename": "texinfo/info/signals.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsignals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fsignals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fsignals.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* signals.h -- Header to include system dependent signal definitions. */\n+/* signals.h -- Header to include system dependent signal definitions.\n+   $Id: signals.h,v 1.3 1997/07/15 18:35:59 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 94, 95, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,11 +22,17 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_SIGNALS_H_)\n-#define _SIGNALS_H_\n+#ifndef INFO_SIGNALS_H\n+#define INFO_SIGNALS_H\n \n+#include <sys/types.h>\n #include <signal.h>\n \n+/* For sysV68 --phdm@info.ucl.ac.be.  */\n+#if !defined (SIGCHLD) && defined (SIGCLD)\n+#define SIGCHLD SIGCLD\n+#endif\n+\n #if !defined (HAVE_SIGPROCMASK) && !defined (sigmask)\n #  define sigmask(x) (1 << ((x)-1))\n #endif /* !HAVE_SIGPROCMASK && !sigmask */\n@@ -86,4 +93,4 @@\n #  define UNBLOCK_SIGNAL(sig)\n #endif /* !HAVE_SIGPROCMASK && !HAVE_SIGSETMASK */\n \n-#endif /* !_SIGNALS_H_ */\n+#endif /* not INFO_SIGNALS_H */"}, {"sha": "2e27268ea7fb02ece53c06f53a0fd5e044358e00", "filename": "texinfo/info/terminal.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fterminal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fterminal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fterminal.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -3,7 +3,7 @@\n /* This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993, 96 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 96, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,15 +21,10 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_TERMINAL_H_)\n-#define _TERMINAL_H_\n+#if !defined (TERMINAL_H)\n+#define TERMINAL_H\n \n-/* We use the following data type to talk about pointers to functions. */\n-#if !defined (__FUNCTION_DEF)\n-#  define __FUNCTION_DEF\n-typedef int Function ();\n-typedef void VFunction ();\n-#endif /* _FUNCTION_DEF */\n+#include \"info.h\"\n \n /* For almost every function externally visible from terminal.c, there is\n    a corresponding \"hook\" function which can be bound in order to replace\n@@ -125,5 +120,6 @@ extern VFunction *terminal_ring_bell_hook;\n \n /* The key sequences output by the arrow keys, if this terminal has any. */\n extern char *term_ku, *term_kd, *term_kr, *term_kl;\n+extern char *term_kP, *term_kN;\n \n-#endif /* !_TERMINAL_H_ */\n+#endif /* !TERMINAL_H */"}, {"sha": "fef953a04dc6350da062ae0b4d51201f0b4b37e9", "filename": "texinfo/info/tilde.c", "status": "modified", "additions": 108, "deletions": 123, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ftilde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ftilde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Ftilde.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,5 +1,5 @@\n /* tilde.c -- Tilde expansion code (~/foo := $HOME/foo).\n-   $Id: tilde.c,v 1.1 1997/08/21 22:58:05 jason Exp $\n+   $Id: tilde.c,v 1.8 1997/07/24 21:49:03 karl Exp $\n \n    This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n@@ -22,6 +22,10 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n+/* Include config.h before doing alloca.  */\n+#include \"info.h\"\n+\n+#ifndef alloca\n #if defined (__GNUC__)\n #  define alloca __builtin_alloca\n #else /* !__GNUC__ */\n@@ -33,28 +37,10 @@\n #    endif /* HAVE_ALLOCA_H */\n #  endif /* !AIX */\n #endif /* !__GNUC__ */\n-\n-#if defined (HAVE_STDLIB_H)\n-#include <stdlib.h>\n-#endif\n-\n-#include \"tilde.h\"\n-#include <pwd.h>\n-\n-#if defined (HAVE_STRING_H)\n-#include <string.h>\n-#endif\n-\n-#include \"clib.h\"\n-\n-#if !defined (NULL)\n-#  define NULL 0x0\n-#endif\n+#endif /* ! defined alloca */\n \n #if defined (TEST) || defined (STATIC_MALLOC)\n static void *xmalloc (), *xrealloc ();\n-#else\n-extern void *xmalloc (), *xrealloc ();\n #endif /* TEST || STATIC_MALLOC */\n \n /* The default value of tilde_additional_prefixes.  This is set to\n@@ -105,16 +91,16 @@ tilde_find_prefix (string, len)\n   if (prefixes)\n     {\n       for (i = 0; i < string_len; i++)\n-\t{\n-\t  for (j = 0; prefixes[j]; j++)\n-\t    {\n-\t      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)\n-\t\t{\n-\t\t  *len = strlen (prefixes[j]) - 1;\n-\t\t  return (i + *len);\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          for (j = 0; prefixes[j]; j++)\n+            {\n+              if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)\n+                {\n+                  *len = strlen (prefixes[j]) - 1;\n+                  return (i + *len);\n+                }\n+            }\n+        }\n     }\n   return (string_len);\n }\n@@ -133,13 +119,13 @@ tilde_find_suffix (string)\n   for (i = 0; i < string_len; i++)\n     {\n       if (string[i] == '/' || !string[i])\n-\tbreak;\n+        break;\n \n       for (j = 0; suffixes && suffixes[j]; j++)\n-\t{\n-\t  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)\n-\t    return (i);\n-\t}\n+        {\n+          if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)\n+            return (i);\n+        }\n     }\n   return (i);\n }\n@@ -167,7 +153,7 @@ tilde_expand (string)\n \n       /* Copy the skipped text into the result. */\n       if ((result_index + start + 1) > result_size)\n-\tresult = (char *)xrealloc (result, 1 + (result_size += (start + 20)));\n+        result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));\n \n       strncpy (result + result_index, string, start);\n       result_index += start;\n@@ -176,12 +162,12 @@ tilde_expand (string)\n       string += start;\n \n       /* Make END be the index of one after the last character of the\n-\t username. */\n+         username. */\n       end = tilde_find_suffix (string);\n \n       /* If both START and END are zero, we are all done. */\n       if (!start && !end)\n-\tbreak;\n+        break;\n \n       /* Expand the entire tilde word, and copy it into RESULT. */\n       tilde_word = (char *)xmalloc (1 + end);\n@@ -194,7 +180,7 @@ tilde_expand (string)\n \n       len = strlen (expansion);\n       if ((result_index + len + 1) > result_size)\n-\tresult = (char *)xrealloc (result, 1 + (result_size += (len + 20)));\n+        result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));\n \n       strcpy (result + result_index, expansion);\n       result_index += len;\n@@ -214,88 +200,87 @@ tilde_expand_word (filename)\n {\n   char *dirname;\n \n-  dirname = filename ? strdup (filename) : (char *)NULL;\n+  dirname = filename ? xstrdup (filename) : (char *)NULL;\n \n   if (dirname && *dirname == '~')\n     {\n       char *temp_name;\n       if (!dirname[1] || dirname[1] == '/')\n-\t{\n-\t  /* Prepend $HOME to the rest of the string. */\n-\t  extern char *getenv ();\n-\t  char *temp_home = getenv (\"HOME\");\n-\n-\t  /* If there is no HOME variable, look up the directory in\n-\t     the password database. */\n-\t  if (!temp_home)\n-\t    {\n-\t      struct passwd *entry;\n-\n-\t      entry = (struct passwd *) getpwuid (getuid ());\n-\t      if (entry)\n-\t\ttemp_home = entry->pw_dir;\n-\t    }\n-\n-\t  temp_name = (char *)\n-\t    alloca (1 + strlen (&dirname[1])\n-\t\t    + (temp_home ? strlen (temp_home) : 0));\n-\t  temp_name[0] = '\\0';\n-\t  if (temp_home)\n-\t    strcpy (temp_name, temp_home);\n-\t  strcat (temp_name, &dirname[1]);\n-\t  free (dirname);\n-\t  dirname = strdup (temp_name);\n-\t}\n+        {\n+          /* Prepend $HOME to the rest of the string. */\n+          char *temp_home = getenv (\"HOME\");\n+\n+          /* If there is no HOME variable, look up the directory in\n+             the password database. */\n+          if (!temp_home)\n+            {\n+              struct passwd *entry;\n+\n+              entry = (struct passwd *) getpwuid (getuid ());\n+              if (entry)\n+                temp_home = entry->pw_dir;\n+            }\n+\n+          temp_name = (char *)\n+            alloca (1 + strlen (&dirname[1])\n+                    + (temp_home ? strlen (temp_home) : 0));\n+          temp_name[0] = '\\0';\n+          if (temp_home)\n+            strcpy (temp_name, temp_home);\n+          strcat (temp_name, &dirname[1]);\n+          free (dirname);\n+          dirname = xstrdup (temp_name);\n+        }\n       else\n-\t{\n-\t  struct passwd *user_entry;\n-\t  char *username = (char *)alloca (257);\n-\t  int i, c;\n-\n-\t  for (i = 1; c = dirname[i]; i++)\n-\t    {\n-\t      if (c == '/')\n-\t\tbreak;\n-\t      else\n-\t\tusername[i - 1] = c;\n-\t    }\n-\t  username[i - 1] = '\\0';\n-\n-\t  if (!(user_entry = (struct passwd *) getpwnam (username)))\n-\t    {\n-\t      /* If the calling program has a special syntax for\n-\t\t expanding tildes, and we couldn't find a standard\n-\t\t expansion, then let them try. */\n-\t      if (tilde_expansion_failure_hook)\n-\t\t{\n-\t\t  char *expansion;\n-\n-\t\t  expansion = (*tilde_expansion_failure_hook) (username);\n-\n-\t\t  if (expansion)\n-\t\t    {\n-\t\t      temp_name = (char *)alloca\n-\t\t\t(1 + strlen (expansion) + strlen (&dirname[i]));\n-\t\t      strcpy (temp_name, expansion);\n-\t\t      strcat (temp_name, &dirname[i]);\n-\t\t      free (expansion);\n-\t\t      goto return_name;\n-\t\t    }\n-\t\t}\n-\t      /* We shouldn't report errors. */\n-\t    }\n-\t  else\n-\t    {\n-\t      temp_name = (char *)alloca\n-\t\t(1 + strlen (user_entry->pw_dir) + strlen (&dirname[i]));\n-\t      strcpy (temp_name, user_entry->pw_dir);\n-\t      strcat (temp_name, &dirname[i]);\n-\t    return_name:\n-\t      free (dirname);\n-\t      dirname = strdup (temp_name);\n-\t    }\n-\t    endpwent ();\n-\t}\n+        {\n+          struct passwd *user_entry;\n+          char *username = (char *)alloca (257);\n+          int i, c;\n+\n+          for (i = 1; (c = dirname[i]); i++)\n+            {\n+              if (c == '/')\n+                break;\n+              else\n+                username[i - 1] = c;\n+            }\n+          username[i - 1] = '\\0';\n+\n+          if (!(user_entry = (struct passwd *) getpwnam (username)))\n+            {\n+              /* If the calling program has a special syntax for\n+                 expanding tildes, and we couldn't find a standard\n+                 expansion, then let them try. */\n+              if (tilde_expansion_failure_hook)\n+                {\n+                  char *expansion;\n+\n+                  expansion = (*tilde_expansion_failure_hook) (username);\n+\n+                  if (expansion)\n+                    {\n+                      temp_name = (char *)alloca\n+                        (1 + strlen (expansion) + strlen (&dirname[i]));\n+                      strcpy (temp_name, expansion);\n+                      strcat (temp_name, &dirname[i]);\n+                      free (expansion);\n+                      goto return_name;\n+                    }\n+                }\n+              /* We shouldn't report errors. */\n+            }\n+          else\n+            {\n+              temp_name = (char *)alloca\n+                (1 + strlen (user_entry->pw_dir) + strlen (&dirname[i]));\n+              strcpy (temp_name, user_entry->pw_dir);\n+              strcat (temp_name, &dirname[i]);\n+            return_name:\n+              free (dirname);\n+              dirname = xstrdup (temp_name);\n+            }\n+            endpwent ();\n+        }\n     }\n   return (dirname);\n }\n@@ -318,15 +303,15 @@ main (argc, argv)\n       fflush (stdout);\n \n       if (!gets (line))\n-\tstrcpy (line, \"done\");\n+        strcpy (line, \"done\");\n \n       if ((strcmp (line, \"done\") == 0) ||\n-\t  (strcmp (line, \"quit\") == 0) ||\n-\t  (strcmp (line, \"exit\") == 0))\n-\t{\n-\t  done = 1;\n-\t  break;\n-\t}\n+          (strcmp (line, \"quit\") == 0) ||\n+          (strcmp (line, \"exit\") == 0))\n+        {\n+          done = 1;\n+          break;\n+        }\n \n       result = tilde_expand (line);\n       printf (\"  --> %s\\n\", result);\n@@ -369,7 +354,7 @@ xrealloc (pointer, bytes)\n static void\n memory_error_and_abort ()\n {\n-  fprintf (stderr, \"readline: Out of virtual memory!\\n\");\n+  fprintf (stderr, _(\"readline: Out of virtual memory!\\n\"));\n   abort ();\n }\n #endif /* TEST */"}, {"sha": "83f534b2bac1764c653719739d1243632fca2bd3", "filename": "texinfo/info/tilde.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ftilde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Ftilde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Ftilde.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -25,13 +25,10 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-/* Function pointers can be declared as (Function *)foo. */\n-#if !defined (__FUNCTION_DEF)\n-#  define __FUNCTION_DEF\n-typedef int Function ();\n-typedef void VFunction ();\n-typedef char *CFunction ();\n-#endif /* _FUNCTION_DEF */\n+#ifndef TILDE_H\n+#define TILDE_H\n+\n+#include \"info.h\"\n \n /* If non-null, this contains the address of a function to call if the\n    standard meaning for expanding a tilde fails.  The function is called\n@@ -56,3 +53,4 @@ extern char *tilde_expand ();\n    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */\n extern char *tilde_expand_word ();\n \n+#endif /* not TILDE_H */"}, {"sha": "248c8af6488bde4aca4db83418203a1cbb0b380a", "filename": "texinfo/info/variables.c", "status": "modified", "additions": 99, "deletions": 96, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fvariables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fvariables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fvariables.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* variables.c -- How to manipulate user visible variables in Info. */\n+/* variables.c -- How to manipulate user visible variables in Info.\n+   $Id: variables.c,v 1.5 1997/07/18 14:34:23 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -25,9 +26,9 @@\n #include \"variables.h\"\n \n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t    User Visible Variables in Info\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                  User Visible Variables in Info                  */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Choices used by the completer when reading a zero/non-zero value for\n@@ -36,73 +37,75 @@ static char *on_off_choices[] = { \"Off\", \"On\", (char *)NULL };\n \n VARIABLE_ALIST info_variables[] = {\n   { \"automatic-footnotes\",\n-      \"When \\\"On\\\", footnotes appear and disappear automatically\",\n+      N_(\"When \\\"On\\\", footnotes appear and disappear automatically\"),\n       &auto_footnotes_p, (char **)on_off_choices },\n \n   { \"automatic-tiling\",\n-      \"When \\\"On\\\", creating or deleting a window resizes other windows\",\n+      N_(\"When \\\"On\\\", creating or deleting a window resizes other windows\"),\n       &auto_tiling_p, (char **)on_off_choices },\n \n   { \"visible-bell\",\n-      \"When \\\"On\\\", flash the screen instead of ringing the bell\",\n+      N_(\"When \\\"On\\\", flash the screen instead of ringing the bell\"),\n       &terminal_use_visible_bell_p, (char **)on_off_choices },\n \n   { \"errors-ring-bell\",\n-      \"When \\\"On\\\", errors cause the bell to ring\",\n+      N_(\"When \\\"On\\\", errors cause the bell to ring\"),\n       &info_error_rings_bell_p, (char **)on_off_choices },\n \n   { \"gc-compressed-files\",\n-      \"When \\\"On\\\", Info garbage collects files which had to be uncompressed\",\n+      N_(\"When \\\"On\\\", Info garbage collects files which had to be uncompressed\"),\n       &gc_compressed_files, (char **)on_off_choices },\n   { \"show-index-match\",\n-      \"When \\\"On\\\", the portion of the matched search string is highlighted\",\n+      N_(\"When \\\"On\\\", the portion of the matched search string is highlighted\"),\n       &show_index_match, (char **)on_off_choices },\n \n   { \"scroll-behaviour\",\n-      \"Controls what happens when scrolling is requested at the end of a node\",\n+      N_(\"Controls what happens when scrolling is requested at the end of a node\"),\n       &info_scroll_behaviour, (char **)info_scroll_choices },\n \n   { \"scroll-step\",\n-      \"The number lines to scroll when the cursor moves out of the window\",\n+      N_(\"The number lines to scroll when the cursor moves out of the window\"),\n       &window_scroll_step, (char **)NULL },\n \n   { \"ISO-Latin\",\n-      \"When \\\"On\\\", Info accepts and displays ISO Latin characters\",\n+      N_(\"When \\\"On\\\", Info accepts and displays ISO Latin characters\"),\n       &ISO_Latin_p, (char **)on_off_choices },\n \n   { (char *)NULL, (char *)NULL, (int *)NULL, (char **)NULL }\n };\n \n-DECLARE_INFO_COMMAND (describe_variable, \"Explain the use of a variable\")\n+DECLARE_INFO_COMMAND (describe_variable, _(\"Explain the use of a variable\"))\n {\n   VARIABLE_ALIST *var;\n   char *description;\n \n   /* Get the variable's name. */\n-  var = read_variable_name (\"Describe variable: \", window);\n+  var = read_variable_name (_(\"Describe variable: \"), window);\n \n   if (!var)\n     return;\n \n-  description = (char *)xmalloc (20 + strlen (var->name) + strlen (var->doc));\n+  description = (char *)xmalloc (20 + strlen (var->name)\n+\t\t\t\t + strlen (_(var->doc)));\n \n   if (var->choices)\n     sprintf (description, \"%s (%s): %s.\",\n-\t     var->name, var->choices[*(var->value)], var->doc);\n+             var->name, var->choices[*(var->value)], _(var->doc));\n   else\n-    sprintf (description, \"%s (%d): %s.\", var->name, *(var->value), var->doc);\n+    sprintf (description, \"%s (%d): %s.\",\n+\t     var->name, *(var->value), _(var->doc));\n \n   window_message_in_echo_area (\"%s\", description);\n   free (description);\n }\n \n-DECLARE_INFO_COMMAND (set_variable, \"Set the value of an Info variable\")\n+DECLARE_INFO_COMMAND (set_variable, _(\"Set the value of an Info variable\"))\n {\n   VARIABLE_ALIST *var;\n   char *line;\n \n   /* Get the variable's name and value. */\n-  var = read_variable_name (\"Set variable: \", window);\n+  var = read_variable_name (_(\"Set variable: \"), window);\n \n   if (!var)\n     return;\n@@ -113,86 +116,86 @@ DECLARE_INFO_COMMAND (set_variable, \"Set the value of an Info variable\")\n \n     if (!var->choices)\n       {\n-\tint potential_value;\n+        int potential_value;\n \n-\tif (info_explicit_arg || count != 1)\n-\t  potential_value = count;\n-\telse\n-\t  potential_value = *(var->value);\n+        if (info_explicit_arg || count != 1)\n+          potential_value = count;\n+        else\n+          potential_value = *(var->value);\n \n-\tsprintf (prompt, \"Set %s to value (%d): \",\n-\t\t var->name, potential_value);\n-\tline = info_read_in_echo_area (active_window, prompt);\n+        sprintf (prompt, _(\"Set %s to value (%d): \"),\n+                 var->name, potential_value);\n+        line = info_read_in_echo_area (active_window, prompt);\n \n-\t/* If no error was printed, clear the echo area. */\n-\tif (!info_error_was_printed)\n-\t  window_clear_echo_area ();\n+        /* If no error was printed, clear the echo area. */\n+        if (!info_error_was_printed)\n+          window_clear_echo_area ();\n \n-\t/* User aborted? */\n-\tif (!line)\n-\t  return;\n+        /* User aborted? */\n+        if (!line)\n+          return;\n \n-\t/* If the user specified a value, get that, otherwise, we are done. */\n-\tcanonicalize_whitespace (line);\n-\tif (*line)\n-\t  *(var->value) = atoi (line);\n-\telse\n-\t  *(var->value) = potential_value;\n+        /* If the user specified a value, get that, otherwise, we are done. */\n+        canonicalize_whitespace (line);\n+        if (*line)\n+          *(var->value) = atoi (line);\n+        else\n+          *(var->value) = potential_value;\n \n-\tfree (line);\n+        free (line);\n       }\n     else\n       {\n-\tregister int i;\n-\tREFERENCE **array = (REFERENCE **)NULL;\n-\tint array_index = 0;\n-\tint array_slots = 0;\n-\n-\tfor (i = 0; var->choices[i]; i++)\n-\t  {\n-\t    REFERENCE *entry;\n-\n-\t    entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));\n-\t    entry->label = strdup (var->choices[i]);\n-\t    entry->nodename = (char *)NULL;\n-\t    entry->filename = (char *)NULL;\n-\n-\t    add_pointer_to_array\n-\t      (entry, array_index, array, array_slots, 10, REFERENCE *);\n-\t  }\n-\n-\tsprintf (prompt, \"Set %s to value (%s): \",\n-\t\t var->name, var->choices[*(var->value)]);\n-\n-\t/* Ask the completer to read a variable value for us. */\n-\tline = info_read_completing_in_echo_area (window, prompt, array);\n-\n-\tinfo_free_references (array);\n-\n-\tif (!echo_area_is_active)\n-\t  window_clear_echo_area ();\n-\n-\t/* User aborted? */\n-\tif (!line)\n-\t  {\n-\t    info_abort_key (active_window, 0, 0);\n-\t    return;\n-\t  }\n-\n-\t/* User accepted default choice?  If so, no change. */\n-\tif (!*line)\n-\t  {\n-\t    free (line);\n-\t    return;\n-\t  }\n-\n-\t/* Find the choice in our list of choices. */\n-\tfor (i = 0; var->choices[i]; i++)\n-\t  if (strcmp (var->choices[i], line) == 0)\n-\t    break;\n-\n-\tif (var->choices[i])\n-\t  *(var->value) = i;\n+        register int i;\n+        REFERENCE **array = (REFERENCE **)NULL;\n+        int array_index = 0;\n+        int array_slots = 0;\n+\n+        for (i = 0; var->choices[i]; i++)\n+          {\n+            REFERENCE *entry;\n+\n+            entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));\n+            entry->label = xstrdup (var->choices[i]);\n+            entry->nodename = (char *)NULL;\n+            entry->filename = (char *)NULL;\n+\n+            add_pointer_to_array\n+              (entry, array_index, array, array_slots, 10, REFERENCE *);\n+          }\n+\n+        sprintf (prompt, _(\"Set %s to value (%s): \"),\n+                 var->name, var->choices[*(var->value)]);\n+\n+        /* Ask the completer to read a variable value for us. */\n+        line = info_read_completing_in_echo_area (window, prompt, array);\n+\n+        info_free_references (array);\n+\n+        if (!echo_area_is_active)\n+          window_clear_echo_area ();\n+\n+        /* User aborted? */\n+        if (!line)\n+          {\n+            info_abort_key (active_window, 0, 0);\n+            return;\n+          }\n+\n+        /* User accepted default choice?  If so, no change. */\n+        if (!*line)\n+          {\n+            free (line);\n+            return;\n+          }\n+\n+        /* Find the choice in our list of choices. */\n+        for (i = 0; var->choices[i]; i++)\n+          if (strcmp (var->choices[i], line) == 0)\n+            break;\n+\n+        if (var->choices[i])\n+          *(var->value) = i;\n       }\n   }\n }\n@@ -259,13 +262,13 @@ make_variable_completions_array ()\n     {\n       REFERENCE *entry;\n \n-      entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));\n-      entry->label = strdup (info_variables[i].name);\n+      entry = (REFERENCE *) xmalloc (sizeof (REFERENCE));\n+      entry->label = xstrdup (info_variables[i].name);\n       entry->nodename = (char *)NULL;\n       entry->filename = (char *)NULL;\n \n       add_pointer_to_array\n-\t(entry, array_index, array, array_slots, 200, REFERENCE *);\n+        (entry, array_index, array, array_slots, 200, REFERENCE *);\n     }\n \n   return (array);"}, {"sha": "1afcfb8d72dd3ed16663a9ac620aef13ed4bdfdb", "filename": "texinfo/info/variables.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fvariables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fvariables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fvariables.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* variables.h -- Description of user visible variables in Info. */\n+/* variables.h -- Description of user visible variables in Info.\n+   $Id: variables.h,v 1.3 1997/07/15 18:44:23 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_VARIABLES_H_)\n-#define _VARIABLES_H_\n+#ifndef INFO_VARIABLES_H\n+#define INFO_VARIABLES_H\n \n /* A variable (in the Info sense) is an integer value with a user-visible\n    name.  You may supply an array of strings to complete over when the\n@@ -32,10 +33,10 @@\n \n /* Structure describing a user visible variable. */\n typedef struct {\n-  char *name;\t\t\t/* Polite name. */\n-  char *doc;\t\t\t/* Documentation string. */\n-  int *value;\t\t\t/* Address of value. */\n-  char **choices;\t\t/* Array of strings or NULL if numeric only. */\n+  char *name;                   /* Polite name. */\n+  char *doc;                    /* Documentation string. */\n+  int *value;                   /* Address of value. */\n+  char **choices;               /* Array of strings or NULL if numeric only. */\n } VARIABLE_ALIST;\n \n /* Read the name of an Info variable in the echo area and return the\n@@ -61,4 +62,4 @@ extern int info_scroll_behaviour;\n extern int window_scroll_step;\n extern int ISO_Latin_p;\n \n-#endif /* _VARIABLES_H_ */\n+#endif /* not INFO_VARIABLES_H */"}, {"sha": "56a310838e253edb7b59f82dfc7d2a327c38e2f2", "filename": "texinfo/info/window.c", "status": "modified", "additions": 326, "deletions": 328, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fwindow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fwindow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fwindow.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* window.c -- Windows in Info. */\n+/* window.c -- Windows in Info.\n+   $Id: window.c,v 1.4 1997/07/15 18:35:59 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,10 +22,7 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n+#include \"info.h\"\n #include \"nodes.h\"\n #include \"window.h\"\n #include \"display.h\"\n@@ -136,36 +134,36 @@ window_new_screen_size (width, height)\n   while ((height - echo_area_required) / numwins <= WINDOW_MIN_SIZE)\n     {\n       /* If only one window, make the size of it be zero, and return\n-\t immediately. */\n+         immediately. */\n       if (!windows->next)\n-\t{\n-\t  windows->height = 0;\n-\t  maybe_free (windows->line_starts);\n-\t  windows->line_starts = (char **)NULL;\n-\t  windows->line_count = 0;\n-\t  break;\n-\t}\n+        {\n+          windows->height = 0;\n+          maybe_free (windows->line_starts);\n+          windows->line_starts = (char **)NULL;\n+          windows->line_count = 0;\n+          break;\n+        }\n \n       /* If we have some temporary windows, delete one of them. */\n       for (win = windows; win; win = win->next)\n-\tif (win->flags & W_TempWindow)\n-\t  break;\n+        if (win->flags & W_TempWindow)\n+          break;\n \n       /* Otherwise, delete the first window, and try again. */\n       if (!win)\n-\twin = windows;\n+        win = windows;\n \n       if (window_deletion_notifier)\n-\t(*window_deletion_notifier) (win);\n+        (*window_deletion_notifier) (win);\n \n       window_delete_window (win);\n       numwins--;\n     }\n \n   /* The screen has changed height and width. */\n-  delta_height = height - the_screen->height;\t/* This is how much. */\n-  the_screen->height = height;\t\t\t/* This is the new height. */\n-  the_screen->width = width;\t\t\t/* This is the new width. */\n+  delta_height = height - the_screen->height;   /* This is how much. */\n+  the_screen->height = height;                  /* This is the new height. */\n+  the_screen->width = width;                    /* This is the new width. */\n \n   /* Set the start of the echo area. */\n   the_echo_area->first_row = height - the_echo_area->height;\n@@ -186,34 +184,34 @@ window_new_screen_size (width, height)\n   for (win = windows; win; win = win->next)\n     {\n       if ((win->width != width) && ((win->flags & W_InhibitMode) == 0))\n-\t{\n-\t  win->width = width;\n-\t  maybe_free (win->modeline);\n-\t  win->modeline = (char *)xmalloc (1 + width);\n-\t}\n+        {\n+          win->width = width;\n+          maybe_free (win->modeline);\n+          win->modeline = (char *)xmalloc (1 + width);\n+        }\n \n       win->height += delta_each;\n \n       /* If the previous height of this window was zero, it was the only\n-\t window, and it was not visible.  Thus we need to compensate for\n-\t the echo_area. */\n+         window, and it was not visible.  Thus we need to compensate for\n+         the echo_area. */\n       if (win->height == delta_each)\n-\twin->height -= (1 + the_echo_area->height);\n+        win->height -= (1 + the_echo_area->height);\n \n       /* If this is not the first window in the chain, then change the\n-\t first row of it.  We cannot just add delta_each to the first row,\n-\t since this window's first row is the sum of the collective increases\n-\t that have gone before it.  So we just add one to the location of the\n-\t previous window's modeline. */\n+         first row of it.  We cannot just add delta_each to the first row,\n+         since this window's first row is the sum of the collective increases\n+         that have gone before it.  So we just add one to the location of the\n+         previous window's modeline. */\n       if (win->prev)\n-\twin->first_row = (win->prev->first_row + win->prev->height) + 1;\n+        win->first_row = (win->prev->first_row + win->prev->height) + 1;\n \n       /* The last window in the chain gets the extra space (or shrinkage). */\n       if (!win->next)\n-\twin->height += delta_leftover;\n+        win->height += delta_leftover;\n \n       if (win->node)\n-\trecalculate_line_starts (win);\n+        recalculate_line_starts (win);\n \n       win->flags |= W_UpdateWindow;\n     }\n@@ -232,32 +230,32 @@ window_new_screen_size (width, height)\n       win = windows;\n \n       while (win)\n-\t{\n-\t  if ((win->height < WINDOW_MIN_HEIGHT) ||\n-\t      (win->height > avail))\n-\t    {\n-\t      WINDOW *lastwin;\n-\n-\t      /* Split the space among the available windows. */\n-\t      delta_each = avail / numwins;\n-\t      delta_leftover = avail - (delta_each * numwins);\n-\n-\t      for (win = windows; win; win = win->next)\n-\t\t{\n-\t\t  lastwin = win;\n-\t\t  if (win->prev)\n-\t\t    win->first_row =\n-\t\t      (win->prev->first_row + win->prev->height) + 1;\n-\t\t  win->height = delta_each;\n-\t\t}\n-\n-\t      /* Give the leftover space (if any) to the last window. */\n-\t      lastwin->height += delta_leftover;\n-\t      break;\n-\t    }\n-\t  else\n-\t    win= win->next;\n-\t}\n+        {\n+          if ((win->height < WINDOW_MIN_HEIGHT) ||\n+              (win->height > avail))\n+            {\n+              WINDOW *lastwin;\n+\n+              /* Split the space among the available windows. */\n+              delta_each = avail / numwins;\n+              delta_leftover = avail - (delta_each * numwins);\n+\n+              for (win = windows; win; win = win->next)\n+                {\n+                  lastwin = win;\n+                  if (win->prev)\n+                    win->first_row =\n+                      (win->prev->first_row + win->prev->height) + 1;\n+                  win->height = delta_each;\n+                }\n+\n+              /* Give the leftover space (if any) to the last window. */\n+              lastwin->height += delta_leftover;\n+              break;\n+            }\n+          else\n+            win= win->next;\n+        }\n     }\n }\n \n@@ -412,25 +410,25 @@ window_change_window_height (window, amount)\n   /* WINDOW decreasing in size? */\n   if (amount < 0)\n     {\n-      int abs_amount = -amount;\t/* It is easier to deal with this way. */\n+      int abs_amount = -amount; /* It is easier to deal with this way. */\n \n       /* If the resultant window would be too small, stop here. */\n       if ((window->height - abs_amount) < WINDOW_MIN_HEIGHT)\n-\treturn;\n+        return;\n \n       /* If we have two neighboring windows, choose the smaller one to get\n-\t larger. */\n+         larger. */\n       if (next && prev)\n-\t{\n-\t  if (prev->height < next->height)\n-\t    shrink_me_growing_prev (window, prev, abs_amount);\n-\t  else\n-\t    shrink_me_growing_next (window, next, abs_amount);\n-\t}\n+        {\n+          if (prev->height < next->height)\n+            shrink_me_growing_prev (window, prev, abs_amount);\n+          else\n+            shrink_me_growing_next (window, next, abs_amount);\n+        }\n       else if (next)\n-\tshrink_me_growing_next (window, next, abs_amount);\n+        shrink_me_growing_next (window, next, abs_amount);\n       else\n-\tshrink_me_growing_prev (window, prev, abs_amount);\n+        shrink_me_growing_prev (window, prev, abs_amount);\n     }\n \n   /* WINDOW increasing in size? */\n@@ -439,65 +437,65 @@ window_change_window_height (window, amount)\n       int total_avail, next_avail = 0, prev_avail = 0;\n \n       if (next)\n-\tnext_avail = next->height - WINDOW_MIN_SIZE;\n+        next_avail = next->height - WINDOW_MIN_SIZE;\n \n       if (prev)\n-\tprev_avail = prev->height - WINDOW_MIN_SIZE;\n+        prev_avail = prev->height - WINDOW_MIN_SIZE;\n \n       total_avail = next_avail + prev_avail;\n \n       /* If there isn't enough space available to grow this window, give up. */\n       if (amount > total_avail)\n-\treturn;\n+        return;\n \n       /* If there aren't two neighboring windows, or if one of the neighbors\n-\t is larger than the other one by at least AMOUNT, grow that one. */\n+         is larger than the other one by at least AMOUNT, grow that one. */\n       if ((next && !prev) || ((next_avail - amount) >= prev_avail))\n-\tgrow_me_shrinking_next (window, next, amount);\n+        grow_me_shrinking_next (window, next, amount);\n       else if ((prev && !next) || ((prev_avail - amount) >= next_avail))\n-\tgrow_me_shrinking_prev (window, prev, amount);\n+        grow_me_shrinking_prev (window, prev, amount);\n       else\n-\t{\n-\t  int change;\n-\n-\t  /* This window has two neighbors.  They both must be shrunk in to\n-\t     make enough space for WINDOW to grow.  Make them both the same\n-\t     size. */\n-\t  if (prev_avail > next_avail)\n-\t    {\n-\t      change = prev_avail - next_avail;\n-\t      grow_me_shrinking_prev (window, prev, change);\n-\t      amount -= change;\n-\t    }\n-\t  else\n-\t    {\n-\t      change = next_avail - prev_avail;\n-\t      grow_me_shrinking_next (window, next, change);\n-\t      amount -= change;\n-\t    }\n-\n-\t  /* Both neighbors are the same size.  Split the difference in\n-\t     AMOUNT between them. */\n-\t  while (amount)\n-\t    {\n-\t      window->height++;\n-\t      amount--;\n-\n-\t      /* Odd numbers grow next, even grow prev. */\n-\t      if (amount & 1)\n-\t\t{\n-\t\t  prev->height--;\n-\t\t  window->first_row--;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  next->height--;\n-\t\t  next->first_row++;\n-\t\t}\n-\t    }\n-\t  window_adjust_pagetop (prev);\n-\t  window_adjust_pagetop (next);\n-\t}\n+        {\n+          int change;\n+\n+          /* This window has two neighbors.  They both must be shrunk in to\n+             make enough space for WINDOW to grow.  Make them both the same\n+             size. */\n+          if (prev_avail > next_avail)\n+            {\n+              change = prev_avail - next_avail;\n+              grow_me_shrinking_prev (window, prev, change);\n+              amount -= change;\n+            }\n+          else\n+            {\n+              change = next_avail - prev_avail;\n+              grow_me_shrinking_next (window, next, change);\n+              amount -= change;\n+            }\n+\n+          /* Both neighbors are the same size.  Split the difference in\n+             AMOUNT between them. */\n+          while (amount)\n+            {\n+              window->height++;\n+              amount--;\n+\n+              /* Odd numbers grow next, even grow prev. */\n+              if (amount & 1)\n+                {\n+                  prev->height--;\n+                  window->first_row--;\n+                }\n+              else\n+                {\n+                  next->height--;\n+                  next->first_row++;\n+                }\n+            }\n+          window_adjust_pagetop (prev);\n+          window_adjust_pagetop (next);\n+        }\n     }\n   if (prev)\n     prev->flags |= W_UpdateWindow;\n@@ -526,10 +524,10 @@ window_tile_windows (style)\n \n   for (win = windows; win; win = win->next)\n     if (do_internals || !win->node ||\n-\t(win->node->flags & N_IsInternal) == 0)\n+        (win->node->flags & N_IsInternal) == 0)\n       {\n-\tavail += win->height;\n-\tnumwins++;\n+        avail += win->height;\n+        numwins++;\n       }\n \n   if (numwins <= 1 || !the_screen->height)\n@@ -544,11 +542,11 @@ window_tile_windows (style)\n   for (win = windows; win; win = win->next)\n     {\n       if (do_internals || !win->node ||\n-\t  (win->node->flags & N_IsInternal) == 0)\n-\t{\n-\t  last_adjusted = win;\n-\t  win->height = per_win_height;\n-\t}\n+          (win->node->flags & N_IsInternal) == 0)\n+        {\n+          last_adjusted = win;\n+          win->height = per_win_height;\n+        }\n     }\n \n   if (last_adjusted)\n@@ -558,7 +556,7 @@ window_tile_windows (style)\n   for (win = windows; win; win = win->next)\n     {\n       if (win->prev)\n-\twin->first_row = win->prev->first_row + win->prev->height + 1;\n+        win->first_row = win->prev->first_row + win->prev->height + 1;\n \n       window_adjust_pagetop (win);\n       win->flags |= W_UpdateWindow;\n@@ -591,11 +589,11 @@ window_toggle_wrap (window)\n       window_adjust_pagetop (window);\n \n       /* If the pagetop hasn't changed maybe we can do some scrolling now\n-\t to speed up the display.  Many of the line starts will be the same,\n-\t so scrolling here is a very good optimization.*/\n+         to speed up the display.  Many of the line starts will be the same,\n+         so scrolling here is a very good optimization.*/\n       if (old_pagetop == window->pagetop)\n-\tdisplay_scroll_line_starts\n-\t  (window, old_pagetop, old_starts, old_lines);\n+        display_scroll_line_starts\n+          (window, old_pagetop, old_starts, old_lines);\n       maybe_free (old_starts);\n     }\n   window->flags |= W_UpdateWindow;\n@@ -650,12 +648,12 @@ window_delete_window (window)\n   if (window == active_window)\n     {\n       /* If there isn't a next window, then there must be a previous one,\n-\t since we cannot delete the last window.  If there is a next window,\n-\t prefer to use that as the active window. */\n+         since we cannot delete the last window.  If there is a next window,\n+         prefer to use that as the active window. */\n       if (next)\n-\tactive_window = next;\n+        active_window = next;\n       else\n-\tactive_window = prev;\n+        active_window = prev;\n     }\n \n   if (next && active_window == next)\n@@ -674,13 +672,13 @@ window_delete_window (window)\n       int diff;\n \n       /* Try to adjust the visible part of the node so that as little\n-\t text as possible has to move. */\n+         text as possible has to move. */\n       diff = window_to_fix->first_row - window->first_row;\n       window_to_fix->first_row = window->first_row;\n \n       window_to_fix->pagetop -= diff;\n       if (window_to_fix->pagetop < 0)\n-\twindow_to_fix->pagetop = 0;\n+        window_to_fix->pagetop = 0;\n     }\n \n   /* The `+ 1' is to offset the difference between the first_row locations.\n@@ -732,17 +730,17 @@ character_width (character, hpos)\n   else if (iscntrl (character))\n     {\n       switch (character)\n-\t{\n-\tcase '\\r':\n-\tcase '\\n':\n-\t  width = the_screen->width - hpos;\n-\t  break;\n-\tcase '\\t':\n-\t  width = ((hpos + 8) & 0xf8) - hpos;\n-\t  break;\n-\tdefault:\n-\t  width = 2;\n-\t}\n+        {\n+        case '\\r':\n+        case '\\n':\n+          width = the_screen->width - hpos;\n+          break;\n+        case '\\t':\n+          width = ((hpos + 8) & 0xf8) - hpos;\n+          break;\n+        default:\n+          width = 2;\n+        }\n     }\n   else if (character == DEL)\n     width = 2;\n@@ -820,61 +818,61 @@ calculate_line_starts (window)\n       unsigned int cwidth, c;\n \n       add_pointer_to_array (line, line_starts_index, line_starts,\n-\t\t\t    line_starts_slots, 100, char *);\n+                            line_starts_slots, 100, char *);\n       if (bump_index)\n-\t{\n-\t  i++;\n-\t  bump_index = 0;\n-\t}\n+        {\n+          i++;\n+          bump_index = 0;\n+        }\n \n       while (1)\n-\t{\n-\t  c = node->contents[i];\n-\t  cwidth = character_width (c, hpos);\n-\n-\t  /* If this character fits within this line, just do the next one. */\n-\t  if ((hpos + cwidth) < window->width)\n-\t    {\n-\t      i++;\n-\t      hpos += cwidth;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If this character would position the cursor at the start of\n-\t\t the next printed screen line, then do the next line. */\n-\t      if (c == '\\n' || c == '\\r' || c == '\\t')\n-\t\t{\n-\t\t  i++;\n-\t\t  hpos = 0;\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* This character passes the window width border.  Postion\n-\t\t     the cursor after the printed character, but remember this\n-\t\t     line start as where this character is.  A bit tricky. */\n-\n-\t\t  /* If this window doesn't wrap lines, proceed to the next\n-\t\t     physical line here. */\n-\t\t  if (window->flags & W_NoWrap)\n-\t\t    {\n-\t\t      hpos = 0;\n-\t\t      while (i < node->nodelen && node->contents[i] != '\\n')\n-\t\t\ti++;\n-\n-\t\t      if (node->contents[i] == '\\n')\n-\t\t\ti++;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      hpos = the_screen->width - hpos;\n-\t\t      bump_index++;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          c = node->contents[i];\n+          cwidth = character_width (c, hpos);\n+\n+          /* If this character fits within this line, just do the next one. */\n+          if ((hpos + cwidth) < window->width)\n+            {\n+              i++;\n+              hpos += cwidth;\n+              continue;\n+            }\n+          else\n+            {\n+              /* If this character would position the cursor at the start of\n+                 the next printed screen line, then do the next line. */\n+              if (c == '\\n' || c == '\\r' || c == '\\t')\n+                {\n+                  i++;\n+                  hpos = 0;\n+                  break;\n+                }\n+              else\n+                {\n+                  /* This character passes the window width border.  Postion\n+                     the cursor after the printed character, but remember this\n+                     line start as where this character is.  A bit tricky. */\n+\n+                  /* If this window doesn't wrap lines, proceed to the next\n+                     physical line here. */\n+                  if (window->flags & W_NoWrap)\n+                    {\n+                      hpos = 0;\n+                      while (i < node->nodelen && node->contents[i] != '\\n')\n+                        i++;\n+\n+                      if (node->contents[i] == '\\n')\n+                        i++;\n+                    }\n+                  else\n+                    {\n+                      hpos = the_screen->width - hpos;\n+                      bump_index++;\n+                    }\n+                  break;\n+                }\n+            }\n+        }\n     }\n   window->line_starts = line_starts;\n   window->line_count = line_starts_index;\n@@ -916,7 +914,7 @@ window_adjust_pagetop (window)\n       line_start = window->line_starts[line];\n \n       if ((line_start - contents) > window->point)\n-\tbreak;\n+        break;\n     }\n \n   /* The line index preceding the line start which is past point is the\n@@ -929,26 +927,26 @@ window_adjust_pagetop (window)\n       (line - window->pagetop > (window->height - 1)))\n     {\n       /* The user-settable variable \"scroll-step\" is used to attempt\n-\t to make point visible, iff it is non-zero.  If that variable\n-\t is zero, then the line containing point is centered within\n-\t the window. */\n+         to make point visible, iff it is non-zero.  If that variable\n+         is zero, then the line containing point is centered within\n+         the window. */\n       if (window_scroll_step < window->height)\n-\t{\n-\t  if ((line < window->pagetop) &&\n-\t      ((window->pagetop - window_scroll_step) <= line))\n-\t    window->pagetop -= window_scroll_step;\n-\t  else if ((line - window->pagetop > (window->height - 1)) &&\n-\t\t   ((line - (window->pagetop + window_scroll_step)\n-\t\t     < window->height)))\n-\t    window->pagetop += window_scroll_step;\n-\t  else\n-\t    window->pagetop = line - ((window->height - 1) / 2);\n-\t}\n+        {\n+          if ((line < window->pagetop) &&\n+              ((window->pagetop - window_scroll_step) <= line))\n+            window->pagetop -= window_scroll_step;\n+          else if ((line - window->pagetop > (window->height - 1)) &&\n+                   ((line - (window->pagetop + window_scroll_step)\n+                     < window->height)))\n+            window->pagetop += window_scroll_step;\n+          else\n+            window->pagetop = line - ((window->height - 1) / 2);\n+        }\n       else\n-\twindow->pagetop = line - ((window->height - 1) / 2);\n+        window->pagetop = line - ((window->height - 1) / 2);\n \n       if (window->pagetop < 0)\n-\twindow->pagetop = 0;\n+        window->pagetop = 0;\n       window->flags |= W_UpdateWindow;\n     }\n }\n@@ -970,7 +968,7 @@ window_line_of_point (window)\n   for (i = start; i < window->line_count; i++)\n     {\n       if ((window->line_starts[i] - window->node->contents) > window->point)\n-\tbreak;\n+        break;\n     }\n \n   return (i - 1);\n@@ -1029,7 +1027,7 @@ window_chars_to_goal (line, goal)\n       check = hpos + character_width (line[i], hpos);\n \n       if (check > goal)\n-\tbreak;\n+        break;\n \n       hpos = check;\n     }\n@@ -1056,26 +1054,26 @@ window_make_modeline (window)\n   if (window->pagetop == 0)\n     {\n       if (lines_remaining <= window->height)\n-\tstrcpy (location_indicator, \"All\");\n+        strcpy (location_indicator, \"All\");\n       else\n-\tstrcpy (location_indicator, \"Top\");\n+        strcpy (location_indicator, \"Top\");\n     }\n   else\n     {\n       if (lines_remaining <= window->height)\n-\tstrcpy (location_indicator, \"Bot\");\n+        strcpy (location_indicator, \"Bot\");\n       else\n-\t{\n-\t  float pt, lc;\n-\t  int percentage;\n+        {\n+          float pt, lc;\n+          int percentage;\n \n-\t  pt = (float)window->pagetop;\n-\t  lc = (float)window->line_count;\n+          pt = (float)window->pagetop;\n+          lc = (float)window->line_count;\n \n-\t  percentage = 100 * (pt / lc);\n+          percentage = 100 * (pt / lc);\n \n-\t  sprintf (location_indicator, \"%2d%%\", percentage);\n-\t}\n+          sprintf (location_indicator, \"%2d%%\", percentage);\n+        }\n     }\n \n   /* Calculate the maximum size of the information to stick in MODELINE. */\n@@ -1088,49 +1086,49 @@ window_make_modeline (window)\n \n     if (node)\n       {\n-\tif (node->nodename)\n-\t  nodename = node->nodename;\n+        if (node->nodename)\n+          nodename = node->nodename;\n \n-\tif (node->parent)\n-\t  {\n-\t    parent = filename_non_directory (node->parent);\n-\t    modeline_len += strlen (\"Subfile: \") + strlen (node->filename);\n-\t  }\n+        if (node->parent)\n+          {\n+            parent = filename_non_directory (node->parent);\n+            modeline_len += strlen (\"Subfile: \") + strlen (node->filename);\n+          }\n \n-\tif (node->filename)\n-\t  filename = filename_non_directory (node->filename);\n+        if (node->filename)\n+          filename = filename_non_directory (node->filename);\n \n-\tif (node->flags & N_UpdateTags)\n-\t  update_message = \"--*** Tags out of Date ***\";\n+        if (node->flags & N_UpdateTags)\n+          update_message = _(\"--*** Tags out of Date ***\");\n       }\n \n     if (update_message)\n       modeline_len += strlen (update_message);\n     modeline_len += strlen (filename);\n     modeline_len += strlen (nodename);\n-    modeline_len += 4;\t\t/* strlen (location_indicator). */\n+    modeline_len += 4;          /* strlen (location_indicator). */\n \n     /* 10 for the decimal representation of the number of lines in this\n        node, and the remainder of the text that can appear in the line. */\n-    modeline_len += 10 + strlen (\"-----Info: (), lines ----, \");\n+    modeline_len += 10 + strlen (_(\"-----Info: (), lines ----, \"));\n     modeline_len += window->width;\n \n     modeline = (char *)xmalloc (1 + modeline_len);\n \n     /* Special internal windows have no filename. */\n     if (!parent && !*filename)\n-      sprintf (modeline, \"-%s---Info: %s, %d lines --%s--\",\n-\t       (window->flags & W_NoWrap) ? \"$\" : \"-\",\n-\t       nodename, window->line_count, location_indicator);\n+      sprintf (modeline, _(\"-%s---Info: %s, %d lines --%s--\"),\n+               (window->flags & W_NoWrap) ? \"$\" : \"-\",\n+               nodename, window->line_count, location_indicator);\n     else\n-      sprintf (modeline, \"-%s%s-Info: (%s)%s, %d lines --%s--\",\n-\t       (window->flags & W_NoWrap) ? \"$\" : \"-\",\n-\t       (node && (node->flags & N_IsCompressed)) ? \"zz\" : \"--\",\n-\t       parent ? parent : filename,\n-\t       nodename, window->line_count, location_indicator);\n+      sprintf (modeline, _(\"-%s%s-Info: (%s)%s, %d lines --%s--\"),\n+               (window->flags & W_NoWrap) ? \"$\" : \"-\",\n+               (node && (node->flags & N_IsCompressed)) ? \"zz\" : \"--\",\n+               parent ? parent : filename,\n+               nodename, window->line_count, location_indicator);\n \n     if (parent)\n-      sprintf (modeline + strlen (modeline), \" Subfile: %s\", filename);\n+      sprintf (modeline + strlen (modeline), _(\" Subfile: %s\"), filename);\n \n     if (update_message)\n       sprintf (modeline + strlen (modeline), \"%s\", update_message);\n@@ -1141,9 +1139,9 @@ window_make_modeline (window)\n       modeline[window->width] = '\\0';\n     else\n       {\n-\twhile (i < window->width)\n-\t  modeline[i++] = '-';\n-\tmodeline[i] = '\\0';\n+        while (i < window->width)\n+          modeline[i++] = '-';\n+        modeline[i] = '\\0';\n       }\n \n     strcpy (window->modeline, modeline);\n@@ -1197,9 +1195,9 @@ window_set_state (window, state)\n \n \f\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t   Manipulating Home-Made Nodes\t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                 Manipulating Home-Made Nodes                     */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* A place to buffer echo area messages. */\n@@ -1259,8 +1257,8 @@ message_in_echo_area (format, arg1, arg2)\n   if (echo_area_node)\n     {\n       add_pointer_to_array (echo_area_node, old_echo_area_nodes_index,\n-\t\t\t    old_echo_area_nodes, old_echo_area_nodes_slots,\n-\t\t\t    4, NODE *);\n+                            old_echo_area_nodes, old_echo_area_nodes_slots,\n+                            4, NODE *);\n     }\n   echo_area_node = (NODE *)NULL;\n   window_message_in_echo_area (format, arg1, arg2);\n@@ -1299,7 +1297,7 @@ message_buffer_resize (length)\n   while (message_buffer_size <= message_buffer_index + length)\n     message_buffer = (char *)\n       xrealloc (message_buffer,\n-\t\tmessage_buffer_size += 100 + (2 * length));\n+                message_buffer_size += 100 + (2 * length));\n }\n \n /* Format MESSAGE_BUFFER with the results of printing FORMAT with ARG1 and\n@@ -1323,70 +1321,70 @@ build_message_buffer (format, arg1, arg2)\n   for (i = 0; format[i]; i++)\n     {\n       if (format[i] != '%')\n-\t{\n-\t  message_buffer[message_buffer_index++] = format[i];\n-\t  len--;\n-\t}\n+        {\n+          message_buffer[message_buffer_index++] = format[i];\n+          len--;\n+        }\n       else\n-\t{\n-\t  char c;\n-\n-\t  c = format[++i];\n-\n-\t  switch (c)\n-\t    {\n-\t    case '%':\t\t/* Insert a percent sign. */\n-\t      message_buffer_resize (len + 1);\n-\t      message_buffer[message_buffer_index++] = '%';\n-\t      break;\n-\n-\t    case 's':\t\t/* Insert the current arg as a string. */\n-\t      {\n-\t\tchar *string;\n-\t\tint string_len;\n-\n-\t\tstring = (char *)args[arg_index++];\n-\t\tstring_len = strlen (string);\n-\n-\t\tmessage_buffer_resize (len + string_len);\n-\t\tsprintf\n-\t\t  (message_buffer + message_buffer_index, \"%s\", string);\n-\t\tmessage_buffer_index += string_len;\n-\t      }\n-\t      break;\n-\n-\t    case 'd':\t\t/* Insert the current arg as an integer. */\n-\t      {\n-\t\tlong long_val;\n-\t\tint integer;\n-\n-\t\tlong_val = (long)args[arg_index++];\n-\t\tinteger = (int)long_val;\n-\n-\t\tmessage_buffer_resize (len + 32);\n-\t\tsprintf\n-\t\t  (message_buffer + message_buffer_index, \"%d\", integer);\n-\t\tmessage_buffer_index = strlen (message_buffer);\n-\t      }\n-\t      break;\n-\n-\t    case 'c':\t\t/* Insert the current arg as a character. */\n-\t      {\n-\t\tlong long_val;\n-\t\tint character;\n-\n-\t\tlong_val = (long)args[arg_index++];\n-\t\tcharacter = (int)long_val;\n-\n-\t\tmessage_buffer_resize (len + 1);\n-\t\tmessage_buffer[message_buffer_index++] = character;\n-\t      }\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t}\n+        {\n+          char c;\n+\n+          c = format[++i];\n+\n+          switch (c)\n+            {\n+            case '%':           /* Insert a percent sign. */\n+              message_buffer_resize (len + 1);\n+              message_buffer[message_buffer_index++] = '%';\n+              break;\n+\n+            case 's':           /* Insert the current arg as a string. */\n+              {\n+                char *string;\n+                int string_len;\n+\n+                string = (char *)args[arg_index++];\n+                string_len = strlen (string);\n+\n+                message_buffer_resize (len + string_len);\n+                sprintf\n+                  (message_buffer + message_buffer_index, \"%s\", string);\n+                message_buffer_index += string_len;\n+              }\n+              break;\n+\n+            case 'd':           /* Insert the current arg as an integer. */\n+              {\n+                long long_val;\n+                int integer;\n+\n+                long_val = (long)args[arg_index++];\n+                integer = (int)long_val;\n+\n+                message_buffer_resize (len + 32);\n+                sprintf\n+                  (message_buffer + message_buffer_index, \"%d\", integer);\n+                message_buffer_index = strlen (message_buffer);\n+              }\n+              break;\n+\n+            case 'c':           /* Insert the current arg as a character. */\n+              {\n+                long long_val;\n+                int character;\n+\n+                long_val = (long)args[arg_index++];\n+                character = (int)long_val;\n+\n+                message_buffer_resize (len + 1);\n+                message_buffer[message_buffer_index++] = character;\n+              }\n+              break;\n+\n+            default:\n+              abort ();\n+            }\n+        }\n     }\n   message_buffer[message_buffer_index] = '\\0';\n }\n@@ -1474,7 +1472,7 @@ pad_to (count, string)\n   else\n     {\n       while (i < count)\n-\tstring[i++] = ' ';\n+        string[i++] = ' ';\n     }\n   string[i] = '\\0';\n "}, {"sha": "17367cbd5a405331be49b45e798e337691e18340", "filename": "texinfo/info/window.h", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fwindow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Finfo%2Fwindow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Finfo%2Fwindow.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,9 +1,10 @@\n-/* window.h -- Structure and flags used in manipulating Info windows. */\n+/* window.h -- Structure and flags used in manipulating Info windows.\n+   $Id: window.h,v 1.4 1997/07/15 18:45:47 karl Exp $\n \n-/* This file is part of GNU Info, a program for reading online documentation\n+   This file is part of GNU Info, a program for reading online documentation\n    stored in Info format.\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -21,8 +22,8 @@\n \n    Written by Brian Fox (bfox@ai.mit.edu). */\n \n-#if !defined (_WINDOW_H_)\n-#define _WINDOW_H_\n+#ifndef INFO_WINDOW_H\n+#define INFO_WINDOW_H\n \n #include \"nodes.h\"\n #include \"infomap.h\"\n@@ -44,47 +45,48 @@\n    if you need to change window state information, here is where you would\n    do it.  NB> The last element does NOT end with a semi-colon. */\n #define WINDOW_STATE_DECL \\\n-   NODE *node;\t\t/* The node displayed in this window. */ \\\n-   int pagetop;\t\t/* LINE_STARTS[PAGETOP] is first line in WINDOW. */ \\\n-   long point\t\t/* Offset within NODE of the cursor position. */\n+   NODE *node;          /* The node displayed in this window. */ \\\n+   int pagetop;         /* LINE_STARTS[PAGETOP] is first line in WINDOW. */ \\\n+   long point           /* Offset within NODE of the cursor position. */\n \n /* Structure which defines a window.  Windows are doubly linked, next\n    and prev. The list of windows is kept on WINDOWS.  The structure member\n    window->height is the total height of the window.  The position location\n    (0, window->height + window->first_row) is the first character of this\n    windows modeline.  The number of lines that can be displayed in a window\n    is equal to window->height - 1. */\n-typedef struct __window__ {\n-  struct __window__ *next;\t/* Next window in this chain. */\n-  struct __window__ *prev;\t/* Previous window in this chain. */\n-  int width;\t\t/* Width of this window. */\n-  int height;\t\t/* Height of this window. */\n-  int first_row;\t/* Offset of the first line in the_screen. */\n-  int goal_column;\t/* The column we would like the cursor to appear in. */\n-  Keymap keymap;\t/* Keymap used to read commands in this window. */\n-  WINDOW_STATE_DECL;\t/* Node, pagetop and point. */\n-  char *modeline;\t/* Calculated text of the modeline for this window. */\n-  char **line_starts;\t/* Array of printed line starts for this node. */\n-  int line_count;\t/* Number of lines appearing in LINE_STARTS. */\n-  int flags;\t\t/* See below for details. */\n+typedef struct window_struct\n+{\n+  struct window_struct *next;      /* Next window in this chain. */\n+  struct window_struct *prev;      /* Previous window in this chain. */\n+  int width;            /* Width of this window. */\n+  int height;           /* Height of this window. */\n+  int first_row;        /* Offset of the first line in the_screen. */\n+  int goal_column;      /* The column we would like the cursor to appear in. */\n+  Keymap keymap;        /* Keymap used to read commands in this window. */\n+  WINDOW_STATE_DECL;    /* Node, pagetop and point. */\n+  char *modeline;       /* Calculated text of the modeline for this window. */\n+  char **line_starts;   /* Array of printed line starts for this node. */\n+  int line_count;       /* Number of lines appearing in LINE_STARTS. */\n+  int flags;            /* See below for details. */\n } WINDOW;\n \n typedef struct {\n-  WINDOW_STATE_DECL;\t\t/* What gets saved. */\n+  WINDOW_STATE_DECL;            /* What gets saved. */\n } WINDOW_STATE;\n \n-#define W_UpdateWindow\t0x01\t/* WINDOW needs updating. */\n-#define W_WindowIsPerm\t0x02\t/* This WINDOW is a permanent object. */\n-#define W_WindowVisible\t0x04\t/* This WINDOW is currently visible. */\n-#define W_InhibitMode\t0x08\t/* This WINDOW has no modeline. */\n-#define W_NoWrap\t0x10\t/* Lines do not wrap in this window. */\n-#define W_InputWindow\t0x20\t/* Window accepts input. */\n-#define W_TempWindow\t0x40\t/* Window is less important. */\n+#define W_UpdateWindow  0x01    /* WINDOW needs updating. */\n+#define W_WindowIsPerm  0x02    /* This WINDOW is a permanent object. */\n+#define W_WindowVisible 0x04    /* This WINDOW is currently visible. */\n+#define W_InhibitMode   0x08    /* This WINDOW has no modeline. */\n+#define W_NoWrap        0x10    /* Lines do not wrap in this window. */\n+#define W_InputWindow   0x20    /* Window accepts input. */\n+#define W_TempWindow    0x40    /* Window is less important. */\n \n-extern WINDOW *windows;\t\t/* List of visible Info windows. */\n-extern WINDOW *active_window;\t/* The currently active window. */\n-extern WINDOW *the_screen;\t/* The Info screen is just another window. */\n-extern WINDOW *the_echo_area;\t/* THE_ECHO_AREA is a window in THE_SCREEN. */\n+extern WINDOW *windows;         /* List of visible Info windows. */\n+extern WINDOW *active_window;   /* The currently active window. */\n+extern WINDOW *the_screen;      /* The Info screen is just another window. */\n+extern WINDOW *the_echo_area;   /* THE_ECHO_AREA is a window in THE_SCREEN. */\n \n /* Global variable control redisplay of scrolled windows.  If non-zero, it\n    is the desired number of lines to scroll the window in order to make\n@@ -226,4 +228,4 @@ extern void window_get_state (), window_set_state ();\n    offset of GOAL. */\n extern int window_chars_to_goal ();\n \n-#endif /* !_WINDOW_H_ */\n+#endif /* not INFO_WINDOW_H */"}, {"sha": "842b26e19d296fbb9b6b2d79b3f11112f4b942f1", "filename": "texinfo/makeinfo/Makefile.in", "status": "modified", "additions": 232, "deletions": 77, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fmakeinfo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fmakeinfo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Fmakeinfo%2FMakefile.in?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,116 +1,271 @@\n-# Makefile for GNU makeinfo.\n-# $Id: Makefile.in,v 1.1 1997/08/21 22:58:07 jason Exp $\n-# \n-# Copyright (C) 1993, 96 Free Software Foundation, Inc.\n+# Makefile.in generated automatically by automake 1.2 from Makefile.am\n \n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n+# Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy, distribute and modify it.\n \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-\n-#### Start of system configuration section. ####\n+SHELL = /bin/sh\n \n srcdir = @srcdir@\n-VPATH = $(srcdir):$(common)\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n+\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n \n-common = $(srcdir)/../libtxi\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+\n+top_builddir = ..\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n \n-EXEEXT = @EXEEXT@\n-CC = @CC@\n INSTALL = @INSTALL@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+transform = @program_transform_name@\n+\n+NORMAL_INSTALL = true\n+PRE_INSTALL = true\n+POST_INSTALL = true\n+NORMAL_UNINSTALL = true\n+PRE_UNINSTALL = true\n+POST_UNINSTALL = true\n+CATALOGS = @CATALOGS@\n+CATOBJEXT = @CATOBJEXT@\n+CC = @CC@\n+DATADIRNAME = @DATADIRNAME@\n+EXEEXT = @EXEEXT@\n+GENCAT = @GENCAT@\n+GMOFILES = @GMOFILES@\n+GMSGFMT = @GMSGFMT@\n+GT_NO = @GT_NO@\n+GT_YES = @GT_YES@\n+INSTOBJEXT = @INSTOBJEXT@\n+INTLDEPS = @INTLDEPS@\n+INTLLIBS = @INTLLIBS@\n+INTLOBJS = @INTLOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKINSTALLDIRS = @MKINSTALLDIRS@\n+MSGFMT = @MSGFMT@\n+PACKAGE = @PACKAGE@\n+POFILES = @POFILES@\n+POSUB = @POSUB@\n+RANLIB = @RANLIB@\n+TERMLIBS = @TERMLIBS@\n+TEXCONFIG = @TEXCONFIG@\n+TEXMF = @TEXMF@\n+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@\n+USE_NLS = @USE_NLS@\n+VERSION = @VERSION@\n+l = @l@\n+\n+bin_PROGRAMS = makeinfo\n+\n+localedir = $(datadir)/locale\n+INCLUDES = -I$(top_srcdir)/lib -I../intl -DLOCALEDIR=\\\"$(localedir)\\\"\n+LDADD = ../lib/libtxi.a @INTLLIBS@\n+\n+makeinfo_SOURCES = makeinfo.c makeinfo.h multi.c\n+\n+EXTRA_DIST = README\n+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n+CONFIG_HEADER = ../config.h\n+CONFIG_CLEAN_FILES = \n+bin_PROGRAMS =  makeinfo$(EXEEXT)\n+PROGRAMS =  $(bin_PROGRAMS)\n+\n+\n+DEFS = @DEFS@ -I. -I$(srcdir) -I..\n+CPPFLAGS = @CPPFLAGS@\n+LDFLAGS = @LDFLAGS@\n+LIBS = @LIBS@\n+makeinfo_OBJECTS =  makeinfo.o multi.o\n+makeinfo_LDADD = $(LDADD)\n+makeinfo_DEPENDENCIES =  ../lib/libtxi.a\n+makeinfo_LDFLAGS = \n+CFLAGS = @CFLAGS@\n+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)\n+LINK = $(CC) $(CFLAGS) $(LDFLAGS) -o $@\n+DIST_COMMON =  README Makefile.am Makefile.in\n \n-LN\t= ln\n-RM\t= rm -f\n-MKDIR\t= mkdir\n \n-DEFS = @DEFS@\n-LIBS = -L../libtxi -ltxi @LIBS@\n-LOADLIBES = $(LIBS)\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-SHELL = /bin/sh\n+TAR = tar\n+GZIP = --best\n+SOURCES = $(makeinfo_SOURCES)\n+OBJECTS = $(makeinfo_OBJECTS)\n \n-CFLAGS = @CFLAGS@\n-LDFLAGS = @LDFLAGS@\n+default: all\n \n-prefix = @prefix@\n-exec_prefix = @exec_prefix@\n-bindir = @bindir@\n-# Prefix for each installed program, normally empty or `g'.\n-binprefix = \n-infodir = @infodir@\n+.SUFFIXES:\n+.SUFFIXES: .c .o\n+$(srcdir)/Makefile.in: @MAINT@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus makeinfo/Makefile\n+\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n+\n+\n+mostlyclean-binPROGRAMS:\n \n-#### End of system configuration section. ####\n+clean-binPROGRAMS:\n+\ttest -z \"$(bin_PROGRAMS)\" || rm -f $(bin_PROGRAMS)\n \n-SRCS =  makeinfo.c multi.c\n-OBJS =  makeinfo.o multi.o\n+distclean-binPROGRAMS:\n \n-PROGS = makeinfo$(EXEEXT)\n+maintainer-clean-binPROGRAMS:\n \n-all: $(PROGS) makeinfo.info\n-sub-all: all\n+install-binPROGRAMS: $(bin_PROGRAMS)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(bindir)\n+\t@list='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \"  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`\"; \\\n+\t     $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\t  else :; fi; \\\n+\tdone\n+\n+uninstall-binPROGRAMS:\n+\t$(NORMAL_UNINSTALL)\n+\tlist='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\tdone\n \n .c.o:\n-\t$(CC) -c $(CPPFLAGS) -I. -I$(srcdir) -I$(common) $(DEFS) $(CFLAGS) $<\n+\t$(COMPILE) -c $<\n+\n+mostlyclean-compile:\n+\trm -f *.o core\n+\n+clean-compile:\n+\n+distclean-compile:\n+\trm -f *.tab.c\n+\n+maintainer-clean-compile:\n+\n+makeinfo$(EXEEXT): $(makeinfo_OBJECTS) $(makeinfo_DEPENDENCIES)\n+\t@rm -f makeinfo$(EXEEXT)\n+\t$(LINK) $(makeinfo_LDFLAGS) $(makeinfo_OBJECTS) $(makeinfo_LDADD) $(LIBS)\n+\n+tags: TAGS\n+\n+ID: $(HEADERS) $(SOURCES)\n+\there=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\ttest -z \"$(ETAGS_ARGS)$(SOURCES)$(HEADERS)$$tags\" \\\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $(SOURCES) $(HEADERS) -o $$here/TAGS)\n+\n+mostlyclean-tags:\n+\n+clean-tags:\n+\n+distclean-tags:\n+\trm -f TAGS ID\n+\n+maintainer-clean-tags:\n+\n+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n+\n+subdir = makeinfo\n \n-makeinfo$(EXEEXT): $(OBJS) ../libtxi/libtxi.a\n-\t$(CC) $(LDFLAGS) -o makeinfo $(OBJS) $(LOADLIBES)\n+distdir: $(DISTFILES)\n+\t@for file in $(DISTFILES); do \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  test -f $(distdir)/$$file \\\n+\t  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t  || cp -p $$d/$$file $(distdir)/$$file; \\\n+\tdone\n+info:\n+dvi:\n+check: all\n+\t$(MAKE)\n+installcheck:\n+install-info:\n+install-exec: install-binPROGRAMS\n+\t@$(NORMAL_INSTALL)\n \n-../libtxi/libtxi.a:\n-\t(cd ../libtxi && $(MAKE) $(MFLAGS) libtxi.a)\n+install-data: \n+\t@$(NORMAL_INSTALL)\n \n-makeinfo.o: makeinfo.c $(common)/getopt.h\n+install: install-exec install-data all\n+\t@:\n \n-$(OBJS): makeinfo.h\n+uninstall: uninstall-binPROGRAMS\n \n-info makeinfo.info: ./makeinfo makeinfo.texi #macro.texi\n-\t./makeinfo --no-split -I$(srcdir) makeinfo.texi\n+all: Makefile $(PROGRAMS)\n \n-# makeinfo.texi: ./makeinfo makeinfo.mki\n-# \t./makeinfo -E makeinfo.texi -I$(srcdir) makeinfo.mki\n+install-strip:\n+\t$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install\n+installdirs:\n+\t$(mkinstalldirs)  $(bindir)\n \n-dvi makeinfo.dvi: ./makeinfo makeinfo.texi #macro.texi\n-\t$(srcdir)/../util/texi2dvi makeinfo.txi\n \n-install: all\n-\t$(INSTALL_PROGRAM) makeinfo$(EXEEXT) $(bindir)/$(binprefix)makeinfo$(EXEEXT)\n-\t-d=$(srcdir); test -f ./makeinfo.info && d=.; $(INSTALL_DATA) $$d/makeinfo.info $(infodir)/makeinfo.info\n-\t$(POST_INSTALL)\n+mostlyclean-generic:\n+\ttest -z \"$(MOSTLYCLEANFILES)\" || rm -f $(MOSTLYCLEANFILES)\n \n-install-info: \n-\t-d=$(srcdir); test -f ./makeinfo.info && d=.; $(INSTALL_DATA) $$d/makeinfo.info $(infodir)/makeinfo.info\n-\t../util/install-info --info-dir=$(infodir) $(infodir)/makeinfo.info\n+clean-generic:\n+\ttest -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n \n-uninstall:\n-\tfor f in $(PROGS); do rm -f $(bindir)/$(binprefix)$$f; done\n-\trm -f $(infodir)/makeinfo.info\n+distclean-generic:\n+\trm -f Makefile $(DISTCLEANFILES)\n+\trm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\ttest -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \n-TAGS: $(SRCS)\n-\tetags $(SRCS)\n+maintainer-clean-generic:\n+\ttest -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n+\ttest -z \"$(BUILT_SOURCES)\" || rm -f $(BUILT_SOURCES)\n+mostlyclean:  mostlyclean-binPROGRAMS mostlyclean-compile \\\n+\t\tmostlyclean-tags mostlyclean-generic\n \n-clean:\n-\trm -f *.o a.out core core.* $(PROGS)\n+clean:  clean-binPROGRAMS clean-compile clean-tags clean-generic \\\n+\t\tmostlyclean\n \n-mostlyclean: clean\n+distclean:  distclean-binPROGRAMS distclean-compile distclean-tags \\\n+\t\tdistclean-generic clean\n+\trm -f config.status\n \n-distclean: clean\n-\trm -f TAGS Makefile config.status *.info */*.info\n+maintainer-clean:  maintainer-clean-binPROGRAMS maintainer-clean-compile \\\n+\t\tmaintainer-clean-tags maintainer-clean-generic \\\n+\t\tdistclean\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n \n-realclean: distclean\n-maintainer-clean: distclean\n+.PHONY: default mostlyclean-binPROGRAMS distclean-binPROGRAMS \\\n+clean-binPROGRAMS maintainer-clean-binPROGRAMS uninstall-binPROGRAMS \\\n+install-binPROGRAMS mostlyclean-compile distclean-compile clean-compile \\\n+maintainer-clean-compile tags mostlyclean-tags distclean-tags \\\n+clean-tags maintainer-clean-tags distdir info dvi installcheck \\\n+install-info install-exec install-data install uninstall all \\\n+installdirs mostlyclean-generic distclean-generic clean-generic \\\n+maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n-Makefile: Makefile.in ../config.status\n-\tcd .. && sh config.status\n \n-# Prevent GNU make v3 from overflowing arg limit on SysV.\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:"}, {"sha": "205a3bdf0415a3c1695c97df86ec733added8cde", "filename": "texinfo/makeinfo/makeinfo.h", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fmakeinfo%2Fmakeinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fmakeinfo%2Fmakeinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Fmakeinfo%2Fmakeinfo.h?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,7 +1,7 @@\n /* makeinfo.h -- Declarations for Makeinfo.\n-   $Id: makeinfo.h,v 1.1 1997/08/21 22:58:08 jason Exp $\n+   $Id: makeinfo.h,v 1.3 1997/07/15 18:28:38 karl Exp $\n \n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -35,26 +35,28 @@\n \n enum insertion_type\n {\n-  menu, detailmenu, quotation, lisp, smalllisp, example, smallexample,\n-  display, itemize, format, enumerate, cartouche, multitable, table,\n-  ftable, vtable, group, ifinfo, flushleft, flushright, ifset,\n-  ifclear, deffn, defun, defmac, defspec, defvr, defvar, defopt,\n-  deftypefn, deftypefun, deftypevr, deftypevar, defcv, defivar, defop,\n-  defmethod, deftypemethod, deftp, direntry, bad_type\n+  cartouche, defcv, deffn, defivar, defmac, defmethod,\n+  defop, defopt, defspec, deftp, deftypefn, deftypefun,\n+  deftypemethod, deftypevar, deftypevr, defun, defvar,\n+  defvr, detailmenu, direntry, display, enumerate, example,\n+  flushleft, flushright, format, ftable, group, ifclear,\n+  ifinfo, ifnothtml, ifnottex, ifset, itemize, lisp, menu,\n+  multitable, quotation, smallexample, smalllisp, table, vtable,\n+  bad_type\n };\n \n DECLARE (int, insertion_level, 0);\n \n #if defined (COMPILING_MAKEINFO)\n char *insertion_type_names[] =\n {\n-  \"menu\", \"detailmenu\", \"quotation\", \"lisp\", \"smalllisp\", \"example\",\n-  \"smallexample\", \"display\", \"itemize\", \"format\", \"enumerate\",\n-  \"cartouche\", \"multitable\", \"table\", \"ftable\", \"vtable\", \"group\",\n-  \"ifinfo\", \"flushleft\", \"flushright\", \"ifset\", \"ifclear\", \"deffn\",\n-  \"defun\", \"defmac\", \"defspec\", \"defvr\", \"defvar\", \"defopt\",\n-  \"deftypefn\", \"deftypefun\", \"deftypevr\", \"deftypevar\", \"defcv\",\n-  \"defivar\", \"defop\", \"defmethod\", \"deftypemethod\", \"deftp\", \"direntry\",\n+  \"cartouche\", \"defcv\", \"deffn\", \"defivar\", \"defmac\", \"defmethod\",\n+  \"defop\", \"defopt\", \"defspec\", \"deftp\", \"deftypefn\", \"deftypefun\",\n+  \"deftypemethod\", \"deftypevar\", \"deftypevr\", \"defun\", \"defvar\",\n+  \"defvr\", \"detailmenu\", \"direntry\", \"display\", \"enumerate\", \"example\",\n+  \"flushleft\", \"flushright\", \"format\", \"ftable\", \"group\", \"ifclear\",\n+  \"ifinfo\", \"ifnothtml\", \"ifnottex\", \"ifset\", \"itemize\", \"lisp\", \"menu\",\n+  \"multitable\", \"quotation\", \"smallexample\", \"smalllisp\", \"table\", \"vtable\",\n   \"bad_type\"\n };\n #endif\n@@ -107,15 +109,15 @@ DECLARE (int, line_number, 0);\n \n #define curchar() input_text[input_text_offset]\n /* **************************************************************** */\n-/*\t\t\t\t\t\t\t\t    */\n-/*\t\t\t      Global Defines  \t\t\t    */\n-/*\t\t\t\t\t\t\t\t    */\n+/*                                                                  */\n+/*                            Global Defines                        */\n+/*                                                                  */\n /* **************************************************************** */\n \n /* Error levels */\n #define NO_ERROR 0\n-#define SYNTAX\t 2\n-#define FATAL\t 4\n+#define SYNTAX   2\n+#define FATAL    4\n \n /* C's standard macros don't check to make sure that the characters being\n    changed are within range.  So I have to check explicitly. */\n@@ -164,29 +166,29 @@ DECLARE (int, line_number, 0);\n #define SPLIT_SIZE_THRESHOLD 70000  /* What's good enough for Stallman... */\n #define DEFAULT_SPLIT_SIZE 50000    /* Is probably good enough for me. */\n \n-DECLARE (int, splitting, 1);\t/* Defaults to true for now. */\n+DECLARE (int, splitting, 1);    /* Defaults to true for now. */\n \n typedef void COMMAND_FUNCTION (); /* So I can say COMMAND_FUNCTION *foo; */\n \n #define command_char(c) ((!whitespace(c)) && \\\n-\t\t\t ((c) != '\\n') && \\\n-\t\t\t ((c) != '{') && \\\n-\t\t\t ((c) != '}') && \\\n-\t\t\t ((c) != '='))\n+                         ((c) != '\\n') && \\\n+                         ((c) != '{') && \\\n+                         ((c) != '}') && \\\n+                         ((c) != '='))\n \n #define skip_whitespace() \\\n      while ((input_text_offset != size_of_input_text) && \\\n-\t     whitespace (curchar())) \\\n+             whitespace (curchar())) \\\n        input_text_offset++\n \n #define skip_whitespace_and_newlines() \\\n   do { \\\n    while ((input_text_offset != size_of_input_text) && \\\n-\t  (whitespace (curchar ()) || (curchar () == '\\n'))) \\\n+          (whitespace (curchar ()) || (curchar () == '\\n'))) \\\n       { \\\n-\t if (curchar () == '\\n') \\\n-\t   line_number++; \\\n-\t input_text_offset++; \\\n+         if (curchar () == '\\n') \\\n+           line_number++; \\\n+         input_text_offset++; \\\n       } \\\n    } while (0)\n "}, {"sha": "99c380d3dd95b6992e71cec29a8baa6a9c8ade90", "filename": "texinfo/makeinfo/multi.c", "status": "modified", "additions": 104, "deletions": 88, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fmakeinfo%2Fmulti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Fmakeinfo%2Fmulti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Fmakeinfo%2Fmulti.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,7 +1,7 @@\n-/* multi.c -- Multitable stuff for makeinfo.\n-   $Id: multi.c,v 1.1 1997/08/21 22:58:08 jason Exp $\n+/* multi.c -- multitable stuff for makeinfo.\n+   $Id: multi.c,v 1.9 1997/07/24 22:01:00 karl Exp $\n \n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -17,10 +17,10 @@\n    along with this program; if not, write to the Free Software Foundation,\n    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-#include <stdio.h>\n+#include \"system.h\"\n #include \"makeinfo.h\"\n \n-#define MAXCOLS 100\t\t/* remove this limit later @@ */\n+#define MAXCOLS 100             /* remove this limit later @@ */\n \n \f\n /*\n@@ -38,7 +38,7 @@\n  * `select_output_environment' function switches from one output\n  * environment to another.\n  *\n- * Environment #0 (i.e. element #0 of the table) is the regular\n+ * Environment #0 (i.e., element #0 of the table) is the regular\n  * environment that is used when we're not formatting a multitable.\n  *\n  * Environment #N (where N = 1,2,3,...) is the env. for column #N of\n@@ -55,7 +55,7 @@ struct env\n   int paragraph_is_open;\n   int current_indent;\n   int fill_column;\n-} envs[MAXCOLS];\t\t/* the environment table */\n+} envs[MAXCOLS];                /* the environment table */\n \n /* index in environment table of currently selected environment */\n static int current_env_no;\n@@ -67,6 +67,40 @@ static int last_column;\n    to be drawn, separating rows and columns in the current multitable. */\n static int hsep, vsep;\n \f\n+/* Output a row.  Have to keep `output_position' up-to-date for each\n+   character we output, or the tags table will be off, leading to\n+   chopped-off output files and undefined nodes (because they're in the\n+   wrong file, etc.).  Perhaps it would be better to accumulate this\n+   value somewhere and add it once at the end of the table, or return it\n+   as the value, but this seems simplest.  */\n+static void\n+out_char (ch)\n+    int ch;\n+{\n+  extern int output_position;\n+  putc (ch, output_stream);\n+  output_position++;\n+}\n+\n+\n+void\n+draw_horizontal_separator ()\n+{\n+  int i, j, s;\n+\n+  for (s = 0; s < envs[0].current_indent; s++)\n+    out_char (' ');\n+  if (vsep)\n+    out_char ('+');\n+  for (i = 1; i <= last_column; i++) {\n+    for (j = 0; j <= envs[i].fill_column; j++)\n+      out_char ('-');\n+    if (vsep)\n+      out_char ('+');\n+  }\n+  out_char ('\\n');\n+}\n+\n void\n do_multitable ()\n {\n@@ -116,7 +150,7 @@ setup_multitable_parameters ()\n   char *params = insertion_stack->item_function;\n   int nchars;\n   float columnfrac;\n-  char command[200];\n+  char command[200]; /* naughty, should be no fixed limits */\n   int i = 1;\n \n   /* We implement @hsep and @vsep even though TeX doesn't.\n@@ -129,22 +163,32 @@ setup_multitable_parameters ()\n       params++;\n \n     if (*params == '@') {\n-      sscanf (params, \"%s%n\", command, &nchars);\n+      sscanf (params, \"%200s\", command);\n+      nchars = strlen (command);\n       params += nchars;\n       if (strcmp (command, \"@hsep\") == 0)\n-\thsep++;\n+        hsep++;\n       else if (strcmp (command, \"@vsep\") == 0)\n-\tvsep++;\n+        vsep++;\n       else if (strcmp (command, \"@columnfractions\") == 0) {\n-\t/* Clobber old environments and create new ones,\n-\t   starting at #1.  Environment #0 is the normal standard output,\n-\t   so we don't mess with it. */\n-\tfor ( ; i <= MAXCOLS; i++) {\n-\t  if (sscanf (params, \"%f%n\", &columnfrac, &nchars) < 1)\n-\t    goto done;\n-\t  params += nchars;\n-\t  setup_output_environment (i, (int) (columnfrac * fill_column + .5));\n-\t}\n+        /* Clobber old environments and create new ones, starting at #1.\n+           Environment #0 is the normal output, so don't mess with it. */\n+        for ( ; i <= MAXCOLS; i++) {\n+          if (sscanf (params, \"%f\", &columnfrac) < 1)\n+            goto done;\n+          /* Unfortunately, can't use %n since some m68k-hp-bsd libc\n+             doesn't support it.  So skip whitespace (preceding the\n+             number) and then non-whitespace (the number).  */\n+          while (*params && (*params == ' ' || *params == '\\t'))\n+            params++;\n+          /* Hmm, but what what @columnfractions 3foo.  Well, I suppose\n+             it's invalid input anyway.  */\n+          while (*params && *params != ' ' && *params != '\\t'\n+                 && *params != '\\n' && *params != '@')\n+            params++;\n+          setup_output_environment (i,\n+                     (int) (columnfrac * (fill_column - current_indent) + .5));\n+        }\n       }\n \n     } else if (*params == '{') {\n@@ -154,18 +198,17 @@ setup_multitable_parameters ()\n       }\n       /* This gives us two spaces between columns.  Seems reasonable.\n          Really should expand the text, though, so a template of\n-         `@code{foo}' has a width of three, not ten.  Also have to match\n-         braces, then.  */\n+         `@code{foo}' has a width of five, not ten.  Also have to match\n+         braces, then.  How to take into account current_indent here?  */\n       setup_output_environment (i++, params++ - start);\n       \n     } else {\n-      warning (\"ignoring stray text `%s' after @multitable\", params);\n+      warning (_(\"ignoring stray text `%s' after @multitable\"), params);\n       break;\n     }\n   }\n \n done:\n-\n   flush_output ();\n   inhibit_output_flushing ();\n \n@@ -227,25 +270,38 @@ select_output_environment (n)\n }\n \n /* advance to the next environment number */\n-int\n+void\n nselect_next_environment ()\n {\n   if (current_env_no >= last_column) {\n-    line_error (\"Too many columns in multitable item (max %d)\", last_column);\n-    return 1;\n+    line_error (_(\"Too many columns in multitable item (max %d)\"), last_column);\n+    return;\n   }\n   select_output_environment (current_env_no + 1);\n }\n \n \f\n static void output_multitable_row ();\n \n+/* do anything needed at the beginning of processing a\n+   multitable column. */\n+void\n+init_column ()\n+{\n+  /* don't indent 1st paragraph in the item */\n+  cm_noindent ();\n+\n+  /* throw away possible whitespace after @item or @tab command */\n+  skip_whitespace ();\n+}\n+\n /* start a new item (row) of a multitable */\n+int\n multitable_item ()\n {\n   if (!multitable_active) {\n     /* impossible, I think. */\n-    error (\"multitable item not in active multitable\");\n+    error (_(\"multitable item not in active multitable\"));\n     exit (1);\n   }\n   if (current_env_no > 0) {\n@@ -254,7 +310,7 @@ multitable_item ()\n   /* start at column 1 */\n   select_output_environment (1);\n   if (!output_paragraph) {\n-    line_error (\"Cannot select column #%d in multitable\", current_env_no);\n+    line_error (_(\"Cannot select column #%d in multitable\"), current_env_no);\n     exit (FATAL);\n   }\n \n@@ -263,38 +319,10 @@ multitable_item ()\n   return 0;\n }\n \n-/* do anything needed at the beginning of processing a\n-   multitable column. */\n-init_column ()\n-{\n-  /* don't indent 1st paragraph in the item */\n-  cm_noindent ();\n-\n-  /* throw away possible whitespace after @item or @tab command */\n-  skip_whitespace ();\n-}\n-\n-/* Output a row.  Have to keep `output_position' up-to-date for each\n-   character we output, or the tags table will be off, leading to\n-   chopped-off output files and undefined nodes (because they're in the\n-   wrong file, etc.).  Perhaps it would be better to accumulate this\n-   value somewhere and add it once at the end of the table, or return it\n-   as the value, but this seems simplest.  */\n-\n-static void\n-out_char (ch)\n-    int ch;\n-{\n-  extern int output_position;\n-  putc (ch, output_stream);\n-  output_position++;\n-}\n-\n-\n static void\n output_multitable_row ()\n {\n-  int i, j, remaining;\n+  int i, j, s, remaining;\n \n   /* offset in the output paragraph of the next char needing\n      to be output for that column. */\n@@ -325,29 +353,34 @@ output_multitable_row ()\n     /* first, see if there is any work to do */\n     for (i = 1; i <= last_column; i++) {\n       if (CHAR_ADDR (0) < envs[i].output_paragraph_offset) {\n-\tremaining = 1;\n-\tbreak;\n+        remaining = 1;\n+        break;\n       }\n     }\n     if (!remaining)\n       break;\n-\n+    \n+    for (s = 0; s < envs[0].current_indent; s++)\n+      out_char (' ');\n+    \n     if (vsep)\n       out_char ('|');\n \n     for (i = 1; i <= last_column; i++) {\n+      for (s = 0; i < envs[i].current_indent; s++)\n+        out_char (' ');\n       for (j = 0; CHAR_ADDR (j) < envs[i].output_paragraph_offset; j++) {\n-\tif (CHAR_AT (j) == '\\n')\n-\t  break;\n-\tout_char (CHAR_AT (j));\n+        if (CHAR_AT (j) == '\\n')\n+          break;\n+        out_char (CHAR_AT (j));\n       }\n-      offset[i] += j + 1;\t/* skip last text plus skip the newline */\n+      offset[i] += j + 1;       /* skip last text plus skip the newline */\n       for (; j <= envs[i].fill_column; j++)\n-\tout_char (' ');\n+        out_char (' ');\n       if (vsep)\n-\tout_char ('|');\t/* draw column separator */\n+        out_char ('|'); /* draw column separator */\n     }\n-    out_char ('\\n');\t/* end of line */\n+    out_char ('\\n');    /* end of line */\n   }\n \n   if (hsep)\n@@ -363,27 +396,12 @@ output_multitable_row ()\n #undef CHAR_AT\n #undef CHAR_ADDR\n \n-int\n-draw_horizontal_separator ()\n-{\n-  int i, j;\n-  if (vsep)\n-    out_char ('+');\n-  for (i = 1; i <= last_column; i++) {\n-    for (j = 0; j <= envs[i].fill_column; j++)\n-      out_char ('-');\n-    if (vsep)\n-      out_char ('+');\n-  }\n-  out_char ('\\n');\n-}\n-\n /* select a new column in current row of multitable */\n void\n cm_tab ()\n {\n   if (!multitable_active)\n-    error (\"ignoring @tab outside of multitable\");\n+    error (_(\"ignoring @tab outside of multitable\"));\n   \n   nselect_next_environment ();\n   init_column ();\n@@ -394,8 +412,6 @@ cm_tab ()\n void\n end_multitable ()\n {\n-  int i;\n-\n   output_multitable_row ();\n \n   /* Multitables cannot be nested.  Otherwise, we'd have to save the\n@@ -409,10 +425,10 @@ end_multitable ()\n   uninhibit_output_flushing ();\n \n #if 0\n-  printf (\"** Multicolumn output from last row:\\n\");\n+  printf (_(\"** Multicolumn output from last row:\\n\"));\n   for (i = 1; i <= last_column; i++) {\n     select_output_environment (i);\n-    printf (\"* column #%d: output = %s\\n\", i, output_paragraph);\n+    printf (_(\"* column #%d: output = %s\\n\"), i, output_paragraph);\n   }\n #endif\n }"}, {"sha": "2ce38f94db16b5b39a6e7981c43eceb8e85f6f19", "filename": "texinfo/texinfo.tex", "status": "modified", "additions": 189, "deletions": 54, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Ftexinfo.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Ftexinfo.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Ftexinfo.tex?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,5 +1,5 @@\n %% TeX macros to handle Texinfo files.\n-%% $Id: texinfo.tex,v 1.1 1997/08/21 22:57:53 jason Exp $\n+%% $Id: texinfo.tex,v 2.218 1997/07/26 19:12:35 karl Exp $\n \n %  Copyright (C) 1985, 86, 88, 90, 91, 92, 93,\n %                94, 95, 96, 97 Free Software Foundation, Inc.\n@@ -36,7 +36,7 @@\n \n % This automatically updates the version number based on RCS.\n \\def\\deftexinfoversion$#1: #2 ${\\def\\texinfoversion{#2}}\n-\\deftexinfoversion$Revision: 1.1 $\n+\\deftexinfoversion$Revision: 2.218 $\n \\message{Loading texinfo package [Version \\texinfoversion]:}\n \n % If in a .fmt file, print the version number\n@@ -101,6 +101,7 @@\n \\hyphenation{ap-pen-dix}\n \\hyphenation{mini-buf-fer mini-buf-fers}\n \\hyphenation{eshell}\n+\\hyphenation{white-space}\n \n % Margin to add to right of even pages, to left of odd pages.\n \\newdimen \\bindingoffset\n@@ -185,7 +186,13 @@\n       %\n       \\unvbox\\headlinebox\n       \\pagebody{#1}%\n-      \\unvbox\\footlinebox\n+      \\ifdim\\ht\\footlinebox > 0pt\n+        % Only leave this space if the footline is nonempty.\n+        % (We lessened \\vsize for it in \\oddfootingxxx.)\n+        % The \\baselineskip=24pt in plain's \\makefootline has no effect.\n+        \\vskip 2\\baselineskip\n+        \\unvbox\\footlinebox\n+      \\fi\n       %\n       \\ifcropmarks\n           \\egroup % end of \\vbox\\bgroup\n@@ -729,10 +736,11 @@\n %\n \\def\\ignore{\\doignore{ignore}}\n \n-% Also ignore @ifinfo, @ifhtml, @html, @menu, and @direntry text.\n+% Ignore @ifinfo, @ifhtml, @ifnottex, @html, @menu, and @direntry text.\n %\n \\def\\ifinfo{\\doignore{ifinfo}}\n \\def\\ifhtml{\\doignore{ifhtml}}\n+\\def\\ifnottex{\\doignore{ifnottex}}\n \\def\\html{\\doignore{html}}\n \\def\\menu{\\doignore{menu}}\n \\def\\direntry{\\doignore{direntry}}\n@@ -759,6 +767,10 @@\n   % Make sure that spaces turn into tokens that match what \\doignoretext wants.\n   \\catcode32 = 10\n   %\n+  % Ignore braces, too, so mismatched braces don't cause trouble.\n+  \\catcode`\\{ = 9\n+  \\catcode`\\} = 9\n+  %\n   % And now expand that command.\n   \\doignoretext\n }\n@@ -850,7 +862,7 @@\n     \\pretolerance = 10000\n     %\n     % Do not execute instructions in @tex\n-    \\def\\tex{\\doignore{tex}}\n+    \\def\\tex{\\doignore{tex}}%\n }\n \n % @set VAR sets the variable VAR to an empty value.\n@@ -926,11 +938,16 @@\n \\def\\ifclearfail{\\nestedignore{ifclear}}\n \\defineunmatchedend{ifclear}\n \n-% @iftex always succeeds; we read the text following, through @end\n-% iftex).  But `@end iftex' should be valid only after an @iftex.\n+% @iftex, @ifnothtml, @ifnotinfo always succeed; we read the text\n+% following, through the first @end iftex (etc.).  Make `@end iftex'\n+% (etc.) valid only after an @iftex.\n %\n \\def\\iftex{\\conditionalsucceed{iftex}}\n+\\def\\ifnothtml{\\conditionalsucceed{ifnothtml}}\n+\\def\\ifnotinfo{\\conditionalsucceed{ifnotinfo}}\n \\defineunmatchedend{iftex}\n+\\defineunmatchedend{ifnothtml}\n+\\defineunmatchedend{ifnotinfo}\n \n % We can't just want to start a group at @iftex (for example) and end it\n % at @end iftex, since then @set commands inside the conditional have no\n@@ -1006,6 +1023,15 @@\n    \\openindices\n    \\fixbackslash  % Turn off hack to swallow `\\input texinfo'.\n    \\global\\let\\setfilename=\\comment % Ignore extra @setfilename cmds.\n+   %\n+   % If texinfo.cnf is present on the system, read it.\n+   % Useful for site-wide @afourpaper, etc.\n+   % Just to be on the safe side, close the input stream before the \\input.\n+   \\openin 1 texinfo.cnf\n+   \\ifeof1 \\let\\temp=\\relax \\else \\def\\temp{\\input texinfo.cnf }\\fi\n+   \\closein1\n+   \\temp\n+   %\n    \\comment % Ignore the actual filename.\n }\n \n@@ -1041,8 +1067,9 @@\n % We don't need math for this one.\n \\def\\ttsl{\\tenttsl}\n \n-%% Try out Computer Modern fonts at \\magstephalf\n-\\let\\mainmagstep=\\magstephalf\n+% Use Computer Modern fonts at \\magstephalf (11pt).\n+\\newcount\\mainmagstep\n+\\mainmagstep=\\magstephalf\n \n % Set the font macro #1 to the font named #2, adding on the\n % specified font prefix (normally `cm').\n@@ -1114,13 +1141,26 @@\n \\font\\indi=cmmi9\n \\font\\indsy=cmsy9\n \n+% Fonts for title page:\n+\\setfont\\titlerm\\rmbshape{12}{\\magstep3}\n+\\setfont\\titleit\\itbshape{10}{\\magstep4}\n+\\setfont\\titlesl\\slbshape{10}{\\magstep4}\n+\\setfont\\titlett\\ttbshape{12}{\\magstep3}\n+\\setfont\\titlettsl\\ttslshape{10}{\\magstep4}\n+\\setfont\\titlesf\\sfbshape{17}{\\magstep1}\n+\\let\\titlebf=\\titlerm\n+\\setfont\\titlesc\\scbshape{10}{\\magstep4}\n+\\font\\titlei=cmmi12 scaled \\magstep3\n+\\font\\titlesy=cmsy10 scaled \\magstep4\n+\\def\\authorrm{\\secrm}\n+\n % Chapter (and unnumbered) fonts (17.28pt).\n \\setfont\\chaprm\\rmbshape{12}{\\magstep2}\n \\setfont\\chapit\\itbshape{10}{\\magstep3}\n \\setfont\\chapsl\\slbshape{10}{\\magstep3}\n \\setfont\\chaptt\\ttbshape{12}{\\magstep2}\n \\setfont\\chapttsl\\ttslshape{10}{\\magstep3}\n-\\setfont\\chapsf\\sfbshape{12}{\\magstep2}\n+\\setfont\\chapsf\\sfbshape{17}{1000}\n \\let\\chapbf=\\chaprm\n \\setfont\\chapsc\\scbshape{10}{\\magstep3}\n \\font\\chapi=cmmi12 scaled \\magstep2\n@@ -1157,19 +1197,15 @@\n \\setfont\\ssecit\\itbshape{10}{1315}\n \\setfont\\ssecsl\\slbshape{10}{1315}\n \\setfont\\ssectt\\ttbshape{12}{\\magstephalf}\n-\\setfont\\ssecttsl\\ttslshape{10}{\\magstep1}\n+\\setfont\\ssecttsl\\ttslshape{10}{1315}\n \\setfont\\ssecsf\\sfbshape{12}{\\magstephalf}\n \\let\\ssecbf\\ssecrm\n \\setfont\\ssecsc\\scbshape{10}{\\magstep1}\n \\font\\sseci=cmmi12 scaled \\magstephalf\n-\\font\\ssecsy=cmsy10 scaled \\magstep1\n+\\font\\ssecsy=cmsy10 scaled 1315\n % The smallcaps and symbol fonts should actually be scaled \\magstep1.5,\n % but that is not a standard magnification.\n \n-% Fonts for title page:\n-\\setfont\\titlerm\\rmbshape{12}{\\magstep3}\n-\\let\\authorrm = \\secrm\n-\n % In order for the font changes to affect most math symbols and letters,\n % we have to define the \\textfont of the standard families.  Since\n % texinfo doesn't allow for producing subscripts and superscripts, we\n@@ -1194,6 +1230,13 @@\n   \\let\\tenbf=\\textbf \\let\\tentt=\\texttt \\let\\smallcaps=\\textsc\n   \\let\\tensf=\\textsf \\let\\teni=\\texti \\let\\tensy=\\textsy \\let\\tenttsl=\\textttsl\n   \\resetmathfonts}\n+\\def\\titlefonts{%\n+  \\let\\tenrm=\\titlerm \\let\\tenit=\\titleit \\let\\tensl=\\titlesl\n+  \\let\\tenbf=\\titlebf \\let\\tentt=\\titlett \\let\\smallcaps=\\titlesc\n+  \\let\\tensf=\\titlesf \\let\\teni=\\titlei \\let\\tensy=\\titlesy\n+  \\let\\tenttsl=\\titlettsl\n+  \\resetmathfonts \\setleading{25pt}}\n+\\def\\titlefont#1{{\\titlefonts #1}}\n \\def\\chapfonts{%\n   \\let\\tenrm=\\chaprm \\let\\tenit=\\chapit \\let\\tensl=\\chapsl\n   \\let\\tenbf=\\chapbf \\let\\tentt=\\chaptt \\let\\smallcaps=\\chapsc\n@@ -1330,18 +1373,56 @@\n \n % @kbd is like @code, except that if the argument is just one @key command,\n % then @kbd has no effect.\n-%\n+\n+% @kbdinputstyle -- arg is `distinct' (@kbd uses slanted tty font always),\n+%   `example' (@kbd uses ttsl only inside of @example and friends),\n+%   or `code' (@kbd uses normal tty font always).\n+\\def\\kbdinputstyle{\\parsearg\\kbdinputstylexxx}\n+\\def\\kbdinputstylexxx#1{%\n+  \\def\\arg{#1}%\n+  \\ifx\\arg\\worddistinct\n+    \\gdef\\kbdexamplefont{\\ttsl}\\gdef\\kbdfont{\\ttsl}%\n+  \\else\\ifx\\arg\\wordexample\n+    \\gdef\\kbdexamplefont{\\ttsl}\\gdef\\kbdfont{\\tt}%\n+  \\else\\ifx\\arg\\wordcode\n+    \\gdef\\kbdexamplefont{\\tt}\\gdef\\kbdfont{\\tt}%\n+  \\fi\\fi\\fi\n+}\n+\\def\\worddistinct{distinct}\n+\\def\\wordexample{example}\n+\\def\\wordcode{code}\n+\n+% Default is kbdinputdistinct.  (Too much of a hassle to call the macro,\n+% the catcodes are wrong for parsearg to work.)\n+\\gdef\\kbdexamplefont{\\ttsl}\\gdef\\kbdfont{\\ttsl}\n+\n \\def\\xkey{\\key}\n \\def\\kbdfoo#1#2#3\\par{\\def\\one{#1}\\def\\three{#3}\\def\\threex{??}%\n \\ifx\\one\\xkey\\ifx\\threex\\three \\key{#2}%\n-\\else{\\tclose{\\ttsl\\look}}\\fi\n-\\else{\\tclose{\\ttsl\\look}}\\fi}\n+\\else{\\tclose{\\kbdfont\\look}}\\fi\n+\\else{\\tclose{\\kbdfont\\look}}\\fi}\n+\n+% @url.  Quotes do not seem necessary, so use \\code.\n+\\let\\url=\\code\n+\n+% @uref (abbreviation for `urlref') takes an optional second argument\n+% specifying the text to display.  First (mandatory) arg is the url.\n+% Perhaps eventually put in a hypertex \\special here.\n+% \n+\\def\\uref#1{\\urefxxx #1,,\\finish}\n+\\def\\urefxxx#1,#2,#3\\finish{%\n+  \\setbox0 = \\hbox{\\ignorespaces #2}%\n+  \\ifdim\\wd0 > 0pt\n+    \\unhbox0\\ (\\code{#1})%\n+  \\else\n+    \\code{#1}%\n+  \\fi\n+}\n \n-% @url, @email.  Quotes do not seem necessary.\n-\\let\\url=\\code % perhaps include a hypertex \\special eventually\n % rms does not like the angle brackets --karl, 17may97.\n+% So now @email is just like @uref.\n %\\def\\email#1{$\\langle${\\tt #1}$\\rangle$}\n-\\let\\email=\\code\n+\\let\\email=\\uref\n \n % Check if we are currently using a typewriter font.  Since all the\n % Computer Modern typewriter fonts have zero interword stretch (and\n@@ -1378,8 +1459,6 @@\n \\newskip\\titlepagebottomglue \\titlepagebottomglue = 2pc\n \n % First the title page.  Must do @settitle before @titlepage.\n-\\def\\titlefont#1{{\\titlerm #1}}\n-\n \\newif\\ifseenauthor\n \\newif\\iffinishedtitlepage\n \n@@ -1401,7 +1480,7 @@\n    %\n    % Now you can print the title using @title.\n    \\def\\title{\\parsearg\\titlezzz}%\n-   \\def\\titlezzz##1{\\leftline{\\titlefont{##1}}\n+   \\def\\titlezzz##1{\\leftline{\\titlefonts\\rm ##1}\n                     % print a rule at the page bottom also.\n                     \\finishedtitlepagefalse\n                     \\vskip4pt \\hrule height 4pt width \\hsize \\vskip4pt}%\n@@ -1490,23 +1569,23 @@\n \\gdef\\oddheadingyyy #1@|#2@|#3@|#4\\finish{%\n \\global\\oddheadline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}}\n \n-\\gdef\\everyheadingxxx #1{\\everyheadingyyy #1@|@|@|@|\\finish}\n-\\gdef\\everyheadingyyy #1@|#2@|#3@|#4\\finish{%\n-\\global\\evenheadline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}\n-\\global\\oddheadline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}}\n+\\gdef\\everyheadingxxx#1{\\oddheadingxxx{#1}\\evenheadingxxx{#1}}%\n \n \\gdef\\evenfootingxxx #1{\\evenfootingyyy #1@|@|@|@|\\finish}\n \\gdef\\evenfootingyyy #1@|#2@|#3@|#4\\finish{%\n \\global\\evenfootline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}}\n \n \\gdef\\oddfootingxxx #1{\\oddfootingyyy #1@|@|@|@|\\finish}\n \\gdef\\oddfootingyyy #1@|#2@|#3@|#4\\finish{%\n-\\global\\oddfootline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}}\n+  \\global\\oddfootline = {\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}%\n+  %\n+  % Leave some space for the footline.  Hopefully ok to assume\n+  % @evenfooting will not be used by itself.\n+  \\global\\advance\\pageheight by -\\baselineskip\n+  \\global\\advance\\vsize by -\\baselineskip\n+}\n \n-\\gdef\\everyfootingxxx #1{\\everyfootingyyy #1@|@|@|@|\\finish}\n-\\gdef\\everyfootingyyy #1@|#2@|#3@|#4\\finish{%\n-\\global\\evenfootline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}\n-\\global\\oddfootline={\\rlap{\\centerline{#2}}\\line{#1\\hfil#3}}}\n+\\gdef\\everyfootingxxx#1{\\oddfootingxxx{#1}\\evenfootingxxx{#1}}\n %\n }% unbind the catcode of @.\n \n@@ -2230,7 +2309,13 @@\n %\\def\\char{\\realbackslash char}%\n \\def\\TeX{\\realbackslash TeX}%\n \\def\\dots{\\realbackslash dots }%\n-\\def\\copyright{\\realbackslash copyright }%\n+\\def\\result{\\realbackslash result}%\n+\\def\\equiv{\\realbackslash equiv}%\n+\\def\\expansion{\\realbackslash expansion}%\n+\\def\\print{\\realbackslash print}%\n+\\def\\error{\\realbackslash error}%\n+\\def\\point{\\realbackslash point}%\n+\\def\\copyright{\\realbackslash copyright}%\n \\def\\tclose##1{\\realbackslash tclose {##1}}%\n \\def\\code##1{\\realbackslash code {##1}}%\n \\def\\dotless##1{\\realbackslash dotless {##1}}%\n@@ -2248,6 +2333,7 @@\n \\def\\kbd##1{\\realbackslash kbd {##1}}%\n \\def\\dfn##1{\\realbackslash dfn {##1}}%\n \\def\\emph##1{\\realbackslash emph {##1}}%\n+\\def\\value##1{\\realbackslash value {##1}}%\n \\unsepspaces\n }\n \n@@ -2682,6 +2768,12 @@\n   \\def\\print{\\realbackslash print}%\n   \\def\\TeX{\\realbackslash TeX}%\n   \\def\\dots{\\realbackslash dots}%\n+  \\def\\result{\\realbackslash result}%\n+  \\def\\equiv{\\realbackslash equiv}%\n+  \\def\\expansion{\\realbackslash expansion}%\n+  \\def\\print{\\realbackslash print}%\n+  \\def\\error{\\realbackslash error}%\n+  \\def\\point{\\realbackslash point}%\n   \\def\\copyright{\\realbackslash copyright}%\n   \\def\\tt{\\realbackslash tt}%\n   \\def\\bf{\\realbackslash bf}%\n@@ -3208,7 +3300,9 @@\n    \\unnumbchapmacro{#1}\\def\\thischapter{}%\n    \\begingroup                  % Set up to handle contents files properly.\n       \\catcode`\\\\=0  \\catcode`\\{=1  \\catcode`\\}=2  \\catcode`\\@=11\n-      \\catcode`\\^=7 % to see ^^e4 as \\\"a etc. juha@piuha.ydi.vtt.fi\n+      % We can't do this, because then an actual ^ in a section\n+      % title fails, e.g., @chapter ^ -- exponentiation.  --karl, 9jul97.\n+      %\\catcode`\\^=7 % to see ^^e4 as \\\"a etc. juha@piuha.ydi.vtt.fi\n       \\raggedbottom             % Worry more about breakpoints than the bottom.\n       \\advance\\hsize by -\\contentsrightmargin % Don't use the full line length.\n }\n@@ -3563,11 +3657,12 @@\n %\n \\def\\nonfillfinish{\\afterenvbreak\\endgroup}%\n \n-% This macro is\n \\def\\lisp{\\begingroup\n   \\nonfillstart\n   \\let\\Elisp = \\nonfillfinish\n   \\tt\n+  % Make @kbd do something special, if requested.\n+  \\let\\kbdfont\\kbdexamplefont\n   \\rawbackslash % have \\ input char produce \\ char from current font\n   \\gobble\n }\n@@ -4303,29 +4398,27 @@\n % Read the last existing aux file, if any.  No error if none exists.\n \\def\\readauxfile{\\begingroup\n   \\catcode`\\^^@=\\other\n-  \\catcode`\\\u0001=\\other\n-  \\catcode`\\\u0002=\\other\n+  \\catcode`\\^^A=\\other\n+  \\catcode`\\^^B=\\other\n   \\catcode`\\^^C=\\other\n   \\catcode`\\^^D=\\other\n   \\catcode`\\^^E=\\other\n   \\catcode`\\^^F=\\other\n   \\catcode`\\^^G=\\other\n   \\catcode`\\^^H=\\other\n-  \\catcode`\\\u000b=\\other\n+  \\catcode`\\^^K=\\other\n   \\catcode`\\^^L=\\other\n-  \\catcode`\\\u000e=\\other\n-  \\catcode`\\\u000f=\\other\n-  \\catcode`\\\u0010=\\other\n-  \\catcode`\\\u0011=\\other\n-  \\catcode`\\\u0012=\\other\n-  \\catcode`\\\u0013=\\other\n-  \\catcode`\\\u0014=\\other\n-  \\catcode`\\\u0015=\\other\n-  \\catcode`\\\u0016=\\other\n-  \\catcode`\\\u0017=\\other\n-  \\catcode`\\\u0018=\\other\n-  \\catcode`\\\u0019=\\other\n-  \\catcode26=\\other\n+  \\catcode`\\^^N=\\other\n+  \\catcode`\\^^P=\\other\n+  \\catcode`\\^^Q=\\other\n+  \\catcode`\\^^R=\\other\n+  \\catcode`\\^^S=\\other\n+  \\catcode`\\^^T=\\other\n+  \\catcode`\\^^U=\\other\n+  \\catcode`\\^^V=\\other\n+  \\catcode`\\^^W=\\other\n+  \\catcode`\\^^X=\\other\n+  \\catcode`\\^^Z=\\other\n   \\catcode`\\^^[=\\other\n   \\catcode`\\^^\\=\\other\n   \\catcode`\\^^]=\\other\n@@ -4403,7 +4496,7 @@\n % space to prevent strange expansion errors.)\n \\def\\supereject{\\par\\penalty -20000\\footnoteno =0 }\n \n-% @footnotestyle is meaningful for info output only..\n+% @footnotestyle is meaningful for info output only.\n \\let\\footnotestyle=\\comment\n \n \\let\\ptexfootnote=\\footnote\n@@ -4518,9 +4611,51 @@\n %\n \\def\\finalout{\\overfullrule=0pt}\n \n+% @image.  We use the macros from epsf.tex to support this.\n+% If epsf.tex is not installed and @image is used, we complain.\n+% \n+% Check for and read epsf.tex up front.  If we read it only at @image\n+% time, we might be inside a group, and then its definitions would get\n+% undone and the next image would fail.\n+\\openin 1 = xepsf.tex\n+\\ifeof 1 \\else\n+  \\closein 1\n+  \\def\\epsfannounce{\\toks0 = }% do not bother showing banner\n+  \\input epsf.tex\n+\\fi\n+%\n+\\newif\\ifwarnednoepsf\n+\\newhelp\\noepsfhelp{epsf.tex must be installed for images to\n+  work.  It is also included in the Texinfo distribution, or you can get\n+  it from ftp://ftp.tug.org/tex/epsf.tex.}\n+%\n+% Only complain once about lack of epsf.tex.\n+\\def\\image#1{%\n+  \\ifx\\epsfbox\\undefined\n+    \\ifwarnednoepsf \\else\n+      \\errhelp = \\noepsfhelp\n+      \\errmessage{epsf.tex not found, images will be ignored}%\n+      \\global\\warnednoepsftrue\n+    \\fi\n+  \\else\n+    \\imagexxx #1,,,\\finish\n+  \\fi\n+}\n+%\n+% Arguments to @image:\n+% #1 is (mandatory) image filename; we tack on .eps extension.\n+% #2 is (optional) width, #3 is (optional) height.\n+% #4 is just the usual extra ignored arg for parsing this stuff.\n+\\def\\imagexxx#1,#2,#3,#4\\finish{%\n+  % \\epsfbox itself resets \\epsf?size at each figure.\n+  \\setbox0 = \\hbox{\\ignorespaces #2}\\ifdim\\wd0 > 0pt \\epsfxsize=#2\\relax \\fi\n+  \\setbox0 = \\hbox{\\ignorespaces #3}\\ifdim\\wd0 > 0pt \\epsfysize=#3\\relax \\fi\n+  \\epsfbox{#1.eps}%\n+}\n \n % End of control word definitions.\n \n+\n \\message{and turning on texinfo input format.}\n \n \\def\\openindices{%"}, {"sha": "a848e610f5910dba18ef401fe0c268370a987228", "filename": "texinfo/util/Makefile.in", "status": "modified", "additions": 286, "deletions": 68, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Futil%2FMakefile.in?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,105 +1,323 @@\n-# Makefile for GNU Texindex and other utilities.\n-# $Id: Makefile.in,v 1.1 1997/08/21 22:58:12 jason Exp $\n-# \n-# Copyright (C) 1990, 91, 92, 96 Free Software Foundation, Inc.\n+# Makefile.in generated automatically by automake 1.2 from Makefile.am\n \n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n+# Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy, distribute and modify it.\n \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+SHELL = /bin/sh\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+srcdir = @srcdir@\n+top_srcdir = @top_srcdir@\n+VPATH = @srcdir@\n+prefix = @prefix@\n+exec_prefix = @exec_prefix@\n \n-#### Start of system configuration section. ####\n+bindir = @bindir@\n+sbindir = @sbindir@\n+libexecdir = @libexecdir@\n+datadir = @datadir@\n+sysconfdir = @sysconfdir@\n+sharedstatedir = @sharedstatedir@\n+localstatedir = @localstatedir@\n+libdir = @libdir@\n+infodir = @infodir@\n+mandir = @mandir@\n+includedir = @includedir@\n+oldincludedir = /usr/include\n \n-srcdir = @srcdir@\n-VPATH  = $(srcdir):$(common)\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n \n-common = $(srcdir)/../libtxi\n+top_builddir = ..\n+\n+ACLOCAL = @ACLOCAL@\n+AUTOCONF = @AUTOCONF@\n+AUTOMAKE = @AUTOMAKE@\n+AUTOHEADER = @AUTOHEADER@\n \n-EXEEXT = @EXEEXT@\n-CC = @CC@\n INSTALL = @INSTALL@\n INSTALL_PROGRAM = @INSTALL_PROGRAM@\n INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+transform = @program_transform_name@\n \n-LN\t= ln\n-RM\t= rm -f\n-MKDIR\t= mkdir\n+NORMAL_INSTALL = true\n+PRE_INSTALL = true\n+POST_INSTALL = true\n+NORMAL_UNINSTALL = true\n+PRE_UNINSTALL = true\n+POST_UNINSTALL = true\n+CATALOGS = @CATALOGS@\n+CATOBJEXT = @CATOBJEXT@\n+CC = @CC@\n+DATADIRNAME = @DATADIRNAME@\n+EXEEXT = @EXEEXT@\n+GENCAT = @GENCAT@\n+GMOFILES = @GMOFILES@\n+GMSGFMT = @GMSGFMT@\n+GT_NO = @GT_NO@\n+GT_YES = @GT_YES@\n+INSTOBJEXT = @INSTOBJEXT@\n+INTLDEPS = @INTLDEPS@\n+INTLLIBS = @INTLLIBS@\n+INTLOBJS = @INTLOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKINSTALLDIRS = @MKINSTALLDIRS@\n+MSGFMT = @MSGFMT@\n+PACKAGE = @PACKAGE@\n+POFILES = @POFILES@\n+POSUB = @POSUB@\n+RANLIB = @RANLIB@\n+TERMLIBS = @TERMLIBS@\n+TEXCONFIG = @TEXCONFIG@\n+TEXMF = @TEXMF@\n+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@\n+USE_NLS = @USE_NLS@\n+VERSION = @VERSION@\n+l = @l@\n \n-DEFS = @DEFS@\n-LIBS = -L../libtxi -ltxi @LIBS@\n-LOADLIBES = $(LIBS)\n+bin_PROGRAMS = texindex\n+bin_SCRIPTS = texi2dvi\n \n-SHELL = /bin/sh\n+noinst_PROGRAMS = install-inf\n+install_inf_SOURCES = install-info.c\n \n-CFLAGS = @CFLAGS@\n+localedir = $(datadir)/locale\n+INCLUDES = -I$(top_srcdir)/lib -I../intl -DLOCALEDIR=\\\"$(localedir)\\\"\n+LDADD = ../lib/libtxi.a @INTLLIBS@\n+\n+EXTRA_DIST = README deref.c fixfonts gen-dir-node tex3patch texi2dvi \\\n+             update-info \n+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs\n+CONFIG_HEADER = ../config.h\n+CONFIG_CLEAN_FILES = \n+bin_PROGRAMS =  texindex$(EXEEXT)\n+noinst_PROGRAMS =  install-inf$(EXEEXT)\n+PROGRAMS =  $(bin_PROGRAMS) $(noinst_PROGRAMS)\n+\n+\n+DEFS = @DEFS@ -I. -I$(srcdir) -I..\n+CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n+LIBS = @LIBS@\n+texindex_SOURCES = texindex.c\n+texindex_OBJECTS =  texindex.o\n+texindex_LDADD = $(LDADD)\n+texindex_DEPENDENCIES =  ../lib/libtxi.a\n+texindex_LDFLAGS = \n+install_inf_OBJECTS =  install-info.o\n+install_inf_LDADD = $(LDADD)\n+install_inf_DEPENDENCIES =  ../lib/libtxi.a\n+install_inf_LDFLAGS = \n+SCRIPTS =  $(bin_SCRIPTS)\n \n-prefix = @prefix@\n-exec_prefix = @exec_prefix@\n-bindir = @bindir@\n-# Prefix for each installed program, normally empty or `g'.\n-binprefix = \n-# Prefix for each installed man page, normally empty or `g'.\n-manprefix = \n-mandir = @mandir@/man1\n-manext = 1\n-infodir = @infodir@\n+CFLAGS = @CFLAGS@\n+COMPILE = $(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)\n+LINK = $(CC) $(CFLAGS) $(LDFLAGS) -o $@\n+DIST_COMMON =  README Makefile.am Makefile.in\n+\n+\n+DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n+\n+TAR = tar\n+GZIP = --best\n+SOURCES = texindex.c $(install_inf_SOURCES)\n+OBJECTS = texindex.o $(install_inf_OBJECTS)\n+\n+default: all\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .o\n+$(srcdir)/Makefile.in: @MAINT@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n+\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus util/Makefile\n+\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n+\n+\n+mostlyclean-binPROGRAMS:\n \n-#### End of system configuration section. ####\n+clean-binPROGRAMS:\n+\ttest -z \"$(bin_PROGRAMS)\" || rm -f $(bin_PROGRAMS)\n \n-all: texindex$(EXEEXT) install-info$(EXEEXT)\n-sub-all: all\n+distclean-binPROGRAMS:\n+\n+maintainer-clean-binPROGRAMS:\n+\n+install-binPROGRAMS: $(bin_PROGRAMS)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(bindir)\n+\t@list='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \"  $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`\"; \\\n+\t     $(INSTALL_PROGRAM) $$p $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\t  else :; fi; \\\n+\tdone\n+\n+uninstall-binPROGRAMS:\n+\t$(NORMAL_UNINSTALL)\n+\tlist='$(bin_PROGRAMS)'; for p in $$list; do \\\n+\t  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\tdone\n+\n+mostlyclean-noinstPROGRAMS:\n+\n+clean-noinstPROGRAMS:\n+\ttest -z \"$(noinst_PROGRAMS)\" || rm -f $(noinst_PROGRAMS)\n+\n+distclean-noinstPROGRAMS:\n+\n+maintainer-clean-noinstPROGRAMS:\n \n .c.o:\n-\t$(CC) -c $(CPPFLAGS) $(DEFS) -I. -I$(srcdir) -I$(common) $(CFLAGS) $<\n+\t$(COMPILE) -c $<\n \n+mostlyclean-compile:\n+\trm -f *.o core\n \n-install: all\n-\t$(INSTALL_PROGRAM) texindex$(EXEEXT) $(bindir)/texindex$(EXEEXT)\n-\t$(INSTALL_PROGRAM) $(srcdir)/texi2dvi $(bindir)/texi2dvi\n-\t$(INSTALL_PROGRAM) install-info$(EXEEXT) $(bindir)/install-info$(EXEEXT)\n+clean-compile:\n \n-install-info:\n+distclean-compile:\n+\trm -f *.tab.c\n+\n+maintainer-clean-compile:\n+\n+texindex$(EXEEXT): $(texindex_OBJECTS) $(texindex_DEPENDENCIES)\n+\t@rm -f texindex$(EXEEXT)\n+\t$(LINK) $(texindex_LDFLAGS) $(texindex_OBJECTS) $(texindex_LDADD) $(LIBS)\n+\n+install-inf$(EXEEXT): $(install_inf_OBJECTS) $(install_inf_DEPENDENCIES)\n+\t@rm -f install-inf$(EXEEXT)\n+\t$(LINK) $(install_inf_LDFLAGS) $(install_inf_OBJECTS) $(install_inf_LDADD) $(LIBS)\n+\n+install-binSCRIPTS: $(bin_SCRIPTS)\n+\t@$(NORMAL_INSTALL)\n+\t$(mkinstalldirs) $(bindir)\n+\t@list='$(bin_SCRIPTS)'; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    echo \" $(INSTALL_SCRIPT) $$p $(bindir)/`echo $$p|sed '$(transform)'`$(EXEEXT)\"; \\\n+\t    $(INSTALL_SCRIPT) $$p $(bindir)/`echo $$p|sed '$(transform)'`$(EXEEXT); \\\n+\t  else if test -f $(srcdir)/$$p; then \\\n+\t    echo \" $(INSTALL_SCRIPT) $(srcdir)/$$p $(bindir)/`echo $$p|sed '$(transform)'`$(EXEEXT)\"; \\\n+\t    $(INSTALL_SCRIPT) $(srcdir)/$$p $(bindir)/`echo $$p|sed '$(transform)'`$(EXEEXT); \\\n+\t  else :; fi; fi; \\\n+\tdone\n+\n+uninstall-binSCRIPTS:\n+\t$(NORMAL_UNINSTALL)\n+\tlist='$(bin_SCRIPTS)'; for p in $$list; do \\\n+\t  rm -f $(bindir)/`echo $$p|sed '$(transform)'`; \\\n+\tdone\n+\n+tags: TAGS\n+\n+ID: $(HEADERS) $(SOURCES)\n+\there=`pwd` && cd $(srcdir) && mkid -f$$here/ID $(SOURCES) $(HEADERS)\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES)\n+\ttags=; \\\n+\there=`pwd`; \\\n+\ttest -z \"$(ETAGS_ARGS)$(SOURCES)$(HEADERS)$$tags\" \\\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $(SOURCES) $(HEADERS) -o $$here/TAGS)\n+\n+mostlyclean-tags:\n+\n+clean-tags:\n+\n+distclean-tags:\n+\trm -f TAGS ID\n+\n+maintainer-clean-tags:\n+\n+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n+\n+subdir = util\n+\n+distdir: $(DISTFILES)\n+\t@for file in $(DISTFILES); do \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  test -f $(distdir)/$$file \\\n+\t  || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n+\t  || cp -p $$d/$$file $(distdir)/$$file; \\\n+\tdone\n+info:\n dvi:\n+check: all\n+\t$(MAKE)\n+installcheck:\n+install-info:\n+install-exec: install-binPROGRAMS install-binSCRIPTS install-exec-local\n+\t@$(NORMAL_INSTALL)\n+\n+install-data: \n+\t@$(NORMAL_INSTALL)\n+\n+install: install-exec install-data all\n+\t@:\n+\n+uninstall: uninstall-binPROGRAMS uninstall-binSCRIPTS\n+\n+all: Makefile $(PROGRAMS) $(SCRIPTS)\n+\n+install-strip:\n+\t$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' INSTALL_SCRIPT='$(INSTALL_PROGRAM)' install\n+installdirs:\n+\t$(mkinstalldirs)  $(bindir) $(bindir)\n \n-uninstall:\n-\trm -f $(bindir)/texindex$(EXEEXT) $(bindir)/texi2dvi $(bindir)/install-info$(EXEEXT)\n \n-Makefile: Makefile.in ../config.status\n-\tcd ..; $(SHELL) config.status\n+mostlyclean-generic:\n+\ttest -z \"$(MOSTLYCLEANFILES)\" || rm -f $(MOSTLYCLEANFILES)\n \n-TAGS:\n-\tetags *.c *.h $(common)/getopt*.c $(common)/getopt.h\n+clean-generic:\n+\ttest -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n \n-clean:\n-\trm -f *.o a.out core core.* texindex install-info\n+distclean-generic:\n+\trm -f Makefile $(DISTCLEANFILES)\n+\trm -f config.cache config.log stamp-h stamp-h[0-9]*\n+\ttest -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \n-mostlyclean: clean\n+maintainer-clean-generic:\n+\ttest -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n+\ttest -z \"$(BUILT_SOURCES)\" || rm -f $(BUILT_SOURCES)\n+mostlyclean:  mostlyclean-binPROGRAMS mostlyclean-noinstPROGRAMS \\\n+\t\tmostlyclean-compile mostlyclean-tags \\\n+\t\tmostlyclean-generic\n \n-distclean: clean\n-\trm -f Makefile config.status\n+clean:  clean-binPROGRAMS clean-noinstPROGRAMS clean-compile clean-tags \\\n+\t\tclean-generic mostlyclean\n \n-realclean: distclean\n-\trm -f TAGS\n+distclean:  distclean-binPROGRAMS distclean-noinstPROGRAMS \\\n+\t\tdistclean-compile distclean-tags distclean-generic \\\n+\t\tclean\n+\trm -f config.status\n \n-texindex: texindex.o ../libtxi/libtxi.a\n-\t$(CC) $(LDFLAGS) -o texindex texindex.o $(LOADLIBES)\n+maintainer-clean:  maintainer-clean-binPROGRAMS \\\n+\t\tmaintainer-clean-noinstPROGRAMS \\\n+\t\tmaintainer-clean-compile maintainer-clean-tags \\\n+\t\tmaintainer-clean-generic distclean\n+\t@echo \"This command is intended for maintainers to use;\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n \n-texindex.o: texindex.c $(common)/getopt.h\n+.PHONY: default mostlyclean-binPROGRAMS distclean-binPROGRAMS \\\n+clean-binPROGRAMS maintainer-clean-binPROGRAMS uninstall-binPROGRAMS \\\n+install-binPROGRAMS mostlyclean-noinstPROGRAMS distclean-noinstPROGRAMS \\\n+clean-noinstPROGRAMS maintainer-clean-noinstPROGRAMS \\\n+mostlyclean-compile distclean-compile clean-compile \\\n+maintainer-clean-compile uninstall-binSCRIPTS install-binSCRIPTS tags \\\n+mostlyclean-tags distclean-tags clean-tags maintainer-clean-tags \\\n+distdir info dvi installcheck install-info install-exec install-data \\\n+install uninstall all installdirs mostlyclean-generic distclean-generic \\\n+clean-generic maintainer-clean-generic clean mostlyclean distclean \\\n+maintainer-clean\n \n-install-info: install-info.o\n-\t$(CC) $(LDFLAGS) -o install-info install-info.o $(LOADLIBES)\n \n-install-info.o: install-info.c $(common)/getopt.h\n+install-exec-local: $(noinst_PROGRAMS)\n+\t$(mkinstalldirs) $(bindir)\n+\t$(INSTALL_PROGRAM) install-inf$(EXEEXT) $(bindir)/`echo install-info$(EXEEXT)|sed '$(transform)'`; \\\n \n-# Prevent GNU make v3 from overflowing arg limit on SysV.\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:"}, {"sha": "c7ef670c539324b59b272e32256b0575b4f55813", "filename": "texinfo/util/gen-dir-node", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2Fgen-dir-node", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2Fgen-dir-node", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Futil%2Fgen-dir-node?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,5 +1,5 @@\n #!/bin/sh\n-# $Id: gen-dir-node,v 1.1 1997/08/21 22:58:12 jason Exp $\n+# $Id: gen-dir-node,v 1.1 1997/05/22 22:02:43 karl Exp $\n # Generate the top-level Info node, given a directory of Info files\n # and (optionally) a skeleton file.  The output will be suitable for a\n # top-level dir file.  The skeleton file contains info topic names in the\n@@ -164,9 +164,14 @@ else\n fi\n \n for file in ${infofiles}; do\n+  case $file in\n+    *.gz) zcat=zcat; file=`echo $file|sed 's/\\.gz$//'`; gz=.gz;;\n+    *) zcat=cat; gz=;;\n+  esac\n   infoname=`echo $file | sed 's/\\.info$//'`\n-  entry=`sed -e '1,/START-INFO-DIR-ENTRY/d' \\\n-\t-e '/END-INFO-DIR-ENTRY/,$d' ${INFODIR}/${file}`\n+  entry=`$zcat ${INFODIR}/${file}$gz \\\n+           |sed -e '1,/START-INFO-DIR-ENTRY/d' \\\n+\t\t-e '/END-INFO-DIR-ENTRY/,$d'`\n \n   if [ ! -z \"${entry}\" ] ; then\n     echo \"${entry}\""}, {"sha": "67a95121b7c8fff07f00197853d36313c5c158ac", "filename": "texinfo/util/texi2dvi", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2Ftexi2dvi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2Ftexi2dvi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Futil%2Ftexi2dvi?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -3,7 +3,7 @@\n \n # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.\n \n-# $Id: texi2dvi,v 1.1 1997/08/21 22:58:13 jason Exp $\n+# $Id: texi2dvi,v 0.6 1997/07/14 19:23:18 karl Exp $\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -47,7 +47,7 @@\n progname=`echo \"$0\" | sed -e 's/[^\\/]*\\///g'`\n \n # This string is expanded by rcs automatically when this file is checked out.\n-rcs_revision='$Revision: 1.1 $'\n+rcs_revision='$Revision: 0.6 $'\n version=`set - $rcs_revision; echo $2`\n \n # To prevent hairy quoting and escaping later.\n@@ -329,39 +329,6 @@ done\n \n $verbose \"$0 done.\"\n true # exit successfully.\n-\n-# texi2dvi ends here\n-# $Log: texi2dvi,v $\n-# Revision 1.1  1997/08/21 22:58:13  jason\n-# Initial revision\n-#\n-# Revision 1.10  1996/10/04 18:21:55  karl\n-# Include only the current year in the copyright message.\n-#\n-# Revision 1.9  1996/10/04 11:49:48  karl\n-# Exit successfully.  From arnold.\n-#\n-# Revision 1.8  1996/10/03 23:14:26  karl\n-# Only show diff if verbose.\n-# Update version number.\n-#\n-# Revision 1.7  1996/09/29 22:56:08  karl\n-# Use $progname instead of $0 for --version.\n-#\n-# Revision 1.6  1996/09/28 21:01:23  karl\n-# Recompute original index files each time through loop.\n-# Make indentation uniform.\n-# Use same basename for the temp input files.\n-# Standardize --version output.\n-#\n-# Revision 1.5  1996/09/26 14:46:34  karl\n-# (texi2dvi): Run TeX until the aux/index files stabilize, instead of just\n-# twice.  From: David Shaw <daves@gsms01.alcatel.com.au>.\n-#\n-# Revision 1.4  1996/08/27 18:59:26  karl\n-# Include bug reporting address.\n-#\n-# Revision 1.3  1996/07/26 18:20:56  karl\n # Do macro expansion with makeinfo before running TeX.\n # Various expansion safety measures added for test; avoid use of -o.\n #"}, {"sha": "2b3bd20c30db66f6c77654b305c9988c76a1b5a7", "filename": "texinfo/util/texindex.c", "status": "modified", "additions": 335, "deletions": 358, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2Ftexindex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8491377bd19a528b1249b3a6ad67277d813720fc/texinfo%2Futil%2Ftexindex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/texinfo%2Futil%2Ftexindex.c?ref=8491377bd19a528b1249b3a6ad67277d813720fc", "patch": "@@ -1,7 +1,7 @@\n /* Prepare TeX index dribble output into an actual index.\n-   $Id: texindex.c,v 1.1 1997/08/21 22:58:13 jason Exp $\n+   $Id: texindex.c,v 1.17 1997/07/24 23:34:45 karl Exp $\n \n-   Copyright (C) 1987, 91, 92, 96 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91, 92, 96, 97 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -17,12 +17,8 @@\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307. */\n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <errno.h>\n-#include \"getopt.h\"\n-\n-#define TEXINDEX_VERSION_STRING \"GNU Texindex (Texinfo 3.9) 2.1\"\n+#include \"system.h\"\n+#include <getopt.h>\n \n #if defined (emacs)\n #  include \"../src/config.h\"\n@@ -33,26 +29,6 @@\n #  undef open\n #endif\n \n-#if defined (HAVE_STRING_H)\n-#  include <string.h>\n-#endif /* HAVE_STRING_H */\n-\n-#if !defined (HAVE_STRCHR)\n-char *strrchr ();\n-#endif /* !HAVE_STRCHR */\n-\n-#if defined (STDC_HEADERS)\n-#  include <stdlib.h>\n-#else /* !STDC_HEADERS */\n-char *getenv (), *malloc (), *realloc ();\n-#endif /* !STDC_HEADERS */\n-\n-#if defined (HAVE_UNISTD_H)\n-#  include <unistd.h>\n-#else /* !HAVE_UNISTD_H */\n-off_t lseek ();\n-#endif /* !HAVE_UNISTD_H */\n-\n #if !defined (HAVE_MEMSET)\n #undef memset\n #define memset(ptr, ignore, count) bzero (ptr, count)\n@@ -89,38 +65,31 @@ char *mktemp ();\n #  define SEEK_END 2\n #endif /* !SEEK_SET */\n \n-#ifndef errno\n-extern int errno;\n-#endif\n-#ifndef strerror\n-extern char *strerror ();\n-#endif\n-\n /* When sorting in core, this structure describes one line\n    and the position and length of its first keyfield.  */\n struct lineinfo\n {\n-  char *text;\t\t/* The actual text of the line. */\n+  char *text;           /* The actual text of the line. */\n   union {\n-    char *text;\t\t/* The start of the key (for textual comparison). */\n-    long number;\t/* The numeric value (for numeric comparison). */\n+    char *text;         /* The start of the key (for textual comparison). */\n+    long number;        /* The numeric value (for numeric comparison). */\n   } key;\n-  long keylen;\t\t/* Length of KEY field. */\n+  long keylen;          /* Length of KEY field. */\n };\n \n /* This structure describes a field to use as a sort key. */\n struct keyfield\n {\n-  int startwords;\t/* Number of words to skip. */\n-  int startchars;\t/* Number of additional chars to skip. */\n-  int endwords;\t\t/* Number of words to ignore at end. */\n-  int endchars;\t\t/* Ditto for characters of last word. */\n-  char ignore_blanks;\t/* Non-zero means ignore spaces and tabs. */\n-  char fold_case;\t/* Non-zero means case doesn't matter. */\n-  char reverse;\t\t/* Non-zero means compare in reverse order. */\n-  char numeric;\t\t/* Non-zeros means field is ASCII numeric. */\n-  char positional;\t/* Sort according to file position. */\n-  char braced;\t\t/* Count balanced-braced groupings as fields. */\n+  int startwords;       /* Number of words to skip. */\n+  int startchars;       /* Number of additional chars to skip. */\n+  int endwords;         /* Number of words to ignore at end. */\n+  int endchars;         /* Ditto for characters of last word. */\n+  char ignore_blanks;   /* Non-zero means ignore spaces and tabs. */\n+  char fold_case;       /* Non-zero means case doesn't matter. */\n+  char reverse;         /* Non-zero means compare in reverse order. */\n+  char numeric;         /* Non-zeros means field is ASCII numeric. */\n+  char positional;      /* Sort according to file position. */\n+  char braced;          /* Count balanced-braced groupings as fields. */\n };\n \n /* Vector of keyfields to use. */\n@@ -214,6 +183,15 @@ main (argc, argv)\n   else\n     program_name = argv[0];\n \n+#ifdef HAVE_SETLOCALE\n+  /* Set locale via LC_ALL.  */\n+  setlocale (LC_ALL, \"\");\n+#endif\n+\n+  /* Set the text message domain.  */\n+  bindtextdomain (PACKAGE, LOCALEDIR);\n+  textdomain (PACKAGE);\n+\n   /* Describe the kind of sorting to do. */\n   /* The first keyfield uses the first braced field and folds case. */\n   keyfields[0].braced = 1;\n@@ -247,23 +225,23 @@ main (argc, argv)\n \n       desc = open (infiles[i], O_RDONLY, 0);\n       if (desc < 0)\n-\tpfatal_with_name (infiles[i]);\n+        pfatal_with_name (infiles[i]);\n       lseek (desc, (off_t) 0, SEEK_END);\n       ptr = (long) lseek (desc, (off_t) 0, SEEK_CUR);\n \n       close (desc);\n \n       outfile = outfiles[i];\n       if (!outfile)\n-\t{\n-\t  outfile = concat (infiles[i], \"s\", \"\");\n-\t}\n+        {\n+          outfile = concat (infiles[i], \"s\", \"\");\n+        }\n \n       if (ptr < MAX_IN_CORE_SORT)\n-\t/* Sort a small amount of data. */\n-\tsort_in_core (infiles[i], ptr, outfile);\n+        /* Sort a small amount of data. */\n+        sort_in_core (infiles[i], ptr, outfile);\n       else\n-\tsort_offline (infiles[i], ptr, outfile);\n+        sort_offline (infiles[i], ptr, outfile);\n     }\n \n   flush_tempfiles (tempcount);\n@@ -282,15 +260,15 @@ typedef struct\n \n TEXINDEX_OPTION texindex_options[] = {\n   { \"--keep\", \"-k\", &keep_tempfiles, 1, (char *)NULL,\n-      \"keep temporary files around after processing\" },\n+      N_(\"keep temporary files around after processing\") },\n   { \"--no-keep\", 0, &keep_tempfiles, 0, (char *)NULL,\n-      \"do not keep temporary files around after processing (default)\" },\n+      N_(\"do not keep temporary files around after processing (default)\") },\n   { \"--output\", \"-o\", (int *)NULL, 0, \"FILE\",\n-      \"send output to FILE\" },\n+      N_(\"send output to FILE\") },\n   { \"--version\", (char *)NULL, (int *)NULL, 0, (char *)NULL,\n-      \"display version information and exit\" },\n+      N_(\"display version information and exit\") },\n   { \"--help\", \"-h\", (int *)NULL, 0, (char *)NULL,\n-      \"display this help and exit\" },\n+      N_(\"display this help and exit\") },\n   { (char *)NULL, (char *)NULL, (int *)NULL, 0, (char *)NULL }\n };\n \n@@ -301,25 +279,25 @@ usage (result_value)\n   register int i;\n   FILE *f = result_value ? stderr : stdout;\n \n-  fprintf (f, \"Usage: %s [OPTION]... FILE...\\n\", program_name);\n-  fprintf (f, \"Generate a sorted index for each TeX output FILE.\\n\");\n+  fprintf (f, _(\"Usage: %s [OPTION]... FILE...\\n\"), program_name);\n+  fprintf (f, _(\"Generate a sorted index for each TeX output FILE.\\n\"));\n   /* Avoid trigraph nonsense.  */\n-  fprintf (f, \"Usually FILE... is `foo.??\\' for a document `foo.texi'.\\n\");\n-  fprintf (f, \"\\nOptions:\\n\");\n+  fprintf (f, _(\"Usually FILE... is `foo.??\\' for a document `foo.texi'.\\n\"));\n+  fprintf (f, _(\"\\nOptions:\\n\"));\n \n   for (i = 0; texindex_options[i].long_name; i++)\n     {\n       if (texindex_options[i].short_name)\n-\tfprintf (f, \"%s, \", texindex_options[i].short_name);\n+        fprintf (f, \"%s, \", texindex_options[i].short_name);\n \n       fprintf (f, \"%s %s\",\n-\t       texindex_options[i].long_name,\n-\t       texindex_options[i].arg_name\n+               texindex_options[i].long_name,\n+               texindex_options[i].arg_name\n                ? texindex_options[i].arg_name : \"\");\n \n-      fprintf (f, \"\\t%s\\n\", texindex_options[i].doc_string);\n+      fprintf (f, \"\\t%s\\n\", _(texindex_options[i].doc_string));\n     }\n-  puts (\"\\nEmail bug reports to bug-texinfo@prep.ai.mit.edu.\");\n+  puts (_(\"\\nEmail bug reports to bug-texinfo@prep.ai.mit.edu.\"));\n \n   exit (result_value);\n }\n@@ -333,7 +311,6 @@ decode_command (argc, argv)\n      char **argv;\n {\n   int arg_index = 1;\n-  int optc;\n   char **ip;\n   char **op;\n \n@@ -364,46 +341,46 @@ decode_command (argc, argv)\n       char *arg = argv[arg_index++];\n \n       if (*arg == '-')\n-\t{\n-\t  if (strcmp (arg, \"--version\") == 0)\n-\t    {\n-\t      puts (TEXINDEX_VERSION_STRING);\n-puts (\"Copyright (C) 1996 Free Software Foundation, Inc.\\n\\\n+        {\n+          if (strcmp (arg, \"--version\") == 0)\n+            {\n+              printf (_(\"texindex (GNU %s %s) 2.1\\n\"), PACKAGE, VERSION);\n+puts (_(\"Copyright (C) 1996 Free Software Foundation, Inc.\\n\\\n There is NO warranty.  You may redistribute this software\\n\\\n under the terms of the GNU General Public License.\\n\\\n-For more information about these matters, see the files named COPYING.\");\n-\t      exit (0);\n-\t    }\n-\t  else if ((strcmp (arg, \"--keep\") == 0) ||\n-\t\t   (strcmp (arg, \"-k\") == 0))\n-\t    {\n-\t      keep_tempfiles = 1;\n-\t    }\n-\t  else if ((strcmp (arg, \"--help\") == 0) ||\n-\t\t   (strcmp (arg, \"-h\") == 0))\n-\t    {\n-\t      usage (0);\n-\t    }\n-\t  else if ((strcmp (arg, \"--output\") == 0) ||\n-\t\t   (strcmp (arg, \"-o\") == 0))\n-\t    {\n-\t      if (argv[arg_index] != (char *)NULL)\n-\t\t{\n-\t\t  arg_index++;\n-\t\t  if (op > outfiles)\n-\t\t    *(op - 1) = argv[arg_index];\n-\t\t}\n-\t      else\n-\t\tusage (1);\n-\t    }\n-\t  else\n-\t    usage (1);\n-\t}\n+For more information about these matters, see the files named COPYING.\"));\n+              exit (0);\n+            }\n+          else if ((strcmp (arg, \"--keep\") == 0) ||\n+                   (strcmp (arg, \"-k\") == 0))\n+            {\n+              keep_tempfiles = 1;\n+            }\n+          else if ((strcmp (arg, \"--help\") == 0) ||\n+                   (strcmp (arg, \"-h\") == 0))\n+            {\n+              usage (0);\n+            }\n+          else if ((strcmp (arg, \"--output\") == 0) ||\n+                   (strcmp (arg, \"-o\") == 0))\n+            {\n+              if (argv[arg_index] != (char *)NULL)\n+                {\n+                  arg_index++;\n+                  if (op > outfiles)\n+                    *(op - 1) = argv[arg_index];\n+                }\n+              else\n+                usage (1);\n+            }\n+          else\n+            usage (1);\n+        }\n       else\n-\t{\n-\t  *ip++ = arg;\n-\t  *op++ = (char *)NULL;\n-\t}\n+        {\n+          *ip++ = arg;\n+          *op++ = (char *)NULL;\n+        }\n     }\n \n   /* Record number of keyfields and terminate list of filenames. */\n@@ -459,7 +436,7 @@ tempcopy (idesc)\n       int nread = read (idesc, buffer, BUFSIZE);\n       write (odesc, buffer, nread);\n       if (!nread)\n-\tbreak;\n+        break;\n     }\n \n   close (odesc);\n@@ -485,16 +462,16 @@ compare_full (line1, line2)\n       char *start1 = find_field (&keyfields[i], *line1, &length1);\n       char *start2 = find_field (&keyfields[i], *line2, &length2);\n       int tem = compare_field (&keyfields[i], start1, length1, *line1 - text_base,\n-\t\t\t       start2, length2, *line2 - text_base);\n+                               start2, length2, *line2 - text_base);\n       if (tem)\n-\t{\n-\t  if (keyfields[i].reverse)\n-\t    return -tem;\n-\t  return tem;\n-\t}\n+        {\n+          if (keyfields[i].reverse)\n+            return -tem;\n+          return tem;\n+        }\n     }\n \n-  return 0;\t\t\t/* Lines match exactly. */\n+  return 0;                     /* Lines match exactly. */\n }\n \n /* Compare LINE1 and LINE2, described by structures\n@@ -514,19 +491,19 @@ compare_prepared (line1, line2)\n   if (keyfields->positional)\n     {\n       if (line1->text - text_base > line2->text - text_base)\n-\ttem = 1;\n+        tem = 1;\n       else\n-\ttem = -1;\n+        tem = -1;\n     }\n   else if (keyfields->numeric)\n     tem = line1->key.number - line2->key.number;\n   else\n     tem = compare_field (keyfields, line1->key.text, line1->keylen, 0,\n-\t\t\t line2->key.text, line2->keylen, 0);\n+                         line2->key.text, line2->keylen, 0);\n   if (tem)\n     {\n       if (keyfields->reverse)\n-\treturn -tem;\n+        return -tem;\n       return tem;\n     }\n \n@@ -543,16 +520,16 @@ compare_prepared (line1, line2)\n       char *start1 = find_field (&keyfields[i], text1, &length1);\n       char *start2 = find_field (&keyfields[i], text2, &length2);\n       int tem = compare_field (&keyfields[i], start1, length1, text1 - text_base,\n-\t\t\t       start2, length2, text2 - text_base);\n+                               start2, length2, text2 - text_base);\n       if (tem)\n-\t{\n-\t  if (keyfields[i].reverse)\n-\t    return -tem;\n-\t  return tem;\n-\t}\n+        {\n+          if (keyfields[i].reverse)\n+            return -tem;\n+          return tem;\n+        }\n     }\n \n-  return 0;\t\t\t/* Lines match exactly. */\n+  return 0;                     /* Lines match exactly. */\n }\n \n /* Like compare_full but more general.\n@@ -578,16 +555,16 @@ compare_general (str1, str2, pos1, pos2, use_keyfields)\n       char *start1 = find_field (&keyfields[i], str1, &length1);\n       char *start2 = find_field (&keyfields[i], str2, &length2);\n       int tem = compare_field (&keyfields[i], start1, length1, pos1,\n-\t\t\t       start2, length2, pos2);\n+                               start2, length2, pos2);\n       if (tem)\n-\t{\n-\t  if (keyfields[i].reverse)\n-\t    return -tem;\n-\t  return tem;\n-\t}\n+        {\n+          if (keyfields[i].reverse)\n+            return -tem;\n+          return tem;\n+        }\n     }\n \n-  return 0;\t\t\t/* Lines match exactly. */\n+  return 0;                     /* Lines match exactly. */\n }\n \n /* Find the start and length of a field in STR according to KEYFIELD.\n@@ -610,23 +587,23 @@ find_field (keyfield, str, lengthptr)\n     fun = find_pos;\n \n   start = (*fun) (str, keyfield->startwords, keyfield->startchars,\n-\t\t  keyfield->ignore_blanks);\n+                  keyfield->ignore_blanks);\n   if (keyfield->endwords < 0)\n     {\n       if (keyfield->braced)\n-\tend = find_braced_end (start);\n+        end = find_braced_end (start);\n       else\n-\t{\n-\t  end = start;\n-\t  while (*end && *end != '\\n')\n-\t    end++;\n-\t}\n+        {\n+          end = start;\n+          while (*end && *end != '\\n')\n+            end++;\n+        }\n     }\n   else\n     {\n       end = (*fun) (str, keyfield->endwords, keyfield->endchars, 0);\n       if (end - str < start - str)\n-\tend = start;\n+        end = start;\n     }\n   *lengthptr = end - start;\n   return start;\n@@ -651,11 +628,11 @@ find_pos (str, words, chars, ignore_blanks)\n       char c;\n       /* Find next bunch of nonblanks and skip them. */\n       while ((c = *p) == ' ' || c == '\\t')\n-\tp++;\n+        p++;\n       while ((c = *p) && c != '\\n' && !(c == ' ' || c == '\\t'))\n-\tp++;\n+        p++;\n       if (!*p || *p == '\\n')\n-\treturn p;\n+        return p;\n     }\n \n   while (*p == ' ' || *p == '\\t')\n@@ -664,7 +641,7 @@ find_pos (str, words, chars, ignore_blanks)\n   for (i = 0; i < chars; i++)\n     {\n       if (!*p || *p == '\\n')\n-\tbreak;\n+        break;\n       p++;\n     }\n   return p;\n@@ -688,19 +665,19 @@ find_braced_pos (str, words, chars, ignore_blanks)\n     {\n       bracelevel = 1;\n       while ((c = *p++) != '{' && c != '\\n' && c)\n-\t/* Do nothing. */ ;\n+        /* Do nothing. */ ;\n       if (c != '{')\n-\treturn p - 1;\n+        return p - 1;\n       while (bracelevel)\n-\t{\n-\t  c = *p++;\n-\t  if (c == '{')\n-\t    bracelevel++;\n-\t  if (c == '}')\n-\t    bracelevel--;\n-\t  if (c == 0 || c == '\\n')\n-\t    return p - 1;\n-\t}\n+        {\n+          c = *p++;\n+          if (c == '{')\n+            bracelevel++;\n+          if (c == '}')\n+            bracelevel--;\n+          if (c == 0 || c == '\\n')\n+            return p - 1;\n+        }\n     }\n \n   while ((c = *p++) != '{' && c != '\\n' && c)\n@@ -716,7 +693,7 @@ find_braced_pos (str, words, chars, ignore_blanks)\n   for (i = 0; i < chars; i++)\n     {\n       if (!*p || *p == '\\n')\n-\tbreak;\n+        break;\n       p++;\n     }\n   return p;\n@@ -738,11 +715,11 @@ find_braced_end (str)\n     {\n       c = *p++;\n       if (c == '{')\n-\tbracelevel++;\n+        bracelevel++;\n       if (c == '}')\n-\tbracelevel--;\n+        bracelevel--;\n       if (c == 0 || c == '\\n')\n-\treturn p - 1;\n+        return p - 1;\n     }\n   return p - 1;\n }\n@@ -755,7 +732,7 @@ find_value (start, length)\n   while (length != 0L)\n     {\n       if (isdigit (*start))\n-\treturn atol (start);\n+        return atol (start);\n       length--;\n       start++;\n     }\n@@ -801,17 +778,17 @@ compare_field (keyfield, start1, length1, pos1, start2, length2, pos2)\n   if (keyfields->positional)\n     {\n       if (pos1 > pos2)\n-\treturn 1;\n+        return 1;\n       else\n-\treturn -1;\n+        return -1;\n     }\n   if (keyfield->numeric)\n     {\n       long value = find_value (start1, length1) - find_value (start2, length2);\n       if (value > 0)\n-\treturn 1;\n+        return 1;\n       if (value < 0)\n-\treturn -1;\n+        return -1;\n       return 0;\n     }\n   else\n@@ -822,46 +799,46 @@ compare_field (keyfield, start1, length1, pos1, start2, length2, pos2)\n       char *e2 = start2 + length2;\n \n       while (1)\n-\t{\n-\t  int c1, c2;\n-\n-\t  if (p1 == e1)\n-\t    c1 = 0;\n-\t  else\n-\t    c1 = *p1++;\n-\t  if (p2 == e2)\n-\t    c2 = 0;\n-\t  else\n-\t    c2 = *p2++;\n-\n-\t  if (char_order[c1] != char_order[c2])\n-\t    return char_order[c1] - char_order[c2];\n-\t  if (!c1)\n-\t    break;\n-\t}\n+        {\n+          int c1, c2;\n+\n+          if (p1 == e1)\n+            c1 = 0;\n+          else\n+            c1 = *p1++;\n+          if (p2 == e2)\n+            c2 = 0;\n+          else\n+            c2 = *p2++;\n+\n+          if (char_order[c1] != char_order[c2])\n+            return char_order[c1] - char_order[c2];\n+          if (!c1)\n+            break;\n+        }\n \n       /* Strings are equal except possibly for case.  */\n       p1 = start1;\n       p2 = start2;\n       while (1)\n-\t{\n-\t  int c1, c2;\n-\n-\t  if (p1 == e1)\n-\t    c1 = 0;\n-\t  else\n-\t    c1 = *p1++;\n-\t  if (p2 == e2)\n-\t    c2 = 0;\n-\t  else\n-\t    c2 = *p2++;\n-\n-\t  if (c1 != c2)\n-\t    /* Reverse sign here so upper case comes out last.  */\n-\t    return c2 - c1;\n-\t  if (!c1)\n-\t    break;\n-\t}\n+        {\n+          int c1, c2;\n+\n+          if (p1 == e1)\n+            c1 = 0;\n+          else\n+            c1 = *p1++;\n+          if (p2 == e2)\n+            c2 = 0;\n+          else\n+            c2 = *p2++;\n+\n+          if (c1 != c2)\n+            /* Reverse sign here so upper case comes out last.  */\n+            return c2 - c1;\n+          if (!c1)\n+            break;\n+        }\n \n       return 0;\n     }\n@@ -903,17 +880,17 @@ readline (linebuffer, stream)\n     {\n       int c = getc (stream);\n       if (p == end)\n-\t{\n-\t  buffer = (char *) xrealloc (buffer, linebuffer->size *= 2);\n-\t  p += buffer - linebuffer->buffer;\n-\t  end += buffer - linebuffer->buffer;\n-\t  linebuffer->buffer = buffer;\n-\t}\n+        {\n+          buffer = (char *) xrealloc (buffer, linebuffer->size *= 2);\n+          p += buffer - linebuffer->buffer;\n+          end += buffer - linebuffer->buffer;\n+          linebuffer->buffer = buffer;\n+        }\n       if (c < 0 || c == '\\n')\n-\t{\n-\t  *p = 0;\n-\t  break;\n-\t}\n+        {\n+          *p = 0;\n+          break;\n+        }\n       *p++ = c;\n     }\n \n@@ -946,7 +923,7 @@ sort_offline (infile, nfiles, total, outfile)\n \n   if (lb.buffer[0] != '\\\\' && lb.buffer[0] != '@')\n     {\n-      error (\"%s: not a texinfo index file\", infile);\n+      error (_(\"%s: not a texinfo index file\"), infile);\n       return;\n     }\n \n@@ -960,34 +937,34 @@ sort_offline (infile, nfiles, total, outfile)\n       long tempsize = 0;\n \n       if (!ostream)\n-\tpfatal_with_name (outname);\n+        pfatal_with_name (outname);\n       tempfiles[i] = outname;\n \n       /* Copy lines into this temp file as long as it does not make file\n-\t \"too big\" or until there are no more lines.  */\n+         \"too big\" or until there are no more lines.  */\n \n       while (tempsize + linelength + 1 <= MAX_IN_CORE_SORT)\n-\t{\n-\t  tempsize += linelength + 1;\n-\t  fputs (lb.buffer, ostream);\n-\t  putc ('\\n', ostream);\n-\n-\t  /* Read another line of input data.  */\n-\n-\t  linelength = readline (&lb, istream);\n-\t  if (!linelength && feof (istream))\n-\t    break;\n-\n-\t  if (lb.buffer[0] != '\\\\' && lb.buffer[0] != '@')\n-\t    {\n-\t      error (\"%s: not a texinfo index file\", infile);\n-\t      failure = 1;\n-\t      goto fail;\n-\t    }\n-\t}\n+        {\n+          tempsize += linelength + 1;\n+          fputs (lb.buffer, ostream);\n+          putc ('\\n', ostream);\n+\n+          /* Read another line of input data.  */\n+\n+          linelength = readline (&lb, istream);\n+          if (!linelength && feof (istream))\n+            break;\n+\n+          if (lb.buffer[0] != '\\\\' && lb.buffer[0] != '@')\n+            {\n+              error (_(\"%s: not a texinfo index file\"), infile);\n+              failure = 1;\n+              goto fail;\n+            }\n+        }\n       fclose (ostream);\n       if (feof (istream))\n-\tbreak;\n+        break;\n     }\n \n   free (lb.buffer);\n@@ -1006,7 +983,7 @@ sort_offline (infile, nfiles, total, outfile)\n       char *newtemp = maketempname (++tempcount);\n       sort_in_core (&tempfiles[i], MAX_IN_CORE_SORT, newtemp);\n       if (!keep_tempfiles)\n-\tunlink (tempfiles[i]);\n+        unlink (tempfiles[i]);\n       tempfiles[i] = newtemp;\n     }\n \n@@ -1041,12 +1018,12 @@ sort_in_core (infile, total, outfile)\n   int desc = open (infile, O_RDONLY, 0);\n \n   if (desc < 0)\n-    fatal (\"failure reopening %s\", infile);\n+    fatal (_(\"failure reopening %s\"), infile);\n   for (file_size = 0;;)\n     {\n       i = read (desc, data + file_size, total - file_size);\n       if (i <= 0)\n-\tbreak;\n+        break;\n       file_size += i;\n     }\n   file_data = data;\n@@ -1056,7 +1033,7 @@ sort_in_core (infile, total, outfile)\n \n   if (file_size > 0 && data[0] != '\\\\' && data[0] != '@')\n     {\n-      error (\"%s: not a texinfo index file\", infile);\n+      error (_(\"%s: not a texinfo index file\"), infile);\n       return;\n     }\n \n@@ -1084,7 +1061,7 @@ sort_in_core (infile, total, outfile)\n   nextline = parsefile (infile, nextline, file_data, file_size);\n   if (nextline == 0)\n     {\n-      error (\"%s: not a texinfo index file\", infile);\n+      error (_(\"%s: not a texinfo index file\"), infile);\n       return;\n     }\n \n@@ -1102,18 +1079,18 @@ sort_in_core (infile, total, outfile)\n       char **p;\n \n       for (lp = lineinfo, p = linearray; p != nextline; lp++, p++)\n-\t{\n-\t  lp->text = *p;\n-\t  lp->key.text = find_field (keyfields, *p, &lp->keylen);\n-\t  if (keyfields->numeric)\n-\t    lp->key.number = find_value (lp->key.text, lp->keylen);\n-\t}\n+        {\n+          lp->text = *p;\n+          lp->key.text = find_field (keyfields, *p, &lp->keylen);\n+          if (keyfields->numeric)\n+            lp->key.number = find_value (lp->key.text, lp->keylen);\n+        }\n \n       qsort (lineinfo, nextline - linearray, sizeof (struct lineinfo),\n              compare_prepared);\n \n       for (lp = lineinfo, p = linearray; p != nextline; lp++, p++)\n-\t*p = lp->text;\n+        *p = lp->text;\n \n       free (lineinfo);\n     }\n@@ -1126,7 +1103,7 @@ sort_in_core (infile, total, outfile)\n     {\n       ostream = fopen (outfile, \"w\");\n       if (!ostream)\n-\tpfatal_with_name (outfile);\n+        pfatal_with_name (outfile);\n     }\n \n   writelines (linearray, nextline - linearray, ostream);\n@@ -1160,21 +1137,21 @@ parsefile (filename, nextline, data, size)\n   while (p != end)\n     {\n       if (p[0] != '\\\\' && p[0] != '@')\n-\treturn 0;\n+        return 0;\n \n       *line = p;\n       while (*p && *p != '\\n')\n-\tp++;\n+        p++;\n       if (p != end)\n-\tp++;\n+        p++;\n \n       line++;\n       if (line == linearray + nlines)\n-\t{\n-\t  char **old = linearray;\n-\t  linearray = (char **) xrealloc (linearray, sizeof (char *) * (nlines *= 4));\n-\t  line += linearray - old;\n-\t}\n+        {\n+          char **old = linearray;\n+          linearray = (char **) xrealloc (linearray, sizeof (char *) * (nlines *= 4));\n+          line += linearray - old;\n+        }\n     }\n \n   return line;\n@@ -1266,7 +1243,7 @@ indexify (line, ostream)\n     {\n       initial = p;\n       /* Get length of inner pair of braces starting at `p',\n-\t including that inner pair of braces.  */\n+         including that inner pair of braces.  */\n       initiallength = find_braced_end (p + 1) + 1 - p;\n     }\n   else\n@@ -1277,7 +1254,7 @@ indexify (line, ostream)\n       initiallength = 1;\n \n       if (initial1[0] >= 'a' && initial1[0] <= 'z')\n-\tinitial1[0] -= 040;\n+        initial1[0] -= 040;\n     }\n \n   pagenumber = find_braced_pos (line, 1, 0, 0);\n@@ -1298,52 +1275,52 @@ indexify (line, ostream)\n     {\n       /* Close off current secondary entry first, if one is open. */\n       if (pending)\n-\t{\n-\t  fputs (\"}\\n\", ostream);\n-\t  pending = 0;\n-\t}\n+        {\n+          fputs (\"}\\n\", ostream);\n+          pending = 0;\n+        }\n \n       /* If this primary has a different initial, include an entry for\n-\t the initial. */\n+         the initial. */\n       if (initiallength != lastinitiallength ||\n-\t  strncmp (initial, lastinitial, initiallength))\n-\t{\n-\t  fprintf (ostream, \"\\\\initial {\");\n-\t  fwrite (initial, 1, initiallength, ostream);\n-\t  fprintf (ostream, \"}\\n\", initial);\n-\t  if (initial == initial1)\n-\t    {\n-\t      lastinitial = lastinitial1;\n-\t      *lastinitial1 = *initial1;\n-\t    }\n-\t  else\n-\t    {\n-\t      lastinitial = initial;\n-\t    }\n-\t  lastinitiallength = initiallength;\n-\t}\n+          strncmp (initial, lastinitial, initiallength))\n+        {\n+          fprintf (ostream, \"\\\\initial {\");\n+          fwrite (initial, 1, initiallength, ostream);\n+          fputs (\"}\\n\", ostream);\n+          if (initial == initial1)\n+            {\n+              lastinitial = lastinitial1;\n+              *lastinitial1 = *initial1;\n+            }\n+          else\n+            {\n+              lastinitial = initial;\n+            }\n+          lastinitiallength = initiallength;\n+        }\n \n       /* Make the entry for the primary.  */\n       if (nosecondary)\n-\tfputs (\"\\\\entry {\", ostream);\n+        fputs (\"\\\\entry {\", ostream);\n       else\n-\tfputs (\"\\\\primary {\", ostream);\n+        fputs (\"\\\\primary {\", ostream);\n       fwrite (primary, primarylength, 1, ostream);\n       if (nosecondary)\n-\t{\n-\t  fputs (\"}{\", ostream);\n-\t  pending = 1;\n-\t}\n+        {\n+          fputs (\"}{\", ostream);\n+          pending = 1;\n+        }\n       else\n-\tfputs (\"}\\n\", ostream);\n+        fputs (\"}\\n\", ostream);\n \n       /* Record name of most recent primary. */\n       if (lastprimarylength < primarylength)\n-\t{\n-\t  lastprimarylength = primarylength + 100;\n-\t  lastprimary = (char *) xrealloc (lastprimary,\n-\t\t\t\t\t   1 + lastprimarylength);\n-\t}\n+        {\n+          lastprimarylength = primarylength + 100;\n+          lastprimary = (char *) xrealloc (lastprimary,\n+                                           1 + lastprimarylength);\n+        }\n       strncpy (lastprimary, primary, primarylength);\n       lastprimary[primarylength] = 0;\n \n@@ -1354,16 +1331,16 @@ indexify (line, ostream)\n   /* Should not have an entry with no subtopic following one with a subtopic. */\n \n   if (nosecondary && *lastsecondary)\n-    error (\"entry %s follows an entry with a secondary name\", line);\n+    error (_(\"entry %s follows an entry with a secondary name\"), line);\n \n   /* Start a new secondary entry if necessary. */\n   if (!nosecondary && strncmp (secondary, lastsecondary, secondarylength))\n     {\n       if (pending)\n-\t{\n-\t  fputs (\"}\\n\", ostream);\n-\t  pending = 0;\n-\t}\n+        {\n+          fputs (\"}\\n\", ostream);\n+          pending = 0;\n+        }\n \n       /* Write the entry for the secondary.  */\n       fputs (\"\\\\secondary {\", ostream);\n@@ -1373,18 +1350,18 @@ indexify (line, ostream)\n \n       /* Record name of most recent secondary. */\n       if (lastsecondarylength < secondarylength)\n-\t{\n-\t  lastsecondarylength = secondarylength + 100;\n-\t  lastsecondary = (char *) xrealloc (lastsecondary,\n-\t\t\t\t\t     1 + lastsecondarylength);\n-\t}\n+        {\n+          lastsecondarylength = secondarylength + 100;\n+          lastsecondary = (char *) xrealloc (lastsecondary,\n+                                             1 + lastsecondarylength);\n+        }\n       strncpy (lastsecondary, secondary, secondarylength);\n       lastsecondary[secondarylength] = 0;\n     }\n \n   /* Here to add one more page number to the current entry. */\n   if (pending++ != 1)\n-    fputs (\", \", ostream);\t/* Punctuate first, if this is not the first. */\n+    fputs (\", \", ostream);      /* Punctuate first, if this is not the first. */\n   fwrite (pagenumber, pagelength, 1, ostream);\n }\n \n@@ -1422,16 +1399,16 @@ writelines (linearray, nlines, ostream)\n       if (next_line == linearray\n       /* Compare previous line with this one, using only the\n          explicitly specd keyfields. */\n-\t  || compare_general (*(next_line - 1), *next_line, 0L, 0L, num_keyfields - 1))\n-\t{\n-\t  char *p = *next_line;\n-\t  char c;\n-\n-\t  while ((c = *p++) && c != '\\n')\n-\t    /* Do nothing. */ ;\n-\t  *(p - 1) = 0;\n-\t  indexify (*next_line, ostream);\n-\t}\n+          || compare_general (*(next_line - 1), *next_line, 0L, 0L, num_keyfields - 1))\n+        {\n+          char *p = *next_line;\n+          char c;\n+\n+          while ((c = *p++) && c != '\\n')\n+            /* Do nothing. */ ;\n+          *(p - 1) = 0;\n+          indexify (*next_line, ostream);\n+        }\n     }\n \n   finish_index (ostream);\n@@ -1470,7 +1447,7 @@ merge_files (infiles, nfiles, outfile)\n     {\n       int nf = MAX_DIRECT_MERGE;\n       if (i + 1 == ntemps)\n-\tnf = nfiles - i * MAX_DIRECT_MERGE;\n+        nf = nfiles - i * MAX_DIRECT_MERGE;\n       tempfiles[i] = maketempname (++tempcount);\n       value |= merge_direct (&infiles[i * MAX_DIRECT_MERGE], nf, tempfiles[i]);\n     }\n@@ -1525,7 +1502,7 @@ merge_direct (infiles, nfiles, outfile)\n   if (nfiles == 0)\n     {\n       if (outfile)\n-\tfclose (ostream);\n+        fclose (ostream);\n       return 0;\n     }\n \n@@ -1567,7 +1544,7 @@ merge_direct (infiles, nfiles, outfile)\n       file_lossage[i] = 0;\n       streams[i] = fopen (infiles[i], \"r\");\n       if (!streams[i])\n-\tpfatal_with_name (infiles[i]);\n+        pfatal_with_name (infiles[i]);\n \n       readline (thisline[i], streams[i]);\n     }\n@@ -1585,48 +1562,48 @@ merge_direct (infiles, nfiles, outfile)\n       /* Look at the next avail line of each file; choose the least one.  */\n \n       for (i = 0; i < nfiles; i++)\n-\t{\n-\t  if (thisline[i] &&\n-\t      (!best ||\n-\t       0 < compare_general (best->buffer, thisline[i]->buffer,\n-\t\t\t\t (long) bestfile, (long) i, num_keyfields)))\n-\t    {\n-\t      best = thisline[i];\n-\t      bestfile = i;\n-\t    }\n-\t}\n+        {\n+          if (thisline[i] &&\n+              (!best ||\n+               0 < compare_general (best->buffer, thisline[i]->buffer,\n+                                 (long) bestfile, (long) i, num_keyfields)))\n+            {\n+              best = thisline[i];\n+              bestfile = i;\n+            }\n+        }\n \n       /* Output that line, unless it matches the previous one and we\n-\t don't want duplicates. */\n+         don't want duplicates. */\n \n       if (!(prev_out &&\n-\t    !compare_general (prev_out->buffer,\n-\t\t\t      best->buffer, 0L, 1L, num_keyfields - 1)))\n-\tindexify (best->buffer, ostream);\n+            !compare_general (prev_out->buffer,\n+                              best->buffer, 0L, 1L, num_keyfields - 1)))\n+        indexify (best->buffer, ostream);\n       prev_out = best;\n \n       /* Now make the line the previous of its file, and fetch a new\n-\t line from that file.  */\n+         line from that file.  */\n \n       exch = prevline[bestfile];\n       prevline[bestfile] = thisline[bestfile];\n       thisline[bestfile] = exch;\n \n       while (1)\n-\t{\n-\t  /* If the file has no more, mark it empty. */\n-\n-\t  if (feof (streams[bestfile]))\n-\t    {\n-\t      thisline[bestfile] = 0;\n-\t      /* Update the number of files still not empty. */\n-\t      nleft--;\n-\t      break;\n-\t    }\n-\t  readline (thisline[bestfile], streams[bestfile]);\n-\t  if (thisline[bestfile]->buffer[0] || !feof (streams[bestfile]))\n-\t    break;\n-\t}\n+        {\n+          /* If the file has no more, mark it empty. */\n+\n+          if (feof (streams[bestfile]))\n+            {\n+              thisline[bestfile] = 0;\n+              /* Update the number of files still not empty. */\n+              nleft--;\n+              break;\n+            }\n+          readline (thisline[bestfile], streams[bestfile]);\n+          if (thisline[bestfile]->buffer[0] || !feof (streams[bestfile]))\n+            break;\n+        }\n     }\n \n   finish_index (ostream);\n@@ -1692,7 +1669,7 @@ pfatal_with_name (name)\n \n   s = strerror (errno);\n   printf (\"%s: \", program_name);\n-  printf (\"%s; for file `%s'.\\n\", s, name);\n+  printf (_(\"%s; for file `%s'.\\n\"), s, name);\n   exit (TI_FATAL_ERROR);\n }\n \n@@ -1745,6 +1722,21 @@ strrchr (string, character)\n }\n #endif /* HAVE_STRCHR */\n \n+void\n+memory_error (callers_name, bytes_wanted)\n+     char *callers_name;\n+     int bytes_wanted;\n+{\n+  char printable_string[80];\n+\n+  sprintf (printable_string,\n+           _(\"Virtual memory exhausted in %s ()!  Needed %d bytes.\"),\n+           callers_name, bytes_wanted);\n+\n+  error (printable_string);\n+  abort ();\n+}\n+\n /* Just like malloc, but kills the program in case of fatal error. */\n void *\n xmalloc (nbytes)\n@@ -1776,18 +1768,3 @@ xrealloc (pointer, nbytes)\n \n   return (temp);\n }\n-\n-memory_error (callers_name, bytes_wanted)\n-     char *callers_name;\n-     int bytes_wanted;\n-{\n-  char printable_string[80];\n-\n-  sprintf (printable_string,\n-\t   \"Virtual memory exhausted in %s ()!  Needed %d bytes.\",\n-\t   callers_name, bytes_wanted);\n-\n-  error (printable_string);\n-  abort ();\n-}\n-"}]}