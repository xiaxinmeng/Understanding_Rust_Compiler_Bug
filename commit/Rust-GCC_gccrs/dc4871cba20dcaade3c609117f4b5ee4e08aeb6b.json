{"sha": "dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM0ODcxY2JhMjBkY2FhZGUzYzYwOTExN2Y0YjVlZTRlMDhhZWI2Yg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-11-25T10:35:52Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-11-25T10:35:52Z"}, "message": "[multiple changes]\n\n2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/29385 (partial)\n\t* include/bits/stl_tree.h (_Rb_tree<>::destroy_node): Uglify.\n\t(_M_erase, erase(iterator), erase(const_iterator)): Adjust\n\n2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/29385 (partial)\n\t* include/bits/stl_tree.h (_Rb_tree<>::_M_lower_bound(_Const_Link_type,\n\t_Const_Link_type, const _Key&), _M_upper_bound(_Const_Link_type,\n\t_Const_Link_type, const _Key&)): Add.\n\t(lower_bound(const key_type&), upper_bound(const key_type&),\n\tfind(const key_type&)): Call the latter.\n\n2006-11-25  Gawain Bolton  <gp.bolton@computer.org>\n\n\tPR libstdc++/29385 (partial)\n\t* include/bits/stl_tree.h (_Rb_tree_rotate_left,\n\t_Rb_tree_rotate_right): Do not declare.\n\t(_Rb_tree<>::_M_insert(_Base_ptr, _Base_ptr, const value_type&),\n\t_M_insert(_Const_Base_ptr, _Const_Base_ptr, const value_type&),\n\t_M_insert_unique(iterator, const value_type&),\n\t_M_insert_unique(const_iterator, const value_type&),\n\t_M_insert_equal(iterator, const value_type&),\n\t_M_insert_equal(const_iterator, const value_type&)):\n\tRemove.\n\t(_Rb_tree<>::_M_insert_(_Const_Base_ptr, _Const_Base_ptr,\n\tconst value_type&), _M_insert_unique_(const_iterator,\n\tconst value_type&), _M_insert_equal_(const_iterator,\n\tconst value_type&)): Add, adjust all callers.\n\t* include/bits/stl_map.h (map<>::insert(iterator, const value_type&)):\n\tAdjust.\n\t* include/bits/stl_set.h (set<>::insert(iterator, const value_type&)):\n\tLikewise.\n\t* include/bits/stl_multimap.h (multimap<>::insert(iterator,\n\tconst value_type&)): Likewise.\n\t* include/bits/stl_multiset.h (multiset<>::insert(iterator,\n\tconst value_type&)): Likewise.\n\nFrom-SVN: r119190", "tree": {"sha": "864aa4fa02044acc5cd9e76136495625583a08f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/864aa4fa02044acc5cd9e76136495625583a08f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/comments", "author": null, "committer": null, "parents": [{"sha": "d73be2683d8be63e92ade52ba9613e3c7382c809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73be2683d8be63e92ade52ba9613e3c7382c809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d73be2683d8be63e92ade52ba9613e3c7382c809"}], "stats": {"total": 552, "additions": 199, "deletions": 353}, "files": [{"sha": "2566535a112c8bc02105a7ef31cff2150e158fbb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "patch": "@@ -1,3 +1,43 @@\n+2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/29385 (partial)\n+\t* include/bits/stl_tree.h (_Rb_tree<>::destroy_node): Uglify.\n+\t(_M_erase, erase(iterator), erase(const_iterator)): Adjust\n+\n+2006-11-25  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/29385 (partial)\n+\t* include/bits/stl_tree.h (_Rb_tree<>::_M_lower_bound(_Const_Link_type,\n+\t_Const_Link_type, const _Key&), _M_upper_bound(_Const_Link_type,\n+\t_Const_Link_type, const _Key&)): Add.\n+\t(lower_bound(const key_type&), upper_bound(const key_type&),\n+\tfind(const key_type&)): Call the latter.\n+\n+2006-11-25  Gawain Bolton  <gp.bolton@computer.org>\n+\n+\tPR libstdc++/29385 (partial)\n+\t* include/bits/stl_tree.h (_Rb_tree_rotate_left,\n+\t_Rb_tree_rotate_right): Do not declare.\n+\t(_Rb_tree<>::_M_insert(_Base_ptr, _Base_ptr, const value_type&),\n+\t_M_insert(_Const_Base_ptr, _Const_Base_ptr, const value_type&),\n+\t_M_insert_unique(iterator, const value_type&),\n+\t_M_insert_unique(const_iterator, const value_type&),\n+\t_M_insert_equal(iterator, const value_type&),\n+\t_M_insert_equal(const_iterator, const value_type&)):\n+\tRemove.\n+\t(_Rb_tree<>::_M_insert_(_Const_Base_ptr, _Const_Base_ptr,\n+\tconst value_type&), _M_insert_unique_(const_iterator,\n+\tconst value_type&), _M_insert_equal_(const_iterator,\n+\tconst value_type&)): Add, adjust all callers.\n+\t* include/bits/stl_map.h (map<>::insert(iterator, const value_type&)):\n+\tAdjust.\n+\t* include/bits/stl_set.h (set<>::insert(iterator, const value_type&)):\n+\tLikewise.\n+\t* include/bits/stl_multimap.h (multimap<>::insert(iterator,\n+\tconst value_type&)): Likewise.\n+\t* include/bits/stl_multiset.h (multiset<>::insert(iterator,\n+\tconst value_type&)): Likewise.\n+\n 2006-11-22  Antony King <anthony.king@st.com>\n             J\"orn Rennecke <joern.rennecke@st.com>\n "}, {"sha": "d04b3767a6981cc41997c2f14959670425d25ec5", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "patch": "@@ -423,7 +423,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        */\n       iterator\n       insert(iterator position, const value_type& __x)\n-      { return _M_t._M_insert_unique(position, __x); }\n+      { return _M_t._M_insert_unique_(position, __x); }\n \n       /**\n        *  @brief Template function that attemps to insert a range of elements."}, {"sha": "554035a6a2053d56bbcaf2417bf19cc61a6ef6f9", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "patch": "@@ -361,7 +361,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        */\n       iterator\n       insert(iterator __position, const value_type& __x)\n-      { return _M_t._M_insert_equal(__position, __x); }\n+      { return _M_t._M_insert_equal_(__position, __x); }\n \n       /**\n        *  @brief A template function that attemps to insert a range of elements."}, {"sha": "3979cd6d7db67e8896ba34395f6908ce0191663d", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "patch": "@@ -316,7 +316,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        */\n       iterator\n       insert(iterator __position, const value_type& __x)\n-      { return _M_t._M_insert_equal(__position, __x); }\n+      { return _M_t._M_insert_equal_(__position, __x); }\n \n       /**\n        *  @brief A template function that attemps to insert a range of elements."}, {"sha": "6ee85263b01fda6925273f6ca9b833d8abd355b4", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "patch": "@@ -329,7 +329,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        */\n       iterator\n       insert(iterator __position, const value_type& __x)\n-      { return _M_t._M_insert_unique(__position, __x); }\n+      { return _M_t._M_insert_unique_(__position, __x); }\n \n       /**\n        *  @brief A template function that attemps to insert a range of elements."}, {"sha": "c4dba4f488bda7d9ccf5c1038cf33abe7e5f6bb9", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 155, "deletions": 349, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc4871cba20dcaade3c609117f4b5ee4e08aeb6b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=dc4871cba20dcaade3c609117f4b5ee4e08aeb6b", "patch": "@@ -305,14 +305,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n                const _Rb_tree_const_iterator<_Val>& __y)\n     { return __x._M_node != __y._M_node; }\n \n-  void\n-  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,\n-                       _Rb_tree_node_base*& __root);\n-\n-  void\n-  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,\n-                        _Rb_tree_node_base*& __root);\n-\n   void\n   _Rb_tree_insert_and_rebalance(const bool __insert_left,\n                                 _Rb_tree_node_base* __x,\n@@ -395,7 +387,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       }\n \n       void\n-      destroy_node(_Link_type __p)\n+      _M_destroy_node(_Link_type __p)\n       {\n \tget_allocator().destroy(&__p->_M_value_field);\n \t_M_put_node(__p);\n@@ -546,23 +538,31 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     private:\n       iterator\n-      _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n+      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,\n+\t\t const value_type& __v);\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 233. Insertion hints in associative containers.\n       iterator\n       _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n \n-      const_iterator\n-      _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __y,\n-\t\tconst value_type& __v);\n+      iterator\n+      _M_insert_equal_lower(const value_type& __x);\n \n       _Link_type\n       _M_copy(_Const_Link_type __x, _Link_type __p);\n \n       void\n       _M_erase(_Link_type __x);\n \n+      iterator\n+      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,\n+\t\t     const _Key& __k) const;\n+\n+      iterator\n+      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,\n+\t\t     const _Key& __k) const;\n+\n     public:\n       // allocation/deallocation\n       _Rb_tree()\n@@ -662,22 +662,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       iterator\n       _M_insert_equal(const value_type& __x);\n \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 233. Insertion hints in associative containers.\n-      iterator\n-      _M_insert_equal_lower(const value_type& __x);\n-\n       iterator\n-      _M_insert_unique(iterator __position, const value_type& __x);\n-\n-      const_iterator\n-      _M_insert_unique(const_iterator __position, const value_type& __x);\n+      _M_insert_unique_(const_iterator __position, const value_type& __x);\n \n       iterator\n-      _M_insert_equal(iterator __position, const value_type& __x);\n-\n-      const_iterator\n-      _M_insert_equal(const_iterator __position, const value_type& __x);\n+      _M_insert_equal_(const_iterator __position, const value_type& __x);\n \n       template<typename _InputIterator>\n         void\n@@ -717,31 +706,35 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       // Set operations.\n       iterator\n-      find(const key_type& __x);\n+      find(const key_type& __k);\n \n       const_iterator\n-      find(const key_type& __x) const;\n+      find(const key_type& __k) const;\n \n       size_type\n-      count(const key_type& __x) const;\n+      count(const key_type& __k) const;\n \n       iterator\n-      lower_bound(const key_type& __x);\n+      lower_bound(const key_type& __k)\n+      { return iterator(_M_lower_bound(_M_begin(), _M_end(), __k)); }\n \n       const_iterator\n-      lower_bound(const key_type& __x) const;\n+      lower_bound(const key_type& __k) const\n+      { return const_iterator(_M_lower_bound(_M_begin(), _M_end(), __k)); }\n \n       iterator\n-      upper_bound(const key_type& __x);\n+      upper_bound(const key_type& __k)\n+      { return iterator(_M_upper_bound(_M_begin(), _M_end(), __k)); }\n \n       const_iterator\n-      upper_bound(const key_type& __x) const;\n+      upper_bound(const key_type& __k) const\n+      { return const_iterator(_M_upper_bound(_M_begin(), _M_end(), __k)); }\n \n-      pair<iterator,iterator>\n-      equal_range(const key_type& __x);\n+      pair<iterator, iterator>\n+      equal_range(const key_type& __k);\n \n       pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __x) const;\n+      equal_range(const key_type& __k) const;\n \n       // Debugging.\n       bool\n@@ -829,15 +822,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n+    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)\n     {\n       bool __insert_left = (__x != 0 || __p == _M_end()\n \t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v), \n \t\t\t\t\t\t      _S_key(__p)));\n \n       _Link_type __z = _M_create_node(__v);\n \n-      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  \n+      _Rb_tree_insert_and_rebalance(__insert_left, __z,\n+\t\t\t\t    const_cast<_Base_ptr>(__p),  \n \t\t\t\t    this->_M_impl._M_header);\n       ++_M_impl._M_node_count;\n       return iterator(__z);\n@@ -863,55 +857,101 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)\n+    _M_insert_equal_lower(const _Val& __v)\n     {\n-      bool __insert_left = (__x != 0 || __p == _M_end()\n-\t\t\t    || _M_impl._M_key_compare(_KeyOfValue()(__v), \n-\t\t\t\t\t\t      _S_key(__p)));\n+      _Link_type __x = _M_begin();\n+      _Link_type __y = _M_end();\n+      while (__x != 0)\n+\t{\n+\t  __y = __x;\n+\t  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?\n+\t        _S_left(__x) : _S_right(__x);\n+\t}\n+      return _M_insert_lower(__x, __y, __v);\n+    }\n \n-      _Link_type __z = _M_create_node(__v);\n+  template<typename _Key, typename _Val, typename _KoV,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n+    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n+    _M_copy(_Const_Link_type __x, _Link_type __p)\n+    {\n+      // Structural copy.  __x and __p must be non-null.\n+      _Link_type __top = _M_clone_node(__x);\n+      __top->_M_parent = __p;\n \n-      _Rb_tree_insert_and_rebalance(__insert_left, __z,\n-\t\t\t\t    const_cast<_Base_ptr>(__p),  \n-\t\t\t\t    this->_M_impl._M_header);\n-      ++_M_impl._M_node_count;\n-      return const_iterator(__z);\n+      try\n+\t{\n+\t  if (__x->_M_right)\n+\t    __top->_M_right = _M_copy(_S_right(__x), __top);\n+\t  __p = __top;\n+\t  __x = _S_left(__x);\n+\n+\t  while (__x != 0)\n+\t    {\n+\t      _Link_type __y = _M_clone_node(__x);\n+\t      __p->_M_left = __y;\n+\t      __y->_M_parent = __p;\n+\t      if (__x->_M_right)\n+\t\t__y->_M_right = _M_copy(_S_right(__x), __y);\n+\t      __p = __y;\n+\t      __x = _S_left(__x);\n+\t    }\n+\t}\n+      catch(...)\n+\t{\n+\t  _M_erase(__top);\n+\t  __throw_exception_again;\n+\t}\n+      return __top;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    void\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert_equal(const _Val& __v)\n+    _M_erase(_Link_type __x)\n     {\n-      _Link_type __x = _M_begin();\n-      _Link_type __y = _M_end();\n+      // Erase without rebalancing.\n       while (__x != 0)\n \t{\n-\t  __y = __x;\n-\t  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n-\t        _S_left(__x) : _S_right(__x);\n+\t  _M_erase(_S_right(__x));\n+\t  _Link_type __y = _S_left(__x);\n+\t  _M_destroy_node(__x);\n+\t  __x = __y;\n \t}\n-      return _M_insert(__x, __y, __v);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert_equal_lower(const _Val& __v)\n+    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,\n+\t\t   const _Key& __k) const\n     {\n-      _Link_type __x = _M_begin();\n-      _Link_type __y = _M_end();\n       while (__x != 0)\n-\t{\n-\t  __y = __x;\n-\t  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?\n-\t        _S_left(__x) : _S_right(__x);\n-\t}\n-      return _M_insert_lower(__x, __y, __v);\n+\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      return iterator(const_cast<_Link_type>(__y));\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,\n+\t\t   const _Key& __k) const\n+    {\n+      while (__x != 0)\n+\tif (_M_impl._M_key_compare(__k, _S_key(__x)))\n+\t  __y = __x, __x = _S_left(__x);\n+\telse\n+\t  __x = _S_right(__x);\n+      return iterator(const_cast<_Link_type>(__y));\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -983,233 +1023,141 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       iterator __j = iterator(__y);\n       if (__comp)\n \tif (__j == begin())\n-\t  return pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n+\t  return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);\n \telse\n \t  --__j;\n       if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n-\treturn pair<iterator, bool>(_M_insert(__x, __y, __v), true);\n+\treturn pair<iterator, bool>(_M_insert_(__x, __y, __v), true);\n       return pair<iterator, bool>(__j, false);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert_unique(iterator __position, const _Val& __v)\n+    _M_insert_equal(const _Val& __v)\n     {\n-      // end()\n-      if (__position._M_node == _M_end())\n-\t{\n-\t  if (size() > 0\n-\t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n-\t\t\t\t\t_KeyOfValue()(__v)))\n-\t    return _M_insert(0, _M_rightmost(), __v);\n-\t  else\n-\t    return _M_insert_unique(__v).first;\n-\t}\n-      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t      _S_key(__position._M_node)))\n-\t{\n-\t  // First, try before...\n-\t  iterator __before = __position;\n-\t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n-\t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), \n-\t\t\t\t\t  _KeyOfValue()(__v)))\n-\t    {\n-\t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v);\n-\t      else\n-\t\treturn _M_insert(__position._M_node,\n-\t\t\t\t __position._M_node, __v);\n-\t    }\n-\t  else\n-\t    return _M_insert_unique(__v).first;\n-\t}\n-      else if (_M_impl._M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t      _KeyOfValue()(__v)))\n+      _Link_type __x = _M_begin();\n+      _Link_type __y = _M_end();\n+      while (__x != 0)\n \t{\n-\t  // ... then try after.\n-\t  iterator __after = __position;\n-\t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert(0, _M_rightmost(), __v);\n-\t  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t  _S_key((++__after)._M_node)))\n-\t    {\n-\t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert(0, __position._M_node, __v);\n-\t      else\n-\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n-\t    }\n-\t  else\n-\t    return _M_insert_unique(__v).first;\n+\t  __y = __x;\n+\t  __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?\n+\t        _S_left(__x) : _S_right(__x);\n \t}\n-      else\n-\treturn __position; // Equivalent keys.\n+      return _M_insert_(__x, __y, __v);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert_unique(const_iterator __position, const _Val& __v)\n+    _M_insert_unique_(const_iterator __position, const _Val& __v)\n     {\n       // end()\n       if (__position._M_node == _M_end())\n \t{\n \t  if (size() > 0\n \t      && _M_impl._M_key_compare(_S_key(_M_rightmost()), \n \t\t\t\t\t_KeyOfValue()(__v)))\n-\t    return _M_insert(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(), __v);\n \t  else\n-\t    return const_iterator(_M_insert_unique(__v).first);\n+\t    return _M_insert_unique(__v).first;\n \t}\n       else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t      _S_key(__position._M_node)))\n \t{\n \t  // First, try before...\n \t  const_iterator __before = __position;\n \t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n+\t    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);\n \t  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), \n \t\t\t\t\t  _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v);\n+\t\treturn _M_insert_(0, __before._M_node, __v);\n \t      else\n-\t\treturn _M_insert(__position._M_node,\n-\t\t\t\t __position._M_node, __v);\n+\t\treturn _M_insert_(__position._M_node,\n+\t\t\t\t  __position._M_node, __v);\n \t    }\n \t  else\n-\t    return const_iterator(_M_insert_unique(__v).first);\n+\t    return _M_insert_unique(__v).first;\n \t}\n       else if (_M_impl._M_key_compare(_S_key(__position._M_node),\n \t\t\t\t      _KeyOfValue()(__v)))\n \t{\n \t  // ... then try after.\n \t  const_iterator __after = __position;\n \t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(), __v);\n \t  else if (_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t  _S_key((++__after)._M_node)))\n \t    {\n \t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert(0, __position._M_node, __v);\n+\t\treturn _M_insert_(0, __position._M_node, __v);\n \t      else\n-\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n+\t\treturn _M_insert_(__after._M_node, __after._M_node, __v);\n \t    }\n \t  else\n-\t    return const_iterator(_M_insert_unique(__v).first);\n+\t    return _M_insert_unique(__v).first;\n \t}\n       else\n-\treturn __position; // Equivalent keys.\n+\t// Equivalent keys.\n+\treturn iterator(static_cast<_Link_type>\n+\t\t\t(const_cast<_Base_ptr>(__position._M_node)));\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert_equal(iterator __position, const _Val& __v)\n+    _M_insert_equal_(const_iterator __position, const _Val& __v)\n     {\n       // end()\n       if (__position._M_node == _M_end())\n \t{\n \t  if (size() > 0\n \t      && !_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t _S_key(_M_rightmost())))\n-\t    return _M_insert(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(), __v);\n \t  else\n \t    return _M_insert_equal(__v);\n \t}\n-      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),\n-\t\t\t\t       _KeyOfValue()(__v)))\n-\t{\n-\t  // First, try before...\n-\t  iterator __before = __position;\n-\t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n-\t  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t   _S_key((--__before)._M_node)))\n-\t    {\n-\t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v);\n-\t      else\n-\t\treturn _M_insert(__position._M_node,\n-\t\t\t\t __position._M_node, __v);\n-\t    }\n-\t  else\n-\t    return _M_insert_equal(__v);\n-\t}\n-      else\n-\t{\n-\t  // ... then try after.  \n-\t  iterator __after = __position;\n-\t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert(0, _M_rightmost(), __v);\n-\t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),\n-\t\t\t\t\t   _KeyOfValue()(__v)))\n-\t    {\n-\t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert(0, __position._M_node, __v);\n-\t      else\n-\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n-\t    }\n-\t  else\n-\t    return _M_insert_equal_lower(__v);\n-\t}\n-    }\n-\n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_insert_equal(const_iterator __position, const _Val& __v)\n-    {\n-      // end()\n-      if (__position._M_node == _M_end())\n-\t{\n-\t  if (size() > 0\n-\t      && !_M_impl._M_key_compare(_KeyOfValue()(__v),\n-\t\t\t\t\t _S_key(_M_rightmost())))\n-\t    return _M_insert(0, _M_rightmost(), __v);\n-\t  else\n-\t    return const_iterator(_M_insert_equal(__v));\n-\t}\n       else if (!_M_impl._M_key_compare(_S_key(__position._M_node),\n \t\t\t\t       _KeyOfValue()(__v)))\n \t{\n \t  // First, try before...\n \t  const_iterator __before = __position;\n \t  if (__position._M_node == _M_leftmost()) // begin()\n-\t    return _M_insert(_M_leftmost(), _M_leftmost(), __v);\n+\t    return _M_insert_(_M_leftmost(), _M_leftmost(), __v);\n \t  else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),\n \t\t\t\t\t   _S_key((--__before)._M_node)))\n \t    {\n \t      if (_S_right(__before._M_node) == 0)\n-\t\treturn _M_insert(0, __before._M_node, __v);\n+\t\treturn _M_insert_(0, __before._M_node, __v);\n \t      else\n-\t\treturn _M_insert(__position._M_node,\n-\t\t\t\t __position._M_node, __v);\n+\t\treturn _M_insert_(__position._M_node,\n+\t\t\t\t  __position._M_node, __v);\n \t    }\n \t  else\n-\t    return const_iterator(_M_insert_equal(__v));\n+\t    return _M_insert_equal(__v);\n \t}\n       else\n \t{\n \t  // ... then try after.  \n \t  const_iterator __after = __position;\n \t  if (__position._M_node == _M_rightmost())\n-\t    return _M_insert(0, _M_rightmost(), __v);\n+\t    return _M_insert_(0, _M_rightmost(), __v);\n \t  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),\n \t\t\t\t\t   _KeyOfValue()(__v)))\n \t    {\n \t      if (_S_right(__position._M_node) == 0)\n-\t\treturn _M_insert(0, __position._M_node, __v);\n+\t\treturn _M_insert_(0, __position._M_node, __v);\n \t      else\n-\t\treturn _M_insert(__after._M_node, __after._M_node, __v);\n+\t\treturn _M_insert_(__after._M_node, __after._M_node, __v);\n \t    }\n \t  else\n-\t    return const_iterator(_M_insert_equal_lower(__v));\n+\t    return _M_insert_equal_lower(__v);\n \t}\n     }\n \n@@ -1218,21 +1166,21 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     template<class _II>\n       void\n       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n-      _M_insert_equal(_II __first, _II __last)\n+      _M_insert_unique(_II __first, _II __last)\n       {\n \tfor (; __first != __last; ++__first)\n-\t  _M_insert_equal(end(), *__first);\n+\t  _M_insert_unique_(end(), *__first);\n       }\n \n   template<typename _Key, typename _Val, typename _KoV,\n            typename _Cmp, typename _Alloc>\n     template<class _II>\n       void\n       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n-      _M_insert_unique(_II __first, _II __last)\n+      _M_insert_equal(_II __first, _II __last)\n       {\n \tfor (; __first != __last; ++__first)\n-\t  _M_insert_unique(end(), *__first);\n+\t  _M_insert_equal_(end(), *__first);\n       }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1245,7 +1193,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n \t\t\t\t(__position._M_node,\n \t\t\t\t this->_M_impl._M_header));\n-      destroy_node(__y);\n+      _M_destroy_node(__y);\n       --_M_impl._M_node_count;\n     }\n \n@@ -1259,7 +1207,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n \t\t\t\t(const_cast<_Base_ptr>(__position._M_node),\n \t\t\t\t this->_M_impl._M_header));\n-      destroy_node(__y);\n+      _M_destroy_node(__y);\n       --_M_impl._M_node_count;\n     }\n \n@@ -1275,58 +1223,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __old_size - size();\n     }\n \n-  template<typename _Key, typename _Val, typename _KoV,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n-    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n-    _M_copy(_Const_Link_type __x, _Link_type __p)\n-    {\n-      // Structural copy.  __x and __p must be non-null.\n-      _Link_type __top = _M_clone_node(__x);\n-      __top->_M_parent = __p;\n-\n-      try\n-\t{\n-\t  if (__x->_M_right)\n-\t    __top->_M_right = _M_copy(_S_right(__x), __top);\n-\t  __p = __top;\n-\t  __x = _S_left(__x);\n-\n-\t  while (__x != 0)\n-\t    {\n-\t      _Link_type __y = _M_clone_node(__x);\n-\t      __p->_M_left = __y;\n-\t      __y->_M_parent = __p;\n-\t      if (__x->_M_right)\n-\t\t__y->_M_right = _M_copy(_S_right(__x), __y);\n-\t      __p = __y;\n-\t      __x = _S_left(__x);\n-\t    }\n-\t}\n-      catch(...)\n-\t{\n-\t  _M_erase(__top);\n-\t  __throw_exception_again;\n-\t}\n-      return __top;\n-    }\n-\n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    void\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_erase(_Link_type __x)\n-    {\n-      // Erase without rebalancing.\n-      while (__x != 0)\n-\t{\n-\t  _M_erase(_S_right(__x));\n-\t  _Link_type __y = _S_left(__x);\n-\t  destroy_node(__x);\n-\t  __x = __y;\n-\t}\n-    }\n-\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n@@ -1369,16 +1265,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     find(const _Key& __k)\n     {\n-      _Link_type __x = _M_begin(); // Current node.\n-      _Link_type __y = _M_end(); // Last node which is not less than __k.\n-\n-      while (__x != 0)\n-\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n-\t  __y = __x, __x = _S_left(__x);\n-\telse\n-\t  __x = _S_right(__x);\n-\n-      iterator __j = iterator(__y);\n+      iterator __j = iterator(_M_lower_bound(_M_begin(), _M_end(), __k));\n       return (__j == end()\n \t      || _M_impl._M_key_compare(__k,\n \t\t\t\t\t_S_key(__j._M_node))) ? end() : __j;\n@@ -1390,20 +1277,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     find(const _Key& __k) const\n     {\n-      _Const_Link_type __x = _M_begin(); // Current node.\n-      _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n-\n-     while (__x != 0)\n-       {\n-\t if (!_M_impl._M_key_compare(_S_key(__x), __k))\n-\t   __y = __x, __x = _S_left(__x);\n-\t else\n-\t   __x = _S_right(__x);\n-       }\n-     const_iterator __j = const_iterator(__y);\n-     return (__j == end()\n-\t     || _M_impl._M_key_compare(__k, \n-\t\t\t\t       _S_key(__j._M_node))) ? end() : __j;\n+      const_iterator __j = const_iterator(_M_lower_bound(_M_begin(),\n+\t\t\t\t\t\t\t _M_end(), __k));\n+      return (__j == end()\n+\t      || _M_impl._M_key_compare(__k, \n+\t\t\t\t\t_S_key(__j._M_node))) ? end() : __j;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -1417,78 +1295,6 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __n;\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    lower_bound(const _Key& __k)\n-    {\n-      _Link_type __x = _M_begin(); // Current node.\n-      _Link_type __y = _M_end(); // Last node which is not less than __k.\n-\n-      while (__x != 0)\n-\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n-\t  __y = __x, __x = _S_left(__x);\n-\telse\n-\t  __x = _S_right(__x);\n-\n-      return iterator(__y);\n-    }\n-\n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    lower_bound(const _Key& __k) const\n-    {\n-      _Const_Link_type __x = _M_begin(); // Current node.\n-      _Const_Link_type __y = _M_end(); // Last node which is not less than __k.\n-\n-      while (__x != 0)\n-\tif (!_M_impl._M_key_compare(_S_key(__x), __k))\n-\t  __y = __x, __x = _S_left(__x);\n-\telse\n-\t  __x = _S_right(__x);\n-\n-      return const_iterator(__y);\n-    }\n-\n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    upper_bound(const _Key& __k)\n-    {\n-      _Link_type __x = _M_begin(); // Current node.\n-      _Link_type __y = _M_end(); // Last node which is greater than __k.\n-\n-      while (__x != 0)\n-\tif (_M_impl._M_key_compare(__k, _S_key(__x)))\n-\t  __y = __x, __x = _S_left(__x);\n-\telse\n-\t  __x = _S_right(__x);\n-\n-      return iterator(__y);\n-    }\n-\n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    upper_bound(const _Key& __k) const\n-    {\n-      _Const_Link_type __x = _M_begin(); // Current node.\n-      _Const_Link_type __y = _M_end(); // Last node which is greater than __k.\n-\n-      while (__x != 0)\n-\tif (_M_impl._M_key_compare(__k, _S_key(__x)))\n-\t  __y = __x, __x = _S_left(__x);\n-\telse\n-\t  __x = _S_right(__x);\n-\n-      return const_iterator(__y);\n-    }\n-\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline"}]}