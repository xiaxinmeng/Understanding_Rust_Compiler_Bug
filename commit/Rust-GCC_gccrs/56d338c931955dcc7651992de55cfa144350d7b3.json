{"sha": "56d338c931955dcc7651992de55cfa144350d7b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZkMzM4YzkzMTk1NWRjYzc2NTE5OTJkZTU1Y2ZhMTQ0MzUwZDdiMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-13T23:10:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-13T23:10:34Z"}, "message": "re PR middle-end/59119 (Segfault in -fisolate-erroneous-paths pass)\n\n\t* PR middle-end/59119\n\t* gimple-ssa-isolate-paths.c (find_implicit_erroneous_behaviour): New\n\tfunction, extracted from gimple_ssa_isolate_erroneous_paths.\n\t(find_explicit_erroneous_behaviour): Similarly.\n\t(insert_trap_and_remove_trailing_statements): Remove statements\n\tin reverse order.\n\n\t* PR middle-end/59119\n\t* gcc.c-torture/compile/pr59119.c: New test.\n\nFrom-SVN: r204760", "tree": {"sha": "1d5b5f09d8d85eaa8827dc53778717ed6277c309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5b5f09d8d85eaa8827dc53778717ed6277c309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56d338c931955dcc7651992de55cfa144350d7b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d338c931955dcc7651992de55cfa144350d7b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56d338c931955dcc7651992de55cfa144350d7b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56d338c931955dcc7651992de55cfa144350d7b3/comments", "author": null, "committer": null, "parents": [{"sha": "98eaa66fa50a5ea0110f78f7f15cbdfc1905ffd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98eaa66fa50a5ea0110f78f7f15cbdfc1905ffd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98eaa66fa50a5ea0110f78f7f15cbdfc1905ffd9"}], "stats": {"total": 153, "additions": 118, "deletions": 35}, "files": [{"sha": "ecc7aed56d4193edbf95c66694cdaeed8bfcc3f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56d338c931955dcc7651992de55cfa144350d7b3", "patch": "@@ -1,3 +1,12 @@\n+2013-11-13  Jeff Law  <law@redhat.com>\n+\n+\t* PR middle-end/59119\n+\t* gimple-ssa-isolate-paths.c (find_implicit_erroneous_behaviour): New\n+\tfunction, extracted from gimple_ssa_isolate_erroneous_paths.\n+\t(find_explicit_erroneous_behaviour): Similarly.\n+\t(insert_trap_and_remove_trailing_statements): Remove statements\n+\tin reverse order.\n+\n 2013-11-13  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cfgrtl.c (can_fallthru): Reorder code to move tablejump check up."}, {"sha": "0051da2126f51746dd859893e63673a3ea4b0299", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 81, "deletions": 35, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=56d338c931955dcc7651992de55cfa144350d7b3", "patch": "@@ -100,14 +100,16 @@ insert_trap_and_remove_trailing_statements (gimple_stmt_iterator *si_p, tree op)\n   else\n     gsi_insert_before (si_p, seq, GSI_NEW_STMT);\n \n-  /* The iterator points to the __builtin_trap.  Advance the iterator\n-     and delete everything else in the block.  */\n-  gsi_next (si_p);\n-  for (; !gsi_end_p (*si_p);)\n+  /* We must remove statements from the end of the block so that we\n+     never reference a released SSA_NAME.  */\n+  basic_block bb = gimple_bb (gsi_stmt (*si_p));\n+  for (gimple_stmt_iterator si = gsi_last_bb (bb);\n+       gsi_stmt (si) != gsi_stmt (*si_p);\n+       si = gsi_last_bb (bb))\n     {\n-      stmt = gsi_stmt (*si_p);\n+      stmt = gsi_stmt (si);\n       unlink_stmt_vdef (stmt);\n-      gsi_remove (si_p, true);\n+      gsi_remove (&si, true);\n       release_defs (stmt);\n     }\n }\n@@ -192,40 +194,19 @@ isolate_path (basic_block bb, basic_block duplicate,\n   return duplicate;\n }\n \n-/* Search the function for statements which, if executed, would cause\n-   the program to fault such as a dereference of a NULL pointer.\n-\n-   Such a program can't be valid if such a statement was to execute\n-   according to ISO standards.\n-\n-   We detect explicit NULL pointer dereferences as well as those implied\n-   by a PHI argument having a NULL value which unconditionally flows into\n-   a dereference in the same block as the PHI.\n-\n-   In the former case we replace the offending statement with an\n-   unconditional trap and eliminate the outgoing edges from the statement's\n-   basic block.  This may expose secondary optimization opportunities.\n-\n-   In the latter case, we isolate the path(s) with the NULL PHI \n-   feeding the dereference.  We can then replace the offending statement\n-   and eliminate the outgoing edges in the duplicate.  Again, this may\n-   expose secondary optimization opportunities.\n+/* Look for PHI nodes which feed statements in the same block where\n+   the value of the PHI node implies the statement is erroneous.\n \n-   A warning for both cases may be advisable as well.\n+   For example, a NULL PHI arg value which then feeds a pointer\n+   dereference.\n \n-   Other statically detectable violations of the ISO standard could be\n-   handled in a similar way, such as out-of-bounds array indexing.  */\n-\n-static unsigned int\n-gimple_ssa_isolate_erroneous_paths (void)\n+   When found isolate and optimize the path associated with the PHI\n+   argument feeding the erroneous statement.  */\n+static void\n+find_implicit_erroneous_behaviour (void)\n {\n   basic_block bb;\n \n-  initialize_original_copy_tables ();\n-\n-  /* Search all the blocks for edges which, if traversed, will\n-     result in undefined behaviour.  */\n-  cfg_altered = false;\n   FOR_EACH_BB (bb)\n     {\n       gimple_stmt_iterator si;\n@@ -288,6 +269,21 @@ gimple_ssa_isolate_erroneous_paths (void)\n \t\t}\n \t    }\n \t}\n+    }\n+}\n+\n+/* Look for statements which exhibit erroneous behaviour.  For example\n+   a NULL pointer dereference. \n+\n+   When found, optimize the block containing the erroneous behaviour.  */\n+static void\n+find_explicit_erroneous_behaviour (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator si;\n \n       /* Now look at the statements in the block and see if any of\n \t them explicitly dereference a NULL pointer.  This happens\n@@ -318,6 +314,56 @@ gimple_ssa_isolate_erroneous_paths (void)\n \t    }\n \t}\n     }\n+}\n+/* Search the function for statements which, if executed, would cause\n+   the program to fault such as a dereference of a NULL pointer.\n+\n+   Such a program can't be valid if such a statement was to execute\n+   according to ISO standards.\n+\n+   We detect explicit NULL pointer dereferences as well as those implied\n+   by a PHI argument having a NULL value which unconditionally flows into\n+   a dereference in the same block as the PHI.\n+\n+   In the former case we replace the offending statement with an\n+   unconditional trap and eliminate the outgoing edges from the statement's\n+   basic block.  This may expose secondary optimization opportunities.\n+\n+   In the latter case, we isolate the path(s) with the NULL PHI \n+   feeding the dereference.  We can then replace the offending statement\n+   and eliminate the outgoing edges in the duplicate.  Again, this may\n+   expose secondary optimization opportunities.\n+\n+   A warning for both cases may be advisable as well.\n+\n+   Other statically detectable violations of the ISO standard could be\n+   handled in a similar way, such as out-of-bounds array indexing.  */\n+\n+static unsigned int\n+gimple_ssa_isolate_erroneous_paths (void)\n+{\n+  initialize_original_copy_tables ();\n+\n+  /* Search all the blocks for edges which, if traversed, will\n+     result in undefined behaviour.  */\n+  cfg_altered = false;\n+\n+  /* First handle cases where traversal of a particular edge\n+     triggers undefined behaviour.  These cases require creating\n+     duplicate blocks and thus new SSA_NAMEs.\n+\n+     We want that process complete prior to the phase where we start\n+     removing edges from the CFG.  Edge removal may ultimately result in\n+     removal of PHI nodes and thus releasing SSA_NAMEs back to the\n+     name manager.\n+\n+     If the two processes run in parallel we could release an SSA_NAME\n+     back to the manager but we could still have dangling references\n+     to the released SSA_NAME in unreachable blocks.\n+     that any released names not have dangling references in the IL.  */\n+  find_implicit_erroneous_behaviour ();\n+  find_explicit_erroneous_behaviour ();\n+\n   free_original_copy_tables ();\n \n   /* We scramble the CFG and loop structures a bit, clean up "}, {"sha": "36f48fd17f9306aee9eb43796149c39ac64c5057", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56d338c931955dcc7651992de55cfa144350d7b3", "patch": "@@ -1,3 +1,8 @@\n+2013-11-12  Jeff Law  <law@redhat.com>\n+\n+\t* PR middle-end/59119\n+\t* gcc.c-torture/compile/pr59119.c: New test.\n+\n 2013-11-13  Martin Jambor  <mjambor@suse.cz>\n \n \t* gcc.dg/ira-shrinkwrap-prep-1.c: Add lp64 to target requirements."}, {"sha": "b026ba5d4ac88e7f41d04105fc66dd335cae1e97", "filename": "gcc/testsuite/gcc.c-torture/compile/pr59119.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr59119.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56d338c931955dcc7651992de55cfa144350d7b3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr59119.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr59119.c?ref=56d338c931955dcc7651992de55cfa144350d7b3", "patch": "@@ -0,0 +1,23 @@\n+extern void *memmove (void *, const void *, __SIZE_TYPE__);\n+extern void *memset (void *, int, __SIZE_TYPE__);\n+\n+typedef struct {\n+    long n_prefix;\n+    long n_spadding;\n+} NumberFieldWidths;\n+\n+void\n+fill_number(char *buf, const NumberFieldWidths *spec)\n+{\n+    if (spec->n_prefix) {\n+        memmove(buf,\n+                (char *) 0,\n+                spec->n_prefix * sizeof(char));\n+        buf += spec->n_prefix;\n+    }\n+    if (spec->n_spadding) {\n+        memset(buf, 0, spec->n_spadding);\n+        buf += spec->n_spadding;\n+    }\n+}\n+"}]}