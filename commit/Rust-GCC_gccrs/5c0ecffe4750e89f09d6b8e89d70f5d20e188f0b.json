{"sha": "5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMwZWNmZmU0NzUwZTg5ZjA5ZDZiOGU4OWQ3MGY1ZDIwZTE4OGYwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-21T12:53:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-21T12:53:31Z"}, "message": "global.c (allocno): New structure and static variable.\n\n\t* global.c (allocno): New structure and static variable.\n\t(allocno_reg): Remove, all references replaced by allocno.\n\t(allocno_size): Likewise.\n\t(hard_reg_conflicts): Likewise.\n\t(hard_reg_preferences): Likewise.\n\t(hard_reg_copy_preferences): Likewise.\n\t(hard_reg_full_preferences): Likewise.\n\t(regs_someone_prefers): Likewise.\n\t(allocno_calls_crossed): Likewise.\n\t(allocno_n_refs): Likewise.\n\t(allocno_live_length): Likewise.\n\t(find_reg): Rename ALLOCNO to NUM.\n\nFrom-SVN: r30602", "tree": {"sha": "a7e4c119815dc2d28a0db54b3eeda7922fa7bd31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7e4c119815dc2d28a0db54b3eeda7922fa7bd31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b/comments", "author": null, "committer": null, "parents": [{"sha": "ee59f29bd96fdf420a4c9888bf65ce20957989d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee59f29bd96fdf420a4c9888bf65ce20957989d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee59f29bd96fdf420a4c9888bf65ce20957989d3"}], "stats": {"total": 336, "additions": 155, "deletions": 181}, "files": [{"sha": "2c95f571e2cd5787e50e0ef090424372a16e2b15", "filename": "gcc/global.c", "status": "modified", "additions": 155, "deletions": 181, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=5c0ecffe4750e89f09d6b8e89d70f5d20e188f0b", "patch": "@@ -83,20 +83,58 @@ static int max_allocno;\n \n static int *reg_allocno;\n \n-/* Indexed by allocno, gives the reg number.  */\n+struct allocno\n+{\n+  int reg;\n+  /* Gives the number of consecutive hard registers needed by that\n+     pseudo reg.  */\n+  int size;\n+\n+  /* Number of calls crossed by each allocno.  */\n+  int calls_crossed;\n+\n+  /* Number of refs (weighted) to each allocno.  */\n+  int n_refs;\n+\n+  /* Guess at live length of each allocno.\n+     This is actually the max of the live lengths of the regs.  */\n+  int live_length;\n+\n+  /* Set of hard regs conflicting with allocno N.  */\n+\n+  HARD_REG_SET hard_reg_conflicts;\n+\n+  /* Set of hard regs preferred by allocno N.\n+     This is used to make allocnos go into regs that are copied to or from them,\n+     when possible, to reduce register shuffling.  */\n+\n+  HARD_REG_SET hard_reg_preferences;\n+\n+  /* Similar, but just counts register preferences made in simple copy\n+     operations, rather than arithmetic.  These are given priority because\n+     we can always eliminate an insn by using these, but using a register\n+     in the above list won't always eliminate an insn.  */\n \n-static int *allocno_reg;\n+  HARD_REG_SET hard_reg_copy_preferences;\n+\n+  /* Similar to hard_reg_preferences, but includes bits for subsequent\n+     registers when an allocno is multi-word.  The above variable is used for\n+     allocation while this is used to build reg_someone_prefers, below.  */\n+\n+  HARD_REG_SET hard_reg_full_preferences;\n+\n+  /* Set of hard registers that some later allocno has a preference for.  */\n+\n+  HARD_REG_SET regs_someone_prefers;\n+};\n+\n+static struct allocno *allocno;\n \n /* A vector of the integers from 0 to max_allocno-1,\n    sorted in the order of first-to-be-allocated first.  */\n \n static int *allocno_order;\n \n-/* Indexed by an allocno, gives the number of consecutive\n-   hard registers needed by that pseudo reg.  */\n-\n-static int *allocno_size;\n-\n /* Indexed by (pseudo) reg number, gives the number of another\n    lower-numbered pseudo reg which can share a hard reg with this pseudo\n    *even if the two pseudos would otherwise appear to conflict*.  */\n@@ -139,7 +177,7 @@ static int allocno_row_words;\n do {\t\t\t\t\t\t\t\t\t\\\n   int i_;\t\t\t\t\t\t\t\t\\\n   int allocno_;\t\t\t\t\t\t\t\t\\\n-  INT_TYPE *p_ = (ALLOCNO_SET);\t\t\\\n+  INT_TYPE *p_ = (ALLOCNO_SET);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   for (i_ = allocno_row_words - 1, allocno_ = 0; i_ >= 0;\t\t\\\n        i_--, allocno_ += INT_BITS)\t\t\t\t\t\\\n@@ -168,34 +206,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n static HARD_REG_SET hard_regs_live;\n \n-/* Indexed by N, set of hard regs conflicting with allocno N.  */\n-\n-static HARD_REG_SET *hard_reg_conflicts;\n-\n-/* Indexed by N, set of hard regs preferred by allocno N.\n-   This is used to make allocnos go into regs that are copied to or from them,\n-   when possible, to reduce register shuffling.  */\n-\n-static HARD_REG_SET *hard_reg_preferences;\n-\n-/* Similar, but just counts register preferences made in simple copy\n-   operations, rather than arithmetic.  These are given priority because\n-   we can always eliminate an insn by using these, but using a register\n-   in the above list won't always eliminate an insn.  */\n-\n-static HARD_REG_SET *hard_reg_copy_preferences;\n-\n-/* Similar to hard_reg_preferences, but includes bits for subsequent\n-   registers when an allocno is multi-word.  The above variable is used for\n-   allocation while this is used to build reg_someone_prefers, below.  */\n-\n-static HARD_REG_SET *hard_reg_full_preferences;\n-\n-/* Indexed by N, set of hard registers that some later allocno has a\n-   preference for.  */\n-\n-static HARD_REG_SET *regs_someone_prefers;\n-\n /* Set of registers that global-alloc isn't supposed to use.  */\n \n static HARD_REG_SET no_global_alloc_regs;\n@@ -204,19 +214,6 @@ static HARD_REG_SET no_global_alloc_regs;\n \n static HARD_REG_SET regs_used_so_far;\n \n-/* Number of calls crossed by each allocno.  */\n-\n-static int *allocno_calls_crossed;\n-\n-/* Number of refs (weighted) to each allocno.  */\n-\n-static int *allocno_n_refs;\n-\n-/* Guess at live length of each allocno.\n-   This is actually the max of the live lengths of the regs.  */\n-\n-static int *allocno_live_length;\n-\n /* Number of refs (weighted) to each hard reg, as used by local alloc.\n    It is zero for a reg that contains global pseudos or is explicitly used.  */\n \n@@ -230,11 +227,11 @@ static int local_reg_live_length[FIRST_PSEUDO_REGISTER];\n /* Test a bit in TABLE, a vector of HARD_REG_SETs,\n    for vector element I, and hard register number J.  */\n \n-#define REGBITP(TABLE, I, J)     TEST_HARD_REG_BIT (TABLE[I], J)\n+#define REGBITP(TABLE, I, J)     TEST_HARD_REG_BIT (allocno[I].TABLE, J)\n \n /* Set to 1 a bit in a vector of HARD_REG_SETs.  Works like REGBITP.  */\n \n-#define SET_REGBIT(TABLE, I, J)  SET_HARD_REG_BIT (TABLE[I], J)\n+#define SET_REGBIT(TABLE, I, J)  SET_HARD_REG_BIT (allocno[I].TABLE, J)\n \n /* Bit mask for allocnos live at current point in the scan.  */\n \n@@ -444,22 +441,18 @@ global_alloc (file)\n     else\n       reg_allocno[i] = -1;\n \n-  allocno_reg = (int *) xmalloc (max_allocno * sizeof (int));\n-  allocno_size = (int *) xcalloc (max_allocno, sizeof (int));\n-  allocno_calls_crossed = (int *) xcalloc (max_allocno, sizeof (int));\n-  allocno_n_refs = (int *) xcalloc (max_allocno, sizeof (int));\n-  allocno_live_length = (int *) xcalloc (max_allocno, sizeof (int));\n+  allocno = (struct allocno *) xcalloc (max_allocno, sizeof (struct allocno));\n \n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_allocno[i] >= 0)\n       {\n-\tint allocno = reg_allocno[i];\n-\tallocno_reg[allocno] = i;\n-\tallocno_size[allocno] = PSEUDO_REGNO_SIZE (i);\n-\tallocno_calls_crossed[allocno] += REG_N_CALLS_CROSSED (i);\n-\tallocno_n_refs[allocno] += REG_N_REFS (i);\n-\tif (allocno_live_length[allocno] < REG_LIVE_LENGTH (i))\n-\t  allocno_live_length[allocno] = REG_LIVE_LENGTH (i);\n+\tint num = reg_allocno[i];\n+\tallocno[num].reg = i;\n+\tallocno[num].size = PSEUDO_REGNO_SIZE (i);\n+\tallocno[num].calls_crossed += REG_N_CALLS_CROSSED (i);\n+\tallocno[num].n_refs += REG_N_REFS (i);\n+\tif (allocno[num].live_length < REG_LIVE_LENGTH (i))\n+\t  allocno[num].live_length = REG_LIVE_LENGTH (i);\n       }\n \n   /* Calculate amount of usage of each hard reg by pseudos\n@@ -486,20 +479,6 @@ global_alloc (file)\n     if (regs_ever_live[i])\n       local_reg_n_refs[i] = 0;\n \t\n-  /* Allocate the space for the conflict and preference tables and\n-     initialize them.  */\n-\n-  hard_reg_conflicts\n-    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n-  hard_reg_preferences\n-    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n-  hard_reg_copy_preferences\n-    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n-  hard_reg_full_preferences\n-    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n-  regs_someone_prefers\n-    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n-\n   allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n \n   /* We used to use alloca here, but the size of what it would try to\n@@ -531,10 +510,12 @@ global_alloc (file)\n \n       for (i = 0; i < (size_t) max_allocno; i++)\n \t{\n-\t  AND_COMPL_HARD_REG_SET (hard_reg_conflicts[i], eliminable_regset);\n-\t  AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[i],\n+\t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_conflicts,\n+\t\t\t\t  eliminable_regset);\n+\t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_copy_preferences,\n+\t\t\t\t  eliminable_regset);\n+\t  AND_COMPL_HARD_REG_SET (allocno[i].hard_reg_preferences,\n \t\t\t\t  eliminable_regset);\n-\t  AND_COMPL_HARD_REG_SET (hard_reg_preferences[i], eliminable_regset);\n \t}\n \n       /* Try to expand the preferences by merging them between allocnos.  */\n@@ -556,10 +537,10 @@ global_alloc (file)\n \n       for (i = 0; i < (size_t) max_allocno; i++)\n \t{\n-\t  if (allocno_size[i] == 0)\n-\t    allocno_size[i] = 1;\n-\t  if (allocno_live_length[i] == 0)\n-\t    allocno_live_length[i] = -1;\n+\t  if (allocno[i].size == 0)\n+\t    allocno[i].size = 1;\n+\t  if (allocno[i].live_length == 0)\n+\t    allocno[i].live_length = -1;\n \t}\n \n       qsort (allocno_order, max_allocno, sizeof (int), allocno_compare);\n@@ -573,19 +554,19 @@ global_alloc (file)\n \t except for parameters marked with reg_live_length[regno] == -2.  */\n \n       for (i = 0; i < (size_t) max_allocno; i++)\n-\tif (reg_renumber[allocno_reg[allocno_order[i]]] < 0\n-\t    && REG_LIVE_LENGTH (allocno_reg[allocno_order[i]]) >= 0)\n+\tif (reg_renumber[allocno[allocno_order[i]].reg] < 0\n+\t    && REG_LIVE_LENGTH (allocno[allocno_order[i]].reg) >= 0)\n \t  {\n \t    /* If we have more than one register class,\n \t       first try allocating in the class that is cheapest\n \t       for this pseudo-reg.  If that fails, try any reg.  */\n \t    if (N_REG_CLASSES > 1)\n \t      {\n \t\tfind_reg (allocno_order[i], 0, 0, 0, 0);\n-\t\tif (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n+\t\tif (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n \t\t  continue;\n \t      }\n-\t    if (reg_alternate_class (allocno_reg[allocno_order[i]]) != NO_REGS)\n+\t    if (reg_alternate_class (allocno[allocno_order[i]].reg) != NO_REGS)\n \t      find_reg (allocno_order[i], 0, 1, 0, 0);\n \t  }\n \n@@ -607,16 +588,7 @@ global_alloc (file)\n   /* Clean up.  */\n   free (reg_allocno);\n   free (reg_may_share);\n-  free (allocno_reg);\n-  free (allocno_size);\n-  free (allocno_calls_crossed);\n-  free (allocno_n_refs);\n-  free (allocno_live_length);\n-  free (hard_reg_conflicts);\n-  free (hard_reg_preferences);\n-  free (hard_reg_copy_preferences);\n-  free (hard_reg_full_preferences);\n-  free (regs_someone_prefers);\n+  free (allocno);\n   free (conflicts);\n   free (allocnos_live);\n \n@@ -637,13 +609,13 @@ allocno_compare (v1p, v2p)\n      times a register can occur in one insn (surely less than 100).\n      Multiplying this by 10000 can't overflow.  */\n   register int pri1\n-    = (((double) (floor_log2 (allocno_n_refs[v1]) * allocno_n_refs[v1])\n-\t/ allocno_live_length[v1])\n-       * 10000 * allocno_size[v1]);\n+    = (((double) (floor_log2 (allocno[v1].n_refs) * allocno[v1].n_refs)\n+\t/ allocno[v1].live_length)\n+       * 10000 * allocno[v1].size);\n   register int pri2\n-    = (((double) (floor_log2 (allocno_n_refs[v2]) * allocno_n_refs[v2])\n-\t/ allocno_live_length[v2])\n-       * 10000 * allocno_size[v2]);\n+    = (((double) (floor_log2 (allocno[v2].n_refs) * allocno[v2].n_refs)\n+\t/ allocno[v2].live_length)\n+       * 10000 * allocno[v2].size);\n   if (pri2 - pri1)\n     return pri2 - pri1;\n \n@@ -883,20 +855,20 @@ expand_preferences ()\n \n \t    if (XEXP (link, 0) == SET_SRC (set))\n \t      {\n-\t\tIOR_HARD_REG_SET (hard_reg_copy_preferences[a1],\n-\t\t\t\t  hard_reg_copy_preferences[a2]);\n-\t\tIOR_HARD_REG_SET (hard_reg_copy_preferences[a2],\n-\t\t\t\t  hard_reg_copy_preferences[a1]);\n+\t\tIOR_HARD_REG_SET (allocno[a1].hard_reg_copy_preferences,\n+\t\t\t\t  allocno[a2].hard_reg_copy_preferences);\n+\t\tIOR_HARD_REG_SET (allocno[a2].hard_reg_copy_preferences,\n+\t\t\t\t  allocno[a1].hard_reg_copy_preferences);\n \t      }\n \n-\t    IOR_HARD_REG_SET (hard_reg_preferences[a1],\n-\t\t\t      hard_reg_preferences[a2]);\n-\t    IOR_HARD_REG_SET (hard_reg_preferences[a2],\n-\t\t\t      hard_reg_preferences[a1]);\n-\t    IOR_HARD_REG_SET (hard_reg_full_preferences[a1],\n-\t\t\t      hard_reg_full_preferences[a2]);\n-\t    IOR_HARD_REG_SET (hard_reg_full_preferences[a2],\n-\t\t\t      hard_reg_full_preferences[a1]);\n+\t    IOR_HARD_REG_SET (allocno[a1].hard_reg_preferences,\n+\t\t\t      allocno[a2].hard_reg_preferences);\n+\t    IOR_HARD_REG_SET (allocno[a2].hard_reg_preferences,\n+\t\t\t      allocno[a1].hard_reg_preferences);\n+\t    IOR_HARD_REG_SET (allocno[a1].hard_reg_full_preferences,\n+\t\t\t      allocno[a2].hard_reg_full_preferences);\n+\t    IOR_HARD_REG_SET (allocno[a2].hard_reg_full_preferences,\n+\t\t\t      allocno[a1].hard_reg_full_preferences);\n \t  }\n }\n \f\n@@ -911,7 +883,7 @@ static void\n prune_preferences ()\n {\n   int i;\n-  int allocno;\n+  int num;\n   int *allocno_to_order = (int *) xmalloc (max_allocno * sizeof (int));\n   \n   /* Scan least most important to most important.\n@@ -923,22 +895,22 @@ prune_preferences ()\n     {\n       HARD_REG_SET temp;\n \n-      allocno = allocno_order[i];\n-      allocno_to_order[allocno] = i;\n-      COPY_HARD_REG_SET (temp, hard_reg_conflicts[allocno]);\n+      num = allocno_order[i];\n+      allocno_to_order[num] = i;\n+      COPY_HARD_REG_SET (temp, allocno[num].hard_reg_conflicts);\n \n-      if (allocno_calls_crossed[allocno] == 0)\n+      if (allocno[num].calls_crossed == 0)\n \tIOR_HARD_REG_SET (temp, fixed_reg_set);\n       else\n \tIOR_HARD_REG_SET (temp,\tcall_used_reg_set);\n \n       IOR_COMPL_HARD_REG_SET\n \t(temp,\n-\t reg_class_contents[(int) reg_preferred_class (allocno_reg[allocno])]);\n+\t reg_class_contents[(int) reg_preferred_class (allocno[num].reg)]);\n \n-      AND_COMPL_HARD_REG_SET (hard_reg_preferences[allocno], temp);\n-      AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[allocno], temp);\n-      AND_COMPL_HARD_REG_SET (hard_reg_full_preferences[allocno], temp);\n+      AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_preferences, temp);\n+      AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_copy_preferences, temp);\n+      AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_full_preferences, temp);\n     }\n \n   for (i = max_allocno - 1; i >= 0; i--)\n@@ -951,31 +923,33 @@ prune_preferences ()\n       HARD_REG_SET temp, temp2;\n       int allocno2;\n \n-      allocno = allocno_order[i];\n+      num = allocno_order[i];\n \n       CLEAR_HARD_REG_SET (temp);\n       CLEAR_HARD_REG_SET (temp2);\n \n-      EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + allocno * allocno_row_words,\n+      EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + num * allocno_row_words,\n \t\t\t\t     allocno2,\n \t{\n \t  if (allocno_to_order[allocno2] > i)\n \t    {\n-\t      if (allocno_size[allocno2] <= allocno_size[allocno])\n-\t\tIOR_HARD_REG_SET (temp, hard_reg_full_preferences[allocno2]);\n+\t      if (allocno[allocno2].size <= allocno[num].size)\n+\t\tIOR_HARD_REG_SET (temp,\n+\t\t\t\t  allocno[allocno2].hard_reg_full_preferences);\n \t      else\n-\t\tIOR_HARD_REG_SET (temp2, hard_reg_full_preferences[allocno2]);\n+\t\tIOR_HARD_REG_SET (temp2,\n+\t\t\t\t  allocno[allocno2].hard_reg_full_preferences);\n \t    }\n \t});\n \n-      AND_COMPL_HARD_REG_SET (temp, hard_reg_full_preferences[allocno]);\n+      AND_COMPL_HARD_REG_SET (temp, allocno[num].hard_reg_full_preferences);\n       IOR_HARD_REG_SET (temp, temp2);\n-      COPY_HARD_REG_SET (regs_someone_prefers[allocno], temp);\n+      COPY_HARD_REG_SET (allocno[num].regs_someone_prefers, temp);\n     }\n   free (allocno_to_order);\n }\n \f\n-/* Assign a hard register to ALLOCNO; look for one that is the beginning\n+/* Assign a hard register to allocno NUM; look for one that is the beginning\n    of a long enough stretch of hard regs none of which conflicts with ALLOCNO.\n    The registers marked in PREFREGS are tried first.\n \n@@ -994,8 +968,8 @@ prune_preferences ()\n    If not, do nothing.  */\n \n static void\n-find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n-     int allocno;\n+find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n+     int num;\n      HARD_REG_SET losers;\n      int alt_regs_p;\n      int accept_call_clobbered;\n@@ -1008,13 +982,13 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n     HARD_REG_SET used, used1, used2;\n \n   enum reg_class class = (alt_regs_p\n-\t\t\t  ? reg_alternate_class (allocno_reg[allocno])\n-\t\t\t  : reg_preferred_class (allocno_reg[allocno]));\n-  enum machine_mode mode = PSEUDO_REGNO_MODE (allocno_reg[allocno]);\n+\t\t\t  ? reg_alternate_class (allocno[num].reg)\n+\t\t\t  : reg_preferred_class (allocno[num].reg));\n+  enum machine_mode mode = PSEUDO_REGNO_MODE (allocno[num].reg);\n \n   if (accept_call_clobbered)\n     COPY_HARD_REG_SET (used1, call_fixed_reg_set);\n-  else if (allocno_calls_crossed[allocno] == 0)\n+  else if (allocno[num].calls_crossed == 0)\n     COPY_HARD_REG_SET (used1, fixed_reg_set);\n   else\n     COPY_HARD_REG_SET (used1, call_used_reg_set);\n@@ -1027,10 +1001,10 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n   IOR_COMPL_HARD_REG_SET (used1, reg_class_contents[(int) class]);\n   COPY_HARD_REG_SET (used2, used1);\n \n-  IOR_HARD_REG_SET (used1, hard_reg_conflicts[allocno]);\n+  IOR_HARD_REG_SET (used1, allocno[num].hard_reg_conflicts);\n \n #ifdef CLASS_CANNOT_CHANGE_SIZE\n-  if (REG_CHANGES_SIZE (allocno_reg[allocno]))\n+  if (REG_CHANGES_SIZE (allocno[num].reg))\n     IOR_HARD_REG_SET (used1,\n \t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE]);\n #endif\n@@ -1043,7 +1017,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \n   COPY_HARD_REG_SET (used, used1);\n   IOR_COMPL_HARD_REG_SET (used, regs_used_so_far);\n-  IOR_HARD_REG_SET (used, regs_someone_prefers[allocno]);\n+  IOR_HARD_REG_SET (used, allocno[num].regs_someone_prefers);\n   \n   best_reg = -1;\n   for (i = FIRST_PSEUDO_REGISTER, pass = 0;\n@@ -1061,7 +1035,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n #endif\n \t  if (! TEST_HARD_REG_BIT (used, regno)\n \t      && HARD_REGNO_MODE_OK (regno, mode)\n-\t      && (allocno_calls_crossed[allocno] == 0\n+\t      && (allocno[num].calls_crossed == 0\n \t\t  || accept_call_clobbered\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t    {\n@@ -1094,14 +1068,14 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n      First do this for those register with copy preferences, then all\n      preferred registers.  */\n \n-  AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[allocno], used);\n-  GO_IF_HARD_REG_SUBSET (hard_reg_copy_preferences[allocno],\n+  AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_copy_preferences, used);\n+  GO_IF_HARD_REG_SUBSET (allocno[num].hard_reg_copy_preferences,\n \t\t\t reg_class_contents[(int) NO_REGS], no_copy_prefs);\n \n   if (best_reg >= 0)\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (hard_reg_copy_preferences[allocno], i)\n+\tif (TEST_HARD_REG_BIT (allocno[num].hard_reg_copy_preferences, i)\n \t    && HARD_REGNO_MODE_OK (i, mode)\n \t    && (REGNO_REG_CLASS (i) == REGNO_REG_CLASS (best_reg)\n \t\t|| reg_class_subset_p (REGNO_REG_CLASS (i),\n@@ -1130,14 +1104,14 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n     }\n  no_copy_prefs:\n \n-  AND_COMPL_HARD_REG_SET (hard_reg_preferences[allocno], used);\n-  GO_IF_HARD_REG_SUBSET (hard_reg_preferences[allocno],\n+  AND_COMPL_HARD_REG_SET (allocno[num].hard_reg_preferences, used);\n+  GO_IF_HARD_REG_SUBSET (allocno[num].hard_reg_preferences,\n \t\t\t reg_class_contents[(int) NO_REGS], no_prefs);\n \n   if (best_reg >= 0)\n     {\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (TEST_HARD_REG_BIT (hard_reg_preferences[allocno], i)\n+\tif (TEST_HARD_REG_BIT (allocno[num].hard_reg_preferences, i)\n \t    && HARD_REGNO_MODE_OK (i, mode)\n \t    && (REGNO_REG_CLASS (i) == REGNO_REG_CLASS (best_reg)\n \t\t|| reg_class_subset_p (REGNO_REG_CLASS (i),\n@@ -1177,9 +1151,9 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t allocate a call-clobbered register and save and restore it\n \t around calls, do that.  */\n       if (! accept_call_clobbered\n-\t  && allocno_calls_crossed[allocno] != 0\n-\t  && CALLER_SAVE_PROFITABLE (allocno_n_refs[allocno],\n-\t\t\t\t     allocno_calls_crossed[allocno]))\n+\t  && allocno[num].calls_crossed != 0\n+\t  && CALLER_SAVE_PROFITABLE (allocno[num].n_refs,\n+\t\t\t\t     allocno[num].calls_crossed))\n \t{\n \t  HARD_REG_SET new_losers;\n \t  if (! losers)\n@@ -1188,8 +1162,8 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t    COPY_HARD_REG_SET (new_losers, losers);\n \t    \n \t  IOR_HARD_REG_SET(new_losers, losing_caller_save_reg_set);\n-\t  find_reg (allocno, new_losers, alt_regs_p, 1, retrying);\n-\t  if (reg_renumber[allocno_reg[allocno]] >= 0)\n+\t  find_reg (num, new_losers, alt_regs_p, 1, retrying);\n+\t  if (reg_renumber[allocno[num].reg] >= 0)\n \t    {\n \t      caller_save_needed = 1;\n \t      return;\n@@ -1204,7 +1178,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n      so we can use it instead.  */\n   if (best_reg < 0 && !retrying\n       /* Let's not bother with multi-reg allocnos.  */\n-      && allocno_size[allocno] == 1)\n+      && allocno[num].size == 1)\n     {\n       /* Count from the end, to find the least-used ones first.  */\n       for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n@@ -1220,7 +1194,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t      && ! TEST_HARD_REG_BIT (used2, regno)\n \t      && HARD_REGNO_MODE_OK (regno, mode)\n #ifdef CLASS_CANNOT_CHANGE_SIZE\n-\t      && ! (REG_CHANGES_SIZE (allocno_reg[allocno])\n+\t      && ! (REG_CHANGES_SIZE (allocno[num].reg)\n \t\t    && (TEST_HARD_REG_BIT\n \t\t\t(reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE],\n \t\t\t regno)))\n@@ -1233,8 +1207,8 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t \n \t      double tmp1 = ((double) local_reg_n_refs[regno]\n \t\t\t    / local_reg_live_length[regno]);\n-\t      double tmp2 = ((double) allocno_n_refs[allocno]\n-\t\t\t     / allocno_live_length[allocno]);\n+\t      double tmp2 = ((double) allocno[num].n_refs\n+\t\t\t     / allocno[num].live_length);\n \n \t      if (tmp1 < tmp2)\n \t\t{\n@@ -1267,11 +1241,11 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n       HARD_REG_SET this_reg;\n \n       /* Yes.  Record it as the hard register of this pseudo-reg.  */\n-      reg_renumber[allocno_reg[allocno]] = best_reg;\n+      reg_renumber[allocno[num].reg] = best_reg;\n       /* Also of any pseudo-regs that share with it.  */\n-      if (reg_may_share[allocno_reg[allocno]])\n+      if (reg_may_share[allocno[num].reg])\n \tfor (j = FIRST_PSEUDO_REGISTER; j < max_regno; j++)\n-\t  if (reg_allocno[j] == allocno)\n+\t  if (reg_allocno[j] == num)\n \t    reg_renumber[j] = best_reg;\n \n       /* Make a set of the hard regs being allocated.  */\n@@ -1286,10 +1260,10 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t}\n       /* For each other pseudo-reg conflicting with this one,\n \t mark it as conflicting with the hard regs this one occupies.  */\n-      lim = allocno;\n+      lim = num;\n       EXECUTE_IF_SET_IN_ALLOCNO_SET (conflicts + lim * allocno_row_words, j,\n \t{\n-\t  IOR_HARD_REG_SET (hard_reg_conflicts[j], this_reg);\n+\t  IOR_HARD_REG_SET (allocno[j].hard_reg_conflicts, this_reg);\n \t});\n     }\n }\n@@ -1345,7 +1319,7 @@ record_one_conflict (regno)\n        record conflicts with live pseudo regs.  */\n     EXECUTE_IF_SET_IN_ALLOCNO_SET (allocnos_live, j,\n       {\n-\tSET_HARD_REG_BIT (hard_reg_conflicts[j], regno);\n+\tSET_HARD_REG_BIT (allocno[j].hard_reg_conflicts, regno);\n       });\n   else\n     /* When a pseudo-register becomes live,\n@@ -1354,7 +1328,7 @@ record_one_conflict (regno)\n     {\n       register int ialloc = reg_allocno[regno];\n       register int ialloc_prod = ialloc * allocno_row_words;\n-      IOR_HARD_REG_SET (hard_reg_conflicts[ialloc], hard_regs_live);\n+      IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, hard_regs_live);\n       for (j = allocno_row_words - 1; j >= 0; j--)\n \t{\n #if 0\n@@ -1382,15 +1356,15 @@ record_conflicts (allocno_vec, len)\n      register int *allocno_vec;\n      register int len;\n {\n-  register int allocno;\n+  register int num;\n   register int j;\n   register int ialloc_prod;\n \n   while (--len >= 0)\n     {\n-      allocno = allocno_vec[len];\n-      ialloc_prod = allocno * allocno_row_words;\n-      IOR_HARD_REG_SET (hard_reg_conflicts[allocno], hard_regs_live);\n+      num = allocno_vec[len];\n+      ialloc_prod = num * allocno_row_words;\n+      IOR_HARD_REG_SET (allocno[num].hard_reg_conflicts, hard_regs_live);\n     }\n }\n \n@@ -1879,48 +1853,48 @@ dump_conflicts (file)\n   nregs = 0;\n   for (i = 0; i < max_allocno; i++)\n     {\n-      if (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n+      if (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n         continue;\n       nregs++;\n     }\n   fprintf (file, \";; %d regs to allocate:\", nregs);\n   for (i = 0; i < max_allocno; i++)\n     {\n       int j;\n-      if (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n+      if (reg_renumber[allocno[allocno_order[i]].reg] >= 0)\n \tcontinue;\n-      fprintf (file, \" %d\", allocno_reg[allocno_order[i]]);\n+      fprintf (file, \" %d\", allocno[allocno_order[i]].reg);\n       for (j = 0; j < max_regno; j++)\n \tif (reg_allocno[j] == allocno_order[i]\n-\t    && j != allocno_reg[allocno_order[i]])\n+\t    && j != allocno[allocno_order[i]].reg)\n \t  fprintf (file, \"+%d\", j);\n-      if (allocno_size[allocno_order[i]] != 1)\n-\tfprintf (file, \" (%d)\", allocno_size[allocno_order[i]]);\n+      if (allocno[allocno_order[i]].size != 1)\n+\tfprintf (file, \" (%d)\", allocno[allocno_order[i]].size);\n     }\n   fprintf (file, \"\\n\");\n \n   for (i = 0; i < max_allocno; i++)\n     {\n       register int j;\n-      fprintf (file, \";; %d conflicts:\", allocno_reg[i]);\n+      fprintf (file, \";; %d conflicts:\", allocno[i].reg);\n       for (j = 0; j < max_allocno; j++)\n \tif (CONFLICTP (j, i))\n-\t  fprintf (file, \" %d\", allocno_reg[j]);\n+\t  fprintf (file, \" %d\", allocno[j].reg);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (hard_reg_conflicts[i], j))\n+\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_conflicts, j))\n \t  fprintf (file, \" %d\", j);\n       fprintf (file, \"\\n\");\n \n       has_preferences = 0;\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (hard_reg_preferences[i], j))\n+\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n \t  has_preferences = 1;\n \n       if (! has_preferences)\n \tcontinue;\n-      fprintf (file, \";; %d preferences:\", allocno_reg[i]);\n+      fprintf (file, \";; %d preferences:\", allocno[i].reg);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n-\tif (TEST_HARD_REG_BIT (hard_reg_preferences[i], j))\n+\tif (TEST_HARD_REG_BIT (allocno[i].hard_reg_preferences, j))\n \t  fprintf (file, \" %d\", j);\n       fprintf (file, \"\\n\");\n     }"}]}