{"sha": "8516af930204c949aebf7e4aaf9bbde13010ff92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUxNmFmOTMwMjA0Yzk0OWFlYmY3ZTRhYWY5YmJkZTEzMDEwZmY5Mg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-24T19:54:41Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-24T19:54:41Z"}, "message": "(scan_loop): Correct comment.\n\n(strength_reduce): Correct comments.  Don't set maybe_multiple when\npass branch to scan_start.  Don't set not_every_iteration after\npassing a CODE_LABEL, or after passing a branch out of the loop.\nWhen outputting DEST_ADDR giv increments, put them next to the memory\naddress on machines with auto-increment addresses.\n(record_biv): Set new field always_executed.\n(record_giv): Set new fields always_executed and auto_inc_opt.\n(maybe_eliminate_biv_1): Reject biv with auto_inc_opt optimization\nin some cases.\n\nFrom-SVN: r11090", "tree": {"sha": "95414b030b362ec22743101feaa3f8dc6f602d8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95414b030b362ec22743101feaa3f8dc6f602d8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8516af930204c949aebf7e4aaf9bbde13010ff92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8516af930204c949aebf7e4aaf9bbde13010ff92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8516af930204c949aebf7e4aaf9bbde13010ff92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8516af930204c949aebf7e4aaf9bbde13010ff92/comments", "author": null, "committer": null, "parents": [{"sha": "125e4dcf94ec1c0b4f9a42dad9de754bbdfa1926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125e4dcf94ec1c0b4f9a42dad9de754bbdfa1926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/125e4dcf94ec1c0b4f9a42dad9de754bbdfa1926"}], "stats": {"total": 223, "additions": 192, "deletions": 31}, "files": [{"sha": "5514b91a2121a051f8792dda62ff5c663c24c36c", "filename": "gcc/loop.c", "status": "modified", "additions": 192, "deletions": 31, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8516af930204c949aebf7e4aaf9bbde13010ff92/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8516af930204c949aebf7e4aaf9bbde13010ff92/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8516af930204c949aebf7e4aaf9bbde13010ff92", "patch": "@@ -916,8 +916,7 @@ scan_loop (loop_start, end, nregs)\n \t executed during each iteration.  Therefore, we can\n \t only move out sets of trivial variables\n \t (those not used after the loop).  */\n-      /* This code appears in three places, once in scan_loop, and twice\n-\t in strength_reduce.  */\n+      /* Similar code appears twice in strength_reduce.  */\n       else if ((GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN)\n \t       /* If we enter the loop in the middle, and scan around to the\n \t\t  beginning, don't set maybe_never for that.  This must be an\n@@ -3323,7 +3322,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       /* Past CODE_LABEL, we get to insns that may be executed multiple\n \t times.  The only way we can be sure that they can't is if every\n \t every jump insn between here and the end of the loop either\n-\t returns, exits the loop, or is a forward jump.  */\n+\t returns, exits the loop, is a forward jump, or is a jump\n+\t to the loop start.  */\n \n       if (GET_CODE (p) == CODE_LABEL)\n \t{\n@@ -3350,31 +3350,46 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t  && GET_CODE (PATTERN (insn)) != RETURN\n \t\t  && (! condjump_p (insn)\n \t\t      || (JUMP_LABEL (insn) != 0\n+\t\t\t  && JUMP_LABEL (insn) != scan_start\n \t\t\t  && (INSN_UID (JUMP_LABEL (insn)) >= max_uid_for_loop\n \t\t\t      || INSN_UID (insn) >= max_uid_for_loop\n \t\t\t      || (INSN_LUID (JUMP_LABEL (insn))\n \t\t\t\t  < INSN_LUID (insn))))))\n-\t      {\n-\t\tmaybe_multiple = 1;\n-\t\tbreak;\n-\t      }\n+\t\t{\n+\t\t  maybe_multiple = 1;\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n \n-      /* Past a label or a jump, we get to insns for which we can't count\n-\t on whether or how many times they will be executed during each\n-\t iteration.  */\n-      /* This code appears in three places, once in scan_loop, and twice\n-\t in strength_reduce.  */\n-      if ((GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN)\n+      /* Past a jump, we get to insns for which we can't count\n+\t on whether they will be executed during each iteration.  */\n+      /* This code appears twice in strength_reduce.  There is also similar\n+\t code in scan_loop.  */\n+      if (GET_CODE (p) == JUMP_INSN\n \t  /* If we enter the loop in the middle, and scan around to the\n \t     beginning, don't set not_every_iteration for that.\n \t     This can be any kind of jump, since we want to know if insns\n \t     will be executed if the loop is executed.  */\n-\t  && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop_top\n+\t  && ! (JUMP_LABEL (p) == loop_top\n \t\t&& ((NEXT_INSN (NEXT_INSN (p)) == loop_end && simplejump_p (p))\n \t\t    || (NEXT_INSN (p) == loop_end && condjump_p (p)))))\n-\tnot_every_iteration = 1;\n+\t{\n+\t  rtx label = 0;\n+\n+\t  /* If this is a jump outside the loop, then it also doesn't\n+\t     matter.  Check to see if the target of this branch is on the\n+\t     loop_number_exits_labels list.  */\n+\t     \n+\t  for (label = loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]];\n+\t       label;\n+\t       label = LABEL_NEXTREF (label))\n+\t    if (XEXP (label, 0) == JUMP_LABEL (p))\n+\t      break;\n+\n+\t  if (! label)\n+\t    not_every_iteration = 1;\n+\t}\n \n       else if (GET_CODE (p) == NOTE)\n \t{\n@@ -3396,8 +3411,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \n \t Therefore, if we have just passed a label and have no more labels\n \t between here and the test insn of the loop, we know these insns\n-\t will be executed each iteration.  This can also happen if we\n-\t have just passed a jump, for example, when there are nested loops.  */\n+\t will be executed each iteration.  */\n \n       if (not_every_iteration && GET_CODE (p) == CODE_LABEL\n \t  && no_labels_between_p (p, loop_end))\n@@ -3639,20 +3653,34 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t|| GET_CODE (p) == CODE_LABEL)\n \tupdate_giv_derive (p);\n \n-      /* Past a label or a jump, we get to insns for which we can't count\n-\t on whether or how many times they will be executed during each\n-\t iteration.  */\n-      /* This code appears in three places, once in scan_loop, and twice\n-\t in strength_reduce.  */\n-      if ((GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN)\n-\t  /* If we enter the loop in the middle, and scan around\n-\t     to the beginning, don't set not_every_iteration for that.\n+      /* Past a jump, we get to insns for which we can't count\n+\t on whether they will be executed during each iteration.  */\n+      /* This code appears twice in strength_reduce.  There is also similar\n+\t code in scan_loop.  */\n+      if (GET_CODE (p) == JUMP_INSN\n+\t  /* If we enter the loop in the middle, and scan around to the\n+\t     beginning, don't set not_every_iteration for that.\n \t     This can be any kind of jump, since we want to know if insns\n \t     will be executed if the loop is executed.  */\n-\t  && ! (GET_CODE (p) == JUMP_INSN && JUMP_LABEL (p) == loop_top\n+\t  && ! (JUMP_LABEL (p) == loop_top\n \t\t&& ((NEXT_INSN (NEXT_INSN (p)) == loop_end && simplejump_p (p))\n \t\t    || (NEXT_INSN (p) == loop_end && condjump_p (p)))))\n-\tnot_every_iteration = 1;\n+\t{\n+\t  rtx label = 0;\n+\n+\t  /* If this is a jump outside the loop, then it also doesn't\n+\t     matter.  Check to see if the target of this branch is on the\n+\t     loop_number_exits_labels list.  */\n+\t     \n+\t  for (label = loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]];\n+\t       label;\n+\t       label = LABEL_NEXTREF (label))\n+\t    if (XEXP (label, 0) == JUMP_LABEL (p))\n+\t      break;\n+\n+\t  if (! label)\n+\t    not_every_iteration = 1;\n+\t}\n \n       else if (GET_CODE (p) == NOTE)\n \t{\n@@ -3858,20 +3886,83 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  struct induction *tv;\n \t  if (! v->ignore && v->same == 0)\n \t    {\n+\t      int auto_inc_opt = 0;\n+\n \t      v->new_reg = gen_reg_rtx (v->mode);\n \n-\t      /* For each place where the biv is incremented,\n-\t\t add an insn to increment the new, reduced reg for the giv.  */\n+#ifdef AUTO_INC_DEC\n+\t      /* If the target has auto-increment addressing modes, and\n+\t\t this is an address giv, then try to put the increment\n+\t\t immediately after its use, so that flow can create an\n+\t\t auto-increment addressing mode.  */\n+\t      if (v->giv_type == DEST_ADDR && bl->biv_count == 1\n+\t\t  && bl->biv->always_executed\n+\t\t  && ! bl->biv->maybe_multiple\n+\t\t  && v->always_executed && ! v->maybe_multiple)\n+\t\t{\n+\t\t  /* If other giv's have been combined with this one, then\n+\t\t     this will work only if all uses of the other giv's occur\n+\t\t     before this giv's insn.  This is difficult to check.\n+\n+\t\t     We simplify this by looking for the common case where\n+\t\t     there is one DEST_REG giv, and this giv's insn is the\n+\t\t     last use of the dest_reg of that DEST_REG giv.  If the\n+\t\t     the increment occurs after the address giv, then we can\n+\t\t     perform the optimization.  (Otherwise, the increment\n+\t\t     would have to go before other_giv, and we would not be\n+\t\t     able to combine it with the address giv to get an\n+\t\t     auto-inc address.)  */\n+\t\t  if (v->combined_with)\n+\t\t    {\n+\t\t      struct induction *other_giv = 0;\n+\n+\t\t      for (tv = bl->giv; tv; tv = tv->next_iv)\n+\t\t\tif (tv->same == v)\n+\t\t\t  {\n+\t\t\t    if (other_giv)\n+\t\t\t      break;\n+\t\t\t    else\n+\t\t\t      other_giv = tv;\n+\t\t\t  }\n+\t\t      if (! tv && other_giv\n+\t\t\t  && (regno_last_uid[REGNO (other_giv->dest_reg)]\n+\t\t\t      == INSN_UID (v->insn))\n+\t\t\t  && INSN_LUID (v->insn) < INSN_LUID (bl->biv->insn))\n+\t\t\tauto_inc_opt = 1;\n+\t\t    }\n+\t\t  /* Check for case where increment is before the the address\n+\t\t     giv.  */\n+\t\t  else if (INSN_LUID (v->insn) > INSN_LUID (bl->biv->insn))\n+\t\t    auto_inc_opt = -1;\n+\t\t  else\n+\t\t    auto_inc_opt = 1;\n+\n+\t\t  if (auto_inc_opt)\n+\t\t    v->auto_inc_opt = 1;\n+\t\t}\n+#endif\n+\n+\t      /* For each place where the biv is incremented, add an insn\n+\t\t to increment the new, reduced reg for the giv.  */\n \t      for (tv = bl->biv; tv; tv = tv->next_iv)\n \t\t{\n+\t\t  rtx insert_before;\n+\n+\t\t  if (! auto_inc_opt)\n+\t\t    insert_before = tv->insn;\n+\t\t  else if (auto_inc_opt == 1)\n+\t\t    insert_before = NEXT_INSN (v->insn);\n+\t\t  else\n+\t\t    insert_before = v->insn;\n+\n \t\t  if (tv->mult_val == const1_rtx)\n \t\t    emit_iv_add_mult (tv->add_val, v->mult_val,\n-\t\t\t\t      v->new_reg, v->new_reg, tv->insn);\n+\t\t\t\t      v->new_reg, v->new_reg, insert_before);\n \t\t  else /* tv->mult_val == const0_rtx */\n \t\t    /* A multiply is acceptable here\n \t\t       since this is presumed to be seldom executed.  */\n \t\t    emit_iv_add_mult (tv->add_val, v->mult_val,\n-\t\t\t\t      v->add_val, v->new_reg, tv->insn);\n+\t\t\t\t      v->add_val, v->new_reg, insert_before);\n \t\t}\n \n \t      /* Add code at loop start to initialize giv's reduced reg.  */\n@@ -4262,6 +4353,7 @@ record_biv (v, insn, dest_reg, inc_val, mult_val,\n   v->add_val = inc_val;\n   v->mode = GET_MODE (dest_reg);\n   v->always_computable = ! not_every_iteration;\n+  v->always_executed = ! not_every_iteration;\n   v->maybe_multiple = maybe_multiple;\n \n   /* Add this to the reg's iv_class, creating a class\n@@ -4374,6 +4466,7 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   v->new_reg = 0;\n   v->final_value = 0;\n   v->same_insn = 0;\n+  v->auto_inc_opt = 0;\n \n   /* The v->always_computable field is used in update_giv_derive, to\n      determine whether a giv can be used to derive another giv.  For a\n@@ -4388,6 +4481,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n   else\n     v->always_computable = ! not_every_iteration;\n \n+  v->always_executed = ! not_every_iteration;\n+\n   if (type == DEST_ADDR)\n     {\n       v->mode = GET_MODE (*location);\n@@ -6049,6 +6144,17 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode)\n \t      {\n+\t\t/* If the giv V had the auto-inc address optimization applied\n+\t\t   to it, and INSN occurs between the giv insn and the biv\n+\t\t   insn, then we must adjust the value used here.\n+\t\t   This is rare, so we don't bother to do so.  */\n+\t\tif (v->auto_inc_opt\n+\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n+\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n+\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n+\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t  continue;\n+\n \t\tif (! eliminate_p)\n \t\t  return 1;\n \n@@ -6074,6 +6180,17 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode)\n \t      {\n+\t\t/* If the giv V had the auto-inc address optimization applied\n+\t\t   to it, and INSN occurs between the giv insn and the biv\n+\t\t   insn, then we must adjust the value used here.\n+\t\t   This is rare, so we don't bother to do so.  */\n+\t\tif (v->auto_inc_opt\n+\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n+\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n+\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n+\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t  continue;\n+\n \t\tif (! eliminate_p)\n \t\t  return 1;\n \n@@ -6131,6 +6248,17 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t&& ! v->ignore && ! v->maybe_dead && v->always_computable\n \t\t&& v->mode == mode)\n \t      {\n+\t\t/* If the giv V had the auto-inc address optimization applied\n+\t\t   to it, and INSN occurs between the giv insn and the biv\n+\t\t   insn, then we must adjust the value used here.\n+\t\t   This is rare, so we don't bother to do so.  */\n+\t\tif (v->auto_inc_opt\n+\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n+\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n+\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n+\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t  continue;\n+\n \t\tif (! eliminate_p)\n \t\t  return 1;\n \n@@ -6169,6 +6297,17 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t      {\n \t\trtx tem;\n \n+\t\t/* If the giv V had the auto-inc address optimization applied\n+\t\t   to it, and INSN occurs between the giv insn and the biv\n+\t\t   insn, then we must adjust the value used here.\n+\t\t   This is rare, so we don't bother to do so.  */\n+\t\tif (v->auto_inc_opt\n+\t\t    && ((INSN_LUID (v->insn) < INSN_LUID (insn)\n+\t\t\t && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n+\t\t\t|| (INSN_LUID (v->insn) > INSN_LUID (insn)\n+\t\t\t    && INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t  continue;\n+\n \t\tif (! eliminate_p)\n \t\t  return 1;\n \n@@ -6200,6 +6339,17 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t  {\n \t\t    rtx tem;\n \n+\t\t    /* If the giv V had the auto-inc address optimization applied\n+\t\t       to it, and INSN occurs between the giv insn and the biv\n+\t\t       insn, then we must adjust the value used here.\n+\t\t       This is rare, so we don't bother to do so.  */\n+\t\t    if (v->auto_inc_opt\n+\t\t\t&& ((INSN_LUID (v->insn) < INSN_LUID (insn)\n+\t\t\t     && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n+\t\t\t    || (INSN_LUID (v->insn) > INSN_LUID (insn)\n+\t\t\t\t&& INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t      continue;\n+\n \t\t    if (! eliminate_p)\n \t\t      return 1;\n \n@@ -6251,6 +6401,17 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t    && rtx_equal_p (tv->add_val, v->add_val)\n \t\t    && tv->mode == mode)\n \t\t  {\n+\t\t    /* If the giv V had the auto-inc address optimization applied\n+\t\t       to it, and INSN occurs between the giv insn and the biv\n+\t\t       insn, then we must adjust the value used here.\n+\t\t       This is rare, so we don't bother to do so.  */\n+\t\t    if (v->auto_inc_opt\n+\t\t\t&& ((INSN_LUID (v->insn) < INSN_LUID (insn)\n+\t\t\t     && INSN_LUID (insn) < INSN_LUID (bl->biv->insn))\n+\t\t\t    || (INSN_LUID (v->insn) > INSN_LUID (insn)\n+\t\t\t\t&& INSN_LUID (insn) > INSN_LUID (bl->biv->insn))))\n+\t\t      continue;\n+\n \t\t    if (! eliminate_p)\n \t\t      return 1;\n "}]}