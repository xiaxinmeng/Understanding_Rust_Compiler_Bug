{"sha": "89675e73495690215be5a19c0cf9ea3dc83826b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk2NzVlNzM0OTU2OTAyMTViZTVhMTljMGNmOWVhM2RjODM4MjZiMQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2007-09-09T11:22:24Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2007-09-09T11:22:24Z"}, "message": "tree-vectorizer.h (stmt_vinfo_set_inside_of_loop_cost, [...]): New functions.\n\n\t* tree-vectorizer.h (stmt_vinfo_set_inside_of_loop_cost,\n\tstmt_vinfo_set_outside_of_loop_cost): New functions.\n\t* tree-vect-transform.c (vect_get_cost_fields): Remove.\n\t(vect_model_simple_cost): Call\n\tstmt_vinfo_set_inside/outside_of_loop_cost to set the relevant cost\n\tfield instead of calling vect_get_cost_fields.\n\t(vect_model_store_cost, vect_model_load_cost): Likewise.\n\nFrom-SVN: r128294", "tree": {"sha": "9418d7d2c8a15772cdcdf5fbb870cefdb5a643dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9418d7d2c8a15772cdcdf5fbb870cefdb5a643dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89675e73495690215be5a19c0cf9ea3dc83826b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89675e73495690215be5a19c0cf9ea3dc83826b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89675e73495690215be5a19c0cf9ea3dc83826b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89675e73495690215be5a19c0cf9ea3dc83826b1/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23a651fcb5a4e57299951b6894779807d2deb693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a651fcb5a4e57299951b6894779807d2deb693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a651fcb5a4e57299951b6894779807d2deb693"}], "stats": {"total": 126, "additions": 63, "deletions": 63}, "files": [{"sha": "c6cee928b9dc0d26e219e180a7f18df067487fd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89675e73495690215be5a19c0cf9ea3dc83826b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89675e73495690215be5a19c0cf9ea3dc83826b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89675e73495690215be5a19c0cf9ea3dc83826b1", "patch": "@@ -1,3 +1,13 @@\n+2007-09-09  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (stmt_vinfo_set_inside_of_loop_cost,\n+\tstmt_vinfo_set_outside_of_loop_cost): New functions.\n+\t* tree-vect-transform.c (vect_get_cost_fields): Remove.\n+\t(vect_model_simple_cost): Call\n+\tstmt_vinfo_set_inside/outside_of_loop_cost to set the relevant cost\n+\tfield instead of calling vect_get_cost_fields.\n+\t(vect_model_store_cost, vect_model_load_cost): Likewise.\n+\n 2007-09-09  Revital Eres  <eres@il.ibm.com>\n \n \t* config/rs6000/rs6000.c (paired_init_builtins): Add const"}, {"sha": "30dbf712e55d15aecb5ed28b0adc633df5b5b731", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 32, "deletions": 63, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89675e73495690215be5a19c0cf9ea3dc83826b1/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89675e73495690215be5a19c0cf9ea3dc83826b1/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=89675e73495690215be5a19c0cf9ea3dc83826b1", "patch": "@@ -462,26 +462,6 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n }\n \n \n-/* Return addresses of the cost fields of SLP_NODE if it's not NULL, and of\n-   the stmt otherwise.  */\n-\n-static inline void\n-vect_get_cost_fields (stmt_vec_info stmt_info, slp_tree slp_node, \n-\t\t      int **inside_cost_field, int **outside_cost_field)\n-{\n-  if (slp_node)\n-    {\n-      *inside_cost_field = &(SLP_TREE_INSIDE_OF_LOOP_COST (slp_node));\n-      *outside_cost_field = &(SLP_TREE_OUTSIDE_OF_LOOP_COST (slp_node));\n-    }\n-  else\n-    {\n-      *inside_cost_field = &(STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info));\n-      *outside_cost_field = &(STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n-    }\n-}\n-\n-\n /* Function vect_model_simple_cost.  \n \n    Models cost for simple operations, i.e. those that only emit ncopies of a \n@@ -493,24 +473,24 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\tenum vect_def_type *dt, slp_tree slp_node)\n {\n   int i;\n-  int *inside_cost_field, *outside_cost_field;\n+  int inside_cost = 0, outside_cost = 0;\n \n-  /* Take addresses of relevant fields to update in the function.  */\n-  vect_get_cost_fields (stmt_info, slp_node, &inside_cost_field, \n-\t\t\t&outside_cost_field);\n-\n-  *inside_cost_field = ncopies * TARG_VEC_STMT_COST;\n+  inside_cost = ncopies * TARG_VEC_STMT_COST;\n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n     {\n       if (dt[i] == vect_constant_def || dt[i] == vect_invariant_def)\n-\t*outside_cost_field += TARG_SCALAR_TO_VEC_COST; \n+\toutside_cost += TARG_SCALAR_TO_VEC_COST; \n     }\n   \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", *inside_cost_field, *outside_cost_field);\n+             \"outside_cost = %d .\", inside_cost, outside_cost);\n+\n+  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n+  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n \n@@ -541,16 +521,11 @@ void\n vect_model_store_cost (stmt_vec_info stmt_info, int ncopies, \n \t\t       enum vect_def_type dt, slp_tree slp_node)\n {\n-  int cost = 0;\n   int group_size;\n-  int *inside_cost_field, *outside_cost_field;\n-\n-  /* Take addresses of relevant fields to update in the function.  */\n-  vect_get_cost_fields (stmt_info, slp_node, &inside_cost_field, \n-\t\t\t&outside_cost_field);\n+  int inside_cost = 0, outside_cost = 0;\n \n   if (dt == vect_constant_def || dt == vect_invariant_def)\n-    *outside_cost_field = TARG_SCALAR_TO_VEC_COST;\n+    outside_cost = TARG_SCALAR_TO_VEC_COST;\n \n   /* Strided access?  */\n   if (DR_GROUP_FIRST_DR (stmt_info)) \n@@ -564,7 +539,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   if (group_size > 1) \n     {\n       /* Uses a high and low interleave operation for each needed permute.  */\n-      cost = ncopies * exact_log2(group_size) * group_size \n+      inside_cost = ncopies * exact_log2(group_size) * group_size \n              * TARG_VEC_STMT_COST;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -574,13 +549,15 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     }\n \n   /* Costs of the stores.  */\n-  cost += ncopies * TARG_VEC_STORE_COST;\n-\n-  *inside_cost_field = cost;\n+  inside_cost += ncopies * TARG_VEC_STORE_COST;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", *inside_cost_field, *outside_cost_field);\n+             \"outside_cost = %d .\", inside_cost, outside_cost);\n+\n+  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n+  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n \n@@ -595,16 +572,11 @@ void\n vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n \t\t \n {\n-  int inner_cost = 0;\n   int group_size;\n   int alignment_support_cheme;\n   tree first_stmt;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n-  int *inside_cost_field, *outside_cost_field;\n-\n-  /* Take addresses of relevant fields to update in the function.  */\n-  vect_get_cost_fields (stmt_info, slp_node, &inside_cost_field, \n-\t\t\t&outside_cost_field);\n+  int inside_cost = 0, outside_cost = 0;\n \n   /* Strided accesses?  */\n   first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n@@ -627,8 +599,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n   if (group_size > 1) \n     {\n       /* Uses an even and odd extract operations for each needed permute.  */\n-      inner_cost = ncopies * exact_log2(group_size) * group_size\n-                   * TARG_VEC_STMT_COST;\n+      inside_cost = ncopies * exact_log2(group_size) * group_size\n+\t* TARG_VEC_STMT_COST;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n@@ -641,7 +613,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n     {\n     case dr_aligned:\n       {\n-        inner_cost += ncopies * TARG_VEC_LOAD_COST;\n+        inside_cost += ncopies * TARG_VEC_LOAD_COST;\n \n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n@@ -651,7 +623,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n     case dr_unaligned_supported:\n       {\n         /* Here, we assign an additional cost for the unaligned load.  */\n-        inner_cost += ncopies * TARG_VEC_UNALIGNED_LOAD_COST;\n+        inside_cost += ncopies * TARG_VEC_UNALIGNED_LOAD_COST;\n \n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n@@ -661,20 +633,18 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n       }\n     case dr_explicit_realign:\n       {\n-        inner_cost += ncopies * (2*TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n+        inside_cost += ncopies * (2*TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n \n         /* FIXME: If the misalignment remains fixed across the iterations of\n            the containing loop, the following cost should be added to the\n            outside costs.  */\n         if (targetm.vectorize.builtin_mask_for_load)\n-          inner_cost += TARG_VEC_STMT_COST;\n+          inside_cost += TARG_VEC_STMT_COST;\n \n         break;\n       }\n     case dr_explicit_realign_optimized:\n       {\n-        int outer_cost = 0;\n-\n         if (vect_print_dump_info (REPORT_DETAILS))\n           fprintf (vect_dump, \"vect_model_load_cost: unaligned software \"\n                    \"pipelined.\");\n@@ -688,28 +658,27 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n \n         if ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1 || slp_node)\n           {\n-            outer_cost = 2*TARG_VEC_STMT_COST;\n+            outside_cost = 2*TARG_VEC_STMT_COST;\n             if (targetm.vectorize.builtin_mask_for_load)\n-              outer_cost += TARG_VEC_STMT_COST;\n+              outside_cost += TARG_VEC_STMT_COST;\n           }\n-        \n-        *outside_cost_field = outer_cost;\n \n-        inner_cost += ncopies * (TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n+        inside_cost += ncopies * (TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n \n         break;\n       }\n \n     default:\n       gcc_unreachable ();\n     }\n-\n-  *inside_cost_field = inner_cost;\n-\n+  \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", *inside_cost_field, *outside_cost_field);\n+             \"outside_cost = %d .\", inside_cost, outside_cost);\n \n+  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n+  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n "}, {"sha": "913c524137b1f4d56df35094ac976bd92e7ab3c6", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89675e73495690215be5a19c0cf9ea3dc83826b1/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89675e73495690215be5a19c0cf9ea3dc83826b1/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=89675e73495690215be5a19c0cf9ea3dc83826b1", "patch": "@@ -561,6 +561,27 @@ is_loop_header_bb_p (basic_block bb)\n   return false;\n }\n \n+static inline void \n+stmt_vinfo_set_inside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node, \n+\t\t\t\t    int cost)\n+{\n+  if (slp_node)\n+    SLP_TREE_INSIDE_OF_LOOP_COST (slp_node) = cost;\n+  else\n+    STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = cost;\n+}     \n+\n+static inline void \n+stmt_vinfo_set_outside_of_loop_cost (stmt_vec_info stmt_info, slp_tree slp_node, \n+\t\t\t\t     int cost)\n+{\n+  if (slp_node)\n+    SLP_TREE_OUTSIDE_OF_LOOP_COST (slp_node) = cost;\n+  else\n+    STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = cost;\n+}     \n+\n+\n /*-----------------------------------------------------------------*/\n /* Info on data references alignment.                              */\n /*-----------------------------------------------------------------*/"}]}