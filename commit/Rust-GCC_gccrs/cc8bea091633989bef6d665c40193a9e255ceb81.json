{"sha": "cc8bea091633989bef6d665c40193a9e255ceb81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M4YmVhMDkxNjMzOTg5YmVmNmQ2NjVjNDAxOTNhOWUyNTVjZWI4MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:55:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:55:45Z"}, "message": "poly_int: aff_tree\n\nThis patch changes the type of aff_tree::offset from widest_int to\npoly_widest_int and adjusts the function interfaces in the same way.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-affine.h (aff_tree::offset): Change from widest_int\n\tto poly_widest_int.\n\t(wide_int_ext_for_comb): Delete.\n\t(aff_combination_const, aff_comb_cannot_overlap_p): Take the\n\tconstants as poly_widest_int rather than widest_int.\n\t(aff_combination_constant_multiple_p): Return the multiplier\n\tas a poly_widest_int.\n\t(aff_combination_zero_p, aff_combination_singleton_var_p): Handle\n\tpolynomial offsets.\n\t* tree-affine.c (wide_int_ext_for_comb): Make original widest_int\n\tversion static and add an overload for poly_widest_int.\n\t(aff_combination_const, aff_combination_add_cst)\n\t(wide_int_constant_multiple_p, aff_comb_cannot_overlap_p): Take\n\tthe constants as poly_widest_int rather than widest_int.\n\t(tree_to_aff_combination): Generalize INTEGER_CST case to\n\tpoly_int_tree_p.\n\t(aff_combination_to_tree): Track offsets as poly_widest_ints.\n\t(aff_combination_add_product, aff_combination_mult): Handle\n\tpolynomial offsets.\n\t(aff_combination_constant_multiple_p): Return the multiplier\n\tas a poly_widest_int.\n\t* tree-predcom.c (determine_offset): Return the offset as a\n\tpoly_widest_int.\n\t(split_data_refs_to_components, suitable_component_p): Update\n\taccordingly.\n\t(valid_initializer_p): Update call to\n\taff_combination_constant_multiple_p.\n\t* tree-ssa-address.c (addr_to_parts): Handle polynomial offsets.\n\t* tree-ssa-loop-ivopts.c (get_address_cost_ainc): Take the step\n\tas a poly_int64 rather than a HOST_WIDE_INT.\n\t(get_address_cost): Handle polynomial offsets.\n\t(iv_elimination_compare_lt): Likewise.\n\t(rewrite_use_nonlinear_expr): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255888", "tree": {"sha": "0198dc636ad0b00daedf03723bb5e7349e3373a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0198dc636ad0b00daedf03723bb5e7349e3373a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc8bea091633989bef6d665c40193a9e255ceb81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8bea091633989bef6d665c40193a9e255ceb81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8bea091633989bef6d665c40193a9e255ceb81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8bea091633989bef6d665c40193a9e255ceb81/comments", "author": null, "committer": null, "parents": [{"sha": "a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a90c88042b29b16ecadc2f0560f4d3581bcf9ad6"}], "stats": {"total": 184, "additions": 132, "deletions": 52}, "files": [{"sha": "1c2a7be3d9e8789c97ab8ebe36d65f05c64be320", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc8bea091633989bef6d665c40193a9e255ceb81", "patch": "@@ -1,3 +1,41 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-affine.h (aff_tree::offset): Change from widest_int\n+\tto poly_widest_int.\n+\t(wide_int_ext_for_comb): Delete.\n+\t(aff_combination_const, aff_comb_cannot_overlap_p): Take the\n+\tconstants as poly_widest_int rather than widest_int.\n+\t(aff_combination_constant_multiple_p): Return the multiplier\n+\tas a poly_widest_int.\n+\t(aff_combination_zero_p, aff_combination_singleton_var_p): Handle\n+\tpolynomial offsets.\n+\t* tree-affine.c (wide_int_ext_for_comb): Make original widest_int\n+\tversion static and add an overload for poly_widest_int.\n+\t(aff_combination_const, aff_combination_add_cst)\n+\t(wide_int_constant_multiple_p, aff_comb_cannot_overlap_p): Take\n+\tthe constants as poly_widest_int rather than widest_int.\n+\t(tree_to_aff_combination): Generalize INTEGER_CST case to\n+\tpoly_int_tree_p.\n+\t(aff_combination_to_tree): Track offsets as poly_widest_ints.\n+\t(aff_combination_add_product, aff_combination_mult): Handle\n+\tpolynomial offsets.\n+\t(aff_combination_constant_multiple_p): Return the multiplier\n+\tas a poly_widest_int.\n+\t* tree-predcom.c (determine_offset): Return the offset as a\n+\tpoly_widest_int.\n+\t(split_data_refs_to_components, suitable_component_p): Update\n+\taccordingly.\n+\t(valid_initializer_p): Update call to\n+\taff_combination_constant_multiple_p.\n+\t* tree-ssa-address.c (addr_to_parts): Handle polynomial offsets.\n+\t* tree-ssa-loop-ivopts.c (get_address_cost_ainc): Take the step\n+\tas a poly_int64 rather than a HOST_WIDE_INT.\n+\t(get_address_cost): Handle polynomial offsets.\n+\t(iv_elimination_compare_lt): Likewise.\n+\t(rewrite_use_nonlinear_expr): Likewise.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3869b0be036fa88f2f0a634e6a7a88d76422676c", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=cc8bea091633989bef6d665c40193a9e255ceb81", "patch": "@@ -34,12 +34,20 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Extends CST as appropriate for the affine combinations COMB.  */\n \n-widest_int\n+static widest_int\n wide_int_ext_for_comb (const widest_int &cst, tree type)\n {\n   return wi::sext (cst, TYPE_PRECISION (type));\n }\n \n+/* Likewise for polynomial offsets.  */\n+\n+static poly_widest_int\n+wide_int_ext_for_comb (const poly_widest_int &cst, tree type)\n+{\n+  return wi::sext (cst, TYPE_PRECISION (type));\n+}\n+\n /* Initializes affine combination COMB so that its value is zero in TYPE.  */\n \n static void\n@@ -57,7 +65,7 @@ aff_combination_zero (aff_tree *comb, tree type)\n /* Sets COMB to CST.  */\n \n void\n-aff_combination_const (aff_tree *comb, tree type, const widest_int &cst)\n+aff_combination_const (aff_tree *comb, tree type, const poly_widest_int &cst)\n {\n   aff_combination_zero (comb, type);\n   comb->offset = wide_int_ext_for_comb (cst, comb->type);;\n@@ -190,7 +198,7 @@ aff_combination_add_elt (aff_tree *comb, tree elt, const widest_int &scale_in)\n /* Adds CST to C.  */\n \n static void\n-aff_combination_add_cst (aff_tree *c, const widest_int &cst)\n+aff_combination_add_cst (aff_tree *c, const poly_widest_int &cst)\n {\n   c->offset = wide_int_ext_for_comb (c->offset + cst, c->type);\n }\n@@ -268,10 +276,6 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n   code = TREE_CODE (expr);\n   switch (code)\n     {\n-    case INTEGER_CST:\n-      aff_combination_const (comb, type, wi::to_widest (expr));\n-      return;\n-\n     case POINTER_PLUS_EXPR:\n       tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n       tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n@@ -423,7 +427,14 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n       break;\n \n     default:\n-      break;\n+      {\n+\tif (poly_int_tree_p (expr))\n+\t  {\n+\t    aff_combination_const (comb, type, wi::to_poly_widest (expr));\n+\t    return;\n+\t  }\n+\tbreak;\n+      }\n     }\n \n   aff_combination_elt (comb, type, expr);\n@@ -478,7 +489,8 @@ aff_combination_to_tree (aff_tree *comb)\n {\n   tree type = comb->type, base = NULL_TREE, expr = NULL_TREE;\n   unsigned i;\n-  widest_int off, sgn;\n+  poly_widest_int off;\n+  int sgn;\n \n   gcc_assert (comb->n == MAX_AFF_ELTS || comb->rest == NULL_TREE);\n \n@@ -502,7 +514,7 @@ aff_combination_to_tree (aff_tree *comb)\n \n   /* Ensure that we get x - 1, not x + (-1) or x + 0xff..f if x is\n      unsigned.  */\n-  if (wi::neg_p (comb->offset))\n+  if (known_lt (comb->offset, 0))\n     {\n       off = -comb->offset;\n       sgn = -1;\n@@ -588,7 +600,19 @@ aff_combination_add_product (aff_tree *c, const widest_int &coef, tree val,\n     }\n \n   if (val)\n-    aff_combination_add_elt (r, val, coef * c->offset);\n+    {\n+      if (c->offset.is_constant ())\n+\t/* Access coeffs[0] directly, for efficiency.  */\n+\taff_combination_add_elt (r, val, coef * c->offset.coeffs[0]);\n+      else\n+\t{\n+\t  /* c->offset is polynomial, so multiply VAL rather than COEF\n+\t     by it.  */\n+\t  tree offset = wide_int_to_tree (TREE_TYPE (val), c->offset);\n+\t  val = fold_build2 (MULT_EXPR, TREE_TYPE (val), val, offset);\n+\t  aff_combination_add_elt (r, val, coef);\n+\t}\n+    }\n   else\n     aff_combination_add_cst (r, coef * c->offset);\n }\n@@ -607,7 +631,15 @@ aff_combination_mult (aff_tree *c1, aff_tree *c2, aff_tree *r)\n     aff_combination_add_product (c1, c2->elts[i].coef, c2->elts[i].val, r);\n   if (c2->rest)\n     aff_combination_add_product (c1, 1, c2->rest, r);\n-  aff_combination_add_product (c1, c2->offset, NULL, r);\n+  if (c2->offset.is_constant ())\n+    /* Access coeffs[0] directly, for efficiency.  */\n+    aff_combination_add_product (c1, c2->offset.coeffs[0], NULL, r);\n+  else\n+    {\n+      /* c2->offset is polynomial, so do the multiplication in tree form.  */\n+      tree offset = wide_int_to_tree (c2->type, c2->offset);\n+      aff_combination_add_product (c1, 1, offset, r);\n+    }\n }\n \n /* Returns the element of COMB whose value is VAL, or NULL if no such\n@@ -776,27 +808,28 @@ free_affine_expand_cache (hash_map<tree, name_expansion *> **cache)\n    is set to true.  */\n \n static bool\n-wide_int_constant_multiple_p (const widest_int &val, const widest_int &div,\n-\t\t\t      bool *mult_set, widest_int *mult)\n+wide_int_constant_multiple_p (const poly_widest_int &val,\n+\t\t\t      const poly_widest_int &div,\n+\t\t\t      bool *mult_set, poly_widest_int *mult)\n {\n-  widest_int rem, cst;\n+  poly_widest_int rem, cst;\n \n-  if (val == 0)\n+  if (known_eq (val, 0))\n     {\n-      if (*mult_set && *mult != 0)\n+      if (*mult_set && maybe_ne (*mult, 0))\n \treturn false;\n       *mult_set = true;\n       *mult = 0;\n       return true;\n     }\n \n-  if (div == 0)\n+  if (maybe_eq (div, 0))\n     return false;\n \n-  if (!wi::multiple_of_p (val, div, SIGNED, &cst))\n+  if (!multiple_p (val, div, &cst))\n     return false;\n \n-  if (*mult_set && *mult != cst)\n+  if (*mult_set && maybe_ne (*mult, cst))\n     return false;\n \n   *mult_set = true;\n@@ -809,12 +842,12 @@ wide_int_constant_multiple_p (const widest_int &val, const widest_int &div,\n \n bool\n aff_combination_constant_multiple_p (aff_tree *val, aff_tree *div,\n-\t\t\t\t     widest_int *mult)\n+\t\t\t\t     poly_widest_int *mult)\n {\n   bool mult_set = false;\n   unsigned i;\n \n-  if (val->n == 0 && val->offset == 0)\n+  if (val->n == 0 && known_eq (val->offset, 0))\n     {\n       *mult = 0;\n       return true;\n@@ -927,23 +960,26 @@ get_inner_reference_aff (tree ref, aff_tree *addr, widest_int *size)\n    size SIZE2 at position DIFF cannot overlap.  */\n \n bool\n-aff_comb_cannot_overlap_p (aff_tree *diff, const widest_int &size1,\n-\t\t\t   const widest_int &size2)\n+aff_comb_cannot_overlap_p (aff_tree *diff, const poly_widest_int &size1,\n+\t\t\t   const poly_widest_int &size2)\n {\n   /* Unless the difference is a constant, we fail.  */\n   if (diff->n != 0)\n     return false;\n \n-  if (wi::neg_p (diff->offset))\n+  if (!ordered_p (diff->offset, 0))\n+    return false;\n+\n+  if (maybe_lt (diff->offset, 0))\n     {\n       /* The second object is before the first one, we succeed if the last\n \t element of the second object is before the start of the first one.  */\n-      return wi::neg_p (diff->offset + size2 - 1);\n+      return known_le (diff->offset + size2, 0);\n     }\n   else\n     {\n       /* We succeed if the second object starts after the first one ends.  */\n-      return size1 <= diff->offset;\n+      return known_le (size1, diff->offset);\n     }\n }\n "}, {"sha": "d6802ebd093d121c6719314f865aa6d8eaafc703", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=cc8bea091633989bef6d665c40193a9e255ceb81", "patch": "@@ -43,7 +43,7 @@ struct aff_tree\n   tree type;\n \n   /* Constant offset.  */\n-  widest_int offset;\n+  poly_widest_int offset;\n \n   /* Number of elements of the combination.  */\n   unsigned n;\n@@ -64,8 +64,7 @@ struct aff_tree\n \n struct name_expansion;\n \n-widest_int wide_int_ext_for_comb (const widest_int &, aff_tree *);\n-void aff_combination_const (aff_tree *, tree, const widest_int &);\n+void aff_combination_const (aff_tree *, tree, const poly_widest_int &);\n void aff_combination_elt (aff_tree *, tree, tree);\n void aff_combination_scale (aff_tree *, const widest_int &);\n void aff_combination_mult (aff_tree *, aff_tree *, aff_tree *);\n@@ -76,14 +75,15 @@ void aff_combination_convert (aff_tree *, tree);\n void tree_to_aff_combination (tree, tree, aff_tree *);\n tree aff_combination_to_tree (aff_tree *);\n void unshare_aff_combination (aff_tree *);\n-bool aff_combination_constant_multiple_p (aff_tree *, aff_tree *, widest_int *);\n+bool aff_combination_constant_multiple_p (aff_tree *, aff_tree *,\n+\t\t\t\t\t  poly_widest_int *);\n void aff_combination_expand (aff_tree *, hash_map<tree, name_expansion *> **);\n void tree_to_aff_combination_expand (tree, tree, aff_tree *,\n \t\t\t\t     hash_map<tree, name_expansion *> **);\n tree get_inner_reference_aff (tree, aff_tree *, widest_int *);\n void free_affine_expand_cache (hash_map<tree, name_expansion *> **);\n-bool aff_comb_cannot_overlap_p (aff_tree *, const widest_int &,\n-\t\t\t\tconst widest_int &);\n+bool aff_comb_cannot_overlap_p (aff_tree *, const poly_widest_int &,\n+\t\t\t\tconst poly_widest_int &);\n \n /* Debugging functions.  */\n void debug_aff (aff_tree *);\n@@ -102,7 +102,7 @@ aff_combination_zero_p (aff_tree *aff)\n   if (!aff)\n     return true;\n \n-  if (aff->n == 0 && aff->offset == 0)\n+  if (aff->n == 0 && known_eq (aff->offset, 0))\n     return true;\n \n   return false;\n@@ -121,7 +121,7 @@ inline bool\n aff_combination_singleton_var_p (aff_tree *aff)\n {\n   return (aff->n == 1\n-\t  && aff->offset == 0\n+\t  && known_eq (aff->offset, 0)\n \t  && (aff->elts[0].coef == 1 || aff->elts[0].coef == -1));\n }\n #endif /* GCC_TREE_AFFINE_H */"}, {"sha": "d3a863e209f0320d72cb3d5b14ea9734b9a146fe", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=cc8bea091633989bef6d665c40193a9e255ceb81", "patch": "@@ -692,7 +692,7 @@ aff_combination_dr_offset (struct data_reference *dr, aff_tree *offset)\n \n static bool\n determine_offset (struct data_reference *a, struct data_reference *b,\n-\t\t  widest_int *off)\n+\t\t  poly_widest_int *off)\n {\n   aff_tree diff, baseb, step;\n   tree typea, typeb;\n@@ -801,7 +801,7 @@ split_data_refs_to_components (struct loop *loop,\n \n   FOR_EACH_VEC_ELT (depends, i, ddr)\n     {\n-      widest_int dummy_off;\n+      poly_widest_int dummy_off;\n \n       if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n \tcontinue;\n@@ -958,7 +958,11 @@ suitable_component_p (struct loop *loop, struct component *comp)\n \n   for (i = 1; comp->refs.iterate (i, &a); i++)\n     {\n-      if (!determine_offset (first->ref, a->ref, &a->offset))\n+      /* Polynomial offsets are no use, since we need to know the\n+\t gap between iteration numbers at compile time.  */\n+      poly_widest_int offset;\n+      if (!determine_offset (first->ref, a->ref, &offset)\n+\t  || !offset.is_constant (&a->offset))\n \treturn false;\n \n       enum ref_step_type a_step;\n@@ -1187,7 +1191,7 @@ valid_initializer_p (struct data_reference *ref,\n \t\t     unsigned distance, struct data_reference *root)\n {\n   aff_tree diff, base, step;\n-  widest_int off;\n+  poly_widest_int off;\n \n   /* Both REF and ROOT must be accessing the same object.  */\n   if (!operand_equal_p (DR_BASE_ADDRESS (ref), DR_BASE_ADDRESS (root), 0))\n@@ -1215,7 +1219,7 @@ valid_initializer_p (struct data_reference *ref,\n   if (!aff_combination_constant_multiple_p (&diff, &step, &off))\n     return false;\n \n-  if (off != distance)\n+  if (maybe_ne (off, distance))\n     return false;\n \n   return true;"}, {"sha": "440215b7818f2c50c1a04ead2bbc3c78edd72868", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=cc8bea091633989bef6d665c40193a9e255ceb81", "patch": "@@ -693,7 +693,7 @@ addr_to_parts (tree type, aff_tree *addr, tree iv_cand, tree base_hint,\n   parts->index = NULL_TREE;\n   parts->step = NULL_TREE;\n \n-  if (addr->offset != 0)\n+  if (maybe_ne (addr->offset, 0))\n     parts->offset = wide_int_to_tree (sizetype, addr->offset);\n   else\n     parts->offset = NULL_TREE;"}, {"sha": "5555f46eb305879278906ec6cc056356766ed5ac", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea091633989bef6d665c40193a9e255ceb81/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=cc8bea091633989bef6d665c40193a9e255ceb81", "patch": "@@ -4229,7 +4229,7 @@ struct ainc_cost_data\n };\n \n static comp_cost\n-get_address_cost_ainc (HOST_WIDE_INT ainc_step, HOST_WIDE_INT ainc_offset,\n+get_address_cost_ainc (poly_int64 ainc_step, poly_int64 ainc_offset,\n \t\t       machine_mode addr_mode, machine_mode mem_mode,\n \t\t       addr_space_t as, bool speed)\n {\n@@ -4303,13 +4303,13 @@ get_address_cost_ainc (HOST_WIDE_INT ainc_step, HOST_WIDE_INT ainc_offset,\n     }\n \n   HOST_WIDE_INT msize = GET_MODE_SIZE (mem_mode);\n-  if (ainc_offset == 0 && msize == ainc_step)\n+  if (known_eq (ainc_offset, 0) && known_eq (msize, ainc_step))\n     return comp_cost (data->costs[AINC_POST_INC], 0);\n-  if (ainc_offset == 0 && msize == -ainc_step)\n+  if (known_eq (ainc_offset, 0) && known_eq (msize, -ainc_step))\n     return comp_cost (data->costs[AINC_POST_DEC], 0);\n-  if (ainc_offset == msize && msize == ainc_step)\n+  if (known_eq (ainc_offset, msize) && known_eq (msize, ainc_step))\n     return comp_cost (data->costs[AINC_PRE_INC], 0);\n-  if (ainc_offset == -msize && msize == -ainc_step)\n+  if (known_eq (ainc_offset, -msize) && known_eq (msize, -ainc_step))\n     return comp_cost (data->costs[AINC_PRE_DEC], 0);\n \n   return infinite_cost;\n@@ -4359,7 +4359,7 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n \t}\n       if (ok_with_ratio_p || ok_without_ratio_p)\n \t{\n-\t  if (aff_inv->offset != 0)\n+\t  if (maybe_ne (aff_inv->offset, 0))\n \t    {\n \t      parts.offset = wide_int_to_tree (sizetype, aff_inv->offset);\n \t      /* Addressing mode \"base + index [<< scale] + offset\".  */\n@@ -4392,10 +4392,12 @@ get_address_cost (struct ivopts_data *data, struct iv_use *use,\n     }\n   else\n     {\n-      if (can_autoinc && ratio == 1 && cst_and_fits_in_hwi (cand->iv->step))\n+      poly_int64 ainc_step;\n+      if (can_autoinc\n+\t  && ratio == 1\n+\t  && ptrdiff_tree_p (cand->iv->step, &ainc_step))\n \t{\n-\t  HOST_WIDE_INT ainc_step = int_cst_value (cand->iv->step);\n-\t  HOST_WIDE_INT ainc_offset = (aff_inv->offset).to_shwi ();\n+\t  poly_int64 ainc_offset = (aff_inv->offset).force_shwi ();\n \n \t  if (stmt_after_increment (data->current_loop, cand, use->stmt))\n \t    ainc_offset += ainc_step;\n@@ -4955,7 +4957,7 @@ iv_elimination_compare_lt (struct ivopts_data *data,\n   aff_combination_scale (&tmpa, -1);\n   aff_combination_add (&tmpb, &tmpa);\n   aff_combination_add (&tmpb, &nit);\n-  if (tmpb.n != 0 || tmpb.offset != 1)\n+  if (tmpb.n != 0 || maybe_ne (tmpb.offset, 1))\n     return false;\n \n   /* Finally, check that CAND->IV->BASE - CAND->IV->STEP * A does not\n@@ -6852,7 +6854,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n   unshare_aff_combination (&aff_var);\n   /* Prefer CSE opportunity than loop invariant by adding offset at last\n      so that iv_uses have different offsets can be CSEed.  */\n-  widest_int offset = aff_inv.offset;\n+  poly_widest_int offset = aff_inv.offset;\n   aff_inv.offset = 0;\n \n   gimple_seq stmt_list = NULL, seq = NULL;"}]}