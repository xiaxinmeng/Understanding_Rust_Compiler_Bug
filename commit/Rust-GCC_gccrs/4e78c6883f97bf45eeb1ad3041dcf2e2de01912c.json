{"sha": "4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3OGM2ODgzZjk3YmY0NWVlYjFhZDMwNDFkY2YyZTJkZTAxOTEyYw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2019-10-09T01:14:02Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-10-09T01:14:02Z"}, "message": "use call-clobbered reg to disalign the stack\n\nSome x86 tests of stack realignment, that disaligned the stack with\npushes and pops, failed when the compiler was configured to tune for a\ntarget that preferred to accumulate outgoing arguments: the stack\nspace is reserved before the asm push, the call sequence overwrites\nthe saved register, and then the asm pop restores the overwritten\nvalue.  Since that's a call-preserved register in 32-bit mode, it\nshould be preserved unchanged, but isn't.\n\nMerely changing the register to a call-clobbered one would be enough,\nbut the tests would remain fragile and prone to failure due to other\noptimizations, so I arranged for the compiler to be made aware of the\nregister used for the push and the pop, so it won't use it for\nsomething else, and forced the function to use a frame pointer, so\nthat it won't use stack pointer offsets for local variables: the\noffsets would likely be wrong between the asm push and pop.\n\n\nfor  gcc/testsuite/ChangeLog\n\n\t* gcc.target/i386/20060512-1.c (sse2_test): Use a\n\tcall-clobbered register variable for stack-disaligning push\n\tand pop.  Require a frame pointer.\n\t* gcc.target/i386/20060512-3.c (sse2_test): Likewise.\n\nFrom-SVN: r276751", "tree": {"sha": "f1501df656c903e2d98944667905fc93de3969ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1501df656c903e2d98944667905fc93de3969ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/comments", "author": null, "committer": null, "parents": [{"sha": "ffbef318488159e807d93c0cf43f0d72417e5dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffbef318488159e807d93c0cf43f0d72417e5dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffbef318488159e807d93c0cf43f0d72417e5dfc"}], "stats": {"total": 30, "additions": 20, "deletions": 10}, "files": [{"sha": "a1f3966f79196995ee089d099805dd4e00b96c64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "patch": "@@ -1,3 +1,10 @@\n+2019-10-08  Alexandre Oliva <oliva@adacore.com>\n+\n+\t* gcc.target/i386/20060512-1.c (sse2_test): Use a\n+\tcall-clobbered register variable for stack-disaligning push\n+\tand pop.  Require a frame pointer.\n+\t* gcc.target/i386/20060512-3.c (sse2_test): Likewise.\n+\n 2019-10-08  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/92001"}, {"sha": "fe95f6d52fa9881ccedb3795e0dbed33c4056904", "filename": "gcc/testsuite/gcc.target/i386/20060512-1.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c?ref=4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "patch": "@@ -7,11 +7,11 @@\n #include <emmintrin.h>\n \n #ifdef __x86_64__\n-# define PUSH \"pushq %rsi\"\n-# define POP \"popq %rsi\"\n+# define REG \"rcx\"\n+# define WIDTH \"q\"\n #else\n-# define PUSH \"pushl %esi\"\n-# define POP \"popl %esi\"\n+# define REG \"ecx\"\n+# define WIDTH \"l\"\n #endif\n \n __m128i __attribute__ ((__noinline__))\n@@ -30,13 +30,15 @@ self_aligning_function (int x, int y)\n int g_1 = 20;\n int g_2 = 22;\n \n-static void\n+static void __attribute__ ((__optimize__ (\"-fno-omit-frame-pointer\")))\n sse2_test (void)\n {\n   int result;\n-  asm (PUSH);                  /* Misalign runtime stack.  */\n+  register int __attribute__ ((__mode__ (__word__))) reg asm (REG);\n+  asm volatile (\"push\" WIDTH \"\\t%0\"  /* Disalign runtime stack.  */\n+\t\t: : \"r\" (reg) : \"memory\");\n   result = self_aligning_function (g_1, g_2);\n   if (result != 42)\n     abort ();\n-  asm (POP);\n+  asm volatile (\"pop\" WIDTH \"\\t%0\" : \"=r\" (reg));\n }"}, {"sha": "0cebb47f6e9bc9ed3602139ccdd5251e395598a6", "filename": "gcc/testsuite/gcc.target/i386/20060512-3.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e78c6883f97bf45eeb1ad3041dcf2e2de01912c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-3.c?ref=4e78c6883f97bf45eeb1ad3041dcf2e2de01912c", "patch": "@@ -23,13 +23,14 @@ self_aligning_function (int x, int y)\n int g_1 = 20;\n int g_2 = 22;\n \n-static void\n+static void __attribute__ ((__optimize__ (\"-fno-omit-frame-pointer\")))\n sse2_test (void)\n {\n   int result;\n-  asm (\"pushl %esi\");\t\t/* Disalign runtime stack.  */\n+  register int reg asm (\"ecx\");\n+  asm (\"pushl\\t%0\": : \"r\" (reg) : \"memory\"); /* Disalign runtime stack.  */\n   result = self_aligning_function (g_1, g_2);\n   if (result != 42)\n     abort ();\n-  asm (\"popl %esi\");\n+  asm (\"popl\\t%0\" : \"=r\" (reg));\n }"}]}