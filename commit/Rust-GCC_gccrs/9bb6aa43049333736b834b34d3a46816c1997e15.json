{"sha": "9bb6aa43049333736b834b34d3a46816c1997e15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiNmFhNDMwNDkzMzM3MzZiODM0YjM0ZDNhNDY4MTZjMTk5N2UxNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-04-13T09:21:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-04-13T09:21:22Z"}, "message": "re PR tree-optimization/21258 (Teach VRP to pick up a constant from case label.)\n\n2007-04-13  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/21258\n\t* tree-vrp.c (compare_case_labels): New helper.\n\t(find_switch_asserts): New function.\n\t(find_assert_locations): Call it for SWITCH_EXPRs.\n\n\t* gcc.dg/tree-ssa/vrp34.c: New testcase.\n\nFrom-SVN: r123778", "tree": {"sha": "3863c3f46faaf518cc32d01591e8d032b20ccd93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3863c3f46faaf518cc32d01591e8d032b20ccd93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb6aa43049333736b834b34d3a46816c1997e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb6aa43049333736b834b34d3a46816c1997e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb6aa43049333736b834b34d3a46816c1997e15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb6aa43049333736b834b34d3a46816c1997e15/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27ac40e2a09b03d11470e714203f509cbf4078f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ac40e2a09b03d11470e714203f509cbf4078f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ac40e2a09b03d11470e714203f509cbf4078f8"}], "stats": {"total": 171, "additions": 165, "deletions": 6}, "files": [{"sha": "825f0445c92b676619defcc021c7dac198b2780a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bb6aa43049333736b834b34d3a46816c1997e15", "patch": "@@ -1,3 +1,10 @@\n+2007-04-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/21258\n+\t* tree-vrp.c (compare_case_labels): New helper.\n+\t(find_switch_asserts): New function.\n+\t(find_assert_locations): Call it for SWITCH_EXPRs.\n+\n 2007-04-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (X87_FLOAT_MODE_P): Check for TARGET_80387."}, {"sha": "53aed21fc8d73a2fdfc7ffcb110214b434bf7dbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9bb6aa43049333736b834b34d3a46816c1997e15", "patch": "@@ -1,3 +1,8 @@\n+2007-04-13  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/21258\n+\t* gcc.dg/tree-ssa/vrp34.c: New testcase.\n+\n 2007-04-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* gfortran.dg/c_by_val.c: Use GCC extensions instead of including"}, {"sha": "fd92eca655768f29290e0bfaf7b178e9c3d791fe", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp34.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp34.c?ref=9bb6aa43049333736b834b34d3a46816c1997e15", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+void bar (void);\n+\n+void\n+foo (int a)\n+{\n+  switch (a)\n+    {\n+    case 4:\n+      if (a >= 3)\n+        if (a <= 5)\n+          bar ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Folding predicate a_. > 2 to 1\" \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump \"Folding predicate a_. <= 5 to 1\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "9beddbf068b955a14d378085dd57857c58b8eeeb", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 133, "deletions": 6, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb6aa43049333736b834b34d3a46816c1997e15/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9bb6aa43049333736b834b34d3a46816c1997e15", "patch": "@@ -3593,7 +3593,7 @@ static bool find_assert_locations (basic_block bb);\n \n /* Determine whether the outgoing edges of BB should receive an\n    ASSERT_EXPR for each of the operands of BB's LAST statement.\n-   The last statement of BB must be a COND_EXPR or a SWITCH_EXPR.\n+   The last statement of BB must be a COND_EXPR.\n \n    If any of the sub-graphs rooted at BB have an interesting use of\n    the predicate operands, an assert location node is added to the\n@@ -3666,6 +3666,131 @@ find_conditional_asserts (basic_block bb, tree last)\n   return need_assert;\n }\n \n+/* Compare two case labels sorting first by the destination label uid\n+   and then by the case value.  */\n+\n+static int\n+compare_case_labels (const void *p1, const void *p2)\n+{\n+  tree case1 = *(tree *)p1;\n+  tree case2 = *(tree *)p2;\n+  unsigned int uid1 = DECL_UID (CASE_LABEL (case1));\n+  unsigned int uid2 = DECL_UID (CASE_LABEL (case2));\n+\n+  if (uid1 < uid2)\n+    return -1;\n+  else if (uid1 == uid2)\n+    {\n+      /* Make sure the default label is first in a group.  */\n+      if (!CASE_LOW (case1))\n+\treturn -1;\n+      else if (!CASE_LOW (case2))\n+\treturn 1;\n+      else\n+        return tree_int_cst_compare (CASE_LOW (case1), CASE_LOW (case2));\n+    }\n+  else\n+    return 1;\n+}\n+\n+/* Determine whether the outgoing edges of BB should receive an\n+   ASSERT_EXPR for each of the operands of BB's LAST statement.\n+   The last statement of BB must be a SWITCH_EXPR.\n+\n+   If any of the sub-graphs rooted at BB have an interesting use of\n+   the predicate operands, an assert location node is added to the\n+   list of assertions for the corresponding operands.  */\n+\n+static bool\n+find_switch_asserts (basic_block bb, tree last)\n+{\n+  bool need_assert;\n+  block_stmt_iterator bsi;\n+  tree op, cond;\n+  edge e;\n+  tree vec = SWITCH_LABELS (last), vec2;\n+  size_t n = TREE_VEC_LENGTH (vec);\n+  unsigned int idx;\n+\n+  need_assert = false;\n+  bsi = bsi_for_stmt (last);\n+  op = TREE_OPERAND (last, 0);\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return false;\n+\n+  /* Build a vector of case labels sorted by destination label.  */\n+  vec2 = make_tree_vec (n);\n+  for (idx = 0; idx < n; ++idx)\n+    TREE_VEC_ELT (vec2, idx) = TREE_VEC_ELT (vec, idx);\n+  qsort (&TREE_VEC_ELT (vec2, 0), n, sizeof (tree), compare_case_labels);\n+\n+  for (idx = 0; idx < n; ++idx)\n+    {\n+      tree min, max;\n+      tree cl = TREE_VEC_ELT (vec2, idx);\n+\n+      min = CASE_LOW (cl);\n+      max = CASE_HIGH (cl);\n+\n+      /* If there are multiple case labels with the same destination\n+\t we need to combine them to a single value range for the edge.  */\n+      if (idx + 1 < n\n+\t  && CASE_LABEL (cl) == CASE_LABEL (TREE_VEC_ELT (vec2, idx + 1)))\n+\t{\n+\t  /* Skip labels until the last of the group.  */\n+\t  do {\n+\t    ++idx;\n+\t  } while (idx < n\n+\t\t   && CASE_LABEL (cl) == CASE_LABEL (TREE_VEC_ELT (vec2, idx)));\n+\t  --idx;\n+\n+\t  /* Pick up the maximum of the case label range.  */\n+\t  if (CASE_HIGH (TREE_VEC_ELT (vec2, idx)))\n+\t    max = CASE_HIGH (TREE_VEC_ELT (vec2, idx));\n+\t  else\n+\t    max = CASE_LOW (TREE_VEC_ELT (vec2, idx));\n+\t}\n+\n+      /* Nothing to do if the range includes the default label until we\n+\t can register anti-ranges.  */\n+      if (min == NULL_TREE)\n+\tcontinue;\n+\n+      /* Find the edge to register the assert expr on.  */\n+      e = find_edge (bb, label_to_block (CASE_LABEL (cl)));\n+\n+      /* Remove the SWITCH_EXPR operand from the FOUND_IN_SUBGRAPH bitmap.\n+\t Otherwise, when we finish traversing each of the sub-graphs, we\n+\t won't know whether the variables were found in the sub-graphs or\n+\t if they had been found in a block upstream from BB.  */\n+      RESET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n+\n+      /* Traverse the strictly dominated sub-graph rooted at E->DEST\n+\t to determine if any of the operands in the conditional\n+\t predicate are used.  */\n+      if (e->dest != bb)\n+\tneed_assert |= find_assert_locations (e->dest);\n+\n+      /* Register the necessary assertions for the operand in the\n+\t SWITCH_EXPR.  */\n+      cond = build2 (max ? GE_EXPR : EQ_EXPR, boolean_type_node,\n+\t\t     op, fold_convert (TREE_TYPE (op), min));\n+      need_assert |= register_edge_assert_for (op, e, bsi, cond);\n+      if (max)\n+\t{\n+\t  cond = build2 (LE_EXPR, boolean_type_node,\n+\t\t\t op, fold_convert (TREE_TYPE (op), max));\n+\t  need_assert |= register_edge_assert_for (op, e, bsi, cond);\n+\t}\n+    }\n+\n+  /* Finally, indicate that we have found the operand in the\n+     SWITCH_EXPR.  */\n+  SET_BIT (found_in_subgraph, SSA_NAME_VERSION (op));\n+\n+  return need_assert;\n+}\n+\n \n /* Traverse all the statements in block BB looking for statements that\n    may generate useful assertions for the SSA names in their operand.\n@@ -3728,9 +3853,7 @@ find_conditional_asserts (basic_block bb, tree last)\n \n    If this function returns true, then it means that there are names\n    for which we need to generate ASSERT_EXPRs.  Those assertions are\n-   inserted by process_assert_insertions.\n-\n-   TODO.  Handle SWITCH_EXPR.  */\n+   inserted by process_assert_insertions.  */\n \n static bool\n find_assert_locations (basic_block bb)\n@@ -3853,6 +3976,11 @@ find_assert_locations (basic_block bb)\n       && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n     need_assert |= find_conditional_asserts (bb, last);\n \n+  if (last\n+      && TREE_CODE (last) == SWITCH_EXPR\n+      && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n+    need_assert |= find_switch_asserts (bb, last);\n+\n   /* Recurse into the dominator children of BB.  */\n   for (son = first_dom_son (CDI_DOMINATORS, bb);\n        son;\n@@ -4759,8 +4887,7 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n \n   *taken_edge_p = NULL;\n \n-  /* FIXME.  Handle SWITCH_EXPRs.  But first, the assert pass needs to\n-     add ASSERT_EXPRs for them.  */\n+  /* FIXME.  Handle SWITCH_EXPRs.  */\n   if (TREE_CODE (stmt) == SWITCH_EXPR)\n     return SSA_PROP_VARYING;\n "}]}