{"sha": "93b826f0fd2c0520a092322b50027974a9b9a2c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiODI2ZjBmZDJjMDUyMGEwOTIzMjJiNTAwMjc5NzRhOWI5YTJjNQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2011-03-09T00:21:53Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2011-03-09T00:21:53Z"}, "message": "Fix PR 47755 fallout\n\nFrom-SVN: r170802", "tree": {"sha": "cc7fa828658e47431ee1599ef6e39eb12c1b5b52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc7fa828658e47431ee1599ef6e39eb12c1b5b52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93b826f0fd2c0520a092322b50027974a9b9a2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b826f0fd2c0520a092322b50027974a9b9a2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93b826f0fd2c0520a092322b50027974a9b9a2c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b826f0fd2c0520a092322b50027974a9b9a2c5/comments", "author": null, "committer": null, "parents": [{"sha": "84fdf81b8aa9c4fef1a43b852eb125dd124eb6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fdf81b8aa9c4fef1a43b852eb125dd124eb6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fdf81b8aa9c4fef1a43b852eb125dd124eb6e1"}], "stats": {"total": 181, "additions": 179, "deletions": 2}, "files": [{"sha": "a92e4a62922bcb6cb1f54c7c9fc2b4d1c20981f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93b826f0fd2c0520a092322b50027974a9b9a2c5", "patch": "@@ -1,3 +1,10 @@\n+2011-03-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/47755\n+\t* config/rs6000/rs6000.c (easy_altivec_constant): Correctly handle\n+\tV2DI/V2DF constants.  Only all 0's or all 1's are easy.\n+\t(output_vec_const_move): Ditto.\n+\n 2011-03-08  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/mips/mips.h (PREFERRED_RELOAD_CLASS): Remove macro."}, {"sha": "b6d1a94caeacfb5e5adee376e8877cc8e106c940", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=93b826f0fd2c0520a092322b50027974a9b9a2c5", "patch": "@@ -4946,6 +4946,29 @@ easy_altivec_constant (rtx op, enum machine_mode mode)\n   else if (mode != GET_MODE (op))\n     return false;\n \n+  /* V2DI/V2DF was added with VSX.  Only allow 0 and all 1's as easy\n+     constants.  */\n+  if (mode == V2DFmode)\n+    return zero_constant (op, mode);\n+\n+  if (mode == V2DImode)\n+    {\n+      /* In case the compiler is built 32-bit, CONST_DOUBLE constants are not\n+\t easy.  */\n+      if (GET_CODE (CONST_VECTOR_ELT (op, 0)) != CONST_INT\n+\t  || GET_CODE (CONST_VECTOR_ELT (op, 1)) != CONST_INT)\n+\treturn false;\n+\n+      if (zero_constant (op, mode))\n+\treturn true;\n+\n+      if (INTVAL (CONST_VECTOR_ELT (op, 0)) == -1\n+\t  && INTVAL (CONST_VECTOR_ELT (op, 1)) == -1)\n+\treturn true;\n+\n+      return false;\n+    }\n+\n   /* Start with a vspltisw.  */\n   step = GET_MODE_NUNITS (mode) / 4;\n   copies = 1;\n@@ -5022,8 +5045,16 @@ output_vec_const_move (rtx *operands)\n   vec = operands[1];\n   mode = GET_MODE (dest);\n \n-  if (TARGET_VSX && zero_constant (vec, mode))\n-    return \"xxlxor %x0,%x0,%x0\";\n+  if (TARGET_VSX)\n+    {\n+      if (zero_constant (vec, mode))\n+\treturn \"xxlxor %x0,%x0,%x0\";\n+\n+      if (mode == V2DImode\n+\t  && INTVAL (CONST_VECTOR_ELT (vec, 0)) == -1\n+\t  && INTVAL (CONST_VECTOR_ELT (vec, 1)) == -1)\n+\treturn \"vspltisw %0,-1\";\n+    }\n \n   if (TARGET_ALTIVEC)\n     {"}, {"sha": "78730576e0e4c7a0c3221af3f0b03d5a6261e34a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=93b826f0fd2c0520a092322b50027974a9b9a2c5", "patch": "@@ -1,3 +1,8 @@\n+2011-03-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/47755\n+\t* gcc.target/powerpc/pr47755-2.c: New file.\n+\n 2011-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* go.test/go-test.exp: For goroutines.go test if GCCGO_RUN_ALL_TESTS"}, {"sha": "2180efdbe42d97c15a5155903861a595ccad84f1", "filename": "gcc/testsuite/gcc.target/powerpc/pr47755-2.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr47755-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b826f0fd2c0520a092322b50027974a9b9a2c5/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr47755-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr47755-2.c?ref=93b826f0fd2c0520a092322b50027974a9b9a2c5", "patch": "@@ -0,0 +1,134 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7\" } */\n+\n+/* PR 47755: Make sure compiler generates correct code for various\n+   V2DI constants.  */\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+\n+static int num_errors;\n+#define FAIL_LL(A, B) \\\n+  (num_errors++, printf (\"Fail (%i, %i)\\n\", (int)(A), (int)(B)))\n+#define FAIL_I(A, B, C, D) \\\n+  (num_errors++, \\\n+  printf (\"Fail (%i, %i, %i, %i)\\n\", (int)(A), (int)(B), (int)(C), (int)(D)))\n+\n+#else\n+extern void abort (void) __attribute__((__noreturn__));\n+#define FAIL_LL(A, B) abort ()\n+#define FAIL_I(A, B, C, D) abort ()\n+#endif\n+\n+static test_ll (vector long long, long long, long long) __attribute__((__noinline__));\n+\n+static\n+test_ll (vector long long v, long long a, long long b)\n+{\n+  union {\n+    vector long long v;\n+    long long ll[2];\n+  } u;\n+\n+  u.v = v;\n+  if (u.ll[0] != a && u.ll[1] != b)\n+    FAIL_LL (a, b);\n+}\n+\n+#define TEST_LL(A,B) test_ll ((vector long long){ (A), (B) }, (A), (B))\n+\n+static test_i (vector int, int, int, int, int) __attribute__((__noinline__));\n+\n+static\n+test_i (vector int v, int a, int b, int c, int d)\n+{\n+  union {\n+    vector int v;\n+    int i[4];\n+  } u;\n+\n+  u.v = v;\n+  if (u.i[0] != a && u.i[1] != b && u.i[2] != c && u.i[3] != d)\n+    FAIL_I (a, b, c, d);\n+}\n+\n+#define TEST_I(A,B,C,D) \\\n+  test_i ((vector int){ (A), (B), (C), (D) }, (A), (B), (C), (D))\n+\n+int\n+main (void)\n+{\n+  TEST_LL (-2LL, -2LL);\n+  TEST_LL (-2LL, -1LL);\n+  TEST_LL (-2LL,  0LL);\n+  TEST_LL (-2LL,  1LL);\n+  TEST_LL (-2LL,  2LL);\n+\n+  TEST_LL (-1LL, -2LL);\n+  TEST_LL (-1LL, -1LL);\n+  TEST_LL (-1LL,  0LL);\n+  TEST_LL (-1LL,  1LL);\n+  TEST_LL (-1LL,  2LL);\n+\n+  TEST_LL (0LL, -2LL);\n+  TEST_LL (0LL, -1LL);\n+  TEST_LL (0LL,  0LL);\n+  TEST_LL (0LL,  1LL);\n+  TEST_LL (0LL,  2LL);\n+\n+  TEST_LL (1LL, -2LL);\n+  TEST_LL (1LL, -1LL);\n+  TEST_LL (1LL,  0LL);\n+  TEST_LL (1LL,  1LL);\n+  TEST_LL (1LL,  2LL);\n+\n+  TEST_LL (2LL, -2LL);\n+  TEST_LL (2LL, -1LL);\n+  TEST_LL (2LL,  0LL);\n+  TEST_LL (2LL,  1LL);\n+  TEST_LL (2LL,  2LL);\n+\n+  /* We could use VSPLTI instructions for these tests.  */\n+  TEST_LL (0x0101010101010101LL, 0x0101010101010101LL);\n+  TEST_LL (0x0001000100010001LL, 0x0001000100010001LL);\n+  TEST_LL (0x0000000100000001LL, 0x0000000100000001LL);\n+\n+  TEST_LL (0x0404040404040404LL, 0x0404040404040404LL);\n+  TEST_LL (0x0004000400040004LL, 0x0004000400040004LL);\n+  TEST_LL (0x0000000400000004LL, 0x0000000400000004LL);\n+\n+  TEST_LL (0xf8f8f8f8f8f8f8f8LL, 0xf8f8f8f8f8f8f8f8LL);\n+  TEST_LL (0xfff8fff8fff8fff8LL, 0xfff8fff8fff8fff8LL);\n+  TEST_LL (0xfffffff8fffffff8LL, 0xfffffff8fffffff8LL);\n+\n+  /* We could use VSPLTI instructions for these tests.  */\n+  TEST_I (-2, -2, -2, -2);\n+  TEST_I (-1, -1, -1, -1);\n+  TEST_I ( 0,  0,  0,  0);\n+  TEST_I ( 1,  1,  1,  1);\n+  TEST_I ( 2,  2,  2,  2);\n+\n+  TEST_I (0x01010101, 0x01010101, 0x01010101, 0x01010101);\n+  TEST_I (0x00010001, 0x00010001, 0x00010001, 0x00010001);\n+\n+  TEST_I (0x02020202, 0x02020202, 0x02020202, 0x02020202);\n+  TEST_I (0x00020002, 0x00020002, 0x00020002, 0x00020002);\n+\n+  TEST_I (0xf8f8f8f8, 0xf8f8f8f8, 0xf8f8f8f8, 0xf8f8f8f8);\n+  TEST_I (0xfff8fff8, 0xfff8fff8, 0xfff8fff8, 0xfff8fff8);\n+\n+  /* non-easy constants.  */\n+  TEST_I (-2, -1,  0,  1);\n+  TEST_I ( 1,  0, -1, -2);\n+\n+  TEST_I (-1, -1,  0,  0);\n+  TEST_I ( 0,  0, -1, -1);\n+\n+#ifdef DEBUG\n+  printf (\"%d error%s\\n\", num_errors, (num_errors == 1) ? \"\" : \"s\");\n+#endif\n+\n+  return 0;\n+};"}]}