{"sha": "35ca685200830626e5abd623f65a850649beace2", "node_id": "C_kwDOANBUbNoAKDM1Y2E2ODUyMDA4MzA2MjZlNWFiZDYyM2Y2NWE4NTA2NDliZWFjZTI", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-18T15:20:47Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-23T08:56:23Z"}, "message": "macros: Add base functions to check for follow-set ambiguities\n\nRust does not allow for all macro fragments to be followed by any kind\nof tokens: We must check tokens following those fragments that might\ncontain restrictions and make sure that they are allowed, conforming to\nthe Macro Follow-Set Ambiguity specification\n\nCo-authored-by: philberty <philip.herron@embecosm.com>\n\nmacro-frag-spec: Transform enum into a class\n\nThis allows us to add methods on the fragment specifier, which are\nneeded to make sure that follow-set ambiguities are respected\n\ntests: Add tests for forbidden follow-up tokens\n\nThis also fix a test that was previously accepted but invalid: rustc\nalso rejected it", "tree": {"sha": "aed3eeb63995c6cced4bdeed0f327ceaf3d618e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed3eeb63995c6cced4bdeed0f327ceaf3d618e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35ca685200830626e5abd623f65a850649beace2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ca685200830626e5abd623f65a850649beace2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ca685200830626e5abd623f65a850649beace2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ca685200830626e5abd623f65a850649beace2/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc6e405912c83aee41efd3015d9157cdbe9134fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6e405912c83aee41efd3015d9157cdbe9134fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6e405912c83aee41efd3015d9157cdbe9134fe"}], "stats": {"total": 436, "additions": 336, "deletions": 100}, "files": [{"sha": "d15c09cfa2d0e5fcfa4b8bf964acf9b6b5ce8644", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -76,45 +76,6 @@ get_string_in_delims (std::string str_input, DelimType delim_type)\n   gcc_unreachable ();\n }\n \n-// Converts a frag spec enum item to a string form.\n-std::string\n-frag_spec_to_str (MacroFragSpec frag_spec)\n-{\n-  switch (frag_spec)\n-    {\n-    case BLOCK:\n-      return \"block\";\n-    case EXPR:\n-      return \"expr\";\n-    case IDENT:\n-      return \"ident\";\n-    case ITEM:\n-      return \"item\";\n-    case LIFETIME:\n-      return \"lifetime\";\n-    case LITERAL:\n-      return \"literal\";\n-    case META:\n-      return \"meta\";\n-    case PAT:\n-      return \"pat\";\n-    case PATH:\n-      return \"path\";\n-    case STMT:\n-      return \"stmt\";\n-    case TT:\n-      return \"tt\";\n-    case TY:\n-      return \"ty\";\n-    case VIS:\n-      return \"vis\";\n-    case INVALID:\n-      return \"INVALID_FRAG_SPEC\";\n-    default:\n-      return \"ERROR_MARK_STRING - unknown frag spec\";\n-    }\n-}\n-\n enum AttrMode\n {\n   OUTER,\n@@ -2396,7 +2357,7 @@ LifetimeParam::as_string () const\n std::string\n MacroMatchFragment::as_string () const\n {\n-  return \"$\" + ident + \": \" + frag_spec_to_str (frag_spec);\n+  return \"$\" + ident + \": \" + frag_spec.as_string ();\n }\n \n std::string"}, {"sha": "478d3ab2f1132846ff0e0e5c535073fca8cc773b", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 127, "deletions": 54, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -28,60 +28,128 @@ namespace AST {\n // Decls as definitions moved to rust-ast.h\n class MacroItem;\n \n-enum MacroFragSpec\n+class MacroFragSpec\n {\n-  BLOCK,\n-  EXPR,\n-  IDENT,\n-  ITEM,\n-  LIFETIME,\n-  LITERAL,\n-  META,\n-  PAT,\n-  PATH,\n-  STMT,\n-  TT,\n-  TY,\n-  VIS,\n-  INVALID // not really a specifier, but used to mark invalid one passed in\n-};\n+public:\n+  enum Kind\n+  {\n+    BLOCK,\n+    EXPR,\n+    IDENT,\n+    ITEM,\n+    LIFETIME,\n+    LITERAL,\n+    META,\n+    PAT,\n+    PATH,\n+    STMT,\n+    TT,\n+    TY,\n+    VIS,\n+    INVALID // not really a specifier, but used to mark invalid one passed in\n+  };\n \n-inline MacroFragSpec\n-get_frag_spec_from_str (std::string str)\n-{\n-  if (str == \"block\")\n-    return BLOCK;\n-  else if (str == \"expr\")\n-    return EXPR;\n-  else if (str == \"ident\")\n-    return IDENT;\n-  else if (str == \"item\")\n-    return ITEM;\n-  else if (str == \"lifetime\")\n-    return LIFETIME;\n-  else if (str == \"literal\")\n-    return LITERAL;\n-  else if (str == \"meta\")\n-    return META;\n-  else if (str == \"pat\")\n-    return PAT;\n-  else if (str == \"path\")\n-    return PATH;\n-  else if (str == \"stmt\")\n-    return STMT;\n-  else if (str == \"tt\")\n-    return TT;\n-  else if (str == \"ty\")\n-    return TY;\n-  else if (str == \"vis\")\n-    return VIS;\n-  else\n-    {\n-      // error_at(\"invalid string '%s' used as fragment specifier\",\n-      // str->c_str());\n-      return INVALID;\n-    }\n-}\n+  MacroFragSpec (Kind kind) : kind (kind) {}\n+\n+  static MacroFragSpec get_frag_spec_from_str (const std::string &str)\n+  {\n+    if (str == \"block\")\n+      return MacroFragSpec (BLOCK);\n+    else if (str == \"expr\")\n+      return MacroFragSpec (EXPR);\n+    else if (str == \"ident\")\n+      return MacroFragSpec (IDENT);\n+    else if (str == \"item\")\n+      return MacroFragSpec (ITEM);\n+    else if (str == \"lifetime\")\n+      return MacroFragSpec (LIFETIME);\n+    else if (str == \"literal\")\n+      return MacroFragSpec (LITERAL);\n+    else if (str == \"meta\")\n+      return MacroFragSpec (META);\n+    else if (str == \"pat\" || str == \"pat_param\")\n+      return MacroFragSpec (PAT);\n+    else if (str == \"path\")\n+      return MacroFragSpec (PATH);\n+    else if (str == \"stmt\")\n+      return MacroFragSpec (STMT);\n+    else if (str == \"tt\")\n+      return MacroFragSpec (TT);\n+    else if (str == \"ty\")\n+      return MacroFragSpec (TY);\n+    else if (str == \"vis\")\n+      return MacroFragSpec (VIS);\n+    else\n+      {\n+\t// error_at(\"invalid string '%s' used as fragment specifier\",\n+\t// str->c_str()));\n+\treturn MacroFragSpec (INVALID);\n+      }\n+  }\n+\n+  Kind get_kind () const { return kind; }\n+  bool is_error () const { return kind == Kind::INVALID; }\n+\n+  // Converts a frag spec enum item to a string form.\n+  std::string as_string () const\n+  {\n+    switch (kind)\n+      {\n+      case BLOCK:\n+\treturn \"block\";\n+      case EXPR:\n+\treturn \"expr\";\n+      case IDENT:\n+\treturn \"ident\";\n+      case ITEM:\n+\treturn \"item\";\n+      case LIFETIME:\n+\treturn \"lifetime\";\n+      case LITERAL:\n+\treturn \"literal\";\n+      case META:\n+\treturn \"meta\";\n+      case PAT:\n+\treturn \"pat\";\n+      case PATH:\n+\treturn \"path\";\n+      case STMT:\n+\treturn \"stmt\";\n+      case TT:\n+\treturn \"tt\";\n+      case TY:\n+\treturn \"ty\";\n+      case VIS:\n+\treturn \"vis\";\n+      case INVALID:\n+\treturn \"INVALID_FRAG_SPEC\";\n+      default:\n+\treturn \"ERROR_MARK_STRING - unknown frag spec\";\n+      }\n+  }\n+\n+  bool has_follow_set_restrictions ()\n+  {\n+    switch (kind)\n+      {\n+      case EXPR:\n+      case STMT:\n+\t// FIXME: Add the following cases once we can handle them properly\n+\t// in `is_match_compatible()`\n+\t// case PAT:\n+\t// // case PAT_PARAM: FIXME: Doesn't <metavar>:pat_param exist?\n+\t// case PATH:\n+\t// case TY:\n+\t// case VIS:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+private:\n+  Kind kind;\n+};\n \n // A macro match that has an identifier and fragment spec\n class MacroMatchFragment : public MacroMatch\n@@ -96,12 +164,17 @@ class MacroMatchFragment : public MacroMatch\n   {}\n \n   // Returns whether macro match fragment is in an error state.\n-  bool is_error () const { return frag_spec == INVALID; }\n+  bool is_error () const\n+  {\n+    return frag_spec.get_kind () == MacroFragSpec::INVALID;\n+  }\n \n   // Creates an error state macro match fragment.\n   static MacroMatchFragment create_error (Location locus)\n   {\n-    return MacroMatchFragment (std::string (\"\"), INVALID, locus);\n+    return MacroMatchFragment (std::string (\"\"),\n+\t\t\t       MacroFragSpec (MacroFragSpec::Kind::INVALID),\n+\t\t\t       locus);\n   }\n \n   std::string as_string () const override;"}, {"sha": "35bd84a23ae1fb70ae829f9609d85ca4dcca0d14", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -439,7 +439,7 @@ bool\n MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n \t\t\t       AST::MacroMatchFragment &fragment)\n {\n-  switch (fragment.get_frag_spec ())\n+  switch (fragment.get_frag_spec ().get_kind ())\n     {\n     case AST::MacroFragSpec::EXPR:\n       parser.parse_expr ();"}, {"sha": "1d1b624e19b966719c9655c59deb8370fdbe284d", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"rust-diagnostics.h\"\n #include \"util/rust-make-unique.h\"\n+#include <algorithm>\n \n namespace Rust {\n // Left binding powers of operations.\n@@ -1767,6 +1768,13 @@ Parser<ManagedTokenSource>::parse_macro_matcher ()\n \t  return AST::MacroMatcher::create_error (t->get_locus ());\n \t}\n \n+      if (matches.size () > 0)\n+\t{\n+\t  auto &last_match = matches.back ();\n+\t  if (!is_match_compatible (*last_match, *match))\n+\t    return AST::MacroMatcher::create_error (match->get_match_locus ());\n+\t}\n+\n       matches.push_back (std::move (match));\n \n       // DEBUG\n@@ -1955,8 +1963,9 @@ Parser<ManagedTokenSource>::parse_macro_match_fragment ()\n   if (t == nullptr)\n     return nullptr;\n \n-  AST::MacroFragSpec frag = AST::get_frag_spec_from_str (t->get_str ());\n-  if (frag == AST::INVALID)\n+  AST::MacroFragSpec frag\n+    = AST::MacroFragSpec::get_frag_spec_from_str (t->get_str ());\n+  if (frag.is_error ())\n     {\n       Error error (t->get_locus (),\n \t\t   \"invalid fragment specifier %qs in fragment macro match\","}, {"sha": "16ed4a0763b9f92671dad29dc57d5b6535105b44", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -92,4 +92,145 @@ extract_module_path (const AST::AttrVec &inner_attrs,\n \n   return path;\n }\n+\n+static bool\n+peculiar_fragment_match_compatible (AST::MacroMatchFragment &last_match,\n+\t\t\t\t    AST::MacroMatch &match)\n+{\n+  static std::unordered_map<AST::MacroFragSpec::Kind, std::vector<TokenId>>\n+    follow_set = {\n+      {AST::MacroFragSpec::EXPR, {MATCH_ARROW, COMMA, SEMICOLON}},\n+      {AST::MacroFragSpec::STMT, {MATCH_ARROW, COMMA, SEMICOLON}},\n+    };\n+\n+  Location error_locus = match.get_match_locus ();\n+\n+  // There are two behaviors to handle here: If the follow-up match is a token,\n+  // we want to check if it is allowed.\n+  // If it is a fragment, repetition or matcher then we know that it will be\n+  // an error.\n+  // For repetitions and matchers we want to extract a proper location to report\n+  // the error.\n+  switch (match.get_macro_match_type ())\n+    {\n+      case AST::MacroMatch::Tok: {\n+\tauto tok = static_cast<AST::Token *> (&match);\n+\tauto &allowed_toks\n+\t  = follow_set[last_match.get_frag_spec ().get_kind ()];\n+\tauto is_valid = std::find (allowed_toks.begin (), allowed_toks.end (),\n+\t\t\t\t   tok->get_id ())\n+\t\t\t!= allowed_toks.end ();\n+\tif (!is_valid)\n+\t  // FIXME: Add hint about allowed fragments\n+\t  rust_error_at (tok->get_match_locus (),\n+\t\t\t \"token %<%s%> is not allowed after %<%s%> fragment\",\n+\t\t\t tok->get_str ().c_str (),\n+\t\t\t last_match.get_frag_spec ().as_string ().c_str ());\n+\treturn is_valid;\n+      }\n+      break;\n+      case AST::MacroMatch::Repetition: {\n+\tauto repetition = static_cast<AST::MacroMatchRepetition *> (&match);\n+\tauto &matches = repetition->get_matches ();\n+\tif (!matches.empty ())\n+\t  error_locus = matches.front ()->get_match_locus ();\n+\tbreak;\n+      }\n+      case AST::MacroMatch::Matcher: {\n+\tauto matcher = static_cast<AST::MacroMatcher *> (&match);\n+\tauto &matches = matcher->get_matches ();\n+\tif (!matches.empty ())\n+\t  error_locus = matches.front ()->get_match_locus ();\n+\tbreak;\n+      }\n+    default:\n+      break;\n+    }\n+\n+  rust_error_at (error_locus, \"fragment not allowed after %<%s%> fragment\",\n+\t\t last_match.get_frag_spec ().as_string ().c_str ());\n+\n+  return false;\n+}\n+\n+/**\n+ * Avoid UB by calling .front() and .back() on empty containers...\n+ */\n+\n+template <typename T>\n+static T *\n+get_back_ptr (std::vector<std::unique_ptr<T>> &values)\n+{\n+  if (values.empty ())\n+    return nullptr;\n+\n+  return values.back ().get ();\n+}\n+\n+template <typename T>\n+static T *\n+get_front_ptr (std::vector<std::unique_ptr<T>> &values)\n+{\n+  if (values.empty ())\n+    return nullptr;\n+\n+  return values.front ().get ();\n+}\n+\n+bool\n+is_match_compatible (AST::MacroMatch &last_match, AST::MacroMatch &match)\n+{\n+  AST::MacroMatch *new_last = nullptr;\n+\n+  // We want to \"extract\" the concerning matches. In cases such as matchers and\n+  // repetitions, we actually store multiple matchers, but are only concerned\n+  // about the follow-set ambiguities of certain elements.\n+  // There are some cases where we can short-circuit the algorithm: There will\n+  // never be restrictions on token literals, or on certain fragments which do\n+  // not have a set of follow-restrictions.\n+\n+  switch (last_match.get_macro_match_type ())\n+    {\n+      // This is our main stop condition: When we are finally looking at the\n+      // last match (or its actual last component), and it is a fragment, it\n+      // may contain some follow up restrictions.\n+      case AST::MacroMatch::Fragment: {\n+\tauto fragment = static_cast<AST::MacroMatchFragment *> (&last_match);\n+\tif (fragment->get_frag_spec ().has_follow_set_restrictions ())\n+\t  return peculiar_fragment_match_compatible (*fragment, match);\n+\telse\n+\t  return true;\n+      }\n+      case AST::MacroMatch::Repetition: {\n+\t// A repetition on the left hand side means we want to make sure the\n+\t// last match of the repetition is compatible with the new match\n+\tauto repetition\n+\t  = static_cast<AST::MacroMatchRepetition *> (&last_match);\n+\tnew_last = get_back_ptr (repetition->get_matches ());\n+\t// If there are no matches in the matcher, then it can be followed by\n+\t// anything\n+\tif (!new_last)\n+\t  return true;\n+\tbreak;\n+      }\n+      case AST::MacroMatch::Matcher: {\n+\t// Likewise for another matcher\n+\tauto matcher = static_cast<AST::MacroMatcher *> (&last_match);\n+\tnew_last = get_back_ptr (matcher->get_matches ());\n+\t// If there are no matches in the matcher, then it can be followed by\n+\t// anything\n+\tif (!new_last)\n+\t  return true;\n+\tbreak;\n+      }\n+    case AST::MacroMatch::Tok:\n+      return true;\n+    }\n+\n+  rust_assert (new_last);\n+\n+  // We check recursively until we find a terminating condition\n+  // FIXME: Does expansion depth/limit matter here?\n+  return is_match_compatible (*new_last, match);\n+}\n } // namespace Rust"}, {"sha": "c86d194c1593cac21ff8ffde8572968c4a2be020", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -702,6 +702,18 @@ template <typename ManagedTokenSource> class Parser\n std::string\n extract_module_path (const AST::AttrVec &inner_attrs,\n \t\t     const AST::AttrVec &outer_attrs, const std::string &name);\n+\n+/**\n+ * Check if a MacroMatch is allowed to follow the last parsed MacroMatch.\n+ *\n+ * @param last_match Last matcher parsed before the current match\n+ * @param match Current matcher to check\n+ *\n+ * @return true if the follow-up is valid, false otherwise\n+ */\n+bool\n+is_match_compatible (AST::MacroMatch &last_match,\n+\t\t     AST::MacroMatch &current_match);\n } // namespace Rust\n \n // as now template, include implementations of all methods"}, {"sha": "c477d979ec6541e0f2b13f58ba6dd178c45d9fca", "filename": "gcc/testsuite/rust/compile/macro27.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro27.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro27.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro27.rs?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! m {\n+    ($a:expr tok) => {\n+        // { dg-error \"token .tok. is not allowed after .expr. fragment\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"required first macro rule in macro rules definition could not be parsed\" \"\" { target *-*-* } .-2 }\n+        // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-3 }\n+        $a\n+    };\n+}"}, {"sha": "ff557da4f2c31e6b1afb3d32ab8748d428618c3a", "filename": "gcc/testsuite/rust/compile/macro28.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro28.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro28.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro28.rs?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! m {\n+    ($a:expr $(tok $es:expr)*) => {\n+        // { dg-error \"fragment not allowed after .expr. fragment\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"required first macro rule in macro rules definition could not be parsed\" \"\" { target *-*-* } .-2 }\n+        // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-3 }\n+        $a\n+    };\n+}"}, {"sha": "b26ddb13b4166edf6e6ec8600d863324b3e299c1", "filename": "gcc/testsuite/rust/compile/macro29.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro29.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro29.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro29.rs?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! m {\n+    ($($es:expr)* tok) => {\n+        // { dg-error \"token .tok. is not allowed after .expr. fragment\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"required first macro rule in macro rules definition could not be parsed\" \"\" { target *-*-* } .-2 }\n+        // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-3 }\n+        $a\n+    };\n+}"}, {"sha": "da4645a434b39848cc1974bf2e1ec861d931b66d", "filename": "gcc/testsuite/rust/compile/macro30.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro30.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro30.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro30.rs?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! m {\n+    ($e:expr $f:expr) => {\n+        // { dg-error \"fragment not allowed after .expr. fragment\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"required first macro rule in macro rules definition could not be parsed\" \"\" { target *-*-* } .-2 }\n+        // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-3 }\n+        $e\n+    };\n+}"}, {"sha": "28d84ac43f1f309f75cdf3d96f07f83aa8121b1f", "filename": "gcc/testsuite/rust/compile/macro31.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro31.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro31.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro31.rs?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -0,0 +1,8 @@\n+macro_rules! m {\n+    ($($e:expr)* $($f:expr)*) => {\n+        // { dg-error \"fragment not allowed after .expr. fragment\" \"\" { target *-*-* } .-1 }\n+        // { dg-error \"required first macro rule in macro rules definition could not be parsed\" \"\" { target *-*-* } .-2 }\n+        // { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-3 }\n+        $e\n+    };\n+}"}, {"sha": "97317a0879ea72fc02662641db671d4d84f73bb1", "filename": "gcc/testsuite/rust/execute/torture/macros20.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros20.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35ca685200830626e5abd623f65a850649beace2/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros20.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmacros20.rs?ref=35ca685200830626e5abd623f65a850649beace2", "patch": "@@ -1,14 +1,14 @@\n macro_rules! add {\n-    ($e:expr big_tok $($es:expr) big_tok *) => {\n-        $e + add!($($es) big_tok *)\n+    ($e:expr , $($es:expr) , *) => {\n+        $e + add!($($es) , *)\n     };\n     ($e:expr) => {\n         $e\n     };\n }\n \n fn main() -> i32 {\n-    let a = add!(15 big_tok 2 big_tok 9); // 26\n+    let a = add!(15, 2, 9); // 26\n \n     a - 26\n }"}]}