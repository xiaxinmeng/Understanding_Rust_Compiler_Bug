{"sha": "89ca6d794e9bb950640839d1235fc881495e8df8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljYTZkNzk0ZTliYjk1MDY0MDgzOWQxMjM1ZmM4ODE0OTVlOGRmOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-16T11:42:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-16T11:42:47Z"}, "message": "flags.h (TYPE_OVERFLOW_WRAPS, [...]): Move to tree.h.\n\n\t* flags.h (TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED,\n\tTYPE_OVERFLOW_TRAPS, POINTER_TYPE_OVERFLOW_UNDEFINED): Move to tree.h.\n\t* tree.h (TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED,\n\tTYPE_OVERFLOW_TRAPS, POINTER_TYPE_OVERFLOW_UNDEFINED): New home.\n\nFrom-SVN: r189520", "tree": {"sha": "224306b6c32199c76b98de195429d90ca198c346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/224306b6c32199c76b98de195429d90ca198c346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89ca6d794e9bb950640839d1235fc881495e8df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ca6d794e9bb950640839d1235fc881495e8df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ca6d794e9bb950640839d1235fc881495e8df8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ca6d794e9bb950640839d1235fc881495e8df8/comments", "author": null, "committer": null, "parents": [{"sha": "7ee2468b9274dd08bac00909fbbe8308f92c68e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee2468b9274dd08bac00909fbbe8308f92c68e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee2468b9274dd08bac00909fbbe8308f92c68e5"}], "stats": {"total": 57, "additions": 32, "deletions": 25}, "files": [{"sha": "771bc0d1b385f701b46c4dc210ed7934143cf008", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ca6d794e9bb950640839d1235fc881495e8df8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ca6d794e9bb950640839d1235fc881495e8df8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89ca6d794e9bb950640839d1235fc881495e8df8", "patch": "@@ -1,3 +1,10 @@\n+2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* flags.h (TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED,\n+\tTYPE_OVERFLOW_TRAPS, POINTER_TYPE_OVERFLOW_UNDEFINED): Move to tree.h.\n+\t* tree.h (TYPE_OVERFLOW_WRAPS, TYPE_OVERFLOW_UNDEFINED,\n+\tTYPE_OVERFLOW_TRAPS, POINTER_TYPE_OVERFLOW_UNDEFINED): New home.\n+\n 2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* system.h (dump_file): Do not define."}, {"sha": "141185befc7fc72071e9717cf3cf9505459e0379", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ca6d794e9bb950640839d1235fc881495e8df8/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ca6d794e9bb950640839d1235fc881495e8df8/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=89ca6d794e9bb950640839d1235fc881495e8df8", "patch": "@@ -106,30 +106,6 @@ extern int dump_for_graph;\n #define abi_version_at_least(N) \\\n   (flag_abi_version == 0 || flag_abi_version >= (N))\n \n-/* True if overflow wraps around for the given integral type.  That\n-   is, TYPE_MAX + 1 == TYPE_MIN.  */\n-#define TYPE_OVERFLOW_WRAPS(TYPE) \\\n-  (TYPE_UNSIGNED (TYPE) || flag_wrapv)\n-\n-/* True if overflow is undefined for the given integral type.  We may\n-   optimize on the assumption that values in the type never overflow.\n-\n-   IMPORTANT NOTE: Any optimization based on TYPE_OVERFLOW_UNDEFINED\n-   must issue a warning based on warn_strict_overflow.  In some cases\n-   it will be appropriate to issue the warning immediately, and in\n-   other cases it will be appropriate to simply set a flag and let the\n-   caller decide whether a warning is appropriate or not.  */\n-#define TYPE_OVERFLOW_UNDEFINED(TYPE) \\\n-  (!TYPE_UNSIGNED (TYPE) && !flag_wrapv && !flag_trapv && flag_strict_overflow)\n-\n-/* True if overflow for the given integral type should issue a\n-   trap.  */\n-#define TYPE_OVERFLOW_TRAPS(TYPE) \\\n-  (!TYPE_UNSIGNED (TYPE) && flag_trapv)\n-\n-/* True if pointer types have undefined overflow.  */\n-#define POINTER_TYPE_OVERFLOW_UNDEFINED (flag_strict_overflow)\n-\n /* Whether to emit an overflow warning whose code is C.  */\n #define issue_strict_overflow_warning(c) (warn_strict_overflow >= (int) (c))\n "}, {"sha": "cc840ae496eb3c703b3b2f31de23f96cd4b2c409", "filename": "gcc/tree.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ca6d794e9bb950640839d1235fc881495e8df8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ca6d794e9bb950640839d1235fc881495e8df8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=89ca6d794e9bb950640839d1235fc881495e8df8", "patch": "@@ -1,4 +1,4 @@\n-/* Front-end tree definitions for GNU compiler.\n+/* Definitions for the ubiquitous 'tree' type for GNU compilers.\n    Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n@@ -1348,6 +1348,30 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n /* In integral and pointer types, means an unsigned type.  */\n #define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->base.unsigned_flag)\n \n+/* True if overflow wraps around for the given integral type.  That\n+   is, TYPE_MAX + 1 == TYPE_MIN.  */\n+#define TYPE_OVERFLOW_WRAPS(TYPE) \\\n+  (TYPE_UNSIGNED (TYPE) || flag_wrapv)\n+\n+/* True if overflow is undefined for the given integral type.  We may\n+   optimize on the assumption that values in the type never overflow.\n+\n+   IMPORTANT NOTE: Any optimization based on TYPE_OVERFLOW_UNDEFINED\n+   must issue a warning based on warn_strict_overflow.  In some cases\n+   it will be appropriate to issue the warning immediately, and in\n+   other cases it will be appropriate to simply set a flag and let the\n+   caller decide whether a warning is appropriate or not.  */\n+#define TYPE_OVERFLOW_UNDEFINED(TYPE) \\\n+  (!TYPE_UNSIGNED (TYPE) && !flag_wrapv && !flag_trapv && flag_strict_overflow)\n+\n+/* True if overflow for the given integral type should issue a\n+   trap.  */\n+#define TYPE_OVERFLOW_TRAPS(TYPE) \\\n+  (!TYPE_UNSIGNED (TYPE) && flag_trapv)\n+\n+/* True if pointer types have undefined overflow.  */\n+#define POINTER_TYPE_OVERFLOW_UNDEFINED (flag_strict_overflow)\n+\n /* Nonzero in a VAR_DECL or STRING_CST means assembler code has been written.\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n    This is interesting in an inline function, since it might not need"}]}