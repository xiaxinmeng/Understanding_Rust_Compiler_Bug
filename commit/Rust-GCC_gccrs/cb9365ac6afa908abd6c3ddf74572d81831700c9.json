{"sha": "cb9365ac6afa908abd6c3ddf74572d81831700c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I5MzY1YWM2YWZhOTA4YWJkNmMzZGRmNzQ1NzJkODE4MzE3MDBjOQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-11-16T01:56:54Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-11-16T01:56:54Z"}, "message": "PR 60324 VLA related fixes to random number generator.\n\n2014-11-16  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libfortran/60324\n\t* intrinsics/random.c (kiss_size): Rename to KISS_SIZE, make it a\n\tmacro instead of a variable.\n\t(random_seed_i4): Make seed correct size, remove assert, KISS_SIZE\n\trelated changes.\n\t(random_seed_i8): KISS_SIZE related changes.\n\nFrom-SVN: r217623", "tree": {"sha": "134087fa9bfaa7fd3b70c724e7b7815ddf1e8b1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/134087fa9bfaa7fd3b70c724e7b7815ddf1e8b1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb9365ac6afa908abd6c3ddf74572d81831700c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9365ac6afa908abd6c3ddf74572d81831700c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9365ac6afa908abd6c3ddf74572d81831700c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9365ac6afa908abd6c3ddf74572d81831700c9/comments", "author": null, "committer": null, "parents": [{"sha": "431db45ab855781518d62dbcc2bd599e2a190bcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431db45ab855781518d62dbcc2bd599e2a190bcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431db45ab855781518d62dbcc2bd599e2a190bcb"}], "stats": {"total": 54, "additions": 28, "deletions": 26}, "files": [{"sha": "a389a4231b5850e61f177e14d1b794c17832e47d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9365ac6afa908abd6c3ddf74572d81831700c9/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9365ac6afa908abd6c3ddf74572d81831700c9/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=cb9365ac6afa908abd6c3ddf74572d81831700c9", "patch": "@@ -1,3 +1,12 @@\n+2014-11-16  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/60324\n+\t* intrinsics/random.c (kiss_size): Rename to KISS_SIZE, make it a\n+\tmacro instead of a variable.\n+\t(random_seed_i4): Make seed correct size, remove assert, KISS_SIZE\n+\trelated changes.\n+\t(random_seed_i8): KISS_SIZE related changes.\n+\n 2014-11-13  Marek Polacek  <polacek@redhat.com>\n \n \t* intrinsics/access.c: Include <stdlib.h>."}, {"sha": "d2510b2ad145748c513054f92c1497ea4179de0b", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9365ac6afa908abd6c3ddf74572d81831700c9/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9365ac6afa908abd6c3ddf74572d81831700c9/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=cb9365ac6afa908abd6c3ddf74572d81831700c9", "patch": "@@ -224,7 +224,7 @@ KISS algorithm.  */\n    z=0,c=0 and z=2^32-1,c=698769068\n    should be avoided.  */\n \n-/* Any modifications to the seeds that change kiss_size below need to be\n+/* Any modifications to the seeds that change KISS_SIZE below need to be\n    reflected in check.c (gfc_check_random_seed) to enable correct\n    compile-time checking of PUT size for the RANDOM_SEED intrinsic.  */\n \n@@ -250,7 +250,7 @@ static GFC_UINTEGER_4 kiss_default_seed[] = {\n #endif\n };\n \n-static const GFC_INTEGER_4 kiss_size = sizeof(kiss_seed)/sizeof(kiss_seed[0]);\n+#define KISS_SIZE (sizeof(kiss_seed)/sizeof(kiss_seed[0]))\n \n static GFC_UINTEGER_4 * const kiss_seed_1 = kiss_seed;\n static GFC_UINTEGER_4 * const kiss_seed_2 = kiss_seed + 4;\n@@ -665,12 +665,7 @@ unscramble_seed (unsigned char *dest, unsigned char *src, int size)\n void\n random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n-  int i;\n-\n-#define KISS_MAX_SIZE 12\n-  unsigned char seed[4 * KISS_MAX_SIZE];\n-  _Static_assert (kiss_size <= KISS_MAX_SIZE,\n-\t\t  \"kiss_size must <= KISS_MAX_SIZE\");\n+  unsigned char seed[4 * KISS_SIZE];\n \n   __gthread_mutex_lock (&random_lock);\n \n@@ -681,11 +676,11 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n   /* From the standard: \"If no argument is present, the processor assigns\n      a processor-dependent value to the seed.\"  */\n   if (size == NULL && put == NULL && get == NULL)\n-      for (i = 0; i < kiss_size; i++)\n+      for (size_t i = 0; i < KISS_SIZE; i++)\n \tkiss_seed[i] = kiss_default_seed[i];\n \n   if (size != NULL)\n-    *size = kiss_size;\n+    *size = KISS_SIZE;\n \n   if (put != NULL)\n     {\n@@ -694,18 +689,18 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < kiss_size)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) KISS_SIZE)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  We copy the seed given by the user.  */\n-      for (i = 0; i < kiss_size; i++)\n+      for (size_t i = 0; i < KISS_SIZE; i++)\n \tmemcpy (seed + i * sizeof(GFC_UINTEGER_4),\n-\t\t&(put->base_addr[(kiss_size - 1 - i) * GFC_DESCRIPTOR_STRIDE(put,0)]),\n+\t\t&(put->base_addr[(KISS_SIZE - 1 - i) * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof(GFC_UINTEGER_4));\n \n       /* We put it after scrambling the bytes, to paper around users who\n \t provide seeds with quality only in the lower or upper part.  */\n-      scramble_seed ((unsigned char *) kiss_seed, seed, 4*kiss_size);\n+      scramble_seed ((unsigned char *) kiss_seed, seed, 4 * KISS_SIZE);\n     }\n \n   /* Return the seed to GET data.  */\n@@ -716,15 +711,15 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < kiss_size)\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) KISS_SIZE)\n \truntime_error (\"Array size of GET is too small.\");\n \n       /* Unscramble the seed.  */\n-      unscramble_seed (seed, (unsigned char *) kiss_seed, 4*kiss_size);\n+      unscramble_seed (seed, (unsigned char *) kiss_seed, 4 * KISS_SIZE);\n \n       /*  Then copy it back to the user variable.  */\n-      for (i = 0; i < kiss_size; i++)\n-\tmemcpy (&(get->base_addr[(kiss_size - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n+      for (size_t i = 0; i < KISS_SIZE; i++)\n+\tmemcpy (&(get->base_addr[(KISS_SIZE - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n                seed + i * sizeof(GFC_UINTEGER_4),\n                sizeof(GFC_UINTEGER_4));\n     }\n@@ -737,8 +732,6 @@ iexport(random_seed_i4);\n void\n random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n {\n-  int i;\n-\n   __gthread_mutex_lock (&random_lock);\n \n   /* Check that we only have one argument present.  */\n@@ -748,11 +741,11 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n   /* From the standard: \"If no argument is present, the processor assigns\n      a processor-dependent value to the seed.\"  */\n   if (size == NULL && put == NULL && get == NULL)\n-      for (i = 0; i < kiss_size; i++)\n+      for (size_t i = 0; i < KISS_SIZE; i++)\n \tkiss_seed[i] = kiss_default_seed[i];\n \n   if (size != NULL)\n-    *size = kiss_size / 2;\n+    *size = KISS_SIZE / 2;\n \n   if (put != NULL)\n     {\n@@ -761,11 +754,11 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n         runtime_error (\"Array rank of PUT is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(put,0) < kiss_size / 2)\n+      if (GFC_DESCRIPTOR_EXTENT(put,0) < (index_type) KISS_SIZE / 2)\n         runtime_error (\"Array size of PUT is too small.\");\n \n       /*  This code now should do correct strides.  */\n-      for (i = 0; i < kiss_size / 2; i++)\n+      for (size_t i = 0; i < KISS_SIZE / 2; i++)\n \tmemcpy (&kiss_seed[2*i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof (GFC_UINTEGER_8));\n     }\n@@ -778,11 +771,11 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n \truntime_error (\"Array rank of GET is not 1.\");\n \n       /* If the array is too small, abort.  */\n-      if (GFC_DESCRIPTOR_EXTENT(get,0) < kiss_size / 2)\n+      if (GFC_DESCRIPTOR_EXTENT(get,0) < (index_type) KISS_SIZE / 2)\n \truntime_error (\"Array size of GET is too small.\");\n \n       /*  This code now should do correct strides.  */\n-      for (i = 0; i < kiss_size / 2; i++)\n+      for (size_t i = 0; i < KISS_SIZE / 2; i++)\n \tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &kiss_seed[2*i],\n \t\tsizeof (GFC_UINTEGER_8));\n     }"}]}