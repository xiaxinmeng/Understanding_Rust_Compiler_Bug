{"sha": "cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwZmFmOWRjOWJkOGU3NDM4NzM1OWNiNDBmYzk1ZGU5MmVhNWUyZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-02T13:16:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-02T13:16:27Z"}, "message": "i386.c (pentium4_cost, [...]): Update 32bit memcpy/memset decriptors.\n\n\t* config/i386/i386.c (pentium4_cost, nocona_cost): Update\n\t32bit memcpy/memset decriptors.\n\t(decide_alg): With -minline-all-stringops and sizes that are best\n\tto be copied via libcall still work hard enough to pick non-libcall\n\tstrategy.\n\nCo-Authored-By: Uros Bizjak <ubizjak@gmail.com>\n\nFrom-SVN: r119445", "tree": {"sha": "eb2cf06e6c30f37e6af172fab8aa6a30af765618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb2cf06e6c30f37e6af172fab8aa6a30af765618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f/comments", "author": null, "committer": null, "parents": [{"sha": "9c134b65cd165e02a1e8a09bc14dd119f9034589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c134b65cd165e02a1e8a09bc14dd119f9034589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c134b65cd165e02a1e8a09bc14dd119f9034589"}], "stats": {"total": 33, "additions": 24, "deletions": 9}, "files": [{"sha": "eef0bb0ff0ac23db356b53e33d7e0cbb7d05e95d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f", "patch": "@@ -1,3 +1,12 @@\n+2006-11-30  Jan Hubicka  <jh@suse.cz>\n+\t    Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (pentium4_cost, nocona_cost): Update\n+\t32bit memcpy/memset decriptors.\n+\t(decide_alg): With -minline-all-stringops and sizes that are best\n+\tto be copied via libcall still work hard enough to pick non-libcall\n+\tstrategy.\n+\n 2006-12-02  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* doc/extend.texi, doc/invoke.texi, doc/md.texi: Fix typos."}, {"sha": "22ed4a9c32c300fbd431c46089057e91df792fa3", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=cc0faf9dc9bd8e74387359cb40fc95de92ea5e2f", "patch": "@@ -655,10 +655,11 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}}},\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}}}\n+  {{libcall, {{12, loop_1_byte}, {64, loop}, {-1, rep_prefix_4_byte}}},\n+   DUMMY_STRINGOP_ALGS},\n+  {{libcall, {{6, loop_1_byte}, {64, loop}, {20480, rep_prefix_4_byte},\n+   {-1, libcall}}},\n+   DUMMY_STRINGOP_ALGS},\n };\n \n static const\n@@ -712,10 +713,11 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{12, loop_1_byte}, {64, loop}, {-1, rep_prefix_4_byte}}},\n    {libcall, {{32, loop}, {20000, rep_prefix_8_byte},\n \t      {100000, unrolled_loop}, {-1, libcall}}}},\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{6, loop_1_byte}, {64, loop}, {20480, rep_prefix_4_byte},\n+   {-1, libcall}}},\n    {libcall, {{24, loop}, {64, unrolled_loop},\n \t      {8192, rep_prefix_8_byte}, {-1, libcall}}}}\n };\n@@ -13507,14 +13509,18 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t         last non-libcall inline algorithm.  */\n \t      if (TARGET_INLINE_ALL_STRINGOPS)\n \t\t{\n-\t\t  gcc_assert (alg != libcall);\n-\t\t  return alg;\n+\t\t  /* When the current size is best to be copied by a libcall,\n+\t\t     but we are still forced to inline, run the heuristic bellow\n+\t\t     that will pick code for medium sized blocks.  */\n+\t\t  if (alg != libcall)\n+\t\t    return alg;\n+\t\t  break;\n \t\t}\n \t      else\n \t\treturn algs->size[i].alg;\n \t    }\n \t}\n-      gcc_unreachable ();\n+      gcc_assert (TARGET_INLINE_ALL_STRINGOPS);\n     }\n   /* When asked to inline the call anyway, try to pick meaningful choice.\n      We look for maximal size of block that is faster to copy by hand and"}]}