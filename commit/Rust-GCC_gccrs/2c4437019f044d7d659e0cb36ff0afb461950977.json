{"sha": "2c4437019f044d7d659e0cb36ff0afb461950977", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0NDM3MDE5ZjA0NGQ3ZDY1OWUwY2IzNmZmMGFmYjQ2MTk1MDk3Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-11-19T16:18:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-11-19T16:18:39Z"}, "message": "re PR c++/67409 (tree-cfg.c dereferences a NULL pointer)\n\n\tPR c++/67409\n\t* decl.c (identify_goto): Add LOC and DIAG_KIND arguments, call\n\temit_diagnostic instead of permerror.\n\t(check_previous_goto_1): Adjust identify_goto callers, treat all\n\tcases but crossing initialization and entering scope of decl with\n\tnon-trivial dtor as unconditional hard errors.\n\t(check_goto): Use identify_goto.  Treat all cases but crossing\n\tinitialization and entering scope of decl with non-trivial dtor\n\tas unconditional hard errors.\n\n\t* g++.dg/eh/goto3.C: New test.\n\nCo-Authored-By: Manuel L\u00f3pez-Ib\u00e1\u00f1ez <manu@gcc.gnu.org>\n\nFrom-SVN: r230613", "tree": {"sha": "992607ebfe44ec436c19d44c6cfe72f68fc36911", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/992607ebfe44ec436c19d44c6cfe72f68fc36911"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c4437019f044d7d659e0cb36ff0afb461950977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4437019f044d7d659e0cb36ff0afb461950977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c4437019f044d7d659e0cb36ff0afb461950977", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c4437019f044d7d659e0cb36ff0afb461950977/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e1ce42e7224ff9ebf8ad82178894f4f0ccfb9eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1ce42e7224ff9ebf8ad82178894f4f0ccfb9eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1ce42e7224ff9ebf8ad82178894f4f0ccfb9eb"}], "stats": {"total": 110, "additions": 79, "deletions": 31}, "files": [{"sha": "1013d8fbd7929182777f9ee1860ee5fe04bff06f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c4437019f044d7d659e0cb36ff0afb461950977", "patch": "@@ -1,3 +1,16 @@\n+2015-11-19  Jakub Jelinek  <jakub@redhat.com>\n+\t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR c++/67409\n+\t* decl.c (identify_goto): Add LOC and DIAG_KIND arguments, call\n+\temit_diagnostic instead of permerror.\n+\t(check_previous_goto_1): Adjust identify_goto callers, treat all\n+\tcases but crossing initialization and entering scope of decl with\n+\tnon-trivial dtor as unconditional hard errors.\n+\t(check_goto): Use identify_goto.  Treat all cases but crossing\n+\tinitialization and entering scope of decl with non-trivial dtor\n+\tas unconditional hard errors.\n+\n 2015-11-19  Michael Matz  <matz@suse.de>\n \n \t* fwprop.c (update_uses): Use flag_checking instead of"}, {"sha": "e895c5a06ce8d756c6b0d2594a3606bb8e3cc9d9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2c4437019f044d7d659e0cb36ff0afb461950977", "patch": "@@ -2967,14 +2967,16 @@ decl_jump_unsafe (tree decl)\n   return 0;\n }\n \n-/* A subroutine of check_previous_goto_1 to identify a branch to the user.  */\n+/* A subroutine of check_previous_goto_1 and check_goto to identify a branch\n+   to the user.  */\n \n static bool\n-identify_goto (tree decl, const location_t *locus)\n+identify_goto (tree decl, location_t loc, const location_t *locus,\n+\t       diagnostic_t diag_kind)\n {\n-  bool complained = (decl\n-\t\t     ? permerror (input_location, \"jump to label %qD\", decl)\n-\t\t     : permerror (input_location, \"jump to case label\"));\n+  bool complained\n+    = (decl ? emit_diagnostic (diag_kind, loc, 0, \"jump to label %qD\", decl)\n+\t    : emit_diagnostic (diag_kind, loc, 0, \"jump to case label\"));\n   if (complained && locus)\n     inform (*locus, \"  from here\");\n   return complained;\n@@ -2991,15 +2993,17 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \t\t       bool exited_omp, const location_t *locus)\n {\n   cp_binding_level *b;\n-  bool identified = false, complained = false;\n+  bool complained = false;\n+  int identified = 0;\n   bool saw_eh = false, saw_omp = false, saw_tm = false;\n \n   if (exited_omp)\n     {\n-      complained = identify_goto (decl, locus);\n+      complained = identify_goto (decl, input_location, locus, DK_ERROR);\n       if (complained)\n \tinform (input_location, \"  exits OpenMP structured block\");\n-      identified = saw_omp = true;\n+      saw_omp = true;\n+      identified = 2;\n     }\n \n   for (b = current_binding_level; b ; b = b->level_chain)\n@@ -3016,8 +3020,9 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \n \t  if (!identified)\n \t    {\n-\t      complained = identify_goto (decl, locus);\n-\t      identified = true;\n+\t      complained = identify_goto (decl, input_location, locus,\n+\t\t\t\t\t  DK_PERMERROR);\n+\t      identified = 1;\n \t    }\n \t  if (complained)\n \t    {\n@@ -3035,10 +3040,11 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \tbreak;\n       if ((b->kind == sk_try || b->kind == sk_catch) && !saw_eh)\n \t{\n-\t  if (!identified)\n+\t  if (identified < 2)\n \t    {\n-\t      complained = identify_goto (decl, locus);\n-\t      identified = true;\n+\t      complained = identify_goto (decl, input_location, locus,\n+\t\t\t\t\t  DK_ERROR);\n+\t      identified = 2;\n \t    }\n \t  if (complained)\n \t    {\n@@ -3051,21 +3057,23 @@ check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,\n \t}\n       if (b->kind == sk_omp && !saw_omp)\n \t{\n-\t  if (!identified)\n+\t  if (identified < 2)\n \t    {\n-\t      complained = identify_goto (decl, locus);\n-\t      identified = true;\n+\t      complained = identify_goto (decl, input_location, locus,\n+\t\t\t\t\t  DK_ERROR);\n+\t      identified = 2;\n \t    }\n \t  if (complained)\n \t    inform (input_location, \"  enters OpenMP structured block\");\n \t  saw_omp = true;\n \t}\n       if (b->kind == sk_transaction && !saw_tm)\n \t{\n-\t  if (!identified)\n+\t  if (identified < 2)\n \t    {\n-\t      complained = identify_goto (decl, locus);\n-\t      identified = true;\n+\t      complained = identify_goto (decl, input_location, locus,\n+\t\t\t\t\t  DK_ERROR);\n+\t      identified = 2;\n \t    }\n \t  if (complained)\n \t    inform (input_location,\n@@ -3098,7 +3106,8 @@ void\n check_goto (tree decl)\n {\n   struct named_label_entry *ent, dummy;\n-  bool saw_catch = false, identified = false, complained = false;\n+  bool saw_catch = false, complained = false;\n+  int identified = 0;\n   tree bad;\n   unsigned ix;\n \n@@ -3141,11 +3150,13 @@ check_goto (tree decl)\n   if (ent->in_try_scope || ent->in_catch_scope || ent->in_transaction_scope\n       || ent->in_omp_scope || !vec_safe_is_empty (ent->bad_decls))\n     {\n-      complained = permerror (DECL_SOURCE_LOCATION (decl),\n-\t\t\t      \"jump to label %qD\", decl);\n-      if (complained)\n-\tinform (input_location, \"  from here\");\n-      identified = true;\n+      diagnostic_t diag_kind = DK_PERMERROR;\n+      if (ent->in_try_scope || ent->in_catch_scope\n+\t  || ent->in_transaction_scope || ent->in_omp_scope)\n+\tdiag_kind = DK_ERROR;\n+      complained = identify_goto (decl, DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t  &input_location, diag_kind);\n+      identified = 1 + (diag_kind == DK_ERROR);\n     }\n \n   FOR_EACH_VEC_SAFE_ELT (ent->bad_decls, ix, bad)\n@@ -3155,6 +3166,12 @@ check_goto (tree decl)\n       if (u > 1 && DECL_ARTIFICIAL (bad))\n \t{\n \t  /* Can't skip init of __exception_info.  */\n+\t  if (identified == 1)\n+\t    {\n+\t      complained = identify_goto (decl, DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t\t  &input_location, DK_ERROR);\n+\t      identified = 2;\n+\t    }\n \t  if (complained)\n \t    inform (DECL_SOURCE_LOCATION (bad), \"  enters catch block\");\n \t  saw_catch = true;\n@@ -3195,13 +3212,12 @@ check_goto (tree decl)\n \t    break;\n \t  if (b->kind == sk_omp)\n \t    {\n-\t      if (!identified)\n+\t      if (identified < 2)\n \t\t{\n-\t\t  complained = permerror (DECL_SOURCE_LOCATION (decl),\n-\t\t\t\t\t  \"jump to label %qD\", decl);\n-\t\t  if (complained)\n-\t\t    inform (input_location, \"  from here\");\n-\t\t  identified = true;\n+\t\t  complained = identify_goto (decl,\n+\t\t\t\t\t      DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t\t      &input_location, DK_ERROR);\n+\t\t  identified = 2;\n \t\t}\n \t      if (complained)\n \t\tinform (input_location, \"  exits OpenMP structured block\");"}, {"sha": "2d4962d74897d440f8fba05c7e37acf07147da4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c4437019f044d7d659e0cb36ff0afb461950977", "patch": "@@ -1,3 +1,8 @@\n+2015-11-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/67409\n+\t* g++.dg/eh/goto3.C: New test.\n+\n 2015-11-19  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/68431"}, {"sha": "d584ad76e816dca33f2b0387fb494525c6480a76", "filename": "gcc/testsuite/g++.dg/eh/goto3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fgoto3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c4437019f044d7d659e0cb36ff0afb461950977/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fgoto3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fgoto3.C?ref=2c4437019f044d7d659e0cb36ff0afb461950977", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/67409\n+// { dg-options \"-fpermissive\" }\n+\n+void f()\n+try\n+  {\n+    goto l2;       // { dg-message \"from here\" }\n+  l1: ;\t    // { dg-error \"jump to label 'l1'\" }\n+  } catch (...)\n+  {\n+  l2: ;\t    // { dg-error \"jump to label 'l2'\" }\n+\t\t   // { dg-message \"enters catch block\" \"\" { target *-*-*} 11 }\n+    goto l1;       // { dg-message \"from here|enters try block\" }\n+  }"}]}