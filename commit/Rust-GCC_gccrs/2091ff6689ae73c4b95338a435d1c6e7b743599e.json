{"sha": "2091ff6689ae73c4b95338a435d1c6e7b743599e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA5MWZmNjY4OWFlNzNjNGI5NTMzOGE0MzVkMWM2ZTdiNzQzNTk5ZQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2007-05-08T00:37:39Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2007-05-08T00:37:39Z"}, "message": "libiberty.h (writeargv): Declare.\n\ninclude/\n2007-05-07  Nathan Froyd  <froydnj@codesourcery.com>\n\n\t* libiberty.h (writeargv): Declare.\n\nlibiberty/\n2007-05-07  Nathan Froyd  <froydnj@codesourcery.com>\n\n\t* argv.c (writeargv): New function.\n\ngcc/\n2007-05-07  Nathan Froyd  <froydnj@codesourcery.com>\n\n\t* gcc.c (at_file_supplied): New variable.\n\t(main): Set it if we expanded argv.\n\t(do_spec_1): Pass an @-file to the linker if we were called with\n\tan @-file argument and HAVE_GNU_LD.\n\t* collect2.c (at_file_supplied): New variable.\n\t(response_file): New variable.\n\t(collect_exit): Unlink response_file if necessary.\n\t(handler): Likewise.\n\t(do_wait): Likewise.\n\t(main): Set at_file_supplied if we expanded argv.\n\t(collect_execute): Pass an @-file to subprocesses if we were called\n\twith an @-file argument.\n\t* configure.ac: Add define for HAVE_GNU_LD.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\nFrom-SVN: r124532", "tree": {"sha": "3aff327d968d66aedb2dcdc719740c083d117e18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3aff327d968d66aedb2dcdc719740c083d117e18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2091ff6689ae73c4b95338a435d1c6e7b743599e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2091ff6689ae73c4b95338a435d1c6e7b743599e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2091ff6689ae73c4b95338a435d1c6e7b743599e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2091ff6689ae73c4b95338a435d1c6e7b743599e/comments", "author": null, "committer": null, "parents": [{"sha": "decc7c8a1cd784b2edeff50ee0f30572237b71f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/decc7c8a1cd784b2edeff50ee0f30572237b71f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/decc7c8a1cd784b2edeff50ee0f30572237b71f6"}], "stats": {"total": 245, "additions": 238, "deletions": 7}, "files": [{"sha": "c57813d40314ab7f621c05c8b2407845585a326a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -1,3 +1,21 @@\n+2007-05-07  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc.c (at_file_supplied): New variable.\n+\t(main): Set it if we expanded argv.\n+\t(do_spec_1): Pass an @-file to the linker if we were called with\n+\tan @-file argument and HAVE_GNU_LD.\n+\t* collect2.c (at_file_supplied): New variable.\n+\t(response_file): New variable.\n+\t(collect_exit): Unlink response_file if necessary.\n+\t(handler): Likewise.\n+\t(do_wait): Likewise.\n+\t(main): Set at_file_supplied if we expanded argv.\n+\t(collect_execute): Pass an @-file to subprocesses if we were called\n+\twith an @-file argument.\n+\t* configure.ac: Add define for HAVE_GNU_LD.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\n 2007-05-07   Naveen.H.S  <naveen.hs@kpitcummins.com>\n \n \t* config/m32c/muldiv.md (mulhisi3_c): Limit the mode of the 2nd\n@@ -28,7 +46,7 @@\n \tashrpsi3, lshrpsi3): Update shift count constraint.\n \n 2007-05-07  Danny Smith  <dannysmith@users.sourceforge.net>\n-\t    Nathan Froyd  <froydnj@codesourcery.com\n+\t    Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR 22133\n \t* c-incpath.c (add_path): Strip trailing path separators."}, {"sha": "1ef174f534e97384e41fa719b9d4dd4544261ddb", "filename": "gcc/collect2.c", "status": "modified", "additions": 69, "deletions": 2, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -1,7 +1,7 @@\n /* Collect static initialization info into data structures that can be\n    traversed by C++ initialization and finalization routines.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n    Contributed by Chris Smith (csmith@convex.com).\n    Heavily modified by Michael Meissner (meissner@cygnus.com),\n    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).\n@@ -202,6 +202,9 @@ static struct head exports;\t\t/* list of exported symbols */\n #endif\n static struct head frame_tables;\t/* list of frame unwind info tables */\n \n+static bool at_file_supplied;\t\t/* Whether to use @file arguments */\n+static char *response_file;\t\t/* Name of any current response file */\n+\n struct obstack temporary_obstack;\n char * temporary_firstobj;\n \n@@ -302,6 +305,9 @@ collect_exit (int status)\n   if (status != 0 && output_file != 0 && output_file[0])\n     maybe_unlink (output_file);\n \n+  if (response_file)\n+    maybe_unlink (response_file);\n+\n   exit (status);\n }\n \n@@ -393,6 +399,9 @@ handler (int signo)\n     maybe_unlink (export_file);\n #endif\n \n+  if (response_file)\n+    maybe_unlink (response_file);\n+\n   signal (signo, SIG_DFL);\n   raise (signo);\n }\n@@ -793,7 +802,15 @@ main (int argc, char **argv)\n   char **object_lst;\n   const char **object;\n   int first_file;\n-  int num_c_args\t= argc+9;\n+  int num_c_args;\n+  char **old_argv;\n+\n+  old_argv = argv;\n+  expandargv (&argc, &argv);\n+  if (argv != old_argv)\n+    at_file_supplied = 1;\n+\n+  num_c_args = argc + 9;\n \n   no_demangle = !! getenv (\"COLLECT_NO_DEMANGLE\");\n \n@@ -1513,6 +1530,12 @@ do_wait (const char *prog, struct pex_obj *pex)\n       error (\"%s returned %d exit status\", prog, ret);\n       collect_exit (ret);\n     }\n+\n+  if (response_file)\n+    {\n+      unlink (response_file);\n+      response_file = NULL;\n+    }\n }\n \n \f\n@@ -1525,6 +1548,47 @@ collect_execute (const char *prog, char **argv, const char *outname,\n   struct pex_obj *pex;\n   const char *errmsg;\n   int err;\n+  char *response_arg = NULL;\n+  char *response_argv[3] ATTRIBUTE_UNUSED;\n+\n+  if (HAVE_GNU_LD && at_file_supplied && argv[0] != NULL)\n+    {\n+      /* If using @file arguments, create a temporary file and put the\n+         contents of argv into it.  Then change argv to an array corresponding\n+         to a single argument @FILE, where FILE is the temporary filename.  */\n+\n+      char **current_argv = argv + 1;\n+      char *argv0 = argv[0];\n+      int status;\n+      FILE *f;\n+\n+      /* Note: we assume argv contains at least one element; this is\n+         checked above.  */\n+\n+      response_file = make_temp_file (\"\");\n+\n+      f = fopen (response_file, \"w\");\n+\n+      if (f == NULL)\n+        fatal (\"could not open response file %s\", response_file);\n+\n+      status = writeargv (current_argv, f);\n+\n+      if (status)\n+        fatal (\"could not write to response file %s\", response_file);\n+\n+      status = fclose (f);\n+\n+      if (EOF == status)\n+        fatal (\"could not close response file %s\", response_file);\n+\n+      response_arg = concat (\"@\", response_file, NULL);\n+      response_argv[0] = argv0;\n+      response_argv[1] = response_arg;\n+      response_argv[2] = NULL;\n+\n+      argv = response_argv;\n+    }\n \n   if (vflag || debug)\n     {\n@@ -1568,6 +1632,9 @@ collect_execute (const char *prog, char **argv, const char *outname,\n \tfatal (errmsg);\n     }\n \n+  if (response_arg)\n+    free (response_arg);\n+\n   return pex;\n }\n "}, {"sha": "7864d8c066f97655fc4ef1668207e64acc7eec81", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -869,6 +869,12 @@\n #endif\n \n \n+/* Define if using GNU ld. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GNU_LD\n+#endif\n+\n+\n /* Define if you have the iconv() function. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_ICONV"}, {"sha": "b3aa2b09ce72a382452b347584bd0c8d861dadeb", "filename": "gcc/configure", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -1767,6 +1767,13 @@ _ACEOF\n \n fi\n \n+gnu_ld=`if test x\"$gnu_ld_flag\" = x\"yes\"; then echo 1; else echo 0; fi`\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_GNU_LD $gnu_ld\n+_ACEOF\n+\n+\n echo \"$as_me:$LINENO: checking whether a default linker was specified\" >&5\n echo $ECHO_N \"checking whether a default linker was specified... $ECHO_C\" >&6\n if test x\"${DEFAULT_LINKER+set}\" = x\"set\"; then\n@@ -7665,7 +7672,7 @@ if test \"${gcc_cv_prog_makeinfo_modern+set}\" = set; then\n else\n     ac_prog_version=`$MAKEINFO --version 2>&1 |\n                    sed -n 's/^.*GNU texinfo.* \\([0-9][0-9.]*\\).*$/\\1/p'`\n-  echo \"configure:7668: version of makeinfo is $ac_prog_version\" >&5\n+  echo \"configure:7675: version of makeinfo is $ac_prog_version\" >&5\n   case $ac_prog_version in\n     '')     gcc_cv_prog_makeinfo_modern=no;;\n     4.[4-9]*)"}, {"sha": "708ce1681a3fd239af3fd328a8d3cbe1ad87fc28", "filename": "gcc/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -206,6 +206,9 @@ if test x\"${DEFAULT_LINKER+set}\" = x\"set\"; then\n \t[Define to enable the use of a default linker.])\n fi\n \n+gnu_ld=`if test x\"$gnu_ld_flag\" = x\"yes\"; then echo 1; else echo 0; fi`\n+AC_DEFINE_UNQUOTED(HAVE_GNU_LD, $gnu_ld, [Define if using GNU ld.])\n+\n AC_MSG_CHECKING([whether a default linker was specified])\n if test x\"${DEFAULT_LINKER+set}\" = x\"set\"; then\n   if test x\"$gnu_ld_flag\" = x\"no\"; then"}, {"sha": "5ed41bd66ff0757b7981f64217171844314553b2", "filename": "gcc/gcc.c", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -127,6 +127,9 @@ static const char dir_separator_str[] = { DIR_SEPARATOR, 0 };\n /* Flag set by cppspec.c to 1.  */\n int is_cpp_driver;\n \n+/* Flag set to non-zero if an @file argument has been supplied to gcc.  */\n+static bool at_file_supplied;\n+\n /* Flag saying to pass the greatest exit code returned by a sub-process\n    to the calling program.  */\n static int pass_exit_codes;\n@@ -5009,9 +5012,63 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      int max = n_infiles;\n \t      max += lang_specific_extra_outfiles;\n \n-\t      for (i = 0; i < max; i++)\n-\t\tif (outfiles[i])\n-\t\t  store_arg (outfiles[i], 0, 0);\n+              if (HAVE_GNU_LD && at_file_supplied)\n+                {\n+                  /* We are going to expand `%o' to `@FILE', where FILE\n+                     is a newly-created temporary filename.  The filenames\n+                     that would usually be expanded in place of %o will be\n+                     written to the temporary file.  */\n+\n+                  char *temp_file = make_temp_file (\"\");\n+                  char *at_argument;\n+                  char **argv;\n+                  int n_files, j, status;\n+                  FILE *f;\n+\n+                  at_argument = concat (\"@\", temp_file, NULL);\n+                  store_arg (at_argument, 0, 0);\n+\n+                  /* Convert OUTFILES into a form suitable for writeargv.  */\n+\n+                  /* Determine how many are non-NULL.  */\n+                  for (n_files = 0, i = 0; i < max; i++)\n+                    n_files += outfiles[i] != NULL;\n+\n+                  argv = alloca (sizeof (char *) * (n_files + 1));\n+\n+                  /* Copy the strings over.  */\n+                  for (i = 0, j = 0; i < max; i++)\n+                    if (outfiles[i])\n+                      {\n+                        argv[j] = (char *) outfiles[i];\n+                        j++;\n+                      }\n+                  argv[j] = NULL;\n+\n+                  f = fopen (temp_file, \"w\");\n+\n+                  if (f == NULL)\n+                    fatal (\"could not open temporary response file %s\",\n+                           temp_file);\n+\n+                  status = writeargv (argv, f);\n+\n+                  if (status)\n+                    fatal (\"could not write to temporary response file %s\",\n+                           temp_file);\n+\n+                  status = fclose (f);\n+\n+                  if (EOF == status)\n+                    fatal (\"could not close temporary response file %s\",\n+                           temp_file);\n+\n+                  record_temp_file (temp_file, !save_temps_flag, !save_temps_flag);\n+                }\n+              else\n+                for (i = 0; i < max; i++)\n+\t          if (outfiles[i])\n+\t\t    store_arg (outfiles[i], 0, 0);\n \t      break;\n \t    }\n \n@@ -6093,6 +6150,7 @@ main (int argc, char **argv)\n   char *specs_file;\n   const char *p;\n   struct user_specs *uptr;\n+  char **old_argv = argv;\n \n   p = argv[0] + strlen (argv[0]);\n   while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n@@ -6103,6 +6161,10 @@ main (int argc, char **argv)\n \n   expandargv (&argc, &argv);\n \n+  /* Determine if any expansions were made.  */\n+  if (argv != old_argv)\n+    at_file_supplied = true;\n+\n   prune_options (&argc, &argv);\n \n #ifdef GCC_DRIVER_HOST_INITIALIZATION"}, {"sha": "b4112bfc7beab6b80f4564e2e07ae32316ff4c33", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -1,3 +1,7 @@\n+2007-05-07  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* libiberty.h (writeargv): Declare.\n+\n 2007-04-25  Mark Mitchell  <mark@codesourcery.com>\n \n \t* demangle.h: Change license to LGPL + exception."}, {"sha": "4e697343fb6f9095f41e9d4da1d343b4c6342c26", "filename": "include/libiberty.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/include%2Flibiberty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/include%2Flibiberty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Flibiberty.h?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -86,6 +86,10 @@ extern char **dupargv (char **) ATTRIBUTE_MALLOC;\n \n extern void expandargv PARAMS ((int *, char ***));\n \n+/* Write argv to an @-file, inserting necessary quoting.  */\n+\n+extern int writeargv PARAMS ((char **, FILE *));\n+\n /* Return the last component of a path name.  Note that we can't use a\n    prototype here because the parameter is declared inconsistently\n    across different systems, sometimes as \"char *\" and sometimes as"}, {"sha": "a4217845c7359f996917f257c4c504cae2ea2558", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -1,3 +1,7 @@\n+2007-05-07  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* argv.c (writeargv): New function.\n+\n 2007-05-05  Geoffrey Keating  <geoffk@apple.com>\n \n \t* cp-demangle.c (d_name): Detect local-source-name."}, {"sha": "a04f50d7f4910a02666a81d71317a6f4692dfca3", "filename": "libiberty/argv.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2091ff6689ae73c4b95338a435d1c6e7b743599e/libiberty%2Fargv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2091ff6689ae73c4b95338a435d1c6e7b743599e/libiberty%2Fargv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fargv.c?ref=2091ff6689ae73c4b95338a435d1c6e7b743599e", "patch": "@@ -290,6 +290,62 @@ char **buildargv (const char *input)\n \n /*\n \n+@deftypefn Extension int writeargv (const char **@var{argv}, FILE *@{file})\n+\n+Write each member of ARGV, handling all necessary quoting, to the file\n+named by FILE, separated by whitespace.  Return 0 on success, non-zero\n+if an error occurred while writing to FILE.\n+\n+@end deftypefn\n+\n+*/\n+\n+int\n+writeargv (char **argv, FILE *f)\n+{\n+  int status = 0;\n+\n+  if (f == NULL)\n+    return 1;\n+\n+  while (*argv != NULL)\n+    {\n+      int ret;\n+      const char *arg = *argv;\n+\n+      while (*arg != EOS)\n+        {\n+          char c = *arg;\n+\n+          if (ISSPACE(c) || c == '\\\\' || c == '\\'' || c == '\"')\n+            if (EOF == fputc ('\\\\', f))\n+              {\n+                status = 1;\n+                goto done;\n+              }\n+\n+          if (EOF == fputc (c, f))\n+            {\n+              status = 1;\n+              goto done;\n+            }\n+          arg++;\n+        }\n+\n+      if (EOF == fputc ('\\n', f))\n+        {\n+          status = 1;\n+          goto done;\n+        }\n+      argv++;\n+    }\n+\n+ done:\n+  return status;\n+}\n+\n+/*\n+\n @deftypefn Extension void expandargv (int *@var{argcp}, char ***@var{argvp})\n \n The @var{argcp} and @code{argvp} arguments are pointers to the usual"}]}