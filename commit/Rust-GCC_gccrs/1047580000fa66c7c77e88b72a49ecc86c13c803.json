{"sha": "1047580000fa66c7c77e88b72a49ecc86c13c803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA0NzU4MDAwMGZhNjZjN2M3N2U4OGI3MmE0OWVjYzg2YzEzYzgwMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-07-13T12:43:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T12:43:26Z"}, "message": "checks.adb (Selected_Range_Checks): Do not consider that a non-static integer bound forces the check if...\n\n2009-07-13  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* checks.adb (Selected_Range_Checks): Do not consider that a non-static\n\tinteger bound forces the check if it is compared to its subtype range.\n\nFrom-SVN: r149577", "tree": {"sha": "0ed87ab4fbc3efd45811f2204a76ffae023a0cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ed87ab4fbc3efd45811f2204a76ffae023a0cff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1047580000fa66c7c77e88b72a49ecc86c13c803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1047580000fa66c7c77e88b72a49ecc86c13c803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1047580000fa66c7c77e88b72a49ecc86c13c803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1047580000fa66c7c77e88b72a49ecc86c13c803/comments", "author": null, "committer": null, "parents": [{"sha": "2f3e235bb3e7b573f4a3fa78e1a755004f64b1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3e235bb3e7b573f4a3fa78e1a755004f64b1f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3e235bb3e7b573f4a3fa78e1a755004f64b1f6"}], "stats": {"total": 98, "additions": 70, "deletions": 28}, "files": [{"sha": "3d759ceb7c0f8fa092c94f437514e3767cde1a30", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1047580000fa66c7c77e88b72a49ecc86c13c803/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1047580000fa66c7c77e88b72a49ecc86c13c803/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1047580000fa66c7c77e88b72a49ecc86c13c803", "patch": "@@ -1,3 +1,8 @@\n+2009-07-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* checks.adb (Selected_Range_Checks): Do not consider that a non-static\n+\tinteger bound forces the check if it is compared to its subtype range.\n+\n 2009-07-13  Robert Dewar  <dewar@adacore.com>\n \n \t* prj.ads, prj-dect.adb, prj-err.ads, prj-err.adb, prj-nmsc.adb,"}, {"sha": "015256e9dad0d82a5e27f8aa2207770a6b190778", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1047580000fa66c7c77e88b72a49ecc86c13c803/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1047580000fa66c7c77e88b72a49ecc86c13c803/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=1047580000fa66c7c77e88b72a49ecc86c13c803", "patch": "@@ -6644,40 +6644,78 @@ package body Checks is\n          declare\n             T_LB       : constant Node_Id := Type_Low_Bound  (T_Typ);\n             T_HB       : constant Node_Id := Type_High_Bound (T_Typ);\n-            LB         : constant Node_Id := Low_Bound (Ck_Node);\n-            HB         : constant Node_Id := High_Bound (Ck_Node);\n-            Null_Range : Boolean;\n+            Known_T_LB : constant Boolean := Compile_Time_Known_Value (T_LB);\n+            Known_T_HB : constant Boolean := Compile_Time_Known_Value (T_HB);\n \n+            LB         : Node_Id := Low_Bound (Ck_Node);\n+            HB         : Node_Id := High_Bound (Ck_Node);\n+            Known_LB   : Boolean;\n+            Known_HB   : Boolean;\n+\n+            Null_Range     : Boolean;\n             Out_Of_Range_L : Boolean;\n             Out_Of_Range_H : Boolean;\n \n          begin\n-            --  Check for case where everything is static and we can\n-            --  do the check at compile time. This is skipped if we\n-            --  have an access type, since the access value may be null.\n-\n-            --  ??? This code can be improved since you only need to know\n-            --  that the two respective bounds (LB & T_LB or HB & T_HB)\n-            --  are known at compile time to emit pertinent messages.\n-\n-            if Compile_Time_Known_Value (LB)\n-              and then Compile_Time_Known_Value (HB)\n-              and then Compile_Time_Known_Value (T_LB)\n-              and then Compile_Time_Known_Value (T_HB)\n-              and then not Do_Access\n+            --  Compute what is known at compile time\n+\n+            if Known_T_LB and Known_T_HB then\n+               if Compile_Time_Known_Value (LB) then\n+                  Known_LB := True;\n+\n+               --  There's no point in checking that a bound is within its\n+               --  own range so pretend that it is known in this case. First\n+               --  deal with low bound.\n+\n+               elsif Ekind (Etype (LB)) = E_Signed_Integer_Subtype\n+                 and then Scalar_Range (Etype (LB)) = Scalar_Range (T_Typ)\n+               then\n+                  LB := T_LB;\n+                  Known_LB := True;\n+\n+               else\n+                  Known_LB := False;\n+               end if;\n+\n+               --  Likewise for the high bound\n+\n+               if Compile_Time_Known_Value (HB) then\n+                  Known_HB := True;\n+\n+               elsif Ekind (Etype (HB)) = E_Signed_Integer_Subtype\n+                 and then Scalar_Range (Etype (HB)) = Scalar_Range (T_Typ)\n+               then\n+                  HB := T_HB;\n+                  Known_HB := True;\n+\n+               else\n+                  Known_HB := False;\n+               end if;\n+            end if;\n+\n+            --  Check for case where everything is static and we can do the\n+            --  check at compile time. This is skipped if we have an access\n+            --  type, since the access value may be null.\n+\n+            --  ??? This code can be improved since you only need to know that\n+            --  the two respective bounds (LB & T_LB or HB & T_HB) are known at\n+            --  compile time to emit pertinent messages.\n+\n+            if Known_T_LB and Known_T_HB and Known_LB and Known_HB\n+              and not Do_Access\n             then\n                --  Floating-point case\n \n                if Is_Floating_Point_Type (S_Typ) then\n                   Null_Range := Expr_Value_R (HB) < Expr_Value_R (LB);\n                   Out_Of_Range_L :=\n                     (Expr_Value_R (LB) < Expr_Value_R (T_LB))\n-                       or else\n+                      or else\n                     (Expr_Value_R (LB) > Expr_Value_R (T_HB));\n \n                   Out_Of_Range_H :=\n                     (Expr_Value_R (HB) > Expr_Value_R (T_HB))\n-                       or else\n+                      or else\n                     (Expr_Value_R (HB) < Expr_Value_R (T_LB));\n \n                --  Fixed or discrete type case\n@@ -6686,12 +6724,12 @@ package body Checks is\n                   Null_Range := Expr_Value (HB) < Expr_Value (LB);\n                   Out_Of_Range_L :=\n                     (Expr_Value (LB) < Expr_Value (T_LB))\n-                    or else\n+                      or else\n                     (Expr_Value (LB) > Expr_Value (T_HB));\n \n                   Out_Of_Range_H :=\n                     (Expr_Value (HB) > Expr_Value (T_HB))\n-                    or else\n+                      or else\n                     (Expr_Value (HB) < Expr_Value (T_LB));\n                end if;\n \n@@ -6725,7 +6763,6 @@ package body Checks is\n                               \"static range out of bounds of}?\", T_Typ));\n                      end if;\n                   end if;\n-\n                end if;\n \n             else\n@@ -6827,15 +6864,17 @@ package body Checks is\n                          or else\n                        (Expr_Value_R (Ck_Node) > Expr_Value_R (UB));\n \n-                  else -- fixed or discrete type\n+                  --  Fixed or discrete type\n+\n+                  else\n                      Out_Of_Range :=\n                        Expr_Value (Ck_Node) < Expr_Value (LB)\n                          or else\n                        Expr_Value (Ck_Node) > Expr_Value (UB);\n                   end if;\n \n-                  --  Bounds of the type are static and the literal is\n-                  --  out of range so make a warning message.\n+                  --  Bounds of the type are static and the literal is out of\n+                  --  range so output a warning message.\n \n                   if Out_Of_Range then\n                      if No (Warn_Node) then\n@@ -6936,7 +6975,6 @@ package body Checks is\n \n                         Next (L_Index);\n                         Next (R_Index);\n-\n                      end if;\n                   end loop;\n                end;\n@@ -6963,7 +7001,6 @@ package body Checks is\n                        (Cond, Range_N_Cond (Ck_Node, T_Typ, Indx));\n                   end loop;\n                end;\n-\n             end if;\n \n          else\n@@ -7059,8 +7096,8 @@ package body Checks is\n \n          Add_Check\n            (Make_Raise_Constraint_Error (Loc,\n-              Condition => Cond,\n-              Reason    => CE_Range_Check_Failed));\n+             Condition => Cond,\n+             Reason    => CE_Range_Check_Failed));\n       end if;\n \n       return Ret_Result;"}]}