{"sha": "aa373032bfd895dc6eb671308b68163f2971ffd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEzNzMwMzJiZmQ4OTVkYzZlYjY3MTMwOGI2ODE2M2YyOTcxZmZkMg==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2009-11-23T13:29:50Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2009-11-23T13:29:50Z"}, "message": "re PR c++/14777 (typedef doesn't fully expose base class type)\n\nFix PR c++/14777\n\ngcc/cp/ChangeLog:\n\n\tPR c++/14777\n\t* cp-tree.def <TEMPLATE_INFO>: Declare new kind of tree\n\tnode.\n\t* cp-tree.h (struct tree_template_info,\n\tstruct qualified_typedef_usage_s): New.\n\t(cp_tree_node_structure_enum): add TS_CP_TEMPLATE_INFO.\n\t(union lang_tree_node): Add template_info.\n\t(TI_TEMPLATE, TI_ARGS, TI_TYPEDEFS_NEEDING_ACCESS_CHECKING):\n\tAdjust.\n\t(build_template_info): Declare.\n\t(get_types_needing_access_check): Adjust return type.\n\t(add_typedef_to_current_template_for_access_check): Declare.\n\t* cp-objcp-common.c (cp_tree_size): Handle TEMPLATE_INFO.\n\t* semantics.c (add_typedef_to_current_template_for_access_check):\n\tSplit from ...\n\t(check_accessibility_of_qualified_id): ... here.\n\t* decl.c (make_typename_type): Use it.\n\t* pt.c (build_template_info): Define.\n\t(check_explicit_specialization, find_parameter_packs_r,\n\tpush_template_decl_real, lookup_template_class,\n\tfor_each_template_parm_r, tsubst_decl, tsubst): Use\n\tbuild_template_info.\n\t(get_types_needing_access_check): Adjust return type.\n\t(append_type_to_template_for_access_check_1): Record the\n\tlocation of the usage point of the typedef. Adjust to TEMPLATE_INFO.\n\t(append_type_to_template_for_access_check): Add new location\n\tparameter. Pass it to append_type_to_template_for_access_check_1.\n\tAdjust to TEMPLATE_INFO.\n\t(perform_typedefs_access_check): Temporarily set input_location to\n\tthe usage point of the typedef we are checking access for. Adjust\n\tto new TEMPLATE_INFO tree node.\n\t* tree.c (bind_template_template_parm): Use build_template_info.\n\t* call.c (add_template_candidate_real): Likewise.\n\t* decl.c (grokfndecl): Likewise.\n\t(cp_tree_node_structure): Handle TEMPLATE_INFO.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/14777\n\t* g++.dg/template/typedef13.C: Adjust.\n\t* g++.dg/template/typedef19.C: Adjust.\n\t* g++.dg/template/typedef20.C: Adjust.\n\t* g++.dg/template/typedef22.C: New test.\n\nFrom-SVN: r154443", "tree": {"sha": "89a5ca8d719266689c7a82d65e3492021cebf4ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89a5ca8d719266689c7a82d65e3492021cebf4ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa373032bfd895dc6eb671308b68163f2971ffd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa373032bfd895dc6eb671308b68163f2971ffd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa373032bfd895dc6eb671308b68163f2971ffd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa373032bfd895dc6eb671308b68163f2971ffd2/comments", "author": null, "committer": null, "parents": [{"sha": "75d05d2ab74bf3d2fd9ceac0d7b2e45a75aae0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d05d2ab74bf3d2fd9ceac0d7b2e45a75aae0bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d05d2ab74bf3d2fd9ceac0d7b2e45a75aae0bb"}], "stats": {"total": 314, "additions": 240, "deletions": 74}, "files": [{"sha": "3f28a9499063b299a09d8face239365b74782686", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -1,3 +1,41 @@\n+2009-11-23  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/14777\n+\t* cp-tree.def <TEMPLATE_INFO>: Declare new kind of tree\n+\tnode.\n+\t* cp-tree.h (struct tree_template_info,\n+\tstruct qualified_typedef_usage_s): New.\n+\t(cp_tree_node_structure_enum): add TS_CP_TEMPLATE_INFO.\n+\t(union lang_tree_node): Add template_info.\n+\t(TI_TEMPLATE, TI_ARGS, TI_TYPEDEFS_NEEDING_ACCESS_CHECKING):\n+\tAdjust.\n+\t(build_template_info): Declare.\n+\t(get_types_needing_access_check): Adjust return type.\n+\t(add_typedef_to_current_template_for_access_check): Declare.\n+\t* cp-objcp-common.c (cp_tree_size): Handle TEMPLATE_INFO.\n+\t* semantics.c (add_typedef_to_current_template_for_access_check):\n+\tSplit from ...\n+\t(check_accessibility_of_qualified_id): ... here.\n+\t* decl.c (make_typename_type): Use it.\n+\t* pt.c (build_template_info): Define.\n+\t(check_explicit_specialization, find_parameter_packs_r,\n+\tpush_template_decl_real, lookup_template_class,\n+\tfor_each_template_parm_r, tsubst_decl, tsubst): Use\n+\tbuild_template_info.\n+\t(get_types_needing_access_check): Adjust return type.\n+\t(append_type_to_template_for_access_check_1): Record the\n+\tlocation of the usage point of the typedef. Adjust to TEMPLATE_INFO.\n+\t(append_type_to_template_for_access_check): Add new location\n+\tparameter. Pass it to append_type_to_template_for_access_check_1.\n+\tAdjust to TEMPLATE_INFO.\n+\t(perform_typedefs_access_check): Temporarily set input_location to\n+\tthe usage point of the typedef we are checking access for. Adjust\n+\tto new TEMPLATE_INFO tree node.\n+\t* tree.c (bind_template_template_parm): Use build_template_info.\n+\t* call.c (add_template_candidate_real): Likewise.\n+\t* decl.c (grokfndecl): Likewise.\n+\t(cp_tree_node_structure): Handle TEMPLATE_INFO.\n+\n 2009-11-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/9050, DR 147, DR 318"}, {"sha": "70a5b1efbf58f6c626654de2bf3c45109e88d460", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -2581,7 +2581,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n        for this will point at template <class T> template <> S<T>::f(int),\n        so that we can find the definition.  For the purposes of\n        overload resolution, however, we want the original TMPL.  */\n-    cand->template_decl = tree_cons (tmpl, targs, NULL_TREE);\n+    cand->template_decl = build_template_info (tmpl, targs);\n   else\n     cand->template_decl = DECL_TEMPLATE_INFO (fn);\n "}, {"sha": "f06ad5b86c8e6e429d791e05740431eb2d384858", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -140,6 +140,8 @@ cp_tree_size (enum tree_code code)\n \n     case LAMBDA_EXPR:           return sizeof (struct tree_lambda_expr);\n \n+    case TEMPLATE_INFO:         return sizeof (struct tree_template_info);\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "c71f94caa619df38a10f73177e41c7663270d63a", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -439,6 +439,16 @@ DEFTREECODE (LAMBDA_EXPR, \"lambda_expr\", tcc_exceptional, 0)\n    DECLTYPE_FOR_LAMBDA_RETURN is set if we want lambda return deduction.  */\n DEFTREECODE (DECLTYPE_TYPE, \"decltype_type\", tcc_type, 0)\n \n+/* Used to represent the template information stored by template\n+   specializations.\n+   The accessors are:\n+   TI_TEMPLATE the template declaration associated to the specialization\n+   TI_ARGS the arguments of the template specialization\n+   TI_TYPEDEFS_NEEDING_ACCESS_CHECKING the vector of typedefs used in\n+   the pattern of the template for which access check is needed at template\n+   instantiation time.  */\n+DEFTREECODE (TEMPLATE_INFO, \"template_info\", tcc_exceptional, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "c6de2b488d9cbac274af62c897b0ee527ae8df70", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -633,6 +633,34 @@ struct GTY (()) tree_lambda_expr\n   int discriminator;\n };\n \n+/* A (typedef,context,usage location) triplet.\n+   It represents a typedef used through a\n+   context at a given source location.\n+   e.g.\n+   struct foo {\n+     typedef int myint;\n+   };\n+\n+   struct bar {\n+    foo::myint v; // #1<-- this location.\n+   };\n+\n+   In bar, the triplet will be (myint, foo, #1).\n+   */\n+struct GTY(()) qualified_typedef_usage_s {\n+  tree typedef_decl;\n+  tree context;\n+  location_t locus;\n+};\n+typedef struct qualified_typedef_usage_s qualified_typedef_usage_t;\n+DEF_VEC_O (qualified_typedef_usage_t);\n+DEF_VEC_ALLOC_O (qualified_typedef_usage_t,gc);\n+\n+struct GTY(()) tree_template_info {\n+  struct tree_common common;\n+  VEC(qualified_typedef_usage_t,gc) *typedefs_needing_access_checking;\n+};\n+\n enum cp_tree_node_structure_enum {\n   TS_CP_GENERIC,\n   TS_CP_IDENTIFIER,\n@@ -647,6 +675,7 @@ enum cp_tree_node_structure_enum {\n   TS_CP_ARGUMENT_PACK_SELECT,\n   TS_CP_TRAIT_EXPR,\n   TS_CP_LAMBDA_EXPR,\n+  TS_CP_TEMPLATE_INFO,\n   LAST_TS_CP_ENUM\n };\n \n@@ -669,6 +698,8 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n     trait_expression;\n   struct tree_lambda_expr GTY ((tag (\"TS_CP_LAMBDA_EXPR\")))\n     lambda_expression;\n+  struct tree_template_info GTY ((tag (\"TS_CP_TEMPLATE_INFO\")))\n+    template_info;\n };\n \n \f\n@@ -2441,12 +2472,14 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    ? (ENUM_TEMPLATE_INFO (NODE) = (VAL))\t\\\n    : (CLASSTYPE_TEMPLATE_INFO (NODE) = (VAL)))\n \n-#define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n-#define TI_ARGS(NODE) (TREE_VALUE (NODE))\n+#define TI_TEMPLATE(NODE) TREE_TYPE (TEMPLATE_INFO_CHECK (NODE))\n+#define TI_ARGS(NODE) TREE_CHAIN (TEMPLATE_INFO_CHECK (NODE))\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n /* The list of typedefs - used in the template - that need\n    access checking at template instantiation time.  */\n-#define TI_TYPEDEFS_NEEDING_ACCESS_CHECKING(NODE) (TREE_CHAIN (NODE))\n+#define TI_TYPEDEFS_NEEDING_ACCESS_CHECKING(NODE) \\\n+  ((struct tree_template_info*)TEMPLATE_INFO_CHECK \\\n+     (NODE))->typedefs_needing_access_checking\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -4809,7 +4842,8 @@ extern tree check_explicit_specialization\t(tree, tree, int, int);\n extern tree make_auto\t\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);\n-extern void append_type_to_template_for_access_check (tree, tree, tree);\n+extern void append_type_to_template_for_access_check (tree, tree, tree,\n+\t\t\t\t\t\t      location_t);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n extern tree process_template_parm\t\t(tree, location_t, tree, \n@@ -4843,8 +4877,9 @@ extern bool function_parameter_pack_p\t\t(const_tree);\n extern bool function_parameter_expanded_from_pack_p (tree, tree);\n extern tree make_pack_expansion                 (tree);\n extern bool check_for_bare_parameter_packs      (tree);\n+extern tree build_template_info\t\t\t(tree, tree);\n extern tree get_template_info\t\t\t(const_tree);\n-extern tree get_types_needing_access_check\t(tree);\n+extern VEC(qualified_typedef_usage_t,gc)* get_types_needing_access_check (tree);\n extern int template_class_depth\t\t\t(tree);\n extern int is_specialization_of\t\t\t(tree, tree);\n extern bool is_specialization_of_friend\t\t(tree, tree);\n@@ -5073,6 +5108,8 @@ extern void finish_mem_initializers\t\t(tree);\n extern tree check_template_template_default_arg (tree);\n extern bool expand_or_defer_fn_1\t\t(tree);\n extern void expand_or_defer_fn\t\t\t(tree);\n+extern void add_typedef_to_current_template_for_access_check (tree, tree,\n+\t\t\t\t\t\t\t      location_t);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);\n extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t bool, bool);"}, {"sha": "db289b50197aada9a96b6df916d66597b1d8d3b5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -3089,6 +3089,11 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n   if (complain & tf_error)\n     perform_or_defer_access_check (TYPE_BINFO (context), t, t);\n \n+  /* If we are currently parsing a template and if T is a typedef accessed\n+     through CONTEXT then we need to remember and check access of T at\n+     template instantiation time.  */\n+  add_typedef_to_current_template_for_access_check (t, context, input_location);\n+\n   if (want_template)\n     return lookup_template_class (t, TREE_OPERAND (fullname, 1),\n \t\t\t\t  NULL_TREE, context,\n@@ -6713,7 +6718,7 @@ grokfndecl (tree ctype,\n \t    }\n \t  gcc_assert (TREE_CODE (fns) == IDENTIFIER_NODE\n \t\t      || TREE_CODE (fns) == OVERLOAD);\n-\t  DECL_TEMPLATE_INFO (decl) = tree_cons (fns, args, NULL_TREE);\n+\t  DECL_TEMPLATE_INFO (decl) = build_template_info (fns, args);\n \n \t  for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); t; t = TREE_CHAIN (t))\n \t    if (TREE_PURPOSE (t)\n@@ -12881,6 +12886,7 @@ cp_tree_node_structure (union lang_tree_node * t)\n     case ARGUMENT_PACK_SELECT:  return TS_CP_ARGUMENT_PACK_SELECT;\n     case TRAIT_EXPR:\t\treturn TS_CP_TRAIT_EXPR;\n     case LAMBDA_EXPR:\t\treturn TS_CP_LAMBDA_EXPR;\n+    case TEMPLATE_INFO:\t\treturn TS_CP_TEMPLATE_INFO;\n     default:\t\t\treturn TS_CP_GENERIC;\n     }\n }"}, {"sha": "2e58ed9e7574064924b49abbfdedabc2d6917eed", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -189,7 +189,8 @@ static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_pack_expansion (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_decl (tree, tree, tsubst_flags_t);\n static void perform_typedefs_access_check (tree tmpl, tree targs);\n-static void append_type_to_template_for_access_check_1 (tree, tree, tree);\n+static void append_type_to_template_for_access_check_1 (tree, tree, tree,\n+\t\t\t\t\t\t\tlocation_t);\n static hashval_t iterative_hash_template_arg (tree arg, hashval_t val);\n static tree listify (tree);\n static tree listify_autos (tree, tree);\n@@ -286,6 +287,17 @@ finish_member_template_decl (tree decl)\n   return error_mark_node;\n }\n \n+/* Create a template info node.  */\n+\n+tree\n+build_template_info (tree template_decl, tree template_args)\n+{\n+  tree result = make_node (TEMPLATE_INFO);\n+  TI_TEMPLATE (result) = template_decl;\n+  TI_ARGS (result) = template_args;\n+  return result;\n+}\n+\n /* Return the template info node corresponding to T, whatever T is.  */\n \n tree\n@@ -2492,7 +2504,7 @@ check_explicit_specialization (tree declarator,\n \t    }\n \n \t  /* Set up the DECL_TEMPLATE_INFO for DECL.  */\n-\t  DECL_TEMPLATE_INFO (decl) = tree_cons (tmpl, targs, NULL_TREE);\n+\t  DECL_TEMPLATE_INFO (decl) = build_template_info (tmpl, targs);\n \n \t  /* Inherit default function arguments from the template\n \t     DECL is specializing.  */\n@@ -2900,7 +2912,7 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       if (TYPE_TEMPLATE_INFO (t))\n-\tcp_walk_tree (&TREE_VALUE (TYPE_TEMPLATE_INFO (t)), \n+\tcp_walk_tree (&TI_ARGS (TYPE_TEMPLATE_INFO (t)),\n \t\t      &find_parameter_packs_r, ppd, ppd->visited);\n \n       *walk_subtrees = 0;\n@@ -4351,7 +4363,7 @@ push_template_decl_real (tree decl, bool is_friend)\n \t  DECL_TI_TEMPLATE (decl) = new_tmpl;\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (new_tmpl);\n \t  DECL_TEMPLATE_INFO (new_tmpl)\n-\t    = tree_cons (tmpl, args, NULL_TREE);\n+\t    = build_template_info (tmpl, args);\n \n \t  register_specialization (new_tmpl,\n \t\t\t\t   most_general_template (tmpl),\n@@ -4470,7 +4482,7 @@ template arguments to %qD do not match original template %qD\",\n   if (DECL_TEMPLATE_INFO (tmpl))\n     args = add_outermost_template_args (DECL_TI_ARGS (tmpl), args);\n \n-  info = tree_cons (tmpl, args, NULL_TREE);\n+  info = build_template_info (tmpl, args);\n \n   if (DECL_IMPLICIT_TYPEDEF_P (decl))\n     SET_TYPE_TEMPLATE_INFO (TREE_TYPE (tmpl), info);\n@@ -6448,7 +6460,7 @@ lookup_template_class (tree d1,\n \t  found = CLASSTYPE_TI_TEMPLATE (found);\n \t}\n \n-      SET_TYPE_TEMPLATE_INFO (t, tree_cons (found, arglist, NULL_TREE));\n+      SET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));\n \n       elt.spec = t;\n       slot = (spec_entry **) htab_find_slot_with_hash (type_specializations,\n@@ -6524,7 +6536,7 @@ for_each_template_parm_r (tree *tp, int *walk_subtrees, void *d)\n     case ENUMERAL_TYPE:\n       if (!TYPE_TEMPLATE_INFO (t))\n \t*walk_subtrees = 0;\n-      else if (for_each_template_parm (TREE_VALUE (TYPE_TEMPLATE_INFO (t)),\n+      else if (for_each_template_parm (TI_ARGS (TYPE_TEMPLATE_INFO (t)),\n \t\t\t\t       fn, data, pfd->visited, \n \t\t\t\t       pfd->include_nondeduced_p))\n \treturn error_mark_node;\n@@ -7380,17 +7392,24 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n static void\n perform_typedefs_access_check (tree tmpl, tree targs)\n {\n-  tree t;\n+  location_t saved_location;\n+  int i;\n+  qualified_typedef_usage_t *iter;\n \n   if (!tmpl\n       || (!CLASS_TYPE_P (tmpl)\n \t  && TREE_CODE (tmpl) != FUNCTION_DECL))\n     return;\n \n-  for (t = get_types_needing_access_check (tmpl); t; t = TREE_CHAIN (t))\n+  saved_location = input_location;\n+  for (i = 0;\n+       VEC_iterate (qualified_typedef_usage_t,\n+\t\t    get_types_needing_access_check (tmpl),\n+\t\t    i, iter);\n+\t++i)\n     {\n-      tree type_decl = TREE_PURPOSE (t);\n-      tree type_scope = TREE_VALUE (t);\n+      tree type_decl = iter->typedef_decl;\n+      tree type_scope = iter->context;\n \n       if (!type_decl || !type_scope || !CLASS_TYPE_P (type_scope))\n \tcontinue;\n@@ -7400,9 +7419,13 @@ perform_typedefs_access_check (tree tmpl, tree targs)\n       if (uses_template_parms (type_scope))\n \ttype_scope = tsubst (type_scope, targs, tf_error, NULL_TREE);\n \n+      /* Make access check error messages point to the location\n+         of the use of the typedef.  */\n+      input_location = iter->locus;\n       perform_or_defer_access_check (TYPE_BINFO (type_scope),\n \t\t\t\t     type_decl, type_decl);\n     }\n+    input_location = saved_location;\n }\n \n tree\n@@ -8654,7 +8677,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tgcc_assert (DECL_LANG_SPECIFIC (r) != 0);\n \tTREE_CHAIN (r) = NULL_TREE;\n \n-\tDECL_TEMPLATE_INFO (r) = build_tree_list (t, args);\n+\tDECL_TEMPLATE_INFO (r) = build_template_info (t, args);\n \n \tif (TREE_CODE (decl) == TYPE_DECL)\n \t  {\n@@ -8883,7 +8906,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (gen_tmpl)\n \t  {\n \t    DECL_TEMPLATE_INFO (r)\n-\t      = tree_cons (gen_tmpl, argvec, NULL_TREE);\n+\t      = build_template_info (gen_tmpl, argvec);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t    register_specialization (r, gen_tmpl, argvec, false, hash);\n \n@@ -9297,7 +9320,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    DECL_EXTERNAL (r) = 1;\n \n \t    register_specialization (r, gen_tmpl, argvec, false, hash);\n-\t    DECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n+\t    DECL_TEMPLATE_INFO (r) = build_template_info (tmpl, argvec);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t  }\n \telse if (cp_unevaluated_operand)\n@@ -9906,7 +9929,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t      return error_mark_node;\n \n \t\t    TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (r)\n-\t\t      = tree_cons (TYPE_TI_TEMPLATE (t), argvec, NULL_TREE);\n+\t\t      = build_template_info (TYPE_TI_TEMPLATE (t), argvec);\n \t\t  }\n \t      }\n \t    break;\n@@ -18079,28 +18102,29 @@ type_uses_auto (tree type)\n   return NULL_TREE;\n }\n \n-/* For a given template T, return the list of typedefs referenced\n+/* For a given template T, return the vector of typedefs referenced\n    in T for which access check is needed at T instantiation time.\n    T is either  a FUNCTION_DECL or a RECORD_TYPE.\n    Those typedefs were added to T by the function\n    append_type_to_template_for_access_check.  */\n \n-tree\n+VEC(qualified_typedef_usage_t,gc)*\n get_types_needing_access_check (tree t)\n {\n-  tree ti, result = NULL_TREE;\n+  tree ti;\n+  VEC(qualified_typedef_usage_t,gc) *result = NULL;\n \n   if (!t || t == error_mark_node)\n-    return t;\n+    return NULL;\n \n   if (!(ti = get_template_info (t)))\n-    return NULL_TREE;\n+    return NULL;\n \n   if (CLASS_TYPE_P (t)\n       || TREE_CODE (t) == FUNCTION_DECL)\n     {\n       if (!TI_TEMPLATE (ti))\n-\treturn NULL_TREE;\n+\treturn NULL;\n \n       result = TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti);\n     }\n@@ -18114,15 +18138,18 @@ get_types_needing_access_check (tree t)\n    T is either a FUNCTION_DECL or a RECORD_TYPE.\n    TYPE_DECL is a TYPE_DECL node representing a typedef.\n    SCOPE is the scope through which TYPE_DECL is accessed.\n+   LOCATION is the location of the usage point of TYPE_DECL.\n \n    This function is a subroutine of\n    append_type_to_template_for_access_check.  */\n \n static void\n append_type_to_template_for_access_check_1 (tree t,\n \t\t\t\t\t    tree type_decl,\n-\t\t\t\t\t    tree scope)\n+\t\t\t\t\t    tree scope,\n+\t\t\t\t\t    location_t location)\n {\n+  qualified_typedef_usage_t typedef_usage;\n   tree ti;\n \n   if (!t || t == error_mark_node)\n@@ -18139,14 +18166,20 @@ append_type_to_template_for_access_check_1 (tree t,\n \n   gcc_assert (TI_TEMPLATE (ti));\n \n-  TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti) =\n-    tree_cons (type_decl, scope, TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti));\n+  typedef_usage.typedef_decl = type_decl;\n+  typedef_usage.context = scope;\n+  typedef_usage.locus = location;\n+\n+  VEC_safe_push (qualified_typedef_usage_t, gc,\n+\t\t TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti),\n+\t\t &typedef_usage);\n }\n \n /* Append TYPE_DECL to the template TEMPL.\n    TEMPL is either a class type, a FUNCTION_DECL or a a TEMPLATE_DECL.\n    At TEMPL instanciation time, TYPE_DECL will be checked to see\n    if it can be accessed through SCOPE.\n+   LOCATION is the location of the usage point of TYPE_DECL.\n \n    e.g. consider the following code snippet:\n \n@@ -18157,7 +18190,7 @@ append_type_to_template_for_access_check_1 (tree t,\n \n      template<class U> struct S\n      {\n-       C::myint mi;\n+       C::myint mi; // <-- usage point of the typedef C::myint\n      };\n \n      S<char> s;\n@@ -18174,25 +18207,25 @@ append_type_to_template_for_access_check_1 (tree t,\n void\n append_type_to_template_for_access_check (tree templ,\n                                           tree type_decl,\n-\t\t\t\t\t  tree scope)\n+\t\t\t\t\t  tree scope,\n+\t\t\t\t\t  location_t location)\n {\n-  tree node;\n+  qualified_typedef_usage_t *iter;\n+  int i;\n \n   gcc_assert (type_decl && (TREE_CODE (type_decl) == TYPE_DECL));\n \n   /* Make sure we don't append the type to the template twice.  */\n-  for (node = get_types_needing_access_check (templ);\n-       node;\n-       node = TREE_CHAIN (node))\n-    {\n-      tree decl = TREE_PURPOSE (node);\n-      tree type_scope = TREE_VALUE (node);\n-\n-      if (decl == type_decl && type_scope == scope)\n-\treturn;\n-    }\n+  for (i = 0;\n+       VEC_iterate (qualified_typedef_usage_t,\n+\t\t    get_types_needing_access_check (templ),\n+\t\t    i, iter);\n+       ++i)\n+    if (iter->typedef_decl == type_decl && scope == iter->context)\n+      return;\n \n-  append_type_to_template_for_access_check_1 (templ, type_decl, scope);\n+  append_type_to_template_for_access_check_1 (templ, type_decl,\n+\t\t\t\t\t      scope, location);\n }\n \n /* Set up the hash tables for template instantiations.  */"}, {"sha": "34b5d574d07c791267d50ab9ec26e0a3ee0a009d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -1531,6 +1531,37 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n     }\n }\n \n+/* If we are currently parsing a template and we encountered a typedef\n+   TYPEDEF_DECL that is being accessed though CONTEXT, this function\n+   adds the typedef to a list tied to the current template.\n+   At tempate instantiatin time, that list is walked and access check\n+   performed for each typedef.\n+   LOCATION is the location of the usage point of TYPEDEF_DECL.  */\n+\n+void\n+add_typedef_to_current_template_for_access_check (tree typedef_decl,\n+                                                  tree context,\n+\t\t\t\t\t\t  location_t location)\n+{\n+    tree template_info = NULL;\n+    tree cs = current_scope ();\n+\n+    if (!is_typedef_decl (typedef_decl)\n+\t|| !context\n+\t|| !CLASS_TYPE_P (context)\n+\t|| !cs)\n+      return;\n+\n+    if (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL)\n+      template_info = get_template_info (cs);\n+\n+    if (template_info\n+\t&& TI_TEMPLATE (template_info)\n+\t&& !currently_open_class (context))\n+      append_type_to_template_for_access_check (cs, typedef_decl,\n+\t\t\t\t\t\tcontext, location);\n+}\n+\n /* DECL was the declaration to which a qualified-id resolved.  Issue\n    an error message if it is not accessible.  If OBJECT_TYPE is\n    non-NULL, we have just seen `x->' or `x.' and OBJECT_TYPE is the\n@@ -1549,27 +1580,11 @@ check_accessibility_of_qualified_id (tree decl,\n      add it to a list tied to the template.\n      At template instantiation time, that list will be walked and\n      access check performed.  */\n-  if (is_typedef_decl (decl))\n-    {\n-      /* This the scope through which type_decl is accessed.\n-\t It will be useful information later to do access check for\n-\t type_decl usage.  */\n-      tree scope = nested_name_specifier\n-      ?  nested_name_specifier\n-      : DECL_CONTEXT (decl);\n-      tree templ_info = NULL;\n-      tree cs = current_scope ();\n-\n-      if (cs && (CLASS_TYPE_P (cs) || TREE_CODE (cs) == FUNCTION_DECL))\n-\ttempl_info = get_template_info (cs);\n-\n-      if (templ_info\n-\t  && TI_TEMPLATE (templ_info)\n-\t  && scope\n-\t  && CLASS_TYPE_P (scope)\n-\t  && !currently_open_class (scope))\n-\tappend_type_to_template_for_access_check (current_scope (), decl, scope);\n-    }\n+  add_typedef_to_current_template_for_access_check (decl,\n+\t\t\t\t\t\t    nested_name_specifier\n+\t\t\t\t\t\t    ? nested_name_specifier\n+\t\t\t\t\t\t    : DECL_CONTEXT (decl),\n+\t\t\t\t\t\t    input_location);\n \n   /* If we're not checking, return immediately.  */\n   if (deferred_access_no_check)"}, {"sha": "d431b3109a6fe8a42cb9a792d27fa32851c5d9f3", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -1490,8 +1490,7 @@ bind_template_template_parm (tree t, tree newargs)\n   TEMPLATE_TYPE_PARM_INDEX (t2) = copy_node (TEMPLATE_TYPE_PARM_INDEX (t));\n   TEMPLATE_PARM_DECL (TEMPLATE_TYPE_PARM_INDEX (t2)) = decl;\n   TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t2)\n-    = tree_cons (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t),\n-\t\t newargs, NULL_TREE);\n+    = build_template_info (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t), newargs);\n \n   TREE_TYPE (decl) = t2;\n   TYPE_NAME (t2) = decl;"}, {"sha": "3a5389090ad99711ee31822d92c64cf18239f175", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -1,3 +1,11 @@\n+2009-11-23  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tPR c++/14777\n+\t* g++.dg/template/typedef13.C: Adjust.\n+\t* g++.dg/template/typedef19.C: Adjust.\n+\t* g++.dg/template/typedef20.C: Adjust.\n+\t* g++.dg/template/typedef22.C: New test.\n+\n 2009-11-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/42113"}, {"sha": "a22e1cb11ca058d2e7ec0386a03f8c4389c32733", "filename": "gcc/testsuite/g++.dg/template/typedef13.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef13.C?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -8,8 +8,8 @@ class A\n };\n \n template <class T> class B : public A\n-{ // { dg-error \"within this context\"  }\n-  mytype mem;\n+{\n+  mytype mem; // { dg-error \"within this context\"  }\n };\n \n B<int> b; // { dg-message \"instantiated from here\" }"}, {"sha": "2fac20ea065468a9e12b474de9193b6641d204e0", "filename": "gcc/testsuite/g++.dg/template/typedef19.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef19.C?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -14,8 +14,8 @@ class B : public A\n \n template<class T>\n class B<T*> : public A\n-{ // { dg-error \"within this context\" }\n-  mytype mem;\n+{\n+  mytype mem; // { dg-error \"within this context\" }\n };\n \n B<int*> b;"}, {"sha": "c768ce0a78ab3b9522ff544ebd061ad97d08c07c", "filename": "gcc/testsuite/g++.dg/template/typedef20.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef20.C?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -18,9 +18,9 @@ struct y : public x\n \n template<typename T>\n struct y<T*> : public x\n-{ // { dg-error \"within this context\" }\n+{\n   typedef x::type good;\n-  typedef x::privtype bad;\n+  typedef x::privtype bad; // { dg-error \"within this context\" }\n };\n \n template class y<int>;"}, {"sha": "e3ecfcb36730714fc18275b1cf557e17e99bcff5", "filename": "gcc/testsuite/g++.dg/template/typedef22.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa373032bfd895dc6eb671308b68163f2971ffd2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef22.C?ref=aa373032bfd895dc6eb671308b68163f2971ffd2", "patch": "@@ -0,0 +1,18 @@\n+// Contributed by Dodji Seketeli <dodji@redhat.com>\n+// Origin: PR c++/14777\n+// { dg-do compile }\n+\n+template <typename T>\n+struct B\n+{\n+protected:\n+  typedef int M; // { dg-error \"protected\" }\n+};\n+\n+template <typename T>\n+struct A : B<T> {\n+  typedef typename B<char>::M N; // { dg-error \"context\" }\n+  A (int = N ());\n+};\n+\n+A<int> a = A<int> ();"}]}