{"sha": "25e00ab67444a01dce446e95308521d1a73f8232", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVlMDBhYjY3NDQ0YTAxZGNlNDQ2ZTk1MzA4NTIxZDFhNzNmODIzMg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-06-18T22:55:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-06-18T22:55:02Z"}, "message": "re PR libstdc++/57641 (std::timed_mutex.try_lock_until() is broken)\n\n\tPR libstdc++/57641\n\t* include/std/mutex (timed_mutex, recursive_timed_mutex): Move common\n\tfunctionality to new __timed_mutex_impl mixin. Overload try_lock_until\n\tto handle conversion between different clocks. Replace constrained\n\t__try_lock_for_impl overloads with conditional increment.\n\t* include/std/shared_mutex (shared_mutex::_Mutex): Use the new mixin.\n\t* testsuite/30_threads/timed_mutex/try_lock_until/57641.cc: New.\n\nFrom-SVN: r200180", "tree": {"sha": "c491d5047a720ef9b19dbe186747c2ab31667949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c491d5047a720ef9b19dbe186747c2ab31667949"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25e00ab67444a01dce446e95308521d1a73f8232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e00ab67444a01dce446e95308521d1a73f8232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e00ab67444a01dce446e95308521d1a73f8232", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e00ab67444a01dce446e95308521d1a73f8232/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bef8491a658de9e8920acaeff6cb76ef4e946e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef8491a658de9e8920acaeff6cb76ef4e946e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef8491a658de9e8920acaeff6cb76ef4e946e2c"}], "stats": {"total": 269, "additions": 138, "deletions": 131}, "files": [{"sha": "4428e94a7f9e3e0d2642db75ac24e79aa0dd880e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=25e00ab67444a01dce446e95308521d1a73f8232", "patch": "@@ -1,3 +1,13 @@\n+2013-06-18  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/57641\n+\t* include/std/mutex (timed_mutex, recursive_timed_mutex): Move common\n+\tfunctionality to new __timed_mutex_impl mixin. Overload try_lock_until\n+\tto handle conversion between different clocks. Replace constrained\n+\t__try_lock_for_impl overloads with conditional increment.\n+\t* include/std/shared_mutex (shared_mutex::_Mutex): Use the new mixin.\n+\t* testsuite/30_threads/timed_mutex/try_lock_until/57641.cc: New.\n+\n 2013-06-17  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \t    Chris Jefferson  <chris@bubblescope.net>\n "}, {"sha": "40b2e31dc7f937166597ceec0d79c557c6bbdc12", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 54, "deletions": 88, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=25e00ab67444a01dce446e95308521d1a73f8232", "patch": "@@ -199,15 +199,57 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   };\n \n #if _GTHREAD_USE_MUTEX_TIMEDLOCK\n-  /// timed_mutex\n-  class timed_mutex : private __mutex_base\n-  {\n+  template<typename _Derived>\n+    class __timed_mutex_impl\n+    {\n+    protected:\n #ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n-    typedef chrono::steady_clock \t  \t__clock_t;\n+      typedef chrono::steady_clock \t  \t__clock_t;\n #else\n-    typedef chrono::high_resolution_clock \t__clock_t;\n+      typedef chrono::high_resolution_clock \t__clock_t;\n #endif\n \n+      template<typename _Rep, typename _Period>\n+\tbool\n+\t_M_try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n+\t{\n+\t  auto __rt = chrono::duration_cast<__clock_t::duration>(__rtime);\n+\t  if (ratio_greater<__clock_t::period, _Period>())\n+\t    ++__rt;\n+\n+\t  return _M_try_lock_until(__clock_t::now() + __rt);\n+\t}\n+\n+      template<typename _Duration>\n+\tbool\n+\t_M_try_lock_until(const chrono::time_point<__clock_t,\n+\t\t\t\t\t\t   _Duration>& __atime)\n+\t{\n+\t  chrono::time_point<__clock_t, chrono::seconds> __s =\n+\t    chrono::time_point_cast<chrono::seconds>(__atime);\n+\n+\t  chrono::nanoseconds __ns =\n+\t    chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n+\n+\t  __gthread_time_t __ts = {\n+\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n+\t    static_cast<long>(__ns.count())\n+\t  };\n+\n+\t  auto __mutex = static_cast<_Derived*>(this)->native_handle();\n+\t  return !__gthread_mutex_timedlock(__mutex, &__ts);\n+\t}\n+\n+      template<typename _Clock, typename _Duration>\n+\tbool\n+\t_M_try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n+\t{ return _M_try_lock_for(__atime - _Clock::now()); }\n+    };\n+\n+  /// timed_mutex\n+  class timed_mutex\n+  : private __mutex_base, public __timed_mutex_impl<timed_mutex>\n+  {\n   public:\n     typedef __native_type* \t\t  \tnative_handle_type;\n \n@@ -237,25 +279,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     template <class _Rep, class _Period>\n       bool\n       try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n-      { return __try_lock_for_impl(__rtime); }\n+      { return _M_try_lock_for(__rtime); }\n \n     template <class _Clock, class _Duration>\n       bool\n       try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n-      {\n-\tchrono::time_point<_Clock, chrono::seconds> __s =\n-\t  chrono::time_point_cast<chrono::seconds>(__atime);\n-\n-\tchrono::nanoseconds __ns =\n-\t  chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n-\n-\t__gthread_time_t __ts = {\n-\t  static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t  static_cast<long>(__ns.count())\n-\t};\n-\n-\treturn !__gthread_mutex_timedlock(&_M_mutex, &__ts);\n-      }\n+      { return _M_try_lock_until(__atime); }\n \n     void\n     unlock()\n@@ -267,40 +296,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     native_handle_type\n     native_handle()\n     { return &_M_mutex; }\n-\n-  private:\n-    template<typename _Rep, typename _Period>\n-      typename enable_if<\n-\tratio_less_equal<__clock_t::period, _Period>::value, bool>::type\n-      __try_lock_for_impl(const chrono::duration<_Rep, _Period>& __rtime)\n-      {\n-\t__clock_t::time_point __atime = __clock_t::now()\n-\t  + chrono::duration_cast<__clock_t::duration>(__rtime);\n-\n-\treturn try_lock_until(__atime);\n-      }\n-\n-    template <typename _Rep, typename _Period>\n-      typename enable_if<\n-\t!ratio_less_equal<__clock_t::period, _Period>::value, bool>::type\n-      __try_lock_for_impl(const chrono::duration<_Rep, _Period>& __rtime)\n-      {\n-\t__clock_t::time_point __atime = __clock_t::now()\n-\t  + ++chrono::duration_cast<__clock_t::duration>(__rtime);\n-\n-\treturn try_lock_until(__atime);\n-      }\n   };\n \n   /// recursive_timed_mutex\n-  class recursive_timed_mutex : private __recursive_mutex_base\n+  class recursive_timed_mutex\n+  : private __recursive_mutex_base,\n+    public __timed_mutex_impl<recursive_timed_mutex>\n   {\n-#ifdef _GLIBCXX_USE_CLOCK_MONOTONIC\n-    typedef chrono::steady_clock \t\t__clock_t;\n-#else\n-    typedef chrono::high_resolution_clock \t__clock_t;\n-#endif\n-\n   public:\n     typedef __native_type* \t\t\tnative_handle_type;\n \n@@ -330,25 +332,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     template <class _Rep, class _Period>\n       bool\n       try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n-      { return __try_lock_for_impl(__rtime); }\n+      { return _M_try_lock_for(__rtime); }\n \n     template <class _Clock, class _Duration>\n       bool\n       try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n-      {\n-\tchrono::time_point<_Clock, chrono::seconds>  __s =\n-\t  chrono::time_point_cast<chrono::seconds>(__atime);\n-\n-\tchrono::nanoseconds __ns =\n-\t  chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n-\n-\t__gthread_time_t __ts = {\n-\t  static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t  static_cast<long>(__ns.count())\n-\t};\n-\n-\treturn !__gthread_recursive_mutex_timedlock(&_M_mutex, &__ts);\n-      }\n+      { return _M_try_lock_until(__atime); }\n \n     void\n     unlock()\n@@ -360,29 +349,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     native_handle_type\n     native_handle()\n     { return &_M_mutex; }\n-\n-  private:\n-    template<typename _Rep, typename _Period>\n-      typename enable_if<\n-\tratio_less_equal<__clock_t::period, _Period>::value, bool>::type\n-      __try_lock_for_impl(const chrono::duration<_Rep, _Period>& __rtime)\n-      {\n-\t__clock_t::time_point __atime = __clock_t::now()\n-\t  + chrono::duration_cast<__clock_t::duration>(__rtime);\n-\n-\treturn try_lock_until(__atime);\n-      }\n-\n-    template <typename _Rep, typename _Period>\n-      typename enable_if<\n-\t!ratio_less_equal<__clock_t::period, _Period>::value, bool>::type\n-      __try_lock_for_impl(const chrono::duration<_Rep, _Period>& __rtime)\n-      {\n-\t__clock_t::time_point __atime = __clock_t::now()\n-\t  + ++chrono::duration_cast<__clock_t::duration>(__rtime);\n-\n-\treturn try_lock_until(__atime);\n-      }\n   };\n #endif\n #endif // _GLIBCXX_HAS_GTHREADS"}, {"sha": "ff58825928e495fe87d30fc0f2ab62893fabe7c7", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=25e00ab67444a01dce446e95308521d1a73f8232", "patch": "@@ -56,55 +56,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   class shared_mutex\n   {\n #if _GTHREAD_USE_MUTEX_TIMEDLOCK\n-    struct _Mutex : mutex\n+    struct _Mutex : mutex, __timed_mutex_impl<_Mutex>\n     {\n-      typedef chrono::steady_clock \t  \t__clock_t;\n-\n-      template <class _Rep, class _Period>\n+      template<typename _Rep, typename _Period>\n \tbool\n \ttry_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n-\t{ return __try_lock_for_impl(__rtime); }\n+\t{ return _M_try_lock_for(__rtime); }\n \n-      template <class _Clock, class _Duration>\n+      template<typename _Clock, typename _Duration>\n \tbool\n \ttry_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n-\t{\n-\t  chrono::time_point<_Clock, chrono::seconds> __s =\n-\t    chrono::time_point_cast<chrono::seconds>(__atime);\n-\n-\t  chrono::nanoseconds __ns =\n-\t    chrono::duration_cast<chrono::nanoseconds>(__atime - __s);\n-\n-\t  __gthread_time_t __ts = {\n-\t    static_cast<std::time_t>(__s.time_since_epoch().count()),\n-\t    static_cast<long>(__ns.count())\n-\t  };\n-\n-\t  return !__gthread_mutex_timedlock(native_handle(), &__ts);\n-\t}\n-\n-    private:\n-      template<typename _Rep, typename _Period>\n-\ttypename enable_if<\n-\t  ratio_less_equal<__clock_t::period, _Period>::value, bool>::type\n-\t__try_lock_for_impl(const chrono::duration<_Rep, _Period>& __rtime)\n-\t{\n-\t  __clock_t::time_point __atime = __clock_t::now()\n-\t    + chrono::duration_cast<__clock_t::duration>(__rtime);\n-\n-\t  return try_lock_until(__atime);\n-\t}\n-\n-      template <typename _Rep, typename _Period>\n-\ttypename enable_if<\n-\t  !ratio_less_equal<__clock_t::period, _Period>::value, bool>::type\n-\t__try_lock_for_impl(const chrono::duration<_Rep, _Period>& __rtime)\n-\t{\n-\t  __clock_t::time_point __atime = __clock_t::now()\n-\t    + ++chrono::duration_cast<__clock_t::duration>(__rtime);\n-\n-\t  return try_lock_until(__atime);\n-\t}\n+\t{ return _M_try_lock_until(__atime); }\n     };\n #else\n     typedef mutex _Mutex;"}, {"sha": "94fe5b32761427b73fa62aca1ac3e3493dde5136", "filename": "libstdc++-v3/testsuite/30_threads/timed_mutex/try_lock_until/57641.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftimed_mutex%2Ftry_lock_until%2F57641.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25e00ab67444a01dce446e95308521d1a73f8232/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftimed_mutex%2Ftry_lock_until%2F57641.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftimed_mutex%2Ftry_lock_until%2F57641.cc?ref=25e00ab67444a01dce446e95308521d1a73f8232", "patch": "@@ -0,0 +1,69 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads-timed \"\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <mutex>\n+#include <chrono>\n+#include <thread>\n+#include <testsuite_hooks.h>\n+\n+// PR libstdc++/57641\n+\n+namespace C = std::chrono;\n+\n+// custom clock with epoch 10s before system_clock's\n+struct clock\n+{\n+  typedef C::system_clock::rep rep;\n+  typedef C::system_clock::period period;\n+  typedef C::system_clock::duration duration;\n+  typedef C::time_point<clock> time_point;\n+  static constexpr bool is_steady = C::system_clock::is_steady;\n+\n+  static time_point\n+  now()\n+  {\n+    auto sys_time = C::system_clock::now().time_since_epoch();\n+    return time_point(sys_time + C::seconds(10));\n+  }\n+};\n+\n+std::timed_mutex mx;\n+bool test = false;\n+\n+void f()\n+{\n+  test = mx.try_lock_until(clock::now() + C::milliseconds(1));\n+}\n+\n+int main()\n+{\n+  bool test = false;\n+  std::lock_guard<std::timed_mutex> l(mx);\n+  auto start = C::system_clock::now();\n+  std::thread t(f);\n+  t.join();\n+  auto stop = C::system_clock::now();\n+  VERIFY( (stop - start) < C::seconds(9) );\n+  VERIFY( !test );\n+}"}]}