{"sha": "f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk1NmFkYjk2MTNlZTBlOTQ5MWIzNzEzOWQ4YWI2ZDdhMjNlMGYzYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-04-27T21:12:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-04-27T21:12:18Z"}, "message": "cselib.c (find_slot_memmode): Delete.\n\ngcc/\n\t* cselib.c (find_slot_memmode): Delete.\n\t(cselib_hasher): Change compare_type to a struct.\n\t(cselib_hasher::equal): Update accordingly.  Don't expect wrapped\n\tconstants.\n\t(preserve_constants_and_equivs): Adjust for new compare_type.\n\t(cselib_find_slot): Likewise.  Take the mode of the rtx as argument.\n\t(wrap_constant): Delete.\n\t(cselib_lookup_mem, cselib_lookup_1): Update calls to cselib_find_slot.\n\nFrom-SVN: r209843", "tree": {"sha": "760a76549513ee629e677cca47e0c7f8f898c8cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/760a76549513ee629e677cca47e0c7f8f898c8cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d01b2c21cf2d72c552afda7ed796c5584d11d9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d01b2c21cf2d72c552afda7ed796c5584d11d9f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d01b2c21cf2d72c552afda7ed796c5584d11d9f3"}], "stats": {"total": 77, "additions": 36, "deletions": 41}, "files": [{"sha": "b25f1f66eb5419ae18519750e307318a9a6910ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "patch": "@@ -1,3 +1,14 @@\n+2014-04-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* cselib.c (find_slot_memmode): Delete.\n+\t(cselib_hasher): Change compare_type to a struct.\n+\t(cselib_hasher::equal): Update accordingly.  Don't expect wrapped\n+\tconstants.\n+\t(preserve_constants_and_equivs): Adjust for new compare_type.\n+\t(cselib_find_slot): Likewise.  Take the mode of the rtx as argument.\n+\t(wrap_constant): Delete.\n+\t(cselib_lookup_mem, cselib_lookup_1): Update calls to cselib_find_slot.\n+\n 2014-04-26  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \t* doc/install.texi (Building with profile feedback): Remove"}, {"sha": "6bdc482b91f9cb7bd5d560c3f09b46b2697177fa", "filename": "gcc/cselib.c", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f956adb9613ee0e9491b37139d8ab6d7a23e0f3c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=f956adb9613ee0e9491b37139d8ab6d7a23e0f3c", "patch": "@@ -49,9 +49,6 @@ struct elt_list {\n     cselib_val *elt;\n };\n \n-/* See the documentation of cselib_find_slot below.  */\n-static enum machine_mode find_slot_memmode;\n-\n static bool cselib_record_memory;\n static bool cselib_preserve_constants;\n static bool cselib_any_perm_equivs;\n@@ -94,7 +91,14 @@ static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n struct cselib_hasher : typed_noop_remove <cselib_val>\n {\n   typedef cselib_val value_type;\n-  typedef rtx_def compare_type;\n+  struct compare_type {\n+    /* The rtx value and its mode (needed separately for constant\n+       integers).  */\n+    enum machine_mode mode;\n+    rtx x;\n+    /* The mode of the contaning MEM, if any, otherwise VOIDmode.  */\n+    enum machine_mode memmode;\n+  };\n   static inline hashval_t hash (const value_type *);\n   static inline bool equal (const value_type *, const compare_type *);\n };\n@@ -118,27 +122,20 @@ inline bool\n cselib_hasher::equal (const value_type *v, const compare_type *x_arg)\n {\n   struct elt_loc_list *l;\n-  rtx x = CONST_CAST_RTX (x_arg);\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  gcc_assert (!CONST_SCALAR_INT_P (x) && GET_CODE (x) != CONST_FIXED);\n+  rtx x = x_arg->x;\n+  enum machine_mode mode = x_arg->mode;\n+  enum machine_mode memmode = x_arg->memmode;\n \n   if (mode != GET_MODE (v->val_rtx))\n     return false;\n \n-  /* Unwrap X if necessary.  */\n-  if (GET_CODE (x) == CONST\n-      && (CONST_SCALAR_INT_P (XEXP (x, 0))\n-\t  || GET_CODE (XEXP (x, 0)) == CONST_FIXED))\n-    x = XEXP (x, 0);\n-\n   if (GET_CODE (x) == VALUE)\n     return x == v->val_rtx;\n \n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_1 (l->loc, x, find_slot_memmode))\n+    if (rtx_equal_for_cselib_1 (l->loc, x, memmode))\n       {\n \tpromote_debug_loc (l);\n \treturn true;\n@@ -498,8 +495,11 @@ preserve_constants_and_equivs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n \n   if (invariant_or_equiv_p (v))\n     {\n+      cselib_hasher::compare_type lookup = {\n+\tGET_MODE (v->val_rtx), v->val_rtx, VOIDmode\n+      };\n       cselib_val **slot\n-\t= cselib_preserved_hash_table.find_slot_with_hash (v->val_rtx,\n+\t= cselib_preserved_hash_table.find_slot_with_hash (&lookup,\n \t\t\t\t\t\t\t   v->hash, INSERT);\n       gcc_assert (!*slot);\n       *slot = v;\n@@ -572,22 +572,19 @@ cselib_get_next_uid (void)\n \n /* Search for X, whose hashcode is HASH, in CSELIB_HASH_TABLE,\n    INSERTing if requested.  When X is part of the address of a MEM,\n-   MEMMODE should specify the mode of the MEM.  While searching the\n-   table, MEMMODE is held in FIND_SLOT_MEMMODE, so that autoinc RTXs\n-   in X can be resolved.  */\n+   MEMMODE should specify the mode of the MEM.  */\n \n static cselib_val **\n-cselib_find_slot (rtx x, hashval_t hash, enum insert_option insert,\n-\t\t  enum machine_mode memmode)\n+cselib_find_slot (enum machine_mode mode, rtx x, hashval_t hash,\n+\t\t  enum insert_option insert, enum machine_mode memmode)\n {\n   cselib_val **slot = NULL;\n-  find_slot_memmode = memmode;\n+  cselib_hasher::compare_type lookup = { mode, x, memmode };\n   if (cselib_preserve_constants)\n-    slot = cselib_preserved_hash_table.find_slot_with_hash (x, hash,\n+    slot = cselib_preserved_hash_table.find_slot_with_hash (&lookup, hash,\n \t\t\t\t\t\t\t    NO_INSERT);\n   if (!slot)\n-    slot = cselib_hash_table.find_slot_with_hash (x, hash, insert);\n-  find_slot_memmode = VOIDmode;\n+    slot = cselib_hash_table.find_slot_with_hash (&lookup, hash, insert);\n   return slot;\n }\n \n@@ -1042,18 +1039,6 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, enum machine_mode memmode)\n   return 1;\n }\n \n-/* We need to pass down the mode of constants through the hash table\n-   functions.  For that purpose, wrap them in a CONST of the appropriate\n-   mode.  */\n-static rtx\n-wrap_constant (enum machine_mode mode, rtx x)\n-{\n-  if (!CONST_SCALAR_INT_P (x) && GET_CODE (x) != CONST_FIXED)\n-    return x;\n-  gcc_assert (mode != VOIDmode);\n-  return gen_rtx_CONST (mode, x);\n-}\n-\n /* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n    For registers and memory locations, we look up their cselib_val structure\n    and return its VALUE element.\n@@ -1407,8 +1392,7 @@ cselib_lookup_mem (rtx x, int create)\n \n   mem_elt = new_cselib_val (next_uid, mode, x);\n   add_mem_for_addr (addr, mem_elt, x);\n-  slot = cselib_find_slot (wrap_constant (mode, x), mem_elt->hash,\n-\t\t\t   INSERT, mode);\n+  slot = cselib_find_slot (mode, x, mem_elt->hash, INSERT, VOIDmode);\n   *slot = mem_elt;\n   return mem_elt;\n }\n@@ -2064,7 +2048,7 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n \t    }\n \t}\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n-      slot = cselib_find_slot (x, e->hash, INSERT, memmode);\n+      slot = cselib_find_slot (mode, x, e->hash, INSERT, memmode);\n       *slot = e;\n       return e;\n     }\n@@ -2077,7 +2061,7 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n   if (! hashval)\n     return 0;\n \n-  slot = cselib_find_slot (wrap_constant (mode, x), hashval,\n+  slot = cselib_find_slot (mode, x, hashval,\n \t\t\t   create ? INSERT : NO_INSERT, memmode);\n   if (slot == 0)\n     return 0;"}]}