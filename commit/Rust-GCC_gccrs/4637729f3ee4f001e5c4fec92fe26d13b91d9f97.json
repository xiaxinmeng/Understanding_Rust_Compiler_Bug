{"sha": "4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzNzcyOWYzZWU0ZjAwMWU1YzRmZWM5MmZlMjZkMTNiOTFkOWY5Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T13:51:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T13:51:43Z"}, "message": "[multiple changes]\n\n2011-08-02  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb: Minor reformatting.\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Loop_Statement):  If the iteration scheme is an\n\tAda2012 iterator, the loop will be rewritten during expansion into a\n\twhile loop with a cursor and an element declaration. Do not analyze the\n\tbody in this case, because if the container is for indefinite types the\n\tactual subtype of the elements will only be determined when the cursor\n\tdeclaration is analyzed.\n\n2011-08-02  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Ignore\n\tsize/alignment related attributes in CodePeer_Mode.\n\n2011-08-02  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch3.adb (Check_Ops_From_Incomplete_Type): Remove call to\n\tPrepend_Element, since this can result in the operation getting the\n\twrong slot in the full type's dispatch table if the full type has\n\tinherited operations. The incomplete type's operation will get added\n\tto the proper position in the full type's primitives\n\tlist later in Sem_Disp.Check_Operation_From_Incomplete_Type.\n\t(Process_Incomplete_Dependents): Add Is_Primitive test when checking for\n\tdispatching operations, since there are cases where nonprimitive\n\tsubprograms can get added to the list of incomplete dependents (such\n\tas subprograms in nested packages).\n\t* sem_ch6.adb (Process_Formals): First, remove test for being in a\n\tprivate part when determining whether to add a primitive with a\n\tparameter of a tagged incomplete type to the Private_Dependents list.\n\tSuch primitives can also occur in the visible part, and should not have\n\tbeen excluded from being private dependents.\n\t* sem_ch7.adb (Uninstall_Declarations): When checking the rule of\n\tRM05-3.10.1(9.3/2), test that a subprogram in the Private_Dependents\n\tlist of a Taft-amendment incomplete type is a primitive before issuing\n\tan error that the full type must appear in the same unit. There are\n\tcases where nonprimitives can be in the list (such as subprograms in\n\tnested packages).\n\t* sem_disp.adb (Derives_From): Use correct condition for checking that\n\ta formal's type is derived from the type of the corresponding formal in\n\tthe parent subprogram (the condition was completely wrong). Add\n\tchecking that was missing for controlling result types being derived\n\tfrom the result type of the parent operation.\n\nFrom-SVN: r177156", "tree": {"sha": "7912df75525fc2582825ca39cb64a8b12c8f1039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7912df75525fc2582825ca39cb64a8b12c8f1039"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/comments", "author": null, "committer": null, "parents": [{"sha": "4c60de0c970a2b152748ec3c65f65328b4689471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c60de0c970a2b152748ec3c65f65328b4689471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c60de0c970a2b152748ec3c65f65328b4689471"}], "stats": {"total": 202, "additions": 167, "deletions": 35}, "files": [{"sha": "71be8748ea8a00d934e11cfa1b2a212b13d1738a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -1,3 +1,50 @@\n+2011-08-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb: Minor reformatting.\n+\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Loop_Statement):  If the iteration scheme is an\n+\tAda2012 iterator, the loop will be rewritten during expansion into a\n+\twhile loop with a cursor and an element declaration. Do not analyze the\n+\tbody in this case, because if the container is for indefinite types the\n+\tactual subtype of the elements will only be determined when the cursor\n+\tdeclaration is analyzed.\n+\n+2011-08-02  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Ignore\n+\tsize/alignment related attributes in CodePeer_Mode.\n+\n+2011-08-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch3.adb (Check_Ops_From_Incomplete_Type): Remove call to\n+\tPrepend_Element, since this can result in the operation getting the\n+\twrong slot in the full type's dispatch table if the full type has\n+\tinherited operations. The incomplete type's operation will get added\n+\tto the proper position in the full type's primitives\n+\tlist later in Sem_Disp.Check_Operation_From_Incomplete_Type.\n+\t(Process_Incomplete_Dependents): Add Is_Primitive test when checking for\n+\tdispatching operations, since there are cases where nonprimitive\n+\tsubprograms can get added to the list of incomplete dependents (such\n+\tas subprograms in nested packages).\n+\t* sem_ch6.adb (Process_Formals): First, remove test for being in a\n+\tprivate part when determining whether to add a primitive with a\n+\tparameter of a tagged incomplete type to the Private_Dependents list.\n+\tSuch primitives can also occur in the visible part, and should not have\n+\tbeen excluded from being private dependents.\n+\t* sem_ch7.adb (Uninstall_Declarations): When checking the rule of\n+\tRM05-3.10.1(9.3/2), test that a subprogram in the Private_Dependents\n+\tlist of a Taft-amendment incomplete type is a primitive before issuing\n+\tan error that the full type must appear in the same unit. There are\n+\tcases where nonprimitives can be in the list (such as subprograms in\n+\tnested packages).\n+\t* sem_disp.adb (Derives_From): Use correct condition for checking that\n+\ta formal's type is derived from the type of the corresponding formal in\n+\tthe parent subprogram (the condition was completely wrong). Add\n+\tchecking that was missing for controlling result types being derived\n+\tfrom the result type of the parent operation.\n+\n 2011-08-02  Yannick Moy  <moy@adacore.com>\n \n \t* errout.adb (First_Node): minor renaming"}, {"sha": "85e9d572ba49438b317cc28b5c93fdaeb356d10f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -6923,10 +6923,9 @@ package body Exp_Ch4 is\n                Set_Entity (Right_Opnd (Neg), Corresponding_Equality (Ne));\n             end if;\n \n-            --  For navigation purposes, the inequality is treated as an\n+            --  For navigation purposes, we want to treat the inequality as an\n             --  implicit reference to the corresponding equality. Preserve the\n-            --  Comes_From_ source flag so that the proper Xref entry is\n-            --  generated.\n+            --  Comes_From_ source flag to generate proper Xref entries.\n \n             Preserve_Comes_From_Source (Neg, N);\n             Preserve_Comes_From_Source (Right_Opnd (Neg), N);"}, {"sha": "7d2e64c64e49530c9a9285095bc3cb183f97adaa", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -1567,9 +1567,10 @@ package body Sem_Ch13 is\n          Set_Analyzed (N, True);\n       end if;\n \n-      --  Process Ignore_Rep_Clauses option\n+      --  Process Ignore_Rep_Clauses option (we also ignore rep clauses in\n+      --  CodePeer mode, since they are not relevant in that context).\n \n-      if Ignore_Rep_Clauses then\n+      if Ignore_Rep_Clauses or CodePeer_Mode then\n          case Id is\n \n             --  The following should be ignored. They do not affect legality\n@@ -1584,26 +1585,36 @@ package body Sem_Ch13 is\n                  Attribute_Machine_Radix  |\n                  Attribute_Object_Size    |\n                  Attribute_Size           |\n-                 Attribute_Small          |\n                  Attribute_Stream_Size    |\n                  Attribute_Value_Size     =>\n-\n                Rewrite (N, Make_Null_Statement (Sloc (N)));\n                return;\n \n+            --  We do not want too ignore 'Small in CodePeer_Mode, since it\n+            --  has an impact on the exact computations performed.\n+\n+            --  Perhaps 'Small should also not be ignored by\n+            --  Ignore_Rep_Clauses ???\n+\n+            when Attribute_Small =>\n+               if Ignore_Rep_Clauses then\n+                  Rewrite (N, Make_Null_Statement (Sloc (N)));\n+                  return;\n+               end if;\n+\n             --  The following should not be ignored, because in the first place\n             --  they are reasonably portable, and should not cause problems in\n             --  compiling code from another target, and also they do affect\n             --  legality, e.g. failing to provide a stream attribute for a\n             --  type may make a program illegal.\n \n-            when Attribute_External_Tag            |\n-                 Attribute_Input                   |\n-                 Attribute_Output                  |\n-                 Attribute_Read                    |\n-                 Attribute_Storage_Pool            |\n-                 Attribute_Storage_Size            |\n-                 Attribute_Write                   =>\n+            when Attribute_External_Tag |\n+                 Attribute_Input        |\n+                 Attribute_Output       |\n+                 Attribute_Read         |\n+                 Attribute_Storage_Pool |\n+                 Attribute_Storage_Size |\n+                 Attribute_Write        =>\n                null;\n \n             --  Other cases are errors (\"attribute& cannot be set with"}, {"sha": "458505211fe9b307c7627d2e670645ebfac3dd1f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -2190,9 +2190,12 @@ package body Sem_Ch3 is\n                                     or else In_Package_Body (Current_Scope));\n \n       procedure Check_Ops_From_Incomplete_Type;\n-      --  If there is a tagged incomplete partial view of the type, transfer\n-      --  its operations to the full view, and indicate that the type of the\n-      --  controlling parameter (s) is this full view.\n+      --  If there is a tagged incomplete partial view of the type, traverse\n+      --  the primitives of the incomplete view and change the type of any\n+      --  controlling formals and result to indicate the full view. The\n+      --  primitives will be added to the full type's primitive operations\n+      --  list later in Sem_Disp.Check_Operation_From_Incomplete_Type (which\n+      --  is called from Process_Incomplete_Dependents).\n \n       ------------------------------------\n       -- Check_Ops_From_Incomplete_Type --\n@@ -2212,7 +2215,6 @@ package body Sem_Ch3 is\n             Elmt := First_Elmt (Primitive_Operations (Prev));\n             while Present (Elmt) loop\n                Op := Node (Elmt);\n-               Prepend_Elmt (Op, Primitive_Operations (T));\n \n                Formal := First_Formal (Op);\n                while Present (Formal) loop\n@@ -17844,17 +17846,17 @@ package body Sem_Ch3 is\n \n          elsif Is_Overloadable (Priv_Dep) then\n \n-            --  A protected operation is never dispatching: only its\n-            --  wrapper operation (which has convention Ada) is.\n+            --  If a subprogram in the incomplete dependents list is primitive\n+            --  for a tagged full type then mark it as a dispatching operation,\n+            --  check whether it overrides an inherited subprogram, and check\n+            --  restrictions on its controlling formals. Note that a protected\n+            --  operation is never dispatching: only its wrapper operation\n+            --  (which has convention Ada) is.\n \n             if Is_Tagged_Type (Full_T)\n+              and then Is_Primitive (Priv_Dep)\n               and then Convention (Priv_Dep) /= Convention_Protected\n             then\n-\n-               --  Subprogram has an access parameter whose designated type\n-               --  was incomplete. Reexamine declaration now, because it may\n-               --  be a primitive operation of the full type.\n-\n                Check_Operation_From_Incomplete_Type (Priv_Dep, Inc_T);\n                Set_Is_Dispatching_Operation (Priv_Dep);\n                Check_Controlling_Formals (Full_T, Priv_Dep);"}, {"sha": "177987c2310d205bf307aea5b113096f897661ba", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -2387,7 +2387,33 @@ package body Sem_Ch5 is\n       Kill_Current_Values;\n       Push_Scope (Ent);\n       Analyze_Iteration_Scheme (Iter);\n-      Analyze_Statements (Statements (Loop_Statement));\n+\n+      --  Analyze the statements of the body except in the case of an Ada 2012\n+      --  iterator with the expander active. In this case the expander will do\n+      --  a rewrite of the loop into a while loop. We will then analyze the\n+      --  loop body when we analyze this while loop.\n+\n+      --  We need to do this delay because if the container is for indefinite\n+      --  types the actual subtype of the components will only be determined\n+      --  when the cursor declaration is analyzed.\n+\n+      --  If the expander is not active, then we want to analyze the loop body\n+      --  now even in the Ada 2012 iterator case, since the rewriting will not\n+      --  be done.\n+\n+      if No (Iter)\n+        or else No (Iterator_Specification (Iter))\n+        or else not Expander_Active\n+      then\n+         Analyze_Statements (Statements (Loop_Statement));\n+      end if;\n+\n+      --  Finish up processing for the loop. We kill all current values, since\n+      --  in general we don't know if the statements in the loop have been\n+      --  executed. We could do a bit better than this with a loop that we\n+      --  know will execute at least once, but it's not worth the trouble and\n+      --  the front end is not in the business of flow tracing.\n+\n       Process_End_Label (Loop_Statement, 'e', Ent);\n       End_Scope;\n       Kill_Current_Values;"}, {"sha": "34278978c4335483d5b21bda01c5963855657818", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -8655,7 +8655,6 @@ package body Sem_Ch6 is\n \n                if Is_Tagged_Type (Formal_Type) then\n                   if Ekind (Scope (Current_Scope)) = E_Package\n-                    and then In_Private_Part (Scope (Current_Scope))\n                     and then not From_With_Type (Formal_Type)\n                     and then not Is_Class_Wide_Type (Formal_Type)\n                   then\n@@ -8666,6 +8665,14 @@ package body Sem_Ch6 is\n                         Append_Elmt\n                           (Current_Scope,\n                              Private_Dependents (Base_Type (Formal_Type)));\n+\n+                        --  Freezing is delayed to ensure that Register_Prim\n+                        --  will get called for this operation, which is needed\n+                        --  in cases where static dispatch tables aren't built.\n+                        --  (Note that the same is done for controlling access\n+                        --  parameter cases in function Access_Definition.)\n+\n+                        Set_Has_Delayed_Freeze (Current_Scope);\n                      end if;\n                   end if;\n "}, {"sha": "46d63dc7ab44dedace04c7ce8e2c3168a3d6412c", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -2463,7 +2463,11 @@ package body Sem_Ch7 is\n                while Present (Elmt) loop\n                   Subp := Node (Elmt);\n \n-                  if Is_Overloadable (Subp) then\n+                  --  Is_Primitive is tested because there can be cases where\n+                  --  nonprimitive subprograms (in nested packages) are added\n+                  --  to the Private_Dependents list.\n+\n+                  if Is_Overloadable (Subp) and then Is_Primitive (Subp) then\n                      Error_Msg_NE\n                        (\"type& must be completed in the private part\",\n                          Parent (Subp), Id);"}, {"sha": "b1e99dc79c5ac4f248bd2d7c69a0e8989186fce6", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4637729f3ee4f001e5c4fec92fe26d13b91d9f97/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=4637729f3ee4f001e5c4fec92fe26d13b91d9f97", "patch": "@@ -1362,23 +1362,28 @@ package body Sem_Disp is\n       Op1, Op2   : Elmt_Id;\n       Prev       : Elmt_Id := No_Elmt;\n \n-      function Derives_From (Proc : Entity_Id) return Boolean;\n-      --  Check that Subp has the signature of an operation derived from Proc.\n-      --  Subp has an access parameter that designates Typ.\n+      function Derives_From (Parent_Subp : Entity_Id) return Boolean;\n+      --  Check that Subp has profile of an operation derived from Parent_Subp.\n+      --  Subp must have a parameter or result type that is Typ or an access\n+      --  parameter or access result type that designates Typ.\n \n       ------------------\n       -- Derives_From --\n       ------------------\n \n-      function Derives_From (Proc : Entity_Id) return Boolean is\n+      function Derives_From (Parent_Subp : Entity_Id) return Boolean is\n          F1, F2 : Entity_Id;\n \n       begin\n-         if Chars (Proc) /= Chars (Subp) then\n+         if Chars (Parent_Subp) /= Chars (Subp) then\n             return False;\n          end if;\n \n-         F1 := First_Formal (Proc);\n+         --  Check that the type of controlling formals is derived from the\n+         --  parent subprogram's controlling formal type (or designated type\n+         --  if the formal type is an anonymous access type).\n+\n+         F1 := First_Formal (Parent_Subp);\n          F2 := First_Formal (Subp);\n          while Present (F1) and then Present (F2) loop\n             if Ekind (Etype (F1)) = E_Anonymous_Access_Type then\n@@ -1393,14 +1398,45 @@ package body Sem_Disp is\n             elsif Ekind (Etype (F2)) = E_Anonymous_Access_Type then\n                return False;\n \n-            elsif Etype (F1) /= Etype (F2) then\n+            elsif Etype (F1) = Parent_Typ and then Etype (F2) /= Full then\n                return False;\n             end if;\n \n             Next_Formal (F1);\n             Next_Formal (F2);\n          end loop;\n \n+         --  Check that a controlling result type is derived from the parent\n+         --  subprogram's result type (or designated type if the result type\n+         --  is an anonymous access type).\n+\n+         if Ekind (Parent_Subp) = E_Function then\n+            if Ekind (Subp) /= E_Function then\n+               return False;\n+\n+            elsif Ekind (Etype (Parent_Subp)) = E_Anonymous_Access_Type then\n+               if Ekind (Etype (Subp)) /= E_Anonymous_Access_Type then\n+                  return False;\n+\n+               elsif Designated_Type (Etype (Parent_Subp)) = Parent_Typ\n+                 and then Designated_Type (Etype (Subp)) /= Full\n+               then\n+                  return False;\n+               end if;\n+\n+            elsif Ekind (Etype (Subp)) = E_Anonymous_Access_Type then\n+               return False;\n+\n+            elsif Etype (Parent_Subp) = Parent_Typ\n+              and then Etype (Subp) /= Full\n+            then\n+               return False;\n+            end if;\n+\n+         elsif Ekind (Subp) = E_Function then\n+            return False;\n+         end if;\n+\n          return No (F1) and then No (F2);\n       end Derives_From;\n "}]}