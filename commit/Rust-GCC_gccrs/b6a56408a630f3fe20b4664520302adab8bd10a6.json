{"sha": "b6a56408a630f3fe20b4664520302adab8bd10a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZhNTY0MDhhNjMwZjNmZTIwYjQ2NjQ1MjAzMDJhZGFiOGJkMTBhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T09:54:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T09:54:19Z"}, "message": "[multiple changes]\n\n2015-03-04  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch7.adb: Minor reformatting.\n\t* exp_unst.adb (Build_Tables): Fix minor glitch for no separate\n\tspec case.\n\t* erroutc.adb (Delete_Msg): add missing decrement of info msg counter.\n\n2015-03-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Build_Pragma_Check_Equivalent): Suppress\n\treferences to formal parameters subject to pragma Unreferenced.\n\t(Suppress_Reference): New routine.\n\t* sem_attr.adb (Analyze_Attribute): Reimplement the analysis\n\tof attribute 'Old. Attributes 'Old and 'Result now share\n\tcommon processing.\n\t(Analyze_Old_Result_Attribute): New routine.\n\t(Check_Placement_In_Check): Removed.\n\t(Check_Placement_In_Contract_Cases): Removed.\n\t(Check_Placement_In_Test_Case): Removed.\n\t(Check_Use_In_Contract_Cases): Removed.\n\t(Check_Use_In_Test_Case): Removed.\n\t(In_Refined_Post): Removed.\n\t(Is_Within): Removed.\n\t* sem_warn.adb (Check_Low_Bound_Tested): Code cleanup.\n\t(Check_Low_Bound_Tested_For): New routine.\n\n2015-03-04  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration):\n\tGenerate a runtime check to test the expression of pragma\n\tDefault_Initial_Condition when the object is default initialized.\n\nFrom-SVN: r221176", "tree": {"sha": "c6ff97a61069fd55e6d95e3d19dc0adade7dbb7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6ff97a61069fd55e6d95e3d19dc0adade7dbb7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6a56408a630f3fe20b4664520302adab8bd10a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a56408a630f3fe20b4664520302adab8bd10a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a56408a630f3fe20b4664520302adab8bd10a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a56408a630f3fe20b4664520302adab8bd10a6/comments", "author": null, "committer": null, "parents": [{"sha": "2322588a7149e39ed808e586e3ec640e032b6e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2322588a7149e39ed808e586e3ec640e032b6e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2322588a7149e39ed808e586e3ec640e032b6e9e"}], "stats": {"total": 1049, "additions": 509, "deletions": 540}, "files": [{"sha": "c48ea3fb80997f4468ae7090f66dcf7c02fa94dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -1,3 +1,35 @@\n+2015-03-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch7.adb: Minor reformatting.\n+\t* exp_unst.adb (Build_Tables): Fix minor glitch for no separate\n+\tspec case.\n+\t* erroutc.adb (Delete_Msg): add missing decrement of info msg counter.\n+\n+2015-03-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Build_Pragma_Check_Equivalent): Suppress\n+\treferences to formal parameters subject to pragma Unreferenced.\n+\t(Suppress_Reference): New routine.\n+\t* sem_attr.adb (Analyze_Attribute): Reimplement the analysis\n+\tof attribute 'Old. Attributes 'Old and 'Result now share\n+\tcommon processing.\n+\t(Analyze_Old_Result_Attribute): New routine.\n+\t(Check_Placement_In_Check): Removed.\n+\t(Check_Placement_In_Contract_Cases): Removed.\n+\t(Check_Placement_In_Test_Case): Removed.\n+\t(Check_Use_In_Contract_Cases): Removed.\n+\t(Check_Use_In_Test_Case): Removed.\n+\t(In_Refined_Post): Removed.\n+\t(Is_Within): Removed.\n+\t* sem_warn.adb (Check_Low_Bound_Tested): Code cleanup.\n+\t(Check_Low_Bound_Tested_For): New routine.\n+\n+2015-03-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration):\n+\tGenerate a runtime check to test the expression of pragma\n+\tDefault_Initial_Condition when the object is default initialized.\n+\n 2015-03-02  Robert Dewar  <dewar@adacore.com>\n \n \t* scng.adb (Scan): Ignore illegal character in relaxed"}, {"sha": "041158ae485cc38a41863d713495847dd7ac27c7", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -141,6 +141,10 @@ package body Erroutc is\n             if Errors.Table (D).Warn or else Errors.Table (D).Style then\n                Warnings_Detected := Warnings_Detected - 1;\n \n+               if Errors.Table (D).Info then\n+                  Info_Messages := Info_Messages - 1;\n+               end if;\n+\n                --  Note: we do not need to decrement Warnings_Treated_As_Errors\n                --  because this only gets incremented if we actually output the\n                --  message, which we won't do if we are deleting it here!"}, {"sha": "0baa3f68edc59ff9b3cd36b471d74010291e2b00", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -6138,11 +6138,9 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n-      --  At this point the object is fully initialized by either invoking the\n-      --  related type init proc, routine [Deep_]Initialize or performing in-\n-      --  place assingments for an array object. If the related type is subject\n-      --  to pragma Default_Initial_Condition, add a runtime check to verify\n-      --  the assumption of the pragma. Generate:\n+      --  If the object is default initialized and its type is subject to\n+      --  pragma Default_Initial_Condition, add a runtime check to verify\n+      --  the assumption of the pragma (SPARK RM 7.3.3). Generate:\n \n       --    <Base_Typ>Default_Init_Cond (<Base_Typ> (Def_Id));\n \n@@ -6152,6 +6150,7 @@ package body Exp_Ch3 is\n         and then (Has_Default_Init_Cond           (Base_Typ)\n                     or else\n                   Has_Inherited_Default_Init_Cond (Base_Typ))\n+        and then not Has_Init_Expression (N)\n       then\n          declare\n             DIC_Call : constant Node_Id :="}, {"sha": "ce3052e5c7a4cdffd3ee189b2a6aae9c8b59f1dc", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -7163,6 +7163,42 @@ package body Exp_Ch6 is\n          Subp_Id  : Entity_Id := Empty;\n          Inher_Id : Entity_Id := Empty) return Node_Id\n       is\n+         function Suppress_Reference (N : Node_Id) return Traverse_Result;\n+         --  Detect whether node N references a formal parameter subject to\n+         --  pragma Unreferenced. If this is the case, set Comes_From_Source\n+         --  to False to suppress the generation of a reference when analyzing\n+         --  N later on.\n+\n+         ------------------------\n+         -- Suppress_Reference --\n+         ------------------------\n+\n+         function Suppress_Reference (N : Node_Id) return Traverse_Result is\n+            Formal : Entity_Id;\n+\n+         begin\n+            if Is_Entity_Name (N) and then Present (Entity (N)) then\n+               Formal := Entity (N);\n+\n+               --  The formal parameter is subject to pragma Unreferenced.\n+               --  Prevent the generation of a reference by resetting the\n+               --  Comes_From_Source flag.\n+\n+               if Is_Formal (Formal)\n+                 and then Has_Pragma_Unreferenced (Formal)\n+               then\n+                  Set_Comes_From_Source (N, False);\n+               end if;\n+            end if;\n+\n+            return OK;\n+         end Suppress_Reference;\n+\n+         procedure Suppress_References is\n+           new Traverse_Proc (Suppress_Reference);\n+\n+         --  Local variables\n+\n          Loc          : constant Source_Ptr := Sloc (Prag);\n          Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n          Check_Prag   : Node_Id;\n@@ -7172,6 +7208,8 @@ package body Exp_Ch6 is\n          Nam          : Name_Id;\n          Subp_Formal  : Entity_Id;\n \n+      --  Start of processing for Build_Pragma_Check_Equivalent\n+\n       begin\n          Formals_Map := No_Elist;\n \n@@ -7208,8 +7246,26 @@ package body Exp_Ch6 is\n          --  Mark the pragma as being internally generated and reset the\n          --  Analyzed flag.\n \n-         Set_Comes_From_Source (Check_Prag, False);\n          Set_Analyzed          (Check_Prag, False);\n+         Set_Comes_From_Source (Check_Prag, False);\n+\n+         --  The tree of the original pragma may contain references to the\n+         --  formal parameters of the related subprogram. At the same time\n+         --  the corresponding body may mark the formals as unreferenced:\n+\n+         --     procedure Proc (Formal : ...)\n+         --       with Pre => Formal ...;\n+\n+         --     procedure Proc (Formal : ...) is\n+         --        pragma Unreferenced (Formal);\n+         --     ...\n+\n+         --  This creates problems because all pragma Check equivalents are\n+         --  analyzed at the end of the body declarations. Since all source\n+         --  references have already been accounted for, reset any references\n+         --  to such formals in the generated pragma Check equivalent.\n+\n+         Suppress_References (Check_Prag);\n \n          if Present (Corresponding_Aspect (Prag)) then\n             Nam := Chars (Identifier (Corresponding_Aspect (Prag)));"}, {"sha": "2c6683d0ff66ab875028ce5ef4e3e4cd3ce51375", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -7853,12 +7853,10 @@ package body Exp_Ch7 is\n      (Loc     : Source_Ptr;\n       Ptr_Typ : Entity_Id) return Node_Id\n    is\n-\n-      --  It is possible for Ptr_Typ to be a partial view, if the access\n-      --  type is a full view declared in the private part of a nested package,\n-      --  and the finalization actions take place when completing analysis\n-      --  of the enclosing unit. For this reason we use Underlying_Type\n-      --  in two places below.\n+      --  It is possible for Ptr_Typ to be a partial view, if the access type\n+      --  is a full view declared in the private part of a nested package, and\n+      --  the finalization actions take place when completing analysis of the\n+      --  enclosing unit. For this reason use Underlying_Type twice below.\n \n       Desig_Typ : constant Entity_Id :=\n                     Available_View"}, {"sha": "2b143c50f457d0ee800c98ca9d9b87115b4a4291", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -491,16 +491,16 @@ package body Exp_Unst is\n          --  then we won't catch it in the traversal of the body. But we do\n          --  want to visit the declaration in this case!\n \n-         declare\n-            Dummy : Traverse_Result;\n-            Decl  : constant Node_Id :=\n-              Parent (Declaration_Node (Corresponding_Spec (Subp_Body)));\n-            pragma Assert (Nkind (Decl) = N_Subprogram_Declaration);\n-         begin\n-            if not Acts_As_Spec (Subp_Body) then\n+         if not Acts_As_Spec (Subp_Body) then\n+            declare\n+               Dummy : Traverse_Result;\n+               Decl  : constant Node_Id :=\n+                 Parent (Declaration_Node (Corresponding_Spec (Subp_Body)));\n+               pragma Assert (Nkind (Decl) = N_Subprogram_Declaration);\n+            begin\n                Dummy := Visit_Node (Decl);\n-            end if;\n-         end;\n+            end;\n+         end if;\n \n          --  Traverse the body to get the rest of the subprograms and calls\n "}, {"sha": "d4ece9791d20a2ac53a168b6bab9026e2bb2af35", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 374, "deletions": 499, "changes": 873, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -241,6 +241,15 @@ package body Sem_Attr is\n       --  Used for Access, Unchecked_Access, Unrestricted_Access attributes.\n       --  Internally, Id distinguishes which of the three cases is involved.\n \n+      procedure Analyze_Attribute_Old_Result\n+        (Legal   : out Boolean;\n+         Spec_Id : out Entity_Id);\n+      --  Common processing for attributes 'Old and 'Result. The routine checks\n+      --  that the attribute appears in a postcondition-like aspect or pragma\n+      --  associated with a suitable subprogram or a body. Flag Legal is set\n+      --  when the above criterias are met. Spec_Id denotes the entity of the\n+      --  subprogram [body] or Empty if the attribute is illegal.\n+\n       procedure Bad_Attribute_For_Predicate;\n       --  Output error message for use of a predicate (First, Last, Range) not\n       --  allowed with a type that has predicates. If the type is a generic\n@@ -343,6 +352,9 @@ package body Sem_Attr is\n       procedure Check_Object_Reference (P : Node_Id);\n       --  Check that P is an object reference\n \n+      procedure Check_PolyORB_Attribute;\n+      --  Validity checking for PolyORB/DSA attribute\n+\n       procedure Check_Program_Unit;\n       --  Verify that prefix of attribute N is a program unit\n \n@@ -364,9 +376,6 @@ package body Sem_Attr is\n       procedure Check_System_Prefix;\n       --  Verify that prefix of attribute N is package System\n \n-      procedure Check_PolyORB_Attribute;\n-      --  Validity checking for PolyORB/DSA attribute\n-\n       procedure Check_Task_Prefix;\n       --  Verify that prefix of attribute N is a task or task type\n \n@@ -397,10 +406,6 @@ package body Sem_Attr is\n       pragma No_Return (Error_Attr);\n       --  Like Error_Attr, but error is posted at the start of the prefix\n \n-      function In_Refined_Post return Boolean;\n-      --  Determine whether the current attribute appears in pragma\n-      --  Refined_Post.\n-\n       procedure Legal_Formal_Attribute;\n       --  Common processing for attributes Definite and Has_Discriminants.\n       --  Checks that prefix is generic indefinite formal type.\n@@ -1072,6 +1077,263 @@ package body Sem_Attr is\n          end if;\n       end Analyze_Access_Attribute;\n \n+      ----------------------------------\n+      -- Analyze_Attribute_Old_Result --\n+      ----------------------------------\n+\n+      procedure Analyze_Attribute_Old_Result\n+        (Legal   : out Boolean;\n+         Spec_Id : out Entity_Id)\n+      is\n+         procedure Check_Placement_In_Check (Prag : Node_Id);\n+         --  Verify that the attribute appears within pragma Check that mimics\n+         --  a postcondition.\n+\n+         procedure Check_Placement_In_Contract_Cases (Prag : Node_Id);\n+         --  Verify that the attribute appears within a consequence of aspect\n+         --  or pragma Contract_Cases denoted by Prag.\n+\n+         procedure Check_Placement_In_Test_Case (Prag : Node_Id);\n+         --  Verify that the attribute appears within the \"Ensures\" argument of\n+         --  aspect or pragma Test_Case denoted by Prag.\n+\n+         function Is_Within\n+           (Nod      : Node_Id;\n+            Encl_Nod : Node_Id) return Boolean;\n+         --  Subsidiary to Check_Placemenet_In_XXX. Determine whether arbitrary\n+         --  node Nod is within enclosing node Encl_Nod.\n+\n+         ------------------------------\n+         -- Check_Placement_In_Check --\n+         ------------------------------\n+\n+         procedure Check_Placement_In_Check (Prag : Node_Id) is\n+            Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+            Nam  : constant Name_Id := Chars (Get_Pragma_Arg (First (Args)));\n+\n+         begin\n+            --  The \"Name\" argument of pragma Check denotes a postcondition\n+\n+            if Nam_In (Nam, Name_Post,\n+                            Name_Post_Class,\n+                            Name_Postcondition,\n+                            Name_Refined_Post)\n+            then\n+               null;\n+\n+            --  Otherwise the placement of the attribute is illegal\n+\n+            else\n+               if Aname = Name_Old then\n+                  Error_Attr\n+                    (\"attribute % can only appear in postcondition\", P);\n+\n+               --  Specialize the error message for attribute 'Result\n+\n+               else\n+                  Error_Attr\n+                    (\"attribute % can only appear in postcondition of \"\n+                     & \"function\", P);\n+               end if;\n+            end if;\n+         end Check_Placement_In_Check;\n+\n+         ---------------------------------------\n+         -- Check_Placement_In_Contract_Cases --\n+         ---------------------------------------\n+\n+         procedure Check_Placement_In_Contract_Cases (Prag : Node_Id) is\n+            Arg   : Node_Id;\n+            Cases : Node_Id;\n+            CCase : Node_Id;\n+\n+         begin\n+            --  Obtain the argument of the aspect or pragma\n+\n+            if Nkind (Prag) = N_Aspect_Specification then\n+               Arg := Prag;\n+            else\n+               Arg := First (Pragma_Argument_Associations (Prag));\n+            end if;\n+\n+            Cases := Expression (Arg);\n+\n+            if Present (Component_Associations (Cases)) then\n+               CCase := First (Component_Associations (Cases));\n+               while Present (CCase) loop\n+\n+                  --  Detect whether the attribute appears within the\n+                  --  consequence of the current contract case.\n+\n+                  if Nkind (CCase) = N_Component_Association\n+                    and then Is_Within (N, Expression (CCase))\n+                  then\n+                     return;\n+                  end if;\n+\n+                  Next (CCase);\n+               end loop;\n+            end if;\n+\n+            --  Otherwise aspect or pragma Contract_Cases is either malformed\n+            --  or the attribute does not appear within a consequence.\n+\n+            Error_Attr\n+              (\"attribute % must appear in the consequence of a contract case\",\n+               P);\n+         end Check_Placement_In_Contract_Cases;\n+\n+         ----------------------------------\n+         -- Check_Placement_In_Test_Case --\n+         ----------------------------------\n+\n+         procedure Check_Placement_In_Test_Case (Prag : Node_Id) is\n+            Arg : constant Node_Id :=\n+                    Test_Case_Arg\n+                      (Prag        => Prag,\n+                       Arg_Nam     => Name_Ensures,\n+                       From_Aspect => Nkind (Prag) = N_Aspect_Specification);\n+\n+         begin\n+            --  Detect whether the attribute appears within the \"Ensures\"\n+            --  expression of aspect or pragma Test_Case.\n+\n+            if Present (Arg) and then Is_Within (N, Arg) then\n+               null;\n+\n+            else\n+               Error_Attr\n+                 (\"attribute % must appear in the ensures expression of a \"\n+                  & \"test case\", P);\n+            end if;\n+         end Check_Placement_In_Test_Case;\n+\n+         ---------------\n+         -- Is_Within --\n+         ---------------\n+\n+         function Is_Within\n+           (Nod      : Node_Id;\n+            Encl_Nod : Node_Id) return Boolean\n+         is\n+            Par : Node_Id;\n+\n+         begin\n+            Par := Nod;\n+            while Present (Par) loop\n+               if Par = Encl_Nod then\n+                  return True;\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  exit;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n+            return False;\n+         end Is_Within;\n+\n+         --  Local variables\n+\n+         Prag      : Node_Id;\n+         Prag_Nam  : Name_Id;\n+         Subp_Decl : Node_Id;\n+\n+      --  Start of processing for Analyze_Attribute_Old_Result\n+\n+      begin\n+         --  Assume that the attribute is illegal\n+\n+         Legal   := False;\n+         Spec_Id := Empty;\n+\n+         --  Traverse the parent chain to find the aspect or pragma where the\n+         --  attribute resides.\n+\n+         Prag := N;\n+         while Present (Prag) loop\n+            if Nkind_In (Prag, N_Aspect_Specification, N_Pragma) then\n+               exit;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Prag) then\n+               exit;\n+            end if;\n+\n+            Prag := Parent (Prag);\n+         end loop;\n+\n+         --  The attribute is allowed to appear only in postcondition-like\n+         --  aspects or pragmas.\n+\n+         if Nkind_In (Prag, N_Aspect_Specification, N_Pragma) then\n+            if Nkind (Prag) = N_Aspect_Specification then\n+               Prag_Nam := Chars (Identifier (Prag));\n+            else\n+               Prag_Nam := Pragma_Name (Prag);\n+            end if;\n+\n+            if Prag_Nam = Name_Check then\n+               Check_Placement_In_Check (Prag);\n+\n+            elsif Prag_Nam = Name_Contract_Cases then\n+               Check_Placement_In_Contract_Cases (Prag);\n+\n+            elsif Nam_In (Prag_Nam, Name_Post,\n+                                    Name_Post_Class,\n+                                    Name_Postcondition,\n+                                    Name_Refined_Post)\n+            then\n+               null;\n+\n+            elsif Prag_Nam = Name_Test_Case then\n+               Check_Placement_In_Test_Case (Prag);\n+\n+            else\n+               Error_Attr (\"attribute % can only appear in postcondition\", P);\n+               return;\n+            end if;\n+\n+         --  Otherwise the placement of the attribute is illegal\n+\n+         else\n+            Error_Attr (\"attribute % can only appear in postcondition\", P);\n+            return;\n+         end if;\n+\n+         --  Find the related subprogram subject to the aspect or pragma\n+\n+         if Nkind (Prag) = N_Aspect_Specification then\n+            Subp_Decl := Parent (Prag);\n+         else\n+            Subp_Decl := Find_Related_Subprogram_Or_Body (Prag);\n+         end if;\n+\n+         --  The aspect or pragma where the attribute resides should be\n+         --  associated with a subprogram declaration or a body. If this is not\n+         --  the case, then the aspect or pragma is illegal. Return as analysis\n+         --  cannot be carried out.\n+\n+         if not Nkind_In (Subp_Decl, N_Abstract_Subprogram_Declaration,\n+                                     N_Entry_Declaration,\n+                                     N_Generic_Subprogram_Declaration,\n+                                     N_Subprogram_Body,\n+                                     N_Subprogram_Body_Stub,\n+                                     N_Subprogram_Declaration)\n+         then\n+            return;\n+         end if;\n+\n+         --  If we get here, then the attribute is legal\n+\n+         Legal   := True;\n+         Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n+      end Analyze_Attribute_Old_Result;\n+\n       ---------------------------------\n       -- Bad_Attribute_For_Predicate --\n       ---------------------------------\n@@ -2175,60 +2437,6 @@ package body Sem_Attr is\n          Error_Attr;\n       end Error_Attr_P;\n \n-      ---------------------\n-      -- In_Refined_Post --\n-      ---------------------\n-\n-      function In_Refined_Post return Boolean is\n-         function Is_Refined_Post (Prag : Node_Id) return Boolean;\n-         --  Determine whether Prag denotes one of the incarnations of pragma\n-         --  Refined_Post (either as is or pragma Check (Refined_Post, ...).\n-\n-         ---------------------\n-         -- Is_Refined_Post --\n-         ---------------------\n-\n-         function Is_Refined_Post (Prag : Node_Id) return Boolean is\n-            Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-            Nam  : constant Name_Id := Pragma_Name (Prag);\n-\n-         begin\n-            if Nam = Name_Refined_Post then\n-               return True;\n-\n-            elsif Nam = Name_Check then\n-               pragma Assert (Present (Args));\n-\n-               return Chars (Expression (First (Args))) = Name_Refined_Post;\n-            end if;\n-\n-            return False;\n-         end Is_Refined_Post;\n-\n-         --  Local variables\n-\n-         Stmt : Node_Id;\n-\n-      --  Start of processing for In_Refined_Post\n-\n-      begin\n-         Stmt := Parent (N);\n-         while Present (Stmt) loop\n-            if Nkind (Stmt) = N_Pragma and then Is_Refined_Post (Stmt) then\n-               return True;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Stmt) then\n-               exit;\n-            end if;\n-\n-            Stmt := Parent (Stmt);\n-         end loop;\n-\n-         return False;\n-      end In_Refined_Post;\n-\n       ----------------------------\n       -- Legal_Formal_Attribute --\n       ----------------------------\n@@ -4462,14 +4670,6 @@ package body Sem_Attr is\n          --  the related postcondition expression. Subp_Id is the subprogram to\n          --  which the related postcondition applies.\n \n-         procedure Check_Use_In_Contract_Cases (Prag : Node_Id);\n-         --  Perform various semantic checks related to the placement of the\n-         --  attribute in pragma Contract_Cases.\n-\n-         procedure Check_Use_In_Test_Case (Prag : Node_Id);\n-         --  Perform various semantic checks related to the placement of the\n-         --  attribute in pragma Contract_Cases.\n-\n          --------------------------------\n          -- Check_References_In_Prefix --\n          --------------------------------\n@@ -4504,14 +4704,17 @@ package body Sem_Attr is\n                --  case, then the scope of the local entity is nested within\n                --  that of the subprogram.\n \n-               elsif Nkind (Nod) = N_Identifier\n+               elsif Is_Entity_Name (Nod)\n                  and then Present (Entity (Nod))\n                  and then Scope_Within (Scope (Entity (Nod)), Subp_Id)\n                then\n                   Error_Attr\n                     (\"prefix of attribute % cannot reference local entities\",\n                      Nod);\n                   return Abandon;\n+\n+               --  Otherwise keep inspecting the prefix\n+\n                else\n                   return OK;\n                end if;\n@@ -4525,261 +4728,130 @@ package body Sem_Attr is\n             Check_References (P);\n          end Check_References_In_Prefix;\n \n-         ---------------------------------\n-         -- Check_Use_In_Contract_Cases --\n-         ---------------------------------\n-\n-         procedure Check_Use_In_Contract_Cases (Prag : Node_Id) is\n-            Cases : constant Node_Id :=\n-                      Get_Pragma_Arg\n-                        (First (Pragma_Argument_Associations (Prag)));\n-            Expr  : Node_Id;\n-\n-         begin\n-            --  Climb the parent chain to reach the top of the expression where\n-            --  attribute 'Old resides.\n-\n-            Expr := N;\n-            while Parent (Parent (Expr)) /= Cases loop\n-               Expr := Parent (Expr);\n-            end loop;\n-\n-            --  Ensure that the obtained expression is the consequence of a\n-            --  contract case as this is the only postcondition-like part of\n-            --  the pragma. Otherwise, attribute 'Old appears in the condition\n-            --  of a contract case. Emit an error since this is not a\n-            --  postcondition-like context. (SPARK RM 6.1.3(2))\n-\n-            if Expr /= Expression (Parent (Expr)) then\n-               Error_Attr\n-                 (\"attribute % cannot appear in the condition \"\n-                  & \"of a contract case\", P);\n-            end if;\n-         end Check_Use_In_Contract_Cases;\n-\n-         ----------------------------\n-         -- Check_Use_In_Test_Case --\n-         ----------------------------\n-\n-         procedure Check_Use_In_Test_Case (Prag : Node_Id) is\n-            Ensures : constant Node_Id := Test_Case_Arg (Prag, Name_Ensures);\n-            Expr    : Node_Id;\n-\n-         begin\n-            --  Climb the parent chain to reach the top of the Ensures part of\n-            --  pragma Test_Case.\n-\n-            Expr := N;\n-            while Expr /= Prag loop\n-               if Expr = Ensures then\n-                  return;\n-               end if;\n-\n-               Expr := Parent (Expr);\n-            end loop;\n-\n-            --  If we get there, then attribute 'Old appears in the requires\n-            --  expression of pragma Test_Case which is not a postcondition-\n-            --  like context.\n-\n-            Error_Attr\n-              (\"attribute % cannot appear in the requires expression of a \"\n-               & \"test case\", P);\n-         end Check_Use_In_Test_Case;\n-\n          --  Local variables\n \n-         CS : Entity_Id;\n-         --  The enclosing scope, excluding loops for quantified expressions.\n-         --  During analysis, it is the postcondition subprogram. During\n-         --  pre-analysis, it is the scope of the subprogram declaration.\n-\n-         Prag : Node_Id;\n-         --  During pre-analysis, Prag is the enclosing pragma node if any\n+         Legal    : Boolean;\n+         Pref_Id  : Entity_Id;\n+         Pref_Typ : Entity_Id;\n+         Spec_Id  : Entity_Id;\n \n       --  Start of processing for Old\n \n       begin\n-         Prag := Empty;\n-\n-         --  Find enclosing scopes, excluding loops\n-\n-         CS := Current_Scope;\n-         while Ekind (CS) = E_Loop loop\n-            CS := Scope (CS);\n-         end loop;\n-\n-         --  Check the legality of attribute 'Old when it appears inside pragma\n-         --  Refined_Post. These specialized checks are required only when code\n-         --  generation is disabled. In the general case pragma Refined_Post is\n-         --  transformed into pragma Check by Process_PPCs which in turn is\n-         --  relocated to procedure _Postconditions. From then on the legality\n-         --  of 'Old is determined as usual.\n+         --  The attribute reference is a primary. If any expressions follow,\n+         --  then the attribute reference is an indexable object. Transform the\n+         --  attribute into an indexed component and analyze it.\n \n-         if not Expander_Active and then In_Refined_Post then\n-            Preanalyze_And_Resolve (P);\n-            Check_References_In_Prefix (CS);\n-            P_Type := Etype (P);\n-            Set_Etype (N, P_Type);\n+         if Present (E1) then\n+            Rewrite (N,\n+              Make_Indexed_Component (Loc,\n+                Prefix      =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => Relocate_Node (P),\n+                    Attribute_Name => Name_Old),\n+                Expressions => Expressions (N)));\n+            Analyze (N);\n+            return;\n+         end if;\n \n-            if Is_Limited_Type (P_Type) then\n-               Error_Attr (\"attribute % cannot apply to limited objects\", P);\n-            end if;\n+         Analyze_Attribute_Old_Result (Legal, Spec_Id);\n \n-            if Is_Entity_Name (P)\n-              and then Is_Constant_Object (Entity (P))\n-            then\n-               Error_Msg_N\n-                 (\"??attribute Old applied to constant has no effect\", P);\n-            end if;\n+         --  The aspect or pragma where attribute 'Old resides should be\n+         --  associated with a subprogram declaration or a body. If this is not\n+         --  the case, then the aspect or pragma is illegal. Return as analysis\n+         --  cannot be carried out.\n \n+         if not Legal then\n             return;\n+         end if;\n \n-         --  A Contract_Cases, Postcondition or Test_Case pragma is in the\n-         --  process of being preanalyzed. Perform the semantic checks now\n-         --  before the pragma is relocated and/or expanded.\n-\n-         --  For a generic subprogram, postconditions are preanalyzed as well\n-         --  for name capture, and still appear within an aspect spec.\n-\n-         elsif In_Spec_Expression or Inside_A_Generic then\n-            Prag := N;\n-            while Present (Prag)\n-               and then not Nkind_In (Prag, N_Aspect_Specification,\n-                                            N_Function_Specification,\n-                                            N_Pragma,\n-                                            N_Procedure_Specification,\n-                                            N_Subprogram_Body)\n-            loop\n-               Prag := Parent (Prag);\n-            end loop;\n-\n-            --  In ASIS mode, the aspect itself is analyzed, in addition to the\n-            --  corresponding pragma. Don't issue errors when analyzing aspect.\n+         --  The prefix must be preanalyzed as the full analysis will take\n+         --  place during expansion.\n \n-            if Nkind (Prag) = N_Aspect_Specification\n-              and then Nam_In (Chars (Identifier (Prag)), Name_Post,\n-                                                          Name_Refined_Post)\n-            then\n-               null;\n+         Preanalyze_And_Resolve (P);\n \n-            --  In all other cases the related context must be a pragma\n+         --  Ensure that the prefix does not contain attributes 'Old or 'Result\n \n-            elsif Nkind (Prag) /= N_Pragma then\n-               Error_Attr (\"% attribute can only appear in postcondition\", P);\n+         Check_References_In_Prefix (Spec_Id);\n \n-            --  Verify the placement of the attribute with respect to the\n-            --  related pragma.\n+         --  Set the type of the attribute now to prevent cascaded errors\n \n-            else\n-               case Get_Pragma_Id (Prag) is\n-                  when Pragma_Contract_Cases =>\n-                     Check_Use_In_Contract_Cases (Prag);\n+         Pref_Typ := Etype (P);\n+         Set_Etype (N, Pref_Typ);\n \n-                  when Pragma_Postcondition | Pragma_Refined_Post =>\n-                     null;\n+         --  Legality checks\n \n-                  when Pragma_Test_Case =>\n-                     Check_Use_In_Test_Case (Prag);\n+         if Is_Limited_Type (Pref_Typ) then\n+            Error_Attr (\"attribute % cannot apply to limited objects\", P);\n+         end if;\n \n-                  when others =>\n-                     Error_Attr\n-                       (\"% attribute can only appear in postcondition\", P);\n-               end case;\n-            end if;\n+         --  The prefix is a simple name\n \n-         --  Body case, where we must be inside a generated _Postconditions\n-         --  procedure, or else the attribute use is definitely misplaced. The\n-         --  postcondition itself may have generated transient scopes, and is\n-         --  not necessarily the current one.\n+         if Is_Entity_Name (P) and then Present (Entity (P)) then\n+            Pref_Id := Entity (P);\n \n-         else\n-            while Present (CS) and then CS /= Standard_Standard loop\n-               if Chars (CS) = Name_uPostconditions then\n-                  exit;\n-               else\n-                  CS := Scope (CS);\n-               end if;\n-            end loop;\n+            --  Emit a warning when the prefix is a constant. Note that the use\n+            --  of Error_Attr would reset the type of N to Any_Type even though\n+            --  this is a warning. Use Error_Msg_XXX instead.\n \n-            if Chars (CS) /= Name_uPostconditions then\n-               Error_Attr (\"% attribute can only appear in postcondition\", P);\n+            if Is_Constant_Object (Pref_Id) then\n+               Error_Msg_Name_1 := Name_Old;\n+               Error_Msg_N\n+                 (\"??atribute % applied to constant has no effect\", P);\n             end if;\n-         end if;\n \n-         --  If the attribute reference is generated for a Requires clause,\n-         --  then no expressions follow. Otherwise it is a primary, in which\n-         --  case, if expressions follow, the attribute reference must be an\n-         --  indexable object, so rewrite the node accordingly.\n+         --  Otherwise the prefix is not a simple name\n \n-         if Present (E1) then\n-            Rewrite (N,\n-              Make_Indexed_Component (Loc,\n-                Prefix      =>\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => Relocate_Node (Prefix (N)),\n-                    Attribute_Name => Name_Old),\n-                Expressions => Expressions (N)));\n+         else\n+            --  Ensure that the prefix of attribute 'Old is an entity when it\n+            --  is potentially unevaluated (6.1.1 (27/3)).\n \n-            Analyze (N);\n-            return;\n-         end if;\n+            if Is_Potentially_Unevaluated (N) then\n+               Uneval_Old_Msg;\n \n-         Check_E0;\n+            --  Detect a possible infinite recursion when the prefix denotes\n+            --  the related function.\n \n-         --  Prefix has not been analyzed yet, and its full analysis will take\n-         --  place during expansion (see below).\n+            --    function Func (...) return ...\n+            --      with Post => Func'Old ...;\n \n-         Preanalyze_And_Resolve (P);\n-         Check_References_In_Prefix (CS);\n-         P_Type := Etype (P);\n-         Set_Etype (N, P_Type);\n+            elsif Nkind (P) = N_Function_Call then\n+               Pref_Id := Entity (Name (P));\n \n-         if Is_Limited_Type (P_Type) then\n-            Error_Attr (\"attribute % cannot apply to limited objects\", P);\n-         end if;\n+               if Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n+                 and then Pref_Id = Spec_Id\n+               then\n+                  Error_Msg_Warn := SPARK_Mode /= On;\n+                  Error_Msg_N (\"!possible infinite recursion<<\", P);\n+                  Error_Msg_N (\"\\!??Storage_Error ]<<\", P);\n+               end if;\n+            end if;\n \n-         if Is_Entity_Name (P)\n-           and then Is_Constant_Object (Entity (P))\n-         then\n-            Error_Msg_N\n-              (\"??attribute Old applied to constant has no effect\", P);\n-         end if;\n+            --  The prefix of attribute 'Old may refer to a component of a\n+            --  formal parameter. In this case its expansion may generate\n+            --  actual subtypes that are referenced in an inner context and\n+            --  that must be elaborated within the subprogram itself. If the\n+            --  prefix includes a function call, it may involve finalization\n+            --  actions that should be inserted when the attribute has been\n+            --  rewritten as a declaration. Create a declaration for the prefix\n+            --  and insert it at the start of the enclosing subprogram. This is\n+            --  an expansion activity that has to be performed now to prevent\n+            --  out-of-order issues.\n \n-         --  Check that the prefix of 'Old is an entity when it may be\n-         --  potentially unevaluated (6.1.1 (27/3)).\n+            --  This expansion is both harmful and not needed in SPARK mode,\n+            --  since the formal verification backend relies on the types of\n+            --  nodes (hence is not robust w.r.t. a change to base type here),\n+            --  and does not suffer from the out-of-order issue described\n+            --  above. Thus, this expansion is skipped in SPARK mode.\n \n-         if Present (Prag)\n-           and then Is_Potentially_Unevaluated (N)\n-           and then not Is_Entity_Name (P)\n-         then\n-            Uneval_Old_Msg;\n-         end if;\n+            if not GNATprove_Mode then\n+               Pref_Typ := Base_Type (Pref_Typ);\n+               Set_Etype (N, Pref_Typ);\n+               Set_Etype (P, Pref_Typ);\n \n-         --  The attribute appears within a pre/postcondition, but refers to\n-         --  an entity in the enclosing subprogram. If it is a component of\n-         --  a formal its expansion might generate actual subtypes that may\n-         --  be referenced in an inner context, and which must be elaborated\n-         --  within the subprogram itself. If the prefix includes a function\n-         --  call it may involve finalization actions that should only be\n-         --  inserted when the attribute has been rewritten as a declarations.\n-         --  As a result, if the prefix is not a simple name we create\n-         --  a declaration for it now, and insert it at the start of the\n-         --  enclosing subprogram. This is properly an expansion activity\n-         --  but it has to be performed now to prevent out-of-order issues.\n-\n-         --  This expansion is both harmful and not needed in SPARK mode, since\n-         --  the formal verification backend relies on the types of nodes\n-         --  (hence is not robust w.r.t. a change to base type here), and does\n-         --  not suffer from the out-of-order issue described above. Thus, this\n-         --  expansion is skipped in SPARK mode.\n-\n-         if not Is_Entity_Name (P) and then not GNATprove_Mode then\n-            P_Type := Base_Type (P_Type);\n-            Set_Etype (N, P_Type);\n-            Set_Etype (P, P_Type);\n-            Analyze_Dimension (N);\n-            Expand (N);\n+               Analyze_Dimension (N);\n+               Expand (N);\n+            end if;\n          end if;\n       end Old;\n \n@@ -4985,105 +5057,12 @@ package body Sem_Attr is\n       ------------\n \n       when Attribute_Result => Result : declare\n-         procedure Check_Placement_In_Check (Prag : Node_Id);\n-         --  Verify that attribute 'Result appears within pragma Check that\n-         --  emulates a postcondition.\n-\n-         procedure Check_Placement_In_Contract_Cases (Prag : Node_Id);\n-         --  Verify that attribute 'Result appears within a consequence of\n-         --  pragma Contract_Cases.\n-\n-         procedure Check_Placement_In_Test_Case (Prag : Node_Id);\n-         --  Verify that attribute 'Result appears within the Ensures argument\n-         --  of pragma Test_Case.\n-\n          function Denote_Same_Function\n            (Pref_Id : Entity_Id;\n             Spec_Id : Entity_Id) return Boolean;\n          --  Determine whether the entity of the prefix Pref_Id denotes the\n          --  same entity as that of the related subprogram Spec_Id.\n \n-         function Is_Within\n-           (Nod      : Node_Id;\n-            Encl_Nod : Node_Id) return Boolean;\n-         --  Subsidiary to Check_Placemenet_In_XXX_Case. Determine whether\n-         --  arbitrary node Nod is within enclosing node Encl_Nod.\n-\n-         ------------------------------\n-         -- Check_Placement_In_Check --\n-         ------------------------------\n-\n-         procedure Check_Placement_In_Check (Prag : Node_Id) is\n-            Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-            Nam  : constant Name_Id := Chars (Get_Pragma_Arg (First (Args)));\n-\n-         begin\n-            --  The \"Name\" argument of pragma Check denotes a postcondition\n-\n-            if Nam_In (Nam, Name_Post,\n-                            Name_Postcondition,\n-                            Name_Refined_Post)\n-            then\n-               null;\n-\n-            --  Otherwise the placement of attribute 'Result is illegal\n-\n-            else\n-               Error_Attr\n-                 (\"% attribute can only appear in postcondition of function\",\n-                  P);\n-            end if;\n-         end Check_Placement_In_Check;\n-\n-         ---------------------------------------\n-         -- Check_Placement_In_Contract_Cases --\n-         ---------------------------------------\n-\n-         procedure Check_Placement_In_Contract_Cases (Prag : Node_Id) is\n-            Args  : constant List_Id := Pragma_Argument_Associations (Prag);\n-            Cases : constant Node_Id := Get_Pragma_Arg (First (Args));\n-            CCase : Node_Id;\n-\n-         begin\n-            if Present (Component_Associations (Cases)) then\n-               CCase := First (Component_Associations (Cases));\n-               while Present (CCase) loop\n-\n-                  --  Guard against a malformed contract case. Detect whether\n-                  --  attribute 'Result appears within the consequence of the\n-                  --  current contract case.\n-\n-                  if Nkind (CCase) = N_Component_Association\n-                    and then Is_Within (N, Expression (CCase))\n-                  then\n-                     return;\n-                  end if;\n-\n-                  Next (CCase);\n-               end loop;\n-            end if;\n-\n-            --  Otherwise pragma Contract_Cases is either malformed in some\n-            --  way or attribute 'Result does not appear within a consequence\n-            --  expression.\n-\n-            Error_Attr (\"% attribute misplaced inside contract cases\", P);\n-         end Check_Placement_In_Contract_Cases;\n-\n-         ----------------------------------\n-         -- Check_Placement_In_Test_Case --\n-         ----------------------------------\n-\n-         procedure Check_Placement_In_Test_Case (Prag : Node_Id) is\n-         begin\n-            --  Detect whether attribute 'Result appears within the \"Ensures\"\n-            --  expression of pragma Test_Case.\n-\n-            if not Is_Within (N, Test_Case_Arg (Prag, Name_Ensures)) then\n-               Error_Attr (\"% attribute misplaced inside test case\", P);\n-            end if;\n-         end Check_Placement_In_Test_Case;\n-\n          --------------------------\n          -- Denote_Same_Function --\n          --------------------------\n@@ -5135,41 +5114,11 @@ package body Sem_Attr is\n             end if;\n          end Denote_Same_Function;\n \n-         ---------------\n-         -- Is_Within --\n-         ---------------\n-\n-         function Is_Within\n-           (Nod      : Node_Id;\n-            Encl_Nod : Node_Id) return Boolean\n-         is\n-            Par : Node_Id;\n-\n-         begin\n-            Par := Nod;\n-            while Present (Par) loop\n-               if Par = Encl_Nod then\n-                  return True;\n-\n-               --  Prevent the search from going too far\n-\n-               elsif Is_Body_Or_Package_Declaration (Par) then\n-                  exit;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n-\n-            return False;\n-         end Is_Within;\n-\n          --  Local variables\n \n-         Prag      : Node_Id;\n-         Prag_Id   : Pragma_Id;\n-         Pref_Id   : Entity_Id;\n-         Spec_Id   : Entity_Id;\n-         Subp_Decl : Node_Id;\n+         Legal   : Boolean;\n+         Pref_Id : Entity_Id;\n+         Spec_Id : Entity_Id;\n \n       --  Start of processing for Result\n \n@@ -5190,91 +5139,17 @@ package body Sem_Attr is\n             return;\n          end if;\n \n-         --  Traverse the parent chain to find the aspect or pragma where\n-         --  attribute 'Result resides.\n-\n-         Prag := N;\n-         while Present (Prag) loop\n-            if Nkind_In (Prag, N_Aspect_Specification, N_Pragma) then\n-               exit;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Prag) then\n-               exit;\n-            end if;\n-\n-            Prag := Parent (Prag);\n-         end loop;\n-\n-         --  Do not emit an error when preanalyzing an aspect for ASIS. If the\n-         --  placement of attribute 'Result is illegal, the error is reported\n-         --  when analyzing the corresponding pragma.\n-\n-         if ASIS_Mode and then Nkind (Prag) = N_Aspect_Specification then\n-            null;\n-\n-         --  Attribute 'Result is allowed to appear only in postcondition-like\n-         --  pragmas.\n-\n-         elsif Nkind (Prag) = N_Pragma then\n-            Prag_Id := Get_Pragma_Id (Prag);\n-\n-            if Prag_Id = Pragma_Check then\n-               Check_Placement_In_Check (Prag);\n-\n-            elsif Prag_Id = Pragma_Contract_Cases then\n-               Check_Placement_In_Contract_Cases (Prag);\n-\n-            elsif Prag_Id = Pragma_Postcondition\n-              or else Prag_Id = Pragma_Refined_Post\n-            then\n-               null;\n-\n-            elsif Prag_Id = Pragma_Test_Case then\n-               Check_Placement_In_Test_Case (Prag);\n-\n-            else\n-               Error_Attr\n-                 (\"% attribute can only appear in postcondition of function\",\n-                  P);\n-               return;\n-            end if;\n-\n-         --  Otherwise the placement of the attribute is illegal\n-\n-         else\n-            Error_Attr\n-              (\"% attribute can only appear in postcondition of function\", P);\n-            return;\n-         end if;\n-\n-         --  Attribute 'Result appears within a postcondition-like pragma. Find\n-         --  the related subprogram subject to the pragma.\n+         Analyze_Attribute_Old_Result (Legal, Spec_Id);\n \n-         if Nkind (Prag) = N_Aspect_Specification then\n-            Subp_Decl := Parent (Prag);\n-         else\n-            Subp_Decl := Find_Related_Subprogram_Or_Body (Prag);\n-         end if;\n-\n-         --  The pragma where attribute 'Result resides should be associated\n-         --  with a subprogram declaration or a body. If this is not the case,\n-         --  then the pragma is illegal. Return as analysis cannot be carried\n-         --  out.\n+         --  The aspect or pragma where attribute 'Result resides should be\n+         --  associated with a subprogram declaration or a body. If this is not\n+         --  the case, then the aspect or pragma is illegal. Return as analysis\n+         --  cannot be carried out.\n \n-         if not Nkind_In (Subp_Decl, N_Abstract_Subprogram_Declaration,\n-                                     N_Entry_Declaration,\n-                                     N_Generic_Subprogram_Declaration,\n-                                     N_Subprogram_Body,\n-                                     N_Subprogram_Body_Stub,\n-                                     N_Subprogram_Declaration)\n-         then\n+         if not Legal then\n             return;\n          end if;\n \n-         Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n-\n          --  Attribute 'Result is part of a _Postconditions procedure. There is\n          --  no need to perform the semantic checks below as they were already\n          --  verified when the attribute was analyzed in its original context.\n@@ -5309,23 +5184,23 @@ package body Sem_Attr is\n                   else\n                      Error_Msg_Name_2 := Chars (Spec_Id);\n                      Error_Attr\n-                       (\"incorrect prefix for % attribute, expected %\", P);\n+                       (\"incorrect prefix for attribute %, expected %\", P);\n                   end if;\n \n                --  Otherwise the prefix denotes some other form of subprogram\n                --  entity.\n \n                else\n                   Error_Attr\n-                    (\"% attribute can only appear in postcondition of \"\n+                    (\"attribute % can only appear in postcondition of \"\n                      & \"function\", P);\n                end if;\n \n             --  Otherwise the prefix is illegal\n \n             else\n                Error_Msg_Name_2 := Chars (Spec_Id);\n-               Error_Attr (\"incorrect prefix for % attribute, expected %\", P);\n+               Error_Attr (\"incorrect prefix for attribute %, expected %\", P);\n             end if;\n          end if;\n       end Result;"}, {"sha": "b0e80116225e58012f06de9e35025c5228028f26", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a56408a630f3fe20b4664520302adab8bd10a6/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=b6a56408a630f3fe20b4664520302adab8bd10a6", "patch": "@@ -723,28 +723,33 @@ package body Sem_Warn is\n    ----------------------------\n \n    procedure Check_Low_Bound_Tested (Expr : Node_Id) is\n+      procedure Check_Low_Bound_Tested_For (Opnd : Node_Id);\n+      --  Determine whether operand Opnd denotes attribute 'First whose prefix\n+      --  is a formal parameter. If this is the case, mark the entity of the\n+      --  prefix as having its low bound tested.\n+\n+      --------------------------------\n+      -- Check_Low_Bound_Tested_For --\n+      --------------------------------\n+\n+      procedure Check_Low_Bound_Tested_For (Opnd : Node_Id) is\n+      begin\n+         if Nkind (Opnd) = N_Attribute_Reference\n+           and then Attribute_Name (Opnd) = Name_First\n+           and then Is_Entity_Name (Prefix (Opnd))\n+           and then Present (Entity (Prefix (Opnd)))\n+           and then Is_Formal (Entity (Prefix (Opnd)))\n+         then\n+            Set_Low_Bound_Tested (Entity (Prefix (Opnd)));\n+         end if;\n+      end Check_Low_Bound_Tested_For;\n+\n+   --  Start of processing for Check_Low_Bound_Tested\n+\n    begin\n       if Comes_From_Source (Expr) then\n-         declare\n-            L : constant Node_Id := Left_Opnd (Expr);\n-            R : constant Node_Id := Right_Opnd (Expr);\n-         begin\n-            if Nkind (L) = N_Attribute_Reference\n-              and then Attribute_Name (L) = Name_First\n-              and then Is_Entity_Name (Prefix (L))\n-              and then Is_Formal (Entity (Prefix (L)))\n-            then\n-               Set_Low_Bound_Tested (Entity (Prefix (L)));\n-            end if;\n-\n-            if Nkind (R) = N_Attribute_Reference\n-              and then Attribute_Name (R) = Name_First\n-              and then Is_Entity_Name (Prefix (R))\n-              and then Is_Formal (Entity (Prefix (R)))\n-            then\n-               Set_Low_Bound_Tested (Entity (Prefix (R)));\n-            end if;\n-         end;\n+         Check_Low_Bound_Tested_For (Left_Opnd  (Expr));\n+         Check_Low_Bound_Tested_For (Right_Opnd (Expr));\n       end if;\n    end Check_Low_Bound_Tested;\n "}]}