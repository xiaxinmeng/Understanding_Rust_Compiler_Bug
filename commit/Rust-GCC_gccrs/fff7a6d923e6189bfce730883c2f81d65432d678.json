{"sha": "fff7a6d923e6189bfce730883c2f81d65432d678", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmN2E2ZDkyM2U2MTg5YmZjZTczMDg4M2MyZjgxZDY1NDMyZDY3OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-12-10T13:19:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-29T08:00:47Z"}, "message": "[Ada] Bad handling of array sliding in aggregate\n\ngcc/ada/\n\n\t* exp_aggr.adb (Collect_Initialization_Statements): Removed.\n\t(Convert_Aggr_In_Object_Decl, Expand_Array_Aggregate): Fix\n\tcreation and insertion of Initialization_Statements.  Do not set\n\tInitialization_Statements when a transient scope is involved.\n\tMove processing of Array_Slice here.  Ensure that an object with\n\tan Array_Slice call gets its array component initialized.  Add\n\tcomments.\n\t* exp_ch7.adb: Update comments.\n\t(Store_Actions_In_Scope): Deal properly with an empty list which\n\tmight now be generated by Convert_Aggr_In_Object_Decl.\n\t* exp_ch3.adb: Update comments.\n\t(Expand_N_Object_Declaration): Remove processing of Array_Slice.", "tree": {"sha": "638492cbfef68e043a6697994f44d8ad66f06525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/638492cbfef68e043a6697994f44d8ad66f06525"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fff7a6d923e6189bfce730883c2f81d65432d678", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff7a6d923e6189bfce730883c2f81d65432d678", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff7a6d923e6189bfce730883c2f81d65432d678", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff7a6d923e6189bfce730883c2f81d65432d678/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c837e5bf7e68634e65a1b1f5e6052a9aeaae1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c837e5bf7e68634e65a1b1f5e6052a9aeaae1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c837e5bf7e68634e65a1b1f5e6052a9aeaae1bb"}], "stats": {"total": 143, "additions": 71, "deletions": 72}, "files": [{"sha": "c719b02408441008f3903a5ef4166f2aac448f7f", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 65, "deletions": 58, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff7a6d923e6189bfce730883c2f81d65432d678/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff7a6d923e6189bfce730883c2f81d65432d678/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=fff7a6d923e6189bfce730883c2f81d65432d678", "patch": "@@ -78,15 +78,6 @@ package body Exp_Aggr is\n    type Case_Table_Type is array (Nat range <>) of Case_Bounds;\n    --  Table type used by Check_Case_Choices procedure\n \n-   procedure Collect_Initialization_Statements\n-     (Obj        : Entity_Id;\n-      N          : Node_Id;\n-      Node_After : Node_Id);\n-   --  If Obj is not frozen, collect actions inserted after N until, but not\n-   --  including, Node_After, for initialization of Obj, and move them to an\n-   --  expression with actions, which becomes the Initialization_Statements for\n-   --  Obj.\n-\n    procedure Expand_Delta_Array_Aggregate  (N : Node_Id; Deltas : List_Id);\n    procedure Expand_Delta_Record_Aggregate (N : Node_Id; Deltas : List_Id);\n    procedure Expand_Container_Aggregate (N : Node_Id);\n@@ -4210,40 +4201,6 @@ package body Exp_Aggr is\n       return L;\n    end Build_Record_Aggr_Code;\n \n-   ---------------------------------------\n-   -- Collect_Initialization_Statements --\n-   ---------------------------------------\n-\n-   procedure Collect_Initialization_Statements\n-     (Obj        : Entity_Id;\n-      N          : Node_Id;\n-      Node_After : Node_Id)\n-   is\n-      Loc          : constant Source_Ptr := Sloc (N);\n-      Init_Actions : constant List_Id    := New_List;\n-      Init_Node    : Node_Id;\n-      Comp_Stmt    : Node_Id;\n-\n-   begin\n-      --  Nothing to do if Obj is already frozen, as in this case we known we\n-      --  won't need to move the initialization statements about later on.\n-\n-      if Is_Frozen (Obj) then\n-         return;\n-      end if;\n-\n-      Init_Node := N;\n-      while Next (Init_Node) /= Node_After loop\n-         Append_To (Init_Actions, Remove_Next (Init_Node));\n-      end loop;\n-\n-      if not Is_Empty_List (Init_Actions) then\n-         Comp_Stmt := Make_Compound_Statement (Loc, Actions => Init_Actions);\n-         Insert_Action_After (Init_Node, Comp_Stmt);\n-         Set_Initialization_Statements (Obj, Comp_Stmt);\n-      end if;\n-   end Collect_Initialization_Statements;\n-\n    -------------------------------\n    -- Convert_Aggr_In_Allocator --\n    -------------------------------\n@@ -4314,6 +4271,8 @@ package body Exp_Aggr is\n       Typ  : constant Entity_Id  := Etype (Aggr);\n       Occ  : constant Node_Id    := New_Occurrence_Of (Obj, Loc);\n \n+      Has_Transient_Scope : Boolean := False;\n+\n       function Discriminants_Ok return Boolean;\n       --  If the object type is constrained, the discriminants in the\n       --  aggregate must be checked against the discriminants of the subtype.\n@@ -4405,7 +4364,7 @@ package body Exp_Aggr is\n       --  the finalization list of the return must be moved to the caller's\n       --  finalization list to complete the return.\n \n-      --  However, if the aggregate is limited, it is built in place, and the\n+      --  Similarly if the aggregate is limited, it is built in place, and the\n       --  controlled components are not assigned to intermediate temporaries\n       --  so there is no need for a transient scope in this case either.\n \n@@ -4414,13 +4373,60 @@ package body Exp_Aggr is\n         and then not Is_Limited_Type (Typ)\n       then\n          Establish_Transient_Scope (Aggr, Manage_Sec_Stack => False);\n+         Has_Transient_Scope := True;\n       end if;\n \n       declare\n-         Node_After : constant Node_Id := Next (N);\n+         Stmts : constant List_Id := Late_Expansion (Aggr, Typ, Occ);\n+         Stmt  : Node_Id;\n+         Param : Node_Id;\n+\n       begin\n-         Insert_Actions_After (N, Late_Expansion (Aggr, Typ, Occ));\n-         Collect_Initialization_Statements (Obj, N, Node_After);\n+         --  If Obj is already frozen or if N is wrapped in a transient scope,\n+         --  Stmts do not need to be saved in Initialization_Statements since\n+         --  there is no freezing issue.\n+\n+         if Is_Frozen (Obj) or else Has_Transient_Scope then\n+            Insert_Actions_After (N, Stmts);\n+         else\n+            Stmt := Make_Compound_Statement (Sloc (N), Actions => Stmts);\n+            Insert_Action_After (N, Stmt);\n+\n+            --  Insert_Action_After may freeze Obj in which case we should\n+            --  remove the compound statement just created and simply insert\n+            --  Stmts after N.\n+\n+            if Is_Frozen (Obj) then\n+               Remove (Stmt);\n+               Insert_Actions_After (N, Stmts);\n+            else\n+               Set_Initialization_Statements (Obj, Stmt);\n+            end if;\n+         end if;\n+\n+         --  If Typ has controlled components and a call to a Slice_Assign\n+         --  procedure is part of the initialization statements, then we\n+         --  need to initialize the array component since Slice_Assign will\n+         --  need to adjust it.\n+\n+         if Has_Controlled_Component (Typ) then\n+            Stmt := First (Stmts);\n+\n+            while Present (Stmt) loop\n+               if Nkind (Stmt) = N_Procedure_Call_Statement\n+                 and then Get_TSS_Name (Entity (Name (Stmt)))\n+                            = TSS_Slice_Assign\n+               then\n+                  Param := First (Parameter_Associations (Stmt));\n+                  Insert_Actions\n+                    (Stmt,\n+                     Build_Initialization_Call\n+                       (Sloc (N), New_Copy_Tree (Param), Etype (Param)));\n+               end if;\n+\n+               Next (Stmt);\n+            end loop;\n+         end if;\n       end;\n \n       Set_No_Initialization (N);\n@@ -6793,25 +6799,26 @@ package body Exp_Aggr is\n       --  code must be inserted after it. The defining entity might not come\n       --  from source if this is part of an inlined body, but the declaration\n       --  itself will.\n+      --  The test below looks very specialized and kludgy???\n \n       if Comes_From_Source (Tmp)\n         or else\n           (Nkind (Parent (N)) = N_Object_Declaration\n             and then Comes_From_Source (Parent (N))\n             and then Tmp = Defining_Entity (Parent (N)))\n       then\n-         declare\n-            Node_After : constant Node_Id := Next (Parent_Node);\n-\n-         begin\n+         if Parent_Kind /= N_Object_Declaration or else Is_Frozen (Tmp) then\n             Insert_Actions_After (Parent_Node, Aggr_Code);\n-\n-            if Parent_Kind = N_Object_Declaration then\n-               Collect_Initialization_Statements\n-                 (Obj => Tmp, N => Parent_Node, Node_After => Node_After);\n-            end if;\n-         end;\n-\n+         else\n+            declare\n+               Comp_Stmt : constant Node_Id :=\n+                 Make_Compound_Statement\n+                   (Sloc (Parent_Node), Actions => Aggr_Code);\n+            begin\n+               Insert_Action_After (Parent_Node, Comp_Stmt);\n+               Set_Initialization_Statements (Tmp, Comp_Stmt);\n+            end;\n+         end if;\n       else\n          Insert_Actions (N, Aggr_Code);\n       end if;"}, {"sha": "f3729852c4e1892b1d96abdad0eaacac311c8ff4", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff7a6d923e6189bfce730883c2f81d65432d678/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff7a6d923e6189bfce730883c2f81d65432d678/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=fff7a6d923e6189bfce730883c2f81d65432d678", "patch": "@@ -124,7 +124,7 @@ package body Exp_Ch3 is\n    --  Build assignment procedure for one-dimensional arrays of controlled\n    --  types. Other array and slice assignments are expanded in-line, but\n    --  the code expansion for controlled components (when control actions\n-   --  are active) can lead to very large blocks that GCC3 handles poorly.\n+   --  are active) can lead to very large blocks that GCC handles poorly.\n \n    procedure Build_Untagged_Equality (Typ : Entity_Id);\n    --  AI05-0123: Equality on untagged records composes. This procedure\n@@ -4168,7 +4168,7 @@ package body Exp_Ch3 is\n \n    --  Generates the following subprogram:\n \n-   --    procedure Assign\n+   --    procedure array_typeSA\n    --     (Source,  Target    : Array_Type,\n    --      Left_Lo, Left_Hi   : Index;\n    --      Right_Lo, Right_Hi : Index;\n@@ -4178,7 +4178,6 @@ package body Exp_Ch3 is\n    --       Ri1 : Index;\n \n    --    begin\n-\n    --       if Left_Hi < Left_Lo then\n    --          return;\n    --       end if;\n@@ -4204,7 +4203,7 @@ package body Exp_Ch3 is\n    --             Ri1 := Index'succ (Ri1);\n    --          end if;\n    --       end loop;\n-   --    end Assign;\n+   --    end array_typeSA;\n \n    procedure Build_Slice_Assignment (Typ : Entity_Id) is\n       Loc   : constant Source_Ptr := Sloc (Typ);\n@@ -6561,7 +6560,7 @@ package body Exp_Ch3 is\n          if Needs_Finalization (Typ) and then not No_Initialization (N) then\n             Obj_Init :=\n               Make_Init_Call\n-                (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                (Obj_Ref => New_Object_Reference,\n                  Typ     => Typ);\n          end if;\n \n@@ -6977,11 +6976,7 @@ package body Exp_Ch3 is\n       else\n          --  Obtain actual expression from qualified expression\n \n-         if Nkind (Expr) = N_Qualified_Expression then\n-            Expr_Q := Expression (Expr);\n-         else\n-            Expr_Q := Expr;\n-         end if;\n+         Expr_Q := Unqualify (Expr);\n \n          --  When we have the appropriate type of aggregate in the expression\n          --  (it has been determined during analysis of the aggregate by"}, {"sha": "0315458da0a0165d042940464513b70e626e1f4b", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff7a6d923e6189bfce730883c2f81d65432d678/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff7a6d923e6189bfce730883c2f81d65432d678/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=fff7a6d923e6189bfce730883c2f81d65432d678", "patch": "@@ -153,9 +153,6 @@ package body Exp_Ch7 is\n    procedure Set_Node_To_Be_Wrapped (N : Node_Id);\n    --  Set the field Node_To_Be_Wrapped of the current scope\n \n-   --  ??? The entire comment needs to be rewritten\n-   --  ??? which entire comment?\n-\n    procedure Store_Actions_In_Scope (AK : Scope_Action_Kind; L : List_Id);\n    --  Shared processing for Store_xxx_Actions_In_Scope\n \n@@ -9841,7 +9838,7 @@ package body Exp_Ch7 is\n       Actions : List_Id renames SE.Actions_To_Be_Wrapped (AK);\n \n    begin\n-      if No (Actions) then\n+      if Is_Empty_List (Actions) then\n          Actions := L;\n \n          if Is_List_Member (SE.Node_To_Be_Wrapped) then"}]}