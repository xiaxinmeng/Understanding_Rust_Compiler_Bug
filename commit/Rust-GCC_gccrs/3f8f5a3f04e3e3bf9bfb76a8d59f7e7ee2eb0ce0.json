{"sha": "3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4ZjVhM2YwNGUzZTNiZjliZmI3NmE4ZDU5ZjdlN2VlMmViMGNlMA==", "commit": {"author": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-07-06T15:16:19Z"}, "committer": {"name": "Timothy Moore", "email": "moore@gnu.org", "date": "1992-07-06T15:16:19Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1460", "tree": {"sha": "b64bcca3f5e606c4a0bb46b2ef5d2d4cc6453481", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b64bcca3f5e606c4a0bb46b2ef5d2d4cc6453481"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0/comments", "author": null, "committer": null, "parents": [{"sha": "17d71a73a9ebdd2b58740526dc7af91a7e07a786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17d71a73a9ebdd2b58740526dc7af91a7e07a786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17d71a73a9ebdd2b58740526dc7af91a7e07a786"}], "stats": {"total": 57, "additions": 30, "deletions": 27}, "files": [{"sha": "a0181e927dac60a0e031156b6151ab85dfb68256", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3f8f5a3f04e3e3bf9bfb76a8d59f7e7ee2eb0ce0", "patch": "@@ -76,15 +76,13 @@ enum cmp_type\t\t\t\t/* comparison type */\n \n /* Print subsidiary information on the compiler version in use.  */\n \n-#define TARGET_VERSION fprintf (stderr, \" (hp9000s800)\");\n+#define TARGET_VERSION fprintf (stderr, \" (hppa)\");\n \n-/* Run-time compilation parameters selecting different hardware subsets.\n-\n-   On the the hp9k800, we don't yet need any. But ... */\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n \n-/* compile code for PA-RISC 1.1 (\"Snake\") */\n+/* compile code for HP-PA 1.1 (\"Snake\") */\n \n #define TARGET_SNAKE (target_flags & 1)\n \n@@ -112,7 +110,7 @@ extern int target_flags;\n \n /* Define this if most significant word of a multiword number is lowest\n    numbered.  */\n-/* For the hp9k800 we can decide arbitrarily\n+/* For the HP-PA we can decide arbitrarily\n    since there are no machine instructions for them.  */\n #define WORDS_BIG_ENDIAN 1\n \n@@ -183,13 +181,13 @@ extern int target_flags;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.\n \n-   The hp9k800 has 32 fullword registers and 16 floating point\n+   HP-PA 1.0 has 32 fullword registers and 16 floating point\n    registers. The floating point registers hold either word or double\n    word values.\n    \n    16 additional registers are reserved.\n    \n-   PA-RISC 1.1 has 32 fullword registers and 32 floating point\n+   HP-PA 1.1 has 32 fullword registers and 32 floating point\n    registers. However, the floating point registers behave\n    differently: the left and right halves of registers are addressable\n    as 32 bit registers. So, we will set things up like the 68k which\n@@ -202,7 +200,7 @@ extern int target_flags;\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n \n-   On the hp9k800, these are:\n+   On the HP-PA, these are:\n    Reg 0\t= 0 (hardware). However, 0 is used for condition code,\n                   so is not fixed.\n    Reg 1\t= ADDIL target/Temporary (hardware).\n@@ -343,15 +341,15 @@ extern int target_flags;\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On the hp9k800, ordinary registers hold 32 bits worth;\n+   On the HP-PA, ordinary registers hold 32 bits worth;\n    The floating point registers are 64 bits wide. Snake fp regs are 32\n    bits wide */\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   (((REGNO) < 32 || (REGNO) >= 48)\t\\\n    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) : 1)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the hp9k800, the cpu registers can hold any mode.  We\n+   On the HP-PA, the cpu registers can hold any mode.  We\n    force this to be an even register is it cannot hold the full mode.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n@@ -370,7 +368,7 @@ extern int target_flags;\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n-/* the hp9k800 pc isn't overloaded on a register that the compiler knows about.  */\n+/* The HP-PA pc isn't overloaded on a register that the compiler knows about.  */\n /* #define PC_REGNUM  */\n \n /* Register to use for pushing function arguments.  */\n@@ -437,7 +435,7 @@ extern int leaf_function;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-  /* The hp9k800 has four kinds of registers: general regs, 1.0 fp regs,\n+  /* The HP-PA has four kinds of registers: general regs, 1.0 fp regs,\n      1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n      fmpyadd and fmpysub are restricted. */\n \n@@ -505,7 +503,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \n-HP9000/800 immediate field sizes:\n+HP-PA immediate field sizes:\n   5 bits: scalar/floating short loads + stores; deposit; conditional branch\n   11 bits: arithmetic immediate, compare immediate\n   14 bits: loads and stores; load offset\n@@ -573,7 +571,7 @@ HP9000/800 immediate field sizes:\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n-   On the hp9k800, don't define this because there are no push insns.  */\n+   On the HP-PA, don't define this because there are no push insns.  */\n /*  #define PUSH_ROUNDING(BYTES) */\n \n /* Offset of first parameter from the argument pointer register value.\n@@ -630,7 +628,7 @@ HP9000/800 immediate field sizes:\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n-/* On the hp9k800 the value is found in register(s) 28(-29), unless\n+/* On the HP-PA the value is found in register(s) 28(-29), unless\n    the mode is SF or DF. Then the value is returned in fr4 (36, ) */\n \n \n@@ -666,7 +664,7 @@ HP9000/800 immediate field sizes:\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.\n \n-   On the hp9k800, this is a single integer, which is a number of words\n+   On the HP-PA, this is a single integer, which is a number of words\n    of arguments scanned so far (including the invisible argument,\n    if any, which holds the structure-value-address).\n    Thus 4 or more means all following args should go on the stack.  */\n@@ -706,7 +704,7 @@ HP9000/800 immediate field sizes:\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-/* On the hp9k800 the first four words of args are normally in registers\n+/* On the HP-PA the first four words of args are normally in registers\n    and the rest are pushed.  But any arg that won't entirely fit in regs\n    is pushed.  */\n \n@@ -783,8 +781,13 @@ extern enum cmp_type hppa_branch_type;\n \t\t   fprintf (FILE, \",ARGW%d=FR\", i++);\t\t\t\\\n \t\t else if (TYPE_MODE (DECL_ARG_TYPE (parm)) == DFmode)\t\\\n \t\t   {\t\t\t\t\t\t\t\\\n-\t\t      if (i == 1) i++;\t\t\t\t        \\\n-\t\t      ASM_DOUBLE_ARG_DESCRIPTORS (FILE, i++, i++);\t\\\n+\t\t     if (i <= 2)\t\t\t\t\t\\\n+\t\t       {\t\t\t\t\t\t\\\n+\t\t\t if (i == 1) i++;\t\t\t\t\\\n+\t\t\t ASM_DOUBLE_ARG_DESCRIPTORS (FILE, i++, i++);\t\\\n+\t\t       }\t\t\t\t\t\t\\\n+\t\t     else\t\t\t\t\t\t\\\n+\t\t       break;\t\t\t\t\t\t\\\n \t\t   }\t\t\t\t\t\t\t\\\n \t\t else\t\t\t\t\t\t\t\\\n \t\t   {\t\t\t\t\t\t\t\\\n@@ -957,7 +960,7 @@ extern union tree_node *current_function_decl;\n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n \n-   These macros are specific to the the hp9k800, and may be used only\n+   These macros are specific to the the HP-PA, and may be used only\n    in code for printing assembler insns and in conditions for\n    define_optimization.  */\n \n@@ -1060,7 +1063,7 @@ extern union tree_node *current_function_decl;\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.\n \n-   On the hp9k800, the actual legitimate addresses must be\n+   On the HP-PA, the actual legitimate addresses must be\n    REG+REG, REG+(REG*SCALE) or REG+SMALLINT.\n    But we can treat a SYMBOL_REF as legitimate if it is part of this\n    function's constant-pool, because such addresses can actually\n@@ -1149,7 +1152,7 @@ extern union tree_node *current_function_decl;\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.  */\n \n-/* On the hp9k800, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n+/* On the HP-PA, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n { if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n@@ -1206,7 +1209,7 @@ extern union tree_node *current_function_decl;\n    name string in the `symbol_ref' (if one bit is not enough\n    information).\n \n-   On the PA-RISC we use this to indicate if a symbol is in text or\n+   On the HP-PA we use this to indicate if a symbol is in text or\n    data space.  */\n \n #define ENCODE_SECTION_INFO(DECL)\\\n@@ -1378,7 +1381,7 @@ do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n \n #define ASM_APP_OFF \"\"\n \n-/* We don't yet know how to identify GCC to HP series 800.  */\n+/* We don't yet know how to identify GCC to HP-PA machines.  */\n #define ASM_IDENTIFY_GCC(FILE) fprintf (FILE, \"; gcc_compiled.:\\n\")\n \n /* Output before code.  */\n@@ -1541,7 +1544,7 @@ do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n   fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n-   (the hp9k800 does not use such vectors,\n+   (The HP-PA does not use such vectors,\n    but we must define this macro anyway.)  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n@@ -1605,7 +1608,7 @@ do { fprintf (FILE, \"\\t.SPACE $PRIVATE$\\n\\\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.\n \n-   On the hp9k800, the CODE can be `r', meaning this is a register-only operand\n+   On the HP-PA, the CODE can be `r', meaning this is a register-only operand\n    and an immediate zero should be represented as `r0'.\n \n    Several % codes are defined:"}]}