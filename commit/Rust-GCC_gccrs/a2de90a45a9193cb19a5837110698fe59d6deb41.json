{"sha": "a2de90a45a9193cb19a5837110698fe59d6deb41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJkZTkwYTQ1YTkxOTNjYjE5YTU4MzcxMTA2OThmZTU5ZDZkZWI0MQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2017-09-01T11:43:51Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2017-09-01T11:43:51Z"}, "message": "[ARC] Reimplement ZOL support.\n\n2017-05-22  Claudiu Zissulescu <claziss@synopsys.com>\n\n\t* config/arc/arc-c.c (__ARC_LPC_WIDTH__): Add builtin define.\n\t* config/arc/arc.c (ARC_MAX_LOOP_LENGTH): Define.\n\t(arc_conditional_register_usage): Remove ARC600 lp_count\n\texception.\n\t(arc_file_start): Emit Tag_ARC_CPU_variation.\n\t(arc_can_use_doloop_p): New conditions to use ZOLs.\n\t(hwloop_fail): New function.\n\t(hwloop_optimize): Likewise.\n\t(hwloop_pattern_reg): Likewise.\n\t(arc_doloop_hooks): New struct, to be used with reorg_loops.\n\t(arc_reorg_loops): New function, calls reorg_loops.\n\t(arc_reorg): Call arc_reorg_loops.  Remove old ZOL handling.\n\t(arc600_corereg_hazard): Remove ZOL checking, case handled by\n\thwloop_optimize.\n\t(arc_loop_hazard): Remove function, functionality moved into\n\thwloop_optimize.\n\t(arc_hazard): Remove arc_loop_hazard call.\n\t(arc_adjust_insn_length): Remove ZOL handling, functionality moved\n\tinto hwloop_optimize.\n\t(arc_label_align): Remove ZOL handling.\n\t* config/arc/arc.h (LOOP_ALIGN): Changed to 0.\n\t* config/arc/arc.md (doloop_begin): Remove pattern.\n\t(doloop_begin_i): Likewise.\n\t(doloop_end_i): Likewise.\n\t(doloop_fallback): Likewise.\n\t(doloop_fallback_m): Likewise.\n\t(doloop_end): Reimplement expand.\n\t(arc_lp): New pattern for LP instruction.\n\t(loop_end): New pattern.\n\t(loop_fail): Likewise.\n\t(decrement_and_branch_until_zero): Likewise.\n\t* config/arc/arc.opt (mlpc-width): New option.\n\t* doc/invoke.texi (mlpc-width): Document option.\n\ntestsuite/\n2017-05-22  Claudiu Zissulescu <claziss@synopsys.com>\n\n \t    * gcc.target/arc/loop-1.c: Deleted.\n\nFrom-SVN: r251589", "tree": {"sha": "efe25ca85f6d3a5f7496251262247e817b30cc0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efe25ca85f6d3a5f7496251262247e817b30cc0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2de90a45a9193cb19a5837110698fe59d6deb41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2de90a45a9193cb19a5837110698fe59d6deb41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2de90a45a9193cb19a5837110698fe59d6deb41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2de90a45a9193cb19a5837110698fe59d6deb41/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "782bdf21895dc769cfd85a08c8c1b780924775f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782bdf21895dc769cfd85a08c8c1b780924775f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782bdf21895dc769cfd85a08c8c1b780924775f3"}], "stats": {"total": 1274, "additions": 584, "deletions": 690}, "files": [{"sha": "61ba8994f13daa6d6e0483aaed1bc8799760499b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -1,3 +1,39 @@\n+2017-09-01  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-c.c (__ARC_LPC_WIDTH__): Add builtin define.\n+\t* config/arc/arc.c (ARC_MAX_LOOP_LENGTH): Define.\n+\t(arc_conditional_register_usage): Remove ARC600 lp_count\n+\texception.\n+\t(arc_file_start): Emit Tag_ARC_CPU_variation.\n+\t(arc_can_use_doloop_p): New conditions to use ZOLs.\n+\t(hwloop_fail): New function.\n+\t(hwloop_optimize): Likewise.\n+\t(hwloop_pattern_reg): Likewise.\n+\t(arc_doloop_hooks): New struct, to be used with reorg_loops.\n+\t(arc_reorg_loops): New function, calls reorg_loops.\n+\t(arc_reorg): Call arc_reorg_loops.  Remove old ZOL handling.\n+\t(arc600_corereg_hazard): Remove ZOL checking, case handled by\n+\thwloop_optimize.\n+\t(arc_loop_hazard): Remove function, functionality moved into\n+\thwloop_optimize.\n+\t(arc_hazard): Remove arc_loop_hazard call.\n+\t(arc_adjust_insn_length): Remove ZOL handling, functionality moved\n+\tinto hwloop_optimize.\n+\t(arc_label_align): Remove ZOL handling.\n+\t* config/arc/arc.h (LOOP_ALIGN): Changed to 0.\n+\t* config/arc/arc.md (doloop_begin): Remove pattern.\n+\t(doloop_begin_i): Likewise.\n+\t(doloop_end_i): Likewise.\n+\t(doloop_fallback): Likewise.\n+\t(doloop_fallback_m): Likewise.\n+\t(doloop_end): Reimplement expand.\n+\t(arc_lp): New pattern for LP instruction.\n+\t(loop_end): New pattern.\n+\t(loop_fail): Likewise.\n+\t(decrement_and_branch_until_zero): Likewise.\n+\t* config/arc/arc.opt (mlpc-width): New option.\n+\t* doc/invoke.texi (mlpc-width): Document option.\n+\n 2017-09-01  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc.c (arc_ifcvt): Remove use of merge_blocks call."}, {"sha": "44ff338c26997c062a92964ae98530b2cfbaeb02", "filename": "gcc/config/arc/arc-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-c.c?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -62,6 +62,8 @@ arc_cpu_cpp_builtins (cpp_reader * pfile)\n   builtin_define_with_int_value (\"__ARC_TLS_REGNO__\",\n \t\t\t\t arc_tp_regno);\n \n+  builtin_define_with_int_value (\"__ARC_LPC_WIDTH__\", arc_lpcwidth);\n+\n   builtin_define (TARGET_BIG_ENDIAN\n \t\t  ? \"__BIG_ENDIAN__\" : \"__LITTLE_ENDIAN__\");\n   if (TARGET_BIG_ENDIAN)"}, {"sha": "9704240b50776950261f94693b063663614fa808", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 382, "deletions": 335, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -65,11 +65,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"alias.h\"\n #include \"opts.h\"\n+#include \"hw-doloop.h\"\n \n /* Which cpu we're compiling for (ARC600, ARC601, ARC700).  */\n static char arc_cpu_name[10] = \"\";\n static const char *arc_cpu_string = arc_cpu_name;\n \n+/* Maximum size of a loop.  */\n+#define ARC_MAX_LOOP_LENGTH 4095\n+\n /* ??? Loads can handle any constant, stores can only handle small ones.  */\n /* OTOH, LIMMs cost extra, so their usefulness is limited.  */\n #define RTX_OK_FOR_OFFSET_P(MODE, X) \\\n@@ -1705,18 +1709,7 @@ arc_conditional_register_usage (void)\n \t   i <= ARC_LAST_SIMD_DMA_CONFIG_REG; i++)\n \treg_alloc_order [i] = i;\n     }\n-  /* For ARC600, lp_count may not be read in an instruction\n-     following immediately after another one setting it to a new value.\n-     There was some discussion on how to enforce scheduling constraints for\n-     processors with missing interlocks on the gcc mailing list:\n-     http://gcc.gnu.org/ml/gcc/2008-05/msg00021.html .\n-     However, we can't actually use this approach, because for ARC the\n-     delay slot scheduling pass is active, which runs after\n-     machine_dependent_reorg.  */\n-  if (TARGET_ARC600)\n-    CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], LP_COUNT);\n-  else if (!TARGET_LP_WR_INTERLOCK)\n-    fixed_regs[LP_COUNT] = 1;\n+\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!call_used_regs[regno])\n       CLEAR_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\n@@ -6900,28 +6893,33 @@ arc_pass_by_reference (cumulative_args_t ca_v ATTRIBUTE_UNUSED,\n /* Implement TARGET_CAN_USE_DOLOOP_P.  */\n \n static bool\n-arc_can_use_doloop_p (const widest_int &iterations, const widest_int &,\n+arc_can_use_doloop_p (const widest_int &,\n+\t\t      const widest_int &iterations_max,\n \t\t      unsigned int loop_depth, bool entered_at_top)\n {\n-  if (loop_depth > 1)\n+  /* Considering limitations in the hardware, only use doloop\n+     for innermost loops which must be entered from the top.  */\n+  if (loop_depth > 1 || !entered_at_top)\n     return false;\n-  /* Setting up the loop with two sr instructions costs 6 cycles.  */\n-  if (TARGET_ARC700\n-      && !entered_at_top\n-      && wi::gtu_p (iterations, 0)\n-      && wi::leu_p (iterations, flag_pic ? 6 : 3))\n+\n+  /* Check for lp_count width boundary.  */\n+  if (arc_lpcwidth != 32\n+      && (wi::gtu_p (iterations_max, ((1 << arc_lpcwidth) - 1))\n+\t  || wi::eq_p (iterations_max, 0)))\n     return false;\n   return true;\n }\n \n-/* NULL if INSN insn is valid within a low-overhead loop.\n-   Otherwise return why doloop cannot be applied.  */\n+/* NULL if INSN insn is valid within a low-overhead loop.  Otherwise\n+   return why doloop cannot be applied.  */\n \n static const char *\n arc_invalid_within_doloop (const rtx_insn *insn)\n {\n   if (CALL_P (insn))\n     return \"Function call in the loop.\";\n+\n+  /* FIXME! add here all the ZOL exceptions.  */\n   return NULL;\n }\n \n@@ -7020,6 +7018,359 @@ workaround_arc_anomaly (void)\n     }\n }\n \n+/* A callback for the hw-doloop pass.  Called when a loop we have discovered\n+   turns out not to be optimizable; we have to split the loop_end pattern into\n+   a subtract and a test.  */\n+\n+static void\n+hwloop_fail (hwloop_info loop)\n+{\n+  rtx test;\n+  rtx insn = loop->loop_end;\n+\n+  if (TARGET_V2\n+      && (loop->length && (loop->length <= ARC_MAX_LOOP_LENGTH))\n+      && REG_P (loop->iter_reg))\n+    {\n+      /* TARGET_V2 has dbnz instructions.  */\n+      test = gen_dbnz (loop->iter_reg, loop->start_label);\n+      insn = emit_jump_insn_before (test, loop->loop_end);\n+    }\n+  else if (REG_P (loop->iter_reg) && (REGNO (loop->iter_reg) == LP_COUNT))\n+    {\n+      /* We have the lp_count as loop iterator, try to use it.  */\n+      emit_insn_before (gen_loop_fail (), loop->loop_end);\n+      test = gen_rtx_NE (VOIDmode, gen_rtx_REG (CC_ZNmode, CC_REG),\n+\t\t\t const0_rtx);\n+      test = gen_rtx_IF_THEN_ELSE (VOIDmode, test,\n+\t\t\t\t   gen_rtx_LABEL_REF (Pmode, loop->start_label),\n+\t\t\t\t   pc_rtx);\n+      insn = emit_jump_insn_before (gen_rtx_SET (pc_rtx, test),\n+\t\t\t\t     loop->loop_end);\n+    }\n+  else\n+    {\n+      emit_insn_before (gen_addsi3 (loop->iter_reg,\n+\t\t\t\t    loop->iter_reg,\n+\t\t\t\t    constm1_rtx),\n+\t\t\tloop->loop_end);\n+      test = gen_rtx_NE (VOIDmode, loop->iter_reg, const0_rtx);\n+      insn = emit_jump_insn_before (gen_cbranchsi4 (test,\n+\t\t\t\t\t\t    loop->iter_reg,\n+\t\t\t\t\t\t    const0_rtx,\n+\t\t\t\t\t\t    loop->start_label),\n+\t\t\t\t    loop->loop_end);\n+    }\n+  JUMP_LABEL (insn) = loop->start_label;\n+  LABEL_NUSES (loop->start_label)++;\n+  delete_insn (loop->loop_end);\n+}\n+\n+/* Optimize LOOP.  */\n+\n+static bool\n+hwloop_optimize (hwloop_info loop)\n+{\n+  int i;\n+  edge entry_edge;\n+  basic_block entry_bb, bb;\n+  rtx iter_reg, end_label;\n+  rtx_insn *insn, *seq, *entry_after, *last_insn;\n+  unsigned int length;\n+  bool need_fix = false;\n+  rtx lp_reg = gen_rtx_REG (SImode, LP_COUNT);\n+\n+  if (loop->depth > 1)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d is not innermost\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  if (!loop->incoming_dest)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d has more than one entry\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  if (loop->incoming_dest != loop->head)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d is not entered from head\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  if (loop->has_call || loop->has_asm)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d has invalid insn\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Scan all the blocks to make sure they don't use iter_reg.  */\n+  if (loop->iter_reg_used || loop->iter_reg_used_outside)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d uses iterator\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Check if start_label appears before doloop_end.  */\n+  length = 0;\n+  for (insn = loop->start_label;\n+       insn && insn != loop->loop_end;\n+       insn = NEXT_INSN (insn))\n+    length += NONDEBUG_INSN_P (insn) ? get_attr_length (insn) : 0;\n+\n+  if (!insn)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d start_label not before loop_end\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  loop->length = length;\n+  if (loop->length > ARC_MAX_LOOP_LENGTH)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d too long\\n\", loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Check if we use a register or not.  */\n+  if (!REG_P (loop->iter_reg))\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d iterator is MEM\\n\",\n+                 loop->loop_no);\n+      return false;\n+    }\n+\n+  /* Check if loop register is lpcount.  */\n+  if (REG_P (loop->iter_reg) && (REGNO (loop->iter_reg)) != LP_COUNT)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \";; loop %d doesn't use lp_count as loop\"\n+\t\t \" iterator\\n\",\n+                 loop->loop_no);\n+      /* This loop doesn't use the lp_count, check though if we can\n+\t fix it.  */\n+      if (TEST_HARD_REG_BIT (loop->regs_set_in_loop, LP_COUNT)\n+\t  /* In very unique cases we may have LP_COUNT alive.  */\n+\t  || (loop->incoming_src\n+\t      && REGNO_REG_SET_P (df_get_live_out (loop->incoming_src),\n+\t\t\t\t  LP_COUNT)))\n+\treturn false;\n+      else\n+\tneed_fix = true;\n+    }\n+\n+  /* Check for control like instruction as the last instruction of a\n+     ZOL.  */\n+  bb = loop->tail;\n+  last_insn = PREV_INSN (loop->loop_end);\n+\n+  while (1)\n+    {\n+      for (; last_insn != BB_HEAD (bb);\n+\t   last_insn = PREV_INSN (last_insn))\n+\tif (NONDEBUG_INSN_P (last_insn))\n+\t  break;\n+\n+      if (last_insn != BB_HEAD (bb))\n+\tbreak;\n+\n+      if (single_pred_p (bb)\n+\t  && single_pred_edge (bb)->flags & EDGE_FALLTHRU\n+\t  && single_pred (bb) != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t{\n+\t  bb = single_pred (bb);\n+\t  last_insn = BB_END (bb);\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  last_insn = NULL;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!last_insn)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has no last instruction\\n\",\n+\t\t loop->loop_no);\n+      return false;\n+    }\n+\n+  if ((TARGET_ARC600_FAMILY || TARGET_HS)\n+      && INSN_P (last_insn)\n+      && (JUMP_P (last_insn) || CALL_P (last_insn)\n+\t  || GET_CODE (PATTERN (last_insn)) == SEQUENCE\n+\t  || get_attr_type (last_insn) == TYPE_BRCC\n+\t  || get_attr_type (last_insn) == TYPE_BRCC_NO_DELAY_SLOT))\n+    {\n+      if (loop->length + 2 > ARC_MAX_LOOP_LENGTH)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d too long\\n\", loop->loop_no);\n+\t  return false;\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has a control like last insn;\"\n+\t\t \"add a nop\\n\",\n+\t\t loop->loop_no);\n+\n+      last_insn = emit_insn_after (gen_nopv (), last_insn);\n+    }\n+\n+  if (LABEL_P (last_insn))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has a label as last insn;\"\n+\t\t \"add a nop\\n\",\n+\t\t loop->loop_no);\n+      last_insn = emit_insn_after (gen_nopv (), last_insn);\n+    }\n+  loop->last_insn = last_insn;\n+\n+  /* Get the loop iteration register.  */\n+  iter_reg = loop->iter_reg;\n+\n+  gcc_assert (REG_P (iter_reg));\n+\n+  entry_edge = NULL;\n+\n+  FOR_EACH_VEC_SAFE_ELT (loop->incoming, i, entry_edge)\n+    if (entry_edge->flags & EDGE_FALLTHRU)\n+      break;\n+\n+  if (entry_edge == NULL)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; loop %d has no fallthru edge jumping\"\n+\t\t \"into the loop\\n\",\n+\t\t loop->loop_no);\n+      return false;\n+    }\n+  /* The loop is good.  */\n+  end_label = gen_label_rtx ();\n+  loop->end_label = end_label;\n+\n+  /* Place the zero_cost_loop_start instruction before the loop.  */\n+  entry_bb = entry_edge->src;\n+\n+  start_sequence ();\n+\n+  if (need_fix)\n+    {\n+      /* The loop uses a R-register, but the lp_count is free, thus\n+\t use lp_count.  */\n+      emit_insn (gen_movsi (lp_reg, iter_reg));\n+      SET_HARD_REG_BIT (loop->regs_set_in_loop, LP_COUNT);\n+      iter_reg = lp_reg;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \";; fix loop %d to use lp_count\\n\",\n+\t\t   loop->loop_no);\n+\t}\n+    }\n+\n+  insn = emit_insn (gen_arc_lp (iter_reg,\n+\t\t\t\tloop->start_label,\n+\t\t\t\tloop->end_label));\n+\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  entry_after = BB_END (entry_bb);\n+  if (!single_succ_p (entry_bb) || vec_safe_length (loop->incoming) > 1\n+      || !entry_after)\n+    {\n+      basic_block new_bb;\n+      edge e;\n+      edge_iterator ei;\n+\n+      emit_insn_before (seq, BB_HEAD (loop->head));\n+      seq = emit_label_before (gen_label_rtx (), seq);\n+      new_bb = create_basic_block (seq, insn, entry_bb);\n+      FOR_EACH_EDGE (e, ei, loop->incoming)\n+        {\n+          if (!(e->flags & EDGE_FALLTHRU))\n+            redirect_edge_and_branch_force (e, new_bb);\n+          else\n+            redirect_edge_succ (e, new_bb);\n+        }\n+\n+      make_edge (new_bb, loop->head, 0);\n+    }\n+  else\n+    {\n+#if 0\n+      while (DEBUG_INSN_P (entry_after)\n+             || (NOTE_P (entry_after)\n+                 && NOTE_KIND (entry_after) != NOTE_INSN_BASIC_BLOCK\n+\t\t /* Make sure we don't split a call and its corresponding\n+\t\t    CALL_ARG_LOCATION note.  */\n+                 && NOTE_KIND (entry_after) != NOTE_INSN_CALL_ARG_LOCATION))\n+        entry_after = NEXT_INSN (entry_after);\n+#endif\n+      entry_after = next_nonnote_insn_bb (entry_after);\n+\n+      gcc_assert (entry_after);\n+      emit_insn_before (seq, entry_after);\n+    }\n+\n+  delete_insn (loop->loop_end);\n+  /* Insert the loop end label before the last instruction of the\n+     loop.  */\n+  emit_label_after (end_label, loop->last_insn);\n+\n+  return true;\n+}\n+\n+/* A callback for the hw-doloop pass.  This function examines INSN; if\n+   it is a loop_end pattern we recognize, return the reg rtx for the\n+   loop counter.  Otherwise, return NULL_RTX.  */\n+\n+static rtx\n+hwloop_pattern_reg (rtx_insn *insn)\n+{\n+  rtx reg;\n+\n+  if (!JUMP_P (insn) || recog_memoized (insn) != CODE_FOR_loop_end)\n+    return NULL_RTX;\n+\n+  reg = SET_DEST (XVECEXP (PATTERN (insn), 0, 1));\n+  if (!REG_P (reg))\n+    return NULL_RTX;\n+  return reg;\n+}\n+\n+static struct hw_doloop_hooks arc_doloop_hooks =\n+{\n+  hwloop_pattern_reg,\n+  hwloop_optimize,\n+  hwloop_fail\n+};\n+\n+/* Run from machine_dependent_reorg, this pass looks for doloop_end insns\n+   and tries to rewrite the RTL of these loops so that proper Blackfin\n+   hardware loops are generated.  */\n+\n+static void\n+arc_reorg_loops (void)\n+{\n+  reorg_loops (true, &arc_doloop_hooks);\n+}\n+\n static int arc_reorg_in_progress = 0;\n \n /* ARC's machince specific reorg function.  */\n@@ -7033,204 +7384,17 @@ arc_reorg (void)\n   long offset;\n   int changed;\n \n-  workaround_arc_anomaly ();\n-\n   cfun->machine->arc_reorg_started = 1;\n   arc_reorg_in_progress = 1;\n \n-  /* Link up loop ends with their loop start.  */\n-  {\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == JUMP_INSN\n-\t  && recog_memoized (insn) == CODE_FOR_doloop_end_i)\n-\t{\n-\t  rtx_insn *top_label\n-\t    = as_a <rtx_insn *> (XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (insn), 0, 0)), 1), 0));\n-\t  rtx num = GEN_INT (CODE_LABEL_NUMBER (top_label));\n-\t  rtx_insn *lp, *prev = prev_nonnote_insn (top_label);\n-\t  rtx_insn *lp_simple = NULL;\n-\t  rtx_insn *next = NULL;\n-\t  rtx op0 = XEXP (XVECEXP (PATTERN (insn), 0, 1), 0);\n-\t  int seen_label = 0;\n-\n-\t  for (lp = prev;\n-\t       (lp && NONJUMP_INSN_P (lp)\n-\t\t&& recog_memoized (lp) != CODE_FOR_doloop_begin_i);\n-\t       lp = prev_nonnote_insn (lp))\n-\t    ;\n-\t  if (!lp || !NONJUMP_INSN_P (lp)\n-\t      || dead_or_set_regno_p (lp, LP_COUNT))\n-\t    {\n-\t      HOST_WIDE_INT loop_end_id\n-\t\t= INTVAL (XEXP (XVECEXP (PATTERN (insn), 0, 4), 0));\n-\n-\t      for (prev = next = insn, lp = NULL ; prev || next;)\n-\t\t{\n-\t\t  if (prev)\n-\t\t    {\n-\t\t      if (NONJUMP_INSN_P (prev)\n-\t\t\t  && recog_memoized (prev) == CODE_FOR_doloop_begin_i\n-\t\t\t  && (INTVAL (XEXP (XVECEXP (PATTERN (prev), 0, 5), 0))\n-\t\t\t      == loop_end_id))\n-\t\t\t{\n-\t\t\t  lp = prev;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      else if (LABEL_P (prev))\n-\t\t\tseen_label = 1;\n-\t\t      prev = prev_nonnote_insn (prev);\n-\t\t    }\n-\t\t  if (next)\n-\t\t    {\n-\t\t      if (NONJUMP_INSN_P (next)\n-\t\t\t  && recog_memoized (next) == CODE_FOR_doloop_begin_i\n-\t\t\t  && (INTVAL (XEXP (XVECEXP (PATTERN (next), 0, 5), 0))\n-\t\t\t      == loop_end_id))\n-\t\t\t{\n-\t\t\t  lp = next;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      next = next_nonnote_insn (next);\n-\t\t    }\n-\t\t}\n-\t      prev = NULL;\n-\t    }\n-\t  else\n-\t    lp_simple = lp;\n-\t  if (lp && !dead_or_set_regno_p (lp, LP_COUNT))\n-\t    {\n-\t      rtx begin_cnt = XEXP (XVECEXP (PATTERN (lp), 0 ,3), 0);\n-\t      if (INTVAL (XEXP (XVECEXP (PATTERN (lp), 0, 4), 0)))\n-\t\t/* The loop end insn has been duplicated.  That can happen\n-\t\t   when there is a conditional block at the very end of\n-\t\t   the loop.  */\n-\t\tgoto failure;\n-\t      /* If Register allocation failed to allocate to the right\n-\t\t register, There is no point into teaching reload to\n-\t\t fix this up with reloads, as that would cost more\n-\t\t than using an ordinary core register with the\n-\t\t doloop_fallback pattern.  */\n-\t      if ((true_regnum (op0) != LP_COUNT || !REG_P (begin_cnt))\n-\t      /* Likewise, if the loop setup is evidently inside the loop,\n-\t\t we loose.  */\n-\t\t  || (!lp_simple && lp != next && !seen_label))\n-\t\t{\n-\t\t  remove_insn (lp);\n-\t\t  goto failure;\n-\t\t}\n-\t      /* It is common that the optimizers copy the loop count from\n-\t\t another register, and doloop_begin_i is stuck with the\n-\t\t source of the move.  Making doloop_begin_i only accept \"l\"\n-\t\t is nonsentical, as this then makes reload evict the pseudo\n-\t\t used for the loop end.  The underlying cause is that the\n-\t\t optimizers don't understand that the register allocation for\n-\t\t doloop_begin_i should be treated as part of the loop.\n-\t\t Try to work around this problem by verifying the previous\n-\t\t move exists.  */\n-\t      if (true_regnum (begin_cnt) != LP_COUNT)\n-\t\t{\n-\t\t  rtx_insn *mov;\n-\t\t  rtx set, note;\n+  compute_bb_for_insn ();\n \n-\t\t  for (mov = prev_nonnote_insn (lp); mov;\n-\t\t       mov = prev_nonnote_insn (mov))\n-\t\t    {\n-\t\t      if (!NONJUMP_INSN_P (mov))\n-\t\t\tmov = 0;\n-\t\t      else if ((set = single_set (mov))\n-\t\t\t  && rtx_equal_p (SET_SRC (set), begin_cnt)\n-\t\t\t  && rtx_equal_p (SET_DEST (set), op0))\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  if (mov)\n-\t\t    {\n-\t\t      XEXP (XVECEXP (PATTERN (lp), 0 ,3), 0) = op0;\n-\t\t      note = find_regno_note (lp, REG_DEAD, REGNO (begin_cnt));\n-\t\t      if (note)\n-\t\t\tremove_note (lp, note);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      remove_insn (lp);\n-\t\t      goto failure;\n-\t\t    }\n-\t\t}\n-\t      XEXP (XVECEXP (PATTERN (insn), 0, 4), 0) = num;\n-\t      XEXP (XVECEXP (PATTERN (lp), 0, 4), 0) = num;\n-\t      if (next == lp)\n-\t\tXEXP (XVECEXP (PATTERN (lp), 0, 6), 0) = const2_rtx;\n-\t      else if (!lp_simple)\n-\t\tXEXP (XVECEXP (PATTERN (lp), 0, 6), 0) = const1_rtx;\n-\t      else if (prev != lp)\n-\t\t{\n-\t\t  remove_insn (lp);\n-\t\t  add_insn_after (lp, prev, NULL);\n-\t\t}\n-\t      if (!lp_simple)\n-\t\t{\n-\t\t  XEXP (XVECEXP (PATTERN (lp), 0, 7), 0)\n-\t\t    = gen_rtx_LABEL_REF (Pmode, top_label);\n-\t\t  add_reg_note (lp, REG_LABEL_OPERAND, top_label);\n-\t\t  LABEL_NUSES (top_label)++;\n-\t\t}\n-\t      /* We can avoid tedious loop start / end setting for empty loops\n-\t\t be merely setting the loop count to its final value.  */\n-\t      if (next_active_insn (top_label) == insn)\n-\t\t{\n-\t\t  rtx lc_set\n-\t\t    = gen_rtx_SET (XEXP (XVECEXP (PATTERN (lp), 0, 3), 0),\n-\t\t\t\t   const0_rtx);\n-\n-\t\t  rtx_insn *lc_set_insn = emit_insn_before (lc_set, insn);\n-\t\t  delete_insn (lp);\n-\t\t  delete_insn (insn);\n-\t\t  insn = lc_set_insn;\n-\t\t}\n-\t      /* If the loop is non-empty with zero length, we can't make it\n-\t\t a zero-overhead loop.  That can happen for empty asms.  */\n-\t      else\n-\t\t{\n-\t\t  rtx_insn *scan;\n+  df_analyze ();\n \n-\t\t  for (scan = top_label;\n-\t\t       (scan && scan != insn\n-\t\t\t&& (!NONJUMP_INSN_P (scan) || !get_attr_length (scan)));\n-\t\t       scan = NEXT_INSN (scan));\n-\t\t  if (scan == insn)\n-\t\t    {\n-\t\t      remove_insn (lp);\n-\t\t      goto failure;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Sometimes the loop optimizer makes a complete hash of the\n-\t\t loop.  If it were only that the loop is not entered at the\n-\t\t top, we could fix this up by setting LP_START with SR .\n-\t\t However, if we can't find the loop begin were it should be,\n-\t\t chances are that it does not even dominate the loop, but is\n-\t\t inside the loop instead.  Using SR there would kill\n-\t\t performance.\n-\t\t We use the doloop_fallback pattern here, which executes\n-\t\t in two cycles on the ARC700 when predicted correctly.  */\n-\t    failure:\n-\t      if (!REG_P (op0))\n-\t\t{\n-\t\t  rtx op3 = XEXP (XVECEXP (PATTERN (insn), 0, 5), 0);\n+  /* Doloop optimization.  */\n+  arc_reorg_loops ();\n \n-\t\t  emit_insn_before (gen_move_insn (op3, op0), insn);\n-\t\t  PATTERN (insn)\n-\t\t    = gen_doloop_fallback_m (op3, JUMP_LABEL (insn), op0);\n-\t\t}\n-\t      else\n-\t\tXVEC (PATTERN (insn), 0)\n-\t\t  = gen_rtvec (2, XVECEXP (PATTERN (insn), 0, 0),\n-\t\t\t       XVECEXP (PATTERN (insn), 0, 1));\n-\t      INSN_CODE (insn) = -1;\n-\t    }\n-\t}\n-    }\n+  workaround_arc_anomaly ();\n \n /* FIXME: should anticipate ccfsm action, generate special patterns for\n    to-be-deleted branches that have no delay slot and have at least the\n@@ -7774,11 +7938,11 @@ arc_register_move_cost (machine_mode,\n \treturn 6;\n     }\n \n-  /* The ARC700 stalls for 3 cycles when *reading* from lp_count.  */\n-  if (TARGET_ARC700\n-      && (from_class == LPCOUNT_REG || from_class == ALL_CORE_REGS\n-\t  || from_class == WRITABLE_CORE_REGS))\n-    return 8;\n+  /* Using lp_count as scratch reg is a VERY bad idea.  */\n+  if (from_class == LPCOUNT_REG)\n+    return 1000;\n+  if (to_class == LPCOUNT_REG)\n+    return 6;\n \n   /* Force an attempt to 'mov Dy,Dx' to spill.  */\n   if ((TARGET_ARC700 || TARGET_EM) && TARGET_DPFP\n@@ -8220,14 +8384,6 @@ arc600_corereg_hazard (rtx_insn *pred, rtx_insn *succ)\n {\n   if (!TARGET_ARC600)\n     return 0;\n-  /* If SUCC is a doloop_end_i with a preceding label, we must output a nop\n-     in front of SUCC anyway, so there will be separation between PRED and\n-     SUCC.  */\n-  if (recog_memoized (succ) == CODE_FOR_doloop_end_i\n-      && LABEL_P (prev_nonnote_insn (succ)))\n-    return 0;\n-  if (recog_memoized (succ) == CODE_FOR_doloop_begin_i)\n-    return 0;\n   if (GET_CODE (PATTERN (pred)) == SEQUENCE)\n     pred = as_a <rtx_sequence *> (PATTERN (pred))->insn (1);\n   if (GET_CODE (PATTERN (succ)) == SEQUENCE)\n@@ -8301,76 +8457,6 @@ arc_asm_insn_p (rtx x)\n   return 0;\n }\n \n-/* We might have a CALL to a non-returning function before a loop end.\n-   ??? Although the manual says that's OK (the target is outside the\n-   loop, and the loop counter unused there), the assembler barfs on\n-   this for ARC600, so we must insert a nop before such a call too.\n-   For ARC700, and ARCv2 is not allowed to have the last ZOL\n-   instruction a jump to a location where lp_count is modified.  */\n-\n-static bool\n-arc_loop_hazard (rtx_insn *pred, rtx_insn *succ)\n-{\n-  rtx_insn *jump  = NULL;\n-  rtx label_rtx = NULL_RTX;\n-  rtx_insn *label = NULL;\n-  basic_block succ_bb;\n-\n-  if (recog_memoized (succ) != CODE_FOR_doloop_end_i)\n-    return false;\n-\n-  /* Phase 1: ARC600 and ARCv2HS doesn't allow any control instruction\n-     (i.e., jump/call) as the last instruction of a ZOL.  */\n-  if (TARGET_ARC600 || TARGET_HS)\n-    if (JUMP_P (pred) || CALL_P (pred)\n-\t|| arc_asm_insn_p (PATTERN (pred))\n-\t|| GET_CODE (PATTERN (pred)) == SEQUENCE)\n-      return true;\n-\n-  /* Phase 2: Any architecture, it is not allowed to have the last ZOL\n-     instruction a jump to a location where lp_count is modified.  */\n-\n-  /* Phase 2a: Dig for the jump instruction.  */\n-  if (JUMP_P (pred))\n-    jump = pred;\n-  else if (GET_CODE (PATTERN (pred)) == SEQUENCE\n-\t   && JUMP_P (XVECEXP (PATTERN (pred), 0, 0)))\n-    jump = as_a <rtx_insn *> (XVECEXP (PATTERN (pred), 0, 0));\n-  else\n-    return false;\n-\n-  /* Phase 2b: Make sure is not a millicode jump.  */\n-  if ((GET_CODE (PATTERN (jump)) == PARALLEL)\n-      && (XVECEXP (PATTERN (jump), 0, 0) == ret_rtx))\n-    return false;\n-\n-  label_rtx = JUMP_LABEL (jump);\n-  if (!label_rtx)\n-    return false;\n-\n-  /* Phase 2c: Make sure is not a return.  */\n-  if (ANY_RETURN_P (label_rtx))\n-    return false;\n-\n-  /* Pahse 2d: Go to the target of the jump and check for aliveness of\n-     LP_COUNT register.  */\n-  label = safe_as_a <rtx_insn *> (label_rtx);\n-  succ_bb = BLOCK_FOR_INSN (label);\n-  if (!succ_bb)\n-    {\n-      gcc_assert (NEXT_INSN (label));\n-      if (NOTE_INSN_BASIC_BLOCK_P (NEXT_INSN (label)))\n-\tsucc_bb = NOTE_BASIC_BLOCK (NEXT_INSN (label));\n-      else\n-\tsucc_bb = BLOCK_FOR_INSN (NEXT_INSN (label));\n-    }\n-\n-  if (succ_bb && REGNO_REG_SET_P (df_get_live_out (succ_bb), LP_COUNT))\n-    return true;\n-\n-  return false;\n-}\n-\n /* For ARC600:\n    A write to a core reg greater or equal to 32 must not be immediately\n    followed by a use.  Anticipate the length requirement to insert a nop\n@@ -8382,9 +8468,6 @@ arc_hazard (rtx_insn *pred, rtx_insn *succ)\n   if (!pred || !INSN_P (pred) || !succ || !INSN_P (succ))\n     return 0;\n \n-  if (arc_loop_hazard (pred, succ))\n-    return 4;\n-\n   if (TARGET_ARC600)\n     return arc600_corereg_hazard (pred, succ);\n \n@@ -8402,24 +8485,6 @@ arc_adjust_insn_length (rtx_insn *insn, int len, bool)\n   if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n     return len;\n \n-  /* It is impossible to jump to the very end of a Zero-Overhead Loop, as\n-     the ZOL mechanism only triggers when advancing to the end address,\n-     so if there's a label at the end of a ZOL, we need to insert a nop.\n-     The ARC600 ZOL also has extra restrictions on jumps at the end of a\n-     loop.  */\n-  if (recog_memoized (insn) == CODE_FOR_doloop_end_i)\n-    {\n-      rtx_insn *prev = prev_nonnote_insn (insn);\n-\n-      return ((LABEL_P (prev)\n-\t       || (TARGET_ARC600\n-\t\t   && (JUMP_P (prev)\n-\t\t       || CALL_P (prev) /* Could be a noreturn call.  */\n-\t\t       || (NONJUMP_INSN_P (prev)\n-\t\t\t   && GET_CODE (PATTERN (prev)) == SEQUENCE))))\n-\t      ? len + 4 : len);\n-    }\n-\n   /* Check for return with but one preceding insn since function\n      start / call.  */\n   if (TARGET_PAD_RETURN\n@@ -9755,27 +9820,9 @@ arc_scheduling_not_expected (void)\n   return cfun->machine->arc_reorg_started;\n }\n \n-/* Oddly enough, sometimes we get a zero overhead loop that branch\n-   shortening doesn't think is a loop - observed with compile/pr24883.c\n-   -O3 -fomit-frame-pointer -funroll-loops.  Make sure to include the\n-   alignment visible for branch shortening  (we actually align the loop\n-   insn before it, but that is equivalent since the loop insn is 4 byte\n-   long.)  */\n-\n int\n arc_label_align (rtx_insn *label)\n {\n-  int loop_align = LOOP_ALIGN (LABEL);\n-\n-  if (loop_align > align_labels_log)\n-    {\n-      rtx_insn *prev = prev_nonnote_insn (label);\n-\n-      if (prev && NONJUMP_INSN_P (prev)\n-\t  && GET_CODE (PATTERN (prev)) == PARALLEL\n-\t  && recog_memoized (prev) == CODE_FOR_doloop_begin_i)\n-\treturn loop_align;\n-    }\n   /* Code has a minimum p2 alignment of 1, which we must restore after an\n      ADDR_DIFF_VEC.  */\n   if (align_labels_log < 1)"}, {"sha": "ad26de71d20b630f9af616d4dac4157cde7672cd", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -581,15 +581,15 @@ enum reg_class\n   {0x0000f00f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},\t     /* 'q', r0-r3, r12-r15 */\t\t\\\n   {0x1000f00f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},\t     /* 'e', r0-r3, r12-r15, sp */\t\\\n   {0x1c001fff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},    /* \"Rsc\", r0-r12 */ \\\n-  {0x9fffffff, 0xc0000000, 0x00000000, 0x00000000, 0x00000000},      /* 'r', r0-r28, blink, ap and pcl */\t\\\n+  {0x9fffffff, 0x80000000, 0x00000000, 0x00000000, 0x00000000},      /* 'r', r0-r28, blink, ap and pcl */\t\\\n   {0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'W',  r0-r31 */ \\\n   /* Include ap / pcl in WRITABLE_CORE_REGS for sake of symmetry.  As these \\\n      registers are fixed, it does not affect the literal meaning of the \\\n      constraints, but it makes it a superset of GENERAL_REGS, thus \\\n      enabling some operations that would otherwise not be possible.  */ \\\n-  {0xffffffff, 0xd0000000, 0x00000000, 0x00000000, 0x00000000},      /* 'w', r0-r31, r60 */ \\\n-  {0xffffffff, 0xdfffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'c', r0-r60, ap, pcl */ \\\n-  {0xffffffff, 0xdfffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'Rac', r0-r60, ap, pcl */ \\\n+  {0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'w', r0-r31, r60 */ \\\n+  {0xffffffff, 0x9fffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'c', r0-r60, ap, pcl */ \\\n+  {0xffffffff, 0x9fffffff, 0x00000000, 0x00000000, 0x00000000},      /* 'Rac', r0-r60, ap, pcl */ \\\n   {0x0000000f, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rcd', r0-r3 */ \\\n   {0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'Rsd', r0-r1 */ \\\n   {0x9fffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000},      /* 'h',  r0-28, r30 */ \\\n@@ -1351,7 +1351,7 @@ do {\t\t\t\t\t\t\t\\\n    of a loop.  */\n /* On the ARC, align loops to 4 byte boundaries unless doing all-out size\n    optimization.  */\n-#define LOOP_ALIGN JUMP_ALIGN\n+#define LOOP_ALIGN(X) 0\n \n #define LABEL_ALIGN(LABEL) (arc_label_align (LABEL))\n "}, {"sha": "c766306075c307048f92468ef55a81c7a47990cc", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 115, "deletions": 304, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -554,6 +554,11 @@\n    (eq_attr \"annul_ret_delay_insn\" \"yes\")\n    (eq_attr \"cond_ret_delay_insn\" \"yes\")])\n \n+(define_delay (eq_attr \"type\" \"loop_end\")\n+  [(eq_attr \"in_delay_slot\" \"true\")\n+   (eq_attr \"in_delay_slot\" \"true\")\n+   (nil)])\n+\n ;; For ARC600, unexposing the delay sloy incurs a penalty also in the\n ;; non-taken case, so the only meaningful way to have an annull-true\n ;; filled delay slot is to conditionalize the delay slot insn.\n@@ -618,8 +623,8 @@\n ; The iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n (define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w,w,???w,h, w,Rcq,  S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n-\t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1,cL,I,?Rac,i,?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,w*l,w*l,???w,h,w*l,Rcq,  S,!*x,  r,r, Ucm,m,???m,  m,Usc\")\n+\t(match_operand:QI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1, cL,  I,?Rac,i, ?i,  T,Rcq,Usd,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], QImode)\n    || register_operand (operands[1], QImode)\"\n   \"@\n@@ -655,8 +660,8 @@\n   \"if (prepare_move_operands (operands, HImode)) DONE;\")\n \n (define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w,w,???w,Rcq#q,h, w,Rcq,  S,  r,r, Ucm,m,???m,  m,VUsc\")\n-\t(match_operand:HI 1 \"move_src_operand\" \"   cL,   cP,Rcq#q,    P,hCm1,cL,I,?Rac,    i,i,?i,  T,Rcq,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,w*l,w*l,???w,Rcq#q,h,w*l,Rcq,  S,  r,r, Ucm,m,???m,  m,VUsc\")\n+\t(match_operand:HI 1 \"move_src_operand\" \"   cL,   cP,Rcq#q,    P,hCm1, cL,  I,?Rac,    i,i, ?i,  T,Rcq,Ucm,m,?Rac,c,?Rac,Cm3,i\"))]\n   \"register_operand (operands[0], HImode)\n    || register_operand (operands[1], HImode)\n    || (CONSTANT_P (operands[1])\n@@ -706,9 +711,9 @@\n ; the iscompact attribute allows the epilogue expander to know for which\n ; insns it should lengthen the return insn.\n ; N.B. operand 1 of alternative 7 expands into pcl,symbol@gotpc .\n-(define_insn \"*movsi_insn\"                      ;   0     1     2     3    4  5 6   7   8   9   10  11  12  13    14  15   16  17  18     19     20  21  22    23    24 25 26    27 28  29   30   31\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h, w,w,  w,  w,  w,  w,???w, ?w,  w,Rcq#q,  h,   w,Rcq,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,???m,  m,VUsc\")\n-\t(match_operand:SI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1,cL,I,Crr,Clo,Chi,Cbi,?Rac,Cpc,Clb, ?Cal,Cal,?Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  w,!*Rzd,c,?Rac,Cm3, C32\"))]\n+(define_insn \"*movsi_insn\"                      ;   0     1     2     3    4  5    6   7   8   9   10    11  12  13    14  15   16  17  18     19     20  21  22    23    24 25 26    27 28  29  30   31\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,    w,Rcq#q,   h,w*l,w*l,  w,  w,  w,  w,  ???w, ?w,  w,Rcq#q,  h, w*l,Rcq,  S,   Us<,RcqRck,!*x,  r,!*Rsd,!*Rcd,r,Ucm,  Usd,m,???m,  m,VUsc\")\n+\t(match_operand:SI 1 \"move_src_operand\"  \"  cL,   cP,Rcq#q,    P,hCm1, cL,  I,Crr,Clo,Chi,Cbi,?Rac*l,Cpc,Clb, ?Cal,Cal,?Cal,Uts,Rcq,RcqRck,   Us>,Usd,Ucm,  Usd,  Ucd,m,  w,!*Rzd,c,?Rac,Cm3, C32\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\n    || (CONSTANT_P (operands[1])\n@@ -5106,317 +5111,123 @@\n \t\t\t\txtr, const0_rtx);\n })\n \n+;; -------------------------------------------------------------------\n+;; Hardware loop\n+;; -------------------------------------------------------------------\n+\n ; operand 0 is the loop count pseudo register\n-; operand 1 is the loop end pattern\n-(define_expand \"doloop_begin\"\n-  [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand 1 \"\" \"\"))]\n+; operand 1 is the label to jump to at the top of the loop\n+(define_expand \"doloop_end\"\n+  [(parallel [(set (pc)\n+\t\t   (if_then_else\n+\t\t    (ne (match_operand 0 \"\" \"\")\n+\t\t\t(const_int 1))\n+\t\t    (label_ref (match_operand 1 \"\" \"\"))\n+\t\t    (pc)))\n+\t      (set (match_dup 0) (plus (match_dup 0) (const_int -1)))\n+\t      (unspec [(const_int 0)] UNSPEC_ARC_LP)\n+\t      (clobber (match_dup 2))])]\n   \"\"\n {\n-  /* Using the INSN_UID of the loop end pattern to identify it causes\n-     trouble with -fcompare-debug, so allocate a debug-independent\n-     id instead.  We use negative numbers so that we can use the same\n-     slot in doloop_end_i where we later store a CODE_LABEL_NUMBER, and\n-     still be able to tell what kind of number this is.  */\n-  static HOST_WIDE_INT loop_end_id = 0;\n-\n-  rtx id = GEN_INT (--loop_end_id);\n-  XEXP (XVECEXP (PATTERN (operands[1]), 0, 4), 0) = id;\n-  emit_insn (gen_doloop_begin_i (operands[0], const0_rtx, id,\n-\t\t\t\t const0_rtx, const0_rtx));\n-  DONE;\n+ if (GET_MODE (operands[0]) != SImode)\n+   FAIL;\n+ operands[2] = gen_rtx_SCRATCH (SImode);\n })\n \n-; ??? can't describe the insn properly as then the optimizers try to\n-; hoist the SETs.\n-;(define_insn \"doloop_begin_i\"\n-;  [(set (reg:SI LP_START) (pc))\n-;   (set (reg:SI LP_END) (unspec:SI [(pc)] UNSPEC_ARC_LP))\n-;   (use (match_operand 0 \"const_int_operand\" \"n\"))]\n-;  \"\"\n-;  \"lp .L__GCC__LP%0\"\n-;)\n-\n-; The operands of doloop_end_i are also read / written by arc_reorg with\n-; XVECEXP (PATTERN (lp, 0, N), so if you want to change the pattern, you\n-; might have to adjust arc_reorg.\n-; operands 0 / 2 are supplied by the expander, 1, 3 and 4 are filled in\n-; by arc_reorg.  arc_reorg might also alter operand 0.\n-;\n-; N in XVECEXP PATTERN (lp, 0 N)\n-;  V              rtl                 purpose\n-;  0           unspec UNSPEC_ARC_LP identify pattern\n-;  1           clobber LP_START     show LP_START is set\n-;  2           clobber LP_END       show LP_END is set\n-;  3           use operand0         loop count pseudo register\n-;  4           use operand1         before arc_reorg: -id\n-;                                   after : CODE_LABEL_NUMBER of loop top label\n-;  5           use operand2         INSN_UID of loop end insn\n-;  6           use operand3         loop setup not at start (1 above, 2 below)\n-;  7           use operand4         LABEL_REF of top label, if not\n-;                                   immediately following\n-; If operand1 is still zero after arc_reorg, this is an orphaned loop\n-; instruction that was not at the start of the loop.\n-; There is no point is reloading this insn - then lp_count would still not\n-; be available for the loop end.\n-(define_insn \"doloop_begin_i\"\n-  [(unspec:SI [(pc)] UNSPEC_ARC_LP)\n-   (clobber (reg:SI LP_START))\n-   (clobber (reg:SI LP_END))\n-   (use (match_operand:SI 0 \"register_operand\" \"l,l,????*X\"))\n-   (use (match_operand 1 \"const_int_operand\" \"n,n,C_0\"))\n-   (use (match_operand 2 \"const_int_operand\" \"n,n,X\"))\n-   (use (match_operand 3 \"const_int_operand\" \"C_0,n,X\"))\n-   (use (match_operand 4 \"const_int_operand\" \"C_0,X,X\"))]\n+(define_insn \"arc_lp\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"l\")]\n+\t      UNSPEC_ARC_LP)\n+   (use (label_ref (match_operand 1 \"\" \"\")))\n+   (use (label_ref (match_operand 2 \"\" \"\")))]\n   \"\"\n-{\n-  rtx_insn *scan;\n-  int len, size = 0;\n-  int n_insns = 0;\n-  rtx loop_start = operands[4];\n-\n-  if (CONST_INT_P (loop_start))\n-    loop_start = NULL_RTX;\n-  /* Size implications of the alignment will be taken care of by the\n-     alignment inserted at the loop start.  */\n-  if (LOOP_ALIGN (0) && INTVAL (operands[1]))\n-    {\n-      asm_fprintf (asm_out_file, \"\\t.p2align %d\\\\n\", LOOP_ALIGN (0));\n-      arc_clear_unalign ();\n-    }\n-  if (!INTVAL (operands[1]))\n-    return \"; LITTLE LOST LOOP\";\n-  if (loop_start && flag_pic)\n-    {\n-      /* ??? Can do better for when a scratch register\n-\t is known.  But that would require extra testing.  */\n-      return \"push_s r0\\;add r0,pcl,%4@pcl\\;sr r0,[2]; LP_START\\;add r0,pcl,.L__GCC__LP%1@pcl\\;sr r0,[3]; LP_END\\;pop_s r0\";\n-    }\n-  /* Check if the loop end is in range to be set by the lp instruction.  */\n-  size = INTVAL (operands[3]) < 2 ? 0 : 2048;\n-  for (scan = insn; scan && size < 2048; scan = NEXT_INSN (scan))\n-    {\n-      if (!INSN_P (scan))\n-\tcontinue;\n-      if (recog_memoized (scan) == CODE_FOR_doloop_end_i\n-\t  && (XEXP (XVECEXP (PATTERN (scan), 0, 4), 0)\n-\t      == XEXP (XVECEXP (PATTERN (insn), 0, 4), 0)))\n-\tbreak;\n-      len = get_attr_length (scan);\n-      size += len;\n-    }\n-  /* Try to verify that there are at least three instruction fetches\n-     between the loop setup and the first encounter of the loop end.  */\n-  for (scan = NEXT_INSN (insn); scan && n_insns < 3; scan = NEXT_INSN (scan))\n-    {\n-      if (!INSN_P (scan))\n-\tcontinue;\n-      if (rtx_sequence *seq = dyn_cast <rtx_sequence *> (PATTERN (scan)))\n-\tscan = seq->insn (0);\n-      if (JUMP_P (scan))\n-\t{\n-\t  if (recog_memoized (scan) != CODE_FOR_doloop_end_i)\n-\t    {\n-\t      n_insns += 2;\n-\t      if (simplejump_p (scan))\n-\t\t{\n-\t\t  scan = as_a <rtx_insn *> (XEXP (SET_SRC (PATTERN (scan)), 0));\n-\t\t  continue;\n-\t\t}\n-\n-\t      rtx lab = JUMP_LABEL (scan);\n-\t      if (!lab)\n-\t\tbreak;\n-\n-\t      rtx_insn *next_scan\n-\t\t= next_active_insn (NEXT_INSN (PREV_INSN (scan)));\n-\t      if (next_scan\n-\t\t  && recog_memoized (next_scan) != CODE_FOR_doloop_begin_i)\n-\t\tbreak;\n-\n-\t      /* JUMP_LABEL might be simple_return instead if an insn.  */\n-\t      if (!INSN_P (lab))\n-\t\t{\n-\t\t  n_insns++;\n-\t\t  break;\n-\t\t}\n-\n-\t      rtx_insn *next_lab = next_active_insn (as_a<rtx_insn *> (lab));\n-\t      if (next_lab\n-\t\t  && recog_memoized (next_lab) != CODE_FOR_doloop_begin_i)\n-\t\tbreak;\n-\n-\t\tn_insns++;\n-\t    }\n-\t  break;\n-\t}\n-      len = get_attr_length (scan);\n-      /* Size estimation of asms assumes that each line which is nonempty\n-\t codes an insn, and that each has a long immediate.  For minimum insn\n-\t count, assume merely that a nonempty asm has at least one insn.  */\n-      if (GET_CODE (PATTERN (scan)) == ASM_INPUT\n-\t  || asm_noperands (PATTERN (scan)) >= 0)\n-\tn_insns += (len != 0);\n-      else\n-\tn_insns += (len > 4 ? 2 : (len ? 1 : 0));\n-    }\n-  if (LOOP_ALIGN (0))\n-    {\n-      asm_fprintf (asm_out_file, \"\\t.p2align %d\\\\n\", LOOP_ALIGN (0));\n-      arc_clear_unalign ();\n-    }\n-  gcc_assert (n_insns || GET_CODE (next_nonnote_insn (insn)) == CODE_LABEL);\n-  if (size >= 2048 || (TARGET_ARC600 && n_insns == 1) || loop_start)\n-    {\n-      if (flag_pic)\n-\t{\n-\t  /* ??? Can do better for when a scratch register\n-\t     is known.  But that would require extra testing.  */\n-\t  arc_clear_unalign ();\n-\t  return \".p2align 2\\;push_s r0\\;add r0,pcl,24\\;sr r0,[2]; LP_START\\;add r0,pcl,.L__GCC__LP%1@pcl\\;sr r0,[3]; LP_END\\;pop_s r0\";\n-\t}\n-      output_asm_insn ((size < 2048\n-\t\t\t? \"lp .L__GCC__LP%1\" : \"sr .L__GCC__LP%1,[3]; LP_END\"),\n-\t\t       operands);\n-      output_asm_insn (loop_start\n-\t\t       ? \"sr %4,[2]; LP_START\" : \"sr 0f,[2]; LP_START\",\n-\t\t       operands);\n-      if (TARGET_ARC600 && n_insns < 1)\n-\toutput_asm_insn (\"nop\", operands);\n-      return (TARGET_ARC600 && n_insns < 3) ? \"nop_s\\;nop_s\\;0:\" : \"0:\";\n-    }\n-  else if (TARGET_ARC600 && n_insns < 3)\n-    {\n-      /* At least four instructions are needed between the setting of LP_COUNT\n-\t and the loop end - but the lp instruction qualifies as one.  */\n-      rtx_insn *prev = prev_nonnote_insn (insn);\n-\n-      if (!INSN_P (prev) || dead_or_set_regno_p (prev, LP_COUNT))\n-\toutput_asm_insn (\"nop\", operands);\n-    }\n-  return \"lp .L__GCC__LP%1\";\n-}\n+  \"lp\\\\t@%l2\\\\t; %0:@%l1->@%l2\"\n   [(set_attr \"type\" \"loop_setup\")\n-   (set_attr_alternative \"length\"\n-;     FIXME: length is usually 4, but we need branch shortening\n-;     to get this right.\n-;     [(if_then_else (match_test \"TARGET_ARC600\") (const_int 16) (const_int 4))\n-     [(if_then_else (match_test \"flag_pic\") (const_int 24) (const_int 16))\n-      (if_then_else (match_test \"flag_pic\") (const_int 28) (const_int 16))\n-      (const_int 0)])]\n-  ;; ??? we should really branch shorten this insn, but then we'd\n-  ;; need a proper label first.  N.B. the end label can not only go out\n-  ;; of range when it is far away, but also when it precedes the loop -\n-  ;; which, unfortunately, it sometimes does, when the loop \"optimizer\"\n-  ;; messes things up.\n-)\n-\n-; operand 0 is the loop count pseudo register\n-; operand 1 is the label to jump to at the top of the loop\n-; Use this for the ARC600 and ARC700.\n-; ??? ARC600 might want to check if the loop has few iteration and only a\n-; single insn - loop setup is expensive then.\n-(define_expand \"doloop_end\"\n-  [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"!TARGET_ARC601\"\n-{\n-  /* We could do smaller bivs with biv widening, and wider bivs by having\n-     a high-word counter in an outer loop - but punt on this for now.  */\n-  if (GET_MODE (operands[0]) != SImode)\n-    FAIL;\n-  emit_jump_insn (gen_doloop_end_i (operands[0], operands[1], const0_rtx));\n-  DONE;\n-})\n+   (set_attr \"length\" \"4\")])\n \n-(define_insn_and_split \"doloop_end_i\"\n+;; if by any chance the lp_count is not used, then use an 'r'\n+;; register, instead of going to memory.\n+(define_insn \"loop_end\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 0 \"shouldbe_register_operand\" \"+l,*c,*m\")\n-\t\t\t   (const_int 1))\n+\t(if_then_else (ne (match_operand:SI 2 \"nonimmediate_operand\" \"0,0\")\n+\t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))\n-   (use (reg:SI LP_START))\n-   (use (reg:SI LP_END))\n-   (use (match_operand 2 \"const_int_operand\" \"n,???Cn0,???X\"))\n-   (clobber (match_scratch:SI 3 \"=X,X,&????r\"))]\n+   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=l!r,m\")\n+\t(plus (match_dup 2) (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_ARC_LP)\n+   (clobber (match_scratch:SI 3 \"=X,&r\"))]\n   \"\"\n-  \"*\n-{\n-  rtx_insn *prev = prev_nonnote_insn (insn);\n-\n-  /* If there is an immediately preceding label, we must output a nop,\n-     lest a branch to that label will fall out of the loop.\n-     ??? We could try to avoid this by claiming to have a delay slot if there\n-     is a preceding label, and outputting the delay slot insn instead, if\n-     present.\n-     Or we could have some optimization that changes the source edge to update\n-     the loop count and jump to the loop start instead.  */\n-  /* For ARC600, we must also prevent jumps inside the loop and jumps where\n-     the loop counter value is live at the target from being directly at the\n-     loop end.  Being sure that the loop counter is dead at the target is\n-     too much hair - we can't rely on data flow information at this point -\n-     so insert a nop for all branches.\n-     The ARC600 also can't read the loop counter in the last insn of a loop.  */\n-  if (LABEL_P (prev))\n-    output_asm_insn (\\\"nop%?\\\", operands);\n-  return \\\"\\\\n.L__GCC__LP%2: ; loop end, start is %1\\\";\n-}\"\n-  \"&& memory_operand (operands[0], SImode)\"\n-  [(pc)]\n-{\n-  emit_move_insn (operands[3], operands[0]);\n-  emit_jump_insn (gen_doloop_fallback_m (operands[3], operands[1], operands[0]));\n-  DONE;\n-}\n-  [(set_attr \"type\" \"loop_end\")\n-   (set (attr \"length\")\n-\t(if_then_else (match_test \"LABEL_P (prev_nonnote_insn (insn))\")\n-\t\t      (const_int 4) (const_int 0)))]\n-)\n+  \"\\\\t;%0 %1 %2\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"predicable\" \"no\")\n+   (set_attr \"type\" \"loop_end\")])\n \n-; This pattern is generated by arc_reorg when there is no recognizable\n-; loop start.\n-(define_insn \"*doloop_fallback\"\n-  [(set (pc) (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"+r,!w\")\n-\t\t\t\t(const_int 1))\n-\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n-\t\t\t   (pc)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))]\n-   ; avoid fooling the loop optimizer into assuming this is a special insn.\n-  \"reload_completed\"\n-  \"*return get_attr_length (insn) == 8\n-   ? \\\"brne.d %0,1,%1\\;sub %0,%0,1\\\"\n-   : \\\"breq %0,1,0f\\;b.d %1\\;sub %0,%0,1\\\\n0:\\\";\"\n-  [(set (attr \"length\")\n-\t(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -256))\n- \t\t\t   (le (minus (match_dup 1) (pc)) (const_int 244)))\n- \t\t      (const_int 8) (const_int 12)))\n-   (set_attr \"type\" \"brcc_no_delay_slot\")\n-   (set_attr \"cond\" \"nocond\")]\n-)\n+;; split pattern for the very slim chance when the loop register is\n+;; memory.\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (ne (match_operand:SI 0 \"memory_operand\")\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 1 \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 0) (plus (match_dup 0) (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_ARC_LP)\n+   (clobber (match_scratch:SI 2))]\n+  \"memory_operand (operands[0], SImode)\"\n+  [(set (match_dup 2) (match_dup 0))\n+   (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n+   (set (match_dup 0) (match_dup 2))\n+   (set (reg:CC CC_REG) (compare:CC (match_dup 2) (const_int 0)))\n+   (set (pc)\n+\t(if_then_else (ne (reg:CC CC_REG)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_dup 1))\n+\t\t      (pc)))]\n+  \"\")\n \n-; reload can't make output reloads for jump insns, so we have to do this by hand.\n-(define_insn \"doloop_fallback_m\"\n-  [(set (pc) (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"+&r\")\n-\t\t\t\t(const_int 1))\n-\t\t\t   (label_ref (match_operand 1 \"\" \"\"))\n-\t\t\t   (pc)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))\n-   (set (match_operand:SI 2 \"memory_operand\" \"=m\")\n-\t(plus:SI (match_dup 0) (const_int -1)))]\n-   ; avoid fooling the loop optimizer into assuming this is a special insn.\n-  \"reload_completed\"\n-  \"*return get_attr_length (insn) == 12\n-   ? \\\"sub %0,%0,1\\;brne.d %0,0,%1\\;st%U2%V2 %0,%2\\\"\n-   : \\\"sub %0,%0,1\\;breq %0,0,0f\\;b.d %1\\\\n0:\\tst%U2%V2 %0,%2\\\";\"\n-  [(set (attr \"length\")\n-\t(if_then_else (and (ge (minus (match_dup 1) (pc)) (const_int -252))\n- \t\t\t   (le (minus (match_dup 1) (pc)) (const_int 244)))\n- \t\t      (const_int 12) (const_int 16)))\n-   (set_attr \"type\" \"brcc_no_delay_slot\")\n-   (set_attr \"cond\" \"nocond\")]\n-)\n+(define_insn \"loop_fail\"\n+  [(set (reg:SI LP_COUNT)\n+\t(plus:SI (reg:SI LP_COUNT) (const_int -1)))\n+   (set (reg:CC_ZN CC_REG)\n+\t(compare:CC_ZN (plus:SI (reg:SI LP_COUNT) (const_int -1))\n+\t\t       (const_int 0)))]\n+  \"\"\n+  \"sub.f%?\\\\tlp_count,lp_count,1\"\n+  [(set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"compare\")\n+   (set_attr \"cond\" \"set_zn\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"predicable\" \"yes\")])\n+\n+(define_insn_and_split \"dbnz\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+r!l,m\")\n+\t\t      (const_int -1))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (clobber (match_scratch:SI 2 \"=X,r\"))]\n+  \"TARGET_V2\"\n+  \"@\n+   dbnz%#\\\\t%0,%l1\n+   #\"\n+  \"TARGET_V2 && reload_completed && memory_operand (operands[0], SImode)\"\n+  [(set (match_dup 2) (match_dup 0))\n+   (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n+   (set (reg:CC CC_REG) (compare:CC (match_dup 2) (const_int 0)))\n+   (set (match_dup 0) (match_dup 2))\n+   (set (pc) (if_then_else (ge (reg:CC CC_REG)\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_dup 1))\n+\t\t\t   (pc)))]\n+  \"\"\n+  [(set_attr \"iscompact\" \"false\")\n+   (set_attr \"type\" \"loop_end\")\n+   (set_attr \"length\" \"4,20\")])\n \n (define_expand \"movmemsi\"\n   [(match_operand:BLK 0 \"\" \"\")"}, {"sha": "d1ebd442a4d8de6aadf61395ceff14c34468f2a3", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -494,3 +494,28 @@ Specifies the registers that the processor saves on an interrupt entry and exit.\n mrgf-banked-regs=\n Target RejectNegative Joined Var(arc_deferred_options) Defer\n Specifies the number of registers replicated in second register bank on entry to fast interrupt.\n+\n+mlpc-width=\n+Target RejectNegative Joined Enum(arc_lpc) Var(arc_lpcwidth) Init(32)\n+Sets LP_COUNT register width.  Possible values are 8, 16, 20, 24, 28, and 32.\n+\n+Enum\n+Name(arc_lpc) Type(int)\n+\n+EnumValue\n+Enum(arc_lpc) String(8) Value(8)\n+\n+EnumValue\n+Enum(arc_lpc) String(16) Value(16)\n+\n+EnumValue\n+Enum(arc_lpc) String(20) Value(20)\n+\n+EnumValue\n+Enum(arc_lpc) String(24) Value(24)\n+\n+EnumValue\n+Enum(arc_lpc) String(28) Value(28)\n+\n+EnumValue\n+Enum(arc_lpc) String(32) Value(32)"}, {"sha": "3dfe0caa60e40ccdfee1743b607ab3c117eec8c0", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -362,6 +362,8 @@\n       else if (TARGET_MUL64_SET\n \t       && (REGNO (op) == 57 || REGNO(op) == 58 || REGNO(op) == 59 ))\n \treturn 0;\n+      else if (REGNO (op) == LP_COUNT)\n+        return 1;\n       else\n \treturn dest_reg_operand (op, mode);\n     case SUBREG :"}, {"sha": "ab76c1b10bb4c038e34a20eb122600f7f976ea32", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -614,7 +614,7 @@ Objective-C and Objective-C++ Dialects}.\n -mcrc  -mdsp-packa  -mdvbf  -mlock  -mmac-d16  -mmac-24  -mrtsc  -mswape @gol\n -mtelephony  -mxy  -misize  -mannotate-align  -marclinux  -marclinux_prof @gol\n -mlong-calls  -mmedium-calls  -msdata -mirq-ctrl-saved @gol\n--mrgf-banked-regs -G @var{num} @gol\n+-mrgf-banked-regs -mlpc-width=@var{width} -G @var{num} @gol\n -mvolatile-cache  -mtp-regno=@var{regno} @gol\n -malign-call  -mauto-modify-reg  -mbbit-peephole  -mno-brcc @gol\n -mcase-vector-pcrel  -mcompact-casesi  -mno-cond-exec  -mearly-cbranchsi @gol\n@@ -14779,6 +14779,18 @@ registers to avoid memory transactions during interrupt entry and exit\n sequences.  Use this option when you are using fast interrupts in an\n ARC V2 family processor.  Permitted values are 4, 8, 16, and 32.\n \n+@item -mlpc-width=@var{width}\n+@opindex mlpc-width\n+Specify the width of the @code{lp_count} register.  Valid values for\n+@var{width} are 8, 16, 20, 24, 28 and 32 bits.  The default width is\n+fixed to 32 bits.  If the width is less than 32, the compiler does not\n+attempt to transform loops in your program to use the zero-delay loop\n+mechanism unless it is known that the @code{lp_count} register can\n+hold the required loop-counter value.  Depending on the width\n+specified, the compiler and run-time library might continue to use the\n+loop mechanism for various needs.  This option defines macro\n+@code{__ARC_LPC_WIDTH__} with the value of @var{width}.\n+\n @end table\n \n The following options are passed through to the assembler, and also"}, {"sha": "12161a62963e619629c7eae0204a66a3da3eb2e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2de90a45a9193cb19a5837110698fe59d6deb41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a2de90a45a9193cb19a5837110698fe59d6deb41", "patch": "@@ -1,3 +1,7 @@\n+2017-09-01  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/loop-1.c: Deleted.\n+\n 2017-09-01  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* gcc.target/arc/arc.exp: Test also cpp files."}, {"sha": "1afe8ebacea379344719a8607f910d5fd714486e", "filename": "gcc/testsuite/gcc.target/arc/loop-1.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/782bdf21895dc769cfd85a08c8c1b780924775f3/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/782bdf21895dc769cfd85a08c8c1b780924775f3/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Floop-1.c?ref=782bdf21895dc769cfd85a08c8c1b780924775f3", "patch": "@@ -1,45 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2\" } */\n-\n-/* This case would fail to make use of the zero-overhead loop\n-   instruction at one time due to a bug.  */\n-\n-extern char a[];\n-\n-struct some_t\n-{\n-  struct\n-  {\n-    int aaa;\n-    short bbb;\n-    char ccc;\n-    char ddd;\n-  } ppp[8];\n-\n-  int www[1];\n-};\n-\n-int b;\n-\n-void\n-some_function ()\n-{\n-  struct some_t *tmp = (struct some_t *) a;\n-\n-  while ((*tmp).ppp[b].ccc)\n-    while(0);\n-\n-  for (; b; b++)\n-    {\n-      if (tmp->ppp[b].ccc)\n-        {\n-          int c = tmp->ppp[b].bbb;\n-          int d = tmp->ppp[b].aaa;\n-          int e = d - tmp->www[c];\n-          if (e)\n-            tmp->ppp[b].ddd = 1;\n-        }\n-    }\n-}\n-\n-/* { dg-final { scan-assembler \"\\[^\\n\\]+lp \\\\.L__GCC__\" } } */"}]}