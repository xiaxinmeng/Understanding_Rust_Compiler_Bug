{"sha": "de05c19d5fd661ae16dd75a895b49d32d12f5edc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUwNWMxOWQ1ZmQ2NjFhZTE2ZGQ3NWE4OTViNDlkMzJkMTJmNWVkYw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-10-09T19:56:53Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-10-12T15:04:49Z"}, "message": "Correct handling of indices into arrays with elements larger than 1 (PR c++/96511)\n\nResolves:\nPR c++/96511 - Incorrect -Wplacement-new on POINTER_PLUS into an array with 4-byte elements\nPR middle-end/96384 - bogus -Wstringop-overflow= storing into multidimensional array with index in range\n\ngcc/ChangeLog:\n\n\tPR c++/96511\n\tPR middle-end/96384\n\t* builtins.c (get_range): Return full range of type when neither\n\tvalue nor its range is available.  Fail for ranges inverted due\n\tto the signedness of offsets.\n\t(compute_objsize): Handle more special array members.  Handle\n\tPOINTER_PLUS_EXPR and VIEW_CONVERT_EXPR that come up in front end\n\tcode.\n\t(access_ref::offset_bounded): Define new member function.\n\t* builtins.h (access_ref::eval): New data member.\n\t(access_ref::offset_bounded): New member function.\n\t(access_ref::offset_zero): New member function.\n\t(compute_objsize): Declare a new overload.\n\t* gimple-array-bounds.cc (array_bounds_checker::check_array_ref): Use\n\tenum special_array_member.\n\t* tree.c (component_ref_size): Use special_array_member.\n\t* tree.h (special_array_member): Define a new type.\n\t(component_ref_size): Change signature.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/96511\n\tPR middle-end/96384\n\t* init.c (warn_placement_new_too_small): Call builtin_objsize instead\n\tof duplicating what it does.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/96511\n\tPR middle-end/96384\n\t* g++.dg/init/strlen.C: Add expected warning.\n\t* g++.dg/warn/Wplacement-new-size-1.C: Relax warnings.\n\t* g++.dg/warn/Wplacement-new-size-2.C: Same.\n\t* g++.dg/warn/Wplacement-new-size-6.C: Same.\n\t* gcc.dg/Warray-bounds-58.c: Adjust\n\t* gcc.dg/Wstringop-overflow-37.c: Same.\n\t* g++.dg/warn/Wplacement-new-size-7.C: New test.", "tree": {"sha": "05d9906c75f514094c4320b482f200787a34b9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05d9906c75f514094c4320b482f200787a34b9b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de05c19d5fd661ae16dd75a895b49d32d12f5edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de05c19d5fd661ae16dd75a895b49d32d12f5edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de05c19d5fd661ae16dd75a895b49d32d12f5edc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de05c19d5fd661ae16dd75a895b49d32d12f5edc/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71dbabccbfb295c87d91719fe72d9d60511c0b44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dbabccbfb295c87d91719fe72d9d60511c0b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71dbabccbfb295c87d91719fe72d9d60511c0b44"}], "stats": {"total": 714, "additions": 391, "deletions": 323}, "files": [{"sha": "283c1e6674c8b612156a7ce7180f38a6b9e5f083", "filename": "gcc/builtins.c", "status": "modified", "additions": 108, "deletions": 27, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -200,7 +200,7 @@ static void expand_builtin_sync_synchronize (void);\n \n access_ref::access_ref (tree bound /* = NULL_TREE */,\n \t\t\tbool minaccess /* = false */)\n-  : ref ()\n+: ref (), eval ([](tree x){ return x; }), trail1special (true)\n {\n   /* Set to valid.  */\n   offrng[0] = offrng[1] = 0;\n@@ -4370,10 +4370,34 @@ static bool\n get_range (tree x, gimple *stmt, signop sgn, offset_int r[2],\n \t   range_query *rvals /* = NULL */)\n {\n+  tree type = TREE_TYPE (x);\n+  if (TREE_CODE (x) != INTEGER_CST\n+      && TREE_CODE (x) != SSA_NAME)\n+    {\n+      if (TYPE_UNSIGNED (type))\n+\t{\n+\t  if (sgn == SIGNED)\n+\t    type = signed_type_for (type);\n+\t}\n+      else if (sgn == UNSIGNED)\n+\ttype = unsigned_type_for (type);\n+\n+      r[0] = wi::to_offset (TYPE_MIN_VALUE (type));\n+      r[1] = wi::to_offset (TYPE_MAX_VALUE (type));\n+      return x;\n+    }\n+\n   wide_int wr[2];\n   if (!get_range (x, stmt, wr, rvals))\n     return false;\n \n+  /* Only convert signed integers or unsigned sizetype to a signed\n+     offset and avoid converting large positive values in narrower\n+     types to negative offsets.  */\n+  if (TYPE_UNSIGNED (type)\n+      && wr[0].get_precision () < TYPE_PRECISION (sizetype))\n+    sgn = UNSIGNED;\n+\n   r[0] = offset_int::from (wr[0], sgn);\n   r[1] = offset_int::from (wr[1], sgn);\n   return true;\n@@ -4394,9 +4418,11 @@ get_range (tree x, gimple *stmt, signop sgn, offset_int r[2],\n    to influence code generation or optimization.  */\n \n static bool\n-compute_objsize (tree ptr, int ostype, access_ref *pref,\n-\t\t bitmap *visited, range_query *rvals /* = NULL */)\n+compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n+\t\t range_query *rvals)\n {\n+  STRIP_NOPS (ptr);\n+\n   const bool addr = TREE_CODE (ptr) == ADDR_EXPR;\n   if (addr)\n     ptr = TREE_OPERAND (ptr, 0);\n@@ -4408,26 +4434,29 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n       if (!addr && POINTER_TYPE_P (TREE_TYPE (ptr)))\n \treturn false;\n \n-      tree size = decl_init_size (ptr, false);\n-      if (!size || TREE_CODE (size) != INTEGER_CST)\n-\treturn false;\n-\n       pref->ref = ptr;\n-      pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+      if (tree size = decl_init_size (ptr, false))\n+\tif (TREE_CODE (size) == INTEGER_CST)\n+\t  {\n+\t    pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+\t    return true;\n+\t  }\n+      pref->sizrng[0] = 0;\n+      pref->sizrng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n       return true;\n     }\n \n   const tree_code code = TREE_CODE (ptr);\n \n   if (code == COMPONENT_REF)\n     {\n+      tree ref = TREE_OPERAND (ptr, 0);\n       tree field = TREE_OPERAND (ptr, 1);\n \n       if (ostype == 0)\n \t{\n \t  /* For raw memory functions like memcpy bail if the size\n \t     of the enclosing object cannot be determined.  */\n-\t  tree ref = TREE_OPERAND (ptr, 0);\n \t  if (!compute_objsize (ref, ostype, pref, visited, rvals)\n \t      || !pref->ref)\n \t    return false;\n@@ -4449,20 +4478,28 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \treturn false;\n \n       pref->ref = field;\n-      /* Only return constant sizes for now while callers depend\n-\t on it.  INT0LEN is true for interior zero-length arrays.  */\n-      bool int0len = false;\n-      tree size = component_ref_size (ptr, &int0len);\n-      if (int0len)\n+\n+      /* SAM is set for array members that might need special treatment.  */\n+      special_array_member sam;\n+      tree size = component_ref_size (ptr, &sam);\n+      if (sam == special_array_member::int_0)\n+\tpref->sizrng[0] = pref->sizrng[1] = 0;\n+      else if (!pref->trail1special && sam == special_array_member::trail_1)\n+\tpref->sizrng[0] = pref->sizrng[1] = 1;\n+      else if (size && TREE_CODE (size) == INTEGER_CST)\n+\tpref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+      else\n \t{\n-\t  pref->sizrng[0] = pref->sizrng[1] = 0;\n-\t  return true;\n+\t  /* When the size of the member is unknown it's either a flexible\n+\t     array member or a trailing special array member (either zero\n+\t     length or one-element).  Set the size to the maximum minus\n+\t     the constant size of the type.  */\n+\t  pref->sizrng[0] = 0;\n+\t  pref->sizrng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\t  if (tree recsize = TYPE_SIZE_UNIT (TREE_TYPE (ref)))\n+\t    if (TREE_CODE (recsize) == INTEGER_CST)\n+\t      pref->sizrng[1] -= wi::to_offset (recsize);\n \t}\n-\n-      if (!size || TREE_CODE (size) != INTEGER_CST)\n-\treturn false;\n-\n-      pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n       return true;\n     }\n \n@@ -4492,7 +4529,7 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \treturn false;\n \n       offset_int orng[2];\n-      tree off = TREE_OPERAND (ptr, 1);\n+      tree off = pref->eval (TREE_OPERAND (ptr, 1));\n       if (!get_range (off, NULL, SIGNED, orng, rvals))\n \t/* Fail unless the size of the object is zero.  */\n \treturn pref->sizrng[0] == 0 && pref->sizrng[0] == pref->sizrng[1];\n@@ -4522,11 +4559,22 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n \t  if (ostype && TREE_CODE (eltype) == ARRAY_TYPE)\n \t    {\n-\t      /* Execpt for the permissive raw memory functions which\n-\t\t use the size of the whole object determined above,\n-\t\t use the size of the referenced array.  */\n-\t      pref->sizrng[0] = pref->offrng[0] + orng[0] + sz;\n-\t      pref->sizrng[1] = pref->offrng[1] + orng[1] + sz;\n+\t      /* Except for the permissive raw memory functions which use\n+\t\t the size of the whole object determined above, use the size\n+\t\t of the referenced array.  Because the overall offset is from\n+\t\t the beginning of the complete array object add this overall\n+\t\t offset to the size of array.  */\n+\t      offset_int sizrng[2] =\n+\t\t{\n+\t\t pref->offrng[0] + orng[0] + sz,\n+\t\t pref->offrng[1] + orng[1] + sz\n+\t\t};\n+\t      if (sizrng[1] < sizrng[0])\n+\t\tstd::swap (sizrng[0], sizrng[1]);\n+\t      if (sizrng[0] >= 0 && sizrng[0] <= pref->sizrng[0])\n+\t\tpref->sizrng[0] = sizrng[0];\n+\t      if (sizrng[1] >= 0 && sizrng[1] <= pref->sizrng[1])\n+\t\tpref->sizrng[1] = sizrng[1];\n \t    }\n \t}\n \n@@ -4535,6 +4583,28 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n \n       return true;\n     }\n+  else if (code == POINTER_PLUS_EXPR)\n+    {\n+      tree ref = TREE_OPERAND (ptr, 0);\n+      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+\treturn false;\n+\n+      offset_int orng[2];\n+      tree off = pref->eval (TREE_OPERAND (ptr, 1));\n+      if (!get_range (off, NULL, SIGNED, orng, rvals))\n+\t/* Fail unless the size of the object is zero.  */\n+\treturn pref->sizrng[0] == 0 && pref->sizrng[0] == pref->sizrng[1];\n+\n+      pref->offrng[0] += orng[0];\n+      pref->offrng[1] += orng[1];\n+\n+      return true;\n+    }\n+  else if (code == VIEW_CONVERT_EXPR)\n+    {\n+      ptr = TREE_OPERAND (ptr, 0);\n+      return compute_objsize (ptr, ostype, pref, visited, rvals);\n+    }\n \n   if (TREE_CODE (ptr) == SSA_NAME)\n     {\n@@ -12504,3 +12574,14 @@ builtin_with_linkage_p (tree decl)\n     }\n   return false;\n }\n+\n+/* Return true if OFFRNG is bounded to a subrange of offset values\n+   valid for the largest possible object.  */\n+\n+bool\n+access_ref::offset_bounded () const\n+{\n+  tree min = TYPE_MIN_VALUE (ptrdiff_type_node);\n+  tree max = TYPE_MAX_VALUE (ptrdiff_type_node);\n+  return wi::to_offset (min) <= offrng[0] && offrng[1] <= wi::to_offset (max);\n+}"}, {"sha": "f226c63e19861ebe2afa2066f26f8bd4c029c0e1", "filename": "gcc/builtins.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -173,6 +173,22 @@ struct access_ref\n      For string functions the size of the actual access is\n      further constrained by the length of the string.  */\n   offset_int bndrng[2];\n+\n+  /* Return true if OFFRNG is the constant zero.  */\n+  bool offset_zero () const\n+  {\n+    return offrng[0] == 0 && offrng[1] == 0;\n+  }\n+\n+  /* Return true if OFFRNG is bounded to a subrange of possible offset\n+     values.  */\n+  bool offset_bounded () const;\n+\n+  /* Used to fold integer expressions when called from front ends.  */\n+  tree (*eval)(tree);\n+  /* Set if trailing one-element arrays should be treated as flexible\n+     array members.  */\n+  bool trail1special;\n };\n \n /* Describes a pair of references used in an access by built-in"}, {"sha": "1bddb6555dc182294ed0c9c39f66c3be4d4e0b3d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 83, "deletions": 249, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"asan.h\"\n #include \"stor-layout.h\"\n+#include \"builtins.h\"\n \n static bool begin_init_stmts (tree *, tree *);\n static tree finish_init_stmts (bool, tree, tree);\n@@ -2564,27 +2565,6 @@ throw_bad_array_new_length (void)\n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n \n-/* Attempt to find the initializer for flexible array field T in the\n-   initializer INIT, when non-null.  Returns the initializer when\n-   successful and NULL otherwise.  */\n-static tree\n-find_flexarray_init (tree t, tree init)\n-{\n-  if (!init || init == error_mark_node)\n-    return NULL_TREE;\n-\n-  unsigned HOST_WIDE_INT idx;\n-  tree field, elt;\n-\n-  /* Iterate over all top-level initializer elements.  */\n-  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), idx, field, elt)\n-    /* If the member T is found, return it.  */\n-    if (field == t)\n-      return elt;\n-\n-  return NULL_TREE;\n-}\n-\n /* Attempt to verify that the argument, OPER, of a placement new expression\n    refers to an object sufficiently large for an object of TYPE or an array\n    of NELTS of such objects when NELTS is non-null, and issue a warning when\n@@ -2601,17 +2581,6 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n {\n   location_t loc = cp_expr_loc_or_input_loc (oper);\n \n-  /* The number of bytes to add to or subtract from the size of the provided\n-     buffer based on an offset into an array or an array element reference.\n-     Although intermediate results may be negative (as in a[3] - 2) a valid\n-     final result cannot be.  */\n-  offset_int adjust = 0;\n-  /* True when the size of the entire destination object should be used\n-     to compute the possibly optimistic estimate of the available space.  */\n-  bool use_obj_size = false;\n-  /* True when the reference to the destination buffer is an ADDR_EXPR.  */\n-  bool addr_expr = false;\n-\n   STRIP_NOPS (oper);\n \n   /* Using a function argument or a (non-array) variable as an argument\n@@ -2625,231 +2594,96 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n   /* Evaluate any constant expressions.  */\n   size = fold_non_dependent_expr (size);\n \n-  /* Handle the common case of array + offset expression when the offset\n-     is a constant.  */\n-  if (TREE_CODE (oper) == POINTER_PLUS_EXPR)\n-    {\n-      /* If the offset is compile-time constant, use it to compute a more\n-\t accurate estimate of the size of the buffer.  Since the operand\n-\t of POINTER_PLUS_EXPR is represented as an unsigned type, convert\n-\t it to signed first.\n-\t Otherwise, use the size of the entire array as an optimistic\n-\t estimate (this may lead to false negatives).  */\n-      tree adj = TREE_OPERAND (oper, 1);\n-      adj = fold_for_warn (adj);\n-      if (CONSTANT_CLASS_P (adj))\n-\tadjust += wi::to_offset (convert (ssizetype, adj));\n-      else\n-\tuse_obj_size = true;\n-\n-      oper = TREE_OPERAND (oper, 0);\n-\n-      STRIP_NOPS (oper);\n-    }\n-\n-  if (TREE_CODE (oper) == TARGET_EXPR)\n-    oper = TREE_OPERAND (oper, 1);\n-  else if (TREE_CODE (oper) == ADDR_EXPR)\n-    {\n-      addr_expr = true;\n-      oper = TREE_OPERAND (oper, 0);\n-    }\n-\n-  STRIP_NOPS (oper);\n-\n-  if (TREE_CODE (oper) == ARRAY_REF\n-      && (addr_expr || TREE_CODE (TREE_TYPE (oper)) == ARRAY_TYPE))\n-    {\n-      /* Similar to the offset computed above, see if the array index\n-\t is a compile-time constant.  If so, and unless the offset was\n-\t not a compile-time constant, use the index to determine the\n-\t size of the buffer.  Otherwise, use the entire array as\n-\t an optimistic estimate of the size.  */\n-      const_tree adj = fold_non_dependent_expr (TREE_OPERAND (oper, 1));\n-      if (!use_obj_size && CONSTANT_CLASS_P (adj))\n-\tadjust += wi::to_offset (adj);\n-      else\n-\t{\n-\t  use_obj_size = true;\n-\t  adjust = 0;\n-\t}\n+  access_ref ref;\n+  ref.eval = [](tree x){ return fold_non_dependent_expr (x); };\n+  ref.trail1special = warn_placement_new < 2;\n+  tree objsize =  compute_objsize (oper, 1, &ref);\n+  if (!objsize)\n+    return;\n \n-      oper = TREE_OPERAND (oper, 0);\n-    }\n+  offset_int bytes_avail = wi::to_offset (objsize);\n+  offset_int bytes_need;\n \n-  /* Refers to the declared object that constains the subobject referenced\n-     by OPER.  When the object is initialized, makes it possible to determine\n-     the actual size of a flexible array member used as the buffer passed\n-     as OPER to placement new.  */\n-  tree var_decl = NULL_TREE;\n-  /* True when operand is a COMPONENT_REF, to distinguish flexible array\n-     members from arrays of unspecified size.  */\n-  bool compref = TREE_CODE (oper) == COMPONENT_REF;\n-\n-  /* For COMPONENT_REF (i.e., a struct member) the size of the entire\n-     enclosing struct.  Used to validate the adjustment (offset) into\n-     an array at the end of a struct.  */\n-  offset_int compsize = 0;\n-\n-  /* Descend into a struct or union to find the member whose address\n-     is being used as the argument.  */\n-  if (TREE_CODE (oper) == COMPONENT_REF)\n+  if (CONSTANT_CLASS_P (size))\n+    bytes_need = wi::to_offset (size);\n+  else if (nelts && CONSTANT_CLASS_P (nelts))\n+    bytes_need = (wi::to_offset (nelts)\n+\t\t  * wi::to_offset (TYPE_SIZE_UNIT (type)));\n+  else if (tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n+    bytes_need = wi::to_offset (TYPE_SIZE_UNIT (type));\n+  else\n     {\n-      tree comptype = TREE_TYPE (TREE_OPERAND (oper, 0));\n-      compsize = wi::to_offset (TYPE_SIZE_UNIT (comptype));\n-\n-      tree op0 = oper;\n-      while (TREE_CODE (op0 = TREE_OPERAND (op0, 0)) == COMPONENT_REF);\n-      STRIP_ANY_LOCATION_WRAPPER (op0);\n-      if (VAR_P (op0))\n-\tvar_decl = op0;\n-      oper = TREE_OPERAND (oper, 1);\n+      /* The type is a VLA.  */\n+      return;\n     }\n \n-  STRIP_ANY_LOCATION_WRAPPER (oper);\n-  tree opertype = TREE_TYPE (oper);\n-  if ((addr_expr || !INDIRECT_TYPE_P (opertype))\n-      && (VAR_P (oper)\n-\t  || TREE_CODE (oper) == FIELD_DECL\n-\t  || TREE_CODE (oper) == PARM_DECL))\n-    {\n-      /* A possibly optimistic estimate of the number of bytes available\n-\t in the destination buffer.  */\n-      offset_int bytes_avail = 0;\n-      /* True when the estimate above is in fact the exact size\n-\t of the destination buffer rather than an estimate.  */\n-      bool exact_size = true;\n-\n-      /* Treat members of unions and members of structs uniformly, even\n-\t though the size of a member of a union may be viewed as extending\n-\t to the end of the union itself (it is by __builtin_object_size).  */\n-      if ((VAR_P (oper) || use_obj_size)\n-\t  && DECL_SIZE_UNIT (oper)\n-\t  && tree_fits_uhwi_p (DECL_SIZE_UNIT (oper)))\n-\t{\n-\t  /* Use the size of the entire array object when the expression\n-\t     refers to a variable or its size depends on an expression\n-\t     that's not a compile-time constant.  */\n-\t  bytes_avail = wi::to_offset (DECL_SIZE_UNIT (oper));\n-\t  exact_size = !use_obj_size;\n-\t}\n-      else if (tree opersize = TYPE_SIZE_UNIT (opertype))\n-\t{\n-\t  /* Use the size of the type of the destination buffer object\n-\t     as the optimistic estimate of the available space in it.\n-\t     Use the maximum possible size for zero-size arrays and\n-\t     flexible array members (except of initialized objects\n-\t     thereof).  */\n-\t  if (TREE_CODE (opersize) == INTEGER_CST)\n-\t    bytes_avail = wi::to_offset (opersize);\n-\t}\n-\n-      if (bytes_avail == 0)\n-\t{\n-\t  if (var_decl)\n-\t    {\n-\t      /* Constructing into a buffer provided by the flexible array\n-\t\t member of a declared object (which is permitted as a G++\n-\t\t extension).  If the array member has been initialized,\n-\t\t determine its size from the initializer.  Otherwise,\n-\t\t the array size is zero.  */\n-\t      if (tree init = find_flexarray_init (oper,\n-\t\t\t\t\t\t   DECL_INITIAL (var_decl)))\n-\t\tbytes_avail = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (init)));\n-\t    }\n-\t  else\n-\t    bytes_avail = (wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node))\n-\t\t\t   - compsize);\n-\t}\n-\n-      tree_code oper_code = TREE_CODE (opertype);\n-\n-      if (compref && oper_code == ARRAY_TYPE)\n-\t{\n-\t  tree nelts = array_type_nelts_top (opertype);\n-\t  tree nelts_cst = maybe_constant_value (nelts);\n-\t  if (TREE_CODE (nelts_cst) == INTEGER_CST\n-\t      && integer_onep (nelts_cst)\n-\t      && !var_decl\n-\t      && warn_placement_new < 2)\n-\t    return;\n-\t}\n-\n-      /* Reduce the size of the buffer by the adjustment computed above\n-\t from the offset and/or the index into the array.  */\n-      if (bytes_avail < adjust || adjust < 0)\n-\tbytes_avail = 0;\n-      else\n-\t{\n-\t  tree elttype = (TREE_CODE (opertype) == ARRAY_TYPE\n-\t\t\t  ? TREE_TYPE (opertype) : opertype);\n-\t  if (tree eltsize = TYPE_SIZE_UNIT (elttype))\n-\t    {\n-\t      bytes_avail -= adjust * wi::to_offset (eltsize);\n-\t      if (bytes_avail < 0)\n-\t\tbytes_avail = 0;\n-\t    }\n-\t}\n+  if (bytes_avail >= bytes_need)\n+    return;\n \n-      /* The minimum amount of space needed for the allocation.  This\n-\t is an optimistic estimate that makes it possible to detect\n-\t placement new invocation for some undersize buffers but not\n-\t others.  */\n-      offset_int bytes_need;\n+  /* True when the size to mention in the warning is exact as opposed\n+     to \"at least N\".  */\n+  const bool exact_size = (ref.offrng[0] == ref.offrng[1]\n+\t\t\t   || ref.sizrng[1] - ref.offrng[0] == 0);\n \n-      if (nelts)\n-\tnelts = fold_for_warn (nelts);\n-\n-      if (CONSTANT_CLASS_P (size))\n-\tbytes_need = wi::to_offset (size);\n-      else if (nelts && CONSTANT_CLASS_P (nelts))\n-\tbytes_need = (wi::to_offset (nelts)\n-\t\t      * wi::to_offset (TYPE_SIZE_UNIT (type)));\n-      else if (tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n-\tbytes_need = wi::to_offset (TYPE_SIZE_UNIT (type));\n-      else\n-\t{\n-\t  /* The type is a VLA.  */\n-\t  return;\n-\t}\n+  tree opertype = ref.ref ? TREE_TYPE (ref.ref) : TREE_TYPE (oper);\n+  bool warned = false;\n+  if (nelts)\n+    nelts = fold_for_warn (nelts);\n+  if (nelts)\n+    if (CONSTANT_CLASS_P (nelts))\n+      warned = warning_at (loc, OPT_Wplacement_new_,\n+\t\t\t   (exact_size\n+\t\t\t    ? G_(\"placement new constructing an object \"\n+\t\t\t\t \"of type %<%T [%wu]%> and size %qwu \"\n+\t\t\t\t \"in a region of type %qT and size %qwi\")\n+\t\t\t    : G_(\"placement new constructing an object \"\n+\t\t\t\t \"of type %<%T [%wu]%> and size %qwu \"\n+\t\t\t\t \"in a region of type %qT and size \"\n+\t\t\t\t \"at most %qwu\")),\n+\t\t\t   type, tree_to_uhwi (nelts),\n+\t\t\t   bytes_need.to_uhwi (),\n+\t\t\t   opertype, bytes_avail.to_uhwi ());\n+    else\n+      warned = warning_at (loc, OPT_Wplacement_new_,\n+\t\t\t   (exact_size\n+\t\t\t    ? G_(\"placement new constructing an array \"\n+\t\t\t\t \"of objects of type %qT and size %qwu \"\n+\t\t\t\t \"in a region of type %qT and size %qwi\")\n+\t\t\t    : G_(\"placement new constructing an array \"\n+\t\t\t\t \"of objects of type %qT and size %qwu \"\n+\t\t\t\t \"in a region of type %qT and size \"\n+\t\t\t\t \"at most %qwu\")),\n+\t\t\t   type, bytes_need.to_uhwi (), opertype,\n+\t\t\t   bytes_avail.to_uhwi ());\n+  else\n+    warned = warning_at (loc, OPT_Wplacement_new_,\n+\t\t\t (exact_size\n+\t\t\t  ? G_(\"placement new constructing an object \"\n+\t\t\t       \"of type %qT and size %qwu in a region \"\n+\t\t\t       \"of type %qT and size %qwi\")\n+\t\t\t  : G_(\"placement new constructing an object \"\n+\t\t\t       \"of type %qT \"\n+\t\t\t       \"and size %qwu in a region of type %qT \"\n+\t\t\t       \"and size at most %qwu\")),\n+\t\t\t       type, bytes_need.to_uhwi (), opertype,\n+\t\t\t bytes_avail.to_uhwi ());\n+\n+  if (!warned || !ref.ref)\n+    return;\n \n-      if (bytes_avail < bytes_need)\n-\t{\n-\t  if (nelts)\n-\t    if (CONSTANT_CLASS_P (nelts))\n-\t      warning_at (loc, OPT_Wplacement_new_,\n-\t\t\t  exact_size ?\n-\t\t\t  \"placement new constructing an object of type \"\n-\t\t\t  \"%<%T [%wu]%> and size %qwu in a region of type %qT \"\n-\t\t\t  \"and size %qwi\"\n-\t\t\t  : \"placement new constructing an object of type \"\n-\t\t\t  \"%<%T [%wu]%> and size %qwu in a region of type %qT \"\n-\t\t\t  \"and size at most %qwu\",\n-\t\t\t  type, tree_to_uhwi (nelts), bytes_need.to_uhwi (),\n-\t\t\t  opertype, bytes_avail.to_uhwi ());\n-\t    else\n-\t      warning_at (loc, OPT_Wplacement_new_,\n-\t\t\t  exact_size ?\n-\t\t\t  \"placement new constructing an array of objects \"\n-\t\t\t  \"of type %qT and size %qwu in a region of type %qT \"\n-\t\t\t  \"and size %qwi\"\n-\t\t\t  : \"placement new constructing an array of objects \"\n-\t\t\t  \"of type %qT and size %qwu in a region of type %qT \"\n-\t\t\t  \"and size at most %qwu\",\n-\t\t\t  type, bytes_need.to_uhwi (), opertype,\n-\t\t\t  bytes_avail.to_uhwi ());\n-\t  else\n-\t    warning_at (loc, OPT_Wplacement_new_,\n-\t\t\texact_size ?\n-\t\t\t\"placement new constructing an object of type %qT \"\n-\t\t\t\"and size %qwu in a region of type %qT and size %qwi\"\n-\t\t\t: \"placement new constructing an object of type %qT \"\n-\t\t\t\"and size %qwu in a region of type %qT and size \"\n-\t\t\t\"at most %qwu\",\n-\t\t\ttype, bytes_need.to_uhwi (), opertype,\n-\t\t\tbytes_avail.to_uhwi ());\n-\t}\n-    }\n+  if (ref.offrng[0] == 0 || !ref.offset_bounded ())\n+    /* Avoid mentioning the offset when its lower bound is zero\n+       or when it's impossibly large.  */\n+    inform (DECL_SOURCE_LOCATION (ref.ref),\n+\t    \"%qD declared here\", ref.ref);\n+  else if (ref.offrng[0] == ref.offrng[1])\n+    inform (DECL_SOURCE_LOCATION (ref.ref),\n+\t    \"at offset %wi from %qD declared here\",\n+\t    ref.offrng[0].to_shwi (), ref.ref);\n+  else\n+    inform (DECL_SOURCE_LOCATION (ref.ref),\n+\t    \"at offset [%wi, %wi] from %qD declared here\",\n+\t    ref.offrng[0].to_shwi (), ref.offrng[1].to_shwi (), ref.ref);\n }\n \n /* True if alignof(T) > __STDCPP_DEFAULT_NEW_ALIGNMENT__.  */"}, {"sha": "456a7cbec3c7a72fb2994625a9e6d65ef82f2671", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -188,7 +188,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n   tree decl = NULL_TREE;\n \n   /* Set for accesses to interior zero-length arrays.  */\n-  bool interior_zero_len = false;\n+  special_array_member sam{ };\n \n   tree up_bound_p1;\n \n@@ -220,7 +220,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t    {\n \t      /* Try to determine the size of the trailing array from\n \t\t its initializer (if it has one).  */\n-\t      if (tree refsize = component_ref_size (arg, &interior_zero_len))\n+\t      if (tree refsize = component_ref_size (arg, &sam))\n \t\tif (TREE_CODE (refsize) == INTEGER_CST)\n \t\t  maxbound = refsize;\n \t    }\n@@ -325,7 +325,7 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n \t\t\t \"array subscript %E is below array bounds of %qT\",\n \t\t\t low_sub, artype);\n \n-  if (!warned && interior_zero_len)\n+  if (!warned && sam == special_array_member::int_0)\n     warned = warning_at (location, OPT_Wzero_length_bounds,\n \t\t\t (TREE_CODE (low_sub) == INTEGER_CST\n \t\t\t  ? G_(\"array subscript %E is outside the bounds \""}, {"sha": "cc650d65dbe6816f582d55ed16356b80e8085557", "filename": "gcc/testsuite/g++.dg/init/strlen.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstrlen.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstrlen.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstrlen.C?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -29,7 +29,7 @@ test_dynamic_type (S *p)\n   // distinguish invalid cases from ones like it that might be valid.\n   // If/when GIMPLE changes to make this possible this test can be\n   // removed.\n-  char *q = new (p->a) char [16];\n+  char *q = new (p->a) char [16];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n \n   init (q);\n "}, {"sha": "cec83163dbe782375e601c8d3055d51d883d6bc3", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-1.C", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -66,8 +66,9 @@ struct BA2 { int i; A2 a2; };\n void fBx (BAx *pbx, BAx &rbx)\n {\n   BAx bax;\n-  new (bax.ax.a) char;     // { dg-warning \"placement\" }\n-  new (bax.ax.a) Int16;    // { dg-warning \"placement\" }\n+  // The uninitialized flexible array takes up the bytes of padding.\n+  new (bax.ax.a) char;\n+  new (bax.ax.a) Int16;\n   new (bax.ax.a) Int32;    // { dg-warning \"placement\" }\n \n   new (pbx->ax.a) char;\n@@ -84,9 +85,12 @@ void fBx1 ()\n {\n   static BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n \n-  new (bax1.ax.a) char;\t    // { dg-warning \"placement\" }\n-  new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }\n-  new (bax1.ax.a) Int16;    // { dg-warning \"placement\" }\n+  // The empty flexible array takes up the bytes of padding.\n+  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char[2];\n+  new (bax1.ax.a) Int16;\n+  new (bax1.ax.a) char[3];\n+  new (bax1.ax.a) char[4];  // { dg-warning \"placement\" }\n   new (bax1.ax.a) Int32;    // { dg-warning \"placement\" }\n }\n "}, {"sha": "e5fdfe1f603ee3b255e9185741396e82174d166c", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-2.C", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -124,9 +124,13 @@ struct BA2 { int i; A2 a2; };\n void fBx (BAx *pbx, BAx &rbx)\n {\n   BAx bax;\n-  new (bax.ax.a) char;        // { dg-warning \"placement\" }\n-  new (bax.ax.a) Int16;       // { dg-warning \"placement\" }\n+  // The uninitialized flexible array takes up the bytes of padding.\n+  new (bax.ax.a) char;\n+  new (bax.ax.a) Int16;\n+  new (bax.ax.a) char[3];\n   new (bax.ax.a) Int32;       // { dg-warning \"placement\" }\n+  new (bax.ax.a) char[4];     // { dg-warning \"placement\" }\n+  new (bax.ax.a) char[5];     // { dg-warning \"placement\" }\n \n   new (pbx->ax.a) char;\n   new (rbx.ax.a) char;\n@@ -142,10 +146,14 @@ void fBx1 ()\n {\n   static BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n \n-  new (bax1.ax.a) char;\t      // { dg-warning \"placement\" }\n-  new (bax1.ax.a) char[2];    // { dg-warning \"placement\" }\n-  new (bax1.ax.a) Int16;      // { dg-warning \"placement\" }\n+  // The empty flexible array takes up the bytes of padding.\n+  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char[2];\n+  new (bax1.ax.a) Int16;\n+  new (bax1.ax.a) char[3];\n   new (bax1.ax.a) Int32;      // { dg-warning \"placement\" }\n+  new (bax1.ax.a) char[4];    // { dg-warning \"placement\" }\n+  new (bax1.ax.a) char[5];    // { dg-warning \"placement\" }\n }\n \n void fB0 (BA0 *pb0, BA0 &rb0)"}, {"sha": "5eb63d23b477ff49c003be0d041f838ff4f30acc", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-6.C", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -17,20 +17,22 @@ void fBx1 ()\n {\n   static BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } }; // { dg-error \"initialization of flexible array member in a nested context\" }\n \n-  new (bax1.ax.a) char;     // { dg-warning \"placement\" }\n-  new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }\n-  new (bax1.ax.a) Int16;    // { dg-warning \"placement\" }\n+  // The first three bytes of the flexible array member live in the padding.\n+  new (bax1.ax.a) char;\n+  new (bax1.ax.a) char[2];\n+  new (bax1.ax.a) Int16;\n   new (bax1.ax.a) Int32;    // { dg-warning \"placement\" }\n }\n \n void fBx2 ()\n {\n   static BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } }; // { dg-error \"initialization of flexible array member in a nested context\" }\n \n-  new (bax2.ax.a) char;       // { dg-warning \"placement\" }\n-  new (bax2.ax.a) char[2];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int16;      // { dg-warning \"placement\" }\n+  // The first three bytes of the flexible array member live in the padding.\n+  new (bax2.ax.a) char;\n+  new (bax2.ax.a) char[2];\n+  new (bax2.ax.a) char[3];\n+  new (bax2.ax.a) Int16;\n   new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n   new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n }\n@@ -39,10 +41,11 @@ void fBx3 ()\n {\n   static BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } }; // { dg-error \"initialization of flexible array member in a nested context\" }\n \n-  new (bax2.ax.a) char;       // { dg-warning \"placement\" }\n-  new (bax2.ax.a) char[2];    // { dg-warning \"placement\" }\n-  new (bax2.ax.a) Int16;      // { dg-warning \"placement\" }\n-  new (bax2.ax.a) char[3];    // { dg-warning \"placement\" }\n+  // The first three bytes of the flexible array member live in the padding.\n+  new (bax2.ax.a) char;\n+  new (bax2.ax.a) char[2];\n+  new (bax2.ax.a) Int16;\n+  new (bax2.ax.a) char[3];\n   new (bax2.ax.a) char[4];    // { dg-warning \"placement\" }\n   new (bax2.ax.a) Int32;      // { dg-warning \"placement\" }\n }"}, {"sha": "82f298d80088c6558e9381e0a0c13592cb6833c2", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-7.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-7.C?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -0,0 +1,82 @@\n+/* PR c++/96511 - Incorrect -Wplacement-new on POINTER_PLUS into an array\n+   with 4-byte elements\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+void* operator new (size_t, void *p) { return p; }\n+\n+void test_a1_int16 ()\n+{\n+  int16_t a3[3];                    // { dg-message \"declared here\" }\n+\n+  new (a3) int16_t;\n+  new (a3 + 1) int16_t;\n+  new (a3 + 2) int16_t;             // { dg-bogus \"\\\\\\[-Wplacement-new\" }\n+  new (&a3[1]) int16_t;\n+  new (&a3[0] + 1) int16_t;\n+  new (&a3[0] + 2) int16_t;         // { dg-bogus \"\\\\\\[-Wplacement-new\" }\n+  new (&a3[0] + 3) int16_t;         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}\n+\n+void test_a1_int32 ()\n+{\n+  int16_t a3[3];\n+\n+  new (a3 + 1) int32_t;             // { dg-bogus \"\\\\\\[-Wplacement-new\" }\n+  new (&a3[1]) int32_t;\n+  new (&a3[0] + 1) int32_t;         // { dg-bogus \"\\\\\\[-Wplacement-new\" }\n+  new (&a3[0] + 2) int32_t;         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}\n+\n+\n+void test_a2 ()\n+{\n+  int16_t a23[2][3];\n+\n+  new (a23 + 1) int16_t;            // { dg-bogus \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[1]) int16_t;\n+  new (&a23[2]) int16_t;            // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&a23[0][0] + 1) int16_t;\n+  new (&a23[0][0] + 2) int16_t;\n+  // Deriving a pointer to the next array from one to an element of\n+  // the prior array isn't valid even if the resulting pointer points\n+  // to an element of the larger array.  Verify it's diagnosed.\n+  new (&a23[0][0] + 3) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][0] + 4) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][0] + 5) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][0] + 6) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&a23[0][1] + 1) int16_t;\n+  new (&a23[0][1] + 2) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][1] + 3) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][1] + 4) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][1] + 5) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][1] + 6) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&a23[0][2] + 1) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][2] + 2) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][2] + 3) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][2] + 4) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][2] + 5) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[0][2] + 6) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&a23[1][0]) int16_t;\n+  new (&a23[1][0] + 1) int16_t;\n+  new (&a23[1][0] + 2) int16_t;\n+  new (&a23[1][0] + 3) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[1][0] + 4) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&a23[1][1]) int16_t;\n+  new (&a23[1][2]) int16_t;\n+  new (&a23[1][2] + 1) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[1][3]) int16_t;         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[1][3] + 1) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&a23[2][0]) int16_t;         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&a23[2][0] + 1) int16_t;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}"}, {"sha": "849457e559ffe0bee850c245539f4a162bad9348", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-58.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -Wno-stringop-overread\" } */\n \n typedef __SIZE_TYPE__ size_t;\n \n@@ -15,7 +15,7 @@ void fa0_extern (void)\n {\n   sink (strlen (ea0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ea0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (ea0.a));        // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ea0.a));        // valid just-past-the-end offset\n   sink (strlen (ea0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n }\n \n@@ -25,7 +25,7 @@ void fa0_static (void)\n {\n   sink (strlen (sa0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (sa0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n-  sink (strlen (sa0.a));        // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (sa0.a));        // valid just-past-the-end offset\n   sink (strlen (sa0.a + 1));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n }\n \n@@ -52,22 +52,22 @@ void fax_static (void)\n   sink (strlen (ax0.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax0.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax0.a));\n-  sink (strlen (ax0.a + 1));    // { dg-warning \"\\\\\\[-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax0.a + 1));    // valid just-past-the-end offset\n   sink (strlen (ax0.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n \n   sink (strlen (ax1.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax1.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax1.a));\n   sink (strlen (ax1.a + 1));\n-  sink (strlen (ax1.a + 2));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax1.a + 2));    // valid just-past-the-end offset\n   sink (strlen (ax1.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n \n   sink (strlen (ax2.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   sink (strlen (ax2.a - 1));    // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax2.a));\n   sink (strlen (ax2.a + 1));\n   sink (strlen (ax2.a + 2));\n-  sink (strlen (ax2.a + 3));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax2.a + 3));    // valid just-past-the-end offset\n   sink (strlen (ax2.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n \n   sink (strlen (ax3.a - 2));    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n@@ -76,6 +76,6 @@ void fax_static (void)\n   sink (strlen (ax3.a + 1));\n   sink (strlen (ax3.a + 2));\n   sink (strlen (ax3.a + 3));\n-  sink (strlen (ax3.a + 4));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" \"pr93514\" }\n+  sink (strlen (ax3.a + 4));    // valid just-past-the-end offset\n   sink (strlen (ax3.a + 5));    // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" }\n }"}, {"sha": "46f8fed79f3bff5a260c743f1cbaa3d98319204d", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-37.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -184,6 +184,18 @@ void test_note (const char *s)\n     sink (a);\n   }\n \n+  {\n+    char a[1][1][2];                    // { dg-message \"at offset 2 into \" }\n+    strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 0 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[1][2][2];                    // { dg-message \"destination object\" }\n+    strncpy (a[0][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+    sink (a);\n+  }\n+\n   {\n     char a[1][2][2];                    // { dg-message \"at offset 2 into \" }\n     strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n@@ -192,7 +204,13 @@ void test_note (const char *s)\n \n   {\n     char a[1][2][2];                    // { dg-message \"at offset 4 into \" }\n-    strncpy (a[1][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+    strncpy (a[1][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 0 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[2][1][2];                    // { dg-message \"at offset 2 into \" }\n+    strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 0 \" }\n     sink (a);\n   }\n "}, {"sha": "555ba97e68bc7fbc3bfd87066e49254a4d0988ff", "filename": "gcc/tree.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -13640,20 +13640,21 @@ get_initializer_for (tree init, tree decl)\n /* Determines the size of the member referenced by the COMPONENT_REF\n    REF, using its initializer expression if necessary in order to\n    determine the size of an initialized flexible array member.\n-   If non-null, *INTERIOR_ZERO_LENGTH is set when REF refers to\n-   an interior zero-length array.\n+   If non-null, set *ARK when REF refers to an interior zero-length\n+   array or a trailing one-element array.\n    Returns the size as sizetype (which might be zero for an object\n    with an uninitialized flexible array member) or null if the size\n    cannot be determined.  */\n \n tree\n-component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n+component_ref_size (tree ref, special_array_member *sam /* = NULL */)\n {\n   gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n \n-  bool int_0_len = false;\n-  if (!interior_zero_length)\n-    interior_zero_length = &int_0_len;\n+  special_array_member arkbuf;\n+  if (!sam)\n+    sam = &arkbuf;\n+  *sam = special_array_member::none;\n \n   /* The object/argument referenced by the COMPONENT_REF and its type.  */\n   tree arg = TREE_OPERAND (ref, 0);\n@@ -13675,9 +13676,16 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t   more than one element.  */\n \treturn memsize;\n \n-      *interior_zero_length = zero_length && !trailing;\n-      if (*interior_zero_length)\n-\tmemsize = NULL_TREE;\n+      if (zero_length)\n+\t{\n+\t  if (trailing)\n+\t    *sam = special_array_member::trail_0;\n+\t  else\n+\t    {\n+\t      *sam = special_array_member::int_0;\n+\t      memsize = NULL_TREE;\n+\t    }\n+\t}\n \n       if (!zero_length)\n \tif (tree dom = TYPE_DOMAIN (memtype))\n@@ -13688,9 +13696,13 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t\t{\n \t\t  offset_int minidx = wi::to_offset (min);\n \t\t  offset_int maxidx = wi::to_offset (max);\n-\t\t  if (maxidx - minidx > 0)\n+\t\t  offset_int neltsm1 = maxidx - minidx;\n+\t\t  if (neltsm1 > 0)\n \t\t    /* MEMBER is an array with more than one element.  */\n \t\t    return memsize;\n+\n+\t\t  if (neltsm1 == 0)\n+\t\t    *sam = special_array_member::trail_1;\n \t\t}\n \n       /* For a refernce to a zero- or one-element array member of a union\n@@ -13708,7 +13720,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n   tree base = get_addr_base_and_unit_offset (ref, &baseoff);\n   if (!base || !VAR_P (base))\n     {\n-      if (!*interior_zero_length)\n+      if (*sam != special_array_member::int_0)\n \treturn NULL_TREE;\n \n       if (TREE_CODE (arg) != COMPONENT_REF)\n@@ -13728,7 +13740,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n   /* Determine the base type of the referenced object.  If it's\n      the same as ARGTYPE and MEMBER has a known size, return it.  */\n   tree bt = basetype;\n-  if (!*interior_zero_length)\n+  if (*sam != special_array_member::int_0)\n     while (TREE_CODE (bt) == ARRAY_TYPE)\n       bt = TREE_TYPE (bt);\n   bool typematch = useless_type_conversion_p (argtype, bt);\n@@ -13768,7 +13780,7 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t  if (DECL_P (base)\n \t      && DECL_EXTERNAL (base)\n \t      && bt == basetype\n-\t      && !*interior_zero_length)\n+\t      && *sam != special_array_member::int_0)\n \t    /* The size of a flexible array member of an extern struct\n \t       with no initializer cannot be determined (it's defined\n \t       in another translation unit and can have an initializer"}, {"sha": "f43ac9f19428c54b6b20c6226090257374429905", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de05c19d5fd661ae16dd75a895b49d32d12f5edc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=de05c19d5fd661ae16dd75a895b49d32d12f5edc", "patch": "@@ -5292,12 +5292,22 @@ extern bool array_at_struct_end_p (tree);\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n extern tree component_ref_field_offset (tree);\n \n+/* Describes a \"special\" array member due to which component_ref_size\n+   returns null.  */\n+enum struct special_array_member\n+  {\n+   none,      /* Not a special array member.  */\n+   int_0,     /* Interior array member with size zero.  */\n+   trail_0,   /* Trailing array member with size zero.  */\n+   trail_1    /* Trailing array member with one element.  */\n+  };\n+\n /* Return the size of the member referenced by the COMPONENT_REF, using\n    its initializer expression if necessary in order to determine the size\n    of an initialized flexible array member.  The size might be zero for\n    an object with an uninitialized flexible array member or null if it\n    cannot be determined.  */\n-extern tree component_ref_size (tree, bool * = NULL);\n+extern tree component_ref_size (tree, special_array_member * = NULL);\n \n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);"}]}