{"sha": "0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwNjMwMGY2YzNmN2JhZTVlYjFjNDZkYmQ0NWFhMDdjOTRlMWIxNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-31T08:27:00Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-31T08:27:00Z"}, "message": "varasm: Optimize memory broadcast for constant vector under AVX512 [PR54201]\n\nI meant something like the following, which on e.g. a dumb:\n\ntypedef float V __attribute__((vector_size (4 * sizeof (float))));\n\nvoid\nfoo (V *p, float *q)\n{\n  p[0] += (V) { 1.0f, 2.0f, 3.0f, 4.0f };\n  q[0] += 4.0f;\n  q[1] -= 3.0f;\n  q[17] -= 2.0f;\n  q[31] += 1.0f;\n}\n\ntestcase merges all the 4 scalar constant pool entries into the CONST_VECTOR\none.\n\nI'm punting for section anchors and not doing it in the per-function (i.e.\nnon-shared) constant pools simply because I don't know them well enough,\ndon't know whether backends use the offsets for something etc.\nFor section anchors, I guess it would need to be done before (re)computing the\noffsets and arrange for the desc->mark < 0 entries not to be considered as\nobjects in the object block, for non-shared pools, perhaps it would be\nenough to call the new function from output_constant_pool before calling\nrecompute_pool_offsets and adjust recompute_pool_offsets to ignore\ndesc->mark < 0.\n\nHere is an adjusted patch that ought to merge even the same sized different\nmode vectors with the same byte representation, etc.\nIt won't really help with avoiding the multiple reads of the constant in the\nsame function, but as you found, your patch doesn't help with that either.\nYour patch isn't really incompatible with what the patch below does, though\nI wonder whether a) it wouldn't be better to always canonicalize to an\nintegral mode with as few elts as possible even e.g. for floats b) whether\nasserting that it simplify_rtx succeeds is safe, whether it shouldn't just\ncanonicalize if the canonicalization works and just do what it previously\ndid otherwise.\n\nThe following patch puts all pool entries which can be natively encoded\ninto a vector, sorts it by decreasing size, determines minimum size\nof a pool entry and adds hash elts for each (aligned) min_size or wider\npower of two-ish portion of the pool constant in addition to the whole pool\nconstant byte representation.\n\nThis is the version that passed bootstrap/regtest on both x86_64-linux and\ni686-linux.  In both bootstraps/regtests together, it saved (from the\nstatistics I've gathered) 63104 .rodata bytes (before constant merging),\nin 6814 hits of the data->desc->mark = ~(*slot)->desc->labelno;.\n\n2020-08-31  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/54201\n\t* varasm.c: Include alloc-pool.h.\n\t(output_constant_pool_contents): Emit desc->mark < 0 entries as\n\taliases.\n\t(struct constant_descriptor_rtx_data): New type.\n\t(constant_descriptor_rtx_data_cmp): New function.\n\t(struct const_rtx_data_hasher): New type.\n\t(const_rtx_data_hasher::hash, const_rtx_data_hasher::equal): New\n\tmethods.\n\t(optimize_constant_pool): New function.\n\t(output_shared_constant_pool): Call it if TARGET_SUPPORTS_ALIASES.", "tree": {"sha": "a657c23a96f86f3d7ff49a255a4300ff3c6ed8be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a657c23a96f86f3d7ff49a255a4300ff3c6ed8be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0939f42dd84ca03212caf0b6937cf201a16a44f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0939f42dd84ca03212caf0b6937cf201a16a44f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0939f42dd84ca03212caf0b6937cf201a16a44f"}], "stats": {"total": 181, "additions": 180, "deletions": 1}, "files": [{"sha": "ea0b59cf44af725e16dd0a430bcbba442008c320", "filename": "gcc/varasm.c", "status": "modified", "additions": 180, "deletions": 1, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0106300f6c3f7bae5eb1c46dbd45aa07c94e1b15", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"rtl-iter.h\"\n #include \"file-prefix-map.h\" /* remap_debug_filename()  */\n+#include \"alloc-pool.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data declarations.  */\n@@ -4198,7 +4199,27 @@ output_constant_pool_contents (struct rtx_constant_pool *pool)\n   class constant_descriptor_rtx *desc;\n \n   for (desc = pool->first; desc ; desc = desc->next)\n-    if (desc->mark)\n+    if (desc->mark < 0)\n+      {\n+#ifdef ASM_OUTPUT_DEF\n+\tconst char *name = targetm.strip_name_encoding (XSTR (desc->sym, 0));\n+\tchar label[256];\n+\tchar buffer[256 + 32];\n+\tconst char *p;\n+\n+\tASM_GENERATE_INTERNAL_LABEL (label, \"LC\", ~desc->mark);\n+\tp = targetm.strip_name_encoding (label);\n+\tif (desc->offset)\n+\t  {\n+\t    sprintf (buffer, \"%s+%ld\", p, (long) (desc->offset));\n+\t    p = buffer;\n+\t  }\n+\tASM_OUTPUT_DEF (asm_out_file, name, p);\n+#else\n+\tgcc_unreachable ();\n+#endif\n+      }\n+    else if (desc->mark)\n       {\n \t/* If the constant is part of an object_block, make sure that\n \t   the constant has been positioned within its block, but do not\n@@ -4216,6 +4237,160 @@ output_constant_pool_contents (struct rtx_constant_pool *pool)\n       }\n }\n \n+struct constant_descriptor_rtx_data {\n+  constant_descriptor_rtx *desc;\n+  target_unit *bytes;\n+  unsigned short size;\n+  unsigned short offset;\n+  unsigned int hash;\n+};\n+\n+/* qsort callback to sort constant_descriptor_rtx_data * vector by\n+   decreasing size.  */\n+\n+static int\n+constant_descriptor_rtx_data_cmp (const void *p1, const void *p2)\n+{\n+  constant_descriptor_rtx_data *const data1\n+    = *(constant_descriptor_rtx_data * const *) p1;\n+  constant_descriptor_rtx_data *const data2\n+    = *(constant_descriptor_rtx_data * const *) p2;\n+  if (data1->size > data2->size)\n+    return -1;\n+  if (data1->size < data2->size)\n+    return 1;\n+  if (data1->hash < data2->hash)\n+    return -1;\n+  gcc_assert (data1->hash > data2->hash);\n+  return 1;\n+}\n+\n+struct const_rtx_data_hasher : nofree_ptr_hash<constant_descriptor_rtx_data>\n+{\n+  static hashval_t hash (constant_descriptor_rtx_data *);\n+  static bool equal (constant_descriptor_rtx_data *,\n+\t\t     constant_descriptor_rtx_data *);\n+};\n+\n+/* Hash and compare functions for const_rtx_data_htab.  */\n+\n+hashval_t\n+const_rtx_data_hasher::hash (constant_descriptor_rtx_data *data)\n+{\n+  return data->hash;\n+}\n+\n+bool\n+const_rtx_data_hasher::equal (constant_descriptor_rtx_data *x,\n+\t\t\t      constant_descriptor_rtx_data *y)\n+{\n+  if (x->hash != y->hash || x->size != y->size)\n+    return 0;\n+  unsigned int align1 = x->desc->align;\n+  unsigned int align2 = y->desc->align;\n+  unsigned int offset1 = (x->offset * BITS_PER_UNIT) & (align1 - 1);\n+  unsigned int offset2 = (y->offset * BITS_PER_UNIT) & (align2 - 1);\n+  if (offset1)\n+    align1 = least_bit_hwi (offset1);\n+  if (offset2)\n+    align2 = least_bit_hwi (offset2);\n+  if (align2 > align1)\n+    return 0;\n+  if (memcmp (x->bytes, y->bytes, x->size * sizeof (target_unit)) != 0)\n+    return 0;\n+  return 1;\n+}\n+\n+/* Attempt to optimize constant pool POOL.  If it contains both CONST_VECTOR\n+   constants and scalar constants with the values of CONST_VECTOR elements,\n+   try to alias the scalar constants with the CONST_VECTOR elements.  */\n+\n+static void\n+optimize_constant_pool (struct rtx_constant_pool *pool)\n+{\n+  auto_vec<target_unit, 128> buffer;\n+  auto_vec<constant_descriptor_rtx_data *, 128> vec;\n+  object_allocator<constant_descriptor_rtx_data>\n+    data_pool (\"constant_descriptor_rtx_data_pool\");\n+  int idx = 0;\n+  size_t size = 0;\n+  for (constant_descriptor_rtx *desc = pool->first; desc; desc = desc->next)\n+    if (desc->mark > 0\n+\t&& ! (SYMBOL_REF_HAS_BLOCK_INFO_P (desc->sym)\n+\t      && SYMBOL_REF_BLOCK (desc->sym)))\n+      {\n+\tbuffer.truncate (0);\n+\tbuffer.reserve (GET_MODE_SIZE (desc->mode));\n+\tif (native_encode_rtx (desc->mode, desc->constant, buffer, 0,\n+\t\t\t       GET_MODE_SIZE (desc->mode)))\n+\t  {\n+\t    constant_descriptor_rtx_data *data = data_pool.allocate ();\n+\t    data->desc = desc;\n+\t    data->bytes = NULL;\n+\t    data->size = GET_MODE_SIZE (desc->mode);\n+\t    data->offset = 0;\n+\t    data->hash = idx++;\n+\t    size += data->size;\n+\t    vec.safe_push (data);\n+\t  }\n+      }\n+  if (idx)\n+    {\n+      vec.qsort (constant_descriptor_rtx_data_cmp);\n+      unsigned min_size = vec.last ()->size;\n+      target_unit *bytes = XNEWVEC (target_unit, size);\n+      unsigned int i;\n+      constant_descriptor_rtx_data *data;\n+      hash_table<const_rtx_data_hasher> * htab\n+\t= new hash_table<const_rtx_data_hasher> (31);\n+      size = 0;\n+      FOR_EACH_VEC_ELT (vec, i, data)\n+\t{\n+\t  buffer.truncate (0);\n+\t  native_encode_rtx (data->desc->mode, data->desc->constant,\n+\t\t\t     buffer, 0, data->size);\n+\t  memcpy (bytes + size, buffer.address (), data->size);\n+\t  data->bytes = bytes + size;\n+\t  data->hash = iterative_hash (data->bytes,\n+\t\t\t\t       data->size * sizeof (target_unit), 0);\n+\t  size += data->size;\n+\t  constant_descriptor_rtx_data **slot\n+\t    = htab->find_slot_with_hash (data, data->hash, INSERT);\n+\t  if (*slot)\n+\t    {\n+\t      data->desc->mark = ~(*slot)->desc->labelno;\n+\t      data->desc->offset = (*slot)->offset;\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned int sz = 1 << floor_log2 (data->size);\n+\n+\t      *slot = data;\n+\t      for (sz >>= 1; sz >= min_size; sz >>= 1)\n+\t\tfor (unsigned off = 0; off + sz <= data->size; off += sz)\n+\t\t  {\n+\t\t    constant_descriptor_rtx_data tmp;\n+\t\t    tmp.desc = data->desc;\n+\t\t    tmp.bytes = data->bytes + off;\n+\t\t    tmp.size = sz;\n+\t\t    tmp.offset = off;\n+\t\t    tmp.hash = iterative_hash (tmp.bytes,\n+\t\t\t\t\t       sz * sizeof (target_unit), 0);\n+\t\t    slot = htab->find_slot_with_hash (&tmp, tmp.hash, INSERT);\n+\t\t    if (*slot == NULL)\n+\t\t      {\n+\t\t\t*slot = data_pool.allocate ();\n+\t\t\t**slot = tmp;\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t}\n+      delete htab;\n+      XDELETE (bytes);\n+    }\n+  data_pool.release ();\n+}\n+\n /* Mark all constants that are used in the current function, then write\n    out the function's private constant pool.  */\n \n@@ -4251,6 +4426,10 @@ output_constant_pool (const char *fnname ATTRIBUTE_UNUSED,\n void\n output_shared_constant_pool (void)\n {\n+  if (optimize\n+      && TARGET_SUPPORTS_ALIASES)\n+    optimize_constant_pool (shared_constant_pool);\n+\n   output_constant_pool_contents (shared_constant_pool);\n }\n \f"}]}