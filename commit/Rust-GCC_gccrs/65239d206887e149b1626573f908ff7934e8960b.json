{"sha": "65239d206887e149b1626573f908ff7934e8960b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyMzlkMjA2ODg3ZTE0OWIxNjI2NTczZjkwOGZmNzkzNGU4OTYwYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-21T11:19:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-21T11:19:40Z"}, "message": "mips-protos.h (mips_regno_mode_ok_for_base_p): Give the STRICT_P argument type \"bool\" rather than \"int\".\n\ngcc/\n\t* config/mips/mips-protos.h (mips_regno_mode_ok_for_base_p): Give\n\tthe STRICT_P argument type \"bool\" rather than \"int\".\n\t(mips_legitimate_address_p): Likewise.\n\t(fp_register_operand, lo_operand): Delete.\n\t(mips_subword): Give the HIGH_P argument type \"bool\" rather than \"int\".\n\t(mips_emit_scc): Rename to...\n\t(mips_expand_scc): ...this.\n\t(gen_conditional_branch): Rename to...\n\t(mips_expand_conditional_branch): ...this.\n\t(gen_conditional_move): Rename to...\n\t(mips_expand_conditional_move): ...this.\n\t(mips_gen_conditional_trap): Rename to...\n\t(mips_expand_conditional_trap): ...this and take an rtx code instead\n\tof an operands array.\n\t(mips_expand_call): Give the SIBCALL_P argument type \"bool\"\n\trather than \"int\".\n\t(mips_emit_fcc_reload): Rename to...\n\t(mips_expand_fcc_reload): ...this.\n\t(init_cumulative_args): Rename to...\n\t(mips_init_cumulative_args): ...this and remove the libname argument.\n\t(function_arg_advance): Rename to...\n\t(mips_function_arg_advance): ...this.\n\t(function_arg): Rename to...\n\t(mips_function_arg): ...this and use \"rtx\" instead of\n\t\"struct rtx_def *\".\n\t(function_arg_boundary): Rename to...\n\t(mips_function_arg_boundary): ...this.\n\t(mips_expand_unaligned_load): Rename to...\n\t(mips_expand_ext_as_unaligned_load): ...this and give the WIDTH\n\tand BITPOS arguments type \"HOST_WIDE_INT\".\n\t(mips_expand_unaligned_store): Rename to...\n\t(mips_expand_ins_as_unaligned_store): ...this and give the WIDTH\n\tand BITPOS arguments type \"HOST_WIDE_INT\".\n\t(override_options): Rename to...\n\t(mips_override_options): ...this.\n\t(print_operand): Rename to...\n\t(mips_print_operand): ...this.\n\t(print_operand_address): Rename to...\n\t(mips_print_operand_address): ...this.\n\t(mips_output_ascii): Remove the PREFIX argument.\n\t(mips_expand_epilogue): Give the SIBCALL_P argument type \"bool\"\n\trather than \"int\".\n\t(mips_can_use_return_insn): Return a \"bool\" rather than an \"int\".\n\t(mips_function_value): Remove the FUNC argument.  Use \"rtx\" instead\n\tof \"struct rtx_def *\".\n\t(mips_secondary_reload_class): Give the IN_P argument type \"bool\"\n\trather than \"int\".\n\t(build_mips16_call_stub): Delete.\n\t(mips_store_data_bypass_p): Return a \"bool\" rather than an \"int\".\n\t(mips_use_ins_ext_p): Give the second and third arguments type\n\t\"HOST_WIDE_INT\" rather than \"rtx\".\n\t* config/mips/mips.h: Update after the above changes.  Tweak comments\n\tand formatting.\n\t(SECONDARY_INPUT_RELOAD_CLASS): Pass a boolean IN_P argument.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n\t(mips_print_operand_punct, mips_hard_regno_mode_ok): Change the\n\telement type from \"char\" to \"bool\".\n\t(mips_section_threshold, sym_lineno, set_noat, mips_branch_likely)\n\t(mips_cpu_info_table): Delete.\n\t* config/mips/mips.md: Update after the above changes.  Tweak some\n\tformatting.\n\t* config/mips/mips-ps-3d.md: Likewise.\n\t* config/mips/mips.c: Tweak comments and formatting.\n\tUse NULL-like macros rather than 0 in various places.\n\t(mips_section_threshold): Rename to...\n\t(mips_small_data_threshold): ...this and give it an unsigned type.\n\t(num_source_filenames): Remove explicit initialization.\n\t(sdb_label_count): Likewise.\n\t(sym_lineno): Delete.\n\t(set_noat): Make static.\n\t(mips_branch_likely): Likewise, and give it type \"bool\".\n\t(mips_isa_info): Rename to...\n\t(mips_isa_option_info): ...this.\n\t(mips_flag_delayed_branch): Rename to...\n\t(mips_base_delayed_branch): ...this.\n\t(mips_split_addresses): Delete.\n\t(mips_print_operand_punct, mips_hard_regno_mode_ok): Change the\n\telement type from \"char\" to \"bool\".\n\t(mips_regno_to_class): Add an explicit array size.\n\t(mips16_flipper): Change from type \"int\" to type \"bool\".\n\t(mips_comp_type_attributes): Remove redundant FUNCTION_TYPE check.\n\t(mips_tls_operand_p): Rename to...\n\t(mips_tls_symbol_p): ...this.\n\t(mips_global_symbol_p): Remove redundant \"const\".\n\t(mips_offset_within_alignment_p): Simplify.\n\t(mips_regno_mode_ok_for_base_p): Change the name of the last argument\n\tto STRICT_P and give it type bool.\n\t(mips_valid_base_register_p): Likewise.\n\t(mips_classify_address): Likewise.\n\t(mips_legitimate_address_p): Likewise.\n\t(mips16_unextended_reference_p): Take the offset as an\n\t\"unsigned HOST_WIDE_INT\" rather than an \"rtx\".  Simplify.\n\t(mips_const_insns): Use IN_RANGE.\n\t(mips_force_temporary): Remove an unnecessary copy_rtx.\n\t(mips16_gp_pseudo_reg): Simplify.\n\t(mips_split_symbol): Remove an unnecessary copy_rtx.\n\t(mips_legitimize_tls_address): Only create registers if we need them.\n\t(mips_legitimize_address): Use mips_split_plus.\n\t(mips_move_integer): Swap DEST and TEMP arguments.  Rename local\n\tvariable COST to NUM_OPS.\n\t(mips_legitimize_move): Use gen_lowpart.\n\t(mips_rewrite_small_data): Rename the OP parameter to PATTERN.\n\t(m16_check_op): Use IN_RANGE.\n\t(mips_subword): Give the HIGH_P argument type \"bool\" rather than \"int\".\n\t(mips_split_doubleword_move): Pass booleans to mips_subword.\n\t(mips_output_move): Store the mode in a local variable.\n\tExplicitly assert that this function does not deal with\n\tMFLO and MFHI.  Use SMALL_OPERAND_UNSIGNED.  Make order of\n\tcases more consistent.\n\t(mips_relational_operand_ok_p): Rename to...\n\t(mips_int_order_operand_ok_p): ...this.\n\t(mips_canonicalize_comparison): Rename to...\n\t(mips_canonicalize_int_order_test): ...this.\n\t(mips_emit_int_relational): Rename to...\n\t(mips_emit_int_order_test): ...this.  Store the mode in a local\n\tvariable.\n\t(mips_reverse_fp_cond_p): Rename to...\n\t(mips_reversed_fp_cond): ...this.\n\t(mips_emit_compare): Make the order of the statements more consistent.\n\t(mips_emit_scc): Rename to...\n\t(mips_expand_scc): ...this.\n\t(gen_conditional_branch): Rename to...\n\t(mips_expand_conditional_branch): ...this.\n\t(gen_conditional_move): Rename to...\n\t(mips_expand_conditional_move): ...this.  Build the condition\n\tseparately from the main pattern.\n\t(mips_gen_conditional_trap): Rename to...\n\t(mips_expand_conditional_trap): ...this and take an rtx code instead\n\tof an operands array.  Simplify.\n\t(init_cumulative_args): Rename to...\n\t(mips_init_cumulative_args): ...this.  Use memset rather than a\n\tcopy from a zeroed static.  Use prototype_p and stdarg_p.\n\t(mips_arg_info): Rename to...\n\t(mips_get_arg_info): ...this and put the INFO argument first.\n\t(function_arg): Rename to...\n\t(mips_function_arg): ...this and use \"rtx\" instead of\n\t\"struct rtx_def *\".  Only split structures into chunks if \n\tTARGET_HARD_FLOAT, rather than checking !TARGET_SOFT_FLOAT on\n\ta chunk-by-chunk basis.  Use SCALAR_FLOAT_TYPE_P instead of a\n\tcomparison with REAL_TYPE.  Rename local variable REG to REGNO\n\tand make it unsigned.\n\t(function_arg_advance): Rename to...\n\t(mips_function_arg_advance): ...this.\n\t(function_arg_boundary): Rename to...\n\t(mips_function_arg_boundary): ...this.\n\t(mips_pad_arg_upward): Use SCALAR_INT_MODE_P instead of a comparison\n\twith MODE_INT.\n\t(mips_fpr_return_fields): Use SCALAR_FLOAT_TYPE_P instead of a\n\tcomparison with REAL_TYPE.\n\t(mips_function_value): Remove the FUNC argument.  Rename local\n\tvariable UNSIGNEDP to UNSIGNED_P.\n\t(mips_return_in_memory): Use IN_RANGE.\n\t(mips_setup_incoming_varargs): Pass a boolean rather than an int\n\tto FUNCTION_ARG_ADVANCE.\n\t(mips_gimplify_va_arg_expr): Rename local variable INDIRECT\n\tto INDIRECT_P.  Remove a redundant mips_abi check.  Only calculate\n\tSIZE and RSIZE if needed.\n\t(mips16_stub): Rename FPRET to FP_RET_P and give it type \"bool\"\n\trather than \"int\".\n\t(build_mips16_function_stub): Rename to...\n\t(mips16_build_function_stub): ...this.\n\t(build_mips16_call_stub): Rename to...\n\t(mips16_build_call_stub): ...this.  Make static, and return a\n\t\"bool\" rather than an \"int\".  Rename the ARG_SIZE argument to\n\tARGS_SIZE.  Rename the local variable FPRET to FP_RET_P and give\n\tit type \"bool\".  Use \"jr\" rather than \"j\".  Use XNEW.  Simplify.\n\t(mips_load_call_address): Give the SIBCALL_P argument type \"bool\"\n\trather than \"int\".\n\t(mips_expand_call): Likewise.  Assert that MIPS16 calls via stubs\n\tare not sibling ones.\n\t(mips_emit_fcc_reload): Rename to...\n\t(mips_expand_fcc_reload): ...this.\n\t(mips_get_unaligned_mem): Give the WIDTH and BITPOS arguments type\n\t\"HOST_WIDE_INT\".\n\t(mips_expand_unaligned_load): Rename to...\n\t(mips_expand_ext_as_unaligned_load): ...this and give the WIDTH\n\tand BITPOS arguments type \"HOST_WIDE_INT\".  Remove redundant\n\tSUBREG_BYTE check.\n\t(mips_expand_unaligned_store): Rename to...\n\t(mips_expand_ins_as_unaligned_store): ...this and give the WIDTH\n\tand BITPOS arguments type \"HOST_WIDE_INT\".\n\t(mips_use_ins_ext_p): Rename second and third arguments to WIDTH\n\tand BITPOS and give them type \"HOST_WIDE_INT\" rather than \"rtx\".\n\tUse IN_RANGE.\n\t(mips_init_split_addresses): Replace with...\n\t(mips_split_addresses_p): ...this new function.\n\t(mips_init_relocs): Check mips_split_addresses_p () rather than\n\tmips_split_addresses.  Always initialize mips_split_p with booleans.\n\t(print_operand_reloc): Rename to...\n\t(mips_print_operand_reloc): ...this.  Use a gcc_assert rather than\n\ta fatal_error.\n\t(print_operand): Rename to...\n\t(mips_print_operand): ...this.\n\t(print_operand_address): Rename to...\n\t(mips_print_operand_address): ...this.  Use GP_REG_FIRST.\n\t(mips_in_small_data_p): Simplify.\n\t(mips_output_ascii): Remove the PREFIX argument and \"register\"\n\tkeywords.  Use the STRING parameter directly and cast to\n\t\"unsigned char\".\n\t(mips16e_collect_argument_save_p): Use IN_RANGE.\n\t(mips_function_has_gp_insn): Simplify.\n\t(mips_set_return_address): Use BITSET_P.\n\t(mips_restore_gp): Use a separate statement to pick the base\n\tregister.\n\t(mips_output_function_prologue): Use a local FRAME variable.\n\t(mips_save_reg): Pass booleans to mips_subword.\n\t(mips_expand_prologue): Use a local FRAME variable.  Use\n\tcprestore_size to detect when .cprestore is needed.\n\t(mips_restore_reg): Use GP_REG_FIRST.\n\t(mips_expand_epilogue): Give the SIBCALL_P argument type \"bool\"\n\trather than \"int\".  Use local FRAME and REGNO variables.\n\t(mips_can_use_return_insn): Return a \"bool\" rather than an \"int\".\n\t(mips_secondary_reload_class): Give the IN_P argument type \"bool\"\n\trather than \"int\".\n\t(mips_linked_madd_p): Rename arguments to OUT_INSN and IN_INSN.\n\t(mips_store_data_bypass_p): Return a \"bool\" rather than an \"int\".\n\t(vr4130_swap_insns_p): Rename local variables to DEP1_P and DEP2_P.\n\t(mips_74k_agen_init): Assume INSN satisfies USEFUL_INSN_P.\n\t(mips_variable_issue): Do nothing unless INSN satisfies USEFUL_INSN_P.\n\t(builtin_description): Rename to...\n\t(mips_builtin_description): ...this.\n\t(mips_bdesc): Rename to...\n\t(mips_ps_bdesc): ...this.\n\t(sb1_bdesc): Rename to...\n\t(mips_sb1_bdesc): ...this.\n\t(dsp_bdesc): Rename to...\n\t(mips_dsp_bdesc): ...this.\n\t(dsp_32only_bdesc): Rename to...\n\t(mips_dsp_32only_bdesc): ...this.\n\t(bdesc_map): Rename to...\n\t(mips_bdesc_map): ...this.\n\t(bdesc_arrays): Rename to...\n\t(mips_bdesc_arrays): ...this.\n\t(mips_prepare_builtin_arg): Rename OP to OPNO and ARGNUM to ARGNO.\n\tTweak error message.\n\t(mips_expand_builtin_direct): Rename HAS_TARGET to HAS_TARGET_P.\n\tRename local variables I and J to OPNO and ARGNO respectively.\n\tAssert that the number of arguments is no more than the number of\n\tinput operands.\n\t(mips_expand_builtin_compare): Use an array of arguments rather\n\tthan an array of operands.  Assert that the number of operands is\n\tas expected.\n\t(add_constant): Rename to...\n\t(mips16_add_constant): ...this.  Use XNEW.\n\t(dump_constants_1): Rename to...\n\t(mips16_emit_constants_1): ...this.  Use ALL_SCALAR_FIXED_POINT_MODE_P.\n\t(dump_constants): Rename to...\n\t(mips16_emit_constants): ...this.\n\t(mips_sim_wait_reg, mips_sim_record_set): Use END_REGNO.\n\t(mips_set_mips16_mode): Don't call mips_init_split_addresses.\n\tAssign mips16_p to was_mips16_p.\n\t(mips_parse_cpu): Tweak warning message.\n\t(override_options): Rename to...\n\t(mips_override_options): ...this.  Move the mips_cost initialization\n\tout of the \"shared with GAS\" block.  Quote option names in error\n\tmessages.\n\t(mips_conditional_register_usage): Make local variable REGNO unsigned.\n\t(mips_order_regs_for_local_alloc): Remove register keyword.\n\nFrom-SVN: r129532", "tree": {"sha": "309528620942102b8ef62792fa4662af3950e1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/309528620942102b8ef62792fa4662af3950e1a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65239d206887e149b1626573f908ff7934e8960b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65239d206887e149b1626573f908ff7934e8960b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65239d206887e149b1626573f908ff7934e8960b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65239d206887e149b1626573f908ff7934e8960b/comments", "author": null, "committer": null, "parents": [{"sha": "b5edaa2ca150f3204cc1e3448502e02a97ecc105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5edaa2ca150f3204cc1e3448502e02a97ecc105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5edaa2ca150f3204cc1e3448502e02a97ecc105"}], "stats": {"total": 3659, "additions": 1888, "deletions": 1771}, "files": [{"sha": "ea58775e69e946268d761683ed2914617fb9236f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65239d206887e149b1626573f908ff7934e8960b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65239d206887e149b1626573f908ff7934e8960b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65239d206887e149b1626573f908ff7934e8960b", "patch": "@@ -1,3 +1,264 @@\n+2007-10-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips-protos.h (mips_regno_mode_ok_for_base_p): Give\n+\tthe STRICT_P argument type \"bool\" rather than \"int\".\n+\t(mips_legitimate_address_p): Likewise.\n+\t(fp_register_operand, lo_operand): Delete.\n+\t(mips_subword): Give the HIGH_P argument type \"bool\" rather than \"int\".\n+\t(mips_emit_scc): Rename to...\n+\t(mips_expand_scc): ...this.\n+\t(gen_conditional_branch): Rename to...\n+\t(mips_expand_conditional_branch): ...this.\n+\t(gen_conditional_move): Rename to...\n+\t(mips_expand_conditional_move): ...this.\n+\t(mips_gen_conditional_trap): Rename to...\n+\t(mips_expand_conditional_trap): ...this and take an rtx code instead\n+\tof an operands array.\n+\t(mips_expand_call): Give the SIBCALL_P argument type \"bool\"\n+\trather than \"int\".\n+\t(mips_emit_fcc_reload): Rename to...\n+\t(mips_expand_fcc_reload): ...this.\n+\t(init_cumulative_args): Rename to...\n+\t(mips_init_cumulative_args): ...this and remove the libname argument.\n+\t(function_arg_advance): Rename to...\n+\t(mips_function_arg_advance): ...this.\n+\t(function_arg): Rename to...\n+\t(mips_function_arg): ...this and use \"rtx\" instead of\n+\t\"struct rtx_def *\".\n+\t(function_arg_boundary): Rename to...\n+\t(mips_function_arg_boundary): ...this.\n+\t(mips_expand_unaligned_load): Rename to...\n+\t(mips_expand_ext_as_unaligned_load): ...this and give the WIDTH\n+\tand BITPOS arguments type \"HOST_WIDE_INT\".\n+\t(mips_expand_unaligned_store): Rename to...\n+\t(mips_expand_ins_as_unaligned_store): ...this and give the WIDTH\n+\tand BITPOS arguments type \"HOST_WIDE_INT\".\n+\t(override_options): Rename to...\n+\t(mips_override_options): ...this.\n+\t(print_operand): Rename to...\n+\t(mips_print_operand): ...this.\n+\t(print_operand_address): Rename to...\n+\t(mips_print_operand_address): ...this.\n+\t(mips_output_ascii): Remove the PREFIX argument.\n+\t(mips_expand_epilogue): Give the SIBCALL_P argument type \"bool\"\n+\trather than \"int\".\n+\t(mips_can_use_return_insn): Return a \"bool\" rather than an \"int\".\n+\t(mips_function_value): Remove the FUNC argument.  Use \"rtx\" instead\n+\tof \"struct rtx_def *\".\n+\t(mips_secondary_reload_class): Give the IN_P argument type \"bool\"\n+\trather than \"int\".\n+\t(build_mips16_call_stub): Delete.\n+\t(mips_store_data_bypass_p): Return a \"bool\" rather than an \"int\".\n+\t(mips_use_ins_ext_p): Give the second and third arguments type\n+\t\"HOST_WIDE_INT\" rather than \"rtx\".\n+\t* config/mips/mips.h: Update after the above changes.  Tweak comments\n+\tand formatting.\n+\t(SECONDARY_INPUT_RELOAD_CLASS): Pass a boolean IN_P argument.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n+\t(mips_print_operand_punct, mips_hard_regno_mode_ok): Change the\n+\telement type from \"char\" to \"bool\".\n+\t(mips_section_threshold, sym_lineno, set_noat, mips_branch_likely)\n+\t(mips_cpu_info_table): Delete.\n+\t* config/mips/mips.md: Update after the above changes.  Tweak some\n+\tformatting.\n+\t* config/mips/mips-ps-3d.md: Likewise.\n+\t* config/mips/mips.c: Tweak comments and formatting.\n+\tUse NULL-like macros rather than 0 in various places.\n+\t(mips_section_threshold): Rename to...\n+\t(mips_small_data_threshold): ...this and give it an unsigned type.\n+\t(num_source_filenames): Remove explicit initialization.\n+\t(sdb_label_count): Likewise.\n+\t(sym_lineno): Delete.\n+\t(set_noat): Make static.\n+\t(mips_branch_likely): Likewise, and give it type \"bool\".\n+\t(mips_isa_info): Rename to...\n+\t(mips_isa_option_info): ...this.\n+\t(mips_flag_delayed_branch): Rename to...\n+\t(mips_base_delayed_branch): ...this.\n+\t(mips_split_addresses): Delete.\n+\t(mips_print_operand_punct, mips_hard_regno_mode_ok): Change the\n+\telement type from \"char\" to \"bool\".\n+\t(mips_regno_to_class): Add an explicit array size.\n+\t(mips16_flipper): Change from type \"int\" to type \"bool\".\n+\t(mips_comp_type_attributes): Remove redundant FUNCTION_TYPE check.\n+\t(mips_tls_operand_p): Rename to...\n+\t(mips_tls_symbol_p): ...this.\n+\t(mips_global_symbol_p): Remove redundant \"const\".\n+\t(mips_offset_within_alignment_p): Simplify.\n+\t(mips_regno_mode_ok_for_base_p): Change the name of the last argument\n+\tto STRICT_P and give it type bool.\n+\t(mips_valid_base_register_p): Likewise.\n+\t(mips_classify_address): Likewise.\n+\t(mips_legitimate_address_p): Likewise.\n+\t(mips16_unextended_reference_p): Take the offset as an\n+\t\"unsigned HOST_WIDE_INT\" rather than an \"rtx\".  Simplify.\n+\t(mips_const_insns): Use IN_RANGE.\n+\t(mips_force_temporary): Remove an unnecessary copy_rtx.\n+\t(mips16_gp_pseudo_reg): Simplify.\n+\t(mips_split_symbol): Remove an unnecessary copy_rtx.\n+\t(mips_legitimize_tls_address): Only create registers if we need them.\n+\t(mips_legitimize_address): Use mips_split_plus.\n+\t(mips_move_integer): Swap DEST and TEMP arguments.  Rename local\n+\tvariable COST to NUM_OPS.\n+\t(mips_legitimize_move): Use gen_lowpart.\n+\t(mips_rewrite_small_data): Rename the OP parameter to PATTERN.\n+\t(m16_check_op): Use IN_RANGE.\n+\t(mips_subword): Give the HIGH_P argument type \"bool\" rather than \"int\".\n+\t(mips_split_doubleword_move): Pass booleans to mips_subword.\n+\t(mips_output_move): Store the mode in a local variable.\n+\tExplicitly assert that this function does not deal with\n+\tMFLO and MFHI.  Use SMALL_OPERAND_UNSIGNED.  Make order of\n+\tcases more consistent.\n+\t(mips_relational_operand_ok_p): Rename to...\n+\t(mips_int_order_operand_ok_p): ...this.\n+\t(mips_canonicalize_comparison): Rename to...\n+\t(mips_canonicalize_int_order_test): ...this.\n+\t(mips_emit_int_relational): Rename to...\n+\t(mips_emit_int_order_test): ...this.  Store the mode in a local\n+\tvariable.\n+\t(mips_reverse_fp_cond_p): Rename to...\n+\t(mips_reversed_fp_cond): ...this.\n+\t(mips_emit_compare): Make the order of the statements more consistent.\n+\t(mips_emit_scc): Rename to...\n+\t(mips_expand_scc): ...this.\n+\t(gen_conditional_branch): Rename to...\n+\t(mips_expand_conditional_branch): ...this.\n+\t(gen_conditional_move): Rename to...\n+\t(mips_expand_conditional_move): ...this.  Build the condition\n+\tseparately from the main pattern.\n+\t(mips_gen_conditional_trap): Rename to...\n+\t(mips_expand_conditional_trap): ...this and take an rtx code instead\n+\tof an operands array.  Simplify.\n+\t(init_cumulative_args): Rename to...\n+\t(mips_init_cumulative_args): ...this.  Use memset rather than a\n+\tcopy from a zeroed static.  Use prototype_p and stdarg_p.\n+\t(mips_arg_info): Rename to...\n+\t(mips_get_arg_info): ...this and put the INFO argument first.\n+\t(function_arg): Rename to...\n+\t(mips_function_arg): ...this and use \"rtx\" instead of\n+\t\"struct rtx_def *\".  Only split structures into chunks if \n+\tTARGET_HARD_FLOAT, rather than checking !TARGET_SOFT_FLOAT on\n+\ta chunk-by-chunk basis.  Use SCALAR_FLOAT_TYPE_P instead of a\n+\tcomparison with REAL_TYPE.  Rename local variable REG to REGNO\n+\tand make it unsigned.\n+\t(function_arg_advance): Rename to...\n+\t(mips_function_arg_advance): ...this.\n+\t(function_arg_boundary): Rename to...\n+\t(mips_function_arg_boundary): ...this.\n+\t(mips_pad_arg_upward): Use SCALAR_INT_MODE_P instead of a comparison\n+\twith MODE_INT.\n+\t(mips_fpr_return_fields): Use SCALAR_FLOAT_TYPE_P instead of a\n+\tcomparison with REAL_TYPE.\n+\t(mips_function_value): Remove the FUNC argument.  Rename local\n+\tvariable UNSIGNEDP to UNSIGNED_P.\n+\t(mips_return_in_memory): Use IN_RANGE.\n+\t(mips_setup_incoming_varargs): Pass a boolean rather than an int\n+\tto FUNCTION_ARG_ADVANCE.\n+\t(mips_gimplify_va_arg_expr): Rename local variable INDIRECT\n+\tto INDIRECT_P.  Remove a redundant mips_abi check.  Only calculate\n+\tSIZE and RSIZE if needed.\n+\t(mips16_stub): Rename FPRET to FP_RET_P and give it type \"bool\"\n+\trather than \"int\".\n+\t(build_mips16_function_stub): Rename to...\n+\t(mips16_build_function_stub): ...this.\n+\t(build_mips16_call_stub): Rename to...\n+\t(mips16_build_call_stub): ...this.  Make static, and return a\n+\t\"bool\" rather than an \"int\".  Rename the ARG_SIZE argument to\n+\tARGS_SIZE.  Rename the local variable FPRET to FP_RET_P and give\n+\tit type \"bool\".  Use \"jr\" rather than \"j\".  Use XNEW.  Simplify.\n+\t(mips_load_call_address): Give the SIBCALL_P argument type \"bool\"\n+\trather than \"int\".\n+\t(mips_expand_call): Likewise.  Assert that MIPS16 calls via stubs\n+\tare not sibling ones.\n+\t(mips_emit_fcc_reload): Rename to...\n+\t(mips_expand_fcc_reload): ...this.\n+\t(mips_get_unaligned_mem): Give the WIDTH and BITPOS arguments type\n+\t\"HOST_WIDE_INT\".\n+\t(mips_expand_unaligned_load): Rename to...\n+\t(mips_expand_ext_as_unaligned_load): ...this and give the WIDTH\n+\tand BITPOS arguments type \"HOST_WIDE_INT\".  Remove redundant\n+\tSUBREG_BYTE check.\n+\t(mips_expand_unaligned_store): Rename to...\n+\t(mips_expand_ins_as_unaligned_store): ...this and give the WIDTH\n+\tand BITPOS arguments type \"HOST_WIDE_INT\".\n+\t(mips_use_ins_ext_p): Rename second and third arguments to WIDTH\n+\tand BITPOS and give them type \"HOST_WIDE_INT\" rather than \"rtx\".\n+\tUse IN_RANGE.\n+\t(mips_init_split_addresses): Replace with...\n+\t(mips_split_addresses_p): ...this new function.\n+\t(mips_init_relocs): Check mips_split_addresses_p () rather than\n+\tmips_split_addresses.  Always initialize mips_split_p with booleans.\n+\t(print_operand_reloc): Rename to...\n+\t(mips_print_operand_reloc): ...this.  Use a gcc_assert rather than\n+\ta fatal_error.\n+\t(print_operand): Rename to...\n+\t(mips_print_operand): ...this.\n+\t(print_operand_address): Rename to...\n+\t(mips_print_operand_address): ...this.  Use GP_REG_FIRST.\n+\t(mips_in_small_data_p): Simplify.\n+\t(mips_output_ascii): Remove the PREFIX argument and \"register\"\n+\tkeywords.  Use the STRING parameter directly and cast to\n+\t\"unsigned char\".\n+\t(mips16e_collect_argument_save_p): Use IN_RANGE.\n+\t(mips_function_has_gp_insn): Simplify.\n+\t(mips_set_return_address): Use BITSET_P.\n+\t(mips_restore_gp): Use a separate statement to pick the base\n+\tregister.\n+\t(mips_output_function_prologue): Use a local FRAME variable.\n+\t(mips_save_reg): Pass booleans to mips_subword.\n+\t(mips_expand_prologue): Use a local FRAME variable.  Use\n+\tcprestore_size to detect when .cprestore is needed.\n+\t(mips_restore_reg): Use GP_REG_FIRST.\n+\t(mips_expand_epilogue): Give the SIBCALL_P argument type \"bool\"\n+\trather than \"int\".  Use local FRAME and REGNO variables.\n+\t(mips_can_use_return_insn): Return a \"bool\" rather than an \"int\".\n+\t(mips_secondary_reload_class): Give the IN_P argument type \"bool\"\n+\trather than \"int\".\n+\t(mips_linked_madd_p): Rename arguments to OUT_INSN and IN_INSN.\n+\t(mips_store_data_bypass_p): Return a \"bool\" rather than an \"int\".\n+\t(vr4130_swap_insns_p): Rename local variables to DEP1_P and DEP2_P.\n+\t(mips_74k_agen_init): Assume INSN satisfies USEFUL_INSN_P.\n+\t(mips_variable_issue): Do nothing unless INSN satisfies USEFUL_INSN_P.\n+\t(builtin_description): Rename to...\n+\t(mips_builtin_description): ...this.\n+\t(mips_bdesc): Rename to...\n+\t(mips_ps_bdesc): ...this.\n+\t(sb1_bdesc): Rename to...\n+\t(mips_sb1_bdesc): ...this.\n+\t(dsp_bdesc): Rename to...\n+\t(mips_dsp_bdesc): ...this.\n+\t(dsp_32only_bdesc): Rename to...\n+\t(mips_dsp_32only_bdesc): ...this.\n+\t(bdesc_map): Rename to...\n+\t(mips_bdesc_map): ...this.\n+\t(bdesc_arrays): Rename to...\n+\t(mips_bdesc_arrays): ...this.\n+\t(mips_prepare_builtin_arg): Rename OP to OPNO and ARGNUM to ARGNO.\n+\tTweak error message.\n+\t(mips_expand_builtin_direct): Rename HAS_TARGET to HAS_TARGET_P.\n+\tRename local variables I and J to OPNO and ARGNO respectively.\n+\tAssert that the number of arguments is no more than the number of\n+\tinput operands.\n+\t(mips_expand_builtin_compare): Use an array of arguments rather\n+\tthan an array of operands.  Assert that the number of operands is\n+\tas expected.\n+\t(add_constant): Rename to...\n+\t(mips16_add_constant): ...this.  Use XNEW.\n+\t(dump_constants_1): Rename to...\n+\t(mips16_emit_constants_1): ...this.  Use ALL_SCALAR_FIXED_POINT_MODE_P.\n+\t(dump_constants): Rename to...\n+\t(mips16_emit_constants): ...this.\n+\t(mips_sim_wait_reg, mips_sim_record_set): Use END_REGNO.\n+\t(mips_set_mips16_mode): Don't call mips_init_split_addresses.\n+\tAssign mips16_p to was_mips16_p.\n+\t(mips_parse_cpu): Tweak warning message.\n+\t(override_options): Rename to...\n+\t(mips_override_options): ...this.  Move the mips_cost initialization\n+\tout of the \"shared with GAS\" block.  Quote option names in error\n+\tmessages.\n+\t(mips_conditional_register_usage): Make local variable REGNO unsigned.\n+\t(mips_order_regs_for_local_alloc): Remove register keyword.\n+\n 2007-10-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* system.h (IN_RANGE): Cast each argument individually."}, {"sha": "ed7a7890faf77784c8f4f68684d8d675e5dacc76", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=65239d206887e149b1626573f908ff7934e8960b", "patch": "@@ -166,15 +166,13 @@ struct mips16e_save_restore_info;\n \n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_context,\n \t\t\t\t      enum mips_symbol_type *);\n-extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, int);\n+extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n+extern bool mips_legitimate_address_p (enum machine_mode, rtx, bool);\n extern bool mips_stack_address_p (rtx, enum machine_mode);\n extern int mips_address_insns (rtx, enum machine_mode, bool);\n extern int mips_const_insns (rtx);\n extern int mips_load_store_insns (rtx, rtx);\n extern int mips_idiv_insns (void);\n-extern int fp_register_operand (rtx, enum machine_mode);\n-extern int lo_operand (rtx, enum machine_mode);\n-extern bool mips_legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx mips_emit_move (rtx, rtx);\n extern bool mips_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n@@ -199,47 +197,49 @@ extern int m16_nuimm8_4 (rtx, enum machine_mode);\n extern int m16_simm8_8 (rtx, enum machine_mode);\n extern int m16_nsimm8_8 (rtx, enum machine_mode);\n \n-extern rtx mips_subword (rtx, int);\n+extern rtx mips_subword (rtx, bool);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n extern void mips_split_doubleword_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n extern void mips_restore_gp (void);\n #ifdef RTX_CODE\n-extern bool mips_emit_scc (enum rtx_code, rtx);\n-extern void gen_conditional_branch (rtx *, enum rtx_code);\n+extern bool mips_expand_scc (enum rtx_code, rtx);\n+extern void mips_expand_conditional_branch (rtx *, enum rtx_code);\n extern void mips_expand_vcondv2sf (rtx, rtx, rtx, enum rtx_code, rtx, rtx);\n+extern void mips_expand_conditional_move (rtx *);\n+extern void mips_expand_conditional_trap (enum rtx_code);\n #endif\n-extern void gen_conditional_move (rtx *);\n-extern void mips_gen_conditional_trap (rtx *);\n-extern void mips_expand_call (rtx, rtx, rtx, rtx, int);\n-extern void mips_emit_fcc_reload (rtx, rtx, rtx);\n+extern void mips_expand_call (rtx, rtx, rtx, rtx, bool);\n+extern void mips_expand_fcc_reload (rtx, rtx, rtx);\n extern void mips_set_return_address (rtx, rtx);\n extern bool mips_expand_block_move (rtx, rtx, rtx);\n extern void mips_expand_synci_loop (rtx, rtx);\n \n-extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n-extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t  tree, int);\n-extern struct rtx_def *function_arg (const CUMULATIVE_ARGS *,\n-\t\t\t\t     enum machine_mode, tree, int);\n-extern int function_arg_boundary (enum machine_mode, tree);\n+extern void mips_init_cumulative_args (CUMULATIVE_ARGS *, tree);\n+extern void mips_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t       tree, int);\n+extern rtx mips_function_arg (const CUMULATIVE_ARGS *,\n+\t\t\t      enum machine_mode, tree, int);\n+extern int mips_function_arg_boundary (enum machine_mode, tree);\n extern bool mips_pad_arg_upward (enum machine_mode, const_tree);\n extern bool mips_pad_reg_upward (enum machine_mode, tree);\n extern void mips_va_start (tree, rtx);\n \n-extern bool mips_expand_unaligned_load (rtx, rtx, unsigned int, int);\n-extern bool mips_expand_unaligned_store (rtx, rtx, unsigned int, int);\n+extern bool mips_expand_ext_as_unaligned_load (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t       HOST_WIDE_INT);\n+extern bool mips_expand_ins_as_unaligned_store (rtx, rtx, HOST_WIDE_INT,\n+\t\t\t\t\t\tHOST_WIDE_INT);\n extern bool mips_mem_fits_mode_p (enum machine_mode mode, rtx x);\n-extern void override_options (void);\n+extern void mips_override_options (void);\n extern void mips_conditional_register_usage (void);\n extern void mips_order_regs_for_local_alloc (void);\n extern HOST_WIDE_INT mips_debugger_offset (rtx, HOST_WIDE_INT);\n \n-extern void print_operand (FILE *, rtx, int);\n-extern void print_operand_address (FILE *, rtx);\n+extern void mips_print_operand (FILE *, rtx, int);\n+extern void mips_print_operand_address (FILE *, rtx);\n extern void mips_output_external (FILE *, tree, const char *);\n extern void mips_output_filename (FILE *, const char *);\n-extern void mips_output_ascii (FILE *, const char *, size_t, const char *);\n+extern void mips_output_ascii (FILE *, const char *, size_t);\n extern void mips_output_aligned_decl_common (FILE *, tree, const char *,\n \t\t\t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t\t\t     unsigned int);\n@@ -258,9 +258,9 @@ extern HOST_WIDE_INT mips_initial_elimination_offset (int, int);\n extern rtx mips_return_addr (int, rtx);\n extern enum mips_loadgp_style mips_current_loadgp_style (void);\n extern void mips_expand_prologue (void);\n-extern void mips_expand_epilogue (int);\n-extern int mips_can_use_return_insn (void);\n-extern struct rtx_def *mips_function_value (const_tree, const_tree, enum machine_mode);\n+extern void mips_expand_epilogue (bool);\n+extern bool mips_can_use_return_insn (void);\n+extern rtx mips_function_value (const_tree, enum machine_mode);\n \n extern bool mips_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n@@ -269,9 +269,8 @@ extern bool mips_modes_tieable_p (enum machine_mode, enum machine_mode);\n extern enum reg_class mips_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t\t   rtx, int);\n+\t\t\t\t\t\t   rtx, bool);\n extern int mips_class_max_nregs (enum reg_class, enum machine_mode);\n-extern int build_mips16_call_stub (rtx, rtx, rtx, int);\n extern int mips_register_move_cost (enum machine_mode, enum reg_class,\n \t\t\t\t    enum reg_class);\n \n@@ -283,13 +282,13 @@ extern const char *mips_output_order_conditional_branch (rtx, rtx *, bool);\n extern const char *mips_output_division (const char *, rtx *);\n extern unsigned int mips_hard_regno_nregs (int, enum machine_mode);\n extern bool mips_linked_madd_p (rtx, rtx);\n-extern int mips_store_data_bypass_p (rtx, rtx);\n+extern bool mips_store_data_bypass_p (rtx, rtx);\n extern rtx mips_prefetch_cookie (rtx, rtx);\n \n extern void irix_asm_output_align (FILE *, unsigned);\n extern const char *current_section_name (void);\n extern unsigned int current_section_flags (void);\n-extern bool mips_use_ins_ext_p (rtx, rtx, rtx);\n+extern bool mips_use_ins_ext_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n \n extern const char *mips16e_output_save_restore (rtx, HOST_WIDE_INT);\n extern bool mips16e_save_restore_pattern_p (rtx, HOST_WIDE_INT,"}, {"sha": "d4efe4cbf79ffcc135404d7a7cc2ee080beabc2e", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=65239d206887e149b1626573f908ff7934e8960b", "patch": "@@ -61,7 +61,7 @@\n   if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n     FAIL;\n \n-  gen_conditional_move (operands);\n+  mips_expand_conditional_move (operands);\n   DONE;\n })\n "}, {"sha": "71678605cf975edbb5caea21c616610dde2c2ce5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1537, "deletions": 1638, "changes": 3175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=65239d206887e149b1626573f908ff7934e8960b"}, {"sha": "e1794c2830d5b6d3a29db664c79d634aeef03fd5", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 23, "deletions": 67, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=65239d206887e149b1626573f908ff7934e8960b", "patch": "@@ -922,7 +922,7 @@ enum mips_code_readable_setting {\n #define SWITCH_TAKES_ARG(CHAR)\t\t\t\t\t\t\\\n   (DEFAULT_SWITCH_TAKES_ARG (CHAR) || (CHAR) == 'G')\n \n-#define OVERRIDE_OPTIONS override_options ()\n+#define OVERRIDE_OPTIONS mips_override_options ()\n \n #define CONDITIONAL_REGISTER_USAGE mips_conditional_register_usage ()\n \n@@ -1385,7 +1385,7 @@ enum mips_code_readable_setting {\n \n    Regarding coprocessor registers: without evidence to the contrary,\n    it's best to assume that each coprocessor register has a unique\n-   use.  This can be overridden, in, e.g., override_options() or\n+   use.  This can be overridden, in, e.g., mips_override_options or\n    CONDITIONAL_REGISTER_USAGE should the assumption be inappropriate\n    for a particular target.  */\n \n@@ -1864,9 +1864,9 @@ enum reg_class\n    general registers, and from the floating point registers.  */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n-  mips_secondary_reload_class (CLASS, MODE, X, 1)\n+  mips_secondary_reload_class (CLASS, MODE, X, true)\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n-  mips_secondary_reload_class (CLASS, MODE, X, 0)\n+  mips_secondary_reload_class (CLASS, MODE, X, false)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n@@ -1959,10 +1959,10 @@ enum reg_class\n #define FP_ARG_LAST  (FP_ARG_FIRST + MAX_ARGS_IN_REGISTERS - 1)\n \n #define LIBCALL_VALUE(MODE) \\\n-  mips_function_value (NULL_TREE, NULL, (MODE))\n+  mips_function_value (NULL_TREE, MODE)\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  mips_function_value ((VALTYPE), (FUNC), VOIDmode)\n+  mips_function_value (VALTYPE, VOIDmode)\n \n /* 1 if N is a possible register number for a function value.\n    On the MIPS, R2 R3 and F0 F2 are the only register thus used.\n@@ -2002,9 +2002,9 @@ enum reg_class\n    allocate floating-point registers.\n \n    So for the standard ABIs, the first N words are allocated to integer\n-   registers, and function_arg decides on an argument-by-argument basis\n-   whether that argument should really go in an integer register, or in\n-   a floating-point one.  */\n+   registers, and mips_function_arg decides on an argument-by-argument\n+   basis whether that argument should really go in an integer register,\n+   or in a floating-point one.  */\n \n typedef struct mips_args {\n   /* Always true for varargs functions.  Otherwise true if at least\n@@ -2047,14 +2047,14 @@ typedef struct mips_args {\n    For a library call, FNTYPE is 0.  */\n \n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\t\t\t\t\\\n+  mips_init_cumulative_args (&CUM, FNTYPE)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  function_arg_advance (&CUM, MODE, TYPE, NAMED)\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+  mips_function_arg_advance (&CUM, MODE, TYPE, NAMED)\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -2070,14 +2070,14 @@ typedef struct mips_args {\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  function_arg( &CUM, MODE, TYPE, NAMED)\n+  mips_function_arg (&CUM, MODE, TYPE, NAMED)\n \n-#define FUNCTION_ARG_BOUNDARY function_arg_boundary\n+#define FUNCTION_ARG_BOUNDARY mips_function_arg_boundary\n \n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\\\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n   (mips_pad_arg_upward (MODE, TYPE) ? upward : downward)\n \n-#define BLOCK_REG_PADDING(MODE, TYPE, FIRST)\t\t\\\n+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n   (mips_pad_reg_upward (MODE, TYPE) ? upward : downward)\n \n /* True if using EABI and varargs can be passed in floating-point\n@@ -2099,8 +2099,7 @@ typedef struct mips_args {\n \n \f\n /* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n-  mips_va_start (valist, nextarg)\n+#define EXPAND_BUILTIN_VA_START mips_va_start\n \f\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n@@ -2539,44 +2538,9 @@ typedef struct mips_args {\n \n #define ALL_COP_ADDITIONAL_REGISTER_NAMES\n \n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand X.  X is an RTL\n-   expression.\n-\n-   CODE is a value that can be used to specify one of several ways\n-   of printing the operand.  It is used when identical operands\n-   must be printed differently depending on the context.  CODE\n-   comes from the `%' specification that was used to request\n-   printing of the operand.  If the specification was just `%DIGIT'\n-   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n-   is the ASCII code for LTR.\n-\n-   If X is a register, this macro should print the register's name.\n-   The names can be found in an array `reg_names' whose type is\n-   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n-\n-   When the machine description has a specification `%PUNCT' (a `%'\n-   followed by a punctuation character), this macro is called with\n-   a null pointer for X and the punctuation character for CODE.\n-\n-   See mips.c for the MIPS specific codes.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n-\n-/* A C expression which evaluates to true if CODE is a valid\n-   punctuation character for use in the `PRINT_OPERAND' macro.  If\n-   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no\n-   punctuation characters (except for the standard one, `%') are\n-   used in this way.  */\n-\n+#define PRINT_OPERAND mips_print_operand\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) mips_print_operand_punct[CODE]\n-\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand that is a memory\n-   reference whose address is ADDR.  ADDR is an RTL expression.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n-\n+#define PRINT_OPERAND_ADDRESS mips_print_operand_address\n \n /* A C statement, to be executed after all slot-filler instructions\n    have been output.  If necessary, call `dbr_sequence_length' to\n@@ -2608,10 +2572,8 @@ do\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-\n /* How to tell the debugger about changes of source files.  */\n-#define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n-  mips_output_filename (STREAM, NAME)\n+#define ASM_OUTPUT_SOURCE_FILENAME mips_output_filename\n \n /* mips-tfile does not understand .stabd directives.  */\n #define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER) do {\t\\\n@@ -2736,8 +2698,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This is how to output a string.  */\n #undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(STREAM, STRING, LEN)\t\t\t\t\\\n-  mips_output_ascii (STREAM, STRING, LEN, \"\\t.ascii\\t\")\n+#define ASM_OUTPUT_ASCII mips_output_ascii\n \n /* Output #ident as a in the read-only data section.  */\n #undef  ASM_OUTPUT_IDENT\n@@ -3038,16 +2999,12 @@ while (0)\n \n #ifndef USED_FOR_TARGET\n extern const enum reg_class mips_regno_to_class[];\n-extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n-extern char mips_print_operand_punct[256]; /* print_operand punctuation chars */\n+extern bool mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n+extern bool mips_print_operand_punct[256];\n extern const char *current_function_file; /* filename current function is in */\n extern int num_source_filenames;\t/* current .file # */\n-extern int mips_section_threshold;\t/* # bytes of data/sdata cutoff */\n-extern int sym_lineno;\t\t\t/* sgi next label # for each stmt */\n extern int set_noreorder;\t\t/* # of nested .set noreorder's  */\n extern int set_nomacro;\t\t\t/* # of nested .set nomacro's  */\n-extern int set_noat;\t\t\t/* # of nested .set noat's  */\n-extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\n extern int mips_dwarf_regno[];\n extern bool mips_split_p[];\n@@ -3056,7 +3013,6 @@ extern enum processor_type mips_arch;   /* which cpu to codegen for */\n extern enum processor_type mips_tune;   /* which cpu to schedule for */\n extern int mips_isa;\t\t\t/* architectural level */\n extern int mips_abi;\t\t\t/* which ABI to use */\n-extern const struct mips_cpu_info mips_cpu_info_table[];\n extern const struct mips_cpu_info *mips_arch_info;\n extern const struct mips_cpu_info *mips_tune_info;\n extern const struct mips_rtx_cost_data *mips_cost;"}, {"sha": "1f7503eba87353ded0a18274978017b1c1cd41a6", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65239d206887e149b1626573f908ff7934e8960b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=65239d206887e149b1626573f908ff7934e8960b", "patch": "@@ -749,11 +749,10 @@\n   if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) == MODE_INT\n       && operands[1] == const0_rtx)\n     {\n-      mips_gen_conditional_trap (operands);\n+      mips_expand_conditional_trap (GET_CODE (operands[0]));\n       DONE;\n     }\n-  else\n-    FAIL;\n+  FAIL;\n })\n \n (define_insn \"*conditional_trap<mode>\"\n@@ -3027,9 +3026,9 @@\n \t\t      (match_operand 3 \"immediate_operand\")))]\n   \"!TARGET_MIPS16\"\n {\n-  if (mips_expand_unaligned_load (operands[0], operands[1],\n-\t\t\t\t  INTVAL (operands[2]),\n-\t\t\t\t  INTVAL (operands[3])))\n+  if (mips_expand_ext_as_unaligned_load (operands[0], operands[1],\n+\t\t\t\t\t INTVAL (operands[2]),\n+\t\t\t\t\t INTVAL (operands[3])))\n     DONE;\n   else\n     FAIL;\n@@ -3042,11 +3041,12 @@\n \t\t      (match_operand 3 \"immediate_operand\")))]\n   \"!TARGET_MIPS16\"\n {\n-  if (mips_expand_unaligned_load (operands[0], operands[1],\n-\t\t\t\t  INTVAL (operands[2]),\n-\t\t\t\t  INTVAL (operands[3])))\n+  if (mips_expand_ext_as_unaligned_load (operands[0], operands[1],\n+\t\t\t\t\t INTVAL (operands[2]),\n+\t\t\t\t\t INTVAL (operands[3])))\n     DONE;\n-  else if (mips_use_ins_ext_p (operands[1], operands[2], operands[3]))\n+  else if (mips_use_ins_ext_p (operands[1], INTVAL (operands[2]),\n+\t\t\t       INTVAL (operands[3])))\n     {\n       if (GET_MODE (operands[0]) == DImode)\n         emit_insn (gen_extzvdi (operands[0], operands[1], operands[2],\n@@ -3065,7 +3065,8 @@\n \t(zero_extract:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n \t\t\t  (match_operand:SI 2 \"immediate_operand\" \"I\")\n \t\t\t  (match_operand:SI 3 \"immediate_operand\" \"I\")))]\n-  \"mips_use_ins_ext_p (operands[1], operands[2], operands[3])\"\n+  \"mips_use_ins_ext_p (operands[1], INTVAL (operands[2]),\n+\t\t       INTVAL (operands[3]))\"\n   \"<d>ext\\t%0,%1,%3,%2\"\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"<MODE>\")])\n@@ -3078,11 +3079,12 @@\n \t(match_operand 3 \"reg_or_0_operand\"))]\n   \"!TARGET_MIPS16\"\n {\n-  if (mips_expand_unaligned_store (operands[0], operands[3],\n-\t\t\t\t   INTVAL (operands[1]),\n-\t\t\t\t   INTVAL (operands[2])))\n+  if (mips_expand_ins_as_unaligned_store (operands[0], operands[3],\n+\t\t\t\t\t  INTVAL (operands[1]),\n+\t\t\t\t\t  INTVAL (operands[2])))\n     DONE;\n-  else if (mips_use_ins_ext_p (operands[0], operands[1], operands[2]))\n+  else if (mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),\n+\t\t\t       INTVAL (operands[2])))\n     {\n       if (GET_MODE (operands[0]) == DImode)\n         emit_insn (gen_insvdi (operands[0], operands[1], operands[2],\n@@ -3101,7 +3103,8 @@\n \t\t\t  (match_operand:SI 1 \"immediate_operand\" \"I\")\n \t\t\t  (match_operand:SI 2 \"immediate_operand\" \"I\"))\n \t(match_operand:GPR 3 \"reg_or_0_operand\" \"dJ\"))]\n-  \"mips_use_ins_ext_p (operands[0], operands[1], operands[2])\"\n+  \"mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),\n+\t\t       INTVAL (operands[2]))\"\n   \"<d>ins\\t%0,%z3,%2,%1\"\n   [(set_attr \"type\"\t\"arith\")\n    (set_attr \"mode\"\t\"<MODE>\")])\n@@ -3343,7 +3346,7 @@\n    (set_attr \"length\" \"4\")])\n \n ;; Instructions for adding the low 16 bits of an address to a register.\n-;; Operand 2 is the address: print_operand works out which relocation\n+;; Operand 2 is the address: mips_print_operand works out which relocation\n ;; should be applied.\n \n (define_insn \"*low<mode>\"\n@@ -3374,7 +3377,7 @@\n   \"\"\n   [(const_int 0)]\n {\n-  mips_move_integer (operands[0], operands[2], INTVAL (operands[1]));\n+  mips_move_integer (operands[2], operands[0], INTVAL (operands[1]));\n   DONE;\n })\n \n@@ -3680,7 +3683,7 @@\n    (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n {\n-  mips_emit_fcc_reload (operands[0], operands[1], operands[2]);\n+  mips_expand_fcc_reload (operands[0], operands[1], operands[2]);\n   DONE;\n })\n \n@@ -3690,7 +3693,7 @@\n    (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n {\n-  mips_emit_fcc_reload (operands[0], operands[1], operands[2]);\n+  mips_expand_fcc_reload (operands[0], operands[1], operands[2]);\n   DONE;\n })\n \n@@ -4658,7 +4661,7 @@\n      so, for a shift between 8 and 16, it is just as fast to do two\n      shifts of 8 or less.  If there is a lot of shifting going on, we\n      may win in CSE.  Otherwise combine will put the shifts back\n-     together again.  This can be called by function_arg, so we must\n+     together again.  This can be called by mips_function_arg, so we must\n      be careful not to allocate a new register if we've reached the\n      reload pass.  */\n   if (TARGET_MIPS16\n@@ -5030,7 +5033,7 @@\n \t\t      (pc)))]\n   \"\"\n {\n-  gen_conditional_branch (operands, <CODE>);\n+  mips_expand_conditional_branch (operands, <CODE>);\n   DONE;\n })\n \n@@ -5053,7 +5056,7 @@\n \t(eq:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (EQ, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (EQ, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*seq_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5081,7 +5084,7 @@\n \t(ne:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"!TARGET_MIPS16\"\n-  { if (mips_emit_scc (NE, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (NE, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sne_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5097,7 +5100,7 @@\n \t(gt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (GT, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (GT, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sgt_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5122,7 +5125,7 @@\n \t(ge:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (GE, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (GE, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sge_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5138,7 +5141,7 @@\n \t(lt:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (LT, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (LT, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*slt_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5168,7 +5171,7 @@\n \t(le:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (LE, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (LE, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sle_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5202,7 +5205,7 @@\n \t(gtu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (GTU, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (GTU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sgtu_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5227,7 +5230,7 @@\n         (geu:SI (match_dup 1)\n                 (match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (GEU, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (GEU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sge_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5243,7 +5246,7 @@\n \t(ltu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (LTU, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (LTU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sltu_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5273,7 +5276,7 @@\n \t(leu:SI (match_dup 1)\n \t\t(match_dup 2)))]\n   \"\"\n-  { if (mips_emit_scc (LEU, operands[0])) DONE; else FAIL; })\n+  { if (mips_expand_scc (LEU, operands[0])) DONE; else FAIL; })\n \n (define_insn \"*sleu_<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n@@ -5562,7 +5565,6 @@\n     emit_insn (gen_eh_set_lr_di (operands[0]));\n   else\n     emit_insn (gen_eh_set_lr_si (operands[0]));\n-\n   DONE;\n })\n \n@@ -5992,7 +5994,7 @@\n \t\t\t  (match_operand:GPR 3 \"reg_or_0_operand\")))]\n   \"ISA_HAS_CONDMOVE\"\n {\n-  gen_conditional_move (operands);\n+  mips_expand_conditional_move (operands);\n   DONE;\n })\n \n@@ -6004,7 +6006,7 @@\n \t\t\t      (match_operand:SCALARF 3 \"register_operand\")))]\n   \"ISA_HAS_CONDMOVE\"\n {\n-  gen_conditional_move (operands);\n+  mips_expand_conditional_move (operands);\n   DONE;\n })\n \f"}]}