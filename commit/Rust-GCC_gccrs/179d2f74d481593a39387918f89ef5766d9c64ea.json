{"sha": "179d2f74d481593a39387918f89ef5766d9c64ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc5ZDJmNzRkNDgxNTkzYTM5Mzg3OTE4Zjg5ZWY1NzY2ZDljNjRlYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2008-12-08T17:12:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2008-12-08T17:12:55Z"}, "message": "re PR middle-end/38240 (Vector type definitions not compatible with attribute target)\n\n\tPR 38240\n\t* tree.h (TYPE_MODE): Invoke vector_type_mode when needed.\n\t(SET_TYPE_MODE): New.\n\t* c-decl.c (parser_xref_tag): Use it.\n\t(finish_enum): Likewise.\n\t* tree.c (build_pointer_type_for_mode): Likewise.\n\t(build_reference_type_for_mode, build_index_type): Likewise.\n\t(build_range_type, make_vector_type): Likewise.\n\t(build_common_tree_nodes_2): Likewise.\n\t* stor-layout.c (compute_record_mode): Likewise.\n\t(finalize_type_size, layout_type, make_fract_type): Likewise.\n\t(make_accum_type, initialize_sizetypes): Likewise.\n\t(vector_type_mode): New.\n\t* function.c (allocate_struct_function): Call\n\tinvoke_set_current_function_hook before querying anything else.\n\n\t* config/i386/i386.c (ix86_valid_target_attribute_inner_p): Add avx.\n\ncp/\n\t* class.c (finish_struct_bits): Use SET_TYPE_MODE.\n\t* decl.c (record_unknown_type): Likewise.\n\t(start_enum, finish_enum): Likewise.\n\nFrom-SVN: r142556", "tree": {"sha": "485096f4613a7860b4f1694cbf454cc8dbba8614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/485096f4613a7860b4f1694cbf454cc8dbba8614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/179d2f74d481593a39387918f89ef5766d9c64ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/179d2f74d481593a39387918f89ef5766d9c64ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/179d2f74d481593a39387918f89ef5766d9c64ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/179d2f74d481593a39387918f89ef5766d9c64ea/comments", "author": null, "committer": null, "parents": [{"sha": "be6568d8c686fc6d4d7665b9eadc725eabdce39c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6568d8c686fc6d4d7665b9eadc725eabdce39c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be6568d8c686fc6d4d7665b9eadc725eabdce39c"}], "stats": {"total": 185, "additions": 135, "deletions": 50}, "files": [{"sha": "248979115b0fc0dae6e8674669d4d80ecdf4e47b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -1,3 +1,23 @@\n+2008-12-08  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 38240\n+\t* tree.h (TYPE_MODE): Invoke vector_type_mode when needed.\n+\t(SET_TYPE_MODE): New.\n+\t* c-decl.c (parser_xref_tag): Use it.\n+\t(finish_enum): Likewise.\n+\t* tree.c (build_pointer_type_for_mode): Likewise.\n+\t(build_reference_type_for_mode, build_index_type): Likewise.\n+\t(build_range_type, make_vector_type): Likewise.\n+\t(build_common_tree_nodes_2): Likewise.\n+\t* stor-layout.c (compute_record_mode): Likewise.\n+\t(finalize_type_size, layout_type, make_fract_type): Likewise.\n+\t(make_accum_type, initialize_sizetypes): Likewise.\n+\t(vector_type_mode): New.\n+\t* function.c (allocate_struct_function): Call\n+\tinvoke_set_current_function_hook before querying anything else.\n+\n+\t* config/i386/i386.c (ix86_valid_target_attribute_inner_p): Add avx.\n+\n 2008-12-08  Luis Machado  <luisgpm@br.ibm.com>\n \n \t* alias.c (find_base_term): Synch LO_SUM handling with what"}, {"sha": "7f7f2b00ac73c4538004b50280e7881c906b1b71", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -5302,7 +5302,7 @@ parser_xref_tag (enum tree_code code, tree name)\n     {\n       /* Give the type a default layout like unsigned int\n \t to avoid crashing if it does not get defined.  */\n-      TYPE_MODE (ref) = TYPE_MODE (unsigned_type_node);\n+      SET_TYPE_MODE (ref, TYPE_MODE (unsigned_type_node));\n       TYPE_ALIGN (ref) = TYPE_ALIGN (unsigned_type_node);\n       TYPE_USER_ALIGN (ref) = 0;\n       TYPE_UNSIGNED (ref) = 1;\n@@ -5952,7 +5952,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       TYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n       TYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n       TYPE_SIZE_UNIT (tem) = TYPE_SIZE_UNIT (enumtype);\n-      TYPE_MODE (tem) = TYPE_MODE (enumtype);\n+      SET_TYPE_MODE (tem, TYPE_MODE (enumtype));\n       TYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n       TYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n       TYPE_USER_ALIGN (tem) = TYPE_USER_ALIGN (enumtype);"}, {"sha": "71fbeac7416b85d58470b2e3f88262a1f922167b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -3408,6 +3408,7 @@ ix86_valid_target_attribute_inner_p (tree args, char *p_strings[])\n     IX86_ATTR_ISA (\"3dnow\",\tOPT_m3dnow),\n     IX86_ATTR_ISA (\"abm\",\tOPT_mabm),\n     IX86_ATTR_ISA (\"aes\",\tOPT_maes),\n+    IX86_ATTR_ISA (\"avx\",\tOPT_mavx),\n     IX86_ATTR_ISA (\"mmx\",\tOPT_mmmx),\n     IX86_ATTR_ISA (\"pclmul\",\tOPT_mpclmul),\n     IX86_ATTR_ISA (\"popcnt\",\tOPT_mpopcnt),"}, {"sha": "662fe3248fa2a4714f2a1511138e0db7f685e23f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -1,3 +1,10 @@\n+2008-12-08  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 38240\n+\t* class.c (finish_struct_bits): Use SET_TYPE_MODE.\n+\t* decl.c (record_unknown_type): Likewise.\n+\t(start_enum, finish_enum): Likewise.\n+\n 2008-12-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/35336"}, {"sha": "97ab9e38b877777c707f3a73793376b084612103", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -1494,7 +1494,7 @@ finish_struct_bits (tree t)\n       DECL_MODE (TYPE_MAIN_DECL (t)) = BLKmode;\n       for (variants = t; variants; variants = TYPE_NEXT_VARIANT (variants))\n \t{\n-\t  TYPE_MODE (variants) = BLKmode;\n+\t  SET_TYPE_MODE (variants, BLKmode);\n \t  TREE_ADDRESSABLE (variants) = 1;\n \t}\n     }"}, {"sha": "e786b39c8e30555876744414ba0c550ca5d8f9ae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -3199,7 +3199,7 @@ record_unknown_type (tree type, const char* name)\n   TYPE_SIZE (type) = TYPE_SIZE (void_type_node);\n   TYPE_ALIGN (type) = 1;\n   TYPE_USER_ALIGN (type) = 0;\n-  TYPE_MODE (type) = TYPE_MODE (void_type_node);\n+  SET_TYPE_MODE (type, TYPE_MODE (void_type_node));\n }\n \n /* A string for which we should create an IDENTIFIER_NODE at\n@@ -10912,7 +10912,7 @@ start_enum (tree name, tree underlying_type, bool scoped_enum_p)\n           TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (underlying_type);\n           TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n           TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n-          TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n+          SET_TYPE_MODE (enumtype, TYPE_MODE (underlying_type));\n           TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n           TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n           TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n@@ -11065,7 +11065,7 @@ finish_enum (tree enumtype)\n          applied to the underlying type.  */\n       TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n       TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n-      TYPE_MODE (enumtype) = TYPE_MODE (underlying_type);\n+      SET_TYPE_MODE (enumtype, TYPE_MODE (underlying_type));\n       TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n       TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n       TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n@@ -11133,7 +11133,7 @@ finish_enum (tree enumtype)\n       TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (enumtype);\n       TYPE_SIZE (t) = TYPE_SIZE (enumtype);\n       TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (enumtype);\n-      TYPE_MODE (t) = TYPE_MODE (enumtype);\n+      SET_TYPE_MODE (t, TYPE_MODE (enumtype));\n       TYPE_PRECISION (t) = TYPE_PRECISION (enumtype);\n       TYPE_ALIGN (t) = TYPE_ALIGN (enumtype);\n       TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (enumtype);"}, {"sha": "2ed1748d9ff0bc85f784d5c66c693e4bf06e261e", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -3987,6 +3987,8 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n   OVERRIDE_ABI_FORMAT (fndecl);\n #endif\n \n+  invoke_set_current_function_hook (fndecl);\n+\n   if (fndecl != NULL_TREE)\n     {\n       DECL_STRUCT_FUNCTION (fndecl) = cfun;\n@@ -4012,8 +4014,6 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n       cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n       cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n     }\n-\n-  invoke_set_current_function_hook (fndecl);\n }\n \n /* This is like allocate_struct_function, but pushes a new cfun for FNDECL"}, {"sha": "0e7caa5450bb6a5c4f8b666ff6711b979377076a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 74, "deletions": 32, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -1316,7 +1316,7 @@ compute_record_mode (tree type)\n      However, if possible, we use a mode that fits in a register\n      instead, in order to allow for better optimization down the\n      line.  */\n-  TYPE_MODE (type) = BLKmode;\n+  SET_TYPE_MODE (type, BLKmode);\n \n   if (! host_integerp (TYPE_SIZE (type), 1))\n     return;\n@@ -1360,9 +1360,9 @@ compute_record_mode (tree type)\n   if (TREE_CODE (type) == RECORD_TYPE && mode != VOIDmode\n       && host_integerp (TYPE_SIZE (type), 1)\n       && GET_MODE_BITSIZE (mode) == TREE_INT_CST_LOW (TYPE_SIZE (type)))\n-    TYPE_MODE (type) = mode;\n+    SET_TYPE_MODE (type, mode);\n   else\n-    TYPE_MODE (type) = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);\n+    SET_TYPE_MODE (type, mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1));\n \n   /* If structure's known alignment is less than what the scalar\n      mode would need, and it matters, then stick with BLKmode.  */\n@@ -1374,7 +1374,7 @@ compute_record_mode (tree type)\n       /* If this is the only reason this type is BLKmode, then\n \t don't force containing types to be BLKmode.  */\n       TYPE_NO_FORCE_BLK (type) = 1;\n-      TYPE_MODE (type) = BLKmode;\n+      SET_TYPE_MODE (type, BLKmode);\n     }\n }\n \n@@ -1458,7 +1458,7 @@ finalize_type_size (tree type)\n \t  TYPE_SIZE_UNIT (variant) = size_unit;\n \t  TYPE_ALIGN (variant) = align;\n \t  TYPE_USER_ALIGN (variant) = user_align;\n-\t  TYPE_MODE (variant) = mode;\n+\t  SET_TYPE_MODE (variant, mode);\n \t}\n     }\n }\n@@ -1580,14 +1580,15 @@ layout_type (tree type)\n \t  && tree_int_cst_sgn (TYPE_MIN_VALUE (type)) >= 0)\n \tTYPE_UNSIGNED (type) = 1;\n \n-      TYPE_MODE (type) = smallest_mode_for_size (TYPE_PRECISION (type),\n-\t\t\t\t\t\t MODE_INT);\n+      SET_TYPE_MODE (type,\n+\t\t     smallest_mode_for_size (TYPE_PRECISION (type), MODE_INT));\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n \n     case REAL_TYPE:\n-      TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_FLOAT, 0);\n+      SET_TYPE_MODE (type,\n+\t\t     mode_for_size (TYPE_PRECISION (type), MODE_FLOAT, 0));\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n@@ -1600,11 +1601,11 @@ layout_type (tree type)\n \n     case COMPLEX_TYPE:\n       TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n-      TYPE_MODE (type)\n-\t= mode_for_size (2 * TYPE_PRECISION (TREE_TYPE (type)),\n-\t\t\t (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE\n-\t\t\t  ? MODE_COMPLEX_FLOAT : MODE_COMPLEX_INT),\n-\t\t\t 0);\n+      SET_TYPE_MODE (type,\n+\t\t     mode_for_size (2 * TYPE_PRECISION (TREE_TYPE (type)),\n+\t\t\t\t    (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE\n+\t\t\t\t     ? MODE_COMPLEX_FLOAT : MODE_COMPLEX_INT),\n+\t\t\t\t     0));\n       TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (TYPE_MODE (type)));\n       break;\n@@ -1636,10 +1637,11 @@ layout_type (tree type)\n \t    else\n \t      mode = MIN_MODE_VECTOR_INT;\n \n+\t    /* Do not check vector_mode_supported_p here.  We'll do that\n+\t       later in vector_type_mode.  */\n \t    for (; mode != VOIDmode ; mode = GET_MODE_WIDER_MODE (mode))\n \t      if (GET_MODE_NUNITS (mode) == nunits\n-\t  \t  && GET_MODE_INNER (mode) == innermode\n-\t  \t  && targetm.vector_mode_supported_p (mode))\n+\t  \t  && GET_MODE_INNER (mode) == innermode)\n \t        break;\n \n \t    /* For integers, try mapping it to a same-sized scalar mode.  */\n@@ -1648,10 +1650,12 @@ layout_type (tree type)\n \t      mode = mode_for_size (nunits * GET_MODE_BITSIZE (innermode),\n \t\t\t\t    MODE_INT, 0);\n \n-\t    if (mode == VOIDmode || !have_regs_of_mode[mode])\n-\t      TYPE_MODE (type) = BLKmode;\n+\t    if (mode == VOIDmode ||\n+\t\t(GET_MODE_CLASS (mode) == MODE_INT\n+\t\t && !have_regs_of_mode[mode]))\n+\t      SET_TYPE_MODE (type, BLKmode);\n \t    else\n-\t      TYPE_MODE (type) = mode;\n+\t      SET_TYPE_MODE (type, mode);\n \t  }\n \n \tTYPE_SATURATING (type) = TYPE_SATURATING (TREE_TYPE (type));\n@@ -1672,31 +1676,30 @@ layout_type (tree type)\n       /* This is an incomplete type and so doesn't have a size.  */\n       TYPE_ALIGN (type) = 1;\n       TYPE_USER_ALIGN (type) = 0;\n-      TYPE_MODE (type) = VOIDmode;\n+      SET_TYPE_MODE (type, VOIDmode);\n       break;\n \n     case OFFSET_TYPE:\n       TYPE_SIZE (type) = bitsize_int (POINTER_SIZE);\n       TYPE_SIZE_UNIT (type) = size_int (POINTER_SIZE / BITS_PER_UNIT);\n       /* A pointer might be MODE_PARTIAL_INT,\n \t but ptrdiff_t must be integral.  */\n-      TYPE_MODE (type) = mode_for_size (POINTER_SIZE, MODE_INT, 0);\n+      SET_TYPE_MODE (type, mode_for_size (POINTER_SIZE, MODE_INT, 0));\n       break;\n \n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       /* It's hard to see what the mode and size of a function ought to\n \t be, but we do know the alignment is FUNCTION_BOUNDARY, so\n \t make it consistent with that.  */\n-      TYPE_MODE (type) = mode_for_size (FUNCTION_BOUNDARY, MODE_INT, 0);\n+      SET_TYPE_MODE (type, mode_for_size (FUNCTION_BOUNDARY, MODE_INT, 0));\n       TYPE_SIZE (type) = bitsize_int (FUNCTION_BOUNDARY);\n       TYPE_SIZE_UNIT (type) = size_int (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n       break;\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       {\n-\n \tenum machine_mode mode = ((TREE_CODE (type) == REFERENCE_TYPE\n \t\t\t\t   && reference_types_internal)\n \t\t\t\t  ? Pmode : TYPE_MODE (type));\n@@ -1792,7 +1795,7 @@ layout_type (tree type)\n \t     fall back on structural equality. */\n \t  SET_TYPE_STRUCTURAL_EQUALITY (type);\n \tTYPE_USER_ALIGN (type) = TYPE_USER_ALIGN (element);\n-\tTYPE_MODE (type) = BLKmode;\n+\tSET_TYPE_MODE (type, BLKmode);\n \tif (TYPE_SIZE (type) != 0\n #ifdef MEMBER_TYPE_FORCES_BLK\n \t    && ! MEMBER_TYPE_FORCES_BLK (type, VOIDmode)\n@@ -1805,17 +1808,17 @@ layout_type (tree type)\n \t    /* One-element arrays get the component type's mode.  */\n \t    if (simple_cst_equal (TYPE_SIZE (type),\n \t\t\t\t  TYPE_SIZE (TREE_TYPE (type))))\n-\t      TYPE_MODE (type) = TYPE_MODE (TREE_TYPE (type));\n+\t      SET_TYPE_MODE (type, TYPE_MODE (TREE_TYPE (type)));\n \t    else\n-\t      TYPE_MODE (type)\n-\t\t= mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);\n+\t      SET_TYPE_MODE (type, mode_for_size_tree (TYPE_SIZE (type),\n+\t\t\t\t\t\t       MODE_INT, 1));\n \n \t    if (TYPE_MODE (type) != BLKmode\n \t\t&& STRICT_ALIGNMENT && TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n \t\t&& TYPE_ALIGN (type) < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n \t      {\n \t\tTYPE_NO_FORCE_BLK (type) = 1;\n-\t\tTYPE_MODE (type) = BLKmode;\n+\t\tSET_TYPE_MODE (type, BLKmode);\n \t      }\n \t  }\n \t/* When the element size is constant, check that it is at least as\n@@ -1877,6 +1880,45 @@ layout_type (tree type)\n   if (AGGREGATE_TYPE_P (type))\n     gcc_assert (!TYPE_ALIAS_SET_KNOWN_P (type));\n }\n+\n+/* Vector types need to re-check the target flags each time we report\n+   the machine mode.  We need to do this because attribute target can\n+   change the result of vector_mode_supported_p and have_regs_of_mode\n+   on a per-function basis.  Thus the TYPE_MODE of a VECTOR_TYPE can\n+   change on a per-function basis.  */\n+/* ??? Possibly a better solution is to run through all the types \n+   referenced by a function and re-compute the TYPE_MODE once, rather\n+   than make the TYPE_MODE macro call a function.  */\n+\n+enum machine_mode\n+vector_type_mode (const_tree t)\n+{\n+  enum machine_mode mode;\n+\n+  gcc_assert (TREE_CODE (t) == VECTOR_TYPE);\n+\n+  mode = t->type.mode;\n+  if (VECTOR_MODE_P (mode)\n+      && (!targetm.vector_mode_supported_p (mode)\n+\t  || !have_regs_of_mode[mode]))\n+    {\n+      enum machine_mode innermode = TREE_TYPE (t)->type.mode;\n+\n+      /* For integers, try mapping it to a same-sized scalar mode.  */\n+      if (GET_MODE_CLASS (innermode) == MODE_INT)\n+\t{\n+\t  mode = mode_for_size (TYPE_VECTOR_SUBPARTS (t)\n+\t\t\t\t* GET_MODE_BITSIZE (innermode), MODE_INT, 0);\n+\n+\t  if (mode != VOIDmode && have_regs_of_mode[mode])\n+\t    return mode;\n+\t}\n+\n+      return BLKmode;\n+    }\n+\n+  return mode;\n+}\n \f\n /* Create and return a type for signed integers of PRECISION bits.  */\n \n@@ -1921,10 +1963,10 @@ make_fract_type (int precision, int unsignedp, int satp)\n   if (unsignedp)\n     {\n       TYPE_UNSIGNED (type) = 1;\n-      TYPE_MODE (type) = mode_for_size (precision, MODE_UFRACT, 0);\n+      SET_TYPE_MODE (type, mode_for_size (precision, MODE_UFRACT, 0));\n     }\n   else\n-    TYPE_MODE (type) = mode_for_size (precision, MODE_FRACT, 0);\n+    SET_TYPE_MODE (type, mode_for_size (precision, MODE_FRACT, 0));\n   layout_type (type);\n \n   return type;\n@@ -1947,10 +1989,10 @@ make_accum_type (int precision, int unsignedp, int satp)\n   if (unsignedp)\n     {\n       TYPE_UNSIGNED (type) = 1;\n-      TYPE_MODE (type) = mode_for_size (precision, MODE_UACCUM, 0);\n+      SET_TYPE_MODE (type, mode_for_size (precision, MODE_UACCUM, 0));\n     }\n   else\n-    TYPE_MODE (type) = mode_for_size (precision, MODE_ACCUM, 0);\n+    SET_TYPE_MODE (type, mode_for_size (precision, MODE_ACCUM, 0));\n   layout_type (type);\n \n   return type;\n@@ -1965,7 +2007,7 @@ initialize_sizetypes (bool signed_p)\n   tree t = make_node (INTEGER_TYPE);\n   int precision = GET_MODE_BITSIZE (SImode);\n \n-  TYPE_MODE (t) = SImode;\n+  SET_TYPE_MODE (t, SImode);\n   TYPE_ALIGN (t) = GET_MODE_ALIGNMENT (SImode);\n   TYPE_USER_ALIGN (t) = 0;\n   TYPE_IS_SIZETYPE (t) = 1;"}, {"sha": "6a3568754b3aa4a4941bd484acb680e5a82e9f0e", "filename": "gcc/testsuite/gcc.target/i386/pr38240.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr38240.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr38240.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr38240.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+typedef float V\n+  __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+V __attribute__((target(\"sse\"))) f(const V *ptr) { return *ptr; }\n+\n+V g(const V *ptr) { return *ptr; }"}, {"sha": "03c54cc1cb17b0a785f8b07c80cbdf475d37a010", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -5522,7 +5522,7 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n   t = make_node (POINTER_TYPE);\n \n   TREE_TYPE (t) = to_type;\n-  TYPE_MODE (t) = mode;\n+  SET_TYPE_MODE (t, mode);\n   TYPE_REF_CAN_ALIAS_ALL (t) = can_alias_all;\n   TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (to_type);\n   TYPE_POINTER_TO (to_type) = t;\n@@ -5586,7 +5586,7 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n   t = make_node (REFERENCE_TYPE);\n \n   TREE_TYPE (t) = to_type;\n-  TYPE_MODE (t) = mode;\n+  SET_TYPE_MODE (t, mode);\n   TYPE_REF_CAN_ALIAS_ALL (t) = can_alias_all;\n   TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (to_type);\n   TYPE_REFERENCE_TO (to_type) = t;\n@@ -5655,7 +5655,7 @@ build_index_type (tree maxval)\n   TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n   TYPE_MIN_VALUE (itype) = size_zero_node;\n   TYPE_MAX_VALUE (itype) = fold_convert (sizetype, maxval);\n-  TYPE_MODE (itype) = TYPE_MODE (sizetype);\n+  SET_TYPE_MODE (itype, TYPE_MODE (sizetype));\n   TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n   TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (sizetype);\n   TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n@@ -5711,7 +5711,7 @@ build_range_type (tree type, tree lowval, tree highval)\n   TYPE_MAX_VALUE (itype) = highval ? fold_convert (type, highval) : NULL;\n \n   TYPE_PRECISION (itype) = TYPE_PRECISION (type);\n-  TYPE_MODE (itype) = TYPE_MODE (type);\n+  SET_TYPE_MODE (itype, TYPE_MODE (type));\n   TYPE_SIZE (itype) = TYPE_SIZE (type);\n   TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (type);\n   TYPE_ALIGN (itype) = TYPE_ALIGN (type);\n@@ -7296,7 +7296,7 @@ make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n   t = make_node (VECTOR_TYPE);\n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (innertype);\n   SET_TYPE_VECTOR_SUBPARTS (t, nunits);\n-  TYPE_MODE (t) = mode;\n+  SET_TYPE_MODE (t, mode);\n   TYPE_READONLY (t) = TYPE_READONLY (innertype);\n   TYPE_VOLATILE (t) = TYPE_VOLATILE (innertype);\n \n@@ -7553,19 +7553,19 @@ build_common_tree_nodes_2 (int short_double)\n   dfloat32_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (dfloat32_type_node) = DECIMAL32_TYPE_SIZE; \n   layout_type (dfloat32_type_node);\n-  TYPE_MODE (dfloat32_type_node) = SDmode;\n+  SET_TYPE_MODE (dfloat32_type_node, SDmode);\n   dfloat32_ptr_type_node = build_pointer_type (dfloat32_type_node);\n \n   dfloat64_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (dfloat64_type_node) = DECIMAL64_TYPE_SIZE;\n   layout_type (dfloat64_type_node);\n-  TYPE_MODE (dfloat64_type_node) = DDmode;\n+  SET_TYPE_MODE (dfloat64_type_node, DDmode);\n   dfloat64_ptr_type_node = build_pointer_type (dfloat64_type_node);\n \n   dfloat128_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (dfloat128_type_node) = DECIMAL128_TYPE_SIZE; \n   layout_type (dfloat128_type_node);\n-  TYPE_MODE (dfloat128_type_node) = TDmode;\n+  SET_TYPE_MODE (dfloat128_type_node, TDmode);\n   dfloat128_ptr_type_node = build_pointer_type (dfloat128_type_node);\n \n   complex_integer_type_node = build_complex_type (integer_type_node);"}, {"sha": "55163b6c1b7a5b7a0ca8e4eb015ef9a296a26f95", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/179d2f74d481593a39387918f89ef5766d9c64ea/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=179d2f74d481593a39387918f89ef5766d9c64ea", "patch": "@@ -2050,7 +2050,6 @@ struct tree_block GTY(())\n #define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type.uid)\n #define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type.size)\n #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n-#define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)\n #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)\n #define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type.values)\n #define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)\n@@ -2078,6 +2077,14 @@ struct tree_block GTY(())\n #define TYPE_MAIN_VARIANT(NODE) (TYPE_CHECK (NODE)->type.main_variant)\n #define TYPE_CONTEXT(NODE) (TYPE_CHECK (NODE)->type.context)\n \n+/* Vector types need to check target flags to determine type.  */\n+extern enum machine_mode vector_type_mode (const_tree);\n+#define TYPE_MODE(NODE) \\\n+  (TREE_CODE (TYPE_CHECK (NODE)) == VECTOR_TYPE \\\n+   ? vector_type_mode (NODE) : (NODE)->type.mode)\n+#define SET_TYPE_MODE(NODE, MODE) \\\n+  (TYPE_CHECK (NODE)->type.mode = (MODE))\n+\n /* The \"canonical\" type for this type node, which can be used to\n    compare the type for equality with another type. If two types are\n    equal (based on the semantics of the language), then they will have"}]}