{"sha": "bb304287342b02608f8df217b65f2a93f65ae90c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIzMDQyODczNDJiMDI2MDhmOGRmMjE3YjY1ZjJhOTNmNjVhZTkwYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T09:57:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T09:57:00Z"}, "message": "[multiple changes]\n\n2014-08-04  Vincent Celier  <celier@adacore.com>\n\n\t* prj-dect.adb (Parse_Case_Construction): It is no longer\n\tan error if the variable for a case construction is not\n\ttyped, only if the variable value is not a single string. Call\n\tParse_Choice_List and End_Case_Construction with the new parameter\n\tto indicate that the variable is typed.\n\t* prj-strt.adb (End_Case_Construction): Only check the labels\n\tif the variable is typed.  If the variable is not typed,\n\tissue a warning when there is no \"when others\" allternative.\n\t(Parse_Choice_List): Manage the labels only if the variable\n\tis typed.\n\t* prj-strt.ads (End_Case_Construction): New Boolean parameter\n\tString_Type.\n\t(Parse_Choice_List): Ditto.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb: Additional fix to Check_Predicate_Use.\n\n2014-08-04  Vincent Celier  <celier@adacore.com>\n\n\t* projects.texi: Update documentation of case constructions with\n\tvariables that are not typed.\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Build_Class_Wide_Wrapper): If the operator carries\n\tan Eliminated pragma, indicate that the wrapper is also to be\n\teliminated, to prevent spurious errors when using gnatelim on\n\tprograms that include box-initialization of equality operators\n\t(consequence of AI05-071)..\n\n2014-08-04  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Activate_Overflow_Check): Handle floating-point\n\tcase correctly.\n\t* checks.ads (Activate_Overflow_Check): Clarify handling of\n\tfloating-point cases.\n\t* exp_util.adb (Check_Float_Op_Overflow): Reset Do_Overflow_Check\n\tflag if we generate an explicit overflow check (for\n\tCheck_Float_Overflow mode).\n\nFrom-SVN: r213550", "tree": {"sha": "f018ecd5df9867a82b2f011873e67be25b6d4580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f018ecd5df9867a82b2f011873e67be25b6d4580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb304287342b02608f8df217b65f2a93f65ae90c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb304287342b02608f8df217b65f2a93f65ae90c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb304287342b02608f8df217b65f2a93f65ae90c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb304287342b02608f8df217b65f2a93f65ae90c/comments", "author": null, "committer": null, "parents": [{"sha": "7ed571892e5a8d10c14a674e38b980f60115ceb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ed571892e5a8d10c14a674e38b980f60115ceb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ed571892e5a8d10c14a674e38b980f60115ceb6"}], "stats": {"total": 285, "additions": 195, "deletions": 90}, "files": [{"sha": "91804ed8a4ebab5b482ed93417f7489b11ddfa27", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -1,3 +1,46 @@\n+2014-08-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-dect.adb (Parse_Case_Construction): It is no longer\n+\tan error if the variable for a case construction is not\n+\ttyped, only if the variable value is not a single string. Call\n+\tParse_Choice_List and End_Case_Construction with the new parameter\n+\tto indicate that the variable is typed.\n+\t* prj-strt.adb (End_Case_Construction): Only check the labels\n+\tif the variable is typed.  If the variable is not typed,\n+\tissue a warning when there is no \"when others\" allternative.\n+\t(Parse_Choice_List): Manage the labels only if the variable\n+\tis typed.\n+\t* prj-strt.ads (End_Case_Construction): New Boolean parameter\n+\tString_Type.\n+\t(Parse_Choice_List): Ditto.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb: Additional fix to Check_Predicate_Use.\n+\n+2014-08-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* projects.texi: Update documentation of case constructions with\n+\tvariables that are not typed.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Build_Class_Wide_Wrapper): If the operator carries\n+\tan Eliminated pragma, indicate that the wrapper is also to be\n+\teliminated, to prevent spurious errors when using gnatelim on\n+\tprograms that include box-initialization of equality operators\n+\t(consequence of AI05-071)..\n+\n+2014-08-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Activate_Overflow_Check): Handle floating-point\n+\tcase correctly.\n+\t* checks.ads (Activate_Overflow_Check): Clarify handling of\n+\tfloating-point cases.\n+\t* exp_util.adb (Check_Float_Op_Overflow): Reset Do_Overflow_Check\n+\tflag if we generate an explicit overflow check (for\n+\tCheck_Float_Overflow mode).\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* prj-proc.adb, prj-part.adb, prj-strt.adb, prj.adb, prj.ads,"}, {"sha": "8072629666d03800ba2bfaee95ff8a915af26ef2", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -388,27 +388,46 @@ package body Checks is\n    -----------------------------\n \n    procedure Activate_Overflow_Check (N : Node_Id) is\n+      Typ : constant Entity_Id := Etype (N);\n+\n    begin\n-      --  Nothing to do for unconstrained floating-point types (the test for\n-      --  Etype (N) being present seems necessary in some cases, should be\n-      --  tracked down, but for now just ignore the check in this case ???),\n-      --  except if Check_Float_Overflow is set.\n-\n-      if Present (Etype (N))\n-        and then Is_Floating_Point_Type (Etype (N))\n-        and then not Is_Constrained (Etype (N))\n-        and then not Check_Float_Overflow\n-      then\n-         return;\n-      end if;\n+      --  Floating-point case. If Etype is not set (this can happen when we\n+      --  activate a check on a node that has not yet been analyzed), then\n+      --  we assume we do not have a floating-point type (as per our spec).\n \n-      --  Nothing to do for Rem/Mod/Plus (overflow not possible)\n+      if Present (Typ) and then Is_Floating_Point_Type (Typ) then\n \n-      if Nkind_In (N, N_Op_Rem, N_Op_Mod, N_Op_Plus) then\n-         return;\n+         --  Ignore call if we have no automatic overflow checks on the target\n+         --  and Check_Float_Overflow mode is not set. These are the cases in\n+         --  which we expect to generate infinities and NaN's with no check.\n+\n+         if not (Machine_Overflows_On_Target or Check_Float_Overflow) then\n+            return;\n+\n+         --  Ignore for unary operations (\"+\", \"-\", abs) since these can never\n+         --  result in overflow for floating-point cases.\n+\n+         elsif Nkind (N) in N_Unary_Op then\n+            return;\n+\n+         --  Otherwise we will set the flag\n+\n+         else\n+            null;\n+         end if;\n+\n+      --  Discrete case\n+\n+      else\n+         --  Nothing to do for Rem/Mod/Plus (overflow not possible, the check\n+         --  for zero-divide is a divide check, not an overflow check).\n+\n+         if Nkind_In (N, N_Op_Rem, N_Op_Mod, N_Op_Plus) then\n+            return;\n+         end if;\n       end if;\n \n-      --  Otherwise set the flag\n+      --  Fall through for cases where we do set the flag\n \n       Set_Do_Overflow_Check (N, True);\n       Possible_Local_Raise (N, Standard_Constraint_Error);"}, {"sha": "2dca67e1c4a606ffb3f6423a4b0a300b7e565898", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -145,10 +145,19 @@ package Checks is\n    --  Sets Do_Overflow_Check flag in node N, and handles possible local raise.\n    --  Always call this routine rather than calling Set_Do_Overflow_Check to\n    --  set an explicit value of True, to ensure handling the local raise case.\n-   --  Note that this call has no effect for MOD, REM, and unary \"+\" for which\n-   --  overflow is never possible in any case. In addition, we do not set the\n-   --  flag for unconstrained floating-point type operations, since we want to\n-   --  allow for the generation of IEEE infinities in such cases.\n+   --  Note that for discrete types, this call has no effect for MOD, REM, and\n+   --  unary \"+\" for which overflow is never possible in any case.\n+   --\n+   --  Note: for the discrete-type case, it is legitimate to call this routine\n+   --  on an unanalyzed node where the Etype field is not set. However, for the\n+   --  floating-point case, Etype must be set (to a floating-point type).\n+   --\n+   --  For floating-point, we set the flag if we have automatic overflow checks\n+   --  on the target, or if Check_Float_Overflow mode is set. For the floating-\n+   --  point case, we ignore all the unary operators (\"+\", \"-\", and abs) since\n+   --  none of these can result in overflow. If there are no overflow checks on\n+   --  the target, and Check_Float_Overflow mode is not set, then the call has\n+   --  no effect, since in such cases we want to generate NaN's and infinities.\n \n    procedure Activate_Range_Check (N : Node_Id);\n    pragma Inline (Activate_Range_Check);"}, {"sha": "9467154cfdaecdd148541b4d4b406122d847a60c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -1641,10 +1641,11 @@ package body Exp_Util is\n    begin\n       --  Return if no check needed\n \n-      if not Check_Float_Overflow\n-        or else not Is_Floating_Point_Type (Etype (N))\n+      if not Is_Floating_Point_Type (Etype (N))\n+        or else not (Do_Overflow_Check (N) and then Check_Float_Overflow)\n \n         --  In CodePeer_Mode, rely on the overflow check flag being set instead\n+        --  and do not expand the code for float overflow checking.\n \n         or else CodePeer_Mode\n       then\n@@ -1663,9 +1664,12 @@ package body Exp_Util is\n          Typ : constant Entity_Id  := Etype (N);\n \n       begin\n-         --  Prevent recursion\n+         --  Turn off the Do_Overflow_Check flag, since we are doing that work\n+         --  right here. We also set the node as analyzed to prevent infinite\n+         --  recursion from repeating the operation in the expansion.\n \n-         Set_Analyzed (N);\n+         Set_Do_Overflow_Check (N, False);\n+         Set_Analyzed (N, True);\n \n          --  Do the rewrite to include the check\n "}, {"sha": "672c45419a9551e19c18c2a006029397ab149144", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -827,11 +827,11 @@ package body Prj.Dect is\n       if Present (Case_Variable) then\n          String_Type := String_Type_Of (Case_Variable, In_Tree);\n \n-         if No (String_Type) then\n+         if Expression_Kind_Of (Case_Variable, In_Tree) /= Single then\n             Error_Msg (Flags,\n                        \"variable \"\"\" &\n                        Get_Name_String (Name_Of (Case_Variable, In_Tree)) &\n-                       \"\"\" is not typed\",\n+                       \"\"\" is not a single string\",\n                        Variable_Location);\n          end if;\n       end if;\n@@ -914,7 +914,8 @@ package body Prj.Dect is\n             Parse_Choice_List\n               (In_Tree      => In_Tree,\n                First_Choice => First_Choice,\n-               Flags        => Flags);\n+               Flags        => Flags,\n+               String_Type  => Present (String_Type));\n             Set_First_Choice_Of (Current_Item, In_Tree, To => First_Choice);\n \n             Expect (Tok_Arrow, \"`=>`\");\n@@ -941,7 +942,8 @@ package body Prj.Dect is\n       End_Case_Construction\n         (Check_All_Labels => not When_Others and not Quiet_Output,\n          Case_Location    => Location_Of (Case_Construction, In_Tree),\n-         Flags            => Flags);\n+         Flags            => Flags,\n+         String_Type      => Present (String_Type));\n \n       Expect (Tok_End, \"`END CASE`\");\n       Remove_Next_End_Node;"}, {"sha": "1224270f1f41a53fd62a91d9f11a3514e49f88b6", "filename": "gcc/ada/prj-strt.adb", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprj-strt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprj-strt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.adb?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -297,7 +297,8 @@ package body Prj.Strt is\n    procedure End_Case_Construction\n      (Check_All_Labels   : Boolean;\n       Case_Location      : Source_Ptr;\n-      Flags              : Processing_Flags)\n+      Flags              : Processing_Flags;\n+      String_Type        : Boolean)\n    is\n       Non_Used : Natural := 0;\n       First_Non_Used : Choice_Node_Id := First_Choice_Node_Id;\n@@ -306,35 +307,44 @@ package body Prj.Strt is\n       --  of the string type have been used.\n \n       if Check_All_Labels then\n-         for Choice in Choice_First .. Choices.Last loop\n+         if String_Type then\n+            for Choice in Choice_First .. Choices.Last loop\n                if not Choices.Table (Choice).Already_Used then\n                   Non_Used := Non_Used + 1;\n \n                   if Non_Used = 1 then\n                      First_Non_Used := Choice;\n                   end if;\n                end if;\n-         end loop;\n+            end loop;\n+\n+            --  If only one is not used, report a single warning for this value\n \n-         --  If only one is not used, report a single warning for this value\n+            if Non_Used = 1 then\n+               Error_Msg_Name_1 := Choices.Table (First_Non_Used).The_String;\n+               Error_Msg\n+                 (Flags, \"?value %% is not used as label\", Case_Location);\n \n-         if Non_Used = 1 then\n-            Error_Msg_Name_1 := Choices.Table (First_Non_Used).The_String;\n-            Error_Msg (Flags, \"?value %% is not used as label\", Case_Location);\n+               --  If several are not used, report a warning for each one of\n+               --  them.\n \n-         --  If several are not used, report a warning for each one of them\n+            elsif Non_Used > 1 then\n+               Error_Msg\n+                 (Flags, \"?the following values are not used as labels:\",\n+                  Case_Location);\n \n-         elsif Non_Used > 1 then\n+               for Choice in First_Non_Used .. Choices.Last loop\n+                  if not Choices.Table (Choice).Already_Used then\n+                     Error_Msg_Name_1 := Choices.Table (Choice).The_String;\n+                     Error_Msg (Flags, \"\\?%%\", Case_Location);\n+                  end if;\n+               end loop;\n+            end if;\n+         else\n             Error_Msg\n-              (Flags, \"?the following values are not used as labels:\",\n+              (Flags,\n+               \"?no when others for this case construction\",\n                Case_Location);\n-\n-            for Choice in First_Non_Used .. Choices.Last loop\n-               if not Choices.Table (Choice).Already_Used then\n-                  Error_Msg_Name_1 := Choices.Table (Choice).The_String;\n-                  Error_Msg (Flags, \"\\?%%\", Case_Location);\n-               end if;\n-            end loop;\n          end if;\n       end if;\n \n@@ -487,7 +497,8 @@ package body Prj.Strt is\n    procedure Parse_Choice_List\n      (In_Tree      : Project_Node_Tree_Ref;\n       First_Choice : out Project_Node_Id;\n-      Flags        : Processing_Flags)\n+      Flags        : Processing_Flags;\n+      String_Type  : Boolean := True)\n    is\n       Current_Choice : Project_Node_Id := Empty_Node;\n       Next_Choice    : Project_Node_Id := Empty_Node;\n@@ -517,38 +528,40 @@ package body Prj.Strt is\n \n          Set_String_Value_Of (Current_Choice, In_Tree, To => Choice_String);\n \n-         --  Check if the label is part of the string type and if it has not\n-         --  been already used.\n+         if String_Type then\n+            --  Check if the label is part of the string type and if it has not\n+            --  been already used.\n \n-         Found := False;\n-         for Choice in Choice_First .. Choices.Last loop\n-            if Choices.Table (Choice).The_String = Choice_String then\n+            Found := False;\n+            for Choice in Choice_First .. Choices.Last loop\n+               if Choices.Table (Choice).The_String = Choice_String then\n \n-               --  This label is part of the string type\n+                  --  This label is part of the string type\n \n-               Found := True;\n+                  Found := True;\n \n-               if Choices.Table (Choice).Already_Used then\n+                  if Choices.Table (Choice).Already_Used then\n \n-                  --  But it has already appeared in a choice list for this\n-                  --  case construction so report an error.\n+                     --  But it has already appeared in a choice list for this\n+                     --  case construction so report an error.\n \n-                  Error_Msg_Name_1 := Choice_String;\n-                  Error_Msg (Flags, \"duplicate case label %%\", Token_Ptr);\n+                     Error_Msg_Name_1 := Choice_String;\n+                     Error_Msg (Flags, \"duplicate case label %%\", Token_Ptr);\n \n-               else\n-                  Choices.Table (Choice).Already_Used := True;\n-               end if;\n+                  else\n+                     Choices.Table (Choice).Already_Used := True;\n+                  end if;\n \n-               exit;\n-            end if;\n-         end loop;\n+                  exit;\n+               end if;\n+            end loop;\n \n-         --  If the label is not part of the string list, report an error\n+            --  If the label is not part of the string list, report an error\n \n-         if not Found then\n-            Error_Msg_Name_1 := Choice_String;\n-            Error_Msg (Flags, \"illegal case label %%\", Token_Ptr);\n+            if not Found then\n+               Error_Msg_Name_1 := Choice_String;\n+               Error_Msg (Flags, \"illegal case label %%\", Token_Ptr);\n+            end if;\n          end if;\n \n          --  Scan past the label"}, {"sha": "66a96d3e6f7886524f3bb97b6c5130f5801824f1", "filename": "gcc/ada/prj-strt.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprj-strt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprj-strt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-strt.ads?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,7 +59,8 @@ private package Prj.Strt is\n    procedure End_Case_Construction\n      (Check_All_Labels   : Boolean;\n       Case_Location      : Source_Ptr;\n-      Flags              : Processing_Flags);\n+      Flags              : Processing_Flags;\n+      String_Type        : Boolean);\n    --  This procedure is called at the end of a case construction to remove the\n    --  case labels and to restore the previous state. In particular, in the\n    --  case of nested case constructions, the case labels of the enclosing case\n@@ -70,7 +71,8 @@ private package Prj.Strt is\n    procedure Parse_Choice_List\n      (In_Tree      : Project_Node_Tree_Ref;\n       First_Choice : out Project_Node_Id;\n-      Flags        : Processing_Flags);\n+      Flags        : Processing_Flags;\n+      String_Type  : Boolean := True);\n    --  Get the label for a choice list.\n    --  Report an error if\n    --    - a case label is not a literal string"}, {"sha": "06e3ac6796b45c8800c41fbc7ce6b6ccb4bec9c0", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -2403,7 +2403,7 @@ The environment variables at the time you launch @command{gprbuild}\n will influence the view these tools have of the project\n (PATH to find the compiler, ADA_PROJECT_PATH or GPR_PROJECT_PATH to find the\n projects, environment variables that are referenced in project files\n-through the \"external\" statement,...). Several command line switches\n+through the \"external\" built-in function, ...). Several command line switches\n can be used to override those (-X or -aP), but on some systems and\n with some projects, this might make the command line too long, and on\n all systems often make it hard to read.\n@@ -2427,7 +2427,7 @@ building. The syntax looks like\n @end smallexample\n \n One of the often requested features in projects is to be able to\n-reference external variables in @code{with} statements, as in\n+reference external variables in @code{with} declarations, as in\n \n @smallexample @c projectfile\n   @b{with} @b{external}(\"SETUP\") & \"path/prj.gpr\";   --@i{  ILLEGAL}\n@@ -2566,7 +2566,7 @@ Here are a few valid examples:\n @cindex @code{Project_Path}\n \n This attribute can be used to specify a list of directories in\n-which to look for project files in @code{with} statements.\n+which to look for project files in @code{with} declarations.\n \n When you specify a project in Project_Files (say @code{x/y/a.gpr}), and\n @code{a.gpr} imports a project @code{b.gpr}, only @code{b.gpr} is searched in\n@@ -2637,7 +2637,7 @@ Example:\n @cindex @code{External}\n \n This attribute can be used to set the value of environment\n-variables as retrieved through the @code{external} statement\n+variables as retrieved through the @code{external} function\n in projects. It does not affect the environment variables\n themselves (so for instance you cannot use it to change the value\n of your PATH as seen from the spawned compiler).\n@@ -3403,7 +3403,7 @@ list expression, and can therefore appear in a variable declaration or\n an attribute declaration.\n \n Most of the time, this construct is used to initialize typed variables, which\n-are then used in @b{case} statements to control the value assigned to\n+are then used in @b{case} constructions to control the value assigned to\n attributes in various scenarios. Thus such variables are often called\n @b{scenario variables}.\n \n@@ -3565,39 +3565,39 @@ A @b{context} may be one of the following:\n @c ---------------------------------------------\n \n @noindent\n-A @b{case} statement is used in a project file to effect conditional\n-behavior. Through this statement, you can set the value of attributes\n+A @b{case} construction is used in a project file to effect conditional\n+behavior. Through this construction, you can set the value of attributes\n and variables depending on the value previously assigned to a typed\n variable.\n \n All choices in a choice list must be distinct. Unlike Ada, the choice\n lists of all alternatives do not need to include all values of the type.\n An @code{others} choice must appear last in the list of alternatives.\n \n-The syntax of a @code{case} construction is based on the Ada case statement\n-(although the @code{null} statement for empty alternatives is optional).\n+The syntax of a @code{case} construction is based on the Ada case construction\n+(although the @code{null} declaration for empty alternatives is optional).\n \n-The case expression must be a typed string variable, whose value is often\n-given by an external reference (@pxref{External Values}).\n+The case expression must be a string variable, either typed or not, whose value\n+is often given by an external reference (@pxref{External Values}).\n \n Each alternative starts with the reserved word @code{when}, either a list of\n literal strings separated by the @code{\"|\"} character or the reserved word\n @code{others}, and the @code{\"=>\"} token.\n-Each literal string must belong to the string type that is the type of the\n-case variable.\n-After each @code{=>}, there are zero or more statements.  The only\n-statements allowed in a case construction are other case constructions,\n+When the case expression is a typed string variable, each literal string must\n+belong to the string type that is the type of the case variable.\n+After each @code{=>}, there are zero or more declarations.  The only\n+declarations allowed in a case construction are other case constructions,\n attribute declarations and variable declarations. String type declarations and\n package declarations are not allowed. Variable declarations are restricted to\n variables that have already been declared before the case construction.\n \n @smallexample\n-case_statement ::=\n-  @i{case} @i{<typed_variable_>}name @i{is} @{case_item@} @i{end case} ;\n+case_construction ::=\n+  @i{case} @i{<variable_>}name @i{is} @{case_item@} @i{end case} ;\n \n case_item ::=\n   @i{when} discrete_choice_list =>\n-    @{case_statement\n+    @{case_declaration\n       | attribute_declaration\n       | variable_declaration\n       | empty_declaration@}\n@@ -3606,7 +3606,7 @@ discrete_choice_list ::= string_literal @{| string_literal@} | @i{others}\n @end smallexample\n \n @noindent\n-Here is a typical example:\n+Here is a typical example, with a typed string variable:\n \n @smallexample @c projectfile\n @group"}, {"sha": "65a000f6da8400cb33109896ccce3c362490be30", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -2204,9 +2204,15 @@ package body Sem_Ch5 is\n \n       procedure Check_Predicate_Use (T : Entity_Id) is\n       begin\n+\n+         --  A predicated subtype is illegal in loops and related constructs\n+         --  if the predicate is not static, or else if it is a non-static\n+         --  subtype of a statically predicated subtype.\n+\n          if Is_Discrete_Type (T)\n            and then Has_Predicates (T)\n            and then (not Has_Static_Predicate (T)\n+                      or else not Is_Static_Subtype (T)\n                       or else Has_Dynamic_Predicate_Aspect (T))\n          then\n             Bad_Predicated_Subtype_Use"}, {"sha": "0521efb903358aed32e04961e07dd3bd29959240", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb304287342b02608f8df217b65f2a93f65ae90c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=bb304287342b02608f8df217b65f2a93f65ae90c", "patch": "@@ -2321,6 +2321,13 @@ package body Sem_Ch8 is\n          Insert_Before_And_Analyze (N, Spec_Decl);\n          Wrap_Id := Defining_Entity (Spec_Decl);\n \n+         --  If the operator carries an Eliminated pragma, indicate that the\n+         --  wrapper is also to be eliminated, to prevent spurious error when\n+         --  using gnatelim on programs that include box-initialization of\n+         --  equality operators.\n+\n+         Set_Is_Eliminated (Wrap_Id, Is_Eliminated (Prim_Op));\n+\n          --  The generated body does not freeze and must be analyzed when the\n          --  class-wide wrapper is frozen. The body is only needed if expansion\n          --  is enabled."}]}