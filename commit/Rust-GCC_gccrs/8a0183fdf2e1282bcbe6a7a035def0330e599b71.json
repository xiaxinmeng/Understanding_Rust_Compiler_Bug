{"sha": "8a0183fdf2e1282bcbe6a7a035def0330e599b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEwMTgzZmRmMmUxMjgyYmNiZTZhN2EwMzVkZWYwMzMwZTU5OWI3MQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-11-12T11:15:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-12T11:15:12Z"}, "message": "contracts.adb (Analyze_Entry_Or_Subprogram_Body_Contract): Remove the guard concerning entry bodies as it is spurious.\n\n2015-11-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* contracts.adb (Analyze_Entry_Or_Subprogram_Body_Contract):\n\tRemove the guard concerning entry bodies as it is spurious.\n\t(Analyze_Entry_Or_Subprogram_Contract): Skip the analysis of\n\tContract_Cases when not annotating the tree.\n\t* einfo.adb: Node25 is now used as Contract_Wrapper.\n\t(Contract_Wrapper): New routine.\n\t(PPC_Wrapper): Removed.\n\t(Set_Contract_Wrapper): New routine.\n\t(Set_PPC_Wrapper): Removed.\n\t(Write_Field25_Name): Add output for Contract_Wrapper. Remove\n\toutput for PPC_Wrapper.\n\t* einfo.ads: New attribute Contract_Wrapper along with usage\n\tin entities. Remove attribute PPC_Wrapper along with usage in nodes.\n\t(Contract_Wrapper): New routine along with pragma Inline.\n\t(PPC_Wrapper): Removed along with pragma Inline.\n\t(Set_Contract_Wrapper): New routine along with pragma Inline.\n\t(Set_PPC_Wrapper): Removed along with pragma Inline.\n\t* exp_ch9.adb (Build_Contract_Wrapper): New routine.\n\t(Build_PPC_Wrapper): Removed.\n\t(Build_Protected_Entry): Code cleanup.\n\t(Expand_Entry_Declaration): Create a contract wrapper\n\twhich now verifies Contract_Cases along with pre/postconditions.\n\t(Expand_N_Task_Type_Declaration): There is no need to check\n\twhether an entry has pre/postconditions as this is now done\n\tin Build_Contract_Wrapper.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Pragma\n\tRefined_Post is now properly inserted in entry bodies.\n\t(Insert_Pragma): Add circuitry to insert in an entry body. Redo\n\tthe instance \"header\" circuitry. Remove the now obsolete special\n\tcase of inserting pre- conditions.\n\t* sem_prag.adb (Analyze_Pragma): Pragma Contract_Cases now\n\tapplies to entries.\n\t* sem_res.adb (Resolve_Entry_Call): Update the calls to\n\tPPC_Wrapper.\n\nFrom-SVN: r230236", "tree": {"sha": "e64bca4ccba2bae360c698b80118fc5438cfdf20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e64bca4ccba2bae360c698b80118fc5438cfdf20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a0183fdf2e1282bcbe6a7a035def0330e599b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0183fdf2e1282bcbe6a7a035def0330e599b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a0183fdf2e1282bcbe6a7a035def0330e599b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a0183fdf2e1282bcbe6a7a035def0330e599b71/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d6dffa6695731c28a5a1e6d64c897680f761496c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dffa6695731c28a5a1e6d64c897680f761496c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6dffa6695731c28a5a1e6d64c897680f761496c"}], "stats": {"total": 814, "additions": 474, "deletions": 340}, "files": [{"sha": "63c4f3af4faf2b3741ec6d9a35c723e88173ec59", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -1,3 +1,40 @@\n+2015-11-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.adb (Analyze_Entry_Or_Subprogram_Body_Contract):\n+\tRemove the guard concerning entry bodies as it is spurious.\n+\t(Analyze_Entry_Or_Subprogram_Contract): Skip the analysis of\n+\tContract_Cases when not annotating the tree.\n+\t* einfo.adb: Node25 is now used as Contract_Wrapper.\n+\t(Contract_Wrapper): New routine.\n+\t(PPC_Wrapper): Removed.\n+\t(Set_Contract_Wrapper): New routine.\n+\t(Set_PPC_Wrapper): Removed.\n+\t(Write_Field25_Name): Add output for Contract_Wrapper. Remove\n+\toutput for PPC_Wrapper.\n+\t* einfo.ads: New attribute Contract_Wrapper along with usage\n+\tin entities. Remove attribute PPC_Wrapper along with usage in nodes.\n+\t(Contract_Wrapper): New routine along with pragma Inline.\n+\t(PPC_Wrapper): Removed along with pragma Inline.\n+\t(Set_Contract_Wrapper): New routine along with pragma Inline.\n+\t(Set_PPC_Wrapper): Removed along with pragma Inline.\n+\t* exp_ch9.adb (Build_Contract_Wrapper): New routine.\n+\t(Build_PPC_Wrapper): Removed.\n+\t(Build_Protected_Entry): Code cleanup.\n+\t(Expand_Entry_Declaration): Create a contract wrapper\n+\twhich now verifies Contract_Cases along with pre/postconditions.\n+\t(Expand_N_Task_Type_Declaration): There is no need to check\n+\twhether an entry has pre/postconditions as this is now done\n+\tin Build_Contract_Wrapper.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Pragma\n+\tRefined_Post is now properly inserted in entry bodies.\n+\t(Insert_Pragma): Add circuitry to insert in an entry body. Redo\n+\tthe instance \"header\" circuitry. Remove the now obsolete special\n+\tcase of inserting pre- conditions.\n+\t* sem_prag.adb (Analyze_Pragma): Pragma Contract_Cases now\n+\tapplies to entries.\n+\t* sem_res.adb (Resolve_Entry_Call): Update the calls to\n+\tPPC_Wrapper.\n+\n 2015-11-12  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_attr.adb, freeze.adb, sem_util.adb, sem_ch13.adb: Minor"}, {"sha": "64960c1cac506c085890d5be3f2c42baad839ef7", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -366,17 +366,6 @@ package body Contracts is\n       if Ekind (Body_Id) = E_Void then\n          return;\n \n-      --  Do not analyze the contract of an entry body unless annotating the\n-      --  original tree. It is preferable to analyze the contract after the\n-      --  entry body has been transformed into a subprogram body to properly\n-      --  handle references to unpacked formals.\n-\n-      elsif Ekind_In (Body_Id, E_Entry, E_Entry_Family)\n-        and then not ASIS_Mode\n-        and then not GNATprove_Mode\n-      then\n-         return;\n-\n       --  Do not analyze a contract multiple times\n \n       elsif Present (Items) then\n@@ -442,11 +431,17 @@ package body Contracts is\n    procedure Analyze_Entry_Or_Subprogram_Contract (Subp_Id : Entity_Id) is\n       Items     : constant Node_Id := Contract (Subp_Id);\n       Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n-      Depends   : Node_Id := Empty;\n-      Global    : Node_Id := Empty;\n-      Mode      : SPARK_Mode_Type;\n-      Prag      : Node_Id;\n-      Prag_Nam  : Name_Id;\n+\n+      Skip_Assert_Exprs : constant Boolean :=\n+                            Ekind_In (Subp_Id, E_Entry, E_Entry_Family)\n+                              and then not ASIS_Mode\n+                              and then not GNATprove_Mode;\n+\n+      Depends  : Node_Id := Empty;\n+      Global   : Node_Id := Empty;\n+      Mode     : SPARK_Mode_Type;\n+      Prag     : Node_Id;\n+      Prag_Nam : Name_Id;\n \n    begin\n       --  Do not analyze a contract multiple times\n@@ -475,17 +470,11 @@ package body Contracts is\n       elsif Present (Items) then\n \n          --  Do not analyze the pre/postconditions of an entry declaration\n-         --  unless annotating the original tree for ASIS or GNATprove.\n+         --  unless annotating the original tree for ASIS or GNATprove. The\n+         --  real analysis occurs when the pre/postconditons are relocated to\n+         --  the contract wrapper procedure (see Build_Contract_Wrapper).\n \n-         --  ??? References to formals are causing problems during contract\n-         --  expansion as the references resolve to the entry formals, not\n-         --  the subprogram body emulating the entry body. This will have to\n-         --  be addressed.\n-\n-         if Ekind_In (Subp_Id, E_Entry, E_Entry_Family)\n-           and then not ASIS_Mode\n-           and then not GNATprove_Mode\n-         then\n+         if Skip_Assert_Exprs then\n             null;\n \n          --  Otherwise analyze the pre/postconditions\n@@ -505,7 +494,20 @@ package body Contracts is\n             Prag_Nam := Pragma_Name (Prag);\n \n             if Prag_Nam = Name_Contract_Cases then\n-               Analyze_Contract_Cases_In_Decl_Part (Prag);\n+\n+               --  Do not analyze the contract cases of an entry declaration\n+               --  unless annotating the original tree for ASIS or GNATprove.\n+               --  The real analysis occurs when the contract cases are moved\n+               --  to the contract wrapper procedure (Build_Contract_Wrapper).\n+\n+               if Skip_Assert_Exprs then\n+                  null;\n+\n+               --  Otherwise analyze the contract cases\n+\n+               else\n+                  Analyze_Contract_Cases_In_Decl_Part (Prag);\n+               end if;\n             else\n                pragma Assert (Prag_Nam = Name_Test_Case);\n                Analyze_Test_Case_In_Decl_Part (Prag);"}, {"sha": "e8ee8730f9c2da2a5bc04a3abcb9023682538084", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -216,11 +216,11 @@ package body Einfo is\n    --    Related_Expression              Node24\n    --    Subps_Index                     Uint24\n \n+   --    Contract_Wrapper                Node25\n    --    Debug_Renaming_Link             Node25\n    --    DT_Offset_To_Top_Func           Node25\n    --    Interface_Alias                 Node25\n    --    Interfaces                      Elist25\n-   --    PPC_Wrapper                     Node25\n    --    Related_Array_Object            Node25\n    --    Static_Discrete_Predicate       List25\n    --    Static_Real_Or_String_Predicate Node25\n@@ -1231,6 +1231,12 @@ package body Einfo is\n       return Node34 (Id);\n    end Contract;\n \n+   function Contract_Wrapper (Id : E) return E is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Entry, E_Entry_Family));\n+      return Node25 (Id);\n+   end Contract_Wrapper;\n+\n    function Entry_Parameters_Type (Id : E) return E is\n    begin\n       return Node15 (Id);\n@@ -2876,12 +2882,6 @@ package body Einfo is\n       return Node14 (Id);\n    end Postconditions_Proc;\n \n-   function PPC_Wrapper (Id : E) return E is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Entry, E_Entry_Family));\n-      return Node25 (Id);\n-   end PPC_Wrapper;\n-\n    function Prival (Id : E) return E is\n    begin\n       pragma Assert (Is_Protected_Component (Id));\n@@ -3877,6 +3877,12 @@ package body Einfo is\n       Set_Node34 (Id, V);\n    end Set_Contract;\n \n+   procedure Set_Contract_Wrapper (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Entry, E_Entry_Family));\n+      Set_Node25 (Id, V);\n+   end Set_Contract_Wrapper;\n+\n    procedure Set_Corresponding_Concurrent_Type (Id : E; V : E) is\n    begin\n       pragma Assert\n@@ -5912,12 +5918,6 @@ package body Einfo is\n       Set_Node14 (Id, V);\n    end Set_Postconditions_Proc;\n \n-   procedure Set_PPC_Wrapper (Id : E; V : E) is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Entry, E_Entry_Family));\n-      Set_Node25 (Id, V);\n-   end Set_PPC_Wrapper;\n-\n    procedure Set_Direct_Primitive_Operations (Id : E; V : L) is\n    begin\n       pragma Assert (Is_Tagged_Type (Id));\n@@ -10003,6 +10003,10 @@ package body Einfo is\n               E_Package                                    =>\n             Write_Str (\"Abstract_States\");\n \n+         when E_Entry                                      |\n+              E_Entry_Family                               =>\n+            Write_Str (\"Contract_Wrapper\");\n+\n          when E_Variable                                   =>\n             Write_Str (\"Debug_Renaming_Link\");\n \n@@ -10026,10 +10030,6 @@ package body Einfo is\n          when Task_Kind                                    =>\n             Write_Str (\"Task_Body_Procedure\");\n \n-         when E_Entry                                      |\n-              E_Entry_Family                               =>\n-            Write_Str (\"PPC_Wrapper\");\n-\n          when Discrete_Kind                                =>\n             Write_Str (\"Static_Discrete_Predicate\");\n "}, {"sha": "31059fd2bc6fc1a6783b8a1ac17731d66171ff2f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -714,6 +714,12 @@ package Einfo is\n --       variable and task type entities. Points to the contract of the entity,\n --       holding various assertion items and data classifiers.\n \n+--    Contract_Wrapper (Node25)\n+--       Defined in entry and entry family entities. Set only when the entry\n+--       [family] has contract cases, preconditions, and/or postconditions.\n+--       Contains the entity of a wrapper procedure which encapsulates the\n+--       original entry and implements precondition/postcondition semantics.\n+\n --    Corresponding_Concurrent_Type (Node18)\n --       Defined in record types that are constructed by the expander to\n --       represent task and protected types (Is_Concurrent_Record_Type flag\n@@ -3639,7 +3645,7 @@ package Einfo is\n \n --    Overlays_Constant (Flag243)\n --       Defined in all entities. Set only for E_Constant or E_Variable for\n---       which there is an address clause which causes the entity to overlay\n+--       which there is an address clause that causes the entity to overlay\n --       a constant object.\n \n --    Overridden_Operation (Node26)\n@@ -3707,11 +3713,6 @@ package Einfo is\n --       to the entity of the _Postconditions procedure used to check contract\n --       assertions on exit from a subprogram.\n \n---    PPC_Wrapper (Node25)\n---       Defined in entries and entry families. Set only if pre- or post-\n---       conditions are present. The precondition_wrapper body is the original\n---       entry call, decorated with the given precondition for the entry.\n-\n --    Predicate_Function (synthesized)\n --       Defined in all types. Set for types for which (Has_Predicates is True)\n --       and for which a predicate procedure has been built that tests that the\n@@ -5758,7 +5759,7 @@ package Einfo is\n    --    Accept_Address                      (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n    --    Protection_Object                   (Node23)   (protected kind)\n-   --    PPC_Wrapper                         (Node25)\n+   --    Contract_Wrapper                    (Node25)\n    --    Extra_Formals                       (Node28)\n    --    Contract                            (Node34)\n    --    SPARK_Pragma                        (Node40)   (protected kind)\n@@ -6751,6 +6752,7 @@ package Einfo is\n    function Component_Type                      (Id : E) return E;\n    function Contains_Ignored_Ghost_Code         (Id : E) return B;\n    function Contract                            (Id : E) return N;\n+   function Contract_Wrapper                    (Id : E) return E;\n    function Corresponding_Concurrent_Type       (Id : E) return E;\n    function Corresponding_Discriminant          (Id : E) return E;\n    function Corresponding_Equality              (Id : E) return E;\n@@ -7089,7 +7091,6 @@ package Einfo is\n    function Partial_View_Has_Unknown_Discr      (Id : E) return B;\n    function Pending_Access_Types                (Id : E) return L;\n    function Postconditions_Proc                 (Id : E) return E;\n-   function PPC_Wrapper                         (Id : E) return E;\n    function Prival                              (Id : E) return E;\n    function Prival_Link                         (Id : E) return E;\n    function Private_Dependents                  (Id : E) return L;\n@@ -7415,6 +7416,7 @@ package Einfo is\n    procedure Set_Component_Type                  (Id : E; V : E);\n    procedure Set_Contains_Ignored_Ghost_Code     (Id : E; V : B := True);\n    procedure Set_Contract                        (Id : E; V : N);\n+   procedure Set_Contract_Wrapper                (Id : E; V : E);\n    procedure Set_Corresponding_Concurrent_Type   (Id : E; V : E);\n    procedure Set_Corresponding_Discriminant      (Id : E; V : E);\n    procedure Set_Corresponding_Equality          (Id : E; V : E);\n@@ -7756,7 +7758,6 @@ package Einfo is\n    procedure Set_Partial_View_Has_Unknown_Discr  (Id : E; V : B := True);\n    procedure Set_Pending_Access_Types            (Id : E; V : L);\n    procedure Set_Postconditions_Proc             (Id : E; V : E);\n-   procedure Set_PPC_Wrapper                     (Id : E; V : E);\n    procedure Set_Prival                          (Id : E; V : E);\n    procedure Set_Prival_Link                     (Id : E; V : E);\n    procedure Set_Private_Dependents              (Id : E; V : L);\n@@ -8194,6 +8195,7 @@ package Einfo is\n    pragma Inline (Component_Type);\n    pragma Inline (Contains_Ignored_Ghost_Code);\n    pragma Inline (Contract);\n+   pragma Inline (Contract_Wrapper);\n    pragma Inline (Corresponding_Concurrent_Type);\n    pragma Inline (Corresponding_Discriminant);\n    pragma Inline (Corresponding_Equality);\n@@ -8578,7 +8580,6 @@ package Einfo is\n    pragma Inline (Partial_View_Has_Unknown_Discr);\n    pragma Inline (Pending_Access_Types);\n    pragma Inline (Postconditions_Proc);\n-   pragma Inline (PPC_Wrapper);\n    pragma Inline (Prival);\n    pragma Inline (Prival_Link);\n    pragma Inline (Private_Dependents);\n@@ -8702,6 +8703,7 @@ package Einfo is\n    pragma Inline (Set_Component_Type);\n    pragma Inline (Set_Contains_Ignored_Ghost_Code);\n    pragma Inline (Set_Contract);\n+   pragma Inline (Set_Contract_Wrapper);\n    pragma Inline (Set_Corresponding_Concurrent_Type);\n    pragma Inline (Set_Corresponding_Discriminant);\n    pragma Inline (Set_Corresponding_Equality);\n@@ -9039,7 +9041,6 @@ package Einfo is\n    pragma Inline (Set_Partial_View_Has_Unknown_Discr);\n    pragma Inline (Set_Pending_Access_Types);\n    pragma Inline (Set_Postconditions_Proc);\n-   pragma Inline (Set_PPC_Wrapper);\n    pragma Inline (Set_Prival);\n    pragma Inline (Set_Prival_Link);\n    pragma Inline (Set_Private_Dependents);"}, {"sha": "2fd65927401552078d20c4c616ae6abfda3120da", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 338, "deletions": 229, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -128,6 +128,15 @@ package body Exp_Ch9 is\n    --  Build a specification for a function implementing the protected entry\n    --  barrier of the specified entry body.\n \n+   procedure Build_Contract_Wrapper (E : Entity_Id; Decl : Node_Id);\n+   --  Build the body of a wrapper procedure for an entry or entry family that\n+   --  has contract cases, preconditions, or postconditions. The body gathers\n+   --  the executable contract items and expands them in the usual way, and\n+   --  performs the entry call itself. This way preconditions are evaluated\n+   --  before the call is queued. E is the entry in question, and Decl is the\n+   --  enclosing synchronized type declaration at whose freeze point the\n+   --  generated body is analyzed.\n+\n    function Build_Corresponding_Record\n      (N    : Node_Id;\n       Ctyp : Node_Id;\n@@ -197,14 +206,6 @@ package body Exp_Ch9 is\n    --       <formalN> : AnnN;\n    --    end record;\n \n-   procedure Build_PPC_Wrapper (E : Entity_Id; Decl : Node_Id);\n-   --  Build body of wrapper procedure for an entry or entry family that has\n-   --  pre/postconditions. The body gathers the PPC's and expands them in the\n-   --  usual way, and performs the entry call itself. This way preconditions\n-   --  are evaluated before the call is queued. E is the entry in question,\n-   --  and Decl is the enclosing synchronized type declaration at whose freeze\n-   --  point the generated body is analyzed.\n-\n    function Build_Protected_Entry\n      (N   : Node_Id;\n       Ent : Entity_Id;\n@@ -409,7 +410,7 @@ package body Exp_Ch9 is\n       Context_Decls : out List_Id);\n    --  Subsidiary routine to procedures Build_Activation_Chain_Entity and\n    --  Build_Master_Entity. Given an arbitrary node in the tree, find the\n-   --  nearest enclosing body, block, package or return statement and return\n+   --  nearest enclosing body, block, package, or return statement and return\n    --  its constituents. Context is the enclosing construct, Context_Id is\n    --  the scope of Context_Id and Context_Decls is the declarative list of\n    --  Context.\n@@ -1218,6 +1219,276 @@ package body Exp_Ch9 is\n       Set_Master_Id (Typ, Master_Id);\n    end Build_Class_Wide_Master;\n \n+   ----------------------------\n+   -- Build_Contract_Wrapper --\n+   ----------------------------\n+\n+   procedure Build_Contract_Wrapper (E : Entity_Id; Decl : Node_Id) is\n+      Conc_Typ : constant Entity_Id  := Scope (E);\n+      Loc      : constant Source_Ptr := Sloc (E);\n+\n+      procedure Add_Discriminant_Renamings\n+        (Obj_Id : Entity_Id;\n+         Decls  : List_Id);\n+      --  Add renaming declarations for all discriminants of concurrent type\n+      --  Conc_Typ. Obj_Id is the entity of the wrapper formal parameter which\n+      --  represents the concurrent object.\n+\n+      procedure Add_Matching_Formals (Formals : List_Id; Actuals : List_Id);\n+      --  Add formal parameters that match those of entry E to list Formals.\n+      --  The routine also adds matching actuals for the new formals to list\n+      --  Actuals.\n+\n+      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id);\n+      --  Relocate pragma Prag to list To. The routine creates a new list if\n+      --  To does not exist.\n+\n+      --------------------------------\n+      -- Add_Discriminant_Renamings --\n+      --------------------------------\n+\n+      procedure Add_Discriminant_Renamings\n+        (Obj_Id : Entity_Id;\n+         Decls  : List_Id)\n+      is\n+         Discr : Entity_Id;\n+\n+      begin\n+         --  Inspect the discriminants of the concurrent type and generate a\n+         --  renaming for each one.\n+\n+         if Has_Discriminants (Conc_Typ) then\n+            Discr := First_Discriminant (Conc_Typ);\n+            while Present (Discr) loop\n+               Prepend_To (Decls,\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Chars (Discr)),\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (Etype (Discr), Loc),\n+                   Name                =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Chars (Discr)))));\n+\n+               Next_Discriminant (Discr);\n+            end loop;\n+         end if;\n+      end Add_Discriminant_Renamings;\n+\n+      --------------------------\n+      -- Add_Matching_Formals --\n+      --------------------------\n+\n+      procedure Add_Matching_Formals (Formals : List_Id; Actuals : List_Id) is\n+         Formal     : Entity_Id;\n+         New_Formal : Entity_Id;\n+\n+      begin\n+         --  Inspect the formal parameters of the entry and generate a new\n+         --  matching formal with the same name for the wrapper. A reference\n+         --  to the new formal becomes an actual in the entry call.\n+\n+         Formal := First_Formal (E);\n+         while Present (Formal) loop\n+            New_Formal := Make_Defining_Identifier (Loc, Chars (Formal));\n+            Append_To (Formals,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => New_Formal,\n+                In_Present          => In_Present  (Parent (Formal)),\n+                Out_Present         => Out_Present (Parent (Formal)),\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (Etype (Formal), Loc)));\n+\n+            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n+            Next_Formal (Formal);\n+         end loop;\n+      end Add_Matching_Formals;\n+\n+      ---------------------\n+      -- Transfer_Pragma --\n+      ---------------------\n+\n+      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id) is\n+         New_Prag : Node_Id;\n+\n+      begin\n+         if No (To) then\n+            To := New_List;\n+         end if;\n+\n+         New_Prag := Relocate_Node (Prag);\n+\n+         Set_Analyzed (New_Prag, False);\n+         Append       (New_Prag, To);\n+      end Transfer_Pragma;\n+\n+      --  Local variables\n+\n+      Items      : constant Node_Id := Contract (E);\n+      Actuals    : List_Id;\n+      Call       : Node_Id;\n+      Call_Nam   : Node_Id;\n+      Decls      : List_Id := No_List;\n+      Formals    : List_Id;\n+      Has_Pragma : Boolean := False;\n+      Index_Id   : Entity_Id;\n+      Obj_Id     : Entity_Id;\n+      Prag       : Node_Id;\n+      Wrapper_Id : Entity_Id;\n+\n+   --  Start of processing for Build_Contract_Wrapper\n+\n+   begin\n+      --  This routine generates a specialized wrapper for a protected or task\n+      --  entry [family] which implements precondition/postcondition semantics.\n+      --  Preconditions and case guards of contract cases are checked before\n+      --  the protected action or rendezvous takes place. Postconditions and\n+      --  consequences of contract cases are checked after the protected action\n+      --  or rendezvous takes place. The structure of the generated wrapper is\n+      --  as follows:\n+\n+      --    procedure Wrapper\n+      --      (Obj_Id    : Conc_Typ;    --  concurrent object\n+      --       [Index    : Index_Typ;]  --  index of entry family\n+      --       [Formal_1 : ...;         --  parameters of original entry\n+      --        Formal_N : ...])\n+      --    is\n+      --       [Discr_1 : ... renames Obj_Id.Discr_1;   --  discriminant\n+      --        Discr_N : ... renames Obj_Id.Discr_N;]  --  renamings\n+\n+      --       <precondition checks>\n+      --       <case guard checks>\n+\n+      --       procedure _Postconditions is\n+      --       begin\n+      --          <postcondition checks>\n+      --          <consequence checks>\n+      --       end _Postconditions;\n+\n+      --    begin\n+      --       Entry_Call (Obj_Id, [Index,] [Formal_1, Formal_N]);\n+      --       _Postconditions;\n+      --    end Wrapper;\n+\n+      --  Create the wrapper only when the entry has at least one executable\n+      --  contract item such as contract cases, precondition or postcondition.\n+\n+      if Present (Items) then\n+\n+         --  Inspect the list of pre/postconditions and transfer all available\n+         --  pragmas to the declarative list of the wrapper.\n+\n+         Prag := Pre_Post_Conditions (Items);\n+         while Present (Prag) loop\n+            if Nam_In (Pragma_Name (Prag), Name_Postcondition,\n+                                           Name_Precondition)\n+            then\n+               Has_Pragma := True;\n+               Transfer_Pragma (Prag, To => Decls);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Inspect the list of test/contract cases and transfer only contract\n+         --  cases pragmas to the declarative part of the wrapper.\n+\n+         Prag := Contract_Test_Cases (Items);\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Contract_Cases then\n+               Has_Pragma := True;\n+               Transfer_Pragma (Prag, To => Decls);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  The entry lacks executable contract items and a wrapper is not needed\n+\n+      if not Has_Pragma then\n+         return;\n+      end if;\n+\n+      --  Create the profile of the wrapper. The first formal parameter is the\n+      --  concurrent object.\n+\n+      Obj_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Conc_Typ), 'A'));\n+\n+      Formals := New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Obj_Id,\n+          Out_Present         => True,\n+          In_Present          => True,\n+          Parameter_Type      => New_Occurrence_Of (Conc_Typ, Loc)));\n+\n+      --  Construct the call to the original entry. The call will be gradually\n+      --  augmented with an optional entry index and extra parameters.\n+\n+      Call_Nam :=\n+        Make_Selected_Component (Loc,\n+          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+          Selector_Name => New_Occurrence_Of (E, Loc));\n+\n+      --  When creating a wrapper for an entry family, the second formal is the\n+      --  entry index.\n+\n+      if Ekind (E) = E_Entry_Family then\n+         Index_Id := Make_Defining_Identifier (Loc, Name_I);\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Index_Id,\n+             Parameter_Type      =>\n+               New_Occurrence_Of (Entry_Index_Type (E), Loc)));\n+\n+         --  The call to the original entry becomes an indexed component to\n+         --  accommodate the entry index.\n+\n+         Call_Nam :=\n+           Make_Indexed_Component (Loc,\n+             Prefix      => Call_Nam,\n+             Expressions => New_List (New_Occurrence_Of (Index_Id, Loc)));\n+      end if;\n+\n+      Actuals := New_List;\n+      Call    :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => Call_Nam,\n+          Parameter_Associations => Actuals);\n+\n+      --  Add formal parameters to match those of the entry and build actuals\n+      --  for the entry call.\n+\n+      Add_Matching_Formals (Formals, Actuals);\n+\n+      --  Add renaming declarations for the discriminants of the enclosing type\n+      --  as the various contract items may reference them.\n+\n+      Add_Discriminant_Renamings (Obj_Id, Decls);\n+\n+      Wrapper_Id :=\n+        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n+      Set_Contract_Wrapper (E, Wrapper_Id);\n+\n+      --  The wrapper body is analyzed when the enclosing type is frozen\n+\n+      Append_Freeze_Action (Defining_Entity (Decl),\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Wrapper_Id,\n+              Parameter_Specifications => Formals),\n+          Declarations               => Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Call))));\n+   end Build_Contract_Wrapper;\n+\n    --------------------------------\n    -- Build_Corresponding_Record --\n    --------------------------------\n@@ -1925,166 +2196,6 @@ package body Exp_Ch9 is\n       return Decl;\n    end Build_Renamed_Formal_Declaration;\n \n-   -----------------------\n-   -- Build_PPC_Wrapper --\n-   -----------------------\n-\n-   procedure Build_PPC_Wrapper (E : Entity_Id; Decl : Node_Id) is\n-      Items      : constant Node_Id    := Contract (E);\n-      Loc        : constant Source_Ptr := Sloc (E);\n-      Synch_Type : constant Entity_Id  := Scope (E);\n-      Actuals    : List_Id;\n-      Decls      : List_Id;\n-      Entry_Call : Node_Id;\n-      Entry_Name : Node_Id;\n-      Params     : List_Id;\n-      Prag       : Node_Id;\n-      Synch_Id   : Entity_Id;\n-      Wrapper_Id : Entity_Id;\n-\n-   begin\n-      --  Only build the wrapper if entry has pre/postconditions\n-      --  Should this be done unconditionally instead ???\n-\n-      if Present (Items) then\n-         Prag := Pre_Post_Conditions (Items);\n-\n-         if No (Prag) then\n-            return;\n-         end if;\n-\n-         --  Transfer ppc pragmas to the declarations of the wrapper\n-\n-         Decls := New_List;\n-\n-         while Present (Prag) loop\n-            if Nam_In (Pragma_Name (Prag), Name_Precondition,\n-                                           Name_Postcondition)\n-            then\n-               Append (Relocate_Node (Prag), Decls);\n-               Set_Analyzed (Last (Decls), False);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      else\n-         return;\n-      end if;\n-\n-      Actuals  := New_List;\n-      Synch_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Scope (E)), 'A'));\n-\n-      --  First formal is synchronized object\n-\n-      Params := New_List (\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => Synch_Id,\n-          Out_Present         => True,\n-          In_Present          => True,\n-          Parameter_Type      => New_Occurrence_Of (Scope (E), Loc)));\n-\n-      Entry_Name :=\n-        Make_Selected_Component (Loc,\n-          Prefix        => New_Occurrence_Of (Synch_Id, Loc),\n-          Selector_Name => New_Occurrence_Of (E, Loc));\n-\n-      --  If entity is entry family, second formal is the corresponding index,\n-      --  and entry name is an indexed component.\n-\n-      if Ekind (E) = E_Entry_Family then\n-         declare\n-            Index : constant Entity_Id :=\n-                      Make_Defining_Identifier (Loc, Name_I);\n-         begin\n-            Append_To (Params,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Index,\n-                Parameter_Type      =>\n-                  New_Occurrence_Of (Entry_Index_Type (E), Loc)));\n-\n-            Entry_Name :=\n-              Make_Indexed_Component (Loc,\n-                Prefix      => Entry_Name,\n-                Expressions => New_List (New_Occurrence_Of (Index, Loc)));\n-         end;\n-      end if;\n-\n-      Entry_Call :=\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   => Entry_Name,\n-          Parameter_Associations => Actuals);\n-\n-      --  Now add formals that match those of the entry, and build actuals for\n-      --  the nested entry call.\n-\n-      declare\n-         Form      : Entity_Id;\n-         New_Form  : Entity_Id;\n-         Parm_Spec : Node_Id;\n-\n-      begin\n-         Form := First_Formal (E);\n-         while Present (Form) loop\n-            New_Form := Make_Defining_Identifier (Loc, Chars (Form));\n-            Parm_Spec :=\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => New_Form,\n-                Out_Present         => Out_Present (Parent (Form)),\n-                In_Present          => In_Present  (Parent (Form)),\n-                Parameter_Type      => New_Occurrence_Of (Etype (Form), Loc));\n-\n-            Append (Parm_Spec, Params);\n-            Append (New_Occurrence_Of (New_Form, Loc), Actuals);\n-            Next_Formal (Form);\n-         end loop;\n-      end;\n-\n-      --  Add renaming declarations for the discriminants of the enclosing\n-      --  type, which may be visible in the preconditions.\n-\n-      if Has_Discriminants (Synch_Type) then\n-         declare\n-            D : Entity_Id;\n-            Decl : Node_Id;\n-\n-         begin\n-            D := First_Discriminant (Synch_Type);\n-            while Present (D) loop\n-               Decl :=\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Chars (D)),\n-                   Subtype_Mark        => New_Occurrence_Of (Etype (D), Loc),\n-                   Name                =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => New_Occurrence_Of (Synch_Id, Loc),\n-                       Selector_Name => Make_Identifier (Loc, Chars (D))));\n-               Prepend (Decl, Decls);\n-               Next_Discriminant (D);\n-            end loop;\n-         end;\n-      end if;\n-\n-      Wrapper_Id :=\n-        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n-      Set_PPC_Wrapper (E, Wrapper_Id);\n-\n-      --  The wrapper body is analyzed when the enclosing type is frozen\n-\n-      Append_Freeze_Action (Defining_Entity (Decl),\n-        Make_Subprogram_Body (Loc,\n-          Specification              =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Wrapper_Id,\n-              Parameter_Specifications => Params),\n-          Declarations               => Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Entry_Call))));\n-   end Build_PPC_Wrapper;\n-\n    --------------------------\n    -- Build_Wrapper_Bodies --\n    --------------------------\n@@ -3214,7 +3325,7 @@ package body Exp_Ch9 is\n    --  Start of processing for Build_Lock_Free_Unprotected_Subprogram_Body\n \n    begin\n-      --  Add renamings for the protection object, discriminals, privals and\n+      --  Add renamings for the protection object, discriminals, privals, and\n       --  the entry index constant for use by debugger.\n \n       Debug_Private_Data_Declarations (Decls);\n@@ -3619,7 +3730,7 @@ package body Exp_Ch9 is\n          Decls      := List_Containing (Context);\n \n       --  Default case for object declarations and access types. Note that the\n-      --  context is updated to the nearest enclosing body, block, package or\n+      --  context is updated to the nearest enclosing body, block, package, or\n       --  return statement.\n \n       else\n@@ -3810,43 +3921,42 @@ package body Exp_Ch9 is\n       Ent : Entity_Id;\n       Pid : Node_Id) return Node_Id\n    is\n+      Bod_Decls : constant List_Id := New_List;\n+      Decls     : constant List_Id := Declarations (N);\n+      End_Lab   : constant Node_Id :=\n+                    End_Label (Handled_Statement_Sequence (N));\n+      End_Loc   : constant Source_Ptr :=\n+                    Sloc (Last (Statements (Handled_Statement_Sequence (N))));\n+      --  Used for the generated call to Complete_Entry_Body\n+\n       Loc : constant Source_Ptr := Sloc (N);\n \n-      Decls   : constant List_Id := Declarations (N);\n-      End_Lab : constant Node_Id :=\n-                  End_Label (Handled_Statement_Sequence (N));\n-      End_Loc : constant Source_Ptr :=\n-                  Sloc (Last (Statements (Handled_Statement_Sequence (N))));\n-      --  Used for the generated call to Complete_Entry_Body\n+      Bod_Id    : Entity_Id;\n+      Bod_Spec  : Node_Id;\n+      Bod_Stmts : List_Id;\n+      Complete  : Node_Id;\n+      Ohandle   : Node_Id;\n \n-      Han_Loc : Source_Ptr;\n+      EH_Loc : Source_Ptr;\n       --  Used for the exception handler, inserted at end of the body\n \n-      Op_Decls : constant List_Id := New_List;\n-      Complete : Node_Id;\n-      Edef     : Entity_Id;\n-      Espec    : Node_Id;\n-      Ohandle  : Node_Id;\n-      Op_Stats : List_Id;\n-\n    begin\n       --  Set the source location on the exception handler only when debugging\n       --  the expanded code (see Make_Implicit_Exception_Handler).\n \n       if Debug_Generated_Code then\n-         Han_Loc := End_Loc;\n+         EH_Loc := End_Loc;\n \n       --  Otherwise the inserted code should not be visible to the debugger\n \n       else\n-         Han_Loc := No_Location;\n+         EH_Loc := No_Location;\n       end if;\n \n-      Edef :=\n+      Bod_Id :=\n         Make_Defining_Identifier (Loc,\n           Chars => Chars (Protected_Body_Subprogram (Ent)));\n-      Espec :=\n-        Build_Protected_Entry_Specification (Loc, Edef, Empty);\n+      Bod_Spec := Build_Protected_Entry_Specification (Loc, Bod_Id, Empty);\n \n       --  Add the following declarations:\n \n@@ -3856,26 +3966,25 @@ package body Exp_Ch9 is\n       --  where _O is the formal parameter associated with the concurrent\n       --  object. These declarations are needed for Complete_Entry_Body.\n \n-      Add_Object_Pointer (Loc, Pid, Op_Decls);\n+      Add_Object_Pointer (Loc, Pid, Bod_Decls);\n \n       --  Add renamings for all formals, the Protection object, discriminals,\n       --  privals and the entry index constant for use by debugger.\n \n-      Add_Formal_Renamings (Espec, Op_Decls, Ent, Loc);\n+      Add_Formal_Renamings (Bod_Spec, Bod_Decls, Ent, Loc);\n       Debug_Private_Data_Declarations (Decls);\n \n       --  Put the declarations and the statements from the entry\n \n-      Op_Stats :=\n+      Bod_Stmts :=\n         New_List (\n           Make_Block_Statement (Loc,\n-            Declarations => Decls,\n-            Handled_Statement_Sequence =>\n-              Handled_Statement_Sequence (N)));\n+            Declarations               => Decls,\n+            Handled_Statement_Sequence => Handled_Statement_Sequence (N)));\n \n       case Corresponding_Runtime_Package (Pid) is\n          when System_Tasking_Protected_Objects_Entries =>\n-            Append_To (Op_Stats,\n+            Append_To (Bod_Stmts,\n               Make_Procedure_Call_Statement (End_Loc,\n                 Name                   =>\n                   New_Occurrence_Of (RTE (RE_Complete_Entry_Body), Loc),\n@@ -3901,16 +4010,16 @@ package body Exp_Ch9 is\n       end case;\n \n       --  When exceptions can not be propagated, we never need to call\n-      --  Exception_Complete_Entry_Body\n+      --  Exception_Complete_Entry_Body.\n \n       if No_Exception_Handlers_Set then\n          return\n            Make_Subprogram_Body (Loc,\n-             Specification => Espec,\n-             Declarations => Op_Decls,\n+             Specification              => Bod_Spec,\n+             Declarations               => Bod_Decls,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Op_Stats,\n+                 Statements => Bod_Stmts,\n                  End_Label  => End_Lab));\n \n       else\n@@ -3934,39 +4043,40 @@ package body Exp_Ch9 is\n \n          --  Establish link between subprogram body entity and source entry\n \n-         Set_Corresponding_Protected_Entry (Edef, Ent);\n+         Set_Corresponding_Protected_Entry (Bod_Id, Ent);\n \n          --  Create body of entry procedure. The renaming declarations are\n          --  placed ahead of the block that contains the actual entry body.\n \n          return\n            Make_Subprogram_Body (Loc,\n-             Specification => Espec,\n-             Declarations => Op_Decls,\n+             Specification              => Bod_Spec,\n+             Declarations               => Bod_Decls,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Op_Stats,\n-                 End_Label  => End_Lab,\n+                 Statements         => Bod_Stmts,\n+                 End_Label          => End_Lab,\n                  Exception_Handlers => New_List (\n-                   Make_Implicit_Exception_Handler (Han_Loc,\n+                   Make_Implicit_Exception_Handler (EH_Loc,\n                      Exception_Choices => New_List (Ohandle),\n \n-                     Statements =>  New_List (\n-                       Make_Procedure_Call_Statement (Han_Loc,\n-                         Name => Complete,\n+                     Statements        =>  New_List (\n+                       Make_Procedure_Call_Statement (EH_Loc,\n+                         Name                   => Complete,\n                          Parameter_Associations => New_List (\n-                           Make_Attribute_Reference (Han_Loc,\n-                             Prefix =>\n-                               Make_Selected_Component (Han_Loc,\n+                           Make_Attribute_Reference (EH_Loc,\n+                             Prefix         =>\n+                               Make_Selected_Component (EH_Loc,\n                                  Prefix        =>\n-                                   Make_Identifier (Han_Loc, Name_uObject),\n+                                   Make_Identifier (EH_Loc, Name_uObject),\n                                  Selector_Name =>\n-                                   Make_Identifier (Han_Loc, Name_uObject)),\n-                               Attribute_Name => Name_Unchecked_Access),\n+                                   Make_Identifier (EH_Loc, Name_uObject)),\n+                             Attribute_Name => Name_Unchecked_Access),\n \n-                           Make_Function_Call (Han_Loc,\n-                             Name => New_Occurrence_Of (\n-                               RTE (RE_Get_GNAT_Exception), Loc)))))))));\n+                           Make_Function_Call (EH_Loc,\n+                             Name =>\n+                               New_Occurrence_Of\n+                                 (RTE (RE_Get_GNAT_Exception), Loc)))))))));\n       end if;\n    end Build_Protected_Entry;\n \n@@ -5302,7 +5412,7 @@ package body Exp_Ch9 is\n       Decls : constant List_Id := Declarations (N);\n \n    begin\n-      --  Add renamings for the Protection object, discriminals, privals and\n+      --  Add renamings for the Protection object, discriminals, privals, and\n       --  the entry index constant for use by debugger.\n \n       Debug_Private_Data_Declarations (Decls);\n@@ -5666,7 +5776,7 @@ package body Exp_Ch9 is\n          if Nkind_In (Decl, N_Full_Type_Declaration, N_Object_Declaration) then\n             Set_Debug_Info_Needed (Defining_Identifier (Decl));\n \n-         --  Declaration for the Protection object, discriminals, privals and\n+         --  Declaration for the Protection object, discriminals, privals, and\n          --  entry index constant:\n          --    conc_typR   : protection_typ renames _object._object;\n          --    discr_nameD : discr_typ renames _object.discr_name;\n@@ -9007,9 +9117,10 @@ package body Exp_Ch9 is\n          Insert_After (Current_Node, Sub);\n          Analyze (Sub);\n \n-         --  Build wrapper procedure for pre/postconditions\n+         --  Build a wrapper procedure to handle contract cases, preconditions,\n+         --  and postconditions.\n \n-         Build_PPC_Wrapper (Comp_Id, N);\n+         Build_Contract_Wrapper (Comp_Id, N);\n \n          Set_Protected_Body_Subprogram\n            (Defining_Identifier (Comp),\n@@ -12113,19 +12224,17 @@ package body Exp_Ch9 is\n \n       Expand_Previous_Access_Type (Tasktyp);\n \n-      --  Create wrappers for entries that have pre/postconditions\n+      --  Create wrappers for entries that have contract cases, preconditions\n+      --  and postconditions.\n \n       declare\n          Ent : Entity_Id;\n \n       begin\n          Ent := First_Entity (Tasktyp);\n          while Present (Ent) loop\n-            if Ekind_In (Ent, E_Entry, E_Entry_Family)\n-              and then Present (Contract (Ent))\n-              and then Present (Pre_Post_Conditions (Contract (Ent)))\n-            then\n-               Build_PPC_Wrapper (Ent, N);\n+            if Ekind_In (Ent, E_Entry, E_Entry_Family) then\n+               Build_Contract_Wrapper (Ent, N);\n             end if;\n \n             Next_Entity (Ent);"}, {"sha": "80c5a067474ebc2e8016b4f5b25b395f3ce3ff0d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 32, "deletions": 52, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -1251,22 +1251,25 @@ package body Sem_Ch13 is\n         (Prag        : Node_Id;\n          Is_Instance : Boolean := False)\n       is\n-         Aux   : Node_Id;\n-         Decl  : Node_Id;\n-         Decls : List_Id;\n-         Def   : Node_Id;\n+         Aux      : Node_Id;\n+         Decl     : Node_Id;\n+         Decls    : List_Id;\n+         Def      : Node_Id;\n+         Inserted : Boolean := False;\n \n       begin\n-         --  When the aspect appears on a package, protected unit, subprogram\n-         --  or task unit body, insert the generated pragma at the top of the\n-         --  body declarations to emulate the behavior of a source pragma.\n+         --  When the aspect appears on an entry, package, protected unit,\n+         --  subprogram, or task unit body, insert the generated pragma at the\n+         --  top of the body declarations to emulate the behavior of a source\n+         --  pragma.\n \n          --    package body Pack with Aspect is\n \n          --    package body Pack is\n          --       pragma Prag;\n \n-         if Nkind_In (N, N_Package_Body,\n+         if Nkind_In (N, N_Entry_Body,\n+                         N_Package_Body,\n                          N_Protected_Body,\n                          N_Subprogram_Body,\n                          N_Task_Body)\n@@ -1278,35 +1281,7 @@ package body Sem_Ch13 is\n                Set_Declarations (N, Decls);\n             end if;\n \n-            --  Skip other internally generated pragmas from aspects to find\n-            --  the proper insertion point. As a result the order of pragmas\n-            --  is the same as the order of aspects.\n-\n-            --  As precondition pragmas generated from conjuncts in the\n-            --  precondition aspect are presented in reverse order to\n-            --  Insert_Pragma, insert them in the correct order here by not\n-            --  skipping previously inserted precondition pragmas when the\n-            --  current pragma is a precondition.\n-\n-            Decl := First (Decls);\n-            while Present (Decl) loop\n-               if Nkind (Decl) = N_Pragma\n-                 and then From_Aspect_Specification (Decl)\n-                 and then not (Get_Pragma_Id (Decl) = Pragma_Precondition\n-                                 and then\n-                               Get_Pragma_Id (Prag) = Pragma_Precondition)\n-               then\n-                  Next (Decl);\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            if Present (Decl) then\n-               Insert_Before (Decl, Prag);\n-            else\n-               Append_To (Decls, Prag);\n-            end if;\n+            Prepend_To (Decls, Prag);\n \n          --  When the aspect is associated with a [generic] package declaration\n          --  insert the generated pragma at the top of the visible declarations\n@@ -1335,23 +1310,24 @@ package body Sem_Ch13 is\n             --    <first source declaration>\n \n             --  Insert the pragma before the first source declaration by\n-            --  skipping the instance \"header\".\n+            --  skipping the instance \"header\" to ensure proper visibility of\n+            --  all formals.\n \n             if Is_Instance then\n                Decl := First (Decls);\n-               while Present (Decl) and then not Comes_From_Source (Decl) loop\n-                  Decl := Next (Decl);\n+               while Present (Decl) loop\n+                  if Comes_From_Source (Decl) then\n+                     Insert_Before (Decl, Prag);\n+                     Inserted := True;\n+                     exit;\n+                  else\n+                     Next (Decl);\n+                  end if;\n                end loop;\n \n-               --  The instance \"header\" is followed by at least one source\n-               --  declaration.\n-\n-               if Present (Decl) then\n-                  Insert_Before (Decl, Prag);\n-\n-               --  Otherwise the pragma is placed after the instance \"header\"\n+               --  The pragma is placed after the instance \"header\"\n \n-               else\n+               if not Inserted then\n                   Append_To (Decls, Prag);\n                end if;\n \n@@ -2770,6 +2746,10 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Post);\n \n+                  Decorate (Aspect, Aitem);\n+                  Insert_Pragma (Aitem);\n+                  goto Continue;\n+\n                --  Refined_State\n \n                when Aspect_Refined_State =>\n@@ -4748,7 +4728,7 @@ package body Sem_Ch13 is\n \n                   --  Overlaying controlled objects is erroneous. Emit warning\n                   --  but continue analysis because program is itself legal,\n-                  --  and back-end must see address clause.\n+                  --  and back end must see address clause.\n \n                   if Present (O_Ent)\n                     and then (Has_Controlled_Component (Etype (O_Ent))\n@@ -6587,7 +6567,7 @@ package body Sem_Ch13 is\n \n             --  In ASIS_Mode mode, expansion is disabled, but we must convert\n             --  the Mod clause into an alignment clause anyway, so that the\n-            --  back-end can compute and back-annotate properly the size and\n+            --  back end can compute and back-annotate properly the size and\n             --  alignment of types that may include this record.\n \n             --  This seems dubious, this destroys the source tree in a manner\n@@ -13048,7 +13028,7 @@ package body Sem_Ch13 is\n             end loop;\n \n             --  Reset homonym link of other entities, but do not modify link\n-            --  between entities in current scope, so that the back-end can\n+            --  between entities in current scope, so that the back end can\n             --  have a proper count of local overloadings.\n \n             if No (Prev) then\n@@ -13643,7 +13623,7 @@ package body Sem_Ch13 is\n \n       --  Make entry in unchecked conversion table for later processing by\n       --  Validate_Unchecked_Conversions, which will check sizes and alignments\n-      --  (using values set by the back-end where possible). This is only done\n+      --  (using values set by the back end where possible). This is only done\n       --  if the appropriate warning is active.\n \n       if Warn_On_Unchecked_Conversion then"}, {"sha": "96e099cde028cd8ec6ba0ddaa3a19d4691df81f0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -12670,9 +12670,14 @@ package body Sem_Prag is\n             Subp_Decl :=\n               Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n \n+            --  Entry\n+\n+            if Nkind (Subp_Decl) = N_Entry_Declaration then\n+               null;\n+\n             --  Generic subprogram\n \n-            if Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n+            elsif Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n                null;\n \n             --  Body acts as spec"}, {"sha": "049f2a28bf961fa5ed682cf560cf2174bf7814ec", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a0183fdf2e1282bcbe6a7a035def0330e599b71/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=8a0183fdf2e1282bcbe6a7a035def0330e599b71", "patch": "@@ -7577,8 +7577,8 @@ package body Sem_Res is\n       end if;\n \n       if Ekind_In (Nam, E_Entry, E_Entry_Family)\n-        and then Present (PPC_Wrapper (Nam))\n-        and then Current_Scope /= PPC_Wrapper (Nam)\n+        and then Present (Contract_Wrapper (Nam))\n+        and then Current_Scope /= Contract_Wrapper (Nam)\n       then\n          --  Rewrite as call to the precondition wrapper, adding the task\n          --  object to the list of actuals. If the call is to a member of an\n@@ -7600,7 +7600,7 @@ package body Sem_Res is\n             New_Call :=\n               Make_Procedure_Call_Statement (Loc,\n                 Name                   =>\n-                  New_Occurrence_Of (PPC_Wrapper (Nam), Loc),\n+                  New_Occurrence_Of (Contract_Wrapper (Nam), Loc),\n                 Parameter_Associations => New_Actuals);\n             Rewrite (N, New_Call);\n "}]}