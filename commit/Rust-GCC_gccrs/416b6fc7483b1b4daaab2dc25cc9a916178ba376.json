{"sha": "416b6fc7483b1b4daaab2dc25cc9a916178ba376", "node_id": "C_kwDOANBUbNoAKDQxNmI2ZmM3NDgzYjFiNGRhYWFiMmRjMjVjYzlhOTE2MTc4YmEzNzY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-21T15:33:13Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-23T22:47:00Z"}, "message": "libstdc++: Use fast_float for long double if it uses binary64 format\n\nWe can use the new from_chars implementation when long double and double\nhave the same representation.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/floating_from_chars.cc (USE_STRTOD_FOR_FROM_CHARS):\n\tDefine macro for case where std::from_chars is implemented in\n\tterms of strtod, strtof or strtold.\n\t(buffer_resource, valid_fmt, find_end_of_float, pattern)\n\t(from_chars_impl, make_result, reserve_string): Do not define\n\tunless USE_STRTOD_FOR_FROM_CHARS is defined.\n\t(from_chars): Define when at least one of USE_LIB_FAST_FLOAT and\n\tUSE_STRTOD_FOR_FROM_CHARS is defined, instead of\n\t_GLIBCXX_HAVE_USELOCALE. Use fast_float for long double when it\n\tis binary64.", "tree": {"sha": "654a55d6cdca3498c0ff8dc640d667ddb106b3a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/654a55d6cdca3498c0ff8dc640d667ddb106b3a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/416b6fc7483b1b4daaab2dc25cc9a916178ba376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416b6fc7483b1b4daaab2dc25cc9a916178ba376", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416b6fc7483b1b4daaab2dc25cc9a916178ba376", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416b6fc7483b1b4daaab2dc25cc9a916178ba376/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "084680db9af077ca37c5523a58b6c11e090e7335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/084680db9af077ca37c5523a58b6c11e090e7335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/084680db9af077ca37c5523a58b6c11e090e7335"}], "stats": {"total": 38, "additions": 32, "deletions": 6}, "files": [{"sha": "ba1345db3f2411485821cab97566eacd56e6889a", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416b6fc7483b1b4daaab2dc25cc9a916178ba376/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416b6fc7483b1b4daaab2dc25cc9a916178ba376/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=416b6fc7483b1b4daaab2dc25cc9a916178ba376", "patch": "@@ -46,6 +46,13 @@\n # include <xlocale.h>\n #endif\n \n+#if _GLIBCXX_HAVE_USELOCALE\n+// FIXME: This should be reimplemented so it doesn't use strtod and newlocale.\n+// That will avoid the need for any memory allocation, meaning that the\n+// non-conforming errc::not_enough_memory result cannot happen.\n+# define USE_STRTOD_FOR_FROM_CHARS 1\n+#endif\n+\n #ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n #ifndef __LONG_DOUBLE_IBM128__\n #error \"floating_from_chars.cc must be compiled with -mabi=ibmlongdouble\"\n@@ -56,6 +63,9 @@ extern \"C\" __ieee128 __strtoieee128(const char*, char**);\n \n #if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n # define USE_LIB_FAST_FLOAT 1\n+# if __LDBL_MANT_DIG__ == __DBL_MANT_DIG__\n+#  undef USE_STRTOD_FOR_FROM_CHARS\n+# endif\n #endif\n \n #if USE_LIB_FAST_FLOAT\n@@ -66,13 +76,13 @@ namespace\n } // anon namespace\n #endif\n \n-#if _GLIBCXX_HAVE_USELOCALE\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n namespace\n {\n+#if USE_STRTOD_FOR_FROM_CHARS\n   // A memory resource with a static buffer that can be used for small\n   // allocations. At most one allocation using the freestore can be done\n   // if the static buffer is insufficient. The callers below only require\n@@ -409,6 +419,7 @@ namespace\n     return true;\n   }\n #endif\n+#endif // USE_STRTOD_FOR_FROM_CHARS\n \n #if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n   // If the given ASCII character represents a hexit, return that hexit.\n@@ -771,13 +782,11 @@ namespace\n \n     return {first, errc{}};\n   }\n-#endif\n+#endif // _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64\n \n } // namespace\n \n-// FIXME: This should be reimplemented so it doesn't use strtod and newlocale.\n-// That will avoid the need for any memory allocation, meaning that the\n-// non-conforming errc::not_enough_memory result cannot happen.\n+#if USE_LIB_FAST_FLOAT || USE_STRTOD_FOR_FROM_CHARS\n \n from_chars_result\n from_chars(const char* first, const char* last, float& value,\n@@ -855,6 +864,21 @@ from_chars_result\n from_chars(const char* first, const char* last, long double& value,\n \t   chars_format fmt) noexcept\n {\n+#if _GLIBCXX_FLOAT_IS_IEEE_BINARY32 && _GLIBCXX_DOUBLE_IS_IEEE_BINARY64 \\\n+  && ! USE_STRTOD_FOR_FROM_CHARS\n+  double dbl_value;\n+  from_chars_result result;\n+  if (fmt == chars_format::hex)\n+    result = __floating_from_chars_hex(first, last, dbl_value);\n+  else\n+    {\n+      static_assert(USE_LIB_FAST_FLOAT);\n+      result = fast_float::from_chars(first, last, dbl_value, fmt);\n+    }\n+  if (result.ec == errc{})\n+    value = dbl_value;\n+  return result;\n+#else\n   errc ec = errc::invalid_argument;\n #if _GLIBCXX_USE_CXX11_ABI\n   buffer_resource mr;\n@@ -875,6 +899,7 @@ from_chars(const char* first, const char* last, long double& value,\n       fmt = chars_format{};\n     }\n   return make_result(first, len, fmt, ec);\n+#endif\n }\n \n #ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n@@ -909,6 +934,7 @@ from_chars(const char* first, const char* last, __ieee128& value,\n }\n #endif\n \n+#endif // USE_LIB_FAST_FLOAT || USE_STRTOD_FOR_FROM_CHARS\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n-#endif // _GLIBCXX_HAVE_USELOCALE"}]}