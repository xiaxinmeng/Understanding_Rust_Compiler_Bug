{"sha": "d5906efcaa2b75bc7991909cf56f934d141ecbdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU5MDZlZmNhYTJiNzViYzc5OTE5MDljZjU2ZjkzNGQxNDFlY2JkYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-11-25T22:49:41Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-11-25T22:49:41Z"}, "message": "<patch #10>\n\n[gcc]\n2015-11-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t<patch #10>\n\t* config/rs6000/constraints.md (wb constraint): New constraint for\n\tISA 3.0 d-form scalar addressing.\n\n\t* config/rs6000/rs6000.c (mode_supports_vmx_dform): Add support\n\tfor ISA 3.0 D-form addressing to load SFmode/DFmode scalars into\n\tAltivec registers.  Add wb constraint for Altivec registers with\n\tD-form addressing.  If we have ISA 3.0 d-form support, undo\n\tsecondary reload support for using FPR registers if we want to do\n\tD-form addressing.\n\t(rs6000_debug_reg_global): Likewise.\n\t(rs6000_setup_reg_addr_masks): Likewise.\n\t(rs6000_init_hard_regno_mode_ok): Likewise.\n\t(rs6000_secondary_reload): Likewise.\n\t(rs6000_preferred_reload_class): Likewise.\n\t(rs6000_secondary_reload_class): Likewise.\n\n\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add wb\n\tconstraint.\n\n\t* config/rs6000/rs6000.md (f32_lr2 mode attribute): Add support\n\tfor ISA 3.0 SFmode/DFmode d-form addressing to Altivec registers.\n\t(f32_lm2): Likewise.\n\t(f32_li2): Likewise.\n\t(f32_sr2): Likewise.\n\t(f32_sm2): Likewise.\n\t(f32_si2): Likewise.\n\t(f64_p9): Likewise.\n\t(extendsfdf2_fpr): Likewise.\n\t(mov<mode>_hardfloat): Likewise.\n\t(mov<mode>_hardfloat32): Likewise.\n\t(mov<mode>_hardfloat64): Likewise.\n\n\t* doc/md.texi (RS/6000 constraints): Document wb constraint.\n\tFixup we constraint documentation.\n\n[gcc/testsuite]\n2015-11-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/dform-1.c: New test.\n\t* gcc.target/powerpc/dform-2.c: Likewise.\n\nFrom-SVN: r230913", "tree": {"sha": "7526c55451b8bf3ed828f529ef373b6378be87b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7526c55451b8bf3ed828f529ef373b6378be87b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5906efcaa2b75bc7991909cf56f934d141ecbdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5906efcaa2b75bc7991909cf56f934d141ecbdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5906efcaa2b75bc7991909cf56f934d141ecbdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5906efcaa2b75bc7991909cf56f934d141ecbdb/comments", "author": null, "committer": null, "parents": [{"sha": "22bea0be95010c6efc39649d06e0f15c90ca38c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bea0be95010c6efc39649d06e0f15c90ca38c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bea0be95010c6efc39649d06e0f15c90ca38c4"}], "stats": {"total": 574, "additions": 542, "deletions": 32}, "files": [{"sha": "6093cbc362fe5cf2e8cbf271c2e20f7bf78fe8f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -1,3 +1,41 @@\n+2015-11-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t<patch #10>\n+\t* config/rs6000/constraints.md (wb constraint): New constraint for\n+\tISA 3.0 d-form scalar addressing.\n+\n+\t* config/rs6000/rs6000.c (mode_supports_vmx_dform): Add support\n+\tfor ISA 3.0 D-form addressing to load SFmode/DFmode scalars into\n+\tAltivec registers.  Add wb constraint for Altivec registers with\n+\tD-form addressing.  If we have ISA 3.0 d-form support, undo\n+\tsecondary reload support for using FPR registers if we want to do\n+\tD-form addressing.\n+\t(rs6000_debug_reg_global): Likewise.\n+\t(rs6000_setup_reg_addr_masks): Likewise.\n+\t(rs6000_init_hard_regno_mode_ok): Likewise.\n+\t(rs6000_secondary_reload): Likewise.\n+\t(rs6000_preferred_reload_class): Likewise.\n+\t(rs6000_secondary_reload_class): Likewise.\n+\n+\t* config/rs6000/rs6000.h (enum r6000_reg_class_enum): Add wb\n+\tconstraint.\n+\n+\t* config/rs6000/rs6000.md (f32_lr2 mode attribute): Add support\n+\tfor ISA 3.0 SFmode/DFmode d-form addressing to Altivec registers.\n+\t(f32_lm2): Likewise.\n+\t(f32_li2): Likewise.\n+\t(f32_sr2): Likewise.\n+\t(f32_sm2): Likewise.\n+\t(f32_si2): Likewise.\n+\t(f64_p9): Likewise.\n+\t(extendsfdf2_fpr): Likewise.\n+\t(mov<mode>_hardfloat): Likewise.\n+\t(mov<mode>_hardfloat32): Likewise.\n+\t(mov<mode>_hardfloat64): Likewise.\n+\n+\t* doc/md.texi (RS/6000 constraints): Document wb constraint.\n+\tFixup we constraint documentation.\n+\n 2015-11-25  Tom de Vries  <tom@codesourcery.com>\n \n \t* omp-low.c (pass_expand_omp_ssa::clone): New function."}, {"sha": "1e7f27b7d6f606bfba6b5282b3cbaa1dedc6250f", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -56,7 +56,8 @@\n (define_register_constraint \"wa\" \"rs6000_constraints[RS6000_CONSTRAINT_wa]\"\n   \"Any VSX register if the -mvsx option was used or NO_REGS.\")\n \n-;; wb is not currently used\n+(define_register_constraint \"wb\" \"rs6000_constraints[RS6000_CONSTRAINT_wb]\"\n+  \"Altivec register if the -mpower9-dform option was used or NO_REGS.\")\n \n ;; NOTE: For compatibility, \"wc\" is reserved to represent individual CR bits.\n ;; It is currently used for that purpose in LLVM."}, {"sha": "ba00b61377a806e5d8b22e5c9455e57a1380568a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -409,6 +409,13 @@ mode_supports_pre_modify_p (machine_mode mode)\n \t  != 0);\n }\n \n+/* Return true if we have D-form addressing in altivec registers.  */\n+static inline bool\n+mode_supports_vmx_dform (machine_mode mode)\n+{\n+  return ((reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_OFFSET) != 0);\n+}\n+\n \f\n /* Target cpu costs.  */\n \n@@ -2263,7 +2270,9 @@ rs6000_debug_reg_global (void)\n \t   \"f  reg_class = %s\\n\"\n \t   \"v  reg_class = %s\\n\"\n \t   \"wa reg_class = %s\\n\"\n+\t   \"wb reg_class = %s\\n\"\n \t   \"wd reg_class = %s\\n\"\n+\t   \"we reg_class = %s\\n\"\n \t   \"wf reg_class = %s\\n\"\n \t   \"wg reg_class = %s\\n\"\n \t   \"wh reg_class = %s\\n\"\n@@ -2288,7 +2297,9 @@ rs6000_debug_reg_global (void)\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_f]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_v]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wa]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wb]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wd]],\n+\t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_we]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wf]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wg]],\n \t   reg_class_names[rs6000_constraints[RS6000_CONSTRAINT_wh]],\n@@ -2669,9 +2680,15 @@ rs6000_setup_reg_addr_masks (void)\n \t    }\n \n \t  /* GPR and FPR registers can do REG+OFFSET addressing, except\n-\t     possibly for SDmode.  */\n+\t     possibly for SDmode.  ISA 3.0 (i.e. power9) adds D-form\n+\t     addressing for scalars to altivec registers.  */\n \t  if ((addr_mask != 0) && !indexed_only_p\n-\t      && (rc == RELOAD_REG_GPR || rc == RELOAD_REG_FPR))\n+\t      && msize <= 8\n+\t      && (rc == RELOAD_REG_GPR\n+\t\t  || rc == RELOAD_REG_FPR\n+\t\t  || (rc == RELOAD_REG_VMX\n+\t\t      && TARGET_P9_DFORM\n+\t\t      && (m2 == DFmode || m2 == SFmode))))\n \t    addr_mask |= RELOAD_REG_OFFSET;\n \n \t  /* VMX registers can do (REG & -16) and ((REG+REG) & -16)\n@@ -2995,6 +3012,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \trs6000_constraints[RS6000_CONSTRAINT_wp] = VSX_REGS;\t/* TFmode  */\n     }\n \n+  /* Support for new D-form instructions.  */\n+  if (TARGET_P9_DFORM)\n+    rs6000_constraints[RS6000_CONSTRAINT_wb] = ALTIVEC_REGS;\n+\n   /* Support for new direct moves.  */\n   if (TARGET_DIRECT_MOVE_128)\n     rs6000_constraints[RS6000_CONSTRAINT_we] = VSX_REGS;\n@@ -18260,8 +18281,10 @@ rs6000_secondary_reload (bool in_p,\n \n   /* If this is a scalar floating point value and we want to load it into the\n      traditional Altivec registers, do it via a move via a traditional floating\n-     point register.  Also make sure that non-zero constants use a FPR.  */\n+     point register, unless we have D-form addressing.  Also make sure that\n+     non-zero constants use a FPR.  */\n   if (!done_p && reg_addr[mode].scalar_in_vmx_p\n+      && !mode_supports_vmx_dform (mode)\n       && (rclass == VSX_REGS || rclass == ALTIVEC_REGS)\n       && (memory_p || (GET_CODE (x) == CONST_DOUBLE)))\n     {\n@@ -18825,10 +18848,14 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n \t  return NO_REGS;\n \t}\n \n-      /* If this is a scalar floating point value, prefer the traditional\n-\t floating point registers so that we can use D-form (register+offset)\n-\t addressing.  */\n-      if (GET_MODE_SIZE (mode) < 16)\n+      /* D-form addressing can easily reload the value.  */\n+      if (mode_supports_vmx_dform (mode))\n+\treturn rclass;\n+\n+      /* If this is a scalar floating point value and we don't have D-form\n+\t addressing, prefer the traditional floating point registers so that we\n+\t can use D-form (register+offset) addressing.  */\n+      if (GET_MODE_SIZE (mode) < 16 && rclass == VSX_REGS)\n \treturn FLOAT_REGS;\n \n       /* Prefer the Altivec registers if Altivec is handling the vector\n@@ -18977,6 +19004,7 @@ rs6000_secondary_reload_class (enum reg_class rclass, machine_mode mode,\n      instead of reloading the secondary memory address for Altivec moves.  */\n   if (TARGET_VSX\n       && GET_MODE_SIZE (mode) < 16\n+      && !mode_supports_vmx_dform (mode)\n       && (((rclass == GENERAL_REGS || rclass == BASE_REGS)\n            && (regno >= 0 && ALTIVEC_REGNO_P (regno)))\n           || ((rclass == VSX_REGS || rclass == ALTIVEC_REGS)"}, {"sha": "dafe3acf912d41b8dd00868df0044001df3cc802", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -1523,6 +1523,7 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_f,\t\t/* fpr registers for single values */\n   RS6000_CONSTRAINT_v,\t\t/* Altivec registers */\n   RS6000_CONSTRAINT_wa,\t\t/* Any VSX register */\n+  RS6000_CONSTRAINT_wb,\t\t/* Altivec register if ISA 3.0 vector. */\n   RS6000_CONSTRAINT_wd,\t\t/* VSX register for V2DF */\n   RS6000_CONSTRAINT_we,\t\t/* VSX register if ISA 3.0 vector. */\n   RS6000_CONSTRAINT_wf,\t\t/* VSX register for V4SF */"}, {"sha": "a500d67efa9171734e93be576ba341cfc4f3d841", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -429,16 +429,22 @@\n \t\t\t\t\t(DD \"REAL_VALUE_TO_TARGET_DECIMAL64\")])\n \n ; Definitions for load to 32-bit fpr register\n-(define_mode_attr f32_lr [(SF \"f\")\t\t (SD \"wz\")])\n-(define_mode_attr f32_lm [(SF \"m\")\t\t (SD \"Z\")])\n-(define_mode_attr f32_li [(SF \"lfs%U1%X1 %0,%1\") (SD \"lfiwzx %0,%y1\")])\n-(define_mode_attr f32_lv [(SF \"lxsspx %x0,%y1\")\t (SD \"lxsiwzx %x0,%y1\")])\n+(define_mode_attr f32_lr  [(SF \"f\")\t\t  (SD \"wz\")])\n+(define_mode_attr f32_lr2 [(SF \"wb\")\t\t  (SD \"wn\")])\n+(define_mode_attr f32_lm  [(SF \"m\")\t\t  (SD \"Z\")])\n+(define_mode_attr f32_lm2 [(SF \"o\")\t\t  (SD \"wn\")])\n+(define_mode_attr f32_li  [(SF \"lfs%U1%X1 %0,%1\") (SD \"lfiwzx %0,%y1\")])\n+(define_mode_attr f32_li2 [(SF \"lxssp %0,%1\")     (SD \"lfiwzx %0,%y1\")])\n+(define_mode_attr f32_lv  [(SF \"lxsspx %x0,%y1\")  (SD \"lxsiwzx %x0,%y1\")])\n \n ; Definitions for store from 32-bit fpr register\n-(define_mode_attr f32_sr [(SF \"f\")\t\t  (SD \"wx\")])\n-(define_mode_attr f32_sm [(SF \"m\")\t\t  (SD \"Z\")])\n-(define_mode_attr f32_si [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n-(define_mode_attr f32_sv [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwzx %x1,%y0\")])\n+(define_mode_attr f32_sr  [(SF \"f\")\t\t   (SD \"wx\")])\n+(define_mode_attr f32_sr2 [(SF \"wb\")\t\t   (SD \"wn\")])\n+(define_mode_attr f32_sm  [(SF \"m\")\t\t   (SD \"Z\")])\n+(define_mode_attr f32_sm2 [(SF \"o\")\t\t   (SD \"wn\")])\n+(define_mode_attr f32_si  [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n+(define_mode_attr f32_si2 [(SF \"stxssp %1,%0\")     (SD \"stfiwx %1,%y0\")])\n+(define_mode_attr f32_sv  [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwzx %x1,%y0\")])\n \n ; Definitions for 32-bit fpr direct move\n ; At present, the decimal modes are not allowed in the traditional altivec\n@@ -460,6 +466,9 @@\n ; Definitions for 64-bit use of altivec registers\n (define_mode_attr f64_av  [(DF \"wv\") (DD \"wn\")])\n \n+; Definitions for 64-bit access to ISA 3.0 (power9) vector\n+(define_mode_attr f64_p9  [(DF \"wb\") (DD \"wn\")])\n+\n ; These modes do not fit in integer registers in 32-bit mode.\n ; but on e500v2, the gpr are 64 bit registers\n (define_mode_iterator DIFD [DI (DF \"!TARGET_E500_DOUBLE\") DD])\n@@ -4468,23 +4477,24 @@\n   \"\")\n \n (define_insn_and_split \"*extendsfdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,ws,?ws,wu\")\n-\t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m,0,wy,Z\")))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,ws,?ws,wu,wb\")\n+\t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m,0,wy,Z,o\")))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n   \"@\n    #\n    fmr %0,%1\n    lfs%U1%X1 %0,%1\n    #\n    xscpsgndp %x0,%x1,%x1\n-   lxsspx %x0,%y1\"\n+   lxsspx %x0,%y1\n+   lxssp %0,%1\"\n   \"&& reload_completed && REG_P (operands[1]) && REGNO (operands[0]) == REGNO (operands[1])\"\n   [(const_int 0)]\n {\n   emit_note (NOTE_INSN_DELETED);\n   DONE;\n }\n-  [(set_attr \"type\" \"fp,fp,fpload,fp,fp,fpload\")])\n+  [(set_attr \"type\" \"fp,fp,fpload,fp,fp,fpload,fpload\")])\n \n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -6469,8 +6479,8 @@\n }\")\n \n (define_insn \"mov<mode>_hardfloat\"\n-  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,<f32_vsx>,<f32_vsx>,!r,<f32_lr>,<f32_sm>,<f32_av>,Z,?<f32_dm>,?r,*c*l,!r,*h\")\n-\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,<f32_vsx>,j,j,<f32_lm>,<f32_sr>,Z,<f32_av>,r,<f32_dm>,r,h,0\"))]\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,<f32_vsx>,<f32_vsx>,!r,<f32_lr>,<f32_lr2>,<f32_sm>,<f32_sm2>,<f32_av>,Z,?<f32_dm>,?r,*c*l,!r,*h\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,<f32_vsx>,j,j,<f32_lm>,<f32_lm2>,<f32_sr>,<f32_sr2>,Z,<f32_av>,r,<f32_dm>,r,h,0\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n@@ -6483,15 +6493,17 @@\n    xxlxor %x0,%x0,%x0\n    li %0,0\n    <f32_li>\n+   <f32_li2>\n    <f32_si>\n+   <f32_si2>\n    <f32_lv>\n    <f32_sv>\n    mtvsrwz %x0,%1\n    mfvsrwz %0,%x1\n    mt%0 %1\n    mf%1 %0\n    nop\"\n-  [(set_attr \"type\" \"*,load,store,fp,fp,vecsimple,integer,fpload,fpstore,fpload,fpstore,mftgpr,mffgpr,mtjmpr,mfjmpr,*\")\n+  [(set_attr \"type\" \"*,load,store,fp,fp,vecsimple,integer,fpload,fpload,fpstore,fpstore,fpload,fpstore,mftgpr,mffgpr,mtjmpr,mfjmpr,*\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*mov<mode>_softfloat\"\n@@ -6600,14 +6612,15 @@\n ;; into a floating point register when it is needed for a floating point\n ;; operation.  Prefer traditional floating point registers over VSX registers,\n ;; since the D-form version of the memory instructions does not need a GPR for\n-;; reloading.\n+;; reloading.  ISA 3.0 (power9) adds D-form addressing for scalars to Altivec\n+;; registers.\n \n ;; If we have FPR registers, rs6000_emit_move has moved all constants to memory,\n ;; except for 0.0 which can be created on VSX with an xor instruction.\n \n (define_insn \"*mov<mode>_hardfloat32\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,j,r,Y,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_p9>,o,<f64_vsx>,<f64_vsx>,!r,Y,r,!r\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,o,<f64_p9>,<f64_vsx>,j,j,r,Y,r\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -6617,14 +6630,16 @@\n    fmr %0,%1\n    lxsd%U1x %x0,%y1\n    stxsd%U0x %x1,%y0\n+   lxsd %0,%1\n+   stxsd %1,%0\n    xxlor %x0,%x1,%x1\n    xxlxor %x0,%x0,%x0\n    #\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,vecsimple,vecsimple,two,store,load,two\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,8,8,8,8\")])\n+  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,fpload,fpstore,vecsimple,vecsimple,two,store,load,two\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,8,8,8,8\")])\n \n (define_insn \"*mov<mode>_softfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n@@ -6642,15 +6657,17 @@\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*mov<mode>_hardfloat64\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,<f64_av>,<f64_vsx>,j,j,r,Y,r,r,h,0,wg,r,<f64_dm>,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,<f64_p9>,o,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,o,<f64_p9>,Z,<f64_av>,<f64_vsx>,j,j,r,Y,r,r,h,0,wg,r,<f64_dm>,r\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n    stfd%U0%X0 %1,%0\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n+   lxsd %0,%1\n+   stxsd %1,%0\n    lxsd%U1x %x0,%y1\n    stxsd%U0x %x1,%y0\n    xxlor %x0,%x1,%x1\n@@ -6666,7 +6683,7 @@\n    mffgpr %0,%1\n    mfvsrd %0,%x1\n    mtvsrd %x0,%1\"\n-  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,vecsimple,vecsimple,integer,store,load,*,mtjmpr,mfjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr\")\n+  [(set_attr \"type\" \"fpstore,fpload,fp,fpload,fpstore,fpload,fpstore,vecsimple,vecsimple,integer,store,load,*,mtjmpr,mfjmpr,*,mftgpr,mffgpr,mftgpr,mffgpr\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*mov<mode>_softfloat64\""}, {"sha": "8e3f8f58e5dafef3a86048fe1d4ea1a5c974999e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -3138,11 +3138,15 @@ asm (\"xsaddqp %x0,%x1,%x2\" : \"=v\" (v1) : \"v\" (v2), \"v\" (v3));\n \n is incorrect.\n \n+@item wb\n+Altivec register if @option{-mpower9-dform} is used or NO_REGS.\n+\n @item wd\n VSX vector register to hold vector double data or NO_REGS.\n \n @item we\n-VSX register if the -mpower9-vector -m64 options were used or NO_REGS.\n+VSX register if the @option{-mpower9-vector} and @option{-m64} options\n+were used or NO_REGS.\n \n @item wf\n VSX vector register to hold vector float data or NO_REGS."}, {"sha": "eb52769540d14cb39b3517088eef6791cb3d89fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -1,3 +1,8 @@\n+2015-11-25  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/dform-1.c: New test.\n+\t* gcc.target/powerpc/dform-2.c: Likewise.\n+\n 2015-11-23  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gfortran.dg/lto/bind_c-6_0.f90: New testcase."}, {"sha": "37a30d1c92f68ecca65e85adda190af5d53787a0", "filename": "gcc/testsuite/gcc.target/powerpc/dform-1.c", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-1.c?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -0,0 +1,207 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -mpower9-dform -O2\" } */\n+\n+#ifndef TYPE\n+#define TYPE double\n+#endif\n+\n+#ifndef TYPE_IN\n+#define TYPE_IN TYPE\n+#endif\n+\n+#ifndef TYPE_OUT\n+#define TYPE_OUT TYPE\n+#endif\n+\n+#ifndef ITYPE\n+#define ITYPE long\n+#endif\n+\n+#ifdef DO_CALL\n+extern ITYPE get_bits (ITYPE);\n+\n+#else\n+#define get_bits(X) (X)\n+#endif\n+\n+void test (ITYPE *bits, ITYPE n, TYPE one, TYPE_IN *p, TYPE_OUT *q)\n+{\n+  TYPE x_00 = p[ 0];\n+  TYPE x_01 = p[ 1];\n+  TYPE x_02 = p[ 2];\n+  TYPE x_03 = p[ 3];\n+  TYPE x_04 = p[ 4];\n+  TYPE x_05 = p[ 5];\n+  TYPE x_06 = p[ 6];\n+  TYPE x_07 = p[ 7];\n+  TYPE x_08 = p[ 8];\n+  TYPE x_09 = p[ 9];\n+\n+  TYPE x_10 = p[10];\n+  TYPE x_11 = p[11];\n+  TYPE x_12 = p[12];\n+  TYPE x_13 = p[13];\n+  TYPE x_14 = p[14];\n+  TYPE x_15 = p[15];\n+  TYPE x_16 = p[16];\n+  TYPE x_17 = p[17];\n+  TYPE x_18 = p[18];\n+  TYPE x_19 = p[19];\n+\n+  TYPE x_20 = p[20];\n+  TYPE x_21 = p[21];\n+  TYPE x_22 = p[22];\n+  TYPE x_23 = p[23];\n+  TYPE x_24 = p[24];\n+  TYPE x_25 = p[25];\n+  TYPE x_26 = p[26];\n+  TYPE x_27 = p[27];\n+  TYPE x_28 = p[28];\n+  TYPE x_29 = p[29];\n+\n+  TYPE x_30 = p[30];\n+  TYPE x_31 = p[31];\n+  TYPE x_32 = p[32];\n+  TYPE x_33 = p[33];\n+  TYPE x_34 = p[34];\n+  TYPE x_35 = p[35];\n+  TYPE x_36 = p[36];\n+  TYPE x_37 = p[37];\n+  TYPE x_38 = p[38];\n+  TYPE x_39 = p[39];\n+\n+  TYPE x_40 = p[40];\n+  TYPE x_41 = p[41];\n+  TYPE x_42 = p[42];\n+  TYPE x_43 = p[43];\n+  TYPE x_44 = p[44];\n+  TYPE x_45 = p[45];\n+  TYPE x_46 = p[46];\n+  TYPE x_47 = p[47];\n+  TYPE x_48 = p[48];\n+  TYPE x_49 = p[49];\n+\n+  ITYPE i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      ITYPE bit = get_bits (bits[i]);\n+\n+      if ((bit & ((ITYPE)1) << \t0) != 0) x_00 += one;\n+      if ((bit & ((ITYPE)1) << \t1) != 0) x_01 += one;\n+      if ((bit & ((ITYPE)1) << \t2) != 0) x_02 += one;\n+      if ((bit & ((ITYPE)1) << \t3) != 0) x_03 += one;\n+      if ((bit & ((ITYPE)1) << \t4) != 0) x_04 += one;\n+      if ((bit & ((ITYPE)1) << \t5) != 0) x_05 += one;\n+      if ((bit & ((ITYPE)1) << \t6) != 0) x_06 += one;\n+      if ((bit & ((ITYPE)1) << \t7) != 0) x_07 += one;\n+      if ((bit & ((ITYPE)1) << \t8) != 0) x_08 += one;\n+      if ((bit & ((ITYPE)1) << \t9) != 0) x_09 += one;\n+\n+      if ((bit & ((ITYPE)1) << 10) != 0) x_10 += one;\n+      if ((bit & ((ITYPE)1) << 11) != 0) x_11 += one;\n+      if ((bit & ((ITYPE)1) << 12) != 0) x_12 += one;\n+      if ((bit & ((ITYPE)1) << 13) != 0) x_13 += one;\n+      if ((bit & ((ITYPE)1) << 14) != 0) x_14 += one;\n+      if ((bit & ((ITYPE)1) << 15) != 0) x_15 += one;\n+      if ((bit & ((ITYPE)1) << 16) != 0) x_16 += one;\n+      if ((bit & ((ITYPE)1) << 17) != 0) x_17 += one;\n+      if ((bit & ((ITYPE)1) << 18) != 0) x_18 += one;\n+      if ((bit & ((ITYPE)1) << 19) != 0) x_19 += one;\n+\n+      if ((bit & ((ITYPE)1) << 20) != 0) x_20 += one;\n+      if ((bit & ((ITYPE)1) << 21) != 0) x_21 += one;\n+      if ((bit & ((ITYPE)1) << 22) != 0) x_22 += one;\n+      if ((bit & ((ITYPE)1) << 23) != 0) x_23 += one;\n+      if ((bit & ((ITYPE)1) << 24) != 0) x_24 += one;\n+      if ((bit & ((ITYPE)1) << 25) != 0) x_25 += one;\n+      if ((bit & ((ITYPE)1) << 26) != 0) x_26 += one;\n+      if ((bit & ((ITYPE)1) << 27) != 0) x_27 += one;\n+      if ((bit & ((ITYPE)1) << 28) != 0) x_28 += one;\n+      if ((bit & ((ITYPE)1) << 29) != 0) x_29 += one;\n+\n+      if ((bit & ((ITYPE)1) << 30) != 0) x_30 += one;\n+      if ((bit & ((ITYPE)1) << 31) != 0) x_31 += one;\n+      if ((bit & ((ITYPE)1) << 32) != 0) x_32 += one;\n+      if ((bit & ((ITYPE)1) << 33) != 0) x_33 += one;\n+      if ((bit & ((ITYPE)1) << 34) != 0) x_34 += one;\n+      if ((bit & ((ITYPE)1) << 35) != 0) x_35 += one;\n+      if ((bit & ((ITYPE)1) << 36) != 0) x_36 += one;\n+      if ((bit & ((ITYPE)1) << 37) != 0) x_37 += one;\n+      if ((bit & ((ITYPE)1) << 38) != 0) x_38 += one;\n+      if ((bit & ((ITYPE)1) << 39) != 0) x_39 += one;\n+\n+      if ((bit & ((ITYPE)1) << 40) != 0) x_40 += one;\n+      if ((bit & ((ITYPE)1) << 41) != 0) x_41 += one;\n+      if ((bit & ((ITYPE)1) << 42) != 0) x_42 += one;\n+      if ((bit & ((ITYPE)1) << 43) != 0) x_43 += one;\n+      if ((bit & ((ITYPE)1) << 44) != 0) x_44 += one;\n+      if ((bit & ((ITYPE)1) << 45) != 0) x_45 += one;\n+      if ((bit & ((ITYPE)1) << 46) != 0) x_46 += one;\n+      if ((bit & ((ITYPE)1) << 47) != 0) x_47 += one;\n+      if ((bit & ((ITYPE)1) << 48) != 0) x_48 += one;\n+      if ((bit & ((ITYPE)1) << 49) != 0) x_49 += one;\n+    }\n+\n+  q[ 0] = x_00;\n+  q[ 1] = x_01;\n+  q[ 2] = x_02;\n+  q[ 3] = x_03;\n+  q[ 4] = x_04;\n+  q[ 5] = x_05;\n+  q[ 6] = x_06;\n+  q[ 7] = x_07;\n+  q[ 8] = x_08;\n+  q[ 9] = x_09;\n+\n+  q[10] = x_10;\n+  q[11] = x_11;\n+  q[12] = x_12;\n+  q[13] = x_13;\n+  q[14] = x_14;\n+  q[15] = x_15;\n+  q[16] = x_16;\n+  q[17] = x_17;\n+  q[18] = x_18;\n+  q[19] = x_19;\n+\n+  q[20] = x_20;\n+  q[21] = x_21;\n+  q[22] = x_22;\n+  q[23] = x_23;\n+  q[24] = x_24;\n+  q[25] = x_25;\n+  q[26] = x_26;\n+  q[27] = x_27;\n+  q[28] = x_28;\n+  q[29] = x_29;\n+\n+  q[30] = x_30;\n+  q[31] = x_31;\n+  q[32] = x_32;\n+  q[33] = x_33;\n+  q[34] = x_34;\n+  q[35] = x_35;\n+  q[36] = x_36;\n+  q[37] = x_37;\n+  q[38] = x_38;\n+  q[39] = x_39;\n+\n+  q[40] = x_40;\n+  q[41] = x_41;\n+  q[42] = x_42;\n+  q[43] = x_43;\n+  q[44] = x_44;\n+  q[45] = x_45;\n+  q[46] = x_46;\n+  q[47] = x_47;\n+  q[48] = x_48;\n+  q[49] = x_49;\n+}\n+\n+/* { dg-final { scan-assembler     \"lxsd \"   } } */\n+/* { dg-final { scan-assembler     \"stxsd \"  } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd \" } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd \" } } */"}, {"sha": "b4c4199c0b3d6bcddd1c0322e768882c8472e688", "filename": "gcc/testsuite/gcc.target/powerpc/dform-2.c", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5906efcaa2b75bc7991909cf56f934d141ecbdb/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-2.c?ref=d5906efcaa2b75bc7991909cf56f934d141ecbdb", "patch": "@@ -0,0 +1,209 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -mpower9-dform -O2\" } */\n+\n+#ifndef TYPE\n+#define TYPE float\n+#endif\n+\n+#ifndef TYPE_IN\n+#define TYPE_IN TYPE\n+#endif\n+\n+#ifndef TYPE_OUT\n+#define TYPE_OUT TYPE\n+#endif\n+\n+#ifndef ITYPE\n+#define ITYPE long\n+#endif\n+\n+#ifdef DO_CALL\n+extern ITYPE get_bits (ITYPE);\n+\n+#else\n+#define get_bits(X) (X)\n+#endif\n+\n+void test (ITYPE *bits, ITYPE n, TYPE one, TYPE_IN *p, TYPE_OUT *q)\n+{\n+  TYPE x_00 = p[ 0];\n+  TYPE x_01 = p[ 1];\n+  TYPE x_02 = p[ 2];\n+  TYPE x_03 = p[ 3];\n+  TYPE x_04 = p[ 4];\n+  TYPE x_05 = p[ 5];\n+  TYPE x_06 = p[ 6];\n+  TYPE x_07 = p[ 7];\n+  TYPE x_08 = p[ 8];\n+  TYPE x_09 = p[ 9];\n+\n+  TYPE x_10 = p[10];\n+  TYPE x_11 = p[11];\n+  TYPE x_12 = p[12];\n+  TYPE x_13 = p[13];\n+  TYPE x_14 = p[14];\n+  TYPE x_15 = p[15];\n+  TYPE x_16 = p[16];\n+  TYPE x_17 = p[17];\n+  TYPE x_18 = p[18];\n+  TYPE x_19 = p[19];\n+\n+  TYPE x_20 = p[20];\n+  TYPE x_21 = p[21];\n+  TYPE x_22 = p[22];\n+  TYPE x_23 = p[23];\n+  TYPE x_24 = p[24];\n+  TYPE x_25 = p[25];\n+  TYPE x_26 = p[26];\n+  TYPE x_27 = p[27];\n+  TYPE x_28 = p[28];\n+  TYPE x_29 = p[29];\n+\n+  TYPE x_30 = p[30];\n+  TYPE x_31 = p[31];\n+  TYPE x_32 = p[32];\n+  TYPE x_33 = p[33];\n+  TYPE x_34 = p[34];\n+  TYPE x_35 = p[35];\n+  TYPE x_36 = p[36];\n+  TYPE x_37 = p[37];\n+  TYPE x_38 = p[38];\n+  TYPE x_39 = p[39];\n+\n+  TYPE x_40 = p[40];\n+  TYPE x_41 = p[41];\n+  TYPE x_42 = p[42];\n+  TYPE x_43 = p[43];\n+  TYPE x_44 = p[44];\n+  TYPE x_45 = p[45];\n+  TYPE x_46 = p[46];\n+  TYPE x_47 = p[47];\n+  TYPE x_48 = p[48];\n+  TYPE x_49 = p[49];\n+\n+  ITYPE i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      ITYPE bit = get_bits (bits[i]);\n+\n+      if ((bit & ((ITYPE)1) << \t0) != 0) x_00 += one;\n+      if ((bit & ((ITYPE)1) << \t1) != 0) x_01 += one;\n+      if ((bit & ((ITYPE)1) << \t2) != 0) x_02 += one;\n+      if ((bit & ((ITYPE)1) << \t3) != 0) x_03 += one;\n+      if ((bit & ((ITYPE)1) << \t4) != 0) x_04 += one;\n+      if ((bit & ((ITYPE)1) << \t5) != 0) x_05 += one;\n+      if ((bit & ((ITYPE)1) << \t6) != 0) x_06 += one;\n+      if ((bit & ((ITYPE)1) << \t7) != 0) x_07 += one;\n+      if ((bit & ((ITYPE)1) << \t8) != 0) x_08 += one;\n+      if ((bit & ((ITYPE)1) << \t9) != 0) x_09 += one;\n+\n+      if ((bit & ((ITYPE)1) << 10) != 0) x_10 += one;\n+      if ((bit & ((ITYPE)1) << 11) != 0) x_11 += one;\n+      if ((bit & ((ITYPE)1) << 12) != 0) x_12 += one;\n+      if ((bit & ((ITYPE)1) << 13) != 0) x_13 += one;\n+      if ((bit & ((ITYPE)1) << 14) != 0) x_14 += one;\n+      if ((bit & ((ITYPE)1) << 15) != 0) x_15 += one;\n+      if ((bit & ((ITYPE)1) << 16) != 0) x_16 += one;\n+      if ((bit & ((ITYPE)1) << 17) != 0) x_17 += one;\n+      if ((bit & ((ITYPE)1) << 18) != 0) x_18 += one;\n+      if ((bit & ((ITYPE)1) << 19) != 0) x_19 += one;\n+\n+      if ((bit & ((ITYPE)1) << 20) != 0) x_20 += one;\n+      if ((bit & ((ITYPE)1) << 21) != 0) x_21 += one;\n+      if ((bit & ((ITYPE)1) << 22) != 0) x_22 += one;\n+      if ((bit & ((ITYPE)1) << 23) != 0) x_23 += one;\n+      if ((bit & ((ITYPE)1) << 24) != 0) x_24 += one;\n+      if ((bit & ((ITYPE)1) << 25) != 0) x_25 += one;\n+      if ((bit & ((ITYPE)1) << 26) != 0) x_26 += one;\n+      if ((bit & ((ITYPE)1) << 27) != 0) x_27 += one;\n+      if ((bit & ((ITYPE)1) << 28) != 0) x_28 += one;\n+      if ((bit & ((ITYPE)1) << 29) != 0) x_29 += one;\n+\n+      if ((bit & ((ITYPE)1) << 30) != 0) x_30 += one;\n+      if ((bit & ((ITYPE)1) << 31) != 0) x_31 += one;\n+      if ((bit & ((ITYPE)1) << 32) != 0) x_32 += one;\n+      if ((bit & ((ITYPE)1) << 33) != 0) x_33 += one;\n+      if ((bit & ((ITYPE)1) << 34) != 0) x_34 += one;\n+      if ((bit & ((ITYPE)1) << 35) != 0) x_35 += one;\n+      if ((bit & ((ITYPE)1) << 36) != 0) x_36 += one;\n+      if ((bit & ((ITYPE)1) << 37) != 0) x_37 += one;\n+      if ((bit & ((ITYPE)1) << 38) != 0) x_38 += one;\n+      if ((bit & ((ITYPE)1) << 39) != 0) x_39 += one;\n+\n+      if ((bit & ((ITYPE)1) << 40) != 0) x_40 += one;\n+      if ((bit & ((ITYPE)1) << 41) != 0) x_41 += one;\n+      if ((bit & ((ITYPE)1) << 42) != 0) x_42 += one;\n+      if ((bit & ((ITYPE)1) << 43) != 0) x_43 += one;\n+      if ((bit & ((ITYPE)1) << 44) != 0) x_44 += one;\n+      if ((bit & ((ITYPE)1) << 45) != 0) x_45 += one;\n+      if ((bit & ((ITYPE)1) << 46) != 0) x_46 += one;\n+      if ((bit & ((ITYPE)1) << 47) != 0) x_47 += one;\n+      if ((bit & ((ITYPE)1) << 48) != 0) x_48 += one;\n+      if ((bit & ((ITYPE)1) << 49) != 0) x_49 += one;\n+    }\n+\n+  q[ 0] = x_00;\n+  q[ 1] = x_01;\n+  q[ 2] = x_02;\n+  q[ 3] = x_03;\n+  q[ 4] = x_04;\n+  q[ 5] = x_05;\n+  q[ 6] = x_06;\n+  q[ 7] = x_07;\n+  q[ 8] = x_08;\n+  q[ 9] = x_09;\n+\n+  q[10] = x_10;\n+  q[11] = x_11;\n+  q[12] = x_12;\n+  q[13] = x_13;\n+  q[14] = x_14;\n+  q[15] = x_15;\n+  q[16] = x_16;\n+  q[17] = x_17;\n+  q[18] = x_18;\n+  q[19] = x_19;\n+\n+  q[20] = x_20;\n+  q[21] = x_21;\n+  q[22] = x_22;\n+  q[23] = x_23;\n+  q[24] = x_24;\n+  q[25] = x_25;\n+  q[26] = x_26;\n+  q[27] = x_27;\n+  q[28] = x_28;\n+  q[29] = x_29;\n+\n+  q[30] = x_30;\n+  q[31] = x_31;\n+  q[32] = x_32;\n+  q[33] = x_33;\n+  q[34] = x_34;\n+  q[35] = x_35;\n+  q[36] = x_36;\n+  q[37] = x_37;\n+  q[38] = x_38;\n+  q[39] = x_39;\n+\n+  q[40] = x_40;\n+  q[41] = x_41;\n+  q[42] = x_42;\n+  q[43] = x_43;\n+  q[44] = x_44;\n+  q[45] = x_45;\n+  q[46] = x_46;\n+  q[47] = x_47;\n+  q[48] = x_48;\n+  q[49] = x_49;\n+}\n+\n+/* { dg-final { scan-assembler     \"lxssp \"     } } */\n+/* { dg-final { scan-assembler     \"stxssp \"    } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd \"    } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd \"    } } */\n+/* { dg-final { scan-assembler-not \"xscvdpspn \" } } */\n+"}]}