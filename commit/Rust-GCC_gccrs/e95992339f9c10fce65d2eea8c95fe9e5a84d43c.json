{"sha": "e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk1OTkyMzM5ZjljMTBmY2U2NWQyZWVhOGM5NWZlOWU1YTg0ZDQzYw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2011-03-15T00:24:08Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2011-03-15T00:24:08Z"}, "message": "Makefile.am: Add functional.cc, shared_ptr.cc.\n\n\n\n2011-03-14  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* src/Makefile.am: Add functional.cc, shared_ptr.cc.\n\t* src/Makefile.in: Regenerate.\n\t* libsupc++/Makefile.am: Add nested_exception.cc.\n\t* libsupc++/Makefile.in: Regenerate.\n\t* src/system_error.cc: Add ctor and dtor definitions for error_category.\n\t* src/functional.cc: New. Add dtor definition for bad_function_call.\n\t* src/stdexcept.cc: Add dtor definitions for domain_error,\n\tinvalid_argument, length_error, out_of_range, range_error,\n\toverflow_error, underflow_error.\n\t* src/future.cc: Add dtor definition for __future_base::_Result_base.\n\t* src/shared_ptr.cc: New. Add dtor definition for bad_weak_ptr.\n\t* src/thread.cc: Add dtor for thread::_Impl_base.\n\t* include/std/system_error: Adjust.\n\t* include/std/stdexcept: Same.\n\t* include/std/future: Same.\n\t* include/std/functional: Same.\n\t* include/std/thread: Same.\n\t* include/bits/shared_ptr_base.h: Same.\n\t* libsupc++/nested_exception.cc: New. Add dtor for nested_exception.\n\t* libsupc++/nested_exception.h: Adjust.\n\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust line numbers.\n\t* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Same.\n\t* config/abi/pre/gnu.ver: Add new exports.\n\n\t* include/bits/regex_compiler.h: Nest namespace versioning.\n\t* include/bits/regex_grep_matcher.tcc: Same.\n\t* include/bits/regex_grep_matcher.h: Same.\n\t* include/bits/regex_cursor.h: Same.\n\t* include/bits/regex_nfa.h: Same.\n\t* include/bits/regex_nfa.tcc: Same.\n\nFrom-SVN: r170975", "tree": {"sha": "e5d7d51858cf55279f3ce928eac52925dfcf91d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5d7d51858cf55279f3ce928eac52925dfcf91d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/comments", "author": null, "committer": null, "parents": [{"sha": "fe8e6abcddefc9350252c578ba9f4bb00ca8c346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe8e6abcddefc9350252c578ba9f4bb00ca8c346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe8e6abcddefc9350252c578ba9f4bb00ca8c346"}], "stats": {"total": 1234, "additions": 730, "deletions": 504}, "files": [{"sha": "870fd9c1634f39f5f7b827be5c68ddf4de6c5a01", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -1,3 +1,36 @@\n+2011-03-14  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* src/Makefile.am: Add functional.cc, shared_ptr.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t* libsupc++/Makefile.am: Add nested_exception.cc.\n+\t* libsupc++/Makefile.in: Regenerate.\n+\t* src/system_error.cc: Add ctor and dtor definitions for error_category.\n+\t* src/functional.cc: New. Add dtor definition for bad_function_call.\n+\t* src/stdexcept.cc: Add dtor definitions for domain_error,\n+\tinvalid_argument, length_error, out_of_range, range_error,\n+\toverflow_error, underflow_error.\n+\t* src/future.cc: Add dtor definition for __future_base::_Result_base.\n+\t* src/shared_ptr.cc: New. Add dtor definition for bad_weak_ptr.\n+\t* src/thread.cc: Add dtor for thread::_Impl_base.\n+\t* include/std/system_error: Adjust.\n+\t* include/std/stdexcept: Same.\n+\t* include/std/future: Same.\n+\t* include/std/functional: Same.\n+\t* include/std/thread: Same.\n+\t* include/bits/shared_ptr_base.h: Same.\n+\t* libsupc++/nested_exception.cc: New. Add dtor for nested_exception.\n+\t* libsupc++/nested_exception.h: Adjust.\n+\t* testsuite/20_util/shared_ptr/cons/43820_neg.cc: Adjust line numbers.\n+\t* testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: Same.\n+\t* config/abi/pre/gnu.ver: Add new exports.\n+\n+\t* include/bits/regex_compiler.h: Nest namespace versioning.\n+\t* include/bits/regex_grep_matcher.tcc: Same.\n+\t* include/bits/regex_grep_matcher.h: Same.\n+\t* include/bits/regex_cursor.h: Same.\n+\t* include/bits/regex_nfa.h: Same.\n+\t* include/bits/regex_nfa.tcc: Same.\n+\n 2011-03-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* doc/xml/manual/abi.xml: Replace docs.sun.com URLs by their OTN"}, {"sha": "c85ba8ed52cd724cd9ab0cd6e587516ae50cb9cf", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -124,7 +124,7 @@ GLIBCXX_3.4 {\n       std::messages*;\n       std::money*;\n #     std::n[^u]*;\n-      std::n[^au]*;\n+      std::n[^aue]*;\n       std::nu[^m]*;\n       std::num[^e]*;\n       std::ostrstream*;\n@@ -1219,6 +1219,31 @@ GLIBCXX_3.4.15 {\n     _ZTISt11regex_error;\n     _ZSt19__throw_regex_errorNSt15regex_constants10error_typeE;\n \n+    _ZNSt12bad_weak_ptrD*;\n+    _ZNKSt12bad_weak_ptr4whatEv;\n+    _ZTSSt12bad_weak_ptr;\n+    _ZTVSt12bad_weak_ptr;\n+    _ZTISt12bad_weak_ptr;\n+\n+    _ZNSt14error_categoryC*;\n+    _ZNSt14error_categoryD*;\n+\n+    _ZNSt13__future_base12_Result_baseC*;\n+    _ZNSt13__future_base12_Result_baseD*;\n+    _ZTINSt13__future_base12_Result_baseE;\n+    _ZTSNSt13__future_base12_Result_baseE;\n+    _ZTVNSt13__future_base12_Result_baseE;\n+\n+    _ZNSt13__future_base11_State_baseD*;\n+    _ZTINSt13__future_base11_State_baseE;\n+    _ZTSNSt13__future_base11_State_baseE;\n+    _ZTVNSt13__future_base11_State_baseE;\n+\n+    _ZNSt6thread10_Impl_baseD*;\n+    _ZTINSt6thread10_Impl_baseE;\n+    _ZTSNSt6thread10_Impl_baseE;\n+    _ZTVNSt6thread10_Impl_baseE;\n+\n } GLIBCXX_3.4.14;\n \n # Symbols in the support library (libsupc++) have their own tag.\n@@ -1403,4 +1428,10 @@ CXXABI_1.3.5 {\n     _ZTSSt17bad_function_call;\n     _ZTVSt17bad_function_call;\n \n+    # std::nested_exception\n+    _ZNSt16nested_exceptionD*;\n+    _ZTISt16nested_exception;\n+    _ZTSSt16nested_exception;\n+    _ZTVSt16nested_exception;\n+\n } CXXABI_1.3.4;"}, {"sha": "025c4fa70a9e7011132830d0e97d216a21c5d9ff", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -30,17 +30,19 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n namespace __regex\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n   struct _Scanner_base\n   {\n     typedef unsigned int _StateT;\n \n     static constexpr _StateT _S_state_at_start    = 1 << 0;\n     static constexpr _StateT _S_state_in_brace    = 1 << 2;\n     static constexpr _StateT _S_state_in_bracket  = 1 << 3;\n+\n+    virtual ~_Scanner_base() { };\n   };\n \n   //\n@@ -1100,9 +1102,8 @@ namespace __regex\n     { return _AutomatonPtr(new _Nfa(_Compiler<_InIter, _TraitsT>(__b, __e, __t,\n                                         __f)._M_nfa())); }\n \n-} // namespace __regex\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace\n+} // namespace __regex\n+} // namespace std\n \n /* vim: set ts=8 sw=2 sts=2: */"}, {"sha": "9feac1d0aa374a7ca6f48963b27c86293730d377", "filename": "libstdc++-v3/include/bits/regex_cursor.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -30,10 +30,10 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n namespace __regex\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n   // ABC for pattern matching\n   struct _PatternCursor\n   {\n@@ -88,7 +88,6 @@ namespace __regex\n     __cursor(const _FwdIterT& __b, const _FwdIterT __e)\n     { return _SpecializedCursor<_FwdIterT>(__b, __e); }\n \n-} // namespace __regex\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __regex\n } // namespace"}, {"sha": "06193bba3b797fb5f7fcbb20ecc5173ba1ed740c", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -30,7 +30,6 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _BiIter>\n     class sub_match;\n@@ -40,6 +39,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   \n namespace __regex\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n   // A _Results facade specialized for wrapping a templated match_results.\n   template<typename _FwdIterT, typename _Alloc>\n     class _SpecializedResults\n@@ -121,9 +122,8 @@ namespace __regex\n     _Results&                          _M_results;\n   };\n \n-} // namespace __regex\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __regex\n } // namespace\n \n #include <bits/regex_grep_matcher.tcc>"}, {"sha": "ae28f6fa15217983f18723de2689529ce020422c", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -32,11 +32,8 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n namespace\n {\n-\n   // A stack of states used in evaluating the NFA.\n   typedef std::stack<std::__regex::_StateIdT,\n                      std::vector<std::__regex::_StateIdT>\n@@ -104,6 +101,8 @@ namespace\n \n namespace __regex\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n   inline _Grep_matcher::\n   _Grep_matcher(_PatternCursor& __p, _Results& __r,\n \t\tconst _AutomatonPtr& __nfa,\n@@ -175,7 +174,6 @@ namespace __regex\n     return __e;\n   }\n \n-} // namespace __regex\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __regex\n } // namespace"}, {"sha": "c4a65e6722ddb3871d520d19feef62bc5fa4e825", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -30,10 +30,9 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n namespace __regex\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Base class for, um, automata.  Could be an NFA or a DFA.  Your choice.\n   class _Automaton\n@@ -43,8 +42,7 @@ namespace __regex\n \n   public:\n     virtual\n-    ~_Automaton()\n-    { }\n+    ~_Automaton() { }\n \n     virtual _SizeT\n     _M_sub_count() const = 0;\n@@ -394,10 +392,9 @@ namespace __regex\n \n   };\n \n-} // namespace __regex\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace\n+} // namespace __regex\n+} // namespace std\n \n #include <bits/regex_nfa.tcc>\n "}, {"sha": "9e4a6cee774d2be7e47fc20a263da540c3d2b253", "filename": "libstdc++-v3/include/bits/regex_nfa.tcc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -1,6 +1,6 @@\n // class template regex -*- C++ -*-\n \n-// Copyright (C) 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -31,10 +31,10 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n namespace __regex\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n #ifdef _GLIBCXX_DEBUG\n inline std::ostream& _State::\n _M_print(std::ostream& ostr) const\n@@ -169,7 +169,6 @@ inline _StateIdT _StateSeq::\n _M_clone()\n { return 0; }\n \n-} // namespace __regex\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __regex\n } // namespace"}, {"sha": "72bc4f046335278f0449b1add4369948bbe9d685", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -61,8 +61,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n   public:\n     virtual char const*\n-    what() const throw()\n-    { return \"std::bad_weak_ptr\"; }\n+    what() const throw();\n+\n+    virtual ~bad_weak_ptr() throw();    \n   };\n \n   // Substitute for bad_weak_ptr object in the case of -fno-exceptions."}, {"sha": "6643b76493c4fd4a245e561c8cf5032b82f6c533", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 400, "deletions": 396, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -83,90 +83,90 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     { };\n \n   /// Retrieve the result type for a function type.\n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes...)>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes......)>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes...) const>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes......) const>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>\n     { typedef _Res result_type; };\n \n   /// Retrieve the result type for a function reference.\n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>\n     { typedef _Res result_type; };\n \n   /// Retrieve the result type for a function pointer.\n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>\n     { typedef _Res result_type; };\n \n-  /// Retrieve result type for a member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  /// Retrieve result type for a member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>\n     { typedef _Res result_type; };\n \n-  /// Retrieve result type for a const member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  /// Retrieve result type for a const member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>\n     { typedef _Res result_type; };\n \n-  /// Retrieve result type for a volatile member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  /// Retrieve result type for a volatile member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>\n     { typedef _Res result_type; };\n \n-  /// Retrieve result type for a const volatile member function pointer. \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n-    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) \n+  /// Retrieve result type for a const volatile member function pointer.\n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n+    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)\n \t\t\t\t  const volatile>\n     { typedef _Res result_type; };\n \n-  template<typename _Res, typename _Class, typename... _ArgTypes> \n+  template<typename _Res, typename _Class, typename... _ArgTypes>\n     struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)\n \t\t\t\t  const volatile>\n     { typedef _Res result_type; };\n@@ -186,7 +186,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n     private:\n       template<typename _T1, typename _Res>\n-        static __one __test(const volatile unary_function<_T1, _Res>*);\n+\tstatic __one __test(const volatile unary_function<_T1, _Res>*);\n \n       // It's tempting to change \"...\" to const volatile void*, but\n       // that fails when _Tp is a function type.\n@@ -202,7 +202,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n     private:\n       template<typename _T1, typename _T2, typename _Res>\n-        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n+\tstatic __one __test(const volatile binary_function<_T1, _T2, _Res>*);\n \n       // It's tempting to change \"...\" to const volatile void*, but\n       // that fails when _Tp is a function type.\n@@ -232,11 +232,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   template<typename _Functor, typename... _Args>\n     inline\n     typename enable_if<\n-             (!is_member_pointer<_Functor>::value\n-              && !is_function<_Functor>::value\n-              && !is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::type\n+\t     (!is_member_pointer<_Functor>::value\n+\t      && !is_function<_Functor>::value\n+\t      && !is_function<typename remove_pointer<_Functor>::type>::value),\n+\t     typename result_of<_Functor(_Args...)>::type\n+\t   >::type\n     __invoke(_Functor& __f, _Args&&... __args)\n     {\n       return __f(std::forward<_Args>(__args)...);\n@@ -246,10 +246,10 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   template<typename _Functor, typename... _Args>\n     inline\n     typename enable_if<\n-             (is_pointer<_Functor>::value\n-              && is_function<typename remove_pointer<_Functor>::type>::value),\n-             typename result_of<_Functor(_Args...)>::type\n-           >::type\n+\t     (is_pointer<_Functor>::value\n+\t      && is_function<typename remove_pointer<_Functor>::type>::value),\n+\t     typename result_of<_Functor(_Args...)>::type\n+\t   >::type\n     __invoke(_Functor __f, _Args&&... __args)\n     {\n       return __f(std::forward<_Args>(__args)...);\n@@ -425,7 +425,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // If _Tp is a function type, we can't form result_of<_Tp(...)>,\n       // so turn it into a function pointer type.\n       typedef typename _Function_to_function_pointer<_Tp>::type\n-        _M_func_type;\n+\t_M_func_type;\n \n       _Tp* _M_data;\n     public:\n@@ -444,8 +444,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       reference_wrapper&\n       operator=(const reference_wrapper<_Tp>& __inref)\n       {\n-        _M_data = __inref._M_data;\n-        return *this;\n+\t_M_data = __inref._M_data;\n+\treturn *this;\n       }\n \n       operator _Tp&() const\n@@ -456,9 +456,9 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       { return *_M_data; }\n \n       template<typename... _Args>\n-        typename result_of<_M_func_type(_Args...)>::type\n-        operator()(_Args&&... __args) const\n-        {\n+\ttypename result_of<_M_func_type(_Args...)>::type\n+\toperator()(_Args&&... __args) const\n+\t{\n \t  return __invoke(get(), std::forward<_Args>(__args)...);\n \t}\n     };\n@@ -498,16 +498,16 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    * nothing, depending on the number of arguments provided. The\n    * primary template is the basis case, which derives nothing.\n    */\n-  template<typename _Res, typename... _ArgTypes> \n+  template<typename _Res, typename... _ArgTypes>\n     struct _Maybe_unary_or_binary_function { };\n \n-  /// Derives from @c unary_function, as appropriate. \n-  template<typename _Res, typename _T1> \n+  /// Derives from @c unary_function, as appropriate.\n+  template<typename _Res, typename _T1>\n     struct _Maybe_unary_or_binary_function<_Res, _T1>\n     : std::unary_function<_T1, _Res> { };\n \n-  /// Derives from @c binary_function, as appropriate. \n-  template<typename _Res, typename _T1, typename _T2> \n+  /// Derives from @c binary_function, as appropriate.\n+  template<typename _Res, typename _T1, typename _T2>\n     struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>\n     : std::binary_function<_T1, _T2, _Res> { };\n \n@@ -519,15 +519,15 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       typedef _Res (_Class::*_Functor)(_ArgTypes...);\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __object, const volatile _Class *,\n+\t\t_ArgTypes... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n       typedef _Res result_type;\n@@ -546,12 +546,12 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-        _Res\n+\t_Res\n \toperator()(_Tp& __object, _ArgTypes... __args) const\n-        {\n-          return _M_call(__object, &__object,\n-              std::forward<_ArgTypes>(__args)...);\n-        }\n+\t{\n+\t  return _M_call(__object, &__object,\n+\t      std::forward<_ArgTypes>(__args)...);\n+\t}\n \n     private:\n       _Functor __pmf;\n@@ -560,21 +560,21 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   /// Implementation of @c mem_fn for const member function pointers.\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>\n-    : public _Maybe_unary_or_binary_function<_Res, const _Class*, \n+    : public _Maybe_unary_or_binary_function<_Res, const _Class*,\n \t\t\t\t\t     _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) const;\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __object, const volatile _Class *,\n+\t\t_ArgTypes... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n       typedef _Res result_type;\n@@ -593,11 +593,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n-        {\n-          return _M_call(__object, &__object,\n-              std::forward<_ArgTypes>(__args)...);\n-        }\n+\t_Res operator()(_Tp& __object, _ArgTypes... __args) const\n+\t{\n+\t  return _M_call(__object, &__object,\n+\t      std::forward<_ArgTypes>(__args)...);\n+\t}\n \n     private:\n       _Functor __pmf;\n@@ -606,21 +606,21 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   /// Implementation of @c mem_fn for volatile member function pointers.\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*, \n+    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,\n \t\t\t\t\t     _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __object, const volatile _Class *,\n+\t\t_ArgTypes... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n       typedef _Res result_type;\n@@ -639,12 +639,12 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-        _Res\n+\t_Res\n \toperator()(_Tp& __object, _ArgTypes... __args) const\n-        {\n-          return _M_call(__object, &__object,\n-              std::forward<_ArgTypes>(__args)...);\n-        }\n+\t{\n+\t  return _M_call(__object, &__object,\n+\t      std::forward<_ArgTypes>(__args)...);\n+\t}\n \n     private:\n       _Functor __pmf;\n@@ -653,44 +653,44 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n   /// Implementation of @c mem_fn for const volatile member function pointers.\n   template<typename _Res, typename _Class, typename... _ArgTypes>\n     class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>\n-    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*, \n+    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,\n \t\t\t\t\t     _ArgTypes...>\n     {\n       typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __object, const volatile _Class *, \n-                _ArgTypes... __args) const\n-        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __object, const volatile _Class *,\n+\t\t_ArgTypes... __args) const\n+\t{ return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n       template<typename _Tp>\n-        _Res\n-        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n-        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n+\t_Res\n+\t_M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const\n+\t{ return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n     public:\n       typedef _Res result_type;\n \n       explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }\n \n       // Handle objects\n-      _Res \n+      _Res\n       operator()(const volatile _Class& __object, _ArgTypes... __args) const\n       { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n       // Handle pointers\n-      _Res \n+      _Res\n       operator()(const volatile _Class* __object, _ArgTypes... __args) const\n       { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }\n \n       // Handle smart pointers, references and pointers to derived\n       template<typename _Tp>\n-        _Res operator()(_Tp& __object, _ArgTypes... __args) const\n-        {\n-          return _M_call(__object, &__object,\n-              std::forward<_ArgTypes>(__args)...);\n-        }\n+\t_Res operator()(_Tp& __object, _ArgTypes... __args) const\n+\t{\n+\t  return _M_call(__object, &__object,\n+\t      std::forward<_ArgTypes>(__args)...);\n+\t}\n \n     private:\n       _Functor __pmf;\n@@ -715,60 +715,60 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // This bit of genius is due to Peter Dimov, improved slightly by\n       // Douglas Gregor.\n       template<typename _Tp>\n-        _Res&\n-        _M_call(_Tp& __object, _Class *) const\n-        { return __object.*__pm; }\n+\t_Res&\n+\t_M_call(_Tp& __object, _Class *) const\n+\t{ return __object.*__pm; }\n \n       template<typename _Tp, typename _Up>\n-        _Res&\n-        _M_call(_Tp& __object, _Up * const *) const\n-        { return (*__object).*__pm; }\n+\t_Res&\n+\t_M_call(_Tp& __object, _Up * const *) const\n+\t{ return (*__object).*__pm; }\n \n       template<typename _Tp, typename _Up>\n-        const _Res&\n-        _M_call(_Tp& __object, const _Up * const *) const\n-        { return (*__object).*__pm; }\n+\tconst _Res&\n+\t_M_call(_Tp& __object, const _Up * const *) const\n+\t{ return (*__object).*__pm; }\n \n       template<typename _Tp>\n-        const _Res&\n-        _M_call(_Tp& __object, const _Class *) const\n-        { return __object.*__pm; }\n+\tconst _Res&\n+\t_M_call(_Tp& __object, const _Class *) const\n+\t{ return __object.*__pm; }\n \n       template<typename _Tp>\n-        const _Res&\n-        _M_call(_Tp& __ptr, const volatile void*) const\n-        { return (*__ptr).*__pm; }\n+\tconst _Res&\n+\t_M_call(_Tp& __ptr, const volatile void*) const\n+\t{ return (*__ptr).*__pm; }\n \n       template<typename _Tp> static _Tp& __get_ref();\n \n       template<typename _Tp>\n-        static __sfinae_types::__one __check_const(_Tp&, _Class*);\n+\tstatic __sfinae_types::__one __check_const(_Tp&, _Class*);\n       template<typename _Tp, typename _Up>\n-        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n+\tstatic __sfinae_types::__one __check_const(_Tp&, _Up * const *);\n       template<typename _Tp, typename _Up>\n-        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n+\tstatic __sfinae_types::__two __check_const(_Tp&, const _Up * const *);\n       template<typename _Tp>\n-        static __sfinae_types::__two __check_const(_Tp&, const _Class*);\n+\tstatic __sfinae_types::__two __check_const(_Tp&, const _Class*);\n       template<typename _Tp>\n-        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n+\tstatic __sfinae_types::__two __check_const(_Tp&, const volatile void*);\n \n     public:\n       template<typename _Tp>\n-        struct _Result_type\n+\tstruct _Result_type\n \t: _Mem_fn_const_or_non<_Res,\n \t  (sizeof(__sfinae_types::__two)\n \t   == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>\n-        { };\n+\t{ };\n \n       template<typename _Signature>\n-        struct result;\n+\tstruct result;\n \n       template<typename _CVMem, typename _Tp>\n-        struct result<_CVMem(_Tp)>\n+\tstruct result<_CVMem(_Tp)>\n \t: public _Result_type<_Tp> { };\n \n       template<typename _CVMem, typename _Tp>\n-        struct result<_CVMem(_Tp&)>\n+\tstruct result<_CVMem(_Tp&)>\n \t: public _Result_type<_Tp> { };\n \n       explicit\n@@ -794,9 +794,9 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Handle smart pointers and derived\n       template<typename _Tp>\n-        typename _Result_type<_Tp>::type\n-        operator()(_Tp& __unknown) const\n-        { return _M_call(__unknown, &__unknown); }\n+\ttypename _Result_type<_Tp>::type\n+\toperator()(_Tp& __unknown) const\n+\t{ return _M_call(__unknown, &__unknown); }\n \n     private:\n       _Res _Class::*__pm;\n@@ -847,7 +847,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    *  simplify this with variadic templates, because we're introducing\n    *  unique names for each.\n    */\n-  namespace placeholders \n+  namespace placeholders\n   {\n   _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     extern const _Placeholder<1> _1;\n@@ -894,7 +894,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     : public integral_constant<int, _Num>\n     { };\n \n-  /** \n+  /**\n    * Used by _Safe_tuple_element to indicate that there is no tuple\n    * element at this position.\n    */\n@@ -926,8 +926,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    */\n  template<int __i, typename _Tuple>\n    struct _Safe_tuple_element\n-   : _Safe_tuple_element_impl<__i, _Tuple, \n-                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n+   : _Safe_tuple_element_impl<__i, _Tuple,\n+\t\t\t      (__i >= 0 && __i < tuple_size<_Tuple>::value)>\n    { };\n \n   /**\n@@ -942,8 +942,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n    *  rest of the arguments.\n    */\n   template<typename _Arg,\n-           bool _IsBindExp = is_bind_expression<_Arg>::value,\n-           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n+\t   bool _IsBindExp = is_bind_expression<_Arg>::value,\n+\t   bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>\n     class _Mu;\n \n   /**\n@@ -961,9 +961,9 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        * but not volatile-qualified. This might be a defect in the TR.\n        */\n       template<typename _CVRef, typename _Tuple>\n-        result_type\n-        operator()(_CVRef& __arg, _Tuple&) const volatile\n-        { return __arg.get(); }\n+\tresult_type\n+\toperator()(_CVRef& __arg, _Tuple&) const volatile\n+\t{ return __arg.get(); }\n     };\n \n   /**\n@@ -976,11 +976,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n     public:\n       template<typename _CVArg, typename... _Args>\n-        auto\n-        operator()(_CVArg& __arg,\n+\tauto\n+\toperator()(_CVArg& __arg,\n \t\t   tuple<_Args...>& __tuple) const volatile\n-        -> decltype(__arg(declval<_Args>()...))\n-        {\n+\t-> decltype(__arg(declval<_Args>()...))\n+\t{\n \t  // Construct an index tuple and forward to __call\n \t  typedef typename _Build_index_tuple<sizeof...(_Args)>::__type\n \t    _Indexes;\n@@ -989,13 +989,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n     private:\n       // Invokes the underlying function object __arg by unpacking all\n-      // of the arguments in the tuple. \n+      // of the arguments in the tuple.\n       template<typename _CVArg, typename... _Args, int... _Indexes>\n-        auto\n-        __call(_CVArg& __arg, tuple<_Args...>& __tuple,\n+\tauto\n+\t__call(_CVArg& __arg, tuple<_Args...>& __tuple,\n \t       const _Index_tuple<_Indexes...>&) const volatile\n-        -> decltype(__arg(declval<_Args>()...))\n-        {\n+\t-> decltype(__arg(declval<_Args>()...))\n+\t{\n \t  return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);\n \t}\n     };\n@@ -1012,8 +1012,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       template<typename _Signature> class result;\n \n       template<typename _CVMu, typename _CVArg, typename _Tuple>\n-        class result<_CVMu(_CVArg, _Tuple)>\n-        {\n+\tclass result<_CVMu(_CVArg, _Tuple)>\n+\t{\n \t  // Add a reference, if it hasn't already been done for us.\n \t  // This allows us to be a little bit sloppy in constructing\n \t  // the tuple that we pass to result_of<...>.\n@@ -1026,11 +1026,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t};\n \n       template<typename _Tuple>\n-        typename result<_Mu(_Arg, _Tuple)>::type\n-        operator()(const volatile _Arg&, _Tuple& __tuple) const volatile\n-        {\n+\ttypename result<_Mu(_Arg, _Tuple)>::type\n+\toperator()(const volatile _Arg&, _Tuple& __tuple) const volatile\n+\t{\n \t  return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(\n-              ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));\n+\t      ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));\n \t}\n     };\n \n@@ -1046,16 +1046,16 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       template<typename _Signature> struct result;\n \n       template<typename _CVMu, typename _CVArg, typename _Tuple>\n-        struct result<_CVMu(_CVArg, _Tuple)>\n-        {\n+\tstruct result<_CVMu(_CVArg, _Tuple)>\n+\t{\n \t  typedef typename add_lvalue_reference<_CVArg>::type type;\n \t};\n \n       // Pick up the cv-qualifiers of the argument\n       template<typename _CVArg, typename _Tuple>\n-        _CVArg&&\n-        operator()(_CVArg&& __arg, _Tuple&) const volatile\n-        { return std::forward<_CVArg>(__arg); }\n+\t_CVArg&&\n+\toperator()(_CVArg&& __arg, _Tuple&) const volatile\n+\t{ return std::forward<_CVArg>(__arg); }\n     };\n \n   /**\n@@ -1086,7 +1086,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     struct _Maybe_wrap_member_pointer<_Tp _Class::*>\n     {\n       typedef _Mem_fn<_Tp _Class::*> type;\n-      \n+\n       static type\n       __do_wrap(_Tp _Class::* __pm)\n       { return type(__pm); }\n@@ -1126,59 +1126,59 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     {\n       typedef _Bind __self_type;\n       typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type\n-        _Bound_indexes;\n+\t_Bound_indexes;\n \n       _Functor _M_f;\n       tuple<_Bound_args...> _M_bound_args;\n \n       // Call unqualified\n       template<typename _Result, typename... _Args, int... _Indexes>\n-        _Result\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t_Result\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call as const\n       template<typename _Result, typename... _Args, int... _Indexes>\n-        _Result\n-        __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t_Result\n+\t__call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call as volatile\n       template<typename _Result, typename... _Args, int... _Indexes>\n-        _Result\n-        __call_v(tuple<_Args...>&& __args, \n+\t_Result\n+\t__call_v(tuple<_Args...>&& __args,\n \t\t _Index_tuple<_Indexes...>) volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (__volget<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (__volget<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call as const volatile\n       template<typename _Result, typename... _Args, int... _Indexes>\n-        _Result\n-        __call_c_v(tuple<_Args...>&& __args, \n+\t_Result\n+\t__call_c_v(tuple<_Args...>&& __args,\n \t\t   _Index_tuple<_Indexes...>) const volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (__volget<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (__volget<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n      public:\n       template<typename... _Args>\n-        explicit _Bind(const _Functor& __f, _Args&&... __args)\n-        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)\n-        { }\n+\texplicit _Bind(const _Functor& __f, _Args&&... __args)\n+\t: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)\n+\t{ }\n \n       template<typename... _Args>\n-        explicit _Bind(_Functor&& __f, _Args&&... __args)\n-        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)\n-        { }\n+\texplicit _Bind(_Functor&& __f, _Args&&... __args)\n+\t: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)\n+\t{ }\n \n       _Bind(const _Bind&) = default;\n \n@@ -1188,55 +1188,55 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Call unqualified\n       template<typename... _Args, typename _Result\n-        = decltype( std::declval<_Functor>()(\n-              _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n+\t= decltype( std::declval<_Functor>()(\n+\t      _Mu<_Bound_args>()( std::declval<_Bound_args&>(),\n \t\t\t\t  std::declval<tuple<_Args...>&>() )... ) )>\n-        _Result\n-        operator()(_Args&&... __args)\n-        {\n-          return this->__call<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\t_Result\n+\toperator()(_Args&&... __args)\n+\t{\n+\t  return this->__call<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n \n       // Call as const\n       template<typename... _Args, typename _Result\n-        = decltype( std::declval<const _Functor>()(\n+\t= decltype( std::declval<const _Functor>()(\n \t      _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),\n \t\t\t\t  std::declval<tuple<_Args...>&>() )... ) )>\n-        _Result\n-        operator()(_Args&&... __args) const\n-        {\n-          return this->__call_c<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\t_Result\n+\toperator()(_Args&&... __args) const\n+\t{\n+\t  return this->__call_c<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n \n       // Call as volatile\n       template<typename... _Args, typename _Result\n-        = decltype( std::declval<volatile _Functor>()(\n-              _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n-        _Result\n-        operator()(_Args&&... __args) volatile\n-        {\n-          return this->__call_v<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\t= decltype( std::declval<volatile _Functor>()(\n+\t      _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),\n+\t\t\t\t  std::declval<tuple<_Args...>&>() )... ) )>\n+\t_Result\n+\toperator()(_Args&&... __args) volatile\n+\t{\n+\t  return this->__call_v<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n \n       // Call as const volatile\n       template<typename... _Args, typename _Result\n-        = decltype( std::declval<const volatile _Functor>()(\n-              _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n-                                  std::declval<tuple<_Args...>&>() )... ) )>\n-        _Result\n-        operator()(_Args&&... __args) const volatile\n-        {\n-          return this->__call_c_v<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\t= decltype( std::declval<const volatile _Functor>()(\n+\t      _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),\n+\t\t\t\t  std::declval<tuple<_Args...>&>() )... ) )>\n+\t_Result\n+\toperator()(_Args&&... __args) const volatile\n+\t{\n+\t  return this->__call_c_v<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n     };\n \n   /// Type of the function object returned from bind<R>().\n@@ -1247,111 +1247,111 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     class _Bind_result<_Result, _Functor(_Bound_args...)>\n     {\n       typedef _Bind_result __self_type;\n-      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type \n-        _Bound_indexes;\n+      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type\n+\t_Bound_indexes;\n \n       _Functor _M_f;\n       tuple<_Bound_args...> _M_bound_args;\n \n       // sfinae types\n       template<typename _Res>\n-        struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };\n+\tstruct __enable_if_void : enable_if<is_void<_Res>::value, int> { };\n       template<typename _Res>\n-        struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };\n+\tstruct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };\n \n       // Call unqualified\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        _Result\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __disable_if_void<_Res>::type = 0)\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t_Result\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __disable_if_void<_Res>::type = 0)\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call unqualified, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        void\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __enable_if_void<_Res>::type = 0)\n-        {\n-          _M_f(_Mu<_Bound_args>()\n+\tvoid\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __enable_if_void<_Res>::type = 0)\n+\t{\n+\t  _M_f(_Mu<_Bound_args>()\n \t       (get<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t}\n \n       // Call as const\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        _Result\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __disable_if_void<_Res>::type = 0) const\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (get<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t_Result\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __disable_if_void<_Res>::type = 0) const\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call as const, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        void\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __enable_if_void<_Res>::type = 0) const\n-        {\n-          _M_f(_Mu<_Bound_args>()\n+\tvoid\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __enable_if_void<_Res>::type = 0) const\n+\t{\n+\t  _M_f(_Mu<_Bound_args>()\n \t       (get<_Indexes>(_M_bound_args),  __args)...);\n-        }\n+\t}\n \n       // Call as volatile\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        _Result\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __disable_if_void<_Res>::type = 0) volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (__volget<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t_Result\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __disable_if_void<_Res>::type = 0) volatile\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (__volget<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call as volatile, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        void\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __enable_if_void<_Res>::type = 0) volatile\n-        {\n-          _M_f(_Mu<_Bound_args>()\n+\tvoid\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __enable_if_void<_Res>::type = 0) volatile\n+\t{\n+\t  _M_f(_Mu<_Bound_args>()\n \t       (__volget<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t}\n \n       // Call as const volatile\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        _Result\n-        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n-            typename __disable_if_void<_Res>::type = 0) const volatile\n-        {\n-          return _M_f(_Mu<_Bound_args>()\n-                      (__volget<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t_Result\n+\t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,\n+\t    typename __disable_if_void<_Res>::type = 0) const volatile\n+\t{\n+\t  return _M_f(_Mu<_Bound_args>()\n+\t\t      (__volget<_Indexes>(_M_bound_args), __args)...);\n+\t}\n \n       // Call as const volatile, return void\n       template<typename _Res, typename... _Args, int... _Indexes>\n-        void\n-        __call(tuple<_Args...>&& __args, \n-               _Index_tuple<_Indexes...>,\n-            typename __enable_if_void<_Res>::type = 0) const volatile\n-        {\n-          _M_f(_Mu<_Bound_args>()\n+\tvoid\n+\t__call(tuple<_Args...>&& __args,\n+\t       _Index_tuple<_Indexes...>,\n+\t    typename __enable_if_void<_Res>::type = 0) const volatile\n+\t{\n+\t  _M_f(_Mu<_Bound_args>()\n \t       (__volget<_Indexes>(_M_bound_args), __args)...);\n-        }\n+\t}\n \n     public:\n       typedef _Result result_type;\n \n       template<typename... _Args>\n-        explicit _Bind_result(const _Functor& __f, _Args&&... __args)\n-        : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)\n-        { }\n+\texplicit _Bind_result(const _Functor& __f, _Args&&... __args)\n+\t: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)\n+\t{ }\n \n       template<typename... _Args>\n-        explicit _Bind_result(_Functor&& __f, _Args&&... __args)\n-        : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)\n-        { }\n+\texplicit _Bind_result(_Functor&& __f, _Args&&... __args)\n+\t: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)\n+\t{ }\n \n       _Bind_result(const _Bind_result&) = default;\n \n@@ -1361,43 +1361,43 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       // Call unqualified\n       template<typename... _Args>\n-        result_type\n-        operator()(_Args&&... __args)\n-        {\n-          return this->__call<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\tresult_type\n+\toperator()(_Args&&... __args)\n+\t{\n+\t  return this->__call<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n \n       // Call as const\n       template<typename... _Args>\n-        result_type\n-        operator()(_Args&&... __args) const\n-        {\n-          return this->__call<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\tresult_type\n+\toperator()(_Args&&... __args) const\n+\t{\n+\t  return this->__call<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n \n       // Call as volatile\n       template<typename... _Args>\n-        result_type\n-        operator()(_Args&&... __args) volatile\n-        {\n-          return this->__call<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\tresult_type\n+\toperator()(_Args&&... __args) volatile\n+\t{\n+\t  return this->__call<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n \n       // Call as const volatile\n       template<typename... _Args>\n-        result_type\n-        operator()(_Args&&... __args) const volatile\n-        {\n-          return this->__call<_Result>(\n-              std::forward_as_tuple(std::forward<_Args>(__args)...),\n-              _Bound_indexes());\n-        }\n+\tresult_type\n+\toperator()(_Args&&... __args) const volatile\n+\t{\n+\t  return this->__call<_Result>(\n+\t      std::forward_as_tuple(std::forward<_Args>(__args)...),\n+\t      _Bound_indexes());\n+\t}\n     };\n \n   /**\n@@ -1420,7 +1420,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     struct _Bind_helper\n     {\n       typedef _Maybe_wrap_member_pointer<typename decay<_Functor>::type>\n-        __maybe_type;\n+\t__maybe_type;\n       typedef typename __maybe_type::type __functor_type;\n       typedef _Bind<__functor_type(typename decay<_ArgTypes>::type...)> type;\n     };\n@@ -1438,18 +1438,18 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       typedef typename __helper_type::__maybe_type __maybe_type;\n       typedef typename __helper_type::type __result_type;\n       return __result_type(__maybe_type::__do_wrap(std::forward<_Functor>(__f)),\n-                           std::forward<_ArgTypes>(__args)...);\n-    } \n+\t\t\t   std::forward<_ArgTypes>(__args)...);\n+    }\n \n   template<typename _Result, typename _Functor, typename... _ArgTypes>\n     struct _Bindres_helper\n     {\n       typedef _Maybe_wrap_member_pointer<typename decay<_Functor>::type>\n-        __maybe_type;\n+\t__maybe_type;\n       typedef typename __maybe_type::type __functor_type;\n       typedef _Bind_result<_Result,\n-                           __functor_type(typename decay<_ArgTypes>::type...)>\n-        type;\n+\t\t\t   __functor_type(typename decay<_ArgTypes>::type...)>\n+\ttype;\n     };\n \n   /**\n@@ -1465,15 +1465,19 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       typedef typename __helper_type::__maybe_type __maybe_type;\n       typedef typename __helper_type::type __result_type;\n       return __result_type(__maybe_type::__do_wrap(std::forward<_Functor>(__f)),\n-                           std::forward<_ArgTypes>(__args)...);\n+\t\t\t   std::forward<_ArgTypes>(__args)...);\n     }\n \n   /**\n    *  @brief Exception class thrown when class template function's\n    *  operator() is called with an empty target.\n    *  @ingroup exceptions\n    */\n-  class bad_function_call : public std::exception { };\n+  class bad_function_call : public std::exception\n+  {\n+  public:\n+    virtual ~bad_function_call() throw();\n+  };\n \n   /**\n    *  Trait identifying \"location-invariant\" types, meaning that the\n@@ -1570,11 +1574,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       {\n       protected:\n \tstatic const bool __stored_locally =\n-        (__is_location_invariant<_Functor>::value\n-         && sizeof(_Functor) <= _M_max_size\n-         && __alignof__(_Functor) <= _M_max_align\n-         && (_M_max_align % __alignof__(_Functor) == 0));\n-\t\n+\t(__is_location_invariant<_Functor>::value\n+\t && sizeof(_Functor) <= _M_max_size\n+\t && __alignof__(_Functor) <= _M_max_align\n+\t && (_M_max_align % __alignof__(_Functor) == 0));\n+\n \ttypedef integral_constant<bool, __stored_locally> _Local_storage;\n \n \t// Retrieve a pointer to the function object\n@@ -1611,14 +1615,14 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t{\n \t  __victim._M_access<_Functor>().~_Functor();\n \t}\n-\t\n+\n \t// Destroying an object located on the heap.\n \tstatic void\n \t_M_destroy(_Any_data& __victim, false_type)\n \t{\n \t  delete __victim._M_access<_Functor*>();\n \t}\n-\t\n+\n       public:\n \tstatic bool\n \t_M_manager(_Any_data& __dest, const _Any_data& __source,\n@@ -1634,7 +1638,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t    case __get_functor_ptr:\n \t      __dest._M_access<_Functor*>() = _M_get_pointer(__source);\n \t      break;\n-\t      \n+\n \t    case __clone_functor:\n \t      _M_clone(__dest, __source, _Local_storage());\n \t      break;\n@@ -1649,11 +1653,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \tstatic void\n \t_M_init_functor(_Any_data& __functor, _Functor&& __f)\n \t{ _M_init_functor(__functor, std::move(__f), _Local_storage()); }\n-\t\n+\n \ttemplate<typename _Signature>\n \t  static bool\n \t  _M_not_empty_function(const function<_Signature>& __f)\n-          { return static_cast<bool>(__f); }\n+\t  { return static_cast<bool>(__f); }\n \n \ttemplate<typename _Tp>\n \t  static bool\n@@ -1671,7 +1675,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t  { return true; }\n \n       private:\n-        static void\n+\tstatic void\n \t_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)\n \t{ new (__functor._M_access()) _Functor(std::move(__f)); }\n \n@@ -1701,7 +1705,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t      __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);\n \t      return is_const<_Functor>::value;\n \t      break;\n-\t      \n+\n \t    default:\n \t      _Base::_M_manager(__dest, __source, __op);\n \t    }\n@@ -1717,7 +1721,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       };\n \n     _Function_base() : _M_manager(0) { }\n-    \n+\n     ~_Function_base()\n     {\n       if (_M_manager)\n@@ -1728,7 +1732,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     bool _M_empty() const { return !_M_manager; }\n \n     typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,\n-                                  _Manager_operation);\n+\t\t\t\t  _Manager_operation);\n \n     _Any_data     _M_functor;\n     _Manager_type _M_manager;\n@@ -1747,8 +1751,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       static _Res\n       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        return (*_Base::_M_get_pointer(__functor))(\n-            std::forward<_ArgTypes>(__args)...);\n+\treturn (*_Base::_M_get_pointer(__functor))(\n+\t    std::forward<_ArgTypes>(__args)...);\n       }\n     };\n \n@@ -1762,8 +1766,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       static void\n       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        (*_Base::_M_get_pointer(__functor))(\n-            std::forward<_ArgTypes>(__args)...);\n+\t(*_Base::_M_get_pointer(__functor))(\n+\t    std::forward<_ArgTypes>(__args)...);\n       }\n     };\n \n@@ -1777,8 +1781,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       static _Res\n       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        return __callable_functor(**_Base::_M_get_pointer(__functor))(\n-              std::forward<_ArgTypes>(__args)...);\n+\treturn __callable_functor(**_Base::_M_get_pointer(__functor))(\n+\t      std::forward<_ArgTypes>(__args)...);\n       }\n     };\n \n@@ -1792,32 +1796,32 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       static void\n       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        __callable_functor(**_Base::_M_get_pointer(__functor))(\n-            std::forward<_ArgTypes>(__args)...);\n+\t__callable_functor(**_Base::_M_get_pointer(__functor))(\n+\t    std::forward<_ArgTypes>(__args)...);\n       }\n     };\n \n-  template<typename _Class, typename _Member, typename _Res, \n-           typename... _ArgTypes>\n+  template<typename _Class, typename _Member, typename _Res,\n+\t   typename... _ArgTypes>\n     class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>\n     : public _Function_handler<void(_ArgTypes...), _Member _Class::*>\n     {\n       typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>\n-        _Base;\n+\t_Base;\n \n      public:\n       static _Res\n       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n-        return mem_fn(_Base::_M_get_pointer(__functor)->__value)(\n-            std::forward<_ArgTypes>(__args)...);\n+\treturn mem_fn(_Base::_M_get_pointer(__functor)->__value)(\n+\t    std::forward<_ArgTypes>(__args)...);\n       }\n     };\n \n   template<typename _Class, typename _Member, typename... _ArgTypes>\n     class _Function_handler<void(_ArgTypes...), _Member _Class::*>\n     : public _Function_base::_Base_manager<\n-                 _Simple_type_wrapper< _Member _Class::* > >\n+\t\t _Simple_type_wrapper< _Member _Class::* > >\n     {\n       typedef _Member _Class::* _Functor;\n       typedef _Simple_type_wrapper<_Functor> _Wrapper;\n@@ -1826,31 +1830,31 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n      public:\n       static bool\n       _M_manager(_Any_data& __dest, const _Any_data& __source,\n-                 _Manager_operation __op)\n+\t\t _Manager_operation __op)\n       {\n-        switch (__op)\n+\tswitch (__op)\n \t  {\n #ifdef __GXX_RTTI\n \t  case __get_type_info:\n \t    __dest._M_access<const type_info*>() = &typeid(_Functor);\n \t    break;\n-#endif\t    \n+#endif\n \t  case __get_functor_ptr:\n \t    __dest._M_access<_Functor*>() =\n \t      &_Base::_M_get_pointer(__source)->__value;\n \t    break;\n-\t    \n+\n \t  default:\n \t    _Base::_M_manager(__dest, __source, __op);\n \t  }\n-        return false;\n+\treturn false;\n       }\n \n       static void\n       _M_invoke(const _Any_data& __functor, _ArgTypes... __args)\n       {\n \tmem_fn(_Base::_M_get_pointer(__functor)->__value)(\n-            std::forward<_ArgTypes>(__args)...);\n+\t    std::forward<_ArgTypes>(__args)...);\n       }\n     };\n \n@@ -1866,26 +1870,26 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       private _Function_base\n     {\n       typedef _Res _Signature_type(_ArgTypes...);\n-      \n+\n       struct _Useless { };\n-      \n+\n     public:\n       typedef _Res result_type;\n-      \n+\n       // [3.7.2.1] construct/copy/destroy\n-      \n+\n       /**\n        *  @brief Default construct creates an empty function call wrapper.\n        *  @post @c !(bool)*this\n        */\n       function() : _Function_base() { }\n-      \n+\n       /**\n        *  @brief Creates an empty function call wrapper.\n        *  @post @c !(bool)*this\n        */\n       function(nullptr_t) : _Function_base() { }\n-      \n+\n       /**\n        *  @brief %Function copy constructor.\n        *  @param x A %function object with identical call signature.\n@@ -1905,11 +1909,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        */\n       function(function&& __x) : _Function_base()\n       {\n-        __x.swap(*this);\n+\t__x.swap(*this);\n       }\n \n       // TODO: needs allocator_arg_t\n-      \n+\n       /**\n        *  @brief Builds a %function that targets a copy of the incoming\n        *  function object.\n@@ -1927,10 +1931,10 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *  reference_wrapper<F>, this function will not throw.\n        */\n       template<typename _Functor>\n-        function(_Functor __f,\n-                 typename enable_if<\n-                           !is_integral<_Functor>::value, _Useless>::type\n-                   = _Useless());\n+\tfunction(_Functor __f,\n+\t\t typename enable_if<\n+\t\t\t   !is_integral<_Functor>::value, _Useless>::type\n+\t\t   = _Useless());\n \n       /**\n        *  @brief %Function assignment operator.\n@@ -1947,8 +1951,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       function&\n       operator=(const function& __x)\n       {\n-        function(__x).swap(*this);\n-        return *this;\n+\tfunction(__x).swap(*this);\n+\treturn *this;\n       }\n \n       /**\n@@ -1965,8 +1969,8 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       function&\n       operator=(function&& __x)\n       {\n-        function(std::move(__x)).swap(*this);\n-        return *this;\n+\tfunction(std::move(__x)).swap(*this);\n+\treturn *this;\n       }\n \n       /**\n@@ -1979,13 +1983,13 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       function&\n       operator=(nullptr_t)\n       {\n-        if (_M_manager)\n+\tif (_M_manager)\n \t  {\n \t    _M_manager(_M_functor, _M_functor, __destroy_functor);\n \t    _M_manager = 0;\n \t    _M_invoker = 0;\n \t  }\n-        return *this;\n+\treturn *this;\n       }\n \n       /**\n@@ -2005,7 +2009,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *  reference_wrapper<F>, this function will not throw.\n        */\n       template<typename _Functor>\n-        typename enable_if<!is_integral<_Functor>::value, function&>::type\n+\ttypename enable_if<!is_integral<_Functor>::value, function&>::type\n \toperator=(_Functor&& __f)\n \t{\n \t  function(std::forward<_Functor>(__f)).swap(*this);\n@@ -2014,15 +2018,15 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \n       /// @overload\n       template<typename _Functor>\n-        typename enable_if<!is_integral<_Functor>::value, function&>::type\n+\ttypename enable_if<!is_integral<_Functor>::value, function&>::type\n \toperator=(reference_wrapper<_Functor> __f)\n \t{\n \t  function(__f).swap(*this);\n \t  return *this;\n \t}\n \n       // [3.7.2.2] function modifiers\n-      \n+\n       /**\n        *  @brief Swap the targets of two %function objects.\n        *  @param f A %function with identical call signature.\n@@ -2040,14 +2044,14 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       // TODO: needs allocator_arg_t\n       /*\n       template<typename _Functor, typename _Alloc>\n-        void\n-        assign(_Functor&& __f, const _Alloc& __a)\n-        {\n-          function(allocator_arg, __a,\n-                   std::forward<_Functor>(__f)).swap(*this);\n-        }\n+\tvoid\n+\tassign(_Functor&& __f, const _Alloc& __a)\n+\t{\n+\t  function(allocator_arg, __a,\n+\t\t   std::forward<_Functor>(__f)).swap(*this);\n+\t}\n       */\n-      \n+\n       // [3.7.2.3] function capacity\n \n       /**\n@@ -2085,7 +2089,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        *  This function will not throw an %exception.\n        */\n       const type_info& target_type() const;\n-      \n+\n       /**\n        *  @brief Access the stored target function object.\n        *\n@@ -2096,7 +2100,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n        * This function will not throw an %exception.\n        */\n       template<typename _Functor>       _Functor* target();\n-      \n+\n       /// @overload\n       template<typename _Functor> const _Functor* target() const;\n #endif\n@@ -2125,7 +2129,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n       function<_Res(_ArgTypes...)>::\n       function(_Functor __f,\n \t       typename enable_if<\n-\t                !is_integral<_Functor>::value, _Useless>::type)\n+\t\t\t!is_integral<_Functor>::value, _Useless>::type)\n       : _Function_base()\n       {\n \ttypedef _Function_handler<_Signature_type, _Functor> _My_handler;\n@@ -2144,7 +2148,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     operator()(_ArgTypes... __args) const\n     {\n       if (_M_empty())\n-        __throw_bad_function_call();\n+\t__throw_bad_function_call();\n       return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);\n     }\n \n@@ -2155,11 +2159,11 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     target_type() const\n     {\n       if (_M_manager)\n-        {\n-          _Any_data __typeinfo_result;\n-          _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n-          return *__typeinfo_result._M_access<const type_info*>();\n-        }\n+\t{\n+\t  _Any_data __typeinfo_result;\n+\t  _M_manager(__typeinfo_result, _M_functor, __get_type_info);\n+\t  return *__typeinfo_result._M_access<const type_info*>();\n+\t}\n       else\n \treturn typeid(void);\n     }"}, {"sha": "17d46dbd431770cd10b92b8509dc2545151d2ec7", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -160,7 +160,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       exception_ptr\t\t_M_error;\n \n-      _Result_base() = default;\n       _Result_base(const _Result_base&) = delete;\n       _Result_base& operator=(const _Result_base&) = delete;\n \n@@ -173,7 +172,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       };\n \n     protected:\n-      ~_Result_base();\n+      _Result_base();\n+      virtual ~_Result_base();\n     };\n \n     /// Result.\n@@ -273,8 +273,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n \n-    /// Shared state between a promise and one or more associated futures.\n-    class _State\n+    /// Base class for state between a promise and one or more\n+    /// associated futures.\n+    class _State_base\n     {\n       typedef _Ptr<_Result_base>::type _Ptr_type;\n \n@@ -285,18 +286,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       once_flag\t\t\t_M_once;\n \n     public:\n-      _State() : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT) { }\n-\n-      _State(const _State&) = delete;\n-      _State& operator=(const _State&) = delete;\n+      _State_base() : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT) { }\n+      _State_base(const _State_base&) = delete;\n+      _State_base& operator=(const _State_base&) = delete;\n+      virtual ~_State_base();\n \n       _Result_base&\n       wait()\n       {\n \t_M_run_deferred();\n \tunique_lock<mutex> __lock(_M_mutex);\n \tif (!_M_ready())\n-\t  _M_cond.wait(__lock, std::bind<bool>(&_State::_M_ready, this));\n+\t  _M_cond.wait(__lock, std::bind<bool>(&_State_base::_M_ready, this));\n \treturn *_M_result;\n       }\n \n@@ -305,7 +306,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         wait_for(const chrono::duration<_Rep, _Period>& __rel)\n         {\n \t  unique_lock<mutex> __lock(_M_mutex);\n-\t  auto __bound = std::bind<bool>(&_State::_M_ready, this);\n+\t  auto __bound = std::bind<bool>(&_State_base::_M_ready, this);\n \t  return _M_ready() || _M_cond.wait_for(__lock, __rel, __bound);\n \t}\n \n@@ -314,7 +315,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         wait_until(const chrono::time_point<_Clock, _Duration>& __abs)\n         {\n \t  unique_lock<mutex> __lock(_M_mutex);\n-\t  auto __bound = std::bind<bool>(&_State::_M_ready, this);\n+\t  auto __bound = std::bind<bool>(&_State_base::_M_ready, this);\n \t  return _M_ready() || _M_cond.wait_until(__lock, __abs, __bound);\n \t}\n \n@@ -324,7 +325,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         bool __set = __ignore_failure;\n         // all calls to this function are serialized,\n         // side-effects of invoking __res only happen once\n-        call_once(_M_once, &_State::_M_do_set, this, ref(__res),\n+        call_once(_M_once, &_State_base::_M_do_set, this, ref(__res),\n             ref(__set));\n         if (!__set)\n           __throw_future_error(int(future_errc::promise_already_satisfied));\n@@ -368,7 +369,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n           typename promise<_Res>::_Ptr_type operator()()\n           {\n-            _State::_S_check(_M_promise->_M_future);\n+            _State_base::_S_check(_M_promise->_M_future);\n             _M_promise->_M_storage->_M_set(_M_arg);\n             return std::move(_M_promise->_M_storage);\n           }\n@@ -382,7 +383,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         {\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n-            _State::_S_check(_M_promise->_M_future);\n+            _State_base::_S_check(_M_promise->_M_future);\n             _M_promise->_M_storage->_M_set(std::move(_M_arg));\n             return std::move(_M_promise->_M_storage);\n           }\n@@ -398,7 +399,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         {\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n-            _State::_S_check(_M_promise->_M_future);\n+            _State_base::_S_check(_M_promise->_M_future);\n             _M_promise->_M_storage->_M_error = _M_ex;\n             return std::move(_M_promise->_M_storage);\n           }\n@@ -463,8 +464,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       struct _Task_setter;\n   };\n \n-  inline __future_base::_Result_base::~_Result_base() = default;\n-\n   /// Partial specialization for reference types.\n   template<typename _Res>\n     struct __future_base::_Result<_Res&> : __future_base::_Result_base\n@@ -495,7 +494,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class __basic_future : public __future_base\n     {\n     protected:\n-      typedef shared_ptr<_State>\t\t__state_type;\n+      typedef shared_ptr<_State_base>\t\t__state_type;\n       typedef __future_base::_Result<_Res>&\t__result_type;\n \n     private:\n@@ -512,23 +511,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void \n       wait() const\n       {\n-        _State::_S_check(_M_state);\n+        _State_base::_S_check(_M_state);\n         _M_state->wait();\n       }\n \n       template<typename _Rep, typename _Period>\n         bool\n         wait_for(const chrono::duration<_Rep, _Period>& __rel) const\n         {\n-          _State::_S_check(_M_state);\n+          _State_base::_S_check(_M_state);\n           return _M_state->wait_for(__rel);\n         }\n \n       template<typename _Clock, typename _Duration>\n         bool\n         wait_until(const chrono::time_point<_Clock, _Duration>& __abs) const\n         {\n-          _State::_S_check(_M_state);\n+          _State_base::_S_check(_M_state);\n           return _M_state->wait_until(__abs);\n         }\n \n@@ -537,7 +536,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __result_type\n       _M_get_result()\n       {\n-        _State::_S_check(_M_state);\n+        _State_base::_S_check(_M_state);\n         _Result_base& __res = _M_state->wait();\n         if (!(__res._M_error == 0))\n           rethrow_exception(__res._M_error);\n@@ -553,7 +552,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       explicit\n       __basic_future(const __state_type& __state) : _M_state(__state)\n       {\n-        _State::_S_check(_M_state);\n+        _State_base::_S_check(_M_state);\n         _M_state->_M_set_retrieved_flag();\n       }\n \n@@ -850,9 +849,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Res>\n     class promise\n     {\n-      typedef __future_base::_State \t\t_State;\n-      typedef __future_base::_Result<_Res>\t_Res_type;\n-      typedef typename __future_base::_Ptr<_Res_type>::type _Ptr_type;\n+      typedef __future_base::_State_base \t\t\t_State;\n+      typedef __future_base::_Result<_Res>\t\t\t_Res_type;\n+      typedef typename __future_base::_Ptr<_Res_type>::type\t_Ptr_type;\n       template<typename, typename> friend class _State::_Setter;\n       \n       shared_ptr<_State>                        _M_future;\n@@ -942,9 +941,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Res>\n     class promise<_Res&>\n     {\n-      typedef __future_base::_State \t\t_State;\n-      typedef __future_base::_Result<_Res&>\t_Res_type;\n-      typedef typename __future_base::_Ptr<_Res_type>::type _Ptr_type;\n+      typedef __future_base::_State_base\t\t\t_State;\n+      typedef __future_base::_Result<_Res&>\t\t\t_Res_type;\n+      typedef typename __future_base::_Ptr<_Res_type>::type \t_Ptr_type;\n       template<typename, typename> friend class _State::_Setter;\n \n       shared_ptr<_State>                        _M_future;\n@@ -1017,9 +1016,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<>\n     class promise<void>\n     {\n-      typedef __future_base::_State \t\t_State;\n-      typedef __future_base::_Result<void>\t_Res_type;\n-      typedef typename __future_base::_Ptr<_Res_type>::type _Ptr_type;\n+      typedef __future_base::_State_base\t\t\t_State;\n+      typedef __future_base::_Result<void>\t\t\t_Res_type;\n+      typedef typename __future_base::_Ptr<_Res_type>::type \t_Ptr_type;\n       template<typename, typename> friend class _State::_Setter;\n \n       shared_ptr<_State>                        _M_future;\n@@ -1085,19 +1084,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // set void\n   template<>\n-    struct __future_base::_State::_Setter<void, void>\n+    struct __future_base::_State_base::_Setter<void, void>\n     {\n       promise<void>::_Ptr_type operator()()\n       {\n-        _State::_S_check(_M_promise->_M_future);\n+        _State_base::_S_check(_M_promise->_M_future);\n         return std::move(_M_promise->_M_storage);\n       }\n \n       promise<void>*    _M_promise;\n     };\n \n-  inline __future_base::_State::_Setter<void, void>\n-  __future_base::_State::__setter(promise<void>* __prom)\n+  inline __future_base::_State_base::_Setter<void, void>\n+  __future_base::_State_base::__setter(promise<void>* __prom)\n   {\n     return _Setter<void, void>{ __prom };\n   }\n@@ -1149,7 +1148,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Res, typename... _Args>\n-    struct __future_base::_Task_state<_Res(_Args...)> : __future_base::_State\n+    struct __future_base::_Task_state<_Res(_Args...)> \n+    : __future_base::_State_base\n     {\n       typedef _Res _Res_type;\n \n@@ -1263,14 +1263,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       operator()(_ArgTypes... __args)\n       {\n-        __future_base::_State::_S_check(_M_state);\n+        __future_base::_State_base::_S_check(_M_state);\n         _M_state->_M_run(std::forward<_ArgTypes>(__args)...);\n       }\n \n       void\n       reset()\n       {\n-        __future_base::_State::_S_check(_M_state);\n+        __future_base::_State_base::_S_check(_M_state);\n         packaged_task(std::move(_M_state->_M_task)).swap(*this);\n       }\n     };\n@@ -1288,7 +1288,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \n   template<typename _Res>\n-    class __future_base::_Deferred_state : public __future_base::_State\n+    class __future_base::_Deferred_state : public __future_base::_State_base\n     {\n     public:\n       typedef _Res _Res_type;\n@@ -1314,7 +1314,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Res>\n-    class __future_base::_Async_state : public __future_base::_State\n+    class __future_base::_Async_state : public __future_base::_State_base\n     {\n     public:\n       typedef _Res _Res_type;\n@@ -1347,7 +1347,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     async(launch __policy, _Fn&& __fn, _Args&&... __args)\n     {\n       typedef typename result_of<_Fn(_Args...)>::type result_type;\n-      std::shared_ptr<__future_base::_State> __state;\n+      std::shared_ptr<__future_base::_State_base> __state;\n       if (__policy == launch::async)\n \t{\n \t  typedef typename __future_base::_Async_state<result_type> _State;"}, {"sha": "a461795d7ec8ed3ee225d2ff0429cf3ef4779c15", "filename": "libstdc++-v3/include/std/stdexcept", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdexcept", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdexcept", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdexcept?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -1,6 +1,6 @@\n // Standard exception classes  -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2005, 2007, 2009, 2010\n+// Copyright (C) 2001, 2002, 2005, 2007, 2009, 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -62,8 +62,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     explicit \n     logic_error(const string& __arg);\n \n-    virtual \n-    ~logic_error() throw();\n+    virtual ~logic_error() throw();\n \n     /** Returns a C-style character string describing the general cause of\n      *  the current error (the same string passed to the ctor).  */\n@@ -77,13 +76,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n   public:\n     explicit domain_error(const string& __arg);\n+    virtual ~domain_error() throw();\n   };\n \n   /** Thrown to report invalid arguments to functions.  */\n   class invalid_argument : public logic_error \n   {\n   public:\n     explicit invalid_argument(const string& __arg);\n+    virtual ~invalid_argument() throw();\n   };\n \n   /** Thrown when an object is constructed that would exceed its maximum\n@@ -92,6 +93,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n   public:\n     explicit length_error(const string& __arg);\n+    virtual ~length_error() throw();\n   };\n \n   /** This represents an argument whose value is not within the expected\n@@ -100,6 +102,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n   public:\n     explicit out_of_range(const string& __arg);\n+    virtual ~out_of_range() throw();\n   };\n \n   /** Runtime errors represent problems outside the scope of a program;\n@@ -116,8 +119,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     explicit \n     runtime_error(const string& __arg);\n \n-    virtual \n-    ~runtime_error() throw();\n+    virtual ~runtime_error() throw();\n \n     /** Returns a C-style character string describing the general cause of\n      *  the current error (the same string passed to the ctor).  */\n@@ -130,20 +132,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n   public:\n     explicit range_error(const string& __arg);\n+    virtual ~range_error() throw();\n   };\n \n   /** Thrown to indicate arithmetic overflow.  */\n   class overflow_error : public runtime_error \n   {\n   public:\n     explicit overflow_error(const string& __arg);\n+    virtual ~overflow_error() throw();\n   };\n \n   /** Thrown to indicate arithmetic underflow.  */\n   class underflow_error : public runtime_error \n   {\n   public:\n     explicit underflow_error(const string& __arg);\n+    virtual ~underflow_error() throw();\n   };\n \n   // @} group exceptions"}, {"sha": "da09a758825a4524348fcd5cf4cdce781db27324", "filename": "libstdc++-v3/include/std/system_error", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsystem_error?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -1,6 +1,6 @@\n // <system_error> -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -69,7 +69,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     error_category();\n \n   public:\n-    virtual ~error_category() { }\n+    virtual ~error_category();\n \n     error_category(const error_category&) = delete;\n     error_category& operator=(const error_category&) = delete;\n@@ -102,8 +102,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return this != &__other; }\n   };\n \n-  inline error_category::error_category() = default;\n-\n   // DR 890.\n   _GLIBCXX_CONST const error_category& system_category() throw();\n   _GLIBCXX_CONST const error_category& generic_category() throw();"}, {"sha": "e43c126cdceb908f25fd6046d5df171289c3b981", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -100,7 +100,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       __shared_base_type\t_M_this_ptr;\n \n-      inline virtual ~_Impl_base();\n+      virtual ~_Impl_base();\n \n       virtual void _M_run() = 0;\n     };\n@@ -195,8 +195,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n   };\n \n-  inline thread::_Impl_base::~_Impl_base() = default;\n-\n   inline void\n   swap(thread& __x, thread& __y)\n   { __x.swap(__y); }"}, {"sha": "701c2d9a76ad599b6949fc05d73194db3898da75", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -77,6 +77,7 @@ sources = \\\n \tguard.cc \\\n \tguard_error.cc \\\n \thash_bytes.cc \\\n+\tnested_exception.cc \\\n \tnew_handler.cc \\\n \tnew_op.cc \\\n \tnew_opnt.cc \\\n@@ -134,6 +135,11 @@ cp-demangle.o: cp-demangle.c\n \t$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<\n \n \n+nested_exception.lo: nested_exception.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+nested_exception.o: nested_exception.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n # Libtool notes\n \n # 1) Need to explicitly set LTCXXCOMPILE so that AM_CXXFLAGS is"}, {"sha": "18ba840180ebfb068adac7c737234c2cfe92e958", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -98,10 +98,10 @@ am__objects_1 = array_type_info.lo atexit_arm.lo bad_alloc.lo \\\n \teh_term_handler.lo eh_terminate.lo eh_throw.lo eh_type.lo \\\n \teh_unex_handler.lo enum_type_info.lo function_type_info.lo \\\n \tfundamental_type_info.lo guard.lo guard_error.lo hash_bytes.lo \\\n-\tnew_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo \\\n-\tpbase_type_info.lo pmem_type_info.lo pointer_type_info.lo \\\n-\tpure.lo si_class_type_info.lo tinfo.lo tinfo2.lo vec.lo \\\n-\tvmi_class_type_info.lo vterminate.lo\n+\tnested_exception.lo new_handler.lo new_op.lo new_opnt.lo \\\n+\tnew_opv.lo new_opvnt.lo pbase_type_info.lo pmem_type_info.lo \\\n+\tpointer_type_info.lo pure.lo si_class_type_info.lo tinfo.lo \\\n+\ttinfo2.lo vec.lo vmi_class_type_info.lo vterminate.lo\n @GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo\n am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libsupc___la_OBJECTS = $(am_libsupc___la_OBJECTS)\n@@ -383,6 +383,7 @@ sources = \\\n \tguard.cc \\\n \tguard_error.cc \\\n \thash_bytes.cc \\\n+\tnested_exception.cc \\\n \tnew_handler.cc \\\n \tnew_op.cc \\\n \tnew_opnt.cc \\\n@@ -766,6 +767,11 @@ cp-demangle.lo: cp-demangle.c\n cp-demangle.o: cp-demangle.c\n \t$(C_COMPILE) -DIN_GLIBCPP_V3 -Wno-error -c $<\n \n+nested_exception.lo: nested_exception.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+nested_exception.o: nested_exception.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n install-stdHEADERS: $(std_HEADERS)\n \t@$(NORMAL_INSTALL)\n \t$(mkinstalldirs) $(DESTDIR)$(stddir)"}, {"sha": "876e8e00aa137c854b9d14133f327b3ddf506942", "filename": "libstdc++-v3/libsupc++/nested_exception.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright (C) 2011 Free Software Foundation\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <exception>\n+\n+namespace std \n+{\n+  nested_exception::~nested_exception() = default;\n+} // namespace std"}, {"sha": "6a4f04e2e07b9aec0ac0e39d797a7c49d9e679ff", "filename": "libstdc++-v3/libsupc++/nested_exception.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnested_exception.h?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -63,7 +63,7 @@ namespace std\n \n     nested_exception& operator=(const nested_exception&) = default;\n \n-    inline virtual ~nested_exception();\n+    virtual ~nested_exception();\n \n     void\n     rethrow_nested() const __attribute__ ((__noreturn__))\n@@ -74,8 +74,6 @@ namespace std\n     { return _M_ptr; }\n   };\n \n-  inline nested_exception::~nested_exception() = default;\n-\n   template<typename _Except>\n     struct _Nested_exception : public _Except, public nested_exception\n     {"}, {"sha": "9a3568551385bc655d9def3b40f7c6e2d9a086a7", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -201,6 +201,7 @@ sources = \\\n \tctype.cc \\\n \tdebug.cc \\\n \tfunctexcept.cc \\\n+\tfunctional.cc \\\n \tglobals_io.cc \\\n \thash_c++0x.cc \\\n \thash_tr1.cc \\\n@@ -225,6 +226,7 @@ sources = \\\n \tistream.cc \\\n \tplaceholders.cc \\\n \tregex.cc \\\n+\tshared_ptr.cc \\\n \tstreambuf.cc \\\n \tmutex.cc \\\n \tcondition_variable.cc \\\n@@ -292,6 +294,11 @@ functexcept.lo: functexcept.cc\n functexcept.o: functexcept.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+shared_ptr.lo: shared_ptr.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+shared_ptr.o: shared_ptr.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n system_error.lo: system_error.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n system_error.o: system_error.cc\n@@ -312,6 +319,11 @@ compatibility-c++0x.lo: compatibility-c++0x.cc\n compatibility-c++0x.o: compatibility-c++0x.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+functional.lo: functional.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+functional.o: functional.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n hash_c++0x.lo: hash_c++0x.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n hash_c++0x.o: hash_c++0x.cc"}, {"sha": "b454f66dc8b032d3ffabc4db56b73c98fca3815d", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -110,13 +110,13 @@ am__objects_6 = atomic.lo bitmap_allocator.lo pool_allocator.lo \\\n \tcompatibility-c++0x.lo compatibility-debug_list.lo \\\n \tcompatibility-debug_list-2.lo compatibility-list.lo \\\n \tcompatibility-list-2.lo complex_io.lo ctype.lo debug.lo \\\n-\tfunctexcept.lo globals_io.lo hash_c++0x.lo hash_tr1.lo \\\n-\thashtable_c++0x.lo hashtable_tr1.lo ios.lo ios_failure.lo \\\n-\tios_init.lo ios_locale.lo limits.lo list.lo locale.lo \\\n-\tlocale_init.lo locale_facets.lo localename.lo \\\n+\tfunctexcept.lo functional.lo globals_io.lo hash_c++0x.lo \\\n+\thash_tr1.lo hashtable_c++0x.lo hashtable_tr1.lo ios.lo \\\n+\tios_failure.lo ios_init.lo ios_locale.lo limits.lo list.lo \\\n+\tlocale.lo locale_init.lo locale_facets.lo localename.lo \\\n \tmath_stubs_float.lo math_stubs_long_double.lo stdexcept.lo \\\n \tstrstream.lo system_error.lo tree.lo istream.lo \\\n-\tplaceholders.lo regex.lo streambuf.lo mutex.lo \\\n+\tplaceholders.lo regex.lo shared_ptr.lo streambuf.lo mutex.lo \\\n \tcondition_variable.lo chrono.lo thread.lo future.lo \\\n \tvalarray.lo $(am__objects_1) $(am__objects_5)\n am_libstdc___la_OBJECTS = $(am__objects_6)\n@@ -420,6 +420,7 @@ sources = \\\n \tctype.cc \\\n \tdebug.cc \\\n \tfunctexcept.cc \\\n+\tfunctional.cc \\\n \tglobals_io.cc \\\n \thash_c++0x.cc \\\n \thash_tr1.cc \\\n@@ -444,6 +445,7 @@ sources = \\\n \tistream.cc \\\n \tplaceholders.cc \\\n \tregex.cc \\\n+\tshared_ptr.cc \\\n \tstreambuf.cc \\\n \tmutex.cc \\\n \tcondition_variable.cc \\\n@@ -885,6 +887,11 @@ functexcept.lo: functexcept.cc\n functexcept.o: functexcept.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+shared_ptr.lo: shared_ptr.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+shared_ptr.o: shared_ptr.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n system_error.lo: system_error.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n system_error.o: system_error.cc\n@@ -905,6 +912,11 @@ compatibility-c++0x.lo: compatibility-c++0x.cc\n compatibility-c++0x.o: compatibility-c++0x.cc\n \t$(CXXCOMPILE) -std=gnu++0x -c $<\n \n+functional.lo: functional.cc\n+\t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n+functional.o: functional.cc\n+\t$(CXXCOMPILE) -std=gnu++0x -c $<\n+\n hash_c++0x.lo: hash_c++0x.cc\n \t$(LTCXXCOMPILE) -std=gnu++0x -c $<\n hash_c++0x.o: hash_c++0x.cc"}, {"sha": "2ab34051432cf29155fd9764a2ad87d333a5482f", "filename": "libstdc++-v3/src/functional.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Ffunctional.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Ffunctional.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffunctional.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -0,0 +1,35 @@\n+// Support for <functional> -*- C++ -*-\n+\n+// Copyright (C) 2011\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  bad_function_call::~bad_function_call() throw() = default;\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "d2bc3237019dbed5e93812ac28b47ebeb4631fc3", "filename": "libstdc++-v3/src/future.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffuture.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -79,8 +79,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   const char* \n   future_error::what() const throw() { return _M_code.message().c_str(); }\n \n+  __future_base::_Result_base::_Result_base() = default;\n+\n+  __future_base::_Result_base::~_Result_base() = default;\n+\n+  __future_base::_State_base::~_State_base() = default;\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace\n+} // namespace std\n \n // XXX GLIBCXX_ABI Deprecated\n // gcc-4.6.0"}, {"sha": "670b7ca7ff0c19bf9aa0dfbb93e2969828779175", "filename": "libstdc++-v3/src/shared_ptr.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fshared_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fshared_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fshared_ptr.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -0,0 +1,39 @@\n+// Support for pointer abstractions -*- C++ -*-\n+\n+// Copyright (C) 2011\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  bad_weak_ptr::~bad_weak_ptr() throw() = default;\n+\n+  char const*\n+  bad_weak_ptr::what() const throw()  \n+  { return \"std::bad_weak_ptr\"; }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace"}, {"sha": "b693da23f4f2b541e51f36e838ccf3457cde202b", "filename": "libstdc++-v3/src/stdexcept.cc", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fstdexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fstdexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstdexcept.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -1,6 +1,6 @@\n // Methods for Exception Support for -*- C++ -*-\n \n-// Copyright (C) 1997, 1999, 2001, 2002, 2005, 2009\n+// Copyright (C) 1997, 1999, 2001, 2002, 2005, 2009, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -34,7 +34,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  logic_error::logic_error(const string& __arg) \n+  logic_error::logic_error(const string& __arg)\n   : exception(), _M_msg(__arg) { }\n \n   logic_error::~logic_error() throw() { }\n@@ -46,16 +46,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   domain_error::domain_error(const string& __arg)\n   : logic_error(__arg) { }\n \n+  domain_error::~domain_error() throw() { }\n+\n   invalid_argument::invalid_argument(const string& __arg)\n   : logic_error(__arg) { }\n \n+  invalid_argument::~invalid_argument() throw() { }\n+\n   length_error::length_error(const string& __arg)\n   : logic_error(__arg) { }\n \n+  length_error::~length_error() throw() { }\n+\n   out_of_range::out_of_range(const string& __arg)\n   : logic_error(__arg) { }\n \n-  runtime_error::runtime_error(const string& __arg) \n+  out_of_range::~out_of_range() throw() { }\n+\n+  runtime_error::runtime_error(const string& __arg)\n   : exception(), _M_msg(__arg) { }\n \n   runtime_error::~runtime_error() throw() { }\n@@ -67,12 +75,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   range_error::range_error(const string& __arg)\n   : runtime_error(__arg) { }\n \n+  range_error::~range_error() throw() { }\n+\n   overflow_error::overflow_error(const string& __arg)\n   : runtime_error(__arg) { }\n \n+  overflow_error::~overflow_error() throw() { }\n+\n   underflow_error::underflow_error(const string& __arg)\n   : runtime_error(__arg) { }\n \n+  underflow_error::~underflow_error() throw() { }\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n-"}, {"sha": "5d9c6f5e26bce17d9900aa0d8b8d41289aca7368", "filename": "libstdc++-v3/src/system_error.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fsystem_error.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fsystem_error.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fsystem_error.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -1,6 +1,6 @@\n // <system_error> implementation file\n \n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -74,13 +74,17 @@ namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  error_category::error_category() = default;\n+\n+  error_category::~error_category() = default;\n+\n   const error_category& \n   system_category() throw() { return system_category_instance; }\n \n   const error_category& \n   generic_category() throw() { return generic_category_instance; }\n   \n-  system_error::~system_error() throw() { }\n+  system_error::~system_error() throw() = default;\n \n   error_condition \n   error_category::default_error_condition(int __i) const"}, {"sha": "7c923a2661019a11cfa697874b9eafe67c985f08", "filename": "libstdc++-v3/src/thread.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fthread.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -54,6 +54,8 @@ namespace std _GLIBCXX_VISIBILITY(default)\n \n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  thread::_Impl_base::~_Impl_base() = default;\n+\n   void\n   thread::join()\n   {"}, {"sha": "36cf7f9c29d2a2c8035a4011e8de7de4f2c0e753", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/43820_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2F43820_neg.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -32,9 +32,9 @@ void test01()\n {\n   X* px = 0;\n   std::shared_ptr<X> p1(px);   // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 765 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 766 }\n \n   std::shared_ptr<X> p9(ap());  // { dg-error \"here\" }\n-  // { dg-error \"incomplete\" \"\" { target *-*-* } 857 }\n+  // { dg-error \"incomplete\" \"\" { target *-*-* } 858 }\n \n }"}, {"sha": "28c8797b9ca47ae567f0fadfe799f19837b016a4", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95992339f9c10fce65d2eea8c95fe9e5a84d43c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc?ref=e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "patch": "@@ -43,7 +43,7 @@ main()\n }\n \n // { dg-warning \"note\" \"\" { target *-*-* } 354 }\n-// { dg-warning \"note\" \"\" { target *-*-* } 1085 }\n+// { dg-warning \"note\" \"\" { target *-*-* } 1086 }\n // { dg-warning \"note\" \"\" { target *-*-* } 467 }\n // { dg-warning \"note\" \"\" { target *-*-* } 587 }\n // { dg-warning \"note\" \"\" { target *-*-* } 1050 }"}]}