{"sha": "a312242430aba54965cde34ef5f249751bd56497", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMxMjI0MjQzMGFiYTU0OTY1Y2RlMzRlZjVmMjQ5NzUxYmQ1NjQ5Nw==", "commit": {"author": {"name": "Canqun Yang", "email": "canqun@nudt.edu.cn", "date": "2005-03-26T05:34:58Z"}, "committer": {"name": "Canqun Yang", "email": "canqun@gcc.gnu.org", "date": "2005-03-26T05:34:58Z"}, "message": "trans-common.c (create_common): Build RECORD_NODE for common blocks contain no equivalence objects.\n\n\t* trans-common.c (create_common): Build RECORD_NODE for common blocks\n\tcontain no equivalence objects.\n\t(add_equivalences): New argument saw_equiv.\n\t(trans_common): New local variable saw_equiv.\n\t(finish_equivalences): Add a local variable dummy, Always pass true\n\tfor the 3rd parameter to create_common.\n\nFrom-SVN: r97079", "tree": {"sha": "29833a7f9086efd155911e55276a376a4d654262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29833a7f9086efd155911e55276a376a4d654262"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a312242430aba54965cde34ef5f249751bd56497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a312242430aba54965cde34ef5f249751bd56497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a312242430aba54965cde34ef5f249751bd56497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a312242430aba54965cde34ef5f249751bd56497/comments", "author": null, "committer": null, "parents": [{"sha": "1ad81c8e5789887beee44c95ee81e21b920408a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad81c8e5789887beee44c95ee81e21b920408a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad81c8e5789887beee44c95ee81e21b920408a8"}], "stats": {"total": 38, "additions": 30, "deletions": 8}, "files": [{"sha": "5e93f5f98cfbc9009ce7298cf4481498eeb5b368", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a312242430aba54965cde34ef5f249751bd56497/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a312242430aba54965cde34ef5f249751bd56497/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a312242430aba54965cde34ef5f249751bd56497", "patch": "@@ -1,3 +1,12 @@\n+2005-03-26  Canqun Yang  <canqun@nudt.edu.cn>\n+\n+\t* trans-common.c (create_common): Build RECORD_NODE for common blocks\n+\tcontain no equivalence objects.\n+\t(add_equivalences): New argument saw_equiv.\n+\t(trans_common): New local variable saw_equiv.\n+\t(finish_equivalences): Add a local variable dummy, Always pass true\n+\tfor the 3rd parameter to create_common.\n+\n 2005-03-25  Steven G. Kargl  <kargls@comcast.net>\n \n \t* intrinsic.texi: Fix \"make dvi\""}, {"sha": "42e6712332807814dfe9304f5049c538dbddaaac", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a312242430aba54965cde34ef5f249751bd56497/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a312242430aba54965cde34ef5f249751bd56497/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=a312242430aba54965cde34ef5f249751bd56497", "patch": "@@ -379,7 +379,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n    backend declarations for all of the elements.  */\n \n static void\n-create_common (gfc_common_head *com, segment_info * head)\n+create_common (gfc_common_head *com, segment_info * head, bool saw_equiv)\n {\n   segment_info *s, *next_s;\n   tree union_type;\n@@ -388,8 +388,16 @@ create_common (gfc_common_head *com, segment_info * head)\n   tree decl;\n   bool is_init = false;\n \n-  /* Declare the variables inside the common block.  */\n-  union_type = make_node (UNION_TYPE);\n+  /* Declare the variables inside the common block.\n+     If the current common block contains any equivalence object, then\n+     make a UNION_TYPE node, otherwise RECORD_TYPE. This will let the\n+     alias analyzer work well when there is no address overlapping for\n+     common variables in the current common block.  */\n+  if (saw_equiv)\n+    union_type = make_node (UNION_TYPE);\n+  else\n+    union_type = make_node (RECORD_TYPE);\n+\n   rli = start_record_layout (union_type);\n   field_link = &TYPE_FIELDS (union_type);\n \n@@ -703,7 +711,7 @@ find_equivalence (segment_info *n)\n    segment list multiple times to include indirect equivalences.  */\n \n static void\n-add_equivalences (void)\n+add_equivalences (bool *saw_equiv)\n {\n   segment_info *f;\n   bool more;\n@@ -718,6 +726,8 @@ add_equivalences (void)\n \t    {\n \t      f->sym->equiv_built = 1;\n \t      more = find_equivalence (f);\n+\t      if (more)\n+\t\t*saw_equiv = true;\n \t    }\n \t}\n     }\n@@ -788,10 +798,12 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n   HOST_WIDE_INT current_offset;\n   unsigned HOST_WIDE_INT align;\n   unsigned HOST_WIDE_INT max_align;\n+  bool saw_equiv;\n \n   common_segment = NULL;\n   current_offset = 0;\n   max_align = 1;\n+  saw_equiv = false;\n \n   /* Add symbols to the segment.  */\n   for (sym = var_list; sym; sym = sym->common_next)\n@@ -821,7 +833,7 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n \n \t  /* Add all objects directly or indirectly equivalenced with this\n \t     symbol.  */\n-\t  add_equivalences ();\n+\t  add_equivalences (&saw_equiv);\n \n \t  if (current_segment->offset < 0)\n \t    gfc_error (\"The equivalence set for '%s' cause an invalid \"\n@@ -865,7 +877,7 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n \t\t   common->name, &common->where, common_segment->offset);\n     }\n \n-  create_common (common, common_segment);\n+  create_common (common, common_segment, saw_equiv);\n }\n \n \n@@ -878,6 +890,7 @@ finish_equivalences (gfc_namespace *ns)\n   gfc_symbol *sym;\n   HOST_WIDE_INT offset;\n   unsigned HOST_WIDE_INT align;\n+  bool dummy;\n \n   for (z = ns->equiv; z; z = z->next)\n     for (y = z->eq; y; y = y->eq)\n@@ -888,7 +901,7 @@ finish_equivalences (gfc_namespace *ns)\n         current_segment = get_segment_info (sym, 0);\n \n         /* All objects directly or indirectly equivalenced with this symbol.  */\n-        add_equivalences ();\n+        add_equivalences (&dummy);\n \n \t/* Align the block.  */\n \toffset = align_segment (&align);\n@@ -899,7 +912,7 @@ finish_equivalences (gfc_namespace *ns)\n \tapply_segment_offset (current_segment, offset);\n \n \t/* Create the decl.  */\n-        create_common (NULL, current_segment);\n+        create_common (NULL, current_segment, true);\n         break;\n       }\n }"}]}