{"sha": "0c5863c253fc68676c1b5febc2c49b1d0d088971", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM1ODYzYzI1M2ZjNjg2NzZjMWI1ZmViYzJjNDliMWQwZDA4ODk3MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-03T06:59:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-03T06:59:09Z"}, "message": "re PR debug/43177 (Handle at least simple cases of reversible insns in debug info)\n\n\tPR debug/43177\n\t* var-tracking.c (loc_cmp): Don't assert VALUEs have the same mode.\n\t(VAL_EXPR_HAS_REVERSE): Define.\n\t(reverse_op): New function.\n\t(add_stores): For reversible operations add an extra MO_VAL_USE.\n\n\t* gcc.dg/guality/pr43177.c: New test.\n\nFrom-SVN: r157188", "tree": {"sha": "0d80eefe15903c2dfc70889104ca8beb3e819ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d80eefe15903c2dfc70889104ca8beb3e819ba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c5863c253fc68676c1b5febc2c49b1d0d088971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5863c253fc68676c1b5febc2c49b1d0d088971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5863c253fc68676c1b5febc2c49b1d0d088971", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5863c253fc68676c1b5febc2c49b1d0d088971/comments", "author": null, "committer": null, "parents": [{"sha": "7428bc268d4d669ce01d9f27e6db6028e2fc1e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7428bc268d4d669ce01d9f27e6db6028e2fc1e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7428bc268d4d669ce01d9f27e6db6028e2fc1e11"}], "stats": {"total": 176, "additions": 169, "deletions": 7}, "files": [{"sha": "563835b630a29ecb2e1ac614e90ad1345cb8a0e4", "filename": "gcc/testsuite/gcc.dg/guality/pr43177.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5863c253fc68676c1b5febc2c49b1d0d088971/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43177.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5863c253fc68676c1b5febc2c49b1d0d088971/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43177.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43177.c?ref=0c5863c253fc68676c1b5febc2c49b1d0d088971", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+void __attribute__((noinline))\n+bar (long x)\n+{\n+  asm volatile (\"\" : : \"r\" (x) : \"memory\");\n+}\n+\n+long __attribute__((noinline))\n+foo (long x)\n+{\n+  long l = x + 3;\n+  bar (l);/* { dg-final { gdb-test 15 \"l\" \"10\" } } */\n+  bar (l);/* { dg-final { gdb-test 15 \"x\" \"7\" } } */\n+  return l;\n+}\n+\n+long __attribute__((noinline))\n+baz (int x)\n+{\n+  long l = x + 3;\n+  bar (l);/* { dg-final { gdb-test 24 \"l\" \"10\" } } */\n+  bar (l);/* { dg-final { gdb-test 24 \"x\" \"7\" } } */\n+  return l;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  asm volatile (\"\" : \"=r\" (i) : \"0\" (7));\n+  foo (i);\n+  baz (i);\n+  return 0;\n+}"}, {"sha": "a77ece9354ecdbba3f266647ff58314e9a20c77f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 133, "deletions": 7, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5863c253fc68676c1b5febc2c49b1d0d088971/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5863c253fc68676c1b5febc2c49b1d0d088971/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0c5863c253fc68676c1b5febc2c49b1d0d088971", "patch": "@@ -2478,7 +2478,10 @@ loc_cmp (rtx x, rtx y)\n     {\n       if (GET_CODE (y) != VALUE)\n \treturn -1;\n-      gcc_assert (GET_MODE (x) == GET_MODE (y));\n+      /* Don't assert the modes are the same, that is true only\n+\t when not recursing.  (subreg:QI (value:SI 1:1) 0)\n+\t and (subreg:QI (value:DI 2:2) 0) can be compared,\n+\t even when the modes are different.  */\n       if (canon_value_cmp (x, y))\n \treturn -1;\n       else\n@@ -4678,6 +4681,10 @@ count_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n    MO_CLOBBER as well.  */\n #define VAL_EXPR_IS_CLOBBERED(x) \\\n   (RTL_FLAG_CHECK1 (\"VAL_EXPR_IS_CLOBBERED\", (x), CONCAT)->unchanging)\n+/* Whether the location is a CONCAT of the MO_VAL_SET expression and\n+   a reverse operation that should be handled afterwards.  */\n+#define VAL_EXPR_HAS_REVERSE(x) \\\n+  (RTL_FLAG_CHECK1 (\"VAL_EXPR_HAS_REVERSE\", (x), CONCAT)->return_val)\n \n /* Add uses (register and memory references) LOC which will be tracked\n    to VTI (bb)->mos.  INSN is instruction which the LOC is part of.  */\n@@ -4863,6 +4870,92 @@ add_uses_1 (rtx *x, void *cui)\n   for_each_rtx (x, add_uses, cui);\n }\n \n+/* Attempt to reverse the EXPR operation in the debug info.  Say for\n+   reg1 = reg2 + 6 even when reg2 is no longer live we\n+   can express its value as VAL - 6.  */\n+\n+static rtx\n+reverse_op (rtx val, const_rtx expr)\n+{\n+  rtx src, arg, ret;\n+  cselib_val *v;\n+  enum rtx_code code;\n+\n+  if (GET_CODE (expr) != SET)\n+    return NULL_RTX;\n+\n+  if (!REG_P (SET_DEST (expr)) || GET_MODE (val) != GET_MODE (SET_DEST (expr)))\n+    return NULL_RTX;\n+\n+  src = SET_SRC (expr);\n+  switch (GET_CODE (src))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case XOR:\n+    case NOT:\n+    case NEG:\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      break;\n+    default:\n+      return NULL_RTX;\n+    }\n+\n+  if (!REG_P (XEXP (src, 0)) || !SCALAR_INT_MODE_P (GET_MODE (src)))\n+    return NULL_RTX;\n+\n+  v = cselib_lookup (XEXP (src, 0), GET_MODE (XEXP (src, 0)), 0);\n+  if (!v || !cselib_preserved_value_p (v))\n+    return NULL_RTX;\n+\n+  switch (GET_CODE (src))\n+    {\n+    case NOT:\n+    case NEG:\n+      if (GET_MODE (v->val_rtx) != GET_MODE (val))\n+\treturn NULL_RTX;\n+      ret = gen_rtx_fmt_e (GET_CODE (src), GET_MODE (val), val);\n+      break;\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      ret = gen_lowpart_SUBREG (GET_MODE (v->val_rtx), val);\n+      break;\n+    case XOR:\n+      code = XOR;\n+      goto binary;\n+    case PLUS:\n+      code = MINUS;\n+      goto binary;\n+    case MINUS:\n+      code = PLUS;\n+      goto binary;\n+    binary:\n+      if (GET_MODE (v->val_rtx) != GET_MODE (val))\n+\treturn NULL_RTX;\n+      arg = XEXP (src, 1);\n+      if (!CONST_INT_P (arg) && GET_CODE (arg) != SYMBOL_REF)\n+\t{\n+\t  arg = cselib_expand_value_rtx (arg, scratch_regs, 5);\n+\t  if (arg == NULL_RTX)\n+\t    return NULL_RTX;\n+\t  if (!CONST_INT_P (arg) && GET_CODE (arg) != SYMBOL_REF)\n+\t    return NULL_RTX;\n+\t}\n+      ret = simplify_gen_binary (code, GET_MODE (val), val, arg);\n+      if (ret == val)\n+\t/* Ensure ret isn't VALUE itself (which can happen e.g. for\n+\t   (plus (reg1) (reg2)) when reg2 is known to be 0), as that\n+\t   breaks a lot of routines during var-tracking.  */\n+\tret = gen_rtx_fmt_ee (PLUS, GET_MODE (val), val, const0_rtx);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return gen_rtx_CONCAT (GET_MODE (v->val_rtx), v->val_rtx, ret);\n+}\n+\n /* Add stores (register and memory references) LOC which will be tracked\n    to VTI (bb)->mos.  EXPR is the RTL expression containing the store.\n    CUIP->insn is instruction which the LOC is part of.  */\n@@ -4879,6 +4972,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   bool track_p = false;\n   cselib_val *v;\n   bool resolve, preserve;\n+  rtx reverse;\n \n   if (type == MO_CLOBBER)\n     return;\n@@ -5082,6 +5176,16 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n   */\n \n+  if (GET_CODE (PATTERN (cui->insn)) != COND_EXEC)\n+    {\n+      reverse = reverse_op (v->val_rtx, expr);\n+      if (reverse)\n+\t{\n+\t  loc = gen_rtx_CONCAT (GET_MODE (mo->u.loc), loc, reverse);\n+\t  VAL_EXPR_HAS_REVERSE (loc) = 1;\n+\t}\n+    }\n+\n   mo->u.loc = loc;\n \n   if (track_p)\n@@ -5367,10 +5471,17 @@ compute_bb_dataflow (basic_block bb)\n \t  case MO_VAL_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-\t      rtx val, vloc, uloc;\n+\t      rtx val, vloc, uloc, reverse = NULL_RTX;\n \n-\t      vloc = uloc = XEXP (loc, 1);\n-\t      val = XEXP (loc, 0);\n+\t      vloc = loc;\n+\t      if (VAL_EXPR_HAS_REVERSE (loc))\n+\t\t{\n+\t\t  reverse = XEXP (loc, 1);\n+\t\t  vloc = XEXP (loc, 0);\n+\t\t}\n+\t      uloc = XEXP (vloc, 1);\n+\t      val = XEXP (vloc, 0);\n+\t      vloc = uloc;\n \n \t      if (GET_CODE (val) == CONCAT)\n \t\t{\n@@ -5443,6 +5554,10 @@ compute_bb_dataflow (basic_block bb)\n \t\tvar_regno_delete (out, REGNO (uloc));\n \n \t      val_store (out, val, vloc, insn, true);\n+\n+\t      if (reverse)\n+\t\tval_store (out, XEXP (reverse, 0), XEXP (reverse, 1),\n+\t\t\t   insn, false);\n \t    }\n \t    break;\n \n@@ -7012,10 +7127,17 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t  case MO_VAL_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-\t      rtx val, vloc, uloc;\n+\t      rtx val, vloc, uloc, reverse = NULL_RTX;\n \n-\t      vloc = uloc = XEXP (loc, 1);\n-\t      val = XEXP (loc, 0);\n+\t      vloc = loc;\n+\t      if (VAL_EXPR_HAS_REVERSE (loc))\n+\t\t{\n+\t\t  reverse = XEXP (loc, 1);\n+\t\t  vloc = XEXP (loc, 0);\n+\t\t}\n+\t      uloc = XEXP (vloc, 1);\n+\t      val = XEXP (vloc, 0);\n+\t      vloc = uloc;\n \n \t      if (GET_CODE (val) == CONCAT)\n \t\t{\n@@ -7083,6 +7205,10 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t      val_store (set, val, vloc, insn, true);\n \n+\t      if (reverse)\n+\t\tval_store (set, XEXP (reverse, 0), XEXP (reverse, 1),\n+\t\t\t   insn, false);\n+\n \t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN,\n \t\t\t\t      set->vars);\n \t    }"}]}