{"sha": "8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxMGNjNTJjOWM3YWYwNTc1OWE3N2Q1YmZlNmQ0NmUxNmI1NzFlOA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-08-11T10:50:24Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-08-11T10:50:24Z"}, "message": "re PR fortran/48636 (Enable more inlining with -O2 and higher)\n\n2012-08-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR fortran/48636\n\t* ipa-inline.h (condition): New fields offset, agg_contents and by_ref.\n\t* ipa-inline-analysis.c (agg_position_info): New type.\n\t(add_condition): New parameter aggpos, also store agg_contents, by_ref\n\tand offset.\n\t(dump_condition): Also dump aggregate conditions.\n\t(evaluate_conditions_for_known_args): Also handle aggregate\n\tconditions.  New parameter known_aggs.\n\t(evaluate_properties_for_edge): Gather known aggregate contents.\n\t(inline_node_duplication_hook): Pass NULL known_aggs to\n\tevaluate_conditions_for_known_args.\n\t(unmodified_parm): Split into unmodified_parm and unmodified_parm_1.\n\t(unmodified_parm_or_parm_agg_item): New function.\n\t(set_cond_stmt_execution_predicate): Handle values passed in\n\taggregates.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(will_be_nonconstant_predicate): Likewise.\n\t(estimate_edge_devirt_benefit): Pass new parameter known_aggs to\n\tipa_get_indirect_edge_target.\n\t(estimate_calls_size_and_time): New parameter known_aggs, pass it\n\trecrsively to itself and to estimate_edge_devirt_benefit.\n\t(estimate_node_size_and_time): New vector known_aggs, pass it o\n\tfunctions which need it.\n\t(remap_predicate): New parameter offset_map, use it to remap aggregate\n\tconditions.\n\t(remap_edge_summaries): New parameter offset_map, pass it recursively\n\tto itself and to remap_predicate.\n\t(inline_merge_summary): Also create and populate vector offset_map.\n\t(do_estimate_edge_time): New vector of known aggregate contents,\n\tpassed to functions which need it.\n\t(inline_read_section): Stream new fields of condition.\n\t(inline_write_summary): Likewise.\n\t* ipa-cp.c (ipa_get_indirect_edge_target): Also examine the aggregate\n\tcontents.  Let all local callers pass NULL for known_aggs.\n\n\t* testsuite/gfortran.dg/pr48636.f90: New test.\n\nFrom-SVN: r190313", "tree": {"sha": "43a439de6e36e3979859d9e70595d7bc11210e62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43a439de6e36e3979859d9e70595d7bc11210e62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab96cc5b4dd093b769a909e2245da822c4f8e877", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab96cc5b4dd093b769a909e2245da822c4f8e877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab96cc5b4dd093b769a909e2245da822c4f8e877"}], "stats": {"total": 558, "additions": 425, "deletions": 133}, "files": [{"sha": "8a4bcb56487b4152adaf8fadc0a48199f903d9f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -1,3 +1,40 @@\n+2012-08-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR fortran/48636\n+\t* ipa-inline.h (condition): New fields offset, agg_contents and by_ref.\n+\t* ipa-inline-analysis.c (agg_position_info): New type.\n+\t(add_condition): New parameter aggpos, also store agg_contents, by_ref\n+\tand offset.\n+\t(dump_condition): Also dump aggregate conditions.\n+\t(evaluate_conditions_for_known_args): Also handle aggregate\n+\tconditions.  New parameter known_aggs.\n+\t(evaluate_properties_for_edge): Gather known aggregate contents.\n+\t(inline_node_duplication_hook): Pass NULL known_aggs to\n+\tevaluate_conditions_for_known_args.\n+\t(unmodified_parm): Split into unmodified_parm and unmodified_parm_1.\n+\t(unmodified_parm_or_parm_agg_item): New function.\n+\t(set_cond_stmt_execution_predicate): Handle values passed in\n+\taggregates.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(will_be_nonconstant_predicate): Likewise.\n+\t(estimate_edge_devirt_benefit): Pass new parameter known_aggs to\n+\tipa_get_indirect_edge_target.\n+\t(estimate_calls_size_and_time): New parameter known_aggs, pass it\n+\trecrsively to itself and to estimate_edge_devirt_benefit.\n+\t(estimate_node_size_and_time): New vector known_aggs, pass it o\n+\tfunctions which need it.\n+\t(remap_predicate): New parameter offset_map, use it to remap aggregate\n+\tconditions.\n+\t(remap_edge_summaries): New parameter offset_map, pass it recursively\n+\tto itself and to remap_predicate.\n+\t(inline_merge_summary): Also create and populate vector offset_map.\n+\t(do_estimate_edge_time): New vector of known aggregate contents,\n+\tpassed to functions which need it.\n+\t(inline_read_section): Stream new fields of condition.\n+\t(inline_write_summary): Likewise.\n+\t* ipa-cp.c (ipa_get_indirect_edge_target): Also examine the aggregate\n+\tcontents.  Let all local callers pass NULL for known_aggs.\n+\n 2012-08-11  Jan Hubicka  <jh@suse.cz>\n \n \t* lto-cgraph.c (output_cgraph): Rename to ..."}, {"sha": "1f2ea92fb50bf14abfe9ac2d2cf2fd49efc3bed6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -1084,7 +1084,8 @@ propagate_constants_accross_call (struct cgraph_edge *cs)\n tree\n ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \t\t\t      VEC (tree, heap) *known_vals,\n-\t\t\t      VEC (tree, heap) *known_binfos)\n+\t\t\t      VEC (tree, heap) *known_binfos,\n+\t\t\t      VEC (ipa_agg_jump_function_p, heap) *known_aggs)\n {\n   int param_index = ie->indirect_info->param_index;\n   HOST_WIDE_INT token, anc_offset;\n@@ -1096,8 +1097,26 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \n   if (!ie->indirect_info->polymorphic)\n     {\n-      tree t = (VEC_length (tree, known_vals) > (unsigned int) param_index\n-\t        ? VEC_index (tree, known_vals, param_index) : NULL);\n+      tree t;\n+\n+      if (ie->indirect_info->agg_contents)\n+\t{\n+\t  if (VEC_length (ipa_agg_jump_function_p, known_aggs)\n+\t      > (unsigned int) param_index)\n+\t    {\n+\t      struct ipa_agg_jump_function *agg;\n+\t      agg = VEC_index (ipa_agg_jump_function_p, known_aggs,\n+\t\t\t       param_index);\n+\t      t = ipa_find_agg_cst_for_param (agg, ie->indirect_info->offset,\n+\t\t\t\t\t      ie->indirect_info->by_ref);\n+\t    }\n+\t  else\n+\t    t = NULL;\n+\t}\n+      else\n+\tt = (VEC_length (tree, known_vals) > (unsigned int) param_index\n+\t     ? VEC_index (tree, known_vals, param_index) : NULL);\n+\n       if (t &&\n \t  TREE_CODE (t) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL)\n@@ -1106,6 +1125,7 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n \treturn NULL_TREE;\n     }\n \n+  gcc_assert (!ie->indirect_info->agg_contents);\n   token = ie->indirect_info->otr_token;\n   anc_offset = ie->indirect_info->offset;\n   otr_type = ie->indirect_info->otr_type;\n@@ -1156,7 +1176,8 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       struct inline_summary *isummary;\n       tree target;\n \n-      target = ipa_get_indirect_edge_target (ie, known_csts, known_binfos);\n+      target = ipa_get_indirect_edge_target (ie, known_csts, known_binfos,\n+\t\t\t\t\t     NULL);\n       if (!target)\n \tcontinue;\n \n@@ -1673,7 +1694,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n       tree target;\n \n       next_ie = ie->next_callee;\n-      target = ipa_get_indirect_edge_target (ie, known_vals, NULL);\n+      target = ipa_get_indirect_edge_target (ie, known_vals, NULL, NULL);\n       if (target)\n \tipa_make_edge_direct_to_target (ie, target);\n     }"}, {"sha": "1a3afc456997f52d983b2f20b14e4de822c7fab8", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 307, "deletions": 125, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -203,22 +203,54 @@ not_inlined_predicate (void)\n   return single_cond_predicate (predicate_not_inlined_condition);\n }\n \n+/* Simple description of whether a memory load or a condition refers to a load\n+   from an aggregate and if so, how and where from in the aggregate.\n+   Individual fields have the same meaning like fields with the same name in\n+   struct condition.  */\n \n-/* Add condition to condition list CONDS.  */\n+struct agg_position_info\n+{\n+  HOST_WIDE_INT offset;\n+  bool agg_contents;\n+  bool by_ref;\n+};\n+\n+/* Add condition to condition list CONDS.  AGGPOS describes whether the used\n+   oprand is loaded from an aggregate and where in the aggregate it is.  It can\n+   be NULL, which means this not a load from an aggregate.  */\n \n static struct predicate\n add_condition (struct inline_summary *summary, int operand_num,\n+\t       struct agg_position_info *aggpos,\n \t       enum tree_code code, tree val)\n {\n   int i;\n   struct condition *c;\n   struct condition new_cond;\n+  HOST_WIDE_INT offset;\n+  bool agg_contents, by_ref;\n \n+  if (aggpos)\n+    {\n+      offset = aggpos->offset;\n+      agg_contents = aggpos->agg_contents;\n+      by_ref = aggpos->by_ref;\n+    }\n+  else\n+    {\n+      offset = 0;\n+      agg_contents = false;\n+      by_ref = false;\n+    }\n+\n+  gcc_checking_assert (operand_num >= 0);\n   for (i = 0; VEC_iterate (condition, summary->conds, i, c); i++)\n     {\n       if (c->operand_num == operand_num\n \t  && c->code == code\n-\t  && c->val == val)\n+\t  && c->val == val\n+\t  && c->agg_contents == agg_contents\n+\t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n         return single_cond_predicate (i + predicate_first_dynamic_condition);\n     }\n   /* Too many conditions.  Give up and return constant true.  */\n@@ -228,6 +260,9 @@ add_condition (struct inline_summary *summary, int operand_num,\n   new_cond.operand_num = operand_num;\n   new_cond.code = code;\n   new_cond.val = val;\n+  new_cond.agg_contents = agg_contents;\n+  new_cond.by_ref = by_ref;\n+  new_cond.offset = offset;\n   VEC_safe_push (condition, gc, summary->conds, &new_cond);\n   return single_cond_predicate (i + predicate_first_dynamic_condition);\n }\n@@ -519,6 +554,9 @@ dump_condition (FILE *f, conditions conditions, int cond)\n       c = VEC_index (condition, conditions,\n \t\t     cond - predicate_first_dynamic_condition);\n       fprintf (f, \"op%i\", c->operand_num);\n+      if (c->agg_contents)\n+\tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n+\t\t c->by_ref ? \"ref \" : \"\", c->offset);\n       if (c->code == IS_NOT_CONSTANT)\n \t{\n \t  fprintf (f, \" not constant\");\n@@ -659,15 +697,17 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n \n \n /* KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n-   Return clause of possible truths. When INLINE_P is true, assume that\n-   we are inlining. \n+   KNOWN_AGGS is a vector of aggreggate jump functions for each parameter.\n+   Return clause of possible truths. When INLINE_P is true, assume that we are\n+   inlining.\n \n    ERROR_MARK means compile time invariant.  */\n \n static clause_t\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n-\t\t\t\t    bool inline_p,\n-\t\t\t\t    VEC (tree, heap) *known_vals)\n+\t\t\t\tbool inline_p,\n+\t\t\t\tVEC (tree, heap) *known_vals,\n+\t\t\t\tVEC (ipa_agg_jump_function_p, heap) *known_aggs)\n {\n   clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n   struct inline_summary *info = inline_summary (node);\n@@ -679,16 +719,45 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       tree val;\n       tree res;\n \n-      /* We allow call stmt to have fewer arguments than the callee\n-\t function (especially for K&R style programs).  So bound\n-\t check here.  */\n-      if (c->operand_num < (int)VEC_length (tree, known_vals))\n-        val = VEC_index (tree, known_vals, c->operand_num);\n-      else\n-\tval = NULL;\n+      /* We allow call stmt to have fewer arguments than the callee function\n+\t (especially for K&R style programs).  So bound check here (we assume\n+\t known_aggs vector, if non-NULL, has the same length as\n+\t known_vals).  */\n+      gcc_checking_assert (!known_aggs\n+\t\t\t   || (VEC_length (tree, known_vals)\n+\t\t\t       == VEC_length (ipa_agg_jump_function_p,\n+\t\t\t\t\t      known_aggs)));\n+      if (c->operand_num >= (int) VEC_length (tree, known_vals))\n+\t{\n+\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  continue;\n+\t}\n \n-      if (val == error_mark_node && c->code != CHANGED)\n-\tval = NULL;\n+      if (c->agg_contents)\n+\t{\n+\t  struct ipa_agg_jump_function *agg;\n+\n+\t  if (c->code == CHANGED\n+\t      && !c->by_ref\n+\t      && (VEC_index (tree, known_vals, c->operand_num)\n+\t\t  == error_mark_node))\n+\t    continue;\n+\n+\t  if (known_aggs)\n+\t    {\n+\t      agg = VEC_index (ipa_agg_jump_function_p, known_aggs,\n+\t\t\t       c->operand_num);\n+\t      val = ipa_find_agg_cst_for_param (agg, c->offset, c->by_ref);\n+\t    }\n+\t  else\n+\t    val = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  val = VEC_index (tree, known_vals, c->operand_num);\n+\t  if (val == error_mark_node && c->code != CHANGED)\n+\t    val = NULL_TREE;\n+\t}\n \n       if (!val)\n \t{\n@@ -711,13 +780,15 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n static void\n evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n-\t\t\t      clause_t *clause_ptr,\n-\t\t\t      VEC (tree, heap) **known_vals_ptr,\n-\t\t\t      VEC (tree, heap) **known_binfos_ptr)\n+\t\t\t   clause_t *clause_ptr,\n+\t\t\t   VEC (tree, heap) **known_vals_ptr,\n+\t\t\t   VEC (tree, heap) **known_binfos_ptr,\n+\t\t\t   VEC (ipa_agg_jump_function_p, heap) **known_aggs_ptr)\n {\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n   struct inline_summary *info = inline_summary (callee);\n   VEC (tree, heap) *known_vals = NULL;\n+  VEC (ipa_agg_jump_function_p, heap) *known_aggs = NULL;\n \n   if (clause_ptr)\n     *clause_ptr = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n@@ -742,13 +813,16 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \n       if (count && (info->conds || known_vals_ptr))\n \tVEC_safe_grow_cleared (tree, heap, known_vals, count);\n+      if (count && (info->conds || known_aggs_ptr))\n+\tVEC_safe_grow_cleared (ipa_agg_jump_function_p, heap, known_aggs,\n+\t\t\t       count);\n       if (count && known_binfos_ptr)\n \tVEC_safe_grow_cleared (tree, heap, *known_binfos_ptr, count);\n \n       for (i = 0; i < count; i++)\n \t{\n-\t  tree cst = ipa_value_from_jfunc (parms_info,\n-\t\t\t\t\t   ipa_get_ith_jump_func (args, i));\n+\t  struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n+\t  tree cst = ipa_value_from_jfunc (parms_info, jf);\n \t  if (cst)\n \t    {\n \t      if (known_vals && TREE_CODE (cst) != TREE_BINFO)\n@@ -761,17 +835,26 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t\t  es->param,\n \t\t\t\t  i)->change_prob)\n \t    VEC_replace (tree, known_vals, i, error_mark_node);\n+\t  /* TODO: When IPA-CP starts propagating and merging aggregate jump\n+\t     functions, use its knowledge of the caller too, just like the\n+\t     scalar case above.  */\n+\t  VEC_replace (ipa_agg_jump_function_p, known_aggs, i, &jf->agg);\n \t}\n     }\n \n   if (clause_ptr)\n     *clause_ptr = evaluate_conditions_for_known_args (callee, inline_p,\n-\t\t\t\t\t\t      known_vals);\n+\t\t\t\t\t\t      known_vals, known_aggs);\n \n   if (known_vals_ptr)\n     *known_vals_ptr = known_vals;\n   else\n     VEC_free (tree, heap, known_vals);\n+\n+  if (known_aggs_ptr)\n+    *known_aggs_ptr = known_aggs;\n+  else\n+    VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n }\n \n \n@@ -917,8 +1000,8 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t}\n \t    }\n \t}\n-      possible_truths = evaluate_conditions_for_known_args (dst,\n-\t\t\t\t\t\t\t    false, known_vals);\n+      possible_truths = evaluate_conditions_for_known_args (dst, false,\n+\t\t\t\t\t\t\t    known_vals, NULL);\n       VEC_free (tree, heap, known_vals);\n \n       account_size_time (info, 0, 0, &true_pred);\n@@ -1262,11 +1345,11 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-/* If OP reffers to value of function parameter, return \n-   the corresponding parameter.  */\n+/* If OP refers to value of function parameter, return the corresponding\n+   parameter.  */\n \n static tree\n-unmodified_parm (gimple stmt, tree op)\n+unmodified_parm_1 (gimple stmt, tree op)\n {\n   /* SSA_NAME referring to parm default def?  */\n   if (TREE_CODE (op) == SSA_NAME\n@@ -1285,13 +1368,67 @@ unmodified_parm (gimple stmt, tree op)\n       if (!modified)\n \treturn op;\n     }\n-  /* Assignment from a parameter?  */\n+  return NULL_TREE;\n+}\n+\n+/* If OP refers to value of function parameter, return the corresponding\n+   parameter.  Also traverse chains of SSA register assignments.  */\n+\n+static tree\n+unmodified_parm (gimple stmt, tree op)\n+{\n+  tree res = unmodified_parm_1 (stmt, op);\n+  if (res)\n+    return res;\n+\n   if (TREE_CODE (op) == SSA_NAME\n       && !SSA_NAME_IS_DEFAULT_DEF (op)\n       && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n     return unmodified_parm (SSA_NAME_DEF_STMT (op),\n \t\t\t    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)));\n-  return NULL;\n+  return NULL_TREE;\n+}\n+\n+/* If OP refers to a value of a function parameter or value loaded from an\n+   aggregate passed to a parameter (either by value or reference), return TRUE\n+   and store the number of the parameter to *INDEX_P and information whether\n+   and how it has been loaded from an aggregate into *AGGPOS.  INFO describes\n+   the function parameters, STMT is the statement in which OP is used or\n+   loaded.  */\n+\n+static bool\n+unmodified_parm_or_parm_agg_item (struct ipa_node_params *info,\n+\t\t\t\t  gimple stmt, tree op, int *index_p,\n+\t\t\t\t  struct agg_position_info *aggpos)\n+{\n+  tree res = unmodified_parm_1 (stmt, op);\n+\n+  gcc_checking_assert (aggpos);\n+  if (res)\n+    {\n+      *index_p = ipa_get_param_decl_index (info, res);\n+      if (*index_p < 0)\n+\treturn false;\n+      aggpos->agg_contents = false;\n+      aggpos->by_ref = false;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IS_DEFAULT_DEF (op)\n+\t  || !gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n+\treturn false;\n+      stmt = SSA_NAME_DEF_STMT (op);\n+      op = gimple_assign_rhs1 (stmt);\n+      if (!REFERENCE_CLASS_P (op))\n+\treturn unmodified_parm_or_parm_agg_item (info, stmt, op, index_p,\n+\t\t\t\t\t\t aggpos);\n+    }\n+\n+  aggpos->agg_contents = true;\n+  return ipa_load_from_parm_agg (info, stmt, op, index_p, &aggpos->offset,\n+\t\t\t\t &aggpos->by_ref);\n }\n \n /* See if statement might disappear after inlining.\n@@ -1422,13 +1559,12 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   gimple last;\n   tree op;\n   int index;\n+  struct agg_position_info aggpos;\n   enum tree_code code, inverted_code;\n   edge e;\n   edge_iterator ei;\n   gimple set_stmt;\n   tree op2;\n-  tree parm;\n-  tree base;\n \n   last = last_stmt (bb);\n   if (!last\n@@ -1440,21 +1576,16 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   /* TODO: handle conditionals like\n      var = op0 < 4;\n      if (var != 0).  */\n-  parm = unmodified_parm (last, op);\n-  if (parm)\n+  if (unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n     {\n-      index = ipa_get_param_decl_index (info, parm);\n-      if (index == -1)\n-\treturn;\n       code = gimple_cond_code (last);\n       inverted_code\n \t = invert_tree_comparison (code,\n \t\t\t\t   HONOR_NANS (TYPE_MODE (TREE_TYPE (op))));\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  struct predicate p = add_condition (summary,\n-\t\t\t\t\t      index,\n+\t  struct predicate p = add_condition (summary, index, &aggpos,\n \t\t\t\t\t      e->flags & EDGE_TRUE_VALUE\n \t\t\t\t\t      ? code : inverted_code,\n \t\t\t\t\t      gimple_cond_rhs (last));\n@@ -1475,28 +1606,21 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n      for this and also the constant code is not known to be\n      optimized away when inliner doen't see operand is constant.\n      Other optimizers might think otherwise.  */\n+  if (gimple_cond_code (last) != NE_EXPR\n+      || !integer_zerop (gimple_cond_rhs (last)))\n+    return;\n   set_stmt = SSA_NAME_DEF_STMT (op);\n   if (!gimple_call_builtin_p (set_stmt, BUILT_IN_CONSTANT_P)\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  base = get_base_address (op2);\n-  parm = unmodified_parm (set_stmt, base ? base : op2);\n-  if (!parm)\n-    return;\n-  index = ipa_get_param_decl_index (info, parm);\n-  if (index == -1)\n-    return;\n-  if (gimple_cond_code (last) != NE_EXPR\n-      || !integer_zerop (gimple_cond_rhs (last)))\n+  if (!unmodified_parm_or_parm_agg_item (info, set_stmt, op2, &index, &aggpos))\n     return;\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     if (e->flags & EDGE_FALSE_VALUE)\n       {\n-\tstruct predicate p = add_condition (summary,\n-\t\t\t\t\t    index,\n-\t\t\t\t\t    IS_NOT_CONSTANT,\n-\t\t\t\t\t    NULL);\n+\tstruct predicate p = add_condition (summary, index, &aggpos,\n+\t\t\t\t\t    IS_NOT_CONSTANT, NULL_TREE);\n \te->aux = pool_alloc (edge_predicate_pool);\n \t*(struct predicate *)e->aux = p;\n       }\n@@ -1514,22 +1638,18 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n   gimple last;\n   tree op;\n   int index;\n+  struct agg_position_info aggpos;\n   edge e;\n   edge_iterator ei;\n   size_t n;\n   size_t case_idx;\n-  tree parm;\n \n   last = last_stmt (bb);\n   if (!last\n       || gimple_code (last) != GIMPLE_SWITCH)\n     return;\n   op = gimple_switch_index (last);\n-  parm = unmodified_parm (last, op);\n-  if (!parm)\n-    return;\n-  index = ipa_get_param_decl_index (info, parm);\n-  if (index == -1)\n+  if (!unmodified_parm_or_parm_agg_item (info, last, op, &index, &aggpos))\n     return;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -1554,18 +1674,12 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n       if (!min && !max)\n \tp = true_predicate ();\n       else if (!max)\n-\tp = add_condition (summary, index,\n-\t\t\t   EQ_EXPR,\n-\t\t\t   min);\n+\tp = add_condition (summary, index, &aggpos, EQ_EXPR, min);\n       else\n \t{\n \t  struct predicate p1, p2;\n-\t  p1 = add_condition (summary, index,\n-\t\t\t      GE_EXPR,\n-\t\t\t      min);\n-\t  p2 = add_condition (summary, index,\n-\t\t\t      LE_EXPR,\n-\t\t\t      max);\n+\t  p1 = add_condition (summary, index, &aggpos, GE_EXPR, min);\n+\t  p2 = add_condition (summary, index, &aggpos, LE_EXPR, max);\n \t  p = and_predicates (summary->conds, &p1, &p2);\n \t}\n       *(struct predicate *)e->aux\n@@ -1659,13 +1773,14 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n \t\t\t       struct inline_summary *summary,\n \t\t\t       gimple stmt,\n \t\t\t       VEC (predicate_t, heap) *nonconstant_names)\n-\t\t\t      \n {\n   struct predicate p = true_predicate ();\n   ssa_op_iter iter;\n   tree use;\n   struct predicate op_non_const;\n   bool is_load;\n+  int base_index;\n+  struct agg_position_info aggpos;\n \n   /* What statments might be optimized away\n      when their arguments are constant\n@@ -1681,23 +1796,18 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n     return p;\n \n   is_load = gimple_vuse (stmt) != NULL;\n-\n   /* Loads can be optimized when the value is known.  */\n   if (is_load)\n     {\n-      tree op = gimple_assign_rhs1 (stmt);\n-      tree base = get_base_address (op);\n-      tree parm;\n-\n+      tree op;\n       gcc_assert (gimple_assign_single_p (stmt));\n-      if (!base)\n-\treturn p;\n-      parm = unmodified_parm (stmt, base);\n-      if (!parm )\n-\treturn p;\n-      if (ipa_get_param_decl_index (info, parm) < 0)\n+      op = gimple_assign_rhs1 (stmt);\n+      if (!unmodified_parm_or_parm_agg_item (info, stmt, op, &base_index,\n+\t\t\t\t\t     &aggpos))\n \treturn p;\n     }\n+  else\n+    base_index = -1;\n \n   /* See if we understand all operands before we start\n      adding conditionals.  */\n@@ -1716,23 +1826,24 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n \tcontinue;\n       return p;\n     }\n-  op_non_const = false_predicate ();\n+\n   if (is_load)\n-    {\n-      tree parm = unmodified_parm\n-\t\t    (stmt, get_base_address (gimple_assign_rhs1 (stmt)));\n-      p = add_condition (summary,\n-\t\t\t ipa_get_param_decl_index (info, parm),\n-\t\t\t CHANGED, NULL);\n-      op_non_const = or_predicates (summary->conds, &p, &op_non_const);\n-    }\n+    op_non_const = add_condition (summary, base_index, &aggpos, CHANGED, NULL);\n+  else\n+    op_non_const = false_predicate ();\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree parm = unmodified_parm (stmt, use);\n-      if (parm && ipa_get_param_decl_index (info, parm) >= 0)\n-\tp = add_condition (summary,\n-\t\t\t   ipa_get_param_decl_index (info, parm),\n-\t\t\t   CHANGED, NULL);\n+      int index;\n+\n+      if (parm\n+\t  && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n+\t{\n+\t  if (index != base_index)\n+\t    p = add_condition (summary, index, NULL, CHANGED, NULL_TREE);\n+\t  else\n+\t    continue;\n+\t}\n       else\n \tp = *VEC_index (predicate_t, nonconstant_names,\n \t\t\tSSA_NAME_VERSION (use));\n@@ -2194,15 +2305,17 @@ static void\n estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \t\t\t      int *size, int *time, int prob,\n \t\t\t      VEC (tree, heap) *known_vals,\n-\t\t\t      VEC (tree, heap) *known_binfos)\n+\t\t\t      VEC (tree, heap) *known_binfos,\n+\t\t\t      VEC (ipa_agg_jump_function_p, heap) *known_aggs)\n {\n   tree target;\n   int time_diff, size_diff;\n \n   if (!known_vals && !known_binfos)\n     return;\n \n-  target = ipa_get_indirect_edge_target (ie, known_vals, known_binfos);\n+  target = ipa_get_indirect_edge_target (ie, known_vals, known_binfos,\n+\t\t\t\t\t known_aggs);\n   if (!target)\n     return;\n \n@@ -2259,7 +2372,8 @@ static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t\t\t      clause_t possible_truths,\n \t\t\t      VEC (tree, heap) *known_vals,\n-\t\t\t      VEC (tree, heap) *known_binfos)\n+\t\t\t      VEC (tree, heap) *known_binfos,\n+\t\t\t      VEC (ipa_agg_jump_function_p, heap) *known_aggs)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n@@ -2276,7 +2390,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t  else\n \t    estimate_calls_size_and_time (e->callee, size, time,\n \t\t\t\t\t  possible_truths,\n-\t\t\t\t\t  known_vals, known_binfos);\n+\t\t\t\t\t  known_vals, known_binfos, known_aggs);\n \t}\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -2286,7 +2400,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size, int *time,\n \t{\n \t  estimate_edge_size_and_time (e, size, time, REG_BR_PROB_BASE);\n \t  estimate_edge_devirt_benefit (e, size, time, REG_BR_PROB_BASE,\n-\t\t\t\t\tknown_vals, known_binfos);\n+\t\t\t\t\tknown_vals, known_binfos, known_aggs);\n \t}\n     }\n }\n@@ -2301,6 +2415,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     clause_t possible_truths,\n \t\t\t     VEC (tree, heap) *known_vals,\n \t\t\t     VEC (tree, heap) *known_binfos,\n+\t\t\t     VEC (ipa_agg_jump_function_p, heap) *known_aggs,\n \t\t       \t     int *ret_size, int *ret_time,\n \t\t\t     VEC (inline_param_summary_t, heap)\n \t\t\t       *inline_param_summary)\n@@ -2352,7 +2467,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     time = MAX_TIME * INLINE_TIME_SCALE;\n \n   estimate_calls_size_and_time (node, &size, &time, possible_truths,\n-\t\t\t\tknown_vals, known_binfos);\n+\t\t\t\tknown_vals, known_binfos, known_aggs);\n   time = (time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   size = (size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n \n@@ -2381,27 +2496,31 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n {\n   clause_t clause;\n \n-  clause = evaluate_conditions_for_known_args (node, false, known_vals);\n-  estimate_node_size_and_time (node, clause, known_vals, known_binfos,\n+  clause = evaluate_conditions_for_known_args (node, false, known_vals, NULL);\n+  estimate_node_size_and_time (node, clause, known_vals, known_binfos, NULL,\n \t\t\t       ret_size, ret_time,\n \t\t\t       NULL);\n }\n \n-\n /* Translate all conditions from callee representation into caller\n    representation and symbolically evaluate predicate P into new predicate.\n \n-   INFO is inline_summary of function we are adding predicate into,\n-   CALLEE_INFO is summary of function predicate P is from. OPERAND_MAP is\n-   array giving callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is\n-   clausule of all callee conditions that may be true in caller context.\n-   TOPLEV_PREDICATE is predicate under which callee is executed.  */\n+   INFO is inline_summary of function we are adding predicate into, CALLEE_INFO\n+   is summary of function predicate P is from. OPERAND_MAP is array giving\n+   callee formal IDs the caller formal IDs. POSSSIBLE_TRUTHS is clausule of all\n+   callee conditions that may be true in caller context.  TOPLEV_PREDICATE is\n+   predicate under which callee is executed.  OFFSET_MAP is an array of of\n+   offsets that need to be added to conditions, negative offset means that\n+   conditions relying on values passed by reference have to be discarded\n+   because they might not be preserved (and should be considered offset zero\n+   for other purposes).  */\n \n static struct predicate\n remap_predicate (struct inline_summary *info,\n \t\t struct inline_summary *callee_info,\n \t\t struct predicate *p,\n \t\t VEC (int, heap) *operand_map,\n+\t\t VEC (int, heap) *offset_map,\n \t\t clause_t possible_truths,\n \t\t struct predicate *toplev_predicate)\n {\n@@ -2436,13 +2555,34 @@ remap_predicate (struct inline_summary *info,\n \t\t    Otherwise give up.  */\n \t\t if (!operand_map\n \t\t     || (int)VEC_length (int, operand_map) <= c->operand_num\n-\t\t     || VEC_index (int, operand_map, c->operand_num) == -1)\n+\t\t     || VEC_index (int, operand_map, c->operand_num) == -1\n+\t\t     || (!c->agg_contents\n+\t\t\t && VEC_index (int, offset_map, c->operand_num) != 0)\n+\t\t     || (c->agg_contents && c->by_ref\n+\t\t\t && VEC_index (int, offset_map, c->operand_num) < 0))\n \t\t   cond_predicate = true_predicate ();\n \t\t else\n-\t\t   cond_predicate = add_condition (info,\n-\t\t\t\t\t\t   VEC_index (int, operand_map,\n-\t\t\t\t\t\t\t      c->operand_num),\n-\t\t\t\t\t\t   c->code, c->val);\n+\t\t   {\n+\t\t     struct agg_position_info ap;\n+\t\t     HOST_WIDE_INT offset_delta = VEC_index (int, offset_map,\n+\t\t\t\t\t\t\t     c->operand_num);\n+\t\t     if (offset_delta < 0)\n+\t\t       {\n+\t\t\t gcc_checking_assert (!c->agg_contents || !c->by_ref);\n+\t\t\t offset_delta = 0;\n+\t\t       }\n+\t\t     gcc_assert (!c->agg_contents\n+\t\t\t\t || c->by_ref\n+\t\t\t\t || offset_delta == 0);\n+\t\t     ap.offset = c->offset + offset_delta;\n+\t\t     ap.agg_contents = c->agg_contents;\n+\t\t     ap.by_ref = c->by_ref;\n+\t\t     cond_predicate = add_condition (info,\n+\t\t\t\t\t\t     VEC_index (int,\n+\t\t\t\t\t\t\t\toperand_map,\n+\t\t\t\t\t\t\t\tc->operand_num),\n+\t\t\t\t\t\t     &ap, c->code, c->val);\n+\t\t   }\n \t      }\n \t    /* Fixed conditions remains same, construct single\n \t       condition predicate.  */\n@@ -2549,6 +2689,7 @@ remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n \t\t       struct inline_summary *info,\n \t\t       struct inline_summary *callee_info,\n \t\t       VEC (int, heap) *operand_map,\n+\t\t       VEC (int, heap) *offset_map,\n \t\t       clause_t possible_truths,\n \t\t       struct predicate *toplev_predicate)\n {\n@@ -2565,7 +2706,8 @@ remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n \t  if (es->predicate)\n \t    {\n \t      p = remap_predicate (info, callee_info,\n-\t\t\t\t   es->predicate, operand_map, possible_truths,\n+\t\t\t\t   es->predicate, operand_map, offset_map,\n+\t\t\t\t   possible_truths,\n \t\t\t\t   toplev_predicate);\n \t      edge_set_predicate (e, &p);\n \t      /* TODO: We should remove the edge for code that will be\n@@ -2582,7 +2724,8 @@ remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n \t}\n       else\n \tremap_edge_summaries (inlined_edge, e->callee, info, callee_info,\n-\t\t\t      operand_map, possible_truths, toplev_predicate);\n+\t\t\t      operand_map, offset_map, possible_truths,\n+\t\t\t      toplev_predicate);\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n@@ -2593,8 +2736,8 @@ remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n       if (es->predicate)\n \t{\n \t  p = remap_predicate (info, callee_info,\n-\t\t\t       es->predicate, operand_map, possible_truths,\n-\t\t\t       toplev_predicate);\n+\t\t\t       es->predicate, operand_map, offset_map,\n+\t\t\t       possible_truths, toplev_predicate);\n \t  edge_set_predicate (e, &p);\n \t  /* TODO: We should remove the edge for code that will be optimized\n \t     out, but we need to keep verifiers and tree-inline happy.\n@@ -2623,6 +2766,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n   clause_t clause = 0;\t\t/* not_inline is known to be false.  */\n   size_time_entry *e;\n   VEC (int, heap) *operand_map = NULL;\n+  VEC (int, heap) *offset_map = NULL;\n   int i;\n   struct predicate toplev_predicate;\n   struct predicate true_p = true_predicate ();\n@@ -2639,25 +2783,45 @@ inline_merge_summary (struct cgraph_edge *edge)\n       int count = ipa_get_cs_argument_count (args);\n       int i;\n \n-      evaluate_properties_for_edge (edge, true, &clause, NULL, NULL);\n+      evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL);\n       if (count)\n-\tVEC_safe_grow_cleared (int, heap, operand_map, count);\n+\t{\n+\t  VEC_safe_grow_cleared (int, heap, operand_map, count);\n+\t  VEC_safe_grow_cleared (int, heap, offset_map, count);\n+\t}\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, i);\n \t  int map = -1;\n+\n \t  /* TODO: handle non-NOPs when merging.  */\n-\t  if (jfunc->type == IPA_JF_PASS_THROUGH\n-\t      && ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n-\t    map = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t  if (jfunc->type == IPA_JF_PASS_THROUGH)\n+\t    {\n+\t      if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n+\t\tmap = ipa_get_jf_pass_through_formal_id (jfunc);\n+\t      if (!ipa_get_jf_pass_through_agg_preserved (jfunc))\n+\t\tVEC_replace (int, offset_map, i, -1);\n+\t    }\n+\t  else if (jfunc->type == IPA_JF_ANCESTOR)\n+\t    {\n+\t      HOST_WIDE_INT offset = ipa_get_jf_ancestor_offset (jfunc);\n+\t      if (offset >= 0 && offset < INT_MAX)\n+\t\t{\n+\t\t  map = ipa_get_jf_ancestor_formal_id (jfunc);\n+\t\t  if (!ipa_get_jf_ancestor_agg_preserved (jfunc))\n+\t\t    offset = -1;\n+\t\t  VEC_replace (int, offset_map, i, offset);\n+\t\t}\n+\t    }\n \t  VEC_replace (int, operand_map, i, map);\n \t  gcc_assert (map < ipa_get_param_count (IPA_NODE_REF (to)));\n \t}\n     }\n   for (i = 0; VEC_iterate (size_time_entry, callee_info->entry, i, e); i++)\n     {\n       struct predicate p = remap_predicate (info, callee_info,\n-\t\t\t\t\t    &e->predicate, operand_map, clause,\n+\t\t\t\t\t    &e->predicate, operand_map,\n+\t\t\t\t\t    offset_map, clause,\n \t\t\t\t\t    &toplev_predicate);\n       if (!false_predicate_p (&p))\n \t{\n@@ -2679,7 +2843,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t}\n     }\n   remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n-\t\t\tclause, &toplev_predicate);\n+\t\t\toffset_map, clause, &toplev_predicate);\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -2689,6 +2853,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n   /* Similarly remove param summaries.  */\n   VEC_free (inline_param_summary_t, heap, es->param);\n   VEC_free (int, heap, operand_map);\n+  VEC_free (int, heap, offset_map);\n }\n \n /* For performance reasons inline_merge_summary is not updating overall size\n@@ -2707,7 +2872,7 @@ inline_update_overall_summary (struct cgraph_node *node)\n     info->size += e->size, info->time += e->time;\n   estimate_calls_size_and_time (node, &info->size, &info->time,\n \t\t\t\t~(clause_t)(1 << predicate_false_condition),\n-\t\t\t\tNULL, NULL);\n+\t\t\t\tNULL, NULL, NULL);\n   info->time = (info->time + INLINE_TIME_SCALE / 2) / INLINE_TIME_SCALE;\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n@@ -2729,17 +2894,20 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   clause_t clause;\n   VEC (tree, heap) *known_vals;\n   VEC (tree, heap) *known_binfos;\n+  VEC (ipa_agg_jump_function_p, heap) *known_aggs;\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   callee = cgraph_function_or_thunk_node (edge->callee, NULL);\n \n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_binfos);\n+\t\t\t\t&clause, &known_vals, &known_binfos,\n+\t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       &size, &time, es->param);\n+\t\t\t       known_aggs, &size, &time, es->param);\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n+  VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n \n   ret = (((gcov_type)time\n \t   - es->call_stmt_time) * edge->frequency\n@@ -2776,6 +2944,7 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n   clause_t clause;\n   VEC (tree, heap) *known_vals;\n   VEC (tree, heap) *known_binfos;\n+  VEC (ipa_agg_jump_function_p, heap) *known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -2794,11 +2963,13 @@ do_estimate_edge_growth (struct cgraph_edge *edge)\n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n   evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &known_vals, &known_binfos);\n+\t\t\t\t&clause, &known_vals, &known_binfos,\n+\t\t\t\t&known_aggs);\n   estimate_node_size_and_time (callee, clause, known_vals, known_binfos,\n-\t\t\t       &size, NULL, NULL);\n+\t\t\t       known_aggs, &size, NULL, NULL);\n   VEC_free (tree, heap, known_vals);\n   VEC_free (tree, heap, known_binfos);\n+  VEC_free (ipa_agg_jump_function_p, heap, known_aggs);\n   gcc_checking_assert (inline_edge_summary (edge)->call_stmt_size);\n   return size - inline_edge_summary (edge)->call_stmt_size;\n }\n@@ -3078,6 +3249,11 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  c.operand_num = streamer_read_uhwi (&ib);\n \t  c.code = (enum tree_code) streamer_read_uhwi (&ib);\n \t  c.val = stream_read_tree (&ib, data_in);\n+\t  bp = streamer_read_bitpack (&ib);\n+\t  c.agg_contents = bp_unpack_value (&bp, 1);\n+\t  c.by_ref = bp_unpack_value (&bp, 1);\n+\t  if (c.agg_contents)\n+\t    c.offset = streamer_read_uhwi (&ib);\n \t  VEC_safe_push (condition, gc, info->conds, &c);\n \t}\n       count2 = streamer_read_uhwi (&ib);\n@@ -3223,6 +3399,12 @@ inline_write_summary (cgraph_node_set set,\n \t      streamer_write_uhwi (ob, c->operand_num);\n \t      streamer_write_uhwi (ob, c->code);\n \t      stream_write_tree (ob, c->val, true);\n+\t      bp = bitpack_create (ob->main_stream);\n+\t      bp_pack_value (&bp, c->agg_contents, 1);\n+\t      bp_pack_value (&bp, c->by_ref, 1);\n+\t      streamer_write_bitpack (&bp);\n+\t      if (c->agg_contents)\n+\t\tstreamer_write_uhwi (ob, c->offset);\n \t    }\n \t  streamer_write_uhwi (ob, VEC_length (size_time_entry, info->entry));\n \t  for (i = 0;"}, {"sha": "db3f8d4e56bd06f8448fda9e59812ec6a4d56492", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -28,9 +28,18 @@ along with GCC; see the file COPYING3.  If not see\n \n typedef struct GTY(()) condition\n   {\n+    /* If agg_contents is set, this is the offset from which the used data was\n+       loaded.  */\n+    HOST_WIDE_INT offset;\n     tree val;\n     int operand_num;\n-    enum tree_code code;\n+    ENUM_BITFIELD(tree_code) code : 16;\n+    /* Set if the used data were loaded from an aggregate parameter or from\n+       data received by reference.  */\n+    unsigned agg_contents : 1;\n+    /* If agg_contents is set, this differentiates between loads from data\n+       passed by reference and by value.  */\n+    unsigned by_ref : 1;\n   } condition;\n \n DEF_VEC_O (condition);"}, {"sha": "2d2a54be0cff1174f866b52db37948a3dc524cba", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -494,8 +494,9 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \n /* Indirect edge and binfo processing.  */\n tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t\t   VEC (tree, heap) *known_csts,\n-\t\t\t\t   VEC (tree, heap) *known_binfs);\n+\t\t\t\t   VEC (tree, heap) *,\n+\t\t\t\t   VEC (tree, heap) *,\n+\t\t\t\t   VEC (ipa_agg_jump_function_p, heap) *);\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree);\n \n /* Functions related to both.  */"}, {"sha": "5c5b9b52567e050be93ded098f506de5212df49a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -1,3 +1,8 @@\n+2012-08-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR fortran/48636\n+\t* gfortran.dg/pr48636.f90: New test.\n+\n 2012-08-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/torture/vector-shuffle1.c (f): Pass vectors indirectly"}, {"sha": "44515ae9ad98aa143aeac3f5b42c2bced4c33b6b", "filename": "gcc/testsuite/gfortran.dg/pr48636.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8810cc52c9c7af05759a77d5bfe6d46e16b571e8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr48636.f90?ref=8810cc52c9c7af05759a77d5bfe6d46e16b571e8", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fdump-ipa-inline\" }\n+\n+module foo\n+  implicit none\n+contains\n+  subroutine bar(a,x)\n+    real, dimension(:,:), intent(in) :: a\n+    real, intent(out) :: x\n+    integer :: i,j\n+\n+    x = 0\n+    do j=1,ubound(a,2)\n+       do i=1,ubound(a,1)\n+          x = x + a(i,j)**2\n+       end do\n+    end do\n+  end subroutine bar\n+end module foo\n+\n+program main\n+  use foo\n+  implicit none\n+  real, dimension(2,3) :: a\n+  real :: x\n+  integer :: i\n+\n+  data a /1.0, 2.0, 3.0, -1.0, -2.0, -3.0/\n+\n+  do i=1,2000000\n+     call bar(a,x)\n+  end do\n+  print *,x\n+end program main\n+\n+! { dg-final { scan-ipa-dump \"bar\\[^\\\\n\\]*inline copy in MAIN\" \"inline\" } }\n+! { dg-final { cleanup-ipa-dump \"inline\" } }"}]}