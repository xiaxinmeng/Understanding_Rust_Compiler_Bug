{"sha": "37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiZGI3ZTMxNDdjNjdiYTNlNDFmZjdkNmM0ZGRiODQ4Nzc1ZmUyMg==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-15T02:23:14Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-15T02:23:14Z"}, "message": "(encode, decode): Use 4 HOST_WIDE_INTs for encoded value with HOST_BITS_PER_WIDE_INT/2 bits in each.\n\n(encode, decode): Use 4 HOST_WIDE_INTs for encoded\nvalue with HOST_BITS_PER_WIDE_INT/2 bits in each.\n(LOWPART, HIGHPART): New macros.\n(BASE): Move definition outside of div_and_round_double.\n(add_double, mul_double, lshift_double, rshift_double): Rewrite.\n(lrotate_double): Use LOWPART, HIGHPART, and BASE.\n(rrotate_double): Likewise.\n(div_and_round_double): Major changes to code for general case.\nNow it actually produces non-garbage results for large operands.\n(div_and_round_double): Simplify condition for special code used when\ndivisor < BASE.\n(const_binop): Delete special cases for multiplying by 0, 1, 2, 4, 8.\n(fold, case *_DIV_EXPR): Don't try to optimize for overflow.\n\nFrom-SVN: r7473", "tree": {"sha": "7f4131b6f6da8fbc845712d6904193f1c805fa0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f4131b6f6da8fbc845712d6904193f1c805fa0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22/comments", "author": null, "committer": null, "parents": [{"sha": "4c9a05bc5560ebb1144228bccb5312871a3089f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9a05bc5560ebb1144228bccb5312871a3089f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9a05bc5560ebb1144228bccb5312871a3089f7"}], "stats": {"total": 530, "additions": 192, "deletions": 338}, "files": [{"sha": "90d5c057659bdc7a01cd63b3b7badd84da92f8bf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 192, "deletions": 338, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=37bdb7e3147c67ba3e41ff7d6c4ddb848775fe22", "patch": "@@ -17,8 +17,6 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-/*@@ Fix lossage on folding division of big integers.  */\n-\n /*@@ This file should be rewritten to use an arbitrary precision\n   @@ representation for \"struct tree_int_cst\" and \"struct tree_real_cst\".\n   @@ Perhaps the routines could also be used for bc/dc, and made a lib.\n@@ -48,8 +46,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Handle floating overflow for `const_binop'.  */\n static jmp_buf float_error;\n \n-static void encode\tPROTO((short *, HOST_WIDE_INT, HOST_WIDE_INT));\n-static void decode\tPROTO((short *, HOST_WIDE_INT *, HOST_WIDE_INT *));\n+static void encode\tPROTO((HOST_WIDE_INT *, HOST_WIDE_INT, HOST_WIDE_INT));\n+static void decode\tPROTO((HOST_WIDE_INT *, HOST_WIDE_INT *, HOST_WIDE_INT *));\n static int div_and_round_double PROTO((enum tree_code, int, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT *,\n@@ -94,46 +92,41 @@ static tree strip_compound_expr PROTO((tree, tree));\n #define overflow_sum_sign(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n \f\n /* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.\n-   We do that by representing the two-word integer as MAX_SHORTS shorts,\n-   with only 8 bits stored in each short, as a positive number.  */\n+   We do that by representing the two-word integer in 4 words, with only\n+   HOST_BITS_PER_WIDE_INT/2 bits stored in each word, as a positive number.  */\n+\n+#define LOWPART(x) \\\n+  ((x) & (((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT/2)) - 1))\n+#define HIGHPART(x) \\\n+  ((unsigned HOST_WIDE_INT) (x) >> HOST_BITS_PER_WIDE_INT/2)\n+#define BASE ((unsigned HOST_WIDE_INT) 1 << HOST_BITS_PER_WIDE_INT/2)\n \n-/* Unpack a two-word integer into MAX_SHORTS shorts.\n+/* Unpack a two-word integer into 4 words.\n    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.\n-   SHORTS points to the array of shorts.  */\n+   WORDS points to the array of HOST_WIDE_INTs.  */\n \n static void\n-encode (shorts, low, hi)\n-     short *shorts;\n+encode (words, low, hi)\n+     HOST_WIDE_INT *words;\n      HOST_WIDE_INT low, hi;\n {\n-  register int i;\n-\n-  for (i = 0; i < MAX_SHORTS / 2; i++)\n-    {\n-      shorts[i] = (low >> (i * 8)) & 0xff;\n-      shorts[i + MAX_SHORTS / 2] = (hi >> (i * 8) & 0xff);\n-    }\n+  words[0] = LOWPART (low);\n+  words[1] = HIGHPART (low);\n+  words[2] = LOWPART (hi);\n+  words[3] = HIGHPART (hi);\n }\n \n-/* Pack an array of MAX_SHORTS shorts into a two-word integer.\n-   SHORTS points to the array of shorts.\n+/* Pack an array of 4 words into a two-word integer.\n+   WORDS points to the array of words.\n    The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */\n \n static void\n-decode (shorts, low, hi)\n-     short *shorts;\n+decode (words, low, hi)\n+     HOST_WIDE_INT *words;\n      HOST_WIDE_INT *low, *hi;\n {\n-  register int i;\n-  HOST_WIDE_INT lv = 0, hv = 0;\n-\n-  for (i = 0; i < MAX_SHORTS / 2; i++)\n-    {\n-      lv |= (HOST_WIDE_INT) shorts[i] << (i * 8);\n-      hv |= (HOST_WIDE_INT) shorts[i + MAX_SHORTS / 2] << (i * 8);\n-    }\n-\n-  *low = lv, *hi = hv;\n+  *low = words[0] | words[1] * BASE;\n+  *hi = words[2] | words[3] * BASE;\n }\n \f\n /* Make the integer constant T valid for its type\n@@ -225,38 +218,27 @@ force_fit_type (t, overflow)\n /* Add two doubleword integers with doubleword result.\n    Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n-   We use the 8-shorts representation internally.  */\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n add_double (l1, h1, l2, h2, lv, hv)\n      HOST_WIDE_INT l1, h1, l2, h2;\n      HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[MAX_SHORTS];\n-  short arg2[MAX_SHORTS];\n-  register int carry = 0;\n-  register int i;\n-\n-  encode (arg1, l1, h1);\n-  encode (arg2, l2, h2);\n+  HOST_WIDE_INT l, h;\n \n-  for (i = 0; i < MAX_SHORTS; i++)\n-    {\n-      carry += arg1[i] + arg2[i];\n-      arg1[i] = carry & 0xff;\n-      carry >>= 8;\n-    }\n+  l = l1 + l2;\n+  h = h1 + h2 + ((unsigned HOST_WIDE_INT) l < l1);\n \n-  decode (arg1, lv, hv);\n-  return overflow_sum_sign (h1, h2, *hv);\n+  *lv = l;\n+  *hv = h;\n+  return overflow_sum_sign (h1, h2, h);\n }\n \n /* Negate a doubleword integer with doubleword result.\n    Return nonzero if the operation overflows, assuming it's signed.\n    The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n-   We use the 8-shorts representation internally.  */\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n neg_double (l1, h1, lv, hv)\n@@ -281,86 +263,46 @@ neg_double (l1, h1, lv, hv)\n    Return nonzero if the operation overflows, assuming it's signed.\n    Each argument is given as two `HOST_WIDE_INT' pieces.\n    One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.\n-   We use the 8-shorts representation internally.  */\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n int\n mul_double (l1, h1, l2, h2, lv, hv)\n      HOST_WIDE_INT l1, h1, l2, h2;\n      HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[MAX_SHORTS];\n-  short arg2[MAX_SHORTS];\n-  short prod[MAX_SHORTS * 2];\n-  register int carry = 0;\n+  HOST_WIDE_INT arg1[4];\n+  HOST_WIDE_INT arg2[4];\n+  HOST_WIDE_INT prod[4 * 2];\n+  register unsigned HOST_WIDE_INT carry;\n   register int i, j, k;\n   HOST_WIDE_INT toplow, tophigh, neglow, neghigh;\n \n-  /* These cases are used extensively, arising from pointer combinations.  */\n-  if (h2 == 0)\n-    {\n-      if (l2 == 2)\n-\t{\n-\t  int overflow = left_shift_overflows (h1, 1);\n-\t  unsigned HOST_WIDE_INT temp = l1 + l1;\n-\t  *hv = (h1 << 1) + (temp < l1);\n-\t  *lv = temp;\n-\t  return overflow;\n-\t}\n-      if (l2 == 4)\n-\t{\n-\t  int overflow = left_shift_overflows (h1, 2);\n-\t  unsigned HOST_WIDE_INT temp = l1 + l1;\n-\t  h1 = (h1 << 2) + ((temp < l1) << 1);\n-\t  l1 = temp;\n-\t  temp += temp;\n-\t  h1 += (temp < l1);\n-\t  *lv = temp;\n-\t  *hv = h1;\n-\t  return overflow;\n-\t}\n-      if (l2 == 8)\n-\t{\n-\t  int overflow = left_shift_overflows (h1, 3);\n-\t  unsigned HOST_WIDE_INT temp = l1 + l1;\n-\t  h1 = (h1 << 3) + ((temp < l1) << 2);\n-\t  l1 = temp;\n-\t  temp += temp;\n-\t  h1 += (temp < l1) << 1;\n-\t  l1 = temp;\n-\t  temp += temp;\n-\t  h1 += (temp < l1);\n-\t  *lv = temp;\n-\t  *hv = h1;\n-\t  return overflow;\n-\t}\n-    }\n-\n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n \n   bzero ((char *) prod, sizeof prod);\n \n-  for (i = 0; i < MAX_SHORTS; i++)\n-    for (j = 0; j < MAX_SHORTS; j++)\n-      {\n-\tk = i + j;\n-\tcarry = arg1[i] * arg2[j];\n-\twhile (carry)\n-\t  {\n-\t    carry += prod[k];\n-\t    prod[k] = carry & 0xff;\n-\t    carry >>= 8;\n-\t    k++;\n-\t  }\n-      }\n+  for (i = 0; i < 4; i++)\n+    {\n+      carry = 0;\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  k = i + j;\n+\t  /* This product is <= 0xFFFE0001, the sum <= 0xFFFF0000.  */\n+\t  carry += arg1[i] * arg2[j];\n+\t  /* Since prod[p] < 0xFFFF, this sum <= 0xFFFFFFFF.  */\n+\t  carry += prod[k];\n+\t  prod[k] = LOWPART (carry);\n+\t  carry = HIGHPART (carry);\n+\t}\n+      prod[i + 4] = carry;\n+    }\n \n-  decode (prod, lv, hv);\t/* This ignores\n-\t\t\t\t   prod[MAX_SHORTS] -> prod[MAX_SHORTS*2-1] */\n+  decode (prod, lv, hv);\t/* This ignores prod[4] through prod[4*2-1] */\n \n   /* Check for overflow by calculating the top half of the answer in full;\n      it should agree with the low half's sign bit.  */\n-  decode (prod+MAX_SHORTS, &toplow, &tophigh);\n+  decode (prod+4, &toplow, &tophigh);\n   if (h1 < 0)\n     {\n       neg_double (l2, h2, &neglow, &neghigh);\n@@ -387,34 +329,26 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n      HOST_WIDE_INT *lv, *hv;\n      int arith;\n {\n-  short arg1[MAX_SHORTS];\n-  register int i;\n-  register int carry;\n-\n   if (count < 0)\n     {\n       rshift_double (l1, h1, - count, prec, lv, hv, arith);\n       return;\n     }\n+  \n+  if (count >= prec)\n+    count = (unsigned HOST_WIDE_INT) count & prec;\n \n-  encode (arg1, l1, h1);\n-\n-  if (count > prec)\n-    count = prec;\n-\n-  while (count > 0)\n+  if (count >= HOST_BITS_PER_WIDE_INT)\n     {\n-      carry = 0;\n-      for (i = 0; i < MAX_SHORTS; i++)\n-\t{\n-\t  carry += arg1[i] << 1;\n-\t  arg1[i] = carry & 0xff;\n-\t  carry >>= 8;\n-\t}\n-      count--;\n+      *hv = (unsigned HOST_WIDE_INT) l1 << count - HOST_BITS_PER_WIDE_INT;\n+      *lv = 0;\n+    }\n+  else\n+    {\n+      *hv = (((unsigned HOST_WIDE_INT) h1 << count)\n+\t     | ((unsigned HOST_WIDE_INT) l1 >> HOST_BITS_PER_WIDE_INT - count - 1 >> 1));\n+      *lv = (unsigned HOST_WIDE_INT) l1 << count;\n     }\n-\n-  decode (arg1, lv, hv);\n }\n \n /* Shift the doubleword integer in L1, H1 right by COUNT places\n@@ -429,31 +363,30 @@ rshift_double (l1, h1, count, prec, lv, hv, arith)\n      HOST_WIDE_INT *lv, *hv;\n      int arith;\n {\n-  short arg1[MAX_SHORTS];\n-  register int i;\n-  register int carry;\n+  unsigned HOST_WIDE_INT signmask;\n+  signmask = (arith\n+\t      ? -((unsigned HOST_WIDE_INT) h1 >> (HOST_BITS_PER_WIDE_INT - 1))\n+\t      : 0);\n \n-  encode (arg1, l1, h1);\n+  if (count >= prec)\n+    count = (unsigned HOST_WIDE_INT) count % prec;\n \n-  if (count > prec)\n-    count = prec;\n-\n-  while (count > 0)\n+  if (count >= HOST_BITS_PER_WIDE_INT)\n     {\n-      carry = arith && arg1[7] >> 7; \n-      for (i = MAX_SHORTS - 1; i >= 0; i--)\n-\t{\n-\t  carry <<= 8;\n-\t  carry += arg1[i];\n-\t  arg1[i] = (carry >> 1) & 0xff;\n-\t}\n-      count--;\n+      *hv = signmask;\n+      *lv = ((signmask << 2 * HOST_BITS_PER_WIDE_INT - count - 1 << 1)\n+\t     | ((unsigned HOST_WIDE_INT) h1 >> count - HOST_BITS_PER_WIDE_INT));\n+    }\n+  else\n+    {\n+      *lv = (((unsigned HOST_WIDE_INT) l1 >> count)\n+\t     | ((unsigned HOST_WIDE_INT) h1 << HOST_BITS_PER_WIDE_INT - count - 1 << 1));\n+      *hv = ((signmask << HOST_BITS_PER_WIDE_INT - count)\n+\t     | ((unsigned HOST_WIDE_INT) h1 >> count));\n     }\n-\n-  decode (arg1, lv, hv);\n }\n \f\n-/* Rotate the doubldword integer in L1, H1 left by COUNT places\n+/* Rotate the doubleword integer in L1, H1 left by COUNT places\n    keeping only PREC bits of result.\n    Rotate right if COUNT is negative.\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n@@ -464,7 +397,7 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n      int prec;\n      HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[MAX_SHORTS];\n+  HOST_WIDE_INT arg1[4];\n   register int i;\n   register int carry;\n \n@@ -479,14 +412,14 @@ lrotate_double (l1, h1, count, prec, lv, hv)\n   if (count > prec)\n     count = prec;\n \n-  carry = arg1[MAX_SHORTS - 1] >> 7;\n+  carry = arg1[4 - 1] >> 16 - 1;\n   while (count > 0)\n     {\n-      for (i = 0; i < MAX_SHORTS; i++)\n+      for (i = 0; i < 4; i++)\n \t{\n \t  carry += arg1[i] << 1;\n-\t  arg1[i] = carry & 0xff;\n-\t  carry >>= 8;\n+\t  arg1[i] = LOWPART (carry);\n+\t  carry = HIGHPART (carry);\n \t}\n       count--;\n     }\n@@ -504,7 +437,7 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n      int prec;\n      HOST_WIDE_INT *lv, *hv;\n {\n-  short arg1[MAX_SHORTS];\n+  HOST_WIDE_INT arg1[4];\n   register int i;\n   register int carry;\n \n@@ -516,11 +449,11 @@ rrotate_double (l1, h1, count, prec, lv, hv)\n   carry = arg1[0] & 1;\n   while (count > 0)\n     {\n-      for (i = MAX_SHORTS - 1; i >= 0; i--)\n+      for (i = 4 - 1; i >= 0; i--)\n \t{\n-\t  carry <<= 8;\n+\t  carry *= BASE;\n \t  carry += arg1[i];\n-\t  arg1[i] = (carry >> 1) & 0xff;\n+\t  arg1[i] = LOWPART (carry >> 1);\n \t}\n       count--;\n     }\n@@ -548,9 +481,10 @@ div_and_round_double (code, uns,\n      HOST_WIDE_INT *lquo, *hquo, *lrem, *hrem;\n {\n   int quo_neg = 0;\n-  short num[MAX_SHORTS + 1];\t/* extra element for scaling.  */\n-  short den[MAX_SHORTS], quo[MAX_SHORTS];\n-  register int i, j, work;\n+  HOST_WIDE_INT num[4 + 1];\t/* extra element for scaling.  */\n+  HOST_WIDE_INT den[4], quo[4];\n+  register int i, j;\n+  unsigned HOST_WIDE_INT work;\n   register int carry = 0;\n   HOST_WIDE_INT lnum = lnum_orig;\n   HOST_WIDE_INT hnum = hnum_orig;\n@@ -603,131 +537,104 @@ div_and_round_double (code, uns,\n   encode (num, lnum, hnum); \n   encode (den, lden, hden);\n \n-  /* This code requires more than just hden == 0.\n-     We also have to require that we don't need more than three bytes\n-     to hold CARRY.  If we ever did need four bytes to hold it, we\n-     would lose part of it when computing WORK on the next round.  */\n-  if (hden == 0 && (((unsigned HOST_WIDE_INT) lden << 8) >> 8) == lden)\n-    {\t\t\t\t/* simpler algorithm */\n+  /* Special code for when the divisor < BASE.  */\n+  if (hden == 0 && lden < BASE)\n+    {\n       /* hnum != 0 already checked.  */\n-      for (i = MAX_SHORTS - 1; i >= 0; i--)\n+      for (i = 4 - 1; i >= 0; i--)\n \t{\n-\t  work = num[i] + (carry << 8);\n+\t  work = num[i] + carry * BASE;\n \t  quo[i] = work / (unsigned HOST_WIDE_INT) lden;\n \t  carry = work % (unsigned HOST_WIDE_INT) lden;\n \t}\n     }\n-  else {\t\t\t/* full double precision,\n-\t\t\t\t   with thanks to Don Knuth's\n-\t\t\t\t   \"Seminumerical Algorithms\".  */\n-#define BASE 256\n-    int quo_est, scale, num_hi_sig, den_hi_sig, quo_hi_sig;\n+  else\n+    {\n+      /* Full double precision division,\n+\t with thanks to Don Knuth's \"Seminumerical Algorithms\".  */\n+    int quo_est, scale, num_hi_sig, den_hi_sig;\n \n     /* Find the highest non-zero divisor digit.  */\n-    for (i = MAX_SHORTS - 1; ; i--)\n+    for (i = 4 - 1; ; i--)\n       if (den[i] != 0) {\n \tden_hi_sig = i;\n \tbreak;\n       }\n-    for (i = MAX_SHORTS - 1; ; i--)\n-      if (num[i] != 0) {\n-\tnum_hi_sig = i;\n-\tbreak;\n-      }\n-    quo_hi_sig = num_hi_sig - den_hi_sig + 1;\n \n     /* Insure that the first digit of the divisor is at least BASE/2.\n        This is required by the quotient digit estimation algorithm.  */\n \n     scale = BASE / (den[den_hi_sig] + 1);\n     if (scale > 1) {\t\t/* scale divisor and dividend */\n       carry = 0;\n-      for (i = 0; i <= MAX_SHORTS - 1; i++) {\n+      for (i = 0; i <= 4 - 1; i++) {\n \twork = (num[i] * scale) + carry;\n-\tnum[i] = work & 0xff;\n-\tcarry = work >> 8;\n-\tif (num[i] != 0) num_hi_sig = i;\n-      }\n+\tnum[i] = LOWPART (work);\n+\tcarry = HIGHPART (work);\n+      } num[4] = carry;\n       carry = 0;\n-      for (i = 0; i <= MAX_SHORTS - 1; i++) {\n+      for (i = 0; i <= 4 - 1; i++) {\n \twork = (den[i] * scale) + carry;\n-\tden[i] = work & 0xff;\n-\tcarry = work >> 8;\n+\tden[i] = LOWPART (work);\n+\tcarry = HIGHPART (work);\n \tif (den[i] != 0) den_hi_sig = i;\n       }\n     }\n \n+    num_hi_sig = 4;\n+\n     /* Main loop */\n-    for (i = quo_hi_sig; i > 0; i--) {\n+    for (i = num_hi_sig - den_hi_sig - 1; i >= 0; i--) {\n       /* guess the next quotient digit, quo_est, by dividing the first\n \t two remaining dividend digits by the high order quotient digit.\n \t quo_est is never low and is at most 2 high.  */\n+      unsigned HOST_WIDE_INT tmp;\n \n-      int num_hi;\t\t/* index of highest remaining dividend digit */\n-\n-      num_hi = i + den_hi_sig;\n-\n-      work = (num[num_hi] * BASE) + (num_hi > 0 ? num[num_hi - 1] : 0);\n-      if (num[num_hi] != den[den_hi_sig]) {\n+      num_hi_sig = i + den_hi_sig + 1;\n+      work = num[num_hi_sig] * BASE + num[num_hi_sig - 1];\n+      if (num[num_hi_sig] != den[den_hi_sig])\n \tquo_est = work / den[den_hi_sig];\n-      }\n-      else {\n+      else\n \tquo_est = BASE - 1;\n-      }\n \n       /* refine quo_est so it's usually correct, and at most one high.   */\n-      while ((den[den_hi_sig - 1] * quo_est)\n-\t     > (((work - (quo_est * den[den_hi_sig])) * BASE)\n-\t\t + ((num_hi - 1) > 0 ? num[num_hi - 2] : 0)))\n+      tmp = work - quo_est * den[den_hi_sig];\n+      if (tmp < BASE\n+\t  && den[den_hi_sig - 1] * quo_est > (tmp * BASE + num[num_hi_sig - 2]))\n \tquo_est--;\n \n       /* Try QUO_EST as the quotient digit, by multiplying the\n          divisor by QUO_EST and subtracting from the remaining dividend.\n \t Keep in mind that QUO_EST is the I - 1st digit.  */\n \n       carry = 0;\n-\n       for (j = 0; j <= den_hi_sig; j++)\n \t{\n-\t  int digit;\n-\n-\t  work = num[i + j - 1] - (quo_est * den[j]) + carry;\n-\t  digit = work & 0xff;\n-\t  carry = work >> 8;\n-\t  if (digit < 0)\n-\t    {\n-\t      digit += BASE;\n-\t      carry--;\n-\t    }\n-\t  num[i + j - 1] = digit;\n+\t  work = quo_est * den[j] + carry;\n+\t  carry = HIGHPART (work);\n+\t  work = num[i + j] - LOWPART (work);\n+\t  num[i + j] = LOWPART (work);\n+\t  carry += HIGHPART (work) != 0;\n \t}\n \n       /* if quo_est was high by one, then num[i] went negative and\n \t we need to correct things.  */\n \n-      if (num[num_hi] < 0)\n+      if (num[num_hi_sig] < carry)\n \t{\n \t  quo_est--;\n \t  carry = 0;\t\t/* add divisor back in */\n \t  for (j = 0; j <= den_hi_sig; j++)\n \t    {\n-\t      work = num[i + j - 1] + den[j] + carry;\n-\t      if (work > BASE)\n-\t\t{\n-\t\t  work -= BASE;\n-\t\t  carry = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  carry = 0;\n-\t\t}\n-\t      num[i + j - 1] = work;\n+\t      work = num[i + j] + den[j] + carry;\n+\t      carry = HIGHPART (work);\n+\t      num[i + j] = LOWPART (work);\n \t    }\n-\t  num [num_hi] += carry;\n+\t  num [num_hi_sig] += carry;\n \t}\n \n       /* store the quotient digit.  */\n-      quo[i - 1] = quo_est;\n+      quo[i] = quo_est;\n     }\n   }\n \n@@ -1179,72 +1086,6 @@ const_binop (code, arg1, arg2, notrunc)\n \t  break;\n \n \tcase MULT_EXPR:\n-\t  /* Optimize simple cases.  */\n-\t  if (int1h == 0)\n-\t    {\n-\t      unsigned HOST_WIDE_INT temp;\n-\n-\t      switch (int1l)\n-\t\t{\n-\t\tcase 0:\n-\t\t  t = build_int_2 (0, 0);\n-\t\t  goto got_it;\n-\t\tcase 1:\n-\t\t  t = build_int_2 (int2l, int2h);\n-\t\t  goto got_it;\n-\t\tcase 2:\n-\t\t  overflow = left_shift_overflows (int2h, 1);\n-\t\t  temp = int2l + int2l;\n-\t\t  int2h = (int2h << 1) + (temp < int2l);\n-\t\t  t = build_int_2 (temp, int2h);\n-\t\t  goto got_it;\n-#if 0 /* This code can lose carries.  */\n-\t\tcase 3:\n-\t\t  temp = int2l + int2l + int2l;\n-\t\t  int2h = int2h * 3 + (temp < int2l);\n-\t\t  t = build_int_2 (temp, int2h);\n-\t\t  goto got_it;\n-#endif\n-\t\tcase 4:\n-\t\t  overflow = left_shift_overflows (int2h, 2);\n-\t\t  temp = int2l + int2l;\n-\t\t  int2h = (int2h << 2) + ((temp < int2l) << 1);\n-\t\t  int2l = temp;\n-\t\t  temp += temp;\n-\t\t  int2h += (temp < int2l);\n-\t\t  t = build_int_2 (temp, int2h);\n-\t\t  goto got_it;\n-\t\tcase 8:\n-\t\t  overflow = left_shift_overflows (int2h, 3);\n-\t\t  temp = int2l + int2l;\n-\t\t  int2h = (int2h << 3) + ((temp < int2l) << 2);\n-\t\t  int2l = temp;\n-\t\t  temp += temp;\n-\t\t  int2h += (temp < int2l) << 1;\n-\t\t  int2l = temp;\n-\t\t  temp += temp;\n-\t\t  int2h += (temp < int2l);\n-\t\t  t = build_int_2 (temp, int2h);\n-\t\t  goto got_it;\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  if (int2h == 0)\n-\t    {\n-\t      if (int2l == 0)\n-\t\t{\n-\t\t  t = build_int_2 (0, 0);\n-\t\t  break;\n-\t\t}\n-\t      if (int2l == 1)\n-\t\t{\n-\t\t  t = build_int_2 (int1l, int1h);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n \t  overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n \t  t = build_int_2 (low, hi);\n \t  break;\n@@ -4060,56 +3901,22 @@ fold (expr)\n       if (integer_zerop (arg1))\n \treturn t;\n \n-      /* If we have ((a / C1) / C2) where both division are the same type, tr\n+      /* If we have ((a / C1) / C2) where both division are the same type, try\n \t to simplify.  First see if C1 * C2 overflows or not.  */\n       if (TREE_CODE (arg0) == code && TREE_CODE (arg1) == INTEGER_CST\n \t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n \t{\n-\t  tem = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 1), arg1, 0);\n+\t  tree new_divisor;\n \n-\t  /* If it overflows, the result is +/- 1 or zero, depending on\n-\t     the signs of the constants and remaining operand and on which\n-\t     division operation is being performed.  */\n+\t  new_divisor = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 1), arg1, 0);\n+\t  tem = const_binop (FLOOR_DIV_EXPR, new_divisor, arg1, 0);\n \n-\t  if (TREE_OVERFLOW (tem))\n+\t  if (TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) == TREE_INT_CST_LOW (tem)\n+\t      && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == TREE_INT_CST_HIGH (tem))\n \t    {\n-\t      /* 1 if C1 * C2 is negative (i.e., C1 and C2 have\n-\t\t different signs).  */\n-\t      int c_neg = ((tree_int_cst_sgn (arg1) < 0)\n-\t\t\t   == (tree_int_cst_sgn (TREE_OPERAND (arg0, 1)) < 0));\n-\n-\t      switch (code)\n-\t\t{\n-\t\tcase EXACT_DIV_EXPR:\n-\t\t  /* If this overflowed, it couldn't have been exact.  */\n-\t\t  abort ();\n-\n-\t\tcase TRUNC_DIV_EXPR:\n-\t\t  return omit_one_operand (type, integer_zero_node,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0));\n-\n-\t\tcase FLOOR_DIV_EXPR:\n-\t\t  /* -1 or zero, depending on signs of remaining\n-\t\t     operand and constants.  */\n-\t\t  tem = build (c_neg ? GE_EXPR : LE_EXPR, integer_type_node,\n-\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t       convert (type, integer_zero_node));\n-\t\t  return fold (build (NEGATE_EXPR, type,\n-\t\t\t\t      convert (type, fold (tem))));\n-\n-\t\tcase CEIL_DIV_EXPR:\n-\t\t  /* Zero or 1, depending on signs of remaining\n-\t\t     operand and constants.  */\n-\t\t  tem = build (c_neg ? LE_EXPR : GE_EXPR, integer_type_node,\n-\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t       convert (type, integer_zero_node));\n-\t\t  \n-\t\t  return convert (type, fold (tem));\n-\t\t}\n+\t      /* If no overflow, divide by C1*C2.  */\n+\t      return fold (build (code, type, TREE_OPERAND (arg0, 0), new_divisor));\n \t    }\n-\t  else\n-\t    /* If no overflow, divide by C1*C2.  */\n-\t    return fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n \t}\n \n       /* Look for ((a * C1) / C3) or (((a * C1) + C2) / C3),\n@@ -4187,6 +3994,53 @@ fold (expr)\n \t    }\n \t}\n \n+      /* Note that this transformation might sometimes cause division-by-zero\n+\t to pass unnoticed.  For example when C=2 and y=31.  If that is unacceptable,\n+\t we could restrict the optimization to the case when log == 0.  */\n+\n+      if ((code == FLOOR_DIV_EXPR || code == TRUNC_DIV_EXPR)\n+\t  && TREE_CODE (arg1) == LSHIFT_EXPR)\n+\t{\n+\t  int log;\n+\t  if (TREE_CODE (TREE_OPERAND (arg1, 0)) == INTEGER_CST\n+\t      && (log = exact_log2 (TREE_INT_CST_LOW (TREE_OPERAND (arg1, 0)))) >= 0\n+\t      && TREE_INT_CST_HIGH (TREE_OPERAND (arg1, 0)) == 0)\n+\t    {\n+\t      tree cnt;\n+\t      cnt = log == 0 ? TREE_OPERAND (arg1, 1)\n+\t\t: fold (build (PLUS_EXPR, TREE_TYPE (TREE_OPERAND (arg1, 1)),\n+\t\t\t       TREE_OPERAND (arg1, 1),\n+\t\t\t       build_int_2 (log, 0)));\n+\n+\t      if (TREE_UNSIGNED (type) || code == FLOOR_DIV_EXPR)\n+\t\t{\n+\t\t  /* (x / (C << y)) where C = 1 << log  =>  x >> (y + log)  */\n+\t\t  /* BUG: First TYPE here should always be unsigned to get logical\n+\t\t     shift.  How do we do that?  */\n+\t\t  return fold (build (RSHIFT_EXPR, type, arg0, cnt));\n+\t\t}\n+\n+\t      /* (x / (C << y)) when C = 1 << log  =>\n+\t\t  => (ashiftrt (plus x (and (ashiftrt x 31)\n+\t\t\t\t\t    (not (lshift -1 cnt)))) cnt),\n+\t\t    where cnt is y + log  */\n+\t      /* BUG: Several TYPE arguments here might be wrong.  */\n+\t      return\n+\t\tfold (build (RSHIFT_EXPR, type,\n+\t\t\t     fold (build (PLUS_EXPR, type,\n+\t\t\t\t\t  arg0,\n+\t\t\t\t\t  fold (build (BIT_AND_EXPR, type,\n+\t\t\t\t\t\t       fold (build (RSHIFT_EXPR, type,\n+\t\t\t\t\t\t\t\t    arg0,\n+\t\t\t\t\t\t\t\t    build_int_2 (TYPE_PRECISION (type) - 1, 0))),\n+\t\t\t\t\t\t       fold (build1 (BIT_NOT_EXPR, type,\n+\t\t\t\t\t\t\t\t     fold (build (LSHIFT_EXPR, type,\n+\t\t\t\t\t\t\t\t\t\t  build_int_2 (~0, ~0),\n+\t\t\t\t\t\t\t\t\t\t  cnt)))))))),\n+\t\t\t     cnt));\n+\t    }\n+\t}\n+\n       goto binary;\n \n     case CEIL_MOD_EXPR:"}]}