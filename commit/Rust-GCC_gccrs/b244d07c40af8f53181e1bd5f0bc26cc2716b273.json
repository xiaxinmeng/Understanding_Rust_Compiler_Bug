{"sha": "b244d07c40af8f53181e1bd5f0bc26cc2716b273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI0NGQwN2M0MGFmOGY1MzE4MWUxYmQ1ZjBiYzI2Y2MyNzE2YjI3Mw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-03-17T17:14:11Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1998-03-17T17:14:11Z"}, "message": "Regenerate.\n\nFrom-SVN: r18649", "tree": {"sha": "ecc7540075e57064ce5cf7237fdb443a97facb8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecc7540075e57064ce5cf7237fdb443a97facb8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b244d07c40af8f53181e1bd5f0bc26cc2716b273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b244d07c40af8f53181e1bd5f0bc26cc2716b273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b244d07c40af8f53181e1bd5f0bc26cc2716b273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b244d07c40af8f53181e1bd5f0bc26cc2716b273/comments", "author": null, "committer": null, "parents": [{"sha": "8d02e5c54c041355748312ff0308fe4942dcbb9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d02e5c54c041355748312ff0308fe4942dcbb9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d02e5c54c041355748312ff0308fe4942dcbb9d"}], "stats": {"total": 103, "additions": 93, "deletions": 10}, "files": [{"sha": "7db02afc9a362ea4001f2d2b0789fbc73a8107bb", "filename": "gcc/f/intdoc.texi", "status": "modified", "additions": 93, "deletions": 10, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b244d07c40af8f53181e1bd5f0bc26cc2716b273/gcc%2Ff%2Fintdoc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b244d07c40af8f53181e1bd5f0bc26cc2716b273/gcc%2Ff%2Fintdoc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fintdoc.texi?ref=b244d07c40af8f53181e1bd5f0bc26cc2716b273", "patch": "@@ -7373,7 +7373,7 @@ Loc(@var{Entity})\n @end example\n \n @noindent\n-Loc: @code{INTEGER(KIND=0)} function.\n+Loc: @code{INTEGER(KIND=7)} function.\n \n @noindent\n @var{Entity}: Any type; cannot be a constant or expression.\n@@ -9260,7 +9260,7 @@ CALL Signal(@var{Number}, @var{Handler}, @var{Status})\n or dummy/global @code{INTEGER(KIND=1)} scalar.\n \n @noindent\n-@var{Status}: @code{INTEGER(KIND=1)}; OPTIONAL; scalar; INTENT(OUT).\n+@var{Status}: @code{INTEGER(KIND=7)}; OPTIONAL; scalar; INTENT(OUT).\n \n @noindent\n Intrinsic groups: @code{unix}.\n@@ -9271,12 +9271,13 @@ Description:\n If @var{Handler} is a an @code{EXTERNAL} routine, arranges for it to be\n invoked with a single integer argument (of system-dependent length)\n when signal @var{Number} occurs.\n-If @var{Number} is an integer, it can be\n-used to turn off handling of signal @var{Handler} or revert to its default\n+If @var{Handler} is an integer, it can be\n+used to turn off handling of signal @var{Number} or revert to its default\n action.\n See @code{signal(2)}.\n \n-Note that @var{Handler} will be called using C conventions, so its value in\n+Note that @var{Handler} will be called using C conventions,\n+so the value of its argument in Fortran terms\n Fortran terms is obtained by applying @code{%LOC()} (or @var{LOC()}) to it.\n \n The value returned by @code{signal(2)} is written to @var{Status}, if\n@@ -9287,6 +9288,34 @@ Some non-GNU implementations of Fortran provide this intrinsic as\n only a function, not as a subroutine, or do not support the\n (optional) @var{Status} argument.\n \n+@emph{Warning:} Use of the @code{libf2c} run-time library function\n+@samp{signal_} directly\n+(such as via @samp{EXTERNAL SIGNAL})\n+requires use of the @code{%VAL()} construct\n+to pass an @code{INTEGER} value\n+(such as @samp{SIG_IGN} or @samp{SIG_DFL})\n+for the @var{Handler} argument.\n+\n+However, while @samp{CALL SIGNAL(@var{signum}, %VAL(SIG_IGN))}\n+works when @samp{SIGNAL} is treated as an external procedure\n+(and resolves, at link time, to @code{libf2c}'s @samp{signal_} routine),\n+this construct is not valid when @samp{SIGNAL} is recognized\n+as the intrinsic of that name.\n+\n+Therefore, for maximum portability and reliability,\n+code such references to the @samp{SIGNAL} facility as follows:\n+\n+@smallexample\n+INTRINSIC SIGNAL\n+@dots{}\n+CALL SIGNAL(@var{signum}, SIG_IGN)\n+@end smallexample\n+\n+@code{g77} will compile such a call correctly,\n+while other compilers will generally either do so as well\n+or reject the @samp{INTRINSIC SIGNAL} statement via a diagnostic,\n+allowing you to take appropriate action.\n+\n For information on other intrinsics with the same name:\n @xref{Signal Intrinsic (function)}.\n \n@@ -9303,7 +9332,7 @@ Signal(@var{Number}, @var{Handler})\n @end example\n \n @noindent\n-Signal: @code{INTEGER(KIND=1)} function.\n+Signal: @code{INTEGER(KIND=7)} function.\n \n @noindent\n @var{Number}: @code{INTEGER}; scalar; INTENT(IN).\n@@ -9321,19 +9350,73 @@ Description:\n If @var{Handler} is a an @code{EXTERNAL} routine, arranges for it to be\n invoked with a single integer argument (of system-dependent length)\n when signal @var{Number} occurs.\n-If @var{Number} is an integer, it can be\n-used to turn off handling of signal @var{Handler} or revert to its default\n+If @var{Handler} is an integer, it can be\n+used to turn off handling of signal @var{Number} or revert to its default\n action.\n See @code{signal(2)}.\n \n-Note that @var{Handler} will be called using C conventions, so its value in\n-Fortran terms is obtained by applying @code{%LOC()} (or @var{LOC()}) to it.\n+Note that @var{Handler} will be called using C conventions,\n+so the value of its argument in Fortran terms\n+is obtained by applying @code{%LOC()} (or @var{LOC()}) to it.\n \n The value returned by @code{signal(2)} is returned.\n \n Due to the side effects performed by this intrinsic, the function\n form is not recommended.\n \n+@emph{Warning:} If the returned value is stored in\n+an @code{INTEGER(KIND=1)} (default @code{INTEGER}) argument,\n+truncation of the original return value occurs on some systems\n+(such as Alphas, which have 64-bit pointers but 32-bit default integers),\n+with no warning issued by @code{g77} under normal circumstances.\n+\n+Therefore, the following code fragment might silently fail on\n+some systems:\n+\n+@smallexample\n+INTEGER RTN\n+EXTERNAL MYHNDL\n+RTN = SIGNAL(@var{signum}, MYHNDL)\n+@dots{}\n+! Restore original handler:\n+RTN = SIGNAL(@var{signum}, RTN)\n+@end smallexample\n+\n+The reason for the failure is that @samp{RTN} might not hold\n+all the information on the original handler for the signal,\n+thus restoring an invalid handler.\n+This bug could manifest itself as a spurious run-time failure\n+at an arbitrary point later during the program's execution,\n+for example.\n+\n+@emph{Warning:} Use of the @code{libf2c} run-time library function\n+@samp{signal_} directly\n+(such as via @samp{EXTERNAL SIGNAL})\n+requires use of the @code{%VAL()} construct\n+to pass an @code{INTEGER} value\n+(such as @samp{SIG_IGN} or @samp{SIG_DFL})\n+for the @var{Handler} argument.\n+\n+However, while @samp{RTN = SIGNAL(@var{signum}, %VAL(SIG_IGN))}\n+works when @samp{SIGNAL} is treated as an external procedure\n+(and resolves, at link time, to @code{libf2c}'s @samp{signal_} routine),\n+this construct is not valid when @samp{SIGNAL} is recognized\n+as the intrinsic of that name.\n+\n+Therefore, for maximum portability and reliability,\n+code such references to the @samp{SIGNAL} facility as follows:\n+\n+@smallexample\n+INTRINSIC SIGNAL\n+@dots{}\n+RTN = SIGNAL(@var{signum}, SIG_IGN)\n+@end smallexample\n+\n+@code{g77} will compile such a call correctly,\n+while other compilers will generally either do so as well\n+or reject the @samp{INTRINSIC SIGNAL} statement via a diagnostic,\n+allowing you to take appropriate action.\n+\n For information on other intrinsics with the same name:\n @xref{Signal Intrinsic (subroutine)}.\n "}]}