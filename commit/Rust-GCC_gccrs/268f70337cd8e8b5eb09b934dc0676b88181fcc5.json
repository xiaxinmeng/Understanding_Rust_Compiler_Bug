{"sha": "268f70337cd8e8b5eb09b934dc0676b88181fcc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4ZjcwMzM3Y2Q4ZThiNWViMDliOTM0ZGMwNjc2Yjg4MTgxZmNjNQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2010-12-30T13:28:05Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2010-12-30T13:28:05Z"}, "message": "emit-rtl.c (set_mem_attributes_minus_bitpos): Explicitly derive default values from MEM mode if no memory attributes are present.\n\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Explicitly derive\n\tdefault values from MEM mode if no memory attributes are present.\n\tDo not use mode alignment, even on STRICT_ALIGNMENT targets, when\n\tcalled with an expression (not a type).\n\nFrom-SVN: r168344", "tree": {"sha": "9c670cf4174680014299b8267b1aa6d19a854e3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c670cf4174680014299b8267b1aa6d19a854e3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/268f70337cd8e8b5eb09b934dc0676b88181fcc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268f70337cd8e8b5eb09b934dc0676b88181fcc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268f70337cd8e8b5eb09b934dc0676b88181fcc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268f70337cd8e8b5eb09b934dc0676b88181fcc5/comments", "author": null, "committer": null, "parents": [{"sha": "720386ac5f2f615f03289eb196b0ad4683d860a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/720386ac5f2f615f03289eb196b0ad4683d860a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/720386ac5f2f615f03289eb196b0ad4683d860a3"}], "stats": {"total": 45, "additions": 40, "deletions": 5}, "files": [{"sha": "b0e6c3052b55c96c304065eb0441c37c19934995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268f70337cd8e8b5eb09b934dc0676b88181fcc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268f70337cd8e8b5eb09b934dc0676b88181fcc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=268f70337cd8e8b5eb09b934dc0676b88181fcc5", "patch": "@@ -1,3 +1,10 @@\n+2010-12-30  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Explicitly derive\n+\tdefault values from MEM mode if no memory attributes are present.\n+\tDo not use mode alignment, even on STRICT_ALIGNMENT targets, when\n+\tcalled with an expression (not a type).\n+\n 2010-12-30  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (upper_128bits_state): Remove comments."}, {"sha": "42b2da0ea91f9ddce4c6a413fbdc663c819f0b3e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268f70337cd8e8b5eb09b934dc0676b88181fcc5/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268f70337cd8e8b5eb09b934dc0676b88181fcc5/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=268f70337cd8e8b5eb09b934dc0676b88181fcc5", "patch": "@@ -1540,11 +1540,11 @@ void\n set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t\t\t HOST_WIDE_INT bitpos)\n {\n-  alias_set_type alias = MEM_ALIAS_SET (ref);\n-  tree expr = MEM_EXPR (ref);\n-  rtx offset = MEM_OFFSET (ref);\n-  rtx size = MEM_SIZE (ref);\n-  unsigned int align = MEM_ALIGN (ref);\n+  alias_set_type alias;\n+  tree expr = NULL;\n+  rtx offset = NULL_RTX;\n+  rtx size = NULL_RTX;\n+  unsigned int align = BITS_PER_UNIT;\n   HOST_WIDE_INT apply_bitpos = 0;\n   tree type;\n \n@@ -1580,6 +1580,34 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       && TREE_CODE (type) != COMPLEX_TYPE)\n     MEM_SCALAR_P (ref) = 1;\n \n+  /* Default values from pre-existing memory attributes if present.  */\n+  if (MEM_ATTRS (ref))\n+    {\n+      /* ??? Can this ever happen?  Calling this routine on a MEM that\n+\t already carries memory attributes should probably be invalid.  */\n+      expr = MEM_EXPR (ref);\n+      offset = MEM_OFFSET (ref);\n+      size = MEM_SIZE (ref);\n+      align = MEM_ALIGN (ref);\n+    }\n+\n+  /* Otherwise, default values from the mode of the MEM reference.  */\n+  else if (GET_MODE (ref) != BLKmode)\n+    {\n+      /* Respect mode size.  */\n+      size = GEN_INT (GET_MODE_SIZE (GET_MODE (ref)));\n+      /* ??? Is this really necessary?  We probably should always get\n+\t the size from the type below.  */\n+\n+      /* Respect mode alignment for STRICT_ALIGNMENT targets if T is a type;\n+         if T is an object, always compute the object alignment below.  */\n+      if (STRICT_ALIGNMENT && TYPE_P (t))\n+\talign = GET_MODE_ALIGNMENT (GET_MODE (ref));\n+      /* ??? If T is a type, respecting mode alignment may *also* be wrong\n+\t e.g. if the type carries an alignment attribute.  Should we be\n+\t able to simply always use TYPE_ALIGN?  */\n+    }\n+\n   /* We can set the alignment from the type if we are making an object,\n      this is an INDIRECT_REF, or if TYPE_ALIGN_OK.  */\n   if (objectp || TREE_CODE (t) == INDIRECT_REF || TYPE_ALIGN_OK (type))"}]}