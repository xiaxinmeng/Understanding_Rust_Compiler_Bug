{"sha": "5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1MmMwZTA5MGVmNzAxMzEzYjZmOGQxZDFiNTBjZjlhODE1YWJmNA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-05-29T11:04:10Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-05-29T11:04:10Z"}, "message": "name-lookup.h (global_scope_p): New macro.\n\n        * name-lookup.h (global_scope_p): New macro.\n        * decl.c (pop_binding_level): Use it.  Don't refer directly to\n        global_binding_level.\n        (suspend_binding_level): Likewise.\n        (global_bindings_p): Likewise.\n        (print_other_binding_stack): Likewise.\n        (print_binding_stack): Likewise.\n        (maybe_push_to_top_level): Likewise.\n        (pushdecl_namespace_level): Likewise.\n        (cxx_init_decl_processing): Likewise.\n        (start_decl): Likewise.\n        (cp_finish_decl): Likewise.\n        (start_function): Likewise.\n        (global_binding_level): Remove.\n\nFrom-SVN: r67221", "tree": {"sha": "d7180c6ce33dcebd85341a8e4c530fb403327a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7180c6ce33dcebd85341a8e4c530fb403327a0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8520e562eedd1e487d669fa698cf4b77a45ef39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8520e562eedd1e487d669fa698cf4b77a45ef39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8520e562eedd1e487d669fa698cf4b77a45ef39"}], "stats": {"total": 77, "additions": 42, "deletions": 35}, "files": [{"sha": "b36429813f68f5edf799ad9562b33f00a9b1bae8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "patch": "@@ -1,3 +1,20 @@\n+2003-05-27  Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+\t* name-lookup.h (global_scope_p): New macro.\n+\t* decl.c (pop_binding_level): Use it.  Don't refer directly to\n+\tglobal_binding_level. \n+\t(suspend_binding_level): Likewise.\n+\t(global_bindings_p): Likewise.\n+\t(print_other_binding_stack): Likewise.\n+\t(print_binding_stack): Likewise.\n+\t(maybe_push_to_top_level): Likewise.\n+\t(pushdecl_namespace_level): Likewise.\n+\t(cxx_init_decl_processing): Likewise.\n+\t(start_decl): Likewise.\n+\t(cp_finish_decl): Likewise.\n+\t(start_function): Likewise.\n+\t(global_binding_level): Remove.\n+\n 2003-05-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* parser.c (cp_parser_explicit_instantiation): Restore old"}, {"sha": "b6a215318814a4e7dccfd16906ad5477e288842b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "patch": "@@ -438,12 +438,6 @@ struct cp_binding_level GTY(())\n \n static GTY((deletable (\"\"))) struct cp_binding_level *free_binding_level;\n \n-/* The outermost binding level, for names of file scope.\n-   This is created when the compiler is started and exists\n-   through the entire run.  */\n-\n-static GTY(()) struct cp_binding_level *global_binding_level;\n-\n /* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n \n static int keep_next_level_flag;\n@@ -513,12 +507,9 @@ find_class_binding_level (void)\n static void\n pop_binding_level (void)\n {\n-  if (global_binding_level)\n-    {\n-      /* Cannot pop a level, if there are none left to pop.  */\n-      if (current_binding_level == global_binding_level)\n-\tabort ();\n-    }\n+  if (NAMESPACE_LEVEL (global_namespace))\n+    /* Cannot pop a level, if there are none left to pop.  */\n+    my_friendly_assert (!global_scope_p (current_binding_level), 20030527);\n   /* Pop the current level, and free the structure for reuse.  */\n #if defined(DEBUG_BINDING_LEVELS)\n   binding_depth--;\n@@ -556,12 +547,9 @@ suspend_binding_level (void)\n   if (class_binding_level)\n     current_binding_level = class_binding_level;\n \n-  if (global_binding_level)\n-    {\n-      /* Cannot suspend a level, if there are none left to suspend.  */\n-      if (current_binding_level == global_binding_level)\n-\tabort ();\n-    }\n+  if (NAMESPACE_LEVEL (global_namespace))\n+    /* Cannot suspend a level, if there are none left to suspend.  */\n+    my_friendly_assert (!global_scope_p (current_binding_level), 20030527);\n   /* Suspend the current level.  */\n #if defined(DEBUG_BINDING_LEVELS)\n   binding_depth--;\n@@ -614,7 +602,7 @@ make_binding_level (void)\n int\n global_bindings_p (void)\n {\n-  return current_binding_level == global_binding_level;\n+  return global_scope_p (current_binding_level);\n }\n \n /* Return the innermost binding level that is not for a class scope.  */\n@@ -1964,7 +1952,7 @@ void\n print_other_binding_stack (struct cp_binding_level *stack)\n {\n   struct cp_binding_level *level;\n-  for (level = stack; level != global_binding_level; level = level->level_chain)\n+  for (level = stack; !global_scope_p (level); level = level->level_chain)\n     {\n       fprintf (stderr, \"binding level \");\n       fprintf (stderr, HOST_PTR_PRINTF, (void *) level);\n@@ -1981,8 +1969,9 @@ print_binding_stack (void)\n   fprintf (stderr, HOST_PTR_PRINTF, (void *) current_binding_level);\n   fprintf (stderr, \"\\nclass_binding_level=\");\n   fprintf (stderr, HOST_PTR_PRINTF, (void *) class_binding_level);\n-  fprintf (stderr, \"\\nglobal_binding_level=\");\n-  fprintf (stderr, HOST_PTR_PRINTF, (void *) global_binding_level);\n+  fprintf (stderr, \"\\nNAMESPACE_LEVEL (global_namespace)=\");\n+  fprintf (stderr, HOST_PTR_PRINTF,\n+           (void *) NAMESPACE_LEVEL (global_namespace));\n   fprintf (stderr, \"\\n\");\n   if (class_binding_level)\n     {\n@@ -1998,7 +1987,7 @@ print_binding_stack (void)\n     b = current_binding_level;\n   print_other_binding_stack (b);\n   fprintf (stderr, \"global:\\n\");\n-  print_binding_level (global_binding_level);\n+  print_binding_level (NAMESPACE_LEVEL (global_namespace));\n }\n \n /* Namespace binding access routines: The namespace_bindings field of\n@@ -2224,7 +2213,7 @@ maybe_push_to_top_level (int pseudo)\n   if (scope_chain && previous_class_type)\n     old_bindings = store_bindings (previous_class_values, old_bindings);\n \n-  /* Have to include global_binding_level, because class-level decls\n+  /* Have to include the global scope, because class-scope decls\n      aren't listed anywhere useful.  */\n   for (; b; b = b->level_chain)\n     {\n@@ -2234,7 +2223,7 @@ maybe_push_to_top_level (int pseudo)\n \t inserted into namespace level, finish_file wouldn't find them\n \t when doing pending instantiations. Therefore, don't stop at\n \t namespace level, but continue until :: .  */\n-      if (b == global_binding_level || (pseudo && b->template_parms_p))\n+      if (global_scope_p (b) || (pseudo && b->template_parms_p))\n \tbreak;\n \n       old_bindings = store_bindings (b->names, old_bindings);\n@@ -4110,7 +4099,7 @@ pushdecl_namespace_level (tree x)\n       tree name = DECL_NAME (x);\n       tree newval;\n       tree *ptr = (tree *)0;\n-      for (; b != global_binding_level; b = b->level_chain)\n+      for (; !global_scope_p (b); b = b->level_chain)\n         {\n           tree shadowed = b->type_shadowed;\n           for (; shadowed; shadowed = TREE_CHAIN (shadowed))\n@@ -4137,8 +4126,7 @@ pushdecl_namespace_level (tree x)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n-/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL,\n-   if appropriate.  */\n+/* Like pushdecl, only it places X in the global scope if appropriate.  */\n \n tree\n pushdecl_top_level (tree x)\n@@ -6196,13 +6184,12 @@ cxx_init_decl_processing (void)\n \n   /* Make the binding_level structure for global names.  */\n   pushlevel (0);\n-  global_binding_level = current_binding_level;\n-  global_binding_level->type_decls = binding_table_new (GLOBAL_SCOPE_HT_SIZE);\n+  current_binding_level->type_decls = binding_table_new (GLOBAL_SCOPE_HT_SIZE);\n   /* The global level is the namespace level of ::.  */\n-  NAMESPACE_LEVEL (global_namespace) = global_binding_level;\n+  NAMESPACE_LEVEL (global_namespace) = current_binding_level;\n   declare_namespace_level ();\n \n-  VARRAY_TREE_INIT (global_binding_level->static_decls,\n+  VARRAY_TREE_INIT (current_binding_level->static_decls,\n \t\t    200,\n \t\t    \"Static declarations\");\n \n@@ -6984,7 +6971,7 @@ start_decl (tree declarator,\n   cplus_decl_attributes (&decl, attributes, 0);\n \n   /* If #pragma weak was used, mark the decl weak now.  */\n-  if (current_binding_level == global_binding_level)\n+  if (global_scope_p (current_binding_level))\n     maybe_apply_pragma_weak (decl);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL\n@@ -7997,7 +7984,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n     }\n \n   /* If a name was specified, get the string.  */\n-  if (current_binding_level == global_binding_level)\n+  if (global_scope_p (current_binding_level))\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n@@ -13345,7 +13332,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n       cplus_decl_attributes (&decl1, attrs, 0);\n \n       /* If #pragma weak was used, mark the decl weak now.  */\n-      if (current_binding_level == global_binding_level)\n+      if (global_scope_p (current_binding_level))\n \tmaybe_apply_pragma_weak (decl1);\n \n       fntype = TREE_TYPE (decl1);"}, {"sha": "943106e74620af4197b40e057694b715b9c8e412", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f52c0e090ef701313b6f8d1d1b50cf9a815abf4/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=5f52c0e090ef701313b6f8d1d1b50cf9a815abf4", "patch": "@@ -108,6 +108,9 @@ struct cxx_binding GTY(())\n extern cxx_binding *cxx_binding_make (tree, tree);\n extern void cxx_binding_free (cxx_binding *);\n \f\n+/* True if SCOPE designates the global scope binding contour.  */\n+#define global_scope_p(SCOPE) \\\n+  ((SCOPE) == NAMESPACE_LEVEL (global_namespace))\n \n extern cxx_binding *cxx_scope_find_binding_for_name (cxx_scope *, tree);\n extern cxx_binding *binding_for_name (cxx_scope *, tree);"}]}