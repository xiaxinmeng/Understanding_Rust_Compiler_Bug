{"sha": "86ce5d2fc19438f92afcba1273153071eab48da4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjZTVkMmZjMTk0MzhmOTJhZmNiYTEyNzMxNTMwNzFlYWI0OGRhNA==", "commit": {"author": {"name": "Martin Liska", "email": "marxin.liska@gmail.com", "date": "2013-11-11T23:21:02Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2013-11-11T23:21:02Z"}, "message": "Time profiler introduced.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r204690", "tree": {"sha": "91cab9d80f43cc346699b11a23a3f3458b7ab15e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91cab9d80f43cc346699b11a23a3f3458b7ab15e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ce5d2fc19438f92afcba1273153071eab48da4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ce5d2fc19438f92afcba1273153071eab48da4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ce5d2fc19438f92afcba1273153071eab48da4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ce5d2fc19438f92afcba1273153071eab48da4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9544822809268ed981b10d31efd6225361ba537b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9544822809268ed981b10d31efd6225361ba537b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9544822809268ed981b10d31efd6225361ba537b"}], "stats": {"total": 269, "additions": 257, "deletions": 12}, "files": [{"sha": "92bb7a1124001940e608f4adc1414cc0710a7202", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -1,3 +1,31 @@\n+2013-11-11  Martin Liska  <marxin.liska@gmail.com>\n+\t\t\t\t\t\tJan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Profile dump added.\n+\t* cgraph.h (struct cgraph_node): New time profile variable added.\n+\t* cgraphclones.c (cgraph_clone_node): Time profile is cloned.\n+\t* gcov-io.h (gcov_type): New profiler type introduced.\n+\t* ipa-profile.c (lto_output_node): Streaming for time profile added.\n+\t(input_node): Time profiler is read from LTO stream.\n+\t* predict.c (maybe_hot_count_p): Hot prediction changed.\n+\t* profile.c (instrument_values): New case for time profiler added.\n+\t(compute_value_histograms): Read of time profile.\n+\t* tree-pretty-print.c (dump_function_header): Time profiler is dumped.\n+\t* tree-profile.c (init_ic_make_global_vars): Time profiler function added.\n+\t(gimple_init_edge_profiler): TP function instrumentation.\n+\t(gimple_gen_time_profiler): New.\n+\t* value-prof.c (gimple_add_histogram_value): Support for time profiler\n+\tadded.\n+\t(dump_histogram_value): TP type added to dumps.\n+\t(visit_hist): More sensitive check that takes TP into account.\n+\t(gimple_find_values_to_profile): TP instrumentation.\n+\t* value-prof.h (hist_type): New histogram type added.\n+\t(struct histogram_value_t): Pointer to struct function added.\n+\t* libgcc/Makefile.in: New GCOV merge function for TP added.\n+\t* libgcov.c: function_counter variable introduced.\n+\t(_gcov_merge_time_profile): New.\n+\t(_gcov_time_profiler): New.\n+\n 2013-11-11  Marc Glisse  <marc.glisse@inria.fr>\n \t    Jeff Law  <law@redhat.com>\n "}, {"sha": "385b11da7975a2f7efb697808e5b06d660df8e10", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -1890,6 +1890,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (node->profile_id)\n     fprintf (f, \"  Profile id: %i\\n\",\n \t     node->profile_id);\n+  fprintf (f, \"  First run: %i\\n\", node->tp_first_run);\n   fprintf (f, \"  Function flags:\");\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\","}, {"sha": "dd99dc830b646286ed1b5335b2cd3496d7e62b74", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -298,6 +298,8 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   int uid;\n   /* ID assigned by the profiling.  */\n   unsigned int profile_id;\n+  /* Time profiler: first run of function.  */\n+  int tp_first_run;\n \n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */"}, {"sha": "f91fcfc6fd45bfa3f617e36f3372bfda542079c0", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -208,6 +208,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   new_node->frequency = n->frequency;\n   new_node->clone = n->clone;\n   new_node->clone.tree_map = NULL;\n+  new_node->tp_first_run = n->tp_first_run;\n   if (n->count)\n     {\n       if (new_node->count > n->count)"}, {"sha": "73a52798f0d5ce9c0b492f25e458d816a1fcc696", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -342,17 +342,18 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n \t\t\t\t      counter.  */\n #define GCOV_COUNTER_IOR\t7  /* IOR of the all values passed to\n \t\t\t\t      counter.  */\n-#define GCOV_LAST_VALUE_COUNTER 7  /* The last of counters used for value\n+#define GCOV_TIME_PROFILER  8 /* Time profile collecting first run of a function */\n+#define GCOV_LAST_VALUE_COUNTER 8  /* The last of counters used for value\n \t\t\t\t      profiling.  */\n-#define GCOV_COUNTERS\t\t8\n+#define GCOV_COUNTERS\t\t9\n \n /* Number of counters used for value profiling.  */\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n \n   /* A list of human readable names of the counters */\n #define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \\\n-      \t\t\t\t \"delta\", \"indirect_call\", \"average\", \"ior\"}\n+              \"delta\", \"indirect_call\", \"average\", \"ior\", \"time_profiler\"}\n \n   /* Names of merge functions for counters.  */\n #define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n@@ -362,7 +363,8 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n \t\t\t\t \"__gcov_merge_delta\",  \\\n \t\t\t\t \"__gcov_merge_single\", \\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n-\t\t\t\t \"__gcov_merge_ior\"}\n+\t\t\t\t \"__gcov_merge_ior\",  \\\n+         \"__gcov_merge_time_profile\" }\n \n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n@@ -511,13 +513,16 @@ extern void __gcov_merge_delta (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n /* The merge function that just ors the counters together.  */\n extern void __gcov_merge_ior (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n \n+extern void __gcov_merge_time_profile (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n+\n /* The profiler functions.  */\n extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);\n extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n extern void __gcov_one_value_profiler (gcov_type *, gcov_type);\n extern void __gcov_indirect_call_profiler_v2 (gcov_type, void *);\n extern void __gcov_average_profiler (gcov_type *, gcov_type);\n extern void __gcov_ior_profiler (gcov_type *, gcov_type);\n+extern void __gcov_time_profiler (gcov_type *);\n \n #ifndef inhibit_libc\n /* The wrappers around some library functions..  */"}, {"sha": "99dbf96b7a56ce19be3ddbe53caadac52aba9ce9", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -482,6 +482,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     ref = LCC_NOT_FOUND;\n   streamer_write_hwi_stream (ob->main_stream, ref);\n \n+  streamer_write_hwi_stream (ob->main_stream, node->tp_first_run);\n+\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->local.local, 1);\n   bp_pack_value (&bp, node->externally_visible, 1);\n@@ -1077,7 +1079,10 @@ input_node (struct lto_file_decl_data *file_data,\n     internal_error (\"bytecode stream: found multiple instances of cgraph \"\n \t\t    \"node with uid %d\", node->uid);\n \n+  node->tp_first_run = streamer_read_uhwi (ib);\n+\n   bp = streamer_read_bitpack (ib);\n+\n   input_overwrite_node (file_data, node, tag, &bp);\n \n   /* Store a reference for now, and fix up later to be a pointer.  */"}, {"sha": "2ebc07d4fb4ea02b8f0f657b14f7cecdf647b274", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin-api.h\"\n #include \"lto-streamer.h\"\n #include \"ipa-utils.h\"\n+#include \"ipa-inline.h\"\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n    all edges and removing the old node.  */\n@@ -84,6 +85,12 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   if (node->decl != prevailing_node->decl)\n     cgraph_release_function_body (node);\n \n+  /* Time profile merging */\n+  if (node->tp_first_run)\n+    prevailing_node->tp_first_run = prevailing_node->tp_first_run ?\n+      MIN (prevailing_node->tp_first_run, node->tp_first_run) :\n+      node->tp_first_run;\n+\n   /* Finally remove the replaced node.  */\n   cgraph_remove_node (node);\n }"}, {"sha": "9e50560830e9d0328162d317465766c619609202", "filename": "gcc/profile.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"cfgloop.h\"\n #include \"dumpfile.h\"\n+#include \"cgraph.h\"\n \n #include \"profile.h\"\n \n@@ -188,6 +189,15 @@ instrument_values (histogram_values values)\n \t  gimple_gen_ior_profiler (hist, t, 0);\n \t  break;\n \n+  case HIST_TYPE_TIME_PROFILE:\n+    {\n+      basic_block bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n+      gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\n+      gimple_gen_time_profiler (t, 0, gsi);\n+      break;\n+    }\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -850,6 +860,7 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n   gcov_type *histogram_counts[GCOV_N_VALUE_COUNTERS];\n   gcov_type *act_count[GCOV_N_VALUE_COUNTERS];\n   gcov_type *aact_count;\n+  struct cgraph_node *node;\n \n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)\n     n_histogram_counters[t] = 0;\n@@ -888,16 +899,30 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,\n       t = (int) hist->type;\n \n       aact_count = act_count[t];\n+\n       if (act_count[t])\n         act_count[t] += hist->n_counters;\n \n       gimple_add_histogram_value (cfun, stmt, hist);\n       hist->hvalue.counters =  XNEWVEC (gcov_type, hist->n_counters);\n       for (j = 0; j < hist->n_counters; j++)\n         if (aact_count)\n-\t  hist->hvalue.counters[j] = aact_count[j];\n-\telse\n-\t  hist->hvalue.counters[j] = 0;\n+          hist->hvalue.counters[j] = aact_count[j];\n+        else\n+          hist->hvalue.counters[j] = 0;\n+\n+      /* Time profiler counter is not related to any statement,\n+         so that we have to read the counter and set the value to\n+         the corresponding call graph node.  */\n+      if (hist->type == HIST_TYPE_TIME_PROFILE)\n+        {\n+          node = cgraph_get_node (hist->fun->decl);\n+\n+          node->tp_first_run = hist->hvalue.counters[0];\n+\n+          if (dump_file)\n+            fprintf (dump_file, \"Read tp_first_run: %d\\n\", node->tp_first_run);\n+        }\n     }\n \n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)"}, {"sha": "849597c0d0cbdd57b1ad54dcb606ec0daf54a8f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -1,3 +1,8 @@\n+2013-11-11  Martin Liska\t<marxin.liska@gmail.com>\n+\n+\t* gcc.dg/time-profiler-1.c: New test.\n+\t* gcc.dg/time-profiler-2.c: Ditto.\n+\n 2013-11-11  Marc Glisse  <marc.glisse@inria.fr>\n \t    Jeff Law  <law@redhat.com>\n "}, {"sha": "c61b534a25036236098e295f145835387e23e5b0", "filename": "gcc/testsuite/gcc.dg/tree-prof/time-profiler-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftime-profiler-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftime-profiler-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftime-profiler-1.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-options \"-O2 -fdump-ipa-profile\" } */\n+\n+__attribute__ ((noinline))\n+int foo()\n+{\n+  return 0;\n+}\n+\n+__attribute__ ((noinline))\n+int bar()\n+{\n+  return 1;\n+}\n+\n+int main ()\n+{\n+  return foo ();\n+}\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 0\" 1 \"profile\"} } */\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 1\" 1 \"profile\"} } */\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 2\" 1 \"profile\"} } */\n+/* { dg-final-use { cleanup-ipa-dump \"profile\" } } */"}, {"sha": "0411341975383965eb39f68c164f96a0676f6b4a", "filename": "gcc/testsuite/gcc.dg/tree-prof/time-profiler-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftime-profiler-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftime-profiler-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Ftime-profiler-2.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-options \"-O2 -fdump-ipa-profile\" } */\n+\n+#include <unistd.h>\n+\n+__attribute__ ((noinline))\n+int foo()\n+{\n+  return 1;\n+}\n+\n+__attribute__ ((noinline))\n+int bar()\n+{\n+  return 1;\n+}\n+\n+__attribute__ ((noinline))\n+int baz()\n+{\n+  return 1;\n+}\n+\n+__attribute__ ((noinline))\n+int baz1()\n+{\n+  return 1;\n+}\n+\n+int main ()\n+{\n+  int f = fork();\n+  int r = 0;\n+\n+  foo ();\n+\n+  if (f < 0)\n+    return 1; /* Fork failed.  */\n+\n+  if(f == 0) /* Child process.  */\n+    r = bar() - foo();\n+  else /* Parent process.  */\n+    r = foo() - foo();\n+\n+  return r;\n+}\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 0\" 2 \"profile\"} } */\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 1\" 1 \"profile\"} } */\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 2\" 1 \"profile\"} } */\n+/* { dg-final-use { scan-ipa-dump-times \"Read tp_first_run: 3\" 1 \"profile\"} } */\n+/* { dg-final-use { cleanup-ipa-dump \"profile\" } } */"}, {"sha": "43d5b923e1f4663eb1f22d49ada46804380430d4", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -51,9 +51,10 @@ static GTY(()) tree tree_interval_profiler_fn;\n static GTY(()) tree tree_pow2_profiler_fn;\n static GTY(()) tree tree_one_value_profiler_fn;\n static GTY(()) tree tree_indirect_call_profiler_fn;\n+static GTY(()) tree tree_time_profiler_fn;\n static GTY(()) tree tree_average_profiler_fn;\n static GTY(()) tree tree_ior_profiler_fn;\n-\f\n+\n \n static GTY(()) tree ic_void_ptr_var;\n static GTY(()) tree ic_gcov_type_ptr_var;\n@@ -63,7 +64,8 @@ static GTY(()) tree ptr_void;\n \n /* Add code:\n    __thread gcov*\t__gcov_indirect_call_counters; // pointer to actual counter\n-   __thread  void*\t__gcov_indirect_call_callee; // actual callee address\n+   __thread void*\t__gcov_indirect_call_callee; // actual callee address\n+   __thread int __gcov_function_counter; // time profiler function counter\n */\n static void\n init_ic_make_global_vars (void)\n@@ -145,6 +147,7 @@ gimple_init_edge_profiler (void)\n   tree gcov_type_ptr;\n   tree ic_profiler_fn_type;\n   tree average_profiler_fn_type;\n+  tree time_profiler_fn_type;\n \n   if (!gcov_type_node)\n     {\n@@ -222,6 +225,18 @@ gimple_init_edge_profiler (void)\n \t= tree_cons (get_identifier (\"leaf\"), NULL,\n \t\t     DECL_ATTRIBUTES (tree_indirect_call_profiler_fn));\n \n+      /* void (*) (gcov_type *, gcov_type, void *)  */\n+      time_profiler_fn_type\n+\t       = build_function_type_list (void_type_node,\n+\t\t\t\t\t  gcov_type_ptr, NULL_TREE);\n+      tree_time_profiler_fn\n+\t      = build_fn_decl (\"__gcov_time_profiler\",\n+\t\t\t\t     time_profiler_fn_type);\n+      TREE_NOTHROW (tree_time_profiler_fn) = 1;\n+      DECL_ATTRIBUTES (tree_time_profiler_fn)\n+\t= tree_cons (get_identifier (\"leaf\"), NULL,\n+\t\t     DECL_ATTRIBUTES (tree_time_profiler_fn));\n+\n       /* void (*) (gcov_type *, gcov_type)  */\n       average_profiler_fn_type\n \t      = build_function_type_list (void_type_node,\n@@ -247,6 +262,7 @@ gimple_init_edge_profiler (void)\n       DECL_ASSEMBLER_NAME (tree_pow2_profiler_fn);\n       DECL_ASSEMBLER_NAME (tree_one_value_profiler_fn);\n       DECL_ASSEMBLER_NAME (tree_indirect_call_profiler_fn);\n+      DECL_ASSEMBLER_NAME (tree_time_profiler_fn);\n       DECL_ASSEMBLER_NAME (tree_average_profiler_fn);\n       DECL_ASSEMBLER_NAME (tree_ior_profiler_fn);\n     }\n@@ -455,6 +471,23 @@ gimple_gen_ic_func_profiler (void)\n   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n }\n \n+/* Output instructions as GIMPLE tree at the beginning for each function.\n+   TAG is the tag of the section for counters, BASE is offset of the\n+   counter position and GSI is the iterator we place the counter.  */\n+\n+void\n+gimple_gen_time_profiler (unsigned tag, unsigned base,\n+                          gimple_stmt_iterator &gsi)\n+{\n+  tree ref_ptr = tree_coverage_counter_addr (tag, base);\n+  gimple call;\n+\n+  ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,\n+\t\t\t\t      true, NULL_TREE, true, GSI_SAME_STMT);\n+  call = gimple_build_call (tree_time_profiler_fn, 1, ref_ptr);\n+  gsi_insert_before (&gsi, call, GSI_NEW_STMT);\n+}\n+\n /* Output instructions as GIMPLE trees for code to find the most common value\n    of a difference between two evaluations of an expression.\n    VALUE is the expression whose value is profiled.  TAG is the tag of the"}, {"sha": "40e72ab8c8930b4c8175fa2663cfd25f03236361", "filename": "gcc/value-prof.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -196,6 +196,7 @@ gimple_add_histogram_value (struct function *fun, gimple stmt,\n {\n   hist->hvalue.next = gimple_histogram_value (fun, stmt);\n   set_histogram_value (fun, stmt, hist);\n+  hist->fun = fun;\n }\n \n \n@@ -338,6 +339,15 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n \t}\n       fprintf (dump_file, \".\\n\");\n       break;\n+    case HIST_TYPE_TIME_PROFILE:\n+      fprintf (dump_file, \"Time profile \");\n+      if (hist->hvalue.counters)\n+      {\n+        fprintf (dump_file, \"time:\"HOST_WIDEST_INT_PRINT_DEC,\n+                 (HOST_WIDEST_INT) hist->hvalue.counters[0]);\n+      }\n+      fprintf (dump_file, \".\\n\");\n+      break;\n     case HIST_TYPE_MAX:\n       gcc_unreachable ();\n    }\n@@ -411,6 +421,7 @@ stream_in_histogram_value (struct lto_input_block *ib, gimple stmt)\n \t  break;\n \n \tcase HIST_TYPE_IOR:\n+  case HIST_TYPE_TIME_PROFILE:\n \t  ncounters = 1;\n \t  break;\n \tcase HIST_TYPE_MAX:\n@@ -496,7 +507,9 @@ visit_hist (void **slot, void *data)\n {\n   struct pointer_set_t *visited = (struct pointer_set_t *) data;\n   histogram_value hist = *(histogram_value *) slot;\n-  if (!pointer_set_contains (visited, hist))\n+\n+  if (!pointer_set_contains (visited, hist)\n+      && hist->type != HIST_TYPE_TIME_PROFILE)\n     {\n       error (\"dead histogram\");\n       dump_histogram_value (stderr, hist);\n@@ -1919,12 +1932,14 @@ gimple_find_values_to_profile (histogram_values *values)\n   gimple_stmt_iterator gsi;\n   unsigned i;\n   histogram_value hist = NULL;\n-\n   values->create (0);\n+\n   FOR_EACH_BB (bb)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       gimple_values_to_profile (gsi_stmt (gsi), values);\n \n+  values->safe_push (gimple_alloc_histogram_value (cfun, HIST_TYPE_TIME_PROFILE, 0, 0));\n+\n   FOR_EACH_VEC_ELT (*values, i, hist)\n     {\n       switch (hist->type)\n@@ -1949,6 +1964,10 @@ gimple_find_values_to_profile (histogram_values *values)\n  \t  hist->n_counters = 3;\n \t  break;\n \n+  case HIST_TYPE_TIME_PROFILE:\n+    hist->n_counters = 1;\n+    break;\n+\n \tcase HIST_TYPE_AVERAGE:\n \t  hist->n_counters = 2;\n \t  break;"}, {"sha": "ef77af4395eb8b84af9f87a74ea013bfe87085b3", "filename": "gcc/value-prof.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -34,6 +34,7 @@ enum hist_type\n \t\t\t    called in indirect call */\n   HIST_TYPE_AVERAGE,\t/* Compute average value (sum of all values).  */\n   HIST_TYPE_IOR,\t/* Used to compute expected alignment.  */\n+  HIST_TYPE_TIME_PROFILE, /* Used for time profile */\n   HIST_TYPE_MAX\n };\n \n@@ -54,6 +55,7 @@ struct histogram_value_t\n     } hvalue;\n   enum hist_type type;\t\t\t/* Type of information to measure.  */\n   unsigned n_counters;\t\t\t/* Number of required counters.  */\n+  struct function *fun;\n   union\n     {\n       struct\n@@ -97,6 +99,8 @@ extern void gimple_gen_pow2_profiler (histogram_value, unsigned, unsigned);\n extern void gimple_gen_one_value_profiler (histogram_value, unsigned, unsigned);\n extern void gimple_gen_ic_profiler (histogram_value, unsigned, unsigned);\n extern void gimple_gen_ic_func_profiler (void);\n+extern void gimple_gen_time_profiler (unsigned, unsigned,\n+                                      gimple_stmt_iterator &);\n extern void gimple_gen_const_delta_profiler (histogram_value,\n \t\t\t\t\t     unsigned, unsigned);\n extern void gimple_gen_average_profiler (histogram_value, unsigned, unsigned);"}, {"sha": "0d91cfc2d91d452c0b67e6bfefdf17c772c4a1eb", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -858,7 +858,7 @@ LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \\\n     _gcov_execv _gcov_execvp _gcov_execve _gcov_reset _gcov_dump \\\n     _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \\\n     _gcov_indirect_call_profiler _gcov_average_profiler _gcov_ior_profiler \\\n-    _gcov_merge_ior _gcov_indirect_call_profiler_v2\n+    _gcov_merge_ior _gcov_time_profiler _gcov_indirect_call_profiler_v2 _gcov_merge_time_profile\n \n libgcov-objects = $(patsubst %,%$(objext),$(LIBGCOV))\n "}, {"sha": "6450fd7654867775fab7418c43b736ff66a721cc", "filename": "libgcc/libgcov.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ce5d2fc19438f92afcba1273153071eab48da4/libgcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ce5d2fc19438f92afcba1273153071eab48da4/libgcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.c?ref=86ce5d2fc19438f92afcba1273153071eab48da4", "patch": "@@ -80,6 +80,7 @@ void __gcov_merge_delta (gcov_type *counters  __attribute__ ((unused)),\n #include <sys/stat.h>\n #endif\n \n+extern gcov_type function_counter ATTRIBUTE_HIDDEN;\n extern void gcov_clear (void) ATTRIBUTE_HIDDEN;\n extern void gcov_exit (void) ATTRIBUTE_HIDDEN;\n extern int gcov_dump_complete ATTRIBUTE_HIDDEN;\n@@ -350,6 +351,10 @@ gcov_compute_histogram (struct gcov_summary *sum)\n     }\n }\n \n+\n+/* Counter for first visit of each function.  */\n+gcov_type function_counter;\n+\n /* Dump the coverage counts. We merge with existing counts when\n    possible, to avoid growing the .da files ad infinitum. We use this\n    program's checksum to make sure we only accumulate whole program\n@@ -974,6 +979,27 @@ __gcov_merge_ior (gcov_type *counters, unsigned n_counters)\n }\n #endif\n \n+/* Time profiles are merged so that minimum from all valid (greater than zero)\n+ * is stored. There could be a fork that creates new counters. To have\n+ * the profile stable, we chosen to pick the smallest function visit time.  */\n+\n+#ifdef L_gcov_merge_time_profile\n+void\n+__gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned int i;\n+  gcov_type value;\n+\n+  for (i = 0; i < n_counters; i++)\n+  {\n+    value = gcov_read_counter ();\n+\n+    if (value && (!counters[i] || value < counters[i]))\n+      counters[i] = value;\n+  }\n+}\n+#endif /* L_gcov_merge_time_profile */\n+\n #ifdef L_gcov_merge_single\n /* The profile merging function for choosing the most common value.\n    It is given an array COUNTERS of N_COUNTERS old counters and it\n@@ -1202,6 +1228,18 @@ __gcov_indirect_call_profiler_v2 (gcov_type value, void* cur_func)\n }\n #endif\n \n+#ifdef L_gcov_time_profiler\n+\n+/* Sets corresponding COUNTERS if there is no value.  */\n+\n+void\n+__gcov_time_profiler (gcov_type* counters)\n+{\n+  if (!counters[0])\n+    counters[0] = ++function_counter;\n+}\n+#endif\n+\n #ifdef L_gcov_average_profiler\n /* Increase corresponding COUNTER by VALUE.  FIXME: Perhaps we want\n    to saturate up.  */"}]}