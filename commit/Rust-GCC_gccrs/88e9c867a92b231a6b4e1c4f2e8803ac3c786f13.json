{"sha": "88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlOWM4NjdhOTJiMjMxYTZiNGUxYzRmMmU4ODAzYWMzYzc4NmYxMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-10-10T11:42:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-10T11:42:21Z"}, "message": "modulo-sched.c (ps_insn): Replace node field with an identifier.\n\ngcc/\n\t* modulo-sched.c (ps_insn): Replace node field with an identifier.\n\t(SCHED_ASAP): Replace with..\n\t(NODE_ASAP): ...this macro.\n\t(SCHED_PARAMS): New macro.\n\t(SCHED_TIME, SCHED_FIRST_REG_MOVE, SCHED_NREG_MOVES, SCHED_ROW)\n\t(SCHED_STAGE, SCHED_COLUMN): Redefine using SCHED_PARAMS.\n\t(node_sched_params): Remove asap.\n\t(ps_rtl_insn, ps_first_note): New functions.\n\t(set_node_sched_params): Use XCNEWVEC.  Don't copy across the\n\tasap values.\n\t(print_node_sched_params): Use SCHED_PARAMS and NODE_ASAP.\n\t(generate_reg_moves): Pass ids to the SCHED_* macros.\n\t(update_node_sched_params): Take a ps insn identifier rather than\n\ta node as parameter.  Use ps_rtl_insn.\n\t(set_columns_for_ps): Update for above field and SCHED_* macro changes.\n\t(permute_partial_schedule): Use ps_rtl_insn and ps_first_note.\n\t(optimize_sc): Update for above field and SCHED_* macro changes.\n\tUpdate calls to try_scheduling_node_in_cycle and\n\tupdate_node_sched_params.\n\t(duplicate_insns_of_cycles): Adjust for above field and SCHED_*\n\tmacro changes.  Use ps_rtl_insn and ps_first_note.\n\t(sms_schedule): Pass ids to the SCHED_* macros.\n\t(get_sched_window): Adjust for above field and SCHED_* macro changes.\n\tUse NODE_ASAP instead of SCHED_ASAP.\n\t(try_scheduling_node_in_cycle): Remove node parameter.  Update\n\tcall to ps_add_node_check_conflicts.  Pass ids to the SCHED_*\n\tmacros.\n\t(sms_schedule_by_order): Update call to try_scheduling_node_in_cycle.\n\t(ps_insert_empty_row): Adjust for above field changes.\n\t(compute_split_row): Use ids rather than nodes.\n\t(verify_partial_schedule): Adjust for above field changes.\n\t(print_partial_schedule): Use ps_rtl_insn.\n\t(create_ps_insn): Take an id rather than a node.\n\t(ps_insn_find_column): Adjust for above field changes.\n\tUse ps_rtl_insn.\n\t(ps_insn_advance_column): Adjust for above field changes.\n\t(add_node_to_ps): Remove node parameter.  Update call to\n\tcreate_ps_insn.\n\t(ps_has_conflicts): Use ps_rtl_insn.\n\t(ps_add_node_check_conflicts): Replace node parameter than an id.\n\nFrom-SVN: r179742", "tree": {"sha": "acd34de461c6576ea8ff405b599cc0412909dd90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acd34de461c6576ea8ff405b599cc0412909dd90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13/comments", "author": null, "committer": null, "parents": [{"sha": "be5af15f2de92c69a358b5dd8525cdef671439a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5af15f2de92c69a358b5dd8525cdef671439a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be5af15f2de92c69a358b5dd8525cdef671439a9"}], "stats": {"total": 338, "additions": 191, "deletions": 147}, "files": [{"sha": "aefd48148f4a47ddb326eeb7c8ffb59342103474", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "patch": "@@ -1,3 +1,46 @@\n+2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* modulo-sched.c (ps_insn): Replace node field with an identifier.\n+\t(SCHED_ASAP): Replace with..\n+\t(NODE_ASAP): ...this macro.\n+\t(SCHED_PARAMS): New macro.\n+\t(SCHED_TIME, SCHED_FIRST_REG_MOVE, SCHED_NREG_MOVES, SCHED_ROW)\n+\t(SCHED_STAGE, SCHED_COLUMN): Redefine using SCHED_PARAMS.\n+\t(node_sched_params): Remove asap.\n+\t(ps_rtl_insn, ps_first_note): New functions.\n+\t(set_node_sched_params): Use XCNEWVEC.  Don't copy across the\n+\tasap values.\n+\t(print_node_sched_params): Use SCHED_PARAMS and NODE_ASAP.\n+\t(generate_reg_moves): Pass ids to the SCHED_* macros.\n+\t(update_node_sched_params): Take a ps insn identifier rather than\n+\ta node as parameter.  Use ps_rtl_insn.\n+\t(set_columns_for_ps): Update for above field and SCHED_* macro changes.\n+\t(permute_partial_schedule): Use ps_rtl_insn and ps_first_note.\n+\t(optimize_sc): Update for above field and SCHED_* macro changes.\n+\tUpdate calls to try_scheduling_node_in_cycle and\n+\tupdate_node_sched_params.\n+\t(duplicate_insns_of_cycles): Adjust for above field and SCHED_*\n+\tmacro changes.  Use ps_rtl_insn and ps_first_note.\n+\t(sms_schedule): Pass ids to the SCHED_* macros.\n+\t(get_sched_window): Adjust for above field and SCHED_* macro changes.\n+\tUse NODE_ASAP instead of SCHED_ASAP.\n+\t(try_scheduling_node_in_cycle): Remove node parameter.  Update\n+\tcall to ps_add_node_check_conflicts.  Pass ids to the SCHED_*\n+\tmacros.\n+\t(sms_schedule_by_order): Update call to try_scheduling_node_in_cycle.\n+\t(ps_insert_empty_row): Adjust for above field changes.\n+\t(compute_split_row): Use ids rather than nodes.\n+\t(verify_partial_schedule): Adjust for above field changes.\n+\t(print_partial_schedule): Use ps_rtl_insn.\n+\t(create_ps_insn): Take an id rather than a node.\n+\t(ps_insn_find_column): Adjust for above field changes.\n+\tUse ps_rtl_insn.\n+\t(ps_insn_advance_column): Adjust for above field changes.\n+\t(add_node_to_ps): Remove node parameter.  Update call to\n+\tcreate_ps_insn.\n+\t(ps_has_conflicts): Use ps_rtl_insn.\n+\t(ps_add_node_check_conflicts): Replace node parameter than an id.\n+\n 2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* modulo-sched.c (undo_replace_buff_elem): Delete."}, {"sha": "9e0df2241414cfaad2dfd8da5358c1bb87099d3f", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 148, "deletions": 147, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "patch": "@@ -124,8 +124,8 @@ typedef struct ps_insn *ps_insn_ptr;\n /* A single instruction in the partial schedule.  */\n struct ps_insn\n {\n-  /* The corresponding DDG_NODE.  */\n-  ddg_node_ptr node;\n+  /* The number of the ddg node whose instruction is being scheduled.  */\n+  int id;\n \n   /* The (absolute) cycle in which the PS instruction is scheduled.\n      Same as SCHED_TIME (node).  */\n@@ -172,9 +172,7 @@ static void reset_partial_schedule (partial_schedule_ptr, int new_ii);\n void print_partial_schedule (partial_schedule_ptr, FILE *);\n static void verify_partial_schedule (partial_schedule_ptr, sbitmap);\n static ps_insn_ptr ps_add_node_check_conflicts (partial_schedule_ptr,\n-\t\t\t\t\t\tddg_node_ptr node, int cycle,\n-\t\t\t\t\t\tsbitmap must_precede,\n-\t\t\t\t\t\tsbitmap must_follow);\n+\t\t\t\t\t\tint, int, sbitmap, sbitmap);\n static void rotate_partial_schedule (partial_schedule_ptr, int);\n void set_row_column_for_ps (partial_schedule_ptr);\n static void ps_insert_empty_row (partial_schedule_ptr, int, sbitmap);\n@@ -197,26 +195,24 @@ static void calculate_must_precede_follow (ddg_node_ptr, int, int,\n \t\t\t\t\t   int, int, sbitmap, sbitmap, sbitmap);\n static int get_sched_window (partial_schedule_ptr, ddg_node_ptr, \n \t\t\t     sbitmap, int, int *, int *, int *);\n-static bool try_scheduling_node_in_cycle (partial_schedule_ptr, ddg_node_ptr,\n-\t\t\t\t\t  int, int, sbitmap, int *, sbitmap,\n-\t\t\t\t\t  sbitmap);\n+static bool try_scheduling_node_in_cycle (partial_schedule_ptr, int, int,\n+\t\t\t\t\t  sbitmap, int *, sbitmap, sbitmap);\n static void remove_node_from_ps (partial_schedule_ptr, ps_insn_ptr);\n \n-#define SCHED_ASAP(x) (((node_sched_params_ptr)(x)->aux.info)->asap)\n-#define SCHED_TIME(x) (((node_sched_params_ptr)(x)->aux.info)->time)\n-#define SCHED_FIRST_REG_MOVE(x) \\\n-\t(((node_sched_params_ptr)(x)->aux.info)->first_reg_move)\n-#define SCHED_NREG_MOVES(x) \\\n-\t(((node_sched_params_ptr)(x)->aux.info)->nreg_moves)\n-#define SCHED_ROW(x) (((node_sched_params_ptr)(x)->aux.info)->row)\n-#define SCHED_STAGE(x) (((node_sched_params_ptr)(x)->aux.info)->stage)\n-#define SCHED_COLUMN(x) (((node_sched_params_ptr)(x)->aux.info)->column)\n+#define NODE_ASAP(node) ((node)->aux.count)\n+\n+#define SCHED_PARAMS(x) (&node_sched_params[x])\n+#define SCHED_TIME(x) (SCHED_PARAMS (x)->time)\n+#define SCHED_FIRST_REG_MOVE(x) (SCHED_PARAMS (x)->first_reg_move)\n+#define SCHED_NREG_MOVES(x) (SCHED_PARAMS (x)->nreg_moves)\n+#define SCHED_ROW(x) (SCHED_PARAMS (x)->row)\n+#define SCHED_STAGE(x) (SCHED_PARAMS (x)->stage)\n+#define SCHED_COLUMN(x) (SCHED_PARAMS (x)->column)\n \n /* The scheduling parameters held for each node.  */\n typedef struct node_sched_params\n {\n-  int asap;\t/* A lower-bound on the absolute scheduling cycle.  */\n-  int time;\t/* The absolute scheduling cycle (time >= asap).  */\n+  int time;\t/* The absolute scheduling cycle.  */\n \n   /* The following field (first_reg_move) is a pointer to the first\n      register-move instruction added to handle the modulo-variable-expansion\n@@ -284,6 +280,23 @@ static struct haifa_sched_info sms_sched_info =\n   0\n };\n \n+/* Return the rtl instruction that is being scheduled by partial schedule\n+   instruction ID, which belongs to schedule PS.  */\n+static rtx\n+ps_rtl_insn (partial_schedule_ptr ps, int id)\n+{\n+  return ps->g->nodes[id].insn;\n+}\n+\n+/* Return the first instruction in the original (unscheduled) loop that\n+   was associated with ps_rtl_insn (PS, ID).  If the instruction had\n+   some notes before it, this is the first of those notes.  */\n+static rtx\n+ps_first_note (partial_schedule_ptr ps, int id)\n+{\n+  return ps->g->nodes[id].first_note;\n+}\n+\n /* Given HEAD and TAIL which are the first and last insns in a loop;\n    return the register which controls the loop.  Return zero if it has\n    more than one occurrence in the loop besides the control part or the\n@@ -387,28 +400,11 @@ res_MII (ddg_ptr g)\n /* Points to the array that contains the sched data for each node.  */\n static node_sched_params_ptr node_sched_params;\n \n-/* Allocate sched_params for each node and initialize it.  Assumes that\n-   the aux field of each node contain the asap bound (computed earlier),\n-   and copies it into the sched_params field.  */\n+/* Allocate sched_params for each node and initialize it.  */\n static void\n set_node_sched_params (ddg_ptr g)\n {\n-  int i;\n-\n-  /* Allocate for each node in the DDG a place to hold the \"sched_data\".  */\n-  /* Initialize ASAP/ALAP/HIGHT to zero.  */\n-  node_sched_params = (node_sched_params_ptr)\n-\t\t       xcalloc (g->num_nodes,\n-\t\t\t\tsizeof (struct node_sched_params));\n-\n-  /* Set the pointer of the general data of the node to point to the\n-     appropriate sched_params structure.  */\n-  for (i = 0; i < g->num_nodes; i++)\n-    {\n-      /* Watch out for aliasing problems?  */\n-      node_sched_params[i].asap = g->nodes[i].aux.count;\n-      g->nodes[i].aux.info = &node_sched_params[i];\n-    }\n+  node_sched_params = XCNEWVEC (struct node_sched_params, g->num_nodes);\n }\n \n static void\n@@ -420,13 +416,13 @@ print_node_sched_params (FILE *file, int num_nodes, ddg_ptr g)\n     return;\n   for (i = 0; i < num_nodes; i++)\n     {\n-      node_sched_params_ptr nsp = &node_sched_params[i];\n+      node_sched_params_ptr nsp = SCHED_PARAMS (i);\n       rtx reg_move = nsp->first_reg_move;\n       int j;\n \n       fprintf (file, \"Node = %d; INSN = %d\\n\", i,\n \t       (INSN_UID (g->nodes[i].insn)));\n-      fprintf (file, \" asap = %d:\\n\", nsp->asap);\n+      fprintf (file, \" asap = %d:\\n\", NODE_ASAP (&g->nodes[i]));\n       fprintf (file, \" time = %d:\\n\", nsp->time);\n       fprintf (file, \" nreg_moves = %d:\\n\", nsp->nreg_moves);\n       for (j = 0; j < nsp->nreg_moves; j++)\n@@ -475,15 +471,17 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n       for (e = u->out; e; e = e->next_out)\n \tif (e->type == TRUE_DEP && e->dest != e->src)\n \t  {\n-\t    int nreg_moves4e = (SCHED_TIME (e->dest) - SCHED_TIME (e->src)) / ii;\n+\t    int nreg_moves4e = (SCHED_TIME (e->dest->cuid)\n+\t\t\t\t- SCHED_TIME (e->src->cuid)) / ii;\n \n             if (e->distance == 1)\n-              nreg_moves4e = (SCHED_TIME (e->dest) - SCHED_TIME (e->src) + ii) / ii;\n+              nreg_moves4e = (SCHED_TIME (e->dest->cuid)\n+\t\t\t      - SCHED_TIME (e->src->cuid) + ii) / ii;\n \n \t    /* If dest precedes src in the schedule of the kernel, then dest\n \t       will read before src writes and we can save one reg_copy.  */\n-\t    if (SCHED_ROW (e->dest) == SCHED_ROW (e->src)\n-\t\t&& SCHED_COLUMN (e->dest) < SCHED_COLUMN (e->src))\n+\t    if (SCHED_ROW (e->dest->cuid) == SCHED_ROW (e->src->cuid)\n+\t\t&& SCHED_COLUMN (e->dest->cuid) < SCHED_COLUMN (e->src->cuid))\n \t      nreg_moves4e--;\n \n             if (nreg_moves4e >= 1)\n@@ -515,21 +513,23 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n       for (e = u->out; e; e = e->next_out)\n \tif (e->type == TRUE_DEP && e->dest != e->src)\n \t  {\n-\t    int dest_copy = (SCHED_TIME (e->dest) - SCHED_TIME (e->src)) / ii;\n+\t    int dest_copy = (SCHED_TIME (e->dest->cuid)\n+\t\t\t     - SCHED_TIME (e->src->cuid)) / ii;\n \n \t    if (e->distance == 1)\n-\t      dest_copy = (SCHED_TIME (e->dest) - SCHED_TIME (e->src) + ii) / ii;\n+\t      dest_copy = (SCHED_TIME (e->dest->cuid)\n+\t\t\t   - SCHED_TIME (e->src->cuid) + ii) / ii;\n \n-\t    if (SCHED_ROW (e->dest) == SCHED_ROW (e->src)\n-\t\t&& SCHED_COLUMN (e->dest) < SCHED_COLUMN (e->src))\n+\t    if (SCHED_ROW (e->dest->cuid) == SCHED_ROW (e->src->cuid)\n+\t\t&& SCHED_COLUMN (e->dest->cuid) < SCHED_COLUMN (e->src->cuid))\n \t      dest_copy--;\n \n \t    if (dest_copy)\n \t      SET_BIT (uses_of_defs[dest_copy - 1], e->dest->cuid);\n \t  }\n \n       /* Now generate the reg_moves, attaching relevant uses to them.  */\n-      SCHED_NREG_MOVES (u) = nreg_moves;\n+      SCHED_NREG_MOVES (i) = nreg_moves;\n       old_reg = prev_reg = copy_rtx (SET_DEST (single_set (u->insn)));\n       /* Insert the reg-moves right before the notes which precede\n          the insn they relates to.  */\n@@ -545,8 +545,8 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n \t  add_insn_before (reg_move, last_reg_move, NULL);\n \t  last_reg_move = reg_move;\n \n-\t  if (!SCHED_FIRST_REG_MOVE (u))\n-\t    SCHED_FIRST_REG_MOVE (u) = reg_move;\n+\t  if (!SCHED_FIRST_REG_MOVE (i))\n+\t    SCHED_FIRST_REG_MOVE (i) = reg_move;\n \n \t  EXECUTE_IF_SET_IN_SBITMAP (uses_of_defs[i_reg_move], 0, i_use, sbi)\n \t    {\n@@ -567,7 +567,7 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n    SCHED_STAGE (u) = CALC_STAGE_COUNT (SCHED_TIME (u), min_cycle, ii);\n    because the stages may not be aligned on cycle 0.  */\n static void\n-update_node_sched_params (ddg_node_ptr u, int ii, int cycle, int min_cycle)\n+update_node_sched_params (int u, int ii, int cycle, int min_cycle)\n {\n   int sc_until_cycle_zero;\n   int stage;\n@@ -604,18 +604,19 @@ reset_sched_times (partial_schedule_ptr ps, int amount)\n   for (row = 0; row < ii; row++)\n     for (crr_insn = ps->rows[row]; crr_insn; crr_insn = crr_insn->next_in_row)\n       {\n-\tddg_node_ptr u = crr_insn->node;\n+\tint u = crr_insn->id;\n \tint normalized_time = SCHED_TIME (u) - amount;\n \tint new_min_cycle = PS_MIN_CYCLE (ps) - amount;\n \n         if (dump_file)\n           {\n             /* Print the scheduling times after the rotation.  */\n+\t    rtx insn = ps_rtl_insn (ps, u);\n+\n             fprintf (dump_file, \"crr_insn->node=%d (insn id %d), \"\n-                     \"crr_insn->cycle=%d, min_cycle=%d\", crr_insn->node->cuid,\n-                     INSN_UID (crr_insn->node->insn), normalized_time,\n-                     new_min_cycle);\n-            if (JUMP_P (crr_insn->node->insn))\n+                     \"crr_insn->cycle=%d, min_cycle=%d\", u,\n+                     INSN_UID (insn), normalized_time, new_min_cycle);\n+            if (JUMP_P (insn))\n               fprintf (dump_file, \" (branch)\");\n             fprintf (dump_file, \"\\n\");\n           }\n@@ -640,7 +641,7 @@ set_columns_for_ps (partial_schedule_ptr ps)\n       int column = 0;\n \n       for (; cur_insn; cur_insn = cur_insn->next_in_row)\n-\tSCHED_COLUMN (cur_insn->node) = column++;\n+\tSCHED_COLUMN (cur_insn->id) = column++;\n     }\n }\n \n@@ -656,9 +657,13 @@ permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n \n   for (row = 0; row < ii ; row++)\n     for (ps_ij = ps->rows[row]; ps_ij; ps_ij = ps_ij->next_in_row)\n-      if (PREV_INSN (last) != ps_ij->node->insn)\n-      \treorder_insns_nobb (ps_ij->node->first_note, ps_ij->node->insn,\n-\t\t\t    PREV_INSN (last));\n+      {\n+\trtx insn = ps_rtl_insn (ps, ps_ij->id);\n+\n+\tif (PREV_INSN (last) != insn)\n+\t  reorder_insns_nobb (ps_first_note (ps, ps_ij->id), insn,\n+\t\t\t      PREV_INSN (last));\n+      }\n }\n \n /* Set bitmaps TMP_FOLLOW and TMP_PRECEDE to MUST_FOLLOW and MUST_PRECEDE\n@@ -707,7 +712,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n      to row ii-1.  If they are equal just bail out.  */\n   stage_count = calculate_stage_count (ps, amount);\n   stage_count_curr =\n-    calculate_stage_count (ps, SCHED_TIME (g->closing_branch) - (ii - 1));\n+    calculate_stage_count (ps, SCHED_TIME (g->closing_branch->cuid) - (ii - 1));\n \n   if (stage_count == stage_count_curr)\n     {\n@@ -736,7 +741,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n       print_partial_schedule (ps, dump_file);\n     }\n \n-  if (SMODULO (SCHED_TIME (g->closing_branch), ii) == ii - 1)\n+  if (SMODULO (SCHED_TIME (g->closing_branch->cuid), ii) == ii - 1)\n     {\n       ok = true;\n       goto clear;\n@@ -751,7 +756,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n     {\n       bool success;\n       ps_insn_ptr next_ps_i;\n-      int branch_cycle = SCHED_TIME (g->closing_branch);\n+      int branch_cycle = SCHED_TIME (g->closing_branch->cuid);\n       int row = SMODULO (branch_cycle, ps->ii);\n       int num_splits = 0;\n       sbitmap must_precede, must_follow, tmp_precede, tmp_follow;\n@@ -807,13 +812,12 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n          branch so we can remove it from it's current cycle.  */\n       for (next_ps_i = ps->rows[row];\n \t   next_ps_i; next_ps_i = next_ps_i->next_in_row)\n-\tif (next_ps_i->node->cuid == g->closing_branch->cuid)\n+\tif (next_ps_i->id == g->closing_branch->cuid)\n \t  break;\n \n       remove_node_from_ps (ps, next_ps_i);\n       success =\n-\ttry_scheduling_node_in_cycle (ps, g->closing_branch,\n-\t\t\t\t      g->closing_branch->cuid, c,\n+\ttry_scheduling_node_in_cycle (ps, g->closing_branch->cuid, c,\n \t\t\t\t      sched_nodes, &num_splits,\n \t\t\t\t      tmp_precede, tmp_follow);\n       gcc_assert (num_splits == 0);\n@@ -831,8 +835,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n \t\t\t\t   must_precede, branch_cycle, start, end,\n \t\t\t\t   step);\n \t  success =\n-\t    try_scheduling_node_in_cycle (ps, g->closing_branch,\n-\t\t\t\t\t  g->closing_branch->cuid,\n+\t    try_scheduling_node_in_cycle (ps, g->closing_branch->cuid,\n \t\t\t\t\t  branch_cycle, sched_nodes,\n \t\t\t\t\t  &num_splits, tmp_precede,\n \t\t\t\t\t  tmp_follow);\n@@ -846,7 +849,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n \t    fprintf (dump_file,\n \t\t     \"SMS success in moving branch to cycle %d\\n\", c);\n \n-\t  update_node_sched_params (g->closing_branch, ii, c,\n+\t  update_node_sched_params (g->closing_branch->cuid, ii, c,\n \t\t\t\t    PS_MIN_CYCLE (ps));\n \t  ok = true;\n \t}\n@@ -870,62 +873,64 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n   for (row = 0; row < ps->ii; row++)\n     for (ps_ij = ps->rows[row]; ps_ij; ps_ij = ps_ij->next_in_row)\n       {\n-\tddg_node_ptr u_node = ps_ij->node;\n+\tint u = ps_ij->id;\n \tint j, i_reg_moves;\n \trtx reg_move = NULL_RTX;\n+\trtx u_insn;\n \n         /* Do not duplicate any insn which refers to count_reg as it\n            belongs to the control part.\n            The closing branch is scheduled as well and thus should\n            be ignored.\n            TODO: This should be done by analyzing the control part of\n            the loop.  */\n-        if (reg_mentioned_p (count_reg, u_node->insn)\n-            || JUMP_P (ps_ij->node->insn))\n+\tu_insn = ps_rtl_insn (ps, u);\n+        if (reg_mentioned_p (count_reg, u_insn)\n+            || JUMP_P (u_insn))\n           continue;\n \n \tif (for_prolog)\n \t  {\n-\t    /* SCHED_STAGE (u_node) >= from_stage == 0.  Generate increasing\n+\t    /* SCHED_STAGE (u) >= from_stage == 0.  Generate increasing\n \t       number of reg_moves starting with the second occurrence of\n-\t       u_node, which is generated if its SCHED_STAGE <= to_stage.  */\n-\t    i_reg_moves = to_stage - SCHED_STAGE (u_node) + 1;\n+\t       u, which is generated if its SCHED_STAGE <= to_stage.  */\n+\t    i_reg_moves = to_stage - SCHED_STAGE (u) + 1;\n \t    i_reg_moves = MAX (i_reg_moves, 0);\n-\t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u_node));\n+\t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u));\n \n \t    /* The reg_moves start from the *first* reg_move backwards.  */\n \t    if (i_reg_moves)\n \t      {\n-\t\treg_move = SCHED_FIRST_REG_MOVE (u_node);\n+\t\treg_move = SCHED_FIRST_REG_MOVE (u);\n \t\tfor (j = 1; j < i_reg_moves; j++)\n \t\t  reg_move = PREV_INSN (reg_move);\n \t      }\n \t  }\n \telse /* It's for the epilog.  */\n \t  {\n-\t    /* SCHED_STAGE (u_node) <= to_stage.  Generate all reg_moves,\n-\t       starting to decrease one stage after u_node no longer occurs;\n+\t    /* SCHED_STAGE (u) <= to_stage.  Generate all reg_moves,\n+\t       starting to decrease one stage after u no longer occurs;\n \t       that is, generate all reg_moves until\n-\t       SCHED_STAGE (u_node) == from_stage - 1.  */\n-\t    i_reg_moves = SCHED_NREG_MOVES (u_node)\n-\t    \t       - (from_stage - SCHED_STAGE (u_node) - 1);\n+\t       SCHED_STAGE (u) == from_stage - 1.  */\n+\t    i_reg_moves = (SCHED_NREG_MOVES (u)\n+\t\t\t   - (from_stage - SCHED_STAGE (u) - 1));\n \t    i_reg_moves = MAX (i_reg_moves, 0);\n-\t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u_node));\n+\t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u));\n \n \t    /* The reg_moves start from the *last* reg_move forwards.  */\n \t    if (i_reg_moves)\n \t      {\n-\t\treg_move = SCHED_FIRST_REG_MOVE (u_node);\n-\t\tfor (j = 1; j < SCHED_NREG_MOVES (u_node); j++)\n+\t\treg_move = SCHED_FIRST_REG_MOVE (u);\n+\t\tfor (j = 1; j < SCHED_NREG_MOVES (u); j++)\n \t\t  reg_move = PREV_INSN (reg_move);\n \t      }\n \t  }\n \n \tfor (j = 0; j < i_reg_moves; j++, reg_move = NEXT_INSN (reg_move))\n \t  emit_insn (copy_rtx (PATTERN (reg_move)));\n-\tif (SCHED_STAGE (u_node) >= from_stage\n-\t    && SCHED_STAGE (u_node) <= to_stage)\n-\t  duplicate_insn_chain (u_node->first_note, u_node->insn);\n+\tif (SCHED_STAGE (u) >= from_stage\n+\t    && SCHED_STAGE (u) <= to_stage)\n+\t  duplicate_insn_chain (ps_first_note (ps, u), u_insn);\n       }\n }\n \n@@ -1387,8 +1392,6 @@ sms_schedule (void)\n \tfprintf (dump_file, \"SMS iis %d %d %d (rec_mii, mii, maxii)\\n\",\n \t\t rec_mii, mii, maxii);\n \n-      /* After sms_order_nodes and before sms_schedule_by_order, to copy over\n-\t ASAP.  */\n       set_node_sched_params (g);\n \n       ps = sms_schedule_by_order (g, mii, maxii, node_order);\n@@ -1406,7 +1409,7 @@ sms_schedule (void)\n \t  else\n \t    {\n \t      /* Bring the branch to cycle ii-1.  */\n-\t      int amount = SCHED_TIME (g->closing_branch) - (ps->ii - 1);\n+\t      int amount = SCHED_TIME (g->closing_branch->cuid) - (ps->ii - 1);\n \t      \n \t      if (dump_file)\n \t\tfprintf (dump_file, \"SMS schedule branch at cycle ii-1\\n\");\n@@ -1440,7 +1443,7 @@ sms_schedule (void)\n           if (!opt_sc_p)\n             {\n \t      /* Rotate the partial schedule to have the branch in row ii-1.  */\n-              int amount = SCHED_TIME (g->closing_branch) - (ps->ii - 1);\n+              int amount = SCHED_TIME (g->closing_branch->cuid) - (ps->ii - 1);\n \t      \n               reset_sched_times (ps, amount);\n               rotate_partial_schedule (ps, amount);\n@@ -1641,11 +1644,11 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   if (psp_not_empty)\n     for (e = u_node->in; e != 0; e = e->next_in)\n       {\n-\tddg_node_ptr v_node = e->src;\n+\tint v = e->src->cuid;\n \n-\tif (TEST_BIT (sched_nodes, v_node->cuid))\n+\tif (TEST_BIT (sched_nodes, v))\n \t  {\n-\t    int p_st = SCHED_TIME (v_node);\n+\t    int p_st = SCHED_TIME (v);\n \t    int earliest = p_st + e->latency - (e->distance * ii);\n \t    int latest = (e->data_type == MEM_DEP ? p_st + ii - 1 : INT_MAX);\n \n@@ -1669,11 +1672,11 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   if (pss_not_empty)\n     for (e = u_node->out; e != 0; e = e->next_out)\n       {\n-\tddg_node_ptr v_node = e->dest;\n+\tint v = e->dest->cuid;\n \n-\tif (TEST_BIT (sched_nodes, v_node->cuid))\n+\tif (TEST_BIT (sched_nodes, v))\n \t  {\n-\t    int s_st = SCHED_TIME (v_node);\n+\t    int s_st = SCHED_TIME (v);\n \t    int earliest = (e->data_type == MEM_DEP ? s_st - ii + 1 : INT_MIN);\n \t    int latest = s_st - e->latency + (e->distance * ii);\n \n@@ -1704,7 +1707,7 @@ get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n \n   /* Get a target scheduling window no bigger than ii.  */\n   if (early_start == INT_MIN && late_start == INT_MAX)\n-    early_start = SCHED_ASAP (u_node);\n+    early_start = NODE_ASAP (u_node);\n   else if (early_start == INT_MIN)\n     early_start = late_start - (ii - 1);\n   late_start = MIN (late_start, early_start + (ii - 1));\n@@ -1801,7 +1804,7 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n       SCHED_TIME (e->src) - (e->distance * ii) == first_cycle_in_window  */\n   for (e = u_node->in; e != 0; e = e->next_in)\n     if (TEST_BIT (sched_nodes, e->src->cuid)\n-\t&& ((SCHED_TIME (e->src) - (e->distance * ii)) ==\n+\t&& ((SCHED_TIME (e->src->cuid) - (e->distance * ii)) ==\n              first_cycle_in_window))\n       {\n \tif (dump_file)\n@@ -1826,7 +1829,7 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n       SCHED_TIME (e->dest) + (e->distance * ii) == last_cycle_in_window  */\n   for (e = u_node->out; e != 0; e = e->next_out)\n     if (TEST_BIT (sched_nodes, e->dest->cuid)\n-\t&& ((SCHED_TIME (e->dest) + (e->distance * ii)) ==\n+\t&& ((SCHED_TIME (e->dest->cuid) + (e->distance * ii)) ==\n              last_cycle_in_window))\n       {\n \tif (dump_file)\n@@ -1850,7 +1853,7 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n    last row of the scheduling window)  */\n \n static bool\n-try_scheduling_node_in_cycle (partial_schedule_ptr ps, ddg_node_ptr u_node,\n+try_scheduling_node_in_cycle (partial_schedule_ptr ps,\n \t\t\t      int u, int cycle, sbitmap sched_nodes,\n \t\t\t      int *num_splits, sbitmap must_precede,\n \t\t\t      sbitmap must_follow)\n@@ -1859,11 +1862,10 @@ try_scheduling_node_in_cycle (partial_schedule_ptr ps, ddg_node_ptr u_node,\n   bool success = 0;\n \n   verify_partial_schedule (ps, sched_nodes);\n-  psi = ps_add_node_check_conflicts (ps, u_node, cycle,\n-\t\t\t\t     must_precede, must_follow);\n+  psi = ps_add_node_check_conflicts (ps, u, cycle, must_precede, must_follow);\n   if (psi)\n     {\n-      SCHED_TIME (u_node) = cycle;\n+      SCHED_TIME (u) = cycle;\n       SET_BIT (sched_nodes, u);\n       success = 1;\n       *num_splits = 0;\n@@ -1943,7 +1945,7 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \t\t                           &tmp_precede, must_precede, \n                                            c, start, end, step);\n                   success =\n-                    try_scheduling_node_in_cycle (ps, u_node, u, c,\n+                    try_scheduling_node_in_cycle (ps, u, c,\n                                                   sched_nodes,\n                                                   &num_splits, tmp_precede,\n                                                   tmp_follow);\n@@ -2043,7 +2045,7 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n       for (crr_insn = rows_new[row];\n \t   crr_insn; crr_insn = crr_insn->next_in_row)\n \t{\n-\t  ddg_node_ptr u = crr_insn->node;\n+\t  int u = crr_insn->id;\n \t  int new_time = SCHED_TIME (u) + (SCHED_TIME (u) / ii);\n \n \t  SCHED_TIME (u) = new_time;\n@@ -2064,7 +2066,7 @@ ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n       for (crr_insn = rows_new[row + 1];\n \t   crr_insn; crr_insn = crr_insn->next_in_row)\n \t{\n-\t  ddg_node_ptr u = crr_insn->node;\n+\t  int u = crr_insn->id;\n \t  int new_time = SCHED_TIME (u) + (SCHED_TIME (u) / ii) + 1;\n \n \t  SCHED_TIME (u) = new_time;\n@@ -2104,42 +2106,43 @@ compute_split_row (sbitmap sched_nodes, int low, int up, int ii,\n {\n   ddg_edge_ptr e;\n   int lower = INT_MIN, upper = INT_MAX;\n-  ddg_node_ptr crit_pred = NULL;\n-  ddg_node_ptr crit_succ = NULL;\n+  int crit_pred = -1;\n+  int crit_succ = -1;\n   int crit_cycle;\n \n   for (e = u_node->in; e != 0; e = e->next_in)\n     {\n-      ddg_node_ptr v_node = e->src;\n+      int v = e->src->cuid;\n \n-      if (TEST_BIT (sched_nodes, v_node->cuid)\n-\t  && (low == SCHED_TIME (v_node) + e->latency - (e->distance * ii)))\n-\tif (SCHED_TIME (v_node) > lower)\n+      if (TEST_BIT (sched_nodes, v)\n+\t  && (low == SCHED_TIME (v) + e->latency - (e->distance * ii)))\n+\tif (SCHED_TIME (v) > lower)\n \t  {\n-\t    crit_pred = v_node;\n-\t    lower = SCHED_TIME (v_node);\n+\t    crit_pred = v;\n+\t    lower = SCHED_TIME (v);\n \t  }\n     }\n \n-  if (crit_pred != NULL)\n+  if (crit_pred >= 0)\n     {\n       crit_cycle = SCHED_TIME (crit_pred) + 1;\n       return SMODULO (crit_cycle, ii);\n     }\n \n   for (e = u_node->out; e != 0; e = e->next_out)\n     {\n-      ddg_node_ptr v_node = e->dest;\n-      if (TEST_BIT (sched_nodes, v_node->cuid)\n-\t  && (up == SCHED_TIME (v_node) - e->latency + (e->distance * ii)))\n-\tif (SCHED_TIME (v_node) < upper)\n+      int v = e->dest->cuid;\n+\n+      if (TEST_BIT (sched_nodes, v)\n+\t  && (up == SCHED_TIME (v) - e->latency + (e->distance * ii)))\n+\tif (SCHED_TIME (v) < upper)\n \t  {\n-\t    crit_succ = v_node;\n-\t    upper = SCHED_TIME (v_node);\n+\t    crit_succ = v;\n+\t    upper = SCHED_TIME (v);\n \t  }\n     }\n \n-  if (crit_succ != NULL)\n+  if (crit_succ >= 0)\n     {\n       crit_cycle = SCHED_TIME (crit_succ);\n       return SMODULO (crit_cycle, ii);\n@@ -2163,10 +2166,10 @@ verify_partial_schedule (partial_schedule_ptr ps, sbitmap sched_nodes)\n       \n       for (crr_insn = ps->rows[row]; crr_insn; crr_insn = crr_insn->next_in_row)\n \t{\n-\t  ddg_node_ptr u = crr_insn->node;\n+\t  int u = crr_insn->id;\n \t  \n \t  length++;\n-\t  gcc_assert (TEST_BIT (sched_nodes, u->cuid));\n+\t  gcc_assert (TEST_BIT (sched_nodes, u));\n \t  /* ??? Test also that all nodes of sched_nodes are in ps, perhaps by\n \t     popcount (sched_nodes) == number of insns in ps.  */\n \t  gcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n@@ -2658,12 +2661,12 @@ print_partial_schedule (partial_schedule_ptr ps, FILE *dump)\n       fprintf (dump, \"\\n[ROW %d ]: \", i);\n       while (ps_i)\n \t{\n-\t  if (JUMP_P (ps_i->node->insn))\n-\t    fprintf (dump, \"%d (branch), \",\n-\t\t     INSN_UID (ps_i->node->insn));\n+\t  rtx insn = ps_rtl_insn (ps, ps_i->id);\n+\n+\t  if (JUMP_P (insn))\n+\t    fprintf (dump, \"%d (branch), \", INSN_UID (insn));\n \t  else\n-\t    fprintf (dump, \"%d, \",\n-\t\t     INSN_UID (ps_i->node->insn));\n+\t    fprintf (dump, \"%d, \", INSN_UID (insn));\n \t\n \t  ps_i = ps_i->next_in_row;\n \t}\n@@ -2672,11 +2675,11 @@ print_partial_schedule (partial_schedule_ptr ps, FILE *dump)\n \n /* Creates an object of PS_INSN and initializes it to the given parameters.  */\n static ps_insn_ptr\n-create_ps_insn (ddg_node_ptr node, int cycle)\n+create_ps_insn (int id, int cycle)\n {\n   ps_insn_ptr ps_i = XNEW (struct ps_insn);\n \n-  ps_i->node = node;\n+  ps_i->id = id;\n   ps_i->next_in_row = NULL;\n   ps_i->prev_in_row = NULL;\n   ps_i->cycle = cycle;\n@@ -2741,10 +2744,11 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n        next_ps_i;\n        next_ps_i = next_ps_i->next_in_row)\n     {\n-      if (must_follow && TEST_BIT (must_follow, next_ps_i->node->cuid)\n+      if (must_follow\n+\t  && TEST_BIT (must_follow, next_ps_i->id)\n \t  && ! first_must_follow)\n         first_must_follow = next_ps_i;\n-      if (must_precede && TEST_BIT (must_precede, next_ps_i->node->cuid))\n+      if (must_precede && TEST_BIT (must_precede, next_ps_i->id))\n         {\n           /* If we have already met a node that must follow, then\n \t     there is no possible column.  */\n@@ -2755,8 +2759,8 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n         }\n       /* The closing branch must be the last in the row.  */\n       if (must_precede \n-\t  && TEST_BIT (must_precede, next_ps_i->node->cuid) \n-\t  && JUMP_P (next_ps_i->node->insn))     \n+\t  && TEST_BIT (must_precede, next_ps_i->id)\n+\t  && JUMP_P (ps_rtl_insn (ps, next_ps_i->id)))\n \treturn false;\n              \n        last_in_row = next_ps_i;\n@@ -2765,7 +2769,7 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n   /* The closing branch is scheduled as well.  Make sure there is no\n      dependent instruction after it as the branch should be the last\n      instruction in the row.  */\n-  if (JUMP_P (ps_i->node->insn)) \n+  if (JUMP_P (ps_rtl_insn (ps, ps_i->id)))\n     {\n       if (first_must_follow)\n \treturn false;\n@@ -2816,7 +2820,6 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n {\n   ps_insn_ptr prev, next;\n   int row;\n-  ddg_node_ptr next_node;\n \n   if (!ps || !ps_i)\n     return false;\n@@ -2826,11 +2829,9 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n   if (! ps_i->next_in_row)\n     return false;\n \n-  next_node = ps_i->next_in_row->node;\n-\n   /* Check if next_in_row is dependent on ps_i, both having same sched\n      times (typically ANTI_DEP).  If so, ps_i cannot skip over it.  */\n-  if (must_follow && TEST_BIT (must_follow, next_node->cuid))\n+  if (must_follow && TEST_BIT (must_follow, ps_i->next_in_row->id))\n     return false;\n \n   /* Advance PS_I over its next_in_row in the doubly linked list.  */\n@@ -2861,7 +2862,7 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n    before/after (respectively) the node pointed to by PS_I when scheduled\n    in the same cycle.  */\n static ps_insn_ptr\n-add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle,\n+add_node_to_ps (partial_schedule_ptr ps, int id, int cycle,\n \t\tsbitmap must_precede, sbitmap must_follow)\n {\n   ps_insn_ptr ps_i;\n@@ -2870,7 +2871,7 @@ add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle,\n   if (ps->rows_length[row] >= issue_rate)\n     return NULL;\n \n-  ps_i = create_ps_insn (node, cycle);\n+  ps_i = create_ps_insn (id, cycle);\n \n   /* Finds and inserts PS_I according to MUST_FOLLOW and\n      MUST_PRECEDE.  */\n@@ -2922,7 +2923,7 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n \t   crr_insn;\n \t   crr_insn = crr_insn->next_in_row)\n \t{\n-\t  rtx insn = crr_insn->node->insn;\n+\t  rtx insn = ps_rtl_insn (ps, crr_insn->id);\n \n \t  if (!NONDEBUG_INSN_P (insn))\n \t    continue;\n@@ -2959,7 +2960,7 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n    cuid N must be come before/after (respectively) the node pointed to by\n    PS_I when scheduled in the same cycle.  */\n ps_insn_ptr\n-ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n,\n+ps_add_node_check_conflicts (partial_schedule_ptr ps, int n,\n    \t\t\t     int c, sbitmap must_precede,\n \t\t\t     sbitmap must_follow)\n {"}]}