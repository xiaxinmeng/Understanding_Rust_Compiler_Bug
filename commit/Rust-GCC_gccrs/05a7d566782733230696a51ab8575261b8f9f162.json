{"sha": "05a7d566782733230696a51ab8575261b8f9f162", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVhN2Q1NjY3ODI3MzMyMzA2OTZhNTFhYjg1NzUyNjFiOGY5ZjE2Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-09-03T21:52:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-09-03T21:52:37Z"}, "message": "compiler, runtime: Use runtime functions to pass closure value.\n\nThis changes the compiler and runtime to not pass a closure\nvalue as the last argument, but to instead pass it via\n__go_set_closure and retrieve it via __go_get_closure.  This\neliminates the need for function descriptor wrapper functions.\nIt will make it possible to retrieve the closure value in a\nreflect.MakeFunc function.\n\nFrom-SVN: r202233", "tree": {"sha": "5f956e4c89959ef335ef73b7ec6e00e4bc2c12d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f956e4c89959ef335ef73b7ec6e00e4bc2c12d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05a7d566782733230696a51ab8575261b8f9f162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a7d566782733230696a51ab8575261b8f9f162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05a7d566782733230696a51ab8575261b8f9f162", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05a7d566782733230696a51ab8575261b8f9f162/comments", "author": null, "committer": null, "parents": [{"sha": "3b18bc426a5c853bda2bdb9e646c5b00483e982a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b18bc426a5c853bda2bdb9e646c5b00483e982a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b18bc426a5c853bda2bdb9e646c5b00483e982a"}], "stats": {"total": 580, "additions": 237, "deletions": 343}, "files": [{"sha": "78a427398c2b79394db5364bcdcafab36217f75e", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 65, "deletions": 56, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1382,7 +1382,7 @@ Expression::make_func_reference(Named_object* function, Expression* closure,\n \n Func_descriptor_expression::Func_descriptor_expression(Named_object* fn)\n   : Expression(EXPRESSION_FUNC_DESCRIPTOR, fn->location()),\n-    fn_(fn), dfn_(NULL), dvar_(NULL)\n+    fn_(fn), dvar_(NULL)\n {\n   go_assert(!fn->is_function() || !fn->func_value()->needs_closure());\n }\n@@ -1417,18 +1417,6 @@ Func_descriptor_expression::do_type()\n   return Func_descriptor_expression::descriptor_type;\n }\n \n-// Copy a Func_descriptor_expression;\n-\n-Expression*\n-Func_descriptor_expression::do_copy()\n-{\n-  Func_descriptor_expression* fde =\n-    Expression::make_func_descriptor(this->fn_);\n-  if (this->dfn_ != NULL)\n-    fde->set_descriptor_wrapper(this->dfn_);\n-  return fde;\n-}\n-\n // The tree for a function descriptor.\n \n tree\n@@ -1455,11 +1443,8 @@ Func_descriptor_expression::do_get_tree(Translate_context* context)\n   Bvariable* bvar;\n   if (no->package() != NULL\n       || Linemap::is_predeclared_location(no->location()))\n-    {\n-      bvar = context->backend()->immutable_struct_reference(var_name, btype,\n-\t\t\t\t\t\t\t    loc);\n-      go_assert(this->dfn_ == NULL);\n-    }\n+    bvar = context->backend()->immutable_struct_reference(var_name, btype,\n+\t\t\t\t\t\t\t  loc);\n   else\n     {\n       Location bloc = Linemap::predeclared_location();\n@@ -1469,8 +1454,7 @@ Func_descriptor_expression::do_get_tree(Translate_context* context)\n       bvar = context->backend()->immutable_struct(var_name, is_hidden, false,\n \t\t\t\t\t\t  btype, bloc);\n       Expression_list* vals = new Expression_list();\n-      go_assert(this->dfn_ != NULL);\n-      vals->push_back(Expression::make_func_code_reference(this->dfn_, bloc));\n+      vals->push_back(Expression::make_func_code_reference(this->fn_, bloc));\n       Expression* init =\n \tExpression::make_struct_composite_literal(this->type(), vals, bloc);\n       Translate_context bcontext(gogo, NULL, NULL, NULL);\n@@ -6792,8 +6776,8 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n     }\n \n   Struct_field_list* sfl = new Struct_field_list();\n-  // The type here is wrong--it should be new_fntype.  But we don't\n-  // have new_fntype yet, and it doesn't really matter.\n+  // The type here is wrong--it should be the C function type.  But it\n+  // doesn't really matter.\n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n   sfl->push_back(Struct_field(Typed_identifier(\"fn.0\", vt, loc)));\n   sfl->push_back(Struct_field(Typed_identifier(\"val.1\",\n@@ -6802,17 +6786,17 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n   Type* closure_type = Type::make_struct_type(sfl, loc);\n   closure_type = Type::make_pointer_type(closure_type);\n \n-  Function_type* new_fntype = orig_fntype->copy_with_closure(closure_type);\n+  Function_type* new_fntype = orig_fntype->copy_with_names();\n \n   Named_object* new_no = gogo->start_function(Gogo::thunk_name(), new_fntype,\n \t\t\t\t\t      false, loc);\n \n-  gogo->start_block(loc);\n+  Variable* cvar = new Variable(closure_type, NULL, false, false, false, loc);\n+  cvar->set_is_used();\n+  Named_object* cp = Named_object::make_variable(\"$closure\", NULL, cvar);\n+  new_no->func_value()->set_closure_var(cp);\n \n-  Named_object* cp = gogo->lookup(\"closure.0\", NULL);\n-  go_assert(cp != NULL\n-\t    && cp->is_variable()\n-\t    && cp->var_value()->is_parameter());\n+  gogo->start_block(loc);\n \n   // Field 0 of the closure is the function code pointer, field 1 is\n   // the value on which to invoke the method.\n@@ -6831,7 +6815,7 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n       const Typed_identifier_list* new_params = new_fntype->parameters();\n       args = new Expression_list();\n       for (Typed_identifier_list::const_iterator p = new_params->begin();\n-\t   p + 1 != new_params->end();\n+\t   p != new_params->end();\n \t   ++p)\n \t{\n \t  Named_object* p_no = gogo->lookup(p->name(), NULL);\n@@ -9729,21 +9713,21 @@ Call_expression::do_get_tree(Translate_context* context)\n   const bool has_closure = func != NULL && func->closure() != NULL;\n   const bool is_interface_method = interface_method != NULL;\n \n-  int closure_arg;\n+  bool has_closure_arg;\n   if (has_closure)\n-    closure_arg = 1;\n+    has_closure_arg = true;\n   else if (func != NULL)\n-    closure_arg = 0;\n+    has_closure_arg = false;\n   else if (is_interface_method)\n-    closure_arg = 0;\n+    has_closure_arg = false;\n   else\n-    closure_arg = 1;\n+    has_closure_arg = true;\n \n   int nargs;\n   tree* args;\n   if (this->args_ == NULL || this->args_->empty())\n     {\n-      nargs = (is_interface_method ? 1 : 0) + closure_arg;\n+      nargs = is_interface_method ? 1 : 0;\n       args = nargs == 0 ? NULL : new tree[nargs];\n     }\n   else if (fntype->parameters() == NULL || fntype->parameters()->empty())\n@@ -9752,7 +9736,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       go_assert(!is_interface_method\n \t\t&& fntype->is_method()\n \t\t&& this->args_->size() == 1);\n-      nargs = 1 + closure_arg;\n+      nargs = 1;\n       args = new tree[nargs];\n       args[0] = this->args_->front()->get_tree(context);\n     }\n@@ -9763,7 +9747,6 @@ Call_expression::do_get_tree(Translate_context* context)\n       nargs = this->args_->size();\n       int i = is_interface_method ? 1 : 0;\n       nargs += i;\n-      nargs += closure_arg;\n       args = new tree[nargs];\n \n       Typed_identifier_list::const_iterator pp = params->begin();\n@@ -9787,7 +9770,7 @@ Call_expression::do_get_tree(Translate_context* context)\n \t    return error_mark_node;\n \t}\n       go_assert(pp == params->end());\n-      go_assert(i + closure_arg == nargs);\n+      go_assert(i == nargs);\n     }\n \n   tree fntype_tree = type_to_tree(fntype->get_backend(gogo));\n@@ -9806,21 +9789,23 @@ Call_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n \n   tree fn;\n+  tree closure_tree;\n   if (func != NULL)\n     {\n       Named_object* no = func->named_object();\n-      go_assert(!no->is_function()\n-\t\t|| !no->func_value()->is_descriptor_wrapper());\n       fn = Func_expression::get_code_pointer(gogo, no, location);\n-      if (has_closure)\n+      if (!has_closure)\n+\tclosure_tree = NULL_TREE;\n+      else\n \t{\n-\t  go_assert(closure_arg == 1 && nargs > 0);\n-\t  args[nargs - 1] = func->closure()->get_tree(context);\n+\t  closure_tree = func->closure()->get_tree(context);\n+\t  if (closure_tree == error_mark_node)\n+\t    return error_mark_node;\n \t}\n     }\n   else if (!is_interface_method)\n     {\n-      tree closure_tree = this->fn_->get_tree(context);\n+      closure_tree = this->fn_->get_tree(context);\n       if (closure_tree == error_mark_node)\n \treturn error_mark_node;\n       tree fnc = fold_convert_loc(location.gcc_location(), fntype_tree,\n@@ -9834,16 +9819,14 @@ Call_expression::do_get_tree(Translate_context* context)\n \t\t\t   build_fold_indirect_ref_loc(location.gcc_location(),\n \t\t\t\t\t\t       fnc),\n \t\t\t   field, NULL_TREE);\n-      go_assert(closure_arg == 1 && nargs > 0);\n-      args[nargs - 1] = closure_tree;\n     }      \n   else\n     {\n       fn = this->interface_method_function(context, interface_method,\n \t\t\t\t\t   &args[0]);\n       if (fn == error_mark_node)\n \treturn error_mark_node;\n-      go_assert(closure_arg == 0);\n+      closure_tree = NULL_TREE;\n     }\n \n   if (fn == error_mark_node || TREE_TYPE(fn) == error_mark_node)\n@@ -9894,6 +9877,32 @@ Call_expression::do_get_tree(Translate_context* context)\n   if (func == NULL)\n     fn = save_expr(fn);\n \n+  if (!has_closure_arg)\n+    go_assert(closure_tree == NULL_TREE);\n+  else\n+    {\n+      // Pass the closure argument by calling the function function\n+      // __go_set_closure.  In the order_evaluations pass we have\n+      // ensured that if any parameters contain call expressions, they\n+      // will have been moved out to temporary variables.\n+\n+      go_assert(closure_tree != NULL_TREE);\n+      closure_tree = fold_convert_loc(location.gcc_location(), ptr_type_node,\n+\t\t\t\t      closure_tree);\n+      static tree set_closure_fndecl;\n+      tree set_closure = Gogo::call_builtin(&set_closure_fndecl,\n+\t\t\t\t\t    location,\n+\t\t\t\t\t    \"__go_set_closure\",\n+\t\t\t\t\t    1,\n+\t\t\t\t\t    void_type_node,\n+\t\t\t\t\t    ptr_type_node,\n+\t\t\t\t\t    closure_tree);\n+      if (set_closure == error_mark_node)\n+\treturn error_mark_node;\n+      fn = build2_loc(location.gcc_location(), COMPOUND_EXPR,\n+\t\t      TREE_TYPE(fn), set_closure, fn);\n+    }\n+\n   tree ret = build_call_array(excess_type != NULL_TREE ? excess_type : rettype,\n \t\t\t      fn, nargs, args);\n   delete[] args;\n@@ -11609,25 +11618,25 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n     return Named_object::make_erroneous_name(Gogo::thunk_name());\n \n   Struct_field_list* sfl = new Struct_field_list();\n-  // The type here is wrong--it should be new_fntype.  But we don't\n-  // have new_fntype yet, and it doesn't really matter.\n+  // The type here is wrong--it should be the C function type.  But it\n+  // doesn't really matter.\n   Type* vt = Type::make_pointer_type(Type::make_void_type());\n   sfl->push_back(Struct_field(Typed_identifier(\"fn.0\", vt, loc)));\n   sfl->push_back(Struct_field(Typed_identifier(\"val.1\", type, loc)));\n   Type* closure_type = Type::make_struct_type(sfl, loc);\n   closure_type = Type::make_pointer_type(closure_type);\n \n-  Function_type* new_fntype = orig_fntype->copy_with_closure(closure_type);\n+  Function_type* new_fntype = orig_fntype->copy_with_names();\n \n   Named_object* new_no = gogo->start_function(Gogo::thunk_name(), new_fntype,\n \t\t\t\t\t      false, loc);\n \n-  gogo->start_block(loc);\n+  Variable* cvar = new Variable(closure_type, NULL, false, false, false, loc);\n+  cvar->set_is_used();\n+  Named_object* cp = Named_object::make_variable(\"$closure\", NULL, cvar);\n+  new_no->func_value()->set_closure_var(cp);\n \n-  Named_object* cp = gogo->lookup(\"closure.0\", NULL);\n-  go_assert(cp != NULL\n-\t    && cp->is_variable()\n-\t    && cp->var_value()->is_parameter());\n+  gogo->start_block(loc);\n \n   // Field 0 of the closure is the function code pointer, field 1 is\n   // the value on which to invoke the method.\n@@ -11647,7 +11656,7 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n       const Typed_identifier_list* new_params = new_fntype->parameters();\n       args = new Expression_list();\n       for (Typed_identifier_list::const_iterator p = new_params->begin();\n-\t   p + 1 != new_params->end();\n+\t   p != new_params->end();\n \t   ++p)\n \t{\n \t  Named_object* p_no = gogo->lookup(p->name(), NULL);"}, {"sha": "95584f2748ba3863cde6b5679cc23588bdff1bbd", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1570,14 +1570,6 @@ class Func_descriptor_expression : public Expression\n  public:\n   Func_descriptor_expression(Named_object* fn);\n \n-  // Set the descriptor wrapper.\n-  void\n-  set_descriptor_wrapper(Named_object* dfn)\n-  {\n-    go_assert(this->dfn_ == NULL);\n-    this->dfn_ = dfn;\n-  }\n-\n   // Make the function descriptor type, so that it can be converted.\n   static void\n   make_func_descriptor_type();\n@@ -1594,7 +1586,8 @@ class Func_descriptor_expression : public Expression\n   { }\n \n   Expression*\n-  do_copy();\n+  do_copy()\n+  { return Expression::make_func_descriptor(this->fn_); }\n \n   bool\n   do_is_addressable() const\n@@ -1612,8 +1605,6 @@ class Func_descriptor_expression : public Expression\n \n   // The function for which this is the descriptor.\n   Named_object* fn_;\n-  // The descriptor function.\n-  Named_object* dfn_;\n   // The descriptor variable.\n   Bvariable* dvar_;\n };"}, {"sha": "69797f93342f609701ff7fc792f1a93dbf6e8dbf", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 24, "deletions": 63, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1289,30 +1289,6 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t  functype = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(functype)));\n \t  go_assert(FUNCTION_POINTER_TYPE_P(functype));\n \t  functype = TREE_TYPE(functype);\n-\n-\t  // In the struct, the function type always has a trailing\n-\t  // closure argument.  For the function body, we only use\n-\t  // that trailing arg if this is a function literal or if it\n-\t  // is a wrapper created to store in a descriptor.  Remove it\n-\t  // in that case.\n-\t  if (this->enclosing_ == NULL && !this->is_descriptor_wrapper_)\n-\t    {\n-\t      tree old_params = TYPE_ARG_TYPES(functype);\n-\t      go_assert(old_params != NULL_TREE\n-\t\t\t&& old_params != void_list_node);\n-\t      tree new_params = NULL_TREE;\n-\t      tree *pp = &new_params;\n-\t      while (TREE_CHAIN (old_params) != void_list_node)\n-\t\t{\n-\t\t  tree p = TREE_VALUE(old_params);\n-\t\t  go_assert(TYPE_P(p));\n-\t\t  *pp = tree_cons(NULL_TREE, p, NULL_TREE);\n-\t\t  pp = &TREE_CHAIN(*pp);\n-\t\t  old_params = TREE_CHAIN (old_params);\n-\t\t}\n-\t      *pp = void_list_node;\n-\t      functype = build_function_type(TREE_TYPE(functype), new_params);\n-\t    }\n \t}\n \n       if (functype == error_mark_node)\n@@ -1423,26 +1399,6 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t  functype = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(functype)));\n \t  go_assert(FUNCTION_POINTER_TYPE_P(functype));\n \t  functype = TREE_TYPE(functype);\n-\n-\t  // In the struct, the function type always has a trailing\n-\t  // closure argument.  Here we are referring to the function\n-\t  // code directly, and we know it is not a function literal,\n-\t  // and we know it is not a wrapper created to store in a\n-\t  // descriptor.  Remove that trailing argument.\n-\t  tree old_params = TYPE_ARG_TYPES(functype);\n-\t  go_assert(old_params != NULL_TREE && old_params != void_list_node);\n-\t  tree new_params = NULL_TREE;\n-\t  tree *pp = &new_params;\n-\t  while (TREE_CHAIN (old_params) != void_list_node)\n-\t    {\n-\t      tree p = TREE_VALUE(old_params);\n-\t      go_assert(TYPE_P(p));\n-\t      *pp = tree_cons(NULL_TREE, p, NULL_TREE);\n-\t      pp = &TREE_CHAIN(*pp);\n-\t      old_params = TREE_CHAIN (old_params);\n-\t    }\n-\t  *pp = void_list_node;\n-\t  functype = build_function_type(TREE_TYPE(functype), new_params);\n \t}\n \n       tree decl;\n@@ -1659,34 +1615,39 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t}\n     }\n \n-  // The closure variable is passed last, if this is a function\n-  // literal or a descriptor wrapper.\n+  *pp = NULL_TREE;\n+\n+  DECL_ARGUMENTS(fndecl) = params;\n+\n+  // If we need a closure variable, fetch it by calling a runtime\n+  // function.  The caller will have called __go_set_closure before\n+  // the function call.\n   if (this->closure_var_ != NULL)\n     {\n       Bvariable* bvar =\n \tthis->closure_var_->get_backend_variable(gogo, named_function);\n       tree var_decl = var_to_tree(bvar);\n       if (var_decl != error_mark_node)\n \t{\n-\t  go_assert(TREE_CODE(var_decl) == PARM_DECL);\n-\t  *pp = var_decl;\n-\t  pp = &DECL_CHAIN(*pp);\n+\t  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n+\t  static tree get_closure_fndecl;\n+\t  tree get_closure = Gogo::call_builtin(&get_closure_fndecl,\n+\t\t\t\t\t\tthis->location_,\n+\t\t\t\t\t\t\"__go_get_closure\",\n+\t\t\t\t\t\t0,\n+\t\t\t\t\t\tptr_type_node);\n+\n+\t  // Mark the __go_get_closure function as pure, since it\n+\t  // depends only on the global variable g.\n+\t  DECL_PURE_P(get_closure_fndecl) = 1;\n+\n+\t  get_closure = fold_convert_loc(this->location_.gcc_location(),\n+\t\t\t\t\t TREE_TYPE(var_decl), get_closure);\n+\t  DECL_INITIAL(var_decl) = get_closure;\n+\t  DECL_CHAIN(var_decl) = declare_vars;\n+\t  declare_vars = var_decl;\n \t}\n     }\n-  else if (this->enclosing_ != NULL || this->is_descriptor_wrapper_)\n-    {\n-      tree parm_decl = build_decl(this->location_.gcc_location(), PARM_DECL,\n-\t\t\t\t  get_identifier(\"$closure\"),\n-\t\t\t\t  const_ptr_type_node);\n-      DECL_CONTEXT(parm_decl) = current_function_decl;\n-      DECL_ARG_TYPE(parm_decl) = const_ptr_type_node;\n-      *pp = parm_decl;\n-      pp = &DECL_CHAIN(*pp);\n-    }\n-\n-  *pp = NULL_TREE;\n-\n-  DECL_ARGUMENTS(fndecl) = params;\n \n   if (this->block_ != NULL)\n     {"}, {"sha": "be8ec5939f32e8c06c8b9b3e616a61c44aa8478f", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 42, "deletions": 113, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1770,8 +1770,8 @@ Create_function_descriptors::function(Named_object* no)\n   if (no->is_function()\n       && no->func_value()->enclosing() == NULL\n       && !no->func_value()->is_method()\n-      && !no->func_value()->is_descriptor_wrapper()\n-      && !Gogo::is_hidden_name(no->name()))\n+      && !Gogo::is_hidden_name(no->name())\n+      && !Gogo::is_thunk(no))\n     no->func_value()->descriptor(this->gogo_, no);\n \n   return TRAVERSE_CONTINUE;\n@@ -2541,13 +2541,38 @@ Order_eval::statement(Block* block, size_t* pindex, Statement* s)\n     return TRAVERSE_CONTINUE;\n \n   // If there is only one expression with a side-effect, we can\n-  // usually leave it in place.  However, for an assignment statement,\n-  // we need to evaluate an expression on the right hand side before\n-  // we evaluate any index expression on the left hand side, so for\n-  // that case we always move the expression.  Otherwise we mishandle\n-  // m[0] = len(m) where m is a map.\n-  if (c == 1 && s->classification() != Statement::STATEMENT_ASSIGNMENT)\n-    return TRAVERSE_CONTINUE;\n+  // usually leave it in place.\n+  if (c == 1)\n+    {\n+      switch (s->classification())\n+\t{\n+\tcase Statement::STATEMENT_ASSIGNMENT:\n+\t  // For an assignment statement, we need to evaluate an\n+\t  // expression on the right hand side before we evaluate any\n+\t  // index expression on the left hand side, so for that case\n+\t  // we always move the expression.  Otherwise we mishandle\n+\t  // m[0] = len(m) where m is a map.\n+\t  break;\n+\n+\tcase Statement::STATEMENT_EXPRESSION:\n+\t  {\n+\t    // If this is a call statement that doesn't return any\n+\t    // values, it will not have been counted as a value to\n+\t    // move.  We need to move any subexpressions in case they\n+\t    // are themselves call statements that require passing a\n+\t    // closure.\n+\t    Expression* expr = s->expression_statement()->expr();\n+\t    if (expr->call_expression() != NULL\n+\t\t&& expr->call_expression()->result_count() == 0)\n+\t      break;\n+\t    return TRAVERSE_CONTINUE;\n+\t  }\n+\n+\tdefault:\n+\t  // We can leave the expression in place.\n+\t  return TRAVERSE_CONTINUE;\n+\t}\n+    }\n \n   bool is_thunk = s->thunk_statement() != NULL;\n   for (Find_eval_ordering::const_iterator p = find_eval_ordering.begin();\n@@ -2803,7 +2828,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n       Named_object* orig_closure_no = orig_func->closure_var();\n       Variable* orig_closure_var = orig_closure_no->var_value();\n       Variable* new_var = new Variable(orig_closure_var->type(), NULL, false,\n-\t\t\t\t       true, false, location);\n+\t\t\t\t       false, false, location);\n       snprintf(buf, sizeof buf, \"closure.%u\", count);\n       ++count;\n       Named_object* new_closure_no = Named_object::make_variable(buf, NULL,\n@@ -3275,7 +3300,7 @@ Function::Function(Function_type* type, Function* enclosing, Block* block,\n     local_type_count_(0), descriptor_(NULL), fndecl_(NULL), defer_stack_(NULL),\n     is_sink_(false), results_are_named_(false), nointerface_(false),\n     calls_recover_(false), is_recover_thunk_(false), has_recover_thunk_(false),\n-    in_unique_section_(false), is_descriptor_wrapper_(false)\n+    in_unique_section_(false)\n {\n }\n \n@@ -3357,9 +3382,9 @@ Function::closure_var()\n       Struct_field_list* sfl = new Struct_field_list;\n       Type* struct_type = Type::make_struct_type(sfl, loc);\n       Variable* var = new Variable(Type::make_pointer_type(struct_type),\n-\t\t\t\t   NULL, false, true, false, loc);\n+\t\t\t\t   NULL, false, false, false, loc);\n       var->set_is_used();\n-      this->closure_var_ = Named_object::make_variable(\"closure\", NULL, var);\n+      this->closure_var_ = Named_object::make_variable(\"$closure\", NULL, var);\n       // Note that the new variable is not in any binding contour.\n     }\n   return this->closure_var_;\n@@ -3562,99 +3587,16 @@ Function::determine_types()\n     this->block_->determine_types();\n }\n \n-// Build a wrapper function for a function descriptor.  A function\n-// descriptor refers to a function that takes a closure as its last\n-// argument.  In this case there will be no closure, but an indirect\n-// call will pass nil as the last argument.  We need to build a\n-// wrapper function that accepts and discards that last argument, so\n-// that cases like -mrtd will work correctly.  In most cases the\n-// wrapper function will simply be a jump.\n-\n-Named_object*\n-Function::make_descriptor_wrapper(Gogo* gogo, Named_object* no,\n-\t\t\t\t  Function_type* orig_fntype)\n-{\n-  Location loc = no->location();\n-\n-  Type* vt = Type::make_pointer_type(Type::make_void_type());\n-  Function_type* new_fntype = orig_fntype->copy_with_closure(vt);\n-\n-  std::string name = no->name() + \"$descriptorfn\";\n-  Named_object* dno = gogo->start_function(name, new_fntype, false, loc);\n-  dno->func_value()->is_descriptor_wrapper_ = true;\n-\n-  // Put the wrapper in a unique section so that it can be discarded\n-  // by the linker if it is not needed.  Every top-level function will\n-  // get a wrapper, in case there is a reference other than a call\n-  // from some other package, but most will not need one.\n-  dno->func_value()->set_in_unique_section();\n-\n-  gogo->start_block(loc);\n-\n-  Expression* fn = Expression::make_func_reference(no, NULL, loc);\n-\n-  // Call the function begin wrapped, passing all of the arguments\n-  // except for the last one (the last argument is the ignored\n-  // closure).\n-  const Typed_identifier_list* orig_params = orig_fntype->parameters();\n-  Expression_list* args;\n-  if (orig_params == NULL || orig_params->empty())\n-    args = NULL;\n-  else\n-    {\n-      const Typed_identifier_list* new_params = new_fntype->parameters();\n-      args = new Expression_list();\n-      for (Typed_identifier_list::const_iterator p = new_params->begin();\n-\t   p + 1 != new_params->end();\n-\t   ++p)\n-\t{\n-\t  Named_object* p_no = gogo->lookup(p->name(), NULL);\n-\t  go_assert(p_no != NULL\n-\t\t    && p_no->is_variable()\n-\t\t    && p_no->var_value()->is_parameter());\n-\t  args->push_back(Expression::make_var_reference(p_no, loc));\n-\t}\n-    }\n-\n-  Call_expression* call = Expression::make_call(fn, args,\n-\t\t\t\t\t\torig_fntype->is_varargs(),\n-\t\t\t\t\t\tloc);\n-  call->set_varargs_are_lowered();\n-\n-  Statement* s = Statement::make_return_from_call(call, loc);\n-  gogo->add_statement(s);\n-  Block* b = gogo->finish_block(loc);\n-  gogo->add_block(b, loc);\n-  gogo->lower_block(dno, b);\n-  gogo->finish_function(loc);\n-\n-  return dno;\n-}\n-\n // Return the function descriptor, the value you get when you refer to\n // the function in Go code without calling it.\n \n Expression*\n-Function::descriptor(Gogo* gogo, Named_object* no)\n+Function::descriptor(Gogo*, Named_object* no)\n {\n   go_assert(!this->is_method());\n   go_assert(this->closure_var_ == NULL);\n-  go_assert(!this->is_descriptor_wrapper_);\n   if (this->descriptor_ == NULL)\n-    {\n-      // Make and record the descriptor first, so that when we lower\n-      // the descriptor wrapper we don't try to make it again.\n-      Func_descriptor_expression* descriptor =\n-\tExpression::make_func_descriptor(no);\n-      this->descriptor_ = descriptor;\n-      if (no->package() == NULL\n-\t  && !Linemap::is_predeclared_location(no->location()))\n-\t{\n-\t  Named_object* dno = Function::make_descriptor_wrapper(gogo, no,\n-\t\t\t\t\t\t\t\tthis->type_);\n-\t  descriptor->set_descriptor_wrapper(dno);\n-\t}\n-    }\n+    this->descriptor_ = Expression::make_func_descriptor(no);\n   return this->descriptor_;\n }\n \n@@ -4193,24 +4135,11 @@ Bindings_snapshot::check_goto_defs(Location loc, const Block* block,\n // Return the function descriptor.\n \n Expression*\n-Function_declaration::descriptor(Gogo* gogo, Named_object* no)\n+Function_declaration::descriptor(Gogo*, Named_object* no)\n {\n   go_assert(!this->fntype_->is_method());\n   if (this->descriptor_ == NULL)\n-    {\n-      // Make and record the descriptor first, so that when we lower\n-      // the descriptor wrapper we don't try to make it again.\n-      Func_descriptor_expression* descriptor =\n-\tExpression::make_func_descriptor(no);\n-      this->descriptor_ = descriptor;\n-      if (no->package() == NULL\n-\t  && !Linemap::is_predeclared_location(no->location()))\n-\t{\n-\t  Named_object* dno = Function::make_descriptor_wrapper(gogo, no,\n-\t\t\t\t\t\t\t\tthis->fntype_);\n-\t  descriptor->set_descriptor_wrapper(dno);\n-\t}\n-    }\n+    this->descriptor_ = Expression::make_func_descriptor(no);\n   return this->descriptor_;\n }\n "}, {"sha": "6a87f2d562ccc8650e7c2b914e4269e0de168c13", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1050,12 +1050,6 @@ class Function\n   set_in_unique_section()\n   { this->in_unique_section_ = true; }\n \n-  // Whether this function was created as a descriptor wrapper for\n-  // another function.\n-  bool\n-  is_descriptor_wrapper() const\n-  { return this->is_descriptor_wrapper_; }\n-\n   // Swap with another function.  Used only for the thunk which calls\n   // recover.\n   void\n@@ -1085,10 +1079,6 @@ class Function\n     this->descriptor_ = descriptor;\n   }\n \n-  // Build a descriptor wrapper function.\n-  static Named_object*\n-  make_descriptor_wrapper(Gogo*, Named_object*, Function_type*);\n-\n   // Return the function's decl given an identifier.\n   tree\n   get_or_make_decl(Gogo*, Named_object*, tree id);\n@@ -1190,9 +1180,6 @@ class Function\n   // True if this function should be put in a unique section.  This is\n   // turned on for field tracking.\n   bool in_unique_section_ : 1;\n-  // True if this is a function wrapper created to put in a function\n-  // descriptor.\n-  bool is_descriptor_wrapper_ : 1;\n };\n \n // A snapshot of the current binding state."}, {"sha": "0261f9d4882b79b1e34cf83abd2f857f4345d569", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1658,46 +1658,23 @@ Statement::make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n \t\t\t\t\t\t   location);\n }\n \n-// An expression statement.\n+// Class Expression_statement.\n \n-class Expression_statement : public Statement\n-{\n- public:\n-  Expression_statement(Expression* expr, bool is_ignored)\n-    : Statement(STATEMENT_EXPRESSION, expr->location()),\n-      expr_(expr), is_ignored_(is_ignored)\n-  { }\n-\n-  Expression*\n-  expr()\n-  { return this->expr_; }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse)\n-  { return this->traverse_expression(traverse, &this->expr_); }\n-\n-  void\n-  do_determine_types()\n-  { this->expr_->determine_type_no_context(); }\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  bool\n-  do_may_fall_through() const;\n+// Constructor.\n \n-  Bstatement*\n-  do_get_backend(Translate_context* context);\n+Expression_statement::Expression_statement(Expression* expr, bool is_ignored)\n+  : Statement(STATEMENT_EXPRESSION, expr->location()),\n+    expr_(expr), is_ignored_(is_ignored)\n+{\n+}\n \n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n+// Determine types.\n \n- private:\n-  Expression* expr_;\n-  // Whether the value of this expression is being explicitly ignored.\n-  bool is_ignored_;\n-};\n+void\n+Expression_statement::do_determine_types()\n+{\n+  this->expr_->determine_type_no_context();\n+}\n \n // Check the types of an expression statement.  The only check we do\n // is to possibly give an error about discarding the value of the"}, {"sha": "b128fa0a8eb1cb1e96168be75dc6281809eaf66f", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -17,6 +17,7 @@ class Function;\n class Unnamed_label;\n class Temporary_statement;\n class Variable_declaration_statement;\n+class Expression_statement;\n class Return_statement;\n class Thunk_statement;\n class Label_statement;\n@@ -329,6 +330,14 @@ class Statement\n \t\t\t STATEMENT_VARIABLE_DECLARATION>();\n   }\n \n+  // If this is an expression statement, return it.  Otherwise return\n+  // NULL.\n+  Expression_statement*\n+  expression_statement()\n+  {\n+    return this->convert<Expression_statement, STATEMENT_EXPRESSION>();\n+  }\n+\n   // If this is a return statement, return it.  Otherwise return NULL.\n   Return_statement*\n   return_statement()\n@@ -636,6 +645,43 @@ class Return_statement : public Statement\n   bool is_lowered_;\n };\n \n+// An expression statement.\n+\n+class Expression_statement : public Statement\n+{\n+ public:\n+  Expression_statement(Expression* expr, bool is_ignored);\n+\n+  Expression*\n+  expr()\n+  { return this->expr_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->traverse_expression(traverse, &this->expr_); }\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  bool\n+  do_may_fall_through() const;\n+\n+  Bstatement*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  Expression* expr_;\n+  // Whether the value of this expression is being explicitly ignored.\n+  bool is_ignored_;\n+};\n+\n // A send statement.\n \n class Send_statement : public Statement"}, {"sha": "9ce329d55035ca1773a78fd2543a05f433716a1a", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -3390,10 +3390,7 @@ Function_type::do_get_backend(Gogo* gogo)\n   // When we do anything with a function value other than call it, it\n   // is represented as a pointer to a struct whose first field is the\n   // actual function.  So that is what we return as the type of a Go\n-  // function.  The function stored in the first field always that\n-  // takes one additional trailing argument: the closure pointer.  For\n-  // a top-level function, this additional argument will only be\n-  // passed when invoking the function indirectly, via the struct.\n+  // function.\n \n   Location loc = this->location();\n   Btype* struct_type =\n@@ -3415,15 +3412,9 @@ Function_type::do_get_backend(Gogo* gogo)\n     }\n \n   std::vector<Backend::Btyped_identifier> bparameters;\n-  size_t last;\n-  if (this->parameters_ == NULL)\n-    {\n-      bparameters.resize(1);\n-      last = 0;\n-    }\n-  else\n+  if (this->parameters_ != NULL)\n     {\n-      bparameters.resize(this->parameters_->size() + 1);\n+      bparameters.resize(this->parameters_->size());\n       size_t i = 0;\n       for (Typed_identifier_list::const_iterator p = this->parameters_->begin();\n \t   p != this->parameters_->end();\n@@ -3433,12 +3424,8 @@ Function_type::do_get_backend(Gogo* gogo)\n \t  bparameters[i].btype = p->type()->get_backend(gogo);\n \t  bparameters[i].location = p->location();\n \t}\n-      last = i;\n+      go_assert(i == bparameters.size());\n     }\n-  go_assert(last + 1 == bparameters.size());\n-  bparameters[last].name = \"$closure\";\n-  bparameters[last].btype = ptr_struct_type;\n-  bparameters[last].location = loc;\n \n   std::vector<Backend::Btyped_identifier> bresults;\n   if (this->results_ != NULL)\n@@ -3840,7 +3827,7 @@ Function_type::copy_with_receiver(Type* receiver_type) const\n // closure parameter.\n \n Function_type*\n-Function_type::copy_with_closure(Type* closure_type) const\n+Function_type::copy_with_names() const\n {\n   Typed_identifier_list* new_params = new Typed_identifier_list();\n   const Typed_identifier_list* orig_params = this->parameters_;\n@@ -3858,8 +3845,6 @@ Function_type::copy_with_closure(Type* closure_type) const\n \t\t\t\t\t\t p->location()));\n \t}\n     }\n-  new_params->push_back(Typed_identifier(\"closure.0\", closure_type,\n-\t\t\t\t\t this->location_));\n \n   const Typed_identifier_list* orig_results = this->results_;\n   Typed_identifier_list* new_results;"}, {"sha": "d207fe5a375e2860a121f9bb88c1cefd1a17355d", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -1789,11 +1789,11 @@ class Function_type : public Type\n   Function_type*\n   copy_with_receiver(Type*) const;\n \n-  // Return a copy of this type ignoring any receiver and adding a\n-  // final closure parameter of type CLOSURE_TYPE.  This is used when\n-  // creating descriptors.\n+  // Return a copy of this type ignoring any receiver and using dummy\n+  // names for all parameters.  This is used for thunks for method\n+  // values.\n   Function_type*\n-  copy_with_closure(Type* closure_type) const;\n+  copy_with_names() const;\n \n   static Type*\n   make_function_type_descriptor_type();"}, {"sha": "45a08587973b5be33eedee57dc8ade0c2a922dcc", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -434,9 +434,6 @@ func (v Value) call(op string, in []Value) []Value {\n \t\tnin++\n \t}\n \tfirstPointer := len(in) > 0 && Kind(t.In(0).(*rtype).kind) != Ptr && v.flag&flagMethod == 0 && isMethod(v.typ)\n-\tif v.flag&flagMethod == 0 && !firstPointer {\n-\t\tnin++\n-\t}\n \tparams := make([]unsafe.Pointer, nin)\n \toff := 0\n \tif v.flag&flagMethod != 0 {\n@@ -464,10 +461,6 @@ func (v Value) call(op string, in []Value) []Value {\n \t\t}\n \t\toff++\n \t}\n-\tif v.flag&flagMethod == 0 && !firstPointer {\n-\t\t// Closure argument.\n-\t\tparams[off] = unsafe.Pointer(&fn)\n-\t}\n \n \tret := make([]Value, nout)\n \tresults := make([]unsafe.Pointer, nout)"}, {"sha": "5cf370798bfe4b0e7049ce1df22c9fc17bc5d322", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -302,9 +302,7 @@ go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n   in_types = ((const struct __go_type_descriptor **)\n \t      func->__in.__values);\n \n-  num_args = (num_params\n-\t      + (is_interface ? 1 : 0)\n-\t      + (!is_interface && !is_method ? 1 : 0));\n+  num_args = num_params + (is_interface ? 1 : 0);\n   args = (ffi_type **) __go_alloc (num_args * sizeof (ffi_type *));\n   i = 0;\n   off = 0;\n@@ -321,12 +319,6 @@ go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n   for (; i < num_params; ++i)\n     args[i + off] = go_type_to_ffi (in_types[i]);\n \n-  if (!is_interface && !is_method)\n-    {\n-      // There is a closure argument, a pointer.\n-      args[i + off] = &ffi_type_pointer;\n-    }\n-\n   rettype = go_func_return_ffi (func);\n \n   status = ffi_prep_cif (cif, FFI_DEFAULT_ABI, num_args, rettype, args);\n@@ -511,9 +503,8 @@ go_set_results (const struct __go_func_type *func, unsigned char *call_result,\n    regardless of FUNC_TYPE, it is passed as a pointer.\n \n    If neither IS_INTERFACE nor IS_METHOD is true then we are calling a\n-   function indirectly, and the caller is responsible for passing a\n-   trailing closure argument, a pointer, which is not described in\n-   FUNC_TYPE.  */\n+   function indirectly, and we must pass a closure pointer via\n+   __go_set_closure.  The pointer to pass is simply FUNC_VAL.  */\n \n void\n reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n@@ -528,6 +519,8 @@ reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n \n   call_result = (unsigned char *) malloc (go_results_size (func_type));\n \n+  if (!is_interface && !is_method)\n+    __go_set_closure (func_val);\n   ffi_call (&cif, func_val->fn, call_result, params);\n \n   /* Some day we may need to free result values if RESULTS is"}, {"sha": "c3b32111ca04d00786b752805c6621c4a4f74fbb", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -2263,12 +2263,11 @@ runfinq(void* dummy __attribute__ ((unused)))\n \t\tfor(; fb; fb=next) {\n \t\t\tnext = fb->next;\n \t\t\tfor(i=0; i<(uint32)fb->cnt; i++) {\n-\t\t\t\tvoid *params[2];\n+\t\t\t\tvoid *param;\n \n \t\t\t\tf = &fb->fin[i];\n-\t\t\t\tparams[0] = &f->arg;\n-\t\t\t\tparams[1] = f;\n-\t\t\t\treflect_call(f->ft, f->fn, 0, 0, params, nil);\n+\t\t\t\tparam = &f->arg;\n+\t\t\t\treflect_call(f->ft, f->fn, 0, 0, &param, nil);\n \t\t\t\tf->fn = nil;\n \t\t\t\tf->arg = nil;\n \t\t\t}"}, {"sha": "0e77a3e0603d0001919d717e32c004b86a1f517d", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -2832,3 +2832,23 @@ runtime_proc_scan(void (*addroot)(Obj))\n {\n \taddroot((Obj){(byte*)&runtime_sched, sizeof runtime_sched, 0});\n }\n+\n+// When a function calls a closure, it passes the closure value to\n+// __go_set_closure immediately before the function call.  When a\n+// function uses a closure, it calls __go_get_closure immediately on\n+// function entry.  This is a hack, but it will work on any system.\n+// It would be better to use the static chain register when there is\n+// one.  It is also worth considering expanding these functions\n+// directly in the compiler.\n+\n+void\n+__go_set_closure(void* v)\n+{\n+\tg->closure = v;\n+}\n+\n+void *\n+__go_get_closure(void)\n+{\n+\treturn g->closure;\n+}"}, {"sha": "d2e7d4c11bc02c062d57ef4d783b19713ea8f6bc", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -190,6 +190,7 @@ struct\tLocation\n \n struct\tG\n {\n+\tvoid*\tclosure;\t// Closure value.\n \tDefer*\tdefer;\n \tPanic*\tpanic;\n \tvoid*\texception;\t// current exception being thrown\n@@ -759,3 +760,6 @@ extern void runtime_main(void*);\n int32 getproccount(void);\n \n #define PREFETCH(p) __builtin_prefetch(p)\n+\n+void\t__go_set_closure(void*);\n+void*\t__go_get_closure(void);"}, {"sha": "8d12fe010800964ce2f6677f0a6bc7bba8ce97ef", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05a7d566782733230696a51ab8575261b8f9f162/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=05a7d566782733230696a51ab8575261b8f9f162", "patch": "@@ -46,10 +46,9 @@ static void siftdown(int32);\n \n // Ready the goroutine e.data.\n static void\n-ready(int64 now, Eface e, void *closure)\n+ready(int64 now, Eface e)\n {\n \tUSED(now);\n-\tUSED(closure);\n \n \truntime_ready(e.__object);\n }\n@@ -166,7 +165,7 @@ timerproc(void* dummy __attribute__ ((unused)))\n {\n \tint64 delta, now;\n \tTimer *t;\n-\tvoid (*f)(int64, Eface, void *);\n+\tvoid (*f)(int64, Eface);\n \tEface arg;\n \n \tfor(;;) {\n@@ -197,7 +196,8 @@ timerproc(void* dummy __attribute__ ((unused)))\n \t\t\truntime_unlock(&timers);\n \t\t\tif(raceenabled)\n \t\t\t\truntime_raceacquire(t);\n-\t\t\tf(now, arg, &t->fv);\n+\t\t\t__go_set_closure(t->fv);\n+\t\t\tf(now, arg);\n \t\t\truntime_lock(&timers);\n \t\t}\n \t\tif(delta < 0) {"}]}