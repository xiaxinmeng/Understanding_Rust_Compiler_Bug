{"sha": "1697806fdf25285b924251b0d785324775e9b905", "node_id": "C_kwDOANBUbNoAKDE2OTc4MDZmZGYyNTI4NWI5MjQyNTFiMGQ3ODUzMjQ3NzVlOWI5MDU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-10T13:00:44Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-01T22:44:44Z"}, "message": "trailing_wide_ints with runtime variable lengths\n\nCurrently global ranges are stored in SSA_NAME_RANGE_INFO as a pair of\nwide_int-like objects along with the nonzero bits.  We frequently lose\nprecision when streaming out our higher resolution iranges.  The plan\nwas always to store the full irange between passes.  However, as was\noriginally discussed eons ago:\n\n\thttps://gcc.gnu.org/pipermail/gcc-patches/2017-May/475139.html\n\n...we need a memory efficient way of saving iranges, preferably using\nthe trailing_wide_ints idiom.\n\nThe problem with doing so is that trailing_wide_ints assume a\ncompile-time specified number of elements.  For irange, we need to\ndetermine the size at run-time.\n\nOne solution is to adapt trailing_wide_ints such that N is the maximum\nnumber of elements allowed, and allow setting the actual number at\nrun-time (defaulting to N).  The attached patch does this, while\nrequiring no changes to existing users.\n\nIt uses a byte to store the number of elements in the\ntrailing_wide_ints control word.  The control word is currently a\n16-bit precision, an 8-bit max-length, and the rest is used for\nm_len[N].  On a 64-bit architecture, this allows for 5 elements in\nm_len without having to use an extra word.  With this patch, m_len[]\nwould be smaller by one byte (4) before consuming the padding.  This\nshouldn't be a problem as the only users of trailing_wide_ints use N=2\nfor NUM_POLY_INT_COEFFS in aarch64, and N=3 for range_info_def.\n\nFor irange, my plan is to use one more word to fit a maximum of 12\nelements (the above 4 plus 8 more).  This would allow for 6 pairs of\nsub-ranges which would be more than adequate for our needs.  In\nprevious tests we found that 99% of ranges fit within 3-4 pairs.  More\nprecisely, this would allow for 5 pairs, plus the nonzero bits, plus a\nspare wide-int for future development.\n\nUltimately this means that streaming an irange would consume one more\nword than what we currently do for range_info_def.  IMO this is a nice\ntrade-off considering we started storing a slew of wide-ints directly\n;-).\n\nTested and benchmarked on x86-64 Linux.  There was no discernible\nperformance change in our benchmark suite.\n\ngcc/ChangeLog:\n\n\t* wide-int.h (struct trailing_wide_ints): Add m_num_elements.\n\t(trailing_wide_ints::set_precision): Add num_elements argument.\n\t(trailing_wide_ints::extra_size): Same.", "tree": {"sha": "3c3b90ec34c64887d7b3adff00dec25c6001a703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3b90ec34c64887d7b3adff00dec25c6001a703"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1697806fdf25285b924251b0d785324775e9b905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1697806fdf25285b924251b0d785324775e9b905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1697806fdf25285b924251b0d785324775e9b905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1697806fdf25285b924251b0d785324775e9b905/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a6ee426c2be3bd4359520e02c00ec60cac2fece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a6ee426c2be3bd4359520e02c00ec60cac2fece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a6ee426c2be3bd4359520e02c00ec60cac2fece"}], "stats": {"total": 42, "additions": 29, "deletions": 13}, "files": [{"sha": "d6807e3ef0244b0c01b89f54eb818429b4b76881", "filename": "gcc/wide-int.h", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1697806fdf25285b924251b0d785324775e9b905/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1697806fdf25285b924251b0d785324775e9b905/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=1697806fdf25285b924251b0d785324775e9b905", "patch": "@@ -1373,10 +1373,13 @@ namespace wi\n     : public int_traits <wide_int_storage> {};\n }\n \n-/* An array of N wide_int-like objects that can be put at the end of\n-   a variable-sized structure.  Use extra_size to calculate how many\n-   bytes beyond the sizeof need to be allocated.  Use set_precision\n-   to initialize the structure.  */\n+/* A variable-length array of wide_int-like objects that can be put\n+   at the end of a variable-sized structure.  The number of objects is\n+   at most N and can be set at runtime by using set_precision().\n+\n+   Use extra_size to calculate how many bytes beyond the\n+   sizeof need to be allocated.  Use set_precision to initialize the\n+   structure.  */\n template <int N>\n struct GTY((user)) trailing_wide_ints\n {\n@@ -1387,6 +1390,9 @@ struct GTY((user)) trailing_wide_ints\n   /* The shared maximum length of each number.  */\n   unsigned char m_max_len;\n \n+  /* The number of elements.  */\n+  unsigned char m_num_elements;\n+\n   /* The current length of each number.\n      Avoid char array so the whole structure is not a typeless storage\n      that will, in turn, turn off TBAA on gimple, trees and RTL.  */\n@@ -1399,12 +1405,15 @@ struct GTY((user)) trailing_wide_ints\n public:\n   typedef WIDE_INT_REF_FOR (trailing_wide_int_storage) const_reference;\n \n-  void set_precision (unsigned int);\n+  void set_precision (unsigned int precision, unsigned int num_elements = N);\n   unsigned int get_precision () const { return m_precision; }\n+  unsigned int num_elements () const { return m_num_elements; }\n   trailing_wide_int operator [] (unsigned int);\n   const_reference operator [] (unsigned int) const;\n-  static size_t extra_size (unsigned int);\n-  size_t extra_size () const { return extra_size (m_precision); }\n+  static size_t extra_size (unsigned int precision,\n+\t\t\t    unsigned int num_elements = N);\n+  size_t extra_size () const { return extra_size (m_precision,\n+\t\t\t\t\t\t  m_num_elements); }\n };\n \n inline trailing_wide_int_storage::\n@@ -1457,11 +1466,14 @@ trailing_wide_int_storage::operator = (const T &x)\n }\n \n /* Initialize the structure and record that all elements have precision\n-   PRECISION.  */\n+   PRECISION.  NUM_ELEMENTS can be no more than N.  */\n template <int N>\n inline void\n-trailing_wide_ints <N>::set_precision (unsigned int precision)\n+trailing_wide_ints <N>::set_precision (unsigned int precision,\n+\t\t\t\t       unsigned int num_elements)\n {\n+  gcc_checking_assert (num_elements <= N);\n+  m_num_elements = num_elements;\n   m_precision = precision;\n   m_max_len = ((precision + HOST_BITS_PER_WIDE_INT - 1)\n \t       / HOST_BITS_PER_WIDE_INT);\n@@ -1484,15 +1496,19 @@ trailing_wide_ints <N>::operator [] (unsigned int index) const\n \t\t\t  m_len[index].len, m_precision);\n }\n \n-/* Return how many extra bytes need to be added to the end of the structure\n-   in order to handle N wide_ints of precision PRECISION.  */\n+/* Return how many extra bytes need to be added to the end of the\n+   structure in order to handle NUM_ELEMENTS wide_ints of precision\n+   PRECISION.  NUM_ELEMENTS is the number of elements, and defaults\n+   to N.  */\n template <int N>\n inline size_t\n-trailing_wide_ints <N>::extra_size (unsigned int precision)\n+trailing_wide_ints <N>::extra_size (unsigned int precision,\n+\t\t\t\t    unsigned int num_elements)\n {\n   unsigned int max_len = ((precision + HOST_BITS_PER_WIDE_INT - 1)\n \t\t\t  / HOST_BITS_PER_WIDE_INT);\n-  return (N * max_len - 1) * sizeof (HOST_WIDE_INT);\n+  gcc_checking_assert (num_elements <= N);\n+  return (num_elements * max_len - 1) * sizeof (HOST_WIDE_INT);\n }\n \n /* This macro is used in structures that end with a trailing_wide_ints field"}]}