{"sha": "574284e9c49687d8bcc039165964602311decd2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc0Mjg0ZTljNDk2ODdkOGJjYzAzOTE2NTk2NDYwMjMxMWRlY2QyYg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-10-22T12:33:38Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-10-22T12:33:38Z"}, "message": "re PR fortran/43366 ([OOP][F08] Intrinsic assign to polymorphic variable)\n\ngcc/fortran/ChangeLog:\n\n2016-10-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/43366\n\tPR fortran/51864\n\tPR fortran/57117\n\tPR fortran/61337\n\tPR fortran/61376\n\t* primary.c (gfc_expr_attr): For transformational functions on classes\n\tget the attrs from the class argument.\n\t* resolve.c (resolve_ordinary_assign): Remove error message due to\n\tfeature implementation.  Rewrite POINTER_ASSIGNS to ordinary ones when\n\tthe right-hand side is scalar class object (with some restrictions).\n\t* trans-array.c (trans_array_constructor): Create the temporary from\n\tclass' inner type, i.e., the derived type.\n\t(build_class_array_ref): Add support for class array's storage of the\n\tclass object or the array descriptor in the decl saved descriptor.\n\t(gfc_conv_expr_descriptor): When creating temporaries for class objects\n\tadd the class object's handle into the decl saved descriptor.\n\t(structure_alloc_comps): Use the common way to get the _data component.\n\t(gfc_is_reallocatable_lhs): Add notion of allocatable class objects.\n\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Remove the only ref\n\tonly when the expression's type is BT_CLASS.\n\t(gfc_trans_class_init_assign): Correctly handle class arrays.\n\t(gfc_trans_class_assign): Joined into gfc_trans_assignment_1.\n\t(gfc_conv_procedure_call): Support for class types as arguments.\n\t(trans_get_upoly_len): For unlimited polymorphics retrieve the _len\n\tcomponent's tree.\n\t(trans_class_vptr_len_assignment): Catch all ways to assign the _vptr\n\tand _len components of a class object correctly.\n\t(pointer_assignment_is_proc_pointer): Identify assignments of\n\tprocedure pointers.\n\t(gfc_trans_pointer_assignment): Enhance support for class object pointer\n\tassignments.\n\t(gfc_trans_scalar_assign): Removed assert.\n\t(trans_class_assignment): Assign to a class object.\n\t(gfc_trans_assignment_1): Treat class objects correctly.\n\t(gfc_trans_assignment): Propagate flags to trans_assignment_1.\n\t* trans-stmt.c (gfc_trans_allocate): Use gfc_trans_assignment now\n\tinstead of copy_class_to_class.\n\t* trans-stmt.h: Function prototype removed.\n\t* trans.c (trans_code): Less special casing for class objects.\n\t* trans.h: Added flags to gfc_trans_assignment () prototype.\n\ngcc/testsuite/ChangeLog:\n\n2016-10-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n        Forgot to add on original commit.\n        * gfortran.dg/coarray_alloc_comp_2.f08: New test.\n\n2016-10-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/43366\n\tPR fortran/57117\n\tPR fortran/61337\n\t* gfortran.dg/alloc_comp_class_5.f03: New test.\n\t* gfortran.dg/class_allocate_21.f90: New test.\n\t* gfortran.dg/class_allocate_22.f90: New test.\n\t* gfortran.dg/realloc_on_assign_27.f08: New test.\n\nFrom-SVN: r241439", "tree": {"sha": "8ad33cbaa398ee285a2936428641861d6df822e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ad33cbaa398ee285a2936428641861d6df822e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/574284e9c49687d8bcc039165964602311decd2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574284e9c49687d8bcc039165964602311decd2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574284e9c49687d8bcc039165964602311decd2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574284e9c49687d8bcc039165964602311decd2b/comments", "author": null, "committer": null, "parents": [{"sha": "4e04812da209203a10fbb7197502dd5b8a00459c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e04812da209203a10fbb7197502dd5b8a00459c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e04812da209203a10fbb7197502dd5b8a00459c"}], "stats": {"total": 1339, "additions": 904, "deletions": 435}, "files": [{"sha": "406ebb32e936f8a4d5b31ba52c57a7899cf3599a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -1,3 +1,46 @@\n+2016-10-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/43366\n+\tPR fortran/51864\n+\tPR fortran/57117\n+\tPR fortran/61337\n+\tPR fortran/61376\n+\t* primary.c (gfc_expr_attr): For transformational functions on classes\n+\tget the attrs from the class argument.\n+\t* resolve.c (resolve_ordinary_assign): Remove error message due to\n+\tfeature implementation.  Rewrite POINTER_ASSIGNS to ordinary ones when\n+\tthe right-hand side is scalar class object (with some restrictions).\n+\t* trans-array.c (trans_array_constructor): Create the temporary from\n+\tclass' inner type, i.e., the derived type.\n+\t(build_class_array_ref): Add support for class array's storage of the\n+\tclass object or the array descriptor in the decl saved descriptor.\n+\t(gfc_conv_expr_descriptor): When creating temporaries for class objects\n+\tadd the class object's handle into the decl saved descriptor.\n+\t(structure_alloc_comps): Use the common way to get the _data component.\n+\t(gfc_is_reallocatable_lhs): Add notion of allocatable class objects.\n+\t* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Remove the only ref\n+\tonly when the expression's type is BT_CLASS.\n+\t(gfc_trans_class_init_assign): Correctly handle class arrays.\n+\t(gfc_trans_class_assign): Joined into gfc_trans_assignment_1.\n+\t(gfc_conv_procedure_call): Support for class types as arguments.\n+\t(trans_get_upoly_len): For unlimited polymorphics retrieve the _len\n+\tcomponent's tree.\n+\t(trans_class_vptr_len_assignment): Catch all ways to assign the _vptr\n+\tand _len components of a class object correctly.\n+\t(pointer_assignment_is_proc_pointer): Identify assignments of\n+\tprocedure pointers.\n+\t(gfc_trans_pointer_assignment): Enhance support for class object pointer\n+\tassignments.\n+\t(gfc_trans_scalar_assign): Removed assert.\n+\t(trans_class_assignment): Assign to a class object.\n+\t(gfc_trans_assignment_1): Treat class objects correctly.\n+\t(gfc_trans_assignment): Propagate flags to trans_assignment_1.\n+\t* trans-stmt.c (gfc_trans_allocate): Use gfc_trans_assignment now\n+\tinstead of copy_class_to_class.\n+\t* trans-stmt.h: Function prototype removed.\n+\t* trans.c (trans_code): Less special casing for class objects.\n+\t* trans.h: Added flags to gfc_trans_assignment () prototype.\n+\n 2016-10-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69566"}, {"sha": "3803b88935453502587336687b5ffaedcf51641c", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -2359,6 +2359,10 @@ gfc_expr_attr (gfc_expr *e)\n \t      attr.allocatable = CLASS_DATA (sym)->attr.allocatable;\n \t    }\n \t}\n+      else if (e->value.function.isym\n+\t       && e->value.function.isym->transformational\n+\t       && e->ts.type == BT_CLASS)\n+\tattr = CLASS_DATA (e)->attr;\n       else\n \tattr = gfc_variable_attr (e, NULL);\n "}, {"sha": "6dae6fbb7714e1ac93db3e128b1d7b636305933b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -9911,10 +9911,6 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t\t     \"requires %<-frealloc-lhs%>\", &lhs->where);\n \t  return false;\n \t}\n-      /* See PR 43366.  */\n-      gfc_error (\"Assignment to an allocatable polymorphic variable at %L \"\n-\t\t \"is not yet supported\", &lhs->where);\n-      return false;\n     }\n   else if (lhs->ts.type == BT_CLASS)\n     {\n@@ -10817,6 +10813,19 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      break;\n \n \t    gfc_check_pointer_assign (code->expr1, code->expr2);\n+\n+\t    /* Assigning a class object always is a regular assign.  */\n+\t    if (code->expr2->ts.type == BT_CLASS\n+\t\t&& !CLASS_DATA (code->expr2)->attr.dimension\n+\t\t&& !(UNLIMITED_POLY (code->expr2)\n+\t\t     && code->expr1->ts.type == BT_DERIVED\n+\t\t     && (code->expr1->ts.u.derived->attr.sequence\n+\t\t\t || code->expr1->ts.u.derived->attr.is_bind_c))\n+\t\t&& !(gfc_expr_attr (code->expr1).proc_pointer\n+\t\t     && code->expr2->expr_type == EXPR_VARIABLE\n+\t\t     && code->expr2->symtree->n.sym->attr.flavor\n+\t\t\t== FL_PROCEDURE))\n+\t      code->op = EXEC_ASSIGN;\n \t    break;\n \t  }\n "}, {"sha": "c59e8727f3d946de3cd7ee99488a711cc4627ccd", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 91, "deletions": 34, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -2292,7 +2292,8 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \ttype = build_pointer_type (type);\n     }\n   else\n-    type = gfc_typenode_for_spec (&expr->ts);\n+    type = gfc_typenode_for_spec (expr->ts.type == BT_CLASS\n+\t\t\t\t  ? &CLASS_DATA (expr)->ts : &expr->ts);\n \n   /* See if the constructor determines the loop bounds.  */\n   dynamic = false;\n@@ -3036,50 +3037,57 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n   tree type;\n   tree size;\n   tree offset;\n-  tree decl;\n+  tree decl = NULL_TREE;\n   tree tmp;\n   gfc_expr *expr = se->ss->info->expr;\n   gfc_ref *ref;\n-  gfc_ref *class_ref;\n+  gfc_ref *class_ref = NULL;\n   gfc_typespec *ts;\n \n-  if (expr == NULL\n-      || (expr->ts.type != BT_CLASS\n-\t  && !gfc_is_alloc_class_array_function (expr)))\n-    return false;\n-\n-  if (expr->symtree && expr->symtree->n.sym->ts.type == BT_CLASS)\n-    ts = &expr->symtree->n.sym->ts;\n+  if (se->expr && DECL_P (se->expr) && DECL_LANG_SPECIFIC (se->expr)\n+      && GFC_DECL_SAVED_DESCRIPTOR (se->expr)\n+      && GFC_CLASS_TYPE_P (TREE_TYPE (GFC_DECL_SAVED_DESCRIPTOR (se->expr))))\n+    decl = se->expr;\n   else\n-    ts = NULL;\n-  class_ref = NULL;\n-\n-  for (ref = expr->ref; ref; ref = ref->next)\n     {\n-      if (ref->type == REF_COMPONENT\n-\t    && ref->u.c.component->ts.type == BT_CLASS\n-\t    && ref->next && ref->next->type == REF_COMPONENT\n-\t    && strcmp (ref->next->u.c.component->name, \"_data\") == 0\n-\t    && ref->next->next\n-\t    && ref->next->next->type == REF_ARRAY\n-\t    && ref->next->next->u.ar.type != AR_ELEMENT)\n+      if (expr == NULL\n+\t  || (expr->ts.type != BT_CLASS\n+\t      && !gfc_is_alloc_class_array_function (expr)\n+\t      && !gfc_is_class_array_ref (expr, NULL)))\n+\treturn false;\n+\n+      if (expr->symtree && expr->symtree->n.sym->ts.type == BT_CLASS)\n+\tts = &expr->symtree->n.sym->ts;\n+      else\n+\tts = NULL;\n+\n+      for (ref = expr->ref; ref; ref = ref->next)\n \t{\n-\t  ts = &ref->u.c.component->ts;\n-\t  class_ref = ref;\n-\t  break;\n+\t  if (ref->type == REF_COMPONENT\n+\t      && ref->u.c.component->ts.type == BT_CLASS\n+\t      && ref->next && ref->next->type == REF_COMPONENT\n+\t      && strcmp (ref->next->u.c.component->name, \"_data\") == 0\n+\t      && ref->next->next\n+\t      && ref->next->next->type == REF_ARRAY\n+\t      && ref->next->next->u.ar.type != AR_ELEMENT)\n+\t    {\n+\t      ts = &ref->u.c.component->ts;\n+\t      class_ref = ref;\n+\t      break;\n+\t    }\n \t}\n-    }\n \n-  if (ts == NULL)\n-    return false;\n+      if (ts == NULL)\n+\treturn false;\n+    }\n \n-  if (class_ref == NULL && expr->symtree->n.sym->attr.function\n+  if (class_ref == NULL && expr && expr->symtree->n.sym->attr.function\n       && expr->symtree->n.sym == expr->symtree->n.sym->result)\n     {\n       gcc_assert (expr->symtree->n.sym->backend_decl == current_function_decl);\n       decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);\n     }\n-  else if (gfc_is_alloc_class_array_function (expr))\n+  else if (expr && gfc_is_alloc_class_array_function (expr))\n     {\n       size = NULL_TREE;\n       decl = NULL_TREE;\n@@ -3105,7 +3113,8 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n     }\n   else if (class_ref == NULL)\n     {\n-      decl = expr->symtree->n.sym->backend_decl;\n+      if (decl == NULL_TREE)\n+\tdecl = expr->symtree->n.sym->backend_decl;\n       /* For class arrays the tree containing the class is stored in\n \t GFC_DECL_SAVED_DESCRIPTOR of the sym's backend_decl.\n \t For all others it's sym's backend_decl directly.  */\n@@ -3121,6 +3130,7 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n       class_ref->next = NULL;\n       gfc_init_se (&tmpse, NULL);\n       gfc_conv_expr (&tmpse, expr);\n+      gfc_add_block_to_block (&se->pre, &tmpse.pre);\n       decl = tmpse.expr;\n       class_ref->next = ref;\n     }\n@@ -7094,6 +7104,28 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t\t\tloop.from, loop.to, 0,\n \t\t\t\t\t\tGFC_ARRAY_UNKNOWN, false);\n \t  parm = gfc_create_var (parmtype, \"parm\");\n+\n+\t  /* When expression is a class object, then add the class' handle to\n+\t     the parm_decl.  */\n+\t  if (expr->ts.type == BT_CLASS && expr->expr_type == EXPR_VARIABLE)\n+\t    {\n+\t      gfc_expr *class_expr = gfc_find_and_cut_at_last_class_ref (expr);\n+\t      gfc_se classse;\n+\n+\t      /* class_expr can be NULL, when no _class ref is in expr.\n+\t\t We must not fix this here with a gfc_fix_class_ref ().  */\n+\t      if (class_expr)\n+\t\t{\n+\t\t  gfc_init_se (&classse, NULL);\n+\t\t  gfc_conv_expr (&classse, class_expr);\n+\t\t  gfc_free_expr (class_expr);\n+\n+\t\t  gcc_assert (classse.pre.head == NULL_TREE\n+\t\t\t      && classse.post.head == NULL_TREE);\n+\t\t  gfc_allocate_lang_decl (parm);\n+\t\t  GFC_DECL_SAVED_DESCRIPTOR (parm) = classse.expr;\n+\t\t}\n+\t    }\n \t}\n \n       offset = gfc_index_zero_node;\n@@ -7255,6 +7287,13 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t      : base;\n \t  gfc_conv_descriptor_offset_set (&loop.pre, parm, tmp);\n \t}\n+      else if (IS_CLASS_ARRAY (expr) && !se->data_not_needed\n+\t       && (!rank_remap || se->use_offset)\n+\t       && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+\t{\n+\t  gfc_conv_descriptor_offset_set (&loop.pre, parm,\n+\t\t\t\t\t gfc_conv_descriptor_offset_get (desc));\n+\t}\n       else if (onebased && (!rank_remap || se->use_offset)\n \t  && expr->symtree\n \t  && !(expr->symtree->n.sym && expr->symtree->n.sym->ts.type == BT_CLASS\n@@ -7290,6 +7329,18 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t    GFC_DECL_SAVED_DESCRIPTOR (expr->symtree->n.sym->backend_decl)\n \t  : expr->symtree->n.sym->backend_decl;\n     }\n+  else if (expr->expr_type == EXPR_ARRAY && VAR_P (desc)\n+\t   && IS_CLASS_ARRAY (expr))\n+    {\n+      tree vtype;\n+      gfc_allocate_lang_decl (desc);\n+      tmp = gfc_create_var (expr->ts.u.derived->backend_decl, \"class\");\n+      GFC_DECL_SAVED_DESCRIPTOR (desc) = tmp;\n+      vtype = gfc_class_vptr_get (tmp);\n+      gfc_add_modify (&se->pre, vtype,\n+\t\t      gfc_build_addr_expr (TREE_TYPE (vtype),\n+\t\t\t\t      gfc_find_vtab (&expr->ts)->backend_decl));\n+    }\n   if (!se->direct_byref || se->byref_noassign)\n     {\n       /* Get a pointer to the new descriptor.  */\n@@ -8200,10 +8251,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      /* Allocatable CLASS components.  */\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n-\t      /* Add reference to '_data' component.  */\n-\t      tmp = CLASS_DATA (c)->backend_decl;\n-\t      comp = fold_build3_loc (input_location, COMPONENT_REF,\n-\t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n+\n+\t      comp = gfc_class_data_get (comp);\n \t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n \t\tgfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n \t      else\n@@ -8541,6 +8590,14 @@ gfc_is_reallocatable_lhs (gfc_expr *expr)\n   if (!expr->ref)\n     return false;\n \n+  /* An allocatable class variable with no reference.  */\n+  if (expr->symtree->n.sym->ts.type == BT_CLASS\n+      && CLASS_DATA (expr->symtree->n.sym)->attr.allocatable\n+      && expr->ref && expr->ref->type == REF_COMPONENT\n+      && strcmp (expr->ref->u.c.component->name, \"_data\") == 0\n+      && expr->ref->next == NULL)\n+    return true;\n+\n   /* An allocatable variable.  */\n   if (expr->symtree->n.sym->attr.allocatable\n \t&& expr->ref"}, {"sha": "fc03a23d9ed546f62142ee198f53850e371fb1ad", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 392, "deletions": 170, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -350,7 +350,7 @@ gfc_expr *\n gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n {\n   gfc_expr *base_expr;\n-  gfc_ref *ref, *class_ref, *tail, *array_ref;\n+  gfc_ref *ref, *class_ref, *tail = NULL, *array_ref;\n \n   /* Find the last class reference.  */\n   class_ref = NULL;\n@@ -383,7 +383,7 @@ gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n       tail = class_ref->next;\n       class_ref->next = NULL;\n     }\n-  else\n+  else if (e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n     {\n       tail = e->ref;\n       e->ref = NULL;\n@@ -397,7 +397,7 @@ gfc_find_and_cut_at_last_class_ref (gfc_expr *e)\n       gfc_free_ref_list (class_ref->next);\n       class_ref->next = tail;\n     }\n-  else\n+  else if (e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n     {\n       gfc_free_ref_list (e->ref);\n       e->ref = tail;\n@@ -1458,7 +1458,12 @@ gfc_trans_class_init_assign (gfc_code *code)\n \n   if (code->expr1->ts.type == BT_CLASS\n       && CLASS_DATA (code->expr1)->attr.dimension)\n-    tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);\n+    {\n+      gfc_array_spec *tmparr = gfc_get_array_spec ();\n+      *tmparr = *CLASS_DATA (code->expr1)->as;\n+      gfc_add_full_array_ref (lhs, tmparr);\n+      tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);\n+    }\n   else\n     {\n       sz = gfc_copy_expr (code->expr1);\n@@ -1503,114 +1508,6 @@ gfc_trans_class_init_assign (gfc_code *code)\n }\n \n \n-/* Translate an assignment to a CLASS object\n-   (pointer or ordinary assignment).  */\n-\n-tree\n-gfc_trans_class_assign (gfc_expr *expr1, gfc_expr *expr2, gfc_exec_op op)\n-{\n-  stmtblock_t block;\n-  tree tmp;\n-  gfc_expr *lhs;\n-  gfc_expr *rhs;\n-  gfc_ref *ref;\n-\n-  gfc_start_block (&block);\n-\n-  ref = expr1->ref;\n-  while (ref && ref->next)\n-     ref = ref->next;\n-\n-  /* Class valued proc_pointer assignments do not need any further\n-     preparation.  */\n-  if (ref && ref->type == REF_COMPONENT\n-\t&& ref->u.c.component->attr.proc_pointer\n-\t&& expr2->expr_type == EXPR_VARIABLE\n-\t&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE\n-\t&& op == EXEC_POINTER_ASSIGN)\n-    goto assign;\n-\n-  if (expr2->ts.type != BT_CLASS)\n-    {\n-      /* Insert an additional assignment which sets the '_vptr' field.  */\n-      gfc_symbol *vtab = NULL;\n-      gfc_symtree *st;\n-\n-      lhs = gfc_copy_expr (expr1);\n-      gfc_add_vptr_component (lhs);\n-\n-      if (UNLIMITED_POLY (expr1)\n-\t  && expr2->expr_type == EXPR_NULL && expr2->ts.type == BT_UNKNOWN)\n-\t{\n-\t  rhs = gfc_get_null_expr (&expr2->where);\n- \t  goto assign_vptr;\n-\t}\n-\n-      if (expr2->expr_type == EXPR_NULL)\n-\tvtab = gfc_find_vtab (&expr1->ts);\n-      else\n-\tvtab = gfc_find_vtab (&expr2->ts);\n-      gcc_assert (vtab);\n-\n-      rhs = gfc_get_expr ();\n-      rhs->expr_type = EXPR_VARIABLE;\n-      gfc_find_sym_tree (vtab->name, vtab->ns, 1, &st);\n-      rhs->symtree = st;\n-      rhs->ts = vtab->ts;\n-assign_vptr:\n-      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      gfc_free_expr (lhs);\n-      gfc_free_expr (rhs);\n-    }\n-  else if (expr1->ts.type == BT_DERIVED && UNLIMITED_POLY (expr2))\n-    {\n-      /* F2003:C717 only sequence and bind-C types can come here.  */\n-      gcc_assert (expr1->ts.u.derived->attr.sequence\n-\t\t  || expr1->ts.u.derived->attr.is_bind_c);\n-      gfc_add_data_component (expr2);\n-      goto assign;\n-    }\n-  else if (CLASS_DATA (expr2)->attr.dimension && expr2->expr_type != EXPR_FUNCTION)\n-    {\n-      /* Insert an additional assignment which sets the '_vptr' field.  */\n-      lhs = gfc_copy_expr (expr1);\n-      gfc_add_vptr_component (lhs);\n-\n-      rhs = gfc_copy_expr (expr2);\n-      gfc_add_vptr_component (rhs);\n-\n-      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      gfc_free_expr (lhs);\n-      gfc_free_expr (rhs);\n-    }\n-\n-  /* Do the actual CLASS assignment.  */\n-  if (expr2->ts.type == BT_CLASS\n-      && !CLASS_DATA (expr2)->attr.dimension)\n-    op = EXEC_ASSIGN;\n-  else if (expr2->expr_type != EXPR_FUNCTION || expr2->ts.type != BT_CLASS\n-\t   || !CLASS_DATA (expr2)->attr.dimension)\n-    gfc_add_data_component (expr1);\n-\n-assign:\n-\n-  if (op == EXEC_ASSIGN)\n-    tmp = gfc_trans_assignment (expr1, expr2, false, true);\n-  else if (op == EXEC_POINTER_ASSIGN)\n-    tmp = gfc_trans_pointer_assignment (expr1, expr2);\n-  else\n-    gcc_unreachable();\n-\n-  gfc_add_expr_to_block (&block, tmp);\n-\n-  return gfc_finish_block (&block);\n-}\n-\n-\n /* End of prototype trans-class.c  */\n \n \n@@ -5908,6 +5805,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n   if (comp)\n     ts = comp->ts;\n+  else if (sym->ts.type == BT_CLASS)\n+    ts = CLASS_DATA (sym)->ts;\n   else\n     ts = sym->ts;\n \n@@ -5978,7 +5877,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t&& GFC_DESCRIPTOR_TYPE_P\n \t\t\t(TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr)))))\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n+\t\t\t\t\t\t    se->expr);\n \n \t  /* If the lhs of an assignment x = f(..) is allocatable and\n \t     f2003 is allowed, we must do the automatic reallocation.\n@@ -6264,6 +6163,26 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t}\n     }\n \n+  /* Associate the rhs class object's meta-data with the result, when the\n+     result is a temporary.  */\n+  if (args && args->expr && args->expr->ts.type == BT_CLASS\n+      && sym->ts.type == BT_CLASS && result != NULL_TREE && DECL_P (result)\n+      && !GFC_CLASS_TYPE_P (TREE_TYPE (result)))\n+    {\n+      gfc_se parmse;\n+      gfc_expr *class_expr = gfc_find_and_cut_at_last_class_ref (args->expr);\n+\n+      gfc_init_se (&parmse, NULL);\n+      parmse.data_not_needed = 1;\n+      gfc_conv_expr (&parmse, class_expr);\n+      if (!DECL_LANG_SPECIFIC (result))\n+\tgfc_allocate_lang_decl (result);\n+      GFC_DECL_SAVED_DESCRIPTOR (result) = parmse.expr;\n+      gfc_free_expr (class_expr);\n+      gcc_assert (parmse.pre.head == NULL_TREE\n+\t\t  && parmse.post.head == NULL_TREE);\n+    }\n+\n   /* Follow the function call with the argument post block.  */\n   if (byref)\n     {\n@@ -7886,6 +7805,201 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n }\n \n \n+/* Get the _len component for an unlimited polymorphic expression.  */\n+\n+static tree\n+trans_get_upoly_len (stmtblock_t *block, gfc_expr *expr)\n+{\n+  gfc_se se;\n+  gfc_ref *ref = expr->ref;\n+\n+  gfc_init_se (&se, NULL);\n+  while (ref && ref->next)\n+    ref = ref->next;\n+  gfc_add_len_component (expr);\n+  gfc_conv_expr (&se, expr);\n+  gfc_add_block_to_block (block, &se.pre);\n+  gcc_assert (se.post.head == NULL_TREE);\n+  if (ref)\n+    {\n+      gfc_free_ref_list (ref->next);\n+      ref->next = NULL;\n+    }\n+  else\n+    {\n+      gfc_free_ref_list (expr->ref);\n+      expr->ref = NULL;\n+    }\n+  return se.expr;\n+}\n+\n+\n+/* Assign _vptr and _len components as appropriate.  BLOCK should be a\n+   statement-list outside of the scalarizer-loop.  When code is generated, that\n+   depends on the scalarized expression, it is added to RSE.PRE.\n+   Returns le's _vptr tree and when set the len expressions in to_lenp and\n+   from_lenp to form a le%_vptr%_copy (re, le, [from_lenp, to_lenp])\n+   expression.  */\n+\n+static tree\n+trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n+\t\t\t\t gfc_expr * re, gfc_se *rse,\n+\t\t\t\t tree * to_lenp, tree * from_lenp)\n+{\n+  gfc_se se;\n+  gfc_expr * vptr_expr;\n+  tree tmp, to_len = NULL_TREE, from_len = NULL_TREE, lhs_vptr;\n+  bool set_vptr = false, temp_rhs = false;\n+  stmtblock_t *pre = block;\n+\n+  /* Create a temporary for complicated expressions.  */\n+  if (re->expr_type != EXPR_VARIABLE && re->expr_type != EXPR_NULL\n+      && rse->expr != NULL_TREE && !DECL_P (rse->expr))\n+    {\n+      tmp = gfc_create_var (TREE_TYPE (rse->expr), \"rhs\");\n+      pre = &rse->pre;\n+      gfc_add_modify (&rse->pre, tmp, rse->expr);\n+      rse->expr = tmp;\n+      temp_rhs = true;\n+    }\n+\n+  /* Get the _vptr for the left-hand side expression.  */\n+  gfc_init_se (&se, NULL);\n+  vptr_expr = gfc_find_and_cut_at_last_class_ref (le);\n+  if (vptr_expr != NULL && gfc_expr_attr (vptr_expr).class_ok)\n+    {\n+      /* Care about _len for unlimited polymorphic entities.  */\n+      if (UNLIMITED_POLY (vptr_expr)\n+\t  || (vptr_expr->ts.type == BT_DERIVED\n+\t      && vptr_expr->ts.u.derived->attr.unlimited_polymorphic))\n+\tto_len = trans_get_upoly_len (block, vptr_expr);\n+      gfc_add_vptr_component (vptr_expr);\n+      set_vptr = true;\n+    }\n+  else\n+    vptr_expr = gfc_lval_expr_from_sym (gfc_find_vtab (&le->ts));\n+  se.want_pointer = 1;\n+  gfc_conv_expr (&se, vptr_expr);\n+  gfc_free_expr (vptr_expr);\n+  gfc_add_block_to_block (block, &se.pre);\n+  gcc_assert (se.post.head == NULL_TREE);\n+  lhs_vptr = se.expr;\n+  STRIP_NOPS (lhs_vptr);\n+\n+  /* Set the _vptr only when the left-hand side of the assignment is a\n+     class-object.  */\n+  if (set_vptr)\n+    {\n+      /* Get the vptr from the rhs expression only, when it is variable.\n+\t Functions are expected to be assigned to a temporary beforehand.  */\n+      vptr_expr = re->expr_type == EXPR_VARIABLE\n+\t  ? gfc_find_and_cut_at_last_class_ref (re)\n+\t  : NULL;\n+      if (vptr_expr != NULL && vptr_expr->ts.type == BT_CLASS)\n+\t{\n+\t  if (to_len != NULL_TREE)\n+\t    {\n+\t      /* Get the _len information from the rhs.  */\n+\t      if (UNLIMITED_POLY (vptr_expr)\n+\t\t  || (vptr_expr->ts.type == BT_DERIVED\n+\t\t      && vptr_expr->ts.u.derived->attr.unlimited_polymorphic))\n+\t\tfrom_len = trans_get_upoly_len (block, vptr_expr);\n+\t    }\n+\t  gfc_add_vptr_component (vptr_expr);\n+\t}\n+      else\n+\t{\n+\t  if (re->expr_type == EXPR_VARIABLE\n+\t      && DECL_P (re->symtree->n.sym->backend_decl)\n+\t      && DECL_LANG_SPECIFIC (re->symtree->n.sym->backend_decl)\n+\t      && GFC_DECL_SAVED_DESCRIPTOR (re->symtree->n.sym->backend_decl)\n+\t      && GFC_CLASS_TYPE_P (TREE_TYPE (GFC_DECL_SAVED_DESCRIPTOR (\n+\t\t\t\t\t   re->symtree->n.sym->backend_decl))))\n+\t    {\n+\t      vptr_expr = NULL;\n+\t      se.expr = gfc_class_vptr_get (GFC_DECL_SAVED_DESCRIPTOR (\n+\t\t\t\t\t     re->symtree->n.sym->backend_decl));\n+\t      if (to_len)\n+\t\tfrom_len = gfc_class_len_get (GFC_DECL_SAVED_DESCRIPTOR (\n+\t\t\t\t\t     re->symtree->n.sym->backend_decl));\n+\t    }\n+\t  else if (temp_rhs && re->ts.type == BT_CLASS)\n+\t    {\n+\t      vptr_expr = NULL;\n+\t      se.expr = gfc_class_vptr_get (rse->expr);\n+\t    }\n+\t  else if (re->expr_type != EXPR_NULL)\n+\t    /* Only when rhs is non-NULL use its declared type for vptr\n+\t       initialisation.  */\n+\t    vptr_expr = gfc_lval_expr_from_sym (gfc_find_vtab (&re->ts));\n+\t  else\n+\t    /* When the rhs is NULL use the vtab of lhs' declared type.  */\n+\t    vptr_expr = gfc_lval_expr_from_sym (gfc_find_vtab (&le->ts));\n+\t}\n+\n+      if (vptr_expr)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  se.want_pointer = 1;\n+\t  gfc_conv_expr (&se, vptr_expr);\n+\t  gfc_free_expr (vptr_expr);\n+\t  gfc_add_block_to_block (block, &se.pre);\n+\t  gcc_assert (se.post.head == NULL_TREE);\n+\t}\n+      gfc_add_modify (pre, lhs_vptr, fold_convert (TREE_TYPE (lhs_vptr),\n+\t\t\t\t\t\tse.expr));\n+\n+      if (to_len != NULL_TREE)\n+\t{\n+\t  /* The _len component needs to be set.  Figure how to get the\n+\t     value of the right-hand side.  */\n+\t  if (from_len == NULL_TREE)\n+\t    {\n+\t      if (rse->string_length != NULL_TREE)\n+\t\tfrom_len = rse->string_length;\n+\t      else if (re->ts.type == BT_CHARACTER && re->ts.u.cl->length)\n+\t\t{\n+\t\t  from_len = gfc_get_expr_charlen (re);\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  gfc_conv_expr (&se, re->ts.u.cl->length);\n+\t\t  gfc_add_block_to_block (block, &se.pre);\n+\t\t  gcc_assert (se.post.head == NULL_TREE);\n+\t\t  from_len = gfc_evaluate_now (se.expr, block);\n+\t\t}\n+\t      else\n+\t\tfrom_len = integer_zero_node;\n+\t    }\n+\t  gfc_add_modify (pre, to_len, fold_convert (TREE_TYPE (to_len),\n+\t\t\t\t\t\t     from_len));\n+\t}\n+    }\n+\n+  /* Return the _len trees only, when requested.  */\n+  if (to_lenp)\n+    *to_lenp = to_len;\n+  if (from_lenp)\n+    *from_lenp = from_len;\n+  return lhs_vptr;\n+}\n+\n+/* Indentify class valued proc_pointer assignments.  */\n+\n+static bool\n+pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)\n+{\n+  gfc_ref * ref;\n+\n+  ref = expr1->ref;\n+  while (ref && ref->next)\n+     ref = ref->next;\n+\n+  return ref && ref->type == REF_COMPONENT\n+      && ref->u.c.component->attr.proc_pointer\n+      && expr2->expr_type == EXPR_VARIABLE\n+      && expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE;\n+}\n+\n+\n tree\n gfc_trans_pointer_assign (gfc_code * code)\n {\n@@ -7898,20 +8012,22 @@ gfc_trans_pointer_assign (gfc_code * code)\n tree\n gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n {\n-  gfc_expr *expr1_vptr = NULL;\n   gfc_se lse;\n   gfc_se rse;\n   stmtblock_t block;\n   tree desc;\n   tree tmp;\n   tree decl;\n-  bool scalar;\n+  bool scalar, non_proc_pointer_assign;\n   gfc_ss *ss;\n \n   gfc_start_block (&block);\n \n   gfc_init_se (&lse, NULL);\n \n+  /* Usually testing whether this is not a proc pointer assignment.  */\n+  non_proc_pointer_assign = !pointer_assignment_is_proc_pointer (expr1, expr2);\n+\n   /* Check whether the expression is a scalar or not; we cannot use\n      expr1->rank as it can be nonzero for proc pointers.  */\n   ss = gfc_walk_expr (expr1);\n@@ -7920,7 +8036,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     gfc_free_ss_chain (ss);\n \n   if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS\n-      && expr2->expr_type != EXPR_FUNCTION)\n+      && expr2->expr_type != EXPR_FUNCTION && non_proc_pointer_assign)\n     {\n       gfc_add_data_component (expr2);\n       /* The following is required as gfc_add_data_component doesn't\n@@ -7937,6 +8053,13 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       rse.want_pointer = 1;\n       gfc_conv_expr (&rse, expr2);\n \n+      if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)\n+\t{\n+\t  trans_class_vptr_len_assignment (&block, expr1, expr2, &rse, NULL,\n+\t\t\t\t\t   NULL);\n+\t  lse.expr = gfc_class_data_get (lse.expr);\n+\t}\n+\n       if (expr1->symtree->n.sym->attr.proc_pointer\n \t  && expr1->symtree->n.sym->attr.dummy)\n \tlse.expr = build_fold_indirect_ref_loc (input_location,\n@@ -7950,27 +8073,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n \n-      /* For string assignments to unlimited polymorphic pointers add an\n-\t assignment of the string_length to the _len component of the\n-\t pointer.  */\n-      if ((expr1->ts.type == BT_CLASS || expr1->ts.type == BT_DERIVED)\n-\t  && expr1->ts.u.derived->attr.unlimited_polymorphic\n-\t  && (expr2->ts.type == BT_CHARACTER ||\n-\t      ((expr2->ts.type == BT_DERIVED || expr2->ts.type == BT_CLASS)\n-\t       && expr2->ts.u.derived->attr.unlimited_polymorphic)))\n-\t{\n-\t  gfc_expr *len_comp;\n-\t  gfc_se se;\n-\t  len_comp = gfc_get_len_component (expr1);\n-\t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr (&se, len_comp);\n-\n-\t  /* ptr % _len = len (str)  */\n-\t  gfc_add_modify (&block, se.expr, rse.string_length);\n-\t  lse.string_length = se.expr;\n-\t  gfc_free_expr (len_comp);\n-\t}\n-\n       /* Check character lengths if character expression.  The test is only\n \t really added if -fbounds-check is enabled.  Exclude deferred\n \t character length lefthand sides.  */\n@@ -7997,9 +8099,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t\t    build_int_cst (gfc_charlen_type_node, 0));\n \t}\n \n-      if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS)\n-\trse.expr = gfc_class_data_get (rse.expr);\n-\n       gfc_add_modify (&block, lse.expr,\n \t\t      fold_convert (TREE_TYPE (lse.expr), rse.expr));\n \n@@ -8010,6 +8109,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     {\n       gfc_ref* remap;\n       bool rank_remap;\n+      tree expr1_vptr = NULL_TREE;\n       tree strlen_lhs;\n       tree strlen_rhs = NULL_TREE;\n \n@@ -8026,9 +8126,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_init_se (&lse, NULL);\n       if (remap)\n \tlse.descriptor_only = 1;\n-      if (expr2->expr_type == EXPR_FUNCTION && expr2->ts.type == BT_CLASS\n-\t  && expr1->ts.type == BT_CLASS)\n-\texpr1_vptr = gfc_copy_expr (expr1);\n       gfc_conv_expr_descriptor (&lse, expr1);\n       strlen_lhs = lse.string_length;\n       desc = lse.expr;\n@@ -8054,16 +8151,15 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\trse.expr = gfc_class_data_get (rse.expr);\n \t      else\n \t\t{\n+\t\t  expr1_vptr = trans_class_vptr_len_assignment (&block, expr1,\n+\t\t\t\t\t\t\t\texpr2, &rse,\n+\t\t\t\t\t\t\t\tNULL, NULL);\n \t\t  gfc_add_block_to_block (&block, &rse.pre);\n \t\t  tmp = gfc_create_var (TREE_TYPE (rse.expr), \"ptrtemp\");\n \t\t  gfc_add_modify (&lse.pre, tmp, rse.expr);\n \n-\t\t  gfc_add_vptr_component (expr1_vptr);\n-\t\t  gfc_init_se (&rse, NULL);\n-\t\t  rse.want_pointer = 1;\n-\t\t  gfc_conv_expr (&rse, expr1_vptr);\n-\t\t  gfc_add_modify (&lse.pre, rse.expr,\n-\t\t\t\t  fold_convert (TREE_TYPE (rse.expr),\n+\t\t  gfc_add_modify (&lse.pre, expr1_vptr,\n+\t\t\t\t  fold_convert (TREE_TYPE (expr1_vptr),\n \t\t\t\t\t\tgfc_class_vptr_get (tmp)));\n \t\t  rse.expr = gfc_class_data_get (tmp);\n \t\t}\n@@ -8091,6 +8187,10 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    {\n \t      gfc_conv_expr_descriptor (&rse, expr2);\n \t      strlen_rhs = rse.string_length;\n+\t      if (expr1->ts.type == BT_CLASS)\n+\t\texpr1_vptr = trans_class_vptr_len_assignment (&block, expr1,\n+\t\t\t\t\t\t\t      expr2, &rse,\n+\t\t\t\t\t\t\t      NULL, NULL);\n \t    }\n \t}\n       else if (expr2->expr_type == EXPR_VARIABLE)\n@@ -8109,12 +8209,22 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t      gfc_init_se (&rse, NULL);\n \t      rse.descriptor_only = 1;\n \t      gfc_conv_expr (&rse, expr2);\n+\t      if (expr1->ts.type == BT_CLASS)\n+\t\ttrans_class_vptr_len_assignment (&block, expr1, expr2, &rse,\n+\t\t\t\t\t\t NULL, NULL);\n \t      tmp = gfc_get_element_type (TREE_TYPE (rse.expr));\n \t      tmp = fold_convert (gfc_array_index_type, size_in_bytes (tmp));\n \t      if (!INTEGER_CST_P (tmp))\n \t\tgfc_add_block_to_block (&lse.post, &rse.pre);\n \t      gfc_add_modify (&lse.post, GFC_DECL_SPAN(decl), tmp);\n \t    }\n+\t  else if (expr1->ts.type == BT_CLASS)\n+\t    {\n+\t      rse.expr = NULL_TREE;\n+\t      rse.string_length = NULL_TREE;\n+\t      trans_class_vptr_len_assignment (&block, expr1, expr2, &rse,\n+\t\t\t\t\t       NULL, NULL);\n+\t    }\n \t}\n       else if (expr2->expr_type == EXPR_FUNCTION && expr2->ts.type == BT_CLASS)\n \t{\n@@ -8128,16 +8238,15 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    }\n \t  else\n \t    {\n+\t      expr1_vptr = trans_class_vptr_len_assignment (&block, expr1,\n+\t\t\t\t\t\t\t    expr2, &rse, NULL,\n+\t\t\t\t\t\t\t    NULL);\n \t      gfc_add_block_to_block (&block, &rse.pre);\n \t      tmp = gfc_create_var (TREE_TYPE (rse.expr), \"ptrtemp\");\n \t      gfc_add_modify (&lse.pre, tmp, rse.expr);\n \n-\t      gfc_add_vptr_component (expr1_vptr);\n-\t      gfc_init_se (&rse, NULL);\n-\t      rse.want_pointer = 1;\n-\t      gfc_conv_expr (&rse, expr1_vptr);\n-\t      gfc_add_modify (&lse.pre, rse.expr,\n-\t\t\t      fold_convert (TREE_TYPE (rse.expr),\n+\t      gfc_add_modify (&lse.pre, expr1_vptr,\n+\t\t\t      fold_convert (TREE_TYPE (expr1_vptr),\n \t\t\t\t\tgfc_class_vptr_get (tmp)));\n \t      rse.expr = gfc_class_data_get (tmp);\n \t      gfc_add_modify (&lse.pre, desc, rse.expr);\n@@ -8156,9 +8265,6 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  gfc_add_modify (&lse.pre, desc, tmp);\n \t}\n \n-      if (expr1_vptr)\n-\tgfc_free_expr (expr1_vptr);\n-\n       gfc_add_block_to_block (&block, &lse.pre);\n       if (rank_remap)\n \tgfc_add_block_to_block (&block, &rse.pre);\n@@ -8408,7 +8514,6 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \n       if (rse->string_length != NULL_TREE)\n \t{\n-\t  gcc_assert (rse->string_length != NULL_TREE);\n \t  gfc_conv_string_parameter (rse);\n \t  gfc_add_block_to_block (&block, &rse->pre);\n \t  rlen = rse->string_length;\n@@ -9364,14 +9469,101 @@ is_runtime_conformable (gfc_expr *expr1, gfc_expr *expr2)\n   return false;\n }\n \n+\n+static tree\n+trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n+\t\t\tgfc_se *lse, gfc_se *rse, bool use_vptr_copy)\n+{\n+  tree tmp;\n+  tree fcn;\n+  tree stdcopy, to_len, from_len;\n+  vec<tree, va_gc> *args = NULL;\n+\n+  tmp = trans_class_vptr_len_assignment (block, lhs, rhs, rse, &to_len,\n+\t\t\t\t\t &from_len);\n+\n+  fcn = gfc_vptr_copy_get (tmp);\n+\n+  tmp = GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr))\n+      ? gfc_class_data_get (rse->expr) : rse->expr;\n+  if (use_vptr_copy)\n+    {\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp))\n+\t  || INDIRECT_REF_P (tmp)\n+\t  || (rhs->ts.type == BT_DERIVED\n+\t      && rhs->ts.u.derived->attr.unlimited_polymorphic\n+\t      && !rhs->ts.u.derived->attr.pointer\n+\t      && !rhs->ts.u.derived->attr.allocatable)\n+\t  || (UNLIMITED_POLY (rhs)\n+\t      && !CLASS_DATA (rhs)->attr.pointer\n+\t      && !CLASS_DATA (rhs)->attr.allocatable))\n+\tvec_safe_push (args, gfc_build_addr_expr (NULL_TREE, tmp));\n+      else\n+\tvec_safe_push (args, tmp);\n+      tmp = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))\n+\t  ? gfc_class_data_get (lse->expr) : lse->expr;\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp))\n+\t  || INDIRECT_REF_P (tmp)\n+\t  || (lhs->ts.type == BT_DERIVED\n+\t      && lhs->ts.u.derived->attr.unlimited_polymorphic\n+\t      && !lhs->ts.u.derived->attr.pointer\n+\t      && !lhs->ts.u.derived->attr.allocatable)\n+\t  || (UNLIMITED_POLY (lhs)\n+\t      && !CLASS_DATA (lhs)->attr.pointer\n+\t      && !CLASS_DATA (lhs)->attr.allocatable))\n+\tvec_safe_push (args, gfc_build_addr_expr (NULL_TREE, tmp));\n+      else\n+\tvec_safe_push (args, tmp);\n+\n+      stdcopy = build_call_vec (TREE_TYPE (TREE_TYPE (fcn)), fcn, args);\n+\n+      if (to_len != NULL_TREE && !integer_zerop (from_len))\n+\t{\n+\t  tree extcopy;\n+\t  vec_safe_push (args, from_len);\n+\t  vec_safe_push (args, to_len);\n+\t  extcopy = build_call_vec (TREE_TYPE (TREE_TYPE (fcn)), fcn, args);\n+\n+\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t boolean_type_node, from_len,\n+\t\t\t\t integer_zero_node);\n+\t  return fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t  void_type_node, tmp,\n+\t\t\t\t  extcopy, stdcopy);\n+\t}\n+      else\n+\treturn stdcopy;\n+    }\n+  else\n+    {\n+      tree rhst = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))\n+\t  ? gfc_class_data_get (lse->expr) : lse->expr;\n+      stmtblock_t tblock;\n+      gfc_init_block (&tblock);\n+      if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\ttmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+      if (!POINTER_TYPE_P (TREE_TYPE (rhst)))\n+\trhst = gfc_build_addr_expr (NULL_TREE, rhst);\n+      /* When coming from a ptr_copy lhs and rhs are swapped.  */\n+      gfc_add_modify_loc (input_location, &tblock, rhst,\n+\t\t\t  fold_convert (TREE_TYPE (rhst), tmp));\n+      return gfc_finish_block (&tblock);\n+    }\n+}\n+\n /* Subroutine of gfc_trans_assignment that actually scalarizes the\n    assignment.  EXPR1 is the destination/LHS and EXPR2 is the source/RHS.\n    init_flag indicates initialization expressions and dealloc that no\n-   deallocate prior assignment is needed (if in doubt, set true).  */\n+   deallocate prior assignment is needed (if in doubt, set true).\n+   When PTR_COPY is set and expr1 is a class type, then use the _vptr-copy\n+   routine instead of a pointer assignment.  Alias resolution is only done,\n+   when MAY_ALIAS is set (the default).  This flag is used by ALLOCATE()\n+   where it is known, that newly allocated memory on the lhs can never be\n+   an alias of the rhs.  */\n \n static tree\n gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n-\t\t\tbool dealloc)\n+\t\t\tbool dealloc, bool use_vptr_copy, bool may_alias)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -9387,7 +9579,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   tree string_length;\n   int n;\n   bool maybe_workshare = false;\n-  symbol_attribute lhs_caf_attr, rhs_caf_attr;\n+  symbol_attribute lhs_caf_attr, rhs_caf_attr, lhs_attr;\n \n   /* Assignment of the form lhs = rhs.  */\n   gfc_start_block (&block);\n@@ -9408,8 +9600,13 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t  || gfc_is_alloc_class_scalar_function (expr2)))\n     expr2->must_finalize = 1;\n \n-  lhs_caf_attr = gfc_caf_attr (expr1);\n-  rhs_caf_attr = gfc_caf_attr (expr2);\n+  /* Only analyze the expressions for coarray properties, when in coarray-lib\n+     mode.  */\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      lhs_caf_attr = gfc_caf_attr (expr1);\n+      rhs_caf_attr = gfc_caf_attr (expr2);\n+    }\n \n   if (lss != gfc_ss_terminator)\n     {\n@@ -9442,7 +9639,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n       for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n \tloop.reverse[n] = GFC_ENABLE_REVERSE;\n       /* Resolve any data dependencies in the statement.  */\n-      gfc_conv_resolve_dependencies (&loop, lss, rss);\n+      if (may_alias)\n+\tgfc_conv_resolve_dependencies (&loop, lss, rss);\n       /* Setup the scalarizing loops.  */\n       gfc_conv_loop_setup (&loop, &expr2->where);\n \n@@ -9589,9 +9787,26 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \tgfc_add_block_to_block (&loop.post, &rse.post);\n     }\n \n-  if (flag_coarray == GFC_FCOARRAY_LIB\n-      && lhs_caf_attr.codimension && rhs_caf_attr.codimension\n-      && lhs_caf_attr.alloc_comp && rhs_caf_attr.alloc_comp)\n+  lhs_attr = gfc_expr_attr (expr1);\n+  if ((use_vptr_copy || lhs_attr.pointer\n+       || (lhs_attr.allocatable && !lhs_attr.dimension))\n+      && (expr1->ts.type == BT_CLASS\n+\t  || (gfc_is_class_array_ref (expr1, NULL)\n+\t      || gfc_is_class_scalar_expr (expr1))\n+\t  || (gfc_is_class_array_ref (expr2, NULL)\n+\t      || gfc_is_class_scalar_expr (expr2))))\n+    {\n+      tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,\n+\t\t\t\t    use_vptr_copy || (lhs_attr.allocatable\n+\t\t\t\t\t\t      && !lhs_attr.dimension));\n+      /* Modify the expr1 after the assignment, to allow the realloc below.\n+\t Therefore only needed, when realloc_lhs is enabled.  */\n+      if (flag_realloc_lhs && !lhs_attr.pointer)\n+\tgfc_add_data_component (expr1);\n+    }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB\n+\t   && lhs_caf_attr.codimension && rhs_caf_attr.codimension\n+\t   && lhs_caf_attr.alloc_comp && rhs_caf_attr.alloc_comp)\n     {\n       gfc_code code;\n       gfc_actual_arglist a1, a2;\n@@ -9609,7 +9824,13 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t\t\t   || scalar_to_array\n \t\t\t\t   || expr2->expr_type == EXPR_ARRAY,\n \t\t\t\t   !(l_is_temp || init_flag) && dealloc);\n+  /* Add the pre blocks to the body.  */\n+  gfc_add_block_to_block (&body, &rse.pre);\n+  gfc_add_block_to_block (&body, &lse.pre);\n   gfc_add_expr_to_block (&body, tmp);\n+  /* Add the post blocks to the body.  */\n+  gfc_add_block_to_block (&body, &rse.post);\n+  gfc_add_block_to_block (&body, &lse.post);\n \n   if (lss == gfc_ss_terminator)\n     {\n@@ -9724,7 +9945,7 @@ copyable_array_p (gfc_expr * expr)\n \n tree\n gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n-\t\t      bool dealloc)\n+\t\t      bool dealloc, bool use_vptr_copy, bool may_alias)\n {\n   tree tmp;\n \n@@ -9767,7 +9988,8 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n     }\n \n   /* Fallback to the scalarizer to generate explicit loops.  */\n-  return gfc_trans_assignment_1 (expr1, expr2, init_flag, dealloc);\n+  return gfc_trans_assignment_1 (expr1, expr2, init_flag, dealloc,\n+\t\t\t\t use_vptr_copy, may_alias);\n }\n \n tree"}, {"sha": "2cf41b98577efdd1eca9a483dc2c600b05ee6aa3", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 118, "deletions": 211, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -5439,7 +5439,10 @@ gfc_trans_allocate (gfc_code * code)\n \t  if (code->expr3->rank != 0\n \t      && ((!attr.allocatable && !attr.pointer)\n \t\t  || (code->expr3->expr_type == EXPR_FUNCTION\n-\t\t      && code->expr3->ts.type != BT_CLASS)))\n+\t\t      && (code->expr3->ts.type != BT_CLASS\n+\t\t\t  || (code->expr3->value.function.isym\n+\t\t\t      && code->expr3->value.function.isym\n+\t\t\t\t\t\t\t ->transformational)))))\n \t    gfc_conv_expr_descriptor (&se, code->expr3);\n \t  else\n \t    gfc_conv_expr_reference (&se, code->expr3);\n@@ -5623,73 +5626,6 @@ gfc_trans_allocate (gfc_code * code)\n \t  else\n \t    expr3_esize = TYPE_SIZE_UNIT (\n \t\t  gfc_typenode_for_spec (&code->expr3->ts));\n-\n-\t  /* The routine gfc_trans_assignment () already implements all\n-\t     techniques needed.  Unfortunately we may have a temporary\n-\t     variable for the source= expression here.  When that is the\n-\t     case convert this variable into a temporary gfc_expr of type\n-\t     EXPR_VARIABLE and used it as rhs for the assignment.  The\n-\t     advantage is, that we get scalarizer support for free,\n-\t     don't have to take care about scalar to array treatment and\n-\t     will benefit of every enhancements gfc_trans_assignment ()\n-\t     gets.\n-\t     No need to check whether e3_is is E3_UNSET, because that is\n-\t     done by expr3 != NULL_TREE.\n-\t     Exclude variables since the following block does not handle\n-\t     array sections. In any case, there is no harm in sending\n-\t     variables to gfc_trans_assignment because there is no\n-\t     evaluation of variables.  */\n-\t  if (code->expr3->expr_type != EXPR_VARIABLE\n-\t      && e3_is != E3_MOLD && expr3 != NULL_TREE\n-\t      && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))\n-\t    {\n-\t      /* Build a temporary symtree and symbol.  Do not add it to\n-\t\t the current namespace to prevent accidently modifying\n-\t\t a colliding symbol's as.  */\n-\t      newsym = XCNEW (gfc_symtree);\n-\t      /* The name of the symtree should be unique, because\n-\t\t gfc_create_var () took care about generating the\n-\t\t identifier.  */\n-\t      newsym->name = gfc_get_string (IDENTIFIER_POINTER (\n-\t\t\t\t\t       DECL_NAME (expr3)));\n-\t      newsym->n.sym = gfc_new_symbol (newsym->name, NULL);\n-\t      /* The backend_decl is known.  It is expr3, which is inserted\n-\t\t here.  */\n-\t      newsym->n.sym->backend_decl = expr3;\n-\t      e3rhs = gfc_get_expr ();\n-\t      e3rhs->ts = code->expr3->ts;\n-\t      e3rhs->rank = code->expr3->rank;\n-\t      e3rhs->symtree = newsym;\n-\t      /* Mark the symbol referenced or gfc_trans_assignment will\n-\t\t bug.  */\n-\t      newsym->n.sym->attr.referenced = 1;\n-\t      e3rhs->expr_type = EXPR_VARIABLE;\n-\t      e3rhs->where = code->expr3->where;\n-\t      /* Set the symbols type, upto it was BT_UNKNOWN.  */\n-\t      newsym->n.sym->ts = e3rhs->ts;\n-\t      /* Check whether the expr3 is array valued.  */\n-\t      if (e3rhs->rank)\n-\t\t{\n-\t\t  gfc_array_spec *arr;\n-\t\t  arr = gfc_get_array_spec ();\n-\t\t  arr->rank = e3rhs->rank;\n-\t\t  arr->type = AS_DEFERRED;\n-\t\t  /* Set the dimension and pointer attribute for arrays\n-\t\t     to be on the safe side.  */\n-\t\t  newsym->n.sym->attr.dimension = 1;\n-\t\t  newsym->n.sym->attr.pointer = 1;\n-\t\t  newsym->n.sym->as = arr;\n-\t\t  gfc_add_full_array_ref (e3rhs, arr);\n-\t\t}\n-\t      else if (POINTER_TYPE_P (TREE_TYPE (expr3)))\n-\t\tnewsym->n.sym->attr.pointer = 1;\n-\t      /* The string length is known to.  Set it for char arrays.  */\n-\t      if (e3rhs->ts.type == BT_CHARACTER)\n-\t\tnewsym->n.sym->ts.u.cl->backend_decl = expr3_len;\n-\t      gfc_commit_symbol (newsym->n.sym);\n-\t    }\n-\t  else\n-\t    e3rhs = gfc_copy_expr (code->expr3);\n \t}\n       gcc_assert (expr3_esize);\n       expr3_esize = fold_convert (sizetype, expr3_esize);\n@@ -5723,6 +5659,95 @@ gfc_trans_allocate (gfc_code * code)\n \t}\n     }\n \n+  /* The routine gfc_trans_assignment () already implements all\n+     techniques needed.  Unfortunately we may have a temporary\n+     variable for the source= expression here.  When that is the\n+     case convert this variable into a temporary gfc_expr of type\n+     EXPR_VARIABLE and used it as rhs for the assignment.  The\n+     advantage is, that we get scalarizer support for free,\n+     don't have to take care about scalar to array treatment and\n+     will benefit of every enhancements gfc_trans_assignment ()\n+     gets.\n+     No need to check whether e3_is is E3_UNSET, because that is\n+     done by expr3 != NULL_TREE.\n+     Exclude variables since the following block does not handle\n+     array sections.  In any case, there is no harm in sending\n+     variables to gfc_trans_assignment because there is no\n+     evaluation of variables.  */\n+  if (code->expr3)\n+    {\n+      if (code->expr3->expr_type != EXPR_VARIABLE\n+\t  && e3_is != E3_MOLD && expr3 != NULL_TREE\n+\t  && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))\n+\t{\n+\t  /* Build a temporary symtree and symbol.  Do not add it to the current\n+\t     namespace to prevent accidently modifying a colliding\n+\t     symbol's as.  */\n+\t  newsym = XCNEW (gfc_symtree);\n+\t  /* The name of the symtree should be unique, because gfc_create_var ()\n+\t     took care about generating the identifier.  */\n+\t  newsym->name = gfc_get_string (IDENTIFIER_POINTER (\n+\t\t\t\t\t\t\t    DECL_NAME (expr3)));\n+\t  newsym->n.sym = gfc_new_symbol (newsym->name, NULL);\n+\t  /* The backend_decl is known.  It is expr3, which is inserted\n+\t     here.  */\n+\t  newsym->n.sym->backend_decl = expr3;\n+\t  e3rhs = gfc_get_expr ();\n+\t  e3rhs->rank = code->expr3->rank;\n+\t  e3rhs->symtree = newsym;\n+\t  /* Mark the symbol referenced or gfc_trans_assignment will bug.  */\n+\t  newsym->n.sym->attr.referenced = 1;\n+\t  e3rhs->expr_type = EXPR_VARIABLE;\n+\t  e3rhs->where = code->expr3->where;\n+\t  /* Set the symbols type, upto it was BT_UNKNOWN.  */\n+\t  if (IS_CLASS_ARRAY (code->expr3)\n+\t      && code->expr3->expr_type == EXPR_FUNCTION\n+\t      && code->expr3->value.function.isym\n+\t      && code->expr3->value.function.isym->transformational)\n+\t    {\n+\t      e3rhs->ts = CLASS_DATA (code->expr3)->ts;\n+\t    }\n+\t  else if (code->expr3->ts.type == BT_CLASS\n+\t\t   && !GFC_CLASS_TYPE_P (TREE_TYPE (expr3)))\n+\t    e3rhs->ts = CLASS_DATA (code->expr3)->ts;\n+\t  else\n+\t    e3rhs->ts = code->expr3->ts;\n+\t  newsym->n.sym->ts = e3rhs->ts;\n+\t  /* Check whether the expr3 is array valued.  */\n+\t  if (e3rhs->rank)\n+\t    {\n+\t      gfc_array_spec *arr;\n+\t      arr = gfc_get_array_spec ();\n+\t      arr->rank = e3rhs->rank;\n+\t      arr->type = AS_DEFERRED;\n+\t      /* Set the dimension and pointer attribute for arrays\n+\t     to be on the safe side.  */\n+\t      newsym->n.sym->attr.dimension = 1;\n+\t      newsym->n.sym->attr.pointer = 1;\n+\t      newsym->n.sym->as = arr;\n+\t      if (IS_CLASS_ARRAY (code->expr3)\n+\t\t  && code->expr3->expr_type == EXPR_FUNCTION\n+\t\t  && code->expr3->value.function.isym\n+\t\t  && code->expr3->value.function.isym->transformational)\n+\t\t{\n+\t\t  gfc_array_spec *tarr;\n+\t\t  tarr = gfc_get_array_spec ();\n+\t\t  *tarr = *arr;\n+\t\t  e3rhs->ts.u.derived->as = tarr;\n+\t\t}\n+\t      gfc_add_full_array_ref (e3rhs, arr);\n+\t    }\n+\t  else if (POINTER_TYPE_P (TREE_TYPE (expr3)))\n+\t    newsym->n.sym->attr.pointer = 1;\n+\t  /* The string length is known, too.  Set it for char arrays.  */\n+\t  if (e3rhs->ts.type == BT_CHARACTER)\n+\t    newsym->n.sym->ts.u.cl->backend_decl = expr3_len;\n+\t  gfc_commit_symbol (newsym->n.sym);\n+\t}\n+      else\n+\te3rhs = gfc_copy_expr (code->expr3);\n+    }\n+\n   /* Loop over all objects to allocate.  */\n   for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n@@ -5960,8 +5985,9 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n-      /* Set the vptr.  */\n-      if (al_vptr != NULL_TREE)\n+      /* Set the vptr only when no source= is set.  When source= is set, then\n+\t the trans_assignment below will set the vptr.  */\n+      if (al_vptr != NULL_TREE && (!code->expr3 || code->expr3->mold))\n \t{\n \t  if (expr3_vptr != NULL_TREE)\n \t    /* The vtab is already known, so just assign it.  */\n@@ -6046,153 +6072,34 @@ gfc_trans_allocate (gfc_code * code)\n       if (code->expr3 && !code->expr3->mold && e3_is != E3_MOLD)\n \t{\n \t  /* Initialization via SOURCE block (or static default initializer).\n-\t     Classes need some special handling, so catch them first.  */\n-\t  if (expr3 != NULL_TREE\n-\t      && TREE_CODE (expr3) != POINTER_PLUS_EXPR\n-\t      && code->expr3->ts.type == BT_CLASS\n-\t      && (expr->ts.type == BT_CLASS\n-\t\t  || expr->ts.type == BT_DERIVED))\n-\t    {\n-\t      /* copy_class_to_class can be used for class arrays, too.\n-\t\t It just needs to be ensured, that the decl_saved_descriptor\n-\t\t has a way to get to the vptr.  */\n-\t      tree to;\n-\t      to = VAR_P (se.expr) ? se.expr : TREE_OPERAND (se.expr, 0);\n-\t      tmp = gfc_copy_class_to_class (expr3, to,\n-\t\t\t\t\t     nelems, upoly_expr);\n-\t    }\n-\t  else if (al->expr->ts.type == BT_CLASS)\n-\t    {\n-\t      gfc_actual_arglist *actual, *last_arg;\n-\t      gfc_expr *ppc;\n-\t      gfc_code *ppc_code;\n-\t      gfc_ref *ref, *dataref;\n-\t      gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);\n-\n-\t      /* Do a polymorphic deep copy.  */\n-\t      actual = gfc_get_actual_arglist ();\n-\t      actual->expr = gfc_copy_expr (rhs);\n-\t      if (rhs->ts.type == BT_CLASS)\n-\t\tgfc_add_data_component (actual->expr);\n-\t      last_arg = actual->next = gfc_get_actual_arglist ();\n-\t      last_arg->expr = gfc_copy_expr (al->expr);\n-\t      last_arg->expr->ts.type = BT_CLASS;\n-\t      gfc_add_data_component (last_arg->expr);\n-\n-\t      dataref = NULL;\n-\t      /* Make sure we go up through the reference chain to\n-\t\t the _data reference, where the arrayspec is found.  */\n-\t      for (ref = last_arg->expr->ref; ref; ref = ref->next)\n-\t\tif (ref->type == REF_COMPONENT\n-\t\t    && strcmp (ref->u.c.component->name, \"_data\") == 0)\n-\t\t  dataref = ref;\n-\n-\t      if (dataref && dataref->u.c.component->as)\n-\t\t{\n-\t\t  gfc_array_spec *as = dataref->u.c.component->as;\n-\t\t  gfc_free_ref_list (dataref->next);\n-\t\t  dataref->next = NULL;\n-\t\t  gfc_add_full_array_ref (last_arg->expr, as);\n-\t\t  gfc_resolve_expr (last_arg->expr);\n-\t\t  gcc_assert (last_arg->expr->ts.type == BT_CLASS\n-\t\t\t      || last_arg->expr->ts.type == BT_DERIVED);\n-\t\t  last_arg->expr->ts.type = BT_CLASS;\n-\t\t}\n-\t      if (rhs->ts.type == BT_CLASS)\n-\t\t{\n-\t\t  if (rhs->ref)\n-\t\t    ppc = gfc_find_and_cut_at_last_class_ref (rhs);\n-\t\t  else\n-\t\t    ppc = gfc_copy_expr (rhs);\n-\t\t  gfc_add_vptr_component (ppc);\n-\t\t}\n-\t      else\n-\t\tppc = gfc_lval_expr_from_sym (gfc_find_vtab (&rhs->ts));\n-\t      gfc_add_component_ref (ppc, \"_copy\");\n-\n-\t      ppc_code = gfc_get_code (EXEC_CALL);\n-\t      ppc_code->resolved_sym = ppc->symtree->n.sym;\n-\t      ppc_code->loc = al->expr->where;\n-\t      /* Although '_copy' is set to be elemental in class.c, it is\n-\t\t not staying that way.  Find out why, sometime....  */\n-\t      ppc_code->resolved_sym->attr.elemental = 1;\n-\t      ppc_code->ext.actual = actual;\n-\t      ppc_code->expr1 = ppc;\n-\t      /* Since '_copy' is elemental, the scalarizer will take care\n-\t\t of arrays in gfc_trans_call.  */\n-\t      tmp = gfc_trans_call (ppc_code, true, NULL, NULL, false);\n-\t      /* We need to add the\n-\t\t   if (al_len > 0)\n-\t\t     al_vptr->copy (expr3_data, al_data, expr3_len, al_len);\n-\t\t   else\n-\t\t     al_vptr->copy (expr3_data, al_data);\n-\t\t block, because al is unlimited polymorphic or a deferred\n-\t\t length char array, whose copy routine needs the array lengths\n-\t\t as third and fourth arguments.  */\n-\t      if (al_len && UNLIMITED_POLY (code->expr3))\n-\t\t{\n-\t\t  tree stdcopy, extcopy;\n-\t\t  /* Add al%_len.  */\n-\t\t  last_arg->next = gfc_get_actual_arglist ();\n-\t\t  last_arg = last_arg->next;\n-\t\t  last_arg->expr = gfc_find_and_cut_at_last_class_ref (\n-\t\t\tal->expr);\n-\t\t  gfc_add_len_component (last_arg->expr);\n-\t\t  /* Add expr3's length.  */\n-\t\t  last_arg->next = gfc_get_actual_arglist ();\n-\t\t  last_arg = last_arg->next;\n-\t\t  if (code->expr3->ts.type == BT_CLASS)\n-\t\t    {\n-\t\t      last_arg->expr =\n-\t\t\t  gfc_find_and_cut_at_last_class_ref (code->expr3);\n-\t\t      gfc_add_len_component (last_arg->expr);\n-\t\t    }\n-\t\t  else if (code->expr3->ts.type == BT_CHARACTER)\n-\t\t    last_arg->expr =\n-\t\t\tgfc_copy_expr (code->expr3->ts.u.cl->length);\n-\t\t  else\n-\t\t    gcc_unreachable ();\n-\n-\t\t  stdcopy = tmp;\n-\t\t  extcopy = gfc_trans_call (ppc_code, true, NULL, NULL, false);\n-\n-\t\t  tmp = fold_build2_loc (input_location, GT_EXPR,\n-\t\t\t\t\t boolean_type_node, expr3_len,\n-\t\t\t\t\t integer_zero_node);\n-\t\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n-\t\t}\n-\t      gfc_free_statements (ppc_code);\n-\t      if (rhs != e3rhs)\n-\t\tgfc_free_expr (rhs);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Switch off automatic reallocation since we have just\n-\t\t done the ALLOCATE.  */\n-\t      int realloc_lhs = flag_realloc_lhs;\n-\t      gfc_expr *init_expr = gfc_expr_to_initialize (expr);\n-\t      flag_realloc_lhs = 0;\n-\t      tmp = gfc_trans_assignment (init_expr, e3rhs, false, false);\n-\t      flag_realloc_lhs = realloc_lhs;\n-\t      /* Free the expression allocated for init_expr.  */\n-\t      gfc_free_expr (init_expr);\n-\t    }\n+\t     Switch off automatic reallocation since we have just done the\n+\t     ALLOCATE.  */\n+\t  int realloc_lhs = flag_realloc_lhs;\n+\t  gfc_expr *init_expr = gfc_expr_to_initialize (expr);\n+\t  gfc_expr *rhs = e3rhs ? e3rhs : gfc_copy_expr (code->expr3);\n+\t  flag_realloc_lhs = 0;\n+\t  tmp = gfc_trans_assignment (init_expr, rhs, false, false, true,\n+\t\t\t\t      false);\n+\t  flag_realloc_lhs = realloc_lhs;\n+\t  /* Free the expression allocated for init_expr.  */\n+\t  gfc_free_expr (init_expr);\n+\t  if (rhs != e3rhs)\n+\t    gfc_free_expr (rhs);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n-     else if (code->expr3 && code->expr3->mold\n-\t      && code->expr3->ts.type == BT_CLASS)\n+      else if (code->expr3 && code->expr3->mold\n+\t       && code->expr3->ts.type == BT_CLASS)\n \t{\n-\t  /* Since the _vptr has already been assigned to the allocate\n-\t     object, we can use gfc_copy_class_to_class in its\n-\t     initialization mode.  */\n-\t  tmp = TREE_OPERAND (se.expr, 0);\n-\t  tmp = gfc_copy_class_to_class (NULL_TREE, tmp, nelems,\n-\t\t\t\t\t upoly_expr);\n+\t  /* Use class_init_assign to initialize expr.  */\n+\t  gfc_code *ini;\n+\t  ini = gfc_get_code (EXEC_INIT_ASSIGN);\n+\t  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr);\n+\t  tmp = gfc_trans_class_init_assign (ini);\n+\t  gfc_free_statements (ini);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n-       gfc_free_expr (expr);\n+      gfc_free_expr (expr);\n     } // for-loop\n \n   if (e3rhs)"}, {"sha": "e4d4a67aa5d7ab684628a03d55b4863047a71860", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -32,7 +32,6 @@ tree gfc_trans_assign (gfc_code *);\n tree gfc_trans_pointer_assign (gfc_code *);\n tree gfc_trans_init_assign (gfc_code *);\n tree gfc_trans_class_init_assign (gfc_code *);\n-tree gfc_trans_class_assign (gfc_expr *, gfc_expr *, gfc_exec_op);\n \n /* trans-stmt.c */\n tree gfc_trans_cycle (gfc_code *);"}, {"sha": "fba0d9a5d49d81cf74c4b51183d409738d1c8e53", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -1704,27 +1704,15 @@ trans_code (gfc_code * code, tree cond)\n \t  break;\n \n \tcase EXEC_ASSIGN:\n-\t  if (code->expr1->ts.type == BT_CLASS)\n-\t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n-\t  else\n-\t    res = gfc_trans_assign (code);\n+\t  res = gfc_trans_assign (code);\n \t  break;\n \n         case EXEC_LABEL_ASSIGN:\n           res = gfc_trans_label_assign (code);\n           break;\n \n \tcase EXEC_POINTER_ASSIGN:\n-\t  if (code->expr1->ts.type == BT_CLASS)\n-\t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n-\t  else if (UNLIMITED_POLY (code->expr2)\n-\t\t   && code->expr1->ts.type == BT_DERIVED\n-\t\t   && (code->expr1->ts.u.derived->attr.sequence\n-\t\t       || code->expr1->ts.u.derived->attr.is_bind_c))\n-\t    /* F2003: C717  */\n-\t    res = gfc_trans_class_assign (code->expr1, code->expr2, code->op);\n-\t  else\n-\t    res = gfc_trans_pointer_assign (code);\n+\t  res = gfc_trans_pointer_assign (code);\n \t  break;\n \n \tcase EXEC_INIT_ASSIGN:"}, {"sha": "f76fff81a921e112f86704e4b237eab282fcc6f6", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -699,7 +699,8 @@ tree gfc_call_realloc (stmtblock_t *, tree, tree);\n tree gfc_trans_structure_assign (tree, gfc_expr *, bool);\n \n /* Generate code for an assignment, includes scalarization.  */\n-tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool, bool);\n+tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool, bool, bool p = false,\n+\t\t\t   bool a = true);\n \n /* Generate code for a pointer assignment.  */\n tree gfc_trans_pointer_assignment (gfc_expr *, gfc_expr *);"}, {"sha": "74c2b091c9657da914a1dc135ee40d35d5aa16e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -1,3 +1,18 @@\n+2016-10-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tForgot to add on original commit.\n+\t* gfortran.dg/coarray_alloc_comp_2.f08: New test.\n+\n+2016-10-22  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/43366\n+\tPR fortran/57117\n+\tPR fortran/61337\n+\t* gfortran.dg/alloc_comp_class_5.f03: New test.\n+\t* gfortran.dg/class_allocate_21.f90: New test.\n+\t* gfortran.dg/class_allocate_22.f90: New test.\n+\t* gfortran.dg/realloc_on_assign_27.f08: New test.\n+\n 2016-10-21  Jeff Law  <law@redhat.com>\n \n \t* PR tree-optimization/71947"}, {"sha": "a2d7cce33ac0ea20e652f974ff72b54f3eb8eee5", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_class_5.f03", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_class_5.f03?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+!\n+! Contributed by Vladimir Fuka\n+! Check that pr61337 is fixed.\n+\n+module array_list\n+\n+  type container\n+    class(*), allocatable :: items(:)\n+  end type\n+\n+contains\n+\n+  subroutine add_item(a, e)\n+    type(container),allocatable,intent(inout) :: a(:)\n+    class(*),intent(in) :: e(:)\n+    type(container),allocatable :: tmp(:)\n+\n+      if (.not.allocated(a)) then\n+        allocate(a(1))\n+        allocate(a(1)%items(size(e)), source = e)\n+      else\n+        call move_alloc(a,tmp)\n+        allocate(a(size(tmp)+1))\n+        a(1:size(tmp)) = tmp\n+        allocate(a(size(tmp)+1)%items(size(e)), source=e)\n+      end if\n+   end subroutine\n+\n+end module\n+\n+program test_pr61337\n+\n+  use array_list\n+\n+  type(container), allocatable :: a_list(:)\n+  integer(kind = 8) :: i\n+\n+  call add_item(a_list, [1, 2])\n+  call add_item(a_list, [3.0_8, 4.0_8])\n+  call add_item(a_list, [.true., .false.])\n+\n+  if (size(a_list) /= 3) call abort()\n+  do i = 1, size(a_list)\n+          call checkarr(a_list(i))\n+  end do\n+\n+  deallocate(a_list)\n+\n+contains\n+\n+  subroutine checkarr(c)\n+    type(container) :: c\n+\n+    if (allocated(c%items)) then\n+      select type (x=>c%items)\n+        type is (integer)\n+          if (any(x /= [1, 2])) call abort()\n+        type is (real(kind=8))\n+          if (any(x /= [3.0_8, 4.0_8])) call abort()\n+        type is (logical)\n+          if (any(x .neqv. [.true., .false.])) call abort()\n+        class default\n+          call abort()\n+      end select\n+    else\n+        call abort()\n+    end if\n+  end subroutine\n+end"}, {"sha": "a8ed291f8dfaf0fbe5b787767562dacb39c08249", "filename": "gcc/testsuite/gfortran.dg/class_allocate_21.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_21.f90?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+!\n+! Testcase for pr57117\n+\n+implicit none\n+\n+  type :: ti\n+    integer :: i\n+  end type\n+\n+  class(ti), allocatable :: x(:,:), z(:)\n+  integer :: i\n+\n+  allocate(x(3,3))\n+  x%i = reshape([( i, i = 1, 9 )], [3, 3])\n+  allocate(z(9), source=reshape(x, (/ 9 /)))\n+\n+  if (any( z%i /= [( i, i = 1, 9 )])) call abort()\n+  deallocate (x, z)\n+end\n+"}, {"sha": "5fec72fafe130c64f68288dacbf945f359dab7d0", "filename": "gcc/testsuite/gfortran.dg/class_allocate_22.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_22.f90?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+!\n+! Check pr57117 is fixed.\n+\n+program pr57117\n+  implicit none\n+\n+  type :: ti\n+    integer :: i\n+  end type\n+\n+  class(ti), allocatable :: x(:,:), y(:,:)\n+  integer :: i\n+\n+  allocate(x(2,6))\n+  select type (x)\n+    class is (ti)\n+       x%i = reshape([(i,i=1, 12)],[2,6])\n+  end select\n+  allocate(y, source=transpose(x))\n+\n+  if (any( ubound(y) /= [6,2])) call abort()\n+  if (any(reshape(y(:,:)%i, [12]) /= [ 1,3,5,7,9,11, 2,4,6,8,10,12])) call abort()\n+  deallocate (x,y)\n+end\n+"}, {"sha": "b36ec2bfeb03e05a0889441400ab9ee56919ad12", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_2.f08", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_2.f08?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -0,0 +1,84 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single\" }\n+\n+! Contributed by Damian Rouson\n+! Check the new _caf_send_by_ref()-routine.\n+\n+program main\n+\n+implicit none\n+\n+type :: mytype\n+  integer :: i\n+  integer, allocatable :: indices(:)\n+  real, dimension(2,5,3) :: volume\n+  integer, allocatable :: scalar\n+  integer :: j\n+  integer, allocatable :: matrix(:,:)\n+  real, allocatable :: dynvol(:,:,:)\n+end type\n+\n+type arrtype\n+  type(mytype), allocatable :: vec(:)\n+  type(mytype), allocatable :: mat(:,:)\n+end type arrtype\n+\n+type(mytype), save :: object[*]\n+type(arrtype), save :: bar[*]\n+integer :: i,j,me,neighbor\n+integer :: idx(5)\n+real, allocatable :: volume(:,:,:), vol2(:,:,:)\n+real :: vol_static(2,5,3)\n+\n+idx = (/ 1,2,1,7,5 /)\n+\n+me=this_image()\n+neighbor = merge(1,me+1,me==num_images())\n+object[neighbor]%indices=[(i,i=1,5)]\n+object[neighbor]%i = 37\n+object[neighbor]%scalar = 42\n+vol_static = reshape([(i, i=1, 2*5*3)], [2, 5, 3])\n+object[neighbor]%volume = vol_static\n+object[neighbor]%matrix = reshape([(i, i=1, 70)], [10, 7])\n+object[neighbor]%dynvol = vol_static\n+sync all\n+if (object%scalar /= 42) call abort()\n+if (any( object%indices /= [1,2,3,4,5] )) call abort()\n+if (any( object%matrix /= reshape([(i, i=1, 70)], [10, 7]))) call abort()\n+if (any( object%volume /= vol_static)) call abort()\n+if (any( object%dynvol /= vol_static)) call abort()\n+\n+vol2 = vol_static\n+vol2(:, ::2, :) = 42\n+object[neighbor]%volume(:, ::2, :) = 42\n+object[neighbor]%dynvol(:, ::2, :) = 42\n+if (any( object%volume /= vol2)) call abort()\n+if (any( object%dynvol /= vol2)) call abort()\n+\n+allocate(bar%vec(-2:2))\n+\n+bar[neighbor]%vec(1)%volume = vol_static\n+if (any(bar%vec(1)%volume /= vol_static)) call abort()\n+\n+i = 15\n+bar[neighbor]%vec(1)%scalar = i\n+if (.not. allocated(bar%vec(1)%scalar)) call abort()\n+if (bar%vec(1)%scalar /= 15) call abort()\n+\n+bar[neighbor]%vec(0)%scalar = 27\n+if (.not. allocated(bar%vec(0)%scalar)) call abort()\n+if (bar%vec(0)%scalar /= 27) call abort()\n+\n+bar[neighbor]%vec(1)%indices = [ 3, 4, 15 ]\n+allocate(bar%vec(2)%indices(5))\n+bar[neighbor]%vec(2)%indices = 89\n+\n+if (.not. allocated(bar%vec(1)%indices)) call abort()\n+if (allocated(bar%vec(-2)%indices)) call abort()\n+if (allocated(bar%vec(-1)%indices)) call abort()\n+if (allocated(bar%vec( 0)%indices)) call abort()\n+if (.not. allocated(bar%vec( 2)%indices)) call abort()\n+if (any(bar%vec(2)%indices /= 89)) call abort()\n+\n+if (any (bar%vec(1)%indices /= [ 3,4,15])) call abort()\n+end program"}, {"sha": "9a786299565aea7484fbcdd2e878d8c378399cba", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_27.f08", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_27.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574284e9c49687d8bcc039165964602311decd2b/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_27.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_27.f08?ref=574284e9c49687d8bcc039165964602311decd2b", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+\n+  type :: t\n+    integer :: i\n+  end type\n+\n+  type, extends(t) :: r\n+    real :: r\n+  end type\n+\n+  class(t), allocatable :: x\n+  type(r) :: y = r (3, 42)\n+\n+  x = y\n+  if (x%i /= 3) call abort()\n+  select type(x)\n+    class is (r)\n+      if (x%r /= 42.0) call abort()\n+    class default\n+      call abort()\n+  end select\n+end\n+"}]}