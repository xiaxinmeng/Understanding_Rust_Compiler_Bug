{"sha": "2541c40f06f6653a26cf465d961c39ab6398cfdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU0MWM0MGYwNmY2NjUzYTI2Y2Y0NjVkOTYxYzM5YWI2Mzk4Y2ZkZg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2019-04-12T07:41:51Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2019-04-12T07:41:51Z"}, "message": "S/390: Fix a problem with the bswap vector pattern\n\narch13 introduced instructions to perform vector element-wise byte\nswaps on the way from or to memory.  For a byte swap between vector\nregisters the vector permute instruction is required which needs a\npermute pattern to be loaded into a vector register first.\n\nWith the current implementation there is a potential problem when the\ndecision for the reg-reg variant is made very late.  This patch is\nsupposed to fix that.\n\nWith the patch the required permute pattern is generated already in\nthe expander and attached to the bswap pattern as USE operand.  The\npredicate in the insn_and_split pattern accepts it although the\npermute constant as such is not a valid constant.  For the reg-reg\nvariant only the vector register constraint is used for the permute\nconstant forcing LRA to a) push the constant into literal pool and b)\nload the literal pool constant into a vector register.\n\ngcc/ChangeLog:\n\n2019-04-12  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* config/s390/predicates.md (permute_pattern_operand): New\n\tpredicate.\n\t* config/s390/vector.md (\"*vec_splats_bswap_vec<mode>\"): Add USE\n\toperand for the permute pattern.\n\t(\"*vec_perm<mode>\"): New insn definition.\n\t(\"bswap<mode>\"): Generate the permute pattern operand in the\n\texpander and perform the operand reloads for pre arch13 level\n\talready.\n\t(\"*bswap<mode>_emu\"): Rename to ...\n\t(\"*bswap<mode>\"): ... this. And make the splitter vxe2 only.\n\t* config/s390/vx-builtins.md (\"*vec_insert_and_zero_bswap<mode>\"):\n\tAdd the USE operand for the permute pattern.\n\t(\"*vec_set_bswap_vec<mode>\"): Likewise.\n\nFrom-SVN: r270306", "tree": {"sha": "b190bec60527e95430f227195b399d40fcc7ecd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b190bec60527e95430f227195b399d40fcc7ecd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2541c40f06f6653a26cf465d961c39ab6398cfdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2541c40f06f6653a26cf465d961c39ab6398cfdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2541c40f06f6653a26cf465d961c39ab6398cfdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2541c40f06f6653a26cf465d961c39ab6398cfdf/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e8225e69d1173cf0095a59ccf9bad219d016cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e8225e69d1173cf0095a59ccf9bad219d016cdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e8225e69d1173cf0095a59ccf9bad219d016cdd"}], "stats": {"total": 151, "additions": 105, "deletions": 46}, "files": [{"sha": "fd3e7c631b44c9c7b089f0e4dd2905204d3e1eb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2541c40f06f6653a26cf465d961c39ab6398cfdf", "patch": "@@ -1,3 +1,19 @@\n+2019-04-12  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/predicates.md (permute_pattern_operand): New\n+\tpredicate.\n+\t* config/s390/vector.md (\"*vec_splats_bswap_vec<mode>\"): Add USE\n+\toperand for the permute pattern.\n+\t(\"*vec_perm<mode>\"): New insn definition.\n+\t(\"bswap<mode>\"): Generate the permute pattern operand in the\n+\texpander and perform the operand reloads for pre arch13 level\n+\talready.\n+\t(\"*bswap<mode>_emu\"): Rename to ...\n+\t(\"*bswap<mode>\"): ... this. And make the splitter vxe2 only.\n+\t* config/s390/vx-builtins.md (\"*vec_insert_and_zero_bswap<mode>\"):\n+\tAdd the USE operand for the permute pattern.\n+\t(\"*vec_set_bswap_vec<mode>\"): Likewise.\n+\n 2019-04-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/89946"}, {"sha": "92c602e4addba3f51a7caeae97c82d9b64ad2e90", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=2541c40f06f6653a26cf465d961c39ab6398cfdf", "patch": "@@ -46,6 +46,16 @@\n   (and (match_code \"symbol_ref, label_ref, const, const_int, const_wide_int, const_double, const_vector\")\n        (match_test \"CONSTANT_P (op)\")))\n \n+; An operand used as vector permutation pattern\n+\n+; This in particular accepts constants which would otherwise be\n+; rejected.  These constants require special post reload handling\n+\n+(define_special_predicate \"permute_pattern_operand\"\n+  (and (match_code \"const_vector,mem,reg,subreg\")\n+       (match_test \"GET_MODE (op) == V16QImode\")\n+       (match_test \"!MEM_P (op) || s390_mem_constraint (\\\"R\\\", op)\")))\n+\n ;; Return true if OP is a valid S-type operand.\n \n (define_predicate \"s_operand\""}, {"sha": "a2c101245779ce3c6e19a0da20fbef00142b3665", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=2541c40f06f6653a26cf465d961c39ab6398cfdf", "patch": "@@ -551,9 +551,10 @@\n \n ; vlbrreph, vlbrrepf, vlbrrepg\n (define_insn \"*vec_splats_bswap_vec<mode>\"\n-  [(set (match_operand:V_HW_HSD                           0 \"register_operand\" \"=v\")\n+  [(set (match_operand:V_HW_HSD                           0 \"register_operand\"        \"=v\")\n \t(bswap:V_HW_HSD\n-\t (vec_duplicate:V_HW_HSD (match_operand:<non_vec> 1 \"memory_operand\"    \"R\"))))]\n+\t (vec_duplicate:V_HW_HSD (match_operand:<non_vec> 1 \"memory_operand\"           \"R\"))))\n+   (use (match_operand:V16QI                              2 \"permute_pattern_operand\"  \"X\"))]\n   \"TARGET_VXE2\"\n   \"vlbrrep<bhfgq>\\t%v0,%1\"\n   [(set_attr \"op_type\" \"VRX\")])\n@@ -655,6 +656,17 @@\n   \"vperm\\t%v0,%v1,%v2,%v3\"\n   [(set_attr \"op_type\" \"VRR\")])\n \n+(define_insn \"*vec_perm<mode>\"\n+  [(set (match_operand:VT_HW                                            0 \"register_operand\" \"=v\")\n+\t(subreg:VT_HW (unspec:V16QI [(subreg:V16QI (match_operand:VT_HW 1 \"register_operand\"  \"v\") 0)\n+\t\t\t\t     (subreg:V16QI (match_operand:VT_HW 2 \"register_operand\"  \"v\") 0)\n+\t\t\t\t     (match_operand:V16QI               3 \"register_operand\"  \"v\")]\n+\t\t\t\t    UNSPEC_VEC_PERM) 0))]\n+  \"TARGET_VX\"\n+  \"vperm\\t%v0,%v1,%v2,%v3\"\n+  [(set_attr \"op_type\" \"VRR\")])\n+\n+\n ; vec_perm_const for V2DI using vpdi?\n \n ;;\n@@ -2073,43 +2085,19 @@\n ; FIXME: The bswap rtl standard name currently does not appear to be\n ; used for vector modes.\n (define_expand \"bswap<mode>\"\n-  [(set (match_operand:VT_HW_HSDT                   0 \"nonimmediate_operand\" \"\")\n-\t(bswap:VT_HW_HSDT (match_operand:VT_HW_HSDT 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_VX\")\n-\n-; vlbrh, vlbrf, vlbrg, vlbrq, vstbrh, vstbrf, vstbrg, vstbrq\n-(define_insn \"*bswap<mode>\"\n-  [(set (match_operand:VT_HW_HSDT                   0 \"nonimmediate_operand\" \"=v,v,R\")\n-\t(bswap:VT_HW_HSDT (match_operand:VT_HW_HSDT 1 \"nonimmediate_operand\"  \"v,R,v\")))]\n-  \"TARGET_VXE2\"\n-  \"@\n-   #\n-   vlbr<bhfgq>\\t%v0,%v1\n-   vstbr<bhfgq>\\t%v1,%v0\"\n-  [(set_attr \"op_type\" \"*,VRX,VRX\")])\n-\n-(define_insn_and_split \"*bswap<mode>_emu\"\n-  [(set (match_operand:VT_HW_HSDT                   0 \"nonimmediate_operand\" \"=vR\")\n-\t(bswap:VT_HW_HSDT (match_operand:VT_HW_HSDT 1 \"nonimmediate_operand\" \"vR\")))]\n-  \"TARGET_VX && can_create_pseudo_p ()\"\n-  \"#\"\n-  \"&& ((!memory_operand (operands[1], <MODE>mode)\n-        && !memory_operand (operands[0], <MODE>mode))\n-        || !TARGET_VXE2)\"\n-  [(set (match_dup 3)\n-\t(unspec:V16QI [(match_dup 4)\n-\t\t       (match_dup 4)\n-\t\t       (match_dup 2)]\n-\t\t      UNSPEC_VEC_PERM))\n-   (set (match_dup 0) (subreg:VT_HW_HSDT (match_dup 3) 0))]\n+  [(parallel\n+    [(set (match_operand:VT_HW_HSDT                   0 \"nonimmediate_operand\" \"\")\n+\t  (bswap:VT_HW_HSDT (match_operand:VT_HW_HSDT 1 \"nonimmediate_operand\" \"\")))\n+     (use (match_dup 2))])]\n+  \"TARGET_VX\"\n {\n   static char p[4][16] =\n     { { 1,  0,  3,  2,  5,  4,  7, 6, 9,  8,  11, 10, 13, 12, 15, 14 },   /* H */\n       { 3,  2,  1,  0,  7,  6,  5, 4, 11, 10, 9,  8,  15, 14, 13, 12 },   /* S */\n       { 7,  6,  5,  4,  3,  2,  1, 0, 15, 14, 13, 12, 11, 10, 9,  8  },   /* D */\n       { 15, 14, 13, 12, 11, 10, 9, 8, 7,  6,  5,  4,  3,  2,  1,  0  } }; /* T */\n   char *perm;\n-  rtx perm_rtx[16], constv;\n+  rtx perm_rtx[16];\n \n   switch (GET_MODE_SIZE (GET_MODE_INNER (<MODE>mode)))\n     {\n@@ -2122,14 +2110,57 @@\n   for (int i = 0; i < 16; i++)\n     perm_rtx[i] = GEN_INT (perm[i]);\n \n-  operands[1] = force_reg (<MODE>mode, operands[1]);\n-  operands[2] = gen_reg_rtx (V16QImode);\n-  operands[3] = gen_reg_rtx (V16QImode);\n-  operands[4] = simplify_gen_subreg (V16QImode, operands[1], <MODE>mode, 0);\n-  constv = force_const_mem (V16QImode, gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, perm_rtx)));\n-  emit_move_insn (operands[2], constv);\n+  operands[2] = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, perm_rtx));\n+\n+  /* Without vxe2 we do not have byte swap instructions dealing\n+     directly with memory operands.  So instead of waiting until\n+     reload to fix that up switch over to vector permute right\n+     now.  */\n+  if (!TARGET_VXE2)\n+    {\n+      rtx in = force_reg (V16QImode, simplify_gen_subreg (V16QImode, operands[1], <MODE>mode, 0));\n+      rtx permute = force_reg (V16QImode, force_const_mem (V16QImode, operands[2]));\n+      rtx out = gen_reg_rtx (V16QImode);\n+\n+      emit_insn (gen_vec_permv16qi (out, in, in, permute));\n+      emit_move_insn (operands[0], simplify_gen_subreg (<MODE>mode, out, V16QImode, 0));\n+      DONE;\n+    }\n })\n \n+; Switching late to the reg-reg variant requires the vector permute\n+; pattern to be pushed into literal pool and allocating a vector\n+; register to load it into.  We rely on both being provided by LRA\n+; when fixing up the v constraint for operand 2.\n+\n+; permute_pattern_operand: general_operand would reject the permute\n+; pattern constants since these are not accepted by\n+; s390_legimitate_constant_p\n+\n+; ^R: Prevent these alternatives from being chosen if it would require\n+; pushing the operand into memory first\n+\n+; vlbrh, vlbrf, vlbrg, vlbrq, vstbrh, vstbrf, vstbrg, vstbrq\n+(define_insn_and_split \"*bswap<mode>\"\n+  [(set (match_operand:VT_HW_HSDT                   0 \"nonimmediate_operand\"    \"=v, v,^R\")\n+\t(bswap:VT_HW_HSDT (match_operand:VT_HW_HSDT 1 \"nonimmediate_operand\"     \"v,^R, v\")))\n+   (use (match_operand:V16QI                        2 \"permute_pattern_operand\"  \"v, X, X\"))]\n+  \"TARGET_VXE2\"\n+  \"@\n+   #\n+   vlbr<bhfgq>\\t%v0,%v1\n+   vstbr<bhfgq>\\t%v1,%v0\"\n+  \"&& reload_completed\n+   && !memory_operand (operands[0], <MODE>mode)\n+   && !memory_operand (operands[1], <MODE>mode)\"\n+  [(set (match_dup 0)\n+\t(subreg:VT_HW_HSDT\n+\t (unspec:V16QI [(subreg:V16QI (match_dup 1) 0)\n+\t\t\t(subreg:V16QI (match_dup 1) 0)\n+\t\t\t(match_dup 2)]\n+\t\t       UNSPEC_VEC_PERM) 0))]\n+  \"\"\n+  [(set_attr \"op_type\"      \"*,VRX,VRX\")])\n \n ; reduc_smin\n ; reduc_smax"}, {"sha": "3020bc94d3e4447c0196b1ff746bd15df32cfa8b", "filename": "gcc/config/s390/vx-builtins.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2541c40f06f6653a26cf465d961c39ab6398cfdf/gcc%2Fconfig%2Fs390%2Fvx-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvx-builtins.md?ref=2541c40f06f6653a26cf465d961c39ab6398cfdf", "patch": "@@ -183,10 +183,11 @@\n ; vec_revb (vec_insert_and_zero(x))             bswap-and-replicate-1.c\n ; vllebrzh, vllebrzf, vllebrzg\n (define_insn \"*vec_insert_and_zero_bswap<mode>\"\n-  [(set (match_operand:V_HW_HSD                    0 \"register_operand\" \"=v\")\n+  [(set (match_operand:V_HW_HSD                    0 \"register_operand\"       \"=v\")\n \t(bswap:V_HW_HSD (unspec:V_HW_HSD\n-\t\t\t [(match_operand:<non_vec> 1 \"memory_operand\"    \"R\")]\n-\t\t\t UNSPEC_VEC_INSERT_AND_ZERO)))]\n+\t\t\t [(match_operand:<non_vec> 1 \"memory_operand\"          \"R\")]\n+\t\t\t UNSPEC_VEC_INSERT_AND_ZERO)))\n+   (use (match_operand:V16QI                       2 \"permute_pattern_operand\" \"X\"))]\n   \"TARGET_VXE2\"\n   \"vllebrz<bhfgq>\\t%v0,%1\"\n   [(set_attr \"op_type\" \"VRX\")])\n@@ -2243,12 +2244,13 @@\n ; vec_revb (vec_insert (*a, vec_revb (b), 1))      set-element-bswap-1.c\n ; vlebrh, vlebrf, vlebrg\n (define_insn \"*vec_set_bswap_vec<mode>\"\n-  [(set (match_operand:V_HW_HSD                                     0 \"register_operand\" \"=v\")\n+  [(set (match_operand:V_HW_HSD                                     0 \"register_operand\"       \"=v\")\n \t(bswap:V_HW_HSD\n-\t (unspec:V_HW_HSD [(match_operand:<non_vec>                 1 \"memory_operand\"    \"R\")\n-\t\t           (match_operand:SI                        2 \"const_int_operand\" \"C\")\n-\t\t\t   (bswap:V_HW_HSD (match_operand:V_HW_HSD  3 \"register_operand\"  \"0\"))]\n-\t\t\t  UNSPEC_VEC_SET)))]\n+\t (unspec:V_HW_HSD [(match_operand:<non_vec>                 1 \"memory_operand\"          \"R\")\n+\t\t           (match_operand:SI                        2 \"const_int_operand\"       \"C\")\n+\t\t\t   (bswap:V_HW_HSD (match_operand:V_HW_HSD  3 \"register_operand\"        \"0\"))]\n+\t\t\t  UNSPEC_VEC_SET)))\n+   (use (match_operand:V16QI                                        4 \"permute_pattern_operand\" \"X\"))]\n   \"TARGET_VXE2 && UINTVAL (operands[2]) < GET_MODE_NUNITS (<V_HW_HSD:MODE>mode)\"\n   \"vlebr<bhfgq>\\t%v0,%1,%2\"\n   [(set_attr \"op_type\" \"VRX\")])"}]}