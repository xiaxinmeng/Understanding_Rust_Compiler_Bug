{"sha": "f5fa046faa7f97662312e17aaab6da9713fe7518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVmYTA0NmZhYTdmOTc2NjIzMTJlMTdhYWFiNmRhOTcxM2ZlNzUxOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-07-04T12:52:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-04T12:52:22Z"}, "message": "tree-ssa-alias.c (decl_refs_may_alias_p): Add size1 and size2 parameters; return early for must-alias.\n\n\n\t* tree-ssa-alias.c (decl_refs_may_alias_p): Add size1 and size2\n\tparameters; return early for must-alias.\n\t(indirect_ref_may_alias_decl_p): Likewise; when establishing\n\touter types match, try nonoverlapping_component_refs\n\tif must-alias is not obvious.\n\t(indirect_refs_may_alias_p): Likewise.\n\t(refs_may_alias_p_2): Likewise.\n\n\t* gcc.dg/tree-ssa/alias-access-path-3.c: New testcase.\n\t* gcc.dg/tree-ssa/alias-access-path-8.c: New testcase.\n\nFrom-SVN: r273079", "tree": {"sha": "164e3da0328f43d55b11f59c68ec5cf042b6eb00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/164e3da0328f43d55b11f59c68ec5cf042b6eb00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5fa046faa7f97662312e17aaab6da9713fe7518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5fa046faa7f97662312e17aaab6da9713fe7518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5fa046faa7f97662312e17aaab6da9713fe7518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5fa046faa7f97662312e17aaab6da9713fe7518/comments", "author": null, "committer": null, "parents": [{"sha": "8862ed139a6ac3d28dc75ccbaa1dd36f47c8f9dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8862ed139a6ac3d28dc75ccbaa1dd36f47c8f9dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8862ed139a6ac3d28dc75ccbaa1dd36f47c8f9dd"}], "stats": {"total": 112, "additions": 104, "deletions": 8}, "files": [{"sha": "5f889096dac2bf4ec3d2c2e9bdda274cdbd0aced", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5fa046faa7f97662312e17aaab6da9713fe7518", "patch": "@@ -1,3 +1,13 @@\n+2019-07-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-alias.c (decl_refs_may_alias_p): Add size1 and size2\n+\tparameters; return early for must-alias.\n+\t(indirect_ref_may_alias_decl_p): Likewise; when establishing\n+\touter types match, try nonoverlapping_component_refs\n+\tif must-alias is not obvious.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t(refs_may_alias_p_2): Likewise.\n+\n 2019-07-04  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.h (vn_reference_lookup): Add last_vuse_ptr"}, {"sha": "a89a21893be33526658c0da5065ca6c141a49720", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f5fa046faa7f97662312e17aaab6da9713fe7518", "patch": "@@ -1,3 +1,8 @@\n+2019-07-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-3.c: New testcase.\n+\t* gcc.dg/tree-ssa/alias-access-path-8.c: New testcase.\n+\n 2019-07-04  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* g++.dg/gomp/unmappable-1.C: New file."}, {"sha": "ef4ffac154d693d98cd97e467dda850450c407be", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-3.c?ref=f5fa046faa7f97662312e17aaab6da9713fe7518", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+struct a {int v1;\n+\t  int v2;};\n+struct b {struct a a[0];};\n+\n+int\n+test (struct b *bptr1, struct b *bptr2, int i, int j)\n+{\n+  bptr1->a[i].v1=123;\n+  bptr2->a[j].v2=1;\n+  return bptr1->a[i].v1;\n+}\n+int\n+test2 (struct b *bptr1, struct b *bptr2, int i, int j)\n+{\n+  bptr1->a[i].v1=123;\n+  bptr2->a[j].v1=1;\n+  return bptr1->a[i].v1;\n+}\n+/* test should be optimized, while test2 should not.  */\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"fre1\"} } */"}, {"sha": "1d5b57ab7291571b5fee71134fcc349a4482826a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-8.c?ref=f5fa046faa7f97662312e17aaab6da9713fe7518", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre3\" } */\n+struct a {\n+  int val;\n+};\n+struct b {\n+  struct a a[10],a2[10];\n+};\n+struct c {\n+  struct b b[10];\n+} *cptr,*cptr2;\n+\n+\n+int\n+test (int i, int j, int k, int l)\n+{\n+  cptr->b[i].a[j].val=123;\n+  cptr2->b[k].a2[l].val=2;\n+  return cptr->b[i].a[j].val;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"fre3\"} } */"}, {"sha": "d76656e57afe42894bb5e6642caabbf5a1470990", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5fa046faa7f97662312e17aaab6da9713fe7518/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=f5fa046faa7f97662312e17aaab6da9713fe7518", "patch": "@@ -1452,8 +1452,10 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n static bool\n decl_refs_may_alias_p (tree ref1, tree base1,\n \t\t       poly_int64 offset1, poly_int64 max_size1,\n+\t\t       poly_int64 size1,\n \t\t       tree ref2, tree base2,\n-\t\t       poly_int64 offset2, poly_int64 max_size2)\n+\t\t       poly_int64 offset2, poly_int64 max_size2,\n+\t\t       poly_int64 size2)\n {\n   gcc_checking_assert (DECL_P (base1) && DECL_P (base2));\n \n@@ -1466,6 +1468,10 @@ decl_refs_may_alias_p (tree ref1, tree base1,\n   if (!ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n     return false;\n \n+  /* If there is must alias, there is no use disambiguating further.  */\n+  if (known_eq (size1, max_size1) && known_eq (size2, max_size2))\n+    return true;\n+\n   /* For components with variable position, the above test isn't sufficient,\n      so we disambiguate component references manually.  */\n   if (ref1 && ref2\n@@ -1487,10 +1493,12 @@ decl_refs_may_alias_p (tree ref1, tree base1,\n static bool\n indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t\t       poly_int64 offset1, poly_int64 max_size1,\n+\t\t\t       poly_int64 size1,\n \t\t\t       alias_set_type ref1_alias_set,\n \t\t\t       alias_set_type base1_alias_set,\n \t\t\t       tree ref2 ATTRIBUTE_UNUSED, tree base2,\n \t\t\t       poly_int64 offset2, poly_int64 max_size2,\n+\t\t\t       poly_int64 size2,\n \t\t\t       alias_set_type ref2_alias_set,\n \t\t\t       alias_set_type base2_alias_set, bool tbaa_p)\n {\n@@ -1598,7 +1606,19 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       && (TREE_CODE (TREE_TYPE (base1)) != ARRAY_TYPE\n \t  || (TYPE_SIZE (TREE_TYPE (base1))\n \t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) == INTEGER_CST)))\n-    return ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2);\n+    {\n+      if (!ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2))\n+\treturn false;\n+      if (!ref1 || !ref2\n+\t  /* If there is must alias, there is no use disambiguating further.  */\n+\t  || (known_eq (size1, max_size1) && known_eq (size2, max_size2)))\n+\treturn true;\n+      int res = nonoverlapping_component_refs_since_match_p (base1, ref1,\n+\t\t\t\t\t\t\t     base2, ref2);\n+      if (res == -1)\n+\treturn !nonoverlapping_component_refs_p (ref1, ref2);\n+      return !res;\n+    }\n \n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n@@ -1623,10 +1643,12 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n static bool\n indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t\t   poly_int64 offset1, poly_int64 max_size1,\n+\t\t\t   poly_int64 size1,\n \t\t\t   alias_set_type ref1_alias_set,\n \t\t\t   alias_set_type base1_alias_set,\n \t\t\t   tree ref2 ATTRIBUTE_UNUSED, tree base2,\n \t\t\t   poly_int64 offset2, poly_int64 max_size2,\n+\t\t\t   poly_int64 size2,\n \t\t\t   alias_set_type ref2_alias_set,\n \t\t\t   alias_set_type base2_alias_set, bool tbaa_p)\n {\n@@ -1671,6 +1693,9 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       if (!ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n \t\t\t\t   offset2 + moff2, max_size2))\n \treturn false;\n+      /* If there is must alias, there is no use disambiguating further.  */\n+      if (known_eq (size1, max_size1) && known_eq (size2, max_size2))\n+\treturn true;\n       if (ref1 && ref2)\n \t{\n \t  int res = nonoverlapping_component_refs_since_match_p (NULL, ref1,\n@@ -1717,7 +1742,18 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n          can overlap by an exact multiple of their element size.\n          See gcc.dg/torture/alias-2.c.  */\n       && TREE_CODE (TREE_TYPE (ptrtype1)) != ARRAY_TYPE)\n-    return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n+    {\n+      if (!ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+\treturn false;\n+      if (!ref1 || !ref2\n+\t  || (known_eq (size1, max_size1) && known_eq (size2, max_size2)))\n+\treturn true;\n+      int res = nonoverlapping_component_refs_since_match_p (base1, ref1,\n+\t\t\t\t\t\t\t     base2, ref2);\n+      if (res == -1)\n+\treturn !nonoverlapping_component_refs_p (ref1, ref2);\n+      return !res;\n+    }\n \n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n@@ -1802,7 +1838,9 @@ refs_may_alias_p_2 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   var2_p = DECL_P (base2);\n   if (var1_p && var2_p)\n     return decl_refs_may_alias_p (ref1->ref, base1, offset1, max_size1,\n-\t\t\t\t  ref2->ref, base2, offset2, max_size2);\n+\t\t\t\t  ref1->size,\n+\t\t\t\t  ref2->ref, base2, offset2, max_size2,\n+\t\t\t\t  ref2->size);\n \n   /* Handle restrict based accesses.\n      ???  ao_ref_base strips inner MEM_REF [&decl], recover from that\n@@ -1870,21 +1908,21 @@ refs_may_alias_p_2 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   /* Dispatch to the pointer-vs-decl or pointer-vs-pointer disambiguators.  */\n   if (var1_p && ind2_p)\n     return indirect_ref_may_alias_decl_p (ref2->ref, base2,\n-\t\t\t\t\t  offset2, max_size2,\n+\t\t\t\t\t  offset2, max_size2, ref2->size,\n \t\t\t\t\t  ao_ref_alias_set (ref2),\n \t\t\t\t\t  ao_ref_base_alias_set (ref2),\n \t\t\t\t\t  ref1->ref, base1,\n-\t\t\t\t\t  offset1, max_size1,\n+\t\t\t\t\t  offset1, max_size1, ref1->size,\n \t\t\t\t\t  ao_ref_alias_set (ref1),\n \t\t\t\t\t  ao_ref_base_alias_set (ref1),\n \t\t\t\t\t  tbaa_p);\n   else if (ind1_p && ind2_p)\n     return indirect_refs_may_alias_p (ref1->ref, base1,\n-\t\t\t\t      offset1, max_size1,\n+\t\t\t\t      offset1, max_size1, ref1->size,\n \t\t\t\t      ao_ref_alias_set (ref1),\n \t\t\t\t      ao_ref_base_alias_set (ref1),\n \t\t\t\t      ref2->ref, base2,\n-\t\t\t\t      offset2, max_size2,\n+\t\t\t\t      offset2, max_size2, ref2->size,\n \t\t\t\t      ao_ref_alias_set (ref2),\n \t\t\t\t      ao_ref_base_alias_set (ref2),\n \t\t\t\t      tbaa_p);"}]}