{"sha": "586b5f201303020b6bd856807b5c1d2b9a686c3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg2YjVmMjAxMzAzMDIwYjZiZDg1NjgwN2I1YzFkMmI5YTY4NmMzZA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-03-24T06:41:07Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-03-24T06:41:07Z"}, "message": "locale_facets.h: Tweaks for 80 column.\n\n\n2004-03-23  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/locale_facets.h: Tweaks for 80 column.\n\t(__numpunct_cache::_M_cache): Move to locale_facets.tcc.\n\t(__moneypunct_cache::_M_cache): Same.\n\t(num_get): Don't inherit from __num_base.\n\t(num_put): Same.\n\t(money_get): Don't inherit from money_base.\n\t(money_put): Same.\n\t(__timepunct::_M_am_pm_format): New.\n\t(time_get::_M_extract_num): Return iterator, use ios_base as argument.\n\t(time_get::_M_extract_name): Same.\n\t(time_get::_M_extract_via_format): Same.\n\t* include/bits/locale_facets.tcc: Tweaks for 80 column.\n\tUse _M_getloc instead of getloc.\n\t* testsuite/22_locale/money_put/put/char/9780-3.cc: New.\n\t* testsuite/22_locale/num_put/put/char/9780-2.cc: New.\n\t* testsuite/22_locale/time_put/put/char/9780-1.cc: New.\n\nFrom-SVN: r79902", "tree": {"sha": "5ef315d38cf501e1b3f80c2d41a7436b01194dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ef315d38cf501e1b3f80c2d41a7436b01194dfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/586b5f201303020b6bd856807b5c1d2b9a686c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586b5f201303020b6bd856807b5c1d2b9a686c3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586b5f201303020b6bd856807b5c1d2b9a686c3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586b5f201303020b6bd856807b5c1d2b9a686c3d/comments", "author": null, "committer": null, "parents": [{"sha": "ae87624ff083a7730d28f5e5fe21e77b1771b55c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae87624ff083a7730d28f5e5fe21e77b1771b55c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae87624ff083a7730d28f5e5fe21e77b1771b55c"}], "stats": {"total": 765, "additions": 510, "deletions": 255}, "files": [{"sha": "ef719c83be70866f974adb1ee6065f8fe13d3893", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=586b5f201303020b6bd856807b5c1d2b9a686c3d", "patch": "@@ -1,3 +1,22 @@\n+2004-03-23  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/locale_facets.h: Tweaks for 80 column.\n+\t(__numpunct_cache::_M_cache): Move to locale_facets.tcc.\n+\t(__moneypunct_cache::_M_cache): Same.\n+\t(num_get): Don't inherit from __num_base.\n+\t(num_put): Same.\n+\t(money_get): Don't inherit from money_base.\n+\t(money_put): Same.\n+\t(__timepunct::_M_am_pm_format): New.\n+\t(time_get::_M_extract_num): Return iterator, use ios_base as argument.\n+\t(time_get::_M_extract_name): Same.\n+\t(time_get::_M_extract_via_format): Same.\n+\t* include/bits/locale_facets.tcc: Tweaks for 80 column.\n+\tUse _M_getloc instead of getloc.\n+\t* testsuite/22_locale/money_put/put/char/9780-3.cc: New.\n+\t* testsuite/22_locale/num_put/put/char/9780-2.cc: New.\n+\t* testsuite/22_locale/time_put/put/char/9780-1.cc: New.\n+\n 2004-03-22  Paolo Carlini  <pcarlini@suse.de>\n \n \t* acinclude.m4 (GLIBCXX_ENABLE_ALLOCATOR): Add pool_allocator."}, {"sha": "453ba78f20afa84c001c7cf2a5c8cf4c5f8e0723", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 55, "deletions": 125, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=586b5f201303020b6bd856807b5c1d2b9a686c3d", "patch": "@@ -1451,14 +1451,15 @@ namespace std\n       /**\n        *  @brief  Narrow wchar_t to char\n        *\n-       *  This virtual function converts the argument to char using the\n-       *  simplest reasonable transformation.  If the conversion fails, dfault\n-       *  is returned instead.  For an underived ctype<wchar_t> facet, @a c will\n-       *  be cast to char and returned.\n+       *  This virtual function converts the argument to char using\n+       *  the simplest reasonable transformation.  If the conversion\n+       *  fails, dfault is returned instead.  For an underived\n+       *  ctype<wchar_t> facet, @a c will be cast to char and\n+       *  returned.\n        *\n-       *  do_narrow() is a hook for a derived facet to change the behavior of\n-       *  narrowing.  do_narrow() must always return the same result for the\n-       *  same input.\n+       *  do_narrow() is a hook for a derived facet to change the\n+       *  behavior of narrowing.  do_narrow() must always return the\n+       *  same result for the same input.\n        *\n        *  Note: this is not what you want for codepage conversions.  See\n        *  codecvt for that.\n@@ -1625,40 +1626,6 @@ namespace std\n       _M_cache(const locale& __loc);\n     };\n \n-  template<typename _CharT>\n-    void\n-    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)\n-    {\n-      _M_allocated = true;\n-\n-      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n-\n-      _M_grouping_size = __np.grouping().size();\n-      char* __grouping = new char[_M_grouping_size];\n-      __np.grouping().copy(__grouping, _M_grouping_size);\n-      _M_grouping = __grouping;\n-      _M_use_grouping = _M_grouping_size && __np.grouping()[0] != 0;\n-\n-      _M_truename_size = __np.truename().size();\n-      _CharT* __truename = new _CharT[_M_truename_size];\n-      __np.truename().copy(__truename, _M_truename_size);\n-      _M_truename = __truename;\n-\n-      _M_falsename_size = __np.falsename().size();\n-      _CharT* __falsename = new _CharT[_M_falsename_size];\n-      __np.falsename().copy(__falsename, _M_falsename_size);\n-      _M_falsename = __falsename;\n-\n-      _M_decimal_point = __np.decimal_point();\n-      _M_thousands_sep = __np.thousands_sep();\n-\n-      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n-      __ct.widen(__num_base::_S_atoms_out,\n-\t\t __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);\n-      __ct.widen(__num_base::_S_atoms_in,\n-\t\t __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);\n-    }\n-\n   template<typename _CharT>\n     __numpunct_cache<_CharT>::~__numpunct_cache()\n     {\n@@ -1755,8 +1722,8 @@ namespace std\n       /**\n        *  @brief  Return thousands separator character.\n        *\n-       *  This function returns a char_type to use as a thousands separator.  It\n-       *  does so by returning returning\n+       *  This function returns a char_type to use as a thousands\n+       *  separator.  It does so by returning returning\n        *  numpunct<char_type>::do_thousands_sep().\n        *\n        *  @return  char_type representing a thousands separator.\n@@ -1772,18 +1739,20 @@ namespace std\n        *  integer part of a number.  Groupings indicate where thousands\n        *  separators should be inserted in the integer part of a number.\n        *\n-       *  Each char in the return string is interpret as an integer rather\n-       *  than a character.  These numbers represent the number of digits in a\n-       *  group.  The first char in the string represents the number of digits\n-       *  in the least significant group.  If a char is negative, it indicates\n-       *  an unlimited number of digits for the group.  If more chars from the\n+       *  Each char in the return string is interpret as an integer\n+       *  rather than a character.  These numbers represent the number\n+       *  of digits in a group.  The first char in the string\n+       *  represents the number of digits in the least significant\n+       *  group.  If a char is negative, it indicates an unlimited\n+       *  number of digits for the group.  If more chars from the\n        *  string are required to group a number, the last char is used\n        *  repeatedly.\n        *\n-       *  For example, if the grouping() returns \"\\003\\002\" and is applied to\n-       *  the number 123456789, this corresponds to 12,34,56,789.  Note that\n-       *  if the string was \"32\", this would put more than 50 digits into the\n-       *  least significant group if the character set is ASCII.\n+       *  For example, if the grouping() returns \"\\003\\002\" and is\n+       *  applied to the number 123456789, this corresponds to\n+       *  12,34,56,789.  Note that if the string was \"32\", this would\n+       *  put more than 50 digits into the least significant group if\n+       *  the character set is ASCII.\n        *\n        *  The string is returned by calling\n        *  numpunct<char_type>::do_grouping().\n@@ -1950,7 +1919,7 @@ namespace std\n    *  implement the behavior they require from the num_get facet.\n   */\n   template<typename _CharT, typename _InIter>\n-    class num_get : public locale::facet, public __num_base\n+    class num_get : public locale::facet\n     {\n     public:\n       // Types:\n@@ -1979,10 +1948,11 @@ namespace std\n        *  Parses the input stream into the bool @a v.  It does so by calling\n        *  num_put::do_put().\n        *\n-       *  If ios_base::boolalpha is set, attempts to read ctype<CharT>::truename() or\n-       *  ctype<CharT>::falsename().  Sets @a v to true or false if\n-       *  successful.  Sets err to ios_base::failbit if reading the string\n-       *  fails.  Sets err to ios_base::eofbit if the stream is emptied.\n+       *  If ios_base::boolalpha is set, attempts to read\n+       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets\n+       *  @a v to true or false if successful.  Sets err to\n+       *  ios_base::failbit if reading the string fails.  Sets err to\n+       *  ios_base::eofbit if the stream is emptied.\n        *\n        *  If ios_base::boolalpha is not set, proceeds as with reading a long,\n        *  except if the value is 1, sets @a v to true, if the value is 0, sets\n@@ -2228,7 +2198,7 @@ namespace std\n    *  implement the behavior they require from the num_put facet.\n   */\n   template<typename _CharT, typename _OutIter>\n-    class num_put : public locale::facet, public __num_base\n+    class num_put : public locale::facet\n     {\n     public:\n       // Types:\n@@ -2274,8 +2244,8 @@ namespace std\n       /**\n        *  @brief  Numeric formatting.\n        *\n-       *  Formats the integral value @a v and inserts it into a stream.  It does so\n-       *  by calling num_put::do_put().\n+       *  Formats the integral value @a v and inserts it into a\n+       *  stream.  It does so by calling num_put::do_put().\n        *\n        *  Formatting is affected by the flag settings in @a io.\n        *\n@@ -2794,7 +2764,7 @@ namespace std\n     {\n       if (_M_allocated)\n \t{\n-\t  // XXX.\n+\t  // Unused.\n \t}\n     }\n \n@@ -2870,13 +2840,6 @@ namespace std\n \t__time[1] = _M_data->_M_time_era_format;\n       }\n \n-      void\n-      _M_ampm(const _CharT** __ampm) const\n-      {\n-\t__ampm[0] = _M_data->_M_am;\n-\t__ampm[1] = _M_data->_M_pm;\n-      }\n-\n       void\n       _M_date_time_formats(const _CharT** __dt) const\n       {\n@@ -2885,6 +2848,17 @@ namespace std\n \t__dt[1] = _M_data->_M_date_time_era_format;\n       }\n \n+      void\n+      _M_am_pm_format(const _CharT* __ampm) const\n+      { __ampm = _M_data->_M_am_pm_format; }\n+\n+      void\n+      _M_am_pm(const _CharT** __ampm) const\n+      {\n+\t__ampm[0] = _M_data->_M_am;\n+\t__ampm[1] = _M_data->_M_pm;\n+      }\n+\n       void\n       _M_days(const _CharT** __days) const\n       {\n@@ -3280,23 +3254,21 @@ namespace std\n \t\t  ios_base::iostate& __err, tm* __tm) const;\n \n       // Extract numeric component of length __len.\n-      void\n-      _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,\n+      iter_type\n+      _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n \t\t     int __min, int __max, size_t __len,\n-\t\t     const ctype<_CharT>& __ctype,\n-\t\t     ios_base::iostate& __err) const;\n+\t\t     ios_base& __io, ios_base::iostate& __err) const;\n \n       // Extract day or month name, or any unique array of string\n       // literals in a const _CharT* array.\n-      void\n-      _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,\n+      iter_type\n+      _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n \t\t      const _CharT** __names, size_t __indexlen,\n-\t\t      const ctype<_CharT>& __ctype,\n-\t\t      ios_base::iostate& __err) const;\n+\t\t      ios_base& __io, ios_base::iostate& __err) const;\n \n       // Extract on a component-by-component basis, via __format argument.\n-      void\n-      _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,\n+      iter_type\n+      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t\t    ios_base::iostate& __err, tm* __tm,\n \t\t\t    const _CharT* __format) const;\n     };\n@@ -3333,7 +3305,7 @@ namespace std\n    *  implement the behavior they require from the time_put facet.\n   */\n   template<typename _CharT, typename _OutIter>\n-    class time_put : public locale::facet, public time_base\n+    class time_put : public locale::facet\n     {\n     public:\n       // Types:\n@@ -3535,48 +3507,6 @@ namespace std\n \t}\n     }\n \n-  template<typename _CharT, bool _Intl>\n-    void\n-    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)\n-    {\n-      _M_allocated = true;\n-\n-      const moneypunct<_CharT, _Intl>& __mp =\n-\tuse_facet<moneypunct<_CharT, _Intl> >(__loc);\n-\n-      _M_grouping_size = __mp.grouping().size();\n-      char* __grouping = new char[_M_grouping_size];\n-      __mp.grouping().copy(__grouping, _M_grouping_size);\n-      _M_grouping = __grouping;\n-      _M_use_grouping = _M_grouping_size && __mp.grouping()[0] != 0;\n-      \n-      _M_decimal_point = __mp.decimal_point();\n-      _M_thousands_sep = __mp.thousands_sep();\n-      _M_frac_digits = __mp.frac_digits();\n-      \n-      _M_curr_symbol_size = __mp.curr_symbol().size();\n-      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];\n-      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);\n-      _M_curr_symbol = __curr_symbol;\n-      \n-      _M_positive_sign_size = __mp.positive_sign().size();\n-      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];\n-      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);\n-      _M_positive_sign = __positive_sign;\n-\n-      _M_negative_sign_size = __mp.negative_sign().size();\n-      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];\n-      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);\n-      _M_negative_sign = __negative_sign;\n-      \n-      _M_pos_format = __mp.pos_format();\n-      _M_neg_format = __mp.neg_format();\n-\n-      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n-      __ct.widen(money_base::_S_atoms,\n-\t\t money_base::_S_atoms + money_base::_S_end, _M_atoms);\n-    }\n-\n   /**\n    *  @brief  Facet for formatting data for money amounts.\n    *\n@@ -3660,8 +3590,8 @@ namespace std\n       /**\n        *  @brief  Return thousands separator character.\n        *\n-       *  This function returns a char_type to use as a thousands separator.  It\n-       *  does so by returning returning\n+       *  This function returns a char_type to use as a thousands\n+       *  separator.  It does so by returning returning\n        *  moneypunct<char_type>::do_thousands_sep().\n        *\n        *  @return  char_type representing a thousands separator.\n@@ -4012,7 +3942,7 @@ namespace std\n    *  the money_get facet.\n   */\n   template<typename _CharT, typename _InIter>\n-  class money_get : public locale::facet, public money_base\n+    class money_get : public locale::facet\n     {\n     public:\n       // Types:\n@@ -4147,7 +4077,7 @@ namespace std\n    *  the money_put facet.\n   */\n   template<typename _CharT, typename _OutIter>\n-  class money_put : public locale::facet, public money_base\n+    class money_put : public locale::facet\n     {\n     public:\n       //@{"}, {"sha": "29669b9b051b4f6ce9f7c102ba3440f284cd2bf2", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 220, "deletions": 130, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=586b5f201303020b6bd856807b5c1d2b9a686c3d", "patch": "@@ -122,6 +122,7 @@ namespace std\n       operator() (const locale& __loc) const;\n     };\n \n+  // Specializations.\n   template<typename _CharT>\n     struct __use_cache<__numpunct_cache<_CharT> >\n     {\n@@ -149,6 +150,111 @@ namespace std\n       }\n     };\n \n+  template<typename _CharT, bool _Intl>\n+    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >\n+    {\n+      const __moneypunct_cache<_CharT, _Intl>*\n+      operator() (const locale& __loc) const\n+      {\n+\tconst size_t __i = moneypunct<_CharT, _Intl>::id._M_id();\n+\tconst locale::facet** __caches = __loc._M_impl->_M_caches;\n+\tif (!__caches[__i])\n+\t  {\n+\t    __moneypunct_cache<_CharT, _Intl>* __tmp = NULL;\n+\t    try\n+\t      {\n+\t\t__tmp = new __moneypunct_cache<_CharT, _Intl>;\n+\t\t__tmp->_M_cache(__loc);\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\tdelete __tmp;\n+\t\t__throw_exception_again;\n+\t      }\n+\t    __loc._M_impl->_M_install_cache(__tmp, __i);\n+\t  }\n+\treturn static_cast<\n+\t  const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);\n+      }\n+    };\n+\n+  template<typename _CharT>\n+    void\n+    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)\n+    {\n+      _M_allocated = true;\n+\n+      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+\n+      _M_grouping_size = __np.grouping().size();\n+      char* __grouping = new char[_M_grouping_size];\n+      __np.grouping().copy(__grouping, _M_grouping_size);\n+      _M_grouping = __grouping;\n+      _M_use_grouping = _M_grouping_size && __np.grouping()[0] != 0;\n+\n+      _M_truename_size = __np.truename().size();\n+      _CharT* __truename = new _CharT[_M_truename_size];\n+      __np.truename().copy(__truename, _M_truename_size);\n+      _M_truename = __truename;\n+\n+      _M_falsename_size = __np.falsename().size();\n+      _CharT* __falsename = new _CharT[_M_falsename_size];\n+      __np.falsename().copy(__falsename, _M_falsename_size);\n+      _M_falsename = __falsename;\n+\n+      _M_decimal_point = __np.decimal_point();\n+      _M_thousands_sep = __np.thousands_sep();\n+\n+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n+      __ct.widen(__num_base::_S_atoms_out,\n+\t\t __num_base::_S_atoms_out + __num_base::_S_oend, _M_atoms_out);\n+      __ct.widen(__num_base::_S_atoms_in,\n+\t\t __num_base::_S_atoms_in + __num_base::_S_iend, _M_atoms_in);\n+    }\n+\n+  template<typename _CharT, bool _Intl>\n+    void\n+    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)\n+    {\n+      _M_allocated = true;\n+\n+      const moneypunct<_CharT, _Intl>& __mp =\n+\tuse_facet<moneypunct<_CharT, _Intl> >(__loc);\n+\n+      _M_grouping_size = __mp.grouping().size();\n+      char* __grouping = new char[_M_grouping_size];\n+      __mp.grouping().copy(__grouping, _M_grouping_size);\n+      _M_grouping = __grouping;\n+      _M_use_grouping = _M_grouping_size && __mp.grouping()[0] != 0;\n+      \n+      _M_decimal_point = __mp.decimal_point();\n+      _M_thousands_sep = __mp.thousands_sep();\n+      _M_frac_digits = __mp.frac_digits();\n+      \n+      _M_curr_symbol_size = __mp.curr_symbol().size();\n+      _CharT* __curr_symbol = new _CharT[_M_curr_symbol_size];\n+      __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);\n+      _M_curr_symbol = __curr_symbol;\n+      \n+      _M_positive_sign_size = __mp.positive_sign().size();\n+      _CharT* __positive_sign = new _CharT[_M_positive_sign_size];\n+      __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);\n+      _M_positive_sign = __positive_sign;\n+\n+      _M_negative_sign_size = __mp.negative_sign().size();\n+      _CharT* __negative_sign = new _CharT[_M_negative_sign_size];\n+      __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);\n+      _M_negative_sign = __negative_sign;\n+      \n+      _M_pos_format = __mp.pos_format();\n+      _M_neg_format = __mp.neg_format();\n+\n+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);\n+      __ct.widen(money_base::_S_atoms,\n+\t\t money_base::_S_atoms + money_base::_S_end, _M_atoms);\n+    }\n+\n+\n   // Used by both numeric and monetary facets.\n   // Check to make sure that the __grouping_tmp string constructed in\n   // money_get or num_get matches the canonical grouping for a given\n@@ -181,8 +287,8 @@ namespace std\n       if (__beg != __end)\n \t{\n \t  const char_type __c = *__beg;\n-\t  const bool __plus = __c == __lit[_S_iplus];\n-\t  if ((__plus || __c == __lit[_S_iminus])\n+\t  const bool __plus = __c == __lit[__num_base::_S_iplus];\n+\t  if ((__plus || __c == __lit[__num_base::_S_iminus])\n \t      && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t      && !(__c == __lc->_M_decimal_point))\n \t    {\n@@ -198,7 +304,7 @@ namespace std\n \t  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep\n \t      || __c == __lc->_M_decimal_point)\n \t    break;\n-\t  else if (__c == __lit[_S_izero])\n+\t  else if (__c == __lit[__num_base::_S_izero])\n \t    {\n \t      if (!__found_mantissa)\n \t\t{\n@@ -218,7 +324,7 @@ namespace std\n       if (__lc->_M_use_grouping)\n \t__found_grouping.reserve(32);\n       int __sep_pos = 0;\n-      const char_type* __lit_zero = __lit + _S_izero;\n+      const char_type* __lit_zero = __lit + __num_base::_S_izero;\n       const char_type* __q;\n       while (__beg != __end)\n         {\n@@ -264,12 +370,13 @@ namespace std\n \t    }\n           else if (__q = __traits_type::find(__lit_zero, 10, __c))\n \t    {\n-\t      __xtrc += _S_atoms_in[__q - __lit];\n+\t      __xtrc += __num_base::_S_atoms_in[__q - __lit];\n \t      __found_mantissa = true;\n \t      ++__sep_pos;\n \t      ++__beg;\n \t    }\n-\t  else if ((__c == __lit[_S_ie] || __c == __lit[_S_iE])\n+\t  else if ((__c == __lit[__num_base::_S_ie] \n+\t\t    || __c == __lit[__num_base::_S_iE])\n \t\t   && __found_mantissa && !__found_sci)\n \t    {\n \t      // Scientific notation.\n@@ -281,8 +388,8 @@ namespace std\n \t      // Remove optional plus or minus sign, if they exist.\n \t      if (++__beg != __end)\n \t\t{\n-\t\t  const bool __plus = *__beg == __lit[_S_iplus];\n-\t\t  if ((__plus || *__beg == __lit[_S_iminus])\n+\t\t  const bool __plus = *__beg == __lit[__num_base::_S_iplus];\n+\t\t  if ((__plus || *__beg == __lit[__num_base::_S_iminus])\n \t\t      && !(__lc->_M_use_grouping\n \t\t\t   && *__beg == __lc->_M_thousands_sep)\n \t\t      && !(*__beg == __lc->_M_decimal_point))\n@@ -305,7 +412,8 @@ namespace std\n \t  if (!__found_dec && !__found_sci)\n \t    __found_grouping += static_cast<char>(__sep_pos);\n \n-          if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size,\n+          if (!std::__verify_grouping(__lc->_M_grouping, \n+\t\t\t\t      __lc->_M_grouping_size,\n \t\t\t\t      __found_grouping))\n \t    __err |= ios_base::failbit;\n         }\n@@ -345,8 +453,8 @@ namespace std\n \t  {\n \t    const char_type __c = *__beg;\n \t    if (numeric_limits<_ValueT>::is_signed)\n-\t      __negative = __c == __lit[_S_iminus];\n-\t    if ((__negative || __c == __lit[_S_iplus])\n+\t      __negative = __c == __lit[__num_base::_S_iminus];\n+\t    if ((__negative || __c == __lit[__num_base::_S_iplus])\n \t\t&& !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t\t&& !(__c == __lc->_M_decimal_point))\n \t      ++__beg;\n@@ -360,14 +468,16 @@ namespace std\n \t    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep\n \t\t|| __c == __lc->_M_decimal_point)\n \t      break;\n-\t    else if (__c == __lit[_S_izero] && (!__found_num || __base == 10))\n+\t    else if (__c == __lit[__num_base::_S_izero] \n+\t\t     && (!__found_num || __base == 10))\n \t      {\n \t\t__found_num = true;\n \t\t++__beg;\n \t      }\n \t    else if (__found_num)\n \t      {\n-\t\tif (__c == __lit[_S_ix] || __c == __lit[_S_iX])\n+\t\tif (__c == __lit[__num_base::_S_ix] \n+\t\t    || __c == __lit[__num_base::_S_iX])\n \t\t  {\n \t\t    if (__basefield == 0)\n \t\t      __base = 16;\n@@ -387,7 +497,7 @@ namespace std\n \n \t// At this point, base is determined. If not hex, only allow\n \t// base digits as valid input.\n-\tconst size_t __len = __base == 16 ? _S_iend - _S_izero : __base;\n+\tconst size_t __len = __base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base;\n \n \t// Extract.\n \tstring __found_grouping;\n@@ -396,7 +506,7 @@ namespace std\n \tint __sep_pos = 0;\n \tbool __overflow = false;\n \t_ValueT __result = 0;\n-\tconst char_type* __lit_zero = __lit + _S_izero;\n+\tconst char_type* __lit_zero = __lit + __num_base::_S_izero;\n \tconst char_type* __q;\n \tif (__negative)\n \t  {\n@@ -736,8 +846,8 @@ namespace std\n \n   template<typename _CharT>\n     inline int\n-    __int_to_char(_CharT* __bufend, unsigned long long __v, const _CharT* __lit,\n-\t\t  ios_base::fmtflags __flags)\n+    __int_to_char(_CharT* __bufend, unsigned long long __v, \n+\t\t  const _CharT* __lit, ios_base::fmtflags __flags)\n     { return __int_to_char(__bufend, __v, __lit, __flags, false); }\n #endif\n \n@@ -960,7 +1070,7 @@ namespace std\n \tint __cs_size = __max_digits * 3;\n \tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \n-\t_S_format_float(__io, __fbuf, __mod);\n+\t__num_base::_S_format_float(__io, __fbuf, __mod);\n \t__len = std::__convert_from_v(__cs, __cs_size, __fbuf, __v,\n \t\t\t\t      _S_get_c_locale(), __prec);\n \n@@ -987,7 +1097,7 @@ namespace std\n \t                              : __max_digits * 3;\n \tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \n-\t_S_format_float(__io, __fbuf, __mod);\n+\t__num_base::_S_format_float(__io, __fbuf, __mod);\n \t__len = std::__convert_from_v(__cs, 0, __fbuf, __v,\n \t\t\t\t      _S_get_c_locale(), __prec);\n #endif\n@@ -1133,34 +1243,6 @@ namespace std\n       return __s;\n     }\n \n-  template<typename _CharT, bool _Intl>\n-    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >\n-    {\n-      const __moneypunct_cache<_CharT, _Intl>*\n-      operator() (const locale& __loc) const\n-      {\n-\tconst size_t __i = moneypunct<_CharT, _Intl>::id._M_id();\n-\tconst locale::facet** __caches = __loc._M_impl->_M_caches;\n-\tif (!__caches[__i])\n-\t  {\n-\t    __moneypunct_cache<_CharT, _Intl>* __tmp = NULL;\n-\t    try\n-\t      {\n-\t\t__tmp = new __moneypunct_cache<_CharT, _Intl>;\n-\t\t__tmp->_M_cache(__loc);\n-\t      }\n-\t    catch(...)\n-\t      {\n-\t\tdelete __tmp;\n-\t\t__throw_exception_again;\n-\t      }\n-\t    __loc._M_impl->_M_install_cache(__tmp, __i);\n-\t  }\n-\treturn static_cast<\n-\t  const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);\n-      }\n-    };\n-\n   template<typename _CharT, typename _InIter>\n     template<bool _Intl>\n       _InIter\n@@ -1205,7 +1287,7 @@ namespace std\n \tstring __res;\n \t__res.reserve(32);\n \n-\tconst char_type* __lit_zero = __lit + _S_zero;\n+\tconst char_type* __lit_zero = __lit + money_base::_S_zero;\n \tconst char_type* __q;\n \tconst money_base::pattern __p = __lc->_M_neg_format;\t\n \tfor (int __i = 0; __i < 4 && __testvalid; ++__i)\n@@ -1222,9 +1304,9 @@ namespace std\n \t\t    || __i == 0\n \t\t    || (__i == 1 && (__mandatory_sign\n \t\t\t\t     || (static_cast<part>(__p.field[0])\n-\t\t\t\t\t == sign)\n+\t\t\t\t\t == money_base::sign)\n \t\t\t\t     || (static_cast<part>(__p.field[2])\n-\t\t\t\t\t == space)))\n+\t\t\t\t\t == money_base::space)))\n \t\t    || (__i == 2 && ((static_cast<part>(__p.field[3])\n \t\t\t\t      == money_base::value)\n \t\t\t\t     || __mandatory_sign\n@@ -1270,7 +1352,7 @@ namespace std\n \t\tfor (; __beg != __end; ++__beg)\n \t\t  if (__q = __traits_type::find(__lit_zero, 10, *__beg))\n \t\t    {\n-\t\t      __res += _S_atoms[__q - __lit];\n+\t\t      __res += money_base::_S_atoms[__q - __lit];\n \t\t      ++__n;\n \t\t    }\n \t\t  else if (*__beg == __lc->_M_decimal_point && !__testdecfound)\n@@ -1443,7 +1525,7 @@ namespace std\n \tmoney_base::pattern __p;\n \tconst char_type* __sign;\n \tsize_type __sign_size;\n-\tif (*__beg != __lit[_S_minus])\n+\tif (*__beg != __lit[money_base::_S_minus])\n \t  {\n \t    __p = __lc->_M_pos_format;\n \t    __sign = __lc->_M_positive_sign;\n@@ -1501,21 +1583,22 @@ namespace std\n \t\telse\n \t\t  {\n \t\t    // Have to pad zeros in the decimal position.\n-\t\t    __value.append(-__paddec, __lit[_S_zero]);\n+\t\t    __value.append(-__paddec, __lit[money_base::_S_zero]);\n \t\t    __value.append(__beg, __len);\n \t\t  }\n   \t      }\n   \n \t    // Calculate length of resulting string.\n-\t    const ios_base::fmtflags __f = __io.flags() & ios_base::adjustfield;\n+\t    const ios_base::fmtflags __f = __io.flags() \n+\t                                   & ios_base::adjustfield;\n \t    __len = __value.size() + __sign_size;\n \t    __len += ((__io.flags() & ios_base::showbase)\n \t\t      ? __lc->_M_curr_symbol_size : 0);\n \n \t    string_type __res;\n \t    __res.reserve(2 * __len);\n \t    \n-\t    const size_type __width = static_cast<size_type>(__io.width());\t  \n+\t    const size_type __width = static_cast<size_type>(__io.width());  \n \t    const bool __testipad = (__f == ios_base::internal\n \t\t\t\t     && __len < __width);\n \t    // Fit formatted digits into the required pattern.\n@@ -1626,6 +1709,7 @@ namespace std\n     { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)\n \t            : _M_insert<false>(__s, __io, __fill, __digits); }\n \n+\n   // NB: Not especially useful. Without an ios_base object or some\n   // kind of locale reference, we are left clawing at the air where\n   // the side of the mountain used to be...\n@@ -1639,13 +1723,13 @@ namespace std\n   // specific string, which may contain yet more strings.  I.e. %x => %r =>\n   // %H:%M:%S => extracted characters.\n   template<typename _CharT, typename _InIter>\n-    void\n+    _InIter\n     time_get<_CharT, _InIter>::\n-    _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,\n+    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,\n \t\t\t  ios_base::iostate& __err, tm* __tm,\n \t\t\t  const _CharT* __format) const\n     {\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const size_t __len = char_traits<_CharT>::length(__format);\n@@ -1667,81 +1751,81 @@ namespace std\n \t\t  // Abbreviated weekday name [tm_wday]\n \t\t  const char_type*  __days1[7];\n \t\t  __tp._M_days_abbreviated(__days1);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7,\n-\t\t\t\t  __ctype, __err);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,\n+\t\t\t\t\t  7, __io, __err);\n \t\t  break;\n \t\tcase 'A':\n \t\t  // Weekday name [tm_wday].\n \t\t  const char_type*  __days2[7];\n \t\t  __tp._M_days(__days2);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7,\n-\t\t\t\t  __ctype, __err);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,\n+\t\t\t\t\t  7, __io, __err);\n \t\t  break;\n \t\tcase 'h':\n \t\tcase 'b':\n \t\t  // Abbreviated month name [tm_mon]\n \t\t  const char_type*  __months1[12];\n \t\t  __tp._M_months_abbreviated(__months1);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12,\n-\t\t\t\t  __ctype, __err);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_mon, \n+\t\t\t\t\t  __months1, 12, __io, __err);\n \t\t  break;\n \t\tcase 'B':\n \t\t  // Month name [tm_mon].\n \t\t  const char_type*  __months2[12];\n \t\t  __tp._M_months(__months2);\n-\t\t  _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12,\n-\t\t\t\t  __ctype, __err);\n+\t\t  __beg = _M_extract_name(__beg, __end, __tm->tm_mon, \n+\t\t\t\t\t  __months2, 12, __io, __err);\n \t\t  break;\n \t\tcase 'c':\n \t\t  // Default time and date representation.\n \t\t  const char_type*  __dt[2];\n \t\t  __tp._M_date_time_formats(__dt);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n-\t\t\t\t\t__dt[0]);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t\t\t__tm, __dt[0]);\n \t\t  break;\n \t\tcase 'd':\n \t\t  // Day [01, 31]. [tm_mday]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,\n+\t\t\t\t\t __io, __err);\n \t\t  break;\n \t\tcase 'e':\n \t\t  // Day [1, 31], with single digits preceded by\n \t\t  // space. [tm_mday]\n \t\t  if (__ctype.is(ctype_base::space, *__beg))\n-\t\t    _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9, 1,\n-\t\t\t\t   __ctype, __err);\n+\t\t    __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,\n+\t\t\t\t\t   1, __io, __err);\n \t\t  else\n-\t\t    _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31, 2,\n-\t\t\t\t   __ctype, __err);\n+\t\t    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,\n+\t\t\t\t\t   2, __io, __err);\n \t\t  break;\n \t\tcase 'D':\n \t\t  // Equivalent to %m/%d/%y.[tm_mon, tm_mday, tm_year]\n \t\t  __cs = \"%m/%d/%y\";\n \t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n-\t\t\t\t\t__wcs);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t\t\t__tm, __wcs);\n \t\t  break;\n \t\tcase 'H':\n \t\t  // Hour [00, 23]. [tm_hour]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,\n+\t\t\t\t\t __io, __err);\n \t\t  break;\n \t\tcase 'I':\n \t\t  // Hour [01, 12]. [tm_hour]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,\n+\t\t\t\t\t __io, __err);\n \t\t  break;\n \t\tcase 'm':\n \t\t  // Month [01, 12]. [tm_mon]\n-\t\t  _M_extract_num(__beg, __end, __mem, 1, 12, 2, __ctype,\n-\t\t\t\t __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2, \n+\t\t\t\t\t __io, __err);\n \t\t  if (!__err)\n \t\t    __tm->tm_mon = __mem - 1;\n \t\t  break;\n \t\tcase 'M':\n \t\t  // Minute [00, 59]. [tm_min]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,\n+\t\t\t\t\t __io, __err);\n \t\t  break;\n \t\tcase 'n':\n \t\t  if (__ctype.narrow(*__beg, 0) == '\\n')\n@@ -1753,13 +1837,13 @@ namespace std\n \t\t  // Equivalent to (%H:%M).\n \t\t  __cs = \"%H:%M\";\n \t\t  __ctype.widen(__cs, __cs + 6, __wcs);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n-\t\t\t\t\t__wcs);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t\t\t__tm, __wcs);\n \t\t  break;\n \t\tcase 'S':\n \t\t  // Seconds.\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_sec, 0, 59, 2,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 59, 2,\n+\t\t\t\t\t __io, __err);\n \t\t  break;\n \t\tcase 't':\n \t\t  if (__ctype.narrow(*__beg, 0) == '\\t')\n@@ -1771,33 +1855,33 @@ namespace std\n \t\t  // Equivalent to (%H:%M:%S).\n \t\t  __cs = \"%H:%M:%S\";\n \t\t  __ctype.widen(__cs, __cs + 9, __wcs);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n-\t\t\t\t\t__wcs);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t\t\t__tm, __wcs);\n \t\t  break;\n \t\tcase 'x':\n \t\t  // Locale's date.\n \t\t  const char_type*  __dates[2];\n \t\t  __tp._M_date_formats(__dates);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n-\t\t\t\t\t__dates[0]);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t\t\t__tm, __dates[0]);\n \t\t  break;\n \t\tcase 'X':\n \t\t  // Locale's time.\n \t\t  const char_type*  __times[2];\n \t\t  __tp._M_time_formats(__times);\n-\t\t  _M_extract_via_format(__beg, __end, __io, __err, __tm,\n-\t\t\t\t\t__times[0]);\n+\t\t  __beg = _M_extract_via_format(__beg, __end, __io, __err, \n+\t\t\t\t\t\t__tm, __times[0]);\n \t\t  break;\n \t\tcase 'y':\n \t\tcase 'C': // C99\n \t\t  // Two digit year. [tm_year]\n-\t\t  _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,\n+\t\t\t\t\t __io, __err);\n \t\t  break;\n \t\tcase 'Y':\n \t\t  // Year [1900). [tm_year]\n-\t\t  _M_extract_num(__beg, __end, __mem, 0, 9999, 4,\n-\t\t\t\t __ctype, __err);\n+\t\t  __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,\n+\t\t\t\t\t __io, __err);\n \t\t  if (!__err)\n \t\t    __tm->tm_year = __mem - 1900;\n \t\t  break;\n@@ -1806,19 +1890,19 @@ namespace std\n \t\t  if (__ctype.is(ctype_base::upper, *__beg))\n \t\t    {\n \t\t      int __tmp;\n-\t\t      _M_extract_name(__beg, __end, __tmp,\n-\t\t\t\t      __timepunct_cache<_CharT>::_S_timezones,\n-\t\t\t\t      14, __ctype, __err);\n+\t\t      __beg = _M_extract_name(__beg, __end, __tmp,\n+\t\t\t\t       __timepunct_cache<_CharT>::_S_timezones,\n+\t\t\t\t\t      14, __io, __err);\n \n \t\t      // GMT requires special effort.\n \t\t      if (__beg != __end && !__err && __tmp == 0\n \t\t\t  && (*__beg == __ctype.widen('-')\n \t\t\t      || *__beg == __ctype.widen('+')))\n \t\t\t{\n-\t\t\t  _M_extract_num(__beg, __end, __tmp, 0, 23, 2,\n-\t\t\t\t\t  __ctype, __err);\n-\t\t\t  _M_extract_num(__beg, __end, __tmp, 0, 59, 2,\n-\t\t\t\t\t  __ctype, __err);\n+\t\t\t  __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,\n+\t\t\t\t\t\t __io, __err);\n+\t\t\t  __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,\n+\t\t\t\t\t\t __io, __err);\n \t\t\t}\n \t\t    }\n \t\t  else\n@@ -1838,16 +1922,19 @@ namespace std\n \t\t__err |= ios_base::failbit;\n \t    }\n \t}\n+      return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n-    void\n+    _InIter\n     time_get<_CharT, _InIter>::\n-    _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,\n+    _M_extract_num(iter_type __beg, iter_type __end, int& __member,\n \t\t   int __min, int __max, size_t __len,\n-\t\t   const ctype<_CharT>& __ctype,\n-\t\t   ios_base::iostate& __err) const\n+\t\t   ios_base& __io, ios_base::iostate& __err) const\n     {\n+      const locale& __loc = __io._M_getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n       // As-is works for __len = 1, 2, 4, the values actually used.\n       int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);\n \n@@ -1872,19 +1959,22 @@ namespace std\n \t__member = __value;\n       else\n \t__err |= ios_base::failbit;\n+      return __beg;\n     }\n \n   // Assumptions:\n   // All elements in __names are unique.\n   template<typename _CharT, typename _InIter>\n-    void\n+    _InIter\n     time_get<_CharT, _InIter>::\n-    _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,\n+    _M_extract_name(iter_type __beg, iter_type __end, int& __member,\n \t\t    const _CharT** __names, size_t __indexlen,\n-\t\t    const ctype<_CharT>& __ctype,\n-\t\t    ios_base::iostate& __err) const\n+\t\t    ios_base& __io, ios_base::iostate& __err) const\n     {\n       typedef char_traits<_CharT>\t\t__traits_type;\n+      const locale& __loc = __io._M_getloc();\n+      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n+\n       int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)\n \t\t\t\t\t\t\t  * __indexlen));\n       size_t __nmatches = 0;\n@@ -1911,7 +2001,7 @@ namespace std\n \t  size_t __minlen = 10;\n \t  for (size_t __i2 = 0; __i2 < __nmatches; ++__i2)\n \t    __minlen = std::min(__minlen,\n-\t\t\t\t__traits_type::length(__names[__matches[__i2]]));\n+\t\t\t      __traits_type::length(__names[__matches[__i2]]));\n \t  ++__beg;\n \t  if (__pos < __minlen && __beg != __end)\n \t    {\n@@ -1951,6 +2041,7 @@ namespace std\n \t__testvalid = false;\n       if (!__testvalid)\n \t__err |= ios_base::failbit;\n+      return __beg;\n     }\n \n   template<typename _CharT, typename _InIter>\n@@ -1961,10 +2052,10 @@ namespace std\n     {\n       _CharT __wcs[3];\n       const char* __cs = \"%X\";\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n       __ctype.widen(__cs, __cs + 3, __wcs);\n-      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);\n+      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);\n       if (__beg == __end)\n \t__err |= ios_base::eofbit;\n       return __beg;\n@@ -1978,10 +2069,10 @@ namespace std\n     {\n       _CharT __wcs[3];\n       const char* __cs = \"%x\";\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n       __ctype.widen(__cs, __cs + 3, __wcs);\n-      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);\n+      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);\n       if (__beg == __end)\n \t__err |= ios_base::eofbit;\n       return __beg;\n@@ -1994,13 +2085,13 @@ namespace std\n \t\t   ios_base::iostate& __err, tm* __tm) const\n     {\n       typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const char_type*  __days[7];\n       __tp._M_days_abbreviated(__days);\n       int __tmpwday;\n-      _M_extract_name(__beg, __end, __tmpwday, __days, 7, __ctype, __err);\n+      __beg = _M_extract_name(__beg, __end, __tmpwday, __days, 7, __io, __err);\n \n       // Check to see if non-abbreviated name exists, and extract.\n       // NB: Assumes both _M_days and _M_days_abbreviated organized in\n@@ -2038,13 +2129,14 @@ namespace std\n                      ios_base& __io, ios_base::iostate& __err, tm* __tm) const\n     {\n       typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const char_type*  __months[12];\n       __tp._M_months_abbreviated(__months);\n       int __tmpmon;\n-      _M_extract_name(__beg, __end, __tmpmon, __months, 12, __ctype, __err);\n+      __beg = _M_extract_name(__beg, __end, __tmpmon, __months, 12, \n+\t\t\t      __io, __err);\n \n       // Check to see if non-abbreviated name exists, and extract.\n       // NB: Assumes both _M_months and _M_months_abbreviated organized in\n@@ -2082,7 +2174,7 @@ namespace std\n     do_get_year(iter_type __beg, iter_type __end, ios_base& __io,\n \t\tios_base::iostate& __err, tm* __tm) const\n     {\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n       size_t __i = 0;\n@@ -2110,7 +2202,7 @@ namespace std\n     put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,\n \tconst _CharT* __beg, const _CharT* __end) const\n     {\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n       for (; __beg != __end; ++__beg)\n \tif (__ctype.narrow(*__beg, 0) != '%')\n@@ -2132,8 +2224,7 @@ namespace std\n \t      }\n \t    else\n \t      break;\n-\t    __s = this->do_put(__s, __io, __fill, __tm,\n-\t\t\t       __format, __mod);\n+\t    __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);\n \t  }\n \telse\n \t  break;\n@@ -2146,16 +2237,15 @@ namespace std\n     do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,\n \t   char __format, char __mod) const\n     {\n-      const locale __loc = __io.getloc();\n+      const locale& __loc = __io._M_getloc();\n       ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);\n       __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);\n \n       // NB: This size is arbitrary. Should this be a data member,\n       // initialized at construction?\n       const size_t __maxlen = 64;\n-      char_type* __res =\n-\tstatic_cast<char_type*>(__builtin_alloca(sizeof(char_type)\n-\t\t\t\t\t\t * __maxlen));\n+      char_type* __res = \n+       static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));\n \n       // NB: In IEE 1003.1-200x, and perhaps other locale models, it\n       // is possible that the format character will be longer than one"}, {"sha": "acc1c94cc9bf8a36aeac9fa47a95dfeb8127828e", "filename": "libstdc++-v3/testsuite/22_locale/money_put/put/char/9780-3.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put%2Fput%2Fchar%2F9780-3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put%2Fput%2Fchar%2F9780-3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put%2Fput%2Fchar%2F9780-3.cc?ref=586b5f201303020b6bd856807b5c1d2b9a686c3d", "patch": "@@ -0,0 +1,43 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <sstream>\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  using namespace std;\n+\n+  bool test __attribute__((unused)) = true;\n+  locale l1 = __gnu_test::try_named_locale(\"de_DE\");\n+  locale l2 = __gnu_test::try_named_locale(\"es_ES\");\n+  \n+  const money_put<char>& mp = use_facet<money_put<char> >(l1);  \n+  ostringstream oss;\n+  oss.imbue(l2);\n+  oss.setf(ios_base::showbase);\n+\n+  long double ld = -1234567890;\n+  mp.put(oss.rdbuf(), true, oss, ' ', ld); // -EUR  12.345.678,90\n+  string res = oss.str();\n+  \n+  VERIFY( res == \"-EUR  12.345.678,90\" );\n+\n+  return 0;\n+}"}, {"sha": "2f8d6273b6b369ea64689aaedde5d6bb2301bb99", "filename": "libstdc++-v3/testsuite/22_locale/num_put/put/char/9780-2.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fchar%2F9780-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fchar%2F9780-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnum_put%2Fput%2Fchar%2F9780-2.cc?ref=586b5f201303020b6bd856807b5c1d2b9a686c3d", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <sstream>\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  using namespace std;\n+\n+  bool test __attribute__((unused)) = true;\n+  locale l1 = __gnu_test::try_named_locale(\"de_DE\");\n+  locale l2 = __gnu_test::try_named_locale(\"es_ES\");\n+  \n+  const num_put<char>& np = use_facet<num_put<char> >(l1);  \n+  ostringstream oss;\n+  oss.imbue(l2);\n+\n+  long l = 1234567890;\n+  np.put(oss.rdbuf(), oss, ' ', l); // 1234567890\n+  string res = oss.str();\n+  \n+  VERIFY( res == \"1234567890\" );\n+\n+  return 0;\n+}"}, {"sha": "bd7fe40447d6012aac9cb7766e6c4e7ef4c9f36f", "filename": "libstdc++-v3/testsuite/22_locale/time_put/put/char/9780-1.cc", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_put%2Fput%2Fchar%2F9780-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/586b5f201303020b6bd856807b5c1d2b9a686c3d/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_put%2Fput%2Fchar%2F9780-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_put%2Fput%2Fchar%2F9780-1.cc?ref=586b5f201303020b6bd856807b5c1d2b9a686c3d", "patch": "@@ -0,0 +1,131 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <sstream>\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  using namespace std;\n+\n+  bool test __attribute__((unused)) = true;\n+  locale l1 = __gnu_test::try_named_locale(\"de_DE\");\n+  locale l2 = __gnu_test::try_named_locale(\"es_ES\");\n+  \n+  const time_put<char> &tp = use_facet<time_put<char> >(l1);  \n+  ostringstream oss;\n+  oss.imbue(l2);\n+  \n+  tm t = tm();  \n+  tp.put(oss.rdbuf(), oss, ' ', &t, 'A');\n+  string res = oss.str();\n+  \n+  VERIFY( res == \"domingo\" );\n+\n+  return 0;\n+}\n+\n+// Two interpretations of the standard.\n+\n+// 1 : time_get, time_put each have their own data internally\n+//   use internal data for time and date specifics\n+//   use getloc for ctype info\n+\n+// 2 : time_get, time_put use the ios_base& argument and getloc to\n+// retrieve the necessary data.\n+//   use getloc for ctype, time and date specifics\n+\n+// It is my opinion that the language in the standard is sufficiently\n+// vague to permit both interpretations. In particular, the interface\n+// for time_get and time_put is based on strftime, which as\n+// POSIX notes is dependent on LC_TIME. The C++ standard, however,\n+// does not specify the equivalent mappings of LC_TIME to time_get and\n+// time_put.\n+\n+/*\n+The problems with the first approach, as above, are numerous.\n+\n+1) Then locale usage and design for formatters and parers becomes\n+   fragmented. On one side, num_put and money_put, and on the other,\n+   time_put. This inconsistency is not useful.\n+\n+2) The data structures for time and date formatting are the largest in\n+   the locale library. Making time_put and time_get keep separate\n+   copies is inefficient. (Note that time_put and time_get are in the\n+   same locale::category).\n+*/\n+\n+\n+/*\n+22.2.5 - The time category [lib.category.time]\n+\n+-1- Templates time_get<charT,InputIterator> and\n+ time_put<charT,OutputIterator> provide date and time formatting and\n+ parsing. All specifications of member functions for time_put and\n+ time_get in the subclauses of lib.category.time only apply to the\n+ instantiations required in Tables ?? and ??\n+ (lib.locale.category). Their members use their ios_base&,\n+ ios_base::iostate&, and fill arguments as described in\n+ (lib.locale.categories), and the ctype<> facet, to determine\n+ formatting details.\n+*/\n+\n+/*\n+22.2 - Standard locale categories [lib.locale.categories]\n+\n+-1- Each of the standard categories includes a family of facets. Some\n+ of these implement formatting or parsing of a datum, for use by\n+ standard or users' iostream operators << and >>, as members put() and\n+ get(), respectively. Each such member function takes an ios_base&\n+ argument whose members flags(), precision(), and width(), specify the\n+ format of the corresponding datum. (lib.ios.base). Those functions\n+ which need to use other facets call its member getloc() to retrieve\n+ the locale imbued there. Formatting facets use the character argument\n+ fill to fill out the specified width where necessary.\n+*/\n+\n+/*\n+With GCC/libstdc++, the output of the program with the arguments\n+of de_DE es_ES is:\n+     domingo\n+     lunes\n+     martes\n+     mi\ufffdrcoles\n+     jueves\n+     viernes\n+     s\ufffdbado\n+\n+With Intel C++, it is: (this is clearly wrong)\n+     Sunday\n+     Monday\n+     Tuesday\n+     Wednesday\n+     Thursday\n+     Friday\n+     Saturday\n+\n+And with RogueWave C++\n+     Sonntag\n+     Montag\n+     Dienstag\n+     Mittwoch\n+     Donnerstag\n+     Freitag\n+     Samstag\n+*/"}]}