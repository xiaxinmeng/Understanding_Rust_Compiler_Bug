{"sha": "abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkM2M4MDAxMDliOTVmMDlhZjNiM2YxYTdhNDNkOWI3NjMxZjIxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:51:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:51:22Z"}, "message": "Add a gen_int_shift_amount helper function\n\nThis patch adds a helper routine that constructs rtxes\nfor constant shift amounts, given the mode of the value\nbeing shifted.  As well as helping with the SVE patches, this\nis one step towards allowing CONST_INTs to have a real mode.\n\nOne long-standing problem has been to decide what the mode\nof a shift count should be for arbitrary rtxes (as opposed to those\ndirectly tied to a target pattern).  Realistic choices would be\nthe mode of the shifted elements, word_mode, QImode, a 64-bit mode,\nor the same mode as the shift optabs (in which case what should the\nmode be when the target doesn't have a pattern?)\n\nFor now the patch picks a 64-bit mode, but with a ??? comment.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* emit-rtl.h (gen_int_shift_amount): Declare.\n\t* emit-rtl.c (gen_int_shift_amount): New function.\n\t* asan.c (asan_emit_stack_protection): Use gen_int_shift_amount\n\tinstead of GEN_INT.\n\t* calls.c (shift_return_value): Likewise.\n\t* cse.c (fold_rtx): Likewise.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* expmed.c (init_expmed_one_mode, store_bit_field_1, expand_shift_1)\n\t(expand_shift, expand_smod_pow2): Likewise.\n\t* lower-subreg.c (shift_cost): Likewise.\n\t* optabs.c (expand_superword_shift, expand_doubleword_mult)\n\t(expand_unop, expand_binop, shift_amt_for_vec_perm_mask)\n\t(expand_vec_perm_var): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\t(simplify_binary_operation_1): Likewise.\n\t* combine.c (try_combine, find_split_point, force_int_to_mode)\n\t(simplify_shift_const_1, simplify_shift_const): Likewise.\n\t(change_zero_ext): Likewise.  Use simplify_gen_binary.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255861", "tree": {"sha": "87a4afd30dc1d59b47bcd99fe6310f168476084b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87a4afd30dc1d59b47bcd99fe6310f168476084b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/comments", "author": null, "committer": null, "parents": [{"sha": "27d229f709a928adc7c4e464509cc1633d127f3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27d229f709a928adc7c4e464509cc1633d127f3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27d229f709a928adc7c4e464509cc1633d127f3f"}], "stats": {"total": 282, "additions": 178, "deletions": 104}, "files": [{"sha": "8ab443abe1f982ddf02dcf6053b77293ff81b9ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -1,3 +1,26 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* emit-rtl.h (gen_int_shift_amount): Declare.\n+\t* emit-rtl.c (gen_int_shift_amount): New function.\n+\t* asan.c (asan_emit_stack_protection): Use gen_int_shift_amount\n+\tinstead of GEN_INT.\n+\t* calls.c (shift_return_value): Likewise.\n+\t* cse.c (fold_rtx): Likewise.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* expmed.c (init_expmed_one_mode, store_bit_field_1, expand_shift_1)\n+\t(expand_shift, expand_smod_pow2): Likewise.\n+\t* lower-subreg.c (shift_cost): Likewise.\n+\t* optabs.c (expand_superword_shift, expand_doubleword_mult)\n+\t(expand_unop, expand_binop, shift_amt_for_vec_perm_mask)\n+\t(expand_vec_perm_var): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\t(simplify_binary_operation_1): Likewise.\n+\t* combine.c (try_combine, find_split_point, force_int_to_mode)\n+\t(simplify_shift_const_1, simplify_shift_const): Likewise.\n+\t(change_zero_ext): Likewise.  Use simplify_gen_binary.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* poly-int.h (multiple_p): Fix handling of two non-poly_ints."}, {"sha": "c1135af77739e22e6f84528e323382ae62bd5e29", "filename": "gcc/asan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -1386,7 +1386,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   TREE_ASM_WRITTEN (id) = 1;\n   emit_move_insn (mem, expand_normal (build_fold_addr_expr (decl)));\n   shadow_base = expand_binop (Pmode, lshr_optab, base,\n-\t\t\t      GEN_INT (ASAN_SHADOW_SHIFT),\n+\t\t\t      gen_int_shift_amount (Pmode, ASAN_SHADOW_SHIFT),\n \t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n   shadow_base\n     = plus_constant (Pmode, shadow_base,"}, {"sha": "537b34818a6c6a57af9fbeb13f035368b9135cda", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -2938,15 +2938,17 @@ shift_return_value (machine_mode mode, bool left_p, rtx value)\n   HOST_WIDE_INT shift;\n \n   gcc_assert (REG_P (value) && HARD_REGISTER_P (value));\n-  shift = GET_MODE_BITSIZE (GET_MODE (value)) - GET_MODE_BITSIZE (mode);\n+  machine_mode value_mode = GET_MODE (value);\n+  shift = GET_MODE_BITSIZE (value_mode) - GET_MODE_BITSIZE (mode);\n   if (shift == 0)\n     return false;\n \n   /* Use ashr rather than lshr for right shifts.  This is for the benefit\n      of the MIPS port, which requires SImode values to be sign-extended\n      when stored in 64-bit registers.  */\n-  if (!force_expand_binop (GET_MODE (value), left_p ? ashl_optab : ashr_optab,\n-\t\t\t   value, GEN_INT (shift), value, 1, OPTAB_WIDEN))\n+  if (!force_expand_binop (value_mode, left_p ? ashl_optab : ashr_optab,\n+\t\t\t   value, gen_int_shift_amount (value_mode, shift),\n+\t\t\t   value, 1, OPTAB_WIDEN))\n     gcc_unreachable ();\n   return true;\n }"}, {"sha": "72dc7a5ec45a329cd5197b974feb8c1f1d7c67c8", "filename": "gcc/combine.c", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -3804,8 +3804,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t      && INTVAL (XEXP (*split, 1)) > 0\n \t      && (i = exact_log2 (UINTVAL (XEXP (*split, 1)))) >= 0)\n \t    {\n+\t      rtx i_rtx = gen_int_shift_amount (split_mode, i);\n \t      SUBST (*split, gen_rtx_ASHIFT (split_mode,\n-\t\t\t\t\t     XEXP (*split, 0), GEN_INT (i)));\n+\t\t\t\t\t     XEXP (*split, 0), i_rtx));\n \t      /* Update split_code because we may not have a multiply\n \t\t anymore.  */\n \t      split_code = GET_CODE (*split);\n@@ -3819,8 +3820,10 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t      && (i = exact_log2 (UINTVAL (XEXP (XEXP (*split, 0), 1)))) >= 0)\n \t    {\n \t      rtx nsplit = XEXP (*split, 0);\n+\t      rtx i_rtx = gen_int_shift_amount (GET_MODE (nsplit), i);\n \t      SUBST (XEXP (*split, 0), gen_rtx_ASHIFT (GET_MODE (nsplit),\n-\t\t\t\t\t     XEXP (nsplit, 0), GEN_INT (i)));\n+\t\t\t\t\t\t       XEXP (nsplit, 0),\n+\t\t\t\t\t\t       i_rtx));\n \t      /* Update split_code because we may not have a multiply\n \t\t anymore.  */\n \t      split_code = GET_CODE (*split);\n@@ -5088,12 +5091,12 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t\t\t\t\t\t\t     0))))) >= 1))\n \t    {\n \t      machine_mode mode = GET_MODE (XEXP (SET_SRC (x), 0));\n-\n+\t      rtx pos_rtx = gen_int_shift_amount (mode, pos);\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_NEG (mode,\n \t\t\t\t  gen_rtx_LSHIFTRT (mode,\n \t\t\t\t\t\t    XEXP (SET_SRC (x), 0),\n-\t\t\t\t\t\t    GEN_INT (pos))));\n+\t\t\t\t\t\t    pos_rtx)));\n \n \t      split = find_split_point (&SET_SRC (x), insn, true);\n \t      if (split && split != &SET_SRC (x))\n@@ -5151,11 +5154,11 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t    {\n \t      unsigned HOST_WIDE_INT mask\n \t\t= (HOST_WIDE_INT_1U << len) - 1;\n+\t      rtx pos_rtx = gen_int_shift_amount (mode, pos);\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_AND (mode,\n \t\t\t\t  gen_rtx_LSHIFTRT\n-\t\t\t\t  (mode, gen_lowpart (mode, inner),\n-\t\t\t\t   GEN_INT (pos)),\n+\t\t\t\t  (mode, gen_lowpart (mode, inner), pos_rtx),\n \t\t\t\t  gen_int_mode (mask, mode)));\n \n \t      split = find_split_point (&SET_SRC (x), insn, true);\n@@ -5164,14 +5167,15 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t    }\n \t  else\n \t    {\n+\t      int left_bits = GET_MODE_PRECISION (mode) - len - pos;\n+\t      int right_bits = GET_MODE_PRECISION (mode) - len;\n \t      SUBST (SET_SRC (x),\n \t\t     gen_rtx_fmt_ee\n \t\t     (unsignedp ? LSHIFTRT : ASHIFTRT, mode,\n \t\t      gen_rtx_ASHIFT (mode,\n \t\t\t\t      gen_lowpart (mode, inner),\n-\t\t\t\t      GEN_INT (GET_MODE_PRECISION (mode)\n-\t\t\t\t\t       - len - pos)),\n-\t\t      GEN_INT (GET_MODE_PRECISION (mode) - len)));\n+\t\t\t\t      gen_int_shift_amount (mode, left_bits)),\n+\t\t      gen_int_shift_amount (mode, right_bits)));\n \n \t      split = find_split_point (&SET_SRC (x), insn, true);\n \t      if (split && split != &SET_SRC (x))\n@@ -8952,10 +8956,11 @@ force_int_to_mode (rtx x, scalar_int_mode mode, scalar_int_mode xmode,\n \t  /* Must be more sign bit copies than the mask needs.  */\n \t  && ((int) num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n \t      >= exact_log2 (mask + 1)))\n-\tx = simplify_gen_binary (LSHIFTRT, xmode, XEXP (x, 0),\n-\t\t\t\t GEN_INT (GET_MODE_PRECISION (xmode)\n-\t\t\t\t\t  - exact_log2 (mask + 1)));\n-\n+\t{\n+\t  int nbits = GET_MODE_PRECISION (xmode) - exact_log2 (mask + 1);\n+\t  x = simplify_gen_binary (LSHIFTRT, xmode, XEXP (x, 0),\n+\t\t\t\t   gen_int_shift_amount (xmode, nbits));\n+\t}\n       goto shiftrt;\n \n     case ASHIFTRT:\n@@ -10448,7 +10453,7 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n {\n   enum rtx_code orig_code = code;\n   rtx orig_varop = varop;\n-  int count;\n+  int count, log2;\n   machine_mode mode = result_mode;\n   machine_mode shift_mode;\n   scalar_int_mode tmode, inner_mode, int_mode, int_varop_mode, int_result_mode;\n@@ -10651,27 +10656,23 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t     is cheaper.  But it is still better on those machines to\n \t     merge two shifts into one.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n-\t      && exact_log2 (UINTVAL (XEXP (varop, 1))) >= 0)\n+\t      && (log2 = exact_log2 (UINTVAL (XEXP (varop, 1)))) >= 0)\n \t    {\n-\t      varop\n-\t\t= simplify_gen_binary (ASHIFT, GET_MODE (varop),\n-\t\t\t\t       XEXP (varop, 0),\n-\t\t\t\t       GEN_INT (exact_log2 (\n-\t\t\t\t\t\tUINTVAL (XEXP (varop, 1)))));\n+\t      rtx log2_rtx = gen_int_shift_amount (GET_MODE (varop), log2);\n+\t      varop = simplify_gen_binary (ASHIFT, GET_MODE (varop),\n+\t\t\t\t\t   XEXP (varop, 0), log2_rtx);\n \t      continue;\n \t    }\n \t  break;\n \n \tcase UDIV:\n \t  /* Similar, for when divides are cheaper.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n-\t      && exact_log2 (UINTVAL (XEXP (varop, 1))) >= 0)\n+\t      && (log2 = exact_log2 (UINTVAL (XEXP (varop, 1)))) >= 0)\n \t    {\n-\t      varop\n-\t\t= simplify_gen_binary (LSHIFTRT, GET_MODE (varop),\n-\t\t\t\t       XEXP (varop, 0),\n-\t\t\t\t       GEN_INT (exact_log2 (\n-\t\t\t\t\t\tUINTVAL (XEXP (varop, 1)))));\n+\t      rtx log2_rtx = gen_int_shift_amount (GET_MODE (varop), log2);\n+\t      varop = simplify_gen_binary (LSHIFTRT, GET_MODE (varop),\n+\t\t\t\t\t   XEXP (varop, 0), log2_rtx);\n \t      continue;\n \t    }\n \t  break;\n@@ -10806,10 +10807,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \n \t      mask_rtx = gen_int_mode (nonzero_bits (varop, int_varop_mode),\n \t\t\t\t       int_result_mode);\n-\n+\t      rtx count_rtx = gen_int_shift_amount (int_result_mode, count);\n \t      mask_rtx\n \t\t= simplify_const_binary_operation (code, int_result_mode,\n-\t\t\t\t\t\t   mask_rtx, GEN_INT (count));\n+\t\t\t\t\t\t   mask_rtx, count_rtx);\n \n \t      /* Give up if we can't compute an outer operation to use.  */\n \t      if (mask_rtx == 0\n@@ -10865,9 +10866,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t      if (code == ASHIFTRT && int_mode != int_result_mode)\n \t\tbreak;\n \n+\t      rtx count_rtx = gen_int_shift_amount (int_result_mode, count);\n \t      rtx new_rtx = simplify_const_binary_operation (code, int_mode,\n \t\t\t\t\t\t\t     XEXP (varop, 0),\n-\t\t\t\t\t\t\t     GEN_INT (count));\n+\t\t\t\t\t\t\t     count_rtx);\n \t      varop = gen_rtx_fmt_ee (code, int_mode, new_rtx, XEXP (varop, 1));\n \t      count = 0;\n \t      continue;\n@@ -10933,7 +10935,7 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t      && (new_rtx = simplify_const_binary_operation\n \t\t  (code, int_result_mode,\n \t\t   gen_int_mode (INTVAL (XEXP (varop, 1)), int_result_mode),\n-\t\t   GEN_INT (count))) != 0\n+\t\t   gen_int_shift_amount (int_result_mode, count))) != 0\n \t      && CONST_INT_P (new_rtx)\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n \t\t\t\t  INTVAL (new_rtx), int_result_mode,\n@@ -11076,7 +11078,7 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t      && (new_rtx = simplify_const_binary_operation\n \t\t  (ASHIFT, int_result_mode,\n \t\t   gen_int_mode (INTVAL (XEXP (varop, 1)), int_result_mode),\n-\t\t   GEN_INT (count))) != 0\n+\t\t   gen_int_shift_amount (int_result_mode, count))) != 0\n \t      && CONST_INT_P (new_rtx)\n \t      && merge_outer_ops (&outer_op, &outer_const, PLUS,\n \t\t\t\t  INTVAL (new_rtx), int_result_mode,\n@@ -11097,7 +11099,7 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t      && (new_rtx = simplify_const_binary_operation\n \t\t  (code, int_result_mode,\n \t\t   gen_int_mode (INTVAL (XEXP (varop, 1)), int_result_mode),\n-\t\t   GEN_INT (count))) != 0\n+\t\t   gen_int_shift_amount (int_result_mode, count))) != 0\n \t      && CONST_INT_P (new_rtx)\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  INTVAL (new_rtx), int_result_mode,\n@@ -11152,12 +11154,12 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t\t      - GET_MODE_UNIT_PRECISION (GET_MODE (varop)))))\n \t    {\n \t      rtx varop_inner = XEXP (varop, 0);\n-\n-\t      varop_inner\n-\t\t= gen_rtx_LSHIFTRT (GET_MODE (varop_inner),\n-\t\t\t\t    XEXP (varop_inner, 0),\n-\t\t\t\t    GEN_INT\n-\t\t\t\t    (count + INTVAL (XEXP (varop_inner, 1))));\n+\t      int new_count = count + INTVAL (XEXP (varop_inner, 1));\n+\t      rtx new_count_rtx = gen_int_shift_amount (GET_MODE (varop_inner),\n+\t\t\t\t\t\t\tnew_count);\n+\t      varop_inner = gen_rtx_LSHIFTRT (GET_MODE (varop_inner),\n+\t\t\t\t\t      XEXP (varop_inner, 0),\n+\t\t\t\t\t      new_count_rtx);\n \t      varop = gen_rtx_TRUNCATE (GET_MODE (varop), varop_inner);\n \t      count = 0;\n \t      continue;\n@@ -11209,7 +11211,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n     x = NULL_RTX;\n \n   if (x == NULL_RTX)\n-    x = simplify_gen_binary (code, shift_mode, varop, GEN_INT (count));\n+    x = simplify_gen_binary (code, shift_mode, varop,\n+\t\t\t     gen_int_shift_amount (shift_mode, count));\n \n   /* If we were doing an LSHIFTRT in a wider mode than it was originally,\n      turn off all the bits that the shift would have turned off.  */\n@@ -11271,7 +11274,8 @@ simplify_shift_const (rtx x, enum rtx_code code, machine_mode result_mode,\n     return tem;\n \n   if (!x)\n-    x = simplify_gen_binary (code, GET_MODE (varop), varop, GEN_INT (count));\n+    x = simplify_gen_binary (code, GET_MODE (varop), varop,\n+\t\t\t     gen_int_shift_amount (GET_MODE (varop), count));\n   if (GET_MODE (x) != result_mode)\n     x = gen_lowpart (result_mode, x);\n   return x;\n@@ -11462,8 +11466,9 @@ change_zero_ext (rtx pat)\n \t  if (BITS_BIG_ENDIAN)\n \t    start = GET_MODE_PRECISION (inner_mode) - size - start;\n \n-\t  if (start)\n-\t    x = gen_rtx_LSHIFTRT (inner_mode, XEXP (x, 0), GEN_INT (start));\n+\t  if (start != 0)\n+\t    x = gen_rtx_LSHIFTRT (inner_mode, XEXP (x, 0),\n+\t\t\t\t  gen_int_shift_amount (inner_mode, start));\n \t  else\n \t    x = XEXP (x, 0);\n \t  if (mode != inner_mode)"}, {"sha": "d6e3e7e469ddcc92b53e142817b7f0b2ffd3b195", "filename": "gcc/cse.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -3611,9 +3611,9 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t\t      || INTVAL (const_arg1) < 0))\n \t\t{\n \t\t  if (SHIFT_COUNT_TRUNCATED)\n-\t\t    canon_const_arg1 = GEN_INT (INTVAL (const_arg1)\n-\t\t\t\t\t\t& (GET_MODE_UNIT_BITSIZE (mode)\n-\t\t\t\t\t\t   - 1));\n+\t\t    canon_const_arg1 = gen_int_shift_amount\n+\t\t      (mode, (INTVAL (const_arg1)\n+\t\t\t      & (GET_MODE_UNIT_BITSIZE (mode) - 1)));\n \t\t  else\n \t\t    break;\n \t\t}\n@@ -3660,9 +3660,9 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t\t      || INTVAL (inner_const) < 0))\n \t\t{\n \t\t  if (SHIFT_COUNT_TRUNCATED)\n-\t\t    inner_const = GEN_INT (INTVAL (inner_const)\n-\t\t\t\t\t   & (GET_MODE_UNIT_BITSIZE (mode)\n-\t\t\t\t\t      - 1));\n+\t\t    inner_const = gen_int_shift_amount\n+\t\t      (mode, (INTVAL (inner_const)\n+\t\t\t      & (GET_MODE_UNIT_BITSIZE (mode) - 1)));\n \t\t  else\n \t\t    break;\n \t\t}\n@@ -3692,7 +3692,8 @@ fold_rtx (rtx x, rtx_insn *insn)\n \t\t  /* As an exception, we can turn an ASHIFTRT of this\n \t\t     form into a shift of the number of bits - 1.  */\n \t\t  if (code == ASHIFTRT)\n-\t\t    new_const = GEN_INT (GET_MODE_UNIT_BITSIZE (mode) - 1);\n+\t\t    new_const = gen_int_shift_amount\n+\t\t      (mode, GET_MODE_UNIT_BITSIZE (mode) - 1);\n \t\t  else if (!side_effects_p (XEXP (y, 0)))\n \t\t    return CONST0_RTX (mode);\n \t\t  else"}, {"sha": "c14eace483e34f70ca5b793c66b2dde2b4ed491f", "filename": "gcc/dse.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -1642,8 +1642,9 @@ find_shift_sequence (int access_size,\n \t\t\t\t     store_mode, byte);\n \t  if (ret && CONSTANT_P (ret))\n \t    {\n+\t      rtx shift_rtx = gen_int_shift_amount (new_mode, shift);\n \t      ret = simplify_const_binary_operation (LSHIFTRT, new_mode,\n-\t\t\t\t\t\t     ret, GEN_INT (shift));\n+\t\t\t\t\t\t     ret, shift_rtx);\n \t      if (ret && CONSTANT_P (ret))\n \t\t{\n \t\t  byte = subreg_lowpart_offset (read_mode, new_mode);\n@@ -1679,7 +1680,8 @@ find_shift_sequence (int access_size,\n \t of one dsp where the cost of these two was not the same.  But\n \t this really is a rare case anyway.  */\n       target = expand_binop (new_mode, lshr_optab, new_reg,\n-\t\t\t     GEN_INT (shift), new_reg, 1, OPTAB_DIRECT);\n+\t\t\t     gen_int_shift_amount (new_mode, shift),\n+\t\t\t     new_reg, 1, OPTAB_DIRECT);\n \n       shift_seq = get_insns ();\n       end_sequence ();"}, {"sha": "8dab3308cda90e8d9a2e3ea7d9e6687eb6efee5e", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -6418,6 +6418,22 @@ need_atomic_barrier_p (enum memmodel model, bool pre)\n     }\n }\n \n+/* Return a constant shift amount for shifting a value of mode MODE\n+   by VALUE bits.  */\n+\n+rtx\n+gen_int_shift_amount (machine_mode, HOST_WIDE_INT value)\n+{\n+  /* Use a 64-bit mode, to avoid any truncation.\n+\n+     ??? Perhaps this should be automatically derived from the .md files\n+     instead, or perhaps have a target hook.  */\n+  scalar_int_mode shift_mode = (BITS_PER_UNIT == 8\n+\t\t\t\t? DImode\n+\t\t\t\t: int_mode_for_size (64, 0).require ());\n+  return gen_int_mode (value, shift_mode);\n+}\n+\n /* Initialize fields of rtl_data related to stack alignment.  */\n \n void"}, {"sha": "7fb8770904840d2f38c0946370969b55afd2cf03", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -369,6 +369,7 @@ extern void set_reg_attrs_for_parm (rtx, rtx);\n extern void set_reg_attrs_for_decl_rtl (tree t, rtx x);\n extern void adjust_reg_mode (rtx, machine_mode);\n extern int mem_expr_equal_p (const_tree, const_tree);\n+extern rtx gen_int_shift_amount (machine_mode, HOST_WIDE_INT);\n \n extern bool need_atomic_barrier_p (enum memmodel, bool);\n "}, {"sha": "d663577a62d18decfa335ac3638601724da1c766", "filename": "gcc/expmed.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -223,7 +223,8 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n \t  PUT_MODE (all->zext, wider_mode);\n \t  PUT_MODE (all->wide_mult, wider_mode);\n \t  PUT_MODE (all->wide_lshr, wider_mode);\n-\t  XEXP (all->wide_lshr, 1) = GEN_INT (mode_bitsize);\n+\t  XEXP (all->wide_lshr, 1)\n+\t    = gen_int_shift_amount (wider_mode, mode_bitsize);\n \n \t  set_mul_widen_cost (speed, wider_mode,\n \t\t\t      set_src_cost (all->wide_mult, wider_mode, speed));\n@@ -910,12 +911,14 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t     to make sure that for big-endian machines the higher order\n \t     bits are used.  */\n \t  if (new_bitsize < BITS_PER_WORD && BYTES_BIG_ENDIAN && !backwards)\n-\t    value_word = simplify_expand_binop (word_mode, lshr_optab,\n-\t\t\t\t\t\tvalue_word,\n-\t\t\t\t\t\tGEN_INT (BITS_PER_WORD\n-\t\t\t\t\t\t\t - new_bitsize),\n-\t\t\t\t\t\tNULL_RTX, true,\n-\t\t\t\t\t\tOPTAB_LIB_WIDEN);\n+\t    {\n+\t      int shift = BITS_PER_WORD - new_bitsize;\n+\t      rtx shift_rtx = gen_int_shift_amount (word_mode, shift);\n+\t      value_word = simplify_expand_binop (word_mode, lshr_optab,\n+\t\t\t\t\t\t  value_word, shift_rtx,\n+\t\t\t\t\t\t  NULL_RTX, true,\n+\t\t\t\t\t\t  OPTAB_LIB_WIDEN);\n+\t    }\n \n \t  if (!store_bit_field_1 (op0, new_bitsize,\n \t\t\t\t  bitnum + bit_offset,\n@@ -2366,8 +2369,9 @@ expand_shift_1 (enum tree_code code, machine_mode mode, rtx shifted,\n       if (CONST_INT_P (op1)\n \t  && ((unsigned HOST_WIDE_INT) INTVAL (op1) >=\n \t      (unsigned HOST_WIDE_INT) GET_MODE_BITSIZE (scalar_mode)))\n-\top1 = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (op1)\n-\t\t       % GET_MODE_BITSIZE (scalar_mode));\n+\top1 = gen_int_shift_amount (mode,\n+\t\t\t\t    (unsigned HOST_WIDE_INT) INTVAL (op1)\n+\t\t\t\t    % GET_MODE_BITSIZE (scalar_mode));\n       else if (GET_CODE (op1) == SUBREG\n \t       && subreg_lowpart_p (op1)\n \t       && SCALAR_INT_MODE_P (GET_MODE (SUBREG_REG (op1)))\n@@ -2384,7 +2388,8 @@ expand_shift_1 (enum tree_code code, machine_mode mode, rtx shifted,\n       && IN_RANGE (INTVAL (op1), GET_MODE_BITSIZE (scalar_mode) / 2 + left,\n \t\t   GET_MODE_BITSIZE (scalar_mode) - 1))\n     {\n-      op1 = GEN_INT (GET_MODE_BITSIZE (scalar_mode) - INTVAL (op1));\n+      op1 = gen_int_shift_amount (mode, (GET_MODE_BITSIZE (scalar_mode)\n+\t\t\t\t\t - INTVAL (op1)));\n       left = !left;\n       code = left ? LROTATE_EXPR : RROTATE_EXPR;\n     }\n@@ -2464,8 +2469,8 @@ expand_shift_1 (enum tree_code code, machine_mode mode, rtx shifted,\n \t      if (op1 == const0_rtx)\n \t\treturn shifted;\n \t      else if (CONST_INT_P (op1))\n-\t\tother_amount = GEN_INT (GET_MODE_BITSIZE (scalar_mode)\n-\t\t\t\t\t- INTVAL (op1));\n+\t\tother_amount = gen_int_shift_amount\n+\t\t  (mode, GET_MODE_BITSIZE (scalar_mode) - INTVAL (op1));\n \t      else\n \t\t{\n \t\t  other_amount\n@@ -2538,8 +2543,9 @@ rtx\n expand_shift (enum tree_code code, machine_mode mode, rtx shifted,\n \t      int amount, rtx target, int unsignedp)\n {\n-  return expand_shift_1 (code, mode,\n-\t\t\t shifted, GEN_INT (amount), target, unsignedp);\n+  return expand_shift_1 (code, mode, shifted,\n+\t\t\t gen_int_shift_amount (mode, amount),\n+\t\t\t target, unsignedp);\n }\n \n /* Likewise, but return 0 if that cannot be done.  */\n@@ -3857,7 +3863,7 @@ expand_smod_pow2 (scalar_int_mode mode, rtx op0, HOST_WIDE_INT d)\n \t{\n \t  HOST_WIDE_INT masklow = (HOST_WIDE_INT_1 << logd) - 1;\n \t  signmask = force_reg (mode, signmask);\n-\t  shift = GEN_INT (GET_MODE_BITSIZE (mode) - logd);\n+\t  shift = gen_int_shift_amount (mode, GET_MODE_BITSIZE (mode) - logd);\n \n \t  /* Use the rtx_cost of a LSHIFTRT instruction to determine\n \t     which instruction sequence to use.  If logical right shifts"}, {"sha": "b54e0703d097a572d9da108ddfa725d23c461eaa", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -141,7 +141,7 @@ shift_cost (bool speed_p, struct cost_rtxes *rtxes, enum rtx_code code,\n   PUT_CODE (rtxes->shift, code);\n   PUT_MODE (rtxes->shift, mode);\n   PUT_MODE (rtxes->source, mode);\n-  XEXP (rtxes->shift, 1) = GEN_INT (op1);\n+  XEXP (rtxes->shift, 1) = gen_int_shift_amount (mode, op1);\n   return set_src_cost (rtxes->shift, mode, speed_p);\n }\n "}, {"sha": "b0d82afbbc0a0ec4b46ce02c9c67997de36cd1d8", "filename": "gcc/optabs.c", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -431,8 +431,9 @@ expand_superword_shift (optab binoptab, rtx outof_input, rtx superword_op1,\n       if (binoptab != ashr_optab)\n \temit_move_insn (outof_target, CONST0_RTX (word_mode));\n       else\n-\tif (!force_expand_binop (word_mode, binoptab,\n-\t\t\t\t outof_input, GEN_INT (BITS_PER_WORD - 1),\n+\tif (!force_expand_binop (word_mode, binoptab, outof_input,\n+\t\t\t\t gen_int_shift_amount (word_mode,\n+\t\t\t\t\t\t       BITS_PER_WORD - 1),\n \t\t\t\t outof_target, unsignedp, methods))\n \t  return false;\n     }\n@@ -789,7 +790,8 @@ expand_doubleword_mult (machine_mode mode, rtx op0, rtx op1, rtx target,\n {\n   int low = (WORDS_BIG_ENDIAN ? 1 : 0);\n   int high = (WORDS_BIG_ENDIAN ? 0 : 1);\n-  rtx wordm1 = umulp ? NULL_RTX : GEN_INT (BITS_PER_WORD - 1);\n+  rtx wordm1 = (umulp ? NULL_RTX\n+\t\t: gen_int_shift_amount (word_mode, BITS_PER_WORD - 1));\n   rtx product, adjust, product_high, temp;\n \n   rtx op0_high = operand_subword_force (op0, high, mode);\n@@ -1190,7 +1192,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       unsigned int bits = GET_MODE_PRECISION (int_mode);\n \n       if (CONST_INT_P (op1))\n-        newop1 = GEN_INT (bits - INTVAL (op1));\n+\tnewop1 = gen_int_shift_amount (int_mode, bits - INTVAL (op1));\n       else if (targetm.shift_truncation_mask (int_mode) == bits - 1)\n         newop1 = negate_rtx (GET_MODE (op1), op1);\n       else\n@@ -1412,7 +1414,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       /* Apply the truncation to constant shifts.  */\n       if (double_shift_mask > 0 && CONST_INT_P (op1))\n-\top1 = GEN_INT (INTVAL (op1) & double_shift_mask);\n+\top1 = gen_int_mode (INTVAL (op1) & double_shift_mask, op1_mode);\n \n       if (op1 == CONST0_RTX (op1_mode))\n \treturn op0;\n@@ -1522,7 +1524,7 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       else\n \t{\n \t  rtx into_temp1, into_temp2, outof_temp1, outof_temp2;\n-\t  rtx first_shift_count, second_shift_count;\n+\t  HOST_WIDE_INT first_shift_count, second_shift_count;\n \t  optab reverse_unsigned_shift, unsigned_shift;\n \n \t  reverse_unsigned_shift = (left_shift ^ (shift_count < BITS_PER_WORD)\n@@ -1533,20 +1535,24 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n \t  if (shift_count > BITS_PER_WORD)\n \t    {\n-\t      first_shift_count = GEN_INT (shift_count - BITS_PER_WORD);\n-\t      second_shift_count = GEN_INT (2 * BITS_PER_WORD - shift_count);\n+\t      first_shift_count = shift_count - BITS_PER_WORD;\n+\t      second_shift_count = 2 * BITS_PER_WORD - shift_count;\n \t    }\n \t  else\n \t    {\n-\t      first_shift_count = GEN_INT (BITS_PER_WORD - shift_count);\n-\t      second_shift_count = GEN_INT (shift_count);\n+\t      first_shift_count = BITS_PER_WORD - shift_count;\n+\t      second_shift_count = shift_count;\n \t    }\n+\t  rtx first_shift_count_rtx\n+\t    = gen_int_shift_amount (word_mode, first_shift_count);\n+\t  rtx second_shift_count_rtx\n+\t    = gen_int_shift_amount (word_mode, second_shift_count);\n \n \t  into_temp1 = expand_binop (word_mode, unsigned_shift,\n-\t\t\t\t     outof_input, first_shift_count,\n+\t\t\t\t     outof_input, first_shift_count_rtx,\n \t\t\t\t     NULL_RTX, unsignedp, next_methods);\n \t  into_temp2 = expand_binop (word_mode, reverse_unsigned_shift,\n-\t\t\t\t     into_input, second_shift_count,\n+\t\t\t\t     into_input, second_shift_count_rtx,\n \t\t\t\t     NULL_RTX, unsignedp, next_methods);\n \n \t  if (into_temp1 != 0 && into_temp2 != 0)\n@@ -1559,10 +1565,10 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t    emit_move_insn (into_target, inter);\n \n \t  outof_temp1 = expand_binop (word_mode, unsigned_shift,\n-\t\t\t\t      into_input, first_shift_count,\n+\t\t\t\t      into_input, first_shift_count_rtx,\n \t\t\t\t      NULL_RTX, unsignedp, next_methods);\n \t  outof_temp2 = expand_binop (word_mode, reverse_unsigned_shift,\n-\t\t\t\t      outof_input, second_shift_count,\n+\t\t\t\t      outof_input, second_shift_count_rtx,\n \t\t\t\t      NULL_RTX, unsignedp, next_methods);\n \n \t  if (inter != 0 && outof_temp1 != 0 && outof_temp2 != 0)\n@@ -2802,25 +2808,29 @@ expand_unop (machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n \t  if (optab_handler (rotl_optab, mode) != CODE_FOR_nothing)\n \t    {\n-\t      temp = expand_binop (mode, rotl_optab, op0, GEN_INT (8), target,\n-\t\t\t\t   unsignedp, OPTAB_DIRECT);\n+\t      temp = expand_binop (mode, rotl_optab, op0,\n+\t\t\t\t   gen_int_shift_amount (mode, 8),\n+\t\t\t\t   target, unsignedp, OPTAB_DIRECT);\n \t      if (temp)\n \t\treturn temp;\n \t     }\n \n \t  if (optab_handler (rotr_optab, mode) != CODE_FOR_nothing)\n \t    {\n-\t      temp = expand_binop (mode, rotr_optab, op0, GEN_INT (8), target,\n-\t\t\t\t   unsignedp, OPTAB_DIRECT);\n+\t      temp = expand_binop (mode, rotr_optab, op0,\n+\t\t\t\t   gen_int_shift_amount (mode, 8),\n+\t\t\t\t   target, unsignedp, OPTAB_DIRECT);\n \t      if (temp)\n \t\treturn temp;\n \t    }\n \n \t  last = get_last_insn ();\n \n-\t  temp1 = expand_binop (mode, ashl_optab, op0, GEN_INT (8), NULL_RTX,\n+\t  temp1 = expand_binop (mode, ashl_optab, op0,\n+\t\t\t\tgen_int_shift_amount (mode, 8), NULL_RTX,\n \t\t\t        unsignedp, OPTAB_WIDEN);\n-\t  temp2 = expand_binop (mode, lshr_optab, op0, GEN_INT (8), NULL_RTX,\n+\t  temp2 = expand_binop (mode, lshr_optab, op0,\n+\t\t\t\tgen_int_shift_amount (mode, 8), NULL_RTX,\n \t\t\t        unsignedp, OPTAB_WIDEN);\n \t  if (temp1 && temp2)\n \t    {\n@@ -5402,7 +5412,7 @@ shift_amt_for_vec_perm_mask (rtx sel)\n \treturn NULL_RTX;\n     }\n \n-  return GEN_INT (first * bitsize);\n+  return gen_int_shift_amount (GET_MODE (sel), first * bitsize);\n }\n \n /* A subroutine of expand_vec_perm for expanding one vec_perm insn.  */\n@@ -5572,7 +5582,8 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n \t\t\t\t   NULL, 0, OPTAB_DIRECT);\n       else\n \tsel = expand_simple_binop (selmode, ASHIFT, sel,\n-\t\t\t\t   GEN_INT (exact_log2 (u)),\n+\t\t\t\t   gen_int_shift_amount (selmode,\n+\t\t\t\t\t\t\t exact_log2 (u)),\n \t\t\t\t   NULL, 0, OPTAB_DIRECT);\n       gcc_assert (sel != NULL);\n "}, {"sha": "dec6caebac5e902b1511305cc4b144c9745a4d4a", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd3c800109b95f09af3b3f1a7a43d9b7631f21c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=abd3c800109b95f09af3b3f1a7a43d9b7631f21c", "patch": "@@ -1165,7 +1165,8 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  if (STORE_FLAG_VALUE == 1)\n \t    {\n \t      temp = simplify_gen_binary (ASHIFTRT, inner, XEXP (op, 0),\n-\t\t\t\t\t  GEN_INT (isize - 1));\n+\t\t\t\t\t  gen_int_shift_amount (inner,\n+\t\t\t\t\t\t\t\tisize - 1));\n \t      if (int_mode == inner)\n \t\treturn temp;\n \t      if (GET_MODE_PRECISION (int_mode) > isize)\n@@ -1175,7 +1176,8 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n \t  else if (STORE_FLAG_VALUE == -1)\n \t    {\n \t      temp = simplify_gen_binary (LSHIFTRT, inner, XEXP (op, 0),\n-\t\t\t\t\t  GEN_INT (isize - 1));\n+\t\t\t\t\t  gen_int_shift_amount (inner,\n+\t\t\t\t\t\t\t\tisize - 1));\n \t      if (int_mode == inner)\n \t\treturn temp;\n \t      if (GET_MODE_PRECISION (int_mode) > isize)\n@@ -2672,7 +2674,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t{\n \t  val = wi::exact_log2 (rtx_mode_t (trueop1, mode));\n \t  if (val >= 0)\n-\t    return simplify_gen_binary (ASHIFT, mode, op0, GEN_INT (val));\n+\t    return simplify_gen_binary (ASHIFT, mode, op0,\n+\t\t\t\t\tgen_int_shift_amount (mode, val));\n \t}\n \n       /* x*2 is x+x and x*(-1) is -x */\n@@ -3296,7 +3299,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n       /* Convert divide by power of two into shift.  */\n       if (CONST_INT_P (trueop1)\n \t  && (val = exact_log2 (UINTVAL (trueop1))) > 0)\n-\treturn simplify_gen_binary (LSHIFTRT, mode, op0, GEN_INT (val));\n+\treturn simplify_gen_binary (LSHIFTRT, mode, op0,\n+\t\t\t\t    gen_int_shift_amount (mode, val));\n       break;\n \n     case DIV:\n@@ -3416,10 +3420,12 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  && IN_RANGE (INTVAL (trueop1),\n \t\t       GET_MODE_UNIT_PRECISION (mode) / 2 + (code == ROTATE),\n \t\t       GET_MODE_UNIT_PRECISION (mode) - 1))\n-\treturn simplify_gen_binary (code == ROTATE ? ROTATERT : ROTATE,\n-\t\t\t\t    mode, op0,\n-\t\t\t\t    GEN_INT (GET_MODE_UNIT_PRECISION (mode)\n-\t\t\t\t\t     - INTVAL (trueop1)));\n+\t{\n+\t  int new_amount = GET_MODE_UNIT_PRECISION (mode) - INTVAL (trueop1);\n+\t  rtx new_amount_rtx = gen_int_shift_amount (mode, new_amount);\n+\t  return simplify_gen_binary (code == ROTATE ? ROTATERT : ROTATE,\n+\t\t\t\t      mode, op0, new_amount_rtx);\n+\t}\n #endif\n       /* FALLTHRU */\n     case ASHIFTRT:\n@@ -3460,8 +3466,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t      == GET_MODE_BITSIZE (inner_mode) - GET_MODE_BITSIZE (int_mode))\n \t  && subreg_lowpart_p (op0))\n \t{\n-\t  rtx tmp = GEN_INT (INTVAL (XEXP (SUBREG_REG (op0), 1))\n-\t\t\t     + INTVAL (op1));\n+\t  rtx tmp = gen_int_shift_amount\n+\t    (inner_mode, INTVAL (XEXP (SUBREG_REG (op0), 1)) + INTVAL (op1));\n \t  tmp = simplify_gen_binary (code, inner_mode,\n \t\t\t\t     XEXP (SUBREG_REG (op0), 0),\n \t\t\t\t     tmp);\n@@ -3472,7 +3478,8 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t{\n \t  val = INTVAL (op1) & (GET_MODE_UNIT_PRECISION (mode) - 1);\n \t  if (val != INTVAL (op1))\n-\t    return simplify_gen_binary (code, mode, op0, GEN_INT (val));\n+\t    return simplify_gen_binary (code, mode, op0,\n+\t\t\t\t\tgen_int_shift_amount (mode, val));\n \t}\n       break;\n "}]}