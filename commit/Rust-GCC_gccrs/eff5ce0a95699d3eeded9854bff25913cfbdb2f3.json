{"sha": "eff5ce0a95699d3eeded9854bff25913cfbdb2f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZmNWNlMGE5NTY5OWQzZWVkZWQ5ODU0YmZmMjU5MTNjZmJkYjJmMw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:04:54Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:04:54Z"}, "message": "[arm] Early expansion of usubvdi4.\n\nThis patch adds early expansion of usubvdi4, allowing us to handle some\nconstants in place, which previously we were unable to do.\n\n\t* config/arm/arm.md (usubvdi4): Allow registers or integers for\n\tincoming operands.  Early split the calculation into SImode\n\toperations.\n\t(usubvsi3_borrow): New insn pattern.\n\t(usubvsi3_borrow_imm): Likewise.\n\nFrom-SVN: r277188", "tree": {"sha": "506436cf56210cb90db44b536668b0ee27451b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/506436cf56210cb90db44b536668b0ee27451b5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eff5ce0a95699d3eeded9854bff25913cfbdb2f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff5ce0a95699d3eeded9854bff25913cfbdb2f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff5ce0a95699d3eeded9854bff25913cfbdb2f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff5ce0a95699d3eeded9854bff25913cfbdb2f3/comments", "author": null, "committer": null, "parents": [{"sha": "a79048f6250febc1acce09d790035276d534e754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79048f6250febc1acce09d790035276d534e754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79048f6250febc1acce09d790035276d534e754"}], "stats": {"total": 121, "additions": 117, "deletions": 4}, "files": [{"sha": "dbc421de968674cbc1aea5c192b13b8581eabac0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff5ce0a95699d3eeded9854bff25913cfbdb2f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff5ce0a95699d3eeded9854bff25913cfbdb2f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eff5ce0a95699d3eeded9854bff25913cfbdb2f3", "patch": "@@ -1,3 +1,11 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.md (usubvdi4): Allow registers or integers for\n+\tincoming operands.  Early split the calculation into SImode\n+\toperations.\n+\t(usubvsi3_borrow): New insn pattern.\n+\t(usubvsi3_borrow_imm): Likewise.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm.md (usubv<mode>4): Delete expansion."}, {"sha": "92f1823cdfac07b91f9001b920040e6a1221d5da", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff5ce0a95699d3eeded9854bff25913cfbdb2f3/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff5ce0a95699d3eeded9854bff25913cfbdb2f3/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=eff5ce0a95699d3eeded9854bff25913cfbdb2f3", "patch": "@@ -1390,13 +1390,81 @@\n \n (define_expand \"usubvdi4\"\n   [(match_operand:DI 0 \"s_register_operand\")\n-   (match_operand:DI 1 \"s_register_operand\")\n-   (match_operand:DI 2 \"s_register_operand\")\n+   (match_operand:DI 1 \"reg_or_int_operand\")\n+   (match_operand:DI 2 \"reg_or_int_operand\")\n    (match_operand 3 \"\")]\n   \"TARGET_32BIT\"\n {\n-  emit_insn (gen_subdi3_compare1 (operands[0], operands[1], operands[2]));\n-  arm_gen_unlikely_cbranch (LTU, CCmode, operands[3]);\n+  rtx lo_result, hi_result;\n+  rtx lo_op1, hi_op1, lo_op2, hi_op2;\n+  lo_result = gen_lowpart (SImode, operands[0]);\n+  hi_result = gen_highpart (SImode, operands[0]);\n+  machine_mode mode = CCmode;\n+\n+  if (CONST_INT_P (operands[1]) && CONST_INT_P (operands[2]))\n+    {\n+      /* If both operands are constants we can decide the result statically.  */\n+      wi::overflow_type overflow;\n+      wide_int val = wi::sub (rtx_mode_t (operands[1], DImode),\n+\t\t\t      rtx_mode_t (operands[2], DImode),\n+\t\t\t      UNSIGNED, &overflow);\n+      emit_move_insn (operands[0], GEN_INT (val.to_shwi ()));\n+      if (overflow != wi::OVF_NONE)\n+\temit_jump_insn (gen_jump (operands[3]));\n+      DONE;\n+    }\n+  else if (CONST_INT_P (operands[1]))\n+    {\n+      arm_decompose_di_binop (operands[2], operands[1], &lo_op2, &hi_op2,\n+\t\t\t      &lo_op1, &hi_op1);\n+      if (const_ok_for_arm (INTVAL (lo_op1)))\n+\t{\n+\t  emit_insn (gen_rsb_imm_compare (lo_result, lo_op1, lo_op2,\n+\t\t\t\t\t  GEN_INT (~UINTVAL (lo_op1))));\n+\t  /* We could potentially use RSC here in Arm state, but not\n+\t     in Thumb, so it's probably not worth the effort of handling\n+\t     this.  */\n+\t  hi_op1 = force_reg (SImode, hi_op1);\n+\t  mode = CC_RSBmode;\n+\t  goto highpart;\n+\t}\n+      operands[1] = force_reg (DImode, operands[1]);\n+    }\n+\n+  arm_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,\n+\t\t\t  &lo_op2, &hi_op2);\n+  if (lo_op2 == const0_rtx)\n+    {\n+      emit_move_insn (lo_result, lo_op1);\n+      if (!arm_add_operand (hi_op2, SImode))\n+        hi_op2 = force_reg (SImode, hi_op2);\n+      emit_insn (gen_usubvsi4 (hi_result, hi_op1, hi_op2, operands[3]));\n+      DONE;\n+    }\n+\n+  if (CONST_INT_P (lo_op2) && !arm_addimm_operand (lo_op2, SImode))\n+    lo_op2 = force_reg (SImode, lo_op2);\n+  if (CONST_INT_P (lo_op2))\n+    emit_insn (gen_cmpsi2_addneg (lo_result, lo_op1, lo_op2,\n+\t\t\t\t  GEN_INT (-INTVAL (lo_op2))));\n+  else\n+    emit_insn (gen_subsi3_compare1 (lo_result, lo_op1, lo_op2));\n+\n+ highpart:\n+  if (!arm_not_operand (hi_op2, SImode))\n+    hi_op2 = force_reg (SImode, hi_op2);\n+  rtx ccreg = gen_rtx_REG (mode, CC_REGNUM);\n+  if (CONST_INT_P (hi_op2))\n+    emit_insn (gen_usubvsi3_borrow_imm (hi_result, hi_op1, hi_op2,\n+\t\t\t\t\tGEN_INT (UINTVAL (hi_op2) & 0xffffffff),\n+\t\t\t\t\tgen_rtx_LTU (SImode, ccreg, const0_rtx),\n+\t\t\t\t\tgen_rtx_LTU (DImode, ccreg,\n+\t\t\t\t\t\t     const0_rtx)));\n+  else\n+    emit_insn (gen_usubvsi3_borrow (hi_result, hi_op1, hi_op2,\n+\t\t\t\t    gen_rtx_LTU (SImode, ccreg, const0_rtx),\n+\t\t\t\t    gen_rtx_LTU (DImode, ccreg, const0_rtx)));\n+  arm_gen_unlikely_cbranch (LTU, CC_Bmode, operands[3]);\n \n   DONE;\n })\n@@ -1825,6 +1893,43 @@\n    (set_attr \"type\" \"alus_imm\")]\n )\n \n+(define_insn \"usubvsi3_borrow\"\n+  [(set (reg:CC_B CC_REGNUM)\n+\t(compare:CC_B\n+\t (zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"0,r\"))\n+\t (plus:DI (match_operand:DI 4 \"arm_borrow_operation\" \"\")\n+\t          (zero_extend:DI\n+\t\t   (match_operand:SI 2 \"s_register_operand\" \"l,r\")))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=l,r\")\n+\t(minus:SI (match_dup 1)\n+\t\t  (plus:SI (match_operand:SI 3 \"arm_borrow_operation\" \"\")\n+\t\t\t   (match_dup 2))))]\n+  \"TARGET_32BIT\"\n+  \"sbcs%?\\\\t%0, %1, %2\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"arch\" \"t2,*\")\n+   (set_attr \"length\" \"2,4\")]\n+)\n+\n+(define_insn \"usubvsi3_borrow_imm\"\n+  [(set (reg:CC_B CC_REGNUM)\n+\t(compare:CC_B\n+\t (zero_extend:DI (match_operand:SI 1 \"s_register_operand\" \"r,r\"))\n+\t (plus:DI (match_operand:DI 5 \"arm_borrow_operation\" \"\")\n+\t\t  (match_operand:DI 3 \"const_int_operand\" \"n,n\"))))\n+   (set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(minus:SI (match_dup 1)\n+\t\t  (plus:SI (match_operand:SI 4 \"arm_borrow_operation\" \"\")\n+\t\t\t   (match_operand:SI 2 \"arm_adcimm_operand\" \"I,K\"))))]\n+  \"TARGET_32BIT\n+   && (UINTVAL (operands[2]) & 0xffffffff) == UINTVAL (operands[3])\"\n+  \"@\n+  sbcs%?\\\\t%0, %1, %2\n+  adcs%?\\\\t%0, %1, #%B2\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"type\" \"alus_imm\")]\n+)\n+\n (define_expand \"subsf3\"\n   [(set (match_operand:SF           0 \"s_register_operand\")\n \t(minus:SF (match_operand:SF 1 \"s_register_operand\")"}]}