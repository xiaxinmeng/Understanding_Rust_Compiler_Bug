{"sha": "4dcc4502f316a7320fe72b62c60af12c77e1c96c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRjYzQ1MDJmMzE2YTczMjBmZTcyYjYyYzYwYWYxMmM3N2UxYzk2Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-03-23T12:08:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-03-23T15:48:37Z"}, "message": "tree-optimization/94261 - avoid IL adjustments in SLP analysis\n\nThe remaining IL adjustment done by SLP analysis turns out harmful\nsince we share them in the now multiple analyses states.  It turns\nout we do not actually need those apart from the case where we\nreorg scalar stmts during re-arrangement when optimizing load\npermutations in SLP reductions.  But that isn't needed either now\nsince we only need to permute non-isomorphic parts which now\nreside in separate SLP nodes who are all leafs.\n\n2020-03-23  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/94261\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove\n\tIL operand swapping code.\n\t(vect_slp_rearrange_stmts): Do not arrange isomorphic\n\tnodes that would need operation code adjustments.", "tree": {"sha": "ac934b4b1573123d232d5d00c0b00f19b30c5ebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac934b4b1573123d232d5d00c0b00f19b30c5ebb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dcc4502f316a7320fe72b62c60af12c77e1c96c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dcc4502f316a7320fe72b62c60af12c77e1c96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dcc4502f316a7320fe72b62c60af12c77e1c96c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dcc4502f316a7320fe72b62c60af12c77e1c96c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0d84ecc55f3ea86764b119040c5ffde36cd0524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d84ecc55f3ea86764b119040c5ffde36cd0524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d84ecc55f3ea86764b119040c5ffde36cd0524"}], "stats": {"total": 62, "additions": 16, "deletions": 46}, "files": [{"sha": "8804b0c5249cef1d4665a81a807b1122ed40e721", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dcc4502f316a7320fe72b62c60af12c77e1c96c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dcc4502f316a7320fe72b62c60af12c77e1c96c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4dcc4502f316a7320fe72b62c60af12c77e1c96c", "patch": "@@ -1,3 +1,11 @@\n+2020-03-23  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/94261\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Remove\n+\tIL operand swapping code.\n+\t(vect_slp_rearrange_stmts): Do not arrange isomorphic\n+\tnodes that would need operation code adjustments.\n+\n 2020-03-23  Tobias Burnus  <tobias@codesourcery.com>\n \n \t* doc/install.texi (amdgcn-*-amdhsa): Renamed"}, {"sha": "f6331eeea86e55ca591c873c6beb2ab7315c715c", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 8, "deletions": 46, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dcc4502f316a7320fe72b62c60af12c77e1c96c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dcc4502f316a7320fe72b62c60af12c77e1c96c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=4dcc4502f316a7320fe72b62c60af12c77e1c96c", "patch": "@@ -562,52 +562,6 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n   /* Swap operands.  */\n   if (swapped)\n     {\n-      if (first_op_cond)\n-\t{\n-\t  /* If there are already uses of this stmt in a SLP instance then\n-\t     we've committed to the operand order and can't swap it.  */\n-\t  if (STMT_VINFO_NUM_SLP_USES (stmt_info) != 0)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Build SLP failed: cannot swap operands of \"\n-\t\t\t\t \"shared stmt %G\", stmt_info->stmt);\n-\t      return -1;\n-\t    }\n-\n-\t  /* To get rid of this swapping we have to move the stmt code\n-\t     to the SLP tree as well (and gather it here per stmt).  */\n-\t  gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n-\t  tree cond = gimple_assign_rhs1 (stmt);\n-\t  enum tree_code code = TREE_CODE (cond);\n-\n-\t  /* Swap.  */\n-\t  if (*swap == 1)\n-\t    {\n-\t      swap_ssa_operands (stmt, &TREE_OPERAND (cond, 0),\n-\t\t\t\t &TREE_OPERAND (cond, 1));\n-\t      TREE_SET_CODE (cond, swap_tree_comparison (code));\n-\t    }\n-\t  /* Invert.  */\n-\t  else\n-\t    {\n-\t      swap_ssa_operands (stmt, gimple_assign_rhs2_ptr (stmt),\n-\t\t\t\t gimple_assign_rhs3_ptr (stmt));\n-\t      if (STMT_VINFO_REDUC_IDX (stmt_info) == 1)\n-\t\tSTMT_VINFO_REDUC_IDX (stmt_info) = 2;\n-\t      else if (STMT_VINFO_REDUC_IDX (stmt_info) == 2)\n-\t\tSTMT_VINFO_REDUC_IDX (stmt_info) = 1;\n-\t      bool honor_nans = HONOR_NANS (TREE_OPERAND (cond, 0));\n-\t      code = invert_tree_comparison (TREE_CODE (cond), honor_nans);\n-\t      gcc_assert (code != ERROR_MARK);\n-\t      TREE_SET_CODE (cond, code);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Commutative ops need not reflect swapping, ops are in\n-\t     the SLP tree.  */\n-\t}\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"swapped operands to match def types in %G\",\n@@ -1815,6 +1769,14 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   if (SLP_TREE_SCALAR_STMTS (node).exists ())\n     {\n       gcc_assert (group_size == SLP_TREE_SCALAR_STMTS (node).length ());\n+      /* ???  Computation nodes are isomorphic and need no rearrangement.\n+\t This is a quick hack to cover those where rearrangement breaks\n+\t semantics because only the first stmt is guaranteed to have the\n+\t correct operation code due to others being swapped or inverted.  */\n+      stmt_vec_info first = SLP_TREE_SCALAR_STMTS (node)[0];\n+      if (is_gimple_assign (first->stmt)\n+\t  && gimple_assign_rhs_code (first->stmt) == COND_EXPR)\n+\treturn;\n       vec<stmt_vec_info> tmp_stmts;\n       tmp_stmts.create (group_size);\n       tmp_stmts.quick_grow (group_size);"}]}