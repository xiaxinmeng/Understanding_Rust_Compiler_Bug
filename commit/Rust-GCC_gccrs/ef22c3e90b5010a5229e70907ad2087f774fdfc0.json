{"sha": "ef22c3e90b5010a5229e70907ad2087f774fdfc0", "node_id": "C_kwDOANBUbNoAKGVmMjJjM2U5MGI1MDEwYTUyMjllNzA5MDdhZDIwODdmNzc0ZmRmYzA", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-24T08:54:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-02-24T15:41:32Z"}, "message": "Change vec<,,vl_embed>::m_vecdata refrences into address ()\n\nAs preparation to remove m_vecdata in the vl_embed vector this\nchanges references to it into calls to address ().\n\nAs I was here it also fixes ::contains to avoid repeated bounds\nchecking and the same issue in ::lower_bound which also suffers\nfrom unnecessary copying around values.\n\n\t* vec.h (vec<T, A, vl_embed>::lower_bound): Adjust to\n\ttake a const reference to the object, use address to\n\taccess data.\n\t(vec<T, A, vl_embed>::contains): Use address to access data.\n\t(vec<T, A, vl_embed>::operator[]): Use address instead of\n\tm_vecdata to access data.\n\t(vec<T, A, vl_embed>::iterate): Likewise.\n\t(vec<T, A, vl_embed>::copy): Likewise.\n\t(vec<T, A, vl_embed>::quick_push): Likewise.\n\t(vec<T, A, vl_embed>::pop): Likewise.\n\t(vec<T, A, vl_embed>::quick_insert): Likewise.\n\t(vec<T, A, vl_embed>::ordered_remove): Likewise.\n\t(vec<T, A, vl_embed>::unordered_remove): Likewise.\n\t(vec<T, A, vl_embed>::block_remove): Likewise.\n\t(vec<T, A, vl_heap>::address): Likewise.", "tree": {"sha": "bed6e87eb2251cef1e4b209124e72fc6cefdb5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed6e87eb2251cef1e4b209124e72fc6cefdb5da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef22c3e90b5010a5229e70907ad2087f774fdfc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef22c3e90b5010a5229e70907ad2087f774fdfc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef22c3e90b5010a5229e70907ad2087f774fdfc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef22c3e90b5010a5229e70907ad2087f774fdfc0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94c9b1bb79f63d000ebb05efc155c149325e332d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94c9b1bb79f63d000ebb05efc155c149325e332d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94c9b1bb79f63d000ebb05efc155c149325e332d"}], "stats": {"total": 44, "additions": 25, "deletions": 19}, "files": [{"sha": "2b36f0652349c03a47c47c84d479a37325d94b3c", "filename": "gcc/vec.h", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef22c3e90b5010a5229e70907ad2087f774fdfc0/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef22c3e90b5010a5229e70907ad2087f774fdfc0/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=ef22c3e90b5010a5229e70907ad2087f774fdfc0", "patch": "@@ -611,10 +611,10 @@ struct GTY((user)) vec<T, A, vl_embed>\n   void qsort (int (*) (const void *, const void *));\n   void sort (int (*) (const void *, const void *, void *), void *);\n   void stablesort (int (*) (const void *, const void *, void *), void *);\n-  T *bsearch (const void *key, int (*compar)(const void *, const void *));\n+  T *bsearch (const void *key, int (*compar) (const void *, const void *));\n   T *bsearch (const void *key,\n \t      int (*compar)(const void *, const void *, void *), void *);\n-  unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n+  unsigned lower_bound (const T &, bool (*) (const T &, const T &)) const;\n   bool contains (const T &search) const;\n   static size_t embedded_size (unsigned);\n   void embedded_init (unsigned, unsigned = 0, unsigned = 0);\n@@ -879,15 +879,15 @@ inline const T &\n vec<T, A, vl_embed>::operator[] (unsigned ix) const\n {\n   gcc_checking_assert (ix < m_vecpfx.m_num);\n-  return m_vecdata[ix];\n+  return address ()[ix];\n }\n \n template<typename T, typename A>\n inline T &\n vec<T, A, vl_embed>::operator[] (unsigned ix)\n {\n   gcc_checking_assert (ix < m_vecpfx.m_num);\n-  return m_vecdata[ix];\n+  return address ()[ix];\n }\n \n \n@@ -929,7 +929,7 @@ vec<T, A, vl_embed>::iterate (unsigned ix, T *ptr) const\n {\n   if (ix < m_vecpfx.m_num)\n     {\n-      *ptr = m_vecdata[ix];\n+      *ptr = address ()[ix];\n       return true;\n     }\n   else\n@@ -955,7 +955,7 @@ vec<T, A, vl_embed>::iterate (unsigned ix, T **ptr) const\n {\n   if (ix < m_vecpfx.m_num)\n     {\n-      *ptr = CONST_CAST (T *, &m_vecdata[ix]);\n+      *ptr = CONST_CAST (T *, &address ()[ix]);\n       return true;\n     }\n   else\n@@ -978,7 +978,7 @@ vec<T, A, vl_embed>::copy (ALONE_MEM_STAT_DECL) const\n     {\n       vec_alloc (new_vec, len PASS_MEM_STAT);\n       new_vec->embedded_init (len, len);\n-      vec_copy_construct (new_vec->address (), m_vecdata, len);\n+      vec_copy_construct (new_vec->address (), address (), len);\n     }\n   return new_vec;\n }\n@@ -1018,7 +1018,7 @@ inline T *\n vec<T, A, vl_embed>::quick_push (const T &obj)\n {\n   gcc_checking_assert (space (1));\n-  T *slot = &m_vecdata[m_vecpfx.m_num++];\n+  T *slot = &address ()[m_vecpfx.m_num++];\n   *slot = obj;\n   return slot;\n }\n@@ -1031,7 +1031,7 @@ inline T &\n vec<T, A, vl_embed>::pop (void)\n {\n   gcc_checking_assert (length () > 0);\n-  return m_vecdata[--m_vecpfx.m_num];\n+  return address ()[--m_vecpfx.m_num];\n }\n \n \n@@ -1056,7 +1056,7 @@ vec<T, A, vl_embed>::quick_insert (unsigned ix, const T &obj)\n {\n   gcc_checking_assert (length () < allocated ());\n   gcc_checking_assert (ix <= length ());\n-  T *slot = &m_vecdata[ix];\n+  T *slot = &address ()[ix];\n   memmove (slot + 1, slot, (m_vecpfx.m_num++ - ix) * sizeof (T));\n   *slot = obj;\n }\n@@ -1071,7 +1071,7 @@ inline void\n vec<T, A, vl_embed>::ordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length ());\n-  T *slot = &m_vecdata[ix];\n+  T *slot = &address ()[ix];\n   memmove (slot, slot + 1, (--m_vecpfx.m_num - ix) * sizeof (T));\n }\n \n@@ -1118,7 +1118,8 @@ inline void\n vec<T, A, vl_embed>::unordered_remove (unsigned ix)\n {\n   gcc_checking_assert (ix < length ());\n-  m_vecdata[ix] = m_vecdata[--m_vecpfx.m_num];\n+  T *p = address ();\n+  p[ix] = p[--m_vecpfx.m_num];\n }\n \n \n@@ -1130,7 +1131,7 @@ inline void\n vec<T, A, vl_embed>::block_remove (unsigned ix, unsigned len)\n {\n   gcc_checking_assert (ix + len <= length ());\n-  T *slot = &m_vecdata[ix];\n+  T *slot = &address ()[ix];\n   m_vecpfx.m_num -= len;\n   memmove (slot, slot + len, (m_vecpfx.m_num - ix) * sizeof (T));\n }\n@@ -1248,9 +1249,13 @@ inline bool\n vec<T, A, vl_embed>::contains (const T &search) const\n {\n   unsigned int len = length ();\n+  const T *p = address ();\n   for (unsigned int i = 0; i < len; i++)\n-    if ((*this)[i] == search)\n-      return true;\n+    {\n+      const T *slot = &p[i];\n+      if (*slot == search)\n+\treturn true;\n+    }\n \n   return false;\n }\n@@ -1262,7 +1267,8 @@ vec<T, A, vl_embed>::contains (const T &search) const\n \n template<typename T, typename A>\n unsigned\n-vec<T, A, vl_embed>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n+vec<T, A, vl_embed>::lower_bound (const T &obj,\n+\t\t\t\t  bool (*lessthan)(const T &, const T &))\n   const\n {\n   unsigned int len = length ();\n@@ -1273,7 +1279,7 @@ vec<T, A, vl_embed>::lower_bound (T obj, bool (*lessthan)(const T &, const T &))\n       half = len / 2;\n       middle = first;\n       middle += half;\n-      T middle_elem = (*this)[middle];\n+      const T &middle_elem = address ()[middle];\n       if (lessthan (middle_elem, obj))\n \t{\n \t  first = middle;\n@@ -1476,10 +1482,10 @@ struct vec<T, va_heap, vl_ptr>\n   { return m_vec ? m_vec->length () : 0; }\n \n   T *address (void)\n-  { return m_vec ? m_vec->m_vecdata : NULL; }\n+  { return m_vec ? m_vec->address () : NULL; }\n \n   const T *address (void) const\n-  { return m_vec ? m_vec->m_vecdata : NULL; }\n+  { return m_vec ? m_vec->address () : NULL; }\n \n   T *begin () { return address (); }\n   const T *begin () const { return address (); }"}]}