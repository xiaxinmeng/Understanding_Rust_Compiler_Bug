{"sha": "89d7540d7bd16a0b664be710db1159f5e8763572", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlkNzU0MGQ3YmQxNmEwYjY2NGJlNzEwZGIxMTU5ZjVlODc2MzU3Mg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-27T19:08:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-27T19:08:53Z"}, "message": "(pushdecl): Nested fn decl gets DECL_CONTEXT iff not extern.\n\n(grokdeclarator): Make `long long' work even with\n-pedantic, despite the warning.\n\n(declare_parm_level): Unconditionally store 1.\n(pushdecl): Criterion for no warning is, next level up\nis a parm level.\n\nFrom-SVN: r3555", "tree": {"sha": "e1ec765bbede30f0588e913fdeb1883c1846171e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1ec765bbede30f0588e913fdeb1883c1846171e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89d7540d7bd16a0b664be710db1159f5e8763572", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d7540d7bd16a0b664be710db1159f5e8763572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d7540d7bd16a0b664be710db1159f5e8763572", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d7540d7bd16a0b664be710db1159f5e8763572/comments", "author": null, "committer": null, "parents": [{"sha": "cacb38243ebe742e49bbc89ce2320733b44a4fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacb38243ebe742e49bbc89ce2320733b44a4fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cacb38243ebe742e49bbc89ce2320733b44a4fc0"}], "stats": {"total": 34, "additions": 22, "deletions": 12}, "files": [{"sha": "60454762d0cb9b658b6f5d5c86df8bf031b17422", "filename": "gcc/c-decl.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89d7540d7bd16a0b664be710db1159f5e8763572/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89d7540d7bd16a0b664be710db1159f5e8763572/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=89d7540d7bd16a0b664be710db1159f5e8763572", "patch": "@@ -318,7 +318,6 @@ struct binding_level\n     struct binding_level *level_chain;\n \n     /* Nonzero for the level that holds the parameters of a function.  */\n-    /* 2 for a definition, 1 for a declaration.  */\n     char parm_flag;\n \n     /* Nonzero if this level \"doesn't exist\" for tags.  */\n@@ -740,13 +739,15 @@ kept_level_p ()\n }\n \n /* Identify this binding level as a level of parameters.\n-   DEFINITION_FLAG is 1 for a definition, 0 for a declaration.  */\n+   DEFINITION_FLAG is 1 for a definition, 0 for a declaration.\n+   But it turns out there is no way to pass the right value for\n+   DEFINITION_FLAG, so we ignore it.  */\n \n void\n declare_parm_level (definition_flag)\n      int definition_flag;\n {\n-  current_binding_level->parm_flag = 1 + definition_flag;\n+  current_binding_level->parm_flag = 1;\n }\n \n /* Nonzero if currently making parm declarations.  */\n@@ -1718,8 +1719,11 @@ pushdecl (x)\n   register struct binding_level *b = current_binding_level;\n \n   DECL_CONTEXT (x) = current_function_decl;\n-  /* A local declaration for a function doesn't constitute nesting.  */\n-  if (TREE_CODE (x) == FUNCTION_DECL && DECL_INITIAL (x) == 0)\n+  /* A local extern declaration for a function doesn't constitute nesting.\n+     A local auto declaration does, since it's a forward decl\n+     for a nested function coming later.  */\n+  if (TREE_CODE (x) == FUNCTION_DECL && DECL_INITIAL (x) == 0\n+      && DECL_EXTERNAL (x))\n     DECL_CONTEXT (x) = 0;\n \n   if (warn_nested_externs && DECL_EXTERNAL (x) && b != global_binding_level\n@@ -2072,8 +2076,12 @@ pushdecl (x)\n \t      char *warnstring = 0;\n \n \t      if (TREE_CODE (x) == PARM_DECL\n-\t\t  && current_binding_level->parm_flag == 1)\n-\t\t/* Don't warn about the parm names in a declaration.  */\n+\t\t  && current_binding_level->level_chain->parm_flag)\n+\t\t/* Don't warn about the parm names in function declarator\n+\t\t   within a function declarator.\n+\t\t   It would be nice to avoid warning in any function\n+\t\t   declarator in a declaration, as opposed to a definition,\n+\t\t   but there is no way to tell it's not a definition.  */\n \t\t;\n \t      else if (oldlocal != 0 && TREE_CODE (oldlocal) == PARM_DECL)\n \t\twarnstring = \"declaration of `%s' shadows a parameter\";\n@@ -3693,12 +3701,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t      {\n \t\tif (i == (int) RID_LONG && specbits & (1<<i))\n \t\t  {\n-\t\t    if (pedantic)\n-\t\t      pedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n-\t\t    else if (longlong)\n+\t\t    if (longlong)\n \t\t      error (\"`long long long' is too long for GCC\");\n \t\t    else\n-\t\t      longlong = 1;\n+\t\t      {\n+\t\t\tif (pedantic)\n+\t\t\t  pedwarn (\"ANSI C does not support `long long'\");\n+\t\t\tlonglong = 1;\n+\t\t      }\n \t\t  }\n \t\telse if (specbits & (1 << i))\n \t\t  pedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n@@ -5846,7 +5856,7 @@ store_parm_decls ()\n \t\t\tDECL_ARG_TYPE (parm) = integer_type_node;\n #endif\n \t\t      if (pedantic)\n-\t\t\twarning (\"promoted argument `%s' doesn't match prototype\",\n+\t\t\tpedwarn (\"promoted argument `%s' doesn't match prototype\",\n \t\t\t\t IDENTIFIER_POINTER (DECL_NAME (parm)));\n \t\t    }\n \t\t  /* If -traditional, allow `int' argument to match"}]}