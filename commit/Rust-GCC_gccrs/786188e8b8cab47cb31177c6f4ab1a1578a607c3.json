{"sha": "786188e8b8cab47cb31177c6f4ab1a1578a607c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg2MTg4ZThiOGNhYjQ3Y2IzMTE3N2M2ZjRhYjFhMTU3OGE2MDdjMw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-16T22:08:03Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T00:07:40Z"}, "message": "Add recomputation to outgoing_edge_range.\n\nThe gori engine can calculate outgoing ranges for exported values.  This\nchange allows 1st degree recomputation.  If a name is not exported from a\nblock, but one of the ssa_names used directly in computing it is, then\nwe can recompute the ssa_name on the edge using the edge values for its\noperands.\n\n\t* gimple-range-gori.cc (gori_compute::has_edge_range_p): Check with\n\tmay_recompute_p.\n\t(gori_compute::may_recompute_p): New.\n\t(gori_compute::outgoing_edge_range_p): Perform recomputations.\n\t* gimple-range-gori.h (class gori_compute): Add prototype.", "tree": {"sha": "00d6d325b4aad8196dbc8defd5ce365b5920f35f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00d6d325b4aad8196dbc8defd5ce365b5920f35f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/786188e8b8cab47cb31177c6f4ab1a1578a607c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786188e8b8cab47cb31177c6f4ab1a1578a607c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786188e8b8cab47cb31177c6f4ab1a1578a607c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786188e8b8cab47cb31177c6f4ab1a1578a607c3/comments", "author": null, "committer": null, "parents": [{"sha": "8a22a10c7879109c3906e1b865c50fe236b89f41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a22a10c7879109c3906e1b865c50fe236b89f41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a22a10c7879109c3906e1b865c50fe236b89f41"}], "stats": {"total": 60, "additions": 55, "deletions": 5}, "files": [{"sha": "647f4964769aa2f805b5d43b3f224fe2424f3711", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786188e8b8cab47cb31177c6f4ab1a1578a607c3/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786188e8b8cab47cb31177c6f4ab1a1578a607c3/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=786188e8b8cab47cb31177c6f4ab1a1578a607c3", "patch": "@@ -972,16 +972,18 @@ gori_compute::compute_operand1_and_operand2_range (irange &r,\n   r.intersect (op_range);\n   return true;\n }\n-// Return TRUE if a range can be calcalated for NAME on edge E.\n+// Return TRUE if a range can be calculated or recomputed for NAME on edge E.\n \n bool\n gori_compute::has_edge_range_p (tree name, edge e)\n {\n-  // If no edge is specified, check if NAME is an export on any edge.\n-  if (!e)\n-    return is_export_p (name);\n+  // Check if NAME is an export or can be recomputed.\n+  if (e)\n+    return is_export_p (name, e->src) || may_recompute_p (name, e);\n \n-  return is_export_p (name, e->src);\n+  // If no edge is specified, check if NAME can have a range calculated\n+  // on any edge.\n+  return is_export_p (name) || may_recompute_p (name);\n }\n \n // Dump what is known to GORI computes to listing file F.\n@@ -992,6 +994,32 @@ gori_compute::dump (FILE *f)\n   gori_map::dump (f);\n }\n \n+// Return TRUE if NAME can be recomputed on edge E.  If any direct dependant\n+// is exported on edge E, it may change the computed value of NAME.\n+\n+bool\n+gori_compute::may_recompute_p (tree name, edge e)\n+{\n+  tree dep1 = depend1 (name);\n+  tree dep2 = depend2 (name);\n+\n+  // If the first dependency is not set, there is no recompuation.\n+  if (!dep1)\n+    return false;\n+\n+  // Don't recalculate PHIs or statements with side_effects.\n+  gimple *s = SSA_NAME_DEF_STMT (name);\n+  if (is_a<gphi *> (s) || gimple_has_side_effects (s))\n+    return false;\n+\n+  // If edge is specified, check if NAME can be recalculated on that edge.\n+  if (e)\n+    return ((is_export_p (dep1, e->src))\n+\t    || (dep2 && is_export_p (dep2, e->src)));\n+\n+  return (is_export_p (dep1)) || (dep2 && is_export_p (dep2));\n+}\n+\n // Calculate a range on edge E and return it in R.  Try to evaluate a\n // range for NAME on this edge.  Return FALSE if this is either not a\n // control edge or NAME is not defined by this edge.\n@@ -1026,6 +1054,27 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n \t  return true;\n \t}\n     }\n+  // If NAME isn't exported, check if it can be recomputed.\n+  else if (may_recompute_p (name, e))\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"recomputation attempt on edge %d->%d for \",\n+\t\t   e->src->index, e->dest->index);\n+\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t}\n+      // Simply calculate DEF_STMT on edge E usng the range query Q.\n+      fold_range (r, def_stmt, e, &q);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \" : Calculated :\");\n+\t  r.dump (dump_file);\n+\t  fputc ('\\n', dump_file);\n+\t}\n+      return true;\n+    }\n   return false;\n }\n "}, {"sha": "6f187db08cb05c5fc024c4e3227381b60e8edf06", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/786188e8b8cab47cb31177c6f4ab1a1578a607c3/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/786188e8b8cab47cb31177c6f4ab1a1578a607c3/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=786188e8b8cab47cb31177c6f4ab1a1578a607c3", "patch": "@@ -157,6 +157,7 @@ class gori_compute : public gori_map\n   bool has_edge_range_p (tree name, edge e = NULL);\n   void dump (FILE *f);\n private:\n+  bool may_recompute_p (tree name, edge e = NULL);\n   bool compute_operand_range (irange &r, gimple *stmt, const irange &lhs,\n \t\t\t      tree name, class fur_source &src);\n   bool compute_operand_range_switch (irange &r, gswitch *s, const irange &lhs,"}]}