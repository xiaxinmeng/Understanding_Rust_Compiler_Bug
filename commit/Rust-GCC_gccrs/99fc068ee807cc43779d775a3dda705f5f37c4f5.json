{"sha": "99fc068ee807cc43779d775a3dda705f5f37c4f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlmYzA2OGVlODA3Y2M0Mzc3OWQ3NzVhM2RkYTcwNWY1ZjM3YzRmNQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-04-02T09:14:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-02T09:14:47Z"}, "message": "2012-04-02  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb (First_Component_Or_Discriminant) Now applies to\n\tall types with discriminants, not just records.\n\t* exp_attr.adb (Expand_N_Attribute): Add Scalar_Values handling\n\tfor arrays, scalars and non-variant records.\n\t* sem_attr.adb (Analyze_Attribute): Handle Valid_Scalars\n\t* sem_attr.ads (Valid_Scalars): Update description\n\t* sem_util.ads, sem_util.adb (No_Scalar_Parts): New function.\n\nFrom-SVN: r186069", "tree": {"sha": "9a8efa2ad007e9e906c740bb0b3ea701656c6395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a8efa2ad007e9e906c740bb0b3ea701656c6395"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99fc068ee807cc43779d775a3dda705f5f37c4f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fc068ee807cc43779d775a3dda705f5f37c4f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99fc068ee807cc43779d775a3dda705f5f37c4f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99fc068ee807cc43779d775a3dda705f5f37c4f5/comments", "author": null, "committer": null, "parents": [{"sha": "cdc30df3e2f9badd1f2fd8efe14c6546cd8efe07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc30df3e2f9badd1f2fd8efe14c6546cd8efe07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdc30df3e2f9badd1f2fd8efe14c6546cd8efe07"}], "stats": {"total": 304, "additions": 296, "deletions": 8}, "files": [{"sha": "b8155a14d77e0a32b474042f38573684dffdb3e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -1,3 +1,13 @@\n+2012-04-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (First_Component_Or_Discriminant) Now applies to\n+\tall types with discriminants, not just records.\n+\t* exp_attr.adb (Expand_N_Attribute): Add Scalar_Values handling\n+\tfor arrays, scalars and non-variant records.\n+\t* sem_attr.adb (Analyze_Attribute): Handle Valid_Scalars\n+\t* sem_attr.ads (Valid_Scalars): Update description\n+\t* sem_util.ads, sem_util.adb (No_Scalar_Parts): New function.\n+\n 2012-03-31  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tRevert"}, {"sha": "0f597a1f9410a1c120b802f5c0877d2f2dfd0486", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -5880,7 +5880,9 @@ package body Einfo is\n \n    begin\n       pragma Assert\n-        (Is_Record_Type (Id) or else Is_Incomplete_Or_Private_Type (Id));\n+        (Is_Record_Type (Id)\n+         or else Is_Incomplete_Or_Private_Type (Id)\n+         or else Has_Discriminants (Id));\n \n       Comp_Id := First_Entity (Id);\n       while Present (Comp_Id) loop"}, {"sha": "355770186db64ff21c3fa46950a3598af22476d9", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 233, "deletions": 1, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -76,6 +76,14 @@ package body Exp_Attr is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Build_Array_VS_Func\n+     (A_Type : Entity_Id;\n+      Nod    : Node_Id) return Entity_Id;\n+   --  Build function to test Valid_Scalars for array type A_Type. Nod is the\n+   --  Valid_Scalars attribute node, used to insert the function body, and the\n+   --  value returned is the entity of the constructed function body. We do not\n+   --  bother to generate a separate spec for this subprogram.\n+\n    procedure Compile_Stream_Body_In_Scope\n      (N     : Node_Id;\n       Decl  : Node_Id;\n@@ -174,6 +182,149 @@ package body Exp_Attr is\n    --  expansion. Typically used for rounding and truncation attributes that\n    --  appear directly inside a conversion to integer.\n \n+   -------------------------\n+   -- Build_Array_VS_Func --\n+   -------------------------\n+\n+   function Build_Array_VS_Func\n+     (A_Type : Entity_Id;\n+      Nod    : Node_Id) return Entity_Id\n+   is\n+      Loc        : constant Source_Ptr := Sloc (Nod);\n+      Comp_Type  : constant Entity_Id  := Component_Type (A_Type);\n+      Body_Stmts : List_Id;\n+      Index_List : List_Id;\n+      Func_Id    : Entity_Id;\n+      Formals    : List_Id;\n+\n+      function Test_Component return List_Id;\n+      --  Create one statement to test validity of one component designated by\n+      --  a full set of indexes. Returns statement list containing test.\n+\n+      function Test_One_Dimension (N : Int) return List_Id;\n+      --  Create loop to test one dimension of the array. The single statement\n+      --  in the loop body tests the inner dimensions if any, or else the\n+      --  single component. Note that this procedure is called recursively,\n+      --  with N being the dimension to be initialized. A call with N greater\n+      --  than the number of dimensions simply generates the component test,\n+      --  terminating the recursion. Returns statement list containing tests.\n+\n+      --------------------\n+      -- Test_Component --\n+      --------------------\n+\n+      function Test_Component return List_Id is\n+         Comp : Node_Id;\n+         Anam : Name_Id;\n+\n+      begin\n+         Comp :=\n+           Make_Indexed_Component (Loc,\n+             Prefix      => Make_Identifier (Loc, Name_uA),\n+             Expressions => Index_List);\n+\n+         if Is_Scalar_Type (Comp_Type) then\n+            Anam := Name_Valid;\n+         else\n+            Anam := Name_Valid_Scalars;\n+         end if;\n+\n+         return New_List (\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Attribute_Name => Anam,\n+                     Prefix         => Comp)),\n+             Then_Statements => New_List (\n+               Make_Simple_Return_Statement (Loc,\n+                 Expression => New_Occurrence_Of (Standard_False, Loc)))));\n+      end Test_Component;\n+\n+      ------------------------\n+      -- Test_One_Dimension --\n+      ------------------------\n+\n+      function Test_One_Dimension (N : Int) return List_Id is\n+         Index : Entity_Id;\n+\n+      begin\n+         --  If all dimensions dealt with, we simply test the component\n+\n+         if N > Number_Dimensions (A_Type) then\n+            return Test_Component;\n+\n+         --  Here we generate the required loop\n+\n+         else\n+            Index :=\n+              Make_Defining_Identifier (Loc, New_External_Name ('J', N));\n+\n+            Append (New_Reference_To (Index, Loc), Index_List);\n+\n+            return New_List (\n+              Make_Implicit_Loop_Statement (Nod,\n+                Identifier => Empty,\n+                Iteration_Scheme =>\n+                  Make_Iteration_Scheme (Loc,\n+                    Loop_Parameter_Specification =>\n+                      Make_Loop_Parameter_Specification (Loc,\n+                        Defining_Identifier => Index,\n+                        Discrete_Subtype_Definition =>\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Make_Identifier (Loc, Name_uA),\n+                            Attribute_Name  => Name_Range,\n+                            Expressions     => New_List (\n+                              Make_Integer_Literal (Loc, N))))),\n+                Statements =>  Test_One_Dimension (N + 1)),\n+              Make_Simple_Return_Statement (Loc,\n+                Expression => New_Occurrence_Of (Standard_True, Loc)));\n+         end if;\n+      end Test_One_Dimension;\n+\n+   --  Start of processing for Build_Array_VS_Func\n+\n+   begin\n+      Index_List := New_List;\n+      Func_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('V'));\n+\n+      Body_Stmts := Test_One_Dimension (1);\n+\n+      --  Parameter is always (A : A_Typ)\n+\n+      Formals := New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Make_Defining_Identifier (Loc, Name_uA),\n+          In_Present          => True,\n+          Out_Present         => False,\n+          Parameter_Type      => New_Reference_To (A_Type, Loc)));\n+\n+      --  Build body\n+\n+      Set_Ekind       (Func_Id, E_Function);\n+      Set_Is_Internal (Func_Id);\n+\n+      Insert_Action (Nod,\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Function_Specification (Loc,\n+              Defining_Unit_Name       => Func_Id,\n+              Parameter_Specifications => Formals,\n+                Result_Definition        =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc)),\n+          Declarations               => New_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => Body_Stmts)));\n+\n+      if not Debug_Generated_Code then\n+         Set_Debug_Info_Off (Func_Id);\n+      end if;\n+\n+      return Func_Id;\n+   end Build_Array_VS_Func;\n+\n    ----------------------------------\n    -- Compile_Stream_Body_In_Scope --\n    ----------------------------------\n@@ -5373,8 +5524,89 @@ package body Exp_Attr is\n       -------------------\n \n       when Attribute_Valid_Scalars => Valid_Scalars : declare\n+         Ftyp : Entity_Id;\n+\n       begin\n-         raise Program_Error;\n+         if Present (Underlying_Type (Ptyp)) then\n+            Ftyp := Underlying_Type (Ptyp);\n+         else\n+            Ftyp := Ptyp;\n+         end if;\n+\n+         --  For scalar types, Valid_Scalars is the same as Valid\n+\n+         if Is_Scalar_Type (Ftyp) then\n+            Rewrite (N,\n+              Make_Attribute_Reference (Loc,\n+                Attribute_Name => Name_Valid,\n+                Prefix         => Pref));\n+            Analyze_And_Resolve (N, Standard_Boolean);\n+\n+         --  For array types, we construct a function that determines if there\n+         --  are any non-valid scalar subcomponents, and call the function.\n+         --  We only do this for arrays whose component type needs checking\n+\n+         elsif Is_Array_Type (Ftyp)\n+           and then not No_Scalar_Parts (Component_Type (Ftyp))\n+         then\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (Build_Array_VS_Func (Ftyp, N), Loc),\n+                Parameter_Associations => New_List (Pref)));\n+\n+            Analyze_And_Resolve (N, Standard_Boolean);\n+\n+         --  For record types, we build a big conditional expression, applying\n+         --  Valid or Valid_Scalars as appropriate to all relevant components.\n+\n+         elsif (Is_Record_Type (Ptyp) or else Has_Discriminants (Ptyp))\n+           and then not No_Scalar_Parts (Ptyp)\n+         then\n+            declare\n+               C : Entity_Id;\n+               X : Node_Id;\n+               A : Name_Id;\n+\n+            begin\n+               X := New_Occurrence_Of (Standard_True, Loc);\n+               C := First_Component_Or_Discriminant (Ptyp);\n+               while Present (C) loop\n+                  if No_Scalar_Parts (Etype (C)) then\n+                     goto Continue;\n+                  elsif Is_Scalar_Type (Etype (C)) then\n+                     A := Name_Valid;\n+                  else\n+                     A := Name_Valid_Scalars;\n+                  end if;\n+\n+                  X :=\n+                    Make_And_Then (Loc,\n+                      Left_Opnd   => X,\n+                      Right_Opnd  =>\n+                        Make_Attribute_Reference (Loc,\n+                          Attribute_Name => A,\n+                          Prefix         =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix        =>\n+                                Duplicate_Subexpr (Pref, Name_Req => True),\n+                              Selector_Name =>\n+                                New_Occurrence_Of (C, Loc))));\n+               <<Continue>>\n+                  Next_Component_Or_Discriminant (C);\n+               end loop;\n+\n+               Rewrite (N, X);\n+               Analyze_And_Resolve (N, Standard_Boolean);\n+            end;\n+\n+         --  For all other types, result is True (but not static)\n+\n+         else\n+            Rewrite (N, New_Occurrence_Of (Standard_Boolean, Loc));\n+            Analyze_And_Resolve (N, Standard_Boolean);\n+            Set_Is_Static_Expression (N, False);\n+         end if;\n       end Valid_Scalars;\n \n       -----------"}, {"sha": "10af9e2d05493f7824336c9ea32502522cf1e1ed", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -323,7 +323,7 @@ package body Sem_Attr is\n       --  type or a private type for which no full view has been given.\n \n       procedure Check_Object_Reference (P : Node_Id);\n-      --  Check that P (the prefix of the attribute) is an object reference\n+      --  Check that P is an object reference\n \n       procedure Check_Program_Unit;\n       --  Verify that prefix of attribute N is a program unit\n@@ -5202,8 +5202,13 @@ package body Sem_Attr is\n \n       when Attribute_Valid_Scalars =>\n          Check_E0;\n-         Check_Type;\n-         --  More stuff TBD ???\n+         Check_Object_Reference (P);\n+\n+         if No_Scalar_Parts (P_Type) then\n+            Error_Attr_P (\"?attribute % always True, no scalars to check\");\n+         end if;\n+\n+         Set_Etype (N, Standard_Boolean);\n \n       -----------\n       -- Value --"}, {"sha": "7258593aabf84235555878a2d25696efbad5e22d", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -560,12 +560,18 @@ package Sem_Attr is\n       --    For a scalar type, the result is the same as obj'Valid\n       --\n       --    For an array object, the result is True if the result of applying\n-      --    Valid_Scalars to every component is True.\n+      --    Valid_Scalars to every component is True. For an empty array the\n+      --    result is True.\n       --\n       --    For a record object, the result is True if the result of applying\n       --    Valid_Scalars to every component is True. For class-wide types,\n       --    only the components of the base type are checked. For variant\n-      --    records, only the components actually present are checked.\n+      --    records, only the components actually present are checked. The\n+      --    discriminants, if any, are also checked. If there are no components\n+      --    or discriminants, the result is True.\n+      --\n+      --    For any other type that has discriminants, the result is True if\n+      --    the result of applying Valid_Scalars to each discriminant is True.\n       --\n       --    For all other types, the result is always True\n       --\n@@ -574,7 +580,7 @@ package Sem_Attr is\n       --  type, or in the composite case if no scalar subcomponents exist. For\n       --  a variant record, the warning is given only if none of the variants\n       --  have scalar subcomponents. In addition, the warning is suppressed\n-      --  for private types, or generic types in an instance.\n+      --  for private types, or generic formal types in an instance.\n \n       ----------------\n       -- Value_Size --"}, {"sha": "e07d5bbb1fa98344903b2004d431c0d1842d337b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -10499,6 +10499,34 @@ package body Sem_Util is\n       Actual_Id := Next_Actual (Actual_Id);\n    end Next_Actual;\n \n+   ---------------------\n+   -- No_Scalar_Parts --\n+   ---------------------\n+\n+   function No_Scalar_Parts (T : Entity_Id) return Boolean is\n+      C : Entity_Id;\n+\n+   begin\n+      if Is_Scalar_Type (T) then\n+         return False;\n+\n+      elsif Is_Array_Type (T) then\n+         return No_Scalar_Parts (Component_Type (T));\n+\n+      elsif Is_Record_Type (T) or else Has_Discriminants (T) then\n+         C := First_Component_Or_Discriminant (T);\n+         while Present (C) loop\n+            if not No_Scalar_Parts (Etype (C)) then\n+               return False;\n+            else\n+               Next_Component_Or_Discriminant (C);\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return True;\n+   end No_Scalar_Parts;\n+\n    -----------------------\n    -- Normalize_Actuals --\n    -----------------------"}, {"sha": "607bd8e72e049be9b3dc9489a5ef8b3f207b800e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99fc068ee807cc43779d775a3dda705f5f37c4f5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=99fc068ee807cc43779d775a3dda705f5f37c4f5", "patch": "@@ -1221,6 +1221,11 @@ package Sem_Util is\n    --  Note that the result produced is always an expression, not a parameter\n    --  association node, even if named notation was used.\n \n+   function No_Scalar_Parts (T : Entity_Id) return Boolean;\n+   --  Tests if type T can be determined at compile time to have no scalar\n+   --  parts in the sense of the Valid_Scalars attribute. Returns True if\n+   --  this is the case, meaning that the result of Valid_Scalars is True.\n+\n    procedure Normalize_Actuals\n      (N       : Node_Id;\n       S       : Entity_Id;"}]}