{"sha": "b2272b138c1e7f6a1cb867d614951d516f88a9f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIyNzJiMTM4YzFlN2Y2YTFjYjg2N2Q2MTQ5NTFkNTE2Zjg4YTlmMQ==", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2018-07-13T14:10:45Z"}, "committer": {"name": "Qing Zhao", "email": "qinzhao@gcc.gnu.org", "date": "2018-07-13T14:10:45Z"}, "message": "3nd Patch for PR78009\n\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=78809\nInline strcmp with small constant strings\n\nThe design doc for PR78809 is at:\nhttps://www.mail-archive.com/gcc@gcc.gnu.org/msg83822.html\n\nthis patch is for the third part of change of PR78809.\n\nC. for strcmp (s1, s2), strncmp (s1, s2, n), and memcmp (s1, s2, n)\n   if the result is NOT used to do simple equality test against zero, one of\n\"s1\" or \"s2\" is a small constant string, n is a constant, and the Min value of\nthe length of the constant string and \"n\" is smaller than a predefined\nthreshold T,\n   inline the call by a byte-to-byte comparision sequence to avoid calling\noverhead.\n\nadding test case strcmpopt_5.c into gcc.dg for part C of PR78809.\nadding test case strcmpopt_6.c into gcc.dg to test the following case:\n   When the specified length exceeds one of the arguments of the call to memcmp,\n   the call to memcmp should NOT be inlined.\n\nFrom-SVN: r262636", "tree": {"sha": "c0ff90bac1be9a15892993c77b7e1b8b791f2416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0ff90bac1be9a15892993c77b7e1b8b791f2416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2272b138c1e7f6a1cb867d614951d516f88a9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2272b138c1e7f6a1cb867d614951d516f88a9f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2272b138c1e7f6a1cb867d614951d516f88a9f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2272b138c1e7f6a1cb867d614951d516f88a9f1/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b02160e5ac1dc57bbecd3387b61fcad8c7a57672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b02160e5ac1dc57bbecd3387b61fcad8c7a57672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b02160e5ac1dc57bbecd3387b61fcad8c7a57672"}], "stats": {"total": 338, "additions": 321, "deletions": 17}, "files": [{"sha": "6b776e1c7c5d5061b64f2255cef44fd66a345b3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -1,3 +1,17 @@\n+2018-07-13  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\tPR middle-end/78809\n+\t* builtins.c (expand_builtin_memcmp): Inline the calls first\n+\twhen result_eq is false.\n+\t(expand_builtin_strcmp): Inline the calls first.\n+\t(expand_builtin_strncmp): Likewise.\n+\t(inline_string_cmp): New routine. Expand a string compare \n+\tcall by using a sequence of char comparison.\n+\t(inline_expand_builtin_string_cmp): New routine. Inline expansion\n+\ta call to str(n)cmp/memcmp.\n+\t* doc/invoke.texi (--param builtin-string-cmp-inline-length): New option.\n+\t* params.def (BUILTIN_STRING_CMP_INLINE_LENGTH): New.\n+\n 2018-07-13  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/driver-arm.c: Include arm-native.h."}, {"sha": "839a8180e48bdc8b4ee5ce8870761e425ee83b22", "filename": "gcc/builtins.c", "status": "modified", "additions": 176, "deletions": 17, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"gimple.h\"\n #include \"predict.h\"\n+#include \"params.h\"\n #include \"tm_p.h\"\n #include \"stringpool.h\"\n #include \"tree-vrp.h\"\n@@ -118,6 +119,7 @@ static rtx expand_builtin_next_arg (void);\n static rtx expand_builtin_va_start (tree);\n static rtx expand_builtin_va_end (tree);\n static rtx expand_builtin_va_copy (tree);\n+static rtx inline_expand_builtin_string_cmp (tree, rtx, bool);\n static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n@@ -4443,19 +4445,32 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (get_callee_fndecl (exp));\n+  bool no_overflow = true;\n \n   /* Diagnose calls where the specified length exceeds the size of either\n      object.  */\n-  if (warn_stringop_overflow)\n+  tree size = compute_objsize (arg1, 0);\n+  no_overflow = check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE,\n+\t\t\t      len, /*maxread=*/NULL_TREE, size,\n+\t\t\t      /*objsize=*/NULL_TREE);\n+  if (no_overflow) \n+    {\n+      size = compute_objsize (arg2, 0);\n+      no_overflow = check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE,\n+\t\t\t\t  len,  /*maxread=*/NULL_TREE, size,\n+\t\t\t\t  /*objsize=*/NULL_TREE);\n+    } \n+\n+  /* Due to the performance benefit, always inline the calls first \n+     when result_eq is false.  */\n+  rtx result = NULL_RTX;\n+   \n+  if (!result_eq && fcode != BUILT_IN_BCMP && no_overflow) \n     {\n-      tree size = compute_objsize (arg1, 0);\n-      if (check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n-\t\t\t/*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE))\n-\t{\n-\t  size = compute_objsize (arg2, 0);\n-\t  check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n-\t\t\t/*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE);\n-\t}\n+      result = inline_expand_builtin_string_cmp (exp, target, true);\n+      if (result)\n+\treturn result;\n     }\n \n   machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n@@ -4497,10 +4512,10 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n       && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1)\n     constfn = builtin_memcpy_read_str;\n \n-  rtx result = emit_block_cmp_hints (arg1_rtx, arg2_rtx, len_rtx,\n-\t\t\t\t     TREE_TYPE (len), target,\n-\t\t\t\t     result_eq, constfn,\n-\t\t\t\t     CONST_CAST (char *, src_str));\n+  result = emit_block_cmp_hints (arg1_rtx, arg2_rtx, len_rtx,\n+\t\t\t\t TREE_TYPE (len), target,\n+\t\t\t\t result_eq, constfn,\n+\t\t\t\t CONST_CAST (char *, src_str));\n \n   if (result)\n     {\n@@ -4530,6 +4545,12 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n+  /* Due to the performance benefit, always inline the calls first.  */\n+  rtx result = NULL_RTX;\n+  result = inline_expand_builtin_string_cmp (exp, target, false);\n+  if (result)\n+    return result;\n+\n   insn_code cmpstr_icode = direct_optab_handler (cmpstr_optab, SImode);\n   insn_code cmpstrn_icode = direct_optab_handler (cmpstrn_optab, SImode);\n   if (cmpstr_icode == CODE_FOR_nothing && cmpstrn_icode == CODE_FOR_nothing)\n@@ -4552,7 +4573,6 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   rtx arg1_rtx = get_memory_rtx (arg1, NULL);\n   rtx arg2_rtx = get_memory_rtx (arg2, NULL);\n \n-  rtx result = NULL_RTX;\n   /* Try to call cmpstrsi.  */\n   if (cmpstr_icode != CODE_FOR_nothing)\n     result = expand_cmpstr (cmpstr_icode, target, arg1_rtx, arg2_rtx,\n@@ -4644,6 +4664,12 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n+  /* Due to the performance benefit, always inline the calls first.  */\n+  rtx result = NULL_RTX;\n+  result = inline_expand_builtin_string_cmp (exp, target, false);\n+  if (result)\n+    return result;\n+\n   /* If c_strlen can determine an expression for one of the string\n      lengths, and it doesn't have side effects, then emit cmpstrnsi\n      using length MIN(strlen(string)+1, arg3).  */\n@@ -4706,9 +4732,9 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n   rtx arg1_rtx = get_memory_rtx (arg1, len);\n   rtx arg2_rtx = get_memory_rtx (arg2, len);\n   rtx arg3_rtx = expand_normal (len);\n-  rtx result = expand_cmpstrn_or_cmpmem (cmpstrn_icode, target, arg1_rtx,\n-\t\t\t\t\t arg2_rtx, TREE_TYPE (len), arg3_rtx,\n-\t\t\t\t\t MIN (arg1_align, arg2_align));\n+  result = expand_cmpstrn_or_cmpmem (cmpstrn_icode, target, arg1_rtx,\n+\t\t\t\t     arg2_rtx, TREE_TYPE (len), arg3_rtx,\n+\t\t\t\t     MIN (arg1_align, arg2_align));\n \n   tree fndecl = get_callee_fndecl (exp);\n   if (result)\n@@ -6722,6 +6748,139 @@ expand_builtin_goacc_parlevel_id_size (tree exp, rtx target, int ignore)\n   return target;\n }\n \n+/* Expand a string compare operation using a sequence of char comparison \n+   to get rid of the calling overhead, with result going to TARGET if\n+   that's convenient.\n+\n+   VAR_STR is the variable string source;\n+   CONST_STR is the constant string source;\n+   LENGTH is the number of chars to compare;\n+   CONST_STR_N indicates which source string is the constant string;\n+   IS_MEMCMP indicates whether it's a memcmp or strcmp.\n+   \n+   to: (assume const_str_n is 2, i.e., arg2 is a constant string)\n+\n+   target = var_str[0] - const_str[0];\n+   if (target != 0)\n+     goto ne_label;\n+     ...\n+   target = var_str[length - 2] - const_str[length - 2];\n+   if (target != 0)\n+     goto ne_label;\n+   target = var_str[length - 1] - const_str[length - 1];\n+   ne_label:\n+  */\n+\n+static rtx\n+inline_string_cmp (rtx target, tree var_str, const char* const_str, \n+\t\t   unsigned HOST_WIDE_INT length,\n+\t\t   int const_str_n, machine_mode mode,\n+\t\t   bool is_memcmp) \n+{\n+  HOST_WIDE_INT offset = 0;\n+  rtx var_rtx_array \n+    = get_memory_rtx (var_str, build_int_cst (unsigned_type_node,length));\n+  rtx var_rtx = NULL_RTX;\n+  rtx const_rtx = NULL_RTX; \n+  rtx result = target ? target : gen_reg_rtx (mode); \n+  rtx_code_label *ne_label = gen_label_rtx ();  \n+  tree unit_type_node = is_memcmp ? unsigned_char_type_node : char_type_node;\n+\n+  start_sequence ();\n+\n+  for (unsigned HOST_WIDE_INT i = 0; i < length; i++)\n+    {\n+      var_rtx \n+\t= adjust_address (var_rtx_array, TYPE_MODE (unit_type_node), offset);\n+      const_rtx \n+\t= builtin_memcpy_read_str (CONST_CAST (char *, const_str),\n+\t\t\t\t   offset,\n+    \t\t\t\t   as_a <scalar_int_mode> \n+\t\t\t\t   TYPE_MODE (unit_type_node));\n+      rtx op0 = (const_str_n == 1) ? const_rtx : var_rtx;\n+      rtx op1 = (const_str_n == 1) ? var_rtx : const_rtx;\n+  \n+      result = expand_simple_binop (mode, MINUS, op0, op1, \n+\t\t\t            result, is_memcmp ? 1 : 0, OPTAB_WIDEN);\n+      if (i < length - 1) \n+        emit_cmp_and_jump_insns (result, CONST0_RTX (mode), NE, NULL_RTX,\n+            \t\t         mode, true, ne_label);\n+      offset \n+\t+= GET_MODE_SIZE (as_a <scalar_int_mode> TYPE_MODE (unit_type_node));\n+    }\n+\n+  emit_label (ne_label);\n+  rtx_insn *insns = get_insns ();\n+  end_sequence ();\n+  emit_insn (insns);\n+\n+  return result;\n+}\n+\n+/* Inline expansion a call to str(n)cmp, with result going to \n+   TARGET if that's convenient.\n+   If the call is not been inlined, return NULL_RTX.  */\n+static rtx\n+inline_expand_builtin_string_cmp (tree exp, rtx target, bool is_memcmp)\n+{\n+  tree fndecl = get_callee_fndecl (exp);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  unsigned HOST_WIDE_INT length = 0;\n+  bool is_ncmp = (fcode == BUILT_IN_STRNCMP || fcode == BUILT_IN_MEMCMP);\n+\n+  gcc_checking_assert (fcode == BUILT_IN_STRCMP\n+\t\t       || fcode == BUILT_IN_STRNCMP \n+\t\t       || fcode == BUILT_IN_MEMCMP);\n+\n+  tree arg1 = CALL_EXPR_ARG (exp, 0);\n+  tree arg2 = CALL_EXPR_ARG (exp, 1);\n+  tree len3_tree = is_ncmp ? CALL_EXPR_ARG (exp, 2) : NULL_TREE;\n+\n+  unsigned HOST_WIDE_INT len1 = 0;\n+  unsigned HOST_WIDE_INT len2 = 0;\n+  unsigned HOST_WIDE_INT len3 = 0;\n+\n+  const char *src_str1 = c_getstr (arg1, &len1);\n+  const char *src_str2 = c_getstr (arg2, &len2);\n+ \n+  /* If neither strings is constant string, the call is not qualify.  */\n+  if (!src_str1 && !src_str2)\n+    return NULL_RTX;\n+\n+  /* For strncmp, if the length is not a const, not qualify.  */\n+  if (is_ncmp && !tree_fits_uhwi_p (len3_tree))\n+    return NULL_RTX;\n+\n+  int const_str_n = 0;\n+  if (!len1)\n+    const_str_n = 2;\n+  else if (!len2)\n+    const_str_n = 1;\n+  else if (len2 > len1)\n+    const_str_n = 1;\n+  else\n+    const_str_n = 2;\n+\n+  gcc_checking_assert (const_str_n > 0);\n+  length = (const_str_n == 1) ? len1 : len2;\n+\n+  if (is_ncmp && (len3 = tree_to_uhwi (len3_tree)) < length)\n+    length = len3;\n+\n+  /* If the length of the comparision is larger than the threshold, \n+     do nothing.  */\n+  if (length > (unsigned HOST_WIDE_INT) \n+\t       PARAM_VALUE (BUILTIN_STRING_CMP_INLINE_LENGTH))\n+    return NULL_RTX;\n+\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* Now, start inline expansion the call.  */\n+  return inline_string_cmp (target, (const_str_n == 1) ? arg2 : arg1, \n+\t\t\t    (const_str_n == 1) ? src_str1 : src_str2, length,\n+\t\t\t    const_str_n, mode, is_memcmp);\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient)."}, {"sha": "9804808f128bc2bd808c63e43c2577cb2c413361", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -10594,6 +10594,11 @@ Control the probability of the expression having the specified value. This\n parameter takes a percentage (i.e. 0 ... 100) as input.\n The default probability of 90 is obtained empirically.\n \n+@item builtin-string-cmp-inline-length\n+The maximum length of a constant string for a builtin string cmp call \n+eligible for inlining.\n+The default value is 3.\n+\n @item align-threshold\n \n Select fraction of the maximal frequency of executions of a basic block in"}, {"sha": "df3a06b5d9d1309daa47604d299d163337f6a60c", "filename": "gcc/params.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -446,6 +446,10 @@ DEFPARAM(BUILTIN_EXPECT_PROBABILITY,\n \t \"builtin-expect-probability\",\n \t \"Set the estimated probability in percentage for builtin expect. The default value is 90% probability.\",\n \t 90, 0, 100)\n+DEFPARAM(BUILTIN_STRING_CMP_INLINE_LENGTH,\n+\t \"builtin-string-cmp-inline-length\",\n+\t \"The maximum length of a constant string for a builtin string cmp call eligible for inlining. The default value is 3.\",\n+\t 3, 0, 100)\n DEFPARAM(TRACER_DYNAMIC_COVERAGE_FEEDBACK,\n \t \"tracer-dynamic-coverage-feedback\",\n \t \"The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.\","}, {"sha": "0c61e976f736464ce3931cbed9e61255daec5cc2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -1,3 +1,9 @@\n+2018-07-13  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\tPR middle-end/78809\n+\t* gcc.dg/strcmpopt_5.c: New test.\n+\t* gcc.dg/strcmpopt_6.c: New test.\n+\n 2018-07-13  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/85974"}, {"sha": "c30fb78eb64173a83a07ca532756d37f87424468", "filename": "gcc/testsuite/gcc.dg/strcmpopt_5.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_5.c?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -fdump-rtl-expand\" } */\n+\n+typedef struct { char s[8]; int x; } S;\n+__attribute__ ((noinline)) int\n+f1 (S * s)\n+{\n+  int result = 0;\n+  result += __builtin_strncmp (s->s, \"ab\", 2);\n+  result += __builtin_strncmp (s->s, \"abc\", 3);\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) int\n+f2 (char *p)\n+{\n+  int result = 0;\n+  result += __builtin_strncmp (p, \"ab\", 2);\n+  result += __builtin_strncmp (p, \"abc\", 3);\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) int\n+f3 (S * s)\n+{\n+  int result = 0;\n+  result += __builtin_strcmp (s->s, \"a\");\n+  result += __builtin_strcmp (s->s, \"ab\");\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) int\n+f4 (char *p)\n+{\n+  int result = 0;\n+  result += __builtin_strcmp (p, \"a\");\n+  result += __builtin_strcmp (p, \"ab\");\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) int\n+f5 (S * s)\n+{\n+  int result = 0;\n+  result += __builtin_memcmp (s->s, \"ab\", 2);\n+  result += __builtin_memcmp (s->s, \"abc\", 3);\n+  return result;\n+}\n+\n+__attribute__ ((noinline)) int\n+f6 (char *p)\n+{\n+  int result = 0;\n+  result += __builtin_memcmp (p, \"ab\", 2);\n+  result += __builtin_memcmp (p, \"abc\", 3);\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  S ss = {{'a','b','c'}, 2};\n+  char *s = \"abcd\";\n+\n+  if (f1 (&ss) != 0 || f2 (s) != 0)\n+    __builtin_abort ();\n+\n+  if (f3 (&ss) <= 0 || f4 (s) <= 0)\n+    __builtin_abort ();\n+\n+  if (f5 (&ss) != 0 || f6 (s) != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+\n+}\n+\n+\n+/* { dg-final { scan-rtl-dump-times \"__builtin_strcmp\" 0 \"expand\" } } */\n+/* { dg-final { scan-rtl-dump-times \"__builtin_strncmp\" 0 \"expand\" } } */\n+/* { dg-final { scan-rtl-dump-times \"__builtin_memcmp\" 0 \"expand\" } } */"}, {"sha": "0f8cf87fbd00d9531d060ed3a2efcac1a0a86822", "filename": "gcc/testsuite/gcc.dg/strcmpopt_6.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2272b138c1e7f6a1cb867d614951d516f88a9f1/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_6.c?ref=b2272b138c1e7f6a1cb867d614951d516f88a9f1", "patch": "@@ -0,0 +1,36 @@\n+/* When the specified length exceeds one of the arguments of the call to memcmp, \n+   the call to memcmp should NOT be inlined.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O -fdump-rtl-expand -Wno-stringop-overflow\" } */\n+\n+typedef struct { char s[8]; int x; } S;\n+\n+__attribute__ ((noinline)) int\n+f1 (S * s)\n+{\n+  int result = 0;\n+  result += __builtin_memcmp (s->s, \"a\", 3); \n+  return result;\n+}\n+\n+__attribute__ ((noinline)) int\n+f2 (char *p)\n+{\n+  int result = 0;\n+  result += __builtin_memcmp (p, \"a\", 3); \n+  return result;\n+}\n+\n+int main (void)\n+{\n+  S ss = {{'a','b','c'}, 2};\n+  char *s = \"abcd\";\n+\n+  if (f1 (&ss) < 0 || f2 (s) < 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"__builtin_memcmp\" 4 \"expand\" } } */"}]}