{"sha": "94be91d6159101caa7c560b188bd6c02d8d86d17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRiZTkxZDYxNTkxMDFjYWE3YzU2MGIxODhiZDZjMDJkOGQ4NmQxNw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-07T04:40:19Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-07T04:40:19Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "b3c32de54db1a850079f79d3dfb4c4000dec9d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3c32de54db1a850079f79d3dfb4c4000dec9d90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94be91d6159101caa7c560b188bd6c02d8d86d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94be91d6159101caa7c560b188bd6c02d8d86d17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94be91d6159101caa7c560b188bd6c02d8d86d17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94be91d6159101caa7c560b188bd6c02d8d86d17/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27eef5b7a065e8ea05ac575c4b364bb5dbc44e46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27eef5b7a065e8ea05ac575c4b364bb5dbc44e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27eef5b7a065e8ea05ac575c4b364bb5dbc44e46"}, {"sha": "db7134353447921136a321b8fd78cea78f2c344e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7134353447921136a321b8fd78cea78f2c344e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db7134353447921136a321b8fd78cea78f2c344e"}], "stats": {"total": 2942, "additions": 2075, "deletions": 867}, "files": [{"sha": "511c30d3a2bede73ab5188f456692d633eec8995", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -2399,9 +2399,9 @@ class CallExpr : public ExprWithoutBlock\n \n   void iterate_params (std::function<bool (Expr *)> cb)\n   {\n-    for (auto it = params.begin (); it != params.end (); it++)\n+    for (auto &param : params)\n       {\n-\tif (!cb (it->get ()))\n+\tif (!cb (param.get ()))\n \t  return;\n       }\n   }\n@@ -2504,6 +2504,15 @@ class MethodCallExpr : public ExprWithoutBlock\n   void mark_for_strip () override { receiver = nullptr; }\n   bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n+  void iterate_params (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto &param : params)\n+      {\n+\tif (!cb (param.get ()))\n+\t  return;\n+      }\n+  }\n+\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<std::unique_ptr<Expr> > &get_params () const\n   {"}, {"sha": "a6f5398218fa68a85967d7607af8ea59165ecc08", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -366,12 +366,14 @@ struct SelfParam\n   // bool has_type; // only possible if not ref\n   std::unique_ptr<Type> type;\n \n+  NodeId node_id;\n+\n   Location locus;\n \n   // Unrestricted constructor used for error state\n   SelfParam (Lifetime lifetime, bool has_ref, bool is_mut, Type *type)\n     : has_ref (has_ref), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      type (type)\n+      type (type), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n   // this is ok as no outside classes can ever call this\n \n@@ -401,20 +403,23 @@ struct SelfParam\n   // Type-based self parameter (not ref, no lifetime)\n   SelfParam (std::unique_ptr<Type> type, bool is_mut, Location locus)\n     : has_ref (false), is_mut (is_mut), lifetime (Lifetime::error ()),\n-      type (std::move (type)), locus (locus)\n+      type (std::move (type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()), locus (locus)\n   {}\n \n   // Lifetime-based self parameter (is ref, no type)\n   SelfParam (Lifetime lifetime, bool is_mut, Location locus)\n     : has_ref (true), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      locus (locus)\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()), locus (locus)\n   {}\n \n   // Copy constructor requires clone\n   SelfParam (SelfParam const &other)\n     : has_ref (other.has_ref), is_mut (other.is_mut), lifetime (other.lifetime),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n       locus (other.locus)\n   {\n+    node_id = other.node_id;\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n   }\n@@ -426,6 +431,7 @@ struct SelfParam\n     has_ref = other.has_ref;\n     lifetime = other.lifetime;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n@@ -443,6 +449,13 @@ struct SelfParam\n \n   Location get_locus () const { return locus; }\n \n+  bool get_has_ref () const { return has_ref; };\n+  bool get_is_mut () const { return is_mut; }\n+\n+  Lifetime get_lifetime () const { return lifetime; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type ()\n   {"}, {"sha": "049aaf0044811b19fbfb5b226f81581c638248ae", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -78,7 +78,7 @@ class IdentifierPattern : public Pattern\n   Location locus;\n \n public:\n-  std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Returns whether the IdentifierPattern has a pattern to bind.\n   bool has_pattern_to_bind () const { return to_bind != nullptr; }\n@@ -91,6 +91,15 @@ class IdentifierPattern : public Pattern\n       is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n   {}\n \n+  IdentifierPattern (NodeId node_id, Identifier ident, Location locus,\n+\t\t     bool is_ref = false, bool is_mut = false,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n+  {\n+    this->node_id = node_id;\n+  }\n+\n   // Copy constructor with clone\n   IdentifierPattern (IdentifierPattern const &other)\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),"}, {"sha": "3ba837c14ea83d3c2402f78395c27064b6579eb0", "filename": "gcc/rust/backend/cscope.h", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27eef5b7a065e8ea05ac575c4b364bb5dbc44e46/gcc%2Frust%2Fbackend%2Fcscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27eef5b7a065e8ea05ac575c4b364bb5dbc44e46/gcc%2Frust%2Fbackend%2Fcscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Fcscope.h?ref=27eef5b7a065e8ea05ac575c4b364bb5dbc44e46", "patch": "@@ -1,160 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-backend.h\"\n-#include \"scope.h\"\n-\n-namespace Rust {\n-namespace Compile {\n-\n-class Scope\n-{\n-public:\n-  Scope (Backend *backend) : backend (backend) {}\n-\n-  ~Scope () {}\n-\n-  void Push ()\n-  {\n-    fndecls.Push ();\n-    vars.Push ();\n-    types.Push ();\n-    structDecls.Push ();\n-  }\n-\n-  void Pop ()\n-  {\n-    fndecls.Pop ();\n-    vars.Pop ();\n-    types.Pop ();\n-    structDecls.Pop ();\n-  }\n-\n-  void PushCurrentFunction (std::string name, Bfunction *fn, Btype *retType,\n-\t\t\t    Bvariable *retDecl)\n-  {\n-    fns.push_back (fn);\n-    fnRetType.push_back (retType);\n-    fnRetDecl.push_back (retDecl);\n-  }\n-\n-  Bfunction *PopCurrentFunction ()\n-  {\n-    auto ret = fns.back ();\n-    fns.pop_back ();\n-    fnRetType.pop_back ();\n-    fnRetDecl.pop_back ();\n-    return ret;\n-  }\n-\n-  Bfunction *GetCurrentFndecl () { return fns.back (); }\n-\n-  Btype *GetCurrentFnRetType () { return fnRetType.back (); }\n-\n-  Bvariable *GetCurrentFnRetDecl () { return fnRetDecl.back (); }\n-\n-  Btype *GetFnRetType (Bfunction *fn)\n-  {\n-    auto it = fnRetTypeMapping.find (fn);\n-    if (it == fnRetTypeMapping.end ())\n-      {\n-\treturn NULL;\n-      }\n-    return it->second;\n-  }\n-\n-  void PushBlock (Bblock *block)\n-  {\n-    blocks.push_back (block);\n-    std::vector<Bstatement *> empty;\n-    context.push_back (empty);\n-  }\n-\n-  Bblock *PopBlock ()\n-  {\n-    auto ret = blocks.back ();\n-    blocks.pop_back ();\n-\n-    auto stmts = context.back ();\n-    context.pop_back ();\n-\n-    backend->block_add_statements (ret, stmts);\n-\n-    return ret;\n-  }\n-\n-  Bblock *CurBlock () { return blocks.back (); }\n-\n-  void AddStatement (Bstatement *stmt) { context.back ().push_back (stmt); }\n-\n-  void InsertStructDecl (std::string name, AST::StructStruct *decl)\n-  {\n-    structDecls.Insert (name, decl);\n-  }\n-\n-  bool LookupStructDecl (std::string name, AST::StructStruct **decl)\n-  {\n-    return structDecls.Lookup (name, decl);\n-  }\n-\n-  void InsertFunction (std::string name, Bfunction *fn, Btype *retType)\n-  {\n-    fndecls.Insert (name, fn);\n-    fnRetTypeMapping[fn] = retType;\n-  }\n-\n-  bool LookupFunction (std::string name, Bfunction **fn)\n-  {\n-    return fndecls.Lookup (name, fn);\n-  }\n-\n-  void InsertType (std::string name, Btype *type) { types.Insert (name, type); }\n-\n-  bool LookupType (std::string name, Btype **type)\n-  {\n-    return types.Lookup (name, type);\n-  }\n-\n-  void InsertVar (std::string name, Bvariable *var) { vars.Insert (name, var); }\n-\n-  bool LookupVar (std::string name, Bvariable **var)\n-  {\n-    return vars.Lookup (name, var);\n-  }\n-\n-private:\n-  Backend *backend;\n-\n-  ::std::vector<Bfunction *> fns;\n-  ::std::vector<Bblock *> blocks;\n-  ::std::vector< ::std::vector<Bstatement *> > context;\n-  ::std::vector< ::Btype *> fnRetType;\n-  ::std::vector< ::Bvariable *> fnRetDecl;\n-  ::std::map<Bfunction *, Btype *> fnRetTypeMapping;\n-\n-  Analysis::Scope<Bfunction *> fndecls;\n-  Analysis::Scope<Bvariable *> vars;\n-  Analysis::Scope<Btype *> types;\n-  Analysis::Scope<AST::StructStruct *> structDecls;\n-};\n-\n-} // namespace Compile\n-} // namespace Rust"}, {"sha": "ec7c13af95919ea5ef59d15f3ded141846000663", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -237,9 +237,13 @@ class HIRCompileBase : public HIR::HIRVisitor\n protected:\n   HIRCompileBase (Context *ctx) : ctx (ctx) {}\n \n+  Context *ctx;\n+\n   Context *get_context () { return ctx; }\n \n-  Context *ctx;\n+  void compile_function_body (Bfunction *fndecl,\n+\t\t\t      std::unique_ptr<HIR::BlockExpr> &function_body,\n+\t\t\t      bool has_return_type);\n };\n \n } // namespace Compile"}, {"sha": "879e32d0c24bcaedbf259fb585345c1aa4b4de71", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -28,82 +28,83 @@ namespace Compile {\n class CompileBlock : public HIRCompileBase\n {\n public:\n-  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx)\n+  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n   {\n-    CompileBlock compiler (ctx);\n+    CompileBlock compiler (ctx, result);\n     expr->accept_vis (compiler);\n     return compiler.translated;\n   }\n \n-  ~CompileBlock () {}\n-\n   void visit (HIR::BlockExpr &expr);\n \n private:\n-  CompileBlock (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+  CompileBlock (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n+  {}\n \n   Bblock *translated;\n+  Bvariable *result;\n };\n \n class CompileConditionalBlocks : public HIRCompileBase\n {\n public:\n-  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx)\n+  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx,\n+\t\t\t      Bvariable *result)\n   {\n-    CompileConditionalBlocks resolver (ctx);\n+    CompileConditionalBlocks resolver (ctx, result);\n     expr->accept_vis (resolver);\n     return resolver.translated;\n   }\n \n-  ~CompileConditionalBlocks () {}\n-\n   void visit (HIR::IfExpr &expr);\n \n   void visit (HIR::IfExprConseqElse &expr);\n \n   void visit (HIR::IfExprConseqIf &expr);\n \n private:\n-  CompileConditionalBlocks (Context *ctx)\n-    : HIRCompileBase (ctx), translated (nullptr)\n+  CompileConditionalBlocks (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n   Bstatement *translated;\n+  Bvariable *result;\n };\n \n class CompileExprWithBlock : public HIRCompileBase\n {\n public:\n-  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx)\n+  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx,\n+\t\t\t      Bvariable *result)\n   {\n-    CompileExprWithBlock resolver (ctx);\n+    CompileExprWithBlock resolver (ctx, result);\n     expr->accept_vis (resolver);\n     return resolver.translated;\n   }\n \n-  ~CompileExprWithBlock () {}\n-\n   void visit (HIR::IfExpr &expr)\n   {\n-    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n-    translated = CompileConditionalBlocks::compile (&expr, ctx);\n+    translated = CompileConditionalBlocks::compile (&expr, ctx, result);\n   }\n \n private:\n-  CompileExprWithBlock (Context *ctx)\n-    : HIRCompileBase (ctx), translated (nullptr)\n+  CompileExprWithBlock (Context *ctx, Bvariable *result)\n+    : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n   Bstatement *translated;\n+  Bvariable *result;\n };\n \n } // namespace Compile"}, {"sha": "25c9b89495382664b41c8d28fdf9ec2e7a54f99c", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -110,6 +110,11 @@ class Context\n     return scope_stack.back ();\n   }\n \n+  void add_statement_to_enclosing_scope (Bstatement *stmt)\n+  {\n+    statements.at (statements.size () - 2).push_back (stmt);\n+  }\n+\n   void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n \n   void insert_var_decl (HirId id, ::Bvariable *decl)\n@@ -222,11 +227,11 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   virtual ~TyTyResolveCompile () {}\n \n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::StructFieldType &) override { gcc_unreachable (); }\n \n   void visit (TyTy::FnType &type) override\n   {\n@@ -261,7 +266,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n       ctx->get_mappings ()->lookup_location (type.get_ref ()));\n   }\n \n-  void visit (TyTy::UnitType &type) override\n+  void visit (TyTy::UnitType &) override\n   {\n     translated = ctx->get_backend ()->void_type ();\n   }\n@@ -278,8 +283,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n       {\n \tTyTy::StructFieldType *field = type.get_field (i);\n \tBtype *compiled_field_ty\n-\t  = TyTyCompile::compile (ctx->get_backend (),\n-\t\t\t\t  field->get_field_type ());\n+\t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n \n \tBackend::Btyped_identifier f (field->get_name (), compiled_field_ty,\n \t\t\t\t      ctx->get_mappings ()->lookup_location ("}, {"sha": "b823d299260c83792481bb6e4c957156350bcd1e", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -99,6 +99,8 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::CallExpr &expr);\n \n+  void visit (HIR::MethodCallExpr &expr);\n+\n   void visit (HIR::IdentifierExpr &expr)\n   {\n     // need to look up the reference for this identifier\n@@ -409,27 +411,71 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::IfExpr &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n     ctx->add_statement (stmt);\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    // this can be a return expression\n+    TyTy::TyBase *if_type = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &if_type))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to lookup type of IfExprConseqElse\");\n+\treturn;\n+      }\n+\n+    fncontext fnctx = ctx->peek_fn ();\n+    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+    Btype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\n+    bool is_address_taken = false;\n+    Bstatement *ret_var_stmt = nullptr;\n+    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+      expr.get_locus (), &ret_var_stmt);\n+    ctx->add_statement (ret_var_stmt);\n+\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, tmp);\n     ctx->add_statement (stmt);\n+\n+    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n   {\n-    auto stmt = CompileConditionalBlocks::compile (&expr, ctx);\n+    auto stmt = CompileConditionalBlocks::compile (&expr, ctx, nullptr);\n     ctx->add_statement (stmt);\n   }\n \n   void visit (HIR::BlockExpr &expr)\n   {\n-    auto code_block = CompileBlock::compile (&expr, ctx);\n+    TyTy::TyBase *block_tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t &block_tyty))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to lookup type of BlockExpr\");\n+\treturn;\n+      }\n+\n+    fncontext fnctx = ctx->peek_fn ();\n+    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+    Btype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\n+    bool is_address_taken = false;\n+    Bstatement *ret_var_stmt = nullptr;\n+    Bvariable *tmp = ctx->get_backend ()->temporary_variable (\n+      fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+      expr.get_locus (), &ret_var_stmt);\n+    ctx->add_statement (ret_var_stmt);\n+\n+    auto code_block = CompileBlock::compile (&expr, ctx, tmp);\n     auto block_stmt = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (block_stmt);\n+\n+    translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n   }\n \n   void visit (HIR::StructExprStructFields &struct_expr)"}, {"sha": "1ea0c9fe85848f181d6e4a4283c48e42e714aff8", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -61,6 +61,22 @@ class CompileFnParam : public HIRCompileBase\n   ::Bvariable *translated;\n };\n \n+class CompileSelfParam : public HIRCompileBase\n+{\n+public:\n+  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n+\t\t\t     HIR::SelfParam &self, Btype *decl_type,\n+\t\t\t     Location locus)\n+  {\n+    if (!self.get_is_mut ())\n+      decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+    return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n+\t\t\t\t\t\t    false /* address_taken */,\n+\t\t\t\t\t\t    locus);\n+  }\n+};\n+\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "6d180c87891a2a9451b6b3a2008fc130ef1648b1", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 213, "deletions": 35, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -32,10 +32,10 @@ namespace Compile {\n class CompileInherentImplItem : public HIRCompileBase\n {\n public:\n-  static void Compile (HIR::Type *base, HIR::InherentImplItem *item,\n+  static void Compile (TyTy::TyBase *self, HIR::InherentImplItem *item,\n \t\t       Context *ctx, bool compile_fns)\n   {\n-    CompileInherentImplItem compiler (base, ctx, compile_fns);\n+    CompileInherentImplItem compiler (self, ctx, compile_fns);\n     item->accept_vis (compiler);\n   }\n \n@@ -50,7 +50,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n-    std::string ident = base->as_string () + \"::\" + constant.get_identifier ();\n+    std::string ident = self->as_string () + \"::\" + constant.get_identifier ();\n     Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n@@ -78,7 +78,8 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n       {\n-\trust_fatal_error (function.locus, \"failed to lookup function type\");\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to lookup function type\");\n \treturn;\n       }\n \n@@ -93,23 +94,15 @@ class CompileInherentImplItem : public HIRCompileBase\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n-    bool is_main_fn = function.function_name.compare (\"main\") == 0;\n-\n     std::string fn_identifier\n-      = base->as_string () + \"::\" + function.function_name;\n+      = self->as_string () + \"::\" + function.function_name;\n \n     // if its the main fn or pub visibility mark its as DECL_PUBLIC\n     // please see https://github.com/Rust-GCC/gccrs/pull/137\n-    if (is_main_fn || function.has_visibility ())\n+    if (function.has_visibility ())\n       flags |= Backend::function_is_visible;\n \n     std::string asm_name = fn_identifier;\n-    if (!is_main_fn)\n-      {\n-\t// FIXME need name mangling\n-\tasm_name = \"__\" + function.function_name;\n-      }\n-\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n@@ -213,34 +206,219 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     ctx->push_fn (fndecl, return_address);\n \n-    // compile the block\n-    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n-      CompileStmt::Compile (s, ctx);\n+    compile_function_body (fndecl, function.function_body,\n+\t\t\t   function.has_function_return_type ());\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (function.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+\n+    ctx->push_function (fndecl);\n+  }\n+\n+  void visit (HIR::Method &method)\n+  {\n+    if (!compile_fns)\n+      return;\n+\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (method.get_mappings ().get_hirid (),\n+\t\t\t\t   &lookup))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  return;\n+      }\n+\n+    TyTy::TyBase *fntype_tyty;\n+    if (!ctx->get_tyctx ()->lookup_type (method.get_mappings ().get_hirid (),\n+\t\t\t\t\t &fntype_tyty))\n+      {\n+\trust_fatal_error (method.get_locus (),\n+\t\t\t  \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (method.get_locus (), \"invalid TyTy for function item\");\n+\treturn;\n+      }\n+\n+    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n+    // convert to the actual function type\n+    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+\n+    unsigned int flags = 0;\n+    std::string fn_identifier\n+      = self->as_string () + \"::\" + method.get_method_name ();\n+\n+    // if its the main fn or pub visibility mark its as DECL_PUBLIC\n+    // please see https://github.com/Rust-GCC/gccrs/pull/137\n+    if (method.has_visibility ())\n+      flags |= Backend::function_is_visible;\n+\n+    std::string asm_name = fn_identifier;\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n+\t\t\t\t       asm_name, flags, method.get_locus ());\n+    ctx->insert_function_decl (method.get_mappings ().get_hirid (), fndecl);\n+\n+    // setup the params\n+    TyTy::TyBase *tyret = fntype->return_type ();\n+    std::vector<Bvariable *> param_vars;\n+\n+    // insert self\n+    TyTy::TyBase *self_tyty_lookup = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  method.get_self_param ().get_mappings ().get_hirid (),\n+\t  &self_tyty_lookup))\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to lookup self param type\");\n+\treturn;\n+      }\n+\n+    Btype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+    if (self_type == nullptr)\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to compile self param type\");\n+\treturn;\n+      }\n+\n+    Bvariable *compiled_self_param\n+      = CompileSelfParam::compile (ctx, fndecl, method.get_self_param (),\n+\t\t\t\t   self_type,\n+\t\t\t\t   method.get_self_param ().get_locus ());\n+    if (compiled_self_param == nullptr)\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to compile self param variable\");\n+\treturn;\n+      }\n+\n+    param_vars.push_back (compiled_self_param);\n+    ctx->insert_var_decl (method.get_self_param ().get_mappings ().get_hirid (),\n+\t\t\t  compiled_self_param);\n+\n+    // offset from + 1 for the TyTy::FnType being used\n+    size_t i = 1;\n+    for (auto referenced_param : method.get_function_params ())\n+      {\n+\tauto tyty_param = fntype->param_at (i);\n+\tauto param_tyty = tyty_param.second;\n+\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\tif (compiled_param_type == nullptr)\n+\t  {\n+\t    rust_error_at (referenced_param.get_locus (),\n+\t\t\t   \"failed to compile parameter type\");\n+\t    return;\n+\t  }\n+\n+\tLocation param_locus\n+\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n+\tBvariable *compiled_param_var\n+\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t     compiled_param_type, param_locus);\n+\tif (compiled_param_var == nullptr)\n+\t  {\n+\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_param_var);\n+\n+\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t      compiled_param_var);\n+\ti++;\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (method.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = method.get_function_body ().get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (method.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n+      Resolver::Definition d;\n+      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      locals.push_back (compiled);\n+\n       return true;\n     });\n \n-    if (function_body->has_expr () && function_body->tail_expr_reachable ())\n+    bool toplevel_item\n+      = method.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n+    Bblock *enclosing_scope\n+      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n+\n+    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (method.has_function_return_type ())\n       {\n-\t// the previous passes will ensure this is a valid return\n-\t// dead code elimination should remove any bad trailing expressions\n-\tBexpression *compiled_expr\n-\t  = CompileExpr::Compile (function_body->expr.get (), ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\n-\tauto fncontext = ctx->peek_fn ();\n-\n-\tstd::vector<Bexpression *> retstmts;\n-\tretstmts.push_back (compiled_expr);\n-\tauto s = ctx->get_backend ()->return_statement (\n-\t  fncontext.fndecl, retstmts, function_body->expr->get_locus_slow ());\n-\tctx->add_statement (s);\n+\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  method.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n       }\n \n+    ctx->push_fn (fndecl, return_address);\n+\n+    compile_function_body (fndecl, method.get_function_body (),\n+\t\t\t   method.has_function_return_type ());\n+\n     ctx->pop_block ();\n     auto body = ctx->get_backend ()->block_statement (code_block);\n     if (!ctx->get_backend ()->function_set_body (fndecl, body))\n       {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n+\trust_error_at (method.get_locus (), \"failed to set body to function\");\n \treturn;\n       }\n \n@@ -250,11 +428,11 @@ class CompileInherentImplItem : public HIRCompileBase\n   }\n \n private:\n-  CompileInherentImplItem (HIR::Type *base, Context *ctx, bool compile_fns)\n-    : HIRCompileBase (ctx), base (base), compile_fns (compile_fns)\n+  CompileInherentImplItem (TyTy::TyBase *self, Context *ctx, bool compile_fns)\n+    : HIRCompileBase (ctx), self (self), compile_fns (compile_fns)\n   {}\n \n-  HIR::Type *base;\n+  TyTy::TyBase *self;\n   bool compile_fns;\n };\n "}, {"sha": "7f93af9fefbc475291cff68253570bee0c835d8d", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -265,28 +265,8 @@ class CompileItem : public HIRCompileBase\n \n     ctx->push_fn (fndecl, return_address);\n \n-    // compile the block\n-    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n-      CompileStmt::Compile (s, ctx);\n-      return true;\n-    });\n-\n-    if (function_body->has_expr () && function_body->tail_expr_reachable ())\n-      {\n-\t// the previous passes will ensure this is a valid return\n-\t// dead code elimination should remove any bad trailing expressions\n-\tBexpression *compiled_expr\n-\t  = CompileExpr::Compile (function_body->expr.get (), ctx);\n-\trust_assert (compiled_expr != nullptr);\n-\n-\tauto fncontext = ctx->peek_fn ();\n-\n-\tstd::vector<Bexpression *> retstmts;\n-\tretstmts.push_back (compiled_expr);\n-\tauto s = ctx->get_backend ()->return_statement (\n-\t  fncontext.fndecl, retstmts, function_body->expr->get_locus_slow ());\n-\tctx->add_statement (s);\n-      }\n+    compile_function_body (fndecl, function.function_body,\n+\t\t\t   function.has_function_return_type ());\n \n     ctx->pop_block ();\n     auto body = ctx->get_backend ()->block_statement (code_block);\n@@ -297,15 +277,23 @@ class CompileItem : public HIRCompileBase\n       }\n \n     ctx->pop_fn ();\n-\n     ctx->push_function (fndecl);\n   }\n \n   void visit (HIR::InherentImpl &impl_block)\n   {\n+    TyTy::TyBase *self_lookup = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n+      {\n+\trust_error_at (impl_block.get_locus (),\n+\t\t       \"failed to resolve type of impl\");\n+\treturn;\n+      }\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (impl_block.get_type ().get (),\n-\t\t\t\t\timpl_item.get (), ctx, compile_fns);\n+      CompileInherentImplItem::Compile (self_lookup, impl_item.get (), ctx,\n+\t\t\t\t\tcompile_fns);\n   }\n \n private:"}, {"sha": "d021240e4280b092374ac269eea2ec2160bcd544", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -29,37 +29,24 @@ namespace Compile {\n class CompileStmt : public HIRCompileBase\n {\n public:\n-  static void Compile (HIR::Stmt *stmt, Context *ctx)\n+  static Bexpression *Compile (HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileStmt compiler (ctx);\n     stmt->accept_vis (compiler);\n     rust_assert (compiler.ok);\n+    return compiler.translated;\n   }\n \n-  virtual ~CompileStmt () {}\n-\n   void visit (HIR::ExprStmtWithBlock &stmt)\n   {\n     ok = true;\n-    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n-\n-    // these can be null\n-    if (translated == nullptr)\n-      return;\n-\n-    gcc_unreachable ();\n+    translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n   }\n \n   void visit (HIR::ExprStmtWithoutBlock &stmt)\n   {\n     ok = true;\n-    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n-\n-    // these can be null\n-    if (translated == nullptr)\n-      return;\n-\n-    gcc_unreachable ();\n+    translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n   }\n \n   void visit (HIR::LetStmt &stmt)\n@@ -99,9 +86,12 @@ class CompileStmt : public HIRCompileBase\n   }\n \n private:\n-  CompileStmt (Context *ctx) : HIRCompileBase (ctx), ok (false) {}\n+  CompileStmt (Context *ctx)\n+    : HIRCompileBase (ctx), ok (false), translated (nullptr)\n+  {}\n \n   bool ok;\n+  Bexpression *translated;\n };\n \n } // namespace Compile"}, {"sha": "0629cbed186bc6ad462a1f237e802e4a6eebb467", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -44,22 +44,19 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   ~TyTyCompile () {}\n \n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::StructFieldType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::TupleType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::UnitType &type) override\n-  {\n-    translated = backend->void_type ();\n-  }\n+  void visit (TyTy::UnitType &) override { translated = backend->void_type (); }\n \n   void visit (TyTy::FnType &type) override\n   {\n@@ -93,7 +90,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \t\t\t\tmappings->lookup_location (type.get_ref ()));\n   }\n \n-  void visit (TyTy::BoolType &type) override\n+  void visit (TyTy::BoolType &) override\n   {\n     translated = backend->named_type (\"bool\", backend->bool_type (),\n \t\t\t\t      Linemap::predeclared_location ());\n@@ -190,14 +187,14 @@ class TyTyCompile : public TyTy::TyVisitor\n     gcc_unreachable ();\n   }\n \n-  void visit (TyTy::USizeType &type) override\n+  void visit (TyTy::USizeType &) override\n   {\n     translated = backend->named_type (\n       \"usize\", backend->integer_type (true, backend->get_pointer_size ()),\n       Linemap::predeclared_location ());\n   }\n \n-  void visit (TyTy::ISizeType &type) override\n+  void visit (TyTy::ISizeType &) override\n   {\n     translated = backend->named_type (\n       \"isize\", backend->integer_type (false, backend->get_pointer_size ()),"}, {"sha": "0b83c720da17bd9513890172e620bdd467eb26ef", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 185, "deletions": 16, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -95,6 +95,83 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     }\n }\n \n+void\n+CompileExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // lookup compiled functions\n+  Bfunction *fn = nullptr;\n+  if (!ctx->lookup_function_decl (ref, &fn))\n+    {\n+      // this might fail because its a forward decl so we can attempt to\n+      // resolve it now\n+      HIR::InherentImplItem *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_implitem (\n+\t  expr.get_mappings ().get_crate_num (), ref);\n+      if (resolved_item == nullptr)\n+\t{\n+\t  rust_error_at (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  return;\n+\t}\n+\n+      TyTy::TyBase *self_type = nullptr;\n+      if (!ctx->get_tyctx ()->lookup_type (\n+\t    expr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"failed to resolve type for self param\");\n+\t  return;\n+\t}\n+\n+      CompileInherentImplItem::Compile (self_type, resolved_item, ctx, true);\n+      if (!ctx->lookup_function_decl (ref, &fn))\n+\t{\n+\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n+\t  return;\n+\t}\n+    }\n+\n+  Bexpression *fn_expr\n+    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+\n+  std::vector<Bexpression *> args;\n+\n+  // method receiver\n+  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+  rust_assert (self != nullptr);\n+  args.push_back (self);\n+\n+  // normal args\n+  expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+    Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+    rust_assert (compiled_expr != nullptr);\n+    args.push_back (compiled_expr);\n+    return true;\n+  });\n+\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n+}\n+\n // rust-compile-block.h\n \n void\n@@ -135,10 +212,30 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \t\t\t\t  start_location, end_location);\n   ctx->push_block (new_block);\n \n-  expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n-    CompileStmt::Compile (s, ctx);\n-    return true;\n-  });\n+  for (auto &s : expr.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr == nullptr)\n+\tcontinue;\n+\n+      if (result == nullptr)\n+\t{\n+\t  Bstatement *final_stmt\n+\t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n+\t\t\t\t\t\t\t compiled_expr);\n+\t  ctx->add_statement (final_stmt);\n+\t}\n+      else\n+\t{\n+\t  Bexpression *result_reference\n+\t    = ctx->get_backend ()->var_expression (result,\n+\t\t\t\t\t\t   s->get_locus_slow ());\n+\n+\t  Bstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\t    fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n+\t  ctx->add_statement (assignment);\n+\t}\n+    }\n \n   if (expr.has_expr () && expr.tail_expr_reachable ())\n     {\n@@ -147,14 +244,22 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       Bexpression *compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n       rust_assert (compiled_expr != nullptr);\n \n-      auto fncontext = ctx->peek_fn ();\n+      if (result == nullptr)\n+\t{\n+\t  Bstatement *final_stmt\n+\t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n+\t\t\t\t\t\t\t compiled_expr);\n+\t  ctx->add_statement (final_stmt);\n+\t}\n+      else\n+\t{\n+\t  Bexpression *result_reference = ctx->get_backend ()->var_expression (\n+\t    result, expr.get_final_expr ()->get_locus_slow ());\n \n-      std::vector<Bexpression *> retstmts;\n-      retstmts.push_back (compiled_expr);\n-      auto s\n-\t= ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n-\t\t\t\t\t\t expr.expr->get_locus_slow ());\n-      ctx->add_statement (s);\n+\t  Bstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\t    fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n+\t  ctx->add_statement (assignment);\n+\t}\n     }\n \n   ctx->pop_block ();\n@@ -168,7 +273,8 @@ CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n   Bfunction *fndecl = fnctx.fndecl;\n   Bexpression *condition_expr\n     = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+  Bblock *then_block\n+    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -182,8 +288,10 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n   Bfunction *fndecl = fnctx.fndecl;\n   Bexpression *condition_expr\n     = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n-  Bblock *else_block = CompileBlock::compile (expr.get_else_block (), ctx);\n+  Bblock *then_block\n+    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  Bblock *else_block\n+    = CompileBlock::compile (expr.get_else_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -197,7 +305,8 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n   Bfunction *fndecl = fnctx.fndecl;\n   Bexpression *condition_expr\n     = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block = CompileBlock::compile (expr.get_if_block (), ctx);\n+  Bblock *then_block\n+    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   // else block\n   std::vector<Bvariable *> locals;\n@@ -210,7 +319,8 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n   ctx->push_block (else_block);\n \n   Bstatement *else_stmt_decl\n-    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx);\n+    = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n+\t\t\t\t\t result);\n   ctx->add_statement (else_stmt_decl);\n \n   ctx->pop_block ();\n@@ -244,5 +354,64 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n   translated = CompileExpr::Compile (&expr, ctx);\n }\n \n+// Shared methods in compilation\n+\n+void\n+HIRCompileBase::compile_function_body (\n+  Bfunction *fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n+  bool has_return_type)\n+{\n+  for (auto &s : function_body->get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (has_return_type)\n+\t    {\n+\t      std::vector<Bexpression *> retstmts;\n+\t      retstmts.push_back (compiled_expr);\n+\n+\t      auto ret\n+\t\t= ctx->get_backend ()->return_statement (fndecl, retstmts,\n+\t\t\t\t\t\t\t s->get_locus_slow ());\n+\t      ctx->add_statement (ret);\n+\t    }\n+\t  else\n+\t    {\n+\t      Bstatement *final_stmt\n+\t\t= ctx->get_backend ()->expression_statement (fndecl,\n+\t\t\t\t\t\t\t     compiled_expr);\n+\t      ctx->add_statement (final_stmt);\n+\t    }\n+\t}\n+    }\n+\n+  if (function_body->has_expr () && function_body->tail_expr_reachable ())\n+    {\n+      // the previous passes will ensure this is a valid return\n+      // dead code elimination should remove any bad trailing expressions\n+      Bexpression *compiled_expr\n+\t= CompileExpr::Compile (function_body->expr.get (), ctx);\n+      rust_assert (compiled_expr != nullptr);\n+\n+      if (has_return_type)\n+\t{\n+\t  std::vector<Bexpression *> retstmts;\n+\t  retstmts.push_back (compiled_expr);\n+\n+\t  auto ret = ctx->get_backend ()->return_statement (\n+\t    fndecl, retstmts,\n+\t    function_body->get_final_expr ()->get_locus_slow ());\n+\t  ctx->add_statement (ret);\n+\t}\n+      else\n+\t{\n+\t  Bstatement *final_stmt\n+\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n+\t  ctx->add_statement (final_stmt);\n+\t}\n+    }\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "cd1863f8cdb772988e52ca8c464e1548f33cddc2", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -238,6 +238,35 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t   expr.get_locus ());\n   }\n \n+  void visit (AST::MethodCallExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    HIR::PathExprSegment method_path (\n+      expr.get_method_name ().get_ident_segment ().as_string (),\n+      expr.get_method_name ().get_locus ());\n+\n+    HIR::Expr *receiver\n+      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+    std::vector<std::unique_ptr<HIR::Expr> > params;\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      auto trans = ASTLoweringExpr::translate (p);\n+      params.push_back (std::unique_ptr<HIR::Expr> (trans));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (\n+      crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n+      mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::MethodCallExpr (mapping, std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t\t method_path, std::move (params),\n+\t\t\t\t std::move (outer_attribs), expr.get_locus ());\n+  }\n+\n   void visit (AST::AssignmentExpr &expr)\n   {\n     HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());"}, {"sha": "de4d55d19c89fffabe0c4ce03c213b5c8549d608", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -40,6 +40,21 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  HIR::SelfParam lower_self (AST::SelfParam &self)\n+  {\n+    HIR::Type *type = self.has_type ()\n+\t\t\t? ASTLoweringType::translate (self.get_type ().get ())\n+\t\t\t: nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, self.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t   self.get_is_mut (), self.get_locus ());\n+  }\n+\n   void visit (AST::ConstantItem &constant)\n   {\n     std::vector<HIR::Attribute> outer_attrs;\n@@ -143,6 +158,91 @@ class ASTLowerImplItem : public ASTLoweringBase\n     translated = fn;\n   }\n \n+  void visit (AST::Method &method)\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<HIR::Attribute> outer_attrs;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // need\n+    Identifier method_name = method.get_method_name ();\n+    Location locus = method.get_locus ();\n+\n+    HIR::SelfParam self_param = lower_self (method.get_self_param ());\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = method.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (method.get_return_type ().get ()))\n+\t\t\t\t  : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : method.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> method_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (method.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, method.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+    auto mth\n+      = new HIR::Method (mapping, std::move (method_name),\n+\t\t\t std::move (qualifiers), std::move (generic_params),\n+\t\t\t std::move (self_param), std::move (function_params),\n+\t\t\t std::move (return_type), std::move (where_clause),\n+\t\t\t std::move (method_body), std::move (vis),\n+\t\t\t std::move (outer_attrs), locus);\n+\n+    mappings->insert_hir_implitem (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), mth);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       method.get_locus ());\n+\n+    // insert mappings for self\n+    mappings->insert_hir_self_param (crate_num,\n+\t\t\t\t     self_param.get_mappings ().get_hirid (),\n+\t\t\t\t     &self_param);\n+    mappings->insert_location (crate_num,\n+\t\t\t       self_param.get_mappings ().get_hirid (),\n+\t\t\t       self_param.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : mth->get_function_params ())\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n+\n+    translated = mth;\n+  }\n+\n private:\n   ASTLowerImplItem () : translated (nullptr) {}\n "}, {"sha": "d4af3c215653480f73245dfd726323f3a323d5f3", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -2177,9 +2177,9 @@ class CallExpr : public ExprWithoutBlock\n \n   void iterate_params (std::function<bool (Expr *)> cb)\n   {\n-    for (auto it = params.begin (); it != params.end (); it++)\n+    for (auto &param : params)\n       {\n-\tif (!cb (it->get ()))\n+\tif (!cb (param.get ()))\n \t  return;\n       }\n   }\n@@ -2261,6 +2261,27 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_receiver () { return receiver; }\n+\n+  PathExprSegment get_method_name () const { return method_name; };\n+\n+  std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n+  const std::vector<std::unique_ptr<Expr> > &get_params () const\n+  {\n+    return params;\n+  }\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  void iterate_params (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto &param : params)\n+      {\n+\tif (!cb (param.get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2585,6 +2606,10 @@ class BlockExpr : public ExprWithBlock\n     return statements[statements.size () - 1]->get_locus_slow ();\n   }\n \n+  std::unique_ptr<ExprWithoutBlock> &get_final_expr () { return expr; }\n+\n+  std::vector<std::unique_ptr<Stmt> > &get_statements () { return statements; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "e4fa39a0f2a7962f393d10901a9b24f678d643cc", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -676,7 +676,7 @@ Method::as_string () const\n     }\n \n   str += \"\\n Block expr (body): \\n  \";\n-  str += expr->as_string ();\n+  str += function_body->as_string ();\n \n   return str;\n }"}, {"sha": "4ab23e155f5598bb3a3a7fc4b59a98f6f2d4c638", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 85, "deletions": 14, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -297,10 +297,13 @@ struct SelfParam\n \n   Location locus;\n \n+  Analysis::NodeMapping mappings;\n+\n   // Unrestricted constructor used for error state\n-  SelfParam (Lifetime lifetime, bool has_ref, bool is_mut, Type *type)\n+  SelfParam (Analysis::NodeMapping mappings, Lifetime lifetime, bool has_ref,\n+\t     bool is_mut, Type *type)\n     : has_ref (has_ref), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      type (type)\n+      type (type), mappings (mappings)\n   {}\n   // this is ok as no outside classes can ever call this\n \n@@ -319,21 +322,23 @@ struct SelfParam\n   }\n \n   // Type-based self parameter (not ref, no lifetime)\n-  SelfParam (std::unique_ptr<Type> type, bool is_mut, Location locus)\n+  SelfParam (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     bool is_mut, Location locus)\n     : has_ref (false), is_mut (is_mut), lifetime (Lifetime::error ()),\n-      type (std::move (type)), locus (locus)\n+      type (std::move (type)), locus (locus), mappings (mappings)\n   {}\n \n   // Lifetime-based self parameter (is ref, no type)\n-  SelfParam (Lifetime lifetime, bool is_mut, Location locus)\n+  SelfParam (Analysis::NodeMapping mappings, Lifetime lifetime, bool is_mut,\n+\t     Location locus)\n     : has_ref (true), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      locus (locus)\n+      locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor requires clone\n   SelfParam (SelfParam const &other)\n     : has_ref (other.has_ref), is_mut (other.is_mut), lifetime (other.lifetime),\n-      locus (other.locus)\n+      locus (other.locus), mappings (other.mappings)\n   {\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n@@ -348,6 +353,7 @@ struct SelfParam\n     has_ref = other.has_ref;\n     lifetime = other.lifetime;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -359,6 +365,18 @@ struct SelfParam\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  bool get_has_ref () const { return has_ref; };\n+  bool get_is_mut () const { return is_mut; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n+\n+  Analysis::NodeMapping get_mappings () { return mappings; }\n };\n \n // Qualifiers for function, i.e. const, unsafe, extern etc.\n@@ -542,6 +560,8 @@ struct Visibility\n // A method (function belonging to a type)\n class Method : public InherentImplItem, public TraitImplItem\n {\n+  Analysis::NodeMapping mappings;\n+\n   // moved from impl items for consistency\n   std::vector<Attribute> outer_attrs;\n   Visibility vis;\n@@ -566,9 +586,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::unique_ptr<BlockExpr> expr;\n-\n-  Analysis::NodeMapping mappings;\n+  std::unique_ptr<BlockExpr> function_body;\n \n   Location locus;\n \n@@ -603,8 +621,8 @@ class Method : public InherentImplItem, public TraitImplItem\n       self_param (std::move (self_param)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), expr (std::move (function_body)),\n-      locus (locus)\n+      where_clause (std::move (where_clause)),\n+      function_body (std::move (function_body)), locus (locus)\n   {}\n \n   // TODO: add constructor with less fields\n@@ -616,7 +634,8 @@ class Method : public InherentImplItem, public TraitImplItem\n       method_name (other.method_name), self_param (other.self_param),\n       function_params (other.function_params),\n       return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause), expr (other.expr->clone_block_expr ()),\n+      where_clause (other.where_clause),\n+      function_body (other.function_body->clone_block_expr ()),\n       locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n@@ -636,7 +655,7 @@ class Method : public InherentImplItem, public TraitImplItem\n     function_params = other.function_params;\n     return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n-    expr = other.expr->clone_block_expr ();\n+    function_body = other.function_body->clone_block_expr ();\n     locus = other.locus;\n \n     generic_params.reserve (other.generic_params.size ());\n@@ -661,6 +680,58 @@ class Method : public InherentImplItem, public TraitImplItem\n     return get_mappings ();\n   };\n \n+  // Returns whether function has return type - if not, it is void.\n+  bool has_function_return_type () const { return return_type != nullptr; }\n+\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (function_body != nullptr);\n+    return function_body;\n+  }\n+\n+  SelfParam &get_self_param () { return self_param; }\n+  const SelfParam &get_self_param () const { return self_param; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  Identifier get_method_name () const { return method_name; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n+  const std::unique_ptr<BlockExpr> &get_function_body () const\n+  {\n+    return function_body;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "9a772f0d8599a168aa284550cbcad950c1e37d27", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -228,6 +228,8 @@ class PathExprSegment\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  PathIdentSegment get_segment () const { return segment_name; }\n };\n \n // HIR node representing a pattern that involves a \"path\" - abstract base class"}, {"sha": "16334bdfbd2f18c47a9fd72821486154e3e2d6de", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 175, "deletions": 205, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -21,7 +21,6 @@\n \n #include \"rust-ast-visitor.h\"\n #include \"rust-name-resolver.h\"\n-\n #include \"rust-diagnostics.h\"\n #include \"rust-location.h\"\n \n@@ -33,210 +32,181 @@ class ResolverBase : public AST::ASTVisitor\n public:\n   virtual ~ResolverBase () {}\n \n-  // visitor impl\n-  // rust-ast.h\n-  //  virtual void visit(AttrInput& attr_input);\n-  //  virtual void visit(TokenTree& token_tree);\n-  //  virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok) {}\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree) {}\n-  virtual void visit (AST::AttrInputMetaItemContainer &input) {}\n-  //  virtual void visit(MetaItem& meta_item) {}\n-  //  void vsit(Stmt& stmt) {}\n-  //  virtual void visit(Expr& expr) {}\n-  virtual void visit (AST::IdentifierExpr &ident_expr) {}\n-  //  virtual void visit(Pattern& pattern) {}\n-  //  virtual void visit(Type& type) {}\n-  //  virtual void visit(TypeParamBound& type_param_bound) {}\n-  virtual void visit (AST::Lifetime &lifetime) {}\n-  //  virtual void visit(GenericParam& generic_param) {}\n-  virtual void visit (AST::LifetimeParam &lifetime_param) {}\n-  //  virtual void visit(TraitItem& trait_item) {}\n-  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n-  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n-  virtual void visit (AST::MacroInvocationSemi &macro) {}\n-\n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path) {}\n-  virtual void visit (AST::TypePathSegment &segment) {}\n-  virtual void visit (AST::TypePathSegmentGeneric &segment) {}\n-  virtual void visit (AST::TypePathSegmentFunction &segment) {}\n-  virtual void visit (AST::TypePath &path) {}\n-  virtual void visit (AST::QualifiedPathInExpression &path) {}\n-  virtual void visit (AST::QualifiedPathInType &path) {}\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr) {}\n-  virtual void visit (AST::AttrInputLiteral &attr_input) {}\n-  virtual void visit (AST::MetaItemLitExpr &meta_item) {}\n-  virtual void visit (AST::MetaItemPathLit &meta_item) {}\n-  virtual void visit (AST::BorrowExpr &expr) {}\n-  virtual void visit (AST::DereferenceExpr &expr) {}\n-  virtual void visit (AST::ErrorPropagationExpr &expr) {}\n-  virtual void visit (AST::NegationExpr &expr) {}\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) {}\n-  virtual void visit (AST::ComparisonExpr &expr) {}\n-  virtual void visit (AST::LazyBooleanExpr &expr) {}\n-  virtual void visit (AST::TypeCastExpr &expr) {}\n-  virtual void visit (AST::AssignmentExpr &expr) {}\n-  virtual void visit (AST::CompoundAssignmentExpr &expr) {}\n-  virtual void visit (AST::GroupedExpr &expr) {}\n-  //  virtual void visit(ArrayElems& elems) {}\n-  virtual void visit (AST::ArrayElemsValues &elems) {}\n-  virtual void visit (AST::ArrayElemsCopied &elems) {}\n-  virtual void visit (AST::ArrayExpr &expr) {}\n-  virtual void visit (AST::ArrayIndexExpr &expr) {}\n-  virtual void visit (AST::TupleExpr &expr) {}\n-  virtual void visit (AST::TupleIndexExpr &expr) {}\n-  virtual void visit (AST::StructExprStruct &expr) {}\n-  //  virtual void visit(StructExprField& field) {}\n-  virtual void visit (AST::StructExprFieldIdentifier &field) {}\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field) {}\n-  virtual void visit (AST::StructExprFieldIndexValue &field) {}\n-  virtual void visit (AST::StructExprStructFields &expr) {}\n-  virtual void visit (AST::StructExprStructBase &expr) {}\n-  virtual void visit (AST::StructExprTuple &expr) {}\n-  virtual void visit (AST::StructExprUnit &expr) {}\n-  //  virtual void visit(EnumExprField& field) {}\n-  virtual void visit (AST::EnumExprFieldIdentifier &field) {}\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field) {}\n-  virtual void visit (AST::EnumExprFieldIndexValue &field) {}\n-  virtual void visit (AST::EnumExprStruct &expr) {}\n-  virtual void visit (AST::EnumExprTuple &expr) {}\n-  virtual void visit (AST::EnumExprFieldless &expr) {}\n-  virtual void visit (AST::CallExpr &expr) {}\n-  virtual void visit (AST::MethodCallExpr &expr) {}\n-  virtual void visit (AST::FieldAccessExpr &expr) {}\n-  virtual void visit (AST::ClosureExprInner &expr) {}\n-  virtual void visit (AST::BlockExpr &expr) {}\n-  virtual void visit (AST::ClosureExprInnerTyped &expr) {}\n-  virtual void visit (AST::ContinueExpr &expr) {}\n-  virtual void visit (AST::BreakExpr &expr) {}\n-  virtual void visit (AST::RangeFromToExpr &expr) {}\n-  virtual void visit (AST::RangeFromExpr &expr) {}\n-  virtual void visit (AST::RangeToExpr &expr) {}\n-  virtual void visit (AST::RangeFullExpr &expr) {}\n-  virtual void visit (AST::RangeFromToInclExpr &expr) {}\n-  virtual void visit (AST::RangeToInclExpr &expr) {}\n-  virtual void visit (AST::ReturnExpr &expr) {}\n-  virtual void visit (AST::UnsafeBlockExpr &expr) {}\n-  virtual void visit (AST::LoopExpr &expr) {}\n-  virtual void visit (AST::WhileLoopExpr &expr) {}\n-  virtual void visit (AST::WhileLetLoopExpr &expr) {}\n-  virtual void visit (AST::ForLoopExpr &expr) {}\n-  virtual void visit (AST::IfExpr &expr) {}\n-  virtual void visit (AST::IfExprConseqElse &expr) {}\n-  virtual void visit (AST::IfExprConseqIf &expr) {}\n-  virtual void visit (AST::IfExprConseqIfLet &expr) {}\n-  virtual void visit (AST::IfLetExpr &expr) {}\n-  virtual void visit (AST::IfLetExprConseqElse &expr) {}\n-  virtual void visit (AST::IfLetExprConseqIf &expr) {}\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr) {}\n-  //  virtual void visit(MatchCase& match_case) {}\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case) {}\n-  // virtual void visit (AST::MatchCaseExpr &match_case) {}\n-  virtual void visit (AST::MatchExpr &expr) {}\n-  virtual void visit (AST::AwaitExpr &expr) {}\n-  virtual void visit (AST::AsyncBlockExpr &expr) {}\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param) {}\n-  //  virtual void visit(WhereClauseItem& item) {}\n-  virtual void visit (AST::LifetimeWhereClauseItem &item) {}\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item) {}\n-  virtual void visit (AST::Method &method) {}\n-  virtual void visit (AST::ModuleBodied &module) {}\n-  virtual void visit (AST::ModuleNoBody &module) {}\n-  virtual void visit (AST::ExternCrate &crate) {}\n-  //  virtual void visit(UseTree& use_tree) {}\n-  virtual void visit (AST::UseTreeGlob &use_tree) {}\n-  virtual void visit (AST::UseTreeList &use_tree) {}\n-  virtual void visit (AST::UseTreeRebind &use_tree) {}\n-  virtual void visit (AST::UseDeclaration &use_decl) {}\n-  virtual void visit (AST::Function &function) {}\n-  virtual void visit (AST::TypeAlias &type_alias) {}\n-  virtual void visit (AST::StructStruct &struct_item) {}\n-  virtual void visit (AST::TupleStruct &tuple_struct) {}\n-  virtual void visit (AST::EnumItem &item) {}\n-  virtual void visit (AST::EnumItemTuple &item) {}\n-  virtual void visit (AST::EnumItemStruct &item) {}\n-  virtual void visit (AST::EnumItemDiscriminant &item) {}\n-  virtual void visit (AST::Enum &enum_item) {}\n-  virtual void visit (AST::Union &union_item) {}\n-  virtual void visit (AST::ConstantItem &const_item) {}\n-  virtual void visit (AST::StaticItem &static_item) {}\n-  virtual void visit (AST::TraitItemFunc &item) {}\n-  virtual void visit (AST::TraitItemMethod &item) {}\n-  virtual void visit (AST::TraitItemConst &item) {}\n-  virtual void visit (AST::TraitItemType &item) {}\n-  virtual void visit (AST::Trait &trait) {}\n-  virtual void visit (AST::InherentImpl &impl) {}\n-  virtual void visit (AST::TraitImpl &impl) {}\n-  //  virtual void visit(ExternalItem& item) {}\n-  virtual void visit (AST::ExternalStaticItem &item) {}\n-  virtual void visit (AST::ExternalFunctionItem &item) {}\n-  virtual void visit (AST::ExternBlock &block) {}\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match) {}\n-  virtual void visit (AST::MacroMatchRepetition &match) {}\n-  virtual void visit (AST::MacroMatcher &matcher) {}\n-  virtual void visit (AST::MacroRulesDefinition &rules_def) {}\n-  virtual void visit (AST::MacroInvocation &macro_invoc) {}\n-  virtual void visit (AST::MetaItemPath &meta_item) {}\n-  virtual void visit (AST::MetaItemSeq &meta_item) {}\n-  virtual void visit (AST::MetaWord &meta_item) {}\n-  virtual void visit (AST::MetaNameValueStr &meta_item) {}\n-  virtual void visit (AST::MetaListPaths &meta_item) {}\n-  virtual void visit (AST::MetaListNameValueStr &meta_item) {}\n-\n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern) {}\n-  virtual void visit (AST::IdentifierPattern &pattern) {}\n-  virtual void visit (AST::WildcardPattern &pattern) {}\n-  //  virtual void visit(RangePatternBound& bound) {}\n-  virtual void visit (AST::RangePatternBoundLiteral &bound) {}\n-  virtual void visit (AST::RangePatternBoundPath &bound) {}\n-  virtual void visit (AST::RangePatternBoundQualPath &bound) {}\n-  virtual void visit (AST::RangePattern &pattern) {}\n-  virtual void visit (AST::ReferencePattern &pattern) {}\n-  //  virtual void visit(StructPatternField& field) {}\n-  virtual void visit (AST::StructPatternFieldTuplePat &field) {}\n-  virtual void visit (AST::StructPatternFieldIdentPat &field) {}\n-  virtual void visit (AST::StructPatternFieldIdent &field) {}\n-  virtual void visit (AST::StructPattern &pattern) {}\n-  //  virtual void visit(TupleStructItems& tuple_items) {}\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) {}\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items) {}\n-  virtual void visit (AST::TupleStructPattern &pattern) {}\n-  //  virtual void visit(TuplePatternItems& tuple_items) {}\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) {}\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) {}\n-  virtual void visit (AST::TuplePattern &pattern) {}\n-  virtual void visit (AST::GroupedPattern &pattern) {}\n-  virtual void visit (AST::SlicePattern &pattern) {}\n-\n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt) {}\n-  virtual void visit (AST::LetStmt &stmt) {}\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt) {}\n-  virtual void visit (AST::ExprStmtWithBlock &stmt) {}\n-\n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound) {}\n-  virtual void visit (AST::ImplTraitType &type) {}\n-  virtual void visit (AST::TraitObjectType &type) {}\n-  virtual void visit (AST::ParenthesisedType &type) {}\n-  virtual void visit (AST::ImplTraitTypeOneBound &type) {}\n-  virtual void visit (AST::TraitObjectTypeOneBound &type) {}\n-  virtual void visit (AST::TupleType &type) {}\n-  virtual void visit (AST::NeverType &type) {}\n-  virtual void visit (AST::RawPointerType &type) {}\n-  virtual void visit (AST::ReferenceType &type) {}\n-  virtual void visit (AST::ArrayType &type) {}\n-  virtual void visit (AST::SliceType &type) {}\n-  virtual void visit (AST::InferredType &type) {}\n-  virtual void visit (AST::BareFunctionType &type) {}\n+  void visit (AST::Token &) {}\n+  void visit (AST::DelimTokenTree &) {}\n+  void visit (AST::AttrInputMetaItemContainer &) {}\n+  void visit (AST::IdentifierExpr &) {}\n+  void visit (AST::Lifetime &) {}\n+  void visit (AST::LifetimeParam &) {}\n+  void visit (AST::MacroInvocationSemi &) {}\n+  void visit (AST::PathInExpression &) {}\n+  void visit (AST::TypePathSegment &) {}\n+  void visit (AST::TypePathSegmentGeneric &) {}\n+  void visit (AST::TypePathSegmentFunction &) {}\n+  void visit (AST::TypePath &) {}\n+  void visit (AST::QualifiedPathInExpression &) {}\n+  void visit (AST::QualifiedPathInType &) {}\n+  void visit (AST::LiteralExpr &) {}\n+  void visit (AST::AttrInputLiteral &) {}\n+  void visit (AST::MetaItemLitExpr &) {}\n+  void visit (AST::MetaItemPathLit &) {}\n+  void visit (AST::BorrowExpr &) {}\n+  void visit (AST::DereferenceExpr &) {}\n+  void visit (AST::ErrorPropagationExpr &) {}\n+  void visit (AST::NegationExpr &) {}\n+  void visit (AST::ArithmeticOrLogicalExpr &) {}\n+  void visit (AST::ComparisonExpr &) {}\n+  void visit (AST::LazyBooleanExpr &) {}\n+  void visit (AST::TypeCastExpr &) {}\n+  void visit (AST::AssignmentExpr &) {}\n+  void visit (AST::CompoundAssignmentExpr &) {}\n+  void visit (AST::GroupedExpr &) {}\n+  void visit (AST::ArrayElemsValues &) {}\n+  void visit (AST::ArrayElemsCopied &) {}\n+  void visit (AST::ArrayExpr &) {}\n+  void visit (AST::ArrayIndexExpr &) {}\n+  void visit (AST::TupleExpr &) {}\n+  void visit (AST::TupleIndexExpr &) {}\n+  void visit (AST::StructExprStruct &) {}\n+  void visit (AST::StructExprFieldIdentifier &) {}\n+  void visit (AST::StructExprFieldIdentifierValue &) {}\n+  void visit (AST::StructExprFieldIndexValue &) {}\n+  void visit (AST::StructExprStructFields &) {}\n+  void visit (AST::StructExprStructBase &) {}\n+  void visit (AST::StructExprTuple &) {}\n+  void visit (AST::StructExprUnit &) {}\n+  void visit (AST::EnumExprFieldIdentifier &) {}\n+  void visit (AST::EnumExprFieldIdentifierValue &) {}\n+  void visit (AST::EnumExprFieldIndexValue &) {}\n+  void visit (AST::EnumExprStruct &) {}\n+  void visit (AST::EnumExprTuple &) {}\n+  void visit (AST::EnumExprFieldless &) {}\n+  void visit (AST::CallExpr &) {}\n+  void visit (AST::MethodCallExpr &) {}\n+  void visit (AST::FieldAccessExpr &) {}\n+  void visit (AST::ClosureExprInner &) {}\n+  void visit (AST::BlockExpr &) {}\n+  void visit (AST::ClosureExprInnerTyped &) {}\n+  void visit (AST::ContinueExpr &) {}\n+  void visit (AST::BreakExpr &) {}\n+  void visit (AST::RangeFromToExpr &) {}\n+  void visit (AST::RangeFromExpr &) {}\n+  void visit (AST::RangeToExpr &) {}\n+  void visit (AST::RangeFullExpr &) {}\n+  void visit (AST::RangeFromToInclExpr &) {}\n+  void visit (AST::RangeToInclExpr &) {}\n+  void visit (AST::ReturnExpr &) {}\n+  void visit (AST::UnsafeBlockExpr &) {}\n+  void visit (AST::LoopExpr &) {}\n+  void visit (AST::WhileLoopExpr &) {}\n+  void visit (AST::WhileLetLoopExpr &) {}\n+  void visit (AST::ForLoopExpr &) {}\n+  void visit (AST::IfExpr &) {}\n+  void visit (AST::IfExprConseqElse &) {}\n+  void visit (AST::IfExprConseqIf &) {}\n+  void visit (AST::IfExprConseqIfLet &) {}\n+  void visit (AST::IfLetExpr &) {}\n+  void visit (AST::IfLetExprConseqElse &) {}\n+  void visit (AST::IfLetExprConseqIf &) {}\n+  void visit (AST::IfLetExprConseqIfLet &) {}\n+\n+  void visit (AST::MatchExpr &) {}\n+  void visit (AST::AwaitExpr &) {}\n+  void visit (AST::AsyncBlockExpr &) {}\n+\n+  void visit (AST::TypeParam &) {}\n+\n+  void visit (AST::LifetimeWhereClauseItem &) {}\n+  void visit (AST::TypeBoundWhereClauseItem &) {}\n+  void visit (AST::Method &) {}\n+  void visit (AST::ModuleBodied &) {}\n+  void visit (AST::ModuleNoBody &) {}\n+  void visit (AST::ExternCrate &) {}\n+\n+  void visit (AST::UseTreeGlob &) {}\n+  void visit (AST::UseTreeList &) {}\n+  void visit (AST::UseTreeRebind &) {}\n+  void visit (AST::UseDeclaration &) {}\n+  void visit (AST::Function &) {}\n+  void visit (AST::TypeAlias &) {}\n+  void visit (AST::StructStruct &) {}\n+  void visit (AST::TupleStruct &) {}\n+  void visit (AST::EnumItem &) {}\n+  void visit (AST::EnumItemTuple &) {}\n+  void visit (AST::EnumItemStruct &) {}\n+  void visit (AST::EnumItemDiscriminant &) {}\n+  void visit (AST::Enum &) {}\n+  void visit (AST::Union &) {}\n+  void visit (AST::ConstantItem &) {}\n+  void visit (AST::StaticItem &) {}\n+  void visit (AST::TraitItemFunc &) {}\n+  void visit (AST::TraitItemMethod &) {}\n+  void visit (AST::TraitItemConst &) {}\n+  void visit (AST::TraitItemType &) {}\n+  void visit (AST::Trait &) {}\n+  void visit (AST::InherentImpl &) {}\n+  void visit (AST::TraitImpl &) {}\n+\n+  void visit (AST::ExternalStaticItem &) {}\n+  void visit (AST::ExternalFunctionItem &) {}\n+  void visit (AST::ExternBlock &) {}\n+\n+  void visit (AST::MacroMatchFragment &) {}\n+  void visit (AST::MacroMatchRepetition &) {}\n+  void visit (AST::MacroMatcher &) {}\n+  void visit (AST::MacroRulesDefinition &) {}\n+  void visit (AST::MacroInvocation &) {}\n+  void visit (AST::MetaItemPath &) {}\n+  void visit (AST::MetaItemSeq &) {}\n+  void visit (AST::MetaWord &) {}\n+  void visit (AST::MetaNameValueStr &) {}\n+  void visit (AST::MetaListPaths &) {}\n+  void visit (AST::MetaListNameValueStr &) {}\n+\n+  void visit (AST::LiteralPattern &) {}\n+  void visit (AST::IdentifierPattern &) {}\n+  void visit (AST::WildcardPattern &) {}\n+\n+  void visit (AST::RangePatternBoundLiteral &) {}\n+  void visit (AST::RangePatternBoundPath &) {}\n+  void visit (AST::RangePatternBoundQualPath &) {}\n+  void visit (AST::RangePattern &) {}\n+  void visit (AST::ReferencePattern &) {}\n+\n+  void visit (AST::StructPatternFieldTuplePat &) {}\n+  void visit (AST::StructPatternFieldIdentPat &) {}\n+  void visit (AST::StructPatternFieldIdent &) {}\n+  void visit (AST::StructPattern &) {}\n+\n+  void visit (AST::TupleStructItemsNoRange &) {}\n+  void visit (AST::TupleStructItemsRange &) {}\n+  void visit (AST::TupleStructPattern &) {}\n+\n+  void visit (AST::TuplePatternItemsMultiple &) {}\n+  void visit (AST::TuplePatternItemsRanged &) {}\n+  void visit (AST::TuplePattern &) {}\n+  void visit (AST::GroupedPattern &) {}\n+  void visit (AST::SlicePattern &) {}\n+\n+  void visit (AST::EmptyStmt &) {}\n+  void visit (AST::LetStmt &) {}\n+  void visit (AST::ExprStmtWithoutBlock &) {}\n+  void visit (AST::ExprStmtWithBlock &) {}\n+\n+  void visit (AST::TraitBound &) {}\n+  void visit (AST::ImplTraitType &) {}\n+  void visit (AST::TraitObjectType &) {}\n+  void visit (AST::ParenthesisedType &) {}\n+  void visit (AST::ImplTraitTypeOneBound &) {}\n+  void visit (AST::TraitObjectTypeOneBound &) {}\n+  void visit (AST::TupleType &) {}\n+  void visit (AST::NeverType &) {}\n+  void visit (AST::RawPointerType &) {}\n+  void visit (AST::ReferenceType &) {}\n+  void visit (AST::ArrayType &) {}\n+  void visit (AST::SliceType &) {}\n+  void visit (AST::InferredType &) {}\n+  void visit (AST::BareFunctionType &) {}\n \n protected:\n   ResolverBase (NodeId parent)"}, {"sha": "d563f934d9d672321105214bb40c0d1da1d6671a", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -91,6 +91,15 @@ class ResolveExpr : public ResolverBase\n     });\n   }\n \n+  void visit (AST::MethodCallExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      ResolveExpr::go (p, expr.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n   void visit (AST::AssignmentExpr &expr)\n   {\n     ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());"}, {"sha": "9cbef53fd15fed2bbac85dcbb48e62fae3a0d3b4", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -39,8 +39,12 @@ class ResolveToplevelImplItem : public ResolverBase\n   {\n     std::string identifier\n       = base->as_string () + \"::\" + constant.get_identifier ();\n-    resolver->get_name_scope ().insert (identifier, constant.get_node_id (),\n-\t\t\t\t\tconstant.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      identifier, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (constant.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n@@ -50,8 +54,12 @@ class ResolveToplevelImplItem : public ResolverBase\n   {\n     std::string identifier\n       = base->as_string () + \"::\" + function.get_function_name ();\n-    resolver->get_name_scope ().insert (identifier, function.get_node_id (),\n-\t\t\t\t\tfunction.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      identifier, function.get_node_id (), function.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (function.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n     resolver->insert_new_definition (function.get_node_id (),\n \t\t\t\t     Definition{function.get_node_id (),\n \t\t\t\t\t\tfunction.get_node_id ()});\n@@ -61,8 +69,12 @@ class ResolveToplevelImplItem : public ResolverBase\n   {\n     std::string identifier\n       = base->as_string () + \"::\" + method.get_method_name ();\n-    resolver->get_name_scope ().insert (identifier, method.get_node_id (),\n-\t\t\t\t\tmethod.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      identifier, method.get_node_id (), method.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (method.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n     resolver->insert_new_definition (method.get_node_id (),\n \t\t\t\t     Definition{method.get_node_id (),\n \t\t\t\t\t\tmethod.get_node_id ()});"}, {"sha": "8b6227e73ca5616500183bef8769c6e58d8bc44e", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -24,7 +24,6 @@\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n #include \"rust-ast-resolve-stmt.h\"\n-#include \"rust-ast-resolve-unused.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -110,17 +109,76 @@ class ResolveItem : public ResolverBase\n     ResolveExpr::go (function.get_definition ().get (),\n \t\t     function.get_node_id ());\n \n-    ScanUnused::Scan (resolver->get_name_scope ().peek ());\n-    ScanUnused::Scan (resolver->get_type_scope ().peek ());\n-\n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::InherentImpl &impl_block)\n   {\n+    NodeId resolved_node = ResolveType::go (impl_block.get_type ().get (),\n+\t\t\t\t\t    impl_block.get_node_id ());\n+    if (resolved_node == UNKNOWN_NODEID)\n+      return;\n+\n+    resolver->get_type_scope ().insert (\n+      \"Self\", resolved_node, impl_block.get_type ()->get_locus_slow ());\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n       impl_item->accept_vis (*this);\n+\n+    resolver->get_type_scope ().peek ()->clear_name (\"Self\", resolved_node);\n+  }\n+\n+  void visit (AST::Method &method)\n+  {\n+    if (method.has_return_type ())\n+      ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n+\n+    NodeId scope_node_id = method.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+    // self turns into self: Self as a function param\n+    AST::SelfParam &self_param = method.get_self_param ();\n+    AST::IdentifierPattern self_pattern (\n+      self_param.get_node_id (), \"self\", self_param.get_locus (),\n+      self_param.get_has_ref (), self_param.get_is_mut (),\n+      std::unique_ptr<AST::Pattern> (nullptr));\n+\n+    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+    AST::TypePath self_type_path (std::move (segments),\n+\t\t\t\t  self_param.get_locus ());\n+\n+    ResolveType::go (&self_type_path, self_param.get_node_id ());\n+    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t       self_pattern.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : method.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // resolve the function body\n+    ResolveExpr::go (method.get_definition ().get (), method.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n   }\n \n private:"}, {"sha": "2e4e8e77ba1c2642fefcadb801147dbda6188f0e", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -38,22 +38,34 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl)\n   {\n-    resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n-\t\t\t\t\tstruct_decl.get_node_id (),\n-\t\t\t\t\tstruct_decl.get_locus ());\n+    resolver->get_type_scope ().insert (\n+      struct_decl.get_identifier (), struct_decl.get_node_id (),\n+      struct_decl.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (struct_decl.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n   }\n \n   void visit (AST::StructStruct &struct_decl)\n   {\n-    resolver->get_type_scope ().insert (struct_decl.get_identifier (),\n-\t\t\t\t\tstruct_decl.get_node_id (),\n-\t\t\t\t\tstruct_decl.get_locus ());\n+    resolver->get_type_scope ().insert (\n+      struct_decl.get_identifier (), struct_decl.get_node_id (),\n+      struct_decl.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (struct_decl.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n   }\n \n   void visit (AST::StaticItem &var)\n   {\n-    resolver->get_name_scope ().insert (var.get_identifier (),\n-\t\t\t\t\tvar.get_node_id (), var.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      var.get_identifier (), var.get_node_id (), var.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (var.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n     resolver->insert_new_definition (var.get_node_id (),\n \t\t\t\t     Definition{var.get_node_id (),\n \t\t\t\t\t\tvar.get_node_id ()});\n@@ -62,19 +74,27 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::ConstantItem &constant)\n   {\n-    resolver->get_name_scope ().insert (constant.get_identifier (),\n-\t\t\t\t\tconstant.get_node_id (),\n-\t\t\t\t\tconstant.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      constant.get_identifier (), constant.get_node_id (),\n+      constant.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (constant.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n   }\n \n   void visit (AST::Function &function)\n   {\n-    resolver->get_name_scope ().insert (function.get_function_name (),\n-\t\t\t\t\tfunction.get_node_id (),\n-\t\t\t\t\tfunction.get_locus ());\n+    resolver->get_name_scope ().insert (\n+      function.get_function_name (), function.get_node_id (),\n+      function.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (function.get_locus (), \"redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n     resolver->insert_new_definition (function.get_node_id (),\n \t\t\t\t     Definition{function.get_node_id (),\n \t\t\t\t\t\tfunction.get_node_id ()});\n@@ -90,10 +110,6 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::InherentImpl &impl_block)\n   {\n-    if (!ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t  impl_block.get_node_id ()))\n-      return;\n-\n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (),\n \t\t\t\t   impl_block.get_type ().get ());"}, {"sha": "ec8ee87c21e8d7a259b0a44b0b557864f44db0e1", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -28,14 +28,14 @@ namespace Resolver {\n class ResolveType : public ResolverBase\n {\n public:\n-  static bool go (AST::Type *type, NodeId parent)\n+  static NodeId go (AST::Type *type, NodeId parent)\n   {\n     ResolveType resolver (parent);\n     type->accept_vis (resolver);\n     if (!resolver.ok)\n       rust_error_at (type->get_locus_slow (), \"unresolved type\");\n \n-    return resolver.ok;\n+    return resolver.resolved_node;\n   };\n \n   void visit (AST::BareFunctionType &fntype)"}, {"sha": "928cf1114a9a97378d55edfa4632547d2c08d8ca", "filename": "gcc/rust/resolve/rust-ast-resolve-unused.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-unused.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -24,10 +24,10 @@\n namespace Rust {\n namespace Resolver {\n \n-class ScanUnused : public ResolverBase\n+class ScanUnused\n {\n public:\n-  static void Scan (Rib *r)\n+  static void ScanRib (Rib *r)\n   {\n     r->iterate_decls ([&] (NodeId decl_node_id, Location locus) -> bool {\n       if (!r->have_references_for_node (decl_node_id))\n@@ -37,6 +37,13 @@ class ScanUnused : public ResolverBase\n       return true;\n     });\n   }\n+\n+  static void Scan ()\n+  {\n+    auto resolver = Resolver::get ();\n+    resolver->iterate_name_ribs ([&] (Rib *r) -> void { ScanRib (r); });\n+    resolver->iterate_type_ribs ([&] (Rib *r) -> void { ScanRib (r); });\n+  }\n };\n \n } // namespace Resolver"}, {"sha": "d514132ee3905b5ef862c46c731f358adaad3850", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -22,7 +22,6 @@\n #include \"rust-ast-resolve-toplevel.h\"\n #include \"rust-ast-resolve-item.h\"\n #include \"rust-ast-resolve-expr.h\"\n-#include \"rust-ast-resolve-unused.h\"\n \n #define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n   do                                                                           \\\n@@ -110,7 +109,8 @@ Resolver::insert_builtin_types (Rib *r)\n   auto builtins = get_builtin_types ();\n   for (auto &builtin : builtins)\n     r->insert_name (builtin->as_string (), builtin->get_node_id (),\n-\t\t    Linemap::predeclared_location ());\n+\t\t    Linemap::predeclared_location (), false,\n+\t\t    [] (std::string, NodeId, Location) -> void {});\n }\n \n std::vector<AST::Type *> &\n@@ -283,9 +283,6 @@ NameResolution::go (AST::Crate &crate)\n   // next we can drill down into the items and their scopes\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveItem::go (it->get ());\n-\n-  ScanUnused::Scan (resolver->get_name_scope ().peek ());\n-  ScanUnused::Scan (resolver->get_type_scope ().peek ());\n }\n \n // rust-ast-resolve-expr.h\n@@ -307,9 +304,6 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   if (expr.has_tail_expr ())\n     ResolveExpr::go (expr.get_tail_expr ().get (), expr.get_node_id ());\n \n-  ScanUnused::Scan (resolver->get_name_scope ().peek ());\n-  ScanUnused::Scan (resolver->get_type_scope ().peek ());\n-\n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n }"}, {"sha": "ea0e4f51e602c4f4b01f845b6a77359951b09a25", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -37,8 +37,25 @@ class Rib\n \n   ~Rib () {}\n \n-  void insert_name (std::string ident, NodeId id, Location locus)\n+  void insert_name (std::string ident, NodeId id, Location locus, bool shadow,\n+\t\t    std::function<void (std::string, NodeId, Location)> dup_cb)\n   {\n+    auto it = mappings.find (ident);\n+    bool already_exists = it != mappings.end ();\n+    if (already_exists && !shadow)\n+      {\n+\tfor (auto &decl : decls_within_rib)\n+\t  {\n+\t    if (decl.first == it->second)\n+\t      {\n+\t\tdup_cb (ident, it->second, decl.second);\n+\t\treturn;\n+\t      }\n+\t  }\n+\tdup_cb (ident, it->second, locus);\n+\treturn;\n+      }\n+\n     mappings[ident] = id;\n     decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n@@ -54,6 +71,19 @@ class Rib\n     return true;\n   }\n \n+  void clear_name (std::string ident, NodeId id)\n+  {\n+    mappings.erase (ident);\n+    for (auto &it : decls_within_rib)\n+      {\n+\tif (it.first == id)\n+\t  {\n+\t    decls_within_rib.erase (it);\n+\t    break;\n+\t  }\n+      }\n+  }\n+\n   CrateNum get_crate_num () const { return crate_num; }\n   NodeId get_node_id () const { return node_id; }\n \n@@ -117,9 +147,16 @@ class Scope\n   Scope (CrateNum crate_num) : crate_num (crate_num) {}\n   ~Scope () {}\n \n+  void insert (std::string ident, NodeId id, Location locus, bool shadow,\n+\t       std::function<void (std::string, NodeId, Location)> dup_cb)\n+  {\n+    peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n+  }\n+\n   void insert (std::string ident, NodeId id, Location locus)\n   {\n-    peek ()->insert_name (ident, id, locus);\n+    peek ()->insert_name (ident, id, locus, true,\n+\t\t\t  [] (std::string, NodeId, Location) -> void {});\n   }\n \n   bool lookup (std::string ident, NodeId *id)\n@@ -266,6 +303,23 @@ class Resolver\n     return it->second.size ();\n   }\n \n+  void iterate_name_ribs (std::function<void (Rib *)> cb)\n+  {\n+    for (auto it = name_ribs.begin (); it != name_ribs.end (); it++)\n+      cb (it->second);\n+  }\n+\n+  void iterate_type_ribs (std::function<void (Rib *)> cb)\n+  {\n+    for (auto it = type_ribs.begin (); it != type_ribs.end (); it++)\n+      {\n+\tif (it->first == global_type_node_id)\n+\t  continue;\n+\n+\tcb (it->second);\n+      }\n+  }\n+\n private:\n   Resolver ();\n "}, {"sha": "1d31135905d6954c4813d30940efd123c5faa772", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -35,6 +35,7 @@\n #include \"rust-ast-lower.h\"\n #include \"rust-hir-type-check.h\"\n #include \"rust-tycheck-dump.h\"\n+#include \"rust-ast-resolve-unused.h\"\n #include \"rust-compile.h\"\n \n extern Linemap *\n@@ -527,9 +528,7 @@ Session::parse_file (const char *filename)\n     }\n \n   // resolution pipeline stage\n-  resolution (parsed_crate);\n-  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED RESOLUTION \\n\\033[0m\");\n-\n+  Resolver::NameResolution::Resolve (parsed_crate);\n   if (options.dump_option == CompileOptions::RESOLUTION_DUMP)\n     {\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n@@ -539,7 +538,7 @@ Session::parse_file (const char *filename)\n     return;\n \n   // lower AST to HIR\n-  HIR::Crate hir = lower_ast (parsed_crate);\n+  HIR::Crate hir = HIR::ASTLowering::Resolve (parsed_crate);\n   if (options.dump_option == CompileOptions::HIR_DUMP)\n     {\n       fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n@@ -550,11 +549,17 @@ Session::parse_file (const char *filename)\n     return;\n \n   // type resolve\n-  type_resolution (hir);\n+  Resolver::TypeResolution::Resolve (hir);\n+  if (options.dump_option == CompileOptions::TYPE_RESOLUTION_DUMP)\n+    {\n+      auto buf = Resolver::TypeResolverDump::go (hir);\n+      fprintf (stderr, \"%s\\n\", buf.c_str ());\n+      return;\n+    }\n \n-  // FIXME this needs an option of itself\n-  // auto buf = Resolver::TypeResolverDump::go (hir);\n-  // fprintf (stderr, \"%s\\n\", buf.c_str ());\n+  // scan unused has to be done after type resolution since methods are resolved\n+  // at that point\n+  Resolver::ScanUnused::Scan ();\n \n   if (saw_errors ())\n     return;\n@@ -791,31 +796,6 @@ Session::expansion (AST::Crate &crate)\n   fprintf (stderr, \"finished expansion\\n\");\n }\n \n-void\n-Session::resolution (AST::Crate &crate)\n-{\n-  fprintf (stderr, \"started name resolution\\n\");\n-  Resolver::NameResolution::Resolve (crate);\n-  fprintf (stderr, \"finished name resolution\\n\");\n-}\n-\n-HIR::Crate\n-Session::lower_ast (AST::Crate &crate)\n-{\n-  fprintf (stderr, \"started lowering AST\\n\");\n-  auto hir = HIR::ASTLowering::Resolve (crate);\n-  fprintf (stderr, \"finished lowering AST\\n\");\n-  return hir;\n-}\n-\n-void\n-Session::type_resolution (HIR::Crate &crate)\n-{\n-  fprintf (stderr, \"started type resolution\\n\");\n-  Resolver::TypeResolution::Resolve (crate);\n-  fprintf (stderr, \"finished type resolution\\n\");\n-}\n-\n void\n TargetOptions::dump_target_options () const\n {"}, {"sha": "07d54615ce4871affc5e02a690e613beab11795b", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -177,7 +177,8 @@ struct CompileOptions\n     RESOLUTION_DUMP,\n     TARGET_OPTION_DUMP,\n     HIR_DUMP,\n-    // TODO: add more?\n+    TYPE_RESOLUTION_DUMP,\n+\n   } dump_option;\n \n   /* configuration options - actually useful for conditional compilation and\n@@ -204,8 +205,6 @@ struct Session\n   // backend linemap\n   Linemap *linemap;\n \n-  // TODO: replace raw pointers with smart pointers?\n-\n public:\n   /* Initialise compiler session. Corresponds to langhook grs_langhook_init().\n    * Note that this is called after option handling. */\n@@ -217,7 +216,6 @@ struct Session\n   void init_options ();\n \n private:\n-  // TODO: should this be private or public?\n   void parse_file (const char *filename);\n   bool enable_dump (std::string arg);\n \n@@ -232,23 +230,16 @@ struct Session\n    * (top-level inner attribute creation from command line arguments), setting\n    * options maybe, registering lints maybe, loading plugins maybe. */\n   void register_plugins (AST::Crate &crate);\n+\n   /* Injection pipeline stage. TODO maybe move to another object? Maybe have\n    * some lint checks (in future, obviously), register builtin macros, crate\n    * injection. */\n   void injection (AST::Crate &crate);\n+\n   /* Expansion pipeline stage. TODO maybe move to another object? Expands all\n    * macros, maybe build test harness in future, AST validation, maybe create\n    * macro crate (if not rustdoc).*/\n   void expansion (AST::Crate &crate);\n-  /* Resolution pipeline stage. TODO maybe move to another object.\n-   * Performs name resolution and type resolution, maybe complete gated\n-   * feature checking, maybe create buffered lints in future. */\n-  void resolution (AST::Crate &crate);\n-  /* This lowers the AST down to HIR and assigns all mappings from AST\n-   * NodeIds back to HirIds */\n-  HIR::Crate lower_ast (AST::Crate &crate);\n-  /* This adds the type resolution process */\n-  void type_resolution (HIR::Crate &crate);\n };\n } // namespace Rust\n "}, {"sha": "9a6c76fc85e81184071c85cdb36d86d28f66d4d5", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_METHOD_RESOLVE_H\n+#define RUST_HIR_METHOD_RESOLVE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class MethodResolution : public TypeCheckBase\n+{\n+public:\n+  static std::vector<HIR::Method *> Probe (TyTy::TyBase *receiver,\n+\t\t\t\t\t   HIR::PathExprSegment method_name)\n+  {\n+    MethodResolution probe (receiver, method_name);\n+\n+    // lookup impl items for this crate and find all methods that can resolve to\n+    // this receiver\n+    probe.mappings->iterate_impl_items (\n+      [&] (HirId id, HIR::InherentImplItem *item) mutable -> bool {\n+\titem->accept_vis (probe);\n+\treturn true;\n+      });\n+\n+    return probe.probed;\n+  }\n+\n+  void visit (HIR::Method &method)\n+  {\n+    TyTy::TyBase *self_lookup = nullptr;\n+    if (!context->lookup_type (\n+\t  method.get_self_param ().get_mappings ().get_hirid (), &self_lookup))\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to lookup lookup self type in MethodProbe\");\n+\treturn;\n+      }\n+\n+    // are the names the same\n+    HIR::PathIdentSegment seg = method_name.get_segment ();\n+    if (seg.as_string ().compare (method.get_method_name ()) != 0)\n+      {\n+\t// if the method name does not match then this is not a valid match\n+\treturn;\n+      }\n+\n+    // FIXME this can be simplified with\n+    // https://github.com/Rust-GCC/gccrs/issues/187\n+    auto combined = receiver->combine (self_lookup);\n+    if (combined == nullptr)\n+      {\n+\t// incompatible self argument then this is not a valid method for this\n+\t// receiver\n+\treturn;\n+      }\n+    delete combined;\n+\n+    probed.push_back (&method);\n+  }\n+\n+private:\n+  MethodResolution (TyTy::TyBase *receiver, HIR::PathExprSegment method_name)\n+    : TypeCheckBase (), receiver (receiver), method_name (method_name)\n+  {}\n+\n+  TyTy::TyBase *receiver;\n+  HIR::PathExprSegment method_name;\n+\n+  std::vector<HIR::Method *> probed;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_METHOD_RESOLVE_H"}, {"sha": "6906878ada7bbef393d5cbe68cfda7a6995f5531", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 180, "deletions": 203, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -34,209 +34,186 @@ class TypeCheckBase : public HIR::HIRVisitor\n public:\n   virtual ~TypeCheckBase () {}\n \n-  // visitor impl\n-  // rust-ast.h\n-  //  virtual void visit(AttrInput& attr_input);\n-  //  virtual void visit(TokenTree& token_tree);\n-  //  virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (HIR::Token &tok) {}\n-  virtual void visit (HIR::DelimTokenTree &delim_tok_tree) {}\n-  virtual void visit (HIR::AttrInputMetaItemContainer &input) {}\n-  //  virtual void visit(MetaItem& meta_item) {}\n-  //  void vsit(Stmt& stmt) {}\n-  //  virtual void visit(Expr& expr) {}\n-  virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n-  //  virtual void visit(Pattern& pattern) {}\n-  //  virtual void visit(Type& type) {}\n-  //  virtual void visit(TypeParamBound& type_param_bound) {}\n-  virtual void visit (HIR::Lifetime &lifetime) {}\n-  //  virtual void visit(GenericParam& generic_param) {}\n-  virtual void visit (HIR::LifetimeParam &lifetime_param) {}\n-  //  virtual void visit(TraitItem& trait_item) {}\n-  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n-  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n-\n-  // rust-path.h\n-  virtual void visit (HIR::PathInExpression &path) {}\n-  virtual void visit (HIR::TypePathSegment &segment) {}\n-  virtual void visit (HIR::TypePathSegmentGeneric &segment) {}\n-  virtual void visit (HIR::TypePathSegmentFunction &segment) {}\n-  virtual void visit (HIR::TypePath &path) {}\n-  virtual void visit (HIR::QualifiedPathInExpression &path) {}\n-  virtual void visit (HIR::QualifiedPathInType &path) {}\n-\n-  // rust-expr.h\n-  virtual void visit (HIR::LiteralExpr &expr) {}\n-  virtual void visit (HIR::AttrInputLiteral &attr_input) {}\n-  virtual void visit (HIR::MetaItemLitExpr &meta_item) {}\n-  virtual void visit (HIR::MetaItemPathLit &meta_item) {}\n-  virtual void visit (HIR::BorrowExpr &expr) {}\n-  virtual void visit (HIR::DereferenceExpr &expr) {}\n-  virtual void visit (HIR::ErrorPropagationExpr &expr) {}\n-  virtual void visit (HIR::NegationExpr &expr) {}\n-  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr) {}\n-  virtual void visit (HIR::ComparisonExpr &expr) {}\n-  virtual void visit (HIR::LazyBooleanExpr &expr) {}\n-  virtual void visit (HIR::TypeCastExpr &expr) {}\n-  virtual void visit (HIR::AssignmentExpr &expr) {}\n-  virtual void visit (HIR::CompoundAssignmentExpr &expr) {}\n-  virtual void visit (HIR::GroupedExpr &expr) {}\n-  //  virtual void visit(ArrayElems& elems) {}\n-  virtual void visit (HIR::ArrayElemsValues &elems) {}\n-  virtual void visit (HIR::ArrayElemsCopied &elems) {}\n-  virtual void visit (HIR::ArrayExpr &expr) {}\n-  virtual void visit (HIR::ArrayIndexExpr &expr) {}\n-  virtual void visit (HIR::TupleExpr &expr) {}\n-  virtual void visit (HIR::TupleIndexExpr &expr) {}\n-  virtual void visit (HIR::StructExprStruct &expr) {}\n-  //  virtual void visit(StructExprField& field) {}\n-  virtual void visit (HIR::StructExprFieldIdentifier &field) {}\n-  virtual void visit (HIR::StructExprFieldIdentifierValue &field) {}\n-  virtual void visit (HIR::StructExprFieldIndexValue &field) {}\n-  virtual void visit (HIR::StructExprStructFields &expr) {}\n-  virtual void visit (HIR::StructExprStructBase &expr) {}\n-  virtual void visit (HIR::StructExprTuple &expr) {}\n-  virtual void visit (HIR::StructExprUnit &expr) {}\n-  //  virtual void visit(EnumExprField& field) {}\n-  virtual void visit (HIR::EnumExprFieldIdentifier &field) {}\n-  virtual void visit (HIR::EnumExprFieldIdentifierValue &field) {}\n-  virtual void visit (HIR::EnumExprFieldIndexValue &field) {}\n-  virtual void visit (HIR::EnumExprStruct &expr) {}\n-  virtual void visit (HIR::EnumExprTuple &expr) {}\n-  virtual void visit (HIR::EnumExprFieldless &expr) {}\n-  virtual void visit (HIR::CallExpr &expr) {}\n-  virtual void visit (HIR::MethodCallExpr &expr) {}\n-  virtual void visit (HIR::FieldAccessExpr &expr) {}\n-  virtual void visit (HIR::ClosureExprInner &expr) {}\n-  virtual void visit (HIR::BlockExpr &expr) {}\n-  virtual void visit (HIR::ClosureExprInnerTyped &expr) {}\n-  virtual void visit (HIR::ContinueExpr &expr) {}\n-  virtual void visit (HIR::BreakExpr &expr) {}\n-  virtual void visit (HIR::RangeFromToExpr &expr) {}\n-  virtual void visit (HIR::RangeFromExpr &expr) {}\n-  virtual void visit (HIR::RangeToExpr &expr) {}\n-  virtual void visit (HIR::RangeFullExpr &expr) {}\n-  virtual void visit (HIR::RangeFromToInclExpr &expr) {}\n-  virtual void visit (HIR::RangeToInclExpr &expr) {}\n-  virtual void visit (HIR::ReturnExpr &expr) {}\n-  virtual void visit (HIR::UnsafeBlockExpr &expr) {}\n-  virtual void visit (HIR::LoopExpr &expr) {}\n-  virtual void visit (HIR::WhileLoopExpr &expr) {}\n-  virtual void visit (HIR::WhileLetLoopExpr &expr) {}\n-  virtual void visit (HIR::ForLoopExpr &expr) {}\n-  virtual void visit (HIR::IfExpr &expr) {}\n-  virtual void visit (HIR::IfExprConseqElse &expr) {}\n-  virtual void visit (HIR::IfExprConseqIf &expr) {}\n-  virtual void visit (HIR::IfExprConseqIfLet &expr) {}\n-  virtual void visit (HIR::IfLetExpr &expr) {}\n-  virtual void visit (HIR::IfLetExprConseqElse &expr) {}\n-  virtual void visit (HIR::IfLetExprConseqIf &expr) {}\n-  virtual void visit (HIR::IfLetExprConseqIfLet &expr) {}\n-  //  virtual void visit(MatchCase& match_case) {}\n-  // virtual void visit (HIR::MatchCaseBlockExpr &match_case) {}\n-  // virtual void visit (HIR::MatchCaseExpr &match_case) {}\n-  virtual void visit (HIR::MatchExpr &expr) {}\n-  virtual void visit (HIR::AwaitExpr &expr) {}\n-  virtual void visit (HIR::AsyncBlockExpr &expr) {}\n-\n-  // rust-item.h\n-  virtual void visit (HIR::TypeParam &param) {}\n-  //  virtual void visit(WhereClauseItem& item) {}\n-  virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n-  virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n-  virtual void visit (HIR::Method &method) {}\n-  virtual void visit (HIR::ModuleBodied &module) {}\n-  virtual void visit (HIR::ModuleNoBody &module) {}\n-  virtual void visit (HIR::ExternCrate &crate) {}\n-  //  virtual void visit(UseTree& use_tree) {}\n-  virtual void visit (HIR::UseTreeGlob &use_tree) {}\n-  virtual void visit (HIR::UseTreeList &use_tree) {}\n-  virtual void visit (HIR::UseTreeRebind &use_tree) {}\n-  virtual void visit (HIR::UseDeclaration &use_decl) {}\n-  virtual void visit (HIR::Function &function) {}\n-  virtual void visit (HIR::TypeAlias &type_alias) {}\n-  virtual void visit (HIR::StructStruct &struct_item) {}\n-  virtual void visit (HIR::TupleStruct &tuple_struct) {}\n-  virtual void visit (HIR::EnumItem &item) {}\n-  virtual void visit (HIR::EnumItemTuple &item) {}\n-  virtual void visit (HIR::EnumItemStruct &item) {}\n-  virtual void visit (HIR::EnumItemDiscriminant &item) {}\n-  virtual void visit (HIR::Enum &enum_item) {}\n-  virtual void visit (HIR::Union &union_item) {}\n-  virtual void visit (HIR::ConstantItem &const_item) {}\n-  virtual void visit (HIR::StaticItem &static_item) {}\n-  virtual void visit (HIR::TraitItemFunc &item) {}\n-  virtual void visit (HIR::TraitItemMethod &item) {}\n-  virtual void visit (HIR::TraitItemConst &item) {}\n-  virtual void visit (HIR::TraitItemType &item) {}\n-  virtual void visit (HIR::Trait &trait) {}\n-  virtual void visit (HIR::InherentImpl &impl) {}\n-  virtual void visit (HIR::TraitImpl &impl) {}\n-  //  virtual void visit(ExternalItem& item) {}\n-  virtual void visit (HIR::ExternalStaticItem &item) {}\n-  virtual void visit (HIR::ExternalFunctionItem &item) {}\n-  virtual void visit (HIR::ExternBlock &block) {}\n-\n-  // rust-macro.h\n-  virtual void visit (HIR::MacroMatchFragment &match) {}\n-  virtual void visit (HIR::MacroMatchRepetition &match) {}\n-  virtual void visit (HIR::MacroMatcher &matcher) {}\n-  virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n-  virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n-  virtual void visit (HIR::MetaItemPath &meta_item) {}\n-  virtual void visit (HIR::MetaItemSeq &meta_item) {}\n-  virtual void visit (HIR::MetaWord &meta_item) {}\n-  virtual void visit (HIR::MetaNameValueStr &meta_item) {}\n-  virtual void visit (HIR::MetaListPaths &meta_item) {}\n-  virtual void visit (HIR::MetaListNameValueStr &meta_item) {}\n-\n-  // rust-pattern.h\n-  virtual void visit (HIR::LiteralPattern &pattern) {}\n-  virtual void visit (HIR::IdentifierPattern &pattern) {}\n-  virtual void visit (HIR::WildcardPattern &pattern) {}\n-  //  virtual void visit(RangePatternBound& bound) {}\n-  virtual void visit (HIR::RangePatternBoundLiteral &bound) {}\n-  virtual void visit (HIR::RangePatternBoundPath &bound) {}\n-  virtual void visit (HIR::RangePatternBoundQualPath &bound) {}\n-  virtual void visit (HIR::RangePattern &pattern) {}\n-  virtual void visit (HIR::ReferencePattern &pattern) {}\n-  //  virtual void visit(StructPatternField& field) {}\n-  virtual void visit (HIR::StructPatternFieldTuplePat &field) {}\n-  virtual void visit (HIR::StructPatternFieldIdentPat &field) {}\n-  virtual void visit (HIR::StructPatternFieldIdent &field) {}\n-  virtual void visit (HIR::StructPattern &pattern) {}\n-  //  virtual void visit(TupleStructItems& tuple_items) {}\n-  virtual void visit (HIR::TupleStructItemsNoRange &tuple_items) {}\n-  virtual void visit (HIR::TupleStructItemsRange &tuple_items) {}\n-  virtual void visit (HIR::TupleStructPattern &pattern) {}\n-  //  virtual void visit(TuplePatternItems& tuple_items) {}\n-  virtual void visit (HIR::TuplePatternItemsMultiple &tuple_items) {}\n-  virtual void visit (HIR::TuplePatternItemsRanged &tuple_items) {}\n-  virtual void visit (HIR::TuplePattern &pattern) {}\n-  virtual void visit (HIR::GroupedPattern &pattern) {}\n-  virtual void visit (HIR::SlicePattern &pattern) {}\n-\n-  // rust-stmt.h\n-  virtual void visit (HIR::EmptyStmt &stmt) {}\n-  virtual void visit (HIR::LetStmt &stmt) {}\n-  virtual void visit (HIR::ExprStmtWithoutBlock &stmt) {}\n-  virtual void visit (HIR::ExprStmtWithBlock &stmt) {}\n-\n-  // rust-type.h\n-  virtual void visit (HIR::TraitBound &bound) {}\n-  virtual void visit (HIR::ImplTraitType &type) {}\n-  virtual void visit (HIR::TraitObjectType &type) {}\n-  virtual void visit (HIR::ParenthesisedType &type) {}\n-  virtual void visit (HIR::ImplTraitTypeOneBound &type) {}\n-  virtual void visit (HIR::TraitObjectTypeOneBound &type) {}\n-  virtual void visit (HIR::TupleType &type) {}\n-  virtual void visit (HIR::NeverType &type) {}\n-  virtual void visit (HIR::RawPointerType &type) {}\n-  virtual void visit (HIR::ReferenceType &type) {}\n-  virtual void visit (HIR::ArrayType &type) {}\n-  virtual void visit (HIR::SliceType &type) {}\n-  virtual void visit (HIR::InferredType &type) {}\n-  virtual void visit (HIR::BareFunctionType &type) {}\n+  virtual void visit (HIR::Token &) override {}\n+  virtual void visit (HIR::DelimTokenTree &) override {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &) override {}\n+  virtual void visit (HIR::IdentifierExpr &) override {}\n+  virtual void visit (HIR::Lifetime &) override {}\n+  virtual void visit (HIR::LifetimeParam &) override {}\n+  virtual void visit (HIR::PathInExpression &) override {}\n+  virtual void visit (HIR::TypePathSegment &) override {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &) override {}\n+  virtual void visit (HIR::TypePathSegmentFunction &) override {}\n+  virtual void visit (HIR::TypePath &) override {}\n+  virtual void visit (HIR::QualifiedPathInExpression &) override {}\n+  virtual void visit (HIR::QualifiedPathInType &) override {}\n+\n+  virtual void visit (HIR::LiteralExpr &) override {}\n+  virtual void visit (HIR::AttrInputLiteral &) override {}\n+  virtual void visit (HIR::MetaItemLitExpr &) override {}\n+  virtual void visit (HIR::MetaItemPathLit &) override {}\n+  virtual void visit (HIR::BorrowExpr &) override {}\n+  virtual void visit (HIR::DereferenceExpr &) override {}\n+  virtual void visit (HIR::ErrorPropagationExpr &) override {}\n+  virtual void visit (HIR::NegationExpr &) override {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  virtual void visit (HIR::ComparisonExpr &) override {}\n+  virtual void visit (HIR::LazyBooleanExpr &) override {}\n+  virtual void visit (HIR::TypeCastExpr &) override {}\n+  virtual void visit (HIR::AssignmentExpr &) override {}\n+\n+  virtual void visit (HIR::GroupedExpr &) override {}\n+\n+  virtual void visit (HIR::ArrayElemsValues &) override {}\n+  virtual void visit (HIR::ArrayElemsCopied &) override {}\n+  virtual void visit (HIR::ArrayExpr &) override {}\n+  virtual void visit (HIR::ArrayIndexExpr &) override {}\n+  virtual void visit (HIR::TupleExpr &) override {}\n+  virtual void visit (HIR::TupleIndexExpr &) override {}\n+  virtual void visit (HIR::StructExprStruct &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::StructExprStructFields &) override {}\n+  virtual void visit (HIR::StructExprStructBase &) override {}\n+  virtual void visit (HIR::StructExprTuple &) override {}\n+  virtual void visit (HIR::StructExprUnit &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::EnumExprStruct &) override {}\n+  virtual void visit (HIR::EnumExprTuple &) override {}\n+  virtual void visit (HIR::EnumExprFieldless &) override {}\n+  virtual void visit (HIR::CallExpr &) override {}\n+  virtual void visit (HIR::MethodCallExpr &) override {}\n+  virtual void visit (HIR::FieldAccessExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInner &) override {}\n+  virtual void visit (HIR::BlockExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &) override {}\n+  virtual void visit (HIR::ContinueExpr &) override {}\n+  virtual void visit (HIR::BreakExpr &) override {}\n+  virtual void visit (HIR::RangeFromToExpr &) override {}\n+  virtual void visit (HIR::RangeFromExpr &) override {}\n+  virtual void visit (HIR::RangeToExpr &) override {}\n+  virtual void visit (HIR::RangeFullExpr &) override {}\n+  virtual void visit (HIR::RangeFromToInclExpr &) override {}\n+  virtual void visit (HIR::RangeToInclExpr &) override {}\n+  virtual void visit (HIR::ReturnExpr &) override {}\n+  virtual void visit (HIR::UnsafeBlockExpr &) override {}\n+  virtual void visit (HIR::LoopExpr &) override {}\n+  virtual void visit (HIR::WhileLoopExpr &) override {}\n+  virtual void visit (HIR::WhileLetLoopExpr &) override {}\n+  virtual void visit (HIR::ForLoopExpr &) override {}\n+  virtual void visit (HIR::IfExpr &) override {}\n+  virtual void visit (HIR::IfExprConseqElse &) override {}\n+  virtual void visit (HIR::IfExprConseqIf &) override {}\n+  virtual void visit (HIR::IfExprConseqIfLet &) override {}\n+  virtual void visit (HIR::IfLetExpr &) override {}\n+  virtual void visit (HIR::IfLetExprConseqElse &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIf &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &) override {}\n+\n+  virtual void visit (HIR::MatchExpr &) override {}\n+  virtual void visit (HIR::AwaitExpr &) override {}\n+  virtual void visit (HIR::AsyncBlockExpr &) override {}\n+\n+  virtual void visit (HIR::TypeParam &) override {}\n+\n+  virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n+  virtual void visit (HIR::Method &) override {}\n+  virtual void visit (HIR::ModuleBodied &) override {}\n+  virtual void visit (HIR::ModuleNoBody &) override {}\n+  virtual void visit (HIR::ExternCrate &) override {}\n+\n+  virtual void visit (HIR::UseTreeGlob &) override {}\n+  virtual void visit (HIR::UseTreeList &) override {}\n+  virtual void visit (HIR::UseTreeRebind &) override {}\n+  virtual void visit (HIR::UseDeclaration &) override {}\n+  virtual void visit (HIR::Function &) override {}\n+  virtual void visit (HIR::TypeAlias &) override {}\n+  virtual void visit (HIR::StructStruct &) override {}\n+  virtual void visit (HIR::TupleStruct &) override {}\n+  virtual void visit (HIR::EnumItem &) override {}\n+  virtual void visit (HIR::EnumItemTuple &) override {}\n+  virtual void visit (HIR::EnumItemStruct &) override {}\n+  virtual void visit (HIR::EnumItemDiscriminant &) override {}\n+  virtual void visit (HIR::Enum &) override {}\n+  virtual void visit (HIR::Union &) override {}\n+  virtual void visit (HIR::ConstantItem &) override {}\n+  virtual void visit (HIR::StaticItem &) override {}\n+  virtual void visit (HIR::TraitItemFunc &) override {}\n+  virtual void visit (HIR::TraitItemMethod &) override {}\n+  virtual void visit (HIR::TraitItemConst &) override {}\n+  virtual void visit (HIR::TraitItemType &) override {}\n+  virtual void visit (HIR::Trait &) override {}\n+  virtual void visit (HIR::InherentImpl &) override {}\n+  virtual void visit (HIR::TraitImpl &) override {}\n+\n+  virtual void visit (HIR::ExternalStaticItem &) override {}\n+  virtual void visit (HIR::ExternalFunctionItem &) override {}\n+  virtual void visit (HIR::ExternBlock &) override {}\n+\n+  virtual void visit (HIR::MacroMatchFragment &) override {}\n+  virtual void visit (HIR::MacroMatchRepetition &) override {}\n+  virtual void visit (HIR::MacroMatcher &) override {}\n+  virtual void visit (HIR::MacroRulesDefinition &) override {}\n+  virtual void visit (HIR::MacroInvocation &) override {}\n+  virtual void visit (HIR::MetaItemPath &) override {}\n+  virtual void visit (HIR::MetaItemSeq &) override {}\n+  virtual void visit (HIR::MetaWord &) override {}\n+  virtual void visit (HIR::MetaNameValueStr &) override {}\n+  virtual void visit (HIR::MetaListPaths &) override {}\n+  virtual void visit (HIR::MetaListNameValueStr &) override {}\n+\n+  virtual void visit (HIR::LiteralPattern &) override {}\n+  virtual void visit (HIR::IdentifierPattern &) override {}\n+  virtual void visit (HIR::WildcardPattern &) override {}\n+\n+  virtual void visit (HIR::RangePatternBoundLiteral &) override {}\n+  virtual void visit (HIR::RangePatternBoundPath &) override {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &) override {}\n+  virtual void visit (HIR::RangePattern &) override {}\n+  virtual void visit (HIR::ReferencePattern &) override {}\n+\n+  virtual void visit (HIR::StructPatternFieldTuplePat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdent &) override {}\n+  virtual void visit (HIR::StructPattern &) override {}\n+\n+  virtual void visit (HIR::TupleStructItemsNoRange &) override {}\n+  virtual void visit (HIR::TupleStructItemsRange &) override {}\n+  virtual void visit (HIR::TupleStructPattern &) override {}\n+\n+  virtual void visit (HIR::TuplePatternItemsMultiple &) override {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &) override {}\n+  virtual void visit (HIR::TuplePattern &) override {}\n+  virtual void visit (HIR::GroupedPattern &) override {}\n+  virtual void visit (HIR::SlicePattern &) override {}\n+\n+  virtual void visit (HIR::EmptyStmt &) override {}\n+  virtual void visit (HIR::LetStmt &) override {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &) override {}\n+  virtual void visit (HIR::ExprStmtWithBlock &) override {}\n+\n+  virtual void visit (HIR::TraitBound &) override {}\n+  virtual void visit (HIR::ImplTraitType &) override {}\n+  virtual void visit (HIR::TraitObjectType &) override {}\n+  virtual void visit (HIR::ParenthesisedType &) override {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n+  virtual void visit (HIR::TupleType &) override {}\n+  virtual void visit (HIR::NeverType &) override {}\n+  virtual void visit (HIR::RawPointerType &) override {}\n+  virtual void visit (HIR::ReferenceType &) override {}\n+  virtual void visit (HIR::ArrayType &) override {}\n+  virtual void visit (HIR::SliceType &) override {}\n+  virtual void visit (HIR::InferredType &) override {}\n+  virtual void visit (HIR::BareFunctionType &) override {}\n \n protected:\n   TypeCheckBase ()"}, {"sha": "e6cca19afc188629fa5366891fe7d2ec9d4b8a18", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-method-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -37,7 +38,10 @@ class TypeCheckExpr : public TypeCheckBase\n     expr->accept_vis (resolver);\n \n     if (resolver.infered == nullptr)\n-      return new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n+      {\n+\trust_error_at (expr->get_locus_slow (), \"failed to resolve expression\");\n+\treturn new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n+      }\n \n     auto ref = expr->get_mappings ().get_hirid ();\n     resolver.infered->set_ref (ref);\n@@ -196,9 +200,8 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (ref, &lookup))\n       {\n-\t// FIXME we need to be able to lookup the location info for the\n-\t// reference here\n-\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\trust_error_at (mappings->lookup_location (ref),\n+\t\t       \"failed to lookup type for CallExpr: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -213,6 +216,65 @@ class TypeCheckExpr : public TypeCheckBase\n     infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n+  void visit (HIR::MethodCallExpr &expr)\n+  {\n+    auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n+    if (receiver_tyty == nullptr)\n+      {\n+\trust_error_at (expr.get_receiver ()->get_locus_slow (),\n+\t\t       \"failed to resolve receiver in MethodCallExpr\");\n+\treturn;\n+      }\n+\n+    // https://doc.rust-lang.org/reference/expressions/method-call-expr.html\n+    // method resolution is complex in rust once we start handling generics and\n+    // traits. For now we only support looking up the valid name in impl blocks\n+    // which is simple. There will need to be adjustments to ensure we can turn\n+    // the receiver into borrowed references etc\n+\n+    auto probes\n+      = MethodResolution::Probe (receiver_tyty, expr.get_method_name ());\n+    if (probes.size () == 0)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to resolve the PathExprSegment to any Method\");\n+\treturn;\n+      }\n+    else if (probes.size () > 1)\n+      {\n+\trust_error_at (\n+\t  expr.get_locus (),\n+\t  \"Generics and Traits are not implemented yet for MethodCall\");\n+\treturn;\n+      }\n+\n+    auto resolved_method = probes.at (0);\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (resolved_method->get_mappings ().get_hirid (),\n+\t\t\t       &lookup))\n+      {\n+\trust_error_at (resolved_method->get_locus (),\n+\t\t       \"failed to lookup type for CallExpr: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    infered = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to lookup type to MethodCallExpr\");\n+\treturn;\n+      }\n+\n+    infered->set_ref (expr.get_mappings ().get_hirid ());\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (\n+      expr.get_mappings ().get_nodeid (),\n+      resolved_method->get_mappings ().get_nodeid ());\n+  }\n+\n   void visit (HIR::AssignmentExpr &expr)\n   {\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n@@ -313,7 +375,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!context->lookup_type (ref, &lookup))\n       {\n \trust_error_at (mappings->lookup_location (ref),\n-\t\t       \"consider giving this a type: %s\",\n+\t\t       \"Failed to resolve IdentifierExpr type: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -703,7 +765,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!is_valid_type)\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"expected ADT or Tuple Type got: [%s]\",\n+\t\t       \"expected algebraic data type got: [%s]\",\n \t\t       struct_base->as_string ().c_str ());\n \treturn;\n       }\n@@ -747,7 +809,11 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    context->lookup_type (ref, &infered);\n+    if (!context->lookup_type (ref, &infered))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to resolve PathInExpression type\");\n+      }\n   }\n \n private:\n@@ -799,6 +865,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n \t\t       == TyTy::InferType::INTEGRAL));\n       }\n+    gcc_unreachable ();\n   }\n \n   TyTy::TyBase *infered;"}, {"sha": "c8d161a30c0c803fb7579959fe7cc32e6f257179", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -31,9 +31,9 @@ namespace Resolver {\n class TypeCheckTopLevelImplItem : public TypeCheckBase\n {\n public:\n-  static void Resolve (HIR::InherentImplItem *item)\n+  static void Resolve (HIR::InherentImplItem *item, TyTy::TyBase *self)\n   {\n-    TypeCheckTopLevelImplItem resolver;\n+    TypeCheckTopLevelImplItem resolver (self);\n     item->accept_vis (resolver);\n   }\n \n@@ -81,8 +81,62 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n+  void visit (HIR::Method &method)\n+  {\n+    TyTy::TyBase *ret_type = nullptr;\n+    if (!method.has_function_return_type ())\n+      ret_type = new TyTy::UnitType (method.get_mappings ().get_hirid ());\n+    else\n+      {\n+\tauto resolved\n+\t  = TypeCheckType::Resolve (method.get_return_type ().get ());\n+\tif (resolved == nullptr)\n+\t  {\n+\t    rust_error_at (method.get_locus (),\n+\t\t\t   \"failed to resolve return type\");\n+\t    return;\n+\t  }\n+\n+\tret_type = resolved->clone ();\n+\tret_type->set_ref (\n+\t  method.get_return_type ()->get_mappings ().get_hirid ());\n+      }\n+\n+    // hold all the params to the fndef\n+    std::vector<std::pair<HIR::Pattern *, TyTy::TyBase *> > params;\n+\n+    // add the self param at the front\n+    HIR::SelfParam &self_param = method.get_self_param ();\n+    HIR::IdentifierPattern *self_pattern\n+      = new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n+\t\t\t\t    self_param.get_has_ref (),\n+\t\t\t\t    self_param.get_is_mut (),\n+\t\t\t\t    std::unique_ptr<HIR::Pattern> (nullptr));\n+    context->insert_type (self_param.get_mappings (), self->clone ());\n+    params.push_back (\n+      std::pair<HIR::Pattern *, TyTy::TyBase *> (self_pattern, self->clone ()));\n+\n+    for (auto &param : method.get_function_params ())\n+      {\n+\t// get the name as well required for later on\n+\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::TyBase *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+\tcontext->insert_type (param.get_mappings (), param_tyty);\n+      }\n+\n+    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (), params,\n+\t\t\t\t    ret_type);\n+    context->insert_type (method.get_mappings (), fnType);\n+  }\n+\n private:\n-  TypeCheckTopLevelImplItem () : TypeCheckBase () {}\n+  TypeCheckTopLevelImplItem (TyTy::TyBase *self) : TypeCheckBase (), self (self)\n+  {}\n+\n+  TyTy::TyBase *self;\n };\n \n class TypeCheckImplItem : public TypeCheckBase\n@@ -99,7 +153,7 @@ class TypeCheckImplItem : public TypeCheckBase\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n       {\n-\trust_error_at (function.locus, \"failed to lookup function type\");\n+\trust_error_at (function.get_locus (), \"failed to lookup function type\");\n \treturn;\n       }\n \n@@ -137,6 +191,49 @@ class TypeCheckImplItem : public TypeCheckBase\n     context->pop_return_type ();\n   }\n \n+  void visit (HIR::Method &method)\n+  {\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (method.get_mappings ().get_hirid (), &lookup))\n+      {\n+\trust_error_at (method.get_locus (), \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (method.get_locus (),\n+\t\t       \"found invalid type for function [%s]\",\n+\t\t       lookup->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // need to get the return type from this\n+    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n+    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    context->push_return_type (expected_ret_tyty);\n+\n+    TypeCheckExpr::Resolve (method.get_function_body ().get ());\n+    if (method.get_function_body ()->has_expr ())\n+      {\n+\tauto resolved\n+\t  = TypeCheckExpr::Resolve (method.get_function_body ()->expr.get ());\n+\n+\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n+\tif (ret_resolved == nullptr)\n+\t  {\n+\t    rust_error_at (method.get_function_body ()->expr->get_locus_slow (),\n+\t\t\t   \"failed to resolve final expression\");\n+\t    return;\n+\t  }\n+\n+\tcontext->peek_return_type ()->append_reference (\n+\t  ret_resolved->get_ref ());\n+      }\n+\n+    context->pop_return_type ();\n+  }\n+\n private:\n   TypeCheckImplItem (TyTy::TyBase *self) : TypeCheckBase (), self (self) {}\n "}, {"sha": "06be1ac95beed185851bea790d18d9b59035e89b", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -38,7 +38,7 @@ class TypeCheckItem : public TypeCheckBase\n     item->accept_vis (resolver);\n   }\n \n-  void visit (HIR::InherentImpl &impl_block)\n+  void visit (HIR::InherentImpl &impl_block) override\n   {\n     TyTy::TyBase *self = nullptr;\n     if (!context->lookup_type (\n@@ -53,7 +53,7 @@ class TypeCheckItem : public TypeCheckBase\n       TypeCheckImplItem::Resolve (impl_item.get (), self);\n   }\n \n-  void visit (HIR::Function &function)\n+  void visit (HIR::Function &function) override\n   {\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))"}, {"sha": "61823bf0381ba5854160c7ca45217f7c947889c3", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -137,11 +137,15 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n   void visit (HIR::InherentImpl &impl_block)\n   {\n-    TypeCheckType::Resolve (impl_block.get_type ().get ());\n-    for (auto &impl_item : impl_block.get_impl_items ())\n+    auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n+    if (self == nullptr)\n       {\n-\tTypeCheckTopLevelImplItem::Resolve (impl_item.get ());\n+\trust_error_at (impl_block.get_locus (), \"failed to resolve impl type\");\n+\treturn;\n       }\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self);\n   }\n \n private:"}, {"sha": "681d0238d8e4300302a79f740e04000377087cfd", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -127,19 +127,12 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     return true;\n   });\n \n-  // tail expression must be checked as part of the caller since\n-  // the result of this is very dependant on what we expect it to be\n-\n-  // now that the stmts have been resolved we must resolve the block of locals\n-  // and make sure the variables have been resolved\n-  // auto body_mappings = expr.get_mappings ();\n-  // Rib *rib = nullptr;\n-  // if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n-  //   {\n-  //     rust_fatal_error (expr.get_locus (), \"failed to lookup locals per\n-  //     block\"); return;\n-  //   }\n-  // TyTyResolver::Resolve (rib, mappings, resolver, context);\n+  if (expr.has_expr ())\n+    {\n+      delete block_tyty;\n+\n+      block_tyty = TypeCheckExpr::Resolve (expr.get_final_expr ().get (), true);\n+    }\n \n   infered = block_tyty->clone ();\n }"}, {"sha": "9d882fb2689538e2e3a38d489a6a0756b89dd309", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -37,7 +37,7 @@ class TypeResolverDump : public TypeCheckBase\n     return dumper.dump;\n   }\n \n-  void visit (HIR::InherentImpl &impl_block)\n+  void visit (HIR::InherentImpl &impl_block) override\n   {\n     dump += indent () + \"impl \"\n \t    + type_string (impl_block.get_type ()->get_mappings ()) + \" {\\n\";\n@@ -53,15 +53,15 @@ class TypeResolverDump : public TypeCheckBase\n     dump += indent () + \"}\\n\";\n   }\n \n-  void visit (HIR::ConstantItem &constant)\n+  void visit (HIR::ConstantItem &constant) override\n   {\n     dump += indent () + \"constant \" + constant.get_identifier () + \":\"\n \t    + type_string (constant.get_mappings ()) + \" = \";\n     constant.get_expr ()->accept_vis (*this);\n     dump += \";\\n\";\n   }\n \n-  void visit (HIR::Function &function)\n+  void visit (HIR::Function &function) override\n   {\n     dump += indent () + \"fn \" + function.function_name + \" \"\n \t    + type_string (function.get_mappings ()) + \"\\n\";\n@@ -73,7 +73,19 @@ class TypeResolverDump : public TypeCheckBase\n     dump += indent () + \"}\\n\";\n   }\n \n-  void visit (HIR::BlockExpr &expr)\n+  void visit (HIR::Method &method) override\n+  {\n+    dump += indent () + \"fn \" + method.get_method_name () + \" \"\n+\t    + type_string (method.get_mappings ()) + \"\\n\";\n+    dump += indent () + \"{\\n\";\n+\n+    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n+    function_body->accept_vis (*this);\n+\n+    dump += indent () + \"}\\n\";\n+  }\n+\n+  void visit (HIR::BlockExpr &expr) override\n   {\n     indentation_level++;\n \n@@ -94,7 +106,7 @@ class TypeResolverDump : public TypeCheckBase\n     indentation_level--;\n   }\n \n-  void visit (HIR::LetStmt &stmt)\n+  void visit (HIR::LetStmt &stmt) override\n   {\n     dump += \"let \" + stmt.get_pattern ()->as_string () + \":\"\n \t    + type_string (stmt.get_mappings ());\n@@ -105,35 +117,35 @@ class TypeResolverDump : public TypeCheckBase\n       }\n   }\n \n-  void visit (HIR::ExprStmtWithBlock &stmt)\n+  void visit (HIR::ExprStmtWithBlock &stmt) override\n   {\n     stmt.get_expr ()->accept_vis (*this);\n   }\n \n-  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override\n   {\n     stmt.get_expr ()->accept_vis (*this);\n   }\n \n-  void visit (HIR::AssignmentExpr &expr)\n+  void visit (HIR::AssignmentExpr &expr) override\n   {\n     expr.get_lhs ()->accept_vis (*this);\n     dump += \" = \";\n     expr.get_rhs ()->accept_vis (*this);\n   }\n \n-  void visit (HIR::LiteralExpr &expr)\n+  void visit (HIR::LiteralExpr &expr) override\n   {\n     dump += expr.get_literal ()->as_string () + \":\"\n \t    + type_string (expr.get_mappings ());\n   }\n \n-  void visit (HIR::IdentifierExpr &expr)\n+  void visit (HIR::IdentifierExpr &expr) override\n   {\n     dump += expr.get_identifier () + \":\" + type_string (expr.get_mappings ());\n   }\n \n-  void visit (HIR::ArrayExpr &expr)\n+  void visit (HIR::ArrayExpr &expr) override\n   {\n     dump += type_string (expr.get_mappings ()) + \":[\";\n \n@@ -143,7 +155,7 @@ class TypeResolverDump : public TypeCheckBase\n     dump += \"]\";\n   }\n \n-  void visit (HIR::ArrayElemsValues &elems)\n+  void visit (HIR::ArrayElemsValues &elems) override\n   {\n     elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n       e->accept_vis (*this);\n@@ -152,15 +164,15 @@ class TypeResolverDump : public TypeCheckBase\n     });\n   }\n \n-  void visit (HIR::GroupedExpr &expr)\n+  void visit (HIR::GroupedExpr &expr) override\n   {\n     HIR::Expr *paren_expr = expr.get_expr_in_parens ().get ();\n     dump += \"(\";\n     paren_expr->accept_vis (*this);\n     dump += \")\";\n   }\n \n-  void visit (HIR::PathInExpression &expr)\n+  void visit (HIR::PathInExpression &expr) override\n   {\n     dump += type_string (expr.get_mappings ());\n   }"}, {"sha": "82b070f1f7aa82a9802f7cbb15e2fb2bd3d3c989", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -38,7 +38,6 @@ class TypeCheckCallExpr : private TyVisitor\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n-  ~TypeCheckCallExpr () {}\n \n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n@@ -71,6 +70,47 @@ class TypeCheckCallExpr : private TyVisitor\n   Analysis::Mappings *mappings;\n };\n \n+class TypeCheckMethodCallExpr : private TyVisitor\n+{\n+public:\n+  static TyBase *go (TyBase *ref, HIR::MethodCallExpr &call,\n+\t\t     Resolver::TypeCheckContext *context)\n+  {\n+    TypeCheckMethodCallExpr checker (call, context);\n+    ref->accept_vis (checker);\n+    return checker.resolved;\n+  }\n+\n+  void visit (UnitType &type) override { gcc_unreachable (); }\n+  void visit (InferType &type) override { gcc_unreachable (); }\n+  void visit (TupleType &type) override { gcc_unreachable (); }\n+  void visit (StructFieldType &type) override { gcc_unreachable (); }\n+  void visit (ArrayType &type) override { gcc_unreachable (); }\n+  void visit (BoolType &type) override { gcc_unreachable (); }\n+  void visit (IntType &type) override { gcc_unreachable (); }\n+  void visit (UintType &type) override { gcc_unreachable (); }\n+  void visit (FloatType &type) override { gcc_unreachable (); }\n+  void visit (USizeType &type) override { gcc_unreachable (); }\n+  void visit (ISizeType &type) override { gcc_unreachable (); }\n+  void visit (ErrorType &type) override { gcc_unreachable (); }\n+  void visit (ADTType &type) override { gcc_unreachable (); };\n+\n+  // call fns\n+  void visit (FnType &type) override;\n+\n+private:\n+  TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+\t\t\t   Resolver::TypeCheckContext *context)\n+    : resolved (nullptr), call (c), context (context),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  TyBase *resolved;\n+  HIR::MethodCallExpr &call;\n+  Resolver::TypeCheckContext *context;\n+  Analysis::Mappings *mappings;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "8b04209291b7ae24c1f266719590194a58f9fc03", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -147,14 +147,15 @@ ADTType::accept_vis (TyVisitor &vis)\n std::string\n ADTType::as_string () const\n {\n-  if (num_fields () == 0)\n-    return identifier;\n+  // if (num_fields () == 0)\n+  //   return identifier;\n \n-  std::string fields_buffer;\n-  for (auto &field : fields)\n-    fields_buffer += field->as_string () + \", \";\n+  // std::string fields_buffer;\n+  // for (auto &field : fields)\n+  //   fields_buffer += field->as_string () + \", \";\n \n-  return identifier + \"{\" + fields_buffer + \"}\";\n+  // return identifier + \"{\" + fields_buffer + \"}\";\n+  return identifier;\n }\n \n TyBase *\n@@ -574,5 +575,56 @@ TypeCheckCallExpr::visit (FnType &type)\n   resolved = type.get_return_type ()->clone ();\n }\n \n+// method call checker\n+\n+void\n+TypeCheckMethodCallExpr::visit (FnType &type)\n+{\n+  // +1 for the receiver self\n+  size_t num_args_to_call = call.num_params () + 1;\n+  if (num_args_to_call != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 1;\n+  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n+    auto fnparam = type.param_at (i);\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param);\n+    if (argument_expr_tyty == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"failed to resolve type for argument expr in CallExpr\");\n+\treturn false;\n+      }\n+\n+    auto resolved_argument_type = fnparam.second->combine (argument_expr_tyty);\n+    if (resolved_argument_type == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"Type Resolution failure on parameter\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (param->get_mappings (), resolved_argument_type);\n+\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != num_args_to_call)\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.get_return_type ()->clone ();\n+}\n+\n } // namespace TyTy\n } // namespace Rust"}, {"sha": "8a15631406a6a7998d733858dcc43ee09f0d25e9", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -374,6 +374,30 @@ Mappings::lookup_hir_param (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_self_param (CrateNum crateNum, HirId id,\n+\t\t\t\t HIR::SelfParam *param)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  hirSelfParamMappings[crateNum][id] = param;\n+  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::SelfParam *\n+Mappings::lookup_hir_self_param (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirSelfParamMappings.find (crateNum);\n+  if (it == hirSelfParamMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_hir_struct_field (CrateNum crateNum, HirId id,\n \t\t\t\t   HIR::StructExprField *field)"}, {"sha": "0d625f6b67ec8b1f1aa6345bb89d723b00feaa81", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -125,6 +125,10 @@ class Mappings\n   void insert_hir_param (CrateNum crateNum, HirId id, HIR::FunctionParam *type);\n   HIR::FunctionParam *lookup_hir_param (CrateNum crateNum, HirId id);\n \n+  void insert_hir_self_param (CrateNum crateNum, HirId id,\n+\t\t\t      HIR::SelfParam *type);\n+  HIR::SelfParam *lookup_hir_self_param (CrateNum crateNum, HirId id);\n+\n   void insert_hir_struct_field (CrateNum crateNum, HirId id,\n \t\t\t\tHIR::StructExprField *type);\n   HIR::StructExprField *lookup_hir_struct_field (CrateNum crateNum, HirId id);\n@@ -152,6 +156,20 @@ class Mappings\n     return hirNodesWithinCrate[crate];\n   }\n \n+  void\n+  iterate_impl_items (std::function<bool (HirId, HIR::InherentImplItem *)> cb)\n+  {\n+    for (auto it = hirImplItemMappings.begin ();\n+\t it != hirImplItemMappings.end (); it++)\n+      {\n+\tfor (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n+\t  {\n+\t    if (!cb (iy->first, iy->second))\n+\t      return;\n+\t  }\n+      }\n+  }\n+\n private:\n   Mappings ();\n \n@@ -176,6 +194,7 @@ class Mappings\n     hirStructFieldMappings;\n   std::map<CrateNum, std::map<HirId, HIR::InherentImplItem *> >\n     hirImplItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::SelfParam *> > hirSelfParamMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}, {"sha": "fe63252cf9b5ac9ca12b1b9ffac1b326f6626fdc", "filename": "gcc/testsuite/rust.test/compilable/block_expr1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fblock_expr1.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,27 @@\n+fn test3(x: i32) -> i32 {\n+    if x > 1 {\n+        5\n+    } else {\n+        0\n+    }\n+}\n+\n+fn test5(x: i32) -> i32 {\n+    if x > 1 {\n+        if x == 5 {\n+            7\n+        } else {\n+            9\n+        }\n+    } else {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let call3: i32 = { test3(3) + 2 };\n+    let call5 = {\n+        let a = test5(5);\n+        a + 1\n+    };\n+}"}, {"sha": "3093a6c0f1c7aa3f57d5b8261cf5487c6987e8ff", "filename": "gcc/testsuite/rust.test/compilable/impl_block3.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fimpl_block3.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,31 @@\n+struct Point {\n+    x: f64,\n+    y: f64,\n+}\n+\n+impl Point {\n+    fn origin() -> Point {\n+        Point { x: 0.0, y: 0.0 }\n+    }\n+\n+    fn new(x: f64, y: f64) -> Point {\n+        Point { x: x, y: y }\n+    }\n+}\n+\n+struct Rectangle {\n+    p1: Point,\n+    p2: Point,\n+}\n+\n+impl Rectangle {\n+    fn from(p1: Point, p2: Point) -> Self {\n+        Self { p1, p2 }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point::origin();\n+    let p2 = Point::new(3.0, 4.0);\n+    let rect = Rectangle::from(p1, p2);\n+}"}, {"sha": "cffa02e630b84b1e2a87706d48bd2b6649b93fa6", "filename": "gcc/testsuite/rust.test/compilable/methods1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods1.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,39 @@\n+struct Point {\n+    x: f64,\n+    y: f64,\n+}\n+\n+impl Point {\n+    fn origin() -> Point {\n+        Point { x: 0.0, y: 0.0 }\n+    }\n+\n+    fn new(x: f64, y: f64) -> Point {\n+        Point { x: x, y: y }\n+    }\n+}\n+\n+struct Rectangle {\n+    p1: Point,\n+    p2: Point,\n+}\n+\n+impl Rectangle {\n+    fn from(p1: Point, p2: Point) -> Self {\n+        Self { p1, p2 }\n+    }\n+\n+    fn sum_x(self) -> f64 {\n+        let p1 = self.p1;\n+        let p2 = self.p2;\n+        p1.x + p2.x\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point::origin();\n+    let p2 = Point::new(3.0, 4.0);\n+    let rect = Rectangle::from(p1, p2);\n+\n+    let sum = rect.sum_x();\n+}"}, {"sha": "96a3211f797fada6fbd6cdb5df655fe87b891417", "filename": "gcc/testsuite/rust.test/compilable/methods2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods2.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,41 @@\n+struct Point {\n+    x: f64,\n+    y: f64,\n+}\n+\n+impl Point {\n+    fn origin() -> Point {\n+        Point { x: 0.0, y: 0.0 }\n+    }\n+\n+    fn new(x: f64, y: f64) -> Point {\n+        Point { x: x, y: y }\n+    }\n+}\n+\n+struct Rectangle {\n+    p1: Point,\n+    p2: Point,\n+}\n+\n+impl Rectangle {\n+    fn from(p1: Point, p2: Point) -> Self {\n+        Self { p1, p2 }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point::origin();\n+    let p2 = Point::new(3.0, 4.0);\n+    let rect = Rectangle::from(p1, p2);\n+\n+    let sum = rect.sum_x();\n+}\n+\n+impl Rectangle {\n+    fn sum_x(self) -> f64 {\n+        let p1 = self.p1;\n+        let p2 = self.p2;\n+        p1.x + p2.x\n+    }\n+}"}, {"sha": "817f48b60eeb4f6b1105c01759b3aa2ffd393d5d", "filename": "gcc/testsuite/rust.test/compilable/name_resolve1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fname_resolve1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fname_resolve1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fname_resolve1.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,23 @@\n+struct Foo(i32, bool);\n+\n+impl Foo {\n+    fn new(a: i32, b: bool) -> Foo {\n+        Foo(a, b)\n+    }\n+\n+    fn test() -> i32 {\n+        test()\n+    }\n+}\n+\n+fn test() -> i32 {\n+    123\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo::new(1, true);\n+\n+    let b;\n+    b = Foo::test();\n+}"}, {"sha": "3880be04e0152337fd9c1207cba9e9c446e82cbb", "filename": "gcc/testsuite/rust.test/compilable/nested_struct1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fnested_struct1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fnested_struct1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fnested_struct1.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,17 @@\n+struct Point {\n+    x: f64,\n+    y: f64,\n+}\n+\n+struct Rectangle {\n+    p1: Point,\n+    p2: Point,\n+}\n+\n+fn main() {\n+    let p1 = Point { x: 0.0, y: 0.0 };\n+    let p2 = Point { x: 2.0, y: 4.0 };\n+    let rect = Rectangle { p1, p2 };\n+\n+    let a = rect.p1.x;\n+}"}, {"sha": "373d6dd5a607865943964a84c34eca16d8269435", "filename": "gcc/testsuite/rust.test/compilable/self_type1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fself_type1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fself_type1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fself_type1.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,12 @@\n+struct Foo(i32, bool);\n+\n+impl Foo {\n+    fn new(a: i32, b: bool) -> Self {\n+        Self(a, b)\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo::new(1, true);\n+}"}, {"sha": "9acdf5ff7247b667c0bf073f97a66711a1f63d37", "filename": "gcc/testsuite/rust.test/fail_compilation/redef_error1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error1.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,8 @@\n+struct S1 {\n+    x: f64,\n+    y: f64,\n+}\n+\n+struct S1(i32, bool);\n+\n+fn main() {}"}, {"sha": "c04d2cf15ecd93ed3bfbd46af911e34a791db10e", "filename": "gcc/testsuite/rust.test/fail_compilation/redef_error2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error2.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,4 @@\n+const TEST: i32 = 2;\n+const TEST: f32 = 3.0;\n+\n+fn main() {}"}, {"sha": "9ffa4e5ed68559bc784781e4cb2482ddf123be92", "filename": "gcc/testsuite/rust.test/fail_compilation/redef_error3.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error3.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,9 @@\n+fn test() -> bool {\n+    true\n+}\n+\n+fn test() -> i32 {\n+    123\n+}\n+\n+fn main() {}"}, {"sha": "5b20e1b2aa2b9720d7cd207dedfc469287c48386", "filename": "gcc/testsuite/rust.test/fail_compilation/redef_error4.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error4.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,27 @@\n+struct Foo(i32, bool);\n+\n+impl Foo {\n+    fn new(a: i32, b: bool) -> Foo {\n+        Foo(a, b)\n+    }\n+\n+    fn test() -> i32 {\n+        test()\n+    }\n+\n+    fn test() -> bool {\n+        true\n+    }\n+}\n+\n+fn test() -> i32 {\n+    123\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo::new(1, true);\n+\n+    let b;\n+    b = Foo::test();\n+}"}, {"sha": "342a67e323db1264b21eaa8830c3fe357edd8004", "filename": "gcc/testsuite/rust.test/fail_compilation/redef_error5.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94be91d6159101caa7c560b188bd6c02d8d86d17/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Ffail_compilation%2Fredef_error5.rs?ref=94be91d6159101caa7c560b188bd6c02d8d86d17", "patch": "@@ -0,0 +1,8 @@\n+struct Foo(i32, bool);\n+\n+impl Foo {\n+    const TEST: i32 = 123;\n+    const TEST: bool = false;\n+}\n+\n+fn main() {}"}]}