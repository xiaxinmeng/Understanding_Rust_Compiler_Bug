{"sha": "324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0ZDNmNDUyNWU5YzFjNmU1Nzk3MDY1MmU0M2ZhOWNkODNmZWQ5Yg==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2010-09-06T08:56:43Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2010-09-06T08:56:43Z"}, "message": "re PR rtl-optimization/44919 (ICE on ia64 with -O3 at  sel-sched.c:4672)\n\n\tPR rtl-optimization/44919\n\t* sel-sched.c (move_cond_jump): Remove assert, check that\n\tthe several blocks case can only happen with mutually exclusive\n\tinsns instead.  Rewrite the movement code to support moving through\n\tseveral basic blocks. \n\n\t* g++.dg/opt/pr44919.C: New.\n\nFrom-SVN: r163904", "tree": {"sha": "25cda3b1dd77a6abb9bee17215f7d7f9b96ba6e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25cda3b1dd77a6abb9bee17215f7d7f9b96ba6e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/comments", "author": null, "committer": null, "parents": [{"sha": "7b74bb63ff2aaf8fdd7556b4cc85e202f0a240fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b74bb63ff2aaf8fdd7556b4cc85e202f0a240fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b74bb63ff2aaf8fdd7556b4cc85e202f0a240fb"}], "stats": {"total": 336, "additions": 313, "deletions": 23}, "files": [{"sha": "d882b6290a1e9d38a9c032ccc2ba4b7598d3ec11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "patch": "@@ -1,3 +1,11 @@\n+2010-09-06  Andrey Belevantsev  <abel@ispras.ru>\n+\n+\tPR rtl-optimization/44919\n+\t* sel-sched.c (move_cond_jump): Remove assert, check that\n+\tthe several blocks case can only happen with mutually exclusive\n+\tinsns instead.  Rewrite the movement code to support moving through\n+\tseveral basic blocks.\n+\n 2010-09-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (iptrsize): New mode attribute."}, {"sha": "b3b1a80226868c955bf1f82fcaf8fc1f46b52c13", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "patch": "@@ -4875,18 +4875,35 @@ static void\n move_cond_jump (rtx insn, bnd_t bnd)\n {\n   edge ft_edge;\n-  basic_block block_from, block_next, block_new;\n-  rtx next, prev, link;\n+  basic_block block_from, block_next, block_new, block_bnd, bb;\n+  rtx next, prev, link, head;\n \n-  /* BLOCK_FROM holds basic block of the jump.  */\n   block_from = BLOCK_FOR_INSN (insn);\n+  block_bnd = BLOCK_FOR_INSN (BND_TO (bnd));\n+  prev = BND_TO (bnd);\n \n-  /* Moving of jump should not cross any other jumps or\n-  beginnings of new basic blocks.  */\n-  gcc_assert (block_from == BLOCK_FOR_INSN (BND_TO (bnd)));\n+#ifdef ENABLE_CHECKING\n+  /* Moving of jump should not cross any other jumps or beginnings of new\n+     basic blocks.  The only exception is when we move a jump through\n+     mutually exclusive insns along fallthru edges.  */\n+  if (block_from != block_bnd)\n+    {\n+      bb = block_from;\n+      for (link = PREV_INSN (insn); link != PREV_INSN (prev);\n+           link = PREV_INSN (link))\n+        {\n+          if (INSN_P (link))\n+            gcc_assert (sched_insns_conditions_mutex_p (insn, link));\n+          if (BLOCK_FOR_INSN (link) && BLOCK_FOR_INSN (link) != bb)\n+            {\n+              gcc_assert (single_pred (bb) == BLOCK_FOR_INSN (link));\n+              bb = BLOCK_FOR_INSN (link);\n+            }\n+        }\n+    }\n+#endif\n \n   /* Jump is moved to the boundary.  */\n-  prev = BND_TO (bnd);\n   next = PREV_INSN (insn);\n   BND_TO (bnd) = insn;\n \n@@ -4901,28 +4918,35 @@ move_cond_jump (rtx insn, bnd_t bnd)\n   gcc_assert (block_new->next_bb == block_next\n               && block_from->next_bb == block_new);\n \n-  gcc_assert (BB_END (block_from) == insn);\n-\n-  /* Move all instructions except INSN from BLOCK_FROM to\n-     BLOCK_NEW.  */\n-  for (link = prev; link != insn; link = NEXT_INSN (link))\n+  /* Move all instructions except INSN to BLOCK_NEW.  */\n+  bb = block_bnd;\n+  head = BB_HEAD (block_new);\n+  while (bb != block_from->next_bb)\n     {\n-      EXPR_ORIG_BB_INDEX (INSN_EXPR (link)) = block_new->index;\n-      df_insn_change_bb (link, block_new);\n-    }\n+      rtx from, to;\n+      from = bb == block_bnd ? prev : sel_bb_head (bb);\n+      to = bb == block_from ? next : sel_bb_end (bb);\n \n-  /* Set correct basic block and instructions properties.  */\n-  BB_END (block_new) = PREV_INSN (insn);\n+      /* The jump being moved can be the first insn in the block.\n+         In this case we don't have to move anything in this block.  */\n+      if (NEXT_INSN (to) != from)\n+        {\n+          reorder_insns (from, to, head);\n \n-  NEXT_INSN (PREV_INSN (prev)) = insn;\n-  PREV_INSN (insn) = PREV_INSN (prev);\n+          for (link = to; link != head; link = PREV_INSN (link))\n+            EXPR_ORIG_BB_INDEX (INSN_EXPR (link)) = block_new->index;\n+          head = to;\n+        }\n+\n+      /* Cleanup possibly empty blocks left.  */\n+      block_next = bb->next_bb;\n+      if (bb != block_from)\n+          maybe_tidy_empty_bb (bb);\n+      bb = block_next;\n+    }\n \n   /* Assert there is no jump to BLOCK_NEW, only fallthrough edge.  */\n   gcc_assert (NOTE_INSN_BASIC_BLOCK_P (BB_HEAD (block_new)));\n-  PREV_INSN (prev) = BB_HEAD (block_new);\n-  NEXT_INSN (next) = NEXT_INSN (BB_HEAD (block_new));\n-  NEXT_INSN (BB_HEAD (block_new)) = prev;\n-  PREV_INSN (NEXT_INSN (next)) = next;\n \n   gcc_assert (!sel_bb_empty_p (block_from)\n               && !sel_bb_empty_p (block_new));"}, {"sha": "c3d92fcbd68e378609f128864bf1267fb5f3a2ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "patch": "@@ -1,3 +1,8 @@\n+2010-09-06  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR rtl-optimization/44919\n+\t* g++.dg/opt/pr44919.C: New.\n+\n 2010-09-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/38282"}, {"sha": "e90851be31706dacef60234854ecbd0ba96b37f3", "filename": "gcc/testsuite/g++.dg/opt/pr44919.C", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr44919.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/324d3f4525e9c1c6e57970652e43fa9cd83fed9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr44919.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr44919.C?ref=324d3f4525e9c1c6e57970652e43fa9cd83fed9b", "patch": "@@ -0,0 +1,253 @@\n+// { dg-do compile { target powerpc*-*-* ia64-*-* x86_64-*-* } }\n+// { dg-options \"-O3 -fselective-scheduling2\" }\n+\n+namespace std {\n+\n+typedef long unsigned int size_t;\n+\n+template<typename _Tp> class new_allocator { public: typedef size_t size_type; typedef _Tp* pointer; };\n+template<typename _Tp> class allocator: public new_allocator<_Tp> { public: typedef size_t size_type; template<typename _Tp1> struct rebind { typedef allocator<_Tp1> other; }; };\n+\n+class back_insert_iterator { };\n+template<typename _Container> back_insert_iterator back_inserter(_Container& __x) { };\n+\n+class vector { };\n+\n+struct _List_node_base { };\n+struct _List_node : public _List_node_base { };\n+template<typename _Tp> struct _List_iterator { typedef _List_iterator<_Tp> _Self; typedef _Tp& reference; explicit _List_iterator(_List_node_base* __x) : _M_node(__x) { } reference operator*() const { } _Self& operator++() { } bool operator!=(const _Self& __x) const { return _M_node != __x._M_node; } _List_node_base* _M_node; };\n+template<typename _Tp, typename _Alloc> class _List_base { protected: typedef typename _Alloc::template rebind<_List_node >::other _Node_alloc_type; struct _List_impl : public _Node_alloc_type { _List_node_base _M_node; }; _List_impl _M_impl; };\n+template<typename _Tp, typename _Alloc = std::allocator<_Tp> > class list : protected _List_base<_Tp, _Alloc> { public: typedef _Tp value_type; typedef _List_iterator<_Tp> iterator; iterator begin() { } iterator end() { return iterator(&this->_M_impl._M_node); } };\n+\n+namespace tr1 { template<typename _Tp, size_t _Nm> struct array { typedef _Tp value_type; typedef const value_type& const_reference; typedef const value_type* const_iterator; typedef size_t size_type; value_type _M_instance[_Nm ? _Nm : 1]; const_iterator begin() const { return const_iterator(&_M_instance[0]); } const_reference operator[](size_type __n) const { return _M_instance[__n]; } }; }\n+}\n+\n+namespace X {\n+\n+class Object { };\n+struct Has_qrt { };\n+template <typename F> struct qrt_or_not { typedef const typename F::result_type & type; };\n+template <typename Functor, typename P1 = void> struct Qualified_result_of : qrt_or_not<Functor> { };\n+\n+using std::tr1::array;\n+\n+template <class R_> class Point_2 : public R_::Kernel_base::Point_2 {\n+public:\n+  typedef typename R_::Kernel_base::Point_2 RPoint_2;\n+  typedef RPoint_2 Rep;\n+  const Rep& rep() const { }\n+};\n+\n+template <class R_> class Vector_2 : public R_::Kernel_base::Vector_2 {\n+public:\n+  typedef typename R_::Kernel_base::Vector_2 RVector_2;\n+  typedef RVector_2 Rep;\n+  const Rep& rep() const { return *this; }\n+  typedef R_ R;\n+  typename Qualified_result_of<typename R::Compute_x_2,Vector_2>::type x() const { return R().compute_x_2_object()(*this); }\n+  typename Qualified_result_of<typename R::Compute_y_2,Vector_2>::type y() const { return R().compute_y_2_object()(*this); }\n+  typename Qualified_result_of<typename R::Compute_y_2,Vector_2>::type cartesian(int i) const { return (i==0) ? x() : y(); }\n+  typename Qualified_result_of<typename R::Compute_hx_2,Vector_2>::type hx() const { return R().compute_hx_2_object()(*this); }\n+  typename Qualified_result_of<typename R::Compute_hy_2,Vector_2>::type hy() const { return R().compute_hy_2_object()(*this); }\n+  typename Qualified_result_of<typename R::Compute_hw_2,Vector_2>::type hw() const { return R().compute_hw_2_object()(*this); }\n+  typename Qualified_result_of<typename R::Compute_hx_2,Vector_2>::type homogeneous(int i) const { return (i==0) ? hx() : (i==1)? hy() : hw(); }\n+};\n+\n+template <class R_> class Segment_2 : public R_::Kernel_base::Segment_2 { };\n+template <class R_> class Iso_rectangle_2 : public R_::Kernel_base::Iso_rectangle_2 { };\n+\n+template <typename T, int i > const T& constant() { static const T t(i); return t; }\n+template <class T, class Alloc = std::allocator<T > > class Handle_for { struct RefCounted { T t; }; typedef typename Alloc::template rebind<RefCounted>::other Allocator; typedef typename Allocator::pointer pointer; pointer ptr_; public: typedef T element_type; const T * Ptr() const { return &(ptr_->t); } };\n+template <class T, class Allocator> const T& get(const Handle_for<T, Allocator> &h) { return *(h.Ptr()); }\n+\n+template <class R_> class PointC2 {\n+public:\n+  typedef typename R_::Vector_2 Vector_2; Vector_2 base;\n+  typedef typename Vector_2::Cartesian_const_iterator Cartesian_const_iterator; Cartesian_const_iterator cartesian_begin() const { return base.cartesian_begin(); }\n+};\n+\n+template <class R_> class VectorC2 {\n+public:\n+  typedef typename R_::FT FT;\n+  typedef array<FT, 2> Rep;\n+  typedef typename R_::template Handle<Rep>::type Base;\n+  Base base;\n+  typedef typename Rep::const_iterator Cartesian_const_iterator;\n+  const FT & x() const { return X::get(base)[0]; }\n+  const FT & y() const { return X::get(base)[1]; }\n+  const FT & hx() const { return x(); }\n+  const FT & hy() const { return y(); }\n+  const FT & hw() const { return constant<FT, 1>(); }\n+  Cartesian_const_iterator cartesian_begin() const { return X::get(base).begin(); }\n+};\n+\n+template <class R_> class SegmentC2 { };\n+template <class R_> class Iso_rectangleC2 { };\n+\n+namespace internal {\n+  template <class K> class Segment_2_Iso_rectangle_2_pair {\n+    public:\n+      enum Intersection_results { NO_INTERSECTION };\n+      Segment_2_Iso_rectangle_2_pair(typename K::Segment_2 const *seg, typename K::Iso_rectangle_2 const *rect) ;\n+      Intersection_results intersection_type() const;\n+      mutable Intersection_results _result;\n+      typename K::Point_2 _ref_point;\n+      typename K::Vector_2 _dir;\n+      typename K::Point_2 _isomin;\n+      typename K::Point_2 _isomax;\n+      mutable typename K::FT _min, _max;\n+  };\n+  template <class K> Object intersection( const typename K::Segment_2 &seg, const typename K::Iso_rectangle_2 &iso, const K&) {\n+    typedef Segment_2_Iso_rectangle_2_pair<K> is_t; is_t ispair(&seg, &iso); switch (ispair.intersection_type()) { }\n+  }\n+  template <class K> typename Segment_2_Iso_rectangle_2_pair<K>::Intersection_results Segment_2_Iso_rectangle_2_pair<K>::intersection_type() const {\n+    typedef typename K::RT RT;\n+    typedef typename K::FT FT;\n+    typename K::Construct_cartesian_const_iterator_2 construct_cccit;\n+    typename K::Cartesian_const_iterator_2 ref_point_it = construct_cccit(_ref_point);\n+    typename K::Cartesian_const_iterator_2 end = construct_cccit(_ref_point, 0);\n+    typename K::Cartesian_const_iterator_2 isomin_it = construct_cccit(_isomin);\n+    typename K::Cartesian_const_iterator_2 isomax_it = construct_cccit(_isomax);\n+    for (unsigned int i=0; ref_point_it != end; ++i, ++ref_point_it, ++isomin_it, ++isomax_it) {\n+      if (_dir.homogeneous(i) == RT(0)) {\n+        if ( *(ref_point_it) <*(isomin_it) ) {\n+          _result = NO_INTERSECTION;\n+        }\n+        if ( *(ref_point_it) > *(isomax_it)) {\n+          _result = NO_INTERSECTION;\n+        }\n+      } else {\n+        FT newmin, newmax;\n+        if (_dir.homogeneous(i) > RT(0)) {\n+          newmin = ( *(isomin_it) - (*ref_point_it)) / _dir.cartesian(i);\n+          newmax = ( *(isomax_it) - (*ref_point_it)) / _dir.cartesian(i);\n+        } else {\n+          newmin = ( (*isomax_it) - (*ref_point_it)) / _dir.cartesian(i);\n+          newmax = ( (*isomin_it) - (*ref_point_it)) / _dir.cartesian(i);\n+        }\n+        if (newmin > _min) _min = newmin;\n+        if (newmax <_max) _max = newmax;\n+        if (_max <_min) { return _result; }\n+      }\n+    }\n+  }\n+}\n+\n+template <class K> Object intersection(const Segment_2<K> &seg, const Iso_rectangle_2<K> &iso) { typedef typename K::Intersect_2 Intersect; return Intersect()(seg, iso); }\n+\n+namespace CommonKernelFunctors {\n+  template <typename K> class Construct_cartesian_const_iterator_2 {\n+    typedef typename K::Point_2 Point_2;\n+    typedef typename K::Cartesian_const_iterator_2 Cartesian_const_iterator_2;\n+public:\n+    typedef Cartesian_const_iterator_2 result_type;\n+    Cartesian_const_iterator_2 operator()( const Point_2& p) const { return p.rep().cartesian_begin(); }\n+    Cartesian_const_iterator_2 operator()( const Point_2& p, int) const { }\n+  };\n+  template <typename K> class Intersect_2 {\n+    typedef typename K::Object_2 Object_2;\n+  public:\n+    typedef Object_2 result_type;\n+    template <class T1, class T2> Object_2 operator()(const T1& t1, const T2& t2) const { return internal::intersection(t1, t2, K()); }\n+  };\n+}\n+\n+namespace CartesianKernelFunctors {\n+  using namespace CommonKernelFunctors;\n+  template <typename K> class Compute_x_2 : Has_qrt {\n+    typedef typename K::FT FT;\n+    typedef typename K::Vector_2 Vector_2;\n+  public:\n+    typedef FT result_type;\n+    const result_type & operator()(const Vector_2& v) const { return v.rep().x(); }\n+  };\n+  template <typename K> class Compute_y_2 : Has_qrt {\n+    typedef typename K::FT FT;\n+    typedef typename K::Vector_2 Vector_2;\n+  public:\n+    typedef FT result_type;\n+    const result_type & operator()(const Vector_2& v) const { return v.rep().y(); }\n+  };\n+  template <typename K> class Compute_hx_2 : public Has_qrt {\n+    typedef typename K::FT FT;\n+    typedef typename K::Vector_2 Vector_2;\n+  public:\n+    typedef FT result_type;\n+    const result_type & operator()(const Vector_2& v) const { return v.rep().hx(); }\n+  };\n+  template <typename K> class Compute_hy_2 : public Has_qrt {\n+    typedef typename K::FT FT;\n+    typedef typename K::Vector_2 Vector_2;\n+  public:\n+    typedef FT result_type;\n+    const result_type & operator()(const Vector_2& v) const { return v.rep().hy(); }\n+  };\n+  template <typename K> class Compute_hw_2 : public Has_qrt {\n+    typedef typename K::FT FT;\n+    typedef typename K::Vector_2 Vector_2;\n+  public:\n+    typedef FT result_type;\n+    const result_type & operator()(const Vector_2& v) const { return v.rep().hw(); }\n+  };\n+}\n+\n+template <typename K_, typename FT_> struct Cartesian_base {\n+  typedef K_ Kernel;\n+  typedef X::Object Object_2;\n+  typedef PointC2<Kernel> Point_2;\n+  typedef VectorC2<Kernel> Vector_2;\n+  typedef SegmentC2<Kernel> Segment_2;\n+  typedef Iso_rectangleC2<Kernel> Iso_rectangle_2;\n+  typedef typename array<FT_, 2>::const_iterator Cartesian_const_iterator_2;\n+};\n+\n+template <typename K_base, typename Kernel_ > struct Type_equality_wrapper : public K_base {\n+  typedef K_base Kernel_base;\n+  typedef X::Point_2<Kernel_> Point_2;\n+  typedef X::Vector_2<Kernel_> Vector_2;\n+  typedef X::Segment_2<Kernel_> Segment_2;\n+  typedef X::Iso_rectangle_2<Kernel_> Iso_rectangle_2;\n+};\n+\n+template <typename FT_, typename Kernel_ > struct Cartesian_base_ref_count : public Cartesian_base<Kernel_, FT_ > {\n+  typedef FT_ RT;\n+  typedef FT_ FT;\n+  template <typename T > struct Handle { typedef Handle_for<T> type; };\n+  typedef Kernel_ K;\n+  typedef CartesianKernelFunctors::Compute_x_2<K> Compute_x_2;\n+  Compute_x_2 compute_x_2_object() const { }\n+  typedef CartesianKernelFunctors::Compute_y_2<K> Compute_y_2;\n+  Compute_y_2 compute_y_2_object() const { }\n+  typedef CartesianKernelFunctors::Compute_hx_2<K> Compute_hx_2;\n+  Compute_hx_2 compute_hx_2_object() const { }\n+  typedef CartesianKernelFunctors::Compute_hy_2<K> Compute_hy_2;\n+  Compute_hy_2 compute_hy_2_object() const { }\n+  typedef CartesianKernelFunctors::Compute_hw_2<K> Compute_hw_2;\n+  Compute_hw_2 compute_hw_2_object() const { }\n+  typedef CartesianKernelFunctors::Construct_cartesian_const_iterator_2<K> Construct_cartesian_const_iterator_2;\n+  typedef CartesianKernelFunctors::Intersect_2<K> Intersect_2;\n+};\n+\n+template <typename FT_ > struct Cartesian : public Type_equality_wrapper<Cartesian_base_ref_count<FT_, Cartesian<FT_> >, Cartesian<FT_> > { };\n+\n+template <class Kernel> class Ipelet_base {\n+public:\n+  typedef typename X::Point_2<Kernel> Point_2;\n+  typedef typename Kernel::Segment_2 Segment_2;\n+  typedef typename Kernel::Iso_rectangle_2 Iso_rectangle_2;\n+\n+  Iso_rectangle_2 read_active_objects () const { }\n+  struct Voronoi_from_tri{ std::list<Segment_2> seg_list; };\n+\n+  template <class T,class output_iterator> bool cast_into_seg(const T& obj,const Iso_rectangle_2& bbox,output_iterator out_it) const{ X::intersection(obj,bbox); }\n+  template<class iterator,class output_iterator> void cast_into_seg(const iterator first,const iterator end, const Iso_rectangle_2& bbox, output_iterator out_it) const { for (iterator it=first; it!=end; ++it) cast_into_seg(*it,bbox,out_it); }\n+  void draw_dual_(Voronoi_from_tri& v_recup,const Iso_rectangle_2& bbox) const { std::vector seg_cont; cast_into_seg(v_recup.seg_list.begin(),v_recup.seg_list.end(),bbox,std::back_inserter(seg_cont)); }\n+  void draw_dual_in_ipe(const Iso_rectangle_2& bbox) const { Voronoi_from_tri v_recup; draw_dual_(v_recup,bbox); }\n+};\n+\n+typedef X::Cartesian<double> Kernel;\n+\n+class diagrammeIpelet : public X::Ipelet_base<Kernel> { void protected_run(); };\n+void diagrammeIpelet::protected_run() { Iso_rectangle_2 bbox = read_active_objects( ); draw_dual_in_ipe(bbox); }\n+\n+}"}]}