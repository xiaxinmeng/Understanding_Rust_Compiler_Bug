{"sha": "047f64a30c8549da45fbf192ff685957888b310a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ3ZjY0YTMwYzg1NDlkYTQ1ZmJmMTkyZmY2ODU5NTc4ODhiMzEwYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-11-20T22:43:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-20T22:43:54Z"}, "message": "method.c (build_decl_overload_real): Don't mess with global placement delete.\n\n\t* method.c (build_decl_overload_real): Don't mess with global\n\tplacement delete.\n\n\t* init.c (build_new): Check for null throw spec, not nothrow_t.\n\n\t* decl.c (duplicate_decls): Don't complain about different exceptions\n\tfrom an internal declaration.\n\n\t* call.c (build_op_delete_call): Fix check for member fns again.\n\n\t* decl2.c (import_export_decl): Interface hackery affects\n\tvirtual synthesized methods.\n\nFrom-SVN: r16612", "tree": {"sha": "0997d31bc2c133e99650cba3c6eb49dce3e4e6db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0997d31bc2c133e99650cba3c6eb49dce3e4e6db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/047f64a30c8549da45fbf192ff685957888b310a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047f64a30c8549da45fbf192ff685957888b310a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/047f64a30c8549da45fbf192ff685957888b310a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047f64a30c8549da45fbf192ff685957888b310a/comments", "author": null, "committer": null, "parents": [{"sha": "7bb9fb0edfa79f0a70bf3d1cb0c41982c4f79128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bb9fb0edfa79f0a70bf3d1cb0c41982c4f79128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bb9fb0edfa79f0a70bf3d1cb0c41982c4f79128"}], "stats": {"total": 73, "additions": 51, "deletions": 22}, "files": [{"sha": "f1eeae5dfb35c42674339c2c6bc90b29fe55731c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=047f64a30c8549da45fbf192ff685957888b310a", "patch": "@@ -1,3 +1,18 @@\n+Thu Nov 20 14:40:17 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (build_decl_overload_real): Don't mess with global \n+\tplacement delete.\n+\n+\t* init.c (build_new): Check for null throw spec, not nothrow_t.\n+\n+\t* decl.c (duplicate_decls): Don't complain about different exceptions\n+\tfrom an internal declaration.\n+\n+\t* call.c (build_op_delete_call): Fix check for member fns again.\n+\n+\t* decl2.c (import_export_decl): Interface hackery affects\n+\tvirtual synthesized methods.\n+\n Wed Nov 19 18:24:14 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (start_decl): Don't just complain about a mismatched "}, {"sha": "4e66a307e93485a713414735f75227cff5da58ea", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=047f64a30c8549da45fbf192ff685957888b310a", "patch": "@@ -5182,8 +5182,8 @@ build_op_delete_call (code, addr, size, flags)\n \n   if (fn != error_mark_node)\n     {\n-      if (TREE_PURPOSE (fns))\n-\t/* TREE_PURPOSE is only set for lists of member functions.  */\n+      if (TREE_CODE (TREE_VALUE (fns)) == TREE_LIST)\n+\t/* Member functions.  */\n \tenforce_access (TREE_PURPOSE (TREE_VALUE (fns)), fn);\n       return build_function_call (fn, expr_tree_cons (NULL_TREE, addr, args));\n     }"}, {"sha": "d1d19c7fb38012d3e8d7c0dc8a8896d07231f6fb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=047f64a30c8549da45fbf192ff685957888b310a", "patch": "@@ -2769,7 +2769,8 @@ duplicate_decls (newdecl, olddecl)\n \t  TREE_TYPE (olddecl) = build_exception_variant (newtype,\n \t\t\t\t\t\t\t TYPE_RAISES_EXCEPTIONS (oldtype));\n \n-\t  if ((pedantic || ! DECL_IN_SYSTEM_HEADER (olddecl))\n+\t  if ((pedantic || (! DECL_IN_SYSTEM_HEADER (olddecl)\n+\t\t\t    && DECL_SOURCE_LINE (olddecl) != 0))\n \t      && flag_exceptions\n \t      && ! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))\n \t    {"}, {"sha": "3821cf33dead5a126f45fc7d53f37d595e4d530a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=047f64a30c8549da45fbf192ff685957888b310a", "patch": "@@ -2793,7 +2793,8 @@ import_export_decl (decl)\n   else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n       tree ctype = DECL_CLASS_CONTEXT (decl);\n-      if (CLASSTYPE_INTERFACE_KNOWN (ctype) && ! DECL_ARTIFICIAL (decl))\n+      if (CLASSTYPE_INTERFACE_KNOWN (ctype)\n+\t  && (! DECL_ARTIFICIAL (decl) || DECL_VINDEX (decl)))\n \t{\n \t  DECL_NOT_REALLY_EXTERN (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)"}, {"sha": "7100b565a8386a2597d717737dba3c73e894fe0d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=047f64a30c8549da45fbf192ff685957888b310a", "patch": "@@ -2452,16 +2452,6 @@ build_new (placement, decl, init, use_global_new)\n       return error_mark_node;\n     }\n \n-  /* If the first placement arg is of type nothrow_t, it's allowed to\n-     return 0 on allocation failure.  */\n-  nothrow = (placement && TREE_VALUE (placement)\n-\t     && TREE_TYPE (TREE_VALUE (placement))\n-\t     && IS_AGGR_TYPE (TREE_TYPE (TREE_VALUE (placement)))\n-\t     && (TYPE_IDENTIFIER (TREE_TYPE (TREE_VALUE (placement)))\n-\t\t == get_identifier (\"nothrow_t\")));\n-\n-  check_new = flag_check_new || nothrow;\n-\n #if 1\n   /* Get a little extra space to store a couple of things before the new'ed\n      array, if this isn't the default placement new.  */\n@@ -2513,6 +2503,30 @@ build_new (placement, decl, init, use_global_new)\n       rval = cp_convert (build_pointer_type (true_type), rval);\n     }\n \n+  /*        unless an allocation function is declared with an empty  excep-\n+     tion-specification  (_except.spec_),  throw(), it indicates failure to\n+     allocate storage by throwing a bad_alloc exception  (clause  _except_,\n+     _lib.bad.alloc_); it returns a non-null pointer otherwise If the allo-\n+     cation function is declared  with  an  empty  exception-specification,\n+     throw(), it returns null to indicate failure to allocate storage and a\n+     non-null pointer otherwise.\n+\n+     So check for a null exception spec on the op new we just called.  */\n+\n+  nothrow = 0;\n+  if (rval)\n+    {\n+      /* The CALL_EXPR.  */\n+      tree t = TREE_OPERAND (rval, 0);\n+      /* The function.  */\n+      t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+      t = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (t));\n+\n+      if (t && TREE_VALUE (t) == NULL_TREE)\n+\tnothrow = 1;\n+    }\n+  check_new = flag_check_new || nothrow;\n+\n   if (flag_exceptions && rval)\n     {\n       /* This must last longer so we can use it in the cleanup."}, {"sha": "c16f6eaf02f66dc10b26e7052266c1b491e745ac", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/047f64a30c8549da45fbf192ff685957888b310a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=047f64a30c8549da45fbf192ff685957888b310a", "patch": "@@ -1117,19 +1117,17 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n   char *name = IDENTIFIER_POINTER (dname);\n \n   /* member operators new and delete look like methods at this point.  */\n-  if (! for_method && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST)\n+  if (! for_method && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST\n+      && TREE_CHAIN (parms) == void_list_node)\n     {\n       if (dname == ansi_opname[(int) DELETE_EXPR])\n \treturn get_identifier (\"__builtin_delete\");\n       else if (dname == ansi_opname[(int) VEC_DELETE_EXPR])\n \treturn get_identifier (\"__builtin_vec_delete\");\n-      else if (TREE_CHAIN (parms) == void_list_node)\n-\t{\n-\t  if (dname == ansi_opname[(int) NEW_EXPR])\n-\t    return get_identifier (\"__builtin_new\");\n-\t  else if (dname == ansi_opname[(int) VEC_NEW_EXPR])\n-\t    return get_identifier (\"__builtin_vec_new\");\n-\t}\n+      if (dname == ansi_opname[(int) NEW_EXPR])\n+\treturn get_identifier (\"__builtin_new\");\n+      else if (dname == ansi_opname[(int) VEC_NEW_EXPR])\n+\treturn get_identifier (\"__builtin_vec_new\");\n     }\n \n   OB_INIT ();"}]}