{"sha": "a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVhNTZkODhhMTA0MGE0MmExYmZjMjI1ODczNjRmM2JmYjFlZmE3Ng==", "commit": {"author": {"name": "Than McIntosh", "email": "thanm@google.com", "date": "2016-12-06T22:31:25Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-06T22:31:25Z"}, "message": "compiler: pass lvalue/rvalue context to back end for var exprs\n    \n    Add a new flag on the Var_expression class that indicates\n    whether the var reference appears in an \"lvalue\" context\n    (for example, on the LHS of an assignment stmt) or an\n    \"rvalue\" context (for example, as an argument of a call).\n    \n    Add a traversal pass that visits assignment stmt LHS subtrees\n    so as to mark things prior to backend gen. Select the right\n    context value in other places where Backend::var_expression is\n    called.\n    \n    Reviewed-on: https://go-review.googlesource.com/33990\n\n\t* go-gcc.cc (Gcc_backend::var_expression): Add Varexpr_context\n\tparameter.\n\nFrom-SVN: r243321", "tree": {"sha": "d29a67292ff3a155b5c23dfb0a6145f8ddbee486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d29a67292ff3a155b5c23dfb0a6145f8ddbee486"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/comments", "author": {"login": "thanm", "id": 12280172, "node_id": "MDQ6VXNlcjEyMjgwMTcy", "avatar_url": "https://avatars.githubusercontent.com/u/12280172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thanm", "html_url": "https://github.com/thanm", "followers_url": "https://api.github.com/users/thanm/followers", "following_url": "https://api.github.com/users/thanm/following{/other_user}", "gists_url": "https://api.github.com/users/thanm/gists{/gist_id}", "starred_url": "https://api.github.com/users/thanm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thanm/subscriptions", "organizations_url": "https://api.github.com/users/thanm/orgs", "repos_url": "https://api.github.com/users/thanm/repos", "events_url": "https://api.github.com/users/thanm/events{/privacy}", "received_events_url": "https://api.github.com/users/thanm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd5af1d61761e9bf466cd64360e6321cde0a2c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5af1d61761e9bf466cd64360e6321cde0a2c5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5af1d61761e9bf466cd64360e6321cde0a2c5f"}], "stats": {"total": 167, "additions": 139, "deletions": 28}, "files": [{"sha": "0b116eb6f4e311ba7b469d88a7780c00c837545a", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -1,3 +1,8 @@\n+2016-12-06  Than McIntosh  <thanm@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::var_expression): Add Varexpr_context\n+\tparameter.\n+\n 2016-11-22  Than McIntosh  <thanm@google.com>\n \n \t* go-gcc.cc (char_needs_encoding): Remove."}, {"sha": "f1ac52242a4bde3148e03ba737a8f50f00a954fb", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -276,7 +276,7 @@ class Gcc_backend : public Backend\n   { return this->make_expression(null_pointer_node); }\n \n   Bexpression*\n-  var_expression(Bvariable* var, Location);\n+  var_expression(Bvariable* var, Varexpr_context, Location);\n \n   Bexpression*\n   indirect_expression(Btype*, Bexpression* expr, bool known_valid, Location);\n@@ -1243,7 +1243,7 @@ Gcc_backend::zero_expression(Btype* btype)\n // An expression that references a variable.\n \n Bexpression*\n-Gcc_backend::var_expression(Bvariable* var, Location location)\n+Gcc_backend::var_expression(Bvariable* var, Varexpr_context, Location location)\n {\n   tree ret = var->get_tree(location);\n   if (ret == error_mark_node)"}, {"sha": "0cb0f9c653f95ea65594d54a46ebd34d3ef2934a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -1,4 +1,4 @@\n-b7bad96ce0af50a1129eaab9aa110d68a601917b\n+2102112e26a21589455f940ec6b409766d942c62\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e9a19128e5c2fa4119b323a27d095484dd69c814", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -254,7 +254,7 @@ class Backend\n \n   // Create a reference to a variable.\n   virtual Bexpression*\n-  var_expression(Bvariable* var, Location) = 0;\n+  var_expression(Bvariable* var, Varexpr_context in_lvalue_pos, Location) = 0;\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer"}, {"sha": "24f6b125c7d27e14b2356ee33f185c11c1ad134b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -760,7 +760,8 @@ Var_expression::do_get_backend(Translate_context* context)\n   else\n     go_unreachable();\n \n-  Bexpression* ret = context->backend()->var_expression(bvar, loc);\n+  Bexpression* ret =\n+      context->backend()->var_expression(bvar, this->in_lvalue_pos_, loc);\n   if (is_in_heap)\n     ret = context->backend()->indirect_expression(btype, ret, true, loc);\n   return ret;\n@@ -887,7 +888,10 @@ Temporary_reference_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n-  Bexpression* ret = gogo->backend()->var_expression(bvar, this->location());\n+  Varexpr_context ve_ctxt = (this->is_lvalue_ ? VE_lvalue : VE_rvalue);\n+\n+  Bexpression* ret = gogo->backend()->var_expression(bvar, ve_ctxt,\n+                                                     this->location());\n \n   // The backend can't always represent the same set of recursive types\n   // that the Go frontend can.  In some cases this means that a\n@@ -958,11 +962,11 @@ Set_and_use_temporary_expression::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n   Gogo* gogo = context->gogo();\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n-  Bexpression* var_ref = gogo->backend()->var_expression(bvar, loc);\n+  Bexpression* lvar_ref = gogo->backend()->var_expression(bvar, VE_rvalue, loc);\n \n   Bexpression* bexpr = this->expr_->get_backend(context);\n-  Bstatement* set = gogo->backend()->assignment_statement(var_ref, bexpr, loc);\n-  var_ref = gogo->backend()->var_expression(bvar, loc);\n+  Bstatement* set = gogo->backend()->assignment_statement(lvar_ref, bexpr, loc);\n+  Bexpression* var_ref = gogo->backend()->var_expression(bvar, VE_lvalue, loc);\n   Bexpression* ret = gogo->backend()->compound_expression(set, var_ref, loc);\n   return ret;\n }\n@@ -1065,11 +1069,12 @@ Sink_expression::do_get_backend(Translate_context* context)\n       this->bvar_ =\n \tgogo->backend()->temporary_variable(fn_ctx, context->bblock(), bt, NULL,\n \t\t\t\t\t    false, loc, &decl);\n-      Bexpression* var_ref = gogo->backend()->var_expression(this->bvar_, loc);\n+      Bexpression* var_ref =\n+          gogo->backend()->var_expression(this->bvar_, VE_lvalue, loc);\n       var_ref = gogo->backend()->compound_expression(decl, var_ref, loc);\n       return var_ref;\n     }\n-  return gogo->backend()->var_expression(this->bvar_, loc);\n+  return gogo->backend()->var_expression(this->bvar_, VE_lvalue, loc);\n }\n \n // Ast dump for sink expression.\n@@ -1276,7 +1281,7 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n   Named_object* no = this->fn_;\n   Location loc = no->location();\n   if (this->dvar_ != NULL)\n-    return context->backend()->var_expression(this->dvar_, loc);\n+    return context->backend()->var_expression(this->dvar_, VE_rvalue, loc);\n \n   Gogo* gogo = context->gogo();\n   std::string var_name;\n@@ -1330,7 +1335,7 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n     }\n \n   this->dvar_ = bvar;\n-  return gogo->backend()->var_expression(bvar, loc);\n+  return gogo->backend()->var_expression(bvar, VE_rvalue, loc);\n }\n \n // Print a function descriptor expression.\n@@ -4207,7 +4212,8 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t{\n \t  Temporary_statement* temp = sut->temporary();\n \t  Bvariable* bvar = temp->get_backend_variable(context);\n-          Bexpression* bvar_expr = gogo->backend()->var_expression(bvar, loc);\n+          Bexpression* bvar_expr =\n+              gogo->backend()->var_expression(bvar, VE_lvalue, loc);\n           Bexpression* bval = sut->expression()->get_backend(context);\n \n           Bstatement* bassign =\n@@ -4294,7 +4300,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t  gogo->backend()->implicit_variable_set_init(implicit, buf, btype,\n \t\t\t\t\t\t      true, copy_to_heap, false,\n \t\t\t\t\t\t      bexpr);\n-\t  bexpr = gogo->backend()->var_expression(implicit, loc);\n+\t  bexpr = gogo->backend()->var_expression(implicit, VE_lvalue, loc);\n \n \t  // If we are not copying a slice initializer to the heap,\n \t  // then it can be changed by the program, so if it can\n@@ -4304,7 +4310,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      && this->expr_->type()->has_pointer())\n \t    {\n \t      Bexpression* root =\n-\t\tgogo->backend()->var_expression(implicit, loc);\n+                  gogo->backend()->var_expression(implicit, VE_lvalue, loc);\n \t      root = gogo->backend()->address_expression(root, loc);\n \t      Type* type = Type::make_pointer_type(this->expr_->type());\n \t      gogo->add_gc_root(Expression::make_backend(root, type, loc));\n@@ -4324,7 +4330,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n                                                 true, false, btype, loc);\n           gogo->backend()->immutable_struct_set_init(decl, buf, true, false,\n                                                      btype, loc, bexpr);\n-          bexpr = gogo->backend()->var_expression(decl, loc);\n+          bexpr = gogo->backend()->var_expression(decl, VE_lvalue, loc);\n         }\n \n       go_assert(!this->create_temp_ || this->expr_->is_variable());\n@@ -14116,15 +14122,15 @@ Heap_expression::do_get_backend(Translate_context* context)\n   Bvariable* space_temp =\n     gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n \t\t\t\t\tspace, true, loc, &decl);\n-  space = gogo->backend()->var_expression(space_temp, loc);\n+  space = gogo->backend()->var_expression(space_temp, VE_lvalue, loc);\n   Btype* expr_btype = this->expr_->type()->get_backend(gogo);\n   Bexpression* ref =\n     gogo->backend()->indirect_expression(expr_btype, space, true, loc);\n \n   Bexpression* bexpr = this->expr_->get_backend(context);\n   Bstatement* assn = gogo->backend()->assignment_statement(ref, bexpr, loc);\n   decl = gogo->backend()->compound_statement(decl, assn);\n-  space = gogo->backend()->var_expression(space_temp, loc);\n+  space = gogo->backend()->var_expression(space_temp, VE_rvalue, loc);\n   return gogo->backend()->compound_expression(decl, space, loc);\n }\n \n@@ -15063,7 +15069,8 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   Gogo* gogo = context->gogo();\n   Location loc = Linemap::predeclared_location();\n   if (this->bvar_ != NULL)\n-    return gogo->backend()->var_expression(this->bvar_, this->location());\n+    return gogo->backend()->var_expression(this->bvar_, VE_rvalue,\n+                                           this->location());\n \n   const Typed_identifier_list* interface_methods = this->itype_->methods();\n   go_assert(!interface_methods->empty());\n@@ -15099,7 +15106,8 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n       this->bvar_ =\n           gogo->backend()->immutable_struct_reference(mangled_name, asm_name,\n                                                       btype, loc);\n-      return gogo->backend()->var_expression(this->bvar_, this->location());\n+      return gogo->backend()->var_expression(this->bvar_, VE_rvalue,\n+                                             this->location());\n     }\n \n   // The first element is the type descriptor.\n@@ -15147,7 +15155,7 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t\t  !is_public, btype, loc);\n   gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, false,\n                                              !is_public, btype, loc, ctor);\n-  return gogo->backend()->var_expression(this->bvar_, loc);\n+  return gogo->backend()->var_expression(this->bvar_, VE_lvalue, loc);\n }\n \n void"}, {"sha": "98e21151cc602fb8674eed774706dd2c665e1624", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -1282,14 +1282,24 @@ class Var_expression : public Expression\n  public:\n   Var_expression(Named_object* variable, Location location)\n     : Expression(EXPRESSION_VAR_REFERENCE, location),\n-      variable_(variable)\n+      variable_(variable), in_lvalue_pos_(VE_rvalue)\n   { }\n \n   // Return the variable.\n   Named_object*\n   named_object() const\n   { return this->variable_; }\n \n+  // Does this var expression appear in an lvalue (assigned-to) context?\n+  bool\n+  in_lvalue_pos() const\n+  { return this->in_lvalue_pos_ == VE_lvalue; }\n+\n+  // Mark a var_expression as appearing in an lvalue context.\n+  void\n+  set_in_lvalue_pos()\n+  { this->in_lvalue_pos_ = VE_lvalue; }\n+\n  protected:\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n@@ -1320,6 +1330,8 @@ class Var_expression : public Expression\n  private:\n   // The variable we are referencing.\n   Named_object* variable_;\n+  // Set to TRUE if var expression appears in lvalue context\n+  Varexpr_context in_lvalue_pos_;\n };\n \n // A reference to a variable within an enclosing function."}, {"sha": "e9cc6b43f940882a5064acde1db5d3ec19f20431", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -1369,7 +1369,7 @@ Gogo::write_globals()\n                 {\n                   Location loc = var->location();\n                   Bexpression* var_expr =\n-                      this->backend()->var_expression(bvar, loc);\n+                      this->backend()->var_expression(bvar, VE_lvalue, loc);\n                   var_init_stmt =\n                       this->backend()->assignment_statement(var_expr, var_binit,\n                                                             loc);\n@@ -5734,7 +5734,8 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n     {\n       Named_object* no = (*this->results_)[i];\n       Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n-      Bexpression* val = gogo->backend()->var_expression(bvar, location);\n+      Bexpression* val = gogo->backend()->var_expression(bvar, VE_rvalue,\n+                                                         location);\n       if (no->result_var_value()->is_in_heap())\n \t{\n \t  Btype* bt = no->result_var_value()->type()->get_backend(gogo);\n@@ -6563,7 +6564,8 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n           Expression* val_expr =\n               Expression::make_cast(this->type(), this->init_, loc);\n           Bexpression* val = val_expr->get_backend(&context);\n-          Bexpression* var_ref = gogo->backend()->var_expression(var_decl, loc);\n+          Bexpression* var_ref =\n+              gogo->backend()->var_expression(var_decl, VE_lvalue, loc);\n           decl_init = gogo->backend()->assignment_statement(var_ref, val, loc);\n \t}\n     }"}, {"sha": "e0a97d05f311565d6bc4acf5a8ad31551680c0c6", "filename": "gcc/go/gofrontend/operator.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Foperator.h?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -63,4 +63,10 @@ enum Operator\n   OPERATOR_RSQUARE\t// ]\n };\n \n+// Whether a variable expression appears in lvalue (assignment) context.\n+enum Varexpr_context {\n+  VE_rvalue,\n+  VE_lvalue\n+};\n+\n #endif // !defined(GO_OPERATOR_H)"}, {"sha": "c7b4fe82cebe49ce270645deda7c2ba2453c739c", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -825,6 +825,80 @@ Assignment_statement::do_flatten(Gogo*, Named_object*, Block*,\n   return this;\n }\n \n+\n+// Helper class to locate a root Var_expression within an expression\n+// tree and mark it as being in an \"lvalue\" or assignment\n+// context. Examples:\n+//\n+//    x, y = 40, foo(w)\n+//    x[2] = bar(v)\n+//    x.z.w[blah(v + u)], y.another = 2, 3\n+//\n+// In the code above, vars \"x\" and \"y\" appear in lvalue / assignment\n+// context, whereas the other vars \"v\", \"u\", etc are in rvalue context.\n+//\n+// Note: at the moment the Var_expression version of \"do_copy()\"\n+// defaults to returning the original object, not a new object,\n+// meaning that a given Var_expression can be referenced from more\n+// than one place in the tree. This means that when we want to mark a\n+// Var_expression as having lvalue semantics, we need to make a copy\n+// of it. Example:\n+//\n+//    mystruct.myfield += 42\n+//\n+// When this is lowered to eliminate the += operator, we get a tree\n+//\n+//    mystruct.myfield = mystruct.field + 42\n+//\n+// in which the \"mystruct\" same Var_expression is referenced on both\n+// LHS and RHS subtrees. This in turn means that if we try to mark the\n+// LHS Var_expression the RHS Var_expression will also be marked.  To\n+// address this issue, the code below clones any var_expression before\n+// applying an lvalue marking.\n+//\n+\n+class Mark_lvalue_varexprs : public Traverse\n+{\n+ public:\n+  Mark_lvalue_varexprs()\n+    : Traverse(traverse_expressions)\n+  { }\n+\n+ protected:\n+  int\n+  expression(Expression**);\n+\n+ private:\n+};\n+\n+int Mark_lvalue_varexprs::expression(Expression** ppexpr)\n+{\n+  Expression* e = *ppexpr;\n+\n+  Var_expression* ve = e->var_expression();\n+  if (ve)\n+    {\n+      ve = new Var_expression(ve->named_object(), ve->location());\n+      ve->set_in_lvalue_pos();\n+      *ppexpr = ve;\n+      return TRAVERSE_EXIT;\n+    }\n+\n+  Field_reference_expression* fre = e->field_reference_expression();\n+  if (fre != NULL)\n+    return TRAVERSE_CONTINUE;\n+\n+  Array_index_expression* aie = e->array_index_expression();\n+  if (aie != NULL)\n+    {\n+      Mark_lvalue_varexprs mlve;\n+      aie->array()->traverse_subexpressions(&mlve);\n+      return TRAVERSE_EXIT;\n+    }\n+\n+  return TRAVERSE_EXIT;\n+}\n+\n // Convert an assignment statement to the backend representation.\n \n Bstatement*\n@@ -836,6 +910,9 @@ Assignment_statement::do_get_backend(Translate_context* context)\n       return context->backend()->expression_statement(rhs);\n     }\n \n+  Mark_lvalue_varexprs mlve;\n+  Expression::traverse(&this->lhs_, &mlve);\n+\n   Bexpression* lhs = this->lhs_->get_backend(context);\n   Expression* conv =\n       Expression::convert_for_assignment(context->gogo(), this->lhs_->type(),"}, {"sha": "d540acb35b3dcd01777555ef8028b1323dfa02a8", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5a56d88a1040a42a1bfc22587364f3bfb1efa76/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=a5a56d88a1040a42a1bfc22587364f3bfb1efa76", "patch": "@@ -1173,7 +1173,8 @@ Type::type_descriptor_pointer(Gogo* gogo, Location location)\n       go_assert(t->type_descriptor_var_ != NULL);\n     }\n   Bexpression* var_expr =\n-      gogo->backend()->var_expression(t->type_descriptor_var_, location);\n+      gogo->backend()->var_expression(t->type_descriptor_var_,\n+                                      VE_rvalue, location);\n   return gogo->backend()->address_expression(var_expr, location);\n }\n \n@@ -2146,7 +2147,7 @@ Type::gc_symbol_pointer(Gogo* gogo)\n     }\n   Location bloc = Linemap::predeclared_location();\n   Bexpression* var_expr =\n-      gogo->backend()->var_expression(t->gc_symbol_var_, bloc);\n+      gogo->backend()->var_expression(t->gc_symbol_var_, VE_rvalue, bloc);\n   return gogo->backend()->address_expression(var_expr, bloc);\n }\n "}]}