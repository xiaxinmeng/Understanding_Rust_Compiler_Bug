{"sha": "c69899f0976489947ff59759b61e95e207432485", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY5ODk5ZjA5NzY0ODk5NDdmZjU5NzU5YjYxZTk1ZTIwNzQzMjQ4NQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2015-12-21T09:53:01Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2015-12-21T09:53:01Z"}, "message": "[ARC] Add and refurbish the builtins related functions.\n\ngcc/\n2015-12-21  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/builtins.def: New file.\n\t* config/arc/arc.c (arc_init_simd_builtins): Remove.\n\t(arc_builtins): Likewise.\n\t(TARGET_BUILTIN_DECL): Define.\n\t(arc_builtin_id): New enum.\n\t(arc_builtin_description): New structure.\n\t(arc_bdesc): New variable.\n\t(arc_tolower): New function.\n\t(def_mbuiltin): Remove.\n\t(arc_builtin_decl): New function.\n\t(arc_expand_builtin_aligned ): Likewise.\n\t(apply_GEN_FCN): Likewise.\n\t(arc_init_builtins): Refurbish.\n\t(arc_expand_builtin): Likewise.\n\t(simd_insn_args_type): Remove.\n\t(builtin_description): Likewise\n\t(arc_simd_builtin_desc_list): Likewise.\n\t(arc_expand_simd_builtin): Likewise.\n\t(arc_process_double_reg_moves): Use the new builtin name format.\n\t* config/arc/arc.md (unspec): New builtin function UNSPEC codes.\n\t(vunspec): New builtin function VUNSPEC codes.\n\t(UNSPEC_SWAP, UNSPEC_MUL64, UNSPEC_MULU64, UNSPEC_DIVAW)\n\t(UNSPEC_DIRECT, UNSPEC_LP, UNSPEC_CASESI, VUNSPEC_RTIE)\n\t(VUNSPEC_SYNC, VUNSPEC_BRK, VUNSPEC_FLAG, VUNSPEC_SLEEP)\n\t(VUNSPEC_SWI, VUNSPEC_CORE_READ, VUNSPEC_CORE_WRITE, VUNSPEC_LR)\n\t(VUNSPEC_SR, VUNSPEC_TRAP_S, VUNSPEC_UNIMP_S, VUNSPEC_NOP)\n\t(UNSPEC_ARC_MEMBAR,VUNSPEC_ARC_CAS, VUNSPEC_ARC_LL)\n\t(VUNSPEC_ARC_SC, VUNSPEC_ARC_EX, VUNSPEC_DEXCL)\n\t(VUNSPEC_DEXCL_NORES, VUNSPEC_LR_HIGH): Remove.\n\t(mul64, mulu64): Remove patterns.\n\t(store_direct, *movdf_insn_nolrsr, casesi, casesi_load)\n\t(casesi_compact_jump, nopv, swap, divaw, flag, brk, rtie, sync)\n\t(swi, sleep, core_read, core_write, lr, sr, trap_s, unimp_s)\n\t(doloop_begin_i): Use new builtin function code naming.\n\t(kflag, clri, ffs, ffs_f, ffssi2, fls, seti): New patterns.\n\t* config/arc/builtins.def: New file.\n\t* config/arc/fpx.md: Use new builtin function code naming.\n\t* config/arc/simdext.md: New SIMD builtin function UNSPEC\n\tcodes. Use them in the SIMD patterns.\n\ngcc/testsuite\n2015-12-21  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/builtin_general.c: New test.\n\t* gcc.target/arc/builtin_simd.c: Likewise.\n\t* gcc.target/arc/builtin_special.c: Likewise.\n\nFrom-SVN: r231874", "tree": {"sha": "b15c0826982564ca605c2e917e11a50ea250abca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b15c0826982564ca605c2e917e11a50ea250abca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c69899f0976489947ff59759b61e95e207432485", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c69899f0976489947ff59759b61e95e207432485", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c69899f0976489947ff59759b61e95e207432485", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c69899f0976489947ff59759b61e95e207432485/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8e663301f8b51d033b87d974b04fa431a18227a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8e663301f8b51d033b87d974b04fa431a18227a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8e663301f8b51d033b87d974b04fa431a18227a"}], "stats": {"total": 2768, "additions": 1298, "deletions": 1470}, "files": [{"sha": "bf1a617237dbcc4062d6a4af1db330b85ebc8460", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -1,3 +1,45 @@\n+2015-12-21  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/builtins.def: New file.\n+\t* config/arc/arc.c (arc_init_simd_builtins): Remove.\n+\t(arc_builtins): Likewise.\n+\t(TARGET_BUILTIN_DECL): Define.\n+\t(arc_builtin_id): New enum.\n+\t(arc_builtin_description): New structure.\n+\t(arc_bdesc): New variable.\n+\t(arc_tolower): New function.\n+\t(def_mbuiltin): Remove.\n+\t(arc_builtin_decl): New function.\n+\t(arc_expand_builtin_aligned ): Likewise.\n+\t(apply_GEN_FCN): Likewise.\n+\t(arc_init_builtins): Refurbish.\n+\t(arc_expand_builtin): Likewise.\n+\t(simd_insn_args_type): Remove.\n+\t(builtin_description): Likewise\n+\t(arc_simd_builtin_desc_list): Likewise.\n+\t(arc_expand_simd_builtin): Likewise.\n+\t(arc_process_double_reg_moves): Use the new builtin name format.\n+\t* config/arc/arc.md (unspec): New builtin function UNSPEC codes.\n+\t(vunspec): New builtin function VUNSPEC codes.\n+\t(UNSPEC_SWAP, UNSPEC_MUL64, UNSPEC_MULU64, UNSPEC_DIVAW)\n+\t(UNSPEC_DIRECT, UNSPEC_LP, UNSPEC_CASESI, VUNSPEC_RTIE)\n+\t(VUNSPEC_SYNC, VUNSPEC_BRK, VUNSPEC_FLAG, VUNSPEC_SLEEP)\n+\t(VUNSPEC_SWI, VUNSPEC_CORE_READ, VUNSPEC_CORE_WRITE, VUNSPEC_LR)\n+\t(VUNSPEC_SR, VUNSPEC_TRAP_S, VUNSPEC_UNIMP_S, VUNSPEC_NOP)\n+\t(UNSPEC_ARC_MEMBAR,VUNSPEC_ARC_CAS, VUNSPEC_ARC_LL)\n+\t(VUNSPEC_ARC_SC, VUNSPEC_ARC_EX, VUNSPEC_DEXCL)\n+\t(VUNSPEC_DEXCL_NORES, VUNSPEC_LR_HIGH): Remove.\n+\t(mul64, mulu64): Remove patterns.\n+\t(store_direct, *movdf_insn_nolrsr, casesi, casesi_load)\n+\t(casesi_compact_jump, nopv, swap, divaw, flag, brk, rtie, sync)\n+\t(swi, sleep, core_read, core_write, lr, sr, trap_s, unimp_s)\n+\t(doloop_begin_i): Use new builtin function code naming.\n+\t(kflag, clri, ffs, ffs_f, ffssi2, fls, seti): New patterns.\n+\t* config/arc/builtins.def: New file.\n+\t* config/arc/fpx.md: Use new builtin function code naming.\n+\t* config/arc/simdext.md: New SIMD builtin function UNSPEC\n+\tcodes. Use them in the SIMD patterns.\n+\n 2015-12-21  Sujoy Saraswati  <sujoy.saraswati@hpe.com>\n \n \tPR tree-optimization/61441"}, {"sha": "17d49cd16b36c43a61c54f14ecfb4306c927ef2c", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 516, "deletions": 1257, "changes": 1773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -175,164 +175,6 @@ struct GTY (()) arc_ccfsm\n    this to be no less than the 1/p  */\n #define MAX_INSNS_SKIPPED 3\n \n-/* The values of unspec's first field.  */\n-enum {\n-  ARC_UNSPEC_PLT = 3,\n-  ARC_UNSPEC_GOT,\n-  ARC_UNSPEC_GOTOFF\n-} ;\n-\n-\n-enum arc_builtins {\n-  ARC_BUILTIN_NOP        =    2,\n-  ARC_BUILTIN_NORM       =    3,\n-  ARC_BUILTIN_NORMW      =    4,\n-  ARC_BUILTIN_SWAP       =    5,\n-  ARC_BUILTIN_BRK        =    6,\n-  ARC_BUILTIN_DIVAW      =    7,\n-  ARC_BUILTIN_EX         =    8,\n-  ARC_BUILTIN_MUL64      =    9,\n-  ARC_BUILTIN_MULU64     =   10,\n-  ARC_BUILTIN_RTIE       =   11,\n-  ARC_BUILTIN_SYNC       =   12,\n-  ARC_BUILTIN_CORE_READ  =   13,\n-  ARC_BUILTIN_CORE_WRITE =   14,\n-  ARC_BUILTIN_FLAG       =   15,\n-  ARC_BUILTIN_LR         =   16,\n-  ARC_BUILTIN_SR         =   17,\n-  ARC_BUILTIN_SLEEP      =   18,\n-  ARC_BUILTIN_SWI        =   19,\n-  ARC_BUILTIN_TRAP_S     =   20,\n-  ARC_BUILTIN_UNIMP_S    =   21,\n-  ARC_BUILTIN_ALIGNED    =   22,\n-\n-  /* Sentinel to mark start of simd builtins.  */\n-  ARC_SIMD_BUILTIN_BEGIN      = 1000,\n-\n-  ARC_SIMD_BUILTIN_VADDAW     = 1001,\n-  ARC_SIMD_BUILTIN_VADDW      = 1002,\n-  ARC_SIMD_BUILTIN_VAVB       = 1003,\n-  ARC_SIMD_BUILTIN_VAVRB      = 1004,\n-  ARC_SIMD_BUILTIN_VDIFAW     = 1005,\n-  ARC_SIMD_BUILTIN_VDIFW      = 1006,\n-  ARC_SIMD_BUILTIN_VMAXAW     = 1007,\n-  ARC_SIMD_BUILTIN_VMAXW      = 1008,\n-  ARC_SIMD_BUILTIN_VMINAW     = 1009,\n-  ARC_SIMD_BUILTIN_VMINW      = 1010,\n-  ARC_SIMD_BUILTIN_VMULAW     = 1011,\n-  ARC_SIMD_BUILTIN_VMULFAW    = 1012,\n-  ARC_SIMD_BUILTIN_VMULFW     = 1013,\n-  ARC_SIMD_BUILTIN_VMULW      = 1014,\n-  ARC_SIMD_BUILTIN_VSUBAW     = 1015,\n-  ARC_SIMD_BUILTIN_VSUBW      = 1016,\n-  ARC_SIMD_BUILTIN_VSUMMW     = 1017,\n-  ARC_SIMD_BUILTIN_VAND       = 1018,\n-  ARC_SIMD_BUILTIN_VANDAW     = 1019,\n-  ARC_SIMD_BUILTIN_VBIC       = 1020,\n-  ARC_SIMD_BUILTIN_VBICAW     = 1021,\n-  ARC_SIMD_BUILTIN_VOR        = 1022,\n-  ARC_SIMD_BUILTIN_VXOR       = 1023,\n-  ARC_SIMD_BUILTIN_VXORAW     = 1024,\n-  ARC_SIMD_BUILTIN_VEQW       = 1025,\n-  ARC_SIMD_BUILTIN_VLEW       = 1026,\n-  ARC_SIMD_BUILTIN_VLTW       = 1027,\n-  ARC_SIMD_BUILTIN_VNEW       = 1028,\n-  ARC_SIMD_BUILTIN_VMR1AW     = 1029,\n-  ARC_SIMD_BUILTIN_VMR1W      = 1030,\n-  ARC_SIMD_BUILTIN_VMR2AW     = 1031,\n-  ARC_SIMD_BUILTIN_VMR2W      = 1032,\n-  ARC_SIMD_BUILTIN_VMR3AW     = 1033,\n-  ARC_SIMD_BUILTIN_VMR3W      = 1034,\n-  ARC_SIMD_BUILTIN_VMR4AW     = 1035,\n-  ARC_SIMD_BUILTIN_VMR4W      = 1036,\n-  ARC_SIMD_BUILTIN_VMR5AW     = 1037,\n-  ARC_SIMD_BUILTIN_VMR5W      = 1038,\n-  ARC_SIMD_BUILTIN_VMR6AW     = 1039,\n-  ARC_SIMD_BUILTIN_VMR6W      = 1040,\n-  ARC_SIMD_BUILTIN_VMR7AW     = 1041,\n-  ARC_SIMD_BUILTIN_VMR7W      = 1042,\n-  ARC_SIMD_BUILTIN_VMRB       = 1043,\n-  ARC_SIMD_BUILTIN_VH264F     = 1044,\n-  ARC_SIMD_BUILTIN_VH264FT    = 1045,\n-  ARC_SIMD_BUILTIN_VH264FW    = 1046,\n-  ARC_SIMD_BUILTIN_VVC1F      = 1047,\n-  ARC_SIMD_BUILTIN_VVC1FT     = 1048,\n-\n-  /* Va, Vb, rlimm instructions.  */\n-  ARC_SIMD_BUILTIN_VBADDW     = 1050,\n-  ARC_SIMD_BUILTIN_VBMAXW     = 1051,\n-  ARC_SIMD_BUILTIN_VBMINW     = 1052,\n-  ARC_SIMD_BUILTIN_VBMULAW    = 1053,\n-  ARC_SIMD_BUILTIN_VBMULFW    = 1054,\n-  ARC_SIMD_BUILTIN_VBMULW     = 1055,\n-  ARC_SIMD_BUILTIN_VBRSUBW    = 1056,\n-  ARC_SIMD_BUILTIN_VBSUBW     = 1057,\n-\n-  /* Va, Vb, Ic instructions.  */\n-  ARC_SIMD_BUILTIN_VASRW      = 1060,\n-  ARC_SIMD_BUILTIN_VSR8       = 1061,\n-  ARC_SIMD_BUILTIN_VSR8AW     = 1062,\n-\n-  /* Va, Vb, u6 instructions.  */\n-  ARC_SIMD_BUILTIN_VASRRWi    = 1065,\n-  ARC_SIMD_BUILTIN_VASRSRWi   = 1066,\n-  ARC_SIMD_BUILTIN_VASRWi     = 1067,\n-  ARC_SIMD_BUILTIN_VASRPWBi   = 1068,\n-  ARC_SIMD_BUILTIN_VASRRPWBi  = 1069,\n-  ARC_SIMD_BUILTIN_VSR8AWi    = 1070,\n-  ARC_SIMD_BUILTIN_VSR8i      = 1071,\n-\n-  /* Va, Vb, u8 (simm) instructions.  */\n-  ARC_SIMD_BUILTIN_VMVAW      = 1075,\n-  ARC_SIMD_BUILTIN_VMVW       = 1076,\n-  ARC_SIMD_BUILTIN_VMVZW      = 1077,\n-  ARC_SIMD_BUILTIN_VD6TAPF    = 1078,\n-\n-  /* Va, rlimm, u8 (simm) instructions.  */\n-  ARC_SIMD_BUILTIN_VMOVAW     = 1080,\n-  ARC_SIMD_BUILTIN_VMOVW      = 1081,\n-  ARC_SIMD_BUILTIN_VMOVZW     = 1082,\n-\n-  /* Va, Vb instructions.  */\n-  ARC_SIMD_BUILTIN_VABSAW     = 1085,\n-  ARC_SIMD_BUILTIN_VABSW      = 1086,\n-  ARC_SIMD_BUILTIN_VADDSUW    = 1087,\n-  ARC_SIMD_BUILTIN_VSIGNW     = 1088,\n-  ARC_SIMD_BUILTIN_VEXCH1     = 1089,\n-  ARC_SIMD_BUILTIN_VEXCH2     = 1090,\n-  ARC_SIMD_BUILTIN_VEXCH4     = 1091,\n-  ARC_SIMD_BUILTIN_VUPBAW     = 1092,\n-  ARC_SIMD_BUILTIN_VUPBW      = 1093,\n-  ARC_SIMD_BUILTIN_VUPSBAW    = 1094,\n-  ARC_SIMD_BUILTIN_VUPSBW     = 1095,\n-\n-  ARC_SIMD_BUILTIN_VDIRUN     = 1100,\n-  ARC_SIMD_BUILTIN_VDORUN     = 1101,\n-  ARC_SIMD_BUILTIN_VDIWR      = 1102,\n-  ARC_SIMD_BUILTIN_VDOWR      = 1103,\n-\n-  ARC_SIMD_BUILTIN_VREC       = 1105,\n-  ARC_SIMD_BUILTIN_VRUN       = 1106,\n-  ARC_SIMD_BUILTIN_VRECRUN    = 1107,\n-  ARC_SIMD_BUILTIN_VENDREC    = 1108,\n-\n-  ARC_SIMD_BUILTIN_VLD32WH    = 1110,\n-  ARC_SIMD_BUILTIN_VLD32WL    = 1111,\n-  ARC_SIMD_BUILTIN_VLD64      = 1112,\n-  ARC_SIMD_BUILTIN_VLD32      = 1113,\n-  ARC_SIMD_BUILTIN_VLD64W     = 1114,\n-  ARC_SIMD_BUILTIN_VLD128     = 1115,\n-  ARC_SIMD_BUILTIN_VST128     = 1116,\n-  ARC_SIMD_BUILTIN_VST64      = 1117,\n-\n-  ARC_SIMD_BUILTIN_VST16_N    = 1120,\n-  ARC_SIMD_BUILTIN_VST32_N    = 1121,\n-\n-  ARC_SIMD_BUILTIN_VINTI      = 1201,\n-\n-  ARC_SIMD_BUILTIN_END\n-};\n-\n /* A nop is needed between a 4 byte insn that sets the condition codes and\n    a branch that uses them (the same isn't true for an 8 byte insn that sets\n    the condition codes).  Set by arc_ccfsm_advance.  Used by\n@@ -385,7 +227,6 @@ static bool arc_in_small_data_p (const_tree);\n \n static void arc_init_reg_tables (void);\n static bool arc_return_in_memory (const_tree, const_tree);\n-static void arc_init_simd_builtins (void);\n static bool arc_vector_mode_supported_p (machine_mode);\n \n static bool arc_can_use_doloop_p (const widest_int &, const widest_int &,\n@@ -456,6 +297,9 @@ static void arc_finalize_pic (void);\n #undef  TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN arc_expand_builtin\n \n+#undef  TARGET_BUILTIN_DECL\n+#define TARGET_BUILTIN_DECL arc_builtin_decl\n+\n #undef  TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK arc_output_mi_thunk\n \n@@ -5241,91 +5085,225 @@ arc_cannot_force_const_mem (machine_mode mode, rtx x)\n   return !arc_legitimate_constant_p (mode, x);\n }\n \n+/* IDs for all the ARC builtins.  */\n+\n+enum arc_builtin_id\n+  {\n+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)\t\\\n+    ARC_BUILTIN_ ## NAME,\n+#include \"builtins.def\"\n+#undef DEF_BUILTIN\n+\n+    ARC_BUILTIN_COUNT\n+  };\n+\n+struct GTY(()) arc_builtin_description\n+{\n+  enum insn_code icode;\n+  int n_args;\n+  tree fndecl;\n+};\n+\n+static GTY(()) struct arc_builtin_description\n+arc_bdesc[ARC_BUILTIN_COUNT] =\n+{\n+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)\t\t\\\n+  { (enum insn_code) CODE_FOR_ ## ICODE, N_ARGS, NULL_TREE },\n+#include \"builtins.def\"\n+#undef DEF_BUILTIN\n+};\n+\n+/* Transform UP into lowercase and write the result to LO.\n+   You must provide enough space for LO.  Return LO.  */\n+\n+static char*\n+arc_tolower (char *lo, const char *up)\n+{\n+  char *lo0 = lo;\n+\n+  for (; *up; up++, lo++)\n+    *lo = TOLOWER (*up);\n+\n+  *lo = '\\0';\n+\n+  return lo0;\n+}\n+\n+/* Implement `TARGET_BUILTIN_DECL'.  */\n \n-/* Generic function to define a builtin.  */\n-#define def_mbuiltin(MASK, NAME, TYPE, CODE)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-       if (MASK)\t\t\t\t\t\t\t\\\n-\t  add_builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL, NULL_TREE); \\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+static tree\n+arc_builtin_decl (unsigned id, bool initialize_p ATTRIBUTE_UNUSED)\n+{\n+  if (id < ARC_BUILTIN_COUNT)\n+    return arc_bdesc[id].fndecl;\n \n+  return error_mark_node;\n+}\n \n static void\n arc_init_builtins (void)\n {\n-    tree endlink = void_list_node;\n-\n-    tree void_ftype_void\n-\t= build_function_type (void_type_node,\n-\t\t\t       endlink);\n-\n-    tree int_ftype_int\n-\t= build_function_type (integer_type_node,\n-\t\t\t   tree_cons (NULL_TREE, integer_type_node, endlink));\n-\n-    tree pcvoid_type_node\n-\t= build_pointer_type (build_qualified_type (void_type_node, TYPE_QUAL_CONST));\n-    tree int_ftype_pcvoid_int\n-\t= build_function_type (integer_type_node,\n-\t\t\t   tree_cons (NULL_TREE, pcvoid_type_node,\n-\t\t\t       tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t    endlink)));\n-\n-    tree int_ftype_short_int\n-\t= build_function_type (integer_type_node,\n-\t\t\t       tree_cons (NULL_TREE, short_integer_type_node, endlink));\n-\n-    tree void_ftype_int_int\n-\t= build_function_type (void_type_node,\n-\t\t\t       tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, integer_type_node, endlink)));\n-    tree void_ftype_usint_usint\n-\t= build_function_type (void_type_node,\n-\t\t\t       tree_cons (NULL_TREE, long_unsigned_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, long_unsigned_type_node, endlink)));\n-\n-    tree int_ftype_int_int\n-\t= build_function_type (integer_type_node,\n-\t\t\t       tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE, integer_type_node, endlink)));\n-\n-    tree usint_ftype_usint\n-\t= build_function_type (long_unsigned_type_node,\n-\t\t\t   tree_cons (NULL_TREE, long_unsigned_type_node, endlink));\n-\n-    tree void_ftype_usint\n-\t= build_function_type (void_type_node,\n-\t\t\t   tree_cons (NULL_TREE, long_unsigned_type_node, endlink));\n-\n-    /* Add the builtins.  */\n-    def_mbuiltin (1,\"__builtin_arc_nop\", void_ftype_void, ARC_BUILTIN_NOP);\n-    def_mbuiltin (TARGET_NORM, \"__builtin_arc_norm\", int_ftype_int, ARC_BUILTIN_NORM);\n-    def_mbuiltin (TARGET_NORM, \"__builtin_arc_normw\", int_ftype_short_int, ARC_BUILTIN_NORMW);\n-    def_mbuiltin (TARGET_SWAP, \"__builtin_arc_swap\", int_ftype_int, ARC_BUILTIN_SWAP);\n-    def_mbuiltin (TARGET_MUL64_SET,\"__builtin_arc_mul64\", void_ftype_int_int, ARC_BUILTIN_MUL64);\n-    def_mbuiltin (TARGET_MUL64_SET,\"__builtin_arc_mulu64\", void_ftype_usint_usint, ARC_BUILTIN_MULU64);\n-    def_mbuiltin (1,\"__builtin_arc_rtie\", void_ftype_void, ARC_BUILTIN_RTIE);\n-    def_mbuiltin (TARGET_ARC700,\"__builtin_arc_sync\", void_ftype_void, ARC_BUILTIN_SYNC);\n-    def_mbuiltin ((TARGET_EA_SET),\"__builtin_arc_divaw\", int_ftype_int_int, ARC_BUILTIN_DIVAW);\n-    def_mbuiltin (1,\"__builtin_arc_brk\", void_ftype_void, ARC_BUILTIN_BRK);\n-    def_mbuiltin (1,\"__builtin_arc_flag\", void_ftype_usint, ARC_BUILTIN_FLAG);\n-    def_mbuiltin (1,\"__builtin_arc_sleep\", void_ftype_usint, ARC_BUILTIN_SLEEP);\n-    def_mbuiltin (1,\"__builtin_arc_swi\", void_ftype_void, ARC_BUILTIN_SWI);\n-    def_mbuiltin (1,\"__builtin_arc_core_read\", usint_ftype_usint, ARC_BUILTIN_CORE_READ);\n-    def_mbuiltin (1,\"__builtin_arc_core_write\", void_ftype_usint_usint, ARC_BUILTIN_CORE_WRITE);\n-    def_mbuiltin (1,\"__builtin_arc_lr\", usint_ftype_usint, ARC_BUILTIN_LR);\n-    def_mbuiltin (1,\"__builtin_arc_sr\", void_ftype_usint_usint, ARC_BUILTIN_SR);\n-    def_mbuiltin (TARGET_ARC700,\"__builtin_arc_trap_s\", void_ftype_usint, ARC_BUILTIN_TRAP_S);\n-    def_mbuiltin (TARGET_ARC700,\"__builtin_arc_unimp_s\", void_ftype_void, ARC_BUILTIN_UNIMP_S);\n-    def_mbuiltin (1,\"__builtin_arc_aligned\", int_ftype_pcvoid_int, ARC_BUILTIN_ALIGNED);\n-\n-    if (TARGET_SIMD_SET)\n-      arc_init_simd_builtins ();\n-}\n-\n-static rtx arc_expand_simd_builtin (tree, rtx, rtx, machine_mode, int);\n+  tree pcvoid_type_node\n+    = build_pointer_type (build_qualified_type (void_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST));\n+  tree V8HI_type_node = build_vector_type_for_mode (intHI_type_node,\n+\t\t\t\t\t\t    V8HImode);\n+\n+  tree void_ftype_void\n+    = build_function_type_list (void_type_node, NULL_TREE);\n+  tree int_ftype_int\n+    = build_function_type_list (integer_type_node, integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree int_ftype_pcvoid_int\n+    = build_function_type_list (integer_type_node, pcvoid_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree void_ftype_usint_usint\n+    = build_function_type_list (void_type_node, long_unsigned_type_node,\n+\t\t\t\tlong_unsigned_type_node, NULL_TREE);\n+  tree int_ftype_int_int\n+    = build_function_type_list (integer_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree usint_ftype_usint\n+    = build_function_type_list  (long_unsigned_type_node,\n+\t\t\t\t long_unsigned_type_node, NULL_TREE);\n+  tree void_ftype_usint\n+    = build_function_type_list (void_type_node, long_unsigned_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree int_ftype_void\n+    = build_function_type_list (integer_type_node, void_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree void_ftype_int\n+    = build_function_type_list (void_type_node, integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree int_ftype_short\n+    = build_function_type_list (integer_type_node, short_integer_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  /* Old ARC SIMD types.  */\n+  tree v8hi_ftype_v8hi_v8hi\n+    = build_function_type_list (V8HI_type_node, V8HI_type_node,\n+\t\t\t\tV8HI_type_node, NULL_TREE);\n+  tree v8hi_ftype_v8hi_int\n+    = build_function_type_list (V8HI_type_node, V8HI_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree v8hi_ftype_v8hi_int_int\n+    = build_function_type_list (V8HI_type_node, V8HI_type_node,\n+\t\t\t\tinteger_type_node, integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree void_ftype_v8hi_int_int\n+    = build_function_type_list (void_type_node, V8HI_type_node,\n+\t\t\t\tinteger_type_node, integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree void_ftype_v8hi_int_int_int\n+    = build_function_type_list (void_type_node, V8HI_type_node,\n+\t\t\t\tinteger_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree v8hi_ftype_int_int\n+    = build_function_type_list (V8HI_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree void_ftype_int_int\n+    = build_function_type_list (void_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree v8hi_ftype_v8hi\n+    = build_function_type_list (V8HI_type_node, V8HI_type_node,\n+\t\t\t\tNULL_TREE);\n+\n+  /* Add the builtins.  */\n+#define DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    int id = ARC_BUILTIN_ ## NAME;\t\t\t\t\t\\\n+    const char *Name = \"__builtin_arc_\" #NAME;\t\t\t\t\\\n+    char *name = (char*) alloca (1 + strlen (Name));\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    gcc_assert (id < ARC_BUILTIN_COUNT);\t\t\t\t\\\n+    if (MASK)\t\t\t\t\t\t\t\t\\\n+      arc_bdesc[id].fndecl\t\t\t\t\t\t\\\n+\t= add_builtin_function (arc_tolower(name, Name), TYPE, id,\t\\\n+\t\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\t\t\\\n+  }\n+#include \"builtins.def\"\n+#undef DEF_BUILTIN\n+}\n+\n+/* Helper to expand __builtin_arc_aligned (void* val, int\n+  alignval).  */\n+\n+static rtx\n+arc_expand_builtin_aligned (tree exp)\n+{\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  fold (arg1);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+\n+  if (!CONST_INT_P (op1))\n+    {\n+      /* If we can't fold the alignment to a constant integer\n+\t whilst optimizing, this is probably a user error.  */\n+      if (optimize)\n+\twarning (0, \"__builtin_arc_aligned with non-constant alignment\");\n+    }\n+  else\n+    {\n+      HOST_WIDE_INT alignTest = INTVAL (op1);\n+      /* Check alignTest is positive, and a power of two.  */\n+      if (alignTest <= 0 || alignTest != (alignTest & -alignTest))\n+\t{\n+\t  error (\"invalid alignment value for __builtin_arc_aligned\");\n+\t  return NULL_RTX;\n+\t}\n+\n+      if (CONST_INT_P (op0))\n+\t{\n+\t  HOST_WIDE_INT pnt = INTVAL (op0);\n+\n+\t  if ((pnt & (alignTest - 1)) == 0)\n+\t    return const1_rtx;\n+\t}\n+      else\n+\t{\n+\t  unsigned  align = get_pointer_alignment (arg0);\n+\t  unsigned  numBits = alignTest * BITS_PER_UNIT;\n+\n+\t  if (align && align >= numBits)\n+\t    return const1_rtx;\n+\t  /* Another attempt to ascertain alignment.  Check the type\n+\t     we are pointing to.  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t      && TYPE_ALIGN (TREE_TYPE (TREE_TYPE (arg0))) >= numBits)\n+\t    return const1_rtx;\n+\t}\n+    }\n+\n+  /* Default to false.  */\n+  return const0_rtx;\n+}\n+\n+/* Helper arc_expand_builtin, generates a pattern for the given icode\n+   and arguments.  */\n+\n+static rtx_insn *\n+apply_GEN_FCN (enum insn_code icode, rtx *arg)\n+{\n+  switch (insn_data[icode].n_generator_args)\n+    {\n+    case 0:\n+      return GEN_FCN (icode) ();\n+    case 1:\n+      return GEN_FCN (icode) (arg[0]);\n+    case 2:\n+      return GEN_FCN (icode) (arg[0], arg[1]);\n+    case 3:\n+      return GEN_FCN (icode) (arg[0], arg[1], arg[2]);\n+    case 4:\n+      return GEN_FCN (icode) (arg[0], arg[1], arg[2], arg[3]);\n+    case 5:\n+      return GEN_FCN (icode) (arg[0], arg[1], arg[2], arg[3], arg[4]);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n \n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -5336,314 +5314,396 @@ static rtx arc_expand_simd_builtin (tree, rtx, rtx, machine_mode, int);\n static rtx\n arc_expand_builtin (tree exp,\n \t\t    rtx target,\n-\t\t    rtx subtarget,\n-\t\t    machine_mode mode,\n-\t\t    int ignore)\n-{\n-  tree              fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-  tree              arg0;\n-  tree              arg1;\n-  rtx               op0;\n-  rtx               op1;\n-  int               fcode = DECL_FUNCTION_CODE (fndecl);\n-  int               icode;\n+\t\t    rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t    machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    int ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  unsigned int id = DECL_FUNCTION_CODE (fndecl);\n+  const struct arc_builtin_description *d = &arc_bdesc[id];\n+  int i, j, n_args = call_expr_nargs (exp);\n+  rtx pat = NULL_RTX;\n+  rtx xop[5];\n+  enum insn_code icode = d->icode;\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  int nonvoid;\n+  tree arg0;\n+  tree arg1;\n+  tree arg2;\n+  tree arg3;\n+  rtx op0;\n+  rtx op1;\n+  rtx op2;\n+  rtx op3;\n+  rtx op4;\n   machine_mode mode0;\n   machine_mode mode1;\n+  machine_mode mode2;\n+  machine_mode mode3;\n+  machine_mode mode4;\n \n-  if (fcode > ARC_SIMD_BUILTIN_BEGIN && fcode < ARC_SIMD_BUILTIN_END)\n-    return arc_expand_simd_builtin (exp, target, subtarget, mode, ignore);\n+  if (id >= ARC_BUILTIN_COUNT)\n+    internal_error (\"bad builtin fcode\");\n \n-  switch (fcode)\n+  /* 1st part: Expand special builtins.  */\n+  switch (id)\n     {\n     case ARC_BUILTIN_NOP:\n-      emit_insn (gen_nop ());\n+      emit_insn (gen_nopv ());\n       return NULL_RTX;\n \n-    case ARC_BUILTIN_NORM:\n-      icode = CODE_FOR_clrsbsi2;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      target = gen_reg_rtx (SImode);\n+    case ARC_BUILTIN_RTIE:\n+    case ARC_BUILTIN_SYNC:\n+    case ARC_BUILTIN_BRK:\n+    case ARC_BUILTIN_SWI:\n+    case ARC_BUILTIN_UNIMP_S:\n+      gcc_assert (icode != 0);\n+      emit_insn (GEN_FCN (icode) (const1_rtx));\n+      return NULL_RTX;\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n+    case ARC_BUILTIN_ALIGNED:\n+      return arc_expand_builtin_aligned (exp);\n \n-      emit_insn (gen_clrsbsi2 (target, op0));\n+    case ARC_BUILTIN_CLRI:\n+      target = gen_reg_rtx (SImode);\n+      emit_insn (gen_clri (target, const1_rtx));\n       return target;\n \n-    case ARC_BUILTIN_NORMW:\n-\n-      /* FIXME : This should all be HImode, not SImode.  */\n-      icode = CODE_FOR_normw;\n+    case ARC_BUILTIN_TRAP_S:\n+    case ARC_BUILTIN_SLEEP:\n       arg0 = CALL_EXPR_ARG (exp, 0);\n+      fold (arg0);\n       op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      target = gen_reg_rtx (SImode);\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, convert_to_mode (mode0, op0,0));\n \n-      emit_insn (gen_normw (target, op0));\n-      return target;\n+      if  (!CONST_INT_P (op0) || !satisfies_constraint_L (op0))\n+\t{\n+\t  error (\"builtin operand should be an unsigned 6-bit value\");\n+\t  return NULL_RTX;\n+\t}\n+      gcc_assert (icode != 0);\n+      emit_insn (GEN_FCN (icode) (op0));\n+      return NULL_RTX;\n \n-    case ARC_BUILTIN_MUL64:\n-      icode = CODE_FOR_mul64;\n+    case ARC_BUILTIN_VDORUN:\n+    case ARC_BUILTIN_VDIRUN:\n       arg0 = CALL_EXPR_ARG (exp, 0);\n       arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n \n-      mode0 =  insn_data[icode].operand[0].mode;\n-      mode1 =  insn_data[icode].operand[1].mode;\n+      target = gen_rtx_REG (SImode, (id == ARC_BUILTIN_VDIRUN) ? 131 : 139);\n+\n+      mode0 =  insn_data[icode].operand[1].mode;\n+      mode1 =  insn_data[icode].operand[2].mode;\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n+      if (!insn_data[icode].operand[1].predicate (op0, mode0))\n \top0 = copy_to_mode_reg (mode0, op0);\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n+      if (!insn_data[icode].operand[2].predicate (op1, mode1))\n \top1 = copy_to_mode_reg (mode1, op1);\n \n-      emit_insn (gen_mul64 (op0,op1));\n+      pat = GEN_FCN (icode) (target, op0, op1);\n+      if (!pat)\n+\treturn NULL_RTX;\n+\n+      emit_insn (pat);\n       return NULL_RTX;\n \n-    case ARC_BUILTIN_MULU64:\n-      icode = CODE_FOR_mulu64;\n+    case ARC_BUILTIN_VDIWR:\n+    case ARC_BUILTIN_VDOWR:\n       arg0 = CALL_EXPR_ARG (exp, 0);\n       arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n+\n+      if (!CONST_INT_P (op0)\n+\t  || !(UNSIGNED_INT3 (INTVAL (op0))))\n+\terror (\"operand 1 should be an unsigned 3-bit immediate\");\n \n-      mode0 =  insn_data[icode].operand[0].mode;\n       mode1 =  insn_data[icode].operand[1].mode;\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n+      if (icode == CODE_FOR_vdiwr_insn)\n+\ttarget = gen_rtx_REG (SImode,\n+\t\t\t      ARC_FIRST_SIMD_DMA_CONFIG_IN_REG + INTVAL (op0));\n+      else if (icode == CODE_FOR_vdowr_insn)\n+\ttarget = gen_rtx_REG (SImode,\n+\t\t\t      ARC_FIRST_SIMD_DMA_CONFIG_OUT_REG + INTVAL (op0));\n+      else\n+\tgcc_unreachable ();\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op1, mode1))\n+      if (!insn_data[icode].operand[2].predicate (op1, mode1))\n \top1 = copy_to_mode_reg (mode1, op1);\n \n-      emit_insn (gen_mulu64 (op0,op1));\n-      return NULL_RTX;\n-\n-    case ARC_BUILTIN_RTIE:\n-      icode = CODE_FOR_rtie;\n-      emit_insn (gen_rtie (const1_rtx));\n-      return NULL_RTX;\n+      pat = GEN_FCN (icode) (target, op1);\n+      if (!pat)\n+\treturn NULL_RTX;\n \n-    case ARC_BUILTIN_SYNC:\n-      icode = CODE_FOR_sync;\n-      emit_insn (gen_sync (const1_rtx));\n+      emit_insn (pat);\n       return NULL_RTX;\n \n-    case ARC_BUILTIN_SWAP:\n-      icode = CODE_FOR_swap;\n+    case ARC_BUILTIN_VASRW:\n+    case ARC_BUILTIN_VSR8:\n+    case ARC_BUILTIN_VSR8AW:\n       arg0 = CALL_EXPR_ARG (exp, 0);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      arg1 = CALL_EXPR_ARG (exp, 1);\n+      op0 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n+      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op2 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\n+\n+      target = gen_reg_rtx (V8HImode);\n       mode0 =  insn_data[icode].operand[1].mode;\n-      target = gen_reg_rtx (SImode);\n+      mode1 =  insn_data[icode].operand[2].mode;\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+      if (!insn_data[icode].operand[1].predicate (op0, mode0))\n \top0 = copy_to_mode_reg (mode0, op0);\n \n-      emit_insn (gen_swap (target, op0));\n-      return target;\n+      if ((!insn_data[icode].operand[2].predicate (op1, mode1))\n+\t  || !(UNSIGNED_INT3 (INTVAL (op1))))\n+\terror (\"operand 2 should be an unsigned 3-bit value (I0-I7)\");\n \n-    case ARC_BUILTIN_DIVAW:\n-      icode = CODE_FOR_divaw;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n+      if (!pat)\n+\treturn NULL_RTX;\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      target = gen_reg_rtx (SImode);\n+      emit_insn (pat);\n+      return target;\n \n-      mode0 =  insn_data[icode].operand[0].mode;\n-      mode1 =  insn_data[icode].operand[1].mode;\n+    case ARC_BUILTIN_VLD32WH:\n+    case ARC_BUILTIN_VLD32WL:\n+    case ARC_BUILTIN_VLD64:\n+    case ARC_BUILTIN_VLD32:\n+      rtx src_vreg;\n+      icode = d->icode;\n+      arg0 = CALL_EXPR_ARG (exp, 0); /* source vreg.  */\n+      arg1 = CALL_EXPR_ARG (exp, 1); /* [I]0-7.  */\n+      arg2 = CALL_EXPR_ARG (exp, 2); /* u8.  */\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n+      src_vreg = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n+      op0 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op1 = expand_expr (arg2, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op2 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\n \n-      if (! (*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n+      /* target <- src vreg.  */\n+      emit_insn (gen_move_insn (target, src_vreg));\n \n-      emit_insn (gen_divaw (target, op0, op1));\n-      return target;\n+      /* target <- vec_concat: target, mem (Ib, u8).  */\n+      mode0 =  insn_data[icode].operand[3].mode;\n+      mode1 =  insn_data[icode].operand[1].mode;\n \n-    case ARC_BUILTIN_BRK:\n-      icode = CODE_FOR_brk;\n-      emit_insn (gen_brk (const1_rtx));\n-      return NULL_RTX;\n+      if ((!insn_data[icode].operand[3].predicate (op0, mode0))\n+\t  || !(UNSIGNED_INT3 (INTVAL (op0))))\n+\terror (\"operand 1 should be an unsigned 3-bit value (I0-I7)\");\n \n-    case ARC_BUILTIN_SLEEP:\n-      icode = CODE_FOR_sleep;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n+      if ((!insn_data[icode].operand[1].predicate (op1, mode1))\n+\t  || !(UNSIGNED_INT8 (INTVAL (op1))))\n+\terror (\"operand 2 should be an unsigned 8-bit value\");\n \n-      fold (arg0);\n+      pat = GEN_FCN (icode) (target, op1, op2, op0);\n+      if (!pat)\n+\treturn NULL_RTX;\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 = insn_data[icode].operand[1].mode;\n+      emit_insn (pat);\n+      return target;\n \n-      emit_insn (gen_sleep (op0));\n-      return NULL_RTX;\n+    case ARC_BUILTIN_VLD64W:\n+    case ARC_BUILTIN_VLD128:\n+      arg0 = CALL_EXPR_ARG (exp, 0); /* dest vreg.  */\n+      arg1 = CALL_EXPR_ARG (exp, 1); /* [I]0-7.  */\n \n-    case ARC_BUILTIN_SWI:\n-      icode = CODE_FOR_swi;\n-      emit_insn (gen_swi (const1_rtx));\n-      return NULL_RTX;\n+      op0 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\n+      op1 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op2 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n \n-    case ARC_BUILTIN_FLAG:\n-      icode = CODE_FOR_flag;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 =  insn_data[icode].operand[0].mode;\n+      /* target <- src vreg.  */\n+      target = gen_reg_rtx (V8HImode);\n \n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n+      /* target <- vec_concat: target, mem (Ib, u8).  */\n+      mode0 =  insn_data[icode].operand[1].mode;\n+      mode1 =  insn_data[icode].operand[2].mode;\n+      mode2 =  insn_data[icode].operand[3].mode;\n \n-      emit_insn (gen_flag (op0));\n-      return NULL_RTX;\n+      if ((!insn_data[icode].operand[2].predicate (op1, mode1))\n+\t  || !(UNSIGNED_INT3 (INTVAL (op1))))\n+\terror (\"operand 1 should be an unsigned 3-bit value (I0-I7)\");\n \n-    case ARC_BUILTIN_CORE_READ:\n-      icode = CODE_FOR_core_read;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      target = gen_reg_rtx (SImode);\n+      if ((!insn_data[icode].operand[3].predicate (op2, mode2))\n+\t  || !(UNSIGNED_INT8 (INTVAL (op2))))\n+\terror (\"operand 2 should be an unsigned 8-bit value\");\n \n-      fold (arg0);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 = insn_data[icode].operand[1].mode;\n+      if (!pat)\n+\treturn NULL_RTX;\n \n-      emit_insn (gen_core_read (target, op0));\n+      emit_insn (pat);\n       return target;\n \n-    case ARC_BUILTIN_CORE_WRITE:\n-      icode = CODE_FOR_core_write;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-\n-      fold (arg1);\n+    case ARC_BUILTIN_VST128:\n+    case ARC_BUILTIN_VST64:\n+      arg0 = CALL_EXPR_ARG (exp, 0); /* src vreg.  */\n+      arg1 = CALL_EXPR_ARG (exp, 1); /* [I]0-7.  */\n+      arg2 = CALL_EXPR_ARG (exp, 2); /* u8.  */\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      op0 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\n+      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op2 = expand_expr (arg2, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op3 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n \n       mode0 = insn_data[icode].operand[0].mode;\n       mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+      mode3 = insn_data[icode].operand[3].mode;\n \n-      emit_insn (gen_core_write (op0, op1));\n-      return NULL_RTX;\n-\n-    case ARC_BUILTIN_LR:\n-      icode = CODE_FOR_lr;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      target = gen_reg_rtx (SImode);\n+      if ((!insn_data[icode].operand[1].predicate (op1, mode1))\n+\t  || !(UNSIGNED_INT3 (INTVAL (op1))))\n+\terror (\"operand 2 should be an unsigned 3-bit value (I0-I7)\");\n \n-      fold (arg0);\n+      if ((!insn_data[icode].operand[2].predicate (op2, mode2))\n+\t  || !(UNSIGNED_INT8 (INTVAL (op2))))\n+\terror (\"operand 3 should be an unsigned 8-bit value\");\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 = insn_data[icode].operand[1].mode;\n+      if (!insn_data[icode].operand[3].predicate (op3, mode3))\n+\top3 = copy_to_mode_reg (mode3, op3);\n \n-      emit_insn (gen_lr (target, op0));\n-      return target;\n+      pat = GEN_FCN (icode) (op0, op1, op2, op3);\n+      if (!pat)\n+\treturn NULL_RTX;\n \n-    case ARC_BUILTIN_SR:\n-      icode = CODE_FOR_sr;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n+      emit_insn (pat);\n+      return NULL_RTX;\n \n-      fold (arg1);\n+    case ARC_BUILTIN_VST16_N:\n+    case ARC_BUILTIN_VST32_N:\n+      arg0 = CALL_EXPR_ARG (exp, 0); /* source vreg.  */\n+      arg1 = CALL_EXPR_ARG (exp, 1); /* u3.  */\n+      arg2 = CALL_EXPR_ARG (exp, 2); /* [I]0-7.  */\n+      arg3 = CALL_EXPR_ARG (exp, 3); /* u8.  */\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      op0 = expand_expr (arg3, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op1 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\n+      op2 = expand_expr (arg2, NULL_RTX, SImode, EXPAND_NORMAL);\n+      op3 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n+      op4 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n \n       mode0 = insn_data[icode].operand[0].mode;\n-      mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+      mode3 = insn_data[icode].operand[3].mode;\n+      mode4 = insn_data[icode].operand[4].mode;\n \n-      emit_insn (gen_sr (op0, op1));\n-      return NULL_RTX;\n+      /* Do some correctness checks for the operands.  */\n+      if ((!insn_data[icode].operand[0].predicate (op0, mode0))\n+\t  || !(UNSIGNED_INT8 (INTVAL (op0))))\n+\terror (\"operand 4 should be an unsigned 8-bit value (0-255)\");\n \n-    case ARC_BUILTIN_TRAP_S:\n-      icode = CODE_FOR_trap_s;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n+      if ((!insn_data[icode].operand[2].predicate (op2, mode2))\n+\t  || !(UNSIGNED_INT3 (INTVAL (op2))))\n+\terror (\"operand 3 should be an unsigned 3-bit value (I0-I7)\");\n \n-      fold (arg0);\n+      if (!insn_data[icode].operand[3].predicate (op3, mode3))\n+\top3 = copy_to_mode_reg (mode3, op3);\n \n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      mode0 = insn_data[icode].operand[1].mode;\n+      if ((!insn_data[icode].operand[4].predicate (op4, mode4))\n+\t   || !(UNSIGNED_INT3 (INTVAL (op4))))\n+\terror (\"operand 2 should be an unsigned 3-bit value (subreg 0-7)\");\n+      else if (icode == CODE_FOR_vst32_n_insn\n+\t       && ((INTVAL (op4) % 2) != 0))\n+\terror (\"operand 2 should be an even 3-bit value (subreg 0,2,4,6)\");\n \n-      /* We don't give an error for non-cost values here because\n-\t we still want to allow things to be fixed up by later inlining /\n-\t constant folding / dead code elimination.  */\n-      if  (CONST_INT_P (op0) && !satisfies_constraint_L (op0))\n-\t{\n-\t  /* Keep this message in sync with the one in arc.md:trap_s,\n-\t     because *.md files don't get scanned by exgettext.  */\n-\t  error (\"operand to trap_s should be an unsigned 6-bit value\");\n-\t}\n-      emit_insn (gen_trap_s (op0));\n-      return NULL_RTX;\n+      pat = GEN_FCN (icode) (op0, op1, op2, op3, op4);\n+      if (!pat)\n+\treturn NULL_RTX;\n \n-    case ARC_BUILTIN_UNIMP_S:\n-      icode = CODE_FOR_unimp_s;\n-      emit_insn (gen_unimp_s (const1_rtx));\n+      emit_insn (pat);\n       return NULL_RTX;\n \n-    case ARC_BUILTIN_ALIGNED:\n-      /* __builtin_arc_aligned (void* val, int alignval) */\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      fold (arg1);\n-      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-      target = gen_reg_rtx (SImode);\n+    default:\n+      break;\n+    }\n+\n+  /* 2nd part: Expand regular builtins.  */\n+  if (icode == 0)\n+    internal_error (\"bad builtin fcode\");\n+\n+  nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n+  j = 0;\n \n-      if (!CONST_INT_P (op1))\n+  if (nonvoid)\n+    {\n+      if (target == NULL_RTX\n+\t  || GET_MODE (target) != tmode\n+\t  || !insn_data[icode].operand[0].predicate (target, tmode))\n \t{\n-\t  /* If we can't fold the alignment to a constant integer\n-\t     whilst optimizing, this is probably a user error.  */\n-\t  if (optimize)\n-\t    warning (0, \"__builtin_arc_aligned with non-constant alignment\");\n+\t  target = gen_reg_rtx (tmode);\n \t}\n-      else\n+      xop[j++] = target;\n+    }\n+\n+  gcc_assert (n_args <= 4);\n+  for (i = 0; i < n_args; i++, j++)\n+    {\n+      tree arg = CALL_EXPR_ARG (exp, i);\n+      machine_mode mode = insn_data[icode].operand[j].mode;\n+      rtx op = expand_expr (arg, NULL_RTX, mode, EXPAND_NORMAL);\n+      machine_mode opmode = GET_MODE (op);\n+      char c = insn_data[icode].operand[j].constraint[0];\n+\n+      /* SIMD extension requires exact immediate operand match.  */\n+      if ((id > ARC_BUILTIN_SIMD_BEGIN)\n+\t  && (id < ARC_BUILTIN_SIMD_END)\n+\t  && (c != 'v')\n+\t  && (c != 'r'))\n \t{\n-\t  HOST_WIDE_INT alignTest = INTVAL (op1);\n-\t  /* Check alignTest is positive, and a power of two.  */\n-\t  if (alignTest <= 0 || alignTest != (alignTest & -alignTest))\n+\t  if (!CONST_INT_P (op))\n+\t    error (\"builtin requires an immediate for operand %d\", j);\n+\t  switch (c)\n \t    {\n-\t      error (\"invalid alignment value for __builtin_arc_aligned\");\n-\t      return NULL_RTX;\n+\t    case 'L':\n+\t      if (!satisfies_constraint_L (op))\n+\t\terror (\"operand %d should be a 6 bit unsigned immediate\", j);\n+\t      break;\n+\t    case 'P':\n+\t      if (!satisfies_constraint_P (op))\n+\t\terror (\"operand %d should be a 8 bit unsigned immediate\", j);\n+\t      break;\n+\t    case 'K':\n+\t      if (!satisfies_constraint_K (op))\n+\t\terror (\"operand %d should be a 3 bit unsigned immediate\", j);\n+\t      break;\n+\t    default:\n+\t      error (\"unknown builtin immediate operand type for operand %d\",\n+\t\t     j);\n \t    }\n+\t}\n \n-\t  if (CONST_INT_P (op0))\n-\t    {\n-\t      HOST_WIDE_INT pnt = INTVAL (op0);\n+      if (CONST_INT_P (op))\n+\topmode = mode;\n \n-\t      if ((pnt & (alignTest - 1)) == 0)\n-\t\treturn const1_rtx;\n-\t    }\n-\t  else\n-\t    {\n-\t      unsigned  align = get_pointer_alignment (arg0);\n-\t      unsigned  numBits = alignTest * BITS_PER_UNIT;\n-\n-\t      if (align && align >= numBits)\n-\t\treturn const1_rtx;\n-\t      /* Another attempt to ascertain alignment.  Check the type\n-\t\t we are pointing to.  */\n-\t      if (POINTER_TYPE_P (TREE_TYPE (arg0))\n-\t\t  && TYPE_ALIGN (TREE_TYPE (TREE_TYPE (arg0))) >= numBits)\n-\t\treturn const1_rtx;\n-\t    }\n+      if ((opmode == SImode) && (mode == HImode))\n+\t{\n+\t  opmode = HImode;\n+\t  op = gen_lowpart (HImode, op);\n \t}\n \n-      /* Default to false.  */\n-      return const0_rtx;\n+      /* In case the insn wants input operands in modes different from\n+\t the result, abort.  */\n+      gcc_assert (opmode == mode || opmode == VOIDmode);\n \n-    default:\n-      break;\n+      if (!insn_data[icode].operand[i + nonvoid].predicate (op, mode))\n+\top = copy_to_mode_reg (mode, op);\n+\n+      xop[j] = op;\n     }\n \n-  /* @@@ Should really do something sensible here.  */\n-  return NULL_RTX;\n+  pat = apply_GEN_FCN (icode, xop);\n+  if (pat == NULL_RTX)\n+    return NULL_RTX;\n+\n+  emit_insn (pat);\n+\n+  if (nonvoid)\n+    return target;\n+  else\n+    return const0_rtx;\n }\n \n /* Returns true if the operands[opno] is a valid compile-time constant to be\n@@ -6708,809 +6768,6 @@ arc_asm_output_aligned_decl_local (FILE * stream, tree decl, const char * name,\n     ASM_OUTPUT_SKIP (stream, size);\n }\n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-/* SIMD builtins support.  */\n-enum simd_insn_args_type {\n-  Va_Vb_Vc,\n-  Va_Vb_rlimm,\n-  Va_Vb_Ic,\n-  Va_Vb_u6,\n-  Va_Vb_u8,\n-  Va_rlimm_u8,\n-\n-  Va_Vb,\n-\n-  void_rlimm,\n-  void_u6,\n-\n-  Da_u3_rlimm,\n-  Da_rlimm_rlimm,\n-\n-  Va_Ib_u8,\n-  void_Va_Ib_u8,\n-\n-  Va_Vb_Ic_u8,\n-  void_Va_u3_Ib_u8\n-};\n-\n-struct builtin_description\n-{\n-  enum simd_insn_args_type args_type;\n-  const enum insn_code     icode;\n-  const char * const       name;\n-  const enum arc_builtins  code;\n-};\n-\n-static const struct builtin_description arc_simd_builtin_desc_list[] =\n-{\n-  /* VVV builtins go first.  */\n-#define SIMD_BUILTIN(type, code, string, builtin) \\\n-  { type,CODE_FOR_##code, \"__builtin_arc_\" string, \\\n-    ARC_SIMD_BUILTIN_##builtin },\n-\n-  SIMD_BUILTIN (Va_Vb_Vc,    vaddaw_insn,   \"vaddaw\",     VADDAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vaddw_insn,    \"vaddw\",      VADDW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vavb_insn,     \"vavb\",       VAVB)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vavrb_insn,    \"vavrb\",      VAVRB)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vdifaw_insn,   \"vdifaw\",     VDIFAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vdifw_insn,    \"vdifw\",      VDIFW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmaxaw_insn,   \"vmaxaw\",     VMAXAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmaxw_insn,    \"vmaxw\",      VMAXW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vminaw_insn,   \"vminaw\",     VMINAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vminw_insn,    \"vminw\",      VMINW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmulaw_insn,   \"vmulaw\",     VMULAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,   vmulfaw_insn,  \"vmulfaw\",    VMULFAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmulfw_insn,   \"vmulfw\",     VMULFW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmulw_insn,    \"vmulw\",      VMULW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vsubaw_insn,   \"vsubaw\",     VSUBAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vsubw_insn,    \"vsubw\",      VSUBW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vsummw_insn,   \"vsummw\",     VSUMMW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vand_insn,     \"vand\",       VAND)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vandaw_insn,   \"vandaw\",     VANDAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vbic_insn,     \"vbic\",       VBIC)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vbicaw_insn,   \"vbicaw\",     VBICAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,       vor_insn,      \"vor\",        VOR)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vxor_insn,     \"vxor\",       VXOR)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vxoraw_insn,   \"vxoraw\",     VXORAW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      veqw_insn,     \"veqw\",       VEQW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vlew_insn,     \"vlew\",       VLEW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vltw_insn,     \"vltw\",       VLTW)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vnew_insn,     \"vnew\",       VNEW)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr1aw_insn,   \"vmr1aw\",     VMR1AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr1w_insn,    \"vmr1w\",      VMR1W)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr2aw_insn,   \"vmr2aw\",     VMR2AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr2w_insn,    \"vmr2w\",      VMR2W)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr3aw_insn,   \"vmr3aw\",     VMR3AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr3w_insn,    \"vmr3w\",      VMR3W)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr4aw_insn,   \"vmr4aw\",     VMR4AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr4w_insn,    \"vmr4w\",      VMR4W)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr5aw_insn,   \"vmr5aw\",     VMR5AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr5w_insn,    \"vmr5w\",      VMR5W)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr6aw_insn,   \"vmr6aw\",     VMR6AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr6w_insn,    \"vmr6w\",      VMR6W)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vmr7aw_insn,   \"vmr7aw\",     VMR7AW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vmr7w_insn,    \"vmr7w\",      VMR7W)\n-  SIMD_BUILTIN (Va_Vb_Vc,      vmrb_insn,     \"vmrb\",       VMRB)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vh264f_insn,   \"vh264f\",     VH264F)\n-  SIMD_BUILTIN (Va_Vb_Vc,   vh264ft_insn,  \"vh264ft\",    VH264FT)\n-  SIMD_BUILTIN (Va_Vb_Vc,   vh264fw_insn,  \"vh264fw\",    VH264FW)\n-  SIMD_BUILTIN (Va_Vb_Vc,     vvc1f_insn,    \"vvc1f\",      VVC1F)\n-  SIMD_BUILTIN (Va_Vb_Vc,    vvc1ft_insn,   \"vvc1ft\",     VVC1FT)\n-\n-  SIMD_BUILTIN (Va_Vb_rlimm,    vbaddw_insn,   \"vbaddw\",     VBADDW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,    vbmaxw_insn,   \"vbmaxw\",     VBMAXW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,    vbminw_insn,   \"vbminw\",     VBMINW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,   vbmulaw_insn,  \"vbmulaw\",    VBMULAW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,   vbmulfw_insn,  \"vbmulfw\",    VBMULFW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,    vbmulw_insn,   \"vbmulw\",     VBMULW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,   vbrsubw_insn,  \"vbrsubw\",    VBRSUBW)\n-  SIMD_BUILTIN (Va_Vb_rlimm,    vbsubw_insn,   \"vbsubw\",     VBSUBW)\n-\n-  /* Va, Vb, Ic instructions.  */\n-  SIMD_BUILTIN (Va_Vb_Ic,        vasrw_insn,    \"vasrw\",      VASRW)\n-  SIMD_BUILTIN (Va_Vb_Ic,         vsr8_insn,     \"vsr8\",       VSR8)\n-  SIMD_BUILTIN (Va_Vb_Ic,       vsr8aw_insn,   \"vsr8aw\",     VSR8AW)\n-\n-  /* Va, Vb, u6 instructions.  */\n-  SIMD_BUILTIN (Va_Vb_u6,      vasrrwi_insn,  \"vasrrwi\",    VASRRWi)\n-  SIMD_BUILTIN (Va_Vb_u6,     vasrsrwi_insn, \"vasrsrwi\",   VASRSRWi)\n-  SIMD_BUILTIN (Va_Vb_u6,       vasrwi_insn,   \"vasrwi\",     VASRWi)\n-  SIMD_BUILTIN (Va_Vb_u6,     vasrpwbi_insn, \"vasrpwbi\",   VASRPWBi)\n-  SIMD_BUILTIN (Va_Vb_u6,    vasrrpwbi_insn,\"vasrrpwbi\",  VASRRPWBi)\n-  SIMD_BUILTIN (Va_Vb_u6,      vsr8awi_insn,  \"vsr8awi\",    VSR8AWi)\n-  SIMD_BUILTIN (Va_Vb_u6,        vsr8i_insn,    \"vsr8i\",      VSR8i)\n-\n-  /* Va, Vb, u8 (simm) instructions.  */\n-  SIMD_BUILTIN (Va_Vb_u8,        vmvaw_insn,    \"vmvaw\",      VMVAW)\n-  SIMD_BUILTIN (Va_Vb_u8,         vmvw_insn,     \"vmvw\",       VMVW)\n-  SIMD_BUILTIN (Va_Vb_u8,        vmvzw_insn,    \"vmvzw\",      VMVZW)\n-  SIMD_BUILTIN (Va_Vb_u8,      vd6tapf_insn,  \"vd6tapf\",    VD6TAPF)\n-\n-  /* Va, rlimm, u8 (simm) instructions.  */\n-  SIMD_BUILTIN (Va_rlimm_u8,    vmovaw_insn,   \"vmovaw\",     VMOVAW)\n-  SIMD_BUILTIN (Va_rlimm_u8,     vmovw_insn,    \"vmovw\",      VMOVW)\n-  SIMD_BUILTIN (Va_rlimm_u8,    vmovzw_insn,   \"vmovzw\",     VMOVZW)\n-\n-  /* Va, Vb instructions.  */\n-  SIMD_BUILTIN (Va_Vb,          vabsaw_insn,   \"vabsaw\",     VABSAW)\n-  SIMD_BUILTIN (Va_Vb,           vabsw_insn,    \"vabsw\",      VABSW)\n-  SIMD_BUILTIN (Va_Vb,         vaddsuw_insn,  \"vaddsuw\",    VADDSUW)\n-  SIMD_BUILTIN (Va_Vb,          vsignw_insn,   \"vsignw\",     VSIGNW)\n-  SIMD_BUILTIN (Va_Vb,          vexch1_insn,   \"vexch1\",     VEXCH1)\n-  SIMD_BUILTIN (Va_Vb,          vexch2_insn,   \"vexch2\",     VEXCH2)\n-  SIMD_BUILTIN (Va_Vb,          vexch4_insn,   \"vexch4\",     VEXCH4)\n-  SIMD_BUILTIN (Va_Vb,          vupbaw_insn,   \"vupbaw\",     VUPBAW)\n-  SIMD_BUILTIN (Va_Vb,           vupbw_insn,    \"vupbw\",      VUPBW)\n-  SIMD_BUILTIN (Va_Vb,         vupsbaw_insn,  \"vupsbaw\",    VUPSBAW)\n-  SIMD_BUILTIN (Va_Vb,          vupsbw_insn,   \"vupsbw\",     VUPSBW)\n-\n-  /* DIb, rlimm, rlimm instructions.  */\n-  SIMD_BUILTIN (Da_rlimm_rlimm,  vdirun_insn,  \"vdirun\",     VDIRUN)\n-  SIMD_BUILTIN (Da_rlimm_rlimm,  vdorun_insn,  \"vdorun\",     VDORUN)\n-\n-  /* DIb, limm, rlimm instructions.  */\n-  SIMD_BUILTIN (Da_u3_rlimm,   vdiwr_insn,    \"vdiwr\",      VDIWR)\n-  SIMD_BUILTIN (Da_u3_rlimm,    vdowr_insn,    \"vdowr\",     VDOWR)\n-\n-  /* rlimm instructions.  */\n-  SIMD_BUILTIN (void_rlimm,        vrec_insn,     \"vrec\",      VREC)\n-  SIMD_BUILTIN (void_rlimm,        vrun_insn,     \"vrun\",      VRUN)\n-  SIMD_BUILTIN (void_rlimm,     vrecrun_insn,  \"vrecrun\",   VRECRUN)\n-  SIMD_BUILTIN (void_rlimm,     vendrec_insn,  \"vendrec\",   VENDREC)\n-\n-  /* Va, [Ib,u8] instructions.  */\n-  SIMD_BUILTIN (Va_Vb_Ic_u8,       vld32wh_insn,  \"vld32wh\",   VLD32WH)\n-  SIMD_BUILTIN (Va_Vb_Ic_u8,       vld32wl_insn,  \"vld32wl\",   VLD32WL)\n-  SIMD_BUILTIN (Va_Vb_Ic_u8,         vld64_insn,    \"vld64\",     VLD64)\n-  SIMD_BUILTIN (Va_Vb_Ic_u8,         vld32_insn,    \"vld32\",     VLD32)\n-\n-  SIMD_BUILTIN (Va_Ib_u8,           vld64w_insn,   \"vld64w\",   VLD64W)\n-  SIMD_BUILTIN (Va_Ib_u8,           vld128_insn,   \"vld128\",   VLD128)\n-  SIMD_BUILTIN (void_Va_Ib_u8,      vst128_insn,   \"vst128\",   VST128)\n-  SIMD_BUILTIN (void_Va_Ib_u8,       vst64_insn,    \"vst64\",    VST64)\n-\n-  /* Va, [Ib, u8] instructions.  */\n-  SIMD_BUILTIN (void_Va_u3_Ib_u8,  vst16_n_insn,  \"vst16_n\",   VST16_N)\n-  SIMD_BUILTIN (void_Va_u3_Ib_u8,  vst32_n_insn,  \"vst32_n\",   VST32_N)\n-\n-  SIMD_BUILTIN (void_u6,  vinti_insn,  \"vinti\",   VINTI)\n-};\n-\n-static void\n-arc_init_simd_builtins (void)\n-{\n-  int i;\n-  tree endlink = void_list_node;\n-  tree V8HI_type_node = build_vector_type_for_mode (intHI_type_node, V8HImode);\n-\n-  tree v8hi_ftype_v8hi_v8hi\n-    = build_function_type (V8HI_type_node,\n-\t\t\t   tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t\t\t\t\t endlink)));\n-  tree v8hi_ftype_v8hi_int\n-    = build_function_type (V8HI_type_node,\n-\t\t\t   tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t\t endlink)));\n-\n-  tree v8hi_ftype_v8hi_int_int\n-    = build_function_type (V8HI_type_node,\n-\t\t\t   tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t    integer_type_node,\n-\t\t\t\t\t\t\t    endlink))));\n-\n-  tree void_ftype_v8hi_int_int\n-    = build_function_type (void_type_node,\n-\t\t\t   tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t    integer_type_node,\n-\t\t\t\t\t\t\t    endlink))));\n-\n-  tree void_ftype_v8hi_int_int_int\n-    = (build_function_type\n-\t(void_type_node,\n-\t tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t    tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t       tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t  tree_cons (NULL_TREE,\n-\t\t\t\t\t\t     integer_type_node,\n-\t\t\t\t\t\t     endlink))))));\n-\n-  tree v8hi_ftype_int_int\n-    = build_function_type (V8HI_type_node,\n-\t\t\t   tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t\t endlink)));\n-\n-  tree void_ftype_int_int\n-    = build_function_type (void_type_node,\n-\t\t\t   tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t\t\t\t endlink)));\n-\n-  tree void_ftype_int\n-    = build_function_type (void_type_node,\n-\t\t\t   tree_cons (NULL_TREE, integer_type_node, endlink));\n-\n-  tree v8hi_ftype_v8hi\n-    = build_function_type (V8HI_type_node, tree_cons (NULL_TREE, V8HI_type_node,\n-\t\t\t\t\t\t      endlink));\n-\n-  /* These asserts have been introduced to ensure that the order of builtins\n-     does not get messed up, else the initialization goes wrong.  */\n-  gcc_assert (arc_simd_builtin_desc_list [0].args_type == Va_Vb_Vc);\n-  for (i=0; arc_simd_builtin_desc_list [i].args_type == Va_Vb_Vc; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi_v8hi, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Vb_rlimm);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Vb_rlimm; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Vb_Ic);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Vb_Ic; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Vb_u6);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Vb_u6; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Vb_u8);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Vb_u8; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_rlimm_u8);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_rlimm_u8; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_int_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Vb);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Vb; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Da_rlimm_rlimm);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Da_rlimm_rlimm; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list [i].name,\n-\t\t  void_ftype_int_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Da_u3_rlimm);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Da_u3_rlimm; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  void_ftype_int_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == void_rlimm);\n-  for (; arc_simd_builtin_desc_list [i].args_type == void_rlimm; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  void_ftype_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Vb_Ic_u8);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Vb_Ic_u8; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_v8hi_int_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == Va_Ib_u8);\n-  for (; arc_simd_builtin_desc_list [i].args_type == Va_Ib_u8; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  v8hi_ftype_int_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == void_Va_Ib_u8);\n-  for (; arc_simd_builtin_desc_list [i].args_type == void_Va_Ib_u8; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list [i].name,\n-\t\t  void_ftype_v8hi_int_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == void_Va_u3_Ib_u8);\n-  for (; arc_simd_builtin_desc_list [i].args_type == void_Va_u3_Ib_u8; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  void_ftype_v8hi_int_int_int,\n-\t\t  arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert (arc_simd_builtin_desc_list [i].args_type == void_u6);\n-  for (; arc_simd_builtin_desc_list [i].args_type == void_u6; i++)\n-    def_mbuiltin (TARGET_SIMD_SET, arc_simd_builtin_desc_list[i].name,\n-\t\t  void_ftype_int, arc_simd_builtin_desc_list[i].code);\n-\n-  gcc_assert(i == ARRAY_SIZE (arc_simd_builtin_desc_list));\n-}\n-\n-/* Helper function of arc_expand_builtin; has the same parameters,\n-   except that EXP is now known to be a call to a simd builtin.  */\n-\n-static rtx\n-arc_expand_simd_builtin (tree exp,\n-\t\t\t rtx target,\n-\t\t\t rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t int ignore ATTRIBUTE_UNUSED)\n-{\n-  tree              fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-  tree              arg0;\n-  tree              arg1;\n-  tree              arg2;\n-  tree              arg3;\n-  rtx               op0;\n-  rtx               op1;\n-  rtx               op2;\n-  rtx               op3;\n-  rtx               op4;\n-  rtx pat;\n-  unsigned int         i;\n-  int               fcode = DECL_FUNCTION_CODE (fndecl);\n-  int               icode;\n-  machine_mode mode0;\n-  machine_mode mode1;\n-  machine_mode mode2;\n-  machine_mode mode3;\n-  machine_mode mode4;\n-  const struct builtin_description * d;\n-\n-  for (i = 0, d = arc_simd_builtin_desc_list;\n-       i < ARRAY_SIZE (arc_simd_builtin_desc_list); i++, d++)\n-    if (d->code == (const enum arc_builtins) fcode)\n-      break;\n-\n-  /* We must get an entry here.  */\n-  gcc_assert (i < ARRAY_SIZE (arc_simd_builtin_desc_list));\n-\n-  switch (d->args_type)\n-    {\n-    case Va_Vb_rlimm:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n-\n-      target = gen_reg_rtx (V8HImode);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\t  op1 = copy_to_mode_reg (mode1, op1);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case Va_Vb_u6:\n-    case Va_Vb_u8:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n-\n-      target = gen_reg_rtx (V8HImode);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1)\n-\t  ||  (d->args_type == Va_Vb_u6 && !UNSIGNED_INT6 (INTVAL (op1)))\n-\t  ||  (d->args_type == Va_Vb_u8 && !UNSIGNED_INT8 (INTVAL (op1))))\n-\terror (\"operand 2 of %s instruction should be an unsigned %d-bit value\",\n-\t       d->name,\n-\t       (d->args_type == Va_Vb_u6)? 6: 8);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case Va_rlimm_u8:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n-\n-      target = gen_reg_rtx (V8HImode);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if ( (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\t   || !(UNSIGNED_INT8 (INTVAL (op1))))\n-\terror (\"operand 2 of %s instruction should be an unsigned 8-bit value\",\n-\t       d->name);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case Va_Vb_Ic:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n-      op2 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\n-\n-      target = gen_reg_rtx (V8HImode);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if ( (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\t   || !(UNSIGNED_INT3 (INTVAL (op1))))\n-\terror (\"operand 2 of %s instruction should be an unsigned 3-bit value (I0-I7)\",\n-\t       d->name);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1, op2);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case Va_Vb_Vc:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-\n-      target = gen_reg_rtx (V8HImode);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case Va_Vb:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      op0 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-\n-      target = gen_reg_rtx (V8HImode);\n-      mode0 =  insn_data[icode].operand[1].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      pat = GEN_FCN (icode) (target, op0);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case Da_rlimm_rlimm:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n-\n-\n-      if (icode == CODE_FOR_vdirun_insn)\n-\ttarget = gen_rtx_REG (SImode, 131);\n-      else if (icode == CODE_FOR_vdorun_insn)\n-\ttarget = gen_rtx_REG (SImode, 139);\n-      else\n-\t  gcc_unreachable ();\n-\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-\n-      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-\n-\n-      pat = GEN_FCN (icode) (target, op0, op1);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return NULL_RTX;\n-\n-    case Da_u3_rlimm:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-      arg1 = CALL_EXPR_ARG (exp, 1);\n-      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);\n-\n-\n-      if (! (GET_CODE (op0) == CONST_INT)\n-\t  || !(UNSIGNED_INT3 (INTVAL (op0))))\n-\terror (\"operand 1 of %s instruction should be an unsigned 3-bit value (DR0-DR7)\",\n-\t       d->name);\n-\n-      mode1 =  insn_data[icode].operand[1].mode;\n-\n-      if (icode == CODE_FOR_vdiwr_insn)\n-\ttarget = gen_rtx_REG (SImode,\n-\t\t\t      ARC_FIRST_SIMD_DMA_CONFIG_IN_REG + INTVAL (op0));\n-      else if (icode == CODE_FOR_vdowr_insn)\n-\ttarget = gen_rtx_REG (SImode,\n-\t\t\t      ARC_FIRST_SIMD_DMA_CONFIG_OUT_REG + INTVAL (op0));\n-      else\n-\tgcc_unreachable ();\n-\n-      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\top1 = copy_to_mode_reg (mode1, op1);\n-\n-      pat = GEN_FCN (icode) (target, op1);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return NULL_RTX;\n-\n-    case void_u6:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-\n-      fold (arg0);\n-\n-      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n-      mode0 = insn_data[icode].operand[0].mode;\n-\n-      /* op0 should be u6.  */\n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0)\n-\t  || !(UNSIGNED_INT6 (INTVAL (op0))))\n-\terror (\"operand of %s instruction should be an unsigned 6-bit value\",\n-\t       d->name);\n-\n-      pat = GEN_FCN (icode) (op0);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return NULL_RTX;\n-\n-    case void_rlimm:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0);\n-\n-      fold (arg0);\n-\n-      op0 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL);\n-      mode0 = insn_data[icode].operand[0].mode;\n-\n-      if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\top0 = copy_to_mode_reg (mode0, op0);\n-\n-      pat = GEN_FCN (icode) (op0);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return NULL_RTX;\n-\n-    case Va_Vb_Ic_u8:\n-      {\n-\trtx src_vreg;\n-\ticode = d->icode;\n-\targ0 = CALL_EXPR_ARG (exp, 0); /* source vreg */\n-\targ1 = CALL_EXPR_ARG (exp, 1); /* [I]0-7 */\n-\targ2 = CALL_EXPR_ARG (exp, 2); /* u8 */\n-\n-\tsrc_vreg = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);\n-\top0 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);  /* [I]0-7 */\n-\top1 = expand_expr (arg2, NULL_RTX, SImode, EXPAND_NORMAL);  /* u8 */\n-\top2 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);\t    /* VR0 */\n-\n-\t/* target <- src vreg */\n-\temit_insn (gen_move_insn (target, src_vreg));\n-\n-\t/* target <- vec_concat: target, mem(Ib, u8) */\n-\tmode0 =  insn_data[icode].operand[3].mode;\n-\tmode1 =  insn_data[icode].operand[1].mode;\n-\n-\tif ( (!(*insn_data[icode].operand[3].predicate) (op0, mode0))\n-\t     || !(UNSIGNED_INT3 (INTVAL (op0))))\n-\t  error (\"operand 1 of %s instruction should be an unsigned 3-bit value (I0-I7)\",\n-\t\t d->name);\n-\n-\tif ( (!(*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\t     || !(UNSIGNED_INT8 (INTVAL (op1))))\n-\t  error (\"operand 2 of %s instruction should be an unsigned 8-bit value\",\n-\t\t d->name);\n-\n-\tpat = GEN_FCN (icode) (target, op1, op2, op0);\n-\tif (! pat)\n-\t  return 0;\n-\n-\temit_insn (pat);\n-\treturn target;\n-      }\n-\n-    case void_Va_Ib_u8:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0); /* src vreg */\n-      arg1 = CALL_EXPR_ARG (exp, 1); /* [I]0-7 */\n-      arg2 = CALL_EXPR_ARG (exp, 2); /* u8 */\n-\n-      op0 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);         /* VR0    */\n-      op1 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);   /* I[0-7] */\n-      op2 = expand_expr (arg2, NULL_RTX, SImode, EXPAND_NORMAL);   /* u8     */\n-      op3 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL); /* Vdest  */\n-\n-      mode0 =  insn_data[icode].operand[0].mode;\n-      mode1 =  insn_data[icode].operand[1].mode;\n-      mode2 =  insn_data[icode].operand[2].mode;\n-      mode3 =  insn_data[icode].operand[3].mode;\n-\n-      if ( (!(*insn_data[icode].operand[1].predicate) (op1, mode1))\n-\t   || !(UNSIGNED_INT3 (INTVAL (op1))))\n-\terror (\"operand 2 of %s instruction should be an unsigned 3-bit value (I0-I7)\",\n-\t       d->name);\n-\n-      if ( (!(*insn_data[icode].operand[2].predicate) (op2, mode2))\n-\t   || !(UNSIGNED_INT8 (INTVAL (op2))))\n-\terror (\"operand 3 of %s instruction should be an unsigned 8-bit value\",\n-\t       d->name);\n-\n-      if (!(*insn_data[icode].operand[3].predicate) (op3, mode3))\n-\top3 = copy_to_mode_reg (mode3, op3);\n-\n-      pat = GEN_FCN (icode) (op0, op1, op2, op3);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return NULL_RTX;\n-\n-    case Va_Ib_u8:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0); /* dest vreg */\n-      arg1 = CALL_EXPR_ARG (exp, 1); /* [I]0-7 */\n-\n-      op0 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);       /* VR0    */\n-      op1 = expand_expr (arg0, NULL_RTX, SImode, EXPAND_NORMAL); /* I[0-7] */\n-      op2 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL); /* u8     */\n-\n-      /* target <- src vreg */\n-      target = gen_reg_rtx (V8HImode);\n-\n-      /* target <- vec_concat: target, mem(Ib, u8) */\n-      mode0 =  insn_data[icode].operand[1].mode;\n-      mode1 =  insn_data[icode].operand[2].mode;\n-      mode2 =  insn_data[icode].operand[3].mode;\n-\n-      if ( (!(*insn_data[icode].operand[2].predicate) (op1, mode1))\n-\t   || !(UNSIGNED_INT3 (INTVAL (op1))))\n-\terror (\"operand 1 of %s instruction should be an unsigned 3-bit value (I0-I7)\",\n-\t       d->name);\n-\n-      if ( (!(*insn_data[icode].operand[3].predicate) (op2, mode2))\n-\t   || !(UNSIGNED_INT8 (INTVAL (op2))))\n-\terror (\"operand 2 of %s instruction should be an unsigned 8-bit value\",\n-\t       d->name);\n-\n-      pat = GEN_FCN (icode) (target, op0, op1, op2);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return target;\n-\n-    case void_Va_u3_Ib_u8:\n-      icode = d->icode;\n-      arg0 = CALL_EXPR_ARG (exp, 0); /* source vreg */\n-      arg1 = CALL_EXPR_ARG (exp, 1); /* u3 */\n-      arg2 = CALL_EXPR_ARG (exp, 2); /* [I]0-7 */\n-      arg3 = CALL_EXPR_ARG (exp, 3); /* u8 */\n-\n-      op0 = expand_expr (arg3, NULL_RTX, SImode, EXPAND_NORMAL); /* u8        */\n-      op1 = gen_rtx_REG (V8HImode, ARC_FIRST_SIMD_VR_REG);       /* VR        */\n-      op2 = expand_expr (arg2, NULL_RTX, SImode, EXPAND_NORMAL); /* [I]0-7    */\n-      op3 = expand_expr (arg0, NULL_RTX, V8HImode, EXPAND_NORMAL);/* vreg to be stored */\n-      op4 = expand_expr (arg1, NULL_RTX, SImode, EXPAND_NORMAL);  /* vreg 0-7 subreg no. */\n-\n-      mode0 =  insn_data[icode].operand[0].mode;\n-      mode2 =  insn_data[icode].operand[2].mode;\n-      mode3 =  insn_data[icode].operand[3].mode;\n-      mode4 =  insn_data[icode].operand[4].mode;\n-\n-      /* Do some correctness checks for the operands.  */\n-      if ( (!(*insn_data[icode].operand[0].predicate) (op0, mode0))\n-\t   || !(UNSIGNED_INT8 (INTVAL (op0))))\n-\terror (\"operand 4 of %s instruction should be an unsigned 8-bit value (0-255)\",\n-\t       d->name);\n-\n-      if ( (!(*insn_data[icode].operand[2].predicate) (op2, mode2))\n-\t   || !(UNSIGNED_INT3 (INTVAL (op2))))\n-\terror (\"operand 3 of %s instruction should be an unsigned 3-bit value (I0-I7)\",\n-\t       d->name);\n-\n-      if (!(*insn_data[icode].operand[3].predicate) (op3, mode3))\n-\top3 = copy_to_mode_reg (mode3, op3);\n-\n-      if ( (!(*insn_data[icode].operand[4].predicate) (op4, mode4))\n-\t   || !(UNSIGNED_INT3 (INTVAL (op4))))\n-\terror (\"operand 2 of %s instruction should be an unsigned 3-bit value (subreg 0-7)\",\n-\t       d->name);\n-      else if (icode == CODE_FOR_vst32_n_insn\n-\t       && ((INTVAL(op4) % 2 ) != 0))\n-\terror (\"operand 2 of %s instruction should be an even 3-bit value (subreg 0,2,4,6)\",\n-\t       d->name);\n-\n-      pat = GEN_FCN (icode) (op0, op1, op2, op3, op4);\n-      if (! pat)\n-\treturn 0;\n-\n-      emit_insn (pat);\n-      return NULL_RTX;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return NULL_RTX;\n-}\n-\n static bool\n arc_preserve_reload_p (rtx in)\n {\n@@ -9251,11 +8508,13 @@ arc_process_double_reg_moves (rtx *operands)\n \n \t  /* Produce the two LR insns to get the high and low parts.  */\n \t  emit_insn (gen_rtx_SET (destHigh,\n-\t\t\t\t  gen_rtx_UNSPEC_VOLATILE (Pmode, gen_rtvec (1, src),\n-\t\t\t\t  VUNSPEC_LR_HIGH)));\n+\t\t\t\t  gen_rtx_UNSPEC_VOLATILE (Pmode,\n+\t\t\t\t\t\t\t   gen_rtvec (1, src),\n+\t\t\t\t  VUNSPEC_ARC_LR_HIGH)));\n \t  emit_insn (gen_rtx_SET (destLow,\n-\t\t\t\t  gen_rtx_UNSPEC_VOLATILE (Pmode, gen_rtvec (1, src),\n-\t\t\t\t  VUNSPEC_LR)));\n+\t\t\t\t  gen_rtx_UNSPEC_VOLATILE (Pmode,\n+\t\t\t\t\t\t\t   gen_rtvec (1, src),\n+\t\t\t\t  VUNSPEC_ARC_LR)));\n \t}\n     }\n   else if (state == destDx)\n@@ -9267,7 +8526,7 @@ arc_process_double_reg_moves (rtx *operands)\n \n       emit_insn (gen_rtx_UNSPEC_VOLATILE (Pmode,\n \t\t\t\t\t  gen_rtvec (3, dest, srcHigh, srcLow),\n-\t\t\t\t\t  VUNSPEC_DEXCL_NORES));\n+\t\t\t\t\t  VUNSPEC_ARC_DEXCL_NORES));\n \n     }\n   else"}, {"sha": "08e6a990c3e119552775554d0fa7647b66726af2", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 165, "deletions": 87, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -104,35 +104,66 @@\n ;;                            GOTBASE.(Referenced as @GOTOFF)\n ;;  ----------------------------------------------------------------------------\n \n+(define_c_enum \"unspec\" [\n+  DUMMY_0\n+  DUMMY_1\n+  DUMMY_2\n+  ARC_UNSPEC_PLT\n+  ARC_UNSPEC_GOT\n+  ARC_UNSPEC_GOTOFF\n+  UNSPEC_ARC_NORM\n+  UNSPEC_ARC_NORMW\n+  UNSPEC_ARC_SWAP\n+  UNSPEC_ARC_DIVAW\n+  UNSPEC_ARC_DIRECT\n+  UNSPEC_ARC_LP\n+  UNSPEC_ARC_CASESI\n+  UNSPEC_ARC_FFS\n+  UNSPEC_ARC_FLS\n+  UNSPEC_ARC_MEMBAR\n+  UNSPEC_ARC_DMACH\n+  UNSPEC_ARC_DMACHU\n+  UNSPEC_ARC_DMACWH\n+  UNSPEC_ARC_DMACWHU\n+  UNSPEC_ARC_QMACH\n+  UNSPEC_ARC_QMACHU\n+  UNSPEC_ARC_QMPYH\n+  UNSPEC_ARC_QMPYHU\n+  UNSPEC_ARC_VMAC2H\n+  UNSPEC_ARC_VMAC2HU\n+  UNSPEC_ARC_VMPY2H\n+  UNSPEC_ARC_VMPY2HU\n+  ])\n+\n+(define_c_enum \"vunspec\" [\n+  VUNSPEC_ARC_RTIE\n+  VUNSPEC_ARC_SYNC\n+  VUNSPEC_ARC_BRK\n+  VUNSPEC_ARC_FLAG\n+  VUNSPEC_ARC_SLEEP\n+  VUNSPEC_ARC_SWI\n+  VUNSPEC_ARC_CORE_READ\n+  VUNSPEC_ARC_CORE_WRITE\n+  VUNSPEC_ARC_LR\n+  VUNSPEC_ARC_SR\n+  VUNSPEC_ARC_TRAP_S\n+  VUNSPEC_ARC_UNIMP_S\n+  VUNSPEC_ARC_KFLAG\n+  VUNSPEC_ARC_CLRI\n+  VUNSPEC_ARC_SETI\n+  VUNSPEC_ARC_NOP\n+  VUNSPEC_ARC_STACK_IRQ\n+  VUNSPEC_ARC_DEXCL\n+  VUNSPEC_ARC_DEXCL_NORES\n+  VUNSPEC_ARC_LR_HIGH\n+  VUNSPEC_ARC_EX\n+  VUNSPEC_ARC_CAS\n+  VUNSPEC_ARC_SC\n+  VUNSPEC_ARC_LL\n+  ])\n \n (define_constants\n-  [(UNSPEC_SWAP 13) ; swap generation through builtins. candidate for scheduling\n-   (UNSPEC_MUL64 14) ; mul64 generation through builtins. candidate for scheduling\n-   (UNSPEC_MULU64 15) ; mulu64 generation through builtins. candidate for scheduling\n-   (UNSPEC_DIVAW 16) ; divaw generation through builtins. candidate for scheduling\n-   (UNSPEC_DIRECT 17)\n-   (UNSPEC_PROF 18) ; profile callgraph counter\n-   (UNSPEC_LP 19) ; to set LP_END\n-   (UNSPEC_CASESI 20)\n-   (VUNSPEC_RTIE 17) ; blockage insn for rtie generation\n-   (VUNSPEC_SYNC 18) ; blockage insn for sync generation\n-   (VUNSPEC_BRK 19) ; blockage insn for brk generation\n-   (VUNSPEC_FLAG 20) ; blockage insn for flag generation\n-   (VUNSPEC_SLEEP 21) ; blockage insn for sleep generation\n-   (VUNSPEC_SWI 22) ; blockage insn for swi generation\n-   (VUNSPEC_CORE_READ 23) ; blockage insn for reading a core register\n-   (VUNSPEC_CORE_WRITE 24) ; blockage insn for writing to a core register\n-   (VUNSPEC_LR 25) ; blockage insn for reading an auxiliary register\n-   (VUNSPEC_SR 26) ; blockage insn for writing to an auxiliary register\n-   (VUNSPEC_TRAP_S 27) ; blockage insn for trap_s generation\n-   (VUNSPEC_UNIMP_S 28) ; blockage insn for unimp_s generation\n-   (VUNSPEC_NOP 29) ; volatile NOP\n-\n-   (UNSPEC_ARC_MEMBAR 30)\n-   (VUNSPEC_ARC_CAS 31)\n-   (VUNSPEC_ARC_LL 32)\n-   (VUNSPEC_ARC_SC 33)\n-   (VUNSPEC_ARC_EX 34)\n+  [(UNSPEC_PROF 18) ; profile callgraph counter\n \n    (R0_REG 0)\n    (R1_REG 1)\n@@ -145,10 +176,6 @@\n    (RETURN_ADDR_REGNUM 31)\n    (MUL64_OUT_REG 58)\n \n-   (VUNSPEC_DEXCL 32) ; blockage insn for reading an auxiliary register without LR support\n-   (VUNSPEC_DEXCL_NORES 33) ; blockage insn for reading an auxiliary register without LR support\n-   (VUNSPEC_LR_HIGH 34) ; blockage insn for reading an auxiliary register\n-\n    (LP_COUNT 60)\n    (CC_REG 61)\n    (LP_START 144)\n@@ -716,7 +743,7 @@\n (define_insn \"store_direct\"\n   [(set (match_operand:SI 0 \"move_dest_operand\" \"=m\")\n       (unspec:SI [(match_operand:SI 1 \"register_operand\" \"c\")]\n-       UNSPEC_DIRECT))]\n+       UNSPEC_ARC_DIRECT))]\n   \"\"\n   \"st%U0 %1,%0\\;st%U0.di %1,%0\"\n   [(set_attr \"type\" \"store\")])\n@@ -1083,10 +1110,10 @@\n     ; dexcl2 r0, r1, r0\n     (set (match_dup 4) ; aka r0result\n      \t ; aka DF, r1, r0\n-\t (unspec_volatile:SI [(match_dup 1) (match_dup 5) (match_dup 4)] VUNSPEC_DEXCL ))\n+\t (unspec_volatile:SI [(match_dup 1) (match_dup 5) (match_dup 4)] VUNSPEC_ARC_DEXCL ))\n     ; Generate the second, which makes sure operand5 and operand4 values\n     ; are put back in the Dx register properly.\n-    (unspec_volatile:SI [(match_dup 1) (match_dup 5) (match_dup 4)] VUNSPEC_DEXCL_NORES )\n+    (unspec_volatile:SI [(match_dup 1) (match_dup 5) (match_dup 4)] VUNSPEC_ARC_DEXCL_NORES )\n \n     ; Note: we cannot use a (clobber (match_scratch)) here because\n     ; the combine pass will end up replacing uses of it with 0\n@@ -3646,7 +3673,7 @@\n \t\t      (pc)))\n    (set (match_dup 6)\n \t(unspec:SI [(match_operand 3 \"\" \"\")\n-\t\t    (match_dup 5) (match_dup 7)] UNSPEC_CASESI))\n+\t\t    (match_dup 5) (match_dup 7)] UNSPEC_ARC_CASESI))\n    (parallel [(set (pc) (match_dup 6)) (use (match_dup 7))])]\n   \"\"\n   \"\n@@ -3684,7 +3711,7 @@\n   [(set (match_operand:SI 0 \"register_operand\"             \"=Rcq,r,r\")\n \t(unspec:SI [(match_operand:SI 1 \"nonmemory_operand\" \"Rcq,c,Cal\")\n \t\t    (match_operand:SI 2 \"register_operand\"  \"Rcq,c,c\")\n-\t\t    (label_ref (match_operand 3 \"\" \"\"))] UNSPEC_CASESI))]\n+\t\t    (label_ref (match_operand 3 \"\" \"\"))] UNSPEC_ARC_CASESI))]\n   \"\"\n   \"*\n {\n@@ -3749,7 +3776,7 @@\n (define_insn \"casesi_compact_jump\"\n   [(set (pc)\n \t(unspec:SI [(match_operand:SI 0 \"register_operand\" \"c,q\")]\n-\t\t   UNSPEC_CASESI))\n+\t\t   UNSPEC_ARC_CASESI))\n    (use (label_ref (match_operand 1 \"\" \"\")))\n    (clobber (match_scratch:SI 2 \"=q,0\"))]\n   \"TARGET_COMPACT_CASESI\"\n@@ -4000,7 +4027,7 @@\n    (set_attr \"length\" \"2\")])\n \n (define_insn \"nopv\"\n-  [(unspec_volatile [(const_int 0)] VUNSPEC_NOP)]\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_ARC_NOP)]\n   \"\"\n   \"nop%?\"\n   [(set_attr \"type\" \"misc\")\n@@ -4245,7 +4272,7 @@\n (define_insn \"swap\"\n   [(set (match_operand:SI  0 \"dest_reg_operand\" \"=w,w,w\")\n \t(unspec:SI [(match_operand:SI 1 \"general_operand\" \"L,Cal,c\")]\n-\t\t\t    UNSPEC_SWAP))]\n+\t\t\t    UNSPEC_ARC_SWAP))]\n   \"TARGET_SWAP\"\n   \"@\n    swap \\t%0, %1\n@@ -4254,41 +4281,11 @@\n   [(set_attr \"length\" \"4,8,4\")\n    (set_attr \"type\" \"two_cycle_core,two_cycle_core,two_cycle_core\")])\n \n-;; FIXME: an intrinsic for multiply is daft.  Can we remove this?\n-(define_insn \"mul64\"\n-  [(unspec [(match_operand:SI 0 \"general_operand\" \"%q,r,r,r\")\n-\t\t     (match_operand:SI 1 \"general_operand\" \"q,rL,I,Cal\")]\n-\t\t   UNSPEC_MUL64)]\n-  \"TARGET_MUL64_SET\"\n-  \"@\n-   mul64%? \\t0, %0, %1%&\n-   mul64%? \\t0, %0, %1\n-   mul64 \\t0, %0, %1\n-   mul64%? \\t0, %0, %S1\"\n-  [(set_attr \"length\" \"2,4,4,8\")\n-  (set_attr \"iscompact\" \"true,false,false,false\")\n-  (set_attr \"type\" \"binary,binary,binary,binary\")\n-  (set_attr \"cond\" \"canuse,canuse, nocond, canuse\")])\n-\n-(define_insn \"mulu64\"\n-  [(unspec [(match_operand:SI 0 \"general_operand\" \"%r,r,r,r\")\n-\t\t     (match_operand:SI 1 \"general_operand\" \"rL,I,r,Cal\")]\n-\t\t   UNSPEC_MULU64)]\n-  \"TARGET_MUL64_SET\"\n-  \"@\n-   mulu64%? \\t0, %0, %1\n-   mulu64 \\t0, %0, %1\n-   mulu64 \\t0, %0, %1\n-   mulu64%? \\t0, %0, %S1\"\n-  [(set_attr \"length\" \"4,4,4,8\")\n-   (set_attr \"type\" \"binary,binary,binary,binary\")\n-   (set_attr \"cond\" \"canuse,nocond,nocond,canuse\")])\n-\n (define_insn \"divaw\"\n   [(set (match_operand:SI 0 \"dest_reg_operand\" \"=&w,&w,&w\")\n \t\t\t  (unspec:SI [(div:SI (match_operand:SI 1 \"general_operand\" \"r,Cal,r\")\n \t\t\t\t\t   (match_operand:SI 2 \"general_operand\" \"r,r,Cal\"))]\n-\t\t\t\t\t   UNSPEC_DIVAW))]\n+\t\t\t\t\t   UNSPEC_ARC_DIVAW))]\n   \"TARGET_ARC700 || TARGET_EA_SET\"\n   \"@\n    divaw \\t%0, %1, %2\n@@ -4299,7 +4296,7 @@\n \n (define_insn \"flag\"\n   [(unspec_volatile [(match_operand:SI 0 \"nonmemory_operand\" \"rL,I,Cal\")]\n-\t\t   VUNSPEC_FLAG)]\n+\t\t   VUNSPEC_ARC_FLAG)]\n   \"\"\n   \"@\n     flag%? %0\n@@ -4312,15 +4309,15 @@\n \n (define_insn \"brk\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n-\t\t   VUNSPEC_BRK)]\n+\t\t   VUNSPEC_ARC_BRK)]\n   \"\"\n   \"brk\"\n   [(set_attr \"length\" \"4\")\n   (set_attr \"type\" \"misc\")])\n \n (define_insn \"rtie\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n-\t\t   VUNSPEC_RTIE)]\n+\t\t   VUNSPEC_ARC_RTIE)]\n   \"\"\n   \"rtie\"\n   [(set_attr \"length\" \"4\")\n@@ -4329,15 +4326,15 @@\n \n (define_insn \"sync\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n-\t\t   VUNSPEC_SYNC)]\n+\t\t   VUNSPEC_ARC_SYNC)]\n   \"\"\n   \"sync\"\n   [(set_attr \"length\" \"4\")\n   (set_attr \"type\" \"misc\")])\n \n (define_insn \"swi\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n-\t\t   VUNSPEC_SWI)]\n+\t\t   VUNSPEC_ARC_SWI)]\n   \"\"\n   \"*\n {\n@@ -4352,7 +4349,7 @@\n \n (define_insn \"sleep\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"L\")]\n-\t\t   VUNSPEC_SLEEP)]\n+\t\t   VUNSPEC_ARC_SLEEP)]\n   \"check_if_valid_sleep_operand(operands,0)\"\n   \"sleep %0\"\n   [(set_attr \"length\" \"4\")\n@@ -4361,7 +4358,7 @@\n (define_insn \"core_read\"\n   [(set (match_operand:SI  0 \"dest_reg_operand\" \"=r,r\")\n \t(unspec_volatile:SI [(match_operand:SI 1 \"general_operand\" \"Hn,!r\")]\n-\t\t\t    VUNSPEC_CORE_READ))]\n+\t\t\t    VUNSPEC_ARC_CORE_READ))]\n   \"\"\n   \"*\n     if (check_if_valid_regno_const (operands, 1))\n@@ -4374,7 +4371,7 @@\n (define_insn \"core_write\"\n   [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"r,r\")\n \t\t     (match_operand:SI 1 \"general_operand\" \"Hn,!r\")]\n-\t\t   VUNSPEC_CORE_WRITE)]\n+\t\t   VUNSPEC_ARC_CORE_WRITE)]\n   \"\"\n   \"*\n     if (check_if_valid_regno_const (operands, 1))\n@@ -4387,7 +4384,7 @@\n (define_insn \"lr\"\n   [(set (match_operand:SI  0 \"dest_reg_operand\" \"=r,r,r,r\")\n \t(unspec_volatile:SI [(match_operand:SI 1 \"general_operand\" \"I,HCal,r,D\")]\n-\t\t\t    VUNSPEC_LR))]\n+\t\t\t    VUNSPEC_ARC_LR))]\n   \"\"\n   \"lr\\t%0, [%1]\"\n   [(set_attr \"length\" \"4,8,4,8\")\n@@ -4396,16 +4393,16 @@\n (define_insn \"sr\"\n   [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"Cal,r,r,r\")\n \t\t     (match_operand:SI 1 \"general_operand\" \"Ir,I,HCal,r\")]\n-\t\t   VUNSPEC_SR)]\n+\t\t   VUNSPEC_ARC_SR)]\n   \"\"\n   \"sr\\t%S0, [%1]\"\n   [(set_attr \"length\" \"8,4,8,4\")\n    (set_attr \"type\" \"sr,sr,sr,sr\")])\n \n (define_insn \"trap_s\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"L,Cal\")]\n-\t\t   VUNSPEC_TRAP_S)]\n-  \"TARGET_ARC700\"\n+\t\t   VUNSPEC_ARC_TRAP_S)]\n+  \"!TARGET_ARC600_FAMILY\"\n {\n   if (which_alternative == 0)\n     {\n@@ -4423,8 +4420,8 @@\n \n (define_insn \"unimp_s\"\n   [(unspec_volatile [(match_operand:SI 0 \"immediate_operand\" \"N\")]\n-\t\t   VUNSPEC_UNIMP_S)]\n-  \"TARGET_ARC700\"\n+\t\t   VUNSPEC_ARC_UNIMP_S)]\n+  \"!TARGET_ARC600_FAMILY\"\n   \"unimp_s\"\n   [(set_attr \"length\" \"4\")\n   (set_attr \"type\" \"misc\")])\n@@ -4867,7 +4864,7 @@\n ; hoist the SETs.\n ;(define_insn \"doloop_begin_i\"\n ;  [(set (reg:SI LP_START) (pc))\n-;   (set (reg:SI LP_END) (unspec:SI [(pc)] UNSPEC_LP))\n+;   (set (reg:SI LP_END) (unspec:SI [(pc)] UNSPEC_ARC_LP))\n ;   (use (match_operand 0 \"const_int_operand\" \"n\"))]\n ;  \"\"\n ;  \"lp .L__GCC__LP%0\"\n@@ -4881,7 +4878,7 @@\n ;\n ; N in XVECEXP PATTERN (lp, 0 N)\n ;  V              rtl                 purpose\n-;  0           unspec UNSPEC_LP     identify pattern\n+;  0           unspec UNSPEC_ARC_LP identify pattern\n ;  1           clobber LP_START     show LP_START is set\n ;  2           clobber LP_END       show LP_END is set\n ;  3           use operand0         loop count pseudo register\n@@ -4896,7 +4893,7 @@\n ; There is no point is reloading this insn - then lp_count would still not\n ; be available for the loop end.\n (define_insn \"doloop_begin_i\"\n-  [(unspec:SI [(pc)] UNSPEC_LP)\n+  [(unspec:SI [(pc)] UNSPEC_ARC_LP)\n    (clobber (reg:SI LP_START))\n    (clobber (reg:SI LP_END))\n    (use (match_operand:SI 0 \"register_operand\" \"l,l,????*X\"))\n@@ -5533,6 +5530,87 @@\n    (set_attr \"predicable\" \"yes,no,no,yes,no\")\n    (set_attr \"cond\"       \"canuse,nocond,nocond,canuse,nocond\")])\n \n+(define_insn \"kflag\"\n+  [(unspec_volatile [(match_operand:SI 0 \"nonmemory_operand\" \"rL,I,Cal\")]\n+\t\t   VUNSPEC_ARC_KFLAG)]\n+  \"TARGET_V2\"\n+  \"@\n+    kflag%? %0\n+    kflag %0\n+    kflag%? %S0\"\n+  [(set_attr \"length\" \"4,4,8\")\n+   (set_attr \"type\" \"misc,misc,misc\")\n+   (set_attr \"predicable\" \"yes,no,yes\")\n+   (set_attr \"cond\" \"clob,clob,clob\")])\n+\n+(define_insn \"clri\"\n+  [(set (match_operand:SI  0 \"dest_reg_operand\" \"=r\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"immediate_operand\" \"N\")]\n+\t\t\t    VUNSPEC_ARC_CLRI))]\n+  \"TARGET_V2\"\n+  \"clri  %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"misc\")])\n+\n+(define_insn \"ffs\"\n+  [(set (match_operand:SI  0 \"dest_reg_operand\" \"=w,w\")\n+\t(unspec:SI [(match_operand:SI 1 \"general_operand\" \"cL,Cal\")]\n+\t\t\t    UNSPEC_ARC_FFS))]\n+  \"TARGET_NORM && TARGET_V2\"\n+  \"@\n+   ffs \\t%0, %1\n+   ffs \\t%0, %S1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"two_cycle_core,two_cycle_core\")])\n+\n+(define_insn \"ffs_f\"\n+  [(set (match_operand:SI  0 \"dest_reg_operand\" \"=w,w\")\n+\t(unspec:SI [(match_operand:SI 1 \"general_operand\" \"cL,Cal\")]\n+\t\t\t    UNSPEC_ARC_FFS))\n+   (set (reg:CC_ZN CC_REG)\n+\t(compare:CC_ZN (match_dup 1) (const_int 0)))]\n+  \"TARGET_NORM && TARGET_V2\"\n+  \"@\n+   ffs.f\\t%0, %1\n+   ffs.f\\t%0, %S1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"two_cycle_core,two_cycle_core\")])\n+\n+(define_expand \"ffssi2\"\n+  [(parallel [(set (match_dup 2)\n+\t\t   (unspec:SI [(match_operand:SI 1 \"register_operand\" \"\")]\n+\t\t\t      UNSPEC_ARC_FFS))\n+\t      (set (reg:CC_ZN CC_REG)\n+\t\t   (compare:CC_ZN (match_dup 1) (const_int 0)))])\n+   (set (match_dup 2) (plus:SI (match_dup 2) (const_int 1)))\n+   (set (match_operand:SI 0 \"dest_reg_operand\" \"\")\n+\t(if_then_else:SI (eq:SI (reg:CC_ZN CC_REG) (const_int 0))\n+\t\t\t (const_int 0)\n+\t\t\t (match_dup 2)))]\n+  \"TARGET_NORM && TARGET_V2\"\n+  {\n+   operands[2] = gen_reg_rtx (SImode);\n+   })\n+\n+(define_insn \"fls\"\n+  [(set (match_operand:SI  0 \"dest_reg_operand\" \"=w,w\")\n+\t(unspec:SI [(match_operand:SI 1 \"general_operand\" \"cL,Cal\")]\n+\t\t\t    UNSPEC_ARC_FLS))]\n+  \"TARGET_NORM && TARGET_V2\"\n+  \"@\n+   fls \\t%0, %1\n+   fls \\t%0, %S1\"\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"type\" \"two_cycle_core,two_cycle_core\")])\n+\n+(define_insn \"seti\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"general_operand\" \"rL\")]\n+\t\t       VUNSPEC_ARC_SETI)]\n+  \"TARGET_V2\"\n+  \"seti  %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"misc\")])\n+\n ;; include the arc-FPX instructions\n (include \"fpx.md\")\n "}, {"sha": "398cc6a6d0e5f086c6dde48be89d49fec4f8767e", "filename": "gcc/config/arc/builtins.def", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fbuiltins.def?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -0,0 +1,195 @@\n+/* Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains the definitions and documentation for the\n+   builtins defined in the ARC part of the GNU compiler.  Before\n+   including this file, define a macro\n+\n+   DEF_BUILTIN(NAME, N_ARGS, TYPE, ICODE, MASK)\n+\n+   NAME:    `__builtin_arc_name' will be the user-level name of the builtin.\n+            `ARC_BUILTIN_NAME' will be the internal builtin's id.\n+   N_ARGS:  Number of input arguments.  If special treatment is needed,\n+            set to -1 and handle it by hand, see arc.c:arc_expand_builtin().\n+   TYPE:    A tree node describing the prototype of the built-in.\n+   ICODE:   Name of attached insn or expander.  If special treatment in arc.c\n+            is needed to expand the built-in, use `nothing'.\n+   MASK:    CPU selector mask.  */\n+\n+/* Special builtins.  */\n+DEF_BUILTIN (NOP,        0, void_ftype_void,        nothing,     1)\n+DEF_BUILTIN (RTIE,       0, void_ftype_void,        rtie,        1)\n+DEF_BUILTIN (SYNC,       0, void_ftype_void,        sync,        TARGET_ARC700)\n+DEF_BUILTIN (BRK,        0, void_ftype_void,        brk,         1)\n+DEF_BUILTIN (SWI,        0, void_ftype_void,        swi,         1)\n+DEF_BUILTIN (UNIMP_S,    0, void_ftype_void,        unimp_s,     !TARGET_ARC600_FAMILY)\n+DEF_BUILTIN (TRAP_S,     1, void_ftype_usint,       trap_s,      !TARGET_ARC600_FAMILY)\n+DEF_BUILTIN (ALIGNED,    2, int_ftype_pcvoid_int,   nothing,     1)\n+DEF_BUILTIN (CLRI,       0, int_ftype_void,         clri,        TARGET_V2)\n+DEF_BUILTIN (SLEEP,      1, void_ftype_usint,       sleep,       1)\n+\n+DEF_BUILTIN (FLAG,       1, void_ftype_usint,       flag,       1)\n+DEF_BUILTIN (SR,         2, void_ftype_usint_usint, sr,         1)\n+DEF_BUILTIN (KFLAG,      1, void_ftype_usint,       kflag,      TARGET_V2)\n+DEF_BUILTIN (CORE_WRITE, 2, void_ftype_usint_usint, core_write, 1)\n+DEF_BUILTIN (SETI,       1, void_ftype_int,         seti,       TARGET_V2)\n+\n+/* Regular builtins.  */\n+DEF_BUILTIN (NORM,       1, int_ftype_int,          clrsbsi2,   TARGET_NORM)\n+DEF_BUILTIN (NORMW,      1, int_ftype_short,        normw,      TARGET_NORM)\n+DEF_BUILTIN (SWAP,       1, int_ftype_int,          swap,       TARGET_SWAP)\n+DEF_BUILTIN (DIVAW,      2, int_ftype_int_int,      divaw,      TARGET_EA_SET)\n+DEF_BUILTIN (CORE_READ,  1, usint_ftype_usint,      core_read,  1)\n+DEF_BUILTIN (LR,         1, usint_ftype_usint,      lr,         1)\n+DEF_BUILTIN (FFS,        1, int_ftype_int,          ffs,        (TARGET_EM && TARGET_NORM) || TARGET_HS)\n+DEF_BUILTIN (FLS,        1, int_ftype_int,          fls,        (TARGET_EM && TARGET_NORM) || TARGET_HS)\n+\n+/* ARC SIMD extenssion.  */\n+/* BEGIN SIMD marker.  */\n+DEF_BUILTIN (SIMD_BEGIN, 0, void_ftype_void, nothing, 0)\n+\n+DEF_BUILTIN ( VADDAW, 2, v8hi_ftype_v8hi_v8hi,  vaddaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VADDW, 2, v8hi_ftype_v8hi_v8hi,   vaddw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VAVB, 2, v8hi_ftype_v8hi_v8hi,    vavb_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VAVRB, 2, v8hi_ftype_v8hi_v8hi,   vavrb_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VDIFAW, 2, v8hi_ftype_v8hi_v8hi,  vdifaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VDIFW, 2, v8hi_ftype_v8hi_v8hi,   vdifw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMAXAW, 2, v8hi_ftype_v8hi_v8hi,  vmaxaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMAXW, 2, v8hi_ftype_v8hi_v8hi,   vmaxw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMINAW, 2, v8hi_ftype_v8hi_v8hi,  vminaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMINW, 2, v8hi_ftype_v8hi_v8hi,   vminw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMULAW, 2, v8hi_ftype_v8hi_v8hi,  vmulaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VMULFAW, 2, v8hi_ftype_v8hi_v8hi, vmulfaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMULFW, 2, v8hi_ftype_v8hi_v8hi,  vmulfw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMULW, 2, v8hi_ftype_v8hi_v8hi,   vmulw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VSUBAW, 2, v8hi_ftype_v8hi_v8hi,  vsubaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VSUBW, 2, v8hi_ftype_v8hi_v8hi,   vsubw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VSUMMW, 2, v8hi_ftype_v8hi_v8hi,  vsummw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VAND, 2, v8hi_ftype_v8hi_v8hi,    vand_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VANDAW, 2, v8hi_ftype_v8hi_v8hi,  vandaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VBIC, 2, v8hi_ftype_v8hi_v8hi,    vbic_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VBICAW, 2, v8hi_ftype_v8hi_v8hi,  vbicaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (    VOR, 2, v8hi_ftype_v8hi_v8hi,     vor_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VXOR, 2, v8hi_ftype_v8hi_v8hi,    vxor_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VXORAW, 2, v8hi_ftype_v8hi_v8hi,  vxoraw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VEQW, 2, v8hi_ftype_v8hi_v8hi,    veqw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VLEW, 2, v8hi_ftype_v8hi_v8hi,    vlew_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VLTW, 2, v8hi_ftype_v8hi_v8hi,    vltw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VNEW, 2, v8hi_ftype_v8hi_v8hi,    vnew_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR1AW, 2, v8hi_ftype_v8hi_v8hi,  vmr1aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR1W, 2, v8hi_ftype_v8hi_v8hi,   vmr1w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR2AW, 2, v8hi_ftype_v8hi_v8hi,  vmr2aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR2W, 2, v8hi_ftype_v8hi_v8hi,   vmr2w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR3AW, 2, v8hi_ftype_v8hi_v8hi,  vmr3aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR3W, 2, v8hi_ftype_v8hi_v8hi,   vmr3w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR4AW, 2, v8hi_ftype_v8hi_v8hi,  vmr4aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR4W, 2, v8hi_ftype_v8hi_v8hi,   vmr4w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR5AW, 2, v8hi_ftype_v8hi_v8hi,  vmr5aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR5W, 2, v8hi_ftype_v8hi_v8hi,   vmr5w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR6AW, 2, v8hi_ftype_v8hi_v8hi,  vmr6aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR6W, 2, v8hi_ftype_v8hi_v8hi,   vmr6w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMR7AW, 2, v8hi_ftype_v8hi_v8hi,  vmr7aw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMR7W, 2, v8hi_ftype_v8hi_v8hi,   vmr7w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VMRB, 2, v8hi_ftype_v8hi_v8hi,    vmrb_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VH264F, 2, v8hi_ftype_v8hi_v8hi,  vh264f_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VH264FT, 2, v8hi_ftype_v8hi_v8hi, vh264ft_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VH264FW, 2, v8hi_ftype_v8hi_v8hi, vh264fw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VVC1F, 2, v8hi_ftype_v8hi_v8hi,   vvc1f_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VVC1FT, 2, v8hi_ftype_v8hi_v8hi,  vvc1ft_insn, TARGET_SIMD_SET)\n+\n+DEF_BUILTIN ( VBADDW, 2, v8hi_ftype_v8hi_int,  vbaddw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VBMAXW, 2, v8hi_ftype_v8hi_int,  vbmaxw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VBMINW, 2, v8hi_ftype_v8hi_int,  vbminw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VBMULAW, 2, v8hi_ftype_v8hi_int, vbmulaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VBMULFW, 2, v8hi_ftype_v8hi_int, vbmulfw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VBMULW, 2, v8hi_ftype_v8hi_int,  vbmulw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VBRSUBW, 2, v8hi_ftype_v8hi_int, vbrsubw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VBSUBW, 2, v8hi_ftype_v8hi_int,  vbsubw_insn, TARGET_SIMD_SET)\n+\n+/* Va, Vb, Ic instructions.  */\n+DEF_BUILTIN ( VASRW, 2, v8hi_ftype_v8hi_int,  vasrw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VSR8, 2, v8hi_ftype_v8hi_int,   vsr8_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VSR8AW, 2, v8hi_ftype_v8hi_int, vsr8aw_insn, TARGET_SIMD_SET)\n+\n+/* Va, Vb, u6 instructions.  */\n+DEF_BUILTIN (  VASRRWi, 2, v8hi_ftype_v8hi_int,   vasrrwi_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VASRSRWi, 2, v8hi_ftype_v8hi_int,  vasrsrwi_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VASRWi, 2, v8hi_ftype_v8hi_int,    vasrwi_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VASRPWBi, 2, v8hi_ftype_v8hi_int,  vasrpwbi_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VASRRPWBi, 2, v8hi_ftype_v8hi_int, vasrrpwbi_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VSR8AWi, 2, v8hi_ftype_v8hi_int,   vsr8awi_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (    VSR8i, 2, v8hi_ftype_v8hi_int,     vsr8i_insn, TARGET_SIMD_SET)\n+\n+/* Va, Vb, u8 (simm) instructions.  */\n+DEF_BUILTIN (  VMVAW, 2, v8hi_ftype_v8hi_int,   vmvaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VMVW, 2, v8hi_ftype_v8hi_int,    vmvw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VMVZW, 2, v8hi_ftype_v8hi_int,   vmvzw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VD6TAPF, 2, v8hi_ftype_v8hi_int, vd6tapf_insn, TARGET_SIMD_SET)\n+\n+/* Va, rlimm, u8 (simm) instructions.  */\n+DEF_BUILTIN (VMOVAW, 2, v8hi_ftype_int_int, vmovaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VMOVW, 2, v8hi_ftype_int_int,  vmovw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VMOVZW, 2, v8hi_ftype_int_int, vmovzw_insn, TARGET_SIMD_SET)\n+\n+/* Va, Vb instructions.  */\n+DEF_BUILTIN ( VABSAW, 1, v8hi_ftype_v8hi,  vabsaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VABSW, 1, v8hi_ftype_v8hi,   vabsw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VADDSUW, 1, v8hi_ftype_v8hi, vaddsuw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VSIGNW, 1, v8hi_ftype_v8hi,  vsignw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VEXCH1, 1, v8hi_ftype_v8hi,  vexch1_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VEXCH2, 1, v8hi_ftype_v8hi,  vexch2_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VEXCH4, 1, v8hi_ftype_v8hi,  vexch4_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VUPBAW, 1, v8hi_ftype_v8hi,  vupbaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VUPBW, 1, v8hi_ftype_v8hi,   vupbw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VUPSBAW, 1, v8hi_ftype_v8hi, vupsbaw_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VUPSBW, 1, v8hi_ftype_v8hi,  vupsbw_insn, TARGET_SIMD_SET)\n+\n+/* SIMD special DIb, rlimm, rlimm instructions.  */\n+DEF_BUILTIN (VDIRUN, 2, void_ftype_int_int, vdirun_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VDORUN, 2, void_ftype_int_int, vdorun_insn, TARGET_SIMD_SET)\n+\n+/* SIMD special DIb, limm, rlimm instructions.  */\n+DEF_BUILTIN (VDIWR, 2, void_ftype_int_int, vdiwr_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VDOWR, 2, void_ftype_int_int, vdowr_insn, TARGET_SIMD_SET)\n+\n+/* rlimm instructions.  */\n+DEF_BUILTIN (   VREC, 1, void_ftype_int,    vrec_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (   VRUN, 1, void_ftype_int,    vrun_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VRECRUN, 1, void_ftype_int, vrecrun_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VENDREC, 1, void_ftype_int, vendrec_insn, TARGET_SIMD_SET)\n+\n+/* Va, [Ib,u8] instructions.  */\n+DEF_BUILTIN (VLD32WH, 3, v8hi_ftype_v8hi_int_int, vld32wh_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VLD32WL, 3, v8hi_ftype_v8hi_int_int, vld32wl_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VLD64, 3, v8hi_ftype_v8hi_int_int,   vld64_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (  VLD32, 3, v8hi_ftype_v8hi_int_int,   vld32_insn, TARGET_SIMD_SET)\n+\n+DEF_BUILTIN (VLD64W, 2, v8hi_ftype_int_int,      vld64w_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VLD128, 2, v8hi_ftype_int_int,      vld128_insn, TARGET_SIMD_SET)\n+\n+DEF_BUILTIN (VST128, 3, void_ftype_v8hi_int_int, vst128_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN ( VST64, 3, void_ftype_v8hi_int_int,  vst64_insn, TARGET_SIMD_SET)\n+\n+/* Va, [Ib, u8] instructions.  */\n+DEF_BUILTIN (VST16_N, 4, void_ftype_v8hi_int_int_int, vst16_n_insn, TARGET_SIMD_SET)\n+DEF_BUILTIN (VST32_N, 4, void_ftype_v8hi_int_int_int, vst32_n_insn, TARGET_SIMD_SET)\n+\n+DEF_BUILTIN (VINTI, 1, void_ftype_int, vinti_insn, TARGET_SIMD_SET)\n+\n+/* END SIMD marker.  */\n+DEF_BUILTIN (SIMD_END, 0, void_ftype_void, nothing, 0)"}, {"sha": "1637981a652f39795e0df2d860a934fb2298005f", "filename": "gcc/config/arc/fpx.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Ffpx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Ffpx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Ffpx.md?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -151,7 +151,7 @@\n ;; op0_reg = D1_reg.low\n (define_insn \"*lr_double_lower\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec_volatile:SI [(match_operand:DF 1 \"arc_double_register_operand\" \"D\")] VUNSPEC_LR ))]\n+\t(unspec_volatile:SI [(match_operand:DF 1 \"arc_double_register_operand\" \"D\")] VUNSPEC_ARC_LR ))]\n  \"TARGET_DPFP && !TARGET_DPFP_DISABLE_LRSR\"\n \"lr %0, [%1l] ; *lr_double_lower\"\n [(set_attr \"length\" \"8\")\n@@ -160,7 +160,8 @@\n \n (define_insn \"*lr_double_higher\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(unspec_volatile:SI [(match_operand:DF 1 \"arc_double_register_operand\" \"D\")] VUNSPEC_LR_HIGH ))]\n+\t(unspec_volatile:SI [(match_operand:DF 1 \"arc_double_register_operand\" \"D\")]\n+\t\t\t    VUNSPEC_ARC_LR_HIGH ))]\n  \"TARGET_DPFP && !TARGET_DPFP_DISABLE_LRSR\"\n \"lr %0, [%1h] ; *lr_double_higher\"\n [(set_attr \"length\" \"8\")\n@@ -174,7 +175,7 @@\n \t\t   \t\t\t(match_operand:DF 1 \"arc_double_register_operand\" \"D\")\n \t\t\t\t\t(match_operand:SI 2 \"shouldbe_register_operand\" \"r\")  ; r1\n \t\t\t\t\t(match_operand:SI 3 \"shouldbe_register_operand\" \"r\") ; r0\n-\t\t\t\t\t] VUNSPEC_DEXCL ))\n+\t\t\t\t\t] VUNSPEC_ARC_DEXCL ))\n   ]\n   \"TARGET_DPFP\"\n   \"dexcl%F1 %0, %2, %3\"\n@@ -188,7 +189,7 @@\n \t\t   \t\t\t(match_operand:DF 0 \"arc_double_register_operand\" \"D\")\n \t\t\t\t\t(match_operand:SI 1 \"shouldbe_register_operand\" \"r\")  ; r1\n \t\t\t\t\t(match_operand:SI 2 \"shouldbe_register_operand\" \"r\") ; r0\n-\t\t\t\t\t] VUNSPEC_DEXCL_NORES )\n+\t\t\t\t\t] VUNSPEC_ARC_DEXCL_NORES )\n   ]\n   \"TARGET_DPFP\"\n   \"dexcl%F0 0, %1, %2\"\n@@ -199,7 +200,7 @@\n ;; dexcl a,b,c pattern generated by the peephole2 above\n (define_insn \"*dexcl_3op_peep2_insn_lr\"\n   [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t\t   (unspec_volatile:SI [(match_operand:DF 1 \"arc_double_register_operand\" \"=D\")] VUNSPEC_LR ))\n+\t\t   (unspec_volatile:SI [(match_operand:DF 1 \"arc_double_register_operand\" \"=D\")] VUNSPEC_ARC_LR ))\n \t     (set (match_dup 1) (match_operand:DF 2 \"register_operand\" \"r\"))]\n \t    )\n   ]\n@@ -413,7 +414,7 @@\n ;;   (parallel [\n ;; ;;\t    (set (subreg:SI (match_dup 5) 0)\n ;; \t    (set (match_dup 7)\n-;; \t\t (unspec_volatile [(match_dup 0)] VUNSPEC_LR ))\n+;; \t\t (unspec_volatile [(match_dup 0)] VUNSPEC_ARC_LR ))\n ;; \t    (set (match_dup 0) (match_dup 6))]\n ;; \t    )\n ;;   ]\n@@ -472,7 +473,7 @@\n   (parallel [\n ;;\t    (set (subreg:SI (match_dup 7) 0)\n \t    (set (match_dup 9)\n-\t\t (unspec_volatile:SI [(match_dup 0)] VUNSPEC_LR ))\n+\t\t (unspec_volatile:SI [(match_dup 0)] VUNSPEC_ARC_LR ))\n \t    (set (match_dup 0) (match_dup 8))]\n \t    )\n   ]\n@@ -522,7 +523,7 @@\n ;; \t\t\t\t   (match_dup 3)]))])\n ;; ;  (set (subreg:SI (match_dup 5) 0)\n ;;   (set (match_dup 6)\n-;;        (unspec_volatile [(match_dup 0)] VUNSPEC_LR ))\n+;;        (unspec_volatile [(match_dup 0)] VUNSPEC_ARC_LR ))\n ;;   ]\n ;;   \"operands[6] = simplify_gen_subreg(SImode,operands[5],DFmode,0);\"\n ;;   )\n@@ -572,7 +573,7 @@\n \t\t\t\t   (match_dup 3)]))])\n ;  (set (subreg:SI (match_dup 7) 0)\n   (set (match_dup 8)\n-       (unspec_volatile:SI [(match_dup 0)] VUNSPEC_LR ))\n+       (unspec_volatile:SI [(match_dup 0)] VUNSPEC_ARC_LR ))\n   ]\n   \"operands[8] = simplify_gen_subreg(SImode,operands[7],DFmode,0);\"\n   )"}, {"sha": "e3002f2a2e41de701bcf164daf105a5e8f61bc40", "filename": "gcc/config/arc/simdext.md", "status": "modified", "additions": 115, "deletions": 117, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Fsimdext.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Fconfig%2Farc%2Fsimdext.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fsimdext.md?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -17,119 +17,117 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n-(define_constants\n-  [\n+(define_c_enum \"unspec\" [\n   ;; Va, Vb, Vc builtins\n-  (UNSPEC_ARC_SIMD_VADDAW     1000)\n-  (UNSPEC_ARC_SIMD_VADDW      1001)\n-  (UNSPEC_ARC_SIMD_VAVB       1002)\n-  (UNSPEC_ARC_SIMD_VAVRB      1003)\n-  (UNSPEC_ARC_SIMD_VDIFAW     1004)\n-  (UNSPEC_ARC_SIMD_VDIFW      1005)\n-  (UNSPEC_ARC_SIMD_VMAXAW     1006)\n-  (UNSPEC_ARC_SIMD_VMAXW      1007)\n-  (UNSPEC_ARC_SIMD_VMINAW     1008)\n-  (UNSPEC_ARC_SIMD_VMINW      1009)\n-  (UNSPEC_ARC_SIMD_VMULAW     1010)\n-  (UNSPEC_ARC_SIMD_VMULFAW    1011)\n-  (UNSPEC_ARC_SIMD_VMULFW     1012)\n-  (UNSPEC_ARC_SIMD_VMULW      1013)\n-  (UNSPEC_ARC_SIMD_VSUBAW     1014)\n-  (UNSPEC_ARC_SIMD_VSUBW      1015)\n-  (UNSPEC_ARC_SIMD_VSUMMW     1016)\n-  (UNSPEC_ARC_SIMD_VAND       1017)\n-  (UNSPEC_ARC_SIMD_VANDAW     1018)\n-  (UNSPEC_ARC_SIMD_VBIC       1019)\n-  (UNSPEC_ARC_SIMD_VBICAW     1020)\n-  (UNSPEC_ARC_SIMD_VOR        1021)\n-  (UNSPEC_ARC_SIMD_VXOR       1022)\n-  (UNSPEC_ARC_SIMD_VXORAW     1023)\n-  (UNSPEC_ARC_SIMD_VEQW       1024)\n-  (UNSPEC_ARC_SIMD_VLEW       1025)\n-  (UNSPEC_ARC_SIMD_VLTW       1026)\n-  (UNSPEC_ARC_SIMD_VNEW       1027)\n-  (UNSPEC_ARC_SIMD_VMR1AW     1028)\n-  (UNSPEC_ARC_SIMD_VMR1W      1029)\n-  (UNSPEC_ARC_SIMD_VMR2AW     1030)\n-  (UNSPEC_ARC_SIMD_VMR2W      1031)\n-  (UNSPEC_ARC_SIMD_VMR3AW     1032)\n-  (UNSPEC_ARC_SIMD_VMR3W      1033)\n-  (UNSPEC_ARC_SIMD_VMR4AW     1034)\n-  (UNSPEC_ARC_SIMD_VMR4W      1035)\n-  (UNSPEC_ARC_SIMD_VMR5AW     1036)\n-  (UNSPEC_ARC_SIMD_VMR5W      1037)\n-  (UNSPEC_ARC_SIMD_VMR6AW     1038)\n-  (UNSPEC_ARC_SIMD_VMR6W      1039)\n-  (UNSPEC_ARC_SIMD_VMR7AW     1040)\n-  (UNSPEC_ARC_SIMD_VMR7W      1041)\n-  (UNSPEC_ARC_SIMD_VMRB       1042)\n-  (UNSPEC_ARC_SIMD_VH264F     1043)\n-  (UNSPEC_ARC_SIMD_VH264FT    1044)\n-  (UNSPEC_ARC_SIMD_VH264FW    1045)\n-  (UNSPEC_ARC_SIMD_VVC1F      1046)\n-  (UNSPEC_ARC_SIMD_VVC1FT     1047)\n+  UNSPEC_ARC_SIMD_VADDAW\n+  UNSPEC_ARC_SIMD_VADDW\n+  UNSPEC_ARC_SIMD_VAVB\n+  UNSPEC_ARC_SIMD_VAVRB\n+  UNSPEC_ARC_SIMD_VDIFAW\n+  UNSPEC_ARC_SIMD_VDIFW\n+  UNSPEC_ARC_SIMD_VMAXAW\n+  UNSPEC_ARC_SIMD_VMAXW\n+  UNSPEC_ARC_SIMD_VMINAW\n+  UNSPEC_ARC_SIMD_VMINW\n+  UNSPEC_ARC_SIMD_VMULAW\n+  UNSPEC_ARC_SIMD_VMULFAW\n+  UNSPEC_ARC_SIMD_VMULFW\n+  UNSPEC_ARC_SIMD_VMULW\n+  UNSPEC_ARC_SIMD_VSUBAW\n+  UNSPEC_ARC_SIMD_VSUBW\n+  UNSPEC_ARC_SIMD_VSUMMW\n+  UNSPEC_ARC_SIMD_VAND\n+  UNSPEC_ARC_SIMD_VANDAW\n+  UNSPEC_ARC_SIMD_VBIC\n+  UNSPEC_ARC_SIMD_VBICAW\n+  UNSPEC_ARC_SIMD_VOR\n+  UNSPEC_ARC_SIMD_VXOR\n+  UNSPEC_ARC_SIMD_VXORAW\n+  UNSPEC_ARC_SIMD_VEQW\n+  UNSPEC_ARC_SIMD_VLEW\n+  UNSPEC_ARC_SIMD_VLTW\n+  UNSPEC_ARC_SIMD_VNEW\n+  UNSPEC_ARC_SIMD_VMR1AW\n+  UNSPEC_ARC_SIMD_VMR1W\n+  UNSPEC_ARC_SIMD_VMR2AW\n+  UNSPEC_ARC_SIMD_VMR2W\n+  UNSPEC_ARC_SIMD_VMR3AW\n+  UNSPEC_ARC_SIMD_VMR3W\n+  UNSPEC_ARC_SIMD_VMR4AW\n+  UNSPEC_ARC_SIMD_VMR4W\n+  UNSPEC_ARC_SIMD_VMR5AW\n+  UNSPEC_ARC_SIMD_VMR5W\n+  UNSPEC_ARC_SIMD_VMR6AW\n+  UNSPEC_ARC_SIMD_VMR6W\n+  UNSPEC_ARC_SIMD_VMR7AW\n+  UNSPEC_ARC_SIMD_VMR7W\n+  UNSPEC_ARC_SIMD_VMRB\n+  UNSPEC_ARC_SIMD_VH264F\n+  UNSPEC_ARC_SIMD_VH264FT\n+  UNSPEC_ARC_SIMD_VH264FW\n+  UNSPEC_ARC_SIMD_VVC1F\n+  UNSPEC_ARC_SIMD_VVC1FT\n   ;; Va, Vb, rc/limm builtins\n-  (UNSPEC_ARC_SIMD_VBADDW     1050)\n-  (UNSPEC_ARC_SIMD_VBMAXW     1051)\n-  (UNSPEC_ARC_SIMD_VBMINW     1052)\n-  (UNSPEC_ARC_SIMD_VBMULAW    1053)\n-  (UNSPEC_ARC_SIMD_VBMULFW    1054)\n-  (UNSPEC_ARC_SIMD_VBMULW     1055)\n-  (UNSPEC_ARC_SIMD_VBRSUBW    1056)\n-  (UNSPEC_ARC_SIMD_VBSUBW     1057)\n+  UNSPEC_ARC_SIMD_VBADDW\n+  UNSPEC_ARC_SIMD_VBMAXW\n+  UNSPEC_ARC_SIMD_VBMINW\n+  UNSPEC_ARC_SIMD_VBMULAW\n+  UNSPEC_ARC_SIMD_VBMULFW\n+  UNSPEC_ARC_SIMD_VBMULW\n+  UNSPEC_ARC_SIMD_VBRSUBW\n+  UNSPEC_ARC_SIMD_VBSUBW\n \n   ;; Va, Vb, Ic builtins\n-  (UNSPEC_ARC_SIMD_VASRW      1060)\n-  (UNSPEC_ARC_SIMD_VSR8       1061)\n-  (UNSPEC_ARC_SIMD_VSR8AW     1062)\n+  UNSPEC_ARC_SIMD_VASRW\n+  UNSPEC_ARC_SIMD_VSR8\n+  UNSPEC_ARC_SIMD_VSR8AW\n \n   ;; Va, Vb, Ic builtins\n-  (UNSPEC_ARC_SIMD_VASRRWi    1065)\n-  (UNSPEC_ARC_SIMD_VASRSRWi   1066)\n-  (UNSPEC_ARC_SIMD_VASRWi     1067)\n-  (UNSPEC_ARC_SIMD_VASRPWBi   1068)\n-  (UNSPEC_ARC_SIMD_VASRRPWBi  1069)\n-  (UNSPEC_ARC_SIMD_VSR8AWi    1070)\n-  (UNSPEC_ARC_SIMD_VSR8i      1071)\n+  UNSPEC_ARC_SIMD_VASRRWi\n+  UNSPEC_ARC_SIMD_VASRSRWi\n+  UNSPEC_ARC_SIMD_VASRWi\n+  UNSPEC_ARC_SIMD_VASRPWBi\n+  UNSPEC_ARC_SIMD_VASRRPWBi\n+  UNSPEC_ARC_SIMD_VSR8AWi\n+  UNSPEC_ARC_SIMD_VSR8i\n \n   ;; Va, Vb, u8 (simm) builtins\n-  (UNSPEC_ARC_SIMD_VMVAW      1075)\n-  (UNSPEC_ARC_SIMD_VMVW       1076)\n-  (UNSPEC_ARC_SIMD_VMVZW      1077)\n-  (UNSPEC_ARC_SIMD_VD6TAPF    1078)\n+  UNSPEC_ARC_SIMD_VMVAW\n+  UNSPEC_ARC_SIMD_VMVW\n+  UNSPEC_ARC_SIMD_VMVZW\n+  UNSPEC_ARC_SIMD_VD6TAPF\n \n   ;; Va, rlimm, u8 (simm) builtins\n-  (UNSPEC_ARC_SIMD_VMOVAW     1080)\n-  (UNSPEC_ARC_SIMD_VMOVW      1081)\n-  (UNSPEC_ARC_SIMD_VMOVZW     1082)\n+  UNSPEC_ARC_SIMD_VMOVAW\n+  UNSPEC_ARC_SIMD_VMOVW\n+  UNSPEC_ARC_SIMD_VMOVZW\n \n   ;; Va, Vb builtins\n-  (UNSPEC_ARC_SIMD_VABSAW     1085)\n-  (UNSPEC_ARC_SIMD_VABSW      1086)\n-  (UNSPEC_ARC_SIMD_VADDSUW    1087)\n-  (UNSPEC_ARC_SIMD_VSIGNW     1088)\n-  (UNSPEC_ARC_SIMD_VEXCH1     1089)\n-  (UNSPEC_ARC_SIMD_VEXCH2     1090)\n-  (UNSPEC_ARC_SIMD_VEXCH4     1091)\n-  (UNSPEC_ARC_SIMD_VUPBAW     1092)\n-  (UNSPEC_ARC_SIMD_VUPBW      1093)\n-  (UNSPEC_ARC_SIMD_VUPSBAW    1094)\n-  (UNSPEC_ARC_SIMD_VUPSBW     1095)\n-\n-  (UNSPEC_ARC_SIMD_VDIRUN     1100)\n-  (UNSPEC_ARC_SIMD_VDORUN     1101)\n-  (UNSPEC_ARC_SIMD_VDIWR      1102)\n-  (UNSPEC_ARC_SIMD_VDOWR      1103)\n-\n-  (UNSPEC_ARC_SIMD_VREC      1105)\n-  (UNSPEC_ARC_SIMD_VRUN      1106)\n-  (UNSPEC_ARC_SIMD_VRECRUN   1107)\n-  (UNSPEC_ARC_SIMD_VENDREC   1108)\n-\n-  (UNSPEC_ARC_SIMD_VCAST     1200)\n-  (UNSPEC_ARC_SIMD_VINTI     1201)\n-   ]\n-)\n+  UNSPEC_ARC_SIMD_VABSAW\n+  UNSPEC_ARC_SIMD_VABSW\n+  UNSPEC_ARC_SIMD_VADDSUW\n+  UNSPEC_ARC_SIMD_VSIGNW\n+  UNSPEC_ARC_SIMD_VEXCH1\n+  UNSPEC_ARC_SIMD_VEXCH2\n+  UNSPEC_ARC_SIMD_VEXCH4\n+  UNSPEC_ARC_SIMD_VUPBAW\n+  UNSPEC_ARC_SIMD_VUPBW\n+  UNSPEC_ARC_SIMD_VUPSBAW\n+  UNSPEC_ARC_SIMD_VUPSBW\n+\n+  UNSPEC_ARC_SIMD_VDIRUN\n+  UNSPEC_ARC_SIMD_VDORUN\n+  UNSPEC_ARC_SIMD_VDIWR\n+  UNSPEC_ARC_SIMD_VDOWR\n+\n+  UNSPEC_ARC_SIMD_VREC\n+  UNSPEC_ARC_SIMD_VRUN\n+  UNSPEC_ARC_SIMD_VRECRUN\n+  UNSPEC_ARC_SIMD_VENDREC\n+\n+  UNSPEC_ARC_SIMD_VCAST\n+  UNSPEC_ARC_SIMD_VINTI\n+  ])\n \n ;; Scheduler descriptions for the simd instructions\n (define_insn_reservation \"simd_lat_0_insn\" 1\n@@ -138,19 +136,19 @@\n \n (define_insn_reservation \"simd_lat_1_insn\" 2\n        (eq_attr \"type\" \"simd_vcompare, simd_vlogic,\n-                        simd_vmove_else_zero, simd_varith_1cycle\")\n+\t\t\tsimd_vmove_else_zero, simd_varith_1cycle\")\n   \"issue+simd_unit, nothing\")\n \n (define_insn_reservation \"simd_lat_2_insn\" 3\n        (eq_attr \"type\" \"simd_valign, simd_vpermute,\n-                        simd_vpack, simd_varith_2cycle\")\n+\t\t\tsimd_vpack, simd_varith_2cycle\")\n   \"issue+simd_unit, nothing*2\")\n \n (define_insn_reservation \"simd_lat_3_insn\" 4\n        (eq_attr \"type\" \"simd_valign_with_acc, simd_vpack_with_acc,\n-                        simd_vlogic_with_acc, simd_vload128,\n-                        simd_vmove_with_acc, simd_vspecial_3cycle,\n-                        simd_varith_with_acc\")\n+\t\t\tsimd_vlogic_with_acc, simd_vload128,\n+\t\t\tsimd_vmove_with_acc, simd_vspecial_3cycle,\n+\t\t\tsimd_varith_with_acc\")\n   \"issue+simd_unit, nothing*3\")\n \n (define_insn_reservation \"simd_lat_4_insn\" 5\n@@ -917,7 +915,7 @@\n \n (define_insn \"vmvaw_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n+\t(unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VMVAW))]\n   \"TARGET_SIMD_SET\"\n   \"vmvaw %0, %1, %2\"\n@@ -927,7 +925,7 @@\n \n (define_insn \"vmvw_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n+\t(unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VMVW))]\n   \"TARGET_SIMD_SET\"\n   \"vmvw %0, %1, %2\"\n@@ -937,7 +935,7 @@\n \n (define_insn \"vmvzw_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n+\t(unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VMVZW))]\n   \"TARGET_SIMD_SET\"\n   \"vmvzw %0, %1, %2\"\n@@ -947,7 +945,7 @@\n \n (define_insn \"vd6tapf_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n+\t(unspec:V8HI [(match_operand:V8HI 1 \"vector_register_operand\"  \"v\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VD6TAPF))]\n   \"TARGET_SIMD_SET\"\n   \"vd6tapf %0, %1, %2\"\n@@ -958,7 +956,7 @@\n ;; Va, rlimm, u8 (simm) insns\n (define_insn \"vmovaw_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n+\t(unspec:V8HI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VMOVAW))]\n   \"TARGET_SIMD_SET\"\n   \"vmovaw %0, %1, %2\"\n@@ -968,7 +966,7 @@\n \n (define_insn \"vmovw_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n+\t(unspec:V8HI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VMOVW))]\n   \"TARGET_SIMD_SET\"\n   \"vmovw %0, %1, %2\"\n@@ -978,7 +976,7 @@\n \n (define_insn \"vmovzw_insn\"\n   [(set (match_operand:V8HI 0 \"vector_register_operand\"           \"=v\")\n-        (unspec:V8HI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n+\t(unspec:V8HI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"P\")] UNSPEC_ARC_SIMD_VMOVZW))]\n   \"TARGET_SIMD_SET\"\n   \"vmovzw %0, %1, %2\"\n@@ -1123,7 +1121,7 @@\n ; DMA setup instructions\n (define_insn \"vdirun_insn\"\n   [(set (match_operand:SI 0 \"arc_simd_dma_register_operand\"           \"=d\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"  \"r\")\n \t\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"r\")] UNSPEC_ARC_SIMD_VDIRUN))]\n   \"TARGET_SIMD_SET\"\n   \"vdirun %1, %2\"\n@@ -1133,7 +1131,7 @@\n \n (define_insn \"vdorun_insn\"\n   [(set (match_operand:SI 0 \"arc_simd_dma_register_operand\"              \"=d\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"     \"r\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"     \"r\")\n \t\t\t     (match_operand:SI 2 \"nonmemory_operand\"     \"r\")] UNSPEC_ARC_SIMD_VDORUN))]\n   \"TARGET_SIMD_SET\"\n   \"vdorun %1, %2\"\n@@ -1143,7 +1141,7 @@\n \n (define_insn \"vdiwr_insn\"\n   [(set (match_operand:SI 0 \"arc_simd_dma_register_operand\"           \"=d,d\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"  \"r,Cal\")] UNSPEC_ARC_SIMD_VDIWR))]\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"  \"r,Cal\")] UNSPEC_ARC_SIMD_VDIWR))]\n   \"TARGET_SIMD_SET\"\n   \"vdiwr %0, %1\"\n   [(set_attr \"type\" \"simd_dma\")\n@@ -1152,7 +1150,7 @@\n \n (define_insn \"vdowr_insn\"\n   [(set (match_operand:SI 0 \"arc_simd_dma_register_operand\"           \"=d,d\")\n-        (unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"  \"r,Cal\")] UNSPEC_ARC_SIMD_VDOWR))]\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"nonmemory_operand\"  \"r,Cal\")] UNSPEC_ARC_SIMD_VDOWR))]\n   \"TARGET_SIMD_SET\"\n   \"vdowr %0, %1\"\n   [(set_attr \"type\" \"simd_dma\")"}, {"sha": "bb2ed22edf6307877614785a812b72510b02cfac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -1,3 +1,9 @@\n+2015-12-21  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/builtin_general.c: New test.\n+\t* gcc.target/arc/builtin_simd.c: Likewise.\n+\t* gcc.target/arc/builtin_special.c: Likewise.\n+\n 2015-12-20  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/64910"}, {"sha": "c6965c2b8ea6074ddc6e5e6bda7df6426bf352de", "filename": "gcc/testsuite/gcc.target/arc/builtin_general.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_general.c?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration\" } */\n+\n+#define NORET1OP(name, op1type)\t\t\t\\\n+  void test_ ## name ## _0 (op1type a)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    __builtin_arc_ ## name (a);\t\t\t\\\n+  }\t\t\t\t\t\t\\\n+  void test_ ## name ## _1 (void)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    __builtin_arc_ ## name (0x10);\t\t\\\n+  }\n+\n+#define RET1OP(name, rettype, op1type)\t\t\\\n+  rettype test_ ## name ## _0 (op1type a)\t\\\n+  {\t\t\t\t\t\t\\\n+    return __builtin_arc_ ## name (a);\t\t\\\n+  }\t\t\t\t\t\t\\\n+  rettype test_ ## name ## _1 (void)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return __builtin_arc_ ## name (0x10);\t\\\n+  }\n+\n+NORET1OP (flag, unsigned int)\n+\n+#if defined (__EM__) || defined (__HS__)\n+NORET1OP (kflag, unsigned int)\n+NORET1OP (seti, int)\n+#endif\n+\n+\n+#ifdef __ARC_NORM__\n+RET1OP (norm, int, int)\n+RET1OP (normw, int, short)\n+#endif\n+"}, {"sha": "fff27a479607f95e4ac1e35f3a463e24302592ab", "filename": "gcc/testsuite/gcc.target/arc/builtin_simd.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_simd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_simd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_simd.c?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -0,0 +1,171 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration -mARC700 -msimd\" } */\n+\n+#define STEST1(name, rettype, op1)\t\t\\\n+  rettype test_ ## name                         \\\n+  (void)\t\t\t\t\t\\\n+  {                                             \\\n+    return __builtin_arc_ ## name (op1);\t\\\n+  }\n+\n+#define STEST2(name, rettype, op1, op2)  \\\n+  rettype test_ ## name                         \\\n+  (void)\t\t\t\t\t\\\n+  {                                             \\\n+    return __builtin_arc_ ## name (op1, op2);\t\\\n+  }\n+\n+#define STEST3(name, rettype, op1, op2, op3)\t\\\n+  rettype test_ ## name                         \\\n+  (void)\t\t\t\t\t\\\n+  {                                             \\\n+    return __builtin_arc_ ## name (op1, op2, op3);\t\\\n+  }\n+\n+#define STEST4(name, rettype, op1, op2, op3, op4)\t\\\n+  rettype test_ ## name\t\t\t\t\t\\\n+  (void)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    return __builtin_arc_ ## name (op1, op2, op3, op4);\t\\\n+  }\n+\n+typedef short v8hi __attribute__ ((vector_size (16)));\n+\n+v8hi Va;\n+v8hi Vb;\n+v8hi Vc;\n+#define rlimm 0xf3eec0fe\n+#define Ic    0x02\n+#define Ib    0x02\n+#define u3    0x02\n+#define u6    0x1F\n+#define u8    0xB0\n+\n+STEST2 ( vaddaw, v8hi, Vb, Vc)\n+STEST2 (  vaddw, v8hi, Vb, Vc)\n+STEST2 (   vavb, v8hi, Vb, Vc)\n+STEST2 (  vavrb, v8hi, Vb, Vc)\n+STEST2 ( vdifaw, v8hi, Vb, Vc)\n+STEST2 (  vdifw, v8hi, Vb, Vc)\n+STEST2 ( vmaxaw, v8hi, Vb, Vc)\n+STEST2 (  vmaxw, v8hi, Vb, Vc)\n+STEST2 ( vminaw, v8hi, Vb, Vc)\n+STEST2 (  vminw, v8hi, Vb, Vc)\n+STEST2 ( vmulaw, v8hi, Vb, Vc)\n+STEST2 (vmulfaw, v8hi, Vb, Vc)\n+STEST2 ( vmulfw, v8hi, Vb, Vc)\n+STEST2 (  vmulw, v8hi, Vb, Vc)\n+STEST2 ( vsubaw, v8hi, Vb, Vc)\n+STEST2 (  vsubw, v8hi, Vb, Vc)\n+STEST2 ( vsummw, v8hi, Vb, Vc)\n+STEST2 (   vand, v8hi, Vb, Vc)\n+STEST2 ( vandaw, v8hi, Vb, Vc)\n+STEST2 (   vbic, v8hi, Vb, Vc)\n+STEST2 ( vbicaw, v8hi, Vb, Vc)\n+STEST2 (    vor, v8hi, Vb, Vc)\n+STEST2 (   vxor, v8hi, Vb, Vc)\n+STEST2 ( vxoraw, v8hi, Vb, Vc)\n+STEST2 (   veqw, v8hi, Vb, Vc)\n+STEST2 (   vlew, v8hi, Vb, Vc)\n+STEST2 (   vltw, v8hi, Vb, Vc)\n+STEST2 (   vnew, v8hi, Vb, Vc)\n+STEST2 ( vmr1aw, v8hi, Vb, Vc)\n+STEST2 (  vmr1w, v8hi, Vb, Vc)\n+STEST2 ( vmr2aw, v8hi, Vb, Vc)\n+STEST2 (  vmr2w, v8hi, Vb, Vc)\n+STEST2 ( vmr3aw, v8hi, Vb, Vc)\n+STEST2 (  vmr3w, v8hi, Vb, Vc)\n+STEST2 ( vmr4aw, v8hi, Vb, Vc)\n+STEST2 (  vmr4w, v8hi, Vb, Vc)\n+STEST2 ( vmr5aw, v8hi, Vb, Vc)\n+STEST2 (  vmr5w, v8hi, Vb, Vc)\n+STEST2 ( vmr6aw, v8hi, Vb, Vc)\n+STEST2 (  vmr6w, v8hi, Vb, Vc)\n+STEST2 ( vmr7aw, v8hi, Vb, Vc)\n+STEST2 (  vmr7w, v8hi, Vb, Vc)\n+STEST2 (   vmrb, v8hi, Vb, Vc)\n+STEST2 ( vh264f, v8hi, Vb, Vc)\n+STEST2 (vh264ft, v8hi, Vb, Vc)\n+STEST2 (vh264fw, v8hi, Vb, Vc)\n+STEST2 (  vvc1f, v8hi, Vb, Vc)\n+STEST2 ( vvc1ft, v8hi, Vb, Vc)\n+\n+STEST2 ( vbaddw, v8hi, Vb, rlimm)\n+STEST2 ( vbmaxw, v8hi, Vb, rlimm)\n+STEST2 ( vbminw, v8hi, Vb, rlimm)\n+STEST2 (vbmulaw, v8hi, Vb, rlimm)\n+STEST2 (vbmulfw, v8hi, Vb, rlimm)\n+STEST2 ( vbmulw, v8hi, Vb, rlimm)\n+STEST2 (vbrsubw, v8hi, Vb, rlimm)\n+STEST2 ( vbsubw, v8hi, Vb, rlimm)\n+\n+\n+/* Va, Vb, Ic instructions.  */\n+STEST2 ( vasrw, v8hi, Vb, Ic)\n+STEST2 (  vsr8, v8hi, Vb, Ic)\n+STEST2 (vsr8aw, v8hi, Vb, Ic)\n+\n+/* Va, Vb, u6 instructions.  */\n+STEST2 (  vasrrwi, v8hi, Vb, u6)\n+STEST2 ( vasrsrwi, v8hi, Vb, u6)\n+STEST2 (   vasrwi, v8hi, Vb, u6)\n+STEST2 ( vasrpwbi, v8hi, Vb, u6)\n+STEST2 (vasrrpwbi, v8hi, Vb, u6)\n+STEST2 (  vsr8awi, v8hi, Vb, u6)\n+STEST2 (    vsr8i, v8hi, Vb, u6)\n+\n+/* Va, Vb, u8 (simm) instructions.  */\n+STEST2 (  vmvaw, v8hi, Vb, u8)\n+STEST2 (   vmvw, v8hi, Vb, u8)\n+STEST2 (  vmvzw, v8hi, Vb, u8)\n+STEST2 (vd6tapf, v8hi, Vb, u8)\n+\n+/* Va, rlimm, u8 (simm) instructions.  */\n+STEST2 (vmovaw, v8hi, rlimm, u8)\n+STEST2 ( vmovw, v8hi, rlimm, u8)\n+STEST2 (vmovzw, v8hi, rlimm, u8)\n+\n+/* Va, Vb instructions.  */\n+STEST1 ( vabsaw, v8hi, Vb)\n+STEST1 (  vabsw, v8hi, Vb)\n+STEST1 (vaddsuw, v8hi, Vb)\n+STEST1 ( vsignw, v8hi, Vb)\n+STEST1 ( vexch1, v8hi, Vb)\n+STEST1 ( vexch2, v8hi, Vb)\n+STEST1 ( vexch4, v8hi, Vb)\n+STEST1 ( vupbaw, v8hi, Vb)\n+STEST1 (  vupbw, v8hi, Vb)\n+STEST1 (vupsbaw, v8hi, Vb)\n+STEST1 ( vupsbw, v8hi, Vb)\n+\n+/* DIb, rlimm, rlimm instructions.  */\n+STEST2 (vdirun, void, rlimm, rlimm)\n+STEST2 (vdorun, void, rlimm, rlimm)\n+\n+/* DIb, limm, rlimm instructions.  */\n+STEST2 (vdiwr, void, u3, rlimm)\n+STEST2 (vdowr, void, u3, rlimm)\n+\n+/* rlimm instructions.  */\n+STEST1 (   vrec, void, rlimm)\n+STEST1 (   vrun, void, rlimm)\n+STEST1 (vrecrun, void, rlimm)\n+STEST1 (vendrec, void, rlimm)\n+\n+/* Va, [Ib,u8] instructions.  */\n+STEST3  (vld32wh, v8hi, Vb, Ic, u8)\n+STEST3  (vld32wl, v8hi, Vb, Ic, u8)\n+STEST3  (  vld64, v8hi, Vb, Ic, u8)\n+STEST3  (  vld32, v8hi, Vb, Ic, u8)\n+\n+STEST2  (vld64w, v8hi, Ib, u8)\n+STEST2  (vld128, v8hi, Ib, u8)\n+\n+STEST3 (vst128, void, Va, Ib, u8)\n+STEST3 ( vst64, void, Va, Ib, u8)\n+\n+/* Va, [Ib, u8] instructions.  */\n+STEST4 (vst16_n, void, Va, u3, Ib, u8)\n+STEST4 (vst32_n, void, Va, u3, Ib, u8)\n+\n+STEST1 (vinti, void, u6)"}, {"sha": "7590b1749821f5ef38a6f62d10845555b43c4637", "filename": "gcc/testsuite/gcc.target/arc/builtin_special.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_special.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c69899f0976489947ff59759b61e95e207432485/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_special.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fbuiltin_special.c?ref=c69899f0976489947ff59759b61e95e207432485", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration\" } */\n+\n+#define NORET(name)\t\t\t\t\\\n+  void test_ ## name (void)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    __builtin_arc_ ## name ();\t\t\t\\\n+  }\n+\n+#define RET(name, rettype)\t\t\t\\\n+  rettype test_ ## name (void)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    return __builtin_arc_ ## name ();\t\t\\\n+  }\n+\n+#define NORET1OP(name, op1type)\t\t\t\\\n+  void test_ ## name ## _1 (void)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    __builtin_arc_ ## name (0x10);\t\t\\\n+  }\n+\n+\n+NORET (nop)\n+NORET (rtie)\n+\n+#ifdef __A7__\n+ NORET (sync)\n+#endif\n+\n+NORET (brk)\n+NORET (swi)\n+\n+NORET1OP (sleep, unsigned int)\n+\n+#if defined (__A7__) || defined (__EM__) || defined (__HS__)\n+NORET1OP (trap_s, unsigned int)\n+NORET (unimp_s)\n+#endif\n+\n+#if defined (__EM__) || defined (__HS__)\n+RET (clri, int)\n+#endif"}]}