{"sha": "dd991abb1bb40648f53a1b8014b485ed0ea3ac4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ5OTFhYmIxYmI0MDY0OGY1M2ExYjgwMTRiNDg1ZWQwZWEzYWM0Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2014-09-03T17:00:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2014-09-03T17:00:31Z"}, "message": "aarch64: Improve epilogue unwind info\n\n        * config/aarch64/aarch64.c (aarch64_popwb_single_reg): Remove.\n        (aarch64_popwb_pair_reg): Remove.\n        (aarch64_set_frame_expr): Remove.\n        (aarch64_restore_callee_saves): Add CFI_OPS argument; fill it with\n        the restore ops performed by the insns generated.\n        (aarch64_expand_epilogue): Attach CFI_OPS to the stack deallocation\n        insn.  Perform the calls_eh_return addition later; do not attempt to\n        preserve the CFA in that case.  Don't use aarch64_set_frame_expr.\n        (aarch64_expand_prologue): Use REG_CFA_ADJUST_CFA directly, or no\n        special markup at all.  Load cfun->machine->frame.hard_fp_offset\n        into a local variable.\n        (aarch64_frame_pointer_required): Don't check calls_alloca.\n\nFrom-SVN: r214886", "tree": {"sha": "1b5a4c15b345cfc2b28678b84c8056e3f9a74a82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b5a4c15b345cfc2b28678b84c8056e3f9a74a82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c/comments", "author": null, "committer": null, "parents": [{"sha": "b30e733a13c9eb196b7dfbf7afd4135d7d4c4fd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b30e733a13c9eb196b7dfbf7afd4135d7d4c4fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b30e733a13c9eb196b7dfbf7afd4135d7d4c4fd0"}], "stats": {"total": 275, "additions": 93, "deletions": 182}, "files": [{"sha": "4296bb83297a5b56bab285f77135a422798740d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd991abb1bb40648f53a1b8014b485ed0ea3ac4c", "patch": "@@ -1,3 +1,18 @@\n+2014-09-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_popwb_single_reg): Remove.\n+\t(aarch64_popwb_pair_reg): Remove.\n+\t(aarch64_set_frame_expr): Remove.\n+\t(aarch64_restore_callee_saves): Add CFI_OPS argument; fill it with\n+\tthe restore ops performed by the insns generated.\n+\t(aarch64_expand_epilogue): Attach CFI_OPS to the stack deallocation\n+\tinsn.  Perform the calls_eh_return addition later; do not attempt to\n+\tpreserve the CFA in that case.  Don't use aarch64_set_frame_expr.\n+\t(aarch64_expand_prologue): Use REG_CFA_ADJUST_CFA directly, or no\n+\tspecial markup at all.  Load cfun->machine->frame.hard_fp_offset\n+\tinto a local variable.\n+\t(aarch64_frame_pointer_required): Don't check calls_alloca.\n+\n 2014-09-03  Richard Biener  <rguenther@suse.de>\n \n \t* opts.c (default_options_optimization): Adjust"}, {"sha": "81ea0dc07fb0be56a0064534e2f92b197e34d485", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 78, "deletions": 182, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd991abb1bb40648f53a1b8014b485ed0ea3ac4c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=dd991abb1bb40648f53a1b8014b485ed0ea3ac4c", "patch": "@@ -1805,11 +1805,6 @@ aarch64_libgcc_cmp_return_mode (void)\n static bool\n aarch64_frame_pointer_required (void)\n {\n-  /* If the function contains dynamic stack allocations, we need to\n-     use the frame pointer to access the static parts of the frame.  */\n-  if (cfun->calls_alloca)\n-    return true;\n-\n   /* In aarch64_override_options_after_change\n      flag_omit_leaf_frame_pointer turns off the frame pointer by\n      default.  Turn it back on now if we've not got a leaf\n@@ -1918,22 +1913,6 @@ aarch64_layout_frame (void)\n   cfun->machine->frame.laid_out = true;\n }\n \n-/* Make the last instruction frame-related and note that it performs\n-   the operation described by FRAME_PATTERN.  */\n-\n-static void\n-aarch64_set_frame_expr (rtx frame_pattern)\n-{\n-  rtx_insn *insn;\n-\n-  insn = get_last_insn ();\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-  RTX_FRAME_RELATED_P (frame_pattern) = 1;\n-  REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t      frame_pattern,\n-\t\t\t\t      REG_NOTES (insn));\n-}\n-\n static bool\n aarch64_register_saved_on_entry (int regno)\n {\n@@ -1964,23 +1943,6 @@ aarch64_pushwb_single_reg (enum machine_mode mode, unsigned regno,\n   RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n-static void\n-aarch64_popwb_single_reg (enum machine_mode mode, unsigned regno,\n-\t\t\t  HOST_WIDE_INT adjustment)\n-{\n-  rtx base_rtx = stack_pointer_rtx;\n-  rtx insn, reg, mem;\n-\n-  reg = gen_rtx_REG (mode, regno);\n-  mem = gen_rtx_POST_MODIFY (Pmode, base_rtx,\n-\t\t\t     plus_constant (Pmode, base_rtx, adjustment));\n-  mem = gen_rtx_MEM (mode, mem);\n-\n-  insn = emit_move_insn (reg, mem);\n-  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-}\n-\n static rtx\n aarch64_gen_storewb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n \t\t\t  HOST_WIDE_INT adjustment)\n@@ -2011,7 +1973,6 @@ aarch64_pushwb_pair_reg (enum machine_mode mode, unsigned regno1,\n   insn = emit_insn (aarch64_gen_storewb_pair (mode, stack_pointer_rtx, reg1,\n \t\t\t\t\t      reg2, adjustment));\n   RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 2)) = 1;\n-\n   RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n   RTX_FRAME_RELATED_P (insn) = 1;\n }\n@@ -2033,29 +1994,6 @@ aarch64_gen_loadwb_pair (enum machine_mode mode, rtx base, rtx reg, rtx reg2,\n     }\n }\n \n-static void\n-aarch64_popwb_pair_reg (enum machine_mode mode, unsigned regno1,\n-\t\t\tunsigned regno2, HOST_WIDE_INT adjustment, rtx cfa)\n-{\n-  rtx insn;\n-  rtx reg1 = gen_rtx_REG (mode, regno1);\n-  rtx reg2 = gen_rtx_REG (mode, regno2);\n-\n-  insn = emit_insn (aarch64_gen_loadwb_pair (mode, stack_pointer_rtx, reg1,\n-\t\t\t\t\t     reg2, adjustment));\n-  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 2)) = 1;\n-  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n-  RTX_FRAME_RELATED_P (insn) = 1;\n-\n-  if (cfa)\n-    add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t  (gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\tplus_constant (Pmode, cfa, adjustment))));\n-\n-  add_reg_note (insn, REG_CFA_RESTORE, reg1);\n-  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n-}\n-\n static rtx\n aarch64_gen_store_pair (enum machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n \t\t\trtx reg2)\n@@ -2151,9 +2089,8 @@ aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n static void\n aarch64_restore_callee_saves (enum machine_mode mode,\n \t\t\t      HOST_WIDE_INT start_offset, unsigned start,\n-\t\t\t      unsigned limit, bool skip_wb)\n+\t\t\t      unsigned limit, bool skip_wb, rtx *cfi_ops)\n {\n-  rtx insn;\n   rtx base_rtx = stack_pointer_rtx;\n   rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n \t\t\t\t\t\t ? gen_frame_mem : gen_rtx_MEM);\n@@ -2187,25 +2124,14 @@ aarch64_restore_callee_saves (enum machine_mode mode,\n \n \t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n \t  mem2 = gen_mem_ref (mode, plus_constant (Pmode, base_rtx, offset));\n-\t  insn = emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2,\n-\t\t\t\t\t\t   mem2));\n-\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n+\t  emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2, mem2));\n \n-\t  /* The first part of a frame-related parallel insn is\n-\t     always assumed to be relevant to the frame\n-\t     calculations; subsequent parts, are only\n-\t     frame-related if explicitly marked.  */\n-\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t  *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg2, *cfi_ops);\n \t  regno = regno2;\n \t}\n       else\n-\t{\n-\t  insn = emit_move_insn (reg, mem);\n-\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t}\n-\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+\temit_move_insn (reg, mem);\n+      *cfi_ops = alloc_reg_note (REG_CFA_RESTORE, reg, *cfi_ops);\n     }\n }\n \n@@ -2263,18 +2189,17 @@ aarch64_expand_prologue (void)\n   */\n   HOST_WIDE_INT frame_size, offset;\n   HOST_WIDE_INT fp_offset;\t\t/* Offset from hard FP to SP.  */\n+  HOST_WIDE_INT hard_fp_offset;\n   rtx_insn *insn;\n \n   aarch64_layout_frame ();\n \n-  if (flag_stack_usage_info)\n-    current_function_static_stack_size = cfun->machine->frame.frame_size;\n-\n-  frame_size = cfun->machine->frame.frame_size;\n-  offset = cfun->machine->frame.frame_size;\n+  offset = frame_size = cfun->machine->frame.frame_size;\n+  hard_fp_offset = cfun->machine->frame.hard_fp_offset;\n+  fp_offset = frame_size - hard_fp_offset;\n \n-  fp_offset = cfun->machine->frame.frame_size\n-\t      - cfun->machine->frame.hard_fp_offset;\n+  if (flag_stack_usage_info)\n+    current_function_static_stack_size = frame_size;\n \n   /* Store pairs and load pairs have a range only -512 to 504.  */\n   if (offset >= 512)\n@@ -2285,7 +2210,7 @@ aarch64_expand_prologue (void)\n \t register area.  This will allow the pre-index write-back\n \t store pair instructions to be used for setting up the stack frame\n \t efficiently.  */\n-      offset = cfun->machine->frame.hard_fp_offset;\n+      offset = hard_fp_offset;\n       if (offset >= 512)\n \toffset = cfun->machine->frame.saved_regs_size;\n \n@@ -2296,29 +2221,29 @@ aarch64_expand_prologue (void)\n \t{\n \t  rtx op0 = gen_rtx_REG (Pmode, IP0_REGNUM);\n \t  emit_move_insn (op0, GEN_INT (-frame_size));\n-\t  emit_insn (gen_add2_insn (stack_pointer_rtx, op0));\n-\t  aarch64_set_frame_expr (gen_rtx_SET\n-\t\t\t\t  (Pmode, stack_pointer_rtx,\n-\t\t\t\t   plus_constant (Pmode,\n-\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t  -frame_size)));\n+\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx, op0));\n+\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t    -frame_size)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (frame_size > 0)\n \t{\n-\t  if ((frame_size & 0xfff) != frame_size)\n+\t  int hi_ofs = frame_size & 0xfff000;\n+\t  int lo_ofs = frame_size & 0x000fff;\n+\n+\t  if (hi_ofs)\n \t    {\n \t      insn = emit_insn (gen_add2_insn\n-\t\t\t\t(stack_pointer_rtx,\n-\t\t\t\t GEN_INT (-(frame_size\n-\t\t\t\t\t    & ~(HOST_WIDE_INT)0xfff))));\n+\t\t\t\t(stack_pointer_rtx, GEN_INT (-hi_ofs)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n-\t  if ((frame_size & 0xfff) != 0)\n+\t  if (lo_ofs)\n \t    {\n \t      insn = emit_insn (gen_add2_insn\n-\t\t\t\t(stack_pointer_rtx,\n-\t\t\t\t GEN_INT (-(frame_size\n-\t\t\t\t\t    & (HOST_WIDE_INT)0xfff))));\n+\t\t\t\t(stack_pointer_rtx, GEN_INT (-lo_ofs)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t}\n@@ -2339,10 +2264,6 @@ aarch64_expand_prologue (void)\n \t      insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n \t\t\t\t\t       GEN_INT (-offset)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      aarch64_set_frame_expr (gen_rtx_SET\n-\t\t\t\t      (Pmode, stack_pointer_rtx,\n-\t\t\t\t       gen_rtx_MINUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t      GEN_INT (offset))));\n \n \t      aarch64_save_callee_saves (DImode, fp_offset, R29_REGNUM,\n \t\t\t\t\t R30_REGNUM, false);\n@@ -2355,14 +2276,8 @@ aarch64_expand_prologue (void)\n \t  insn = emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n \t\t\t\t\t   stack_pointer_rtx,\n \t\t\t\t\t   GEN_INT (fp_offset)));\n-\t  aarch64_set_frame_expr (gen_rtx_SET\n-\t\t\t\t  (Pmode, hard_frame_pointer_rtx,\n-\t\t\t\t   plus_constant (Pmode,\n-\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t  fp_offset)));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  insn = emit_insn (gen_stack_tie (stack_pointer_rtx,\n-\t\t\t\t\t   hard_frame_pointer_rtx));\n+\t  emit_insn (gen_stack_tie (stack_pointer_rtx, hard_frame_pointer_rtx));\n \t}\n       else\n \t{\n@@ -2417,21 +2332,19 @@ aarch64_expand_epilogue (bool for_sibcall)\n {\n   HOST_WIDE_INT frame_size, offset;\n   HOST_WIDE_INT fp_offset;\n+  HOST_WIDE_INT hard_fp_offset;\n   rtx_insn *insn;\n-  rtx cfa_reg;\n \n   aarch64_layout_frame ();\n \n   offset = frame_size = cfun->machine->frame.frame_size;\n-  fp_offset = cfun->machine->frame.frame_size\n-\t      - cfun->machine->frame.hard_fp_offset;\n-\n-  cfa_reg = frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n+  hard_fp_offset = cfun->machine->frame.hard_fp_offset;\n+  fp_offset = frame_size - hard_fp_offset;\n \n   /* Store pairs and load pairs have a range only -512 to 504.  */\n   if (offset >= 512)\n     {\n-      offset = cfun->machine->frame.hard_fp_offset;\n+      offset = hard_fp_offset;\n       if (offset >= 512)\n \toffset = cfun->machine->frame.saved_regs_size;\n \n@@ -2459,18 +2372,14 @@ aarch64_expand_epilogue (bool for_sibcall)\n \t\t\t\t       hard_frame_pointer_rtx,\n \t\t\t\t       GEN_INT (0)));\n       offset = offset - fp_offset;\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      /* As SP is set to (FP - fp_offset), according to the rules in\n-\t dwarf2cfi.c:dwarf2out_frame_debug_expr, CFA should be calculated\n-\t from the value of SP from now on.  */\n-      cfa_reg = stack_pointer_rtx;\n     }\n \n   if (offset > 0)\n     {\n       unsigned reg1 = cfun->machine->frame.wb_candidate1;\n       unsigned reg2 = cfun->machine->frame.wb_candidate2;\n       bool skip_wb = true;\n+      rtx cfi_ops = NULL;\n \n       if (frame_pointer_needed)\n \tfp_offset = 0;\n@@ -2481,99 +2390,86 @@ aarch64_expand_epilogue (bool for_sibcall)\n \tskip_wb = false;\n \n       aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM, R30_REGNUM,\n-\t\t\t\t    skip_wb);\n+\t\t\t\t    skip_wb, &cfi_ops);\n       aarch64_restore_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM,\n-\t\t\t\t    skip_wb);\n+\t\t\t\t    skip_wb, &cfi_ops);\n \n       if (skip_wb)\n \t{\n \t  enum machine_mode mode1 = (reg1 <= R30_REGNUM) ? DImode : DFmode;\n+\t  rtx rreg1 = gen_rtx_REG (mode1, reg1);\n \n+\t  cfi_ops = alloc_reg_note (REG_CFA_RESTORE, rreg1, cfi_ops);\n \t  if (reg2 == FIRST_PSEUDO_REGISTER)\n-\t    aarch64_popwb_single_reg (mode1, reg1, offset);\n+\t    {\n+\t      rtx mem = plus_constant (Pmode, stack_pointer_rtx, offset);\n+\t      mem = gen_rtx_POST_MODIFY (Pmode, stack_pointer_rtx, mem);\n+\t      mem = gen_rtx_MEM (mode1, mem);\n+\t      insn = emit_move_insn (rreg1, mem);\n+\t    }\n \t  else\n \t    {\n-\t      if (reg1 != HARD_FRAME_POINTER_REGNUM)\n-\t\tcfa_reg = NULL;\n+\t      rtx rreg2 = gen_rtx_REG (mode1, reg2);\n \n-\t      aarch64_popwb_pair_reg (mode1, reg1, reg2, offset, cfa_reg);\n+\t      cfi_ops = alloc_reg_note (REG_CFA_RESTORE, rreg2, cfi_ops);\n+\t      insn = emit_insn (aarch64_gen_loadwb_pair\n+\t\t\t\t(mode1, stack_pointer_rtx, rreg1,\n+\t\t\t\t rreg2, offset));\n \t    }\n \t}\n       else\n \t{\n \t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx,\n \t\t\t\t\t   GEN_INT (offset)));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-    }\n-\n-  /* Stack adjustment for exception handler.  */\n-  if (crtl->calls_eh_return)\n-    {\n-      /* We need to unwind the stack by the offset computed by\n-\t EH_RETURN_STACKADJ_RTX.  However, at this point the CFA is\n-\t based on SP.  Ideally we would update the SP and define the\n-\t CFA along the lines of:\n-\n-\t SP = SP + EH_RETURN_STACKADJ_RTX\n-\t (regnote CFA = SP - EH_RETURN_STACKADJ_RTX)\n-\n-\t However the dwarf emitter only understands a constant\n-\t register offset.\n \n-\t The solution chosen here is to use the otherwise unused IP0\n-\t as a temporary register to hold the current SP value.  The\n-\t CFA is described using IP0 then SP is modified.  */\n-\n-      rtx ip0 = gen_rtx_REG (DImode, IP0_REGNUM);\n-\n-      insn = emit_move_insn (ip0, stack_pointer_rtx);\n-      add_reg_note (insn, REG_CFA_DEF_CFA, ip0);\n+      /* Reset the CFA to be SP + FRAME_SIZE.  */\n+      rtx new_cfa = stack_pointer_rtx;\n+      if (frame_size > 0)\n+\tnew_cfa = plus_constant (Pmode, new_cfa, frame_size);\n+      cfi_ops = alloc_reg_note (REG_CFA_DEF_CFA, new_cfa, cfi_ops);\n+      REG_NOTES (insn) = cfi_ops;\n       RTX_FRAME_RELATED_P (insn) = 1;\n-\n-      emit_insn (gen_add2_insn (stack_pointer_rtx, EH_RETURN_STACKADJ_RTX));\n-\n-      /* Ensure the assignment to IP0 does not get optimized away.  */\n-      emit_use (ip0);\n     }\n \n-  if (frame_size > -1)\n+  if (frame_size > 0)\n     {\n       if (frame_size >= 0x1000000)\n \t{\n \t  rtx op0 = gen_rtx_REG (Pmode, IP0_REGNUM);\n \t  emit_move_insn (op0, GEN_INT (frame_size));\n-\t  emit_insn (gen_add2_insn (stack_pointer_rtx, op0));\n-\t  aarch64_set_frame_expr (gen_rtx_SET\n-\t\t\t\t  (Pmode, stack_pointer_rtx,\n-\t\t\t\t   plus_constant (Pmode,\n-\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t  frame_size)));\n+\t  insn = emit_insn (gen_add2_insn (stack_pointer_rtx, op0));\n \t}\n-      else if (frame_size > 0)\n+      else\n \t{\n-\t  if ((frame_size & 0xfff) != 0)\n-\t    {\n-\t      insn = emit_insn (gen_add2_insn\n-\t\t\t\t(stack_pointer_rtx,\n-\t\t\t\t GEN_INT ((frame_size\n-\t\t\t\t\t   & (HOST_WIDE_INT) 0xfff))));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t  if ((frame_size & 0xfff) != frame_size)\n+          int hi_ofs = frame_size & 0xfff000;\n+          int lo_ofs = frame_size & 0x000fff;\n+\n+\t  if (hi_ofs && lo_ofs)\n \t    {\n \t      insn = emit_insn (gen_add2_insn\n-\t\t\t\t(stack_pointer_rtx,\n-\t\t\t\t GEN_INT ((frame_size\n-\t\t\t\t\t   & ~ (HOST_WIDE_INT) 0xfff))));\n+\t\t\t\t(stack_pointer_rtx, GEN_INT (hi_ofs)));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      frame_size = lo_ofs;\n \t    }\n+\t  insn = emit_insn (gen_add2_insn\n+\t\t\t    (stack_pointer_rtx, GEN_INT (frame_size)));\n \t}\n \n-      aarch64_set_frame_expr (gen_rtx_SET (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t   plus_constant (Pmode,\n-\t\t\t\t\t\t\t  stack_pointer_rtx,\n-\t\t\t\t\t\t\t  offset)));\n+      /* Reset the CFA to be SP + 0.  */\n+      add_reg_note (insn, REG_CFA_DEF_CFA, stack_pointer_rtx);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Stack adjustment for exception handler.  */\n+  if (crtl->calls_eh_return)\n+    {\n+      /* We need to unwind the stack by the offset computed by\n+\t EH_RETURN_STACKADJ_RTX.  We have already reset the CFA\n+\t to be SP; letting the CFA move during this adjustment\n+\t is just as correct as retaining the CFA from the body\n+\t of the function.  Therefore, do nothing special.  */\n+      emit_insn (gen_add2_insn (stack_pointer_rtx, EH_RETURN_STACKADJ_RTX));\n     }\n \n   emit_use (gen_rtx_REG (DImode, LR_REGNUM));"}]}