{"sha": "b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "node_id": "C_kwDOANBUbNoAKGI1ZTM4YjFjMTY2MzU3ZTJhNjNkMzhhZTZkYTdhZTVkNjhmYzExNWI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-04-01T14:19:08Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-04-01T14:19:08Z"}, "message": "c++: improve \"NTTP argument considered unused\" fix [PR53164, PR105848]\n\nr13-995-g733a792a2b2e16 worked around the problem of (pointer to)\nfunction NTTP arguments not always getting marked as odr-used, by\nredundantly calling mark_used on the substituted ADDR_EXPR callee of a\nCALL_EXPR.  That is just a narrow workaround however, since it assumes\nthe function is later called, but the use as a template argument alone\nshould constitute an odr-use of the function (since template arguments\nare an evaluated context, and we're really passing its address); we\nshouldn't need to subsequently call or otherwise use the function NTTP\nargument.\n\nThis patch fixes this in a more general way by walking the template\narguments of each specialization that's about to be instantiated and\nredundantly calling mark_used on all entities used within.  As before,\nthe call to mark_used as it worst a no-op, but it compensates for the\nsituation where the specialization was first formed in a template context\nin which mark_used is inhibited.\n\nAnother approach would be to call mark_used whenever we substitute a\nTEMPLATE_PARM_INDEX, but that would result in many more redundant calls\nto mark_used compared to this approach.  And as the second testcase\nbelow illustrates, we also need to walk C++20 class NTTP arguments which\ncan be large and thus expensive to walk repeatedly.  The change to\ninvalid_tparm_referent_p is needed to avoid incorrectly rejecting class\nNTTP arguments containing function pointers as in the testcase.\n\n(The third testcase is unrelated to this fix, but it helped rule out an\nearlier approach I was considering and it seems we don't have existing\ntest coverage for this situation.)\n\n\tPR c++/53164\n\tPR c++/105848\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (invalid_tparm_referent_p): Accept ADDR_EXPR of\n\tFUNCTION_DECL.\n\t(instantiate_class_template): Call mark_template_arguments_used.\n\t(tsubst_copy_and_build) <case CALL_EXPR>: Revert r13-995 change.\n\t(mark_template_arguments_used): Define.\n\t(instantiate_body): Call mark_template_arguments_used.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/fn-ptr3a.C: New test.\n\t* g++.dg/template/fn-ptr3b.C: New test.\n\t* g++.dg/template/fn-ptr4.C: New test.", "tree": {"sha": "b86d0a39e1c2d9af8db3790ea07bed5283767009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b86d0a39e1c2d9af8db3790ea07bed5283767009"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/comments", "author": null, "committer": null, "parents": [{"sha": "b06464c7fb06a049e5d0d2bec4e37282c5ecca8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06464c7fb06a049e5d0d2bec4e37282c5ecca8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b06464c7fb06a049e5d0d2bec4e37282c5ecca8c"}], "stats": {"total": 157, "additions": 139, "deletions": 18}, "files": [{"sha": "022f295b36f8bc26fa8d78bae6e4232bd50453a0", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "patch": "@@ -220,6 +220,7 @@ static tree make_argument_pack (tree);\n static tree enclosing_instantiation_of (tree tctx);\n static void instantiate_body (tree pattern, tree args, tree d, bool nested);\n static tree maybe_dependent_member_ref (tree, tree, tsubst_flags_t, tree);\n+static void mark_template_arguments_used (tree, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -7142,12 +7143,13 @@ invalid_tparm_referent_p (tree type, tree expr, tsubst_flags_t complain)\n \t      decl = TREE_OPERAND (decl, 0);\n \t    }\n \n-\tif (!VAR_P (decl))\n+\tif (!VAR_OR_FUNCTION_DECL_P (decl))\n \t  {\n \t    if (complain & tf_error)\n \t      error_at (cp_expr_loc_or_input_loc (expr),\n \t\t\t\"%qE is not a valid template argument of type %qT \"\n-\t\t\t\"because %qE is not a variable\", expr, type, decl);\n+\t\t\t\"because %qE is not a variable or function\",\n+\t\t\texpr, type, decl);\n \t    return true;\n \t  }\n \telse if (cxx_dialect < cxx11 && !DECL_EXTERNAL_LINKAGE_P (decl))\n@@ -12152,6 +12154,9 @@ instantiate_class_template (tree type)\n       cp_unevaluated_operand = 0;\n       c_inhibit_evaluation_warnings = 0;\n     }\n+\n+  mark_template_arguments_used (templ, CLASSTYPE_TI_ARGS (type));\n+\n   /* Use #pragma pack from the template context.  */\n   saved_maximum_field_alignment = maximum_field_alignment;\n   maximum_field_alignment = TYPE_PRECISION (pattern);\n@@ -21192,22 +21197,10 @@ tsubst_copy_and_build (tree t,\n \t  }\n \n \t/* Remember that there was a reference to this entity.  */\n-\tif (function != NULL_TREE)\n-\t  {\n-\t    tree inner = function;\n-\t    if (TREE_CODE (inner) == ADDR_EXPR\n-\t\t&& TREE_CODE (TREE_OPERAND (inner, 0)) == FUNCTION_DECL)\n-\t      /* We should already have called mark_used when taking the\n-\t\t address of this function, but do so again anyway to make\n-\t\t sure it's odr-used: at worst this is a no-op, but if we\n-\t\t obtained this FUNCTION_DECL as part of ahead-of-time overload\n-\t\t resolution then that call to mark_used wouldn't have marked it\n-\t\t odr-used yet (53164).  */\n-\t      inner = TREE_OPERAND (inner, 0);\n-\t    if (DECL_P (inner)\n-\t\t&& !mark_used (inner, complain) && !(complain & tf_error))\n-\t      RETURN (error_mark_node);\n-\t  }\n+\tif (function != NULL_TREE\n+\t    && DECL_P (function)\n+\t    && !mark_used (function, complain) && !(complain & tf_error))\n+\t  RETURN (error_mark_node);\n \n \tif (!maybe_fold_fn_template_args (function, complain))\n \t  return error_mark_node;\n@@ -21902,6 +21895,61 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n   return result;\n }\n \n+/* Call mark_used on each entity within the non-type template arguments in\n+   ARGS for an instantiation of TMPL, to ensure that each such entity is\n+   considered odr-used (and therefore marked for instantiation) regardless of\n+   whether the specialization was first formed in a template context (which\n+   inhibits mark_used).\n+\n+   This function assumes push_to_top_level has been called beforehand.  */\n+\n+static void\n+mark_template_arguments_used (tree tmpl, tree args)\n+{\n+  /* It suffices to do this only when instantiating a primary template.  */\n+  if (TREE_CODE (tmpl) != TEMPLATE_DECL || !PRIMARY_TEMPLATE_P (tmpl))\n+    return;\n+\n+  /* We already marked outer arguments when specializing the context.  */\n+  args = INNERMOST_TEMPLATE_ARGS (args);\n+\n+  for (tree arg : tree_vec_range (args))\n+    {\n+      /* A (pointer/reference to) function or variable NTTP argument.  */\n+      if (TREE_CODE (arg) == ADDR_EXPR\n+\t  || TREE_CODE (arg) == INDIRECT_REF)\n+\t{\n+\t  while (TREE_CODE (arg) == ADDR_EXPR\n+\t\t || REFERENCE_REF_P (arg)\n+\t\t || CONVERT_EXPR_P (arg))\n+\t    arg = TREE_OPERAND (arg, 0);\n+\t  if (VAR_OR_FUNCTION_DECL_P (arg))\n+\t    {\n+\t      /* Pass tf_none to avoid duplicate diagnostics: if this call\n+\t\t fails then an earlier call to mark_used for this argument\n+\t\t must have also failed and emitted a diagnostic.  */\n+\t      bool ok = mark_used (arg, tf_none);\n+\t      gcc_checking_assert (ok || seen_error ());\n+\t    }\n+\t}\n+      /* A class NTTP argument.  */\n+      else if (VAR_P (arg)\n+\t       && DECL_NTTP_OBJECT_P (arg))\n+\t{\n+\t  auto mark_used_r = [](tree *tp, int *, void *) {\n+\t    if (VAR_OR_FUNCTION_DECL_P (*tp))\n+\t      {\n+\t\tbool ok = mark_used (*tp, tf_none);\n+\t\tgcc_checking_assert (ok || seen_error ());\n+\t      }\n+\t    return NULL_TREE;\n+\t  };\n+\t  cp_walk_tree_without_duplicates (&DECL_INITIAL (arg),\n+\t\t\t\t\t   mark_used_r, nullptr);\n+\t}\n+    }\n+}\n+\n /* We're out of SFINAE context now, so generate diagnostics for the access\n    errors we saw earlier when instantiating D from TMPL and ARGS.  */\n \n@@ -26775,6 +26823,8 @@ instantiate_body (tree pattern, tree args, tree d, bool nested_p)\n       c_inhibit_evaluation_warnings = 0;\n     }\n \n+  mark_template_arguments_used (pattern, args);\n+\n   if (VAR_P (d))\n     {\n       /* The variable might be a lambda's extra scope, and that"}, {"sha": "345c621a0c668a6d27cde9f987bfb9793c0ede19", "filename": "gcc/testsuite/g++.dg/template/fn-ptr3a.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr3a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr3a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr3a.C?ref=b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/53164\n+// PR c++/105848\n+// A stricter version of fn-ptr3.C that verifies using f as a template\n+// argument alone constitutes an odr-use.\n+\n+template<class T>\n+void f(T) { T::fail; } // { dg-error \"fail\" }\n+\n+template<void (*P)(int)>\n+struct A {\n+  // P not called\n+};\n+\n+template<void (&P)(char)>\n+void wrap() {\n+  // P not called\n+}\n+\n+template<int>\n+void g() {\n+  A<f> a; // { dg-message \"required from\" }\n+  wrap<f>(); // { dg-message \"required from\" }\n+}\n+\n+int main() {\n+  g<0>();\n+}"}, {"sha": "899c355fb386d95f30d2d03d8ace554bb7c04f4a", "filename": "gcc/testsuite/g++.dg/template/fn-ptr3b.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr3b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr3b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr3b.C?ref=b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/53164\n+// PR c++/105848\n+// A C++20 version of fn-ptr3a.C using class NTTPs.\n+// { dg-do compile { target c++20 } }\n+\n+template<class T>\n+void f(T) { T::fail; } // { dg-error \"fail\" }\n+\n+struct B_int { void (*P)(int); };\n+struct B_char { void (&P)(char); };\n+\n+template<B_int B>\n+struct A {\n+  // B.P not called\n+};\n+\n+template<B_char B>\n+void wrap() {\n+  // B.P not called\n+}\n+\n+template<int>\n+void g() {\n+  A<B_int{f}> a; // { dg-message \"required from\" }\n+  wrap<B_char{f}>(); // { dg-message \"required from\" }\n+}\n+\n+int main() {\n+  g<0>();\n+}"}, {"sha": "36551ec5d7fa629345d6a4e6eaf40082351d81c1", "filename": "gcc/testsuite/g++.dg/template/fn-ptr4.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e38b1c166357e2a63d38ae6da7ae5d68fc115b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn-ptr4.C?ref=b5e38b1c166357e2a63d38ae6da7ae5d68fc115b", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+template<void (*P)()>\n+void wrap() {\n+  P(); // OK, despite A::g not being accessible from here.\n+}\n+\n+struct A {\n+  static void f() {\n+    wrap<A::g>();\n+  }\n+private:\n+  static void g();\n+};"}]}