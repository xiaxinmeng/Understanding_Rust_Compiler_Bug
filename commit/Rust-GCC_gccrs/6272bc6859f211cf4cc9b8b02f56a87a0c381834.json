{"sha": "6272bc6859f211cf4cc9b8b02f56a87a0c381834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI3MmJjNjg1OWYyMTFjZjRjYzliOGIwMmY1NmE4N2EwYzM4MTgzNA==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2002-03-15T21:44:49Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2002-03-15T21:44:49Z"}, "message": "m68hc11.c (emit_move_after_reload): Add a REG_INC note on the insn that sets the soft frame register.\n\n\t* config/m68hc11/m68hc11.c (emit_move_after_reload): Add a REG_INC\n\tnote on the insn that sets the soft frame register.\n\t(must_parenthesize): ix and iy are also reserved names.\n\t(print_operand_address): One more place where parenthesis are required\n\tto avoid confusion with register names.\n\t(m68hc11_gen_movhi): Allow push of stack pointer.\n\t(m68hc11_check_z_replacement): Fix handling of parallel with a\n\tclobber.\n\t(m68hc11_z_replacement): Must update the REG_INC notes to tell what\n\tthe replacement register is.\n\t* config/m68hc11/m68hc11.h (REG_CLASS_CONTENTS): Switch Z_REGS\n\tand D8_REGS classes.\n\t(MODES_TIEABLE_P): All modes are tieable except QImode.\n\nFrom-SVN: r50837", "tree": {"sha": "759002b68a793dc6da200bcb82381ed2d98e1098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/759002b68a793dc6da200bcb82381ed2d98e1098"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6272bc6859f211cf4cc9b8b02f56a87a0c381834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6272bc6859f211cf4cc9b8b02f56a87a0c381834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6272bc6859f211cf4cc9b8b02f56a87a0c381834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6272bc6859f211cf4cc9b8b02f56a87a0c381834/comments", "author": null, "committer": null, "parents": [{"sha": "1d2d9def8281db63e5ea232ce2d29fccd0268ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2d9def8281db63e5ea232ce2d29fccd0268ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2d9def8281db63e5ea232ce2d29fccd0268ecb"}], "stats": {"total": 70, "additions": 65, "deletions": 5}, "files": [{"sha": "82f6aad914b91db4843d2aa88a13a89deac9589f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6272bc6859f211cf4cc9b8b02f56a87a0c381834/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6272bc6859f211cf4cc9b8b02f56a87a0c381834/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6272bc6859f211cf4cc9b8b02f56a87a0c381834", "patch": "@@ -1,3 +1,19 @@\n+2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* config/m68hc11/m68hc11.c (emit_move_after_reload): Add a REG_INC\n+\tnote on the insn that sets the soft frame register.\n+\t(must_parenthesize): ix and iy are also reserved names.\n+\t(print_operand_address): One more place where parenthesis are required\n+\tto avoid confusion with register names.\n+\t(m68hc11_gen_movhi): Allow push of stack pointer.\n+\t(m68hc11_check_z_replacement): Fix handling of parallel with a\n+\tclobber.\n+\t(m68hc11_z_replacement): Must update the REG_INC notes to tell what\n+\tthe replacement register is.\n+\t* config/m68hc11/m68hc11.h (REG_CLASS_CONTENTS): Switch Z_REGS\n+\tand D8_REGS classes.\n+\t(MODES_TIEABLE_P): All modes are tieable except QImode.\n+\n 2002-03-15  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n \t* config/m68hc11/larith.asm (___adddi3): Optimize saving of result."}, {"sha": "e9b1bb9e31b07077ba3ec29a804ac07e141d1748", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6272bc6859f211cf4cc9b8b02f56a87a0c381834/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6272bc6859f211cf4cc9b8b02f56a87a0c381834/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=6272bc6859f211cf4cc9b8b02f56a87a0c381834", "patch": "@@ -1520,6 +1520,17 @@ emit_move_after_reload (to, from, scratch)\n \t\t\t\t\t    XEXP (XEXP (from, 0), 0),\n \t\t\t\t\t    REG_NOTES (insn));\n     }\n+\n+  /* For 68HC11, put a REG_INC note on `sts _.frame' to prevent the cse-reg\n+     to think that sp == _.frame and later replace a x = sp with x = _.frame.\n+     The problem is that we are lying to gcc and use `txs' for x = sp\n+     (which is not really true because txs is really x = sp + 1).  */\n+  else if (TARGET_M6811 && SP_REG_P (from))\n+    {\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n+\t\t\t\t\t    from,\n+\t\t\t\t\t    REG_NOTES (insn));\n+    }\n }\n \n int\n@@ -2263,6 +2274,8 @@ must_parenthesize (op)\n \t      || strcasecmp (name, \"d\") == 0\n \t      || strcasecmp (name, \"x\") == 0\n \t      || strcasecmp (name, \"y\") == 0\n+\t      || strcasecmp (name, \"ix\") == 0\n+\t      || strcasecmp (name, \"iy\") == 0\n \t      || strcasecmp (name, \"pc\") == 0\n \t      || strcasecmp (name, \"sp\") == 0\n \t      || strcasecmp (name, \"ccr\") == 0) ? 1 : 0;\n@@ -2404,7 +2417,13 @@ print_operand_address (file, addr)\n \t    }\n \t  else\n \t    {\n+              need_parenthesis = must_parenthesize (offset);\n+              if (need_parenthesis)\n+                asm_fprintf (file, \"(\");\n+\n \t      output_addr_const (file, offset);\n+              if (need_parenthesis)\n+                asm_fprintf (file, \")\");\n \t      asm_fprintf (file, \",\");\n \t      asm_print_register (file, REGNO (base));\n \t    }\n@@ -2965,6 +2984,9 @@ m68hc11_gen_movhi (insn, operands)\n \t    case HARD_D_REGNUM:\n \t      output_asm_insn (\"psh%1\", operands);\n \t      break;\n+            case HARD_SP_REGNUM:\n+              output_asm_insn (\"sts\\t-2,sp\", operands);\n+              break;\n \t    default:\n \t      abort ();\n \t    }\n@@ -4361,7 +4383,12 @@ m68hc11_check_z_replacement (insn, info)\n \t\t  info->must_save_reg = 0;\n \t\t  info->must_restore_reg = 0;\n \t\t}\n-\t      info->last = NEXT_INSN (insn);\n+\t      if (info->first != insn\n+\t\t  && ((info->y_used && ix_clobber)\n+\t\t      || (info->x_used && iy_clobber)))\n+\t\tinfo->last = insn;\n+\t      else\n+\t\tinfo->last = NEXT_INSN (insn);\n \t      info->save_before_last = 1;\n \t    }\n \t  return 0;\n@@ -4645,6 +4672,8 @@ m68hc11_z_replacement (insn)\n       if (GET_CODE (body) == SET || GET_CODE (body) == PARALLEL\n \t  || GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n \t{\n+          rtx note;\n+\n \t  if (debug_m6811 && reg_mentioned_p (replace_reg, body))\n \t    {\n \t      printf (\"Reg mentioned here...:\\n\");\n@@ -4685,6 +4714,20 @@ m68hc11_z_replacement (insn)\n \t\treplace_reg_qi = gen_rtx (REG, QImode, REGNO (replace_reg));\n \t      validate_replace_rtx (z_reg_qi, replace_reg_qi, insn);\n \t    }\n+\n+          /* If there is a REG_INC note on Z, replace it with a\n+             REG_INC note on the replacement register.  This is necessary\n+             to make sure that the flow pass will identify the change\n+             and it will not remove a possible insn that saves Z.  */\n+          for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+            {\n+              if (REG_NOTE_KIND (note) == REG_INC\n+                  && GET_CODE (XEXP (note, 0)) == REG\n+                  && REGNO (XEXP (note, 0)) == REGNO (z_reg))\n+                {\n+                  XEXP (note, 0) = replace_reg;\n+                }\n+            }\n \t}\n       if (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN)\n \tbreak;"}, {"sha": "829e244a51acbd235ac7d6eb7948d77d021f2d28", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6272bc6859f211cf4cc9b8b02f56a87a0c381834/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6272bc6859f211cf4cc9b8b02f56a87a0c381834/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=6272bc6859f211cf4cc9b8b02f56a87a0c381834", "patch": "@@ -482,11 +482,12 @@ SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n /* Value is 1 if it is a good idea to tie two pseudo registers when one has\n    mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce\n    different values for MODE1 and MODE2, for any hard reg, then this must be\n-   0 for correct output.  */\n+   0 for correct output.\n+\n+   All modes are tieable except QImode.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)                   \\\n      (((MODE1) == (MODE2))                              \\\n-      || ((MODE1) == SImode && (MODE2) == HImode)\t\\\n-      || ((MODE1) == HImode && (MODE2) == SImode))\n+      || ((MODE1) != QImode && (MODE2) != QImode))\n \f\n \n /* Define the classes of registers for register constraints in the\n@@ -637,8 +638,8 @@ enum reg_class\n /* SP_REGS */\t\t { 0x00000008, 0x00000000 }, /* SP */           \\\n /* DA_REGS */\t\t { 0x00000020, 0x00000000 }, /* A */            \\\n /* DB_REGS */\t\t { 0x00000040, 0x00000000 }, /* B */            \\\n-/* D8_REGS */\t\t { 0x00000060, 0x00000000 }, /* A B */          \\\n /* Z_REGS  */\t\t { 0x00000100, 0x00000000 }, /* Z */            \\\n+/* D8_REGS */\t\t { 0x00000060, 0x00000000 }, /* A B */          \\\n /* Q_REGS  */\t\t { 0x00000062, 0x00000000 }, /* A B D */        \\\n /* D_OR_X_REGS */        { 0x00000003, 0x00000000 }, /* D X */          \\\n /* D_OR_Y_REGS */        { 0x00000006, 0x00000000 }, /* D Y */          \\"}]}