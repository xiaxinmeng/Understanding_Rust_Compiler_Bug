{"sha": "99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlkODIxYzAxY2FjYmZkYmE1MjRjYjRkNGQ4ZWEwNjZhYmQxNWQyYg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-08-19T16:02:30Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-08-19T16:02:30Z"}, "message": "re PR fortran/29785 (Fortran 2003: POINTER Rank Remapping)\n\n2010-08-19  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/29785\n\tPR fortran/45016\n\t* trans.h (struct gfc_se): New flag `byref_noassign'.\n\t* trans-array.h (gfc_conv_shift_descriptor_lbound): New method.\n\t(gfc_conv_array_extent_dim), (gfc_conv_descriptor_size): New methods.\n\t* expr.c (gfc_check_pointer_assign): Allow bounds and rank remapping\n\tand check for compile-time errors with those.\n\t* trans-decl.c (trans_associate_var): Use new routine\n\t`gfc_conv_shift_descriptor_lbound' instead of doing it manually.\n\t* trans-array.c (gfc_conv_shift_descriptor_lbound): New method.\n\t(gfc_conv_array_extent_dim), (gfc_conv_descriptor_size): New methods.\n\t(gfc_array_init_size): Use new `gfc_conv_array_extent_dim'.\n\t(gfc_conv_expr_descriptor): Handle new flag `byref_noassign'.\n\t* trans-expr.c (gfc_trans_pointer_assignment): Handle bounds and\n\trank remapping for assignment.\n\n2010-08-19  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/29785\n\tPR fortran/45016\n\t* gfortran.dg/pointer_assign_5.f90: Remove 'not implemented' error.\n\t* gfortran.dg/pointer_remapping_1.f90: New test.\n\t* gfortran.dg/pointer_remapping_2.f03: New test.\n\t* gfortran.dg/pointer_remapping_3.f08: New test.\n\t* gfortran.dg/pointer_remapping_4.f03: New test.\n\t* gfortran.dg/pointer_remapping_5.f08: New test.\n\t* gfortran.dg/pointer_remapping_6.f08: New test.\n\nFrom-SVN: r163377", "tree": {"sha": "5ec817ebbdbef30901290c6099ab8de10dea253a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ec817ebbdbef30901290c6099ab8de10dea253a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1b62c9f96d31dac273e1dfa0e389e240b420c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1b62c9f96d31dac273e1dfa0e389e240b420c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1b62c9f96d31dac273e1dfa0e389e240b420c69"}], "stats": {"total": 716, "additions": 608, "deletions": 108}, "files": [{"sha": "90d26fbc4690766f2f5674b9b098cb417b2f88a7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -1,3 +1,21 @@\n+2010-08-19  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/29785\n+\tPR fortran/45016\n+\t* trans.h (struct gfc_se): New flag `byref_noassign'.\n+\t* trans-array.h (gfc_conv_shift_descriptor_lbound): New method.\n+\t(gfc_conv_array_extent_dim), (gfc_conv_descriptor_size): New methods.\n+\t* expr.c (gfc_check_pointer_assign): Allow bounds and rank remapping\n+\tand check for compile-time errors with those.\n+\t* trans-decl.c (trans_associate_var): Use new routine\n+\t`gfc_conv_shift_descriptor_lbound' instead of doing it manually.\n+\t* trans-array.c (gfc_conv_shift_descriptor_lbound): New method.\n+\t(gfc_conv_array_extent_dim), (gfc_conv_descriptor_size): New methods.\n+\t(gfc_array_init_size): Use new `gfc_conv_array_extent_dim'.\n+\t(gfc_conv_expr_descriptor): Handle new flag `byref_noassign'.\n+\t* trans-expr.c (gfc_trans_pointer_assignment): Handle bounds and\n+\trank remapping for assignment.\n+\n 2010-08-19  Tobias Burnus  <burnus@net-b.de>\n \n \t* intrinsic.texi (Bessel_jn, Bessel_yn): Fix typo."}, {"sha": "959546672e0080190a2f88bacee8c0bc9bf9e3f1", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 74, "deletions": 12, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -3232,7 +3232,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n {\n   symbol_attribute attr;\n   gfc_ref *ref;\n-  int is_pure;\n+  bool is_pure, rank_remap;\n   int pointer, check_intent_in, proc_pointer;\n \n   if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN\n@@ -3260,6 +3260,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   pointer = lvalue->symtree->n.sym->attr.pointer;\n   proc_pointer = lvalue->symtree->n.sym->attr.proc_pointer;\n \n+  rank_remap = false;\n   for (ref = lvalue->ref; ref; ref = ref->next)\n     {\n       if (pointer)\n@@ -3273,6 +3274,8 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n       if (ref->type == REF_ARRAY && ref->next == NULL)\n \t{\n+\t  int dim;\n+\n \t  if (ref->u.ar.type == AR_FULL)\n \t    break;\n \n@@ -3285,16 +3288,41 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n \t  if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Bounds \"\n \t\t\t      \"specification for '%s' in pointer assignment \"\n-                              \"at %L\", lvalue->symtree->n.sym->name,\n+\t\t\t      \"at %L\", lvalue->symtree->n.sym->name,\n \t\t\t      &lvalue->where) == FAILURE)\n-            return FAILURE;\n+\t    return FAILURE;\n \n-\t  gfc_error (\"Pointer bounds remapping at %L is not yet implemented \"\n-\t\t     \"in gfortran\", &lvalue->where);\n-\t  /* TODO: See PR 29785. Add checks that all lbounds are specified and\n-\t     either never or always the upper-bound; strides shall not be\n-\t     present.  */\n-\t  return FAILURE;\n+\t  /* When bounds are given, all lbounds are necessary and either all\n+\t     or none of the upper bounds; no strides are allowed.  If the\n+\t     upper bounds are present, we may do rank remapping.  */\n+\t  for (dim = 0; dim < ref->u.ar.dimen; ++dim)\n+\t    {\n+\t      if (!ref->u.ar.start[dim])\n+\t\t{\n+\t\t  gfc_error (\"Lower bound has to be present at %L\",\n+\t\t\t     &lvalue->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\t      if (ref->u.ar.stride[dim])\n+\t\t{\n+\t\t  gfc_error (\"Stride must not be present at %L\",\n+\t\t\t     &lvalue->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\n+\t      if (dim == 0)\n+\t\trank_remap = (ref->u.ar.end[dim] != NULL);\n+\t      else\n+\t\t{\n+\t\t  if ((rank_remap && !ref->u.ar.end[dim])\n+\t\t      || (!rank_remap && ref->u.ar.end[dim]))\n+\t\t    {\n+\t\t      gfc_error (\"Either all or none of the upper bounds\"\n+\t\t\t\t \" must be specified at %L\", &lvalue->where);\n+\t\t      return FAILURE;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -3456,13 +3484,47 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n-  if (lvalue->rank != rvalue->rank)\n+  if (lvalue->rank != rvalue->rank && !rank_remap)\n     {\n-      gfc_error (\"Different ranks in pointer assignment at %L\",\n-\t\t &lvalue->where);\n+      gfc_error (\"Different ranks in pointer assignment at %L\", &lvalue->where);\n       return FAILURE;\n     }\n \n+  /* Check rank remapping.  */\n+  if (rank_remap)\n+    {\n+      mpz_t lsize, rsize;\n+\n+      /* If this can be determined, check that the target must be at least as\n+\t large as the pointer assigned to it is.  */\n+      if (gfc_array_size (lvalue, &lsize) == SUCCESS\n+\t  && gfc_array_size (rvalue, &rsize) == SUCCESS\n+\t  && mpz_cmp (rsize, lsize) < 0)\n+\t{\n+\t  gfc_error (\"Rank remapping target is smaller than size of the\"\n+\t\t     \" pointer (%ld < %ld) at %L\",\n+\t\t     mpz_get_si (rsize), mpz_get_si (lsize),\n+\t\t     &lvalue->where);\n+\t  return FAILURE;\n+\t}\n+\n+      /* The target must be either rank one or it must be simply contiguous\n+\t and F2008 must be allowed.  */\n+      if (rvalue->rank != 1)\n+\t{\n+\t  if (!gfc_is_simply_contiguous (rvalue, true))\n+\t    {\n+\t      gfc_error (\"Rank remapping target must be rank 1 or\"\n+\t\t\t \" simply contiguous at %L\", &rvalue->where);\n+\t      return FAILURE;\n+\t    }\n+\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Rank remapping\"\n+\t\t\t      \" target is not rank 1 at %L\", &rvalue->where)\n+\t\t== FAILURE)\n+\t    return FAILURE;\n+\t}\n+    }\n+\n   /* Now punt if we are dealing with a NULLIFY(X) or X = NULL(X).  */\n   if (rvalue->expr_type == EXPR_NULL)\n     return SUCCESS;"}, {"sha": "e355901f750c4218e18da0017551ac8871c48be2", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 132, "deletions": 51, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -382,6 +382,39 @@ gfc_build_null_descriptor (tree type)\n }\n \n \n+/* Modify a descriptor such that the lbound of a given dimension is the value\n+   specified.  This also updates ubound and offset accordingly.  */\n+\n+void\n+gfc_conv_shift_descriptor_lbound (stmtblock_t* block, tree desc,\n+\t\t\t\t  int dim, tree new_lbound)\n+{\n+  tree offs, ubound, lbound, stride;\n+  tree diff, offs_diff;\n+\n+  new_lbound = fold_convert (gfc_array_index_type, new_lbound);\n+\n+  offs = gfc_conv_descriptor_offset_get (desc);\n+  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]);\n+  ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]);\n+  stride = gfc_conv_descriptor_stride_get (desc, gfc_rank_cst[dim]);\n+\n+  /* Get difference (new - old) by which to shift stuff.  */\n+  diff = fold_build2 (MINUS_EXPR, gfc_array_index_type, new_lbound, lbound);\n+\n+  /* Shift ubound and offset accordingly.  This has to be done before\n+     updating the lbound, as they depend on the lbound expression!  */\n+  ubound = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, diff);\n+  gfc_conv_descriptor_ubound_set (block, desc, gfc_rank_cst[dim], ubound);\n+  offs_diff = fold_build2 (MULT_EXPR, gfc_array_index_type, diff, stride);\n+  offs = fold_build2 (MINUS_EXPR, gfc_array_index_type, offs, offs_diff);\n+  gfc_conv_descriptor_offset_set (block, desc, offs);\n+\n+  /* Finally set lbound to value we want.  */\n+  gfc_conv_descriptor_lbound_set (block, desc, gfc_rank_cst[dim], new_lbound);\n+}\n+\n+\n /* Cleanup those #defines.  */\n \n #undef DATA_FIELD\n@@ -3784,6 +3817,62 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n }\n \n \n+/* Calculate the size of a given array dimension from the bounds.  This\n+   is simply (ubound - lbound + 1) if this expression is positive\n+   or 0 if it is negative (pick either one if it is zero).  Optionally\n+   (if or_expr is present) OR the (expression != 0) condition to it.  */\n+\n+tree\n+gfc_conv_array_extent_dim (tree lbound, tree ubound, tree* or_expr)\n+{\n+  tree res;\n+  tree cond;\n+\n+  /* Calculate (ubound - lbound + 1).  */\n+  res = fold_build2 (MINUS_EXPR, gfc_array_index_type, ubound, lbound);\n+  res = fold_build2 (PLUS_EXPR, gfc_array_index_type, res, gfc_index_one_node);\n+\n+  /* Check whether the size for this dimension is negative.  */\n+  cond = fold_build2 (LE_EXPR, boolean_type_node, res, gfc_index_zero_node);\n+  res = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t      gfc_index_zero_node, res);\n+\n+  /* Build OR expression.  */\n+  if (or_expr)\n+    *or_expr = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, *or_expr, cond);\n+\n+  return res;\n+}\n+\n+\n+/* For an array descriptor, get the total number of elements.  This is just\n+   the product of the extents along all dimensions.  */\n+\n+tree\n+gfc_conv_descriptor_size (tree desc, int rank)\n+{\n+  tree res;\n+  int dim;\n+\n+  res = gfc_index_one_node;\n+\n+  for (dim = 0; dim < rank; ++dim)\n+    {\n+      tree lbound;\n+      tree ubound;\n+      tree extent;\n+\n+      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]);\n+      ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]);\n+\n+      extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+      res = fold_build2 (MULT_EXPR, gfc_array_index_type, res, extent);\n+    }\n+\n+  return res;\n+}\n+\n+\n /* Fills in an array descriptor, and returns the size of the array.  The size\n    will be a simple_val, ie a variable or a constant.  Also calculates the\n    offset of the base.  Returns the size of the array.\n@@ -3792,13 +3881,13 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n     offset = 0;\n     for (n = 0; n < rank; n++)\n       {\n-        a.lbound[n] = specified_lower_bound;\n-        offset = offset + a.lbond[n] * stride;\n-        size = 1 - lbound;\n-        a.ubound[n] = specified_upper_bound;\n-        a.stride[n] = stride;\n-        size = siz >= 0 ? ubound + size : 0; //size = ubound + 1 - lbound\n-        stride = stride * size;\n+\ta.lbound[n] = specified_lower_bound;\n+\toffset = offset + a.lbond[n] * stride;\n+\tsize = 1 - lbound;\n+\ta.ubound[n] = specified_upper_bound;\n+\ta.stride[n] = stride;\n+\tsize = siz >= 0 ? ubound + size : 0; //size = ubound + 1 - lbound\n+\tstride = stride * size;\n       }\n     return (stride);\n    }  */\n@@ -3814,7 +3903,6 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   tree size;\n   tree offset;\n   tree stride;\n-  tree cond;\n   tree or_expr;\n   tree thencase;\n   tree elsecase;\n@@ -3834,14 +3922,17 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n   tmp = gfc_conv_descriptor_dtype (descriptor);\n   gfc_add_modify (pblock, tmp, gfc_get_dtype (TREE_TYPE (descriptor)));\n \n-  or_expr = NULL_TREE;\n+  or_expr = boolean_false_node;\n \n   for (n = 0; n < rank; n++)\n     {\n+      tree conv_lbound;\n+      tree conv_ubound;\n+\n       /* We have 3 possibilities for determining the size of the array:\n-         lower == NULL    => lbound = 1, ubound = upper[n]\n-         upper[n] = NULL  => lbound = 1, ubound = lower[n]\n-         upper[n] != NULL => lbound = lower[n], ubound = upper[n]  */\n+\t lower == NULL    => lbound = 1, ubound = upper[n]\n+\t upper[n] = NULL  => lbound = 1, ubound = lower[n]\n+\t upper[n] != NULL => lbound = lower[n], ubound = upper[n]  */\n       ubound = upper[n];\n \n       /* Set lower bound.  */\n@@ -3851,52 +3942,41 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       else\n \t{\n \t  gcc_assert (lower[n]);\n-          if (ubound)\n-            {\n+\t  if (ubound)\n+\t    {\n \t      gfc_conv_expr_type (&se, lower[n], gfc_array_index_type);\n \t      gfc_add_block_to_block (pblock, &se.pre);\n-            }\n-          else\n-            {\n-              se.expr = gfc_index_one_node;\n-              ubound = lower[n];\n-            }\n+\t    }\n+\t  else\n+\t    {\n+\t      se.expr = gfc_index_one_node;\n+\t      ubound = lower[n];\n+\t    }\n \t}\n       gfc_conv_descriptor_lbound_set (pblock, descriptor, gfc_rank_cst[n],\n \t\t\t\t      se.expr);\n+      conv_lbound = se.expr;\n \n       /* Work out the offset for this component.  */\n       tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, se.expr, stride);\n       offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n \n-      /* Start the calculation for the size of this dimension.  */\n-      size = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t  gfc_index_one_node, se.expr);\n-\n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n       gcc_assert (ubound);\n       gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n       gfc_add_block_to_block (pblock, &se.pre);\n \n-      gfc_conv_descriptor_ubound_set (pblock, descriptor, gfc_rank_cst[n], se.expr);\n+      gfc_conv_descriptor_ubound_set (pblock, descriptor,\n+\t\t\t\t      gfc_rank_cst[n], se.expr);\n+      conv_ubound = se.expr;\n \n       /* Store the stride.  */\n-      gfc_conv_descriptor_stride_set (pblock, descriptor, gfc_rank_cst[n], stride);\n-\n-      /* Calculate the size of this dimension.  */\n-      size = fold_build2 (PLUS_EXPR, gfc_array_index_type, se.expr, size);\n-\n-      /* Check whether the size for this dimension is negative.  */\n-      cond = fold_build2 (LE_EXPR, boolean_type_node, size,\n-\t\t\t  gfc_index_zero_node);\n-      if (n == 0)\n-\tor_expr = cond;\n-      else\n-\tor_expr = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, or_expr, cond);\n+      gfc_conv_descriptor_stride_set (pblock, descriptor,\n+\t\t\t\t      gfc_rank_cst[n], stride);\n \n-      size = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t\t  gfc_index_zero_node, size);\n+      /* Calculate size and check whether extent is negative.  */\n+      size = gfc_conv_array_extent_dim (conv_lbound, conv_ubound, &or_expr);\n \n       /* Multiply the stride by the number of elements in this dimension.  */\n       stride = fold_build2 (MULT_EXPR, gfc_array_index_type, stride, size);\n@@ -3916,16 +3996,16 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t}\n       else\n \t{\n-          if (ubound || n == rank + corank - 1)\n-            {\n+\t  if (ubound || n == rank + corank - 1)\n+\t    {\n \t      gfc_conv_expr_type (&se, lower[n], gfc_array_index_type);\n \t      gfc_add_block_to_block (pblock, &se.pre);\n-            }\n-          else\n-            {\n-              se.expr = gfc_index_one_node;\n-              ubound = lower[n];\n-            }\n+\t    }\n+\t  else\n+\t    {\n+\t      se.expr = gfc_index_one_node;\n+\t      ubound = lower[n];\n+\t    }\n \t}\n       gfc_conv_descriptor_lbound_set (pblock, descriptor, gfc_rank_cst[n],\n \t\t\t\t      se.expr);\n@@ -3936,7 +4016,8 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t  gcc_assert (ubound);\n \t  gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n \t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  gfc_conv_descriptor_ubound_set (pblock, descriptor, gfc_rank_cst[n], se.expr);\n+\t  gfc_conv_descriptor_ubound_set (pblock, descriptor,\n+\t\t\t\t\t  gfc_rank_cst[n], se.expr);\n \t}\n     }\n \n@@ -5064,7 +5145,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       if (full)\n \t{\n-\t  if (se->direct_byref)\n+\t  if (se->direct_byref && !se->byref_noassign)\n \t    {\n \t      /* Copy the descriptor for pointer assignments.  */\n \t      gfc_add_modify (&se->pre, se->expr, desc);\n@@ -5269,7 +5350,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       desc = info->descriptor;\n       gcc_assert (secss && secss != gfc_ss_terminator);\n-      if (se->direct_byref)\n+      if (se->direct_byref && !se->byref_noassign)\n \t{\n \t  /* For pointer assignments we fill in the destination.  */\n \t  parm = se->expr;\n@@ -5427,7 +5508,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       desc = parm;\n     }\n \n-  if (!se->direct_byref)\n+  if (!se->direct_byref || se->byref_noassign)\n     {\n       /* Get a pointer to the new descriptor.  */\n       if (se->want_pointer)"}, {"sha": "a0d5ca128e19441da95064917bc6ed0bbff3ae49", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -139,6 +139,9 @@ void gfc_conv_descriptor_stride_set (stmtblock_t *, tree, tree, tree);\n void gfc_conv_descriptor_lbound_set (stmtblock_t *, tree, tree, tree);\n void gfc_conv_descriptor_ubound_set (stmtblock_t *, tree, tree, tree);\n \n+/* Shift lower bound of descriptor, updating ubound and offset.  */\n+void gfc_conv_shift_descriptor_lbound (stmtblock_t*, tree, int, tree);\n+\n /* Add pre-loop scalarization code for intrinsic functions which require\n    special handling.  */\n void gfc_add_intrinsic_ss_code (gfc_loopinfo *, gfc_ss *);\n@@ -149,3 +152,7 @@ tree gfc_build_constant_array_constructor (gfc_expr *, tree);\n \n /* Copy a string from src to dest.  */\n void gfc_trans_string_copy (stmtblock_t *, tree, tree, int, tree, tree, int);\n+\n+/* Calculate extent / size of an array.  */\n+tree gfc_conv_array_extent_dim (tree, tree, tree*);\n+tree gfc_conv_descriptor_size (tree, int);"}, {"sha": "ea397096de2e8caad467ddce9bccc5f891bd775e", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -3133,42 +3133,15 @@ trans_associate_var (gfc_symbol* sym, gfc_wrapped_block* block)\n \t descriptor to the one generated for the temporary.  */\n       if (!sym->assoc->variable)\n \t{\n-\t  tree offs;\n \t  int dim;\n \n \t  gfc_add_modify (&se.pre, desc, se.expr);\n \n \t  /* The generated descriptor has lower bound zero (as array\n-\t     temporary), shift bounds so we get lower bounds of 1 all the time.\n-\t     The offset has to be corrected as well.\n-\t     Because the ubound shift and offset depends on the lower bounds, we\n-\t     first calculate those and set the lbound to one last.  */\n-\n-\t  offs = gfc_conv_descriptor_offset_get (desc);\n-\t  for (dim = 0; dim < e->rank; ++dim)\n-\t    {\n-\t      tree from, to;\n-\t      tree stride;\n-\n-\t      from = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]);\n-\t      to = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]);\n-\t      stride = gfc_conv_descriptor_stride_get (desc, gfc_rank_cst[dim]);\n-\n-\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t gfc_index_one_node, from);\n-\t      to = fold_build2 (PLUS_EXPR, gfc_array_index_type, to, tmp);\n-\n-\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, stride);\n-\t      offs = fold_build2 (MINUS_EXPR, gfc_array_index_type, offs, tmp);\n-\n-\t      gfc_conv_descriptor_ubound_set (&se.pre, desc,\n-\t\t\t\t\t      gfc_rank_cst[dim], to);\n-\t    }\n-\t  gfc_conv_descriptor_offset_set (&se.pre, desc, offs);\n-\n+\t     temporary), shift bounds so we get lower bounds of 1.  */\n \t  for (dim = 0; dim < e->rank; ++dim)\n-\t    gfc_conv_descriptor_lbound_set (&se.pre, desc, gfc_rank_cst[dim],\n-\t\t\t\t\t    gfc_index_one_node);\n+\t    gfc_conv_shift_descriptor_lbound (&se.pre, desc,\n+\t\t\t\t\t      dim, gfc_index_one_node);\n \t}\n \n       /* Done, register stuff as init / cleanup code.  */"}, {"sha": "63e674681b3963a9e79c4464b78cdb48f9dc9a5c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 179, "deletions": 13, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -4773,21 +4773,46 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n     }\n   else\n     {\n+      gfc_ref* remap;\n+      bool rank_remap;\n       tree strlen_lhs;\n       tree strlen_rhs = NULL_TREE;\n \n-      /* Array pointer.  */\n+      /* Array pointer.  Find the last reference on the LHS and if it is an\n+\t array section ref, we're dealing with bounds remapping.  In this case,\n+\t set it to AR_FULL so that gfc_conv_expr_descriptor does\n+\t not see it and process the bounds remapping afterwards explicitely.  */\n+      for (remap = expr1->ref; remap; remap = remap->next)\n+\tif (!remap->next && remap->type == REF_ARRAY\n+\t    && remap->u.ar.type == AR_SECTION)\n+\t  {  \n+\t    remap->u.ar.type = AR_FULL;\n+\t    break;\n+\t  }\n+      rank_remap = (remap && remap->u.ar.end[0]);\n+\n       gfc_conv_expr_descriptor (&lse, expr1, lss);\n       strlen_lhs = lse.string_length;\n-      switch (expr2->expr_type)\n+      desc = lse.expr;\n+\n+      if (expr2->expr_type == EXPR_NULL)\n \t{\n-\tcase EXPR_NULL:\n \t  /* Just set the data pointer to null.  */\n \t  gfc_conv_descriptor_data_set (&lse.pre, lse.expr, null_pointer_node);\n-\t  break;\n-\n-\tcase EXPR_VARIABLE:\n-\t  /* Assign directly to the pointer's descriptor.  */\n+\t}\n+      else if (rank_remap)\n+\t{\n+\t  /* If we are rank-remapping, just get the RHS's descriptor and\n+\t     process this later on.  */\n+\t  gfc_init_se (&rse, NULL);\n+\t  rse.direct_byref = 1;\n+\t  rse.byref_noassign = 1;\n+\t  gfc_conv_expr_descriptor (&rse, expr2, rss);\n+\t  strlen_rhs = rse.string_length;\n+\t}\n+      else if (expr2->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  /* Assign directly to the LHS's descriptor.  */\n \t  lse.direct_byref = 1;\n \t  gfc_conv_expr_descriptor (&lse, expr2, rss);\n \t  strlen_rhs = lse.string_length;\n@@ -4806,24 +4831,142 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\tgfc_add_block_to_block (&lse.post, &rse.pre);\n \t      gfc_add_modify (&lse.post, GFC_DECL_SPAN(decl), tmp);\n \t    }\n-\n-\t  break;\n-\n-\tdefault:\n+\t}\n+      else\n+\t{\n \t  /* Assign to a temporary descriptor and then copy that\n \t     temporary to the pointer.  */\n-\t  desc = lse.expr;\n \t  tmp = gfc_create_var (TREE_TYPE (desc), \"ptrtemp\");\n \n \t  lse.expr = tmp;\n \t  lse.direct_byref = 1;\n \t  gfc_conv_expr_descriptor (&lse, expr2, rss);\n \t  strlen_rhs = lse.string_length;\n \t  gfc_add_modify (&lse.pre, desc, tmp);\n-\t  break;\n \t}\n \n       gfc_add_block_to_block (&block, &lse.pre);\n+      if (rank_remap)\n+\tgfc_add_block_to_block (&block, &rse.pre);\n+\n+      /* If we do bounds remapping, update LHS descriptor accordingly.  */\n+      if (remap)\n+\t{\n+\t  int dim;\n+\t  gcc_assert (remap->u.ar.dimen == expr1->rank);\n+\n+\t  if (rank_remap)\n+\t    {\n+\t      /* Do rank remapping.  We already have the RHS's descriptor\n+\t\t converted in rse and now have to build the correct LHS\n+\t\t descriptor for it.  */\n+\n+\t      tree dtype, data;\n+\t      tree offs, stride;\n+\t      tree lbound, ubound;\n+\n+\t      /* Set dtype.  */\n+\t      dtype = gfc_conv_descriptor_dtype (desc);\n+\t      tmp = gfc_get_dtype (TREE_TYPE (desc));\n+\t      gfc_add_modify (&block, dtype, tmp);\n+\n+\t      /* Copy data pointer.  */\n+\t      data = gfc_conv_descriptor_data_get (rse.expr);\n+\t      gfc_conv_descriptor_data_set (&block, desc, data);\n+\n+\t      /* Copy offset but adjust it such that it would correspond\n+\t\t to a lbound of zero.  */\n+\t      offs = gfc_conv_descriptor_offset_get (rse.expr);\n+\t      for (dim = 0; dim < expr2->rank; ++dim)\n+\t\t{\n+\t\t  stride = gfc_conv_descriptor_stride_get (rse.expr,\n+\t\t\t\t\t\t\t   gfc_rank_cst[dim]);\n+\t\t  lbound = gfc_conv_descriptor_lbound_get (rse.expr,\n+\t\t\t\t\t\t\t   gfc_rank_cst[dim]);\n+\t\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t     stride, lbound);\n+\t\t  offs = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      offs, tmp);\n+\t\t}\n+\t      gfc_conv_descriptor_offset_set (&block, desc, offs);\n+\n+\t      /* Set the bounds as declared for the LHS and calculate strides as\n+\t\t well as another offset update accordingly.  */\n+\t      stride = gfc_conv_descriptor_stride_get (rse.expr,\n+\t\t\t\t\t\t       gfc_rank_cst[0]);\n+\t      for (dim = 0; dim < expr1->rank; ++dim)\n+\t\t{\n+\t\t  gfc_se lower_se;\n+\t\t  gfc_se upper_se;\n+\n+\t\t  gcc_assert (remap->u.ar.start[dim] && remap->u.ar.end[dim]);\n+\n+\t\t  /* Convert declared bounds.  */\n+\t\t  gfc_init_se (&lower_se, NULL);\n+\t\t  gfc_init_se (&upper_se, NULL);\n+\t\t  gfc_conv_expr (&lower_se, remap->u.ar.start[dim]);\n+\t\t  gfc_conv_expr (&upper_se, remap->u.ar.end[dim]);\n+\n+\t\t  gfc_add_block_to_block (&block, &lower_se.pre);\n+\t\t  gfc_add_block_to_block (&block, &upper_se.pre);\n+\n+\t\t  lbound = fold_convert (gfc_array_index_type, lower_se.expr);\n+\t\t  ubound = fold_convert (gfc_array_index_type, upper_se.expr);\n+\n+\t\t  lbound = gfc_evaluate_now (lbound, &block);\n+\t\t  ubound = gfc_evaluate_now (ubound, &block);\n+\n+\t\t  gfc_add_block_to_block (&block, &lower_se.post);\n+\t\t  gfc_add_block_to_block (&block, &upper_se.post);\n+\n+\t\t  /* Set bounds in descriptor.  */\n+\t\t  gfc_conv_descriptor_lbound_set (&block, desc,\n+\t\t\t\t\t\t  gfc_rank_cst[dim], lbound);\n+\t\t  gfc_conv_descriptor_ubound_set (&block, desc,\n+\t\t\t\t\t\t  gfc_rank_cst[dim], ubound);\n+\n+\t\t  /* Set stride.  */\n+\t\t  stride = gfc_evaluate_now (stride, &block);\n+\t\t  gfc_conv_descriptor_stride_set (&block, desc,\n+\t\t\t\t\t\t  gfc_rank_cst[dim], stride);\n+\n+\t\t  /* Update offset.  */\n+\t\t  offs = gfc_conv_descriptor_offset_get (desc);\n+\t\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t     lbound, stride);\n+\t\t  offs = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      offs, tmp);\n+\t\t  offs = gfc_evaluate_now (offs, &block);\n+\t\t  gfc_conv_descriptor_offset_set (&block, desc, offs);\n+\n+\t\t  /* Update stride.  */\n+\t\t  tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\t\t  stride = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t\tstride, tmp);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Bounds remapping.  Just shift the lower bounds.  */\n+\n+\t      gcc_assert (expr1->rank == expr2->rank);\n+\n+\t      for (dim = 0; dim < remap->u.ar.dimen; ++dim)\n+\t\t{\n+\t\t  gfc_se lbound_se;\n+\n+\t\t  gcc_assert (remap->u.ar.start[dim]);\n+\t\t  gcc_assert (!remap->u.ar.end[dim]);\n+\t\t  gfc_init_se (&lbound_se, NULL);\n+\t\t  gfc_conv_expr (&lbound_se, remap->u.ar.start[dim]);\n+\n+\t\t  gfc_add_block_to_block (&block, &lbound_se.pre);\n+\t\t  gfc_conv_shift_descriptor_lbound (&block, desc,\n+\t\t\t\t\t\t    dim, lbound_se.expr);\n+\t\t  gfc_add_block_to_block (&block, &lbound_se.post);\n+\t\t}\n+\t    }\n+\t}\n \n       /* Check string lengths if applicable.  The check is only really added\n \t to the output code if -fbounds-check is enabled.  */\n@@ -4835,8 +4978,31 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t\t\t       strlen_lhs, strlen_rhs, &block);\n \t}\n \n+      /* If rank remapping was done, check with -fcheck=bounds that\n+\t the target is at least as large as the pointer.  */\n+      if (rank_remap && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS))\n+\t{\n+\t  tree lsize, rsize;\n+\t  tree fault;\n+\t  const char* msg;\n+\n+\t  lsize = gfc_conv_descriptor_size (lse.expr, expr1->rank);\n+\t  rsize = gfc_conv_descriptor_size (rse.expr, expr2->rank);\n+\n+\t  lsize = gfc_evaluate_now (lsize, &block);\n+\t  rsize = gfc_evaluate_now (rsize, &block);\n+\t  fault = fold_build2 (LT_EXPR, boolean_type_node, rsize, lsize);\n+\n+\t  msg = _(\"Target of rank remapping is too small (%ld < %ld)\");\n+\t  gfc_trans_runtime_check (true, false, fault, &block, &expr2->where,\n+\t\t\t\t   msg, rsize, lsize);\n+\t}\n+\n       gfc_add_block_to_block (&block, &lse.post);\n+      if (rank_remap)\n+\tgfc_add_block_to_block (&block, &rse.post);\n     }\n+\n   return gfc_finish_block (&block);\n }\n "}, {"sha": "d5f82aa29c6f16f44d47fee9478fe213206c33b0", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -64,6 +64,13 @@ typedef struct gfc_se\n      pointer assignments.  */\n   unsigned direct_byref:1;\n \n+  /* If direct_byref is set, do work out the descriptor as in that case but\n+     do still create a new descriptor variable instead of using an\n+     existing one.  This is useful for special pointer assignments like\n+     rank remapping where we have to process the descriptor before\n+     assigning to final one.  */\n+  unsigned byref_noassign:1;\n+\n   /* Ignore absent optional arguments.  Used for some intrinsics.  */\n   unsigned ignore_optional:1;\n "}, {"sha": "8867dee32f578478fbe150561d35c094b556fe2e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -1,3 +1,15 @@\n+2010-08-19  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/29785\n+\tPR fortran/45016\n+\t* gfortran.dg/pointer_assign_5.f90: Remove 'not implemented' error.\n+\t* gfortran.dg/pointer_remapping_1.f90: New test.\n+\t* gfortran.dg/pointer_remapping_2.f03: New test.\n+\t* gfortran.dg/pointer_remapping_3.f08: New test.\n+\t* gfortran.dg/pointer_remapping_4.f03: New test.\n+\t* gfortran.dg/pointer_remapping_5.f08: New test.\n+\t* gfortran.dg/pointer_remapping_6.f08: New test.\n+\n 2010-08-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR testsuite/45324"}, {"sha": "1994ffebb7ef47f97e02e9554f828ca1e0445f87", "filename": "gcc/testsuite/gfortran.dg/pointer_assign_5.f90", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_5.f90?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -1,9 +1,10 @@\n ! { dg-do compile }\n ! PR fortran/37580\n-!\n+\n+! See also the pointer_remapping_* tests.\n+\n program test\n implicit none\n real, pointer :: ptr1(:), ptr2(:)\n ptr1(1) => ptr2 ! { dg-error \"Expected bounds specification\" }\n-ptr1(1:) => ptr2 ! { dg-error \"not yet implemented in gfortran\" }\n end program test"}, {"sha": "d360c4223ccbcaf5568a4d128d440ff4bbab51e5", "filename": "gcc/testsuite/gfortran.dg/pointer_remapping_1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_1.f90?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+\n+! PR fortran/29785\n+! PR fortran/45016\n+! Check for F2003 rejection of pointer remappings.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, TARGET :: arr(12)\n+  INTEGER, POINTER :: vec(:), mat(:, :)\n+\n+  vec => arr ! This is ok.\n+\n+  vec(2:) => arr ! { dg-error \"Fortran 2003\" }\n+  mat(1:2, 1:6) => arr ! { dg-error \"Fortran 2003\" }\n+END PROGRAM main"}, {"sha": "57ec5c87237e4fc88759a7b9a7b055bf1ac17a56", "filename": "gcc/testsuite/gfortran.dg/pointer_remapping_2.f03", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_2.f03?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! PR fortran/29785\n+! Check for F2008 rejection of rank remapping to rank-two base array.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, TARGET :: arr(12), basem(3, 4)\n+  INTEGER, POINTER :: vec(:), mat(:, :)\n+\n+  ! These are ok.\n+  vec => arr\n+  vec(2:) => arr\n+  mat(1:2, 1:6) => arr\n+\n+  vec(1:12) => basem ! { dg-error \"Fortran 2008\" }\n+END PROGRAM main"}, {"sha": "376adb07afcbf153d0a675ea379272dda1b47333", "filename": "gcc/testsuite/gfortran.dg/pointer_remapping_3.f08", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_3.f08?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+\n+! PR fortran/29785\n+! PR fortran/45016\n+! Check for pointer remapping compile-time errors.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, TARGET :: arr(12), basem(3, 4)\n+  INTEGER, POINTER :: vec(:), mat(:, :)\n+\n+  ! Existence of reference elements.\n+  vec(:) => arr ! { dg-error \"Lower bound has to be present\" }\n+  vec(5:7:1) => arr ! { dg-error \"Stride must not be present\" }\n+  mat(1:, 2:5) => arr ! { dg-error \"Either all or none of the upper bounds\" }\n+  mat(2, 6) => arr ! { dg-error \"Expected bounds specification\" }\n+\n+  ! This is bound remapping not rank remapping!\n+  mat(1:, 3:) => arr ! { dg-error \"Different ranks\" }\n+\n+  ! Invalid remapping target; for non-rank one we already check the F2008\n+  ! error elsewhere.  Here, test that not-contiguous target is disallowed\n+  ! with rank > 1.\n+  mat(1:2, 1:3) => arr(1:12:2) ! This is ok, rank one target.\n+  vec(1:8) => basem(1:3:2, :) ! { dg-error \"rank 1 or simply contiguous\" }\n+\n+  ! Target is smaller than pointer.\n+  vec(1:20) => arr ! { dg-error \"smaller than size of the pointer\" }\n+  vec(1:10) => arr(1:12:2) ! { dg-error \"smaller than size of the pointer\" }\n+  vec(1:20) => basem(:, :) ! { dg-error \"smaller than size of the pointer\" }\n+  mat(1:5, 1:5) => arr ! { dg-error \"smaller than size of the pointer\" }\n+END PROGRAM main"}, {"sha": "d196ddeb0d1d7c828e3f15e83a07a43e1c5d8ac0", "filename": "gcc/testsuite/gfortran.dg/pointer_remapping_4.f03", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_4.f03?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2003 -fall-intrinsics -fcheck=bounds\" }\n+\n+! PR fortran/45016\n+! Check pointer bounds remapping at runtime.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, TARGET :: arr(2_2:5), basem(-2:-1, 3:4_1)\n+  INTEGER, POINTER :: vec(:), vec2(:), mat(:, :)\n+\n+  arr = (/ 1, 2, 3, 4 /)\n+  basem = RESHAPE (arr, SHAPE (basem))\n+\n+  vec(0:) => arr\n+  IF (LBOUND (vec, 1) /= 0 .OR. UBOUND (vec, 1) /= 3) CALL abort ()\n+  IF (ANY (vec /= arr)) CALL abort ()\n+  IF (vec(0) /= 1 .OR. vec(2) /= 3) CALL abort ()\n+\n+  ! Test with bound different of index type, so conversion is necessary.\n+  vec2(-5_1:) => vec\n+  IF (LBOUND (vec2, 1) /= -5 .OR. UBOUND (vec2, 1) /= -2) CALL abort ()\n+  IF (ANY (vec2 /= arr)) CALL abort ()\n+  IF (vec2(-5) /= 1 .OR. vec2(-3) /= 3) CALL abort ()\n+\n+  mat(1:, 2:) => basem\n+  IF (ANY (LBOUND (mat) /= (/ 1, 2 /) .OR. UBOUND (mat) /= (/ 2, 3 /))) &\n+    CALL abort ()\n+  IF (ANY (mat /= basem)) CALL abort ()\n+  IF (mat(1, 2) /= 1 .OR. mat(1, 3) /= 3 .OR. mat(2, 3) /= 4) CALL abort ()\n+END PROGRAM main"}, {"sha": "28c0a7d8da6d26d1ae2fb44abed7625d00330a43", "filename": "gcc/testsuite/gfortran.dg/pointer_remapping_5.f08", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_5.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_5.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_5.f08?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics -fcheck=bounds\" }\n+\n+! PR fortran/29785\n+! Check pointer rank remapping at runtime.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, TARGET :: arr(12), basem(3, 4)\n+  INTEGER, POINTER :: vec(:), mat(:, :)\n+  INTEGER :: i\n+\n+  arr = (/ (i, i = 1, 12) /)\n+  basem = RESHAPE (arr, SHAPE (basem))\n+\n+  ! We need not necessarily change the rank...\n+  vec(2_1:5) => arr(1_1:12_1:2_1)\n+  IF (LBOUND (vec, 1) /= 2 .OR. UBOUND (vec, 1) /= 5) CALL abort ()\n+  IF (ANY (vec /= (/ 1, 3, 5, 7 /))) CALL abort ()\n+  IF (vec(2) /= 1 .OR. vec(5) /= 7) CALL abort ()\n+\n+  ! ...but it is of course the more interesting.  Also try remapping a pointer.\n+  vec => arr(1:12:2)\n+  mat(1:3, 1:2) => vec\n+  IF (ANY (LBOUND (mat) /= (/ 1, 1 /) .OR. UBOUND (mat) /= (/ 3, 2 /))) &\n+    CALL abort ()\n+  IF (ANY (mat /= RESHAPE (arr(1:12:2), SHAPE (mat)))) CALL abort ()\n+  IF (mat(1, 1) /= 1 .OR. mat(1, 2) /= 7) CALL abort ()\n+\n+  ! Remap with target of rank > 1.\n+  vec(1:12_1) => basem\n+  IF (LBOUND (vec, 1) /= 1 .OR. UBOUND (vec, 1) /= 12) CALL abort ()\n+  IF (ANY (vec /= arr)) CALL abort ()\n+  IF (vec(1) /= 1 .OR. vec(5) /= 5 .OR. vec(12) /= 12) CALL abort ()\n+END PROGRAM main"}, {"sha": "6a4e138f9e5b1bc03ef63d9130177d0d8d14cd1a", "filename": "gcc/testsuite/gfortran.dg/pointer_remapping_6.f08", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_6.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99d821c01cacbfdba524cb4d4d8ea066abd15d2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_6.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_remapping_6.f08?ref=99d821c01cacbfdba524cb4d4d8ea066abd15d2b", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fcheck=bounds\" }\n+! { dg-shouldfail \"Bounds check\" }\n+\n+! PR fortran/29785\n+! Check that -fcheck=bounds catches too small target at runtime for\n+! pointer rank remapping.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, POINTER :: ptr(:, :)\n+  INTEGER :: n\n+\n+  n = 10\n+  BLOCK\n+    INTEGER, TARGET :: arr(2*n)\n+\n+    ! These are ok.\n+    ptr(1:5, 1:2) => arr\n+    ptr(1:5, 1:2) => arr(::2)\n+    ptr(-5:-1, 11:14) => arr\n+\n+    ! This is not.\n+    ptr(1:3, 1:5) => arr(::2)\n+  END BLOCK\n+END PROGRAM main\n+! { dg-output \"At line 26 of .*\\nFortran runtime error: Target of rank remapping is too small \\\\(10 < 15\\\\)\" }"}]}