{"sha": "bf510679bb3f9bfd6019666065016bb26a5b5466", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY1MTA2NzliYjNmOWJmZDYwMTk2NjYwNjUwMTZiYjI2YTViNTQ2Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-06T08:32:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-06T08:32:22Z"}, "message": "divmod: Match and expand DIVMOD even in some cases of constant divisor [PR97282]\n\nAs written in the comment, tree-ssa-math-opts.c wouldn't create a DIVMOD\nifn call for division + modulo by constant for the fear that during\nexpansion we could generate better code for those cases.\nIf the divisoris a power of two, that is certainly the case always,\nbut otherwise expand_divmod can punt in many cases, e.g. if the division\ntype's precision is above HOST_BITS_PER_WIDE_INT, we don't even call\nchoose_multiplier, because it works on HOST_WIDE_INTs (true, something\nwe should fix eventually now that we have wide_ints), or if pre/post shift\nis larger than BITS_PER_WORD.\n\nSo, the following patch recognizes DIVMOD with constant last argument even\nwhen it is unclear if expand_divmod will be able to optimize it, and then\nduring DIVMOD expansion if the divisor is constant attempts to expand it as\ndivision + modulo and if they actually don't contain any libcalls or\ndivision/modulo, they are kept as is, otherwise that sequence is thrown away\nand divmod optab or libcall is used.\n\n2020-10-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/97282\n\t* tree-ssa-math-opts.c (divmod_candidate_p): Don't return false for\n\tconstant op2 if it is not a power of two and the type has precision\n\tlarger than HOST_BITS_PER_WIDE_INT or BITS_PER_WORD.\n\t* internal-fn.c (contains_call_div_mod): New function.\n\t(expand_DIVMOD): If last argument is a constant, try to expand it as\n\tTRUNC_DIV_EXPR followed by TRUNC_MOD_EXPR, but if the sequence\n\tcontains any calls or {,U}{DIV,MOD} rtxes, throw it away and use\n\tdivmod optab or divmod libfunc.\n\n\t* gcc.target/i386/pr97282.c: New test.", "tree": {"sha": "55da62e4b535db3b797d597c28674e659e57f56d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55da62e4b535db3b797d597c28674e659e57f56d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf510679bb3f9bfd6019666065016bb26a5b5466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf510679bb3f9bfd6019666065016bb26a5b5466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf510679bb3f9bfd6019666065016bb26a5b5466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf510679bb3f9bfd6019666065016bb26a5b5466/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "952adf021889b5e055085d0ed63942ff97d913de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952adf021889b5e055085d0ed63942ff97d913de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952adf021889b5e055085d0ed63942ff97d913de"}], "stats": {"total": 109, "additions": 105, "deletions": 4}, "files": [{"sha": "92cb3cd845a6078c6ec833e512ca54443d970fe5", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf510679bb3f9bfd6019666065016bb26a5b5466/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf510679bb3f9bfd6019666065016bb26a5b5466/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=bf510679bb3f9bfd6019666065016bb26a5b5466", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n #include \"explow.h\"\n+#include \"rtl-iter.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -2985,6 +2986,32 @@ expand_gather_load_optab_fn (internal_fn, gcall *stmt, direct_optab optab)\n     emit_move_insn (lhs_rtx, ops[0].value);\n }\n \n+/* Helper for expand_DIVMOD.  Return true if the sequence starting with\n+   INSN contains any call insns or insns with {,U}{DIV,MOD} rtxes.  */\n+\n+static bool\n+contains_call_div_mod (rtx_insn *insn)\n+{\n+  subrtx_iterator::array_type array;\n+  for (; insn; insn = NEXT_INSN (insn))\n+    if (CALL_P (insn))\n+      return true;\n+    else if (INSN_P (insn))\n+      FOR_EACH_SUBRTX (iter, array, PATTERN (insn), NONCONST)\n+\tswitch (GET_CODE (*iter))\n+\t  {\n+\t  case CALL:\n+\t  case DIV:\n+\t  case UDIV:\n+\t  case MOD:\n+\t  case UMOD:\n+\t    return true;\n+\t  default:\n+\t    break;\n+\t  }\n+  return false;\n+ }\n+\n /* Expand DIVMOD() using:\n  a) optab handler for udivmod/sdivmod if it is available.\n  b) If optab_handler doesn't exist, generate call to\n@@ -3007,18 +3034,52 @@ expand_DIVMOD (internal_fn, gcall *call_stmt)\n   rtx op1 = expand_normal (arg1);\n   rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n-  rtx quotient, remainder, libfunc;\n+  rtx quotient = NULL_RTX, remainder = NULL_RTX;\n+  rtx_insn *insns = NULL;\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n+    {\n+      /* For DIVMOD by integral constants, there could be efficient code\n+\t expanded inline e.g. using shifts and plus/minus.  Try to expand\n+\t the division and modulo and if it emits any library calls or any\n+\t {,U}{DIV,MOD} rtxes throw it away and use a divmod optab or\n+\t divmod libcall.  */\n+      struct separate_ops ops;\n+      ops.code = TRUNC_DIV_EXPR;\n+      ops.type = type;\n+      ops.op0 = make_tree (ops.type, op0);\n+      ops.op1 = arg1;\n+      ops.op2 = NULL_TREE;\n+      ops.location = gimple_location (call_stmt);\n+      start_sequence ();\n+      quotient = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+      if (contains_call_div_mod (get_insns ()))\n+\tquotient = NULL_RTX;\n+      else\n+\t{\n+\t  ops.code = TRUNC_MOD_EXPR;\n+\t  remainder = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n+\t  if (contains_call_div_mod (get_insns ()))\n+\t    remainder = NULL_RTX;\n+\t}\n+      if (remainder)\n+\tinsns = get_insns ();\n+      end_sequence ();\n+    }\n+\n+  if (remainder)\n+    emit_insn (insns);\n \n   /* Check if optab_handler exists for divmod_optab for given mode.  */\n-  if (optab_handler (tab, mode) != CODE_FOR_nothing)\n+  else if (optab_handler (tab, mode) != CODE_FOR_nothing)\n     {\n       quotient = gen_reg_rtx (mode);\n       remainder = gen_reg_rtx (mode);\n       expand_twoval_binop (tab, op0, op1, quotient, remainder, unsignedp);\n     }\n \n   /* Generate call to divmod libfunc if it exists.  */\n-  else if ((libfunc = optab_libfunc (tab, mode)) != NULL_RTX)\n+  else if (rtx libfunc = optab_libfunc (tab, mode))\n     targetm.expand_divmod_libfunc (libfunc, mode, op0, op1,\n \t\t\t\t   &quotient, &remainder);\n "}, {"sha": "6fb10c8bb82189845ee370d649d002e9584f7c7c", "filename": "gcc/testsuite/gcc.target/i386/pr97282.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf510679bb3f9bfd6019666065016bb26a5b5466/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97282.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf510679bb3f9bfd6019666065016bb26a5b5466/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97282.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97282.c?ref=bf510679bb3f9bfd6019666065016bb26a5b5466", "patch": "@@ -0,0 +1,25 @@\n+/* PR rtl-optimization/97282 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"call\\[^\\n\\r]*__udivmod\\[dt]i4\" } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __uint128_t T;\n+#else\n+typedef unsigned long long T;\n+#endif\n+\n+unsigned long\n+foo (T x)\n+{\n+  if (x == 0)\n+    return 0;\n+\n+  unsigned long ret = 0;\n+  while (x > 0)\n+    {\n+      ret = ret + x % 10;\n+      x = x / 10;\n+    }\n+  return ret;\n+}"}, {"sha": "4927255d456650a7da4f9871a1fb50ee70e4e097", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf510679bb3f9bfd6019666065016bb26a5b5466/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf510679bb3f9bfd6019666065016bb26a5b5466/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=bf510679bb3f9bfd6019666065016bb26a5b5466", "patch": "@@ -3567,9 +3567,24 @@ divmod_candidate_p (gassign *stmt)\n \n   /* Disable the transform if either is a constant, since division-by-constant\n      may have specialized expansion.  */\n-  if (CONSTANT_CLASS_P (op1) || CONSTANT_CLASS_P (op2))\n+  if (CONSTANT_CLASS_P (op1))\n     return false;\n \n+  if (CONSTANT_CLASS_P (op2))\n+    {\n+      if (integer_pow2p (op2))\n+\treturn false;\n+\n+      if (TYPE_PRECISION (type) <= HOST_BITS_PER_WIDE_INT\n+\t  && TYPE_PRECISION (type) <= BITS_PER_WORD)\n+\treturn false;\n+\n+      /* If the divisor is not power of 2 and the precision wider than\n+\t HWI, expand_divmod punts on that, so in that case it is better\n+\t to use divmod optab or libfunc.  Similarly if choose_multiplier\n+\t might need pre/post shifts of BITS_PER_WORD or more.  */\n+    }\n+\n   /* Exclude the case where TYPE_OVERFLOW_TRAPS (type) as that should\n      expand using the [su]divv optabs.  */\n   if (TYPE_OVERFLOW_TRAPS (type))"}]}