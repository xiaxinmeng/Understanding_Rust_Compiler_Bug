{"sha": "4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "node_id": "C_kwDOANBUbNoAKDRjMzQ4ODVhNWFmYmRhNGJhZDU4NzM2NjhjZGM2ZmRkZDJkMWMyOWI", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-05-10T13:17:46Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-05-17T16:13:45Z"}, "message": "libproc_macro: Change cpp literal representation\n\nChange the literal representation on cpp side to match the new one in\nrust. This means FFIString had to be implemented on cpp side. A few\nhelper functions has also been introduced.\n\nChangeLog:\n\n\t* libgrust/libproc_macro/Makefile.am: Add ffistring unit to\n\tcompiled objects list.\n\t* libgrust/libproc_macro/Makefile.in: Regenerate.\n\t* libgrust/libproc_macro/literal.cc (Literal::drop): Change with\n\ta call to ffistring drop function.\n\t(Literal::make_literal): Add new helper constructor\n\t(Literal__drop): Remove this function.\n\t(Literal__string): Likewise.\n\t(Literal__byte_string): Likewise.\n\t(Literal__from_string): Moved this function.\n\t(Literal::make_unsigned): Changed the constructor to match the\n\tnew layout.\n\t(Literal::make_signed): Likewise.\n\t(Literal::clone): Reimplement th eclone function.\n\t(Literal::make_u8): Changed the constructor, make suffixed by\n\tdefault.\n\t(Literal::make_u16): Likewise.\n\t(Literal::make_u32): Likewise.\n\t(Literal::make_u64): Likewise.\n\t(Literal::make_i8): Likewise.\n\t(Literal::make_i16): Likewise.\n\t(Literal::make_i32): Likewise.\n\t(Literal::make_i64): Likewise.\n\t(Literal::make_string): Likewise.\n\t(Literal::make_byte_string): Likewise.\n\t(Literal::make_f32): Likewise.\n\t(Literal::make_f64): Likewise.\n\t(Literal::make_char): Likewise.\n\t(Literal::make_usize): Likewise.\n\t(Literal::make_isize): Likewise.\n\t(LitKind::make_byte): Add new helper constructor to avoid having\n\tto set the payload value.\n\t(LitKind::make_char): Likewise.\n\t(LitKind::make_integer): Likewise.\n\t(LitKind::make_float): Likewise.\n\t(LitKind::make_str): Likewise.\n\t(LitKind::make_str_raw): Add a new helper constructor which\n\ttakes the payload value as an argument.\n\t(LitKind::make_byte_str): Add new helper constructor to avoid\n\tmistakes with payload value.\n\t(LitKind::make_byte_str_raw): Add a new helper constructor which\n\ttakes the payload value as an argument.\n\t* libgrust/libproc_macro/literal.h: Add new functions prototype.\n\t(enum UnsignedTag): Removed because it is now unused.\n\t(struct Payload128): Likewise.\n\t(union UnsignedPayload): Likewise.\n\t(struct Unsigned): Likewise.\n\t(enum SignedTag): Likewise.\n\t(union SignedPayload): Likewise.\n\t(struct Signed): Likewise.\n\t(enum LiteralTag): Likewise.\n\t(enum LitKindTag): Likewise.\n\t(struct StringPayload): Likewise.\n\t(struct ByteStringPayload): Likewise.\n\t(union LitKindPayload): Likewise.\n\t(struct UnsignedSuffixPayload): Likewise.\n\t(struct LitKind): Add new literal kind struct representation to\n\tmatch the enum on rust side.\n\t(struct SignedSuffixPayload): Removed because now unused.\n\t(struct UsizePayload): Likewise.\n\t(struct IsizePayload): Likewise.\n\t(struct Float32Payload): Likewise.\n\t(struct Float64Payload): Likewise.\n\t(union LiteralPayload): Likewise.\n\t(struct Literal): Changed the internals of the structure.\n\t(Literal__drop): Removed the drop function fom the c interface.\n\t(Literal__string): Removed unused function.\n\t(Literal__byte_string): Removed unused function.\n\t* libgrust/libproc_macro/ffistring.cc: New file.\n\t* libgrust/libproc_macro/ffistring.h: New file.\n\ngcc/rust/ChangeLog:\n\n\t* lex/rust-token.h: Implement hash for token id enumeration.\n\t* util/rust-token-converter.cc (dispatch_float_literals): Update\n\tto new internals.\n\t(dispatch_integer_literals): Likewise.\n\t(convert): Likewise.\n\t(string_literal): Remove function.\n\t(byte_string_literal): Likewise.\n\t(unsigned_literal): Likewise.\n\t(signed_literal): Likewise.\n\t(from_literal): Update with new internals.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "4075f5ac51e6118da4624261c6b3afcbfe0cfd28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4075f5ac51e6118da4624261c6b3afcbfe0cfd28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a893441ea2b3e8ac20cad5a1168ab0cd0d3c02"}], "stats": {"total": 882, "additions": 368, "deletions": 514}, "files": [{"sha": "8956d7ba010dea1d6d6d9952ddcad6ffc4c4e8c1", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -456,4 +456,16 @@ return *str;\n };\n } // namespace Rust\n \n+namespace std {\n+template <> struct hash<Rust::PrimitiveCoreType>\n+{\n+  size_t operator() (const Rust::PrimitiveCoreType &coretype) const noexcept\n+  {\n+    return hash<std::underlying_type<Rust::PrimitiveCoreType>::type> () (\n+      static_cast<std::underlying_type<Rust::PrimitiveCoreType>::type> (\n+\tcoretype));\n+  }\n+};\n+} // namespace std\n+\n #endif"}, {"sha": "d56493f5411c2ef21589ede1b5d59f288932f40b", "filename": "gcc/rust/util/rust-token-converter.cc", "status": "modified", "additions": 65, "deletions": 203, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/gcc%2Frust%2Futil%2Frust-token-converter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/gcc%2Frust%2Futil%2Frust-token-converter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-token-converter.cc?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -17,9 +17,28 @@\n #include \"rust-lex.h\"\n #include \"rust-token-converter.h\"\n #include \"libproc_macro/proc_macro.h\"\n+#include \"bi-map.h\"\n+\n+#include <string>\n \n namespace Rust {\n \n+static const BiMap<PrimitiveCoreType, std::string> suffixes\n+  = {{{CORETYPE_F32, \"f32\"},\n+      {CORETYPE_F64, \"f64\"},\n+      {CORETYPE_U8, \"u8\"},\n+      {CORETYPE_U16, \"u16\"},\n+      {CORETYPE_U32, \"u32\"},\n+      {CORETYPE_U64, \"u64\"},\n+      {CORETYPE_U128, \"u128\"},\n+      {CORETYPE_I8, \"i8\"},\n+      {CORETYPE_I16, \"i16\"},\n+      {CORETYPE_I32, \"i32\"},\n+      {CORETYPE_I64, \"i64\"},\n+      {CORETYPE_I128, \"i128\"},\n+      {CORETYPE_ISIZE, \"isize\"},\n+      {CORETYPE_USIZE, \"usize\"}}};\n+\n static void\n pop_group (std::vector<ProcMacro::TokenStream> &streams,\n \t   ProcMacro::Delimiter delim)\n@@ -35,93 +54,24 @@ static void\n dispatch_float_literals (ProcMacro::TokenStream &ts,\n \t\t\t const const_TokenPtr &token)\n {\n-  std::string::size_type sz;\n   auto str = token->as_string ();\n-  switch (token->get_type_hint ())\n-    {\n-      case CORETYPE_F32: {\n-\tauto value = std::stof (str, &sz);\n-\tts.push (ProcMacro::TokenTree::make_tokentree (\n-\t  ProcMacro::Literal::make_f32 (value, sz != str.length ())));\n-      }\n-      break;\n-      case CORETYPE_F64: {\n-\tauto value = std::stod (str, &sz);\n-\tts.push (ProcMacro::TokenTree::make_tokentree (\n-\t  ProcMacro::Literal::make_f64 (value, sz != str.length ())));\n-      }\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  auto kind = ProcMacro::LitKind::make_float ();\n+  auto lookup = suffixes.lookup (token->get_type_hint ());\n+  auto suffix = suffixes.is_iter_ok (lookup) ? lookup->second : \"\";\n+  ts.push (ProcMacro::TokenTree::make_tokentree (\n+    ProcMacro::Literal::make_literal (kind, str, suffix)));\n }\n \n static void\n dispatch_integer_literals (ProcMacro::TokenStream &ts,\n \t\t\t   const const_TokenPtr &token)\n {\n-  std::string::size_type sz;\n   auto str = token->as_string ();\n-  unsigned long long uvalue;\n-  long long svalue;\n-\n-  switch (token->get_type_hint ())\n-    {\n-    case CORETYPE_U8:\n-      uvalue = std::stoull (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u8 (uvalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_U16:\n-      uvalue = std::stoull (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u16 (uvalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_U32:\n-      uvalue = std::stoull (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u32 (uvalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_U64:\n-      uvalue = std::stoull (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_u32 (uvalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_I8:\n-      svalue = std::stoll (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i8 (svalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_I16:\n-      svalue = std::stoll (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i16 (svalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_I32:\n-      svalue = std::stoll (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i32 (svalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_I64:\n-      svalue = std::stoll (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_i32 (svalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_INT:\n-      svalue = std::stoll (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_isize (svalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_UINT:\n-      uvalue = std::stoull (str, &sz);\n-      ts.push (ProcMacro::TokenTree::make_tokentree (\n-\tProcMacro::Literal::make_usize (uvalue, sz != str.length ())));\n-      break;\n-    case CORETYPE_UNKNOWN:\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n+  auto kind = ProcMacro::LitKind::make_integer ();\n+  auto lookup = suffixes.lookup (token->get_type_hint ());\n+  auto suffix = suffixes.is_iter_ok (lookup) ? lookup->second : \"\";\n+  ts.push (ProcMacro::TokenTree::make_tokentree (\n+    ProcMacro::Literal::make_literal (kind, str, suffix)));\n }\n \n ProcMacro::TokenStream\n@@ -140,21 +90,25 @@ convert (const std::vector<const_TokenPtr> &tokens)\n \tcase INT_LITERAL:\n \t  dispatch_integer_literals (trees.back (), token);\n \t  break;\n-\t// FIXME: Why does BYTE_CHAR_LITERAL is not handled by rustc ?\n-\tcase CHAR_LITERAL: // TODO: UTF-8 handling\n+\tcase CHAR_LITERAL:\n \t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t    ProcMacro::Literal::make_char (token->as_string ()[0])));\n+\t    ProcMacro::Literal::make_literal (ProcMacro::LitKind::make_char (),\n+\t\t\t\t\t      token->as_string ())));\n \t  break;\n \tcase STRING_LITERAL:\n \t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t    ProcMacro::Literal::make_string (token->as_string ())));\n+\t    ProcMacro::Literal::make_literal (ProcMacro::LitKind::make_str (),\n+\t\t\t\t\t      token->as_string ())));\n \t  break;\n-\t  case BYTE_STRING_LITERAL: {\n-\t    auto str = token->as_string ();\n-\t    std::vector<uint8_t> data (str.begin (), str.end ());\n-\t    trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n-\t      ProcMacro::Literal::make_byte_string (data)));\n-\t  }\n+\tcase BYTE_CHAR_LITERAL:\n+\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t    ProcMacro::Literal::make_literal (ProcMacro::LitKind::make_byte (),\n+\t\t\t\t\t      token->as_string ())));\n+\t  break;\n+\tcase BYTE_STRING_LITERAL:\n+\t  trees.back ().push (ProcMacro::TokenTree::make_tokentree (\n+\t    ProcMacro::Literal::make_literal (\n+\t      ProcMacro::LitKind::make_byte_str (), token->as_string ())));\n \t  break;\n \t// Ident\n \tcase IDENTIFIER:\n@@ -321,91 +275,6 @@ from_ident (const ProcMacro::Ident &ident, std::vector<const_TokenPtr> &result)\n   result.push_back (lexer.peek_token ());\n }\n \n-static void\n-string_literal (const ProcMacro::StringPayload &payload,\n-\t\tstd::vector<const_TokenPtr> &result)\n-{\n-  // TODO: UTF-8 string\n-  result.push_back (Token::make_string (\n-    Location (),\n-    std::string (reinterpret_cast<const char *> (payload.data), payload.len)));\n-}\n-\n-static void\n-byte_string_literal (const ProcMacro::ByteStringPayload &payload,\n-\t\t     std::vector<const_TokenPtr> &result)\n-{\n-  result.push_back (Token::make_byte_string (\n-    Location (),\n-    std::string (reinterpret_cast<const char *> (payload.data), payload.size)));\n-}\n-\n-static void\n-unsigned_literal (const ProcMacro::Unsigned &lit,\n-\t\t  std::vector<const_TokenPtr> &result)\n-{\n-  switch (lit.tag)\n-    {\n-    case ProcMacro::UNSIGNED_8:\n-      result.push_back (Token::make_int (Location (),\n-\t\t\t\t\t std::to_string (lit.payload.unsigned8),\n-\t\t\t\t\t CORETYPE_U8));\n-      break;\n-    case ProcMacro::UNSIGNED_16:\n-      result.push_back (\n-\tToken::make_int (Location (), std::to_string (lit.payload.unsigned16),\n-\t\t\t CORETYPE_U16));\n-      break;\n-    case ProcMacro::UNSIGNED_32:\n-      result.push_back (\n-\tToken::make_int (Location (), std::to_string (lit.payload.unsigned32),\n-\t\t\t CORETYPE_U32));\n-      break;\n-    case ProcMacro::UNSIGNED_64:\n-      result.push_back (\n-\tToken::make_int (Location (), std::to_string (lit.payload.unsigned64),\n-\t\t\t CORETYPE_U64));\n-      break;\n-    case ProcMacro::UNSIGNED_128:\n-      // TODO: Handle 128 bits\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-static void\n-signed_literal (const ProcMacro::Signed &lit,\n-\t\tstd::vector<const_TokenPtr> &result)\n-{\n-  switch (lit.tag)\n-    {\n-    case ProcMacro::SIGNED_8:\n-      result.push_back (Token::make_int (Location (),\n-\t\t\t\t\t std::to_string (lit.payload.signed8),\n-\t\t\t\t\t CORETYPE_I8));\n-      break;\n-    case ProcMacro::SIGNED_16:\n-      result.push_back (Token::make_int (Location (),\n-\t\t\t\t\t std::to_string (lit.payload.signed16),\n-\t\t\t\t\t CORETYPE_I16));\n-      break;\n-    case ProcMacro::SIGNED_32:\n-      result.push_back (Token::make_int (Location (),\n-\t\t\t\t\t std::to_string (lit.payload.signed32),\n-\t\t\t\t\t CORETYPE_I32));\n-      break;\n-    case ProcMacro::SIGNED_64:\n-      result.push_back (Token::make_int (Location (),\n-\t\t\t\t\t std::to_string (lit.payload.signed64),\n-\t\t\t\t\t CORETYPE_I64));\n-      break;\n-    case ProcMacro::SIGNED_128:\n-      // TODO: Handle 128 bits\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /**\n  * Append the token corresponding to a given Literal to a vector.\n  *\n@@ -416,46 +285,39 @@ static void\n from_literal (const ProcMacro::Literal &literal,\n \t      std::vector<const_TokenPtr> &result)\n {\n-  switch (literal.tag)\n+  auto lookup = suffixes.lookup (literal.suffix.to_string ());\n+  auto suffix\n+    = suffixes.is_iter_ok (lookup) ? lookup->second : CORETYPE_UNKNOWN;\n+  // FIXME: Add spans instead of empty locations\n+  switch (literal.kind.tag)\n     {\n-    case ProcMacro::STRING:\n-      string_literal (literal.payload.string_payload, result);\n-      break;\n-    case ProcMacro::BYTE_STRING:\n-      byte_string_literal (literal.payload.byte_string_payload, result);\n+    case ProcMacro::BYTE:\n+      result.push_back (\n+\tToken::make_byte_char (Location (), literal.text.to_string ()[0]));\n       break;\n     case ProcMacro::CHAR:\n       result.push_back (\n-\tToken::make_char (Location (), literal.payload.char_payload));\n+\tToken::make_char (Location (), literal.text.to_string ()[0]));\n       break;\n-    case ProcMacro::UNSIGNED:\n-      unsigned_literal (literal.payload.unsigned_payload.value, result);\n-      break;\n-    case ProcMacro::SIGNED:\n-      signed_literal (literal.payload.signed_payload.value, result);\n-      break;\n-    case ProcMacro::USIZE:\n+    case ProcMacro::INTEGER:\n       result.push_back (\n-\tToken::make_int (Location (),\n-\t\t\t std::to_string (literal.payload.usize_payload.value),\n-\t\t\t CORETYPE_USIZE));\n+\tToken::make_int (Location (), literal.text.to_string (), suffix));\n       break;\n-    case ProcMacro::ISIZE:\n+    case ProcMacro::FLOAT:\n       result.push_back (\n-\tToken::make_int (Location (),\n-\t\t\t std::to_string (literal.payload.isize_payload.value),\n-\t\t\t CORETYPE_ISIZE));\n+\tToken::make_float (Location (), literal.text.to_string (), suffix));\n       break;\n-    case ProcMacro::FLOAT32:\n-      result.push_back (Token::make_float (\n-\tLocation (), std::to_string (literal.payload.float32_payload.value),\n-\tCORETYPE_F32));\n+    case ProcMacro::STR:\n+      result.push_back (\n+\tToken::make_string (Location (), literal.text.to_string ()));\n       break;\n-    case ProcMacro::FLOAT64:\n-      result.push_back (Token::make_float (\n-\tLocation (), std::to_string (literal.payload.float64_payload.value),\n-\tCORETYPE_F64));\n+    case ProcMacro::BYTE_STR:\n+      result.push_back (\n+\tToken::make_byte_string (Location (), literal.text.to_string ()));\n       break;\n+    // FIXME: Handle raw string\n+    case ProcMacro::STR_RAW:\n+    case ProcMacro::BYTE_STR_RAW:\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "5ad262f62bd0a1b718db633ba76b632a566666b0", "filename": "libgrust/libproc_macro/Makefile.am", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2FMakefile.am?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -53,7 +53,14 @@ LIBOBJS = @LIBOBJS@\n objext = @OBJEXT@\n \n REQUIRED_OFILES =\t\t\t\t\t\t\t\\\n-\t./proc_macro.$(objext) ./literal.$(objext) ./group.$(objext) ./ident.$(objext) ./punct.$(objext) ./tokenstream.$(objext) ./tokentree.$(objext)\n+\t./proc_macro.$(objext) \\\n+\t./literal.$(objext) \\\n+\t./group.$(objext) \\\n+\t./ident.$(objext) \\\n+\t./punct.$(objext) \\\n+\t./tokenstream.$(objext) \\\n+\t./tokentree.$(objext) \\\n+\t./ffistring.$(objext)\n \n all: $(TARGETLIB)\n "}, {"sha": "2dd0d9ea768a3f1e20c7067439ed4e0aea390953", "filename": "libgrust/libproc_macro/Makefile.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2FMakefile.in?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -306,7 +306,14 @@ AM_MAKEFLAGS = \\\n TARGETLIB = ./libproc_macro.a\n objext = @OBJEXT@\n REQUIRED_OFILES = \\\n-\t./proc_macro.$(objext) ./literal.$(objext) ./group.$(objext) ./ident.$(objext) ./punct.$(objext) ./tokenstream.$(objext) ./tokentree.$(objext)\n+\t./proc_macro.$(objext) \\\n+\t./literal.$(objext) \\\n+\t./group.$(objext) \\\n+\t./ident.$(objext) \\\n+\t./punct.$(objext) \\\n+\t./tokenstream.$(objext) \\\n+\t./tokentree.$(objext) \\\n+\t./ffistring.$(objext)\n \n all: all-am\n "}, {"sha": "1623bc9899e21ca498ac0c28f407682208c8c799", "filename": "libgrust/libproc_macro/ffistring.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fffistring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fffistring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Fffistring.cc?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2023 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU Proc Macro Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <cstring>\n+#include \"ffistring.h\"\n+\n+namespace ProcMacro {\n+void\n+FFIString::drop (FFIString *str)\n+{\n+  delete[] str->data;\n+  str->len = 0;\n+}\n+\n+FFIString\n+FFIString::make_ffistring (const std::string &str)\n+{\n+  return make_ffistring (reinterpret_cast<const unsigned char *> (str.c_str ()),\n+\t\t\t str.length ());\n+}\n+\n+FFIString\n+FFIString::make_ffistring (const unsigned char *data, std::uint64_t len)\n+{\n+  const unsigned char *inner = new unsigned char[len];\n+  return {inner, len};\n+}\n+\n+FFIString\n+FFIString::clone () const\n+{\n+  unsigned char *inner = new unsigned char[this->len];\n+  std::memcpy (inner, this->data, this->len);\n+  return {inner, this->len};\n+}\n+\n+std::string\n+FFIString::to_string () const\n+{\n+  return std::string (reinterpret_cast<const char *> (this->data), this->len);\n+}\n+\n+} // namespace ProcMacro"}, {"sha": "c151645ee5fcd7362ae7c326018478b8d41e55c4", "filename": "libgrust/libproc_macro/ffistring.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fffistring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fffistring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Fffistring.h?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2023 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU Proc Macro Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef FFISTRING_H\n+#define FFISTRING_H\n+\n+#include <cstdint>\n+#include <string>\n+\n+namespace ProcMacro {\n+\n+struct FFIString\n+{\n+  const unsigned char *data;\n+  std::uint64_t len;\n+\n+public:\n+  FFIString clone () const;\n+  std::string to_string () const;\n+  static FFIString make_ffistring (const std::string &str);\n+  static FFIString make_ffistring (const unsigned char *data,\n+\t\t\t\t   std::uint64_t len);\n+  static void drop (FFIString *str);\n+};\n+\n+extern \"C\" {\n+FFIString\n+FFIString__new (const unsigned char *data, std::uint64_t len);\n+\n+void\n+FFIString__drop (FFIString *str);\n+}\n+\n+} // namespace ProcMacro\n+\n+#endif /* ! FFISTRING_H */"}, {"sha": "e3d171f72681582a557783f10bde1fda37929496", "filename": "libgrust/libproc_macro/literal.cc", "status": "modified", "additions": 116, "deletions": 166, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fliteral.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fliteral.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Fliteral.cc?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -26,266 +26,216 @@\n \n namespace ProcMacro {\n \n-void\n-Literal::drop (Literal *lit)\n-{\n-  switch (lit->tag)\n-    {\n-    case STRING:\n-      delete[] lit->payload.string_payload.data;\n-      lit->payload.string_payload.len = 0;\n-      break;\n-    case BYTE_STRING:\n-      delete[] lit->payload.byte_string_payload.data;\n-      lit->payload.byte_string_payload.size = 0;\n-      break;\n-    case CHAR:\n-    case UNSIGNED:\n-    case SIGNED:\n-    case USIZE:\n-    case ISIZE:\n-    case FLOAT32:\n-    case FLOAT64:\n-      break;\n-    }\n-}\n-\n extern \"C\" {\n-\n-void\n-Literal__drop (Literal *lit)\n-{\n-  Literal::drop (lit);\n-}\n-\n-Literal\n-Literal__string (const unsigned char *str, std::uint64_t len)\n-{\n-  return Literal::make_string (str, len);\n-}\n-\n-Literal\n-Literal__byte_string (const std::uint8_t *bytes, std::uint64_t len)\n-{\n-  return Literal::make_byte_string (bytes, len);\n-}\n-\n bool\n Literal__from_string (const unsigned char *str, std::uint64_t len, Literal *lit)\n {\n-  // FIXME: implement this function with parser\n+  // FIXME: implement this function with lexer\n   std::abort ();\n   return false;\n }\n }\n \n-Literal\n-Literal::make_unsigned (UnsignedSuffixPayload p)\n+void\n+Literal::drop (Literal *lit)\n {\n-  LiteralPayload payload;\n-  payload.unsigned_payload = p;\n-  return {UNSIGNED, payload};\n+  FFIString::drop (&lit->text);\n+  FFIString::drop (&lit->suffix);\n }\n \n Literal\n-Literal::make_signed (SignedSuffixPayload p)\n+Literal::clone () const\n {\n-  LiteralPayload payload;\n-  payload.signed_payload = p;\n-  return {SIGNED, payload};\n+  return {this->kind, this->text.clone (), this->has_suffix,\n+\t  this->suffix.clone ()};\n }\n \n Literal\n-Literal::clone () const\n+Literal::make_literal (LitKind kind, const std::string &text,\n+\t\t       const std::string &suffix)\n {\n-  Literal lit = *this;\n-  switch (this->tag)\n-    {\n-    case STRING:\n-      lit.payload.string_payload.data\n-\t= new unsigned char[lit.payload.string_payload.len];\n-      std::memcpy (lit.payload.string_payload.data,\n-\t\t   this->payload.string_payload.data,\n-\t\t   lit.payload.string_payload.len);\n-      break;\n-    case BYTE_STRING:\n-      lit.payload.byte_string_payload.data\n-\t= new uint8_t[lit.payload.byte_string_payload.size];\n-      std::memcpy (lit.payload.byte_string_payload.data,\n-\t\t   this->payload.byte_string_payload.data,\n-\t\t   lit.payload.byte_string_payload.size);\n-      break;\n-    default:\n-      break;\n-    }\n-  return lit;\n+  auto ffi_text = FFIString::make_ffistring (text);\n+  auto ffi_suffix = FFIString::make_ffistring (suffix);\n+  return {kind, ffi_text, suffix != \"\", ffi_suffix};\n }\n \n Literal\n Literal::make_u8 (std::uint8_t value, bool suffixed)\n {\n-  UnsignedPayload unsigned_payload;\n-  unsigned_payload.unsigned8 = value;\n-  Unsigned val{UNSIGNED_8, unsigned_payload};\n-  UnsignedSuffixPayload payload{val, suffixed};\n-\n-  return make_unsigned (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"u8\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_u16 (std::uint16_t value, bool suffixed)\n {\n-  UnsignedPayload unsigned_payload;\n-  unsigned_payload.unsigned16 = value;\n-  Unsigned val{UNSIGNED_16, unsigned_payload};\n-  UnsignedSuffixPayload payload{val, suffixed};\n-\n-  return make_unsigned (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"u16\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_u32 (std::uint32_t value, bool suffixed)\n {\n-  UnsignedPayload unsigned_payload;\n-  unsigned_payload.unsigned32 = value;\n-  Unsigned val{UNSIGNED_32, unsigned_payload};\n-  UnsignedSuffixPayload payload{val, suffixed};\n-\n-  return make_unsigned (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"u32\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_u64 (std::uint64_t value, bool suffixed)\n {\n-  UnsignedPayload unsigned_payload;\n-  unsigned_payload.unsigned64 = value;\n-  Unsigned val{UNSIGNED_64, unsigned_payload};\n-  UnsignedSuffixPayload payload{val, suffixed};\n-\n-  return make_unsigned (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"u64\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_i8 (std::int8_t value, bool suffixed)\n {\n-  SignedPayload signed_payload;\n-  signed_payload.signed8 = value;\n-  Signed val{SIGNED_8, signed_payload};\n-  SignedSuffixPayload payload{val, suffixed};\n-\n-  return make_signed (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"i8\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_i16 (std::int16_t value, bool suffixed)\n {\n-  SignedPayload signed_payload;\n-  signed_payload.signed16 = value;\n-  Signed val{SIGNED_16, signed_payload};\n-  SignedSuffixPayload payload{val, suffixed};\n-\n-  return make_signed (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"i16\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_i32 (std::int32_t value, bool suffixed)\n {\n-  SignedPayload signed_payload;\n-  signed_payload.signed32 = value;\n-  Signed val{SIGNED_32, signed_payload};\n-  SignedSuffixPayload payload = {val, suffixed};\n-\n-  return make_signed (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"i32\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_i64 (std::int64_t value, bool suffixed)\n {\n-  SignedPayload signed_payload;\n-  signed_payload.signed64 = value;\n-  Signed val{SIGNED_64, signed_payload};\n-  SignedSuffixPayload payload{val, suffixed};\n-\n-  return make_signed (payload);\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"i64\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n Literal::make_string (const std::string &str)\n {\n-  return make_string (reinterpret_cast<const unsigned char *> (str.c_str ()),\n-\t\t      str.length ());\n+  auto text = FFIString::make_ffistring (str);\n+  auto suffix = FFIString::make_ffistring (\"\");\n+  return {LitKind::make_str (), text, false, suffix};\n }\n \n Literal\n-Literal::make_string (const unsigned char *str, std::uint64_t len)\n+Literal::make_byte_string (const std::vector<std::uint8_t> &vec)\n {\n-  unsigned char *data = new unsigned char[len];\n-  StringPayload str_payload = {data, len};\n-  std::memcpy (data, str, len);\n-  LiteralPayload payload;\n-  payload.string_payload = str_payload;\n-  return {STRING, payload};\n+  auto text\n+    = FFIString::make_ffistring (std::string (vec.cbegin (), vec.cend ()));\n+  auto suffix = FFIString::make_ffistring (\"\");\n+  return {LitKind::make_byte_str (), text, false, suffix};\n }\n \n Literal\n-Literal::make_byte_string (const std::vector<std::uint8_t> &vec)\n+Literal::make_f32 (float value, bool suffixed)\n {\n-  return make_byte_string (vec.data (), vec.size ());\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"f32\" : \"\");\n+  return {LitKind::make_float (), text, suffixed, suffix};\n }\n \n Literal\n-Literal::make_byte_string (const std::uint8_t *bytes, std::uint64_t len)\n+Literal::make_f64 (double value, bool suffixed)\n {\n-  std::uint8_t *data = new std::uint8_t[len];\n-  ByteStringPayload bstr_payload = {data, len};\n-  std::memcpy (data, bytes, len);\n-  LiteralPayload payload;\n-  payload.byte_string_payload = bstr_payload;\n-  return {BYTE_STRING, payload};\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"f64\" : \"\");\n+  return {LitKind::make_float (), text, suffixed, suffix};\n }\n \n Literal\n-Literal::make_f32 (float value, bool suffixed)\n+Literal::make_char (std::uint32_t ch)\n {\n-  Float32Payload f{value, suffixed};\n-  LiteralPayload payload;\n-  payload.float32_payload = f;\n-  return {FLOAT32, payload};\n+  auto text = FFIString::make_ffistring (std::to_string ((char) ch));\n+  auto suffix = FFIString::make_ffistring (\"\");\n+  return {LitKind::make_char (), text, false, suffix};\n }\n \n Literal\n-Literal::make_f64 (double value, bool suffixed)\n+Literal::make_usize (std::uint64_t value, bool suffixed)\n {\n-  Float64Payload f{value, suffixed};\n-  LiteralPayload payload;\n-  payload.float64_payload = f;\n-  return {FLOAT64, payload};\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"usize\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n }\n \n Literal\n-Literal::make_char (std::uint32_t ch)\n+Literal::make_isize (std::int64_t value, bool suffixed)\n+{\n+  auto text = FFIString::make_ffistring (std::to_string (value));\n+  auto suffix = FFIString::make_ffistring (suffixed ? \"isize\" : \"\");\n+  return {LitKind::make_integer (), text, suffixed, suffix};\n+}\n+\n+LitKind\n+LitKind::make_byte ()\n {\n-  LiteralPayload payload;\n-  payload.char_payload = ch;\n+  LitKindPayload payload;\n+  return {BYTE, payload};\n+}\n+\n+LitKind\n+LitKind::make_char ()\n+{\n+  LitKindPayload payload;\n   return {CHAR, payload};\n }\n \n-Literal\n-Literal::make_usize (std::uint64_t value, bool suffixed)\n+LitKind\n+LitKind::make_integer ()\n {\n-  UsizePayload p{value, suffixed};\n-  LiteralPayload payload;\n-  payload.usize_payload = p;\n-  return {USIZE, payload};\n+  LitKindPayload payload;\n+  return {INTEGER, payload};\n }\n \n-Literal\n-Literal::make_isize (std::int64_t value, bool suffixed)\n+LitKind\n+LitKind::make_float ()\n+{\n+  LitKindPayload payload;\n+  return {FLOAT, payload};\n+}\n+\n+LitKind\n+LitKind::make_str ()\n+{\n+  LitKindPayload payload;\n+  return {STR, payload};\n+}\n+\n+LitKind\n+LitKind::make_str_raw (std::uint8_t val)\n+{\n+  LitKindPayload payload;\n+  payload.str_raw = val;\n+  return {STR_RAW, payload};\n+}\n+\n+LitKind\n+LitKind::make_byte_str ()\n+{\n+  LitKindPayload payload;\n+  return {BYTE_STR, payload};\n+}\n+\n+LitKind\n+LitKind::make_byte_str_raw (std::uint8_t val)\n {\n-  IsizePayload p{value, suffixed};\n-  LiteralPayload payload;\n-  payload.isize_payload = p;\n-  return {ISIZE, payload};\n+  LitKindPayload payload;\n+  payload.byte_str_raw = val;\n+  return {BYTE_STR_RAW, payload};\n }\n \n } // namespace ProcMacro"}, {"sha": "fa2df3f62ea060ec47d0c767992105e47b98d070", "filename": "libgrust/libproc_macro/literal.h", "status": "modified", "additions": 42, "deletions": 143, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fliteral.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c34885a5afbda4bad5873668cdc6fddd2d1c29b/libgrust%2Flibproc_macro%2Fliteral.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgrust%2Flibproc_macro%2Fliteral.h?ref=4c34885a5afbda4bad5873668cdc6fddd2d1c29b", "patch": "@@ -26,183 +26,82 @@\n #include <cstdint>\n #include <string>\n #include <vector>\n+#include \"ffistring.h\"\n \n namespace ProcMacro {\n-enum UnsignedTag\n-{\n-  UNSIGNED_8,\n-  UNSIGNED_16,\n-  UNSIGNED_32,\n-  UNSIGNED_64,\n-  UNSIGNED_128\n-};\n-\n-struct Payload128\n-{\n-  std::uint64_t low;\n-  std::uint64_t high;\n-};\n-\n-union UnsignedPayload\n-{\n-  std::uint8_t unsigned8;\n-  std::uint16_t unsigned16;\n-  std::uint32_t unsigned32;\n-  std::uint64_t unsigned64;\n-  Payload128 unsigned128;\n-};\n-\n-struct Unsigned\n-{\n-  UnsignedTag tag;\n-  UnsignedPayload payload;\n-};\n-\n-enum SignedTag\n-{\n-  SIGNED_8,\n-  SIGNED_16,\n-  SIGNED_32,\n-  SIGNED_64,\n-  SIGNED_128\n-};\n-\n-union SignedPayload\n-{\n-  std::int8_t signed8;\n-  std::int16_t signed16;\n-  std::int32_t signed32;\n-  std::int64_t signed64;\n-};\n-\n-struct Signed\n-{\n-  SignedTag tag;\n-  SignedPayload payload;\n-};\n \n-enum LiteralTag\n+enum LitKindTag\n {\n-  STRING,\n-  BYTE_STRING,\n+  BYTE,\n   CHAR,\n-  UNSIGNED,\n-  SIGNED,\n-  USIZE,\n-  ISIZE,\n-  FLOAT32,\n-  FLOAT64\n-};\n-\n-struct StringPayload\n-{\n-  unsigned char *data;\n-  std::uint64_t len;\n+  INTEGER,\n+  FLOAT,\n+  STR,\n+  STR_RAW,\n+  BYTE_STR,\n+  BYTE_STR_RAW,\n };\n \n-struct ByteStringPayload\n+union LitKindPayload\n {\n-  std::uint8_t *data;\n-  std::uint64_t size;\n+  std::uint8_t str_raw;\n+  std::uint8_t byte_str_raw;\n };\n \n-struct UnsignedSuffixPayload\n+struct LitKind\n {\n-  Unsigned value;\n-  bool suffix;\n-};\n+  LitKindTag tag;\n+  LitKindPayload payload;\n \n-struct SignedSuffixPayload\n-{\n-  Signed value;\n-  bool suffix;\n-};\n-\n-struct UsizePayload\n-{\n-  std::uint64_t value;\n-  bool suffix;\n-};\n-\n-struct IsizePayload\n-{\n-  std::int64_t value;\n-  bool suffix;\n-};\n-\n-struct Float32Payload\n-{\n-  float value;\n-  bool suffix;\n-};\n-\n-struct Float64Payload\n-{\n-  double value;\n-  bool suffix;\n-};\n-\n-union LiteralPayload\n-{\n-  StringPayload string_payload;\n-  ByteStringPayload byte_string_payload;\n-  std::uint32_t char_payload;\n-  UnsignedSuffixPayload unsigned_payload;\n-  SignedSuffixPayload signed_payload;\n-  UsizePayload usize_payload;\n-  IsizePayload isize_payload;\n-  Float32Payload float32_payload;\n-  Float64Payload float64_payload;\n+private:\n+public:\n+  static LitKind make_byte ();\n+  static LitKind make_char ();\n+  static LitKind make_integer ();\n+  static LitKind make_float ();\n+  static LitKind make_str ();\n+  static LitKind make_str_raw (std::uint8_t val);\n+  static LitKind make_byte_str ();\n+  static LitKind make_byte_str_raw (std::uint8_t val);\n };\n \n struct Literal\n {\n-  LiteralTag tag;\n-  LiteralPayload payload;\n+  LitKind kind;\n+  FFIString text;\n+  bool has_suffix;\n+  FFIString suffix;\n+  // TODO: Add span once done in rust interface\n \n public:\n   Literal clone () const;\n \n-  static Literal make_u8 (std::uint8_t value, bool suffixed = false);\n-  static Literal make_u16 (std::uint16_t value, bool suffixed = false);\n-  static Literal make_u32 (std::uint32_t value, bool suffixed = false);\n-  static Literal make_u64 (std::uint64_t value, bool suffixed = false);\n+  static Literal make_literal (const LitKind kind, const std::string &text,\n+\t\t\t       const std::string &suffix = \"\");\n+  static Literal make_u8 (std::uint8_t value, bool suffixed = true);\n+  static Literal make_u16 (std::uint16_t value, bool suffixed = true);\n+  static Literal make_u32 (std::uint32_t value, bool suffixed = true);\n+  static Literal make_u64 (std::uint64_t value, bool suffixed = true);\n \n-  static Literal make_i8 (std::int8_t value, bool suffixed = false);\n-  static Literal make_i16 (std::int16_t value, bool suffixed = false);\n-  static Literal make_i32 (std::int32_t value, bool suffixed = false);\n-  static Literal make_i64 (std::int64_t value, bool suffixed = false);\n+  static Literal make_i8 (std::int8_t value, bool suffixed = true);\n+  static Literal make_i16 (std::int16_t value, bool suffixed = true);\n+  static Literal make_i32 (std::int32_t value, bool suffixed = true);\n+  static Literal make_i64 (std::int64_t value, bool suffixed = true);\n \n   static Literal make_string (const std::string &str);\n-  static Literal make_string (const unsigned char *str, std::uint64_t len);\n   static Literal make_byte_string (const std::vector<std::uint8_t> &vec);\n-  static Literal make_byte_string (const std::uint8_t *bytes,\n-\t\t\t\t   std::uint64_t len);\n \n   static Literal make_f32 (float value, bool suffixed = false);\n   static Literal make_f64 (double value, bool suffixed = false);\n \n   static Literal make_char (std::uint32_t ch);\n-  static Literal make_usize (std::uint64_t value, bool suffixed = false);\n-  static Literal make_isize (std::int64_t value, bool suffixed = false);\n+  static Literal make_usize (std::uint64_t value, bool suffixed = true);\n+  static Literal make_isize (std::int64_t value, bool suffixed = true);\n \n   static void drop (Literal *lit);\n-\n-private:\n-  static Literal make_unsigned (UnsignedSuffixPayload p);\n-  static Literal make_signed (SignedSuffixPayload p);\n };\n \n extern \"C\" {\n-void\n-Literal__drop (Literal *lit);\n-\n-Literal\n-Literal__string (const unsigned char *str, std::uint64_t len);\n-\n-Literal\n-Literal__byte_string (const std::uint8_t *bytes, std::uint64_t len);\n-\n bool\n Literal__from_string (const unsigned char *str, std::uint64_t len,\n \t\t      Literal *lit);"}]}