{"sha": "08aead780e6afcf0c3320d5dc6d27b60b956e4a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhhZWFkNzgwZTZhZmNmMGMzMzIwZDVkYzZkMjdiNjBiOTU2ZTRhOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-08-14T10:18:15Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-08-14T10:18:15Z"}, "message": "cvt.c (warn_ref_binding): New static function, broken out of ...\n\n\t* cvt.c (warn_ref_binding): New static function, broken out of ...\n\t(convert_to_reference): ... here. Use it.\n\nFrom-SVN: r35672", "tree": {"sha": "6feaa3b7b25d9455d0572f9103f490b7b54163e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6feaa3b7b25d9455d0572f9103f490b7b54163e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08aead780e6afcf0c3320d5dc6d27b60b956e4a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08aead780e6afcf0c3320d5dc6d27b60b956e4a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08aead780e6afcf0c3320d5dc6d27b60b956e4a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08aead780e6afcf0c3320d5dc6d27b60b956e4a9/comments", "author": null, "committer": null, "parents": [{"sha": "08498793c05b98ae3cb165a6ecde53c788bd8157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08498793c05b98ae3cb165a6ecde53c788bd8157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08498793c05b98ae3cb165a6ecde53c788bd8157"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "4432554cf122a1d468b68bf1c2d43cde78e7e7bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08aead780e6afcf0c3320d5dc6d27b60b956e4a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08aead780e6afcf0c3320d5dc6d27b60b956e4a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=08aead780e6afcf0c3320d5dc6d27b60b956e4a9", "patch": "@@ -1,3 +1,8 @@\n+2000-08-14  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cvt.c (warn_ref_binding): New static function, broken out of ...\n+\t(convert_to_reference): ... here. Use it.\t\n+\n 2000-08-11  Kriang Lerdsuwanakij <lerdsuwa@scf-fs.usc.edu>\n \n \t* parse.y (template_arg): Add rule for template qualified with"}, {"sha": "977571d0f68d366e10d04869715448578dc29825", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08aead780e6afcf0c3320d5dc6d27b60b956e4a9/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08aead780e6afcf0c3320d5dc6d27b60b956e4a9/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=08aead780e6afcf0c3320d5dc6d27b60b956e4a9", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02111-1307, USA.  */\n static tree cp_convert_to_pointer PARAMS ((tree, tree));\n static tree convert_to_pointer_force PARAMS ((tree, tree));\n static tree build_up_reference PARAMS ((tree, tree, int));\n+static void warn_ref_binding PARAMS ((tree, tree, tree));\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -410,6 +411,37 @@ build_up_reference (type, arg, flags)\n   return rval;\n }\n \n+/* Subroutine of convert_to_reference. REFTYPE is the target reference type.\n+   INTYPE is the original rvalue type and DECL is an optional _DECL node\n+   for diagnostics.\n+   \n+   [dcl.init.ref] says that if an rvalue is used to\n+   initialize a reference, then the reference must be to a\n+   non-volatile const type.  */\n+\n+static void\n+warn_ref_binding (reftype, intype, decl)\n+     tree reftype, intype, decl;\n+{\n+  tree ttl = TREE_TYPE (reftype);\n+  \n+  if (!CP_TYPE_CONST_NON_VOLATILE_P (ttl))\n+    {\n+      const char *msg;\n+\n+      if (CP_TYPE_VOLATILE_P (ttl) && decl)\n+\t  msg = \"initialization of volatile reference type `%#T' from rvalue of type `%T'\";\n+      else if (CP_TYPE_VOLATILE_P (ttl))\n+\t  msg = \"conversion to volatile reference type `%#T' from rvalue of type `%T'\";\n+      else if (decl)\n+\t  msg = \"initialization of non-const reference type `%#T' from rvalue of type `%T'\";\n+      else\n+\t  msg = \"conversion to non-const reference type `%#T' from rvalue of type `%T'\";\n+\n+      cp_pedwarn (msg, reftype, intype);\n+    }\n+}\n+\n /* For C++: Only need to do one-level references, but cannot\n    get tripped up on signed/unsigned differences.\n \n@@ -472,27 +504,10 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  tree ttl = TREE_TYPE (reftype);\n \t  tree ttr = lvalue_type (expr);\n \n-\t  /* [dcl.init.ref] says that if an rvalue is used to\n-\t     initialize a reference, then the reference must be to a\n-\t     non-volatile const type.  */\n-\t  if (! real_lvalue_p (expr)\n-\t      && !CP_TYPE_CONST_NON_VOLATILE_P (ttl))\n-\t    {\n-\t      const char *msg;\n-\n-\t      if (CP_TYPE_VOLATILE_P (ttl) && decl)\n-\t\tmsg = \"initialization of volatile reference type `%#T'\";\n-\t      else if (CP_TYPE_VOLATILE_P (ttl))\n-\t\tmsg = \"conversion to volatile reference type `%#T'\";\n-\t      else if (decl)\n-\t\tmsg = \"initialization of non-const reference type `%#T'\";\n-\t      else\n-\t\tmsg = \"conversion to non-const reference type `%#T'\";\n-\n-\t      cp_pedwarn (msg, reftype);\n-\t      cp_pedwarn (\"from rvalue of type `%T'\", intype);\n-\t    }\n-\t  else if (! (convtype & CONV_CONST)\n+\t  if (! real_lvalue_p (expr))\n+\t    warn_ref_binding (reftype, intype, decl);\n+\t  \n+\t  if (! (convtype & CONV_CONST)\n \t\t   && !at_least_as_qualified_p (ttl, ttr))\n \t    cp_pedwarn (\"conversion from `%T' to `%T' discards qualifiers\",\n \t\t\tttr, reftype);\n@@ -528,11 +543,8 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t\t\t\t\t \"converting\", 0, 0);\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;\n+      warn_ref_binding (reftype, intype, decl);\n       rval = build_up_reference (reftype, rval, flags);\n-\n-      if (rval && ! CP_TYPE_CONST_P (TREE_TYPE (reftype)))\n-\tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n-\t\t    reftype, intype);\n     }\n \n   if (rval)"}]}