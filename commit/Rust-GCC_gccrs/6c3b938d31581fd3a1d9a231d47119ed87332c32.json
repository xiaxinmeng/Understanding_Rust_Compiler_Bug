{"sha": "6c3b938d31581fd3a1d9a231d47119ed87332c32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzYjkzOGQzMTU4MWZkM2ExZDlhMjMxZDQ3MTE5ZWQ4NzMzMmMzMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2009-02-21T16:48:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2009-02-21T16:48:05Z"}, "message": "Revert last change.\n\nFrom-SVN: r144357", "tree": {"sha": "44b6e7ab933166e7bdfac3579de3a52b544839ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44b6e7ab933166e7bdfac3579de3a52b544839ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c3b938d31581fd3a1d9a231d47119ed87332c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3b938d31581fd3a1d9a231d47119ed87332c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c3b938d31581fd3a1d9a231d47119ed87332c32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c3b938d31581fd3a1d9a231d47119ed87332c32/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c64d3ddec2b86cd3b0ecef3c377affbb87cc370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c64d3ddec2b86cd3b0ecef3c377affbb87cc370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c64d3ddec2b86cd3b0ecef3c377affbb87cc370"}], "stats": {"total": 78, "additions": 38, "deletions": 40}, "files": [{"sha": "8ea2b39bcbefa71e6e65311db936faee6fb4233e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3b938d31581fd3a1d9a231d47119ed87332c32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3b938d31581fd3a1d9a231d47119ed87332c32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c3b938d31581fd3a1d9a231d47119ed87332c32", "patch": "@@ -1,3 +1,8 @@\n+2009-02-21  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* loop-iv.c: Revert last change.\n+\t* emit-rtl.c: Likewise.\n+\n 2008-02-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/39256"}, {"sha": "679e95ea8a24eba266edb6d1c561ed98ebf9ad17", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3b938d31581fd3a1d9a231d47119ed87332c32/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3b938d31581fd3a1d9a231d47119ed87332c32/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6c3b938d31581fd3a1d9a231d47119ed87332c32", "patch": "@@ -1232,17 +1232,6 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n   /* Otherwise, we can't do this.  */\n   return 0;\n }\n-\n-/* Generates a subreg to get the least significant part of EXPR (in mode\n-   INNER_MODE) to OUTER_MODE.  */\n-\n-rtx\n-lowpart_subreg (enum machine_mode outer_mode, rtx expr,\n-\t\tenum machine_mode inner_mode)\n-{\n-  return simplify_gen_subreg (outer_mode, expr, inner_mode,\n-\t\t\t      subreg_lowpart_offset (outer_mode, inner_mode));\n-}\n \f\n rtx\n gen_highpart (enum machine_mode mode, rtx x)"}, {"sha": "9d844d8d90c45ad153177fe2aca8c36eeb04bef3", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c3b938d31581fd3a1d9a231d47119ed87332c32/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c3b938d31581fd3a1d9a231d47119ed87332c32/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=6c3b938d31581fd3a1d9a231d47119ed87332c32", "patch": "@@ -157,12 +157,15 @@ dump_iv_info (FILE *file, struct rtx_iv *iv)\n     fprintf (file, \" (first special)\");\n }\n \n-/* Truncate EXPR (which has mode EXPR_MODE) to MODE.  */\n+/* Generates a subreg to get the least significant part of EXPR (in mode\n+   INNER_MODE) to OUTER_MODE.  */\n \n-static rtx\n-truncate_value (enum machine_mode mode, rtx expr, enum machine_mode expr_mode)\n+rtx\n+lowpart_subreg (enum machine_mode outer_mode, rtx expr,\n+\t\tenum machine_mode inner_mode)\n {\n-  return simplify_gen_unary (TRUNCATE, mode, expr, expr_mode);\n+  return simplify_gen_subreg (outer_mode, expr, inner_mode,\n+\t\t\t      subreg_lowpart_offset (outer_mode, inner_mode));\n }\n \n static void \n@@ -405,7 +408,7 @@ iv_subreg (struct rtx_iv *iv, enum machine_mode mode)\n       && !iv->first_special)\n     {\n       rtx val = get_iv_value (iv, const0_rtx);\n-      val = truncate_value (mode, val, iv->extend_mode);\n+      val = lowpart_subreg (mode, val, iv->extend_mode);\n \n       iv->base = val;\n       iv->extend = UNKNOWN;\n@@ -1244,7 +1247,7 @@ get_iv_value (struct rtx_iv *iv, rtx iteration)\n   if (iv->extend_mode == iv->mode)\n     return val;\n \n-  val = truncate_value (iv->mode, val, iv->extend_mode);\n+  val = lowpart_subreg (iv->mode, val, iv->extend_mode);\n \n   if (iv->extend == UNKNOWN)\n     return val;\n@@ -2197,8 +2200,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   mode = iv0.mode;\n   size = GET_MODE_BITSIZE (mode);\n   get_mode_bounds (mode, (cond == LE || cond == LT), comp_mode, &mmin, &mmax);\n-  mode_mmin = truncate_value (mode, mmin, comp_mode);\n-  mode_mmax = truncate_value (mode, mmax, comp_mode);\n+  mode_mmin = lowpart_subreg (mode, mmin, comp_mode);\n+  mode_mmax = lowpart_subreg (mode, mmax, comp_mode);\n \n   if (GET_CODE (iv0.step) != CONST_INT || GET_CODE (iv1.step) != CONST_INT)\n     goto fail;\n@@ -2255,7 +2258,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t   difficult due to possibly infinite loops.  */\n \tif (iv0.step == const0_rtx)\n \t  {\n-\t    tmp = truncate_value (mode, iv0.base, comp_mode);\n+\t    tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n \t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp,\n \t\t\t\t\t\t  mode_mmax);\n \t    if (assumption == const_true_rtx)\n@@ -2265,7 +2268,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  }\n \telse\n \t  {\n-\t    tmp = truncate_value (mode, iv1.base, comp_mode);\n+\t    tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n \t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp,\n \t\t\t\t\t\t  mode_mmin);\n \t    if (assumption == const_true_rtx)\n@@ -2291,7 +2294,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n     {\n       if (iv0.step == const0_rtx)\n \t{\n-\t  tmp = truncate_value (mode, iv0.base, comp_mode);\n+\t  tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n \t  if (rtx_equal_p (tmp, mode_mmin))\n \t    {\n \t      desc->infinite =\n@@ -2302,7 +2305,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t}\n       else\n \t{\n-\t  tmp = truncate_value (mode, iv1.base, comp_mode);\n+\t  tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n \t  if (rtx_equal_p (tmp, mode_mmax))\n \t    {\n \t      desc->infinite =\n@@ -2326,7 +2329,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       else\n \tstep = iv0.step;\n       delta = simplify_gen_binary (MINUS, comp_mode, iv1.base, iv0.base);\n-      delta = truncate_value (mode, delta, comp_mode);\n+      delta = lowpart_subreg (mode, delta, comp_mode);\n       delta = simplify_gen_binary (UMOD, mode, delta, step);\n       may_xform = const0_rtx;\n       may_not_xform = const_true_rtx;\n@@ -2350,8 +2353,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    {\n \t      bound = simplify_gen_binary (PLUS, comp_mode, mmin, step);\n \t      bound = simplify_gen_binary (MINUS, comp_mode, bound, delta);\n-\t      bound = truncate_value (mode, bound, comp_mode);\n-\t      tmp = truncate_value (mode, iv0.base, comp_mode);\n+\t      bound = lowpart_subreg (mode, bound, comp_mode);\n+\t      tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n \t      may_xform = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\t   bound, tmp);\n \t      may_not_xform = simplify_gen_relational (reverse_condition (cond),\n@@ -2362,8 +2365,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    {\n \t      bound = simplify_gen_binary (MINUS, comp_mode, mmax, step);\n \t      bound = simplify_gen_binary (PLUS, comp_mode, bound, delta);\n-\t      bound = truncate_value (mode, bound, comp_mode);\n-\t      tmp = truncate_value (mode, iv1.base, comp_mode);\n+\t      bound = lowpart_subreg (mode, bound, comp_mode);\n+\t      tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n \t      may_xform = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\t   tmp, bound);\n \t      may_not_xform = simplify_gen_relational (reverse_condition (cond),\n@@ -2414,8 +2417,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t      iv1.base = simplify_gen_binary (PLUS, comp_mode, iv1.base, step);\n \t    }\n \n-\t  tmp0 = truncate_value (mode, iv0.base, comp_mode);\n-\t  tmp1 = truncate_value (mode, iv1.base, comp_mode);\n+\t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n+\t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n \t  assumption = simplify_gen_relational (reverse_condition (cond),\n \t\t\t\t\t\tSImode, mode, tmp0, tmp1);\n \t  if (assumption == const_true_rtx)\n@@ -2443,7 +2446,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  iv0.step = simplify_gen_unary (NEG, comp_mode, iv0.step, mode);\n \t  iv1.base = simplify_gen_unary (NEG, comp_mode, iv1.base, mode);\n \t}\n-      iv0.step = truncate_value (mode, iv0.step, comp_mode);\n+      iv0.step = lowpart_subreg (mode, iv0.step, comp_mode);\n \n       /* Let nsd (s, size of mode) = d.  If d does not divide c, the loop\n \t is infinite.  Otherwise, the number of iterations is\n@@ -2457,7 +2460,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t}\n       bound = GEN_INT (((unsigned HOST_WIDEST_INT) 1 << (size - 1 ) << 1) - 1);\n \n-      tmp1 = truncate_value (mode, iv1.base, comp_mode);\n+      tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n       tmp = simplify_gen_binary (UMOD, mode, tmp1, GEN_INT (d));\n       assumption = simplify_gen_relational (NE, SImode, mode, tmp, const0_rtx);\n       desc->infinite = alloc_EXPR_LIST (0, assumption, desc->infinite);\n@@ -2478,11 +2481,12 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t   but it was already taken into account during LE -> NE transform).  */\n \t{\n \t  step = iv0.step;\n-\t  tmp0 = truncate_value (mode, iv0.base, comp_mode);\n-\t  tmp1 = truncate_value (mode, iv1.base, comp_mode);\n+\t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n+\t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n \n \t  bound = simplify_gen_binary (MINUS, mode, mode_mmax,\n-\t\t\t\t       truncate_value (mode, step, comp_mode));\n+\t\t\t\t       lowpart_subreg (mode, step,\n+\t\t\t\t\t\t       comp_mode));\n \t  if (step_is_pow2)\n \t    {\n \t      rtx t0, t1;\n@@ -2509,7 +2513,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    }\n \n \t  tmp = simplify_gen_binary (PLUS, comp_mode, iv1.base, iv0.step);\n-\t  tmp = truncate_value (mode, tmp, comp_mode);\n+\t  tmp = lowpart_subreg (mode, tmp, comp_mode);\n \t  assumption = simplify_gen_relational (reverse_condition (cond),\n \t\t\t\t\t\tSImode, mode, tmp0, tmp);\n \n@@ -2522,11 +2526,11 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t     We must know that a - s does not overflow and a - s <= b and then\n \t     we can again compute number of iterations as (b - (a - s)) / s.  */\n \t  step = simplify_gen_unary (NEG, mode, iv1.step, mode);\n-\t  tmp0 = truncate_value (mode, iv0.base, comp_mode);\n-\t  tmp1 = truncate_value (mode, iv1.base, comp_mode);\n+\t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n+\t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n \n \t  bound = simplify_gen_binary (PLUS, mode, mode_mmin,\n-\t\t\t\t       truncate_value (mode, step, comp_mode));\n+\t\t\t\t       lowpart_subreg (mode, step, comp_mode));\n \t  if (step_is_pow2)\n \t    {\n \t      rtx t0, t1;\n@@ -2553,7 +2557,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    }\n \n \t  tmp = simplify_gen_binary (PLUS, comp_mode, iv0.base, iv1.step);\n-\t  tmp = truncate_value (mode, tmp, comp_mode);\n+\t  tmp = lowpart_subreg (mode, tmp, comp_mode);\n \t  assumption = simplify_gen_relational (reverse_condition (cond),\n \t\t\t\t\t\tSImode, mode,\n \t\t\t\t\t\ttmp, tmp1);"}]}