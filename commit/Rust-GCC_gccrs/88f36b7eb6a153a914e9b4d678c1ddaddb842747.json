{"sha": "88f36b7eb6a153a914e9b4d678c1ddaddb842747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmMzZiN2ViNmExNTNhOTE0ZTliNGQ2NzhjMWRkYWRkYjg0Mjc0Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-05-03T19:35:01Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-05-03T19:35:01Z"}, "message": "decl.c (maybe_pad_type): Try to get a form of the type with integral mode even if...\n\n\t* decl.c (maybe_pad_type): Try to get a form of the type with integral\n\tmode even if the alignment is not a factor of the original size.  But\n\tmake sure to create the inner field with the original size.  Reorder.\n\t* trans.c (addressable_p) <COMPONENT_REF>: Treat the field of a padding\n\trecord as always addressable.\n\t* utils.c (convert): Deal specially with conversions between original\n\tand packable versions of a record type.\n\t* utils2.c (build_binary_op) <MODIFY_EXPR>: Be more restrictive when\n\trecognizing an assignment between padded objects.\n\nFrom-SVN: r134916", "tree": {"sha": "8c9f10498aa285c5cda1ea869b4f8d07d9999b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c9f10498aa285c5cda1ea869b4f8d07d9999b77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88f36b7eb6a153a914e9b4d678c1ddaddb842747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f36b7eb6a153a914e9b4d678c1ddaddb842747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f36b7eb6a153a914e9b4d678c1ddaddb842747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f36b7eb6a153a914e9b4d678c1ddaddb842747/comments", "author": null, "committer": null, "parents": [{"sha": "093daf0fc7ddbde9214ae6cca049bb80fa7d65ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093daf0fc7ddbde9214ae6cca049bb80fa7d65ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093daf0fc7ddbde9214ae6cca049bb80fa7d65ab"}], "stats": {"total": 199, "additions": 123, "deletions": 76}, "files": [{"sha": "6da64b629731484cbfc4d68bbca383ffbd727a8a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -1,3 +1,15 @@\n+2008-05-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (maybe_pad_type): Try to get a form of the type with integral\n+\tmode even if the alignment is not a factor of the original size.  But\n+\tmake sure to create the inner field with the original size.  Reorder.\n+\t* trans.c (addressable_p) <COMPONENT_REF>: Treat the field of a padding\n+\trecord as always addressable.\n+\t* utils.c (convert): Deal specially with conversions between original\n+\tand packable versions of a record type.\n+\t* utils2.c (build_binary_op) <MODIFY_EXPR>: Be more restrictive when\n+\trecognizing an assignment between padded objects.\n+\n 2008-05-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* decl.c (make_packable_type): Resize the last component to its RM size"}, {"sha": "9d933b740d0785b7a40cbf0caa04e26f270a4737", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -5448,9 +5448,9 @@ make_packable_type (tree type, bool in_record)\n \n   new_type = make_node (TREE_CODE (type));\n \n-  /* Copy the name and flags from the old type to that of the new.  Note\n-     that we rely on the pointer equality created here for TYPE_NAME at\n-     the end of gnat_to_gnu.  */\n+  /* Copy the name and flags from the old type to that of the new.\n+     Note that we rely on the pointer equality created here for\n+     TYPE_NAME to look through conversions in various places.  */\n   TYPE_NAME (new_type) = TYPE_NAME (type);\n   TYPE_JUSTIFIED_MODULAR_P (new_type) = TYPE_JUSTIFIED_MODULAR_P (type);\n   TYPE_CONTAINS_TEMPLATE_P (new_type) = TYPE_CONTAINS_TEMPLATE_P (type);\n@@ -5576,7 +5576,7 @@ make_packable_type (tree type, bool in_record)\n    GNAT_ENTITY and NAME_TRAILER are used to name the resulting record and\n    to issue a warning.\n \n-   IS_USER_TYPE is true if we must be sure we complete the original type.\n+   IS_USER_TYPE is true if we must complete the original type.\n \n    DEFINITION is true if this type is being defined.\n \n@@ -5634,59 +5634,65 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (align == 0 && !size)\n     return type;\n \n+  /* If requested, complete the original type and give it a name.  */\n+  if (is_user_type)\n+    create_type_decl (get_entity_name (gnat_entity), type,\n+\t\t      NULL, !Comes_From_Source (gnat_entity),\n+\t\t      !(TYPE_NAME (type)\n+\t\t\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t\t\t&& DECL_IGNORED_P (TYPE_NAME (type))),\n+\t\t      gnat_entity);\n+\n   /* We used to modify the record in place in some cases, but that could\n      generate incorrect debugging information.  So make a new record\n      type and name.  */\n   record = make_node (RECORD_TYPE);\n+  TYPE_IS_PADDING_P (record) = 1;\n \n   if (Present (gnat_entity))\n     TYPE_NAME (record) = create_concat_name (gnat_entity, name_trailer);\n \n-  /* If we were making a type, complete the original type and give it a\n-     name.  */\n-  if (is_user_type)\n-    create_type_decl (get_entity_name (gnat_entity), type,\n-\t\t      NULL, !Comes_From_Source (gnat_entity),\n-\t\t      !(TYPE_NAME (type)\n-\t\t\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t\t\t&& DECL_IGNORED_P (TYPE_NAME (type))),\n-\t\t      gnat_entity);\n+  TYPE_VOLATILE (record)\n+    = Present (gnat_entity) && Treat_As_Volatile (gnat_entity);\n+\n+  TYPE_ALIGN (record) = align;\n+  if (orig_align)\n+    TYPE_USER_ALIGN (record) = align;\n+\n+  TYPE_SIZE (record) = size ? size : orig_size;\n+  TYPE_SIZE_UNIT (record)\n+    = convert (sizetype,\n+\t       size_binop (CEIL_DIV_EXPR, TYPE_SIZE (record),\n+\t\t\t   bitsize_unit_node));\n \n   /* If we are changing the alignment and the input type is a record with\n      BLKmode and a small constant size, try to make a form that has an\n-     integral mode.  That might allow this record to have an integral mode,\n-     which will be much more efficient.  There is no point in doing this if a\n-     size is specified unless it is also smaller than the maximum mode size\n-     and it is incorrect to do this if the size of the original type is not a\n-     multiple of the alignment.  */\n+     integral mode.  This might allow the padding record to also have an\n+     integral mode, which will be much more efficient.  There is no point\n+     in doing so if a size is specified unless it is also a small constant\n+     size and it is incorrect to do so if we cannot guarantee that the mode\n+     will be naturally aligned since the field must always be addressable.  */\n   if (align != 0\n       && TREE_CODE (type) == RECORD_TYPE\n       && TYPE_MODE (type) == BLKmode\n       && TREE_CODE (orig_size) == INTEGER_CST\n+      && !TREE_CONSTANT_OVERFLOW (orig_size)\n       && compare_tree_int (orig_size, MAX_FIXED_MODE_SIZE) <= 0\n       && (!size\n \t  || (TREE_CODE (size) == INTEGER_CST\n-\t      && compare_tree_int (size, MAX_FIXED_MODE_SIZE) <= 0))\n-      && value_factor_p (orig_size, align))\n-    type = make_packable_type (type, true);\n+\t      && compare_tree_int (size, MAX_FIXED_MODE_SIZE) <= 0)))\n+    {\n+      tree packable_type = make_packable_type (type, true);\n+      if (TYPE_MODE (packable_type) != BLKmode\n+\t  && align >= TYPE_ALIGN (packable_type))\n+        type = packable_type;\n+    }\n \n+  /* Now create the field with the original size.  */\n   field  = create_field_decl (get_identifier (\"F\"), type, record, 0,\n-\t\t\t      NULL_TREE, bitsize_zero_node, 1);\n-\n+\t\t\t      orig_size, bitsize_zero_node, 1);\n   DECL_INTERNAL_P (field) = 1;\n-  TYPE_SIZE (record) = size ? size : orig_size;\n-  TYPE_SIZE_UNIT (record)\n-    = (size ? convert (sizetype,\n-\t\t       size_binop (CEIL_DIV_EXPR, size, bitsize_unit_node))\n-       : TYPE_SIZE_UNIT (type));\n \n-  TYPE_ALIGN (record) = align;\n-  if (orig_align)\n-    TYPE_USER_ALIGN (record) = align;\n-\n-  TYPE_IS_PADDING_P (record) = 1;\n-  TYPE_VOLATILE (record)\n-    = Present (gnat_entity) && Treat_As_Volatile (gnat_entity);\n   /* Do not finalize it until after the auxiliary record is built.  */\n   finish_record_type (record, field, 1, true);\n "}, {"sha": "5ec3ecdd013b18c8a075f1637274f7072675ea80", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -202,7 +202,7 @@ static tree emit_range_check (tree, Node_Id);\n static tree emit_index_check (tree, tree, tree, tree);\n static tree emit_check (tree, tree, int);\n static tree convert_with_check (Entity_Id, tree, bool, bool, bool);\n-static bool larger_record_type_p (tree, tree);\n+static bool smaller_packable_type_p (tree, tree);\n static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n@@ -2204,11 +2204,11 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t     of the object if they are distinct, because the expectations\n \t     of the callee would otherwise not be met:\n \t       - if it's a justified modular type,\n-\t       - if the actual type is a packable version of it.  */\n+\t       - if the actual type is a smaller packable version of it.  */\n \t  else if (TREE_CODE (gnu_name_type) == RECORD_TYPE\n \t\t   && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)\n-\t\t       || larger_record_type_p (gnu_name_type,\n-\t\t\t\t\t\tTREE_TYPE (gnu_name))))\n+\t\t       || smaller_packable_type_p (TREE_TYPE (gnu_name),\n+\t\t\t\t\t\t gnu_name_type)))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n \t  /* Make a SAVE_EXPR to both properly account for potential side\n@@ -6120,21 +6120,25 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   return convert (gnu_type, gnu_result);\n }\n \f\n-/* Return true if RECORD_TYPE, a record type, is larger than TYPE.  */\n+/* Return true if TYPE is a smaller packable version of RECORD_TYPE.  */\n \n static bool\n-larger_record_type_p (tree record_type, tree type)\n+smaller_packable_type_p (tree type, tree record_type)\n {\n-  tree rsize, size;\n+  tree size, rsize;\n \n-  /* Padding types are not considered larger on their own.  */\n-  if (TYPE_IS_PADDING_P (record_type))\n+  /* We're not interested in variants here.  */\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (record_type))\n+    return false;\n+\n+  /* Like a variant, a packable version keeps the original TYPE_NAME.  */\n+  if (TYPE_NAME (type) != TYPE_NAME (record_type))\n     return false;\n \n-  rsize = TYPE_SIZE (record_type);\n   size = TYPE_SIZE (type);\n+  rsize = TYPE_SIZE (record_type);\n \n-  if (!(TREE_CODE (rsize) == INTEGER_CST && TREE_CODE (size) == INTEGER_CST))\n+  if (!(TREE_CODE (size) == INTEGER_CST && TREE_CODE (rsize) == INTEGER_CST))\n     return false;\n \n   return tree_int_cst_lt (size, rsize) != 0;\n@@ -6208,7 +6212,7 @@ addressable_p (tree gnu_expr, tree gnu_type)\n      to be considered in practice.  */\n   if (gnu_type\n       && TREE_CODE (gnu_type) == RECORD_TYPE\n-      && larger_record_type_p (gnu_type, TREE_TYPE (gnu_expr)))\n+      && smaller_packable_type_p (TREE_TYPE (gnu_expr), gnu_type))\n     return false;\n \n   switch (TREE_CODE (gnu_expr))\n@@ -6238,16 +6242,18 @@ addressable_p (tree gnu_expr, tree gnu_type)\n \t      && addressable_p (TREE_OPERAND (gnu_expr, 2), NULL_TREE));\n \n     case COMPONENT_REF:\n-      return (!DECL_BIT_FIELD (TREE_OPERAND (gnu_expr, 1))\n-\t      && (!STRICT_ALIGNMENT\n-\t\t  /* Even with DECL_BIT_FIELD cleared, we have to ensure that\n-\t\t     the field is sufficiently aligned, in case it is subject\n-\t\t     to a pragma Component_Alignment.  But we don't need to\n-\t\t     check the alignment of the containing record, as it is\n-\t\t     guaranteed to be not smaller than that of its most\n-\t\t     aligned field that is not a bit-field.  */\n-\t\t  || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))\n-\t\t       >= TYPE_ALIGN (TREE_TYPE (gnu_expr)))\n+      return (((!DECL_BIT_FIELD (TREE_OPERAND (gnu_expr, 1))\n+\t\t/* Even with DECL_BIT_FIELD cleared, we have to ensure that\n+\t\t   the field is sufficiently aligned, in case it is subject\n+\t\t   to a pragma Component_Alignment.  But we don't need to\n+\t\t   check the alignment of the containing record, as it is\n+\t\t   guaranteed to be not smaller than that of its most\n+\t\t   aligned field that is not a bit-field.  */\n+\t        && (!STRICT_ALIGNMENT\n+\t\t    || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))\n+\t\t       >= TYPE_ALIGN (TREE_TYPE (gnu_expr))))\n+\t       /* The field of a padding record is always addressable.  */\n+\t       || TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n \t      && addressable_p (TREE_OPERAND (gnu_expr, 0), NULL_TREE));\n \n     case ARRAY_REF:  case ARRAY_RANGE_REF:"}, {"sha": "8d3df68fe40ffe7e9680f4013ddd05ca347229ad", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -3396,7 +3396,9 @@ convert (tree type, tree expr)\n \t   && TYPE_IS_PADDING_P (type) && TYPE_IS_PADDING_P (etype)\n \t   && (!TREE_CONSTANT (TYPE_SIZE (type))\n \t       || !TREE_CONSTANT (TYPE_SIZE (etype))\n-\t       || gnat_types_compatible_p (type, etype)))\n+\t       || gnat_types_compatible_p (type, etype)\n+\t       || TYPE_NAME (TREE_TYPE (TYPE_FIELDS (type)))\n+\t\t  == TYPE_NAME (TREE_TYPE (TYPE_FIELDS (etype)))))\n     ;\n \n   /* If the output type has padding, convert to the inner type and\n@@ -3405,9 +3407,13 @@ convert (tree type, tree expr)\n     {\n       /* If we previously converted from another type and our type is\n \t of variable size, remove the conversion to avoid the need for\n-\t variable-size temporaries.  */\n+\t variable-size temporaries.  Likewise for a conversion between\n+\t original and packable version.  */\n       if (TREE_CODE (expr) == VIEW_CONVERT_EXPR\n-\t  && !TREE_CONSTANT (TYPE_SIZE (type)))\n+\t  && (!TREE_CONSTANT (TYPE_SIZE (type))\n+\t      || (ecode == RECORD_TYPE\n+\t\t  && TYPE_NAME (etype)\n+\t\t     == TYPE_NAME (TREE_TYPE (TREE_OPERAND (expr, 0))))))\n \texpr = TREE_OPERAND (expr, 0);\n \n       /* If we are just removing the padding from expr, convert the original\n@@ -3419,7 +3425,10 @@ convert (tree type, tree expr)\n \t  && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (expr, 0)))\n \t  && (!TREE_CONSTANT (TYPE_SIZE (type))\n \t      || gnat_types_compatible_p (type,\n-\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (expr, 0)))))\n+\t\t\t\t\t  TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\t      || (ecode == RECORD_TYPE\n+\t\t  && TYPE_NAME (etype)\n+\t\t     == TYPE_NAME (TREE_TYPE (TYPE_FIELDS (type))))))\n \treturn convert (type, TREE_OPERAND (expr, 0));\n \n       /* If the result type is a padded type with a self-referentially-sized\n@@ -3534,8 +3543,12 @@ convert (tree type, tree expr)\n \n     case CONSTRUCTOR:\n       /* If we are converting a CONSTRUCTOR to a mere variant type, just make\n-\t a new one in the proper type.  */\n-      if (gnat_types_compatible_p (type, etype))\n+\t a new one in the proper type.  Likewise for a conversion between\n+\t original and packable version.  */\n+      if (code == ecode\n+\t  && (gnat_types_compatible_p (type, etype)\n+\t      || (code == RECORD_TYPE\n+\t\t  && TYPE_NAME (type) == TYPE_NAME (etype))))\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;\n@@ -3617,7 +3630,8 @@ convert (tree type, tree expr)\n \n   /* If we're converting between two aggregate types that are mere\n      variants, just make a VIEW_CONVERT_EXPR.  */\n-  else if (AGGREGATE_TYPE_P (type)\n+  else if (code == ecode\n+\t   && AGGREGATE_TYPE_P (type)\n \t   && gnat_types_compatible_p (type, etype))\n     return build1 (VIEW_CONVERT_EXPR, type, expr);\n "}, {"sha": "b45c7aca107b8108e210345b6657d8ffe9b63047", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -693,21 +693,24 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  && TYPE_ALIGN_OK (right_type))\n \toperation_type = right_type;\n \n-      /* If we are copying between padded objects of the same underlying\n-\t type with a non-zero size, use the padded view of the type, this\n-\t is very likely more efficient; but gnat_to_gnu will have removed\n-\t the padding on the RHS so we have to make sure that we can safely\n-\t put it back.  */\n+      /* If we are copying between padded objects with compatible types, use\n+\t the padded view of the objects, this is very likely more efficient.\n+\t Likewise for a padded that is assigned a constructor, in order to\n+\t avoid putting a VIEW_CONVERT_EXPR on the LHS.  But don't do this if\n+\t we wouldn't have actually copied anything.  */\n       else if (TREE_CODE (left_type) == RECORD_TYPE\n \t       && TYPE_IS_PADDING_P (left_type)\n-\t       && TREE_TYPE (TYPE_FIELDS (left_type)) == right_type\n-\t       && !integer_zerop (TYPE_SIZE (right_type))\n+\t       && TREE_CONSTANT (TYPE_SIZE (left_type))\n \t       && ((TREE_CODE (right_operand) == COMPONENT_REF\n \t\t    && TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n \t\t       == RECORD_TYPE\n \t\t    && TYPE_IS_PADDING_P\n-\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n-\t\t   || TREE_CODE (right_operand) == CONSTRUCTOR))\n+\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t    && gnat_types_compatible_p\n+\t\t\t(left_type,\n+\t\t\t TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t   || TREE_CODE (right_operand) == CONSTRUCTOR)\n+\t       && !integer_zerop (TYPE_SIZE (right_type)))\n \toperation_type = left_type;\n \n       /* Find the best type to use for copying between aggregate types.  */"}, {"sha": "53a4fc0d2bdd8c177c6eb48ec4458a35bccafcbc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -1,3 +1,9 @@\n+2008-05-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/alignment4.adb: Adjust.\n+\t* gnat.dg/alignment5.adb: Likewise.\n+\t* gnat.dg/alignment6.adb: XFAIL.\n+\n 2008-05-03  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/loop-36.c: Cleanup the dump file."}, {"sha": "c23bcfe48da5624d123d2008912d9e601155b501", "filename": "gcc/testsuite/gnat.dg/alignment4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2Fgnat.dg%2Falignment4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2Fgnat.dg%2Falignment4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment4.adb?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -11,5 +11,5 @@ begin\n   S1 := S2;\n end;\n \n--- { dg-final { scan-tree-dump-not \"VIEW_CONVERT_EXPR\" \"gimple\" } }\n+-- { dg-final { scan-tree-dump-not \".\\F\" \"gimple\" } }\n -- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "8a89f5ef89584be4827de349f9818ed1821bf25e", "filename": "gcc/testsuite/gnat.dg/alignment5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2Fgnat.dg%2Falignment5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2Fgnat.dg%2Falignment5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment5.adb?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -27,5 +27,5 @@ begin\n    A_REC := B_REC;\n end;\n \n--- { dg-final { scan-tree-dump-not \"VIEW_CONVERT_EXPR\" \"gimple\" } }\n+-- { dg-final { scan-tree-dump-not \"\\.F\" \"gimple\" } }\n -- { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "548574f5cc95b99de29f7d77e56030f3bbb7d2a9", "filename": "gcc/testsuite/gnat.dg/alignment6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2Fgnat.dg%2Falignment6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88f36b7eb6a153a914e9b4d678c1ddaddb842747/gcc%2Ftestsuite%2Fgnat.dg%2Falignment6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment6.adb?ref=88f36b7eb6a153a914e9b4d678c1ddaddb842747", "patch": "@@ -28,5 +28,5 @@ begin\n    B_REC := A_REC;\n end;\n \n--- { dg-final { scan-tree-dump-not \"VIEW_CONVERT_EXPR\" \"gimple\" } }\n+-- { dg-final { scan-tree-dump-not \"VIEW_CONVERT_EXPR\" \"gimple\" { xfail *-*-* } } }\n -- { dg-final { cleanup-tree-dump \"gimple\" } }"}]}