{"sha": "c375c43b73df248b6c1b7c87608ba491600c3e0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM3NWM0M2I3M2RmMjQ4YjZjMWI3Yzg3NjA4YmE0OTE2MDBjM2UwYQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1998-11-02T07:20:48Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1998-11-02T07:20:48Z"}, "message": "configure.in: Call AC_FUNC_VFORK.\n\n        * configure.in: Call AC_FUNC_VFORK.\n        * collect2.c: Define VFORK_STRING as a printable string for\n        error messages (either \"vfork\" or \"fork\".)  If HAVE_VFORK_H is\n        defined, include vfork.h.  If VMS is defined, define vfork()\n        appropriately.  Remove vfork check on USG, we're using autoconf.\n        (collect_execute): Pass VFORK_STRING to fatal_perror instead of\n        checking locally what string to pass.\n        (scan_prog_file): Likewise.\n        (scan_libraries): Likewise.\n        * gcc.c: Remove vfork check on USG, we're using autoconf.\n        Besides, no calls to vfork/fork occur in this file.\n        * protoize.c: Likewise.\n\nFrom-SVN: r23498", "tree": {"sha": "0a6465ac8b45632cb3fe469d00fe1ffb939cbad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a6465ac8b45632cb3fe469d00fe1ffb939cbad7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c375c43b73df248b6c1b7c87608ba491600c3e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c375c43b73df248b6c1b7c87608ba491600c3e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c375c43b73df248b6c1b7c87608ba491600c3e0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c375c43b73df248b6c1b7c87608ba491600c3e0a/comments", "author": null, "committer": null, "parents": [{"sha": "3ccc3a56fbec16381b52668554ed01748d897063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccc3a56fbec16381b52668554ed01748d897063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccc3a56fbec16381b52668554ed01748d897063"}], "stats": {"total": 346, "additions": 299, "deletions": 47}, "files": [{"sha": "2c284181cda9e4cbf32c75c250466d0e233964a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -1,3 +1,21 @@\n+Mon Nov  2 10:10:35 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* configure.in: Call AC_FUNC_VFORK.\n+\n+\t* collect2.c: Define VFORK_STRING as a printable string for\n+ \terror messages (either \"vfork\" or \"fork\".)  If HAVE_VFORK_H is\n+ \tdefined, include vfork.h.  If VMS is defined, define vfork()\n+\tappropriately.  Remove vfork check on USG, we're using autoconf.\n+\t(collect_execute): Pass VFORK_STRING to fatal_perror instead of\n+\tchecking locally what string to pass.\n+\t(scan_prog_file): Likewise.\n+\t(scan_libraries): Likewise.\n+\n+\t* gcc.c: Remove vfork check on USG, we're using autoconf.\n+\tBesides, no calls to vfork/fork occur in this file.\n+\n+\t* protoize.c: Likewise.\n+\n Mon Nov  2 07:52:28 1998  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* configure.in (DEFAULT_LINKER): renamed from LD"}, {"sha": "5fdd08bedf593e0718810d68100502af49955cb7", "filename": "gcc/collect2.c", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -30,6 +30,19 @@ Boston, MA 02111-1307, USA.  */\n #include <signal.h>\n #include <sys/stat.h>\n \n+#ifdef vfork /* Autoconf may define this to fork for us. */\n+# define VFORK_STRING \"fork\"\n+#else\n+# define VFORK_STRING \"vfork\"\n+#endif\n+#ifdef HAVE_VFORK_H\n+#include <vfork.h>\n+#endif\n+#ifdef VMS\n+#define vfork() (decc$$alloc_vfork_blocks() >= 0 ? \\\n+               lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)\n+#endif /* VMS */\n+\n #define COLLECT\n \n #include \"demangle.h\"\n@@ -43,10 +56,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-#ifdef USG\n-#define vfork fork\n-#endif\n-\n #ifndef WIFSIGNALED\n #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)\n #endif\n@@ -1716,13 +1725,7 @@ collect_execute (prog, argv, redir)\n #ifndef __CYGWIN32__\n   pid = vfork ();\n   if (pid == -1)\n-    {\n-#ifdef vfork\n-      fatal_perror (\"fork\");\n-#else\n-      fatal_perror (\"vfork\");\n-#endif\n-    }\n+    fatal_perror (VFORK_STRING);\n \n   if (pid == 0)\t\t\t/* child context */\n     {\n@@ -2243,13 +2246,7 @@ scan_prog_file (prog_name, which_pass)\n   /* Spawn child nm on pipe */\n   pid = vfork ();\n   if (pid == -1)\n-    {\n-#ifdef vfork\n-      fatal_perror (\"fork\");\n-#else\n-      fatal_perror (\"vfork\");\n-#endif\n-    }\n+    fatal_perror (VFORK_STRING);\n \n   if (pid == 0)\t\t\t/* child context */\n     {\n@@ -2685,13 +2682,7 @@ scan_libraries (prog_name)\n   /* Spawn child ldd on pipe */\n   pid = vfork ();\n   if (pid == -1)\n-    {\n-#ifdef vfork\n-      fatal_perror (\"fork\");\n-#else\n-      fatal_perror (\"vfork\");\n-#endif\n-    }\n+    fatal_perror (VFORK_STRING);\n \n   if (pid == 0)\t\t\t/* child context */\n     {"}, {"sha": "fd08dcfda7d14968a69832636240d31152c92762", "filename": "gcc/config.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -98,9 +98,15 @@\n /* Define if you don't have vprintf but do have _doprnt.  */\n #undef HAVE_DOPRNT\n \n+/* Define if you have <vfork.h>.  */\n+#undef HAVE_VFORK_H\n+\n /* Define if you have the vprintf function.  */\n #undef HAVE_VPRINTF\n \n+/* Define to `int' if <sys/types.h> doesn't define.  */\n+#undef pid_t\n+\n /* Define if you have the ANSI C header files.  */\n #undef STDC_HEADERS\n \n@@ -110,6 +116,9 @@\n /* Define if you can safely include both <sys/time.h> and <time.h>.  */\n #undef TIME_WITH_SYS_TIME\n \n+/* Define vfork as fork if vfork does not work.  */\n+#undef vfork\n+\n /* Define if you have the atoll function.  */\n #undef HAVE_ATOLL\n "}, {"sha": "ee384fc57a1fab44b18530157dd5d9a34183c896", "filename": "gcc/configure", "status": "modified", "additions": 255, "deletions": 12, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -2209,18 +2209,261 @@ EOF\n \n fi\n \n+echo $ac_n \"checking for pid_t\"\"... $ac_c\" 1>&6\n+echo \"configure:2214: checking for pid_t\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_type_pid_t'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2219 \"configure\"\n+#include \"confdefs.h\"\n+#include <sys/types.h>\n+#if STDC_HEADERS\n+#include <stdlib.h>\n+#include <stddef.h>\n+#endif\n+EOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  egrep \"pid_t[^a-zA-Z_0-9]\" >/dev/null 2>&1; then\n+  rm -rf conftest*\n+  ac_cv_type_pid_t=yes\n+else\n+  rm -rf conftest*\n+  ac_cv_type_pid_t=no\n+fi\n+rm -f conftest*\n+\n+fi\n+echo \"$ac_t\"\"$ac_cv_type_pid_t\" 1>&6\n+if test $ac_cv_type_pid_t = no; then\n+  cat >> confdefs.h <<\\EOF\n+#define pid_t int\n+EOF\n+\n+fi\n+\n+ac_safe=`echo \"vfork.h\" | sed 'y%./+-%__p_%'`\n+echo $ac_n \"checking for vfork.h\"\"... $ac_c\" 1>&6\n+echo \"configure:2248: checking for vfork.h\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2253 \"configure\"\n+#include \"confdefs.h\"\n+#include <vfork.h>\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:2258: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out`\n+if test -z \"$ac_err\"; then\n+  rm -rf conftest*\n+  eval \"ac_cv_header_$ac_safe=yes\"\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_header_$ac_safe=no\"\n+fi\n+rm -f conftest*\n+fi\n+if eval \"test \\\"`echo '$ac_cv_header_'$ac_safe`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  cat >> confdefs.h <<\\EOF\n+#define HAVE_VFORK_H 1\n+EOF\n+\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+echo $ac_n \"checking for working vfork\"\"... $ac_c\" 1>&6\n+echo \"configure:2283: checking for working vfork\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_vfork_works'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  if test \"$cross_compiling\" = yes; then\n+  echo $ac_n \"checking for vfork\"\"... $ac_c\" 1>&6\n+echo \"configure:2289: checking for vfork\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_vfork'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2294 \"configure\"\n+#include \"confdefs.h\"\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char vfork(); below.  */\n+#include <assert.h>\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char vfork();\n+\n+int main() {\n+\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_vfork) || defined (__stub___vfork)\n+choke me\n+#else\n+vfork();\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:2317: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n+  rm -rf conftest*\n+  eval \"ac_cv_func_vfork=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_func_vfork=no\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$ac_cv_func_'vfork`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  :\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+ac_cv_func_vfork_works=$ac_cv_func_vfork\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 2339 \"configure\"\n+#include \"confdefs.h\"\n+/* Thanks to Paul Eggert for this test.  */\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_VFORK_H\n+#include <vfork.h>\n+#endif\n+/* On some sparc systems, changes by the child to local and incoming\n+   argument registers are propagated back to the parent.\n+   The compiler is told about this with #include <vfork.h>,\n+   but some compilers (e.g. gcc -O) don't grok <vfork.h>.\n+   Test for this by using a static variable whose address\n+   is put into a register that is clobbered by the vfork.  */\n+static\n+#ifdef __cplusplus\n+sparc_address_test (int arg)\n+#else\n+sparc_address_test (arg) int arg;\n+#endif\n+{\n+  static pid_t child;\n+  if (!child) {\n+    child = vfork ();\n+    if (child < 0) {\n+      perror (\"vfork\");\n+      _exit(2);\n+    }\n+    if (!child) {\n+      arg = getpid();\n+      write(-1, \"\", 0);\n+      _exit (arg);\n+    }\n+  }\n+}\n+main() {\n+  pid_t parent = getpid ();\n+  pid_t child;\n+\n+  sparc_address_test ();\n+\n+  child = vfork ();\n+\n+  if (child == 0) {\n+    /* Here is another test for sparc vfork register problems.\n+       This test uses lots of local variables, at least\n+       as many local variables as main has allocated so far\n+       including compiler temporaries.  4 locals are enough for\n+       gcc 1.40.3 on a Solaris 4.1.3 sparc, but we use 8 to be safe.\n+       A buggy compiler should reuse the register of parent\n+       for one of the local variables, since it will think that\n+       parent can't possibly be used any more in this routine.\n+       Assigning to the local variable will thus munge parent\n+       in the parent process.  */\n+    pid_t\n+      p = getpid(), p1 = getpid(), p2 = getpid(), p3 = getpid(),\n+      p4 = getpid(), p5 = getpid(), p6 = getpid(), p7 = getpid();\n+    /* Convince the compiler that p..p7 are live; otherwise, it might\n+       use the same hardware register for all 8 local variables.  */\n+    if (p != p1 || p != p2 || p != p3 || p != p4\n+\t|| p != p5 || p != p6 || p != p7)\n+      _exit(1);\n+\n+    /* On some systems (e.g. IRIX 3.3),\n+       vfork doesn't separate parent from child file descriptors.\n+       If the child closes a descriptor before it execs or exits,\n+       this munges the parent's descriptor as well.\n+       Test for this by closing stdout in the child.  */\n+    _exit(close(fileno(stdout)) != 0);\n+  } else {\n+    int status;\n+    struct stat st;\n+\n+    while (wait(&status) != child)\n+      ;\n+    exit(\n+\t /* Was there some problem with vforking?  */\n+\t child < 0\n+\n+\t /* Did the child fail?  (This shouldn't happen.)  */\n+\t || status\n+\n+\t /* Did the vfork/compiler bug occur?  */\n+\t || parent != getpid()\n+\n+\t /* Did the file descriptor bug occur?  */\n+\t || fstat(fileno(stdout), &st) != 0\n+\t );\n+  }\n+}\n+EOF\n+if { (eval echo configure:2434: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null\n+then\n+  ac_cv_func_vfork_works=yes\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -fr conftest*\n+  ac_cv_func_vfork_works=no\n+fi\n+rm -fr conftest*\n+fi\n+\n+fi\n+\n+echo \"$ac_t\"\"$ac_cv_func_vfork_works\" 1>&6\n+if test $ac_cv_func_vfork_works = no; then\n+  cat >> confdefs.h <<\\EOF\n+#define vfork fork\n+EOF\n+\n+fi\n+\n \n for ac_func in malloc realloc calloc free bcopy bzero bcmp \\\n \tindex rindex getenv atol sbrk abort atof strerror getcwd getwd \\\n \tstrsignal\n do\n echo $ac_n \"checking whether $ac_func must be declared\"\"... $ac_c\" 1>&6\n-echo \"configure:2219: checking whether $ac_func must be declared\" >&5\n+echo \"configure:2462: checking whether $ac_func must be declared\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_decl_needed_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2224 \"configure\"\n+#line 2467 \"configure\"\n #include \"confdefs.h\"\n \n #include <stdio.h>\n@@ -2253,7 +2496,7 @@ int main() {\n char *(*pfn) = (char *(*)) $ac_func\n ; return 0; }\n EOF\n-if { (eval echo configure:2257: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2500: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   eval \"gcc_cv_decl_needed_$ac_func=no\"\n else\n@@ -2282,12 +2525,12 @@ done\n for ac_func in getrlimit setrlimit\n do\n echo $ac_n \"checking whether $ac_func must be declared\"\"... $ac_c\" 1>&6\n-echo \"configure:2286: checking whether $ac_func must be declared\" >&5\n+echo \"configure:2529: checking whether $ac_func must be declared\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_decl_needed_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2291 \"configure\"\n+#line 2534 \"configure\"\n #include \"confdefs.h\"\n \n #include <stdio.h>\n@@ -2324,7 +2567,7 @@ int main() {\n char *(*pfn) = (char *(*)) $ac_func\n ; return 0; }\n EOF\n-if { (eval echo configure:2328: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2571: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   eval \"gcc_cv_decl_needed_$ac_func=no\"\n else\n@@ -2351,12 +2594,12 @@ done\n \n \n echo $ac_n \"checking for sys_siglist declaration in signal.h or unistd.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2355: checking for sys_siglist declaration in signal.h or unistd.h\" >&5\n+echo \"configure:2598: checking for sys_siglist declaration in signal.h or unistd.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2360 \"configure\"\n+#line 2603 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <signal.h>\n@@ -2368,7 +2611,7 @@ int main() {\n char *msg = *(sys_siglist + 1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2372: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2615: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_decl_sys_siglist=yes\n else\n@@ -5587,7 +5830,7 @@ fi\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n-echo \"configure:5591: checking assembler alignment features\" >&5\n+echo \"configure:5834: checking assembler alignment features\" >&5\n gcc_cv_as=\n gcc_cv_as_alignment_features=\n gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/gas\n@@ -5660,7 +5903,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_alignment_features\" 1>&6\n \n echo $ac_n \"checking assembler subsection support\"\"... $ac_c\" 1>&6\n-echo \"configure:5664: checking assembler subsection support\" >&5\n+echo \"configure:5907: checking assembler subsection support\" >&5\n gcc_cv_as_subsections=\n if test x$gcc_cv_as != x; then\n \t# Check if we have .subsection\n@@ -5896,7 +6139,7 @@ fi\n \n # Warn if using init_priority.\n echo $ac_n \"checking whether to enable init_priority by default\"\"... $ac_c\" 1>&6\n-echo \"configure:5900: checking whether to enable init_priority by default\" >&5\n+echo \"configure:6143: checking whether to enable init_priority by default\" >&5\n if test x$enable_init_priority != xyes; then\n   enable_init_priority=no\n fi"}, {"sha": "3af08910febff2bb1e8b8a7576559d7dd3267599", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -367,6 +367,7 @@ AC_CHECK_FUNCS(strtoul bsearch strerror putenv popen bcopy bzero bcmp \\\n \n GCC_FUNC_VFPRINTF_DOPRNT\n GCC_FUNC_PRINTF_PTR\n+AC_FUNC_VFORK\n \n GCC_NEED_DECLARATIONS(malloc realloc calloc free bcopy bzero bcmp \\\n \tindex rindex getenv atol sbrk abort atof strerror getcwd getwd \\"}, {"sha": "3182f6876cc27ae165f546635d99ac41c2aedc5c", "filename": "gcc/gcc.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -69,10 +69,6 @@ extern void set_std_prefix PROTO((char *, int));\n #define exit __posix_exit\n #endif\n \n-#ifdef USG\n-#define vfork fork\n-#endif /* USG */\n-\n /* Test if something is a normal file.  */\n #ifndef S_ISREG\n #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)"}, {"sha": "1e2944e48c3b6b63ab80abc40fa38e5047983bfb", "filename": "gcc/protoize.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c375c43b73df248b6c1b7c87608ba491600c3e0a/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=c375c43b73df248b6c1b7c87608ba491600c3e0a", "patch": "@@ -182,12 +182,6 @@ extern int access ();\n extern size_t   strlen ()\n #endif\n \n-/* Fork is not declared because the declaration caused a conflict\n-   on the HPPA.  */\n-#if !(defined (USG) || defined (VMS))\n-#define fork vfork\n-#endif /* (defined (USG) || defined (VMS)) */\n-\n #endif /* !defined (POSIX) */\n \n /* Look for these where the `const' qualifier is intentionally cast aside.  */"}]}