{"sha": "3a978d72e699a1410ba46ca7630d6733e9420a50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5NzhkNzJlNjk5YTE0MTBiYTQ2Y2E3NjMwZDY3MzNlOTQyMGE1MA==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-19T01:24:08Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-19T01:24:08Z"}, "message": "pt.c: Convert to ISO C.\n\n\t* pt.c: Convert to ISO C.\n\t* semantics.c: Convert to ISO C.\n\nFrom-SVN: r68174", "tree": {"sha": "50696b2f252dcc454fa05027ee45ded72f6d1719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50696b2f252dcc454fa05027ee45ded72f6d1719"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a978d72e699a1410ba46ca7630d6733e9420a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a978d72e699a1410ba46ca7630d6733e9420a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a978d72e699a1410ba46ca7630d6733e9420a50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a978d72e699a1410ba46ca7630d6733e9420a50/comments", "author": null, "committer": null, "parents": [{"sha": "7cbd1918f597f5b1078a1d7e1441de1ea09f00c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbd1918f597f5b1078a1d7e1441de1ea09f00c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbd1918f597f5b1078a1d7e1441de1ea09f00c5"}], "stats": {"total": 1063, "additions": 399, "deletions": 664}, "files": [{"sha": "83e943bc0277a5e6747504006d43efebbf2f1b59", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a978d72e699a1410ba46ca7630d6733e9420a50/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a978d72e699a1410ba46ca7630d6733e9420a50/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a978d72e699a1410ba46ca7630d6733e9420a50", "patch": "@@ -1,3 +1,8 @@\n+2003-06-18  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t* pt.c: Convert to ISO C.\n+\t* semantics.c: Convert to ISO C.\n+\n 2003-06-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (comp_except_specs, compparms, cp_has_mutable_p,"}, {"sha": "b5ac7b20b4e0bef691074e958f43fdad1875a66b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 288, "deletions": 460, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a978d72e699a1410ba46ca7630d6733e9420a50/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a978d72e699a1410ba46ca7630d6733e9420a50/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3a978d72e699a1410ba46ca7630d6733e9420a50", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n-typedef int (*tree_fn_t) PARAMS ((tree, void*));\n+typedef int (*tree_fn_t) (tree, void*);\n \n /* The PENDING_TEMPLATES is a TREE_LIST of templates whose\n    instantiations have been deferred, either because their definitions\n@@ -88,88 +88,83 @@ static htab_t local_specializations;\n #define GTB_IGNORE_TYPE 2 /* We don't need to try to unify the current\n \t\t\t     type with the desired type.  */\n \n-static void push_access_scope_real PARAMS ((tree, tree, tree));\n-static void push_access_scope PARAMS ((tree));\n-static void pop_access_scope PARAMS ((tree));\n-static int resolve_overloaded_unification PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t\t   unification_kind_t, int));\n-static int try_one_overload PARAMS ((tree, tree, tree, tree, tree,\n-\t\t\t\t     unification_kind_t, int));\n-static int unify PARAMS ((tree, tree, tree, tree, int));\n-static void add_pending_template PARAMS ((tree));\n-static void reopen_tinst_level PARAMS ((tree));\n-static tree classtype_mangled_name PARAMS ((tree));\n-static char *mangle_class_name_for_template PARAMS ((const char *,\n-\t\t\t\t\t\t     tree, tree));\n-static tree tsubst_initializer_list PARAMS ((tree, tree));\n-static int list_eq PARAMS ((tree, tree));\n-static tree get_class_bindings PARAMS ((tree, tree, tree));\n-static tree coerce_template_parms PARAMS ((tree, tree, tree,\n-\t\t\t\t\t   tsubst_flags_t, int));\n-static void tsubst_enum\tPARAMS ((tree, tree, tree));\n-static tree add_to_template_args PARAMS ((tree, tree));\n-static tree add_outermost_template_args PARAMS ((tree, tree));\n-static bool check_instantiated_args PARAMS ((tree, tree, tsubst_flags_t));\n-static int maybe_adjust_types_for_deduction PARAMS ((unification_kind_t, tree*,\n-\t\t\t\t\t\t     tree*)); \n-static int  type_unification_real PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t   int, unification_kind_t, int, int));\n-static void note_template_header PARAMS ((int));\n-static tree maybe_fold_nontype_arg PARAMS ((tree));\n-static void maybe_fold_nontype_args PARAMS ((tree));\n-static tree convert_nontype_argument PARAMS ((tree, tree));\n-static tree convert_template_argument PARAMS ((tree, tree, tree,\n-\t\t\t\t\t       tsubst_flags_t, int, tree));\n-static tree get_bindings_overload PARAMS ((tree, tree, tree));\n-static int for_each_template_parm PARAMS ((tree, tree_fn_t, void*, htab_t));\n-static tree build_template_parm_index PARAMS ((int, int, int, tree, tree));\n-static int inline_needs_template_parms PARAMS ((tree));\n-static void push_inline_template_parms_recursive PARAMS ((tree, int));\n-static tree retrieve_specialization PARAMS ((tree, tree));\n-static tree retrieve_local_specialization PARAMS ((tree));\n-static tree register_specialization PARAMS ((tree, tree, tree));\n-static void register_local_specialization PARAMS ((tree, tree));\n-static int unregister_specialization PARAMS ((tree, tree));\n-static tree reduce_template_parm_level PARAMS ((tree, tree, int));\n-static tree build_template_decl PARAMS ((tree, tree));\n-static int mark_template_parm PARAMS ((tree, void *));\n-static int template_parm_this_level_p PARAMS ((tree, void *));\n-static tree tsubst_friend_function PARAMS ((tree, tree));\n-static tree tsubst_friend_class PARAMS ((tree, tree));\n-static int can_complete_type_without_circularity PARAMS ((tree));\n-static tree get_bindings_real PARAMS ((tree, tree, tree, int, int, int));\n-static int template_decl_level PARAMS ((tree));\n-static int check_cv_quals_for_unify PARAMS ((int, tree, tree));\n-static tree tsubst_template_arg_vector PARAMS ((tree, tree, tsubst_flags_t));\n-static tree tsubst_template_parms PARAMS ((tree, tree, tsubst_flags_t));\n-static void regenerate_decl_from_template PARAMS ((tree, tree));\n-static tree most_specialized PARAMS ((tree, tree, tree));\n-static tree most_specialized_class PARAMS ((tree, tree));\n-static int template_class_depth_real PARAMS ((tree, int));\n-static tree tsubst_aggr_type PARAMS ((tree, tree, tsubst_flags_t, tree, int));\n-static tree tsubst_decl PARAMS ((tree, tree, tree, tsubst_flags_t));\n-static tree tsubst_arg_types PARAMS ((tree, tree, tsubst_flags_t, tree));\n-static tree tsubst_function_type PARAMS ((tree, tree, tsubst_flags_t, tree));\n-static void check_specialization_scope PARAMS ((void));\n-static tree process_partial_specialization PARAMS ((tree));\n-static void set_current_access_from_decl PARAMS ((tree));\n-static void check_default_tmpl_args PARAMS ((tree, tree, int, int));\n-static tree tsubst_call_declarator_parms PARAMS ((tree, tree,\n-\t\t\t\t\t\t  tsubst_flags_t, tree));\n-static tree get_template_base_recursive PARAMS ((tree, tree,\n-\t\t\t\t\t\t tree, tree, tree, int)); \n-static tree get_template_base PARAMS ((tree, tree, tree, tree));\n-static int verify_class_unification PARAMS ((tree, tree, tree));\n-static tree try_class_unification PARAMS ((tree, tree, tree, tree));\n-static int coerce_template_template_parms PARAMS ((tree, tree, tsubst_flags_t,\n-\t\t\t\t\t\t   tree, tree));\n-static tree determine_specialization PARAMS ((tree, tree, tree *, int));\n-static int template_args_equal PARAMS ((tree, tree));\n-static void tsubst_default_arguments PARAMS ((tree));\n-static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n-static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n-static void copy_default_args_to_explicit_spec PARAMS ((tree));\n-static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n+static void push_access_scope_real (tree, tree, tree);\n+static void push_access_scope (tree);\n+static void pop_access_scope (tree);\n+static int resolve_overloaded_unification (tree, tree, tree, tree,\n+\t\t\t\t\t   unification_kind_t, int);\n+static int try_one_overload (tree, tree, tree, tree, tree,\n+\t\t\t     unification_kind_t, int);\n+static int unify (tree, tree, tree, tree, int);\n+static void add_pending_template (tree);\n+static void reopen_tinst_level (tree);\n+static tree classtype_mangled_name (tree);\n+static char* mangle_class_name_for_template (const char *, tree, tree);\n+static tree tsubst_initializer_list (tree, tree);\n+static int list_eq (tree, tree);\n+static tree get_class_bindings (tree, tree, tree);\n+static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t, int);\n+static void tsubst_enum\t(tree, tree, tree);\n+static tree add_to_template_args (tree, tree);\n+static tree add_outermost_template_args (tree, tree);\n+static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n+static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*); \n+static int  type_unification_real (tree, tree, tree, tree,\n+\t\t\t\t   int, unification_kind_t, int, int);\n+static void note_template_header (int);\n+static tree maybe_fold_nontype_arg (tree);\n+static void maybe_fold_nontype_args (tree);\n+static tree convert_nontype_argument (tree, tree);\n+static tree convert_template_argument (tree, tree, tree,\n+\t\t\t\t       tsubst_flags_t, int, tree);\n+static tree get_bindings_overload (tree, tree, tree);\n+static int for_each_template_parm (tree, tree_fn_t, void*, htab_t);\n+static tree build_template_parm_index (int, int, int, tree, tree);\n+static int inline_needs_template_parms (tree);\n+static void push_inline_template_parms_recursive (tree, int);\n+static tree retrieve_specialization (tree, tree);\n+static tree retrieve_local_specialization (tree);\n+static tree register_specialization (tree, tree, tree);\n+static void register_local_specialization (tree, tree);\n+static int unregister_specialization (tree, tree);\n+static tree reduce_template_parm_level (tree, tree, int);\n+static tree build_template_decl (tree, tree);\n+static int mark_template_parm (tree, void *);\n+static int template_parm_this_level_p (tree, void *);\n+static tree tsubst_friend_function (tree, tree);\n+static tree tsubst_friend_class (tree, tree);\n+static int can_complete_type_without_circularity (tree);\n+static tree get_bindings_real (tree, tree, tree, int, int, int);\n+static int template_decl_level (tree);\n+static int check_cv_quals_for_unify (int, tree, tree);\n+static tree tsubst_template_arg_vector (tree, tree, tsubst_flags_t);\n+static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n+static void regenerate_decl_from_template (tree, tree);\n+static tree most_specialized (tree, tree, tree);\n+static tree most_specialized_class (tree, tree);\n+static int template_class_depth_real (tree, int);\n+static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n+static tree tsubst_decl (tree, tree, tree, tsubst_flags_t);\n+static tree tsubst_arg_types (tree, tree, tsubst_flags_t, tree);\n+static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n+static void check_specialization_scope (void);\n+static tree process_partial_specialization (tree);\n+static void set_current_access_from_decl (tree);\n+static void check_default_tmpl_args (tree, tree, int, int);\n+static tree tsubst_call_declarator_parms (tree, tree, tsubst_flags_t, tree);\n+static tree get_template_base_recursive (tree, tree, tree, tree, tree, int); \n+static tree get_template_base (tree, tree, tree, tree);\n+static int verify_class_unification (tree, tree, tree);\n+static tree try_class_unification (tree, tree, tree, tree);\n+static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n+\t\t\t\t\t   tree, tree);\n+static tree determine_specialization (tree, tree, tree *, int);\n+static int template_args_equal (tree, tree);\n+static void tsubst_default_arguments (tree);\n+static tree for_each_template_parm_r (tree *, int *, void *);\n+static tree copy_default_args_to_explicit_spec_1 (tree, tree);\n+static void copy_default_args_to_explicit_spec (tree);\n+static int invalid_nontype_parm_type_p (tree, tsubst_flags_t);\n static int eq_local_specializations (const void *, const void *);\n static bool dependent_type_p_r (tree);\n static bool dependent_template_id_p (tree, tree);\n@@ -186,8 +181,7 @@ static tree tsubst_copy_and_build (tree, tree, tsubst_flags_t, tree);\n    this is used instead of the context of T.  */\n \n void\n-push_access_scope_real (t, args, context)\n-  tree t, args, context;\n+push_access_scope_real (tree t, tree args, tree context)\n {\n   if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n     {\n@@ -234,8 +228,7 @@ push_access_scope_real (t, args, context)\n /* Like push_access_scope_real, but always uses DECL_CONTEXT.  */\n \n void\n-push_access_scope (t)\n-  tree t;\n+push_access_scope (tree t)\n {\n   push_access_scope_real (t, NULL_TREE, NULL_TREE);\n }\n@@ -244,8 +237,7 @@ push_access_scope (t)\n    are processing.  */\n \n void\n-pop_access_scope (t)\n-  tree t;\n+pop_access_scope (tree t)\n {\n   if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n     {\n@@ -265,8 +257,7 @@ pop_access_scope (t)\n    itself is returned.  */\n \n tree\n-finish_member_template_decl (decl)\n-  tree decl;\n+finish_member_template_decl (tree decl)\n {\n   if (decl == error_mark_node)\n     return error_mark_node;\n@@ -326,9 +317,7 @@ finish_member_template_decl (decl)\n    always safe.  */\n \n static int \n-template_class_depth_real (type, count_specializations)\n-     tree type;\n-     int count_specializations;\n+template_class_depth_real (tree type, int count_specializations)\n {\n   int depth;\n \n@@ -365,8 +354,7 @@ template_class_depth_real (type, count_specializations)\n    the depth.  */\n \n int \n-template_class_depth (type)\n-     tree type;\n+template_class_depth (tree type)\n {\n   return template_class_depth_real (type, /*count_specializations=*/0);\n }\n@@ -375,8 +363,7 @@ template_class_depth (type)\n    needs us to push template parms.  */\n \n static int\n-inline_needs_template_parms (decl)\n-     tree decl;\n+inline_needs_template_parms (tree decl)\n {\n   if (! DECL_TEMPLATE_INFO (decl))\n     return 0;\n@@ -391,9 +378,7 @@ inline_needs_template_parms (decl)\n    innermost first.  */\n \n static void\n-push_inline_template_parms_recursive (parmlist, levels)\n-     tree parmlist;\n-     int levels;\n+push_inline_template_parms_recursive (tree parmlist, int levels)\n {\n   tree parms = TREE_VALUE (parmlist);\n   int i;\n@@ -446,8 +431,7 @@ push_inline_template_parms_recursive (parmlist, levels)\n    a friend template defined in a class definition.  */\n \n void\n-maybe_begin_member_template_processing (decl)\n-     tree decl;\n+maybe_begin_member_template_processing (tree decl)\n {\n   tree parms;\n   int levels = 0;\n@@ -479,7 +463,7 @@ maybe_begin_member_template_processing (decl)\n /* Undo the effects of begin_member_template_processing.  */\n \n void \n-maybe_end_member_template_processing ()\n+maybe_end_member_template_processing (void)\n {\n   int i;\n \n@@ -513,8 +497,7 @@ maybe_end_member_template_processing ()\n    C<int>::f(U)' is considered a member template.  */\n \n int\n-is_member_template (t)\n-     tree t;\n+is_member_template (tree t)\n {\n   if (!DECL_FUNCTION_TEMPLATE_P (t))\n     /* Anything that isn't a function or a template function is\n@@ -539,8 +522,7 @@ is_member_template (t)\n    a member template.  */\n \n int\n-is_member_template_class (t)\n-     tree t;\n+is_member_template_class (tree t)\n {\n   if (!DECL_CLASS_TEMPLATE_P (t))\n     /* Anything that isn't a class template, is certainly not a member\n@@ -564,9 +546,7 @@ is_member_template_class (t)\n    but has as its innermost set of arguments the EXTRA_ARGS.  */\n \n static tree\n-add_to_template_args (args, extra_args)\n-     tree args;\n-     tree extra_args;\n+add_to_template_args (tree args, tree extra_args)\n {\n   tree new_args;\n   int extra_depth;\n@@ -593,9 +573,7 @@ add_to_template_args (args, extra_args)\n    partial instantiation.  */\n \n static tree\n-add_outermost_template_args (args, extra_args)\n-     tree args;\n-     tree extra_args;\n+add_outermost_template_args (tree args, tree extra_args)\n {\n   tree new_args;\n \n@@ -623,9 +601,7 @@ add_outermost_template_args (args, extra_args)\n /* Return the N levels of innermost template arguments from the ARGS.  */\n \n tree\n-get_innermost_template_args (args, n)\n-     tree args;\n-     int n;\n+get_innermost_template_args (tree args, int n)\n {\n   tree new_args;\n   int extra_levels;\n@@ -657,7 +633,7 @@ get_innermost_template_args (args, n)\n    the parms.  */\n \n void\n-begin_template_parm_list ()\n+begin_template_parm_list (void)\n {\n   /* We use a non-tag-transparent scope here, which causes pushtag to\n      put tags in this scope, rather than in the enclosing class or\n@@ -683,7 +659,7 @@ begin_template_parm_list ()\n    invalid to declare a specialization here, an error is reported.  */\n \n static void\n-check_specialization_scope ()\n+check_specialization_scope (void)\n {\n   tree scope = current_scope ();\n \n@@ -715,7 +691,7 @@ check_specialization_scope ()\n /* We've just seen template <>.  */\n \n void\n-begin_specialization ()\n+begin_specialization (void)\n {\n   begin_scope (sk_template_spec);\n   note_template_header (1);\n@@ -726,7 +702,7 @@ begin_specialization ()\n    template<>.  */\n \n void \n-end_specialization ()\n+end_specialization (void)\n {\n   finish_scope ();\n   reset_specialization ();\n@@ -736,7 +712,7 @@ end_specialization ()\n    function specialization.  */\n \n void\n-reset_specialization ()\n+reset_specialization (void)\n {\n   processing_specialization = 0;\n   template_header_count = 0;\n@@ -746,8 +722,7 @@ reset_specialization ()\n    it was of the form template <>.  */\n \n static void \n-note_template_header (specialization)\n-     int specialization;\n+note_template_header (int specialization)\n {\n   processing_specialization = specialization;\n   template_header_count++;\n@@ -756,15 +731,15 @@ note_template_header (specialization)\n /* We're beginning an explicit instantiation.  */\n \n void\n-begin_explicit_instantiation ()\n+begin_explicit_instantiation (void)\n {\n   my_friendly_assert (!processing_explicit_instantiation, 20020913);\n   processing_explicit_instantiation = true;\n }\n \n \n void\n-end_explicit_instantiation ()\n+end_explicit_instantiation (void)\n {\n   my_friendly_assert(processing_explicit_instantiation, 20020913);\n   processing_explicit_instantiation = false;\n@@ -774,8 +749,7 @@ end_explicit_instantiation ()\n    is a partial specialization.  Do appropriate error-checking.  */\n \n void \n-maybe_process_partial_specialization (type)\n-     tree type;\n+maybe_process_partial_specialization (tree type)\n {\n   /* TYPE maybe an ERROR_MARK_NODE.  */\n   tree context = TYPE_P (type) ? TYPE_CONTEXT (type) : NULL_TREE;\n@@ -878,9 +852,7 @@ maybe_process_partial_specialization (type)\n    templates with more than one level of parameters.  */\n    \n static tree\n-retrieve_specialization (tmpl, args)\n-     tree tmpl;\n-     tree args;\n+retrieve_specialization (tree tmpl, tree args)\n {\n   tree s;\n \n@@ -904,8 +876,7 @@ retrieve_specialization (tmpl, args)\n /* Like retrieve_specialization, but for local declarations.  */\n \n static tree\n-retrieve_local_specialization (tmpl)\n-     tree tmpl;\n+retrieve_local_specialization (tree tmpl)\n {\n   tree spec = \n     (tree) htab_find_with_hash (local_specializations, tmpl,\n@@ -916,9 +887,7 @@ retrieve_local_specialization (tmpl)\n /* Returns nonzero iff DECL is a specialization of TMPL.  */\n \n int\n-is_specialization_of (decl, tmpl)\n-     tree decl;\n-     tree tmpl;\n+is_specialization_of (tree decl, tree tmpl)\n {\n   tree t;\n \n@@ -950,10 +919,7 @@ is_specialization_of (decl, tmpl)\n    declaration, if available.  */\n \n static tree\n-register_specialization (spec, tmpl, args)\n-     tree spec;\n-     tree tmpl;\n-     tree args;\n+register_specialization (tree spec, tree tmpl, tree args)\n {\n   tree s;\n \n@@ -1063,9 +1029,7 @@ register_specialization (spec, tmpl, args)\n    TMPL.  */\n \n static int\n-unregister_specialization (spec, tmpl)\n-     tree spec;\n-     tree tmpl;\n+unregister_specialization (tree spec, tree tmpl)\n {\n   tree* s;\n \n@@ -1103,9 +1067,7 @@ hash_local_specialization (const void* p1)\n    registering SPEC, an instantiation of TMPL.  */\n \n static void\n-register_local_specialization (spec, tmpl)\n-     tree spec;\n-     tree tmpl;\n+register_local_specialization (tree spec, tree tmpl)\n {\n   void **slot;\n \n@@ -1117,8 +1079,7 @@ register_local_specialization (spec, tmpl)\n /* Print the list of candidate FNS in an error message.  */\n \n void\n-print_candidates (fns)\n-     tree fns;\n+print_candidates (tree fns)\n {\n   tree fn;\n \n@@ -1150,12 +1111,10 @@ print_candidates (fns)\n    issued.  The error_mark_node is returned to indicate failure.  */\n \n static tree\n-determine_specialization (template_id, decl, targs_out, \n-\t\t\t  need_member_template)\n-     tree template_id;\n-     tree decl;\n-     tree* targs_out;\n-     int need_member_template;\n+determine_specialization (tree template_id, \n+                          tree decl, \n+                          tree* targs_out, \n+\t\t\t  int need_member_template)\n {\n   tree fns;\n   tree targs;\n@@ -1362,10 +1321,8 @@ determine_specialization (template_id, decl, targs_out,\n    TMPL_TYPES.  */\n       \n static tree\n-copy_default_args_to_explicit_spec_1 (spec_types,\n-\t\t\t\t      tmpl_types)\n-     tree spec_types;\n-     tree tmpl_types;\n+copy_default_args_to_explicit_spec_1 (tree spec_types,\n+\t\t\t\t      tree tmpl_types)\n {\n   tree new_spec_types;\n \n@@ -1398,8 +1355,7 @@ copy_default_args_to_explicit_spec_1 (spec_types,\n    is consistent with how implicit instantiations are handled.  */\n \n static void\n-copy_default_args_to_explicit_spec (decl)\n-     tree decl;\n+copy_default_args_to_explicit_spec (tree decl)\n {\n   tree tmpl;\n   tree spec_types;\n@@ -1516,11 +1472,10 @@ copy_default_args_to_explicit_spec (decl)\n    for that template.  */\n \n tree\n-check_explicit_specialization (declarator, decl, template_count, flags)\n-     tree declarator;\n-     tree decl;\n-     int template_count;\n-     int flags;\n+check_explicit_specialization (tree declarator, \n+                               tree decl, \n+                               int template_count, \n+                               int flags)\n {\n   int have_def = flags & 2;\n   int is_friend = flags & 4;\n@@ -1912,8 +1867,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n    and such is reasonable.  Issue error messages if not.  */\n \n void\n-maybe_check_template_type (type)\n-     tree type;\n+maybe_check_template_type (tree type)\n {\n   if (template_header_count)\n     {\n@@ -1956,9 +1910,7 @@ maybe_check_template_type (type)\n    parameters.  These are represented in the same format used for\n    DECL_TEMPLATE_PARMS.  */\n \n-int comp_template_parms (parms1, parms2)\n-     tree parms1;\n-     tree parms2;\n+int comp_template_parms (tree parms1, tree parms2)\n {\n   tree p1;\n   tree p2;\n@@ -2009,8 +1961,7 @@ int comp_template_parms (parms1, parms2)\n    scope (including nested scopes).  */\n \n void\n-check_template_shadow (decl)\n-     tree decl;\n+check_template_shadow (tree decl)\n {\n   tree olddecl;\n \n@@ -2051,12 +2002,11 @@ check_template_shadow (decl)\n    ORIG_LEVEL, DECL, and TYPE.  */\n \n static tree\n-build_template_parm_index (index, level, orig_level, decl, type)\n-     int index;\n-     int level;\n-     int orig_level;\n-     tree decl;\n-     tree type;\n+build_template_parm_index (int index, \n+                           int level, \n+                           int orig_level, \n+                           tree decl, \n+                           tree type)\n {\n   tree t = make_node (TEMPLATE_PARM_INDEX);\n   TEMPLATE_PARM_IDX (t) = index;\n@@ -2076,10 +2026,7 @@ build_template_parm_index (index, level, orig_level, decl, type)\n    new one is created.  */\n \n static tree \n-reduce_template_parm_level (index, type, levels)\n-     tree index;\n-     tree type;\n-     int levels;\n+reduce_template_parm_level (tree index, tree type, int levels)\n {\n   if (TEMPLATE_PARM_DESCENDANTS (index) == NULL_TREE\n       || (TEMPLATE_PARM_LEVEL (TEMPLATE_PARM_DESCENDANTS (index))\n@@ -2112,8 +2059,7 @@ reduce_template_parm_level (index, type, levels)\n    LIST being built.  */\n \n tree\n-process_template_parm (list, next)\n-     tree list, next;\n+process_template_parm (tree list, tree next)\n {\n   tree parm;\n   tree decl = 0;\n@@ -2206,8 +2152,7 @@ process_template_parm (list, next)\n    as PARM_DECLs.  */\n \n tree\n-end_template_parm_list (parms)\n-     tree parms;\n+end_template_parm_list (tree parms)\n {\n   int nparms;\n   tree parm, next;\n@@ -2232,7 +2177,7 @@ end_template_parm_list (parms)\n /* end_template_decl is called after a template declaration is seen.  */\n \n void\n-end_template_decl ()\n+end_template_decl (void)\n {\n   reset_specialization ();\n \n@@ -2250,7 +2195,7 @@ end_template_decl ()\n    The innermost PARMS are given first.  */\n \n tree\n-current_template_args ()\n+current_template_args (void)\n {\n   tree header;\n   tree args = NULL_TREE;\n@@ -2302,9 +2247,7 @@ current_template_args ()\n    template PARMS.  Used by push_template_decl below.  */\n \n static tree\n-build_template_decl (decl, parms)\n-     tree decl;\n-     tree parms;\n+build_template_decl (tree decl, tree parms)\n {\n   tree tmpl = build_lang_decl (TEMPLATE_DECL, DECL_NAME (decl), NULL_TREE);\n   DECL_TEMPLATE_PARMS (tmpl) = parms;\n@@ -2352,9 +2295,7 @@ struct template_parm_data\n    appropriately.  */\n \n static int\n-mark_template_parm (t, data)\n-     tree t;\n-     void* data;\n+mark_template_parm (tree t, void* data)\n {\n   int level;\n   int idx;\n@@ -2385,8 +2326,7 @@ mark_template_parm (t, data)\n /* Process the partial specialization DECL.  */\n \n static tree\n-process_partial_specialization (decl)\n-     tree decl;\n+process_partial_specialization (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n   tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);\n@@ -2564,11 +2504,7 @@ process_partial_specialization (decl)\n    IS_PARTIAL is nonzero if DECL is a partial specialization.  */\n \n static void\n-check_default_tmpl_args (decl, parms, is_primary, is_partial)\n-     tree decl;\n-     tree parms;\n-     int is_primary;\n-     int is_partial;\n+check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n {\n   const char *msg;\n   int last_level_to_check;\n@@ -2711,9 +2647,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n    parameter of that level, return nonzero.  */\n \n static int\n-template_parm_this_level_p (t, data)\n-     tree t;\n-     void *data;\n+template_parm_this_level_p (tree t, void* data)\n {\n   int this_level = *(int *)data;\n   int level;\n@@ -2733,9 +2667,7 @@ template_parm_this_level_p (t, data)\n    If IS_FRIEND is nonzero, DECL is a friend declaration.  */\n \n tree\n-push_template_decl_real (decl, is_friend)\n-     tree decl;\n-     int is_friend;\n+push_template_decl_real (tree decl, int is_friend)\n {\n   tree tmpl;\n   tree args;\n@@ -2980,8 +2912,7 @@ push_template_decl_real (decl, is_friend)\n }\n \n tree\n-push_template_decl (decl)\n-     tree decl;\n+push_template_decl (tree decl)\n {\n   return push_template_decl_real (decl, 0);\n }\n@@ -2993,9 +2924,7 @@ push_template_decl (decl)\n      template <class T> struct S {};  */\n \n void \n-redeclare_class_template (type, parms)\n-     tree type;\n-     tree parms;\n+redeclare_class_template (tree type, tree parms)\n {\n   tree tmpl;\n   tree tmpl_parms;\n@@ -3074,9 +3003,7 @@ redeclare_class_template (type, parms)\n    parameters.  */\n \n static tree\n-convert_nontype_argument (type, expr)\n-     tree type;\n-     tree expr;\n+convert_nontype_argument (tree type, tree expr)\n {\n   tree expr_type = TREE_TYPE (expr);\n \n@@ -3430,11 +3357,11 @@ convert_nontype_argument (type, expr)\n    substitute the TT parameter.  */\n \n static int\n-coerce_template_template_parms (parm_parms, arg_parms, complain, \n-\t\t\t\tin_decl, outer_args)\n-     tree parm_parms, arg_parms;\n-     tsubst_flags_t complain;\n-     tree in_decl, outer_args;\n+coerce_template_template_parms (tree parm_parms, \n+                                tree arg_parms, \n+                                tsubst_flags_t complain, \n+\t\t\t\ttree in_decl,\n+                                tree outer_args)\n {\n   int nparms, nargs, i;\n   tree parm, arg;\n@@ -3508,13 +3435,12 @@ coerce_template_template_parms (parm_parms, arg_parms, complain,\n    the full set of template arguments deduced so far.  */\n \n static tree\n-convert_template_argument (parm, arg, args, complain, i, in_decl)\n-     tree parm;\n-     tree arg;\n-     tree args;\n-     tsubst_flags_t complain;\n-     int i;\n-     tree in_decl;\n+convert_template_argument (tree parm, \n+                           tree arg, \n+                           tree args, \n+                           tsubst_flags_t complain, \n+                           int i, \n+                           tree in_decl)\n {\n   tree val;\n   tree inner_args;\n@@ -3700,13 +3626,11 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n    deduction for any unspecified trailing arguments.  */\n    \n static tree\n-coerce_template_parms (parms, args, in_decl,\n-\t\t       complain,\n-\t\t       require_all_arguments)\n-     tree parms, args;\n-     tree in_decl;\n-     tsubst_flags_t complain;\n-     int require_all_arguments;\n+coerce_template_parms (tree parms, \n+                       tree args, \n+                       tree in_decl,\n+\t\t       tsubst_flags_t complain,\n+\t\t       int require_all_arguments)\n {\n   int nparms, nargs, i, lost = 0;\n   tree inner_args;\n@@ -3797,8 +3721,7 @@ coerce_template_parms (parms, args, in_decl,\n /* Returns 1 if template args OT and NT are equivalent.  */\n \n static int\n-template_args_equal (ot, nt)\n-     tree ot, nt;\n+template_args_equal (tree ot, tree nt)\n {\n   if (nt == ot)\n     return 1;\n@@ -3818,8 +3741,7 @@ template_args_equal (ot, nt)\n    of template arguments.  Returns 0 otherwise.  */\n \n int\n-comp_template_args (oldargs, newargs)\n-     tree oldargs, newargs;\n+comp_template_args (tree oldargs, tree newargs)\n {\n   int i;\n \n@@ -3841,9 +3763,7 @@ comp_template_args (oldargs, newargs)\n    for the instantiation.  */\n \n static char *\n-mangle_class_name_for_template (name, parms, arglist)\n-     const char *name;\n-     tree parms, arglist;\n+mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n {\n   static struct obstack scratch_obstack;\n   static char *scratch_firstobj;\n@@ -3931,8 +3851,7 @@ mangle_class_name_for_template (name, parms, arglist)\n }\n \n static tree\n-classtype_mangled_name (t)\n-     tree t;\n+classtype_mangled_name (tree t)\n {\n   if (CLASSTYPE_TEMPLATE_INFO (t)\n       /* Specializations have already had their names set up in\n@@ -3960,8 +3879,7 @@ classtype_mangled_name (t)\n }\n \n static void\n-add_pending_template (d)\n-     tree d;\n+add_pending_template (tree d)\n {\n   tree ti = (TYPE_P (d)\n \t     ? CLASSTYPE_TEMPLATE_INFO (d)\n@@ -4000,8 +3918,7 @@ add_pending_template (d)\n    documentation for TEMPLATE_ID_EXPR.  */\n \n tree\n-lookup_template_function (fns, arglist)\n-     tree fns, arglist;\n+lookup_template_function (tree fns, tree arglist)\n {\n   tree type;\n \n@@ -4045,8 +3962,7 @@ lookup_template_function (fns, arglist)\n    DECL is returned.  */\n \n tree\n-maybe_get_template_decl_from_type_decl (decl)\n-     tree decl;\n+maybe_get_template_decl_from_type_decl (tree decl)\n {\n   return (decl != NULL_TREE\n \t  && TREE_CODE (decl) == TYPE_DECL \n@@ -4077,12 +3993,12 @@ maybe_get_template_decl_from_type_decl (decl)\n    being instantiated.  */\n \n tree\n-lookup_template_class (d1, arglist, in_decl, context, entering_scope, complain)\n-     tree d1, arglist;\n-     tree in_decl;\n-     tree context;\n-     int entering_scope;\n-     tsubst_flags_t complain;\n+lookup_template_class (tree d1, \n+                       tree arglist, \n+                       tree in_decl, \n+                       tree context, \n+                       int entering_scope, \n+                       tsubst_flags_t complain)\n {\n   tree template = NULL_TREE, parmlist;\n   tree t;\n@@ -4539,10 +4455,7 @@ struct pair_fn_data\n /* Called from for_each_template_parm via walk_tree.  */\n \n static tree\n-for_each_template_parm_r (tp, walk_subtrees, d)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *d;\n+for_each_template_parm_r (tree* tp, int* walk_subtrees, void* d)\n {\n   tree t = *tp;\n   struct pair_fn_data *pfd = (struct pair_fn_data *) d;\n@@ -4730,11 +4643,7 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n    considered to be the function which always returns 1.  */\n \n static int\n-for_each_template_parm (t, fn, data, visited)\n-     tree t;\n-     tree_fn_t fn;\n-     void* data;\n-     htab_t visited;\n+for_each_template_parm (tree t, tree_fn_t fn, void* data, htab_t visited)\n {\n   struct pair_fn_data pfd;\n   int result;\n@@ -4766,8 +4675,7 @@ for_each_template_parm (t, fn, data, visited)\n }\n \n int\n-uses_template_parms (t)\n-     tree t;\n+uses_template_parms (tree t)\n {\n   return for_each_template_parm (t, 0, 0, NULL);\n }\n@@ -4784,8 +4692,7 @@ static int last_template_error_tick;\n    for diagnostics and to restore it later.  */\n \n int\n-push_tinst_level (d)\n-     tree d;\n+push_tinst_level (tree d)\n {\n   tree new;\n \n@@ -4824,7 +4731,7 @@ push_tinst_level (d)\n    context.  */\n \n void\n-pop_tinst_level ()\n+pop_tinst_level (void)\n {\n   tree old = current_tinst_level;\n \n@@ -4844,8 +4751,7 @@ pop_tinst_level ()\n    is one step out from LEVEL.  */\n \n static void\n-reopen_tinst_level (level)\n-     tree level;\n+reopen_tinst_level (tree level)\n {\n   tree t;\n \n@@ -4861,7 +4767,7 @@ reopen_tinst_level (level)\n    -falt-external-templates.  */\n \n tree\n-tinst_for_decl ()\n+tinst_for_decl (void)\n {\n   tree p = current_tinst_level;\n \n@@ -4877,9 +4783,7 @@ tinst_for_decl ()\n    Returns an appropriate tsubst'd friend declaration.  */\n \n static tree\n-tsubst_friend_function (decl, args)\n-     tree decl;\n-     tree args;\n+tsubst_friend_function (tree decl, tree args)\n {\n   tree new_friend;\n   location_t saved_loc = input_location;\n@@ -5102,9 +5006,7 @@ tsubst_friend_function (decl, args)\n    failure.  */\n \n static tree\n-tsubst_friend_class (friend_tmpl, args)\n-     tree friend_tmpl;\n-     tree args;\n+tsubst_friend_class (tree friend_tmpl, tree args)\n {\n   tree friend_type;\n   tree tmpl;\n@@ -5193,8 +5095,7 @@ tsubst_friend_class (friend_tmpl, args)\n    Otherwise returns one.  */\n \n static int\n-can_complete_type_without_circularity (type)\n-     tree type;\n+can_complete_type_without_circularity (tree type)\n {\n   if (type == NULL_TREE || type == error_mark_node)\n     return 0;\n@@ -5209,8 +5110,7 @@ can_complete_type_without_circularity (type)\n }\n \n tree\n-instantiate_class_template (type)\n-     tree type;\n+instantiate_class_template (tree type)\n {\n   tree template, args, pattern, t, member;\n   tree typedecl;\n@@ -5594,8 +5494,7 @@ instantiate_class_template (type)\n }\n \n static int\n-list_eq (t1, t2)\n-     tree t1, t2;\n+list_eq (tree t1, tree t2)\n {\n   if (t1 == NULL_TREE)\n     return t2 == NULL_TREE;\n@@ -5613,8 +5512,7 @@ list_eq (t1, t2)\n    arguments, fold it like we weren't in the body of a template.  */\n \n static tree\n-maybe_fold_nontype_arg (arg)\n-     tree arg;\n+maybe_fold_nontype_arg (tree arg)\n {\n   if (arg && !TYPE_P (arg) && !uses_template_parms (arg))\n     {\n@@ -5667,10 +5565,7 @@ maybe_fold_nontype_args (tree targs)\n /* Substitute ARGS into the vector of template arguments T.  */\n \n static tree\n-tsubst_template_arg_vector (t, args, complain)\n-     tree t;\n-     tree args;\n-     tsubst_flags_t complain;\n+tsubst_template_arg_vector (tree t, tree args, tsubst_flags_t complain)\n {\n   int len = TREE_VEC_LENGTH (t), need_new = 0, i;\n   tree *elts = (tree *) alloca (len * sizeof (tree));\n@@ -5713,10 +5608,7 @@ tsubst_template_arg_vector (t, args, complain)\n    result will be `template <int*, double, class V>'.  */\n \n static tree\n-tsubst_template_parms (parms, args, complain)\n-     tree parms;\n-     tree args;\n-     tsubst_flags_t complain;\n+tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n {\n   tree r = NULL_TREE;\n   tree* new_parms;\n@@ -5760,12 +5652,11 @@ tsubst_template_parms (parms, args, complain)\n    we are presently tsubst'ing.  Return the substituted value.  */\n \n static tree\n-tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n-     tree t;\n-     tree args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n-     int entering_scope;\n+tsubst_aggr_type (tree t, \n+                  tree args, \n+                  tsubst_flags_t complain, \n+                  tree in_decl, \n+                  int entering_scope)\n {\n   if (t == NULL_TREE)\n     return NULL_TREE;\n@@ -5826,10 +5717,7 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n    FN), which has the indicated TYPE.  */\n \n tree\n-tsubst_default_argument (fn, type, arg)\n-     tree fn;\n-     tree type;\n-     tree arg;\n+tsubst_default_argument (tree fn, tree type, tree arg)\n {\n   /* This default argument came from a template.  Instantiate the\n      default argument here, not in tsubst.  In the case of\n@@ -5865,8 +5753,7 @@ tsubst_default_argument (fn, type, arg)\n /* Substitute into all the default arguments for FN.  */\n \n static void\n-tsubst_default_arguments (fn)\n-     tree fn;\n+tsubst_default_arguments (tree fn)\n {\n   tree arg;\n   tree tmpl_args;\n@@ -5893,11 +5780,7 @@ tsubst_default_arguments (fn)\n    and warning messages under control of COMPLAIN.  */\n \n static tree\n-tsubst_decl (t, args, type, complain)\n-     tree t;\n-     tree args;\n-     tree type;\n-     tsubst_flags_t complain;\n+tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n {\n   location_t saved_loc;\n   tree r = NULL_TREE;\n@@ -6379,11 +6262,10 @@ tsubst_decl (t, args, type, complain)\n /* Substitue into the ARG_TYPES of a function type.  */\n \n static tree\n-tsubst_arg_types (arg_types, args, complain, in_decl)\n-     tree arg_types;\n-     tree args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst_arg_types (tree arg_types, \n+                  tree args, \n+                  tsubst_flags_t complain, \n+                  tree in_decl)\n {\n   tree remaining_arg_types;\n   tree type;\n@@ -6440,11 +6322,10 @@ tsubst_arg_types (arg_types, args, complain, in_decl)\n      results in an invalid type.]  */\n \n static tree\n-tsubst_function_type (t, args, complain, in_decl)\n-     tree t;\n-     tree args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst_function_type (tree t, \n+                      tree args, \n+                      tsubst_flags_t complain, \n+                      tree in_decl)\n {\n   tree return_type;\n   tree arg_types;\n@@ -6497,11 +6378,10 @@ tsubst_function_type (t, args, complain, in_decl)\n /* Substitute into the PARMS of a call-declarator.  */\n \n static tree\n-tsubst_call_declarator_parms (parms, args, complain, in_decl)\n-     tree parms;\n-     tree args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst_call_declarator_parms (tree parms, \n+                              tree args, \n+                              tsubst_flags_t complain, \n+                              tree in_decl)\n {\n   tree new_parms;\n   tree type;\n@@ -6548,10 +6428,7 @@ tsubst_call_declarator_parms (parms, args, complain, in_decl)\n    for expressions, use tsubst_expr or tsubst_copy.  */\n \n static tree\n-tsubst (t, args, complain, in_decl)\n-     tree t, args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree type, r;\n \n@@ -7183,10 +7060,7 @@ tsubst (t, args, complain, in_decl)\n    tsubst_expr.  */\n \n static tree\n-tsubst_copy (t, args, complain, in_decl)\n-     tree t, args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   enum tree_code code;\n   tree r;\n@@ -7596,10 +7470,7 @@ tsubst_copy (t, args, complain, in_decl)\n    processing.  */\n \n static tree\n-tsubst_expr (t, args, complain, in_decl)\n-     tree t, args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n   tree stmt, tmp;\n \n@@ -7923,10 +7794,10 @@ tsubst_expr (t, args, complain, in_decl)\n    analysis.  */\n \n static tree\n-tsubst_copy_and_build (t, args, complain, in_decl)\n-     tree t, args;\n-     tsubst_flags_t complain;\n-     tree in_decl;\n+tsubst_copy_and_build (tree t, \n+                       tree args, \n+                       tsubst_flags_t complain, \n+                       tree in_decl)\n {\n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n@@ -8430,9 +8301,7 @@ tsubst_copy_and_build (t, args, complain, in_decl)\n    Emit an error under control of COMPLAIN, and return TRUE on error. */\n \n static bool\n-check_instantiated_args (tmpl, args, complain)\n-     tree tmpl, args;\n-     tsubst_flags_t complain;\n+check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n {\n   int ix, len = DECL_NTPARMS (tmpl);\n   bool result = false;\n@@ -8489,9 +8358,7 @@ check_instantiated_args (tmpl, args, complain)\n    the template arguments in TARG_PTR.  */\n \n tree\n-instantiate_template (tmpl, targ_ptr, complain)\n-     tree tmpl, targ_ptr;\n-     tsubst_flags_t complain;\n+instantiate_template (tree tmpl, tree targ_ptr, tsubst_flags_t complain)\n {\n   tree fndecl;\n   tree gen_tmpl;\n@@ -8616,11 +8483,13 @@ instantiate_template (tmpl, targ_ptr, complain)\n    partial ordering in [temp.func.order]/6).  */\n \n int\n-fn_type_unification (fn, explicit_targs, targs, args, return_type,\n-\t\t     strict, len)\n-     tree fn, explicit_targs, targs, args, return_type;\n-     unification_kind_t strict;\n-     int len;\n+fn_type_unification (tree fn, \n+                     tree explicit_targs, \n+                     tree targs, \n+                     tree args, \n+                     tree return_type,\n+\t\t     unification_kind_t strict, \n+                     int len)\n {\n   tree parms;\n   tree fntype;\n@@ -8714,10 +8583,9 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    initialized with the result of the conversion function.  */\n \n static int\n-maybe_adjust_types_for_deduction (strict, parm, arg)\n-     unification_kind_t strict;\n-     tree* parm;\n-     tree* arg;\n+maybe_adjust_types_for_deduction (unification_kind_t strict, \n+                                  tree* parm, \n+                                  tree* arg)\n {\n   int result = 0;\n   \n@@ -8821,12 +8689,14 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n    template).  */\n \n static int\n-type_unification_real (tparms, targs, xparms, xargs, subr,\n-\t\t       strict, allow_incomplete, xlen)\n-     tree tparms, targs, xparms, xargs;\n-     int subr;\n-     unification_kind_t strict;\n-     int allow_incomplete, xlen;\n+type_unification_real (tree tparms, \n+                       tree targs, \n+                       tree xparms, \n+                       tree xargs, \n+                       int subr,\n+\t\t       unification_kind_t strict, \n+                       int allow_incomplete, \n+                       int xlen)\n {\n   tree parm, arg;\n   int i;\n@@ -8995,11 +8865,12 @@ type_unification_real (tparms, targs, xparms, xargs, subr,\n    succeeds, we go with that.  Modifies TARGS and returns 0 on success.  */\n \n static int\n-resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n-\t\t\t\tsub_strict)\n-     tree tparms, targs, parm, arg;\n-     unification_kind_t strict;\n-     int sub_strict;\n+resolve_overloaded_unification (tree tparms, \n+                                tree targs,\n+                                tree parm,\n+                                tree arg, \n+                                unification_kind_t strict,\n+\t\t\t\tint sub_strict)\n {\n   tree tempargs = copy_node (targs);\n   int good = 0;\n@@ -9091,11 +8962,13 @@ resolve_overloaded_unification (tparms, targs, parm, arg, strict,\n    Returns 1 on success.  */\n \n static int\n-try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n-\t\t  sub_strict)\n-     tree tparms, orig_targs, targs, parm, arg;\n-     unification_kind_t strict;\n-     int sub_strict;\n+try_one_overload (tree tparms,\n+                  tree orig_targs,\n+                  tree targs, \n+                  tree parm, \n+                  tree arg, \n+                  unification_kind_t strict,\n+\t\t  int sub_strict)\n {\n   int nargs;\n   tree tempargs;\n@@ -9173,8 +9046,7 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n    ARGS contains template arguments from all levels.  */\n \n static int\n-verify_class_unification (targs, parms, args)\n-     tree targs, parms, args;\n+verify_class_unification (tree targs, tree parms, tree args)\n {\n   parms = tsubst (parms, add_outermost_template_args (args, targs),\n   \t\t  tf_none, NULL_TREE);\n@@ -9190,11 +9062,7 @@ verify_class_unification (targs, parms, args)\n    TARGS are as for unify.  */\n \n static tree\n-try_class_unification (tparms, targs, parm, arg)\n-     tree tparms;\n-     tree targs;\n-     tree parm;\n-     tree arg;\n+try_class_unification (tree tparms, tree targs, tree parm, tree arg)\n {\n   tree copy_of_targs;\n \n@@ -9247,14 +9115,12 @@ try_class_unification (tparms, targs, parm, arg)\n    for the base class of ARG that we are currently examining.  */\n \n static tree\n-get_template_base_recursive (tparms, targs, parm,\n-\t\t\t     arg_binfo, rval, flags)\n-     tree tparms;\n-     tree targs;\n-     tree arg_binfo;\n-     tree rval;\n-     tree parm;\n-     int flags;\n+get_template_base_recursive (tree tparms, \n+                             tree targs, \n+                             tree parm,\n+                             tree arg_binfo, \n+                             tree rval, \n+                             int flags)\n {\n   tree binfos;\n   int i, n_baselinks;\n@@ -9323,11 +9189,7 @@ get_template_base_recursive (tparms, targs, parm,\n    as well as a plain template type.  Used by unify.  */\n \n static tree\n-get_template_base (tparms, targs, parm, arg)\n-     tree tparms;\n-     tree targs;\n-     tree parm;\n-     tree arg;\n+get_template_base (tree tparms, tree targs, tree parm, tree arg)\n {\n   tree rval;\n   tree arg_binfo;\n@@ -9350,8 +9212,7 @@ get_template_base (tparms, targs, parm, arg)\n /* Returns the level of DECL, which declares a template parameter.  */\n \n static int\n-template_decl_level (decl)\n-     tree decl;\n+template_decl_level (tree decl)\n {\n   switch (TREE_CODE (decl))\n     {\n@@ -9373,10 +9234,7 @@ template_decl_level (decl)\n    Returns nonzero iff the unification is OK on that basis.*/\n \n static int\n-check_cv_quals_for_unify (strict, arg, parm)\n-     int strict;\n-     tree arg;\n-     tree parm;\n+check_cv_quals_for_unify (int strict, tree arg, tree parm)\n {\n   int arg_quals = cp_type_quals (arg);\n   int parm_quals = cp_type_quals (parm);\n@@ -9443,9 +9301,7 @@ check_cv_quals_for_unify (strict, arg, parm)\n        folding PARM.  */\n \n static int\n-unify (tparms, targs, parm, arg, strict)\n-     tree tparms, targs, parm, arg;\n-     int strict;\n+unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n {\n   int idx;\n   tree targ;\n@@ -9944,9 +9800,7 @@ unify (tparms, targs, parm, arg, strict)\n    instantiation of RESULT has been assigned to this file.  */\n \n void\n-mark_decl_instantiated (result, extern_p)\n-     tree result;\n-     int extern_p;\n+mark_decl_instantiated (tree result, int extern_p)\n {\n   /* We used to set this unconditionally; we moved that to\n      do_decl_instantiation so it wouldn't get set on members of\n@@ -9998,10 +9852,7 @@ mark_decl_instantiated (result, extern_p)\n    LEN is passed through to fn_type_unification.  */\n    \n int\n-more_specialized (pat1, pat2, deduce, len)\n-     tree pat1, pat2;\n-     int deduce;\n-     int len;\n+more_specialized (tree pat1, tree pat2, int deduce, int len)\n {\n   tree targs;\n   int winner = 0;\n@@ -10026,8 +9877,7 @@ more_specialized (pat1, pat2, deduce, len)\n    0 if neither is more specialized.  */\n    \n int\n-more_specialized_class (pat1, pat2)\n-     tree pat1, pat2;\n+more_specialized_class (tree pat1, tree pat2)\n {\n   tree targs;\n   int winner = 0;\n@@ -10052,9 +9902,12 @@ more_specialized_class (pat1, pat2)\n    found.  DEDUCE and LEN are passed through to fn_type_unification.  */\n    \n static tree\n-get_bindings_real (fn, decl, explicit_args, check_rettype, deduce, len)\n-     tree fn, decl, explicit_args;\n-     int check_rettype, deduce, len;\n+get_bindings_real (tree fn, \n+                   tree decl, \n+                   tree explicit_args, \n+                   int check_rettype, \n+                   int deduce, \n+                   int len)\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_tree_vec (ntparms);\n@@ -10109,8 +9962,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype, deduce, len)\n /* For most uses, we want to check the return type.  */\n \n tree \n-get_bindings (fn, decl, explicit_args)\n-     tree fn, decl, explicit_args;\n+get_bindings (tree fn, tree decl, tree explicit_args)\n {\n   return get_bindings_real (fn, decl, explicit_args, 1, DEDUCE_EXACT, -1);\n }\n@@ -10119,8 +9971,7 @@ get_bindings (fn, decl, explicit_args)\n    types.  */\n \n static tree\n-get_bindings_overload (fn, decl, explicit_args)\n-     tree fn, decl, explicit_args;\n+get_bindings_overload (tree fn, tree decl, tree explicit_args)\n {\n   return get_bindings_real (fn, decl, explicit_args, 0, DEDUCE_EXACT, -1);\n }\n@@ -10141,8 +9992,7 @@ get_bindings_overload (fn, decl, explicit_args)\n    is bound to `double'.  */\n \n static tree\n-get_class_bindings (tparms, parms, args)\n-     tree tparms, parms, args;\n+get_class_bindings (tree tparms, tree parms, tree args)\n {\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n   tree vec = make_tree_vec (ntparms);\n@@ -10169,8 +10019,7 @@ get_class_bindings (tparms, parms, args)\n    NULL_TREE is returned.  */\n \n tree\n-most_specialized_instantiation (instantiations)\n-     tree instantiations;\n+most_specialized_instantiation (tree instantiations)\n {\n   tree fn, champ;\n   int fate;\n@@ -10213,8 +10062,7 @@ most_specialized_instantiation (instantiations)\n    arguments EXPLICIT_ARGS.  */\n \n static tree\n-most_specialized (fns, decl, explicit_args)\n-     tree fns, decl, explicit_args;\n+most_specialized (tree fns, tree decl, tree explicit_args)\n {\n   tree candidates = NULL_TREE;\n   tree fn, args;\n@@ -10248,8 +10096,7 @@ most_specialized (fns, decl, explicit_args)\n    `template <class T> template <class U> S<T*>::f(U)'.  */\n \n tree\n-most_general_template (decl)\n-     tree decl;\n+most_general_template (tree decl)\n {\n   /* If DECL is a FUNCTION_DECL, find the TEMPLATE_DECL of which it is\n      an immediate specialization.  */\n@@ -10295,9 +10142,7 @@ most_general_template (decl)\n    error_mark_node if the choice is ambiguous.  */\n \n static tree\n-most_specialized_class (tmpl, args)\n-     tree tmpl;\n-     tree args;\n+most_specialized_class (tree tmpl, tree args)\n {\n   tree list = NULL_TREE;\n   tree t;\n@@ -10462,9 +10307,7 @@ do_decl_instantiation (tree decl, tree storage)\n }\n \n void\n-mark_class_instantiated (t, extern_p)\n-     tree t;\n-     int extern_p;\n+mark_class_instantiated (tree t, int extern_p)\n {\n   SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n   SET_CLASSTYPE_INTERFACE_KNOWN (t);\n@@ -10495,9 +10338,7 @@ bt_instantiate_type_proc (binding_entry entry, void *data)\n    since the standard is unclear (as detailed below).  */\n  \n void\n-do_type_instantiation (t, storage, complain)\n-     tree t, storage;\n-     tsubst_flags_t complain;\n+do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n {\n   int extern_p = 0;\n   int nomem_p = 0;\n@@ -10656,9 +10497,7 @@ do_type_instantiation (t, storage, complain)\n    to instantiate the DECL, we regenerate it.  */\n \n static void\n-regenerate_decl_from_template (decl, tmpl)\n-     tree decl;\n-     tree tmpl;\n+regenerate_decl_from_template (tree decl, tree tmpl)\n {\n   /* The most general version of TMPL.  */\n   tree gen_tmpl;\n@@ -10791,9 +10630,7 @@ template_for_substitution (tree decl)\n    instantiation now; we just have to do it sometime.  */\n \n tree\n-instantiate_decl (d, defer_ok)\n-     tree d;\n-     int defer_ok;\n+instantiate_decl (tree d, int defer_ok)\n {\n   tree tmpl = DECL_TI_TEMPLATE (d);\n   tree gen_args;\n@@ -11107,7 +10944,7 @@ instantiate_decl (d, defer_ok)\n    instantiate, and instantiate any we can.  */\n \n int\n-instantiate_pending_templates ()\n+instantiate_pending_templates (void)\n {\n   tree *t;\n   tree last = NULL_TREE;\n@@ -11196,8 +11033,7 @@ instantiate_pending_templates ()\n    instantiate_decl.  */\n \n static tree\n-tsubst_initializer_list (t, argvec)\n-     tree t, argvec;\n+tsubst_initializer_list (tree t, tree argvec)\n {\n   tree inits = NULL_TREE;\n \n@@ -11238,8 +11074,7 @@ tsubst_initializer_list (t, argvec)\n /* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */\n \n static void\n-set_current_access_from_decl (decl)\n-     tree decl;\n+set_current_access_from_decl (tree decl)\n {\n   if (TREE_PRIVATE (decl))\n     current_access_specifier = access_private_node;\n@@ -11254,10 +11089,7 @@ set_current_access_from_decl (decl)\n    start_enum) and ARGS are the template arguments to use.  */\n \n static void\n-tsubst_enum (tag, newtag, args)\n-     tree tag;\n-     tree newtag;\n-     tree args;\n+tsubst_enum (tree tag, tree newtag, tree args)\n {\n   tree e;\n \n@@ -11289,8 +11121,7 @@ tsubst_enum (tag, newtag, args)\n    the type.  */\n \n tree \n-get_mostly_instantiated_function_type (decl)\n-     tree decl;\n+get_mostly_instantiated_function_type (tree decl)\n {\n   tree fn_type;\n   tree tmpl;\n@@ -11354,20 +11185,20 @@ get_mostly_instantiated_function_type (decl)\n /* Return truthvalue if we're processing a template different from\n    the last one involved in diagnostics.  */\n int\n-problematic_instantiation_changed ()\n+problematic_instantiation_changed (void)\n {\n   return last_template_error_tick != tinst_level_tick;\n }\n \n /* Remember current template involved in diagnostics.  */\n void\n-record_last_problematic_instantiation ()\n+record_last_problematic_instantiation (void)\n {\n   last_template_error_tick = tinst_level_tick;\n }\n \n tree\n-current_instantiation ()\n+current_instantiation (void)\n {\n   return current_tinst_level;\n }\n@@ -11377,9 +11208,7 @@ current_instantiation ()\n    warning messages under control of COMPLAIN.  */\n \n static int\n-invalid_nontype_parm_type_p (type, complain)\n-     tree type;\n-     tsubst_flags_t complain;\n+invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n {\n   if (INTEGRAL_TYPE_P (type))\n     return 0;\n@@ -11610,8 +11439,7 @@ value_dependent_expression_p (tree expression)\n    [temp.dep.expr].  */\n \n bool\n-type_dependent_expression_p (expression)\n-     tree expression;\n+type_dependent_expression_p (tree expression)\n {\n   if (!processing_template_decl)\n     return false;"}, {"sha": "b400e4d5a44fc2a83d7a2488bed8423f180bcbec", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 106, "deletions": 204, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a978d72e699a1410ba46ca7630d6733e9420a50/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a978d72e699a1410ba46ca7630d6733e9420a50/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3a978d72e699a1410ba46ca7630d6733e9420a50", "patch": "@@ -51,16 +51,16 @@\n    parsing into this file; that will make implementing the new parser\n    much easier since it will be able to make use of these routines.  */\n \n-static tree maybe_convert_cond PARAMS ((tree));\n-static tree simplify_aggr_init_exprs_r PARAMS ((tree *, int *, void *));\n-static void emit_associated_thunks PARAMS ((tree));\n-static void genrtl_try_block PARAMS ((tree));\n-static void genrtl_eh_spec_block PARAMS ((tree));\n-static void genrtl_handler PARAMS ((tree));\n-static void cp_expand_stmt PARAMS ((tree));\n-static void genrtl_start_function PARAMS ((tree));\n-static void genrtl_finish_function PARAMS ((tree));\n-static tree clear_decl_rtl PARAMS ((tree *, int *, void *));\n+static tree maybe_convert_cond (tree);\n+static tree simplify_aggr_init_exprs_r (tree *, int *, void *);\n+static void emit_associated_thunks (tree);\n+static void genrtl_try_block (tree);\n+static void genrtl_eh_spec_block (tree);\n+static void genrtl_handler (tree);\n+static void cp_expand_stmt (tree);\n+static void genrtl_start_function (tree);\n+static void genrtl_finish_function (tree);\n+static tree clear_decl_rtl (tree *, int *, void *);\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n \n@@ -297,7 +297,7 @@ void perform_or_defer_access_check (tree class_type, tree decl)\n    at the end of the statement.  */\n \n int\n-stmts_are_full_exprs_p ()\n+stmts_are_full_exprs_p (void)\n {\n   return current_stmt_tree ()->stmts_are_full_exprs_p;\n }\n@@ -307,7 +307,7 @@ stmts_are_full_exprs_p ()\n    returned.  */\n \n stmt_tree\n-current_stmt_tree ()\n+current_stmt_tree (void)\n {\n   return (cfun \n \t  ? &cfun->language->base.x_stmt_tree \n@@ -319,16 +319,15 @@ current_stmt_tree ()\n    declared is not an anonymous union\" [class.union].  */\n \n int\n-anon_aggr_type_p (node)\n-     tree node;\n+anon_aggr_type_p (tree node)\n {\n   return ANON_AGGR_TYPE_P (node);\n }\n \n /* Finish a scope.  */\n \n tree\n-do_poplevel ()\n+do_poplevel (void)\n {\n   tree block = NULL_TREE;\n \n@@ -369,8 +368,7 @@ do_pushlevel (scope_kind sk)\n /* Finish a goto-statement.  */\n \n tree\n-finish_goto_stmt (destination)\n-     tree destination;\n+finish_goto_stmt (tree destination)\n {\n   if (TREE_CODE (destination) == IDENTIFIER_NODE)\n     destination = lookup_label (destination);\n@@ -396,8 +394,7 @@ finish_goto_stmt (destination)\n    statement.  Convert it to a boolean value, if appropriate.  */\n \n tree\n-maybe_convert_cond (cond)\n-     tree cond;\n+maybe_convert_cond (tree cond)\n {\n   /* Empty conditions remain empty.  */\n   if (!cond)\n@@ -415,8 +412,7 @@ maybe_convert_cond (cond)\n /* Finish an expression-statement, whose EXPRESSION is as indicated.  */\n \n tree\n-finish_expr_stmt (expr)\n-     tree expr;\n+finish_expr_stmt (tree expr)\n {\n   tree r = NULL_TREE;\n   tree expr_type = NULL_TREE;;\n@@ -453,7 +449,7 @@ finish_expr_stmt (expr)\n    appropriate.  */\n \n tree\n-begin_if_stmt ()\n+begin_if_stmt (void)\n {\n   tree r;\n   do_pushlevel (sk_block);\n@@ -466,9 +462,7 @@ begin_if_stmt ()\n    IF_STMT.  */\n \n void \n-finish_if_stmt_cond (cond, if_stmt)\n-     tree cond;\n-     tree if_stmt;\n+finish_if_stmt_cond (tree cond, tree if_stmt)\n {\n   cond = maybe_convert_cond (cond);\n   FINISH_COND (cond, if_stmt, IF_COND (if_stmt));\n@@ -478,8 +472,7 @@ finish_if_stmt_cond (cond, if_stmt)\n    IF_STMT.  */\n \n tree\n-finish_then_clause (if_stmt)\n-     tree if_stmt;\n+finish_then_clause (tree if_stmt)\n {\n   RECHAIN_STMTS (if_stmt, THEN_CLAUSE (if_stmt));\n   return if_stmt;\n@@ -488,24 +481,23 @@ finish_then_clause (if_stmt)\n /* Begin the else-clause of an if-statement.  */\n \n void \n-begin_else_clause ()\n+begin_else_clause (void)\n {\n }\n \n /* Finish the else-clause of an if-statement, which may be given by\n    IF_STMT.  */\n \n void\n-finish_else_clause (if_stmt)\n-     tree if_stmt;\n+finish_else_clause (tree if_stmt)\n {\n   RECHAIN_STMTS (if_stmt, ELSE_CLAUSE (if_stmt));\n }\n \n /* Finish an if-statement.  */\n \n void \n-finish_if_stmt ()\n+finish_if_stmt (void)\n {\n   finish_stmt ();\n   do_poplevel ();\n@@ -515,7 +507,7 @@ finish_if_stmt ()\n    appropriate.  */\n \n tree\n-begin_while_stmt ()\n+begin_while_stmt (void)\n {\n   tree r;\n   r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n@@ -528,9 +520,7 @@ begin_while_stmt ()\n    WHILE_STMT.  */\n \n void \n-finish_while_stmt_cond (cond, while_stmt)\n-     tree cond;\n-     tree while_stmt;\n+finish_while_stmt_cond (tree cond, tree while_stmt)\n {\n   cond = maybe_convert_cond (cond);\n   if (processing_template_decl)\n@@ -561,8 +551,7 @@ finish_while_stmt_cond (cond, while_stmt)\n /* Finish a while-statement, which may be given by WHILE_STMT.  */\n \n void \n-finish_while_stmt (while_stmt)\n-     tree while_stmt;\n+finish_while_stmt (tree while_stmt)\n {\n   do_poplevel ();\n   RECHAIN_STMTS (while_stmt, WHILE_BODY (while_stmt));\n@@ -573,7 +562,7 @@ finish_while_stmt (while_stmt)\n    appropriate.  */\n \n tree\n-begin_do_stmt ()\n+begin_do_stmt (void)\n {\n   tree r = build_stmt (DO_STMT, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n@@ -583,8 +572,7 @@ begin_do_stmt ()\n /* Finish the body of a do-statement, which may be given by DO_STMT.  */\n \n void\n-finish_do_body (do_stmt)\n-     tree do_stmt;\n+finish_do_body (tree do_stmt)\n {\n   RECHAIN_STMTS (do_stmt, DO_BODY (do_stmt));\n }\n@@ -593,9 +581,7 @@ finish_do_body (do_stmt)\n    COND is as indicated.  */\n \n void\n-finish_do_stmt (cond, do_stmt)\n-     tree cond;\n-     tree do_stmt;\n+finish_do_stmt (tree cond, tree do_stmt)\n {\n   cond = maybe_convert_cond (cond);\n   DO_COND (do_stmt) = cond;\n@@ -606,8 +592,7 @@ finish_do_stmt (cond, do_stmt)\n    indicated.  */\n \n tree\n-finish_return_stmt (expr)\n-     tree expr;\n+finish_return_stmt (tree expr)\n {\n   tree r;\n \n@@ -632,7 +617,7 @@ finish_return_stmt (expr)\n /* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */\n \n tree\n-begin_for_stmt ()\n+begin_for_stmt (void)\n {\n   tree r;\n \n@@ -650,8 +635,7 @@ begin_for_stmt ()\n    given by FOR_STMT.  */\n \n void\n-finish_for_init_stmt (for_stmt)\n-     tree for_stmt;\n+finish_for_init_stmt (tree for_stmt)\n {\n   if (last_tree != for_stmt)\n     RECHAIN_STMTS (for_stmt, FOR_INIT_STMT (for_stmt));\n@@ -662,9 +646,7 @@ finish_for_init_stmt (for_stmt)\n    FOR_STMT.  */\n \n void\n-finish_for_cond (cond, for_stmt)\n-     tree cond;\n-     tree for_stmt;\n+finish_for_cond (tree cond, tree for_stmt)\n {\n   cond = maybe_convert_cond (cond);\n   if (processing_template_decl)\n@@ -696,9 +678,7 @@ finish_for_cond (cond, for_stmt)\n    given by FOR_STMT.  */\n \n void\n-finish_for_expr (expr, for_stmt)\n-     tree expr;\n-     tree for_stmt;\n+finish_for_expr (tree expr, tree for_stmt)\n {\n   FOR_EXPR (for_stmt) = expr;\n }\n@@ -708,8 +688,7 @@ finish_for_expr (expr, for_stmt)\n    provided.  */\n \n void\n-finish_for_stmt (for_stmt)\n-     tree for_stmt;\n+finish_for_stmt (tree for_stmt)\n {\n   /* Pop the scope for the body of the loop.  */\n   do_poplevel ();\n@@ -722,15 +701,15 @@ finish_for_stmt (for_stmt)\n /* Finish a break-statement.  */\n \n tree\n-finish_break_stmt ()\n+finish_break_stmt (void)\n {\n   return add_stmt (build_break_stmt ());\n }\n \n /* Finish a continue-statement.  */\n \n tree\n-finish_continue_stmt ()\n+finish_continue_stmt (void)\n {\n   return add_stmt (build_continue_stmt ());\n }\n@@ -739,7 +718,7 @@ finish_continue_stmt ()\n    appropriate.  */\n \n tree\n-begin_switch_stmt ()\n+begin_switch_stmt (void)\n {\n   tree r;\n   do_pushlevel (sk_block);\n@@ -751,9 +730,7 @@ begin_switch_stmt ()\n /* Finish the cond of a switch-statement.  */\n \n void\n-finish_switch_cond (cond, switch_stmt)\n-     tree cond;\n-     tree switch_stmt;\n+finish_switch_cond (tree cond, tree switch_stmt)\n {\n   tree orig_type = NULL;\n   if (!processing_template_decl)\n@@ -795,8 +772,7 @@ finish_switch_cond (cond, switch_stmt)\n    SWITCH_STMT.  The COND to switch on is indicated.  */\n \n void\n-finish_switch_stmt (switch_stmt)\n-     tree switch_stmt;\n+finish_switch_stmt (tree switch_stmt)\n {\n   RECHAIN_STMTS (switch_stmt, SWITCH_BODY (switch_stmt));\n   pop_switch (); \n@@ -807,8 +783,7 @@ finish_switch_stmt (switch_stmt)\n /* Generate the RTL for T, which is a TRY_BLOCK.  */\n \n static void \n-genrtl_try_block (t)\n-     tree t;\n+genrtl_try_block (tree t)\n {\n   if (CLEANUP_P (t))\n     {\n@@ -844,8 +819,7 @@ genrtl_try_block (t)\n /* Generate the RTL for T, which is an EH_SPEC_BLOCK.  */\n \n static void \n-genrtl_eh_spec_block (t)\n-     tree t;\n+genrtl_eh_spec_block (tree t)\n {\n   expand_eh_region_start ();\n   expand_stmt (EH_SPEC_STMTS (t));\n@@ -860,7 +834,7 @@ genrtl_eh_spec_block (t)\n    appropriate.  */\n \n tree\n-begin_try_block ()\n+begin_try_block (void)\n {\n   tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n@@ -870,7 +844,7 @@ begin_try_block ()\n /* Likewise, for a function-try-block.  */\n \n tree\n-begin_function_try_block ()\n+begin_function_try_block (void)\n {\n   tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n   FN_TRY_BLOCK_P (r) = 1;\n@@ -881,8 +855,7 @@ begin_function_try_block ()\n /* Finish a try-block, which may be given by TRY_BLOCK.  */\n \n void\n-finish_try_block (try_block)\n-     tree try_block;\n+finish_try_block (tree try_block)\n {\n   RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n }\n@@ -891,8 +864,7 @@ finish_try_block (try_block)\n    TRY_BLOCK.  */\n \n void\n-finish_cleanup_try_block (try_block)\n-     tree try_block;\n+finish_cleanup_try_block (tree try_block)\n {\n   RECHAIN_STMTS (try_block, TRY_STMTS (try_block));\n }\n@@ -901,9 +873,7 @@ finish_cleanup_try_block (try_block)\n    by CLEANUP.  */\n \n void\n-finish_cleanup (cleanup, try_block)\n-     tree cleanup;\n-     tree try_block;\n+finish_cleanup (tree cleanup, tree try_block)\n {\n   TRY_HANDLERS (try_block) = cleanup;\n   CLEANUP_P (try_block) = 1;\n@@ -912,8 +882,7 @@ finish_cleanup (cleanup, try_block)\n /* Likewise, for a function-try-block.  */\n \n void\n-finish_function_try_block (try_block)\n-     tree try_block;\n+finish_function_try_block (tree try_block)\n {\n   if (TREE_CHAIN (try_block) \n       && TREE_CODE (TREE_CHAIN (try_block)) == CTOR_INITIALIZER)\n@@ -932,8 +901,7 @@ finish_function_try_block (try_block)\n    TRY_BLOCK.  */\n \n void\n-finish_handler_sequence (try_block)\n-     tree try_block;\n+finish_handler_sequence (tree try_block)\n {\n   RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n   check_handlers (TRY_HANDLERS (try_block));\n@@ -942,8 +910,7 @@ finish_handler_sequence (try_block)\n /* Likewise, for a function-try-block.  */\n \n void\n-finish_function_handler_sequence (try_block)\n-     tree try_block;\n+finish_function_handler_sequence (tree try_block)\n {\n   in_function_try_handler = 0;\n   RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n@@ -953,8 +920,7 @@ finish_function_handler_sequence (try_block)\n /* Generate the RTL for T, which is a HANDLER.  */\n \n static void\n-genrtl_handler (t)\n-     tree t;\n+genrtl_handler (tree t)\n {\n   genrtl_do_pushlevel ();\n   if (!processing_template_decl)\n@@ -967,7 +933,7 @@ genrtl_handler (t)\n /* Begin a handler.  Returns a HANDLER if appropriate.  */\n \n tree\n-begin_handler ()\n+begin_handler (void)\n {\n   tree r;\n   r = build_stmt (HANDLER, NULL_TREE, NULL_TREE);\n@@ -983,9 +949,7 @@ begin_handler ()\n    if this is a `catch (...)' clause.  */\n \n void\n-finish_handler_parms (decl, handler)\n-     tree decl;\n-     tree handler;\n+finish_handler_parms (tree decl, tree handler)\n {\n   tree type = NULL_TREE;\n   if (processing_template_decl)\n@@ -1009,8 +973,7 @@ finish_handler_parms (decl, handler)\n    the return value from the matching call to finish_handler_parms.  */\n \n void\n-finish_handler (handler)\n-     tree handler;\n+finish_handler (tree handler)\n {\n   if (!processing_template_decl)\n     expand_end_catch_block ();\n@@ -1023,8 +986,7 @@ finish_handler (handler)\n    COMPOUND_STMT if appropriate.  */\n \n tree\n-begin_compound_stmt (has_no_scope)\n-     int has_no_scope;\n+begin_compound_stmt (int has_no_scope)\n {\n   tree r; \n   int is_try = 0;\n@@ -1057,9 +1019,7 @@ begin_compound_stmt (has_no_scope)\n    a scope.  */\n \n tree\n-finish_compound_stmt (has_no_scope, compound_stmt)\n-     int has_no_scope;\n-     tree compound_stmt;\n+finish_compound_stmt (int has_no_scope, tree compound_stmt)\n {\n   tree r;\n   tree t;\n@@ -1087,13 +1047,11 @@ finish_compound_stmt (has_no_scope, compound_stmt)\n    CLOBBERS.  */\n \n tree\n-finish_asm_stmt (cv_qualifier, string, output_operands,\n-\t\t input_operands, clobbers)\n-     tree cv_qualifier;\n-     tree string;\n-     tree output_operands;\n-     tree input_operands;\n-     tree clobbers;\n+finish_asm_stmt (tree cv_qualifier, \n+                 tree string, \n+                 tree output_operands,\n+\t\t tree input_operands, \n+                 tree clobbers)\n {\n   tree r;\n   tree t;\n@@ -1176,8 +1134,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n /* Finish a label with the indicated NAME.  */\n \n tree\n-finish_label_stmt (name)\n-     tree name;\n+finish_label_stmt (tree name)\n {\n   tree decl = define_label (input_filename, input_line, name);\n   return add_stmt (build_stmt (LABEL_STMT, decl));\n@@ -1188,8 +1145,7 @@ finish_label_stmt (name)\n    is useful when writing code involving statement-expressions.  */\n \n void\n-finish_label_decl (name)\n-     tree name;\n+finish_label_decl (tree name)\n {\n   tree decl = declare_local_label (name);\n   add_decl_stmt (decl);\n@@ -1198,18 +1154,15 @@ finish_label_decl (name)\n /* When DECL goes out of scope, make sure that CLEANUP is executed.  */\n \n void \n-finish_decl_cleanup (decl, cleanup)\n-     tree decl;\n-     tree cleanup;\n+finish_decl_cleanup (tree decl, tree cleanup)\n {\n   add_stmt (build_stmt (CLEANUP_STMT, decl, cleanup));\n }\n \n /* If the current scope exits with an exception, run CLEANUP.  */\n \n void\n-finish_eh_cleanup (cleanup)\n-     tree cleanup;\n+finish_eh_cleanup (tree cleanup)\n {\n   tree r = build_stmt (CLEANUP_STMT, NULL_TREE, cleanup);\n   CLEANUP_EH_ONLY (r) = 1;\n@@ -1236,16 +1189,15 @@ finish_mem_initializers (tree mem_inits)\n /* Returns the stack of SCOPE_STMTs for the current function.  */\n \n tree *\n-current_scope_stmt_stack ()\n+current_scope_stmt_stack (void)\n {\n   return &cfun->language->base.x_scope_stmt_stack;\n }\n \n /* Finish a parenthesized expression EXPR.  */\n \n tree\n-finish_parenthesized_expr (expr)\n-     tree expr;\n+finish_parenthesized_expr (tree expr)\n {\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expr))))\n     /* This inhibits warnings in c_common_truthvalue_conversion.  */\n@@ -1324,7 +1276,7 @@ finish_non_static_data_member (tree decl, tree qualifying_scope)\n    finish_stmt_expr.  */\n \n tree \n-begin_stmt_expr ()\n+begin_stmt_expr (void)\n {\n   /* If we're outside a function, we won't have a statement-tree to\n      work with.  But, if we see a statement-expression we need to\n@@ -1345,7 +1297,7 @@ begin_stmt_expr ()\n    function.  */\n \n tree\n-begin_global_stmt_expr ()\n+begin_global_stmt_expr (void)\n {\n   if (! cfun && !last_tree)\n     begin_stmt_tree (&scope_chain->x_saved_tree);\n@@ -1358,8 +1310,7 @@ begin_global_stmt_expr ()\n /* Finish the STMT_EXPR last begun with begin_global_stmt_expr.  */\n \n tree \n-finish_global_stmt_expr (stmt_expr)\n-     tree stmt_expr;\n+finish_global_stmt_expr (tree stmt_expr)\n {\n   stmt_expr = expand_end_stmt_expr (stmt_expr);\n   \n@@ -1376,8 +1327,7 @@ finish_global_stmt_expr (stmt_expr)\n    statement-expression.  */\n \n tree \n-finish_stmt_expr (rtl_expr)\n-     tree rtl_expr;\n+finish_stmt_expr (tree rtl_expr)\n {\n   tree result;\n \n@@ -1523,9 +1473,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n    POSTDECREMENT_EXPR.)  */\n \n tree \n-finish_increment_expr (expr, code)\n-     tree expr;\n-     enum tree_code code;\n+finish_increment_expr (tree expr, enum tree_code code)\n {\n   /* If we get an OFFSET_REF, turn it into what it really means (e.g.,\n      a COMPONENT_REF).  This way if we've got, say, a reference to a\n@@ -1540,7 +1488,7 @@ finish_increment_expr (expr, code)\n /* Finish a use of `this'.  Returns an expression for `this'.  */\n \n tree \n-finish_this_expr ()\n+finish_this_expr (void)\n {\n   tree result;\n \n@@ -1570,10 +1518,7 @@ finish_this_expr ()\n    FN.  Returns an expression for the call.  */\n \n tree \n-finish_object_call_expr (fn, object, args)\n-     tree fn;\n-     tree object;\n-     tree args;\n+finish_object_call_expr (tree fn, tree object, tree args)\n {\n   if (DECL_DECLARES_TYPE_P (fn))\n     {\n@@ -1609,10 +1554,7 @@ finish_object_call_expr (fn, object, args)\n    arguments to FN.  Returns an expression for the call.  */\n \n tree \n-finish_qualified_object_call_expr (fn, object, args)\n-     tree fn;\n-     tree object;\n-     tree args;\n+finish_qualified_object_call_expr (tree fn, tree object, tree args)\n {\n   return build_scoped_method_call (object, TREE_OPERAND (fn, 0),\n \t\t\t\t   TREE_OPERAND (fn, 1), args);\n@@ -1624,10 +1566,7 @@ finish_qualified_object_call_expr (fn, object, args)\n    was of the form `OBJECT.SCOPE::~DESTRUCTOR'.  */\n \n tree \n-finish_pseudo_destructor_expr (object, scope, destructor)\n-     tree object;\n-     tree scope;\n-     tree destructor;\n+finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n {\n   if (destructor == error_mark_node)\n     return error_mark_node;\n@@ -1655,9 +1594,7 @@ finish_pseudo_destructor_expr (object, scope, destructor)\n /* Finish an expression of the form CODE EXPR.  */\n \n tree\n-finish_unary_op_expr (code, expr)\n-     enum tree_code code;\n-     tree expr;\n+finish_unary_op_expr (enum tree_code code, tree expr)\n {\n   tree result = build_x_unary_op (code, expr);\n   /* Inside a template, build_x_unary_op does not fold the\n@@ -1676,9 +1613,7 @@ finish_unary_op_expr (code, expr)\n    the INITIALIZER_LIST is being cast.  */\n \n tree\n-finish_compound_literal (type, initializer_list)\n-     tree type;\n-     tree initializer_list;\n+finish_compound_literal (tree type, tree initializer_list)\n {\n   tree compound_literal;\n \n@@ -1724,10 +1659,7 @@ finish_fname (tree id)\n    valid.  */\n \n int\n-begin_function_definition (decl_specs, attributes, declarator)\n-     tree decl_specs;\n-     tree attributes;\n-     tree declarator;\n+begin_function_definition (tree decl_specs, tree attributes, tree declarator)\n {\n   if (!start_function (decl_specs, declarator, attributes, SF_DEFAULT))\n     return 0;\n@@ -1742,7 +1674,7 @@ begin_function_definition (decl_specs, attributes, declarator)\n /* Finish a translation unit.  */\n \n void \n-finish_translation_unit ()\n+finish_translation_unit (void)\n {\n   /* In case there were missing closebraces,\n      get us back to the global binding level.  */\n@@ -1758,9 +1690,7 @@ finish_translation_unit ()\n    Returns the parameter.  */\n \n tree \n-finish_template_type_parm (aggr, identifier)\n-     tree aggr;\n-     tree identifier;\n+finish_template_type_parm (tree aggr, tree identifier)\n {\n   if (aggr != class_type_node)\n     {\n@@ -1775,9 +1705,7 @@ finish_template_type_parm (aggr, identifier)\n    Returns the parameter.  */\n \n tree \n-finish_template_template_parm (aggr, identifier)\n-     tree aggr;\n-     tree identifier;\n+finish_template_template_parm (tree aggr, tree identifier)\n {\n   tree decl = build_decl (TYPE_DECL, identifier, NULL_TREE);\n   tree tmpl = build_lang_decl (TEMPLATE_DECL, identifier, NULL_TREE);\n@@ -1814,9 +1742,7 @@ check_template_template_default_arg (tree argument)\n    nonzero, the parameter list was terminated by a `...'.  */\n \n tree\n-finish_parmlist (parms, ellipsis)\n-     tree parms;\n-     int ellipsis;\n+finish_parmlist (tree parms, int ellipsis)\n {\n   if (parms)\n     {\n@@ -1833,8 +1759,7 @@ finish_parmlist (parms, ellipsis)\n /* Begin a class definition, as indicated by T.  */\n \n tree\n-begin_class_definition (t)\n-     tree t;\n+begin_class_definition (tree t)\n {\n   if (t == error_mark_node)\n     return error_mark_node;\n@@ -1903,8 +1828,7 @@ begin_class_definition (t)\n /* Finish the member declaration given by DECL.  */\n \n void\n-finish_member_declaration (decl)\n-     tree decl;\n+finish_member_declaration (tree decl)\n {\n   if (decl == error_mark_node || decl == NULL_TREE)\n     return;\n@@ -1992,11 +1916,7 @@ finish_member_declaration (decl)\n    type.  */\n \n tree\n-finish_class_definition (t, attributes, semi, pop_scope_p)\n-     tree t;\n-     tree attributes;\n-     int semi;\n-     int pop_scope_p;\n+finish_class_definition (tree t, tree attributes, int semi, int pop_scope_p)\n {\n   if (t == error_mark_node)\n     return error_mark_node;\n@@ -2030,8 +1950,7 @@ finish_class_definition (t, attributes, semi, pop_scope_p)\n    TYPES whose template parameters are given by PARMS.  */\n \n tree\n-finish_member_class_template (types)\n-     tree types;\n+finish_member_class_template (tree types)\n {\n   tree t;\n \n@@ -2062,8 +1981,7 @@ finish_member_class_template (types)\n    the template parameters.  */\n \n void\n-finish_template_decl (parms)\n-     tree parms;\n+finish_template_decl (tree parms)\n {\n   if (parms)\n     end_template_decl ();\n@@ -2077,10 +1995,7 @@ finish_template_decl (parms)\n    the scope of template-id indicated.  */\n \n tree\n-finish_template_type (name, args, entering_scope)\n-     tree name;\n-     tree args;\n-     int entering_scope;\n+finish_template_type (tree name, tree args, int entering_scope)\n {\n   tree decl;\n \n@@ -2129,7 +2044,7 @@ finish_base_specifier (tree base, tree access, bool virtual_p)\n    premitted in this context, an error is issued.  */\n \n void\n-check_multiple_declarators ()\n+check_multiple_declarators (void)\n {\n   /* [temp]\n      \n@@ -2154,8 +2069,7 @@ check_multiple_declarators ()\n    use as a type-specifier.  */\n \n tree\n-finish_typeof (expr)\n-     tree expr;\n+finish_typeof (tree expr)\n {\n   tree type;\n \n@@ -2184,8 +2098,7 @@ finish_typeof (expr)\n /* Compute the value of the `sizeof' operator.  */\n \n tree\n-finish_sizeof (t)\n-     tree t;\n+finish_sizeof (tree t)\n {\n   return TYPE_P (t) ? cxx_sizeof (t) : expr_sizeof (t);\n }\n@@ -2194,8 +2107,7 @@ finish_sizeof (t)\n    alignment of T, measured in bytes.  */\n \n tree\n-finish_alignof (t)\n-     tree t;\n+finish_alignof (tree t)\n {\n   if (processing_template_decl)\n     return build_min (ALIGNOF_EXPR, size_type_node, t);\n@@ -2207,8 +2119,7 @@ finish_alignof (t)\n    other statements at its nesting level.  */\n \n static void\n-cp_expand_stmt (t)\n-     tree t;\n+cp_expand_stmt (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -2237,10 +2148,9 @@ cp_expand_stmt (t)\n    will equivalent CALL_EXPRs.  */\n \n static tree\n-simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+simplify_aggr_init_exprs_r (tree* tp, \n+                            int* walk_subtrees ATTRIBUTE_UNUSED , \n+                            void* data ATTRIBUTE_UNUSED )\n {\n   tree aggr_init_expr;\n   tree call_expr;\n@@ -2335,8 +2245,7 @@ simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n /* Emit all thunks to FN that should be emitted when FN is emitted.  */\n \n static void\n-emit_associated_thunks (fn)\n-     tree fn;\n+emit_associated_thunks (tree fn)\n {\n   /* When we use vcall offsets, we emit thunks with the virtual\n      functions to which they thunk. The whole point of vcall offsets\n@@ -2365,8 +2274,7 @@ emit_associated_thunks (fn)\n /* Generate RTL for FN.  */\n \n void\n-expand_body (fn)\n-     tree fn;\n+expand_body (tree fn)\n {\n   location_t saved_loc;\n   tree saved_function;\n@@ -2509,10 +2417,7 @@ expand_body (fn)\n    value optimization.  */\n \n tree\n-nullify_returns_r (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n+nullify_returns_r (tree* tp, int* walk_subtrees, void* data)\n {\n   tree nrv = (tree) data;\n \n@@ -2533,8 +2438,7 @@ nullify_returns_r (tp, walk_subtrees, data)\n /* Start generating the RTL for FN.  */\n \n static void\n-genrtl_start_function (fn)\n-     tree fn;\n+genrtl_start_function (tree fn)\n {\n   /* Tell everybody what function we're processing.  */\n   current_function_decl = fn;\n@@ -2595,8 +2499,7 @@ genrtl_start_function (fn)\n /* Finish generating the RTL for FN.  */\n \n static void\n-genrtl_finish_function (fn)\n-     tree fn;\n+genrtl_finish_function (tree fn)\n {\n   tree t;\n \n@@ -2717,10 +2620,9 @@ genrtl_finish_function (fn)\n    its sub-blocks.  */\n \n static tree\n-clear_decl_rtl (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+clear_decl_rtl (tree* tp, \n+                int* walk_subtrees ATTRIBUTE_UNUSED , \n+                void* data ATTRIBUTE_UNUSED )\n {\n   if (nonstatic_local_decl_p (*tp)) \n     SET_DECL_RTL (*tp, NULL_RTX);\n@@ -2731,7 +2633,7 @@ clear_decl_rtl (tp, walk_subtrees, data)\n /* Perform initialization related to this module.  */\n \n void\n-init_cp_semantics ()\n+init_cp_semantics (void)\n {\n   lang_expand_stmt = cp_expand_stmt;\n }"}]}