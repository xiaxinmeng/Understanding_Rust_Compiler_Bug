{"sha": "82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJiYjdkNGU4Mjc0YjViYzIyMDAwZWE2ZmM1OGYxNjllN2UwODdmMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-11-19T01:42:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-11-19T01:42:34Z"}, "message": "md.texi (setmem): Document new parameter.\n\n\n\t* md.texi (setmem): Document new parameter.\n\t* optabs.c (maybe_gen_insn): Support 9 operands.\n\t* builtins.c (determine_block_size): Add probable_max_size;\n\tsupport anti-ranges.\n\t(expand_builtin_memcpy. expand_builtin_memset_args): Pass around\n\tprobable_max_size.\n\t* expr.c (emit_block_move_via_movmem, emit_block_move_hints,\n\temit_block_move, clear_storage_hints, set_storage_via_setmem):\n\tLikewise.\n\t* expr.h (emit_block_move_hints, clear_storage_hints,\n\tset_storage_via_setmem): Update prototype.\n\t* i386.md (setmem, movmem patterns): Add 9th operand.\n\t* i386-protos.h (ix86_expand_set_or_movmem): Update prototype.\n\t* i386.c (ix86_expand_set_or_movmem): Take probable_max_size_exp\n\targument; pass it to decide_alg.\n\n\t* gcc.target/i386/memcpy-3.c: New testcase.\n\nFrom-SVN: r204997", "tree": {"sha": "f2fcdd731a9c1bb632d77915060a8e36c94837b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2fcdd731a9c1bb632d77915060a8e36c94837b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/comments", "author": null, "committer": null, "parents": [{"sha": "0874db6e96b721f9545c6b3976eb77601b09533d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0874db6e96b721f9545c6b3976eb77601b09533d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0874db6e96b721f9545c6b3976eb77601b09533d"}], "stats": {"total": 202, "additions": 145, "deletions": 57}, "files": [{"sha": "7dc980f9bf5368ca344d9aeb3edb24ff9eb0e861", "filename": "gcc/builtins.c", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -3096,12 +3096,15 @@ builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n }\n \n /* LEN specify length of the block of memcpy/memset operation.\n-   Figure out its range and put it into MIN_SIZE/MAX_SIZE.  */\n+   Figure out its range and put it into MIN_SIZE/MAX_SIZE. \n+   In some cases we can make very likely guess on max size, then we\n+   set it into PROBABLE_MAX_SIZE.  */\n \n static void\n determine_block_size (tree len, rtx len_rtx,\n \t\t      unsigned HOST_WIDE_INT *min_size,\n-\t\t      unsigned HOST_WIDE_INT *max_size)\n+\t\t      unsigned HOST_WIDE_INT *max_size,\n+\t\t      unsigned HOST_WIDE_INT *probable_max_size)\n {\n   if (CONST_INT_P (len_rtx))\n     {\n@@ -3111,28 +3114,47 @@ determine_block_size (tree len, rtx len_rtx,\n   else\n     {\n       double_int min, max;\n-      if (TREE_CODE (len) == SSA_NAME \n-\t  && get_range_info (len, &min, &max) == VR_RANGE)\n+      enum value_range_type range_type = VR_UNDEFINED;\n+\n+      /* Determine bounds from the type.  */\n+      if (tree_fits_uhwi_p (TYPE_MIN_VALUE (TREE_TYPE (len))))\n+\t*min_size = tree_to_uhwi (TYPE_MIN_VALUE (TREE_TYPE (len)));\n+      else\n+\t*min_size = 0;\n+      if (tree_fits_uhwi_p (TYPE_MAX_VALUE (TREE_TYPE (len))))\n+\t*probable_max_size = *max_size = tree_to_uhwi (TYPE_MAX_VALUE (TREE_TYPE (len)));\n+      else\n+\t*probable_max_size = *max_size = GET_MODE_MASK (GET_MODE (len_rtx));\n+\n+      if (TREE_CODE (len) == SSA_NAME)\n+\trange_type = get_range_info (len, &min, &max);\n+      if (range_type == VR_RANGE)\n \t{\n-\t  if (min.fits_uhwi ())\n+\t  if (min.fits_uhwi () && *min_size < min.to_uhwi ())\n \t    *min_size = min.to_uhwi ();\n-\t  else\n-\t    *min_size = 0;\n-\t  if (max.fits_uhwi ())\n-\t    *max_size = max.to_uhwi ();\n-\t  else\n-\t    *max_size = (HOST_WIDE_INT)-1;\n+\t  if (max.fits_uhwi () && *max_size > max.to_uhwi ())\n+\t    *probable_max_size = *max_size = max.to_uhwi ();\n \t}\n-      else\n+      else if (range_type == VR_ANTI_RANGE)\n \t{\n-\t  if (tree_fits_uhwi_p (TYPE_MIN_VALUE (TREE_TYPE (len))))\n-\t    *min_size = tree_to_uhwi (TYPE_MIN_VALUE (TREE_TYPE (len)));\n-\t  else\n-\t    *min_size = 0;\n-\t  if (tree_fits_uhwi_p (TYPE_MAX_VALUE (TREE_TYPE (len))))\n-\t    *max_size = tree_to_uhwi (TYPE_MAX_VALUE (TREE_TYPE (len)));\n-\t  else\n-\t    *max_size = GET_MODE_MASK (GET_MODE (len_rtx));\n+\t  /* Anti range 0...N lets us to determine minmal size to N+1.  */\n+\t  if (min.is_zero ())\n+\t    {\n+\t      if ((max + double_int_one).fits_uhwi ())\n+\t\t*min_size = (max + double_int_one).to_uhwi ();\n+\t    }\n+\t  /* Code like\n+\n+\t     int n;\n+\t     if (n < 100)\n+\t       memcpy (a,b, n)\n+\n+\t     Produce anti range allowing negative values of N.  We still\n+\t     can use the information and make a guess that N is not negative.\n+\t     */\n+\t   else if (!max.ule (double_int_one.lshift (30))\n+\t            && min.fits_uhwi ())\n+\t     *probable_max_size = min.to_uhwi () - 1;\n \t}\n     }\n   gcc_checking_assert (*max_size <=\n@@ -3164,6 +3186,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n       unsigned int expected_align = 0;\n       unsigned HOST_WIDE_INT min_size;\n       unsigned HOST_WIDE_INT max_size;\n+      unsigned HOST_WIDE_INT probable_max_size;\n \n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n@@ -3183,7 +3206,8 @@ expand_builtin_memcpy (tree exp, rtx target)\n       dest_mem = get_memory_rtx (dest, len);\n       set_mem_align (dest_mem, dest_align);\n       len_rtx = expand_normal (len);\n-      determine_block_size (len, len_rtx, &min_size, &max_size);\n+      determine_block_size (len, len_rtx, &min_size, &max_size,\n+\t\t\t    &probable_max_size);\n       src_str = c_getstr (src);\n \n       /* If SRC is a string constant and block move would be done\n@@ -3213,7 +3237,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n \t\t\t\t         CALL_EXPR_TAILCALL (exp)\n \t\t\t\t         ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n \t\t\t\t\t expected_align, expected_size,\n-\t\t\t\t\t min_size, max_size);\n+\t\t\t\t\t min_size, max_size, probable_max_size);\n \n       if (dest_addr == 0)\n \t{\n@@ -3629,6 +3653,7 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   unsigned int expected_align = 0;\n   unsigned HOST_WIDE_INT min_size;\n   unsigned HOST_WIDE_INT max_size;\n+  unsigned HOST_WIDE_INT probable_max_size;\n \n   dest_align = get_pointer_alignment (dest);\n \n@@ -3657,7 +3682,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   len = builtin_save_expr (len);\n \n   len_rtx = expand_normal (len);\n-  determine_block_size (len, len_rtx, &min_size, &max_size);\n+  determine_block_size (len, len_rtx, &min_size, &max_size,\n+\t\t\t&probable_max_size);\n   dest_mem = get_memory_rtx (dest, len);\n   val_mode = TYPE_MODE (unsigned_char_type_node);\n \n@@ -3684,7 +3710,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t}\n       else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n \t\t\t\t\tdest_align, expected_align,\n-\t\t\t\t\texpected_size, min_size, max_size))\n+\t\t\t\t\texpected_size, min_size, max_size,\n+\t\t\t\t\tprobable_max_size))\n \tgoto do_libcall;\n \n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3706,7 +3733,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n       else if (!set_storage_via_setmem (dest_mem, len_rtx,\n \t\t\t\t\tgen_int_mode (c, val_mode),\n \t\t\t\t\tdest_align, expected_align,\n-\t\t\t\t\texpected_size, min_size, max_size))\n+\t\t\t\t\texpected_size, min_size, max_size,\n+\t\t\t\t\tprobable_max_size))\n \tgoto do_libcall;\n \n       dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n@@ -3719,7 +3747,8 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n \t\t\t\t   CALL_EXPR_TAILCALL (orig_exp)\n \t\t\t\t   ? BLOCK_OP_TAILCALL : BLOCK_OP_NORMAL,\n \t\t\t\t   expected_align, expected_size,\n-\t\t\t\t   min_size, max_size);\n+\t\t\t\t   min_size, max_size,\n+\t\t\t\t   probable_max_size);\n \n   if (dest_addr == 0)\n     {"}, {"sha": "bceb8f2ef6dd6e387b5a7d5449233a4519394ca3", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -60,7 +60,7 @@ extern int avx_vperm2f128_parallel (rtx par, enum machine_mode mode);\n \n extern bool ix86_expand_strlen (rtx, rtx, rtx, rtx);\n extern bool ix86_expand_set_or_movmem (rtx, rtx, rtx, rtx, rtx, rtx,\n-\t\t\t\t       rtx, rtx, rtx, bool);\n+\t\t\t\t       rtx, rtx, rtx, rtx, bool);\n \n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);"}, {"sha": "d95ca351906161fd75a9d5ccd4d1fbfe7bdce00f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -23715,7 +23715,8 @@ bool\n ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \t\t\t   rtx align_exp, rtx expected_align_exp,\n \t\t\t   rtx expected_size_exp, rtx min_size_exp,\n-\t\t\t   rtx max_size_exp, bool issetmem)\n+\t\t\t   rtx max_size_exp, rtx probable_max_size_exp,\n+\t\t\t   bool issetmem)\n {\n   rtx destreg;\n   rtx srcreg = NULL;\n@@ -23739,6 +23740,7 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   /* TODO: Once vlaue ranges are available, fill in proper data.  */\n   unsigned HOST_WIDE_INT min_size = 0;\n   unsigned HOST_WIDE_INT max_size = -1;\n+  unsigned HOST_WIDE_INT probable_max_size = -1;\n   bool misaligned_prologue_used = false;\n \n   if (CONST_INT_P (align_exp))\n@@ -23754,21 +23756,28 @@ ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n     align = MEM_ALIGN (dst) / BITS_PER_UNIT;\n \n   if (CONST_INT_P (count_exp))\n-    min_size = max_size = count = expected_size = INTVAL (count_exp);\n-  if (min_size_exp)\n-    min_size = INTVAL (min_size_exp);\n-  if (max_size_exp)\n-    max_size = INTVAL (max_size_exp);\n-  if (CONST_INT_P (expected_size_exp) && count == 0)\n-    expected_size = INTVAL (expected_size_exp);\n+    min_size = max_size = probable_max_size = count = expected_size\n+      = INTVAL (count_exp);\n+  else\n+    {\n+      if (min_size_exp)\n+\tmin_size = INTVAL (min_size_exp);\n+      if (max_size_exp)\n+\tmax_size = INTVAL (max_size_exp);\n+      if (probable_max_size_exp)\n+\tprobable_max_size = INTVAL (probable_max_size_exp);\n+      if (CONST_INT_P (expected_size_exp) && count == 0)\n+\texpected_size = INTVAL (expected_size_exp);\n+     }\n \n   /* Make sure we don't need to care about overflow later on.  */\n   if (count > ((unsigned HOST_WIDE_INT) 1 << 30))\n     return false;\n \n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n-  alg = decide_alg (count, expected_size, min_size, max_size, issetmem,\n+  alg = decide_alg (count, expected_size, min_size, probable_max_size,\n+\t\t    issetmem,\n \t\t    issetmem && val_exp == const0_rtx,\n \t\t    &dynamic_check, &noalign);\n   if (alg == libcall)"}, {"sha": "8178f9b9ab05d9f79dc0016770c5e66d5698b8ac", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -15506,13 +15506,15 @@\n    (use (match_operand:SI 4 \"const_int_operand\"))\n    (use (match_operand:SI 5 \"const_int_operand\"))\n    (use (match_operand:SI 6 \"\"))\n-   (use (match_operand:SI 7 \"\"))]\n+   (use (match_operand:SI 7 \"\"))\n+   (use (match_operand:SI 8 \"\"))]\n   \"\"\n {\n  if (ix86_expand_set_or_movmem (operands[0], operands[1],\n \t\t\t        operands[2], NULL, operands[3],\n \t\t\t        operands[4], operands[5],\n-\t\t\t\toperands[6], operands[7], false))\n+\t\t\t\toperands[6], operands[7],\n+\t\t\t\toperands[8], false))\n    DONE;\n  else\n    FAIL;\n@@ -15702,14 +15704,15 @@\n     (use (match_operand:SI 4 \"const_int_operand\"))\n     (use (match_operand:SI 5 \"const_int_operand\"))\n     (use (match_operand:SI 6 \"\"))\n-    (use (match_operand:SI 7 \"\"))]\n+    (use (match_operand:SI 7 \"\"))\n+    (use (match_operand:SI 8 \"\"))]\n   \"\"\n {\n  if (ix86_expand_set_or_movmem (operands[0], NULL,\n \t\t\t        operands[1], operands[2],\n \t\t\t\toperands[3], operands[4],\n \t\t\t        operands[5], operands[6],\n-\t\t\t\toperands[7], true))\n+\t\t\t\toperands[7], operands[8], true))\n    DONE;\n  else\n    FAIL;"}, {"sha": "44a91830b48beb35e02a1ab7aa8f064922c3c779", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -5352,6 +5352,8 @@ all cases. This expected alignment is also in bytes, just like operand 4.\n Expected size, when unknown, is set to @code{(const_int -1)}.\n Operand 7 is the minimal size of the block and operand 8 is the\n maximal size of the block (NULL if it can not be represented as CONST_INT).\n+Operand 9 is the probable maximal size (i.e. we can not rely on it for correctness,\n+but it can be used for choosing proper code sequence for a given size).\n \n The use for multiple @code{setmem@var{m}} is as for @code{movmem@var{m}}.\n "}, {"sha": "ece5d0fc4431f6515dae6cd2ca7611ce87a4886b", "filename": "gcc/expr.c", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -129,7 +129,8 @@ static void move_by_pieces_1 (insn_gen_fn, machine_mode,\n \t\t\t      struct move_by_pieces_d *);\n static bool block_move_libcall_safe_for_call_parm (void);\n static bool emit_block_move_via_movmem (rtx, rtx, rtx, unsigned, unsigned, HOST_WIDE_INT,\n-\t\t\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n+\t\t\t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\t\t\tunsigned HOST_WIDE_INT);\n static tree emit_block_move_libcall_fn (int);\n static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n static rtx clear_by_pieces_1 (void *, HOST_WIDE_INT, enum machine_mode);\n@@ -1131,7 +1132,8 @@ rtx\n emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n \t\t       unsigned int expected_align, HOST_WIDE_INT expected_size,\n \t\t       unsigned HOST_WIDE_INT min_size,\n-\t\t       unsigned HOST_WIDE_INT max_size)\n+\t\t       unsigned HOST_WIDE_INT max_size,\n+\t\t       unsigned HOST_WIDE_INT probable_max_size)\n {\n   bool may_use_call;\n   rtx retval = 0;\n@@ -1188,7 +1190,7 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n     move_by_pieces (x, y, INTVAL (size), align, 0);\n   else if (emit_block_move_via_movmem (x, y, size, align,\n \t\t\t\t       expected_align, expected_size,\n-\t\t\t\t       min_size, max_size))\n+\t\t\t\t       min_size, max_size, probable_max_size))\n     ;\n   else if (may_use_call\n \t   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))\n@@ -1224,7 +1226,7 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n   else\n     max = GET_MODE_MASK (GET_MODE (size));\n   return emit_block_move_hints (x, y, size, method, 0, -1,\n-\t\t\t\tmin, max);\n+\t\t\t\tmin, max, max);\n }\n \n /* A subroutine of emit_block_move.  Returns true if calling the\n@@ -1289,7 +1291,8 @@ static bool\n emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t\t\t    unsigned int expected_align, HOST_WIDE_INT expected_size,\n \t\t\t    unsigned HOST_WIDE_INT min_size,\n-\t\t\t    unsigned HOST_WIDE_INT max_size)\n+\t\t\t    unsigned HOST_WIDE_INT max_size,\n+\t\t\t    unsigned HOST_WIDE_INT probable_max_size)\n {\n   int save_volatile_ok = volatile_ok;\n   enum machine_mode mode;\n@@ -1298,8 +1301,8 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n     expected_align = align;\n   if (expected_size != -1)\n     {\n-      if ((unsigned HOST_WIDE_INT)expected_size > max_size)\n-\texpected_size = max_size;\n+      if ((unsigned HOST_WIDE_INT)expected_size > probable_max_size)\n+\texpected_size = probable_max_size;\n       if ((unsigned HOST_WIDE_INT)expected_size < min_size)\n \texpected_size = min_size;\n     }\n@@ -1328,15 +1331,15 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t      || max_size <= (GET_MODE_MASK (mode) >> 1)\n \t      || GET_MODE_BITSIZE (mode) >= GET_MODE_BITSIZE (Pmode)))\n \t{\n-\t  struct expand_operand ops[8];\n+\t  struct expand_operand ops[9];\n \t  unsigned int nops;\n \n \t  /* ??? When called via emit_block_move_for_call, it'd be\n \t     nice if there were some way to inform the backend, so\n \t     that it doesn't fail the expansion because it thinks\n \t     emitting the libcall would be more efficient.  */\n \t  nops = insn_data[(int) code].n_generator_args;\n-\t  gcc_assert (nops == 4 || nops == 6 || nops == 8);\n+\t  gcc_assert (nops == 4 || nops == 6 || nops == 8 || nops == 9);\n \n \t  create_fixed_operand (&ops[0], x);\n \t  create_fixed_operand (&ops[1], y);\n@@ -1348,7 +1351,7 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t      create_integer_operand (&ops[4], expected_align / BITS_PER_UNIT);\n \t      create_integer_operand (&ops[5], expected_size);\n \t    }\n-\t  if (nops == 8)\n+\t  if (nops >= 8)\n \t    {\n \t      create_integer_operand (&ops[6], min_size);\n \t      /* If we can not represent the maximal size,\n@@ -1358,6 +1361,15 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t      else\n \t\tcreate_fixed_operand (&ops[7], NULL);\n \t    }\n+\t  if (nops == 9)\n+\t    {\n+\t      /* If we can not represent the maximal size,\n+\t\t make parameter NULL.  */\n+\t      if ((HOST_WIDE_INT) probable_max_size != -1)\n+\t        create_integer_operand (&ops[8], probable_max_size);\n+\t      else\n+\t\tcreate_fixed_operand (&ops[8], NULL);\n+\t    }\n \t  if (maybe_expand_insn (code, nops, ops))\n \t    {\n \t      volatile_ok = save_volatile_ok;\n@@ -2747,7 +2759,8 @@ rtx\n clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n \t\t     unsigned int expected_align, HOST_WIDE_INT expected_size,\n \t\t     unsigned HOST_WIDE_INT min_size,\n-\t\t     unsigned HOST_WIDE_INT max_size)\n+\t\t     unsigned HOST_WIDE_INT max_size,\n+\t\t     unsigned HOST_WIDE_INT probable_max_size)\n {\n   enum machine_mode mode = GET_MODE (object);\n   unsigned int align;\n@@ -2789,7 +2802,7 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n     clear_by_pieces (object, INTVAL (size), align);\n   else if (set_storage_via_setmem (object, size, const0_rtx, align,\n \t\t\t\t   expected_align, expected_size,\n-\t\t\t\t   min_size, max_size))\n+\t\t\t\t   min_size, max_size, probable_max_size))\n     ;\n   else if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (object)))\n     return set_storage_via_libcall (object, size, const0_rtx,\n@@ -2808,7 +2821,7 @@ clear_storage (rtx object, rtx size, enum block_op_methods method)\n     min = max = UINTVAL (size);\n   else\n     max = GET_MODE_MASK (GET_MODE (size));\n-  return clear_storage_hints (object, size, method, 0, -1, min, max);\n+  return clear_storage_hints (object, size, method, 0, -1, min, max, max);\n }\n \n \n@@ -2907,7 +2920,8 @@ bool\n set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t\t\tunsigned int expected_align, HOST_WIDE_INT expected_size,\n \t\t\tunsigned HOST_WIDE_INT min_size,\n-\t\t\tunsigned HOST_WIDE_INT max_size)\n+\t\t\tunsigned HOST_WIDE_INT max_size,\n+\t\t\tunsigned HOST_WIDE_INT probable_max_size)\n {\n   /* Try the most limited insn first, because there's no point\n      including more than one in the machine description unless\n@@ -2942,11 +2956,11 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t      || max_size <= (GET_MODE_MASK (mode) >> 1)\n \t      || GET_MODE_BITSIZE (mode) >= GET_MODE_BITSIZE (Pmode)))\n \t{\n-\t  struct expand_operand ops[8];\n+\t  struct expand_operand ops[9];\n \t  unsigned int nops;\n \n \t  nops = insn_data[(int) code].n_generator_args;\n-\t  gcc_assert (nops == 4 || nops == 6 || nops == 8);\n+\t  gcc_assert (nops == 4 || nops == 6 || nops == 8 || nops == 9);\n \n \t  create_fixed_operand (&ops[0], object);\n \t  /* The check above guarantees that this size conversion is valid.  */\n@@ -2958,7 +2972,7 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t      create_integer_operand (&ops[4], expected_align / BITS_PER_UNIT);\n \t      create_integer_operand (&ops[5], expected_size);\n \t    }\n-\t  if (nops == 8)\n+\t  if (nops >= 8)\n \t    {\n \t      create_integer_operand (&ops[6], min_size);\n \t      /* If we can not represent the maximal size,\n@@ -2968,6 +2982,15 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \t      else\n \t\tcreate_fixed_operand (&ops[7], NULL);\n \t    }\n+\t  if (nops == 9)\n+\t    {\n+\t      /* If we can not represent the maximal size,\n+\t\t make parameter NULL.  */\n+\t      if ((HOST_WIDE_INT) probable_max_size != -1)\n+\t        create_integer_operand (&ops[8], probable_max_size);\n+\t      else\n+\t\tcreate_fixed_operand (&ops[8], NULL);\n+\t    }\n \t  if (maybe_expand_insn (code, nops, ops))\n \t    return true;\n \t}"}, {"sha": "422c75d3f592e55d356e16853e1fac03c7ad1049", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -302,6 +302,7 @@ extern rtx emit_block_move_via_libcall (rtx, rtx, rtx, bool);\n extern rtx emit_block_move_hints (rtx, rtx, rtx, enum block_op_methods,\n \t\t\t          unsigned int, HOST_WIDE_INT,\n \t\t\t\t  unsigned HOST_WIDE_INT,\n+\t\t\t\t  unsigned HOST_WIDE_INT,\n \t\t\t\t  unsigned HOST_WIDE_INT);\n extern bool emit_storent_insn (rtx to, rtx from);\n \n@@ -365,6 +366,7 @@ extern rtx clear_storage (rtx, rtx, enum block_op_methods);\n extern rtx clear_storage_hints (rtx, rtx, enum block_op_methods,\n \t\t\t        unsigned int, HOST_WIDE_INT,\n \t\t\t\tunsigned HOST_WIDE_INT,\n+\t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\tunsigned HOST_WIDE_INT);\n /* The same, but always output an library call.  */\n rtx set_storage_via_libcall (rtx, rtx, rtx, bool);\n@@ -373,6 +375,7 @@ rtx set_storage_via_libcall (rtx, rtx, rtx, bool);\n extern bool set_storage_via_setmem (rtx, rtx, rtx, unsigned int,\n \t\t\t\t    unsigned int, HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT);\n \n extern unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,"}, {"sha": "661ce58bf4d7cdd33e0f3505030880eddd8df8bd", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -8229,6 +8229,10 @@ maybe_gen_insn (enum insn_code icode, unsigned int nops,\n       return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n \t\t\t      ops[3].value, ops[4].value, ops[5].value,\n \t\t\t      ops[6].value, ops[7].value);\n+    case 9:\n+      return GEN_FCN (icode) (ops[0].value, ops[1].value, ops[2].value,\n+\t\t\t      ops[3].value, ops[4].value, ops[5].value,\n+\t\t\t      ops[6].value, ops[7].value, ops[8].value);\n     }\n   gcc_unreachable ();\n }"}, {"sha": "7e28844d262749b820bd20e5f2a610544e643925", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -1,3 +1,7 @@\n+2013-11-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.target/i386/memcpy-3.c: New testcase.\n+\n 2013-11-18  Jan Hubicka  <jh@suse.cz>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "b9ea9c28e23167fa190e8be312aaa03e38361a57", "filename": "gcc/testsuite/gcc.target/i386/memcpy-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82bb7d4e8274b5bc22000ea6fc58f169e7e087f0/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemcpy-3.c?ref=82bb7d4e8274b5bc22000ea6fc58f169e7e087f0", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+void *a;\n+void *b;\n+t(int c)\n+{\n+  if (c<10)\n+    __builtin_memcpy (a,b,c);\n+}\n+/* Memcpy should be inlined because block size is known.  */\n+/* { dg-final { scan-assembler-not \"(jmp|call)\\[\\\\t \\]*memcpy\" } } */"}]}