{"sha": "68bc087496642a6bb547fd523e19e443c21acc35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhiYzA4NzQ5NjY0MmE2YmI1NDdmZDUyM2UxOWU0NDNjMjFhY2MzNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-10-07T20:09:01Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-10-07T20:09:01Z"}, "message": "i386.md (any_extend): New code iterator.\n\n\t* config/i386/i386.md (any_extend): New code iterator.\n\t(u, s): New code attributes.\n\t(sgnprefix): Ditto.\n\t(DWIH): Rewrite as code iterator for SI and DI modes.\n\t(DWI): Rewrite as mode attribute.\n\t(dwi): New mode attribute.\n\t(di): Depend on SI mode and DI mode.\n\t(doubleint_general_operand): Remove mode attribute.\n\n\t(*lea_1): Macroize insn from *lea_1_rex64 and *lea_1 patterns using\n\tDWIH mode iterator.\n\n\t(*add<mode>3_doubleword): Use DWIH as the base mode iterator.\n\t(*sub<mode>3_doubleword): Ditto.\n\n\t(mul<mode>3): Macroize expander from mul{hi,si,di}3 patterns\n\tusing SWIM248 mode iterator.\n\t(*mul<mode>3_1): Macroize insn from mul{si,di}3_1 patterns\n\tusing SWI48 mode iterator.\n\t(<u>mul<mode><dwi>3): Macroize expander from {,u}mul{sidi,diti}3\n\tpatterns using DWIH mode iterator and any_extend code iterator.\n\t(<u>mulqihi3): Macroize expander from {,u}mulqihi3 patterns\n\tusing any_extend code iterator.\n\t(*<u>mul<mode><dwi>3_1): Macroize insn from {,u}mul{sidi,diti}3_1\n\tpatterns using DWIH mode iterator and any_extend code iterator.\n\t(*<u>mulqihi3_1): Macroize insn from {,u}mulqihi3_1 patterns\n\tusing any_extend code iterator.\n\t(<s>mul<mode>3_highpart): Macroize expander from\n\t{s,u}mul{si,di}3_highpart patterns using DWIH mode iterator\n\tand any_extend code iterator.\n\t(*<s>muldi3_highpart_1): Macroize insn from\n\t*{s,u}muldi3_highpart_rex64 patterns using any_extend code iterator.\n\t(*<s>mulsi3_highpart_1): Macroize insn from *{s,u}mulsi3_highpart_1\n\tpatterns using any_extend code iterator.\n\t(*<s>mulsi3_highpart_zext): Macroize insn from\n\t*{s,u}mulsi3_highpart_zext patterns using any_extend code iterator.\n\nFrom-SVN: r152539", "tree": {"sha": "f4c4d356f30cb149980683fa4eeaa309bc8e1867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4c4d356f30cb149980683fa4eeaa309bc8e1867"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68bc087496642a6bb547fd523e19e443c21acc35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bc087496642a6bb547fd523e19e443c21acc35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68bc087496642a6bb547fd523e19e443c21acc35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68bc087496642a6bb547fd523e19e443c21acc35/comments", "author": null, "committer": null, "parents": [{"sha": "f484a91ab45ed2eeeb4d87b454e14578cc506428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f484a91ab45ed2eeeb4d87b454e14578cc506428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f484a91ab45ed2eeeb4d87b454e14578cc506428"}], "stats": {"total": 595, "additions": 188, "deletions": 407}, "files": [{"sha": "ae03a3baa1f4ef751c4b61c552e782ab832d57dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bc087496642a6bb547fd523e19e443c21acc35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bc087496642a6bb547fd523e19e443c21acc35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68bc087496642a6bb547fd523e19e443c21acc35", "patch": "@@ -1,3 +1,42 @@\n+2009-10-07  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (any_extend): New code iterator.\n+\t(u, s): New code attributes.\n+\t(sgnprefix): Ditto.\n+\t(DWIH): Rewrite as code iterator for SI and DI modes.\n+\t(DWI): Rewrite as mode attribute.\n+\t(dwi): New mode attribute.\n+\t(di): Depend on SI mode and DI mode.\n+\t(doubleint_general_operand): Remove mode attribute.\n+\n+\t(*lea_1): Macroize insn from *lea_1_rex64 and *lea_1 patterns using\n+\tDWIH mode iterator.\n+\n+\t(*add<mode>3_doubleword): Use DWIH as the base mode iterator.\n+\t(*sub<mode>3_doubleword): Ditto.\n+\n+\t(mul<mode>3): Macroize expander from mul{hi,si,di}3 patterns\n+\tusing SWIM248 mode iterator.\n+\t(*mul<mode>3_1): Macroize insn from mul{si,di}3_1 patterns\n+\tusing SWI48 mode iterator.\n+\t(<u>mul<mode><dwi>3): Macroize expander from {,u}mul{sidi,diti}3\n+\tpatterns using DWIH mode iterator and any_extend code iterator.\n+\t(<u>mulqihi3): Macroize expander from {,u}mulqihi3 patterns\n+\tusing any_extend code iterator.\n+\t(*<u>mul<mode><dwi>3_1): Macroize insn from {,u}mul{sidi,diti}3_1\n+\tpatterns using DWIH mode iterator and any_extend code iterator.\n+\t(*<u>mulqihi3_1): Macroize insn from {,u}mulqihi3_1 patterns\n+\tusing any_extend code iterator.\n+\t(<s>mul<mode>3_highpart): Macroize expander from\n+\t{s,u}mul{si,di}3_highpart patterns using DWIH mode iterator\n+\tand any_extend code iterator.\n+\t(*<s>muldi3_highpart_1): Macroize insn from\n+\t*{s,u}muldi3_highpart_rex64 patterns using any_extend code iterator.\n+\t(*<s>mulsi3_highpart_1): Macroize insn from *{s,u}mulsi3_highpart_1\n+\tpatterns using any_extend code iterator.\n+\t(*<s>mulsi3_highpart_zext): Macroize insn from\n+\t*{s,u}mulsi3_highpart_zext patterns using any_extend code iterator.\n+\n 2009-10-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (tree_add_const_value_attribute_for_decl): Don't add\n@@ -124,10 +163,8 @@\n \t(enum processor_type): Add PROCESSOR_PPCA2.\n \t* config/rs6000/rs6000.c (ppca2_cost): New costs.\n \t(rs6000_override_options): Add \"a2\" to processor_target_table.\n-\tUpdate rs6000_always_hint logic.  Correctly set rs6000_cost for\n-\ta2.\n-\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document\n-\t-mcpu=a2.\n+\tUpdate rs6000_always_hint logic.  Correctly set rs6000_cost for a2.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Document -mcpu=a2.\n \n 2009-10-06  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "6b68c54847d422a6f63a5a5671ba33984e749442", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 147, "deletions": 403, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68bc087496642a6bb547fd523e19e443c21acc35/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68bc087496642a6bb547fd523e19e443c21acc35/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=68bc087496642a6bb547fd523e19e443c21acc35", "patch": "@@ -702,6 +702,16 @@\n ;; Base name for x87 insn mnemonic.\n (define_code_attr absnegprefix [(abs \"abs\") (neg \"chs\")])\n \n+;; Used in signed and unsigned widening multiplications.\n+(define_code_iterator any_extend [sign_extend zero_extend])\n+\n+;; Various insn prefixes for widening operations.\n+(define_code_attr u [(sign_extend \"\") (zero_extend \"u\")])\n+(define_code_attr s [(sign_extend \"s\") (zero_extend \"u\")])\n+\n+;; Instruction prefix for widening operations.\n+(define_code_attr sgnprefix [(sign_extend \"i\") (zero_extend \"\")])\n+\n ;; All single word integer modes.\n (define_mode_iterator SWI [QI HI SI (DI \"TARGET_64BIT\")])\n \n@@ -720,12 +730,13 @@\n (define_mode_iterator SWIM248 [(HI \"TARGET_HIMODE_MATH\")\n \t\t      \t       SI (DI \"TARGET_64BIT\")])\n \n-;; Double word integer modes.\n-(define_mode_iterator DWI [(DI \"!TARGET_64BIT\")\n-\t\t\t   (TI \"TARGET_64BIT\")])\n-\n ;; Half mode for double word integer modes.\n-(define_mode_attr DWIH [(DI \"SI\") (TI \"DI\")])\n+(define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n+\t\t\t    (DI \"TARGET_64BIT\")])\n+\n+;; Double word integer modes.\n+(define_mode_attr DWI [(SI \"DI\") (DI \"TI\")])\n+(define_mode_attr dwi [(SI \"di\") (DI \"ti\")])\n \n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n@@ -740,7 +751,7 @@\n (define_mode_attr g [(SI \"g\") (DI \"rme\")])\n \n ;; Immediate operand constraint for double integer modes.\n-(define_mode_attr di [(DI \"iF\") (TI \"e\")])\n+(define_mode_attr di [(SI \"iF\") (DI \"e\")])\n \n ;; General operand predicate for integer modes.\n (define_mode_attr general_operand\n@@ -750,11 +761,6 @@\n \t (DI \"x86_64_general_operand\")\n \t (TI \"x86_64_general_operand\")])\n \n-;; General operand predicate for double integer modes.\n-(define_mode_attr doubleint_general_operand\n-\t[(DI \"general_operand\")\n-\t (TI \"x86_64_general_operand\")])\n-\n ;; SSE and x87 SFmode and DFmode floating point modes\n (define_mode_iterator MODEF [SF DF])\n \n@@ -783,7 +789,6 @@\n ;; This mode iterator allows :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n-\n \f\n ;; Scheduling descriptions\n \n@@ -6090,28 +6095,28 @@\n   \"\"\n   \"ix86_expand_binary_operator (PLUS, <MODE>mode, operands); DONE;\")\n \n-(define_insn_and_split \"*add<mode>3_doubleword\"\n-  [(set (match_operand:DWI 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(plus:DWI\n-\t  (match_operand:DWI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t  (match_operand:DWI 2 \"<doubleint_general_operand>\" \"ro<di>,r<di>\")))\n+(define_insn_and_split \"*add<dwi>3_doubleword\"\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(plus:<DWI>\n+\t  (match_operand:<DWI> 1 \"nonimmediate_operand\" \"%0,0\")\n+\t  (match_operand:<DWI> 2 \"<general_operand>\" \"ro<di>,r<di>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n+  \"ix86_binary_operator_ok (PLUS, <DWI>mode, operands)\"\n   \"#\"\n   \"reload_completed\"\n   [(parallel [(set (reg:CC FLAGS_REG)\n \t\t   (unspec:CC [(match_dup 1) (match_dup 2)]\n \t\t\t      UNSPEC_ADD_CARRY))\n \t      (set (match_dup 0)\n-\t\t   (plus:<DWIH> (match_dup 1) (match_dup 2)))])\n+\t\t   (plus:DWIH (match_dup 1) (match_dup 2)))])\n    (parallel [(set (match_dup 3)\n-\t\t   (plus:<DWIH>\n-\t\t     (plus:<DWIH>\n-\t\t       (ltu:<DWIH> (reg:CC FLAGS_REG) (const_int 0))\n+\t\t   (plus:DWIH\n+\t\t     (plus:DWIH\n+\t\t       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n \t\t       (match_dup 4))\n \t\t     (match_dup 5)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"split_<mode> (&operands[0], 3, &operands[0], &operands[3]);\")\n+  \"split_<dwi> (&operands[0], 3, &operands[0], &operands[3]);\")\n \n (define_insn \"add<mode>3_carry\"\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n@@ -6181,39 +6186,31 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*lea_1_rex64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"no_seg_address_operand\" \"p\"))]\n-  \"TARGET_64BIT\"\n-  \"lea{q}\\t{%a1, %0|%0, %a1}\"\n+(define_insn \"*lea_1\"\n+  [(set (match_operand:DWIH 0 \"register_operand\" \"=r\")\n+\t(match_operand:DWIH 1 \"no_seg_address_operand\" \"p\"))]\n+  \"\"\n+  \"lea{<imodesuffix>}\\t{%a1, %0|%0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n-   (set_attr \"mode\" \"DI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*lea_1\"\n+(define_insn \"*lea_2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"no_seg_address_operand\" \"p\"))]\n-  \"!TARGET_64BIT\"\n+\t(subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0))]\n+  \"TARGET_64BIT\"\n   \"lea{l}\\t{%a1, %0|%0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*lea_1_zext\"\n+(define_insn \"*lea_2_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t (subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0)))]\n+\t  (subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0)))]\n   \"TARGET_64BIT\"\n   \"lea{l}\\t{%a1, %k0|%k0, %a1}\"\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*lea_2_rex64\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(subreg:SI (match_operand:DI 1 \"no_seg_address_operand\" \"p\") 0))]\n-  \"TARGET_64BIT\"\n-  \"lea{l}\\t{%a1, %0|%0, %a1}\"\n-  [(set_attr \"type\" \"lea\")\n-   (set_attr \"mode\" \"SI\")])\n-\n (define_insn \"*add<mode>_1\"\n   [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=r,rm,r,r\")\n \t(plus:SWI48\n@@ -7624,27 +7621,27 @@\n   \"\"\n   \"ix86_expand_binary_operator (MINUS, <MODE>mode, operands); DONE;\")\n \n-(define_insn_and_split \"*sub<mode>3_doubleword\"\n-  [(set (match_operand:DWI 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(minus:DWI\n-\t  (match_operand:DWI 1 \"nonimmediate_operand\" \"0,0\")\n-\t  (match_operand:DWI 2 \"<doubleint_general_operand>\" \"ro<di>,r<di>\")))\n+(define_insn_and_split \"*sub<dwi>3_doubleword\"\n+  [(set (match_operand:<DWI> 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(minus:<DWI>\n+\t  (match_operand:<DWI> 1 \"nonimmediate_operand\" \"0,0\")\n+\t  (match_operand:<DWI> 2 \"<general_operand>\" \"ro<di>,r<di>\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"ix86_binary_operator_ok (MINUS, <MODE>mode, operands)\"\n   \"#\"\n   \"reload_completed\"\n   [(parallel [(set (reg:CC FLAGS_REG)\n \t\t   (compare:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0)\n-\t\t   (minus:<DWIH> (match_dup 1) (match_dup 2)))])\n+\t\t   (minus:DWIH (match_dup 1) (match_dup 2)))])\n    (parallel [(set (match_dup 3)\n-\t\t   (minus:<DWIH>\n+\t\t   (minus:DWIH\n \t\t     (match_dup 4)\n-\t\t     (plus:<DWIH>\n-\t\t       (ltu:<DWIH> (reg:CC FLAGS_REG) (const_int 0))\n+\t\t     (plus:DWIH\n+\t\t       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n \t\t       (match_dup 5))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"split_<mode> (&operands[0], 3, &operands[0], &operands[3]);\")\n+  \"split_<dwi> (&operands[0], 3, &operands[0], &operands[3]);\")\n \n (define_insn \"sub<mode>3_carry\"\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n@@ -7826,77 +7823,43 @@\n \f\n ;; Multiply instructions\n \n-(define_expand \"muldi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (mult:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"x86_64_general_operand\" \"\")))\n+(define_expand \"mul<mode>3\"\n+  [(parallel [(set (match_operand:SWIM248 0 \"register_operand\" \"\")\n+\t\t   (mult:SWIM248\n+\t\t     (match_operand:SWIM248 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SWIM248 2 \"<general_operand>\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\"\n+  \"\"\n   \"\")\n \n-;; On AMDFAM10\n-;; IMUL reg64, reg64, imm8 \tDirect\n-;; IMUL reg64, mem64, imm8 \tVectorPath\n-;; IMUL reg64, reg64, imm32 \tDirect\n-;; IMUL reg64, mem64, imm32 \tVectorPath\n-;; IMUL reg64, reg64 \t\tDirect\n-;; IMUL reg64, mem64 \t\tDirect\n-\n-(define_insn \"*muldi3_1_rex64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n-\t(mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n-\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"K,e,mr\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"@\n-   imul{q}\\t{%2, %1, %0|%0, %1, %2}\n-   imul{q}\\t{%2, %1, %0|%0, %1, %2}\n-   imul{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"imul\")\n-   (set_attr \"prefix_0f\" \"0,0,1\")\n-   (set (attr \"athlon_decode\")\n-\t(cond [(eq_attr \"cpu\" \"athlon\")\n-\t\t  (const_string \"vector\")\n-\t       (eq_attr \"alternative\" \"1\")\n-\t\t  (const_string \"vector\")\n-\t       (and (eq_attr \"alternative\" \"2\")\n-\t\t    (match_operand 1 \"memory_operand\" \"\"))\n-\t\t  (const_string \"vector\")]\n-\t      (const_string \"direct\")))\n-   (set (attr \"amdfam10_decode\")\n-\t(cond [(and (eq_attr \"alternative\" \"0,1\")\n-\t\t    (match_operand 1 \"memory_operand\" \"\"))\n-\t\t  (const_string \"vector\")]\n-\t      (const_string \"direct\")))\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"mulsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"general_operand\" \"\")))\n+(define_expand \"mulqi3\"\n+  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t   (mult:QI\n+\t\t     (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonimmediate_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n+  \"TARGET_QIMODE_MATH\"\n   \"\")\n \n ;; On AMDFAM10\n-;; IMUL reg32, reg32, imm8 \tDirect\n-;; IMUL reg32, mem32, imm8 \tVectorPath\n-;; IMUL reg32, reg32, imm32 \tDirect\n-;; IMUL reg32, mem32, imm32 \tVectorPath\n-;; IMUL reg32, reg32 \t\tDirect\n-;; IMUL reg32, mem32 \t\tDirect\n-\n-(define_insn \"*mulsi3_1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(mult:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"K,i,mr\")))\n+;; IMUL reg32/64, reg32/64, imm8 \tDirect\n+;; IMUL reg32/64, mem32/64, imm8 \tVectorPath\n+;; IMUL reg32/64, reg32/64, imm32 \tDirect\n+;; IMUL reg32/64, mem32/64, imm32 \tVectorPath\n+;; IMUL reg32/64, reg32/64 \t\tDirect\n+;; IMUL reg32/64, mem32/64 \t\tDirect\n+\n+(define_insn \"*mul<mode>3_1\"\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"=r,r,r\")\n+\t(mult:SWI48\n+\t  (match_operand:SWI48 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n+\t  (match_operand:SWI48 2 \"<general_operand>\" \"K,<i>,mr\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"@\n-   imul{l}\\t{%2, %1, %0|%0, %1, %2}\n-   imul{l}\\t{%2, %1, %0|%0, %1, %2}\n-   imul{l}\\t{%2, %0|%0, %2}\"\n+   imul{<imodesuffix>}\\t{%2, %1, %0|%0, %1, %2}\n+   imul{<imodesuffix>}\\t{%2, %1, %0|%0, %1, %2}\n+   imul{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"prefix_0f\" \"0,0,1\")\n    (set (attr \"athlon_decode\")\n@@ -7913,7 +7876,7 @@\n \t\t    (match_operand 1 \"memory_operand\" \"\"))\n \t\t  (const_string \"vector\")]\n \t      (const_string \"direct\")))\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*mulsi3_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n@@ -7945,27 +7908,21 @@\n \t      (const_string \"direct\")))\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"mulhi3\"\n-  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t   (mult:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t\t    (match_operand:HI 2 \"general_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_HIMODE_MATH\"\n-  \"\")\n-\n ;; On AMDFAM10\n ;; IMUL reg16, reg16, imm8 \tVectorPath\n ;; IMUL reg16, mem16, imm8 \tVectorPath\n ;; IMUL reg16, reg16, imm16 \tVectorPath\n ;; IMUL reg16, mem16, imm16 \tVectorPath\n ;; IMUL reg16, reg16 \t\tDirect\n ;; IMUL reg16, mem16 \t\tDirect\n+\n (define_insn \"*mulhi3_1\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n \t(mult:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%rm,rm,0\")\n \t\t (match_operand:HI 2 \"general_operand\" \"K,n,mr\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n+  \"TARGET_HIMODE_MATH\n+   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"@\n    imul{w}\\t{%2, %1, %0|%0, %1, %2}\n    imul{w}\\t{%2, %1, %0|%0, %1, %2}\n@@ -7984,14 +7941,6 @@\n \t      (const_string \"direct\")))\n    (set_attr \"mode\" \"HI\")])\n \n-(define_expand \"mulqi3\"\n-  [(parallel [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t\t   (mult:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t\t    (match_operand:QI 2 \"register_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_QIMODE_MATH\"\n-  \"\")\n-\n ;;On AMDFAM10\n ;; MUL reg8 \tDirect\n ;; MUL mem8 \tDirect\n@@ -8013,195 +7962,97 @@\n    (set_attr \"amdfam10_decode\" \"direct\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_expand \"umulqihi3\"\n-  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t   (mult:HI (zero_extend:HI\n-\t\t\t      (match_operand:QI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t    (zero_extend:HI\n-\t\t\t      (match_operand:QI 2 \"register_operand\" \"\"))))\n+(define_expand \"<u>mul<mode><dwi>3\"\n+  [(parallel [(set (match_operand:<DWI> 0 \"register_operand\" \"\")\n+\t\t   (mult:<DWI>\n+\t\t     (any_extend:<DWI>\n+\t\t       (match_operand:DWIH 1 \"nonimmediate_operand\" \"\"))\n+\t\t     (any_extend:<DWI>\n+\t\t       (match_operand:DWIH 2 \"register_operand\" \"\"))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_QIMODE_MATH\"\n+  \"\"\n   \"\")\n \n-(define_insn \"*umulqihi3_1\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n-\t(mult:HI (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (zero_extend:HI (match_operand:QI 2 \"nonimmediate_operand\" \"qm\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_QIMODE_MATH\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"mul{b}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"direct\")))\n-   (set_attr \"amdfam10_decode\" \"direct\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_expand \"mulqihi3\"\n+(define_expand \"<u>mulqihi3\"\n   [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t   (mult:HI (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t    (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"\"))))\n+\t\t   (mult:HI\n+\t\t     (any_extend:HI\n+\t\t       (match_operand:QI 1 \"nonimmediate_operand\" \"\"))\n+\t\t     (any_extend:HI\n+\t\t       (match_operand:QI 2 \"register_operand\" \"\"))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_QIMODE_MATH\"\n   \"\")\n \n-(define_insn \"*mulqihi3_insn\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n-\t(mult:HI (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (sign_extend:HI (match_operand:QI 2 \"nonimmediate_operand\" \"qm\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_QIMODE_MATH\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"imul{b}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"direct\")))\n-   (set_attr \"amdfam10_decode\" \"direct\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_expand \"umulditi3\"\n-  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t\t   (mult:TI (zero_extend:TI\n-\t\t\t      (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t    (zero_extend:TI\n-\t\t\t      (match_operand:DI 2 \"register_operand\" \"\"))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\"\n-  \"\")\n-\n-(define_insn \"*umulditi3_insn\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=A\")\n-\t(mult:TI (zero_extend:TI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (zero_extend:TI (match_operand:DI 2 \"nonimmediate_operand\" \"rm\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"mul{q}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"double\")))\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-;; We can't use this pattern in 64bit mode, since it results in two separate 32bit registers\n-(define_expand \"umulsidi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (mult:DI (zero_extend:DI\n-\t\t\t      (match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t    (zero_extend:DI\n-\t\t\t      (match_operand:SI 2 \"register_operand\" \"\"))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"!TARGET_64BIT\"\n-  \"\")\n-\n-(define_insn \"*umulsidi3_insn\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=A\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"rm\"))))\n+(define_insn \"*<u>mul<mode><dwi>3_1\"\n+  [(set (match_operand:<DWI> 0 \"register_operand\" \"=A\")\n+\t(mult:<DWI>\n+\t  (any_extend:<DWI>\n+\t    (match_operand:DWIH 1 \"nonimmediate_operand\" \"%0\"))\n+\t  (any_extend:<DWI>\n+\t    (match_operand:DWIH 2 \"nonimmediate_operand\" \"rm\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"mul{l}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"double\")))\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"mulditi3\"\n-  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t\t   (mult:TI (sign_extend:TI\n-\t\t\t      (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t    (sign_extend:TI\n-\t\t\t      (match_operand:DI 2 \"register_operand\" \"\"))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\"\n-  \"\")\n-\n-(define_insn \"*mulditi3_insn\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=A\")\n-\t(mult:TI (sign_extend:TI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (sign_extend:TI (match_operand:DI 2 \"nonimmediate_operand\" \"rm\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"imul{q}\\t%2\"\n+  \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n+  \"<sgnprefix>mul{<imodesuffix>}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n         (const_string \"double\")))\n    (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"mulsidi3\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (mult:DI (sign_extend:DI\n-\t\t\t      (match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t    (sign_extend:DI\n-\t\t\t      (match_operand:SI 2 \"register_operand\" \"\"))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"!TARGET_64BIT\"\n-  \"\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*mulsidi3_insn\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=A\")\n-\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (sign_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"rm\"))))\n+(define_insn \"*<u>mulqihi3_1\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(mult:HI\n+\t  (any_extend:HI\n+\t    (match_operand:QI 1 \"nonimmediate_operand\" \"%0\"))\n+\t  (any_extend:HI\n+\t    (match_operand:QI 2 \"nonimmediate_operand\" \"qm\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\n+  \"TARGET_QIMODE_MATH\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"imul{l}\\t%2\"\n+  \"<sgnprefix>mul{b}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n-        (const_string \"double\")))\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"SI\")])\n+        (const_string \"direct\")))\n+   (set_attr \"amdfam10_decode\" \"direct\")\n+   (set_attr \"mode\" \"QI\")])\n \n-(define_expand \"umuldi3_highpart\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (truncate:DI\n-\t\t     (lshiftrt:TI\n-\t\t       (mult:TI (zero_extend:TI\n-\t\t\t\t  (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t\t(zero_extend:TI\n-\t\t\t\t  (match_operand:DI 2 \"register_operand\" \"\")))\n-\t\t       (const_int 64))))\n-\t      (clobber (match_scratch:DI 3 \"\"))\n+(define_expand \"<s>mul<mode>3_highpart\"\n+  [(parallel [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+\t\t   (truncate:SWI48\n+\t\t     (lshiftrt:<DWI>\n+\t\t       (mult:<DWI>\n+\t\t\t (any_extend:<DWI>\n+\t\t\t   (match_operand:SWI48 1 \"nonimmediate_operand\" \"\"))\n+\t\t\t (any_extend:<DWI>\n+\t\t\t   (match_operand:SWI48 2 \"register_operand\" \"\")))\n+\t\t       (match_dup 4))))\n+\t      (clobber (match_scratch:SWI48 3 \"\"))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\"\n-  \"\")\n+  \"\"\n+  \"operands[4] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\")\n \n-(define_insn \"*umuldi3_highpart_rex64\"\n+(define_insn \"*<s>muldi3_highpart_1\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(truncate:DI\n \t  (lshiftrt:TI\n-\t    (mult:TI (zero_extend:TI\n-\t\t       (match_operand:DI 1 \"nonimmediate_operand\" \"%a\"))\n-\t\t     (zero_extend:TI\n-\t\t       (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+\t    (mult:TI\n+\t      (any_extend:TI\n+\t\t(match_operand:DI 1 \"nonimmediate_operand\" \"%a\"))\n+\t      (any_extend:TI\n+\t\t(match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n \t    (const_int 64))))\n    (clobber (match_scratch:DI 3 \"=1\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"mul{q}\\t%2\"\n+  \"<sgnprefix>mul{q}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n@@ -8211,33 +8062,20 @@\n    (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"DI\")])\n \n-(define_expand \"umulsi3_highpart\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (truncate:SI\n-\t\t     (lshiftrt:DI\n-\t\t       (mult:DI (zero_extend:DI\n-\t\t\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t\t(zero_extend:DI\n-\t\t\t\t  (match_operand:SI 2 \"register_operand\" \"\")))\n-\t\t       (const_int 32))))\n-\t      (clobber (match_scratch:SI 3 \"\"))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*umulsi3_highpart_insn\"\n+(define_insn \"*<s>mulsi3_highpart_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(truncate:SI\n \t  (lshiftrt:DI\n-\t    (mult:DI (zero_extend:DI\n-\t\t       (match_operand:SI 1 \"nonimmediate_operand\" \"%a\"))\n-\t\t     (zero_extend:DI\n-\t\t       (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n+\t    (mult:DI\n+\t      (any_extend:DI\n+\t\t(match_operand:SI 1 \"nonimmediate_operand\" \"%a\"))\n+\t      (any_extend:DI\n+\t\t(match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n \t    (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=1\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"mul{l}\\t%2\"\n+  \"<sgnprefix>mul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n@@ -8247,20 +8085,20 @@\n    (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*umulsi3_highpart_zext\"\n+(define_insn \"*<s>mulsi3_highpart_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(zero_extend:DI (truncate:SI\n \t  (lshiftrt:DI\n-\t    (mult:DI (zero_extend:DI\n+\t    (mult:DI (any_extend:DI\n \t\t       (match_operand:SI 1 \"nonimmediate_operand\" \"%a\"))\n-\t\t     (zero_extend:DI\n+\t\t     (any_extend:DI\n \t\t       (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n \t    (const_int 32)))))\n    (clobber (match_scratch:SI 3 \"=1\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"mul{l}\\t%2\"\n+  \"<sgnprefix>mul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n@@ -8270,99 +8108,6 @@\n    (set_attr \"amdfam10_decode\" \"double\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"smuldi3_highpart\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (truncate:DI\n-\t\t     (lshiftrt:TI\n-\t\t       (mult:TI (sign_extend:TI\n-\t\t\t\t  (match_operand:DI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t\t(sign_extend:TI\n-\t\t\t\t  (match_operand:DI 2 \"register_operand\" \"\")))\n-\t\t       (const_int 64))))\n-\t      (clobber (match_scratch:DI 3 \"\"))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_64BIT\"\n-  \"\")\n-\n-(define_insn \"*smuldi3_highpart_rex64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(truncate:DI\n-\t  (lshiftrt:TI\n-\t    (mult:TI (sign_extend:TI\n-\t\t       (match_operand:DI 1 \"nonimmediate_operand\" \"%a\"))\n-\t\t     (sign_extend:TI\n-\t\t       (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n-\t    (const_int 64))))\n-   (clobber (match_scratch:DI 3 \"=1\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"imul{q}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"double\")))\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"smulsi3_highpart\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (truncate:SI\n-\t\t     (lshiftrt:DI\n-\t\t       (mult:DI (sign_extend:DI\n-\t\t\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n-\t\t\t\t(sign_extend:DI\n-\t\t\t\t  (match_operand:SI 2 \"register_operand\" \"\")))\n-\t\t       (const_int 32))))\n-\t      (clobber (match_scratch:SI 3 \"\"))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*smulsi3_highpart_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(truncate:SI\n-\t  (lshiftrt:DI\n-\t    (mult:DI (sign_extend:DI\n-\t\t       (match_operand:SI 1 \"nonimmediate_operand\" \"%a\"))\n-\t\t     (sign_extend:DI\n-\t\t       (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n-\t    (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=1\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"imul{l}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"double\")))\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*smulsi3_highpart_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:DI (truncate:SI\n-\t  (lshiftrt:DI\n-\t    (mult:DI (sign_extend:DI\n-\t\t       (match_operand:SI 1 \"nonimmediate_operand\" \"%a\"))\n-\t\t     (sign_extend:DI\n-\t\t       (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n-\t    (const_int 32)))))\n-   (clobber (match_scratch:SI 3 \"=1\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"imul{l}\\t%2\"\n-  [(set_attr \"type\" \"imul\")\n-   (set (attr \"athlon_decode\")\n-     (if_then_else (eq_attr \"cpu\" \"athlon\")\n-        (const_string \"vector\")\n-        (const_string \"double\")))\n-   (set_attr \"amdfam10_decode\" \"double\")\n-   (set_attr \"mode\" \"SI\")])\n-\n ;; The patterns that match these are at the end of this file.\n \n (define_expand \"mulxf3\"\n@@ -8379,7 +8124,6 @@\n   \"(TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode))\n     || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"\")\n-\n \f\n ;; Divide instructions\n "}]}