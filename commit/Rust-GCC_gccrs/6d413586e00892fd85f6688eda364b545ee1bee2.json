{"sha": "6d413586e00892fd85f6688eda364b545ee1bee2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0MTM1ODZlMDA4OTJmZDg1ZjY2ODhlZGEzNjRiNTQ1ZWUxYmVlMg==", "commit": {"author": {"name": "Brooks Moses", "email": "brooks.moses@codesourcery.com", "date": "2007-01-04T23:00:41Z"}, "committer": {"name": "Brooks Moses", "email": "brooks@gcc.gnu.org", "date": "2007-01-04T23:00:41Z"}, "message": "intrinsic.texi (IAND): Clarify argument specifications.\n\n* intrinsic.texi (IAND): Clarify argument specifications.\n(IBCLR): Add documentation.\n(IBITS): Add documentation.\n(IBSET): Add documentation.\n(IEOR): Add documentation.\n(IERRNO): Add documentation.\n(INDEX): Add documentation.\n(IOR): Add documentation.\n(ISHFT): Add documentation.\n(ISHFTC): Add documentation.\n(KILL): Add documentation.\n(LEN_TRIM): Add documentation.\n\nFrom-SVN: r120452", "tree": {"sha": "f5e9ed38530e9892a3a5696cdf9dbffb921f4f33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5e9ed38530e9892a3a5696cdf9dbffb921f4f33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d413586e00892fd85f6688eda364b545ee1bee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d413586e00892fd85f6688eda364b545ee1bee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d413586e00892fd85f6688eda364b545ee1bee2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d413586e00892fd85f6688eda364b545ee1bee2/comments", "author": null, "committer": null, "parents": [{"sha": "bd7e4636d946650249b6c430d33e6ccb70eb302a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd7e4636d946650249b6c430d33e6ccb70eb302a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd7e4636d946650249b6c430d33e6ccb70eb302a"}], "stats": {"total": 267, "additions": 200, "deletions": 67}, "files": [{"sha": "25e2bff433b96098dbad508f4389cff27f7ce216", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d413586e00892fd85f6688eda364b545ee1bee2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d413586e00892fd85f6688eda364b545ee1bee2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6d413586e00892fd85f6688eda364b545ee1bee2", "patch": "@@ -1,3 +1,18 @@\n+2007-01-04  Brooks Moses  <brooks.moses@codesourcery.com>\n+\n+\t* intrinsic.texi (IAND): Clarify argument specifications.\n+\t(IBCLR): Add documentation.\n+\t(IBITS): Add documentation.\n+\t(IBSET): Add documentation.\n+\t(IEOR): Add documentation.\n+\t(IERRNO): Add documentation.\n+\t(INDEX): Add documentation.\n+\t(IOR): Add documentation.\n+\t(ISHFT): Add documentation.\n+\t(ISHFTC): Add documentation.\n+\t(KILL): Add documentation.\n+\t(LEN_TRIM): Add documentation.\n+\n 2007-01-04  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \tPR 30235"}, {"sha": "61145d0739ba821644d766bb1140d1c7d8dfcf0d", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 185, "deletions": 67, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d413586e00892fd85f6688eda364b545ee1bee2/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d413586e00892fd85f6688eda364b545ee1bee2/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=6d413586e00892fd85f6688eda364b545ee1bee2", "patch": "@@ -4540,16 +4540,20 @@ F95 and later\n Elemental function\n \n @item @emph{Syntax}:\n-@code{RESULT = IAND(X, Y)}\n+@code{RESULT = IAND(I, J)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be @code{INTEGER(*)}.\n-@item @var{Y} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{J} @tab The type shall be @code{INTEGER(*)}, of the same\n+kind as @var{I}.  (As a GNU extension, different kinds are also \n+permitted.)\n @end multitable\n \n @item @emph{Return value}:\n-The return type is @code{INTEGER(*)} after cross-promotion of the arguments. \n+The return type is @code{INTEGER(*)}, of the same kind as the\n+arguments.  (If the argument kinds differ, it is of the same kind as\n+the larger argument.)\n \n @item @emph{Example}:\n @smallexample\n@@ -4612,81 +4616,106 @@ F2003 functions and subroutines: @ref{GET_COMMAND}, @ref{GET_COMMAND_ARGUMENT},\n @cindex @code{IBCLR} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{IBCLR} returns the value of @var{I} with the bit at position\n+@var{POS} set to zero.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = IBCLR(I, POS)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return value is of type @code{INTEGER(*)} and of the same kind as\n+@var{I}.\n \n @item @emph{See also}:\n @ref{IBITS}, @ref{IBSET}, @ref{IAND}, @ref{IOR}, @ref{IEOR}\n @end table\n \n \n \n-\n @node IBITS\n @section @code{IBITS} --- Bit extraction\n @cindex @code{IBITS} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{IBITS} extracts a field of length @var{LEN} from @var{I},\n+starting from bit position @var{POS} and extending left for @var{LEN}\n+bits.  The result is right-justified and the remaining bits are\n+zeroed.  The value of @code{POS+LEN} must be less than or equal to the\n+value @code{BIT_SIZE(I)}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = IBITS(I, POS, LEN)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{LEN} @tab The type shall be @code{INTEGER(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n-@item @emph{See also}:\n-@ref{IBCLR}, @ref{IBSET}, @ref{IAND}, @ref{IOR}, @ref{IEOR}\n+The return value is of type @code{INTEGER(*)} and of the same kind as\n+@var{I}.\n \n+@item @emph{See also}:\n+@ref{BIT_SIZE}, @ref{IBCLR}, @ref{IBSET}, @ref{IAND}, @ref{IOR}, @ref{IEOR}\n @end table\n \n \n \n-\n @node IBSET\n @section @code{IBSET} --- Set bit\n @cindex @code{IBSET} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{IBSET} returns the value of @var{I} with the bit at position\n+@var{POS} set to one.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = IBSET(I, POS)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{POS} @tab The type shall be @code{INTEGER(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return value is of type @code{INTEGER(*)} and of the same kind as\n+@var{I}.\n \n @item @emph{See also}:\n @ref{IBCLR}, @ref{IBITS}, @ref{IAND}, @ref{IOR}, @ref{IEOR}\n-\n @end table\n \n \n@@ -4797,80 +4826,110 @@ end program test_idate\n @cindex @code{IEOR} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{IEOR} returns the bitwise boolean exclusive-OR of @var{I} and\n+@var{J}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = IEOR(I, J)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{J} @tab The type shall be @code{INTEGER(*)}, of the same\n+kind as @var{I}.  (As a GNU extension, different kinds are also \n+permitted.)\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return type is @code{INTEGER(*)}, of the same kind as the\n+arguments.  (If the argument kinds differ, it is of the same kind as\n+the larger argument.)\n \n @item @emph{See also}:\n @ref{IOR}, @ref{IAND}, @ref{IBITS}, @ref{IBSET}, @ref{IBCLR},\n @end table\n \n \n \n-\n @node IERRNO\n @section @code{IERRNO} --- Get the last system error number\n @cindex @code{IERRNO} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n+Returns the last system error number, as given by the C @code{errno()}\n+function.\n+\n @item @emph{Standard}:\n GNU extension\n \n @item @emph{Class}:\n+Elemental function\n+\n @item @emph{Syntax}:\n+@code{I = IERRNO()}\n+\n @item @emph{Arguments}:\n+None.\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n+The return value is of type @code{INTEGER} and of the default integer\n+kind.\n \n @item @emph{See also}:\n @ref{PERROR}\n @end table\n \n \n \n-\n @node INDEX\n @section @code{INDEX} --- Position of a substring within a string\n @cindex @code{INDEX} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n+Returns the position of the start of the first occurrence of string\n+@var{SUBSTRING} as a substring in @var{STRING}, counting from one.  If\n+@var{SUBSTRING} is not present in @var{STRING}, zero is returned.  If \n+the @var{BACK} argument is present and true, the return value is the\n+start of the last occurrence rather than the first.\n+\n @item @emph{Standard}:\n F77 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{I = INDEX(STRING, SUBSTRING [, BACK])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{STRING} @tab Shall be a scalar @code{CHARACTER(*)}, with\n+@code{INTENT(IN)}\n+@item @var{SUBSTRING} @tab Shall be a scalar @code{CHARACTER(*)}, with\n+@code{INTENT(IN)}\n+@item @var{BACK} @tab (Optional) Shall be a scalar @code{LOGICAL(*)}, with\n+@code{INTENT(IN)}\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return value is of type @code{INTEGER} and of the default integer\n+kind.\n+\n @item @emph{See also}:\n @end table\n \n \n \n-\n @node INT\n @section @code{INT} --- Convert to integer type\n @cindex @code{INT} intrinsic\n@@ -4937,27 +4996,37 @@ end program\n \n \n \n-\n @node IOR\n @section @code{IOR} --- Bitwise logical or\n @cindex @code{IOR} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{IEOR} returns the bitwise boolean OR of @var{I} and\n+@var{J}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = IEOR(I, J)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{J} @tab The type shall be @code{INTEGER(*)}, of the same\n+kind as @var{I}.  (As a GNU extension, different kinds are also \n+permitted.)\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return type is @code{INTEGER(*)}, of the same kind as the\n+arguments.  (If the argument kinds differ, it is of the same kind as\n+the larger argument.)\n \n @item @emph{See also}:\n @ref{IEOR}, @ref{IAND}, @ref{IBITS}, @ref{IBSET}, @ref{IBCLR},\n@@ -5017,21 +5086,34 @@ end program test_irand\n @cindex @code{ISHFT} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{ISHFT} returns a value corresponding to @var{I} with all of the\n+bits shifted @var{SHIFT} places.  A value of @var{SHIFT} greater than\n+zero corresponds to a left shift, a value of zero corresponds to no\n+shift, and a value less than zero corresponds to a right shift.  If the\n+absolute value of @var{SHIFT} is greater than @code{BIT_SIZE(I)}, the\n+value is undefined.  Bits shifted out from the left end or right end are\n+lost; zeros are shifted in from the opposite end.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = ISHFT(I, SHIFT)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return value is of type @code{INTEGER(*)} and of the same kind as\n+@var{I}.\n \n @item @emph{See also}:\n @ref{ISHFTC}\n@@ -5045,21 +5127,38 @@ Elemental function\n @cindex @code{ISHFTC} intrinsic\n @cindex bit operations\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+@code{ISHFTC} returns a value corresponding to @var{I} with the\n+rightmost @var{SIZE} bits shifted circularly @var{SHIFT} places; that\n+is, bits shifted out one end are shifted into the opposite end.  A value\n+of @var{SHIFT} greater than zero corresponds to a left shift, a value of\n+zero corresponds to no shift, and a value less than zero corresponds to\n+a right shift.  The absolute value of @var{SHIFT} must be less than\n+@var{SIZE}.  If the @var{SIZE} argument is omitted, it is taken to be\n+equivalent to @code{BIT_SIZE(I)}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = ISHFTC(I, SHIFT [, SIZE])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{I} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{SHIFT} @tab The type shall be @code{INTEGER(*)}.\n+@item @var{SIZE} @tab (Optional) The type shall be @code{INTEGER(*)};\n+the value must be greater than zero and less than or equal to\n+@code{BIT_SIZE(I)}.\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return value is of type @code{INTEGER(*)} and of the same kind as\n+@var{I}.\n \n @item @emph{See also}:\n @ref{ISHFT}\n@@ -5114,23 +5213,29 @@ end program test_itime\n @node KILL\n @section @code{KILL} --- Send a signal to a process\n @cindex @code{KILL} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n @item @emph{Standard}:\n-GNU extension\n+Sends the signal specified by @var{SIGNAL} to the process @var{PID}.\n+See @code{kill(2)}.\n \n @item @emph{Class}:\n Subroutine\n \n @item @emph{Syntax}:\n+@code{CALL KILL(PID, SIGNAL [, STATUS])}\n+\n @item @emph{Arguments}:\n-@item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+@multitable @columnfractions .15 .80\n+@item @var{PID} @tab Shall be a scalar @code{INTEGER}, with\n+@code{INTENT(IN)}\n+@item @var{SIGNAL} @tab Shall be a scalar @code{INTEGER}, with\n+@code{INTENT(IN)}\n+@item @var{STATUS} @tab (Optional) status flag of type @code{INTEGER(4)} or\n+                        @code{INTEGER(8)}. Returns 0 on success, or a\n+                        system-specific error code otherwise.\n+@end multitable\n \n @item @emph{See also}:\n @ref{ABORT}, @ref{EXIT}\n@@ -5209,50 +5314,63 @@ Inquiry function\n @node LEN\n @section @code{LEN} --- Length of a character entity\n @cindex @code{LEN} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n+Returns the length of a character string.  If @var{STRING} is an array,\n+the length of an element of @var{STRING} is returned.  Note that\n+@var{STRING} need not be defined when this intrinsic is invoked, since\n+only the length, not the content, of @var{STRING} is needed.\n+\n @item @emph{Standard}:\n F77 and later\n \n @item @emph{Class}:\n Inquiry function\n \n @item @emph{Syntax}:\n+@code{L = LEN(STRING)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{STRING} @tab Shall be a scalar or array of type\n+@code{CHARACTER(*)}, with @code{INTENT(IN)}\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{Specific names}:\n+The return value is an @code{INTEGER} of the default kind.\n \n @item @emph{See also}:\n @ref{LEN_TRIM}, @ref{ADJUSTL}, @ref{ADJUSTR}\n @end table\n \n \n \n-\n @node LEN_TRIM\n @section @code{LEN_TRIM} --- Length of a character entity without trailing blank characters\n @cindex @code{LEN_TRIM} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n+Returns the length of a character string, ignoring any trailing blanks.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{L = LEN_TRIM(STRING)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER(*)},\n+with @code{INTENT(IN)}\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n+The return value is of @code{INTEGER(kind=4)} type.\n \n @item @emph{See also}:\n @ref{LEN}, @ref{ADJUSTL}, @ref{ADJUSTR}"}]}