{"sha": "e7eacc8e2774b2457c625cb3b86e90d93af42382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdlYWNjOGUyNzc0YjI0NTdjNjI1Y2IzYjg2ZTkwZDkzYWY0MjM4Mg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-08-06T17:08:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-06T17:08:29Z"}, "message": "elf.h (TEXT_SPACE_P, [...]): Delete.\n\n        * elf.h (TEXT_SPACE_P, FUNCTION_NAME_P): Delete.\n        (ASM_GLOBALIZE_LABEL, ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT): Likewise.\n        (ASM_FILE_START): Import _mcount with the right type.\n        (ASM_DECLARE_FUNCTION_NAME): Define.\n        (ASM_OUTPUT_EXTERNAL, ASM_OUTPUT_EXTERNAL_LIBCALL): Define.\n        * pa.c (output_function_prologue): Always emit the function's label\n        here.\n        * pa.h (TEXT_SPACE_P): Define.\n        (FUNCTION_NAME_P, ENCODE_SECTION_INFO, STRIP_NAME_ENCODING): Likewise.\n        (ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT, ASM_GLOBALIZE_LABEL): Likewise.\n        * som.h (TEXT_SPACE_P): Delete.\n        (FUNCTION_NAME_P, ENCODE_SECTION_INFO, STRIP_NAME_ENCODING): Likewise.\n        (ASM_GLOBALIZE_LABEL, ASM_OUTPUT_INT): Likewise.\n\nFrom-SVN: r28549", "tree": {"sha": "43336e6851eb3c343f08dff8c51b6ead0c18f821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43336e6851eb3c343f08dff8c51b6ead0c18f821"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7eacc8e2774b2457c625cb3b86e90d93af42382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7eacc8e2774b2457c625cb3b86e90d93af42382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7eacc8e2774b2457c625cb3b86e90d93af42382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7eacc8e2774b2457c625cb3b86e90d93af42382/comments", "author": null, "committer": null, "parents": [{"sha": "3a6bdebaa06c757b5d41c8fffd2f1f4048ea0156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6bdebaa06c757b5d41c8fffd2f1f4048ea0156", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6bdebaa06c757b5d41c8fffd2f1f4048ea0156"}], "stats": {"total": 263, "additions": 158, "deletions": 105}, "files": [{"sha": "2b5d39fc202795be61b10592327b62464bb0d5be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7eacc8e2774b2457c625cb3b86e90d93af42382", "patch": "@@ -1,3 +1,19 @@\n+Fri Aug  6 11:05:29 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* elf.h (TEXT_SPACE_P, FUNCTION_NAME_P): Delete.\n+\t(ASM_GLOBALIZE_LABEL, ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT): Likewise.\n+\t(ASM_FILE_START): Import _mcount with the right type.\n+\t(ASM_DECLARE_FUNCTION_NAME): Define.\n+\t(ASM_OUTPUT_EXTERNAL, ASM_OUTPUT_EXTERNAL_LIBCALL): Define.\n+\t* pa.c (output_function_prologue): Always emit the function's label\n+\there.\n+\t* pa.h (TEXT_SPACE_P): Define.\n+\t(FUNCTION_NAME_P, ENCODE_SECTION_INFO, STRIP_NAME_ENCODING): Likewise.\n+\t(ASM_OUTPUT_INT, ASM_OUTPUT_DOUBLE_INT, ASM_GLOBALIZE_LABEL): Likewise.\n+\t* som.h (TEXT_SPACE_P): Delete.\n+\t(FUNCTION_NAME_P, ENCODE_SECTION_INFO, STRIP_NAME_ENCODING): Likewise.\n+\t(ASM_GLOBALIZE_LABEL, ASM_OUTPUT_INT): Likewise.\n+\n Thu Aug  5 19:29:39 1999  Jim Wilson  <wilson@cygnus.com>\n \n \t* expr.c (emit_group_load): Allow src to be a CONCAT."}, {"sha": "af5031c093ed93c50d83f26df9417ddfcfc26df3", "filename": "gcc/config/pa/elf.h", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Felf.h?ref=e7eacc8e2774b2457c625cb3b86e90d93af42382", "patch": "@@ -21,32 +21,10 @@ Boston, MA 02111-1307, USA.  */\n /* So we can conditionalize small amounts of code in pa.c or pa.md.  */\n #define OBJ_ELF\n \n-/* Dummy definitions.  We do not care about this stuff for ELF.  */\n-#define TEXT_SPACE_P(DECL) 0\n-#define FUNCTION_NAME_P(NAME) 0\n-\n #define TEXT_SECTION_ASM_OP \"\\t.text\"\n #define DATA_SECTION_ASM_OP \"\\t.data\"\n #define BSS_SECTION_ASM_OP \"\\t.section\\t.bss\"\n \n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)  \\\n-  (fputs (\"\\t.globl \", FILE), assemble_name (FILE, NAME), fputs (\"\\n\", FILE))\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-{ fputs (\"\\t.word \", FILE);\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\\\n-  fputs (\"\\n\", FILE);}\n-\n-#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n-{ fputs (\"\\t.dword \", FILE);\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\\\n-  fputs (\"\\n\", FILE);}\n-\n #undef ASM_FILE_START\n #define ASM_FILE_START(FILE) \\\n do {  \\\n@@ -57,7 +35,57 @@ do {  \\\n      else \\\n        fputs(\"\\t.LEVEL 1.0\\n\", FILE); \\\n      if (profile_flag)\\\n-       fprintf (FILE, \"\\t.IMPORT _mcount, CODE\\n\");\\\n+       fprintf (FILE, \"\\t.IMPORT _mcount, ENTRY\\n\");\\\n      if (write_symbols != NO_DEBUG) \\\n        output_file_directive ((FILE), main_input_filename); \\\n    } while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+do {  \\\n+  if (TREE_PUBLIC (DECL)) \\\n+    { \\\n+      fputs (\"\\t.EXPORT \", FILE); \\\n+      assemble_name (FILE, NAME); \\\n+      fputs (\",ENTRY\\n\", FILE); \\\n+    } \\\n+   } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.\n+\n+   We call assemble_name, which in turn sets TREE_SYMBOL_REFERENCED.  This\n+   macro will restore the original value of TREE_SYMBOL_REFERENCED to avoid\n+   placing useless function definitions in the output file.\n+\n+   Also note that the SOM based tools need the symbol imported as a CODE\n+   symbol, while the ELF based tools require the symbol to be imported as\n+   an ENTRY symbol.  What a crock.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+  do { int save_referenced;\t\t\t\t\t\\\n+       save_referenced = TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)); \\\n+       fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n+\t assemble_name (FILE, NAME);\t\t\t\t\\\n+       if (FUNCTION_NAME_P (NAME))     \t\t\t\t\\\n+\t fputs (\",ENTRY\\n\", FILE);\t\t\t\t\\\n+       else\t\t\t\t\t\t\t\\\n+\t fputs (\",DATA\\n\", FILE);\t\t\t\t\\\n+       TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (DECL)) = save_referenced; \\\n+     } while (0)\n+\n+/* The bogus HP assembler requires ALL external references to be\n+   \"imported\", even library calls. They look a bit different, so\n+   here's this macro.\n+\n+   Also note not all libcall names are passed to ENCODE_SECTION_INFO\n+   (__main for example).  To make sure all libcall names have section\n+   info recorded in them, we do it here.  */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, RTL) \\\n+  do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n+       if (!function_label_operand (RTL, VOIDmode))\t\t\t\\\n+\t hppa_encode_label (RTL, 1);\t\t\t\t\t\\\n+       assemble_name (FILE, XSTR ((RTL), 0));\t\t       \t\t\\\n+       fputs (\",ENTRY\\n\", FILE);\t\t\t\t\t\\\n+     } while (0)\n+"}, {"sha": "12b28c6322c8f367797809fe4c982003800046bc", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e7eacc8e2774b2457c625cb3b86e90d93af42382", "patch": "@@ -2651,9 +2651,7 @@ output_function_prologue (file, size)\n   /* The function's label and associated .PROC must never be\n      separated and must be output *after* any profiling declarations\n      to avoid changing spaces/subspaces within a procedure.  */\n-#ifdef OBJ_SOM\n   ASM_OUTPUT_LABEL (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n-#endif\n   fputs (\"\\t.PROC\\n\", file);\n \n   /* hppa_expand_prologue does the dirty work now.  We just need"}, {"sha": "7ea6bdb6009750697e91a5cba1f979db79caa590", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=e7eacc8e2774b2457c625cb3b86e90d93af42382", "patch": "@@ -1586,6 +1586,59 @@ extern struct rtx_def *hppa_legitimize_address ();\n   else\t\t\t\t\t\\\n     readonly_data_section ();\n \n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   The macro definition, if any, is executed immediately after the\n+   rtl for DECL or other node is created.\n+   The value of the rtl will be a `mem' whose address is a\n+   `symbol_ref'.\n+\n+   The usual thing for this macro to do is to a flag in the\n+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n+   name string in the `symbol_ref' (if one bit is not enough\n+   information).\n+\n+   On the HP-PA we use this to indicate if a symbol is in text or\n+   data space.  Also, function labels need special treatment. */\n+\n+#define TEXT_SPACE_P(DECL)\\\n+  (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\t\t\\\n+   || (TREE_CODE (DECL) == VAR_DECL\t\t\t\t\t\\\n+       && TREE_READONLY (DECL) && ! TREE_SIDE_EFFECTS (DECL)\t\t\\\n+       && (! DECL_INITIAL (DECL) || ! reloc_needed (DECL_INITIAL (DECL))) \\\n+       && !flag_pic)\t\t\t\t\t\t\t\\\n+   || (TREE_CODE_CLASS (TREE_CODE (DECL)) == 'c'\t\t\t\\\n+       && !(TREE_CODE (DECL) == STRING_CST && flag_writable_strings)))\n+\n+#define FUNCTION_NAME_P(NAME) \\\n+(*(NAME) == '@' || (*(NAME) == '*' && *((NAME) + 1) == '@'))\n+\n+#define ENCODE_SECTION_INFO(DECL)\\\n+do\t\t\t\t\t\t\t\\\n+  { if (TEXT_SPACE_P (DECL))\t\t\t\t\\\n+      {\trtx _rtl;\t\t\t\t\t\\\n+\tif (TREE_CODE (DECL) == FUNCTION_DECL\t\t\\\n+\t    || TREE_CODE (DECL) == VAR_DECL)\t\t\\\n+\t  _rtl = DECL_RTL (DECL);\t\t\t\\\n+\telse\t\t\t\t\t\t\\\n+\t  _rtl = TREE_CST_RTL (DECL);\t\t\t\\\n+\tSYMBOL_REF_FLAG (XEXP (_rtl, 0)) = 1;\t\t\\\n+\tif (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+\t  hppa_encode_label (XEXP (DECL_RTL (DECL), 0), 0);\\\n+      }\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* Store the user-specified part of SYMBOL_NAME in VAR.\n+   This is sort of inverse to ENCODE_SECTION_INFO.  */\n+\n+#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\\\n+  (VAR) = ((SYMBOL_NAME)  + ((SYMBOL_NAME)[0] == '*' ?\t\\\n+\t\t\t     1 + (SYMBOL_NAME)[1] == '@'\\\n+\t\t\t     : (SYMBOL_NAME)[0] == '@'))\n+\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? TImode : DImode)\n@@ -1882,6 +1935,27 @@ extern struct rtx_def *hppa_legitimize_address ();\n        fprintf (FILE, \"\\t.word 0x%lx\\n\", l);\t\t\t\t\\\n      } while (0)\n \n+/* This is how to output an assembler line defining an `int' constant. \n+\n+   This is made more complicated by the fact that functions must be\n+   prefixed by a P% as well as code label references for the exception\n+   table -- otherwise the linker chokes.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+{ fputs (\"\\t.word \", FILE);\t\t\t\\\n+  if (function_label_operand (VALUE, VOIDmode))\t\\\n+    fputs (\"P%\", FILE);\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\\\n+  fputs (\"\\n\", FILE);}\n+\n+/* Likewise for double integers.  */\n+#define ASM_OUTPUT_DOUBLE_INT(FILE,VALUE)  \\\n+{ fputs (\"\\t.dword \", FILE);\t\t\t\\\n+  if (function_label_operand (VALUE, VOIDmode))\t\\\n+    fputs (\"P%\", FILE);\t\t\t\t\\\n+  output_addr_const (FILE, (VALUE));\t\t\\\n+  fputs (\"\\n\", FILE);}\n+\n /* Likewise for `short' and `char' constants.  */\n \n #define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n@@ -1899,6 +1973,18 @@ extern struct rtx_def *hppa_legitimize_address ();\n #define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n   fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n \n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    /* We only handle DATA objects here, functions are globalized in\t\\\n+       ASM_DECLARE_FUNCTION_NAME.  */\t\t\t\t\t\\\n+    if (! FUNCTION_NAME_P (NAME))\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfputs (\"\\t.EXPORT \", FILE);\t\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfputs (\",DATA\\n\", FILE);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii ((FILE), (P), (SIZE))\n "}, {"sha": "f9c7682d2eaf9217c5cdfb0c4b515392414d13cd", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 5, "deletions": 80, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7eacc8e2774b2457c625cb3b86e90d93af42382/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=e7eacc8e2774b2457c625cb3b86e90d93af42382", "patch": "@@ -136,59 +136,6 @@ do {\t\t\t\t\t\t\t\t\\\n #endif\n \n \f\n-/* Define this macro if references to a symbol must be treated\n-   differently depending on something about the variable or\n-   function named by the symbol (such as what section it is in).\n-\n-   The macro definition, if any, is executed immediately after the\n-   rtl for DECL or other node is created.\n-   The value of the rtl will be a `mem' whose address is a\n-   `symbol_ref'.\n-\n-   The usual thing for this macro to do is to a flag in the\n-   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n-   name string in the `symbol_ref' (if one bit is not enough\n-   information).\n-\n-   On the HP-PA we use this to indicate if a symbol is in text or\n-   data space.  Also, function labels need special treatment. */\n-\n-#define TEXT_SPACE_P(DECL)\\\n-  (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\t\t\\\n-   || (TREE_CODE (DECL) == VAR_DECL\t\t\t\t\t\\\n-       && TREE_READONLY (DECL) && ! TREE_SIDE_EFFECTS (DECL)\t\t\\\n-       && (! DECL_INITIAL (DECL) || ! reloc_needed (DECL_INITIAL (DECL))) \\\n-       && !flag_pic)\t\t\t\t\t\t\t\\\n-   || (TREE_CODE_CLASS (TREE_CODE (DECL)) == 'c'\t\t\t\\\n-       && !(TREE_CODE (DECL) == STRING_CST && flag_writable_strings)))\n-\n-#define FUNCTION_NAME_P(NAME) \\\n-(*(NAME) == '@' || (*(NAME) == '*' && *((NAME) + 1) == '@'))\n-\n-#define ENCODE_SECTION_INFO(DECL)\\\n-do\t\t\t\t\t\t\t\\\n-  { if (TEXT_SPACE_P (DECL))\t\t\t\t\\\n-      {\trtx _rtl;\t\t\t\t\t\\\n-\tif (TREE_CODE (DECL) == FUNCTION_DECL\t\t\\\n-\t    || TREE_CODE (DECL) == VAR_DECL)\t\t\\\n-\t  _rtl = DECL_RTL (DECL);\t\t\t\\\n-\telse\t\t\t\t\t\t\\\n-\t  _rtl = TREE_CST_RTL (DECL);\t\t\t\\\n-\tSYMBOL_REF_FLAG (XEXP (_rtl, 0)) = 1;\t\t\\\n-\tif (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n-\t  hppa_encode_label (XEXP (DECL_RTL (DECL), 0), 0);\\\n-      }\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* Store the user-specified part of SYMBOL_NAME in VAR.\n-   This is sort of inverse to ENCODE_SECTION_INFO.  */\n-\n-#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME)\t\\\n-  (VAR) = ((SYMBOL_NAME)  + ((SYMBOL_NAME)[0] == '*' ?\t\\\n-\t\t\t     1 + (SYMBOL_NAME)[1] == '@'\\\n-\t\t\t     : (SYMBOL_NAME)[0] == '@'))\n-\n /* NAME refers to the function's name.  If we are placing each function into\n    its own section, we need to switch to the section for this function.  Note\n    that the section name will have a \".\" prefix.  */\n@@ -395,7 +342,11 @@ DTORS_SECTION_FUNCTION\n \n    We call assemble_name, which in turn sets TREE_SYMBOL_REFERENCED.  This\n    macro will restore the original value of TREE_SYMBOL_REFERENCED to avoid\n-   placing useless function definitions in the output file.  */\n+   placing useless function definitions in the output file.\n+\n+   Also note that the SOM based tools need the symbol imported as a CODE\n+   symbol, while the ELF based tools require the symbol to be imported as\n+   an ENTRY symbol.  What a crock.  */\n \n #define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n   do { int save_referenced;\t\t\t\t\t\\\n@@ -425,34 +376,8 @@ DTORS_SECTION_FUNCTION\n        fputs (\",CODE\\n\", FILE);\t\t\t\t\t\t\\\n      } while (0)\n \n-#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    /* We only handle DATA objects here, functions are globalized in\t\\\n-       ASM_DECLARE_FUNCTION_NAME.  */\t\t\t\t\t\\\n-    if (! FUNCTION_NAME_P (NAME))\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfputs (\"\\t.EXPORT \", FILE);\t\t\t\t\t\\\n-\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n-\tfputs (\",DATA\\n\", FILE);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n #define ASM_FILE_END(FILE) output_deferred_plabels (FILE)\n \n-/* This is how to output an assembler line defining an `int' constant. \n-\n-   This is made more complicated by the fact that functions must be\n-   prefixed by a P% as well as code label references for the exception\n-   table -- otherwise the linker chokes.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-{ fputs (\"\\t.word \", FILE);\t\t\t\\\n-  if (function_label_operand (VALUE, VOIDmode))\t\\\n-    fputs (\"P%\", FILE);\t\t\t\t\\\n-  output_addr_const (FILE, (VALUE));\t\t\\\n-  fputs (\"\\n\", FILE);}\n-\n-\n /* We want __gcc_plt_call to appear in every program built by\n    gcc, so we make a reference to it out of __main.\n    We use the asm statement to fool the optimizer into not"}]}