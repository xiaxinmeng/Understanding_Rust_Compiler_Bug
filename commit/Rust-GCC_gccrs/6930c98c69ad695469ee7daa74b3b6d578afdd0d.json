{"sha": "6930c98c69ad695469ee7daa74b3b6d578afdd0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkzMGM5OGM2OWFkNjk1NDY5ZWU3ZGFhNzRiM2I2ZDU3OGFmZGQwZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:53:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:53:14Z"}, "message": "Use function_arg_info for TARGET_FUNCTION_ARG_ADVANCE\n\nThere seems to be a bit of confusion around this one.  Almost all\ncallers pass the same arguments as TARGET_FUNCTION_ARG, meaning\nthat the mode is the promoted mode rather than the type mode.\nBut the calls.c handling for normal typed arguments instead passes\nthe unpromoted TYPE_MODE (despite passing the promoted mode to\nTARGET_FUNCTION_ARG).  I've kept this behaviour with a ??? comment.\n\n(The calls.c handling of libgcc functions does pass the promoted\nmode though, as does the function.c handling of incoming arguments.)\n\nAlso, a couple of the arm callers don't seem to be using the hook\ncorrectly.  Again I kept the current choices and added a ??? comment.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (function_arg_advance): Take a function_arg_info instead\n\tof a mode, type and named flag.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_function_arg_advance): Take a function_arg_info\n\tinstead of a mode, type and named flag.\n\t* targhooks.c (default_function_arg_advance): Likewise.\n\t* calls.c (initialize_argument_information): Update call to\n\ttargetm.calls.function_arg_advance.\n\t(emit_library_call_value_1): Likewise.\n\t* dse.c (get_call_args): Likewise.\n\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n\t* function.c (assign_parms, gimplify_parameters): Likewise.\n\t* var-tracking.c (prepare_call_arguments): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(aarch64_setup_incoming_varargs): Update call accordingly.\n\t* config/alpha/alpha.c (alpha_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(alpha_setup_incoming_varargs): Update call accordingly.\n\t* config/arc/arc.c (arc_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(arc_setup_incoming_varargs): Update call accordingly.\n\t* config/arm/arm.c (arm_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(cmse_func_args_or_return_in_stack): Update call accordingly.\n\t(arm_function_ok_for_sibcall): Likewise.\n\t(cmse_nonsecure_call_clear_caller_saved): Likewise.\n\t* config/avr/avr.c (avr_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/bfin/bfin.c (bfin_function_arg_advance): Likewise.\n\t* config/c6x/c6x.c (c6x_function_arg_advance): Likewise.\n\t(c6x_call_saved_register_used): Update call accordingly.\n\t* config/cr16/cr16.c (cr16_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/cris/cris.c (cris_function_arg_advance): Likewise.\n\t* config/csky/csky.c (csky_function_arg_advance): Likewise.\n\t(csky_setup_incoming_varargs): Update call accordingly.\n\t* config/epiphany/epiphany.c (epiphany_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/fr30/fr30.c (fr30_function_arg_advance): Likewise.\n\t* config/frv/frv.c (frv_function_arg_advance): Likewise.\n\t* config/ft32/ft32.c (ft32_function_arg_advance): Likewise.\n\t* config/gcn/gcn.c (gcn_function_arg_advance): Likewise.\n\t* config/h8300/h8300.c (h8300_function_arg_advance): Likewise.\n\t* config/i386/i386.c (ix86_function_arg_advance): Likewise.\n\t(ix86_setup_incoming_varargs): Update call accordingly.\n\t* config/ia64/ia64.c (ia64_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(ia64_setup_incoming_varargs): Update call accordingly.\n\t* config/iq2000/iq2000.c (iq2000_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(iq2000_expand_prologue): Update call accordingly.\n\t* config/lm32/lm32.c (lm32_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/m32c/m32c.c (m32c_function_arg_advance): Likewise.\n\t* config/m32r/m32r.c (m32r_function_arg_advance): Likewise.\n\t* config/m68k/m68k.c (m68k_function_arg_advance): Likewise.\n\t* config/mcore/mcore.c (mcore_function_arg_advance): Likewise.\n\t* config/microblaze/microblaze.c (microblaze_function_arg_advance):\n\tLikewise.\n\t(microblaze_expand_prologue): Update call accordingly.\n\t* config/mips/mips.c (mips_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(mips_setup_incoming_varargs): Update call accordingly.\n\t(mips_output_args_xfer): Likewise.\n\t* config/mmix/mmix.c (mmix_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/mn10300/mn10300.c (mn10300_function_arg_advance): Likewise.\n\t* config/moxie/moxie.c (moxie_function_arg_advance): Likewise.\n\t* config/msp430/msp430.c (msp430_function_arg_advance): Likewise.\n\t* config/nds32/nds32.c (nds32_function_arg_advance): Likewise.\n\t* config/nios2/nios2.c (nios2_function_arg_advance): Likewise.\n\t(nios2_setup_incoming_varargs): Update call accordingly.\n\t* config/nvptx/nvptx.c (nvptx_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/or1k/or1k.c (or1k_function_arg_advance): Likewise.\n\t* config/pa/pa.c (pa_function_arg_advance): Likewise.\n\t* config/pdp11/pdp11.c (pdp11_function_arg_advance): Likewise.\n\t* config/pru/pru.c (pru_function_arg_advance): Likewise.\n\t* config/riscv/riscv.c (riscv_function_arg_advance): Likewise.\n\t(riscv_setup_incoming_varargs): Update call accordingly.\n\t* config/rl78/rl78.c (rl78_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/rs6000/rs6000-internal.h (rs6000_function_arg_advance):\n\tLikewise.\n\t* config/rs6000/rs6000-call.c (rs6000_function_arg_advance): Likewise.\n\t(rs6000_parm_needs_stack): Update call accordingly.\n\t* config/rx/rx.c (rx_function_arg_advance): Take a function_arg_info\n\tinstead of a mode, type and named flag.\n\t* config/s390/s390.c (s390_function_arg_advance): Likewise.\n\t(s390_call_saved_register_used): Update call accordingly.\n\t* config/sh/sh.c (sh_function_arg_advance): Take a function_arg_info\n\tinstead of a mode, type and named flag.\n\t(sh_output_mi_thunk): Update call accordingly.\n\t* config/sparc/sparc.c (sparc_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/spu/spu.c (spu_function_arg_advance): Likewise.\n\t(spu_setup_incoming_varargs): Update call accordingly.\n\t* config/stormy16/stormy16.c (xstormy16_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/tilegx/tilegx.c (tilegx_function_arg_advance): Likewise.\n\t(tilegx_setup_incoming_varargs): Update call accordingly.\n\t* config/tilepro/tilepro.c (tilepro_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t(tilegx_setup_incoming_varargs): Update call accordingly.\n\t* config/v850/v850.c (v850_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/vax/vax.c (vax_function_arg_advance): Likewise.\n\t* config/visium/visium.c (visium_function_arg_advance): Likewise.\n\t(visium_setup_incoming_varargs): Update call accordingly.\n\t* config/xtensa/xtensa.c (xtensa_function_arg_advance): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\nFrom-SVN: r274701", "tree": {"sha": "1cca83289473f2f89ace7e832b1300419d87e88f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cca83289473f2f89ace7e832b1300419d87e88f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6930c98c69ad695469ee7daa74b3b6d578afdd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6930c98c69ad695469ee7daa74b3b6d578afdd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6930c98c69ad695469ee7daa74b3b6d578afdd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6930c98c69ad695469ee7daa74b3b6d578afdd0d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6783fdb7057d559aa1da8afa2c15a702c532a03e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6783fdb7057d559aa1da8afa2c15a702c532a03e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6783fdb7057d559aa1da8afa2c15a702c532a03e"}], "stats": {"total": 939, "additions": 470, "deletions": 469}, "files": [{"sha": "c0be9bb0004cf40df6d7235bf212f9a2a89c8f5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1,3 +1,118 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (function_arg_advance): Take a function_arg_info instead\n+\tof a mode, type and named flag.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_function_arg_advance): Take a function_arg_info\n+\tinstead of a mode, type and named flag.\n+\t* targhooks.c (default_function_arg_advance): Likewise.\n+\t* calls.c (initialize_argument_information): Update call to\n+\ttargetm.calls.function_arg_advance.\n+\t(emit_library_call_value_1): Likewise.\n+\t* dse.c (get_call_args): Likewise.\n+\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n+\t* function.c (assign_parms, gimplify_parameters): Likewise.\n+\t* var-tracking.c (prepare_call_arguments): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(aarch64_setup_incoming_varargs): Update call accordingly.\n+\t* config/alpha/alpha.c (alpha_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(alpha_setup_incoming_varargs): Update call accordingly.\n+\t* config/arc/arc.c (arc_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(arc_setup_incoming_varargs): Update call accordingly.\n+\t* config/arm/arm.c (arm_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(cmse_func_args_or_return_in_stack): Update call accordingly.\n+\t(arm_function_ok_for_sibcall): Likewise.\n+\t(cmse_nonsecure_call_clear_caller_saved): Likewise.\n+\t* config/avr/avr.c (avr_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/bfin/bfin.c (bfin_function_arg_advance): Likewise.\n+\t* config/c6x/c6x.c (c6x_function_arg_advance): Likewise.\n+\t(c6x_call_saved_register_used): Update call accordingly.\n+\t* config/cr16/cr16.c (cr16_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/cris/cris.c (cris_function_arg_advance): Likewise.\n+\t* config/csky/csky.c (csky_function_arg_advance): Likewise.\n+\t(csky_setup_incoming_varargs): Update call accordingly.\n+\t* config/epiphany/epiphany.c (epiphany_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/fr30/fr30.c (fr30_function_arg_advance): Likewise.\n+\t* config/frv/frv.c (frv_function_arg_advance): Likewise.\n+\t* config/ft32/ft32.c (ft32_function_arg_advance): Likewise.\n+\t* config/gcn/gcn.c (gcn_function_arg_advance): Likewise.\n+\t* config/h8300/h8300.c (h8300_function_arg_advance): Likewise.\n+\t* config/i386/i386.c (ix86_function_arg_advance): Likewise.\n+\t(ix86_setup_incoming_varargs): Update call accordingly.\n+\t* config/ia64/ia64.c (ia64_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(ia64_setup_incoming_varargs): Update call accordingly.\n+\t* config/iq2000/iq2000.c (iq2000_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(iq2000_expand_prologue): Update call accordingly.\n+\t* config/lm32/lm32.c (lm32_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/m32c/m32c.c (m32c_function_arg_advance): Likewise.\n+\t* config/m32r/m32r.c (m32r_function_arg_advance): Likewise.\n+\t* config/m68k/m68k.c (m68k_function_arg_advance): Likewise.\n+\t* config/mcore/mcore.c (mcore_function_arg_advance): Likewise.\n+\t* config/microblaze/microblaze.c (microblaze_function_arg_advance):\n+\tLikewise.\n+\t(microblaze_expand_prologue): Update call accordingly.\n+\t* config/mips/mips.c (mips_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(mips_setup_incoming_varargs): Update call accordingly.\n+\t(mips_output_args_xfer): Likewise.\n+\t* config/mmix/mmix.c (mmix_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/mn10300/mn10300.c (mn10300_function_arg_advance): Likewise.\n+\t* config/moxie/moxie.c (moxie_function_arg_advance): Likewise.\n+\t* config/msp430/msp430.c (msp430_function_arg_advance): Likewise.\n+\t* config/nds32/nds32.c (nds32_function_arg_advance): Likewise.\n+\t* config/nios2/nios2.c (nios2_function_arg_advance): Likewise.\n+\t(nios2_setup_incoming_varargs): Update call accordingly.\n+\t* config/nvptx/nvptx.c (nvptx_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/or1k/or1k.c (or1k_function_arg_advance): Likewise.\n+\t* config/pa/pa.c (pa_function_arg_advance): Likewise.\n+\t* config/pdp11/pdp11.c (pdp11_function_arg_advance): Likewise.\n+\t* config/pru/pru.c (pru_function_arg_advance): Likewise.\n+\t* config/riscv/riscv.c (riscv_function_arg_advance): Likewise.\n+\t(riscv_setup_incoming_varargs): Update call accordingly.\n+\t* config/rl78/rl78.c (rl78_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/rs6000/rs6000-internal.h (rs6000_function_arg_advance):\n+\tLikewise.\n+\t* config/rs6000/rs6000-call.c (rs6000_function_arg_advance): Likewise.\n+\t(rs6000_parm_needs_stack): Update call accordingly.\n+\t* config/rx/rx.c (rx_function_arg_advance): Take a function_arg_info\n+\tinstead of a mode, type and named flag.\n+\t* config/s390/s390.c (s390_function_arg_advance): Likewise.\n+\t(s390_call_saved_register_used): Update call accordingly.\n+\t* config/sh/sh.c (sh_function_arg_advance): Take a function_arg_info\n+\tinstead of a mode, type and named flag.\n+\t(sh_output_mi_thunk): Update call accordingly.\n+\t* config/sparc/sparc.c (sparc_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/spu/spu.c (spu_function_arg_advance): Likewise.\n+\t(spu_setup_incoming_varargs): Update call accordingly.\n+\t* config/stormy16/stormy16.c (xstormy16_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/tilegx/tilegx.c (tilegx_function_arg_advance): Likewise.\n+\t(tilegx_setup_incoming_varargs): Update call accordingly.\n+\t* config/tilepro/tilepro.c (tilepro_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t(tilegx_setup_incoming_varargs): Update call accordingly.\n+\t* config/v850/v850.c (v850_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/vax/vax.c (vax_function_arg_advance): Likewise.\n+\t* config/visium/visium.c (visium_function_arg_advance): Likewise.\n+\t(visium_setup_incoming_varargs): Update call accordingly.\n+\t* config/xtensa/xtensa.c (xtensa_function_arg_advance): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (function_arg, function_incoming_arg): Take a"}, {"sha": "69a31848f591003659011aa69c7c9bb7fcd46e4c", "filename": "gcc/calls.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2192,8 +2192,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       /* Increment ARGS_SO_FAR, which has info about which arg-registers\n \t have been used, etc.  */\n \n-      targetm.calls.function_arg_advance (args_so_far, TYPE_MODE (type),\n-\t\t\t\t\t  type, argpos < n_named_args);\n+      /* ??? Traditionally we've passed TYPE_MODE here, instead of the\n+\t promoted_mode used for function_arg above.  However, the\n+\t corresponding handling of incoming arguments in function.c\n+\t does pass the promoted mode.  */\n+      function_arg_info arg_to_skip (type, TYPE_MODE (type),\n+\t\t\t\t     argpos < n_named_args);\n+      targetm.calls.function_arg_advance (args_so_far, arg_to_skip);\n \n       /* Store argument values for functions decorated with attribute\n \t alloc_size.  */\n@@ -4881,7 +4886,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  || reg_parm_stack_space > 0)\n \targs_size.constant += argvec[count].locate.size.constant;\n \n-      targetm.calls.function_arg_advance (args_so_far, Pmode, (tree) 0, true);\n+      targetm.calls.function_arg_advance (args_so_far, ptr_arg);\n \n       count++;\n     }\n@@ -4977,7 +4982,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t\t     known_le (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n #endif\n \n-      targetm.calls.function_arg_advance (args_so_far, mode, (tree) 0, true);\n+      targetm.calls.function_arg_advance (args_so_far, arg);\n     }\n \n   for (int i = 0; i < nargs; i++)"}, {"sha": "f13a7777f483fb86f1ffa319ed6b78055d2cca49", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -4846,14 +4846,12 @@ aarch64_init_cumulative_args (CUMULATIVE_ARGS *pcum,\n \n static void\n aarch64_function_arg_advance (cumulative_args_t pcum_v,\n-\t\t\t      machine_mode mode,\n-\t\t\t      const_tree type,\n-\t\t\t      bool named)\n+\t\t\t      const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   if (pcum->pcs_variant == ARM_PCS_AAPCS64)\n     {\n-      aarch64_layout_arg (pcum_v, mode, type, named);\n+      aarch64_layout_arg (pcum_v, arg.mode, arg.type, arg.named);\n       gcc_assert ((pcum->aapcs_reg != NULL_RTX)\n \t\t  != (pcum->aapcs_stack_words != 0));\n       pcum->aapcs_arg_processed = false;\n@@ -14523,8 +14521,7 @@ aarch64_setup_incoming_varargs (cumulative_args_t cum_v,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *cum;\n-  aarch64_function_arg_advance (pack_cumulative_args(&local_cum),\n-\t\t\t\targ.mode, arg.type, arg.named);\n+  aarch64_function_arg_advance (pack_cumulative_args(&local_cum), arg);\n \n   /* Found out how many registers we need to save.\n      Honor tree-stdvar analysis results.  */"}, {"sha": "477c24e229832a016a8fa0413aeb35330699a9d5", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -5606,23 +5606,21 @@ alpha_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   return gen_rtx_REG (arg.mode, num_args + basereg);\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-alpha_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n+alpha_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  bool onstack = targetm.calls.must_pass_in_stack (mode, type);\n-  int increment = onstack ? 6 : ALPHA_ARG_SIZE (mode, type);\n+  bool onstack = targetm.calls.must_pass_in_stack (arg.mode, arg.type);\n+  int increment = onstack ? 6 : ALPHA_ARG_SIZE (arg.mode, arg.type);\n \n #if TARGET_ABI_OSF\n   *cum += increment;\n #else\n   if (!onstack && cum->num_args < 6)\n-    cum->atypes[cum->num_args] = alpha_arg_type (mode);\n+    cum->atypes[cum->num_args] = alpha_arg_type (arg.mode);\n   cum->num_args += increment;\n #endif\n }\n@@ -6090,8 +6088,7 @@ alpha_setup_incoming_varargs (cumulative_args_t pcum,\n   CUMULATIVE_ARGS cum = *get_cumulative_args (pcum);\n \n   /* Skip the current argument.  */\n-  targetm.calls.function_arg_advance (pack_cumulative_args (&cum),\n-\t\t\t\t      arg.mode, arg.type, arg.named);\n+  targetm.calls.function_arg_advance (pack_cumulative_args (&cum), arg);\n \n #if TARGET_ABI_OPEN_VMS\n   /* For VMS, we allocate space for all 6 arg registers plus a count."}, {"sha": "d603406318380c533784a4b7258a46424bac7c76", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -642,8 +642,8 @@ static bool arc_can_follow_jump (const rtx_insn *follower,\n \t\t\t\t const rtx_insn *followee);\n \n static rtx frame_insn (rtx);\n-static void arc_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t      const_tree, bool);\n+static void arc_function_arg_advance (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n static rtx arc_legitimize_address_0 (rtx, rtx, machine_mode mode);\n \n /* initialize the GCC target structure.  */\n@@ -2429,8 +2429,7 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n   /* We must treat `__builtin_va_alist' as an anonymous arg.  */\n \n   next_cum = *get_cumulative_args (args_so_far);\n-  arc_function_arg_advance (pack_cumulative_args (&next_cum),\n-\t\t\t    arg.mode, arg.type, arg.named);\n+  arc_function_arg_advance (pack_cumulative_args (&next_cum), arg);\n   first_anon_arg = next_cum;\n \n   if (FUNCTION_ARG_REGNO_P (first_anon_arg))\n@@ -6480,17 +6479,7 @@ arc_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   return ret;\n }\n \n-/* The function to update the summarizer variable *CUM to advance past\n-   an argument in the argument list.  The values MODE, TYPE and NAMED\n-   describe that argument.  Once this is done, the variable *CUM is\n-   suitable for analyzing the *following* argument with\n-   `FUNCTION_ARG', etc.\n-\n-   This function need not do anything if the argument in question was\n-   passed on the stack.  The compiler knows how to track the amount of\n-   stack space used for arguments without any special help.\n-\n-   The function is used to implement macro FUNCTION_ARG_ADVANCE.  */\n+/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n /* For the ARC: the cum set here is passed on to function_arg where we\n    look at its value and say which reg to use. Strategy: advance the\n    regnumber here till we run out of arg regs, then set *cum to last\n@@ -6500,18 +6489,15 @@ arc_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n \n static void\n arc_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t  machine_mode mode,\n-\t\t\t  const_tree type,\n-\t\t\t  bool named ATTRIBUTE_UNUSED)\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int bytes = (mode == BLKmode\n-\t       ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode));\n+  int bytes = arg.promoted_size_in_bytes ();\n   int words = (bytes + UNITS_PER_WORD  - 1) / UNITS_PER_WORD;\n   int i;\n \n   if (words)\n-    *cum = ROUND_ADVANCE_CUM (*cum, mode, type);\n+    *cum = ROUND_ADVANCE_CUM (*cum, arg.mode, arg.type);\n   for (i = 0; i < words; i++)\n     *cum = ARC_NEXT_ARG_REG (*cum);\n "}, {"sha": "74e7c54524e66a30fe4d1df9f547787f37886e40", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -190,8 +190,8 @@ static rtx emit_multi_reg_push (unsigned long, unsigned long);\n static int arm_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t  const function_arg_info &);\n static rtx arm_function_arg (cumulative_args_t, const function_arg_info &);\n-static void arm_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t      const_tree, bool);\n+static void arm_function_arg_advance (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n static pad_direction arm_function_arg_padding (machine_mode, const_tree);\n static unsigned int arm_function_arg_boundary (machine_mode, const_tree);\n static rtx aapcs_allocate_return_reg (machine_mode, const_tree,\n@@ -6770,24 +6770,22 @@ arm_arg_partial_bytes (cumulative_args_t pcum_v, const function_arg_info &arg)\n   return 0;\n }\n \n-/* Update the data in PCUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in PCUM to advance over argument ARG.  */\n \n static void\n-arm_function_arg_advance (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t\t  const_tree type, bool named)\n+arm_function_arg_advance (cumulative_args_t pcum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n \n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n     {\n-      aapcs_layout_arg (pcum, mode, type, named);\n+      aapcs_layout_arg (pcum, arg.mode, arg.type, arg.named);\n \n       if (pcum->aapcs_cprc_slot >= 0)\n \t{\n-\t  aapcs_cp_arg_layout[pcum->aapcs_cprc_slot].advance (pcum, mode,\n-\t\t\t\t\t\t\t      type);\n+\t  aapcs_cp_arg_layout[pcum->aapcs_cprc_slot].advance (pcum, arg.mode,\n+\t\t\t\t\t\t\t      arg.type);\n \t  pcum->aapcs_cprc_slot = -1;\n \t}\n \n@@ -6800,12 +6798,12 @@ arm_function_arg_advance (cumulative_args_t pcum_v, machine_mode mode,\n   else\n     {\n       pcum->nargs += 1;\n-      if (arm_vector_mode_supported_p (mode)\n+      if (arm_vector_mode_supported_p (arg.mode)\n \t  && pcum->named_count > pcum->nargs\n \t  && TARGET_IWMMXT_ABI)\n \tpcum->iwmmxt_nregs += 1;\n       else\n-\tpcum->nregs += ARM_NUM_REGS2 (mode, type);\n+\tpcum->nregs += ARM_NUM_REGS2 (arg.mode, arg.type);\n     }\n }\n \n@@ -6984,15 +6982,16 @@ cmse_func_args_or_return_in_stack (tree fndecl, tree name, tree fntype)\n   FOREACH_FUNCTION_ARGS (fntype, arg_type, args_iter)\n     {\n       rtx arg_rtx;\n-      machine_mode arg_mode = TYPE_MODE (arg_type);\n \n       prev_arg_type = arg_type;\n       if (VOID_TYPE_P (arg_type))\n \tcontinue;\n \n       function_arg_info arg (arg_type, /*named=*/true);\n       if (!first_param)\n-\tarm_function_arg_advance (args_so_far, arg_mode, arg_type, true);\n+\t/* ??? We should advance after processing the argument and pass\n+\t   the argument we're advancing past.  */\n+\tarm_function_arg_advance (args_so_far, arg);\n       arg_rtx = arm_function_arg (args_so_far, arg);\n       if (!arg_rtx || arm_arg_partial_bytes (args_so_far, arg))\n \t{\n@@ -7378,7 +7377,10 @@ arm_function_ok_for_sibcall (tree decl, tree exp)\n \t{\n \t  tree type = TREE_VALUE (t);\n \t  if (!VOID_TYPE_P (type))\n-\t    arm_function_arg_advance (cum_v, TYPE_MODE (type), type, true);\n+\t    {\n+\t      function_arg_info arg (type, /*named=*/true);\n+\t      arm_function_arg_advance (cum_v, arg);\n+\t    }\n \t}\n \n       function_arg_info arg (integer_type_node, /*named=*/true);\n@@ -17441,15 +17443,15 @@ cmse_nonsecure_call_clear_caller_saved (void)\n \t    {\n \t      rtx arg_rtx;\n \t      uint64_t to_clear_args_mask;\n-\t      machine_mode arg_mode = TYPE_MODE (arg_type);\n \n \t      if (VOID_TYPE_P (arg_type))\n \t\tcontinue;\n \n \t      function_arg_info arg (arg_type, /*named=*/true);\n \t      if (!first_param)\n-\t\tarm_function_arg_advance (args_so_far, arg_mode, arg_type,\n-\t\t\t\t\t  true);\n+\t\t/* ??? We should advance after processing the argument and pass\n+\t\t   the argument we're advancing past.  */\n+\t\tarm_function_arg_advance (args_so_far, arg);\n \n \t      arg_rtx = arm_function_arg (args_so_far, arg);\n \t      gcc_assert (REG_P (arg_rtx));"}, {"sha": "6a5271d3a5328a8535ea9708e855bc99f424b8a2", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -3405,11 +3405,11 @@ avr_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n    in the argument list.  */\n \n static void\n-avr_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-                          const_tree type, bool named ATTRIBUTE_UNUSED)\n+avr_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int bytes = avr_num_arg_regs (mode, type);\n+  int bytes = avr_num_arg_regs (arg.mode, arg.type);\n \n   cum->nregs -= bytes;\n   cum->regno -= bytes;"}, {"sha": "80ab77781d50fa19f72ef67aeba77dce5fc1e5d7", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1647,18 +1647,16 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n   return;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-bfin_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+bfin_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int count, bytes, words;\n \n-  bytes = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  bytes = arg.promoted_size_in_bytes ();\n   words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n   cum->words += words;"}, {"sha": "383634f17b154424fd5bd5df7a7f347b0e36e853", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -526,10 +526,7 @@ c6x_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n }\n \n static void\n-c6x_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t  bool named ATTRIBUTE_UNUSED)\n+c6x_function_arg_advance (cumulative_args_t cum_v, const function_arg_info &)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   cum->count++;\n@@ -1136,7 +1133,7 @@ c6x_call_saved_register_used (tree call_expr)\n        function_arg_info arg (type, mode, /*named=*/false);\n        parm_rtx = c6x_function_arg (cum, arg);\n \n-       c6x_function_arg_advance (cum, mode, type, 0);\n+       c6x_function_arg_advance (cum, arg);\n \n        if (!parm_rtx)\n \t continue;"}, {"sha": "dc4cb9184826232fa43235e788e49742030a82dd", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -660,34 +660,34 @@ cr16_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n \n /* Implements the macro FUNCTION_ARG_ADVANCE defined in cr16.h.  */\n static void\n-cr16_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+cr16_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS * cum = get_cumulative_args (cum_v);\n \n   /* l holds the number of registers required.  */\n-  int l = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n+  int l = GET_MODE_BITSIZE (arg.mode) / BITS_PER_WORD;\n \n   /* If the parameter isn't passed on a register don't advance cum.  */\n   if (!cum->last_parm_in_reg)\n     return;\n \n-  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type) || (cum->ints < 0))\n     return;\n \n-  if ((mode == SImode) || (mode == HImode)\n-      || (mode == QImode) || (mode == DImode))\n+  if ((arg.mode == SImode) || (arg.mode == HImode)\n+      || (arg.mode == QImode) || (arg.mode == DImode))\n     {\n       if (l <= 1)\n \tcum->ints += 1;\n       else\n \tcum->ints += l;\n     }\n-  else if ((mode == SFmode) || (mode == DFmode))\n+  else if ((arg.mode == SFmode) || (arg.mode == DFmode))\n     cum->ints += l;\n-  else if ((mode) == BLKmode)\n+  else if (arg.mode == BLKmode)\n     {\n-      if ((l = enough_regs_for_param (cum, type, mode)) != 0)\n+      if ((l = enough_regs_for_param (cum, arg.type, arg.mode)) != 0)\n \tcum->ints += l;\n     }\n   return;"}, {"sha": "f238853ba3a3d9da87de87d585d9b9192ae541ed", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -147,8 +147,8 @@ static int cris_arg_partial_bytes (cumulative_args_t,\n static rtx cris_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx cris_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       const function_arg_info &);\n-static void cris_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void cris_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static rtx_insn *cris_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n \t\t\t\t     vec<const char *> &,\n \t\t\t\t     vec<rtx> &, HARD_REG_SET &);\n@@ -4156,12 +4156,12 @@ cris_function_incoming_arg (cumulative_args_t ca, const function_arg_info &arg)\n /* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-cris_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+cris_function_arg_advance (cumulative_args_t ca_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n \n-  ca->regs += (3 + CRIS_FUNCTION_ARG_SIZE (mode, type)) / 4;\n+  ca->regs += (3 + CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type)) / 4;\n }\n \n /* Worker function for TARGET_MD_ASM_ADJUST.  */"}, {"sha": "309d00d3f1b5e012ac0197fec5f4e611365db92e", "filename": "gcc/config/csky/csky.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fcsky%2Fcsky.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fcsky%2Fcsky.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1819,11 +1819,11 @@ csky_num_arg_regs (machine_mode mode, const_tree type)\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-csky_function_arg_advance (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+csky_function_arg_advance (cumulative_args_t pcum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n-  int param_size = csky_num_arg_regs (mode, type);\n+  int param_size = csky_num_arg_regs (arg.mode, arg.type);\n \n   if (*pcum + param_size > CSKY_NPARM_REGS)\n     *pcum = CSKY_NPARM_REGS;\n@@ -1941,7 +1941,7 @@ csky_setup_incoming_varargs (cumulative_args_t pcum_v,\n \n   cfun->machine->uses_anonymous_args = 1;\n   local_cum = *pcum;\n-  csky_function_arg_advance (local_cum_v, arg.mode, arg.type, arg.named);\n+  csky_function_arg_advance (local_cum_v, arg);\n   regs_to_push = CSKY_NPARM_REGS - local_cum;\n   if (regs_to_push)\n     *pretend_size  = regs_to_push * UNITS_PER_WORD;"}, {"sha": "7dfb91f5662462171a9a4587735efc2d59c89454", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2269,16 +2269,15 @@ epiphany_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   return 0;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n static void\n-epiphany_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t       const_tree type, bool named ATTRIBUTE_UNUSED)\n+epiphany_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t       const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum = ROUND_ADVANCE_CUM (*cum, mode, type) + ROUND_ADVANCE_ARG (mode, type);\n+  *cum = (ROUND_ADVANCE_CUM (*cum, arg.mode, arg.type)\n+\t  + ROUND_ADVANCE_ARG (arg.mode, arg.type));\n }\n \f\n /* Nested function support."}, {"sha": "7f1eae17d0043ca10562b826e07524533b4b1342", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -120,8 +120,8 @@ static bool fr30_must_pass_in_stack (machine_mode, const_tree);\n static int fr30_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static rtx fr30_function_arg (cumulative_args_t, const function_arg_info &);\n-static void fr30_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void fr30_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static bool fr30_frame_pointer_required (void);\n static rtx fr30_function_value (const_tree, const_tree, bool);\n static rtx fr30_libcall_value (machine_mode, const_rtx);\n@@ -811,19 +811,13 @@ fr30_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n     return gen_rtx_REG (arg.mode, *cum + FIRST_ARG_REGNUM);\n }\n \n-/* A C statement (sans semicolon) to update the summarizer variable CUM to\n-   advance past an argument in the argument list.  The values MODE, TYPE and\n-   NAMED describe that argument.  Once this is done, the variable CUM is\n-   suitable for analyzing the *following* argument with `FUNCTION_ARG', etc.\n-\n-   This macro need not do anything if the argument in question was passed on\n-   the stack.  The compiler knows how to track the amount of stack space used\n-   for arguments without any special help.  */\n+/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n static void\n-fr30_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n-\t\t\t   const_tree type, bool named)\n+fr30_function_arg_advance (cumulative_args_t cum,\n+\t\t\t   const function_arg_info &arg)\n {\n-  *get_cumulative_args (cum) += named * fr30_num_arg_regs (mode, type);\n+  if (arg.named)\n+    *get_cumulative_args (cum) += fr30_num_arg_regs (arg.mode, arg.type);\n }\n \n /*}}}*/"}, {"sha": "5d319c0bfafd583b9137062ddf284c236a882778", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -385,8 +385,8 @@ static int frv_arg_partial_bytes (cumulative_args_t,\n static rtx frv_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx frv_function_incoming_arg (cumulative_args_t,\n \t\t\t\t      const function_arg_info &);\n-static void frv_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void frv_function_arg_advance (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n static unsigned int frv_function_arg_boundary\t(machine_mode,\n \t\t\t\t\t\t const_tree);\n static void frv_output_dwarf_dtprel\t\t(FILE *, int, rtx)\n@@ -3149,24 +3149,15 @@ frv_function_incoming_arg (cumulative_args_t cum, const function_arg_info &arg)\n }\n \n \f\n-/* A C statement (sans semicolon) to update the summarizer variable CUM to\n-   advance past an argument in the argument list.  The values MODE, TYPE and\n-   NAMED describe that argument.  Once this is done, the variable CUM is\n-   suitable for analyzing the *following* argument with `FUNCTION_ARG', etc.\n-\n-   This macro need not do anything if the argument in question was passed on\n-   the stack.  The compiler knows how to track the amount of stack space used\n-   for arguments without any special help.  */\n+/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n frv_function_arg_advance (cumulative_args_t cum_v,\n-                          machine_mode mode,\n-                          const_tree type ATTRIBUTE_UNUSED,\n-                          bool named)\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n+  machine_mode xmode = (arg.mode == BLKmode) ? SImode : arg.mode;\n   int bytes = GET_MODE_SIZE (xmode);\n   int words = (bytes + UNITS_PER_WORD  - 1) / UNITS_PER_WORD;\n   int arg_num = *cum;\n@@ -3176,7 +3167,8 @@ frv_function_arg_advance (cumulative_args_t cum_v,\n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n \t     \"function_adv: words = %2d, mode = %4s, named = %d, size = %3d\\n\",\n-\t     arg_num, GET_MODE_NAME (mode), named, words * UNITS_PER_WORD);\n+\t     arg_num, GET_MODE_NAME (arg.mode), arg.named,\n+\t     words * UNITS_PER_WORD);\n }\n \n \f"}, {"sha": "e9eb4d4d70bea4ee6f04e4f843f97277348887fd", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -672,13 +672,14 @@ ft32_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n    : (unsigned) int_size_in_bytes (TYPE))\n \n static void\n-ft32_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-                           const_tree type, bool named ATTRIBUTE_UNUSED)\n+ft32_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   *cum = (*cum < FT32_R6\n-          ? *cum + ((3 + FT32_FUNCTION_ARG_SIZE (mode, type)) / 4) : *cum);\n+\t  ? *cum + ((3 + FT32_FUNCTION_ARG_SIZE (arg.mode, arg.type)) / 4)\n+\t  : *cum);\n }\n \n /* Return non-zero if the function argument described by ARG is to be"}, {"sha": "c919d31f69699244062d214bc1c1273fc86e0073", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2313,17 +2313,17 @@ gcn_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n    argument in the argument list.  */\n \n static void\n-gcn_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  const_tree type, bool named)\n+gcn_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   if (cum->normal_function)\n     {\n-      if (!named)\n+      if (!arg.named)\n \treturn;\n \n-      int num_regs = num_arg_regs (mode, type);\n+      int num_regs = num_arg_regs (arg.mode, arg.type);\n       if (num_regs > 0)\n \twhile ((FIRST_PARM_REG + cum->num) % num_regs != 0)\n \t  cum->num++;\n@@ -2335,7 +2335,7 @@ gcn_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \tcum->num++;\n       else\n \t{\n-\t  cum->offset += tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+\t  cum->offset += tree_to_uhwi (TYPE_SIZE_UNIT (arg.type));\n \t  cfun->machine->kernarg_segment_byte_size = cum->offset;\n \t}\n     }"}, {"sha": "c51b32dd8202e4294cf43a92f1e2dece01288167", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1151,19 +1151,16 @@ h8300_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   return result;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-h8300_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n+h8300_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  cum->nbytes += (mode != BLKmode\n-\t\t  ? (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD\n-\t\t  : (int_size_in_bytes (type) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD);\n+  cum->nbytes += ((arg.promoted_size_in_bytes () + UNITS_PER_WORD - 1)\n+\t\t  & -UNITS_PER_WORD);\n }\n \n \f"}, {"sha": "f036d56731caaf422c531c50ea77e3b029dd9e7c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2919,15 +2919,14 @@ function_arg_advance_ms_64 (CUMULATIVE_ARGS *cum, HOST_WIDE_INT bytes,\n   return 0;\n }\n \n-/* Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named)\n+ix86_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  machine_mode mode = arg.mode;\n   HOST_WIDE_INT bytes, words;\n   int nregs;\n \n@@ -2936,14 +2935,11 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   if (!cum->caller && cfun->machine->func_type != TYPE_NORMAL)\n     return;\n \n-  if (mode == BLKmode)\n-    bytes = int_size_in_bytes (type);\n-  else\n-    bytes = GET_MODE_SIZE (mode);\n+  bytes = arg.promoted_size_in_bytes ();\n   words = CEIL (bytes, UNITS_PER_WORD);\n \n-  if (type)\n-    mode = type_natural_mode (type, NULL, false);\n+  if (arg.type)\n+    mode = type_natural_mode (arg.type, NULL, false);\n \n   if (TARGET_64BIT)\n     {\n@@ -2952,10 +2948,11 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n       if (call_abi == MS_ABI)\n \tnregs = function_arg_advance_ms_64 (cum, bytes, words);\n       else\n-\tnregs = function_arg_advance_64 (cum, mode, type, words, named);\n+\tnregs = function_arg_advance_64 (cum, mode, arg.type, words,\n+\t\t\t\t\t arg.named);\n     }\n   else\n-    nregs = function_arg_advance_32 (cum, mode, type, bytes, words);\n+    nregs = function_arg_advance_32 (cum, mode, arg.type, bytes, words);\n \n   if (!nregs)\n     {\n@@ -4109,8 +4106,7 @@ ix86_setup_incoming_varargs (cumulative_args_t cum_v,\n      For stdargs, we do want to skip the last named argument.  */\n   next_cum = *cum;\n   if (stdarg_p (fntype))\n-    ix86_function_arg_advance (pack_cumulative_args (&next_cum),\n-\t\t\t       arg.mode, arg.type, arg.named);\n+    ix86_function_arg_advance (pack_cumulative_args (&next_cum), arg);\n \n   if (cum->call_abi == MS_ABI)\n     setup_incoming_varargs_ms_64 (&next_cum);"}, {"sha": "bfec69b7446efc91b61a17452769cc3c31ea7cc0", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -207,8 +207,8 @@ static int ia64_arg_partial_bytes (cumulative_args_t,\n static rtx ia64_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx ia64_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       const function_arg_info &);\n-static void ia64_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void ia64_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static pad_direction ia64_function_arg_padding (machine_mode, const_tree);\n static unsigned int ia64_function_arg_boundary (machine_mode,\n \t\t\t\t\t\tconst_tree);\n@@ -4596,8 +4596,7 @@ ia64_setup_incoming_varargs (cumulative_args_t cum,\n   CUMULATIVE_ARGS next_cum = *get_cumulative_args (cum);\n \n   /* Skip the current argument.  */\n-  ia64_function_arg_advance (pack_cumulative_args (&next_cum),\n-\t\t\t     arg.mode, arg.type, arg.named);\n+  ia64_function_arg_advance (pack_cumulative_args (&next_cum), arg);\n \n   if (next_cum.words < MAX_ARGUMENT_SLOTS)\n     {\n@@ -4999,12 +4998,12 @@ ia64_arg_type (machine_mode mode)\n    ia64_function_arg.  */\n \n static void\n-ia64_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named)\n+ia64_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int words = ia64_function_arg_words (type, mode);\n-  int offset = ia64_function_arg_offset (cum, type, words);\n+  int words = ia64_function_arg_words (arg.type, arg.mode);\n+  int offset = ia64_function_arg_offset (cum, arg.type, words);\n   machine_mode hfa_mode = VOIDmode;\n \n   /* If all arg slots are already full, then there is nothing to do.  */\n@@ -5014,7 +5013,7 @@ ia64_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n       return;\n     }\n \n-  cum->atypes[cum->words] = ia64_arg_type (mode);\n+  cum->atypes[cum->words] = ia64_arg_type (arg.mode);\n   cum->words += words + offset;\n \n   /* On OpenVMS argument is either in Rn or Fn.  */\n@@ -5026,12 +5025,12 @@ ia64_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n     }\n \n   /* Check for and handle homogeneous FP aggregates.  */\n-  if (type)\n-    hfa_mode = hfa_element_mode (type, 0);\n+  if (arg.type)\n+    hfa_mode = hfa_element_mode (arg.type, 0);\n \n   /* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas\n      and unprototyped hfas are passed specially.  */\n-  if (hfa_mode != VOIDmode && (! cum->prototype || named))\n+  if (hfa_mode != VOIDmode && (! cum->prototype || arg.named))\n     {\n       int fp_regs = cum->fp_regs;\n       /* This is the original value of cum->words + offset.  */\n@@ -5050,8 +5049,7 @@ ia64_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n       /* Fill the FP regs.  We do this always.  We stop if we reach the end\n \t of the argument, the last FP register, or the last argument slot.  */\n \n-      byte_size = ((mode == BLKmode)\n-\t\t   ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+      byte_size = arg.promoted_size_in_bytes ();\n       args_byte_size = int_regs * UNITS_PER_WORD;\n       offset = 0;\n       for (; (offset < byte_size && fp_regs < MAX_ARGUMENT_SLOTS\n@@ -5068,26 +5066,29 @@ ia64_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n   /* Integral and aggregates go in general registers.  So do TFmode FP values.\n      If we have run out of FR registers, then other FP values must also go in\n      general registers.  This can happen when we have a SFmode HFA.  */\n-  else if (mode == TFmode || mode == TCmode\n-           || (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS))\n+  else if (arg.mode == TFmode || arg.mode == TCmode\n+           || !FLOAT_MODE_P (arg.mode)\n+\t   || cum->fp_regs == MAX_ARGUMENT_SLOTS)\n     cum->int_regs = cum->words;\n \n   /* If there is a prototype, then FP values go in a FR register when\n      named, and in a GR register when unnamed.  */\n   else if (cum->prototype)\n     {\n-      if (! named)\n+      if (! arg.named)\n \tcum->int_regs = cum->words;\n       else\n \t/* ??? Complex types should not reach here.  */\n-\tcum->fp_regs += (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n+\tcum->fp_regs\n+\t  += (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n     }\n   /* If there is no prototype, then FP values go in both FR and GR\n      registers.  */\n   else\n     {\n       /* ??? Complex types should not reach here.  */\n-      cum->fp_regs += (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n+      cum->fp_regs\n+\t+= (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT ? 2 : 1);\n       cum->int_regs = cum->words;\n     }\n }"}, {"sha": "80c63812878e5025115d7056f4222f1ba5aa2b8b", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -166,7 +166,7 @@ static int  iq2000_arg_partial_bytes  (cumulative_args_t,\n static rtx iq2000_function_arg\t      (cumulative_args_t,\n \t\t\t\t       const function_arg_info &);\n static void iq2000_function_arg_advance (cumulative_args_t,\n-\t\t\t\t\t machine_mode, const_tree, bool);\n+\t\t\t\t\t const function_arg_info &);\n static pad_direction iq2000_function_arg_padding (machine_mode, const_tree);\n static unsigned int iq2000_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t  const_tree);\n@@ -1153,12 +1153,11 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n     }\n }\n \n-/* Advance the argument of type TYPE and mode MODE to the next argument\n-   position in CUM.  */\n+/* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-iq2000_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t     const_tree type, bool named)\n+iq2000_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t     const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n@@ -1167,29 +1166,29 @@ iq2000_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n       fprintf (stderr,\n \t       \"function_adv({gp reg found = %d, arg # = %2d, words = %2d}, %4s, \",\n \t       cum->gp_reg_found, cum->arg_number, cum->arg_words,\n-\t       GET_MODE_NAME (mode));\n-      fprintf (stderr, \"%p\", (const void *) type);\n-      fprintf (stderr, \", %d )\\n\\n\", named);\n+\t       GET_MODE_NAME (arg.mode));\n+      fprintf (stderr, \"%p\", (const void *) arg.type);\n+      fprintf (stderr, \", %d )\\n\\n\", arg.named);\n     }\n \n   cum->arg_number++;\n-  switch (mode)\n+  switch (arg.mode)\n     {\n     case E_VOIDmode:\n       break;\n \n     default:\n-      gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n-\t\t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n+      gcc_assert (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_INT\n+\t\t  || GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT);\n \n       cum->gp_reg_found = 1;\n-      cum->arg_words += ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n+      cum->arg_words += ((GET_MODE_SIZE (arg.mode) + UNITS_PER_WORD - 1)\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n     case E_BLKmode:\n       cum->gp_reg_found = 1;\n-      cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n+      cum->arg_words += ((int_size_in_bytes (arg.type) + UNITS_PER_WORD - 1)\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n@@ -1971,8 +1970,7 @@ iq2000_expand_prologue (void)\n       function_arg_info arg (passed_type, passed_mode, /*named=*/true);\n       entry_parm = iq2000_function_arg (args_so_far, arg);\n \n-      iq2000_function_arg_advance (args_so_far, passed_mode,\n-\t\t\t\t   passed_type, true);\n+      iq2000_function_arg_advance (args_so_far, arg);\n       next_arg = DECL_CHAIN (cur_arg);\n \n       if (entry_parm && store_args_on_stack)"}, {"sha": "a393dffadecef4b69e110ff54b64e85af6a5a438", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -75,8 +75,7 @@ static HOST_WIDE_INT lm32_compute_frame_size (int size);\n static void lm32_option_override (void);\n static rtx lm32_function_arg (cumulative_args_t, const function_arg_info &);\n static void lm32_function_arg_advance (cumulative_args_t cum,\n-\t\t\t\t       machine_mode mode,\n-\t\t\t\t       const_tree type, bool named);\n+\t\t\t\t       const function_arg_info &);\n static bool lm32_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool lm32_modes_tieable_p (machine_mode, machine_mode);\n static HOST_WIDE_INT lm32_starting_frame_offset (void);\n@@ -641,10 +640,10 @@ lm32_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n }\n \n static void\n-lm32_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+lm32_function_arg_advance (cumulative_args_t cum,\n+\t\t\t   const function_arg_info &arg)\n {\n-  *get_cumulative_args (cum) += LM32_NUM_REGS2 (mode, type);\n+  *get_cumulative_args (cum) += LM32_NUM_REGS2 (arg.mode, arg.type);\n }\n \n HOST_WIDE_INT"}, {"sha": "ace00e06cab93257967eee1954a27242e8141c22", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -79,8 +79,8 @@ static bool m32c_addr_space_legitimate_address_p (machine_mode, rtx, bool, addr_\n static rtx m32c_function_arg (cumulative_args_t, const function_arg_info &);\n static bool m32c_pass_by_reference (cumulative_args_t,\n \t\t\t\t    const function_arg_info &);\n-static void m32c_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void m32c_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static unsigned int m32c_function_arg_boundary (machine_mode, const_tree);\n static int m32c_pushm_popm (Push_Pop_Type);\n static bool m32c_strict_argument_naming (cumulative_args_t);\n@@ -1399,9 +1399,7 @@ m32c_init_cumulative_args (CUMULATIVE_ARGS * ca,\n #define TARGET_FUNCTION_ARG_ADVANCE m32c_function_arg_advance\n static void\n m32c_function_arg_advance (cumulative_args_t ca_v,\n-\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t   const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t   bool named ATTRIBUTE_UNUSED)\n+\t\t\t   const function_arg_info &)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n "}, {"sha": "52a1e26bbc83d6ef7e841c59e9464ddcd567f1ec", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -97,8 +97,8 @@ static bool m32r_pass_by_reference (cumulative_args_t,\n static int m32r_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static rtx m32r_function_arg (cumulative_args_t, const function_arg_info &);\n-static void m32r_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void m32r_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static bool m32r_can_eliminate (const int, const int);\n static void m32r_conditional_register_usage (void);\n static void m32r_trampoline_init (rtx, tree, rtx);\n@@ -1217,18 +1217,16 @@ m32r_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n \t  : NULL_RTX);\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-m32r_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+m32r_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum = (ROUND_ADVANCE_CUM (*cum, mode, type)\n-\t  + ROUND_ADVANCE_ARG (mode, type));\n+  *cum = (ROUND_ADVANCE_CUM (*cum, arg.mode, arg.type)\n+\t  + ROUND_ADVANCE_ARG (arg.mode, arg.type));\n }\n \n /* Worker function for TARGET_RETURN_IN_MEMORY.  */"}, {"sha": "70f3e5c6f0a40a5736a52e04bc0c01afdaa10bfc", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -181,8 +181,8 @@ static void m68k_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void m68k_trampoline_init (rtx, tree, rtx);\n static poly_int64 m68k_return_pops_args (tree, tree, poly_int64);\n static rtx m68k_delegitimize_address (rtx);\n-static void m68k_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void m68k_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static rtx m68k_function_arg (cumulative_args_t, const function_arg_info &);\n static bool m68k_cannot_force_const_mem (machine_mode mode, rtx x);\n static bool m68k_output_addr_const_extra (FILE *, rtx);\n@@ -1469,14 +1469,12 @@ m68k_function_arg (cumulative_args_t, const function_arg_info &)\n }\n \n static void\n-m68k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+m68k_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum += (mode != BLKmode\n-\t   ? (GET_MODE_SIZE (mode) + 3) & ~3\n-\t   : (int_size_in_bytes (type) + 3) & ~3);\n+  *cum += (arg.promoted_size_in_bytes () + 3) & ~3;\n }\n \n /* Convert X to a legitimate function call memory reference and return the"}, {"sha": "9feac9566d22c602235413ab1919ced7feb3647a", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -135,8 +135,7 @@ static int        mcore_arg_partial_bytes       (cumulative_args_t,\n static rtx        mcore_function_arg            (cumulative_args_t,\n \t\t\t\t\t\t const function_arg_info &);\n static void       mcore_function_arg_advance    (cumulative_args_t,\n-\t\t\t\t\t\t machine_mode,\n-\t\t\t\t\t\t const_tree, bool);\n+\t\t\t\t\t\t const function_arg_info &);\n static unsigned int mcore_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t const_tree);\n static void       mcore_asm_trampoline_template (FILE *);\n@@ -2817,13 +2816,13 @@ mcore_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n }\n \n static void\n-mcore_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n+mcore_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum = (ROUND_REG (*cum, mode)\n-\t  + (int)named * mcore_num_arg_regs (mode, type));\n+  *cum = (ROUND_REG (*cum, arg.mode)\n+\t  + (int) arg.named * mcore_num_arg_regs (arg.mode, arg.type));\n }\n \n static unsigned int"}, {"sha": "3d0f593486e757ab5019b7f40d55b450292d10d8", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1543,29 +1543,28 @@ init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n \n static void\n microblaze_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t\t machine_mode mode,\n-\t\t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n+\t\t\t\t const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   cum->arg_number++;\n-  switch (mode)\n+  switch (arg.mode)\n     {\n     case E_VOIDmode:\n       break;\n \n     default:\n-      gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n-\t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n+      gcc_assert (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_INT\n+\t\t  || GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT);\n \n       cum->gp_reg_found = 1;\n-      cum->arg_words += ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n+      cum->arg_words += ((GET_MODE_SIZE (arg.mode) + UNITS_PER_WORD - 1)\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n     case E_BLKmode:\n       cum->gp_reg_found = 1;\n-      cum->arg_words += ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n+      cum->arg_words += ((int_size_in_bytes (arg.type) + UNITS_PER_WORD - 1)\n \t\t\t / UNITS_PER_WORD);\n       break;\n \n@@ -2935,8 +2934,7 @@ microblaze_expand_prologue (void)\n \t  break;\n \t}\n \n-      targetm.calls.function_arg_advance (args_so_far, passed_mode,\n-\t\t\t\t\t  passed_type, true);\n+      targetm.calls.function_arg_advance (args_so_far, arg);\n \n       next_arg = TREE_CHAIN (cur_arg);\n       if (next_arg == 0)"}, {"sha": "c4d08a481348176c66372bfd1ca59da734ded907", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -6102,13 +6102,13 @@ mips_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-mips_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named)\n+mips_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   struct mips_arg_info info;\n \n-  mips_get_arg_info (&info, cum, mode, type, named);\n+  mips_get_arg_info (&info, cum, arg.mode, arg.type, arg.named);\n \n   if (!info.fpr_p)\n     cum->gp_reg_found = true;\n@@ -6118,7 +6118,7 @@ mips_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n      either the o32 or the o64 ABI, both of which pass at most 2 arguments\n      in FPRs.  */\n   if (cum->arg_number < 2 && info.fpr_p)\n-    cum->fp_code += (mode == SFmode ? 1 : 2) << (cum->arg_number * 2);\n+    cum->fp_code += (arg.mode == SFmode ? 1 : 2) << (cum->arg_number * 2);\n \n   /* Advance the register count.  This has the effect of setting\n      num_gprs to MAX_ARGS_IN_REGISTERS if a doubleword-aligned\n@@ -6554,8 +6554,7 @@ mips_setup_incoming_varargs (cumulative_args_t cum,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *get_cumulative_args (cum);\n-  mips_function_arg_advance (pack_cumulative_args (&local_cum),\n-\t\t\t     arg.mode, arg.type, arg.named);\n+  mips_function_arg_advance (pack_cumulative_args (&local_cum), arg);\n \n   /* Found out how many registers we need to save.  */\n   gp_saved = MAX_ARGS_IN_REGISTERS - local_cum.num_gprs;\n@@ -7305,7 +7304,8 @@ mips_output_args_xfer (int fp_code, char direction)\n       else\n \tmips_output_64bit_xfer (direction, gparg, fparg);\n \n-      mips_function_arg_advance (pack_cumulative_args (&cum), mode, NULL, true);\n+      function_arg_info arg (mode, /*named=*/true);\n+      mips_function_arg_advance (pack_cumulative_args (&cum), arg);\n     }\n }\n "}, {"sha": "9c4eb2d634b65dd115c3ab438693655f17cd8410", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -149,8 +149,8 @@ static rtx mmix_struct_value_rtx (tree, int);\n static machine_mode mmix_promote_function_mode (const_tree,\n \t\t\t\t\t\t     machine_mode,\n \t                                             int *, const_tree, int);\n-static void mmix_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t       const_tree, bool);\n+static void mmix_function_arg_advance (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &);\n static rtx mmix_function_incoming_arg (cumulative_args_t,\n \t\t\t\t       const function_arg_info &);\n static rtx mmix_function_arg (cumulative_args_t, const function_arg_info &);\n@@ -615,13 +615,13 @@ mmix_initial_elimination_offset (int fromreg, int toreg)\n }\n \n static void\n-mmix_function_arg_advance (cumulative_args_t argsp_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+mmix_function_arg_advance (cumulative_args_t argsp_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n-  int arg_size = MMIX_FUNCTION_ARG_SIZE (mode, type);\n+  int arg_size = MMIX_FUNCTION_ARG_SIZE (arg.mode, arg.type);\n \n-  argsp->regs = ((targetm.calls.must_pass_in_stack (mode, type)\n+  argsp->regs = ((targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n \t\t  || (arg_size > 8\n \t\t      && !TARGET_LIBFUNC\n \t\t      && !argsp->lib))"}, {"sha": "50020e28f761a3f32af2406d31bef47b790f4fb4", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1575,19 +1575,15 @@ mn10300_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   return result;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-mn10300_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n+mn10300_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t      const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  cum->nbytes += (mode != BLKmode\n-\t\t  ? (GET_MODE_SIZE (mode) + 3) & ~3\n-\t\t  : (int_size_in_bytes (type) + 3) & ~3);\n+  cum->nbytes += (arg.promoted_size_in_bytes () + 3) & ~3;\n }\n \n /* Return the number of bytes of registers to use for an argument passed"}, {"sha": "d84046387258c4305d155a87763b897adb219539", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -438,13 +438,13 @@ moxie_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n    : (unsigned) int_size_in_bytes (TYPE))\n \n static void\n-moxie_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n+moxie_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   *cum = (*cum < MOXIE_R6\n-\t  ? *cum + ((3 + MOXIE_FUNCTION_ARG_SIZE (mode, type)) / 4)\n+\t  ? *cum + ((3 + MOXIE_FUNCTION_ARG_SIZE (arg.mode, arg.type)) / 4)\n \t  : *cum);\n }\n "}, {"sha": "66bb217a7937dc96d8938bdab90b69a0672980d4", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -766,14 +766,12 @@ msp430_callee_copies (cumulative_args_t cap ATTRIBUTE_UNUSED,\n \n void\n msp430_function_arg_advance (cumulative_args_t cap,\n-\t\t\t     machine_mode mode,\n-\t\t\t     const_tree type,\n-\t\t\t     bool named)\n+\t\t\t     const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n   int i;\n \n-  msp430_evaluate_arg (cap, mode, type, named);\n+  msp430_evaluate_arg (cap, arg.mode, arg.type, arg.named);\n \n   if (ca->start_reg >= CA_FIRST_REG)\n     for (i = 0; i < ca->reg_count; i ++)"}, {"sha": "3fd4cc8adebc1e23670cb35cd91bc12813d61a1b", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2008,12 +2008,14 @@ nds32_arg_partial_bytes (cumulative_args_t ca, const function_arg_info &arg)\n }\n \n static void\n-nds32_function_arg_advance (cumulative_args_t ca, machine_mode mode,\n-\t\t\t    const_tree type, bool named)\n+nds32_function_arg_advance (cumulative_args_t ca,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (ca);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n \n-  if (named)\n+  if (arg.named)\n     {\n       /* We need to further check TYPE and MODE so that we can determine\n \t which kind of register we shall advance.  */"}, {"sha": "61678032c4529486cddb42bf4b1ff9e7fd4031d9", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -3399,25 +3399,15 @@ nios2_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n   return 0;\n }\n \n-/* Update the data in CUM to advance over an argument of mode MODE\n-   and data type TYPE; TYPE is null for libcalls where that information\n-   may not be available.  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-nios2_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t    bool named ATTRIBUTE_UNUSED)\n+nios2_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v); \n-  HOST_WIDE_INT param_size;\n-\n-  if (mode == BLKmode)\n-    {\n-      param_size = int_size_in_bytes (type);\n-      gcc_assert (param_size >= 0);\n-    }\n-  else\n-    param_size = GET_MODE_SIZE (mode);\n+  HOST_WIDE_INT param_size = arg.promoted_size_in_bytes ();\n+  gcc_assert (param_size >= 0);\n \n   /* Convert to words (round up).  */\n   param_size = (UNITS_PER_WORD - 1 + param_size) / UNITS_PER_WORD;\n@@ -3520,7 +3510,7 @@ nios2_setup_incoming_varargs (cumulative_args_t cum_v,\n \n   cfun->machine->uses_anonymous_args = 1;\n   local_cum = *cum;\n-  nios2_function_arg_advance (local_cum_v, arg.mode, arg.type, arg.named);\n+  nios2_function_arg_advance (local_cum_v, arg);\n \n   regs_to_push = NUM_ARG_REGS - local_cum.regs_used;\n "}, {"sha": "90171a957840742bb172754341dcdf98b6cbb4ae", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -550,10 +550,7 @@ nvptx_function_incoming_arg (cumulative_args_t cum_v,\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-nvptx_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t    machine_mode ARG_UNUSED (mode),\n-\t\t\t    const_tree ARG_UNUSED (type),\n-\t\t\t    bool ARG_UNUSED (named))\n+nvptx_function_arg_advance (cumulative_args_t cum_v, const function_arg_info &)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n "}, {"sha": "34b9d6f27fee6051eac4b93a0fd167ba6fe4fb2b", "filename": "gcc/config/or1k/or1k.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2For1k%2For1k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2For1k%2For1k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1019,15 +1019,15 @@ or1k_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n    argument.  Note, this is not called for arguments passed on the stack.  */\n \n static void\n-or1k_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree /* type */, bool named)\n+or1k_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int nreg = CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+  int nreg = CEIL (GET_MODE_SIZE (arg.mode), UNITS_PER_WORD);\n \n   /* Note that all large arguments are passed by reference.  */\n   gcc_assert (nreg <= 2);\n-  if (named)\n+  if (arg.named)\n     *cum += nreg;\n }\n "}, {"sha": "ba14fbd527cf4a2da4731b2a9f66c177c5dc9dfc", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -167,8 +167,8 @@ static rtx pa_struct_value_rtx (tree, int);\n static bool pa_pass_by_reference (cumulative_args_t,\n \t\t\t\t  const function_arg_info &);\n static int pa_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n-static void pa_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t     const_tree, bool);\n+static void pa_function_arg_advance (cumulative_args_t,\n+\t\t\t\t     const function_arg_info &);\n static rtx pa_function_arg (cumulative_args_t, const function_arg_info &);\n static pad_direction pa_function_arg_padding (machine_mode, const_tree);\n static unsigned int pa_function_arg_boundary (machine_mode, const_tree);\n@@ -9437,21 +9437,19 @@ pa_function_value_regno_p (const unsigned int regno)\n   return false;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-pa_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n+pa_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int arg_size = pa_function_arg_size (mode, type);\n+  int arg_size = pa_function_arg_size (arg.mode, arg.type);\n \n   cum->nargs_prototype--;\n   cum->words += (arg_size\n \t\t + ((cum->words & 01)\n-\t\t    && type != NULL_TREE\n+\t\t    && arg.type != NULL_TREE\n \t\t    && arg_size > 1));\n }\n "}, {"sha": "62a1b2723b28453b7efb849711b758068bb35828", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -164,7 +164,7 @@ static bool pdp11_function_value_regno_p (const unsigned int);\n static void pdp11_trampoline_init (rtx, tree, rtx);\n static rtx pdp11_function_arg (cumulative_args_t, const function_arg_info &);\n static void pdp11_function_arg_advance (cumulative_args_t,\n-\t\t\t\t\tmachine_mode, const_tree, bool);\n+\t\t\t\t\tconst function_arg_info &);\n static void pdp11_conditional_register_usage (void);\n static bool pdp11_legitimate_constant_p (machine_mode, rtx);\n \n@@ -2189,19 +2189,15 @@ pdp11_function_arg (cumulative_args_t, const function_arg_info &)\n \n /* Worker function for TARGET_FUNCTION_ARG_ADVANCE.\n \n-   Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.)  */\n+   Update the data in CUM to advance over argument ARG.  */\n \n static void\n-pdp11_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named ATTRIBUTE_UNUSED)\n+pdp11_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum += (mode != BLKmode\n-\t   ? GET_MODE_SIZE (mode)\n-\t   : int_size_in_bytes (type));\n+  *cum += arg.promoted_size_in_bytes ();\n }\n \n /* Make sure everything's fine if we *don't* have an FPU."}, {"sha": "579d3d4e11c563a028859dca33058426dff9dd0c", "filename": "gcc/config/pru/pru.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fpru%2Fpru.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fpru%2Fpru.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2177,19 +2177,17 @@ pru_arg_partial_bytes (cumulative_args_t, const function_arg_info &)\n   return 0;\n }\n \n-/* Update the data in CUM to advance over an argument of mode MODE\n-   and data type TYPE; TYPE is null for libcalls where that information\n-   may not be available.  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-pru_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type,\n-\t\t\t    bool named)\n+pru_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n-  int regi = pru_function_arg_regi (cum_v, mode, type, named);\n+  int regi = pru_function_arg_regi (cum_v, arg.mode, arg.type, arg.named);\n \n   if (regi >= 0)\n-    pru_function_arg_regi_mark_slot (regi, cum_v, mode, type, named);\n+    pru_function_arg_regi_mark_slot (regi, cum_v, arg.mode,\n+\t\t\t\t     arg.type, arg.named);\n }\n \n /* Implement TARGET_FUNCTION_VALUE.  */"}, {"sha": "9b16a1eb9c2f5d50b9d5d7ba5c368ad521f3f63e", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2757,13 +2757,13 @@ riscv_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n \n static void\n-riscv_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named)\n+riscv_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   struct riscv_arg_info info;\n \n-  riscv_get_arg_info (&info, cum, mode, type, named, false);\n+  riscv_get_arg_info (&info, cum, arg.mode, arg.type, arg.named, false);\n \n   /* Advance the register count.  This has the effect of setting\n      num_gprs to MAX_ARGS_IN_REGISTERS if a doubleword-aligned\n@@ -2864,8 +2864,7 @@ riscv_setup_incoming_varargs (cumulative_args_t cum,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *get_cumulative_args (cum);\n-  riscv_function_arg_advance (pack_cumulative_args (&local_cum),\n-\t\t\t      arg.mode, arg.type, arg.named);\n+  riscv_function_arg_advance (pack_cumulative_args (&local_cum), arg);\n \n   /* Found out how many registers we need to save.  */\n   gp_saved = MAX_ARGS_IN_REGISTERS - local_cum.num_gprs;"}, {"sha": "1c5d1e1f6112dfec3950708f37c88b9bf03c1ef9", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1750,14 +1750,13 @@ rl78_function_arg (cumulative_args_t, const function_arg_info &)\n #define TARGET_FUNCTION_ARG_ADVANCE     rl78_function_arg_advance\n \n static void\n-rl78_function_arg_advance (cumulative_args_t cum_v, machine_mode mode, const_tree type,\n-\t\t\t   bool named ATTRIBUTE_UNUSED)\n+rl78_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   int rounded_size;\n   CUMULATIVE_ARGS * cum = get_cumulative_args (cum_v);\n \n-  rounded_size = ((mode == BLKmode)\n-\t\t  ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  rounded_size = arg.promoted_size_in_bytes ();\n   if (rounded_size & 1)\n     rounded_size ++;\n   (*cum) += rounded_size;"}, {"sha": "548a7156114c0fbfa5ba944731687bff38187e3e", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1400,11 +1400,11 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n }\n \n void\n-rs6000_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     const_tree type, bool named)\n+rs6000_function_arg_advance (cumulative_args_t cum,\n+\t\t\t     const function_arg_info &arg)\n {\n-  rs6000_function_arg_advance_1 (get_cumulative_args (cum), mode, type, named,\n-\t\t\t\t 0);\n+  rs6000_function_arg_advance_1 (get_cumulative_args (cum),\n+\t\t\t\t arg.mode, arg.type, arg.named, 0);\n }\n \n /* A subroutine of rs6000_darwin64_record_arg.  Assign the bits of the\n@@ -2221,7 +2221,7 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n     return true;\n \n   /* Update info on where next arg arrives in registers.  */\n-  rs6000_function_arg_advance (args_so_far, mode, type, true);\n+  rs6000_function_arg_advance (args_so_far, arg);\n   return false;\n }\n "}, {"sha": "cdd9327b4ef501bce0c7e5524451467cec874893", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -159,9 +159,8 @@ extern unsigned int rs6000_function_arg_boundary (machine_mode mode,\n extern bool rs6000_must_pass_in_stack (machine_mode mode, const_tree type);\n extern int rs6000_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t     const function_arg_info &);\n-extern void rs6000_function_arg_advance (cumulative_args_t cum,\n-\t\t\t\t\t machine_mode mode,\n-\t\t\t\t\t const_tree type, bool named);\n+extern void rs6000_function_arg_advance (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &);\n extern pad_direction rs6000_function_arg_padding (machine_mode mode,\n \t\t\t\t\t\t  const_tree type);\n extern rtx rs6000_function_arg (cumulative_args_t, const function_arg_info &);"}, {"sha": "a1fc22b23595e41ea7d3ad6ac37dfe3b1cb3178c", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1105,10 +1105,10 @@ rx_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n }\n \n static void\n-rx_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n-\t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n+rx_function_arg_advance (cumulative_args_t cum,\n+\t\t\t const function_arg_info &arg)\n {\n-  *get_cumulative_args (cum) += rx_function_arg_size (mode, type);\n+  *get_cumulative_args (cum) += rx_function_arg_size (arg.mode, arg.type);\n }\n \n static unsigned int"}, {"sha": "3ad4a185e20d986932b1ca512f4deab1a07f0ffb", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -11982,35 +11982,31 @@ s390_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n   return false;\n }\n \n-/* Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.).  The boolean NAMED specifies whether the\n-   argument is a named argument (as opposed to an unnamed argument\n-   matching an ellipsis).  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-s390_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named)\n+s390_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (s390_function_arg_vector (mode, type))\n+  if (s390_function_arg_vector (arg.mode, arg.type))\n     {\n       /* We are called for unnamed vector stdarg arguments which are\n \t passed on the stack.  In this case this hook does not have to\n \t do anything since stack arguments are tracked by common\n \t code.  */\n-      if (!named)\n+      if (!arg.named)\n \treturn;\n       cum->vrs += 1;\n     }\n-  else if (s390_function_arg_float (mode, type))\n+  else if (s390_function_arg_float (arg.mode, arg.type))\n     {\n       cum->fprs += 1;\n     }\n-  else if (s390_function_arg_integer (mode, type))\n+  else if (s390_function_arg_integer (arg.mode, arg.type))\n     {\n-      int size = s390_function_arg_size (mode, type);\n+      int size = s390_function_arg_size (arg.mode, arg.type);\n       cum->gprs += ((size + UNITS_PER_LONG - 1) / UNITS_PER_LONG);\n     }\n   else\n@@ -13349,7 +13345,7 @@ s390_call_saved_register_used (tree call_expr)\n        function_arg_info arg (type, mode, /*named=*/true);\n        parm_rtx = s390_function_arg (cum, arg);\n \n-       s390_function_arg_advance (cum, mode, type, true);\n+       s390_function_arg_advance (cum, arg);\n \n        if (!parm_rtx)\n \t continue;"}, {"sha": "ac3c5a57f86ed2e14768b5464404ef2d7fd04bcb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -299,8 +299,8 @@ static bool sh_pass_by_reference (cumulative_args_t,\n static bool sh_callee_copies (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static int sh_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n-static void sh_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t     const_tree, bool);\n+static void sh_function_arg_advance (cumulative_args_t,\n+\t\t\t\t     const function_arg_info &);\n static rtx sh_function_arg (cumulative_args_t, const function_arg_info &);\n static int sh_dwarf_calling_convention (const_tree);\n static void sh_encode_section_info (tree, rtx, int);\n@@ -8066,13 +8066,10 @@ sh_function_arg (cumulative_args_t ca_v, const function_arg_info &arg)\n   return NULL_RTX;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be\n-   available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n static void\n-sh_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n-\t\t\t const_tree type, bool named ATTRIBUTE_UNUSED)\n+sh_function_arg_advance (cumulative_args_t ca_v,\n+\t\t\t const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n \n@@ -8082,7 +8079,7 @@ sh_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n   if ((TARGET_HITACHI || ca->renesas_abi) && TARGET_FPU_DOUBLE)\n     {\n       /* Note that we've used the skipped register.  */\n-      if (mode == SFmode && ca->free_single_fp_reg)\n+      if (arg.mode == SFmode && ca->free_single_fp_reg)\n \t{\n \t  ca->free_single_fp_reg = 0;\n \t  return;\n@@ -8091,21 +8088,19 @@ sh_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n \t skipped in order to align the DF value.  We note this skipped\n \t register, because the next SF value will use it, and not the\n \t SF that follows the DF.  */\n-      if (mode == DFmode\n+      if (arg.mode == DFmode\n \t  && sh_round_reg (*ca, DFmode) != sh_round_reg (*ca, SFmode))\n \t{\n \t  ca->free_single_fp_reg = (sh_round_reg (*ca, SFmode)\n-\t\t\t\t    + BASE_ARG_REG (mode));\n+\t\t\t\t    + BASE_ARG_REG (arg.mode));\n \t}\n     }\n \n   if (! ((TARGET_SH4 || TARGET_SH2A) || ca->renesas_abi)\n-      || sh_pass_in_reg_p (*ca, mode, type))\n-    (ca->arg_count[(int) get_sh_arg_class (mode)]\n-     = (sh_round_reg (*ca, mode)\n-\t+ (mode == BLKmode\n-\t   ? CEIL (int_size_in_bytes (type), UNITS_PER_WORD)\n-\t   : CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD))));\n+      || sh_pass_in_reg_p (*ca, arg.mode, arg.type))\n+    (ca->arg_count[(int) get_sh_arg_class (arg.mode)]\n+     = (sh_round_reg (*ca, arg.mode)\n+\t+ CEIL (arg.promoted_size_in_bytes (), UNITS_PER_WORD)));\n }\n \n /* The Renesas calling convention doesn't quite fit into this scheme since\n@@ -10811,7 +10806,8 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n     {\n       tree ptype = build_pointer_type (TREE_TYPE (funtype));\n \n-      sh_function_arg_advance (pack_cumulative_args (&cum), Pmode, ptype, true);\n+      function_arg_info ptr_arg (ptype, Pmode, /*named=*/true);\n+      sh_function_arg_advance (pack_cumulative_args (&cum), ptr_arg);\n     }\n   function_arg_info ptr_arg (ptr_type_node, Pmode, /*named=*/true);\n   this_rtx = sh_function_arg (pack_cumulative_args (&cum), ptr_arg);"}, {"sha": "68e3dce3bb215c1edda28b6398d1577e4ef7b1db", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -657,7 +657,7 @@ static bool sparc_mode_dependent_address_p (const_rtx, addr_space_t);\n static bool sparc_pass_by_reference (cumulative_args_t,\n \t\t\t\t     const function_arg_info &);\n static void sparc_function_arg_advance (cumulative_args_t,\n-\t\t\t\t\tmachine_mode, const_tree, bool);\n+\t\t\t\t\tconst function_arg_info &);\n static rtx sparc_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx sparc_function_incoming_arg (cumulative_args_t,\n \t\t\t\t\tconst function_arg_info &);\n@@ -7590,19 +7590,19 @@ sparc_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n }\n \n /* Handle the TARGET_FUNCTION_ARG_ADVANCE hook.\n-   Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   TYPE is null for libcalls where that information may not be available.  */\n+   Update the data in CUM to advance over argument ARG.  */\n \n static void\n-sparc_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t    const_tree type, bool named)\n+sparc_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n+  tree type = arg.type;\n+  machine_mode mode = arg.mode;\n   int regno, padding;\n \n   /* We pass false for incoming here, it doesn't matter.  */\n-  function_arg_slotno (cum, mode, type, named, false, &regno, &padding);\n+  function_arg_slotno (cum, mode, type, arg.named, false, &regno, &padding);\n \n   /* If argument requires leading padding, add it.  */\n   cum->words += padding;"}, {"sha": "7afd43b2a00683966ea1c31d6d059a987fd3fe8e", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -3863,18 +3863,18 @@ spu_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n }\n \n static void\n-spu_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+spu_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum += (type && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+  *cum += (arg.type && TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST\n \t   ? 1\n-\t   : mode == BLKmode\n-\t   ? ((int_size_in_bytes (type) + 15) / 16)\n-\t   : mode == VOIDmode\n+\t   : arg.mode == BLKmode\n+\t   ? ((int_size_in_bytes (arg.type) + 15) / 16)\n+\t   : arg.mode == VOIDmode\n \t   ? 1\n-\t   : spu_hard_regno_nregs (FIRST_ARG_REGNUM, mode));\n+\t   : spu_hard_regno_nregs (FIRST_ARG_REGNUM, arg.mode));\n }\n \n /* Implement TARGET_FUNCTION_ARG_OFFSET.  The SPU ABI wants 32/64-bit\n@@ -4099,8 +4099,7 @@ spu_setup_incoming_varargs (cumulative_args_t cum,\n \n       /* cum currently points to the last named argument, we want to\n          start at the next argument. */\n-      spu_function_arg_advance (pack_cumulative_args (&ncum),\n-\t\t\t\targ.mode, arg.type, arg.named);\n+      spu_function_arg_advance (pack_cumulative_args (&ncum), arg);\n \n       offset = -STACK_POINTER_OFFSET;\n       for (regno = ncum; regno < MAX_REGISTER_ARGS; regno++)"}, {"sha": "7ccfbda7aad8e55a7b5ea630db2ccb9ce12ecc03", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1205,9 +1205,8 @@ xstormy16_function_profiler (void)\n   sorry (\"function_profiler support\");\n }\n \f\n-/* Update CUM to advance past an argument in the argument list.  The\n-   values MODE, TYPE and NAMED describe that argument.  Once this is\n-   done, the variable CUM is suitable for analyzing the *following*\n+/* Update CUM to advance past argument ARG.  Once this is done,\n+   the variable CUM is suitable for analyzing the *following*\n    argument with `TARGET_FUNCTION_ARG', etc.\n \n    This function need not do anything if the argument in question was\n@@ -1217,19 +1216,20 @@ xstormy16_function_profiler (void)\n    the word count.  */\n \n static void\n-xstormy16_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n+xstormy16_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t\tconst function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   /* If an argument would otherwise be passed partially in registers,\n      and partially on the stack, the whole of it is passed on the\n      stack.  */\n   if (*cum < NUM_ARGUMENT_REGISTERS\n-      && *cum + XSTORMY16_WORD_SIZE (type, mode) > NUM_ARGUMENT_REGISTERS)\n+      && (*cum + XSTORMY16_WORD_SIZE (arg.type, arg.mode)\n+\t  > NUM_ARGUMENT_REGISTERS))\n     *cum = NUM_ARGUMENT_REGISTERS;\n \n-  *cum += XSTORMY16_WORD_SIZE (type, mode);\n+  *cum += XSTORMY16_WORD_SIZE (arg.type, arg.mode);\n }\n \n static rtx"}, {"sha": "4f296550b9918294d602f129e0afca6156121be7", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -245,19 +245,17 @@ tilegx_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n static void\n tilegx_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t     machine_mode mode,\n-\t\t\t     const_tree type, bool named ATTRIBUTE_UNUSED)\n+\t\t\t     const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  int byte_size = ((mode == BLKmode)\n-\t\t   ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  int byte_size = arg.promoted_size_in_bytes ();\n   int word_size = (byte_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   bool doubleword_aligned_p;\n \n   /* See whether the argument has doubleword alignment.  */\n   doubleword_aligned_p =\n-    tilegx_function_arg_boundary (mode, type) > BITS_PER_WORD;\n+    tilegx_function_arg_boundary (arg.mode, arg.type) > BITS_PER_WORD;\n \n   if (doubleword_aligned_p)\n     *cum += *cum & 1;\n@@ -396,8 +394,7 @@ tilegx_setup_incoming_varargs (cumulative_args_t cum,\n   /* The caller has advanced CUM up to, but not beyond, the last named\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n-  targetm.calls.function_arg_advance (pack_cumulative_args (&local_cum),\n-\t\t\t\t      arg.mode, arg.type, arg.named);\n+  targetm.calls.function_arg_advance (pack_cumulative_args (&local_cum), arg);\n   first_reg = local_cum;\n \n   if (local_cum < TILEGX_NUM_ARG_REGS)"}, {"sha": "2e14b2ecf44b756421c5370cd4612d64ef785113", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -197,19 +197,17 @@ tilepro_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n /* Implement TARGET_FUNCTION_ARG_ADVANCE.  */\n static void\n tilepro_function_arg_advance (cumulative_args_t cum_v,\n-\t\t\t      machine_mode mode,\n-\t\t\t      const_tree type, bool named ATTRIBUTE_UNUSED)\n+\t\t\t      const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  int byte_size = ((mode == BLKmode)\n-\t\t   ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+  int byte_size = arg.promoted_size_in_bytes ();\n   int word_size = (byte_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   bool doubleword_aligned_p;\n \n   /* See whether the argument has doubleword alignment.  */\n   doubleword_aligned_p =\n-    tilepro_function_arg_boundary (mode, type) > BITS_PER_WORD;\n+    tilepro_function_arg_boundary (arg.mode, arg.type) > BITS_PER_WORD;\n \n   if (doubleword_aligned_p)\n     *cum += *cum & 1;\n@@ -348,8 +346,7 @@ tilepro_setup_incoming_varargs (cumulative_args_t cum,\n   /* The caller has advanced CUM up to, but not beyond, the last named\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n-  targetm.calls.function_arg_advance (pack_cumulative_args (&local_cum),\n-\t\t\t\t      arg.mode, arg.type, arg.named);\n+  targetm.calls.function_arg_advance (pack_cumulative_args (&local_cum), arg);\n   first_reg = local_cum;\n \n   if (local_cum < TILEPRO_NUM_ARG_REGS)"}, {"sha": "26ad4a71dbdd835577fec94ddc08a6036332f4ca", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -216,27 +216,22 @@ v850_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n   return 4 * UNITS_PER_WORD - cum->nbytes;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-v850_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   const_tree type, bool named ATTRIBUTE_UNUSED)\n+v850_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   if (!TARGET_GCC_ABI)\n-    cum->nbytes += (((mode != BLKmode\n-\t\t      ? GET_MODE_SIZE (mode)\n-\t\t      : int_size_in_bytes (type)) + UNITS_PER_WORD - 1)\n+    cum->nbytes += ((arg.promoted_size_in_bytes () + UNITS_PER_WORD - 1)\n \t\t    & -UNITS_PER_WORD);\n   else\n-    cum->nbytes += (((type && int_size_in_bytes (type) > 8\n+    cum->nbytes += (((arg.type && int_size_in_bytes (arg.type) > 8\n \t\t      ? GET_MODE_SIZE (Pmode)\n-\t\t      : (mode != BLKmode\n-\t\t\t ? GET_MODE_SIZE (mode)\n-\t\t\t : int_size_in_bytes (type))) + UNITS_PER_WORD - 1)\n+\t\t      : (HOST_WIDE_INT) arg.promoted_size_in_bytes ())\n+\t\t     + UNITS_PER_WORD - 1)\n \t\t    & -UNITS_PER_WORD);\n }\n "}, {"sha": "1c220ffb5d0ad580221dab42f5e6c8d5f929f76a", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -55,8 +55,8 @@ static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool vax_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static rtx vax_function_arg (cumulative_args_t, const function_arg_info &);\n-static void vax_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t      const_tree, bool);\n+static void vax_function_arg_advance (cumulative_args_t,\n+\t\t\t\t      const function_arg_info &);\n static rtx vax_struct_value_rtx (tree, int);\n static void vax_asm_trampoline_template (FILE *);\n static void vax_trampoline_init (rtx, tree, rtx);\n@@ -2148,19 +2148,15 @@ vax_function_arg (cumulative_args_t, const function_arg_info &)\n   return NULL_RTX;\n }\n \n-/* Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.)  */\n+/* Update the data in CUM to advance over argument ARG.  */\n \n static void\n-vax_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n+vax_function_arg_advance (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  *cum += (mode != BLKmode\n-\t   ? (GET_MODE_SIZE (mode) + 3) & ~3\n-\t   : (int_size_in_bytes (type) + 3) & ~3);\n+  *cum += (arg.promoted_size_in_bytes () + 3) & ~3;\n }\n \n static HOST_WIDE_INT"}, {"sha": "b51c23f504612fe3c22cab3d06c6b306cf0deed5", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -163,8 +163,8 @@ static bool visium_pass_by_reference (cumulative_args_t,\n \n static rtx visium_function_arg (cumulative_args_t, const function_arg_info &);\n \n-static void visium_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t\t const_tree, bool);\n+static void visium_function_arg_advance (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &);\n \n static bool visium_return_in_memory (const_tree, const_tree fntype);\n \n@@ -1358,28 +1358,25 @@ visium_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n   return NULL_RTX;\n }\n \n-/* Update the summarizer variable pointed to by PCUM_V to advance past an\n-   argument in the argument list.  The values MODE, TYPE and NAMED describe\n-   that argument.  Once this is done, the variable CUM is suitable for\n+/* Update the summarizer variable pointed to by PCUM_V to advance past\n+   argument ARG.  Once this is done, the variable CUM is suitable for\n    analyzing the _following_ argument with visium_function_arg.  */\n \n static void\n visium_function_arg_advance (cumulative_args_t pcum_v,\n-\t\t\t     machine_mode mode,\n-\t\t\t     const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t     bool named)\n+\t\t\t     const function_arg_info &arg)\n {\n-  int size = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  int size = (GET_MODE_SIZE (arg.mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   int stack_size = 0;\n   CUMULATIVE_ARGS *ca = get_cumulative_args (pcum_v);\n \n   /* Scalar or complex single precision floating point arguments are returned\n      in floating registers.  */\n   if (TARGET_FPU\n-      && ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE)\n-\t  || (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t      && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE * 2)))\n+      && ((GET_MODE_CLASS (arg.mode) == MODE_FLOAT\n+\t   && GET_MODE_SIZE (arg.mode) <= UNITS_PER_HWFPVALUE)\n+\t  || (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT\n+\t      && GET_MODE_SIZE (arg.mode) <= UNITS_PER_HWFPVALUE * 2)))\n     {\n       if (ca->frcount + size <= MAX_ARGS_IN_FP_REGISTERS)\n \tca->frcount += size;\n@@ -1402,7 +1399,7 @@ visium_function_arg_advance (cumulative_args_t pcum_v,\n \t}\n     }\n \n-  if (named)\n+  if (arg.named)\n     ca->stack_words += stack_size;\n }\n \n@@ -1483,8 +1480,7 @@ visium_setup_incoming_varargs (cumulative_args_t pcum_v,\n   /* The caller has advanced ARGS_SO_FAR up to, but not beyond, the last named\n      argument.  Advance a local copy of ARGS_SO_FAR past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n-  TARGET_FUNCTION_ARG_ADVANCE (local_args_so_far, arg.mode,\n-\t\t\t       arg.type, arg.named);\n+  TARGET_FUNCTION_ARG_ADVANCE (local_args_so_far, arg);\n \n   /* Find how many registers we need to save.  */\n   locargs = get_cumulative_args (local_args_so_far);"}, {"sha": "a277633e6efefe310f6d50057aa0616c7237735c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -141,8 +141,8 @@ static tree xtensa_build_builtin_va_list (void);\n static bool xtensa_return_in_memory (const_tree, const_tree);\n static tree xtensa_gimplify_va_arg_expr (tree, tree, gimple_seq *,\n \t\t\t\t\t gimple_seq *);\n-static void xtensa_function_arg_advance (cumulative_args_t, machine_mode,\n-\t\t\t\t\t const_tree, bool);\n+static void xtensa_function_arg_advance (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &);\n static rtx xtensa_function_arg (cumulative_args_t, const function_arg_info &);\n static rtx xtensa_function_incoming_arg (cumulative_args_t,\n \t\t\t\t\t const function_arg_info &);\n@@ -2105,21 +2105,20 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, int incoming)\n /* Advance the argument to the next argument position.  */\n \n static void\n-xtensa_function_arg_advance (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     const_tree type, bool named ATTRIBUTE_UNUSED)\n+xtensa_function_arg_advance (cumulative_args_t cum,\n+\t\t\t     const function_arg_info &arg)\n {\n   int words, max;\n   int *arg_words;\n \n   arg_words = &get_cumulative_args (cum)->arg_words;\n   max = MAX_ARGS_IN_REGISTERS;\n \n-  words = (((mode != BLKmode)\n-\t    ? (int) GET_MODE_SIZE (mode)\n-\t    : int_size_in_bytes (type)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  words = ((arg.promoted_size_in_bytes () + UNITS_PER_WORD - 1)\n+\t   / UNITS_PER_WORD);\n \n   if (*arg_words < max\n-      && (targetm.calls.must_pass_in_stack (mode, type)\n+      && (targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n \t  || *arg_words + words > max))\n     *arg_words = max;\n "}, {"sha": "c3e23cdbb5e8efec8cf3d076b8ed753605b934c8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -4159,10 +4159,9 @@ argument @var{libname} exists for symmetry with\n @c --mew 5feb93   i switched the order of the sentences.  --mew 10feb93\n @end defmac\n \n-@deftypefn {Target Hook} void TARGET_FUNCTION_ARG_ADVANCE (cumulative_args_t @var{ca}, machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} void TARGET_FUNCTION_ARG_ADVANCE (cumulative_args_t @var{ca}, const function_arg_info @var{&arg})\n This hook updates the summarizer variable pointed to by @var{ca} to\n-advance past an argument in the argument list.  The values @var{mode},\n-@var{type} and @var{named} describe that argument.  Once this is done,\n+advance past argument @var{arg} in the argument list.  Once this is done,\n the variable @var{cum} is suitable for analyzing the @emph{following}\n argument with @code{TARGET_FUNCTION_ARG}, etc.\n "}, {"sha": "7511f71b9c0b1cdb8066e718bcd0fac780f027ea", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -2377,7 +2377,7 @@ get_call_args (rtx call_insn, tree fn, rtx *args, int nargs)\n       if (tmp)\n \targs[idx] = tmp;\n \n-      targetm.calls.function_arg_advance (args_so_far, mode, NULL_TREE, true);\n+      targetm.calls.function_arg_advance (args_so_far, arg);\n     }\n   if (arg != void_list_node || idx != nargs)\n     return false;"}, {"sha": "92979289e83105695fecc781574014f34e3bd732", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -1715,8 +1715,7 @@ block_move_libcall_safe_for_call_parm (void)\n \t  return false;\n \tif (targetm.calls.arg_partial_bytes (args_so_far, arg_info))\n \t  return false;\n-\ttargetm.calls.function_arg_advance (args_so_far, mode,\n-\t\t\t\t\t    NULL_TREE, true);\n+\ttargetm.calls.function_arg_advance (args_so_far, arg_info);\n       }\n   }\n   return true;"}, {"sha": "64a272bc4563fcd621864eb985403e0bbcc678be", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -3672,8 +3672,9 @@ assign_parms (tree fndecl)\n \tassign_parms_setup_varargs (&all, &data, false);\n \n       /* Update info on where next arg arrives in registers.  */\n-      targetm.calls.function_arg_advance (all.args_so_far, data.promoted_mode,\n-\t\t\t\t\t  data.passed_type, data.named_arg);\n+      function_arg_info arg (data.passed_type, data.promoted_mode,\n+\t\t\t     data.named_arg);\n+      targetm.calls.function_arg_advance (all.args_so_far, arg);\n     }\n \n   if (targetm.calls.split_complex_arg)\n@@ -3860,8 +3861,9 @@ gimplify_parameters (gimple_seq *cleanup)\n \tcontinue;\n \n       /* Update info on where next arg arrives in registers.  */\n-      targetm.calls.function_arg_advance (all.args_so_far, data.promoted_mode,\n-\t\t\t\t\t  data.passed_type, data.named_arg);\n+      function_arg_info arg (data.passed_type, data.promoted_mode,\n+\t\t\t     data.named_arg);\n+      targetm.calls.function_arg_advance (all.args_so_far, arg);\n \n       /* ??? Once upon a time variable_size stuffed parameter list\n \t SAVE_EXPRs (amongst others) onto a pending sizes list.  This"}, {"sha": "cf315c5bde8dee35432c233768b7926ef6558979", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -4686,16 +4686,15 @@ register to be used by the caller for this argument; likewise\\n\\\n DEFHOOK\n (function_arg_advance,\n  \"This hook updates the summarizer variable pointed to by @var{ca} to\\n\\\n-advance past an argument in the argument list.  The values @var{mode},\\n\\\n-@var{type} and @var{named} describe that argument.  Once this is done,\\n\\\n+advance past argument @var{arg} in the argument list.  Once this is done,\\n\\\n the variable @var{cum} is suitable for analyzing the @emph{following}\\n\\\n argument with @code{TARGET_FUNCTION_ARG}, etc.\\n\\\n \\n\\\n This hook need not do anything if the argument in question was passed\\n\\\n on the stack.  The compiler knows how to track the amount of stack space\\n\\\n used for arguments without any special help.\",\n  void,\n- (cumulative_args_t ca, machine_mode mode, const_tree type, bool named),\n+ (cumulative_args_t ca, const function_arg_info &arg),\n  default_function_arg_advance)\n \n DEFHOOK"}, {"sha": "59954b2b8d6a5fd9d0d382d28d88c5914db42eb0", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -784,10 +784,7 @@ hook_void_CUMULATIVE_ARGS_tree (cumulative_args_t ca ATTRIBUTE_UNUSED,\n }\n \n void\n-default_function_arg_advance (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t      const_tree type ATTRIBUTE_UNUSED,\n-\t\t\t      bool named ATTRIBUTE_UNUSED)\n+default_function_arg_advance (cumulative_args_t, const function_arg_info &)\n {\n   gcc_unreachable ();\n }"}, {"sha": "12665913bf456116ac444f80523069b5d598a256", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -148,7 +148,7 @@ extern void hook_void_CUMULATIVE_ARGS_tree\n extern const char *hook_invalid_arg_for_unprototyped_fn\n   (const_tree, const_tree, const_tree);\n extern void default_function_arg_advance\n-  (cumulative_args_t, machine_mode, const_tree, bool);\n+  (cumulative_args_t, const function_arg_info &);\n extern HOST_WIDE_INT default_function_arg_offset (machine_mode, const_tree);\n extern pad_direction default_function_arg_padding (machine_mode, const_tree);\n extern rtx default_function_arg (cumulative_args_t, const function_arg_info &);"}, {"sha": "8b1d4476e2281dbce59b89b1a391cb708f5dd9cc", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6930c98c69ad695469ee7daa74b3b6d578afdd0d/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=6930c98c69ad695469ee7daa74b3b6d578afdd0d", "patch": "@@ -6293,14 +6293,12 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t\t  && targetm.calls.struct_value_rtx (type, 0) == 0)\n \t\t{\n \t\t  tree struct_addr = build_pointer_type (TREE_TYPE (type));\n-\t\t  machine_mode mode = TYPE_MODE (struct_addr);\n \t\t  function_arg_info arg (struct_addr, /*named=*/true);\n \t\t  rtx reg;\n \t\t  INIT_CUMULATIVE_ARGS (args_so_far_v, type, NULL_RTX, fndecl,\n \t\t\t\t\tnargs + 1);\n \t\t  reg = targetm.calls.function_arg (args_so_far, arg);\n-\t\t  targetm.calls.function_arg_advance (args_so_far, mode,\n-\t\t\t\t\t\t      struct_addr, true);\n+\t\t  targetm.calls.function_arg_advance (args_so_far, arg);\n \t\t  if (reg == NULL_RTX)\n \t\t    {\n \t\t      for (; link; link = XEXP (link, 1))\n@@ -6489,8 +6487,7 @@ prepare_call_arguments (basic_block bb, rtx_insn *insn)\n \t\t\t}\n \t\t  }\n \t      }\n-\t    targetm.calls.function_arg_advance (args_so_far, mode,\n-\t\t\t\t\t\targtype, true);\n+\t    targetm.calls.function_arg_advance (args_so_far, arg);\n \t    t = TREE_CHAIN (t);\n \t  }\n       }"}]}