{"sha": "f429813df18f0da63955b4fbd361c0a807a59b15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQyOTgxM2RmMThmMGRhNjM5NTViNGZiZDM2MWMwYTgwN2E1OWIxNQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-08T10:09:28Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-08T10:09:28Z"}, "message": "re PR middle-end/54685 ([SH] Improve unsigned int comparison with 0x7FFFFFFF)\n\n\tPR target/54685\n\t* config/sh/sh.md (one_cmplsi2): Make insn_and_split.  Add manual\n\tcombine matching for an insn sequence where a ge:SI pattern can be used.\n\n\tPR target/54685\n\t* gcc.target/sh/pr54685.c: New.\n\nFrom-SVN: r192200", "tree": {"sha": "a44e539bf052ee338b4abcb43033e103eaf88a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a44e539bf052ee338b4abcb43033e103eaf88a71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f429813df18f0da63955b4fbd361c0a807a59b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f429813df18f0da63955b4fbd361c0a807a59b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f429813df18f0da63955b4fbd361c0a807a59b15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f429813df18f0da63955b4fbd361c0a807a59b15/comments", "author": null, "committer": null, "parents": [{"sha": "e28d52cffbb2abc7a5764ed4c97a25c376913fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28d52cffbb2abc7a5764ed4c97a25c376913fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28d52cffbb2abc7a5764ed4c97a25c376913fee"}], "stats": {"total": 121, "additions": 120, "deletions": 1}, "files": [{"sha": "75b99cd500d6d198ca9943fc0d32a0867dad2d74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f429813df18f0da63955b4fbd361c0a807a59b15", "patch": "@@ -1,3 +1,9 @@\n+2012-10-08  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54685\n+\t* config/sh/sh.md (one_cmplsi2): Make insn_and_split.  Add manual\n+\tcombine matching for an insn sequence where a ge:SI pattern can be used.\n+\n 2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/53528 C++11 attribute support"}, {"sha": "0a1cd09c1f8db6f446dfaf829518d4d16a3018af", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f429813df18f0da63955b4fbd361c0a807a59b15", "patch": "@@ -5189,11 +5189,61 @@ label:\n   \"neg\t%1,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-(define_insn \"one_cmplsi2\"\n+(define_insn_and_split \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"not\t%1,%0\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(set (reg:SI T_REG) (ge:SI (match_dup 1) (const_int 0)))\n+   (set (match_dup 0) (reg:SI T_REG))]\n+{\n+/* PR 54685\n+   If the result of 'unsigned int <= 0x7FFFFFFF' ends up as the following\n+   sequence:\n+\n+     (set (reg0) (not:SI (reg0) (reg1)))\n+     (parallel [(set (reg2) (lshiftrt:SI (reg0) (const_int 31)))\n+\t\t(clobber (reg:SI T_REG))])\n+\n+   ... match and combine the sequence manually in the split pass after the\n+   combine pass.  Notice that combine does try the target pattern of this\n+   split, but if the pattern is added it interferes with other patterns, in\n+   particular with the div0s comparisons.\n+   This could also be done with a peephole but doing it here before register\n+   allocation can save one temporary.\n+   When we're here, the not:SI pattern obviously has been matched already\n+   and we only have to see whether the following insn is the left shift.  */\n+\n+  rtx i = next_nonnote_insn_bb (curr_insn);\n+  if (i == NULL_RTX || !NONJUMP_INSN_P (i))\n+    FAIL;\n+\n+  rtx p = PATTERN (i);\n+  if (GET_CODE (p) != PARALLEL || XVECLEN (p, 0) != 2)\n+    FAIL;\n+\n+  rtx p0 = XVECEXP (p, 0, 0);\n+  rtx p1 = XVECEXP (p, 0, 1);\n+\n+  if (/* (set (reg2) (lshiftrt:SI (reg0) (const_int 31)))  */\n+      GET_CODE (p0) == SET\n+      && GET_CODE (XEXP (p0, 1)) == LSHIFTRT\n+      && REG_P (XEXP (XEXP (p0, 1), 0))\n+      && REGNO (XEXP (XEXP (p0, 1), 0)) == REGNO (operands[0])\n+      && CONST_INT_P (XEXP (XEXP (p0, 1), 1))\n+      && INTVAL (XEXP (XEXP (p0, 1), 1)) == 31\n+\n+      /* (clobber (reg:SI T_REG))  */\n+      && GET_CODE (p1) == CLOBBER && REG_P (XEXP (p1, 0))\n+      && REGNO (XEXP (p1, 0)) == T_REG)\n+    {\n+      operands[0] = XEXP (p0, 0);\n+      set_insn_deleted (i);\n+    }\n+  else\n+    FAIL;\n+}\n   [(set_attr \"type\" \"arith\")])\n \n (define_expand \"one_cmpldi2\""}, {"sha": "1eb751ed9b7158048c7a351a6e1f200aa53aa1ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f429813df18f0da63955b4fbd361c0a807a59b15", "patch": "@@ -1,3 +1,8 @@\n+2012-10-08  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54685\n+\t* gcc.target/sh/pr54685.c: New.\n+\n 2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/53528 C++11 attribute support"}, {"sha": "ba08a4ade9e36ac760f233fb70df21c401e905c8", "filename": "gcc/testsuite/gcc.target/sh/pr54685.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54685.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f429813df18f0da63955b4fbd361c0a807a59b15/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54685.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54685.c?ref=f429813df18f0da63955b4fbd361c0a807a59b15", "patch": "@@ -0,0 +1,58 @@\n+/* Check that a comparison 'unsigned int <= 0x7FFFFFFF' results in code\n+   utilizing the cmp/pz instruction.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-not \"not\" } } */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 7 } } */\n+/* { dg-final { scan-assembler-times \"shll\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movt\" 4 } } */\n+\n+int\n+test_00 (unsigned int a)\n+{\n+  return !(a > 0x7FFFFFFF);\n+}\n+\n+int\n+test_01 (unsigned int a)\n+{\n+  return !(a > 0x7FFFFFFF) ? -5 : 10;\n+}\n+\n+int\n+test_02 (unsigned int a)\n+{\n+  /* 1x shll, 1x movt  */\n+  return a >= 0x80000000;\n+}\n+\n+int\n+test_03 (unsigned int a)\n+{\n+  return a >= 0x80000000 ? -5 : 10;\n+}\n+\n+int\n+test_04 (unsigned int a)\n+{\n+  return a <= 0x7FFFFFFF;\n+}\n+\n+int\n+test_05 (unsigned int a)\n+{\n+  return a <= 0x7FFFFFFF ? -5 : 10;\n+}\n+\n+int\n+test_06 (unsigned int a)\n+{\n+  return a < 0x80000000;\n+}\n+\n+int\n+test_07 (unsigned int a)\n+{\n+  return a < 0x80000000 ? -5 : 10;\n+}"}]}