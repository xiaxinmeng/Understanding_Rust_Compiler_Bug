{"sha": "9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQxZTBlNzJkYmQ3YTZjZDcxYmQxOGFkZWI4ZDRjOGU1Y2QyZDg2Zg==", "commit": {"author": {"name": "Jose Ruiz", "email": "ruiz@adacore.com", "date": "2011-09-01T13:40:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T13:40:48Z"}, "message": "adaint.c, adaint.h (__gnat_cpu_alloc, [...]): Create these wrappers around the CPU_ALLOC...\n\n2011-09-01  Jose Ruiz  <ruiz@adacore.com>\n\n\t* adaint.c, adaint.h (__gnat_cpu_alloc, __gnat_cpu_alloc_size,\n\t__gnat_cpu_set_free): Create these wrappers around the CPU_ALLOC,\n\tCPU_ALLOC_SIZE and CPU_FREE linux macros.\n\t(__gnat_cpu_zero, __gnat_cpu_set): Use the CPU_ZERO_S and\n\tCPU_SET_S respectively because we are now using dynamically allocated\n\tCPU sets which are more portable across different glibc versions.\n\t* s-osinte-linux.ads (cpu_set_t_ptr, CPU_ALLOC, CPU_ALLOC_SIZE,\n\tCPU_FREE): Add this type and subprograms to be able to create cpu_set_t\n\tmasks dynamically according to the number of processors in the target\n\tplatform.\n\t(CPU_ZERO, CPU_SET): They are now mapped to the CPU_ZERO_S and CPU_SET_S\n\trespectively, so we need to pass the size of the masks as\n\tparameters.\n\t* s-taprop-linux.adb (Create_Task, Set_Task_Affinity): Use dynamically\n\tcreated cpu_set_t masks\n\twith the number of processors available in the target platform,\n\tinstead of static bit arrays. It enhances portability because\n\tit uses the information from the target platform.\n\t* sem_ch8.adb: (Attribute_Renaming): When checking whether we\n\tare using a restricted run-time library, use the flag\n\tConfigurable_Run_Time_Mode instead of Restricted_Profile.\n\nFrom-SVN: r178416", "tree": {"sha": "43c635534492841d32b301dc46c16759c59ad6a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43c635534492841d32b301dc46c16759c59ad6a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/comments", "author": {"login": "JoseRuizAdaCore", "id": 22770339, "node_id": "MDQ6VXNlcjIyNzcwMzM5", "avatar_url": "https://avatars.githubusercontent.com/u/22770339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoseRuizAdaCore", "html_url": "https://github.com/JoseRuizAdaCore", "followers_url": "https://api.github.com/users/JoseRuizAdaCore/followers", "following_url": "https://api.github.com/users/JoseRuizAdaCore/following{/other_user}", "gists_url": "https://api.github.com/users/JoseRuizAdaCore/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoseRuizAdaCore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoseRuizAdaCore/subscriptions", "organizations_url": "https://api.github.com/users/JoseRuizAdaCore/orgs", "repos_url": "https://api.github.com/users/JoseRuizAdaCore/repos", "events_url": "https://api.github.com/users/JoseRuizAdaCore/events{/privacy}", "received_events_url": "https://api.github.com/users/JoseRuizAdaCore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a95be2d47a4e851e44f04765e549e34c43b2f006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a95be2d47a4e851e44f04765e549e34c43b2f006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a95be2d47a4e851e44f04765e549e34c43b2f006"}], "stats": {"total": 165, "additions": 117, "deletions": 48}, "files": [{"sha": "c3cff67dfe7de1196bb0807641c30ad817489460", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "patch": "@@ -1,3 +1,27 @@\n+2011-09-01  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* adaint.c, adaint.h (__gnat_cpu_alloc, __gnat_cpu_alloc_size,\n+\t__gnat_cpu_set_free): Create these wrappers around the CPU_ALLOC,\n+\tCPU_ALLOC_SIZE and CPU_FREE linux macros.\n+\t(__gnat_cpu_zero, __gnat_cpu_set): Use the CPU_ZERO_S and\n+\tCPU_SET_S respectively because we are now using dynamically allocated\n+\tCPU sets which are more portable across different glibc versions.\n+\t* s-osinte-linux.ads (cpu_set_t_ptr, CPU_ALLOC, CPU_ALLOC_SIZE,\n+\tCPU_FREE): Add this type and subprograms to be able to create cpu_set_t\n+\tmasks dynamically according to the number of processors in the target\n+\tplatform.\n+\t(CPU_ZERO, CPU_SET): They are now mapped to the CPU_ZERO_S and CPU_SET_S\n+\trespectively, so we need to pass the size of the masks as\n+\tparameters.\n+\t* s-taprop-linux.adb (Create_Task, Set_Task_Affinity): Use dynamically\n+\tcreated cpu_set_t masks\n+\twith the number of processors available in the target platform,\n+\tinstead of static bit arrays. It enhances portability because\n+\tit uses the information from the target platform.\n+\t* sem_ch8.adb: (Attribute_Renaming): When checking whether we\n+\tare using a restricted run-time library, use the flag\n+\tConfigurable_Run_Time_Mode instead of Restricted_Profile.\n+\n 2011-09-01  Vincent Celier  <celier@adacore.com>\n \n \t* ug_words: Add /MULTI_UNIT_INDEX= -> -gnateI"}, {"sha": "605cdafb4be71c853f451d067b302980b9819edc", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "patch": "@@ -3790,16 +3790,31 @@ void *__gnat_lwp_self (void)\n \n #include <sched.h>\n \n-void __gnat_cpu_zero (cpu_set_t *set)\n+cpu_set_t *__gnat_cpu_alloc (size_t count)\n {\n-  CPU_ZERO (set);\n+  return CPU_ALLOC (count);\n }\n \n-void __gnat_cpu_set (int cpu, cpu_set_t *set)\n+size_t __gnat_cpu_alloc_size (size_t count)\n+{\n+  return CPU_ALLOC_SIZE (count);\n+}\n+\n+void __gnat_cpu_free (cpu_set_t *set)\n+{\n+  CPU_FREE (set);\n+}\n+\n+void __gnat_cpu_zero (size_t count, cpu_set_t *set)\n+{\n+  CPU_ZERO_S (count, set);\n+}\n+\n+void __gnat_cpu_set (int cpu, size_t count, cpu_set_t *set)\n {\n   /* Ada handles CPU numbers starting from 1, while C identifies the first\n      CPU by a 0, so we need to adjust. */\n-  CPU_SET (cpu - 1, set);\n+  CPU_SET_S (cpu - 1, count, set);\n }\n #endif\n "}, {"sha": "de00fb642b3b3f55a3977121e446040f82683f1d", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "patch": "@@ -252,8 +252,11 @@ extern void   *__gnat_lwp_self\t\t\t   (void);\n \n #include <sched.h>\n \n-extern void   __gnat_cpu_zero                      (cpu_set_t *);\n-extern void   __gnat_cpu_set                       (int, cpu_set_t *);\n+extern cpu_set_t *__gnat_cpu_alloc                 (size_t);\n+extern size_t __gnat_cpu_alloc_size                (size_t);\n+extern void   __gnat_cpu_set_free                  (cpu_set_t *);\n+extern void   __gnat_cpu_zero                      (size_t, cpu_set_t *);\n+extern void   __gnat_cpu_set                       (int, size_t, cpu_set_t *);\n #endif\n \n #if defined (_WIN32)"}, {"sha": "18a314bbc9734c0fd20891ea27e69ab3c7ac0302", "filename": "gcc/ada/s-osinte-linux.ads", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fs-osinte-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fs-osinte-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux.ads?ref=9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "patch": "@@ -471,6 +471,10 @@ package System.OS_Interface is\n    pragma Import (C, pthread_key_create, \"pthread_key_create\");\n \n    CPU_SETSIZE : constant := 1_024;\n+   --  Size of the cpu_set_t mask on most linux systems (SUSE 11 uses 4_096).\n+   --  This is kept for backward compatibility (System.Task_Info uses it), but\n+   --  the run-time library does no longer rely on static masks, using\n+   --  dynamically allocated masks instead.\n \n    type bit_field is array (1 .. CPU_SETSIZE) of Boolean;\n    for bit_field'Size use CPU_SETSIZE;\n@@ -482,18 +486,36 @@ package System.OS_Interface is\n    end record;\n    pragma Convention (C, cpu_set_t);\n \n-   procedure CPU_ZERO (cpuset : access cpu_set_t);\n+   type cpu_set_t_ptr is access all cpu_set_t;\n+   --  In the run-time library we use this pointer because the size of type\n+   --  cpu_set_t varies depending on the glibc version. Hence, objects of type\n+   --  cpu_set_t are allocated dynamically using the number of processors\n+   --  available in the target machine (value obtained at execution time).\n+\n+   function CPU_ALLOC (count : size_t) return cpu_set_t_ptr;\n+   pragma Import (C, CPU_ALLOC, \"__gnat_cpu_alloc\");\n+   --  Wrapper around the CPU_ALLOC C macro\n+\n+   function CPU_ALLOC_SIZE (count : size_t) return size_t;\n+   pragma Import (C, CPU_ALLOC_SIZE, \"__gnat_cpu_alloc_size\");\n+   --  Wrapper around the CPU_ALLOC_SIZE C macro\n+\n+   procedure CPU_FREE (cpuset : cpu_set_t_ptr);\n+   pragma Import (C, CPU_FREE, \"__gnat_cpu_free\");\n+   --  Wrapper around the CPU_FREE C macro\n+\n+   procedure CPU_ZERO (count : size_t; cpuset : cpu_set_t_ptr);\n    pragma Import (C, CPU_ZERO, \"__gnat_cpu_zero\");\n-   --  Wrapper around the CPU_ZERO C macro\n+   --  Wrapper around the CPU_ZERO_S C macro\n \n-   procedure CPU_SET (cpu : int; cpuset : access cpu_set_t);\n+   procedure CPU_SET (cpu : int; count : size_t; cpuset : cpu_set_t_ptr);\n    pragma Import (C, CPU_SET, \"__gnat_cpu_set\");\n-   --  Wrapper around the CPU_SET C macro\n+   --  Wrapper around the CPU_SET_S C macro\n \n    function pthread_setaffinity_np\n      (thread     : pthread_t;\n       cpusetsize : size_t;\n-      cpuset     : access cpu_set_t) return int;\n+      cpuset     : cpu_set_t_ptr) return int;\n    pragma Import (C, pthread_setaffinity_np, \"pthread_setaffinity_np\");\n    pragma Weak_External (pthread_setaffinity_np);\n    --  Use a weak symbol because this function may be available or not,\n@@ -502,7 +524,7 @@ package System.OS_Interface is\n    function pthread_attr_setaffinity_np\n      (attr       : access pthread_attr_t;\n       cpusetsize : size_t;\n-      cpuset     : access cpu_set_t) return int;\n+      cpuset     : cpu_set_t_ptr) return int;\n    pragma Import (C, pthread_attr_setaffinity_np,\n                     \"pthread_attr_setaffinity_np\");\n    pragma Weak_External (pthread_attr_setaffinity_np);"}, {"sha": "20345666683a7a1eda2fdf91a130637747095aa8", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "patch": "@@ -869,25 +869,25 @@ package body System.Task_Primitives.Operations is\n \n       elsif T.Common.Base_CPU /= System.Multiprocessors.Not_A_Specific_CPU then\n          declare\n-            CPU_Set : aliased cpu_set_t;\n+            CPUs    : constant size_t :=\n+              Interfaces.C.size_t (System.Multiprocessors.Number_Of_CPUs);\n+            CPU_Set : constant cpu_set_t_ptr := CPU_ALLOC (CPUs);\n+            Size    : constant size_t := CPU_ALLOC_SIZE (CPUs);\n \n          begin\n-            System.OS_Interface.CPU_ZERO (CPU_Set'Access);\n+            CPU_ZERO (Size, CPU_Set);\n             System.OS_Interface.CPU_SET\n-              (int (T.Common.Base_CPU), CPU_Set'Access);\n+              (int (T.Common.Base_CPU), Size, CPU_Set);\n             Result :=\n-              pthread_attr_setaffinity_np\n-                (Attributes'Access,\n-                 CPU_SETSIZE / 8,\n-                 CPU_Set'Access);\n+              pthread_attr_setaffinity_np (Attributes'Access, Size, CPU_Set);\n             pragma Assert (Result = 0);\n+\n+            CPU_FREE (CPU_Set);\n          end;\n \n       --  Handle Task_Info\n \n-      elsif T.Common.Task_Info /= null\n-        and then T.Common.Task_Info.CPU_Affinity /= Task_Info.Any_CPU\n-      then\n+      elsif T.Common.Task_Info /= null then\n          Result :=\n            pthread_attr_setaffinity_np\n              (Attributes'Access,\n@@ -908,26 +908,28 @@ package body System.Task_Primitives.Operations is\n                      Multiprocessors.Number_Of_CPUs => True))\n       then\n          declare\n-            CPU_Set : aliased cpu_set_t;\n+            CPUs    : constant size_t :=\n+              Interfaces.C.size_t (System.Multiprocessors.Number_Of_CPUs);\n+            CPU_Set : constant cpu_set_t_ptr := CPU_ALLOC (CPUs);\n+            Size    : constant size_t := CPU_ALLOC_SIZE (CPUs);\n \n          begin\n-            System.OS_Interface.CPU_ZERO (CPU_Set'Access);\n+            CPU_ZERO (Size, CPU_Set);\n \n             --  Set the affinity to all the processors belonging to the\n             --  dispatching domain.\n \n             for Proc in T.Common.Domain'Range loop\n                if T.Common.Domain (Proc) then\n-                  System.OS_Interface.CPU_SET (int (Proc), CPU_Set'Access);\n+                  System.OS_Interface.CPU_SET (int (Proc), Size, CPU_Set);\n                end if;\n             end loop;\n \n             Result :=\n-              pthread_attr_setaffinity_np\n-                (Attributes'Access,\n-                 CPU_SETSIZE / 8,\n-                 CPU_Set'Access);\n+              pthread_attr_setaffinity_np (Attributes'Access, Size, CPU_Set);\n             pragma Assert (Result = 0);\n+\n+            CPU_FREE (CPU_Set);\n          end;\n       end if;\n \n@@ -1400,9 +1402,10 @@ package body System.Task_Primitives.Operations is\n         and then T.Common.LL.Thread /= Null_Thread_Id\n       then\n          declare\n-            type cpu_set_t_ptr is access all cpu_set_t;\n-            CPU_Set : aliased cpu_set_t;\n-            CPU_Set_Ptr : cpu_set_t_ptr := null;\n+            CPUs    : constant size_t :=\n+              Interfaces.C.size_t (System.Multiprocessors.Number_Of_CPUs);\n+            CPU_Set : cpu_set_t_ptr := null;\n+            Size    : constant size_t := CPU_ALLOC_SIZE (CPUs);\n \n             Result  : Interfaces.C.int;\n \n@@ -1414,17 +1417,16 @@ package body System.Task_Primitives.Operations is\n             if T.Common.Base_CPU /= Multiprocessors.Not_A_Specific_CPU then\n \n                --  Set the affinity to an unique CPU\n-               System.OS_Interface.CPU_ZERO (CPU_Set'Access);\n+\n+               CPU_Set := CPU_ALLOC (CPUs);\n+               System.OS_Interface.CPU_ZERO (Size, CPU_Set);\n                System.OS_Interface.CPU_SET\n-                 (int (T.Common.Base_CPU), CPU_Set'Access);\n-               CPU_Set_Ptr := CPU_Set'Access;\n+                 (int (T.Common.Base_CPU), Size, CPU_Set);\n \n             --  Handle Task_Info\n \n-            elsif T.Common.Task_Info /= null\n-              and then T.Common.Task_Info.CPU_Affinity /= Task_Info.Any_CPU\n-            then\n-               CPU_Set_Ptr := T.Common.Task_Info.CPU_Affinity'Access;\n+            elsif T.Common.Task_Info /= null then\n+               CPU_Set := T.Common.Task_Info.CPU_Affinity'Access;\n \n             --  Handle dispatching domains\n \n@@ -1440,25 +1442,25 @@ package body System.Task_Primitives.Operations is\n                --  domain other than the default one, or when the default one\n                --  has been modified.\n \n-               System.OS_Interface.CPU_ZERO (CPU_Set'Access);\n+               CPU_Set := CPU_ALLOC (CPUs);\n+               System.OS_Interface.CPU_ZERO (Size, CPU_Set);\n \n                for Proc in T.Common.Domain'Range loop\n-                  System.OS_Interface.CPU_SET (int (Proc), CPU_Set'Access);\n+                  System.OS_Interface.CPU_SET (int (Proc), Size, CPU_Set);\n                end loop;\n-\n-               CPU_Set_Ptr := CPU_Set'Access;\n             end if;\n \n             --  We set the new affinity if needed. Otherwise, the new task\n             --  will inherit its creator's CPU affinity mask (according to\n             --  the documentation of pthread_setaffinity_np), which is\n             --  consistent with Ada's required semantics.\n \n-            if CPU_Set_Ptr /= null then\n+            if CPU_Set /= null then\n                Result :=\n-                 pthread_setaffinity_np\n-                   (T.Common.LL.Thread, CPU_SETSIZE / 8, CPU_Set_Ptr);\n+                 pthread_setaffinity_np (T.Common.LL.Thread, Size, CPU_Set);\n                pragma Assert (Result = 0);\n+\n+               CPU_FREE (CPU_Set);\n             end if;\n          end;\n       end if;"}, {"sha": "796f9b07f71c2499b378033284a6e0bb3880a3a8", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "patch": "@@ -3292,10 +3292,13 @@ package body Sem_Ch8 is\n \n       --  We must exclude VM targets and restricted run-time libraries because\n       --  entity AST_Handler is defined in package System.Aux_Dec which is not\n-      --  available in those platforms.\n+      --  available in those platforms. Note that we cannot use the function\n+      --  Restricted_Profile (instead of Configurable_Run_Time_Mode) because\n+      --  the ZFP run-time library is not defined as a profile, and we do not\n+      --  want to deal with AST_Handler in ZFP mode.\n \n       if VM_Target = No_VM\n-        and then not Restricted_Profile\n+        and then not Configurable_Run_Time_Mode\n         and then not Present (Corresponding_Formal_Spec (N))\n         and then Etype (Nam) /= RTE (RE_AST_Handler)\n       then"}]}