{"sha": "d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkyNDZkMmQ0YWUzMGFiMWI5ZjNjNjU3YjUzODc0MzQyZTliOGFjMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:38:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-01-03T15:38:00Z"}, "message": "exp_ch7.ads (Make_Final_Call): Rewrite comment (was incorrectly copied from Make_Init_Call).\n\n\t* exp_ch7.ads (Make_Final_Call): Rewrite comment (was incorrectly\n\tcopied from Make_Init_Call).\n\n\t* exp_strm.adb (Build_Mutable_Record_Read_Procedure): Do component\n\treads and assignments on a temporary variable declared with appropriate\n\tdiscriminants.\n\nFrom-SVN: r92838", "tree": {"sha": "a880071829d5f8e8710dd1390481cba4d860b9fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a880071829d5f8e8710dd1390481cba4d860b9fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2/comments", "author": null, "committer": null, "parents": [{"sha": "16db96c5a21562edf1bc435449e519253ca7a37d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16db96c5a21562edf1bc435449e519253ca7a37d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16db96c5a21562edf1bc435449e519253ca7a37d"}], "stats": {"total": 120, "additions": 83, "deletions": 37}, "files": [{"sha": "75d2507c7d003b2e6be75d54ece1ac6537f7dba3", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2", "patch": "@@ -95,7 +95,7 @@ package Exp_Ch7 is\n    --  initialized. Typ is the expected type of Ref, which is a controlled\n    --  type (Is_Controlled) or a type with controlled components\n    --  (Has_Controlled). With_Attach is an integer expression representing\n-   --  the level of attachment, see Attach_To_Final_Lists' NB_Link param\n+   --  the level of attachment, see Attach_To_Final_List's Nb_Link param\n    --  documentation in s-finimp.ads.\n    --\n    --  This function will generate the appropriate calls to make\n@@ -114,7 +114,7 @@ package Exp_Ch7 is\n    --  adjusted. Typ is the expected type of Ref, which is a controlled\n    --  type (Is_Controlled) or a type with controlled components\n    --  (Has_Controlled).  With_Attach is an integer expression representing\n-   --  the level of attachment, see Attach_To_Final_Lists' NB_Link param\n+   --  the level of attachment, see Attach_To_Final_List's Nb_Link param\n    --  documentation in s-finimp.ads.\n    --\n    --  This function will generate the appropriate calls to make\n@@ -133,10 +133,9 @@ package Exp_Ch7 is\n    --  to have been previously analyzed) that references the object to\n    --  be Finalized. Typ is the expected type of Ref, which is a\n    --  controlled type (Is_Controlled) or a type with controlled\n-   --  components (Has_Controlled). With_Attach is an integer\n-   --  expression representing the level of attachment, see\n-   --  Attach_To_Final_Lists' NB_Link param documentation in\n-   --  s-finimp.ads.\n+   --  components (Has_Controlled). With_Detach is a boolean expression\n+   --  indicating whether to detach the controlled object from whatever\n+   --  finalization list it is currently attached to.\n    --\n    --  This function will generate the appropriate calls to make\n    --  sure that the objects referenced by Ref are finalized. The generated"}, {"sha": "9a5129efb9df6544fd9527d3238dbe9724e96d74", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 78, "deletions": 31, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=d9246d2d4ae30ab1b9f3c657b53874342e9b8ac2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -679,13 +679,11 @@ package body Exp_Strm is\n       --  be outside the range of a 32-bit signed integer, so this must be\n       --  treated as 32-bit unsigned.\n \n-      --  Similarly, if we have\n+      --  Similarly, the representation is also unsigned if we have:\n \n       --     type W is range -1 .. +254;\n       --     for W'Size use 8;\n \n-      --  then the representation is also unsigned.\n-\n       elsif not Is_Unsigned_Type (FST)\n         and then\n           (Is_Fixed_Point_Type (U_Type)\n@@ -772,64 +770,113 @@ package body Exp_Strm is\n       Decl : out Node_Id;\n       Pnam : out Entity_Id)\n    is\n-      Stms  : List_Id;\n-      Disc  : Entity_Id;\n-      Comp  : Node_Id;\n+      Stms : List_Id;\n+      --  Statements for the 'Read body\n+\n+      Tmp : constant Entity_Id := Make_Defining_Identifier (Loc, Name_V);\n+      --  Temporary, must hide formal (assignments to components of the\n+      --  record are always generated with V as the identifier for the record).\n+\n+      Cstr : List_Id;\n+      --  List of constraints to be applied on temporary\n+\n+      Disc     : Entity_Id;\n+      Disc_Ref : Node_Id;\n+      Block    : Node_Id;\n \n    begin\n       Stms := New_List;\n+      Cstr := New_List;\n       Disc := First_Discriminant (Typ);\n \n-      --  Generate Reads for the discriminants of the type.\n+      --  A mutable type cannot be a tagged type, so we generate a new name\n+      --  for the stream procedure.\n+\n+      Pnam :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => Make_TSS_Name_Local (Typ, TSS_Stream_Read));\n+\n+      --  Generate Reads for the discriminants of the type. The discriminants\n+      --  need to be read before the rest of the components, so that\n+      --  variants are initialized correctly.\n \n       while Present (Disc) loop\n-         Comp :=\n+         Disc_Ref :=\n            Make_Selected_Component (Loc,\n-             Prefix => Make_Identifier (Loc, Name_V),\n+             Prefix        => Make_Selected_Component (Loc,\n+                                Prefix => New_Occurrence_Of (Pnam, Loc),\n+                                Selector_Name =>\n+                                  Make_Identifier (Loc, Name_V)),\n              Selector_Name => New_Occurrence_Of (Disc, Loc));\n \n-         Set_Assignment_OK (Comp);\n+         Set_Assignment_OK (Disc_Ref);\n \n          Append_To (Stms,\n            Make_Attribute_Reference (Loc,\n              Prefix => New_Occurrence_Of (Etype (Disc), Loc),\n                Attribute_Name => Name_Read,\n                Expressions => New_List (\n                  Make_Identifier (Loc, Name_S),\n-                 Comp)));\n+                 Disc_Ref)));\n \n+         Append_To (Cstr,\n+           Make_Discriminant_Association (Loc,\n+             Selector_Names => New_List (New_Occurrence_Of (Disc, Loc)),\n+             Expression     => New_Copy_Tree (Disc_Ref)));\n          Next_Discriminant (Disc);\n       end loop;\n \n-      --  A mutable type cannot be a tagged type, so we generate a new name\n-      --  for the stream procedure.\n+      --  Generate reads for the components of the record (including\n+      --  those that depend on discriminants).\n \n-      Pnam :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => Make_TSS_Name_Local (Typ, TSS_Stream_Read));\n       Build_Record_Read_Write_Procedure (Loc, Typ, Decl, Pnam, Name_Read);\n \n-      --  Read the discriminants before the rest of the components, so\n-      --  that discriminant values are properly set of variants, etc.\n-      --  If this is an empty record with discriminants, there are no\n-      --  previous statements. If this is an unchecked union, the stream\n-      --  procedure is erroneous, because there are no discriminants to read.\n+      --  If Typ has controlled components (i.e. if it is classwide\n+      --  or Has_Controlled), or components constrained using the discriminants\n+      --  of Typ, then we need to ensure that all component assignments\n+      --  are performed on an object that has been appropriately constrained\n+      --  prior to being initialized. To this effect, we wrap the component\n+      --  assignments in a block where V is a constrained temporary.\n+\n+      Block :=\n+        Make_Block_Statement (Loc,\n+          Declarations => New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Tmp,\n+             Object_Definition   =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark => New_Occurrence_Of (Typ, Loc),\n+                 Constraint =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     Constraints => Cstr)))),\n+          Handled_Statement_Sequence =>\n+            Handled_Statement_Sequence (Decl));\n+\n+      Append_To (Stms, Block);\n+\n+      Append_To (Statements (Handled_Statement_Sequence (Block)),\n+        Make_Assignment_Statement (Loc,\n+          Name => Make_Selected_Component (Loc,\n+                    Prefix => New_Occurrence_Of (Pnam, Loc),\n+                    Selector_Name => Make_Identifier (Loc, Name_V)),\n+          Expression => Make_Identifier (Loc, Name_V)));\n \n       if Is_Unchecked_Union (Typ) then\n+\n+         --  If this is an unchecked union, the stream procedure is erroneous,\n+         --  because there are no discriminants to read.\n+\n+         --  This should generate a warning ???\n+\n          Stms :=\n            New_List (\n              Make_Raise_Program_Error (Loc,\n                Reason => PE_Unchecked_Union_Restriction));\n       end if;\n \n-      if Is_Non_Empty_List (\n-        Statements (Handled_Statement_Sequence (Decl)))\n-      then\n-         Insert_List_Before\n-           (First (Statements (Handled_Statement_Sequence (Decl))), Stms);\n-      else\n-         Set_Statements (Handled_Statement_Sequence (Decl), Stms);\n-      end if;\n+      Set_Handled_Statement_Sequence (Decl,\n+        Make_Handled_Sequence_Of_Statements (Loc,\n+          Statements => Stms));\n    end Build_Mutable_Record_Read_Procedure;\n \n    ------------------------------------------\n@@ -849,7 +896,7 @@ package body Exp_Strm is\n       Stms := New_List;\n       Disc := First_Discriminant (Typ);\n \n-      --  Generate Writes for the discriminants of the type.\n+      --  Generate Writes for the discriminants of the type\n \n       while Present (Disc) loop\n "}]}