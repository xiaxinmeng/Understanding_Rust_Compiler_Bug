{"sha": "9fc158eb3496423579aebbed057819e7d142fb96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZjMTU4ZWIzNDk2NDIzNTc5YWViYmVkMDU3ODE5ZTdkMTQyZmI5Ng==", "commit": {"author": {"name": "Bilyan Borisov", "email": "bilyan.borisov@arm.com", "date": "2016-11-01T12:48:32Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2016-11-01T12:48:32Z"}, "message": "arm-c.c (arm_cpu_builtins): New macro definition.\n\ngcc/\n\n2016-09-30  Bilyan Borisov  <bilyan.borisov@arm.com>\n\t    Tamar Christina <tamar.christina@arm.com>\n\n\t* config/arm/arm-c.c (arm_cpu_builtins): New macro definition.\n\t* config/arm/arm_neon.h (vmaxnm_f32): New intrinsinc.\n\t(vmaxnmq_f32): Likewise.\n\t(vminnm_f32): Likewise.\n\t(vminnmq_f32): Likewise.\n\t* config/arm/arm_neon_builtins.def (vmaxnm): New builtin.\n\t(vminnm): Likewise.\n\t* config/arm/neon.md (neon_<fmaxmin_op><mode>, VCVTF): New\n\texpander.\n\ngcc/testsuite/\n\n2016-09-30  Bilyan Borisov  <bilyan.borisov@arm.com>\n\n\t* gcc.target/arm/simd/vmaxnm_f32_1.c: New.\n\t* gcc.target/arm/simd/vmaxnmq_f32_1.c: Likewise.\n\t* gcc.target/arm/simd/vminnm_f32_1.c: Likewise.\n\t* gcc.target/arm/simd/vminnmq_f32_1.c: Likewise.\n\n\nCo-Authored-By: Tamar Christina <tamar.christina@arm.com>\n\nFrom-SVN: r241736", "tree": {"sha": "8bcd370eddd2043a62fe4723fc771352bffbad2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bcd370eddd2043a62fe4723fc771352bffbad2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fc158eb3496423579aebbed057819e7d142fb96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc158eb3496423579aebbed057819e7d142fb96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc158eb3496423579aebbed057819e7d142fb96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc158eb3496423579aebbed057819e7d142fb96/comments", "author": null, "committer": null, "parents": [{"sha": "ea4249cb24da2315a58105bc37004f14de12f349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea4249cb24da2315a58105bc37004f14de12f349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea4249cb24da2315a58105bc37004f14de12f349"}], "stats": {"total": 703, "additions": 701, "deletions": 2}, "files": [{"sha": "8c6331e13b96df1cf5ae4d371a98e3bf9d3eb7c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -1,3 +1,16 @@\n+2016-11-01  Bilyan Borisov  <bilyan.borisov@arm.com>\n+\t    Tamar Christina <tamar.christina@arm.com>\n+\n+\t* config/arm/arm-c.c (arm_cpu_builtins): New macro definition.\n+\t* config/arm/arm_neon.h (vmaxnm_f32): New intrinsinc.\n+\t(vmaxnmq_f32): Likewise.\n+\t(vminnm_f32): Likewise.\n+\t(vminnmq_f32): Likewise.\n+\t* config/arm/arm_neon_builtins.def (vmaxnm): New builtin.\n+\t(vminnm): Likewise.\n+\t* config/arm/neon.md (neon_<fmaxmin_op><mode>, VCVTF): New\n+\texpander.\n+\n 2016-10-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/vsx.md (VSX_EXTRACT_FL): New iterator for all"}, {"sha": "74417a6446dbac903da567f3de4f25b387846165", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -87,6 +87,9 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n \t\t      ((TARGET_ARM_ARCH >= 5 && !TARGET_THUMB)\n \t\t       || TARGET_ARM_ARCH_ISA_THUMB >=2));\n \n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_NUMERIC_MAXMIN\",\n+\t\t      TARGET_ARM_ARCH >= 8 && TARGET_NEON && TARGET_FPU_ARMV8);\n+\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_SIMD32\", TARGET_INT_SIMD);\n \n   builtin_define_with_int_value (\"__ARM_SIZEOF_MINIMAL_ENUM\","}, {"sha": "3898ff7302dc3f21e6b50a8a7b835033c1ae2021", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -2956,6 +2956,34 @@ vmaxq_f32 (float32x4_t __a, float32x4_t __b)\n   return (float32x4_t)__builtin_neon_vmaxfv4sf (__a, __b);\n }\n \n+#pragma GCC push_options\n+#pragma GCC target (\"fpu=neon-fp-armv8\")\n+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))\n+vmaxnm_f32 (float32x2_t a, float32x2_t b)\n+{\n+  return (float32x2_t)__builtin_neon_vmaxnmv2sf (a, b);\n+}\n+\n+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n+vmaxnmq_f32 (float32x4_t a, float32x4_t b)\n+{\n+  return (float32x4_t)__builtin_neon_vmaxnmv4sf (a, b);\n+}\n+\n+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))\n+vminnm_f32 (float32x2_t a, float32x2_t b)\n+{\n+  return (float32x2_t)__builtin_neon_vminnmv2sf (a, b);\n+}\n+\n+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))\n+vminnmq_f32 (float32x4_t a, float32x4_t b)\n+{\n+  return (float32x4_t)__builtin_neon_vminnmv4sf (a, b);\n+}\n+#pragma GCC pop_options\n+\n+\n __extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))\n vmaxq_u8 (uint8x16_t __a, uint8x16_t __b)\n {"}, {"sha": "58b10207c1f5c0380cb01fdb4a92a3f0b4dec591", "filename": "gcc/config/arm/arm_neon_builtins.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon_builtins.def?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -147,12 +147,12 @@ VAR6 (BINOP, vmaxs, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR6 (BINOP, vmaxu, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR2 (BINOP, vmaxf, v2sf, v4sf)\n VAR2 (BINOP, vmaxf, v8hf, v4hf)\n-VAR2 (BINOP, vmaxnm, v4hf, v8hf)\n+VAR4 (BINOP, vmaxnm, v2sf, v4sf, v4hf, v8hf)\n VAR6 (BINOP, vmins, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR6 (BINOP, vminu, v8qi, v4hi, v2si, v16qi, v8hi, v4si)\n VAR2 (BINOP, vminf, v2sf, v4sf)\n VAR2 (BINOP, vminf, v4hf, v8hf)\n-VAR2 (BINOP, vminnm, v8hf, v4hf)\n+VAR4 (BINOP, vminnm, v2sf, v4sf, v8hf, v4hf)\n \n VAR3 (BINOP, vpmaxs, v8qi, v4hi, v2si)\n VAR3 (BINOP, vpmaxu, v8qi, v4hi, v2si)"}, {"sha": "4297511c1860127d6e9ef7d10d5cc031a9036855", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -2845,6 +2845,17 @@\n  [(set_attr \"type\" \"neon_fp_minmax_s<q>\")]\n )\n \n+;; v<maxmin>nm intrinsics.\n+(define_insn \"neon_<fmaxmin_op><mode>\"\n+  [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n+\t(unspec:VCVTF [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")\n+\t\t       (match_operand:VCVTF 2 \"s_register_operand\" \"w\")]\n+\t\t       VMAXMINFNM))]\n+  \"TARGET_NEON && TARGET_FPU_ARMV8\"\n+  \"<fmaxmin_op>.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  [(set_attr \"type\" \"neon_fp_minmax_s<q>\")]\n+)\n+\n ;; Vector forms for the IEEE-754 fmax()/fmin() functions\n (define_insn \"<fmaxmin><mode>3\"\n   [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")"}, {"sha": "3d49662d84e7131b8dda35695c6f2957fe346f1d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -1,3 +1,10 @@\n+2016-11-01  Bilyan Borisov  <bilyan.borisov@arm.com>\n+\n+\t* gcc.target/arm/simd/vmaxnm_f32_1.c: New.\n+\t* gcc.target/arm/simd/vmaxnmq_f32_1.c: Likewise.\n+\t* gcc.target/arm/simd/vminnm_f32_1.c: Likewise.\n+\t* gcc.target/arm/simd/vminnmq_f32_1.c: Likewise.\n+\n 2016-11-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* lib/target-supports.exp: Normalize order of i?86 and x86_64 targets."}, {"sha": "c3a9f3671b36a1491ed6d33dc894a3b4b559c4ae", "filename": "gcc/testsuite/gcc.target/arm/simd/vmaxnm_f32_1.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvmaxnm_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvmaxnm_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvmaxnm_f32_1.c?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -0,0 +1,159 @@\n+/* Test the `vmaxnmf32' ARM Neon intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-options \"-save-temps -O3 -march=armv8-a\" } */\n+/* { dg-add-options arm_v8_neon } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort ();\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__regular_input1 ()\n+{\n+  float32_t a1[] = {1,2};\n+  float32_t b1[] = {3,4};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != b1[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__regular_input2 ()\n+{\n+  float32_t a1[] = {3,2};\n+  float32_t b1[] = {1,4};\n+  float32_t e[] = {3,4};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__quiet_NaN_one_arg ()\n+{\n+  /* When given a quiet NaN, vmaxnm returns the other operand.\n+     In this test case we have NaNs in only one operand.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {1,2};\n+  float32_t b1[] = {n,n};\n+  float32_t e[] = {1,2};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__quiet_NaN_both_args ()\n+{\n+  /* When given a quiet NaN, vmaxnm returns the other operand.\n+     In this test case we have NaNs in both operands.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,2};\n+  float32_t b1[] = {1,n};\n+  float32_t e[] = {1,2};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__zero_both_args ()\n+{\n+  /* For 0 and -0, vmaxnm returns 0.  Since 0 == -0, check sign bit.  */\n+  float32_t a1[] = {0.0, 0.0};\n+  float32_t b1[] = {-0.0, -0.0};\n+  float32_t e[] = {0.0, 0.0};\n+\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+\n+  float32_t actual1[2];\n+  vst1_f32 (actual1, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual1[i] != e[i] || __builtin_signbit (actual1[i]) != 0)\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__inf_both_args ()\n+{\n+  /* The max of inf and inf is inf.  The max of -inf and -inf is -inf.  */\n+  float32_t inf = __builtin_huge_valf ();\n+  float32_t a1[] = {inf, -inf};\n+  float32_t b1[] = {inf, -inf};\n+  float32_t e[] = {inf, -inf};\n+\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+\n+  float32_t actual1[2];\n+  vst1_f32 (actual1, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual1[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnm_f32__two_quiet_NaNs_both_args ()\n+{\n+  /* When given 2 NaNs, return a NaN.  Since a NaN is not equal to anything,\n+     not even another NaN, use __builtin_isnan () to check.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,n};\n+  float32_t b1[] = {n,n};\n+  float32_t e[] = {n,n};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vmaxnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (!__builtin_isnan (actual[i]))\n+      abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_vmaxnm_f32__regular_input1 ();\n+  test_vmaxnm_f32__regular_input2 ();\n+  test_vmaxnm_f32__quiet_NaN_one_arg ();\n+  test_vmaxnm_f32__quiet_NaN_both_args ();\n+  test_vmaxnm_f32__zero_both_args ();\n+  test_vmaxnm_f32__inf_both_args ();\n+  test_vmaxnm_f32__two_quiet_NaNs_both_args ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vmaxnm\\.f32\\t\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 7 } } */"}, {"sha": "80c4e9aa18810fea318b865e8c4e503238e826f8", "filename": "gcc/testsuite/gcc.target/arm/simd/vmaxnmq_f32_1.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvmaxnmq_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvmaxnmq_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvmaxnmq_f32_1.c?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -0,0 +1,160 @@\n+/* Test the `vmaxnmqf32' ARM Neon intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-options \"-save-temps -O3 -march=armv8-a\" } */\n+/* { dg-add-options arm_v8_neon } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort ();\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__regular_input1 ()\n+{\n+  float32_t a1[] = {1,2,5,6};\n+  float32_t b1[] = {3,4,7,8};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != b1[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__regular_input2 ()\n+{\n+  float32_t a1[] = {3,2,7,6};\n+  float32_t b1[] = {1,4,5,8};\n+  float32_t e[] = {3,4,7,8};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__quiet_NaN_one_arg ()\n+{\n+  /* When given a quiet NaN, vmaxnmq returns the other operand.\n+     In this test case we have NaNs in only one operand.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {1,2,3,4};\n+  float32_t b1[] = {n,n,n,n};\n+  float32_t e[] = {1,2,3,4};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__quiet_NaN_both_args ()\n+{\n+  /* When given a quiet NaN, vmaxnmq returns the other operand.\n+     In this test case we have NaNs in both operands.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,2,n,4};\n+  float32_t b1[] = {1,n,3,n};\n+  float32_t e[] = {1,2,3,4};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__zero_both_args ()\n+{\n+  /* For 0 and -0, vmaxnmq returns 0.  Since 0 == -0, check sign bit.  */\n+  float32_t a1[] = {0.0, 0.0, -0.0, -0.0};\n+  float32_t b1[] = {-0.0, -0.0, 0.0, 0.0};\n+  float32_t e[] = {0.0, 0.0, 0.0, 0.0};\n+\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+\n+  float32_t actual1[4];\n+  vst1q_f32 (actual1, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual1[i] != e[i] || __builtin_signbit (actual1[i]) != 0)\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__inf_both_args ()\n+{\n+  /* The max of inf and inf is inf.  The max of -inf and -inf is -inf.  */\n+  float32_t inf = __builtin_huge_valf ();\n+  float32_t a1[] = {inf, -inf, inf, inf};\n+  float32_t b1[] = {inf, -inf, -inf, -inf};\n+  float32_t e[] = {inf, -inf, inf, inf};\n+\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+\n+  float32_t actual1[4];\n+  vst1q_f32 (actual1, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual1[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vmaxnmq_f32__two_quiet_NaNs_both_args ()\n+{\n+  /* When given 2 NaNs, return a NaN.  Since a NaN is not equal to anything,\n+     not even another NaN, use __builtin_isnan () to check.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,n,n,n};\n+  float32_t b1[] = {n,n,n,n};\n+  float32_t e[] = {n,n};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vmaxnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (!__builtin_isnan (actual[i]))\n+      abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_vmaxnmq_f32__regular_input1 ();\n+  test_vmaxnmq_f32__regular_input2 ();\n+  test_vmaxnmq_f32__quiet_NaN_one_arg ();\n+  test_vmaxnmq_f32__quiet_NaN_both_args ();\n+  test_vmaxnmq_f32__zero_both_args ();\n+  test_vmaxnmq_f32__inf_both_args ();\n+  test_vmaxnmq_f32__two_quiet_NaNs_both_args ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vmaxnm\\.f32\\t\\[qQ\\]\\[0-9\\]+, ?\\[qQ\\]\\[0-9\\]+, ?\\[qQ\\]\\[0-9\\]+\\n\" 7 } } */"}, {"sha": "9a1d097911748108591a11f3bd7fbf3e44adebaa", "filename": "gcc/testsuite/gcc.target/arm/simd/vminnm_f32_1.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvminnm_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvminnm_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvminnm_f32_1.c?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -0,0 +1,159 @@\n+/* Test the `vminnmf32' ARM Neon intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-options \"-save-temps -O3 -march=armv8-a\" } */\n+/* { dg-add-options arm_v8_neon } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort ();\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__regular_input1 ()\n+{\n+  float32_t a1[] = {1,2};\n+  float32_t b1[] = {3,4};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != a1[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__regular_input2 ()\n+{\n+  float32_t a1[] = {3,2};\n+  float32_t b1[] = {1,4};\n+  float32_t e[] = {1,2};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__quiet_NaN_one_arg ()\n+{\n+  /* When given a quiet NaN, vminnm returns the other operand.\n+     In this test case we have NaNs in only one operand.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {1,2};\n+  float32_t b1[] = {n,n};\n+  float32_t e[] = {1,2};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__quiet_NaN_both_args ()\n+{\n+  /* When given a quiet NaN, vminnm returns the other operand.\n+     In this test case we have NaNs in both operands.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,2};\n+  float32_t b1[] = {1,n};\n+  float32_t e[] = {1,2};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__zero_both_args ()\n+{\n+  /* For 0 and -0, vminnm returns -0.  Since 0 == -0, check sign bit.  */\n+  float32_t a1[] = {0.0,0.0};\n+  float32_t b1[] = {-0.0, -0.0};\n+  float32_t e[] = {-0.0, -0.0};\n+\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+\n+  float32_t actual1[2];\n+  vst1_f32 (actual1, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual1[i] != e[i] || __builtin_signbit (actual1[i]) == 0)\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__inf_both_args ()\n+{\n+  /* The min of inf and inf is inf.  The min of -inf and -inf is -inf.  */\n+  float32_t inf = __builtin_huge_valf ();\n+  float32_t a1[] = {inf, -inf};\n+  float32_t b1[] = {inf, -inf};\n+  float32_t e[] = {inf, -inf};\n+\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+\n+  float32_t actual1[2];\n+  vst1_f32 (actual1, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (actual1[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnm_f32__two_quiet_NaNs_both_args ()\n+{\n+  /* When given 2 NaNs, return a NaN.  Since a NaN is not equal to anything,\n+     not even another NaN, use __builtin_isnan () to check.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,n};\n+  float32_t b1[] = {n,n};\n+  float32_t e[] = {n,n};\n+  float32x2_t a = vld1_f32 (a1);\n+  float32x2_t b = vld1_f32 (b1);\n+  float32x2_t c = vminnm_f32 (a, b);\n+  float32_t actual[2];\n+  vst1_f32 (actual, c);\n+\n+  for (int i = 0; i < 2; ++i)\n+    if (!__builtin_isnan (actual[i]))\n+      abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_vminnm_f32__regular_input1 ();\n+  test_vminnm_f32__regular_input2 ();\n+  test_vminnm_f32__quiet_NaN_one_arg ();\n+  test_vminnm_f32__quiet_NaN_both_args ();\n+  test_vminnm_f32__zero_both_args ();\n+  test_vminnm_f32__inf_both_args ();\n+  test_vminnm_f32__two_quiet_NaNs_both_args ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vminnm\\.f32\\t\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+, ?\\[dD\\]\\[0-9\\]+\\n\" 7 } } */"}, {"sha": "a778abecd857e9ea83d249e0ab52886209030aa4", "filename": "gcc/testsuite/gcc.target/arm/simd/vminnmq_f32_1.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvminnmq_f32_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc158eb3496423579aebbed057819e7d142fb96/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvminnmq_f32_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fvminnmq_f32_1.c?ref=9fc158eb3496423579aebbed057819e7d142fb96", "patch": "@@ -0,0 +1,159 @@\n+/* Test the `vminnmqf32' ARM Neon intrinsic.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-options \"-save-temps -O3 -march=armv8-a\" } */\n+/* { dg-add-options arm_v8_neon } */\n+\n+#include \"arm_neon.h\"\n+\n+extern void abort ();\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__regular_input1 ()\n+{\n+  float32_t a1[] = {1,2,5,6};\n+  float32_t b1[] = {3,4,7,8};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != a1[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__regular_input2 ()\n+{\n+  float32_t a1[] = {3,2,7,6};\n+  float32_t b1[] = {1,4,5,8};\n+  float32_t e[] = {1,2,5,6};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__quiet_NaN_one_arg ()\n+{\n+  /* When given a quiet NaN, vminnmq returns the other operand.\n+     In this test case we have NaNs in only one operand.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {1,2,3,4};\n+  float32_t b1[] = {n,n,n,n};\n+  float32_t e[] = {1,2,3,4};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__quiet_NaN_both_args ()\n+{\n+  /* When given a quiet NaN, vminnmq returns the other operand.\n+     In this test case we have NaNs in both operands.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,2,n,4};\n+  float32_t b1[] = {1,n,3,n};\n+  float32_t e[] = {1,2,3,4};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__zero_both_args ()\n+{\n+  /* For 0 and -0, vminnmq returns -0.  Since 0 == -0, check sign bit.  */\n+  float32_t a1[] = {0.0, 0.0, -0.0, -0.0};\n+  float32_t b1[] = {-0.0, -0.0, 0.0, 0.0};\n+  float32_t e[] = {-0.0, -0.0, -0.0, -0.0};\n+\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+\n+  float32_t actual1[4];\n+  vst1q_f32 (actual1, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual1[i] != e[i] || __builtin_signbit (actual1[i]) == 0)\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__inf_both_args ()\n+{\n+  /* The min of inf and inf is inf.  The min of -inf and -inf is -inf.  */\n+  float32_t inf = __builtin_huge_valf ();\n+  float32_t a1[] = {inf, -inf, inf, inf};\n+  float32_t b1[] = {inf, -inf, -inf, -inf};\n+  float32_t e[] = {inf, -inf, -inf, -inf};\n+\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+\n+  float32_t actual1[4];\n+  vst1q_f32 (actual1, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (actual1[i] != e[i])\n+      abort ();\n+}\n+\n+void __attribute__ ((noinline))\n+test_vminnmq_f32__two_quiet_NaNs_both_args ()\n+{\n+  /* When given 2 NaNs, return a NaN.  Since a NaN is not equal to anything,\n+     not even another NaN, use __builtin_isnan () to check.  */\n+  float32_t n = __builtin_nanf (\"\");\n+  float32_t a1[] = {n,n,n,n};\n+  float32_t b1[] = {n,n,n,n};\n+  float32_t e[] = {n,n};\n+  float32x4_t a = vld1q_f32 (a1);\n+  float32x4_t b = vld1q_f32 (b1);\n+  float32x4_t c = vminnmq_f32 (a, b);\n+  float32_t actual[4];\n+  vst1q_f32 (actual, c);\n+\n+  for (int i = 0; i < 4; ++i)\n+    if (!__builtin_isnan (actual[i]))\n+      abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_vminnmq_f32__regular_input1 ();\n+  test_vminnmq_f32__regular_input2 ();\n+  test_vminnmq_f32__quiet_NaN_one_arg ();\n+  test_vminnmq_f32__quiet_NaN_both_args ();\n+  test_vminnmq_f32__zero_both_args ();\n+  test_vminnmq_f32__inf_both_args ();\n+  test_vminnmq_f32__two_quiet_NaNs_both_args ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vminnm\\.f32\\t\\[qQ\\]\\[0-9\\]+, ?\\[qQ\\]\\[0-9\\]+, ?\\[qQ\\]\\[0-9\\]+\\n\" 7 } } */"}]}