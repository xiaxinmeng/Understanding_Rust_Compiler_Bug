{"sha": "2a8e30fbf34c8364dc0710b374f34038634c90a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE4ZTMwZmJmMzRjODM2NGRjMDcxMGIzNzRmMzQwMzg2MzRjOTBhNg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-02-23T16:41:52Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2010-02-23T16:41:52Z"}, "message": "re PR debug/43077 (VTA issues caused by SSA expand)\n\n\tPR debug/43077\n\t* cfgexpand (expand_debug_expr): Expand TERed ssa names in place.\n\t(expand_gimple_basic_block): Generate and use debug temps if there\n\tare debug uses left after the last real use of TERed ssa names.\n\tUnlink debug immediate uses when they are expanded.\n\ntestsuite/\n\tPR debug/43077\n\t* gcc.dg/guality/pr43077-1.c: New test.\n\nFrom-SVN: r157009", "tree": {"sha": "71c5c9aadb2806f696f8c60fc24dfc8e37a28e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71c5c9aadb2806f696f8c60fc24dfc8e37a28e81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a8e30fbf34c8364dc0710b374f34038634c90a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a8e30fbf34c8364dc0710b374f34038634c90a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a8e30fbf34c8364dc0710b374f34038634c90a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a8e30fbf34c8364dc0710b374f34038634c90a6/comments", "author": null, "committer": null, "parents": [{"sha": "38170f34f370a7e429e39a74401218323dc77eeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38170f34f370a7e429e39a74401218323dc77eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38170f34f370a7e429e39a74401218323dc77eeb"}], "stats": {"total": 200, "additions": 194, "deletions": 6}, "files": [{"sha": "ce7caff698abca1d7a661a86fa5118589d647aa1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a8e30fbf34c8364dc0710b374f34038634c90a6", "patch": "@@ -1,3 +1,11 @@\n+2010-02-23  Michael Matz  <matz@suse.de>\n+\n+\tPR debug/43077\n+\t* cfgexpand (expand_debug_expr): Expand TERed ssa names in place.\n+\t(expand_gimple_basic_block): Generate and use debug temps if there\n+\tare debug uses left after the last real use of TERed ssa names.\n+\tUnlink debug immediate uses when they are expanded.\n+\n 2010-02-23  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 43123"}, {"sha": "d9b5774c006afcc2f5e9659f82bee5de19f05068", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 126, "deletions": 6, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2a8e30fbf34c8364dc0710b374f34038634c90a6", "patch": "@@ -2338,7 +2338,10 @@ expand_debug_expr (tree exp)\n \n \tif (inner_mode == VOIDmode)\n \t  {\n-\t    inner_mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t    if (TREE_CODE (exp) == SSA_NAME)\n+\t      inner_mode = TYPE_MODE (TREE_TYPE (exp));\n+\t    else\n+\t      inner_mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n \t    if (mode == inner_mode)\n \t      return op0;\n \t  }\n@@ -2354,6 +2357,7 @@ expand_debug_expr (tree exp)\n \t  }\n \telse if (FLOAT_MODE_P (mode))\n \t  {\n+\t    gcc_assert (TREE_CODE (exp) != SSA_NAME);\n \t    if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))))\n \t      op0 = simplify_gen_unary (UNSIGNED_FLOAT, mode, op0, inner_mode);\n \t    else\n@@ -2886,14 +2890,24 @@ expand_debug_expr (tree exp)\n \n     case SSA_NAME:\n       {\n-\tint part = var_to_partition (SA.map, exp);\n+\tgimple g = get_gimple_for_ssa_name (exp);\n+\tif (g)\n+\t  {\n+\t    op0 = expand_debug_expr (gimple_assign_rhs_to_tree (g));\n+\t    if (!op0)\n+\t      return NULL;\n+\t  }\n+\telse\n+\t  {\n+\t    int part = var_to_partition (SA.map, exp);\n \n-\tif (part == NO_PARTITION)\n-\t  return NULL;\n+\t    if (part == NO_PARTITION)\n+\t      return NULL;\n \n-\tgcc_assert (part >= 0 && (unsigned)part < SA.map->num_partitions);\n+\t    gcc_assert (part >= 0 && (unsigned)part < SA.map->num_partitions);\n \n-\top0 = SA.partition_to_pseudo[part];\n+\t    op0 = SA.partition_to_pseudo[part];\n+\t  }\n \tgoto adjust_mode;\n       }\n \n@@ -3050,6 +3064,105 @@ expand_gimple_basic_block (basic_block bb)\n       basic_block new_bb;\n \n       stmt = gsi_stmt (gsi);\n+\n+      /* If this statement is a non-debug one, and we generate debug\n+\t insns, then this one might be the last real use of a TERed\n+\t SSA_NAME, but where there are still some debug uses further\n+\t down.  Expanding the current SSA name in such further debug\n+\t uses by their RHS might lead to wrong debug info, as coalescing\n+\t might make the operands of such RHS be placed into the same\n+\t pseudo as something else.  Like so:\n+\t   a_1 = a_0 + 1;   // Assume a_1 is TERed and a_0 is dead\n+\t   use(a_1);\n+\t   a_2 = ...\n+           #DEBUG ... => a_1\n+\t As a_0 and a_2 don't overlap in lifetime, assume they are coalesced.\n+\t If we now would expand a_1 by it's RHS (a_0 + 1) in the debug use,\n+\t the write to a_2 would actually have clobbered the place which\n+\t formerly held a_0.\n+\n+\t So, instead of that, we recognize the situation, and generate\n+\t debug temporaries at the last real use of TERed SSA names:\n+\t   a_1 = a_0 + 1;\n+           #DEBUG #D1 => a_1\n+\t   use(a_1);\n+\t   a_2 = ...\n+           #DEBUG ... => #D1\n+\t */\n+      if (MAY_HAVE_DEBUG_INSNS\n+\t  && SA.values\n+\t  && !is_gimple_debug (stmt))\n+\t{\n+\t  ssa_op_iter iter;\n+\t  tree op;\n+\t  gimple def;\n+\n+\t  location_t sloc = get_curr_insn_source_location ();\n+\t  tree sblock = get_curr_insn_block ();\n+\n+\t  /* Look for SSA names that have their last use here (TERed\n+\t     names always have only one real use).  */\n+\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+\t    if ((def = get_gimple_for_ssa_name (op)))\n+\t      {\n+\t\timm_use_iterator imm_iter;\n+\t\tuse_operand_p use_p;\n+\t\tbool have_debug_uses = false;\n+\n+\t\tFOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)\n+\t\t  {\n+\t\t    if (gimple_debug_bind_p (USE_STMT (use_p)))\n+\t\t      {\n+\t\t\thave_debug_uses = true;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\n+\t\tif (have_debug_uses)\n+\t\t  {\n+\t\t    /* OP is a TERed SSA name, with DEF it's defining\n+\t\t       statement, and where OP is used in further debug\n+\t\t       instructions.  Generate a debug temporary, and\n+\t\t       replace all uses of OP in debug insns with that\n+\t\t       temporary.  */\n+\t\t    gimple debugstmt;\n+\t\t    tree value = gimple_assign_rhs_to_tree (def);\n+\t\t    tree vexpr = make_node (DEBUG_EXPR_DECL);\n+\t\t    rtx val;\n+\t\t    enum machine_mode mode;\n+\n+\t\t    set_curr_insn_source_location (gimple_location (def));\n+\t\t    set_curr_insn_block (gimple_block (def));\n+\n+\t\t    DECL_ARTIFICIAL (vexpr) = 1;\n+\t\t    TREE_TYPE (vexpr) = TREE_TYPE (value);\n+\t\t    if (DECL_P (value))\n+\t\t      mode = DECL_MODE (value);\n+\t\t    else\n+\t\t      mode = TYPE_MODE (TREE_TYPE (value));\n+\t\t    DECL_MODE (vexpr) = mode;\n+\n+\t\t    val = gen_rtx_VAR_LOCATION\n+\t\t\t(mode, vexpr, (rtx)value, VAR_INIT_STATUS_INITIALIZED);\n+\n+\t\t    val = emit_debug_insn (val);\n+\n+\t\t    FOR_EACH_IMM_USE_STMT (debugstmt, imm_iter, op)\n+\t\t      {\n+\t\t\tif (!gimple_debug_bind_p (debugstmt))\n+\t\t\t  continue;\n+\n+\t\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t\t  SET_USE (use_p, vexpr);\n+\n+\t\t\tupdate_stmt (debugstmt);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  set_curr_insn_source_location (sloc);\n+\t  set_curr_insn_block (sblock);\n+\t}\n+\n       currently_expanding_gimple_stmt = stmt;\n \n       /* Expand this statement, then evaluate the resulting RTL and\n@@ -3102,6 +3215,13 @@ expand_gimple_basic_block (basic_block bb)\n \t\t  INSN_VAR_LOCATION_LOC (val) = (rtx)value;\n \t\t}\n \n+\t      /* In order not to generate too many debug temporaries,\n+\t         we delink all uses of debug statements we already expanded.\n+\t\t Therefore debug statements between definition and real\n+\t\t use of TERed SSA names will continue to use the SSA name,\n+\t\t and not be replaced with debug temps.  */\n+\t      delink_stmt_imm_use (stmt);\n+\n \t      gsi = nsi;\n \t      gsi_next (&nsi);\n \t      if (gsi_end_p (nsi))"}, {"sha": "6fe4b8d9836b89dbafd8be3483780ba29f7826fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2a8e30fbf34c8364dc0710b374f34038634c90a6", "patch": "@@ -1,3 +1,8 @@\n+2010-02-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43077\n+\t* gcc.dg/guality/pr43077-1.c: New test.\n+\n 2010-02-23  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 43123"}, {"sha": "d8d5eebe07ffc22476104659f82b165f43e32ed5", "filename": "gcc/testsuite/gcc.dg/guality/pr43077-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43077-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8e30fbf34c8364dc0710b374f34038634c90a6/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43077-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr43077-1.c?ref=2a8e30fbf34c8364dc0710b374f34038634c90a6", "patch": "@@ -0,0 +1,55 @@\n+/* PR debug/43077 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+int varb;\n+\n+int __attribute__((noinline))\n+fn1 (void)\n+{\n+  int vara = (varb == 3);\t\t/* { dg-final { gdb-test 11 \"vara\" \"0\" } } */\n+  asm volatile (\"\" : : \"g\" (vara));\t/* { dg-final { gdb-test 11 \"varb\" \"2\" } } */\n+  return 0;\n+}\n+\n+int __attribute__((noinline))\n+fn2 (void)\n+{\n+  int vara = (varb == 3);\t\t/* { dg-final { gdb-test 19 \"vara\" \"1\" } } */\n+  asm volatile (\"\" : : \"g\" (vara));\t/* { dg-final { gdb-test 19 \"varb\" \"3\" } } */\n+  return 0;\n+}\n+\n+int __attribute__((noinline))\n+foo (unsigned long *p, unsigned long *q)\n+{\n+  int ret;\n+  asm volatile (\"\" : \"=r\" (ret), \"=r\" (*p), \"=r\" (*q) : \"0\" (1), \"1\" (2), \"2\" (3));\n+  return ret;\n+}\n+\n+int __attribute__((noinline))\n+fn3 (void)\n+{\n+  unsigned long a = 0, b = 0, c = 0;\n+  a = foo (&b, &c);\n+\t\t\t\t\t/* { dg-final { gdb-test 42 \"a\" \"1\" } } */\n+\t\t\t\t\t/* { dg-final { gdb-test 42 \"b\" \"2\" } } */\n+\t\t\t\t\t/* { dg-final { gdb-test 42 \"c\" \"3\" } } */\n+  unsigned long vara = a;\t\t/* { dg-final { gdb-test 42 \"vara\" \"1\" } } */\n+  unsigned long varb = b;\t\t/* { dg-final { gdb-test 42 \"varb\" \"2\" } } */\n+  unsigned long varc = c;\t\t/* { dg-final { gdb-test 42 \"varc\" \"3\" } } */\n+  asm volatile (\"\" : : \"g\" (vara), \"g\" (varb), \"g\" (varc));\n+  return a;\n+}\n+\n+int\n+main (void)\n+{\n+  asm volatile (\"\" : \"=r\" (varb) : \"0\" (2));\n+  fn1 ();\n+  asm volatile (\"\" : \"=r\" (varb) : \"0\" (3));\n+  fn2 ();\n+  fn3 ();\n+  return 0;\n+}"}]}