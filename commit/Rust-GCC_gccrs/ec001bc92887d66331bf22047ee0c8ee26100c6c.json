{"sha": "ec001bc92887d66331bf22047ee0c8ee26100c6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMwMDFiYzkyODg3ZDY2MzMxYmYyMjA0N2VlMGM4ZWUyNjEwMGM2Yw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2008-08-13T20:08:55Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-08-13T20:08:55Z"}, "message": "2008-08-13  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tRevert the last patch.\n\nFrom-SVN: r139074", "tree": {"sha": "19b97d8b8ea92120d16460bdab99577fb6df7297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19b97d8b8ea92120d16460bdab99577fb6df7297"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec001bc92887d66331bf22047ee0c8ee26100c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec001bc92887d66331bf22047ee0c8ee26100c6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec001bc92887d66331bf22047ee0c8ee26100c6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec001bc92887d66331bf22047ee0c8ee26100c6c/comments", "author": null, "committer": null, "parents": [{"sha": "7aec7a38d7283e5eb83db7f0dc9556202214c5f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aec7a38d7283e5eb83db7f0dc9556202214c5f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aec7a38d7283e5eb83db7f0dc9556202214c5f0"}], "stats": {"total": 1125, "additions": 47, "deletions": 1078}, "files": [{"sha": "2edf9f9d2eab718b11bddd0211049d22c63f45be", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,3 +1,7 @@\n+2008-08-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tRevert the last patch.\n+\n 2008-08-13  Sebastian Redl <sebastian.redl@getdesigned.at>\n \n \tAdd exception propagation support as per N2179."}, {"sha": "7b31a1cfa472755fa649ce7dc953cbbc43559853", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -66,9 +66,7 @@ GLIBCXX_3.4 {\n #     std::condition_variable;\n       std::co[^n]*;\n       std::c[p-s]*;\n-      std::cu[^r]*;\n-#     std::current_exception\n-      std::c[v-z]*;\n+      std::c[u-z]*;\n #     std::[d-g]*;\n       std::d[a-d]*;\n       std::d[f-z]*;\n@@ -114,13 +112,10 @@ GLIBCXX_3.4 {\n       std::n[^au]*;\n       std::nu[^m]*;\n       std::num[^e]*;\n+      std::[p-r]*;\n       std::ostrstream*;\n       std::out_of_range*;\n       std::overflow_error*;\n-      std::[p-q]*;\n-      std::r[^e]*;\n-      std::re[^t]*;\n-#     std::rethrow_exception\n       std::set_new_handler*;\n       std::set_terminate*;\n       std::set_unexpected*;\n@@ -1052,24 +1047,4 @@ CXXABI_1.3.3 {\n     _ZTIPu8char32_t;\n     _ZTIPKu8char32_t;\n \n-    # exception_ptr\n-    _ZNSt15__exception_ptr13exception_ptrC1Ev;\n-    _ZNSt15__exception_ptr13exception_ptrC2Ev;\n-    _ZNSt15__exception_ptr13exception_ptrC1ERKS0_;\n-    _ZNSt15__exception_ptr13exception_ptrC2ERKS0_;\n-    _ZNSt15__exception_ptr13exception_ptrC1EMS0_FvvE;\n-    _ZNSt15__exception_ptr13exception_ptrC2EMS0_FvvE;\n-    _ZNSt15__exception_ptr13exception_ptrD1Ev;\n-    _ZNSt15__exception_ptr13exception_ptrD2Ev;\n-    _ZNSt15__exception_ptr13exception_ptraSERKS0_;\n-    _ZNKSt15__exception_ptr13exception_ptrcvMS0_FvvEEv;\n-    _ZNKSt15__exception_ptr13exception_ptrntEv;\n-    _ZNKSt15__exception_ptr13exception_ptr20__cxa_exception_typeEv;\n-    _ZNSt15__exception_ptr13exception_ptr4swapERS0_;\n-    _ZNSt15__exception_ptreqERKNS_13exception_ptrES2_;\n-    _ZNSt15__exception_ptrneERKNS_13exception_ptrES2_;\n-\n-    _ZSt17current_exceptionv;\n-    _ZSt17rethrow_exceptionNSt15__exception_ptr13exception_ptrE;\n-\n } CXXABI_1.3.2;"}, {"sha": "c0412f0b8ed549c96eb87956055d7e42bd7e4747", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -34,7 +34,7 @@ noinst_LTLIBRARIES = libsupc++convenience.la\n \n headers = \\\n \texception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h \\\n-\tinitializer_list exception_ptr.h\n+\tinitializer_list\n \n if GLIBCXX_HOSTED\n   c_sources = \\\n@@ -60,7 +60,6 @@ sources = \\\n \teh_exception.cc \\\n \teh_globals.cc \\\n \teh_personality.cc \\\n-\teh_ptr.cc \\\n \teh_term_handler.cc \\\n \teh_terminate.cc \\\n \teh_throw.cc \\"}, {"sha": "105aec63d8dd419a9fd8d3669ae1362dd787ed66", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -79,7 +79,7 @@ am__libsupc___la_SOURCES_DIST = array_type_info.cc atexit_arm.cc \\\n \tbad_cast.cc bad_typeid.cc class_type_info.cc del_op.cc \\\n \tdel_opnt.cc del_opv.cc del_opvnt.cc dyncast.cc eh_alloc.cc \\\n \teh_arm.cc eh_aux_runtime.cc eh_call.cc eh_catch.cc \\\n-\teh_exception.cc eh_globals.cc eh_personality.cc eh_ptr.cc \\\n+\teh_exception.cc eh_globals.cc eh_personality.cc \\\n \teh_term_handler.cc eh_terminate.cc eh_throw.cc eh_type.cc \\\n \teh_unex_handler.cc enum_type_info.cc function_type_info.cc \\\n \tfundamental_type_info.cc guard.cc new_handler.cc new_op.cc \\\n@@ -91,7 +91,7 @@ am__objects_1 = array_type_info.lo atexit_arm.lo bad_cast.lo \\\n \tbad_typeid.lo class_type_info.lo del_op.lo del_opnt.lo \\\n \tdel_opv.lo del_opvnt.lo dyncast.lo eh_alloc.lo eh_arm.lo \\\n \teh_aux_runtime.lo eh_call.lo eh_catch.lo eh_exception.lo \\\n-\teh_globals.lo eh_personality.lo eh_ptr.lo eh_term_handler.lo \\\n+\teh_globals.lo eh_personality.lo eh_term_handler.lo \\\n \teh_terminate.lo eh_throw.lo eh_type.lo eh_unex_handler.lo \\\n \tenum_type_info.lo function_type_info.lo \\\n \tfundamental_type_info.lo guard.lo new_handler.lo new_op.lo \\\n@@ -107,7 +107,7 @@ am__libsupc__convenience_la_SOURCES_DIST = array_type_info.cc \\\n \tatexit_arm.cc bad_cast.cc bad_typeid.cc class_type_info.cc \\\n \tdel_op.cc del_opnt.cc del_opv.cc del_opvnt.cc dyncast.cc \\\n \teh_alloc.cc eh_arm.cc eh_aux_runtime.cc eh_call.cc eh_catch.cc \\\n-\teh_exception.cc eh_globals.cc eh_personality.cc eh_ptr.cc \\\n+\teh_exception.cc eh_globals.cc eh_personality.cc \\\n \teh_term_handler.cc eh_terminate.cc eh_throw.cc eh_type.cc \\\n \teh_unex_handler.cc enum_type_info.cc function_type_info.cc \\\n \tfundamental_type_info.cc guard.cc new_handler.cc new_op.cc \\\n@@ -356,7 +356,7 @@ toolexeclib_LTLIBRARIES = libsupc++.la\n noinst_LTLIBRARIES = libsupc++convenience.la\n headers = \\\n \texception new typeinfo cxxabi.h cxxabi-forced.h exception_defines.h \\\n-\tinitializer_list exception_ptr.h\n+\tinitializer_list\n \n @GLIBCXX_HOSTED_TRUE@c_sources = \\\n @GLIBCXX_HOSTED_TRUE@\tcp-demangle.c \n@@ -380,7 +380,6 @@ sources = \\\n \teh_exception.cc \\\n \teh_globals.cc \\\n \teh_personality.cc \\\n-\teh_ptr.cc \\\n \teh_term_handler.cc \\\n \teh_terminate.cc \\\n \teh_throw.cc \\"}, {"sha": "553c1c1e8580bbc86b0c3e30024ea1f610c3503a", "filename": "libstdc++-v3/libsupc++/eh_alloc.cc", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,5 +1,5 @@\n // -*- C++ -*- Allocate exception objects.\n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2008\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n // Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n@@ -89,9 +89,6 @@ typedef char one_buffer[EMERGENCY_OBJ_SIZE] __attribute__((aligned));\n static one_buffer emergency_buffer[EMERGENCY_OBJ_COUNT];\n static bitmask_type emergency_used;\n \n-static __cxa_dependent_exception dependents_buffer[EMERGENCY_OBJ_COUNT];\n-static bitmask_type dependents_used;\n-\n namespace\n {\n   // A single mutex controlling emergency allocations.\n@@ -160,66 +157,3 @@ __cxxabiv1::__cxa_free_exception(void *vptr) throw()\n   else\n     free (ptr - sizeof (__cxa_exception));\n }\n-\n-\n-extern \"C\" __cxa_dependent_exception*\n-__cxxabiv1::__cxa_allocate_dependent_exception() throw()\n-{\n-  __cxa_dependent_exception *ret;\n-\n-  ret = static_cast<__cxa_dependent_exception*>\n-    (malloc (sizeof (__cxa_dependent_exception)));\n-\n-  if (!ret)\n-    {\n-      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n-\n-      bitmask_type used = dependents_used;\n-      unsigned int which = 0;\n-\n-      while (used & 1)\n-\t{\n-\t  used >>= 1;\n-\t  if (++which >= EMERGENCY_OBJ_COUNT)\n-\t    goto failed;\n-\t}\n-\n-      dependents_used |= (bitmask_type)1 << which;\n-      ret = &dependents_buffer[which];\n-\n-    failed:;\n-\n-      if (!ret)\n-\tstd::terminate ();\n-    }\n-\n-  // We have an uncaught exception as soon as we allocate memory.  This\n-  // yields uncaught_exception() true during the copy-constructor that\n-  // initializes the exception object.  See Issue 475.\n-  __cxa_eh_globals *globals = __cxa_get_globals ();\n-  globals->uncaughtExceptions += 1;\n-\n-  memset (ret, 0, sizeof (__cxa_dependent_exception));\n-\n-  return ret;\n-}\n-\n-\n-extern \"C\" void\n-__cxxabiv1::__cxa_free_dependent_exception\n-  (__cxa_dependent_exception *vptr) throw()\n-{\n-  char *base = (char *) dependents_buffer;\n-  char *ptr = (char *) vptr;\n-  if (ptr >= base\n-      && ptr < base + sizeof (dependents_buffer))\n-    {\n-      const unsigned int which\n-\t= (unsigned) (ptr - base) / sizeof (__cxa_dependent_exception);\n-\n-      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n-      dependents_used &= ~((bitmask_type)1 << which);\n-    }\n-  else\n-    free (vptr);\n-}"}, {"sha": "6f770e95663ca4bc5f8e38f5fde98bb078dbfb21", "filename": "libstdc++-v3/libsupc++/eh_arm.cc", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,5 +1,5 @@\n // -*- C++ -*- ARM specific Exception handling support routines.\n-// Copyright (C) 2004, 2005, 2008 Free Software Foundation, Inc.\n+// Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -48,19 +48,13 @@ __cxa_type_match(_Unwind_Exception* ue_header,\n {\n   bool forced_unwind = __is_gxx_forced_unwind_class(ue_header->exception_class);\n   bool foreign_exception = !forced_unwind && !__is_gxx_exception_class(ue_header->exception_class);\n-  bool dependent_exception =\n-    __is_dependent_exception(ue_header->exception_class);\n   __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n-  __cxa_dependent_exception *dx = __get_dependent_exception_from_ue(ue_header);\n   const std::type_info* throw_type;\n \n   if (forced_unwind)\n     throw_type = &typeid(abi::__forced_unwind);\n   else if (foreign_exception)\n     throw_type = &typeid(abi::__foreign_exception);\n-  else if (dependent_exception)\n-    throw_type = __get_exception_header_from_obj\n-      (dx->primaryException)->exceptionType;\n   else\n     throw_type = xh->exceptionType;\n "}, {"sha": "edf62188a6b6d5cc547f3ee80323fe6a4cd79920", "filename": "libstdc++-v3/libsupc++/eh_call.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_call.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,5 +1,5 @@\n // -*- C++ -*- Helpers for calling unextected and terminate\n-// Copyright (C) 2001, 2002, 2003, 2008 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -125,7 +125,7 @@ __cxa_call_unexpected(void* exc_obj_in)\n \n       __cxa_eh_globals* globals = __cxa_get_globals_fast();\n       __cxa_exception* new_xh = globals->caughtExceptions;\n-      void* new_ptr = __gxx_get_object_from_ambiguous_exception (new_xh);\n+      void* new_ptr = new_xh + 1;\n       const std::type_info* catch_type;\n       int n;\n       bool bad_exception_allowed = false;"}, {"sha": "b7d957c4d3766101539cad58bc151dc2c5e22844", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -377,7 +377,7 @@ PERSONALITY_FUNCTION (int version,\n   const unsigned char *p;\n   _Unwind_Ptr landing_pad, ip;\n   int handler_switch_value;\n-  void* thrown_ptr = 0;\n+  void* thrown_ptr = ue_header + 1;\n   bool foreign_exception;\n   int ip_before_insn = 0;\n \n@@ -543,33 +543,30 @@ PERSONALITY_FUNCTION (int version,\n       bool saw_handler = false;\n \n #ifdef __ARM_EABI_UNWINDER__\n-      // ??? How does this work - more importantly, how does it interact with\n-      // dependent exceptions?\n       throw_type = ue_header;\n       if (actions & _UA_FORCE_UNWIND)\n \t{\n \t  __GXX_INIT_FORCED_UNWIND_CLASS(ue_header->exception_class);\n+\t  thrown_ptr = 0;\n \t}\n-      else if (!foreign_exception)\n-\tthrown_ptr = __get_object_from_ue (ue_header);\n+      else if (foreign_exception)\n+\tthrown_ptr = 0;\n #else\n       // During forced unwinding, match a magic exception type.\n       if (actions & _UA_FORCE_UNWIND)\n \t{\n \t  throw_type = &typeid(abi::__forced_unwind);\n+\t  thrown_ptr = 0;\n \t}\n       // With a foreign exception class, there's no exception type.\n       // ??? What to do about GNU Java and GNU Ada exceptions?\n       else if (foreign_exception)\n \t{\n \t  throw_type = &typeid(abi::__foreign_exception);\n+\t  thrown_ptr = 0;\n \t}\n       else\n-        {\n-          thrown_ptr = __get_object_from_ue (ue_header);\n-          throw_type = __get_exception_header_from_obj\n-            (thrown_ptr)->exceptionType;\n-        }\n+\tthrow_type = xh->exceptionType;\n #endif\n \n       while (1)\n@@ -761,14 +758,13 @@ __cxa_call_unexpected (void *exc_obj_in)\n \n       __cxa_eh_globals *globals = __cxa_get_globals_fast ();\n       __cxa_exception *new_xh = globals->caughtExceptions;\n-      void *new_ptr = __get_object_from_ambiguous_exception (new_xh);\n+      void *new_ptr = new_xh + 1;\n \n       // We don't quite have enough stuff cached; re-parse the LSDA.\n       parse_lsda_header (0, xh_lsda, &info);\n \n       // If this new exception meets the exception spec, allow it.\n-      if (check_exception_spec (&info, __get_exception_header_from_obj\n-                                  (new_ptr)->exceptionType,\n+      if (check_exception_spec (&info, new_xh->exceptionType,\n \t\t\t\tnew_ptr, xh_switch_value))\n \t__throw_exception_again;\n "}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/libsupc++/eh_ptr.cc", "status": "modified", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_ptr.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,236 +0,0 @@\n-// -*- C++ -*- Implement the members of exception_ptr.\n-// Copyright (C) 2008 Free Software Foundation, Inc.\n-//\n-// This file is part of GCC.\n-//\n-// GCC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-//\n-// GCC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-//\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-// Boston, MA 02110-1301, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-#include <bits/c++config.h>\n-#include <exception>\n-#include <exception_ptr.h>\n-#include \"unwind-cxx.h\"\n-\n-using namespace __cxxabiv1;\n-\n-\n-std::__exception_ptr::exception_ptr::exception_ptr() throw()\n-  : _M_exception_object(0)\n-{\n-}\n-\n-\n-std::__exception_ptr::exception_ptr::exception_ptr(void* obj) throw()\n-  : _M_exception_object(obj)\n-{\n-  _M_addref();\n-}\n-\n-\n-std::__exception_ptr::exception_ptr::exception_ptr(__safe_bool) throw()\n-  : _M_exception_object(0)\n-{\n-}\n-\n-\n-std::__exception_ptr::exception_ptr::exception_ptr(\n-                        const exception_ptr& other) throw()\n-  : _M_exception_object(other._M_exception_object)\n-{\n-  _M_addref();\n-}\n-\n-\n-std::__exception_ptr::exception_ptr::~exception_ptr() throw()\n-{\n-  _M_release();\n-}\n-\n-\n-std::__exception_ptr::exception_ptr&\n-std::__exception_ptr::exception_ptr::operator=(\n-                    const exception_ptr& other) throw()\n-{\n-  exception_ptr(other).swap(*this);\n-  return *this;\n-}\n-\n-\n-void\n-std::__exception_ptr::exception_ptr::_M_addref() throw()\n-{\n-  if (_M_exception_object)\n-    {\n-      __cxa_exception *eh =\n-        __get_exception_header_from_obj (_M_exception_object);\n-      __sync_add_and_fetch (&eh->referenceCount, 1);\n-    }\n-}\n-\n-\n-void\n-std::__exception_ptr::exception_ptr::_M_release() throw()\n-{\n-  if (_M_exception_object)\n-    {\n-      __cxa_exception *eh =\n-        __get_exception_header_from_obj (_M_exception_object);\n-      if (__sync_sub_and_fetch (&eh->referenceCount, 1) == 0)\n-        {\n-          if (eh->exceptionDestructor)\n-            eh->exceptionDestructor (_M_exception_object);\n-\n-          __cxa_free_exception (_M_exception_object);\n-          _M_exception_object = 0;\n-        }\n-    }\n-}\n-\n-\n-void*\n-std::__exception_ptr::exception_ptr::_M_get() const throw()\n-{\n-  return _M_exception_object;\n-}\n-\n-\n-void\n-std::__exception_ptr::exception_ptr::_M_safe_bool_dummy()\n-{\n-}\n-\n-\n-void\n-std::__exception_ptr::exception_ptr::swap(exception_ptr &other) throw()\n-{\n-  void *tmp = _M_exception_object;\n-  _M_exception_object = other._M_exception_object;\n-  other._M_exception_object = tmp;\n-}\n-\n-\n-bool\n-std::__exception_ptr::exception_ptr::operator!() const throw()\n-{\n-  return _M_exception_object == 0;\n-}\n-\n-\n-std::__exception_ptr::exception_ptr::operator __safe_bool() const throw()\n-{\n-  return _M_exception_object ? &exception_ptr::_M_safe_bool_dummy : 0;\n-}\n-\n-\n-const std::type_info*\n-std::__exception_ptr::exception_ptr::__cxa_exception_type() const throw()\n-{\n-  __cxa_exception *eh = __get_exception_header_from_obj (_M_exception_object);\n-  return eh->exceptionType;\n-}\n-\n-\n-bool std::__exception_ptr::operator==(const exception_ptr& lhs,\n-                                      const exception_ptr& rhs) throw()\n-{\n-  return lhs._M_exception_object == rhs._M_exception_object;\n-}\n-\n-\n-bool std::__exception_ptr::operator!=(const exception_ptr& lhs,\n-                                      const exception_ptr& rhs) throw()\n-{\n-  return !(lhs == rhs);\n-}\n-\n-\n-std::exception_ptr\n-std::current_exception() throw()\n-{\n-  __cxa_eh_globals *globals = __cxa_get_globals ();\n-  __cxa_exception *header = globals->caughtExceptions;\n-\n-  if (!header)\n-    return std::exception_ptr();\n-\n-  // Since foreign exceptions can't be counted, we can't return them.\n-  if (!__is_gxx_exception_class (header->unwindHeader.exception_class))\n-    return std::exception_ptr();\n-\n-  return std::exception_ptr(\n-    __get_object_from_ambiguous_exception (header));\n-}\n-\n-\n-static void\n-__gxx_dependent_exception_cleanup (_Unwind_Reason_Code code,\n-                                   _Unwind_Exception *exc)\n-{\n-  // This cleanup is set only for dependents.\n-  __cxa_dependent_exception *dep = __get_dependent_exception_from_ue (exc);\n-  __cxa_exception *header =\n-    __get_exception_header_from_obj (dep->primaryException);\n-\n-  // We only want to be called through _Unwind_DeleteException.\n-  // _Unwind_DeleteException in the HP-UX IA64 libunwind library\n-  // returns _URC_NO_REASON and not _URC_FOREIGN_EXCEPTION_CAUGHT\n-  // like the GCC _Unwind_DeleteException function does.\n-  if (code != _URC_FOREIGN_EXCEPTION_CAUGHT && code != _URC_NO_REASON)\n-    __terminate (header->terminateHandler);\n-\n-  if (__sync_sub_and_fetch (&header->referenceCount, 1) == 0)\n-    {\n-      if (header->exceptionDestructor)\n-        header->exceptionDestructor (header + 1);\n-\n-      __cxa_free_exception (header + 1);\n-    }\n-}\n-\n-\n-void\n-std::rethrow_exception(std::exception_ptr ep)\n-{\n-  void *obj = ep._M_get();\n-  __cxa_exception *eh = __get_exception_header_from_obj (obj);\n-\n-  __cxa_dependent_exception *dep = __cxa_allocate_dependent_exception ();\n-  dep->primaryException = obj;\n-  __sync_add_and_fetch (&eh->referenceCount, 1);\n-\n-  dep->unexpectedHandler = __unexpected_handler;\n-  dep->terminateHandler = __terminate_handler;\n-  __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(dep->unwindHeader.exception_class);\n-  dep->unwindHeader.exception_cleanup = __gxx_dependent_exception_cleanup;\n-\n-#ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n-  _Unwind_SjLj_RaiseException (&dep->unwindHeader);\n-#else\n-  _Unwind_RaiseException (&dep->unwindHeader);\n-#endif\n-\n-  // Some sort of unwinding error.  Note that terminate is a handler.\n-  __cxa_begin_catch (&dep->unwindHeader);\n-  std::terminate ();\n-}"}, {"sha": "b405f8f7c64188c167227bb85d8d7a7d1fc866a4", "filename": "libstdc++-v3/libsupc++/eh_throw.cc", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,5 +1,5 @@\n // -*- C++ -*- Exception handling routines for throwing.\n-// Copyright (C) 2001, 2003, 2008 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -36,38 +36,33 @@ using namespace __cxxabiv1;\n static void\n __gxx_exception_cleanup (_Unwind_Reason_Code code, _Unwind_Exception *exc)\n {\n-  // This cleanup is set only for primaries.\n   __cxa_exception *header = __get_exception_header_from_ue (exc);\n \n-  // We only want to be called through _Unwind_DeleteException.\n+  // If we haven't been caught by a foreign handler, then this is\n+  // some sort of unwind error.  In that case just die immediately.\n   // _Unwind_DeleteException in the HP-UX IA64 libunwind library\n-  // returns _URC_NO_REASON and not _URC_FOREIGN_EXCEPTION_CAUGHT\n+  //  returns _URC_NO_REASON and not _URC_FOREIGN_EXCEPTION_CAUGHT\n   // like the GCC _Unwind_DeleteException function does.\n   if (code != _URC_FOREIGN_EXCEPTION_CAUGHT && code != _URC_NO_REASON)\n     __terminate (header->terminateHandler);\n \n-  if (__sync_sub_and_fetch (&header->referenceCount, 1) == 0)\n-    {\n-      if (header->exceptionDestructor)\n-        header->exceptionDestructor (header + 1);\n+  if (header->exceptionDestructor)\n+    header->exceptionDestructor (header + 1);\n \n-      __cxa_free_exception (header + 1);\n-    }\n+  __cxa_free_exception (header + 1);\n }\n \n \n extern \"C\" void\n __cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo, \n \t\t\t void (*dest) (void *))\n {\n-  // Definitely a primary.\n   __cxa_exception *header = __get_exception_header_from_obj (obj);\n-  header->referenceCount = 1;\n   header->exceptionType = tinfo;\n   header->exceptionDestructor = dest;\n   header->unexpectedHandler = __unexpected_handler;\n   header->terminateHandler = __terminate_handler;\n-  __GXX_INIT_PRIMARY_EXCEPTION_CLASS(header->unwindHeader.exception_class);\n+  __GXX_INIT_EXCEPTION_CLASS(header->unwindHeader.exception_class);\n   header->unwindHeader.exception_cleanup = __gxx_exception_cleanup;\n \n #ifdef _GLIBCXX_SJLJ_EXCEPTIONS"}, {"sha": "99627efdd9768362d14cd326b0a835f6e4a73e9a", "filename": "libstdc++-v3/libsupc++/eh_type.cc", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_type.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,5 +1,5 @@\n // -*- C++ -*- Exception handling routines for catching.\n-// Copyright (C) 2001, 2008 Free Software Foundation, Inc.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -43,15 +43,7 @@ std::type_info *__cxa_current_exception_type ()\n   __cxa_eh_globals *globals = __cxa_get_globals ();\n   __cxa_exception *header = globals->caughtExceptions;\n   if (header)\n-    {\n-      if (__is_dependent_exception (header->unwindHeader.exception_class))\n-        {\n-          __cxa_dependent_exception *de =\n-            __get_dependent_exception_from_ue (&header->unwindHeader);\n-          header = __get_exception_header_from_obj (de->primaryException);\n-        }\n-      return header->exceptionType;\n-    }\n+    return header->exceptionType;\n   else\n     return 0;\n }"}, {"sha": "a7e2db78dd19776a52f51f1cf396d1e908349abc", "filename": "libstdc++-v3/libsupc++/exception", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,7 +1,7 @@\n // Exception Handling support header for -*- C++ -*-\n \n // Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n-// 2004, 2005, 2006, 2007, 2008\n+// 2004, 2005, 2006, 2007\n // Free Software Foundation\n //\n // This file is part of GCC.\n@@ -110,7 +110,6 @@ namespace std\n    *  result in a call of @c terminate() (15.5.1).\"\n    */\n   bool uncaught_exception() throw();\n-\n } // namespace std\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n@@ -133,8 +132,4 @@ _GLIBCXX_END_NAMESPACE\n \n #pragma GCC visibility pop\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#include <exception_ptr.h>\n-#endif\n-\n #endif"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/libsupc++/exception_ptr.h", "status": "modified", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fexception_ptr.h?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,169 +0,0 @@\n-// Exception Handling support header (exception_ptr class) for -*- C++ -*-\n-\n-// Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n-// 2004, 2005, 2006, 2007, 2008\n-// Free Software Foundation\n-//\n-// This file is part of GCC.\n-//\n-// GCC is free software; you can redistribute it and/or modify\n-// it under the terms of the GNU General Public License as published by\n-// the Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-// \n-// GCC is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-// \n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING.  If not, write to\n-// the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-// Boston, MA 02110-1301, USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file exception_ptr.h\n- *  This is an internal header file, included by other headers and the\n- *  implementation. You should not attempt to use it directly.\n- */\n-\n-#ifndef __EXCEPTION_PTR_H__\n-#define __EXCEPTION_PTR_H__\n-\n-#pragma GCC visibility push(default)\n-\n-#include <bits/c++config.h>\n-\n-extern \"C++\" {\n-\n-namespace std \n-{\n-  // Hide the free operators from other types\n-  namespace __exception_ptr\n-  {\n-    /**\n-     * @brief An opaque pointer to an arbitrary exception.\n-     */\n-    class exception_ptr;\n-  }\n-\n-  using __exception_ptr::exception_ptr;\n-\n-  /** Obtain an %exception_ptr to the currently handled exception. If there\n-   *  is none, or the currently handled exception is foreign, return the null\n-   *  value.\n-   */\n-  exception_ptr current_exception() throw();\n-\n-  /// Throw the object pointed to by the %exception_ptr.\n-  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));\n-\n-  /// Obtain an %exception_ptr pointing to a copy of the supplied object.\n-  template <class _Ex>\n-  exception_ptr copy_exception(_Ex __ex) throw();\n-\n-\n-  namespace __exception_ptr\n-  {\n-    bool operator==(const exception_ptr&,\n-                    const exception_ptr&) throw();\n-    bool operator!=(const exception_ptr&,\n-                    const exception_ptr&) throw();\n-\n-    class exception_ptr\n-    {\n-      void* _M_exception_object;\n-\n-      explicit exception_ptr(void* __e) throw();\n-\n-      void _M_addref() throw();\n-      void _M_release() throw();\n-\n-      void *_M_get() const throw();\n-\n-      void _M_safe_bool_dummy();\n-\n-      friend exception_ptr std::current_exception() throw();\n-      friend void std::rethrow_exception(exception_ptr);\n-\n-    public:\n-      exception_ptr() throw();\n-\n-      typedef void (exception_ptr::*__safe_bool)();\n-\n-      // For construction from nullptr or 0.\n-      exception_ptr(__safe_bool) throw();\n-\n-      exception_ptr(const exception_ptr&) throw();\n-\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      exception_ptr(exception_ptr&& __o) throw()\n-        : _M_exception_object(__o._M_exception_object)\n-      {\n-        __o._M_exception_object = 0;\n-      }\n-#endif\n-\n-      exception_ptr& operator=(const exception_ptr&) throw();\n-\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      exception_ptr& operator=(exception_ptr&& __o) throw()\n-      {\n-        exception_ptr(__o).swap(*this);\n-        return *this;\n-      }\n-#endif\n-\n-      ~exception_ptr() throw();\n-\n-      void swap(exception_ptr&) throw();\n-\n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      void swap(exception_ptr &&__o) throw()\n-      {\n-        void *__tmp = _M_exception_object;\n-        _M_exception_object = __o._M_exception_object;\n-        __o._M_exception_object = __tmp;\n-      }\n-#endif\n-\n-      bool operator!() const throw();\n-      operator __safe_bool() const throw();\n-\n-      friend bool operator==(const exception_ptr&,\n-                             const exception_ptr&) throw();\n-\n-      const type_info *__cxa_exception_type() const throw();\n-    };\n-\n-  } // namespace __exception_ptr\n-\n-\n-  template <class _Ex>\n-  exception_ptr copy_exception(_Ex __ex) throw()\n-  {\n-    try\n-      {\n-        throw __ex;\n-      }\n-    catch(...)\n-      {\n-        return current_exception ();\n-      }\n-  }\n-\n-} // namespace std\n-\n-} // extern \"C++\"\n-\n-#pragma GCC visibility pop\n-\n-#endif"}, {"sha": "75874fc5da41902c5f6d5e519b15b4d82940a126", "filename": "libstdc++-v3/libsupc++/unwind-cxx.h", "status": "modified", "additions": 12, "deletions": 130, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,5 +1,5 @@\n // -*- C++ -*- Exception handling and frame unwind runtime interface routines.\n-// Copyright (C) 2001, 2008 Free Software Foundation, Inc.\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n //\n // This file is part of GCC.\n //\n@@ -45,15 +45,12 @@\n namespace __cxxabiv1\n {\n \n-// A primary C++ exception object consists of a header, which is a wrapper\n-// around an unwind object header with additional C++ specific information,\n+// A C++ exception object consists of a header, which is a wrapper around\n+// an unwind object header with additional C++ specific information,\n // followed by the exception object itself.\n \n struct __cxa_exception\n-{\n-  // Manage this header.\n-  std::size_t referenceCount;\n-\n+{ \n   // Manage the exception object itself.\n   std::type_info *exceptionType;\n   void (*exceptionDestructor)(void *); \n@@ -90,47 +87,6 @@ struct __cxa_exception\n   _Unwind_Exception unwindHeader;\n };\n \n-// A dependent C++ exception object consists of a wrapper around an unwind\n-// object header with additional C++ specific information, containing a pointer\n-// to a primary exception object.\n-\n-struct __cxa_dependent_exception\n-{\n-  // The primary exception this thing depends on.\n-  void *primaryException;\n-\n-  // The C++ standard has entertaining rules wrt calling set_terminate\n-  // and set_unexpected in the middle of the exception cleanup process.\n-  std::unexpected_handler unexpectedHandler;\n-  std::terminate_handler terminateHandler;\n-\n-  // The caught exception stack threads through here.\n-  __cxa_exception *nextException;\n-\n-  // How many nested handlers have caught this exception.  A negated\n-  // value is a signal that this object has been rethrown.\n-  int handlerCount;\n-\n-#ifdef __ARM_EABI_UNWINDER__\n-  // Stack of exceptions in cleanups.\n-  __cxa_exception* nextPropagatingException;\n-\n-  // The nuber of active cleanup handlers for this exception.\n-  int propagationCount;\n-#else\n-  // Cache parsed handler data from the personality routine Phase 1\n-  // for Phase 2 and __cxa_call_unexpected.\n-  int handlerSwitchValue;\n-  const unsigned char *actionRecord;\n-  const unsigned char *languageSpecificData;\n-  _Unwind_Ptr catchTemp;\n-  void *adjustedPtr;\n-#endif\n-\n-  // The generic exception header.  Must be last.\n-  _Unwind_Exception unwindHeader;\n-};\n-\n // Each thread in a C++ program has access to a __cxa_eh_globals object.\n struct __cxa_eh_globals\n {\n@@ -149,20 +105,12 @@ struct __cxa_eh_globals\n extern \"C\" __cxa_eh_globals *__cxa_get_globals () throw();\n extern \"C\" __cxa_eh_globals *__cxa_get_globals_fast () throw();\n \n-// Allocate memory for the primary exception plus the thrown object.\n+// Allocate memory for the exception plus the thown object.\n extern \"C\" void *__cxa_allocate_exception(std::size_t thrown_size) throw();\n \n-// Free the space allocated for the primary exception.\n+// Free the space allocated for the exception.\n extern \"C\" void __cxa_free_exception(void *thrown_exception) throw();\n \n-// Allocate memory for a dependent exception.\n-extern \"C\" __cxa_dependent_exception*\n-__cxa_allocate_dependent_exception() throw();\n-\n-// Free the space allocated for the dependent exception.\n-extern \"C\" void\n-__cxa_free_dependent_exception(__cxa_dependent_exception *ex) throw();\n-\n // Throw the exception.\n extern \"C\" void __cxa_throw (void *thrown_exception,\n \t\t\t     std::type_info *tinfo,\n@@ -225,12 +173,6 @@ __get_exception_header_from_ue (_Unwind_Exception *exc)\n   return reinterpret_cast<__cxa_exception *>(exc + 1) - 1;\n }\n \n-static inline __cxa_dependent_exception *\n-__get_dependent_exception_from_ue (_Unwind_Exception *exc)\n-{\n-  return reinterpret_cast<__cxa_dependent_exception *>(exc + 1) - 1;\n-}\n-\n #ifdef __ARM_EABI_UNWINDER__\n static inline bool\n __is_gxx_exception_class(_Unwind_Exception_Class c)\n@@ -243,19 +185,11 @@ __is_gxx_exception_class(_Unwind_Exception_Class c)\n \t && c[4] == 'C'\n \t && c[5] == '+'\n \t && c[6] == '+'\n-\t && (c[7] == '\\0' || c[7] == '\\x01');\n-}\n-\n-// Only checks for primary or dependent, but not that it is a C++ exception at\n-// all.\n-static inline bool\n-__is_dependent_exception(_Unwind_Exception_Class c)\n-{\n-  return c[7] == '\\x01';\n+\t && c[7] == '\\0';\n }\n \n static inline void\n-__GXX_INIT_PRIMARY_EXCEPTION_CLASS(_Unwind_Exception_Class c)\n+__GXX_INIT_EXCEPTION_CLASS(_Unwind_Exception_Class c)\n {\n   c[0] = 'G';\n   c[1] = 'N';\n@@ -267,19 +201,6 @@ __GXX_INIT_PRIMARY_EXCEPTION_CLASS(_Unwind_Exception_Class c)\n   c[7] = '\\0';\n }\n \n-static inline void\n-__GXX_INIT_DEPENDENT_EXCEPTION_CLASS(_Unwind_Exception_Class c)\n-{\n-  c[0] = 'G';\n-  c[1] = 'N';\n-  c[2] = 'U';\n-  c[3] = 'C';\n-  c[4] = 'C';\n-  c[5] = '+';\n-  c[6] = '+';\n-  c[7] = '\\x01';\n-}\n-\n static inline bool\n __is_gxx_forced_unwind_class(_Unwind_Exception_Class c)\n {\n@@ -312,8 +233,8 @@ __gxx_caught_object(_Unwind_Exception* eo)\n   return (void*)eo->barrier_cache.bitpattern[0];\n }\n #else // !__ARM_EABI_UNWINDER__\n-// This is the primary exception class we report -- \"GNUCC++\\0\".\n-const _Unwind_Exception_Class __gxx_primary_exception_class\n+// This is the exception class we report -- \"GNUCC++\\0\".\n+const _Unwind_Exception_Class __gxx_exception_class\n = ((((((((_Unwind_Exception_Class) 'G' \n \t << 8 | (_Unwind_Exception_Class) 'N')\n \t<< 8 | (_Unwind_Exception_Class) 'U')\n@@ -323,36 +244,13 @@ const _Unwind_Exception_Class __gxx_primary_exception_class\n     << 8 | (_Unwind_Exception_Class) '+')\n    << 8 | (_Unwind_Exception_Class) '\\0');\n \n-// This is the dependent (from std::rethrow_exception) exception class we report\n-// \"GNUCC++\\x01\"\n-const _Unwind_Exception_Class __gxx_dependent_exception_class\n-= ((((((((_Unwind_Exception_Class) 'G' \n-\t << 8 | (_Unwind_Exception_Class) 'N')\n-\t<< 8 | (_Unwind_Exception_Class) 'U')\n-       << 8 | (_Unwind_Exception_Class) 'C')\n-      << 8 | (_Unwind_Exception_Class) 'C')\n-     << 8 | (_Unwind_Exception_Class) '+')\n-    << 8 | (_Unwind_Exception_Class) '+')\n-   << 8 | (_Unwind_Exception_Class) '\\x01');\n-\n static inline bool\n __is_gxx_exception_class(_Unwind_Exception_Class c)\n {\n-  return c == __gxx_primary_exception_class\n-      || c == __gxx_dependent_exception_class;\n+  return c == __gxx_exception_class;\n }\n \n-// Only checks for primary or dependent, but not that it is a C++ exception at\n-// all.\n-static inline bool\n-__is_dependent_exception(_Unwind_Exception_Class c)\n-{\n-  return (c & 1);\n-}\n-\n-#define __GXX_INIT_PRIMARY_EXCEPTION_CLASS(c) c = __gxx_primary_exception_class\n-#define __GXX_INIT_DEPENDENT_EXCEPTION_CLASS(c) \\\n-  c = __gxx_dependent_exception_class\n+#define __GXX_INIT_EXCEPTION_CLASS(c) c = __gxx_exception_class\n \n // GNU C++ personality routine, Version 0.\n extern \"C\" _Unwind_Reason_Code __gxx_personality_v0\n@@ -367,27 +265,11 @@ extern \"C\" _Unwind_Reason_Code __gxx_personality_sj0\n static inline void*\n __gxx_caught_object(_Unwind_Exception* eo)\n {\n-  // Bad as it looks, this actually works for dependent exceptions too.\n   __cxa_exception* header = __get_exception_header_from_ue (eo);\n   return header->adjustedPtr;\n }\n #endif // !__ARM_EABI_UNWINDER__\n \n-static inline void*\n-__get_object_from_ue(_Unwind_Exception* eo) throw()\n-{\n-  return __is_dependent_exception (eo->exception_class) ?\n-    __get_dependent_exception_from_ue (eo)->primaryException :\n-    eo + 1;\n-}\n-\n-static inline void *\n-__get_object_from_ambiguous_exception(__cxa_exception *p_or_d) throw()\n-{\n-\treturn __get_object_from_ue (&p_or_d->unwindHeader);\n-}\n-\n-\n } /* namespace __cxxabiv1 */\n \n #pragma GCC visibility pop"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/testsuite/18_support/exception_ptr/current_exception.cc", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Fcurrent_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Fcurrent_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Fcurrent_exception.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,90 +0,0 @@\n-// { dg-options \"-std=gnu++0x\" }\n-// 2008-05-25  Sebastian Redl  <sebastian.redl@getdesigned.at>\n-\n-// Copyright (C) 2008 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// current_exception() under various conditions.\n-\n-#include <exception>\n-#include <testsuite_hooks.h>\n-\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  exception_ptr ep = current_exception();\n-  VERIFY( !ep );\n-}\n-\n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  try {\n-    throw 0;\n-  } catch(...) {\n-    exception_ptr ep = current_exception();\n-    VERIFY( ep );\n-  }\n-}\n-\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  try {\n-    throw exception();\n-  } catch(std::exception&) {\n-    exception_ptr ep = current_exception();\n-    VERIFY( ep );\n-  }\n-}\n-\n-void test04()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  try {\n-    throw 0;\n-  } catch(...) {\n-    exception_ptr ep1 = current_exception();\n-    try {\n-      throw 0;\n-    } catch(...) {\n-      exception_ptr ep2 = current_exception();\n-      VERIFY( ep1 != ep2 );\n-    }\n-    exception_ptr ep3 = current_exception();\n-    // Not guaranteed by standard, but by this implementation.\n-    VERIFY( ep1 == ep3 );\n-  }\n-}\n-\n-int main()\n-{\n-  test01();\n-  test02();\n-  test03();\n-  test04();\n-  return 0;\n-}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/testsuite/18_support/exception_ptr/lifespan.cc", "status": "modified", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Flifespan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Flifespan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Flifespan.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,188 +0,0 @@\n-// { dg-options \"-std=gnu++0x\" }\n-// 2008-05-25  Sebastian Redl  <sebastian.redl@getdesigned.at>\n-\n-// Copyright (C) 2008 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// Tests the life span of the exception object.\n-\n-#include <exception>\n-#include <testsuite_hooks.h>\n-\n-bool may_destruct = false;\n-\n-class destructing\n-{\n-  mutable bool copied;\n-\n-public:\n-  destructing() : copied(false) { }\n-  destructing(const destructing &o) : copied(false) { o.copied = true; }\n-  ~destructing() { VERIFY( copied || may_destruct ); }\n-};\n-\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  // Test the destructing class.\n-  {\n-    destructing *d = new destructing;\n-    destructing d2(*d);\n-    delete d;\n-    may_destruct = true;\n-  }\n-  may_destruct = false;\n-}\n-\n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  try {\n-    throw destructing();\n-  } catch(...) {\n-    may_destruct = true;\n-  }\n-  may_destruct = false;\n-}\n-\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  try {\n-    throw destructing();\n-  } catch(...) {\n-    {\n-      exception_ptr ep = current_exception();\n-    }\n-    may_destruct = true;\n-  }\n-  may_destruct = false;\n-}\n-\n-void test04()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  {\n-    exception_ptr ep;\n-    try {\n-      throw destructing();\n-    } catch(...) {\n-      ep = current_exception();\n-    }\n-    may_destruct = true;\n-  }\n-  may_destruct = false;\n-}\n-\n-void test05_helper()\n-{\n-  using namespace std;\n-  try {\n-    throw destructing();\n-  } catch(...) {\n-    exception_ptr ep = current_exception();\n-    rethrow_exception(ep);\n-  }\n-}\n-\n-void test05()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  try {\n-    test05_helper();\n-  } catch(...) {\n-    may_destruct = true;\n-  }\n-  may_destruct = false;\n-}\n-\n-void test06_helper()\n-{\n-  using namespace std;\n-  try {\n-    throw destructing();\n-  } catch(...) {\n-    exception_ptr ep = current_exception();\n-    throw;\n-  }\n-}\n-\n-void test06()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  try {\n-    test06_helper();\n-  } catch(...) {\n-    may_destruct = true;\n-  }\n-  may_destruct = false;\n-}\n-\n-std::exception_ptr gep;\n-\n-void test99()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  may_destruct = false;\n-\n-  try {\n-    throw destructing();\n-  } catch(...) {\n-    gep = current_exception();\n-  }\n-}\n-\n-int main()\n-{\n-  test01();\n-  test02();\n-  test03();\n-  test04();\n-  test05();\n-  test06();\n-\n-  test99();\n-  may_destruct = true;\n-  return 0;\n-}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/testsuite/18_support/exception_ptr/rethrow_exception.cc", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Frethrow_exception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec001bc92887d66331bf22047ee0c8ee26100c6c/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Frethrow_exception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fexception_ptr%2Frethrow_exception.cc?ref=ec001bc92887d66331bf22047ee0c8ee26100c6c", "patch": "@@ -1,113 +0,0 @@\n-// { dg-options \"-std=gnu++0x\" }\n-// 2008-05-25  Sebastian Redl  <sebastian.redl@getdesigned.at>\n-\n-// Copyright (C) 2008 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// rethrow_exception() and preservation of data\n-\n-#include <exception>\n-#include <typeinfo>\n-#include <cstring>\n-#include <stdexcept>\n-#include <testsuite_hooks.h>\n-\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  try {\n-    rethrow_exception(copy_exception(0));\n-  } catch(...) {\n-  }\n-}\n-\n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  try {\n-    rethrow_exception(copy_exception(runtime_error(\"test\")));\n-  } catch(exception &e) {\n-    VERIFY( typeid(e) == typeid(runtime_error) );\n-    VERIFY( strcmp(e.what(), \"test\") == 0 );\n-  }\n-}\n-\n-void test03()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  exception_ptr ep;\n-  try {\n-    throw 0;\n-  } catch(...) {\n-    ep = current_exception();\n-  }\n-  try {\n-    rethrow_exception(ep);\n-  } catch(...) {\n-  }\n-}\n-\n-void test04()\n-{\n-  bool test __attribute__((unused)) = true;\n-  using namespace std;\n-\n-  // Weave the exceptions in an attempt to confuse the machinery.\n-  try {\n-    throw 0;\n-  } catch(...) {\n-    exception_ptr ep1 = current_exception();\n-    try {\n-      throw 1;\n-    } catch(...) {\n-      exception_ptr ep2 = current_exception();\n-      try {\n-        rethrow_exception(ep1);\n-      } catch(...) {\n-        try {\n-          rethrow_exception(ep2);\n-        } catch(...) {\n-          try {\n-            rethrow_exception(ep1);\n-          } catch(...) {\n-          }\n-          try {\n-            rethrow_exception(ep2);\n-          } catch(...) {\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-int main()\n-{\n-  test01();\n-  test02();\n-  test03();\n-  test04();\n-\n-  return 0;\n-}"}]}