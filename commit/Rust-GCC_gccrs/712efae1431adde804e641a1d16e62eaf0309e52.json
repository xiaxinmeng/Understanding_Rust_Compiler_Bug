{"sha": "712efae1431adde804e641a1d16e62eaf0309e52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEyZWZhZTE0MzFhZGRlODA0ZTY0MWExZDE2ZTYyZWFmMDMwOWU1Mg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-09-10T23:38:54Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-09-10T23:38:54Z"}, "message": "gfortran.h (gfc_expr): Remove inline_noncopying_intrinsic attribute.\n\n2010-09-11  Mikael Morin  <mikael@gcc.gnu.org>\n\n\t* gfortran.h (gfc_expr): Remove inline_noncopying_intrinsic attribute.\n\t* dependency.c (gfc_check_dependency): Don't depend on\n\texpr's inline_noncopying_intrinsic_attribute.\n\t* dependency.c (gfc_check_argument_var_dependency,\n\tgfc_check_argument_dependency): Ditto. Recursively check dependency\n\tas NOT_ELEMENTAL in the non-copying (=transpose) case.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Ditto.\n\t* resolve.c (find_noncopying_intrinsics): Remove.\n\t(resolve_function, resolve_call): Remove call to\n\tfind_noncopying_intrinsics.\n\n\t* trans-array.c (gfc_conv_array_transpose): Remove.\n\t(gfc_walk_subexpr): Make non-static. Move prototype...\n\t* trans-array.h (gfc_walk_subexpr): ... here.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Update transpose\n\thandling.\n\t(walk_inline_intrinsic_transpose, walk_inline_intrinsic_function,\n\tgfc_inline_intrinsic_function_p): New.\n\t(gfc_is_intrinsic_libcall): Return early in inline intrinsic case.\n\tRemove transpose from the libcall list.\n\t(gfc_walk_intrinsic_function): Special case inline intrinsic.\n\t* trans.h (gfc_inline_intrinsic_function_p): New prototype.\n\n2010-09-11  Mikael Morin  <mikael@gcc.gnu.org>\n\n\t* gfortran.dg/inline_transpose_1.f90: Update temporary's locations\n\tand counts. Check that transpose is not called.\n\t* gfortran.dg/transpose_2.f90: Update error message.\n\nFrom-SVN: r164205", "tree": {"sha": "b44ce4567a0486b93326f709e0f8118283d0f9f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b44ce4567a0486b93326f709e0f8118283d0f9f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/712efae1431adde804e641a1d16e62eaf0309e52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712efae1431adde804e641a1d16e62eaf0309e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/712efae1431adde804e641a1d16e62eaf0309e52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/712efae1431adde804e641a1d16e62eaf0309e52/comments", "author": null, "committer": null, "parents": [{"sha": "48255616066333ad0b71e5fc55afaf847f7b1fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48255616066333ad0b71e5fc55afaf847f7b1fd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48255616066333ad0b71e5fc55afaf847f7b1fd5"}], "stats": {"total": 377, "additions": 194, "deletions": 183}, "files": [{"sha": "a2916af1abae7ba671626524cb4c2957109eed57", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -1,3 +1,28 @@\n+2010-09-11  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* gfortran.h (gfc_expr): Remove inline_noncopying_intrinsic attribute.\n+\t* dependency.c (gfc_check_dependency): Don't depend on\n+\texpr's inline_noncopying_intrinsic_attribute.\n+\t* dependency.c (gfc_check_argument_var_dependency,\n+\tgfc_check_argument_dependency): Ditto. Recursively check dependency\n+\tas NOT_ELEMENTAL in the non-copying (=transpose) case.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Ditto.\n+\t* resolve.c (find_noncopying_intrinsics): Remove.\n+\t(resolve_function, resolve_call): Remove call to\n+\tfind_noncopying_intrinsics.\n+\n+\t* trans-array.c (gfc_conv_array_transpose): Remove.\n+\t(gfc_walk_subexpr): Make non-static. Move prototype...\n+\t* trans-array.h (gfc_walk_subexpr): ... here.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Update transpose\n+\thandling.\n+\t(walk_inline_intrinsic_transpose, walk_inline_intrinsic_function,\n+\tgfc_inline_intrinsic_function_p): New.\n+\t(gfc_is_intrinsic_libcall): Return early in inline intrinsic case.\n+\tRemove transpose from the libcall list.\n+\t(gfc_walk_intrinsic_function): Special case inline intrinsic.\n+\t* trans.h (gfc_inline_intrinsic_function_p): New prototype.\n+\n 2010-09-10  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-expr.c (expr_is_variable): New function taking non-copying"}, {"sha": "ee66d216ab567cd2785aa339f617d2b268fc2663", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -627,11 +627,15 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n       return gfc_check_dependency (var, expr, 1);\n \n     case EXPR_FUNCTION:\n-      if (intent != INTENT_IN && expr->inline_noncopying_intrinsic\n-\t  && (arg = gfc_get_noncopying_intrinsic_argument (expr))\n-\t  && gfc_check_argument_var_dependency (var, intent, arg, elemental))\n-\treturn 1;\n-      if (elemental)\n+      if (intent != INTENT_IN)\n+\t{\n+\t  arg = gfc_get_noncopying_intrinsic_argument (expr);\n+\t  if (arg != NULL)\n+\t    return gfc_check_argument_var_dependency (var, intent, arg,\n+\t\t\t\t\t\t      NOT_ELEMENTAL);\n+\t}\n+\n+      if (elemental != NOT_ELEMENTAL)\n \t{\n \t  if ((expr->value.function.esym\n \t       && expr->value.function.esym->attr.elemental)\n@@ -683,12 +687,11 @@ gfc_check_argument_dependency (gfc_expr *other, sym_intent intent,\n       return gfc_check_argument_var_dependency (other, intent, expr, elemental);\n \n     case EXPR_FUNCTION:\n-      if (other->inline_noncopying_intrinsic)\n-\t{\n-\t  other = gfc_get_noncopying_intrinsic_argument (other);\n-\t  return gfc_check_argument_dependency (other, INTENT_IN, expr, \n-\t\t\t\t\t\telemental);\n-\t}\n+      other = gfc_get_noncopying_intrinsic_argument (other);\n+      if (other != NULL)\n+\treturn gfc_check_argument_dependency (other, INTENT_IN, expr,\n+\t\t\t\t\t      NOT_ELEMENTAL);\n+\n       return 0;\n \n     default:\n@@ -962,8 +965,9 @@ gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n       return 1;\n \n     case EXPR_FUNCTION:\n-      if (expr2->inline_noncopying_intrinsic)\n+      if (gfc_get_noncopying_intrinsic_argument (expr2) != NULL)\n \tidentical = 1;\n+\n       /* Remember possible differences between elemental and\n \t transformational functions.  All functions inside a FORALL\n \t will be pure.  */"}, {"sha": "056009aabb070526a7b77947e15988081aeef356", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -1695,11 +1695,9 @@ typedef struct gfc_expr\n \n   locus where;\n \n-  /* True if the expression is a call to a function that returns an array,\n-     and if we have decided not to allocate temporary data for that array.\n-     is_boz is true if the integer is regarded as BOZ bitpatten and is_snan\n+  /* is_boz is true if the integer is regarded as BOZ bitpatten and is_snan\n      denotes a signalling not-a-number.  */\n-  unsigned int inline_noncopying_intrinsic : 1, is_boz : 1, is_snan : 1;\n+  unsigned int is_boz : 1, is_snan : 1;\n \n   /* Sometimes, when an error has been emitted, it is necessary to prevent\n       it from recurring.  */"}, {"sha": "90d80a7fda0e87cf25de95605c88f637e447b7d2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -1916,25 +1916,6 @@ resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n }\n \n \n-/* Go through each actual argument in ACTUAL and see if it can be\n-   implemented as an inlined, non-copying intrinsic.  FNSYM is the\n-   function being called, or NULL if not known.  */\n-\n-static void\n-find_noncopying_intrinsics (gfc_symbol *fnsym, gfc_actual_arglist *actual)\n-{\n-  gfc_actual_arglist *ap;\n-  gfc_expr *expr;\n-\n-  for (ap = actual; ap; ap = ap->next)\n-    if (ap->expr\n-\t&& (expr = gfc_get_noncopying_intrinsic_argument (ap->expr))\n-\t&& !gfc_check_fncall_dependency (expr, INTENT_IN, fnsym, actual,\n-\t\t\t\t\t NOT_ELEMENTAL))\n-      ap->expr->inline_noncopying_intrinsic = 1;\n-}\n-\n-\n /* This function does the checking of references to global procedures\n    as defined in sections 18.1 and 14.1, respectively, of the Fortran\n    77 and 95 standards.  It checks for a gsymbol for the name, making\n@@ -3115,15 +3096,6 @@ resolve_function (gfc_expr *expr)\n       gfc_expr_set_symbols_referenced (expr->ts.u.cl->length);\n     }\n \n-  if (t == SUCCESS\n-\t&& !((expr->value.function.esym\n-\t\t&& expr->value.function.esym->attr.elemental)\n-\t\t\t||\n-\t     (expr->value.function.isym\n-\t\t&& expr->value.function.isym->elemental)))\n-    find_noncopying_intrinsics (expr->value.function.esym,\n-\t\t\t\texpr->value.function.actual);\n-\n   /* Make sure that the expression has a typespec that works.  */\n   if (expr->ts.type == BT_UNKNOWN)\n     {\n@@ -3602,8 +3574,6 @@ resolve_call (gfc_code *c)\n   if (resolve_elemental_actual (NULL, c) == FAILURE)\n     return FAILURE;\n \n-  if (t == SUCCESS && !(c->resolved_sym && c->resolved_sym->attr.elemental))\n-    find_noncopying_intrinsics (c->resolved_sym, c->ext.actual);\n   return t;\n }\n "}, {"sha": "7bce2ef866be77dc09be51225a340014949f6bfd", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 92, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -91,7 +91,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-const.h\"\n #include \"dependency.h\"\n \n-static gfc_ss *gfc_walk_subexpr (gfc_ss *, gfc_expr *);\n static bool gfc_get_array_constructor_size (mpz_t *, gfc_constructor_base);\n \n /* The contents of this structure aren't actually used, just the address.  */\n@@ -917,96 +916,6 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n }\n \n \n-/* Generate code to transpose array EXPR by creating a new descriptor\n-   in which the dimension specifications have been reversed.  */\n-\n-void\n-gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n-{\n-  tree dest, src, dest_index, src_index;\n-  gfc_loopinfo *loop;\n-  gfc_ss_info *dest_info;\n-  gfc_ss *dest_ss, *src_ss;\n-  gfc_se src_se;\n-  int n;\n-\n-  loop = se->loop;\n-\n-  src_ss = gfc_walk_expr (expr);\n-  dest_ss = se->ss;\n-\n-  dest_info = &dest_ss->data.info;\n-  gcc_assert (dest_info->dimen == 2);\n-\n-  /* Get a descriptor for EXPR.  */\n-  gfc_init_se (&src_se, NULL);\n-  gfc_conv_expr_descriptor (&src_se, expr, src_ss);\n-  gfc_add_block_to_block (&se->pre, &src_se.pre);\n-  gfc_add_block_to_block (&se->post, &src_se.post);\n-  src = src_se.expr;\n-\n-  /* Allocate a new descriptor for the return value.  */\n-  dest = gfc_create_var (TREE_TYPE (src), \"transp\");\n-  dest_info->descriptor = dest;\n-  se->expr = dest;\n-\n-  /* Copy across the dtype field.  */\n-  gfc_add_modify (&se->pre,\n-\t\t       gfc_conv_descriptor_dtype (dest),\n-\t\t       gfc_conv_descriptor_dtype (src));\n-\n-  /* Copy the dimension information, renumbering dimension 1 to 0 and\n-     0 to 1.  */\n-  for (n = 0; n < 2; n++)\n-    {\n-      dest_info->delta[n] = gfc_index_zero_node;\n-      dest_info->start[n] = gfc_index_zero_node;\n-      dest_info->end[n] = gfc_index_zero_node;\n-      dest_info->stride[n] = gfc_index_one_node;\n-      dest_info->dim[n] = n;\n-\n-      dest_index = gfc_rank_cst[n];\n-      src_index = gfc_rank_cst[1 - n];\n-\n-      gfc_conv_descriptor_stride_set (&se->pre, dest, dest_index,\n-\t\t\t   gfc_conv_descriptor_stride_get (src, src_index));\n-\n-      gfc_conv_descriptor_lbound_set (&se->pre, dest, dest_index,\n-\t\t\t   gfc_conv_descriptor_lbound_get (src, src_index));\n-\n-      gfc_conv_descriptor_ubound_set (&se->pre, dest, dest_index,\n-\t\t\t   gfc_conv_descriptor_ubound_get (src, src_index));\n-\n-      if (!loop->to[n])\n-        {\n-\t  gcc_assert (integer_zerop (loop->from[n]));\n-\t  loop->to[n] =\n-\t    fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n-\t\t\t gfc_conv_descriptor_ubound_get (dest, dest_index),\n-\t\t\t gfc_conv_descriptor_lbound_get (dest, dest_index));\n-        }\n-    }\n-\n-  /* Copy the data pointer.  */\n-  dest_info->data = gfc_conv_descriptor_data_get (src);\n-  gfc_conv_descriptor_data_set (&se->pre, dest, dest_info->data);\n-\n-  /* Copy the offset.  This is not changed by transposition; the top-left\n-     element is still at the same offset as before, except where the loop\n-     starts at zero.  */\n-  if (!integer_zerop (loop->from[0]))\n-    dest_info->offset = gfc_conv_descriptor_offset_get (src);\n-  else\n-    dest_info->offset = gfc_index_zero_node;\n-\n-  gfc_conv_descriptor_offset_set (&se->pre, dest,\n-\t\t\t\t  dest_info->offset);\n-\t  \n-  if (dest_info->dimen > loop->temp_dim)\n-    loop->temp_dim = dest_info->dimen;\n-}\n-\n-\n /* Return the number of iterations in a loop that starts at START,\n    ends at END, and has step STEP.  */\n \n@@ -6989,7 +6898,7 @@ gfc_walk_array_constructor (gfc_ss * ss, gfc_expr * expr)\n /* Walk an expression.  Add walked expressions to the head of the SS chain.\n    A wholly scalar expression will not be added.  */\n \n-static gfc_ss *\n+gfc_ss *\n gfc_walk_subexpr (gfc_ss * ss, gfc_expr * expr)\n {\n   gfc_ss *head;"}, {"sha": "f363716d3d3b798a77aef8ff95b274121fd6ac99", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -64,6 +64,8 @@ void gfc_trans_static_array_pointer (gfc_symbol *);\n \n /* Generate scalarization information for an expression.  */\n gfc_ss *gfc_walk_expr (gfc_expr *);\n+/* Workhorse for gfc_walk_expr.  */\n+gfc_ss *gfc_walk_subexpr (gfc_ss *, gfc_expr *);\n /* Walk the arguments of an elemental function.  */\n gfc_ss *gfc_walk_elemental_function_args (gfc_ss *, gfc_actual_arglist *,\n \t\t\t\t\t  gfc_ss_type);"}, {"sha": "f3aac9c7529f215058293f8bfe52a34c6e280874", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 90, "deletions": 10, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -5583,7 +5583,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \n   name = &expr->value.function.name[2];\n \n-  if (expr->rank > 0 && !expr->inline_noncopying_intrinsic)\n+  if (expr->rank > 0)\n     {\n       lib = gfc_is_intrinsic_libcall (expr);\n       if (lib != 0)\n@@ -5957,13 +5957,9 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_TRANSPOSE:\n-      if (se->ss && se->ss->useflags)\n-\t{\n-\t  gfc_conv_tmp_array_ref (se);\n-\t  gfc_advance_se_ss_chain (se);\n-\t}\n-      else\n-\tgfc_conv_array_transpose (se, expr->value.function.actual->expr);\n+      /* The scalarizer has already been set up for reversed dimension access\n+\t order ; now we just get the argument value normally.  */\n+      gfc_conv_expr (se, expr->value.function.actual->expr);\n       break;\n \n     case GFC_ISYM_LEN:\n@@ -6188,6 +6184,64 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n }\n \n \n+static gfc_ss *\n+walk_inline_intrinsic_transpose (gfc_ss *ss, gfc_expr *expr)\n+{\n+  gfc_ss *arg_ss, *tmp_ss;\n+  gfc_actual_arglist *arg;\n+\n+  arg = expr->value.function.actual;\n+\n+  gcc_assert (arg->expr);\n+\n+  arg_ss = gfc_walk_subexpr (gfc_ss_terminator, arg->expr);\n+  gcc_assert (arg_ss != gfc_ss_terminator);\n+\n+  for (tmp_ss = arg_ss; ; tmp_ss = tmp_ss->next)\n+    {\n+      if (tmp_ss->type != GFC_SS_SCALAR\n+\t  && tmp_ss->type != GFC_SS_REFERENCE)\n+\t{\n+\t  int tmp_dim;\n+\t  gfc_ss_info *info;\n+\n+\t  info = &tmp_ss->data.info;\n+\t  gcc_assert (info->dimen == 2);\n+\n+\t  /* We just invert dimensions.  */\n+\t  tmp_dim = info->dim[0];\n+\t  info->dim[0] = info->dim[1];\n+\t  info->dim[1] = tmp_dim;\n+\t}\n+\n+      /* Stop when tmp_ss points to the last valid element of the chain...  */\n+      if (tmp_ss->next == gfc_ss_terminator)\n+\tbreak;\n+    }\n+\n+  /* ... so that we can attach the rest of the chain to it.  */\n+  tmp_ss->next = ss;\n+\n+  return arg_ss;\n+}\n+\n+\n+static gfc_ss *\n+walk_inline_intrinsic_function (gfc_ss * ss, gfc_expr * expr)\n+{\n+\n+  switch (expr->value.function.isym->id)\n+    {\n+      case GFC_ISYM_TRANSPOSE:\n+\treturn walk_inline_intrinsic_transpose (ss, expr);\n+\n+      default:\n+\tgcc_unreachable ();\n+    }\n+  gcc_unreachable ();\n+}\n+\n+\n /* This generates code to execute before entering the scalarization loop.\n    Currently does nothing.  */\n \n@@ -6250,6 +6304,26 @@ gfc_walk_intrinsic_libfunc (gfc_ss * ss, gfc_expr * expr)\n }\n \n \n+/* Return whether the function call expression EXPR will be expanded\n+   inline by gfc_conv_intrinsic_function.  */\n+\n+bool\n+gfc_inline_intrinsic_function_p (gfc_expr *expr)\n+{\n+  if (!expr->value.function.isym)\n+    return false;\n+\n+  switch (expr->value.function.isym->id)\n+    {\n+    case GFC_ISYM_TRANSPOSE:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+\n /* Returns nonzero if the specified intrinsic function call maps directly to\n    an external library call.  Should only be used for functions that return\n    arrays.  */\n@@ -6260,6 +6334,9 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n   gcc_assert (expr->expr_type == EXPR_FUNCTION && expr->value.function.isym);\n   gcc_assert (expr->rank > 0);\n \n+  if (gfc_inline_intrinsic_function_p (expr))\n+    return 0;\n+\n   switch (expr->value.function.isym->id)\n     {\n     case GFC_ISYM_ALL:\n@@ -6280,7 +6357,6 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n     case GFC_ISYM_SUM:\n     case GFC_ISYM_SHAPE:\n     case GFC_ISYM_SPREAD:\n-    case GFC_ISYM_TRANSPOSE:\n     case GFC_ISYM_YN2:\n       /* Ignore absent optional parameters.  */\n       return 1;\n@@ -6306,11 +6382,15 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n   gcc_assert (isym);\n \n   if (isym->elemental)\n-    return gfc_walk_elemental_function_args (ss, expr->value.function.actual, GFC_SS_SCALAR);\n+    return gfc_walk_elemental_function_args (ss, expr->value.function.actual,\n+\t\t\t\t\t     GFC_SS_SCALAR);\n \n   if (expr->rank == 0)\n     return ss;\n \n+  if (gfc_inline_intrinsic_function_p (expr))\n+    return walk_inline_intrinsic_function (ss, expr);\n+\n   if (gfc_is_intrinsic_libcall (expr))\n     return gfc_walk_intrinsic_libfunc (ss, expr);\n "}, {"sha": "acdd3e30995d3f7dd4d7b5d322757bb5d77a75be", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -345,7 +345,12 @@ tree gfc_builtin_decl_for_float_kind (enum built_in_function, int);\n /* Intrinsic function handling.  */\n void gfc_conv_intrinsic_function (gfc_se *, gfc_expr *);\n \n-/* Does an intrinsic map directly to an external library call.  */\n+/* Is the intrinsic expanded inline.  */\n+bool gfc_inline_intrinsic_function_p (gfc_expr *);\n+\n+/* Does an intrinsic map directly to an external library call\n+   This is true for array-returning intrinsics, unless\n+   gfc_inline_intrinsic_function_p returns true.  */\n int gfc_is_intrinsic_libcall (gfc_expr *);\n \n tree gfc_conv_intrinsic_move_alloc (gfc_code *);"}, {"sha": "eaf236e223ba566d6217c43aad3b0d107ee3e688", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -1,3 +1,9 @@\n+2010-09-11  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* gfortran.dg/inline_transpose_1.f90: Update temporary's locations\n+\tand counts. Check that transpose is not called.\n+\t* gfortran.dg/transpose_2.f90: Update error message.\n+\n 2010-09-10  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n \n \tPR c++/43824"}, {"sha": "50290c6fad188d7eeede68cebd1f509176e47b61", "filename": "gcc/testsuite/gfortran.dg/inline_transpose_1.f90", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_transpose_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_transpose_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_transpose_1.f90?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-fdump-tree-original -Warray-temporaries\" }\n+! { dg-options \"-fdump-tree-original -fdump-tree-optimized -Warray-temporaries -fbounds-check\" }\n \n   implicit none\n \n@@ -29,135 +29,135 @@\n   c = transpose(a)\n   if (any(c /= q)) call abort\n \n-  write(u,*) transpose(a)       ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(a)\n   write(v,*) q\n   if (u /= v) call abort\n \n \n   e = r\n   f = s\n \n-  g = transpose(e+f)            ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  g = transpose(e+f)\n   if (any(g /= r + s)) call abort\n \n-  write(u,*) transpose(e+f)     ! 2 Unnecessary temps { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(e+f)\n   write(v,*) r + s\n   if (u /= v) call abort\n \n \n   e = transpose(e)      ! { dg-warning \"Creating array temporary\" }\n   if (any(e /= s)) call abort\n \n-  write(u,*) transpose(transpose(e))    ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(transpose(e))\n   write(v,*) s\n   if (u /= v) call abort\n \n \n   e = transpose(e+f)     ! { dg-warning \"Creating array temporary\" }\n   if (any(e /= 2*r)) call abort\n \n-  write(u,*) transpose(transpose(e+f))-f        ! 2 Unnecessary temps { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(transpose(e+f))-f\n   write(v,*) 2*r\n   if (u /= v) call abort\n \n \n-  a = foo(transpose(c))\n+  a = foo(transpose(c)) ! Unnecessary { dg-warning \"Creating array temporary\" }\n   if (any(a /= p+1)) call abort\n \n-  write(u,*) foo(transpose(c))    ! { dg-warning \"Creating array temporary\" }\n+  write(u,*) foo(transpose(c))    ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n   write(v,*) p+1\n   if (u /= v) call abort\n \n \n   c = transpose(foo(a))      ! Unnecessary { dg-warning \"Creating array temporary\" }\n   if (any(c /= q+2)) call abort\n \n-  write(u,*) transpose(foo(a))     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(foo(a))     ! { dg-warning \"Creating array temporary\" }\n   write(v,*) q+2\n   if (u /= v) call abort\n \n \n-  e = foo(transpose(e))     ! { dg-warning \"Creating array temporary\" }\n+  e = foo(transpose(e))     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n   if (any(e /= 2*s+1)) call abort\n \n-  write(u,*) transpose(foo(transpose(e))-1)     ! 3 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(foo(transpose(e))-1)     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n   write(v,*) 2*s+1\n   if (u /= v) call abort\n \n \n   e = transpose(foo(e))     ! { dg-warning \"Creating array temporary\" }\n   if (any(e /= 2*r+2)) call abort\n \n-  write(u,*) transpose(foo(transpose(e)-1))     ! 4 temps, should be 2 { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(foo(transpose(e)-1))     ! 2 temps { dg-warning \"Creating array temporary\" }\n   write(v,*) 2*r+2\n   if (u /= v) call abort\n \n \n-  a = bar(transpose(c))         ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  a = bar(transpose(c))\n   if (any(a /= p+4)) call abort\n \n-  write(u,*) bar(transpose(c))  ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  write(u,*) bar(transpose(c))\n   write(v,*) p+4\n   if (u /= v) call abort\n \n \n-  c = transpose(bar(a))         ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  c = transpose(bar(a))\n   if (any(c /= q+6)) call abort\n \n-  write(u,*) transpose(bar(a))  ! 2 Unnecessary temps { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(bar(a))\n   write(v,*) q+6\n   if (u /= v) call abort\n \n \n   e = bar(transpose(e))     ! { dg-warning \"Creating array temporary\" }\n   if (any(e /= 2*s+4)) call abort\n \n-  write(u,*) transpose(bar(transpose(e)))-2     ! 3 Unnecessary temps { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(bar(transpose(e)))-2\n   write(v,*) 2*s+4\n   if (u /= v) call abort\n \n \n   e = transpose(bar(e))     ! { dg-warning \"Creating array temporary\" }\n   if (any(e /= 2*r+6)) call abort\n \n-  write(u,*) transpose(transpose(bar(e))-2)     ! 4 Unnecessary temps { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(transpose(bar(e))-2)\n   write(v,*) 2*r+6\n   if (u /= v) call abort\n \n \n-  if (any(a /= transpose(transpose(a)))) call abort     ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  if (any(a /= transpose(transpose(a)))) call abort     ! optimized away\n \n   write(u,*) a\n-  write(v,*) transpose(transpose(a))    ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  write(v,*) transpose(transpose(a))\n   if (u /= v) call abort\n \n \n   b = a * a\n \n-  if (any(transpose(a+b) /= transpose(a)+transpose(b))) call abort      ! 4 unnecessary temps { dg-warning \"Creating array temporary\" }\n+  if (any(transpose(a+b) /= transpose(a)+transpose(b))) call abort      ! optimized away\n \n-  write(u,*) transpose(a+b)     ! 2 unnecessary temps { dg-warning \"Creating array temporary\" }\n-  write(v,*) transpose(a) + transpose(b)        ! 2 unnecessary temps { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(a+b)\n+  write(v,*) transpose(a) + transpose(b)\n   if (u /= v) call abort\n \n \n-  if (any(transpose(matmul(a,c)) /= matmul(transpose(c), transpose(a)))) call abort      ! 3 temps, should be 2 { dg-warning \"Creating array temporary\" }\n+  if (any(transpose(matmul(a,c)) /= matmul(transpose(c), transpose(a)))) call abort      ! 4 temps, should be 2 { dg-warning \"Creating array temporary\" }\n \n-  write(u,*) transpose(matmul(a,c))     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n-  write(v,*) matmul(transpose(c), transpose(a))     ! { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(matmul(a,c))     ! { dg-warning \"Creating array temporary\" }\n+  write(v,*) matmul(transpose(c), transpose(a))     ! 3 temps, should be 1 { dg-warning \"Creating array temporary\" }\n   if (u /= v) call abort\n \n \n-  if (any(transpose(matmul(e,a)) /= matmul(transpose(a), transpose(e)))) call abort     ! 3 temps, should be 2 { dg-warning \"Creating array temporary\" }\n+  if (any(transpose(matmul(e,a)) /= matmul(transpose(a), transpose(e)))) call abort     ! 4 temps, should be 2 { dg-warning \"Creating array temporary\" }\n \n-  write(u,*) transpose(matmul(e,a))     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n-  write(v,*) matmul(transpose(a), transpose(e))     ! { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(matmul(e,a))     ! { dg-warning \"Creating array temporary\" }\n+  write(v,*) matmul(transpose(a), transpose(e))     ! 3 temps, should be 1 { dg-warning \"Creating array temporary\" }\n   if (u /= v) call abort\n \n \n-  call baz (transpose(a))\n+  call baz (transpose(a))       ! Unnecessary { dg-warning \"Creating array temporary\" }\n \n-  call toto (f, transpose (e))          ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  call toto (f, transpose (e))\n   if (any (f /= 4 * s + 12)) call abort\n \n   call toto (f, transpose (f))          ! { dg-warning \"Creating array temporary\" }\n@@ -189,5 +189,16 @@ elemental subroutine toto (x, y)\n   end subroutine toto\n \n end\n-! { dg-final { scan-tree-dump-times \"struct\\[^\\\\n\\]*atmp\" 60 \"original\" } }\n-! { dg-final { cleanup-tree-dump \"original\" } }\n+! No call to transpose\n+! { dg-final { scan-tree-dump-times \"_gfortran_transpose\" 0 \"original\" } }\n+!\n+! 34 temporaries\n+! { dg-final { scan-tree-dump-times \"struct\\[^\\\\n\\]*atmp\" 34 \"original\" } }\n+!\n+! 2 tests optimized out\n+! { dg-final { scan-tree-dump-times \"_gfortran_abort\" 34 \"original\" } }\n+! { # Commented out as failing at -O0: dg-final { scan-tree-dump-times \"_gfortran_abort\" 32 \"optimized\" } }\n+!\n+! cleanup\n+! { #dg-final { cleanup-tree-dump \"original\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "37033eb88ccf7c10d53009c9f6f4c336ae25cd48", "filename": "gcc/testsuite/gfortran.dg/transpose_2.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/712efae1431adde804e641a1d16e62eaf0309e52/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_2.f90?ref=712efae1431adde804e641a1d16e62eaf0309e52", "patch": "@@ -15,4 +15,5 @@ program main\n   b = 2.1\n   b = transpose(a)\n end program main\n-! { dg-output \"Fortran runtime error: Incorrect extent in return value of TRANSPOSE intrinsic in dimension 1: is 2, should be 3\" }\n+! { dg-output \"Fortran runtime error: Array bound mismatch for dimension 1 of\n+! array 'b' (3/2)\" }"}]}