{"sha": "d5302f06b81185a1c785263358f204fc0f5bdba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUzMDJmMDZiODExODVhMWM3ODUyNjMzNThmMjA0ZmMwZjViZGJhMg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-04-27T17:41:01Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-04-27T17:41:01Z"}, "message": "re PR fortran/60322 ([OOP] Incorrect bounds on polymorphic dummy array)\n\n2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n\n        PR fortran/60322\n        Add tests forgotten to svn-add.\n        * gfortran.dg/class_allocate_19.f03: New test.\n        * gfortran.dg/class_array_20.f03: New test.\n        * gfortran.dg/class_array_21.f03: New test.\n        * gfortran.dg/finalize_29.f08: New test.\n\nFrom-SVN: r222478", "tree": {"sha": "eb5dfcdbfafee7df0b3d4a365fd2f0e3cda7d14b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb5dfcdbfafee7df0b3d4a365fd2f0e3cda7d14b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5302f06b81185a1c785263358f204fc0f5bdba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5302f06b81185a1c785263358f204fc0f5bdba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5302f06b81185a1c785263358f204fc0f5bdba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5302f06b81185a1c785263358f204fc0f5bdba2/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc7d0afb9c70f466189c433962bab41a84765b0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc7d0afb9c70f466189c433962bab41a84765b0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc7d0afb9c70f466189c433962bab41a84765b0f"}], "stats": {"total": 542, "additions": 542, "deletions": 0}, "files": [{"sha": "67bdd69ddf0eb06abe3b1596ffb9a18c974e29e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5302f06b81185a1c785263358f204fc0f5bdba2", "patch": "@@ -1,3 +1,12 @@\n+2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/60322\n+\tAdd tests forgotten to svn-add.\n+\t* gfortran.dg/class_allocate_19.f03: New test.\n+\t* gfortran.dg/class_array_20.f03: New test.\n+\t* gfortran.dg/class_array_21.f03: New test.\n+\t* gfortran.dg/finalize_29.f08: New test.\n+\n 2015-04-27  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/59678"}, {"sha": "719be3e0718768e2b30ac47eec15ef7707924269", "filename": "gcc/testsuite/gfortran.dg/class_allocate_19.f03", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_19.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_19.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_19.f03?ref=d5302f06b81185a1c785263358f204fc0f5bdba2", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+!\n+! Contributed by: Vladimir Fuka  <vladimir.fuka@gmail.com>\n+\n+use iso_c_binding\n+implicit none\n+real, target :: e\n+class(*), allocatable, target :: a(:)\n+e = 1.0\n+call add_element_poly(a,e)\n+if (size(a) /= 1) call abort()\n+call add_element_poly(a,e)\n+if (size(a) /= 2) call abort()\n+select type (a)\n+  type is (real)\n+    if (any (a /= [ 1, 1])) call abort()\n+end select\n+contains\n+    subroutine add_element_poly(a,e)\n+      use iso_c_binding\n+      class(*),allocatable,intent(inout),target :: a(:)\n+      class(*),intent(in),target :: e\n+      class(*),allocatable,target :: tmp(:)\n+      type(c_ptr) :: dummy\n+\n+      interface\n+        function memcpy(dest,src,n) bind(C,name=\"memcpy\") result(res)\n+          import\n+          type(c_ptr) :: res\n+          integer(c_intptr_t),value :: dest\n+          integer(c_intptr_t),value :: src\n+          integer(c_size_t),value :: n\n+        end function\n+      end interface\n+\n+      if (.not.allocated(a)) then\n+        allocate(a(1), source=e)\n+      else\n+        allocate(tmp(size(a)),source=a)\n+        deallocate(a)\n+        allocate(a(size(tmp)+1),mold=e)\n+        dummy = memcpy(loc(a(1)),loc(tmp),sizeof(tmp))\n+        dummy = memcpy(loc(a(size(tmp)+1)),loc(e),sizeof(e))\n+      end if\n+    end subroutine\n+end\n+"}, {"sha": "c49f7d2406fe514cd6cf443345ea4ba95ad6fd7d", "filename": "gcc/testsuite/gfortran.dg/class_array_20.f03", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_20.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_20.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_20.f03?ref=d5302f06b81185a1c785263358f204fc0f5bdba2", "patch": "@@ -0,0 +1,100 @@\n+! {dg-do run}\n+!\n+! Test contributed by Thomas L. Clune via pr60322\n+!                  and Antony Lewis via pr64692\n+\n+program class_array_20\n+  implicit none\n+\n+  type Foo\n+  end type\n+\n+  type(foo), dimension(2:3) :: arg\n+  integer :: oneDarr(2)\n+  integer :: twoDarr(2,3)\n+  integer :: x, y\n+  double precision :: P(2, 2)\n+\n+  ! Checking for PR/60322\n+  call copyFromClassArray([Foo(), Foo()])\n+  call copyFromClassArray(arg)\n+  call copyFromClassArray(arg(:))\n+\n+  x= 3\n+  y= 4\n+  oneDarr = [x, y]\n+  call W([x, y])\n+  call W(oneDarr)\n+  call W([3, 4])\n+\n+  twoDarr = reshape([3, 4, 5, 5, 6, 7], [2, 3])\n+  call WtwoD(twoDarr)\n+  call WtwoD(reshape([3, 4, 5, 5, 6, 7], [2, 3]))\n+\n+  ! Checking for PR/64692\n+  P(1:2, 1) = [1.d0, 2.d0]\n+  P(1:2, 2) = [3.d0, 4.d0]\n+  call AddArray(P(1:2, 2))\n+\n+contains\n+\n+  subroutine copyFromClassArray(classarray)\n+    class (Foo), intent(in) :: classarray(:)\n+\n+    if (lbound(classarray, 1) .ne. 1) call abort()\n+    if (ubound(classarray, 1) .ne. 2) call abort()\n+    if (size(classarray) .ne. 2) call abort()\n+  end subroutine\n+\n+  subroutine AddArray(P)\n+    class(*), target, intent(in) :: P(:)\n+    class(*), pointer :: Pt(:)\n+\n+    allocate(Pt(1:size(P)), source= P)\n+\n+    select type (P)\n+      type is (double precision)\n+        if (abs(P(1)-3.d0) .gt. 1.d-8) call abort()\n+        if (abs(P(2)-4.d0) .gt. 1.d-8) call abort()\n+      class default\n+        call abort()\n+    end select\n+\n+    select type (Pt)\n+      type is (double precision)\n+        if (abs(Pt(1)-3.d0) .gt. 1.d-8) call abort()\n+        if (abs(Pt(2)-4.d0) .gt. 1.d-8) call abort()\n+      class default\n+        call abort()\n+    end select\n+  end subroutine\n+\n+  subroutine W(ar)\n+    class(*), intent(in) :: ar(:)\n+\n+    if (lbound(ar, 1) /= 1) call abort()\n+    select type (ar)\n+      type is (integer)\n+        ! The indeces 1:2 are essential here, or else one would not\n+        ! note, that the array internally starts at 0, although the\n+        ! check for the lbound above went fine.\n+        if (any (ar(1:2) .ne. [3, 4])) call abort()\n+      class default\n+        call abort()\n+    end select\n+  end subroutine\n+\n+  subroutine WtwoD(ar)\n+    class(*), intent(in) :: ar(:,:)\n+\n+    if (any (lbound(ar) /= [1, 1])) call abort()\n+    select type (ar)\n+      type is (integer)\n+        if (any (reshape(ar(1:2,1:3), [6]) .ne. [3, 4, 5, 5, 6, 7])) &\n+        call abort()\n+      class default\n+        call abort()\n+    end select\n+  end subroutine\n+end program class_array_20\n+"}, {"sha": "1e89d384385ab28c7958b3208675bb31fc6f4b71", "filename": "gcc/testsuite/gfortran.dg/class_array_21.f03", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_21.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_21.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_21.f03?ref=d5302f06b81185a1c785263358f204fc0f5bdba2", "patch": "@@ -0,0 +1,97 @@\n+! {dg-do run}\n+!\n+! Contributed by Andre Vehreschild\n+! Check more elaborate class array addressing.\n+\n+module m1\n+\n+  type InnerBaseT\n+    integer, allocatable :: a(:)\n+  end type InnerBaseT\n+\n+  type, extends(InnerBaseT) :: InnerT\n+    integer :: i\n+  end type InnerT\n+\n+  type BaseT\n+    class(InnerT), allocatable :: arr(:,:)\n+  contains\n+    procedure P\n+  end type BaseT\n+\n+contains\n+\n+  subroutine indir(this, mat)\n+    class(BaseT) :: this\n+    class(InnerT), intent(inout) :: mat(:,:)\n+\n+    call this%P(mat)\n+  end subroutine indir\n+\n+  subroutine P(this, mat)\n+    class(BaseT) :: this\n+    class(InnerT), intent(inout) :: mat(:,:)\n+    integer :: i,j\n+\n+    mat%i = 42\n+    do i= 1, ubound(mat, 1)\n+      do j= 1, ubound(mat, 2)\n+        if (.not. allocated(mat(i,j)%a)) then\n+          allocate(mat(i,j)%a(10), source = 72)\n+        end if\n+      end do\n+    end do\n+    mat(1,1)%i = 9\n+    mat(1,1)%a(5) = 1\n+  end subroutine\n+\n+end module m1\n+\n+program test\n+  use m1\n+\n+  class(BaseT), allocatable, target :: o\n+  class(InnerT), pointer :: i_p(:,:)\n+  class(InnerBaseT), allocatable :: i_a(:,:)\n+  integer i,j,l\n+\n+  allocate(o)\n+  allocate(o%arr(2,2))\n+  allocate(InnerT::i_a(2,2))\n+  o%arr%i = 1\n+\n+  i_p => o%arr\n+  call o%P(i_p)\n+  if (any(o%arr%i /= reshape([9,42,42,42],[2,2]))) call abort()\n+  do l= 1, 10\n+    do i= 1, 2\n+      do j= 1,2\n+        if ((i == 1 .and. j == 1 .and. l == 5 .and. &\n+             o%arr(i,j)%a(5) /= 1) &\n+            .or. (.not. (i == 1 .and. j == 1 .and. l == 5) &\n+              .and. o%arr(i,j)%a(l) /= 72)) call abort()\n+      end do\n+    end do\n+  end do\n+\n+  select type (i_a)\n+    type is (InnerT)\n+      call o%P(i_a)\n+      do l= 1, 10\n+        do i= 1, 2\n+          do j= 1,2\n+            if ((i == 1 .and. j == 1 .and. l == 5 .and. &\n+                 i_a(i,j)%a(5) /= 1) &\n+                .or. (.not. (i == 1 .and. j == 1 .and. l == 5) &\n+                  .and. i_a(i,j)%a(l) /= 72)) call abort()\n+          end do\n+        end do\n+      end do\n+  end select\n+\n+  i_p%i = 4\n+  call indir(o, i_p)\n+  if (any(o%arr%i /= reshape([9,42,42,42],[2,2]))) call abort()\n+end program test\n+\n+! vim:ts=2:sts=2:cindent:sw=2:tw=80:"}, {"sha": "1f5f742403bfa152391165136e022d6fc9a7dfb2", "filename": "gcc/testsuite/gfortran.dg/finalize_29.f08", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_29.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5302f06b81185a1c785263358f204fc0f5bdba2/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_29.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_29.f08?ref=d5302f06b81185a1c785263358f204fc0f5bdba2", "patch": "@@ -0,0 +1,289 @@\n+! {dg-do run}\n+!\n+! Testcase contributed by Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+module module_finalize_29\n+  implicit none\n+\n+  ! The type name is encoding the state of its finalizer being\n+  ! elemental (second letter 'e'), or non-element (second letter 'n')\n+  ! or array shaped (second letter 'a'), or shape-specific routine\n+  ! (generic; second letter 'g'),\n+  ! and whether the init-routine is elemental or not (third letter\n+  ! either 'e' or 'n').\n+  type ten\n+    integer :: i = 40\n+  contains\n+    final :: ten_fin\n+  end type ten\n+\n+  type tee\n+    integer :: i = 41\n+  contains\n+    final :: tee_fin\n+  end type tee\n+\n+  type tne\n+    integer :: i = 42\n+  contains\n+    final :: tne_fin\n+  end type tne\n+\n+  type tnn\n+    integer :: i = 43\n+  contains\n+    final :: tnn_fin\n+  end type tnn\n+\n+  type tae\n+    integer :: i = 44\n+  contains\n+    final :: tae_fin\n+  end type tae\n+\n+  type tan\n+    integer :: i = 45\n+  contains\n+    final :: tan_fin\n+  end type tan\n+\n+  type tge\n+    integer :: i = 46\n+  contains\n+    final :: tge_scalar_fin, tge_array_fin\n+  end type tge\n+\n+  type tgn\n+    integer :: i = 47\n+  contains\n+    final :: tgn_scalar_fin, tgn_array_fin\n+  end type tgn\n+\n+  integer :: ten_fin_counts, tee_fin_counts, tne_fin_counts, tnn_fin_counts\n+  integer :: tae_fin_counts, tan_fin_counts\n+  integer :: tge_scalar_fin_counts, tge_array_fin_counts\n+  integer :: tgn_scalar_fin_counts, tgn_array_fin_counts\n+contains\n+  impure elemental subroutine ten_fin(x)\n+    type(ten), intent(inout) :: x\n+    x%i = -10 * x%i\n+    ten_fin_counts = ten_fin_counts + 1\n+  end subroutine ten_fin\n+\n+  impure elemental subroutine tee_fin(x)\n+    type(tee), intent(inout) :: x\n+    x%i = -11 * x%i\n+    tee_fin_counts = tee_fin_counts + 1\n+  end subroutine tee_fin\n+\n+  subroutine tne_fin(x)\n+    type(tne), intent(inout) :: x\n+    x%i = -12 * x%i\n+    tne_fin_counts = tne_fin_counts + 1\n+  end subroutine tne_fin\n+\n+  subroutine tnn_fin(x)\n+    type(tnn), intent(inout) :: x\n+    x%i = -13 * x%i\n+    tnn_fin_counts = tnn_fin_counts + 1\n+  end subroutine tnn_fin\n+\n+  subroutine tae_fin(x)\n+    type(tae), intent(inout) :: x(:,:)\n+    x%i = -14 * x%i\n+    tae_fin_counts = tae_fin_counts + 1\n+  end subroutine tae_fin\n+\n+  subroutine tan_fin(x)\n+    type(tan), intent(inout) :: x(:,:)\n+    x%i = -15 * x%i\n+    tan_fin_counts = tan_fin_counts + 1\n+  end subroutine tan_fin\n+\n+  subroutine tge_scalar_fin(x)\n+    type(tge), intent(inout) :: x\n+    x%i = -16 * x%i\n+    tge_scalar_fin_counts = tge_scalar_fin_counts + 1\n+  end subroutine tge_scalar_fin\n+\n+  subroutine tge_array_fin(x)\n+    type(tge), intent(inout) :: x(:,:)\n+    x%i = -17 * x%i\n+    tge_array_fin_counts = tge_array_fin_counts + 1\n+  end subroutine tge_array_fin\n+\n+  subroutine tgn_scalar_fin(x)\n+    type(tgn), intent(inout) :: x\n+    x%i = -18 * x%i\n+    tgn_scalar_fin_counts = tgn_scalar_fin_counts + 1\n+  end subroutine tgn_scalar_fin\n+\n+  subroutine tgn_array_fin(x)\n+    type(tgn), intent(inout) :: x(:,:)\n+    x%i = -19 * x%i\n+    tgn_array_fin_counts = tgn_array_fin_counts + 1\n+  end subroutine tgn_array_fin\n+\n+  ! The finalizer/initializer call producer\n+  subroutine ten_init(x)\n+    class(ten), intent(out) :: x(:,:)\n+  end subroutine ten_init\n+\n+  impure elemental subroutine tee_init(x)\n+    class(tee), intent(out) :: x\n+  end subroutine tee_init\n+\n+  impure elemental subroutine tne_init(x)\n+    class(tne), intent(out) :: x\n+  end subroutine tne_init\n+\n+  subroutine tnn_init(x)\n+    class(tnn), intent(out) :: x(:,:)\n+  end subroutine tnn_init\n+\n+  impure elemental subroutine tae_init(x)\n+    class(tae), intent(out) :: x\n+  end subroutine tae_init\n+\n+  subroutine tan_init(x)\n+    class(tan), intent(out) :: x(:,:)\n+  end subroutine tan_init\n+\n+  impure elemental subroutine tge_init(x)\n+    class(tge), intent(out) :: x\n+  end subroutine tge_init\n+\n+  subroutine tgn_init(x)\n+    class(tgn), intent(out) :: x(:,:)\n+  end subroutine tgn_init\n+end module module_finalize_29\n+\n+program finalize_29\n+  use module_finalize_29\n+  implicit none\n+\n+  type(ten), allocatable :: x_ten(:,:)\n+  type(tee), allocatable :: x_tee(:,:)\n+  type(tne), allocatable :: x_tne(:,:)\n+  type(tnn), allocatable :: x_tnn(:,:)\n+  type(tae), allocatable :: x_tae(:,:)\n+  type(tan), allocatable :: x_tan(:,:)\n+  type(tge), allocatable :: x_tge(:,:)\n+  type(tgn), allocatable :: x_tgn(:,:)\n+\n+  ! Set the global counts to zero.\n+  ten_fin_counts = 0\n+  tee_fin_counts = 0\n+  tne_fin_counts = 0\n+  tnn_fin_counts = 0\n+  tae_fin_counts = 0\n+  tan_fin_counts = 0\n+  tge_scalar_fin_counts = 0\n+  tge_array_fin_counts = 0\n+  tgn_scalar_fin_counts = 0\n+  tgn_array_fin_counts = 0\n+\n+  allocate(ten :: x_ten(5,5))\n+  allocate(tee :: x_tee(5,5))\n+  allocate(tne :: x_tne(5,5))\n+  allocate(tnn :: x_tnn(5,5))\n+  allocate(tae :: x_tae(5,5))\n+  allocate(tan :: x_tan(5,5))\n+  allocate(tge :: x_tge(5,5))\n+  allocate(tgn :: x_tgn(5,5))\n+\n+  x_ten%i = 1\n+  x_tee%i = 2\n+  x_tne%i = 3\n+  x_tnn%i = 4\n+  x_tae%i = 5\n+  x_tan%i = 6\n+  x_tge%i = 7\n+  x_tgn%i = 8\n+\n+  call ten_init(x_ten(::2, ::3))\n+\n+  if (ten_fin_counts /= 6) call abort()\n+  if (tee_fin_counts + tne_fin_counts + tnn_fin_counts + tae_fin_counts + &\n+        tan_fin_counts + tge_scalar_fin_counts + tge_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+  ten_fin_counts = 0\n+\n+  call tee_init(x_tee(::2, ::3))\n+\n+  if (tee_fin_counts /= 6) call abort()\n+  if (ten_fin_counts + tne_fin_counts + tnn_fin_counts + tae_fin_counts + &\n+        tan_fin_counts + tge_scalar_fin_counts + tge_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+  tee_fin_counts = 0\n+\n+  call tne_init(x_tne(::2, ::3))\n+\n+  if (tne_fin_counts /= 6) call abort()\n+  if (ten_fin_counts + tee_fin_counts + tnn_fin_counts + tae_fin_counts + &\n+        tan_fin_counts + tge_scalar_fin_counts + tge_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+  tne_fin_counts = 0\n+\n+  call tnn_init(x_tnn(::2, ::3))\n+\n+  if (tnn_fin_counts /= 0) call abort()\n+  if (ten_fin_counts + tee_fin_counts + tne_fin_counts + tae_fin_counts + &\n+        tan_fin_counts + tge_scalar_fin_counts + tge_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+\n+  call tae_init(x_tae(::2, ::3))\n+\n+  if (tae_fin_counts /= 0) call abort()\n+  if (ten_fin_counts + tee_fin_counts + tne_fin_counts + tnn_fin_counts + &\n+        tan_fin_counts + tge_scalar_fin_counts + tge_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+\n+  call tan_init(x_tan(::2, ::3))\n+\n+  if (tan_fin_counts /= 1) call abort()\n+  if (ten_fin_counts + tee_fin_counts + tne_fin_counts + tnn_fin_counts + &\n+        tae_fin_counts + tge_scalar_fin_counts + tge_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+  tan_fin_counts = 0\n+\n+  call tge_init(x_tge(::2, ::3))\n+\n+  if (tge_scalar_fin_counts /= 6) call abort()\n+  if (ten_fin_counts + tee_fin_counts + tne_fin_counts + tnn_fin_counts + &\n+        tae_fin_counts + tan_fin_counts + tgn_array_fin_counts + &\n+        tgn_scalar_fin_counts + tgn_array_fin_counts /= 0) call abort()\n+  tge_scalar_fin_counts = 0\n+\n+  call tgn_init(x_tgn(::2, ::3))\n+\n+  if (tgn_array_fin_counts /= 1) call abort()\n+  if (ten_fin_counts + tee_fin_counts + tne_fin_counts + tnn_fin_counts + &\n+        tae_fin_counts + tan_fin_counts + tge_scalar_fin_counts + &\n+        tge_array_fin_counts + tgn_scalar_fin_counts /= 0) call abort()\n+  tgn_array_fin_counts = 0\n+\n+  if (any (reshape (x_ten%i, [25]) /= [[40, 1, 40, 1, 40], [1, 1, 1, 1, 1],&\n+        [1, 1, 1, 1, 1], [40, 1, 40, 1, 40], [1, 1, 1, 1, 1]])) call abort()\n+\n+  if (any (reshape (x_tee%i, [25]) /= [[41, 2, 41, 2, 41], [2, 2, 2, 2, 2],&\n+        [2, 2, 2, 2, 2], [41, 2, 41, 2, 41], [2, 2, 2, 2, 2]])) call abort()\n+\n+  if (any (reshape (x_tne%i, [25]) /= [[42, 3, 42, 3, 42], [3, 3, 3, 3, 3],&\n+        [3, 3, 3, 3, 3], [42, 3, 42, 3, 42], [3, 3, 3, 3, 3]])) call abort()\n+\n+  if (any (reshape (x_tnn%i, [25]) /= [[43, 4, 43, 4, 43], [4, 4, 4, 4, 4],&\n+        [4, 4, 4, 4, 4], [43, 4, 43, 4, 43], [4, 4, 4, 4, 4]])) call abort()\n+\n+  if (any (reshape (x_tae%i, [25]) /= [[44, 5, 44, 5, 44], [5, 5, 5, 5, 5],&\n+        [5, 5, 5, 5, 5], [44, 5, 44, 5, 44], [5, 5, 5, 5, 5]])) call abort()\n+\n+  if (any (reshape (x_tan%i, [25]) /= [[45, 6, 45, 6, 45], [6, 6, 6, 6, 6],&\n+        [6, 6, 6, 6, 6], [45, 6, 45, 6, 45], [6, 6, 6, 6, 6]])) call abort()\n+\n+  if (any (reshape (x_tge%i, [25]) /= [[46, 7, 46, 7, 46], [7, 7, 7, 7, 7],&\n+        [7, 7, 7, 7, 7], [46, 7, 46, 7, 46], [7, 7, 7, 7, 7]])) call abort()\n+\n+  if (any (reshape (x_tgn%i, [25]) /= [[47, 8, 47, 8, 47], [8, 8, 8, 8, 8],&\n+        [8, 8, 8, 8, 8], [47, 8, 47, 8, 47], [8, 8, 8, 8, 8]])) call abort()\n+end program finalize_29"}]}